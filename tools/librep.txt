I tried to implement librep as Snd's extension language, but finally
gave up.  I believe librep was never intended to be an embedded language.
Here are the relevant diffs for it, at the point where I stopped.  


--------------------------------------------------------------------------------
xen.h:


/* ------------------------------ Librep ------------------------------ */
/* (remember ratios) */

#if HAVE_LIBREP
#define XEN_OK 1

#include <rep.h>

#define XEN                                  repv
#define XEN_FILE_EXTENSION                   "cl"
#define XEN_LANGUAGE_NAME                    "Librep"
#define XEN_COMMENT_STRING                   ";"
#define XEN_FALSE                            Qnil
#define XEN_TRUE                             Qt
#define XEN_TRUE_P(a)                        ((a) == XEN_TRUE)
#define XEN_FALSE_P(a)                       ((a) == XEN_FALSE)
#define XEN_BOOLEAN_P(a)                     (((a) == XEN_TRUE) || ((a) == XEN_FALSE))
#define C_TO_XEN_BOOLEAN(a)                  ((a) ? XEN_TRUE : XEN_FALSE)
#define XEN_TO_C_BOOLEAN(a)                  (((a) == XEN_FALSE) ? false : true)
#define XEN_NULL_P(a)                        rep_NILP(a)
#define XEN_BOUND_P(Arg)                     Fboundp(Arg)
#define XEN_NOT_BOUND_P(Arg)                 (!XEN_BOUND_P(Arg))
#define XEN_EMPTY_LIST                       Qnil
#define XEN_UNDEFINED                        rep_undefined_value
#define XEN_EQ_P(a, b)                       (!XEN_FALSE_P(Feq(a, b)))
#define XEN_EQV_P(a, b)                      (!XEN_FALSE_P(Feql(a, b)))
#define XEN_EQUAL_P(a, b)                    (!XEN_FALSE_P(Fequal(a, b)))
#define XEN_CONS_P(Arg)                      rep_CONSP(Arg)
#define XEN_CONS(Arg1, Arg2)                 Fcons(Arg1, Arg2)
#define XEN_CONS_2(Arg1, Arg2, Arg3)         Fcons(Arg1, Fcons(Arg2, Arg3))
#define XEN_PAIR_P(Arg)                      XEN_CONS_P(Arg)
#define XEN_CAR(a)                           rep_CAR(a)
#define XEN_CADR(a)                          rep_CADR(a)
#define XEN_CADDR(a)                         rep_CADDR(a)
#define XEN_CADDDR(a)                        rep_CADDDR(a)
#define XEN_CDR(a)                           rep_CDR(a)
#define XEN_CDDR(a)                          rep_CDDR(a)
#define XEN_LIST_P(Arg)                      rep_LISTP(Arg)
#define XEN_LIST_P_WITH_LENGTH(Arg, Len)     ((XEN_LIST_P(Arg)) && ((Len = XEN_LIST_LENGTH(Arg)) >= 0))
#define XEN_LIST_LENGTH(Arg)                 rep_INT(Flength(Arg))
#define XEN_LIST_1(a)                        rep_LIST_1(a)
#define XEN_LIST_2(a, b)                     rep_LIST_2(a, b)
#define XEN_LIST_3(a, b, c)                  rep_LIST_3(a, b, c)
#define XEN_LIST_4(a, b, c, d)               rep_LIST_4(a, b, c, d)
#define XEN_LIST_5(a, b, c, d, e)            rep_LIST_5(a, b, c, d, e)
#define XEN_LIST_6(a, b, c, d, e, f)         Fcons(a, rep_LIST_5(b, c, d, e, f))
#define XEN_LIST_7(a, b, c, d, e, f, g)      Fcons(a, Fcons(b, rep_LIST_5(c, d, e, f, g)))
#define XEN_LIST_8(a, b, c, d, e, f, g, h)   Fcons(a, Fcons(b, Fcons(c, rep_LIST_5(d, e, f, g, h))))
#define XEN_LIST_9(a, b, c, d, e, f, g, h, i)  Fcons(a, Fcons(b, Fcons(c, Fcons(d, rep_LIST_f(e, f, g, h, i)))))
#define XEN_LIST_REF(Lst, Num)               Fnth(Num, Lst)
#define XEN_LIST_SET(Lst, Num, Val)          "oops"
#define XEN_LIST_REVERSE(Lst)                Freverse(Lst)
#define XEN_COPY_ARG(Lst)                    Lst
#define XEN_APPEND(X, Y)                     xen_rep_append(X, Y)
#define XEN_STRING_P(Arg)                    rep_STRINGP(Arg)
#define XEN_NAME_AS_C_STRING_TO_VALUE(a)     "oops"
#define XEN_TO_C_STRING(STR)                 ((char *)(rep_STR(STR)))
#define C_TO_XEN_STRING(a)                   rep_string_dupn(a, strlen(a))
#define C_TO_XEN_STRINGN(Str, Len)           rep_string_dupn(Str, Len)
#define C_STRING_TO_XEN_SYMBOL(a)            Fintern_symbol(Fmake_symbol(rep_string_dupn(a, strlen(a))), Qnil)
#define XEN_ZERO                             rep_MAKE_INT(0)
#define XEN_NUMBER_P(Arg)                    rep_NUMERICP(Arg)
#define XEN_OFF_T_P(Arg)                     rep_INTEGERP(Arg)
#define XEN_DOUBLE_P(Arg)                    rep_NUMBER_FLOAT_P(Arg)
#define XEN_TO_C_DOUBLE(a)                   rep_get_float(a)
#define XEN_TO_C_DOUBLE_OR_ELSE(a, b)        (XEN_NUMBER_P(a) ? rep_get_float(a) : b)
#define C_TO_XEN_DOUBLE(a)                   rep_make_float(a, rep_FALSE)
#define XEN_INTEGER_P(Arg)                   rep_INTEGERP(Arg)
#define C_TO_XEN_INT(a)                      rep_MAKE_INT(a)
#define XEN_TO_C_INT(a)                      rep_INT(a)
#define XEN_TO_C_INT_OR_ELSE(a, b)           (XEN_INTEGER_P(a) ? rep_INT(a) : b)
#define XEN_ULONG_P(Arg)                     XEN_INTEGER_P(Arg)
#define XEN_TO_C_ULONG(a)                    rep_get_long_uint(a)
#define C_TO_XEN_ULONG(a)                    rep_make_long_uint((unsigned long)a)
#define C_TO_XEN_LONG_LONG(a)                "oops"
#define XEN_TO_C_LONG_LONG(a)                "oops"
#define XEN_EXACT_P(Arg)                     (!XEN_FALSE_P(Fexact(Arg)))
#define C_STRING_TO_XEN_FORM(Str)            "oops"
#define XEN_EVAL_FORM(Form)                  "oops"
#define XEN_EVAL_C_STRING(Arg)               xen_librep_eval_c_string(Arg, false)
#define XEN_EVAL_C_STRING_AND_FREE(Arg)      xen_librep_eval_c_string(Arg, true)
#define XEN_SYMBOL_TO_C_STRING(a)            rep_STR(rep_SYM(a)->name)
#define XEN_TO_STRING(Obj)                   "oops"
#define XEN_WRAP_C_POINTER(a)                rep_make_long_uint((unsigned long)a)
#define XEN_UNWRAP_C_POINTER(a)              rep_get_long_uint(a)
#define XEN_WRAPPED_C_POINTER_P(a)           a
#define XEN_PROCEDURE_P(Arg)                 ((Ffunctionp(Arg)) || (Fsubrp(Arg)) || (Fclosurep(Arg)))
#define XEN_PROCEDURE_SOURCE(Func)           "oops"

#define XEN_DEFINE_PROCEDURE(Name, Func, ReqArg, OptArg, RstArg, Doc) \
  librep_new_procedure(Name, Func, ReqArg, OptArg, RstArg, Doc)

#define XEN_DEFINE_PROCEDURE_WITH_SETTER(Get_Name, Get_Func, Get_Help, Set_Name, Set_Func, Get_Req, Get_Opt, Set_Req, Set_Opt) \

#define XEN_DEFINE_PROCEDURE_WITH_REVERSED_SETTER(Get_Name, Get_Func, Get_Help, Set_Name, Set_Func, Rev_Func, Get_Req, Get_Opt, Set_Req, Set_Opt) 

#define XEN_ARITY(Func) 0
#define XEN_REQUIRED_ARGS(Func) 0
#define XEN_REQUIRED_ARGS_OK(Func, Args) false
#define XEN_CALL_0(Func, Caller)               rep_call_lisp0(Func)
#define XEN_CALL_1(Func, Arg1, Caller)         rep_call_lisp1(Func, Arg1)
#define XEN_CALL_2(Func, Arg1, Arg2, Caller)   rep_call_lisp2(Func, Arg1, Arg2)
#define XEN_CALL_3(Func, Arg1, Arg2, Arg3, Caller) rep_call_lisp3(Func, Arg1, Arg2, Arg3)
#define XEN_CALL_4(Func, Arg1, Arg2, Arg3, Arg4, Caller) rep_call_lisp4(Func, Arg1, Arg2, Arg3, Arg4)
#define XEN_CALL_5(Func, Arg1, Arg2, Arg3, Arg4, Arg5, Caller) [use lispn] rep_call_lisp5(Func, Arg1, Arg2, Arg3, Arg4, Arg5)
#define XEN_CALL_6(Func, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Caller) XEN_ZERO
#define XEN_APPLY(Func, Args, Caller)                     rep_apply(Func, Args)
#define XEN_APPLY_ARG_LIST_END                             Qnil
#define XEN_CALL_0_NO_CATCH(Func)                          rep_call_lisp0(Func)
#define XEN_CALL_1_NO_CATCH(Func, Arg1)                    rep_call_lisp1(Func, Arg1)
#define XEN_CALL_2_NO_CATCH(Func, Arg1, Arg2)              rep_call_lisp2(Func, Arg1, Arg2)
#define XEN_CALL_3_NO_CATCH(Func, Arg1, Arg2, Arg3)        rep_call_lisp3(Func, Arg1, Arg2, Arg3)
#define XEN_APPLY_NO_CATCH(Func, Args)            rep_apply(Func, Args)

#define XEN_DEFINE_CONSTANT(Name, Value, Help) XEN_EVAL_C_STRING_AND_FREE(mus_format("(defvar %s %d)", Name, Value))
#define XEN_DEFINE_VARIABLE(Name, Var, Value) Var = XEN_EVAL_C_STRING_AND_FREE(mus_format("(defvar %s %d)", Name, Value))
#define XEN_DEFINE(Name, Value) XEN_DEFINE_CONSTANT(Name, Value, 0)
/* Value can be anything here */

#define XEN_VARIABLE_SET(a, b)                   Fset(a, b)
#define XEN_VARIABLE_REF(a) 0
#define XEN_MARK_OBJECT_TYPE                      XEN
#define XEN_MAKE_OBJECT_TYPE(Typ, Siz) 0
#define XEN_MAKE_OBJECT_PRINT_PROCEDURE(Type, Wrapped_Print, Original_Print) 
#define XEN_MAKE_OBJECT_FREE_PROCEDURE(Type, Wrapped_Free, Original_Free)
#define XEN_MAKE_AND_RETURN_OBJECT(Tag, Val, ig1, ig2) return(0)
#define XEN_OBJECT_REF(a) 0
#define XEN_OBJECT_TYPE int
#define XEN_OBJECT_TYPE_P(OBJ, TAG) 0
#define XEN_SYMBOL_P(Arg)                         rep_SYMBOLP(Arg)
#define XEN_HOOK_P(Arg) 0
#define XEN_HOOKED(a) 0
#define XEN_DEFINE_HOOK(Name, Arity, Help) 0
#define XEN_DEFINE_SIMPLE_HOOK(Arity) 0
#define XEN_CLEAR_HOOK(Arg)
#define XEN_HOOK_PROCEDURES(a) 0
#define XEN_VECTOR_P(Arg)                         rep_VECTORP(Arg)
#define XEN_VECTOR_LENGTH(Arg)                    rep_VECT_LEN(Arg)
#define XEN_VECTOR_REF(Vect, Num)                 Faref(Vect, Num)
#define XEN_VECTOR_SET(Vect, Num, Val)            Faset(Vect, Num, Val)
#define XEN_MAKE_VECTOR(Num, Fill)                rep_make_vector(Num)
#define XEN_VECTOR_TO_LIST(Vect)                  "oops"
#define XEN_CHAR_P(Arg)                           XEN_STRING_P(Arg)
#define XEN_TO_C_CHAR(Arg)                        XEN_TO_C_STRING(Arg)[0]
#define C_TO_XEN_CHAR(Arg)                        C_TO_XEN_STRING(Arg)
#define XEN_KEYWORD_P(Obj)                         rep_KEYWORDP(Obj)
#define XEN_KEYWORD_EQ_P(k1, k2)                   XEN_EQUAL_P(k1, k2)
#define XEN_MAKE_KEYWORD(Arg)                      Fmake_keyword(C_STRING_TO_XEN_SYMBOL(Arg))
#define XEN_YES_WE_HAVE(Feature)                   Fprovide(C_STRING_TO_XEN_SYMBOL(Feature))
#define XEN_DOCUMENTATION_SYMBOL 0
#define XEN_OBJECT_HELP(Name) 0
#define XEN_PROTECT_FROM_GC(a) 0
#define XEN_LOAD_FILE(a)                         Fload(C_TO_XEN_STRING(a), Qnil, Qnil, Qnil, Qnil)
#define XEN_LOAD_FILE_WITH_PATH(a)               "oops"
#define XEN_LOAD_PATH                            "oops"
#define XEN_ADD_TO_LOAD_PATH(Path)               "oops"
#define XEN_ERROR_TYPE(Typ)                      XEN_FALSE
#define XEN_ERROR(Type, Info)                    Fthrow(Type, Info)
#define XEN_THROW(Type, Info)                    Fthrow(Type, Info)

#define XEN_ASSERT_TYPE(Assertion, Arg, Position, Caller, Correct_Type) \
  rep_DECLARE(Position, Arg, Assertion)

#define XEN_WRONG_TYPE_ARG_ERROR(Caller, ArgN, Arg, Descr)
#define XEN_OUT_OF_RANGE_ERROR(Caller, ArgN, Arg, Descr)
typedef XEN (*XEN_CATCH_BODY_TYPE) (void *data);

XEN xen_librep_eval_c_string(char *data, bool free_str);
XEN xen_rep_append(XEN x, XEN y);
void librep_new_procedure(const char *name, XEN (*func)(), int reqargs, int optargs, int rstargs, const char *doc);
void librep_new_variable(const char *name, int val, const char *doc);

#endif
/* end Librep */

--------------------------------------------------------------------------------

/* librep rep.h includes rep_config.h but make install doesn't copy the latter to /usr/local/include
 */

--------------------------------------------------------------------------------

xen.c


/* ------------------------------ LIBREP ------------------------------ */

#if HAVE_LIBREP

#define FREE(a) free(a)

XEN xen_librep_eval_c_string(char *data, bool free_str)
{
  int c;
  repv stream;
  stream = Fmake_string_input_stream(C_TO_XEN_STRING(data), C_TO_XEN_INT(0));
  if (free_str) FREE(data);
  c = rep_stream_getc(stream);
  return(rep_eval(rep_readl(stream, &c), Qnil));
}

DEFSTRING(rep, "rep/user");

void xen_initialize(void)
{
  int argc = 0;
  char *argv[2];
  argv[0] = "Xen";
  argv[1] = "";
  rep_init("Xen", &argc, (char ***)&argv, NULL, NULL);
}


char *xen_version(void)
{
  return(rep_VERSION);
}


void xen_repl(int argc, char **argv)
{
  rep_call_with_barrier(rep_load_environment, rep_VAL(&rep),
			rep_TRUE, 0, 0, 0);
}


void xen_gc_mark(XEN val) {}

int xen_to_c_int_or_else(XEN obj, int fallback) {return(0);}

off_t xen_to_c_off_t_or_else(XEN obj, off_t fallback) {return(0);}

off_t xen_to_c_off_t(XEN obj) {return(0);}

XEN c_to_xen_off_t(off_t val) {return(0);}

XEN xen_rep_append(XEN x, XEN y)
{
  repv v[2];
  v[0] = x;
  v[1] = y;
  return(Fappend(2, v));
}

static rep_xsubr **obarr = NULL;
static rep_string **obstr = NULL;
static int obarr_size = 0;
static int obarr_ctr = 0;

void librep_new_procedure(const char *name, XEN (*func)(), int reqargs, int optargs, int rstargs, const char *doc)
{
  rep_xsubr *ob;
  rep_string *str;
  if (obarr_ctr == obarr_size)
    {
      if (obarr == NULL)
	{
	  obarr = (rep_xsubr **)calloc(1024, sizeof(rep_xsubr *));
	  obstr = (rep_string **)calloc(1024, sizeof(rep_string *));
	}
      else 
	{
	  obarr = (rep_xsubr **)realloc(obarr, (obarr_size + 1024) * sizeof(rep_xsubr *));
	  obstr = (rep_string **)realloc(obstr, (obarr_size + 1024) * sizeof(rep_string *));
	}
      obarr_size += 1024;
    }
  obarr[obarr_ctr] = (rep_xsubr *)calloc(1, sizeof(rep_xsubr));
  obstr[obarr_ctr] = (rep_string *)calloc(1, sizeof(rep_string));
  str = obstr[obarr_ctr];
  str->car = (strlen(name) << rep_STRING_LEN_SHIFT) | rep_CELL_STATIC_BIT | rep_String;
  str->data = (u_char *)name;
  ob = obarr[obarr_ctr++];
  switch (reqargs + optargs)
    {
    case 0: ob->car = rep_Subr0; break;
    case 1: ob->car = rep_Subr1; break;
    case 2: ob->car = rep_Subr2; break;
    case 3: ob->car = rep_Subr3; break;
    case 4: ob->car = rep_Subr4; break;
    case 5: ob->car = rep_Subr5; break;
    default: ob->car = rep_SubrN; break;
    }
  ob->fun = func;
  ob->int_spec = rep_NULL;
  ob->name = rep_VAL(str);
  rep_add_subr(ob, rep_TRUE);
}

static repv **obvars = NULL;
static rep_string **obvarstrs = NULL;
static int obvars_size = 0;
static int obvars_ctr = 0;

void librep_new_variable(const char *name, int val, const char *doc)
{
  repv *q;
  rep_string *qs;
  if (obvars_size == obvars_ctr)
    {
      if (obvars == NULL)
	{
	  obvars = (repv **)calloc(1024, sizeof(repv *));
	  obvarstrs = (rep_string **)calloc(1024, sizeof(rep_string *));
	}
      else 
	{
	  obvars = (repv **)realloc(obvars, (obvars_size + 1024) * sizeof(repv *));
	  obvarstrs = (rep_string **)realloc(obvarstrs, (obvars_size + 1024) * sizeof(rep_string *));
	}
      obvars_size += 1024;
    }
  obvars[obvars_ctr] = (repv *)calloc(1, sizeof(repv));
  obvarstrs[obvars_ctr] = (rep_string *)calloc(1, sizeof(rep_string));
  qs = obvarstrs[obvars_ctr];
  q = obvars[obvars_ctr++];
  qs->car = (strlen(name) << rep_STRING_LEN_SHIFT) | rep_CELL_STATIC_BIT | rep_String;
  qs->data = (u_char *)name;
  rep_intern_static(q, rep_VAL(qs));
  Fmake_variable_special(*q);
  rep_SYM(q)->car |= rep_SF_DEFVAR;
  Fset((*q), C_TO_XEN_INT(val));
}

#endif

--------------------------------------------------------------------------------

configure.ac

#   --with-librep         try to use Librep as the extension language
#   --with-librep-prefix  set location of Librep

AC_ARG_WITH(librep,      [  --with-librep  	  use Librep])
AC_ARG_WITH(librep-prefix,[  --with-librep-prefix=PFX where Librep is installed],
            librep_prefix="$withval", librep_prefix="")
#--------------------------------------------------------------------------------
# Librep
#--------------------------------------------------------------------------------

if test "$with_librep" = yes && test "$ac_snd_have_extension_language" = yes ; then
  with_librep=no
  AC_MSG_WARN([You asked for both Librep and $LOCAL_LANGUAGE -- $LOCAL_LANGUAGE will be used])
fi

if test "$with_librep" = yes ; then
  AC_MSG_CHECKING([for Librep])
  AC_DEFINE(HAVE_LIBREP)	
  AC_DEFINE(HAVE_CL)	
  ac_snd_have_extension_language=yes
  AC_DEFINE(HAVE_EXTENSION_LANGUAGE)
  XEN_LIBS="-lrep"
  LOCAL_LANGUAGE="Librep"
  AC_MSG_RESULT([yes])  
fi



--------------------------------------------------------------------------------
mus-config.h.in

#undef HAVE_LIBREP

--------------------------------------------------------------------------------

snd-main.c

#if HAVE_LIBREP
  #define SND_PREFS "~/.snd_prefs_rep"
#endif

--------------------------------------------------------------------------------
snd-xen.c

#if HAVE_LIBREP
  #define SND_EXT_CONF "/etc/snd_rep.conf"
  #define SND_PREFS "~/.snd_prefs_rep"
  #define SND_INIT "~/.snd_rep"
#endif

#if HAVE_LIBREP
  XEN_YES_WE_HAVE("snd-librep");
#endif

--------------------------------------------------------------------------------

