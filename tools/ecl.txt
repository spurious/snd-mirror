I tried to add ECL support to Snd, but gave up because there's apparently
no way to make my functions work both in the interpreter and the compiler.
I think I could hack a version of make_this_symbol (all_symbols.c), but ...
What do the ECL authors think they are providing?  I need a way to add
a symbol in lisp that refers to a C function that I provide, so that
a lisp expression that treats that name as a function calls the associated
C function -- why is this so arcane? 

Here is where I stopped:

--------------------------------------------------------------------------------
xen.h


/* ------------------------------ ECL ------------------------------ */

/* we can't include the ecl headers directly because they stomp all over our names,
 *   so everything comes from xen.c
 */

#if HAVE_ECL
#define XEN_OK 1

typedef void* XEN; /* cl_object */

#define XEN_FILE_EXTENSION                     "cl"
#define XEN_LANGUAGE_NAME                      "ECL"
#define XEN_COMMENT_STRING                     ";"
#define XEN_FALSE                              xen_ecl_false()
#define XEN_TRUE                               xen_ecl_true()
#define XEN_TRUE_P(a)                          xen_ecl_true_p(a)
#define XEN_FALSE_P(a)                         xen_ecl_false_p(a)
#define XEN_BOOLEAN_P(a)                       xen_ecl_boolean_p(a)
#define C_TO_XEN_BOOLEAN(a)                    xen_ecl_c_to_xen_boolean(a)
#define XEN_TO_C_BOOLEAN(a)                    xen_ecl_xen_to_c_boolean(a)
#define XEN_NULL_P(a)                          xen_ecl_null_p(a)
#define XEN_BOUND_P(Arg)                       (Arg != xen_ecl_unbound())
#define XEN_NOT_BOUND_P(Arg)                   (Arg == xen_ecl_unbound())
#define XEN_EMPTY_LIST                         xen_ecl_empty_list()
#define XEN_UNDEFINED                          xen_ecl_unbound()
#define XEN_EQ_P(a, b)                         xen_ecl_eq_p(a, b)
#define XEN_EQV_P(a, b)                        xen_ecl_eqv_p(a, b)
#define XEN_EQUAL_P(a, b)                      xen_ecl_equal_p(a, b)
#define XEN_CONS_P(Arg)                        xen_ecl_cons_p(Arg)
#define XEN_CONS(Arg1, Arg2)                   xen_ecl_cons(Arg1, Arg2)
#define XEN_CONS_2(Arg1, Arg2, Arg3)           xen_ecl_cons2(Arg1, Arg2, Arg3)
#define XEN_PAIR_P(Arg)                        xen_ecl_cons_p(Arg)
#define XEN_CAR(a)                             xen_ecl_car(a)
#define XEN_CADR(a)                            xen_ecl_cadr(a)
#define XEN_CADDR(a)                           xen_ecl_caddr(a)
#define XEN_CADDDR(a)                          xen_ecl_cadddr(a)
#define XEN_CDR(a)                             xen_ecl_cdr(a)
#define XEN_CDDR(a)                            xen_ecl_cddr(a)
#define XEN_LIST_P(Arg)                        xen_ecl_list_p(Arg)
#define XEN_LIST_P_WITH_LENGTH(Arg, Len)       ((XEN_LIST_P(Arg)) && (Len = xen_ecl_list_length(Arg)))
#define XEN_LIST_LENGTH(Arg)                   xen_ecl_list_length(Arg)
#define XEN_LIST_1(a)                          xen_ecl_list_1(a)
#define XEN_LIST_2(a, b)                       xen_ecl_list_2(a, b)
#define XEN_LIST_3(a, b, c)                    xen_ecl_list_3(a, b, c)
#define XEN_LIST_4(a, b, c, d)                 xen_ecl_list_4(a, b, c, d)
#define XEN_LIST_5(a, b, c, d, e)              xen_ecl_list_5(a, b, c, d, e)
#define XEN_LIST_6(a, b, c, d, e, f)           xen_ecl_list_6(a, b, c, d, e, f)
#define XEN_LIST_7(a, b, c, d, e, f, g)        xen_ecl_list_7(a, b, c, d, e, f, g)
#define XEN_LIST_8(a, b, c, d, e, f, g, h)     xen_ecl_list_8(a, b, c, d, e, f, g, h)
#define XEN_LIST_9(a, b, c, d, e, f, g, h, i)  xen_ecl_list_9(a, b, c, d, e, f, g, h, i)
#define XEN_LIST_REF(Lst, Num)                 xen_ecl_list_ref(Lst, Num)
#define XEN_LIST_SET(Lst, Num, Val)
#define XEN_LIST_REVERSE(Lst)                  xen_ecl_reverse(Lst)
#define XEN_COPY_ARG(Lst)                      Lst
#define XEN_APPEND(X, Y)                       xen_ecl_append(X, Y)
#define XEN_STRING_P(Arg)                      xen_ecl_string_p(Arg)
#define XEN_NAME_AS_C_STRING_TO_VALUE(a) 0
#define XEN_TO_C_STRING(Str)                   xen_ecl_xen_to_c_string(Str)
#define C_TO_XEN_STRING(a)                     xen_ecl_c_to_xen_string(a)
#define C_TO_XEN_STRINGN(Str, Len)             C_TO_XEN_STRING(Str)
#define C_STRING_TO_XEN_SYMBOL(a)              xen_ecl_c_string_to_xen_symbol(a)
#define XEN_ZERO                               C_TO_XEN_INT(0)
#define XEN_NUMBER_P(Arg)                      xen_ecl_number_p(Arg)
#define XEN_OFF_T_P(Arg) 0
#define XEN_DOUBLE_P(Arg)                      xen_ecl_double_p(Arg)
#define XEN_TO_C_DOUBLE(a) 0.0
#define XEN_TO_C_DOUBLE_OR_ELSE(a, b) b
#define C_TO_XEN_DOUBLE(a) 0
#define XEN_INTEGER_P(Arg)                     xen_ecl_integer_p(Arg)
#define C_TO_XEN_INT(a)                        xen_ecl_c_to_xen_int(a)
#define XEN_TO_C_INT(a)                        xen_ecl_xen_to_c_int(a)
#define XEN_TO_C_INT_OR_ELSE(a, b) b
#define XEN_ULONG_P(Arg) 0
#define XEN_TO_C_ULONG(a) 0
#define C_TO_XEN_ULONG(a) 0
#define C_TO_XEN_LONG_LONG(a) a
#define XEN_TO_C_LONG_LONG(a) a
#define XEN_EXACT_P(Arg) 0

#define XEN_HAVE_RATIOS                        1	
#define XEN_NUMERATOR(Arg)                     xen_ecl_numerator(Arg)
#define XEN_DENOMINATOR(Arg)        	       xen_ecl_denominator(Arg)
#define XEN_RATIONALIZE(Arg1, Arg2)            xen_ecl_rationalize(Arg1, Arg2)
#define XEN_RATIO_P(Arg)                       xen_ecl_rational_p(Arg)
#define XEN_MAKE_RATIO(Num, Den)               xen_ecl_make_ratio(Num, Den)

#define C_STRING_TO_XEN_FORM(Str) 0
#define XEN_EVAL_FORM(Form)                    xen_ecl_eval_form(Form)
#define XEN_EVAL_C_STRING(Arg)                 xen_ecl_eval_c_string(Arg, false)
#define XEN_EVAL_C_STRING_AND_FREE(Arg)        xen_ecl_eval_c_string(Arg, true)
#define XEN_SYMBOL_TO_C_STRING(a) ((char *)"(not a symbol)")
#define XEN_TO_STRING(Obj)                     xen_ecl_xen_to_string(Obj)
#define XEN_WRAP_C_POINTER(a) 0
#define XEN_UNWRAP_C_POINTER(a) 0
#define XEN_WRAPPED_C_POINTER_P(a) 0
#define XEN_PROCEDURE_P(Arg) 0
#define XEN_PROCEDURE_SOURCE(Func) 0


#define XEN_DEFINE_PROCEDURE(Name, Func, ReqArg, OptArg, RstArg, Doc) \
    cl_def_c_function(cl_intern(1, make_simple_base_string(Name)), (void *)Func, ReqArg)	 


#define XEN_DEFINE_PROCEDURE_WITH_SETTER(Get_Name, Get_Func, Get_Help, Set_Name, Set_Func, Get_Req, Get_Opt, Set_Req, Set_Opt)

#define XEN_DEFINE_PROCEDURE_WITH_REVERSED_SETTER(Get_Name, Get_Func, Get_Help, Set_Name, Set_Func, Rev_Func, Get_Req, Get_Opt, Set_Req, Set_Opt)

#define XEN_ARITY(Func) 0
#define XEN_REQUIRED_ARGS(Func) 0
#define XEN_REQUIRED_ARGS_OK(Func, Args) false
#define XEN_CALL_0(Func, Caller)            0       
#define XEN_CALL_1(Func, Arg1, Caller)       0      
#define XEN_CALL_2(Func, Arg1, Arg2, Caller)  0     
#define XEN_CALL_3(Func, Arg1, Arg2, Arg3, Caller) 0
#define XEN_CALL_4(Func, Arg1, Arg2, Arg3, Arg4, Caller) 0
#define XEN_CALL_5(Func, Arg1, Arg2, Arg3, Arg4, Arg5, Caller) 0
#define XEN_CALL_6(Func, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Caller) 0
#define XEN_APPLY(Func, Args, Caller)              0
#define XEN_APPLY_ARG_LIST_END                    0
#define XEN_CALL_0_NO_CATCH(Func)                 0
#define XEN_CALL_1_NO_CATCH(Func, Arg1)            0
#define XEN_CALL_2_NO_CATCH(Func, Arg1, Arg2)      0
#define XEN_CALL_3_NO_CATCH(Func, Arg1, Arg2, Arg3) 0
#define XEN_APPLY_NO_CATCH(Func, Args)             0

#define XEN_DEFINE_CONSTANT(Name, Value, Help)     XEN_EVAL_C_STRING_AND_FREE(mus_format("(defvar %s %d)", Name, Value))
#define XEN_DEFINE_VARIABLE(Name, Value, Help)     XEN_EVAL_C_STRING_AND_FREE(mus_format("(defvar %s %d)", Name, Value))
#define XEN_DEFINE(Name, Value)                    XEN_EVAL_C_STRING_AND_FREE(mus_format("(defvar %s %d)", Name, Value))
/* actually Value can be anything here */

#define XEN_VARIABLE_SET(a, b)
#define XEN_VARIABLE_REF(a) 0
#define XEN_MARK_OBJECT_TYPE         XEN
#define XEN_MAKE_OBJECT_TYPE(Typ, Siz) 0
#define XEN_MAKE_OBJECT_PRINT_PROCEDURE(Type, Wrapped_Print, Original_Print) 
#define XEN_MAKE_OBJECT_FREE_PROCEDURE(Type, Wrapped_Free, Original_Free)
#define XEN_MAKE_AND_RETURN_OBJECT(Tag, Val, ig1, ig2) return(0)
#define XEN_OBJECT_REF(a) 0
#define XEN_OBJECT_TYPE int
#define XEN_OBJECT_TYPE_P(OBJ, TAG) 0
#define XEN_SYMBOL_P(Arg)                          xen_ecl_symbol_p(Arg)
#define XEN_HOOK_P(Arg) 0
#define XEN_HOOKED(a) 0
#define XEN_DEFINE_HOOK(Name, Arity, Help) 0
#define XEN_DEFINE_SIMPLE_HOOK(Arity) 0
#define XEN_CLEAR_HOOK(Arg)
#define XEN_HOOK_PROCEDURES(a) 0
#define XEN_VECTOR_P(Arg)                          xen_ecl_vector_p(Arg)
#define XEN_VECTOR_LENGTH(Arg) 0
#define XEN_VECTOR_REF(Vect, Num) 0
#define XEN_VECTOR_SET(a, b, c)
#define XEN_MAKE_VECTOR(Num, Fill) 0
#define XEN_VECTOR_TO_LIST(Vect) 0
#define XEN_CHAR_P(Arg)                            xen_ecl_char_p(Arg)
#define XEN_TO_C_CHAR(Arg) 0
#define C_TO_XEN_CHAR(Arg) 0
#define XEN_KEYWORD_P(Obj) 0
#define XEN_KEYWORD_EQ_P(k1, k2) 0
#define XEN_MAKE_KEYWORD(Arg) 0
#define XEN_YES_WE_HAVE(Feature)
#define XEN_DOCUMENTATION_SYMBOL 0
#define XEN_OBJECT_HELP(Name) 0
#define XEN_PROTECT_FROM_GC(a) 0
#define XEN_LOAD_FILE(a) 0
#define XEN_LOAD_FILE_WITH_PATH(a) 0
#define XEN_LOAD_PATH XEN_FALSE
#define XEN_ADD_TO_LOAD_PATH(Path) XEN_FALSE
#define XEN_ERROR_TYPE(Typ) XEN_FALSE
#define XEN_ERROR(Type, Info) fprintf(stderr, "error")
#define XEN_THROW(Type, Info) fprintf(stderr, "error")
#define XEN_ASSERT_TYPE(Assertion, Arg, Position, Caller, Correct_Type)
#define XEN_WRONG_TYPE_ARG_ERROR(Caller, ArgN, Arg, Descr)
#define XEN_OUT_OF_RANGE_ERROR(Caller, ArgN, Arg, Descr)
typedef XEN (*XEN_CATCH_BODY_TYPE) (void *data);

void xen_no_ext_lang_check_args(const char *name, int args, int req_args, int opt_args, int rst_args);

XEN xen_ecl_true(void);
XEN xen_ecl_false(void);
XEN xen_ecl_unbound(void);

bool xen_ecl_true_p(XEN val);
bool xen_ecl_false_p(XEN val);
bool xen_ecl_boolean_p(XEN val);
XEN xen_ecl_c_to_xen_boolean(bool val);
bool xen_ecl_xen_to_c_boolean(XEN val);

XEN xen_ecl_c_to_xen_int(int val);
int xen_ecl_xen_to_c_int(XEN val);

XEN xen_ecl_numerator(XEN val);
XEN xen_ecl_denominator(XEN val);
XEN xen_ecl_make_ratio(XEN num, XEN den);
bool xen_ecl_rational_p(XEN val);
XEN xen_ecl_rationalize(XEN arg1, XEN arg2);

bool xen_ecl_cons_p(XEN val);
bool xen_ecl_null_p(XEN val);
bool xen_ecl_list_p(XEN val);
bool xen_ecl_symbol_p(XEN val);
bool xen_ecl_char_p(XEN val);
bool xen_ecl_number_p(XEN val);
bool xen_ecl_vector_p(XEN val);
bool xen_ecl_string_p(XEN val);
bool xen_ecl_double_p(XEN val);
bool xen_ecl_integer_p(XEN val);

bool xen_ecl_eq_p(XEN a, XEN b);
bool xen_ecl_eqv_p(XEN a, XEN b);
bool xen_ecl_equal_p(XEN a, XEN b);

XEN xen_ecl_car(XEN val);
XEN xen_ecl_cadr(XEN val);
XEN xen_ecl_caddr(XEN val);
XEN xen_ecl_cadddr(XEN val);
XEN xen_ecl_cdr(XEN val);
XEN xen_ecl_cddr(XEN val);

XEN xen_ecl_list_1(XEN a);
XEN xen_ecl_list_2(XEN a, XEN b);
XEN xen_ecl_list_3(XEN a, XEN b, XEN c);
XEN xen_ecl_list_4(XEN a, XEN b, XEN c, XEN d);
XEN xen_ecl_list_5(XEN a, XEN b, XEN c, XEN d, XEN e);
XEN xen_ecl_list_6(XEN a, XEN b, XEN c, XEN d, XEN e, XEN f);
XEN xen_ecl_list_7(XEN a, XEN b, XEN c, XEN d, XEN e, XEN f, XEN g);
XEN xen_ecl_list_8(XEN a, XEN b, XEN c, XEN d, XEN e, XEN f, XEN g, XEN h);
XEN xen_ecl_list_9(XEN a, XEN b, XEN c, XEN d, XEN e, XEN f, XEN g, XEN h, XEN i);

XEN xen_ecl_empty_list(void);
XEN xen_ecl_cons(XEN a, XEN b);
XEN xen_ecl_cons2(XEN a, XEN b, XEN c);

XEN xen_ecl_reverse(XEN lst);
XEN xen_ecl_append(XEN a, XEN b);
int xen_ecl_list_length(XEN lst);
XEN xen_ecl_list_ref(XEN lst, int num);

XEN xen_ecl_eval_c_string(char *str, bool free_str);
XEN xen_ecl_eval_form(XEN form);

XEN xen_ecl_c_to_xen_string(const char *str);
char *xen_ecl_xen_to_c_string(XEN obj);
XEN xen_ecl_c_string_to_xen_symbol(const char *str);
XEN xen_ecl_xen_to_string(XEN obj);


#endif
/* end ECL */



--------------------------------------------------------------------------------

xen.c

/* ------------------------------ ECL ------------------------------ */

#if HAVE_ECL

#if MUS_DEBUGGING
  #define MY_FREE(a) mem_free(a, c__FUNCTION__, __FILE__, __LINE__)
#else
  #define MY_FREE(a) free(a)
#endif

/* this header is horrifying -- to protect my code, I'll have to sequester everything in this file */
#include <ecl/ecl.h>



XEN xen_ecl_true(void)
{
  return((XEN)Ct);
}


XEN xen_ecl_false(void)
{
  return((XEN)Cnil);
}


XEN xen_ecl_unbound(void)
{
  return((XEN)ECL_UNBOUND);
}


bool xen_ecl_true_p(XEN val)
{
  return(val == Ct);
}


bool xen_ecl_false_p(XEN val)
{
  return(val == Cnil);
}


bool xen_ecl_boolean_p(XEN val)
{
  return((val == Ct) || (val == Cnil));
}


XEN xen_ecl_c_to_xen_boolean(bool val)
{
  if (val)
    return((XEN)Ct);
  return((XEN)Cnil);
}


bool xen_ecl_xen_to_c_boolean(XEN val)
{
  return(val == Ct);
}


XEN xen_ecl_c_to_xen_int(int val)
{
  return((XEN)MAKE_FIXNUM(val));
}


int xen_ecl_xen_to_c_int(XEN val)
{
  return(fix((cl_object)val));
}

XEN xen_ecl_numerator(XEN val)
{
  return((XEN)cl_numerator((cl_object)val));
}

XEN xen_ecl_denominator(XEN val)
{
  return((XEN)cl_denominator((cl_object)val));
}

XEN xen_ecl_make_ratio(XEN num, XEN den)
{
  return((XEN)ecl_make_ratio((cl_object)num, (cl_object)den));
}

bool xen_ecl_rational_p(XEN val)
{
  cl_type t = type_of((cl_object)val);
  return((t == t_fixnum) || (t == t_bignum) || (t == t_ratio));
}

XEN xen_ecl_rationalize(XEN arg1, XEN arg2)
{
  return((XEN)cl_rationalize((cl_object)arg1));
}



XEN xen_ecl_car(XEN val)
{
  return((XEN)CAR((cl_object)val));
}

XEN xen_ecl_cadr(XEN val)
{
  return((XEN)XEN_CADR((cl_object)val));
}

XEN xen_ecl_caddr(XEN val)
{
  return((XEN)CADDR((cl_object)val));
}

XEN xen_ecl_cadddr(XEN val)
{
  return((XEN)CADDDR((cl_object)val));
}

XEN xen_ecl_cdr(XEN val)
{
  return((XEN)CDR((cl_object)val));
}

XEN xen_ecl_cddr(XEN val)
{
  return((XEN)CDDR((cl_object)val));
}

XEN xen_ecl_empty_list(void)
{
  return((XEN)cl_make_list(1,0));
}

XEN xen_ecl_cons(XEN a, XEN b)
{
  return((XEN)cl_cons((cl_object)a, (cl_object)b));
}

XEN xen_ecl_cons2(XEN a, XEN b, XEN c)
{
  return((XEN)cl_cons((cl_object)a, cl_cons((cl_object)b, (cl_object)c)));
}

XEN xen_ecl_list_1(XEN a)
{
  return((XEN)cl_list(1, (cl_object)a));
}

XEN xen_ecl_list_2(XEN a, XEN b)
{
  return((XEN)cl_list(2, (cl_object)a, (cl_object)b));
}

XEN xen_ecl_list_3(XEN a, XEN b, XEN c)
{
  return((XEN)cl_list(3, (cl_object)a, (cl_object)b, (cl_object)c));
}

XEN xen_ecl_list_4(XEN a, XEN b, XEN c, XEN d)
{
  return((XEN)cl_list(4, (cl_object)a, (cl_object)b, (cl_object)c, (cl_object)d));
}

XEN xen_ecl_list_5(XEN a, XEN b, XEN c, XEN d, XEN e)
{
  return((XEN)cl_list(5, (cl_object)a, (cl_object)b, (cl_object)c, (cl_object)d, (cl_object)e));
}

XEN xen_ecl_list_6(XEN a, XEN b, XEN c, XEN d, XEN e, XEN f)
{
  return((XEN)cl_list(6, (cl_object)a, (cl_object)b, (cl_object)c, (cl_object)d, (cl_object)e, (cl_object)f));
}

XEN xen_ecl_list_7(XEN a, XEN b, XEN c, XEN d, XEN e, XEN f, XEN g)
{
  return((XEN)cl_list(7, (cl_object)a, (cl_object)b, (cl_object)c, (cl_object)d, (cl_object)e, (cl_object)d, (cl_object)g));
}

XEN xen_ecl_list_8(XEN a, XEN b, XEN c, XEN d, XEN e, XEN f, XEN g, XEN h)
{
  return((XEN)cl_list(8, (cl_object)a, (cl_object)b, (cl_object)c, (cl_object)d, (cl_object)e, (cl_object)d, (cl_object)g, (cl_object)h));
}

XEN xen_ecl_list_9(XEN a, XEN b, XEN c, XEN d, XEN e, XEN f, XEN g, XEN h, XEN i)
{
  return((XEN)cl_list(9, (cl_object)a, (cl_object)b, (cl_object)c, (cl_object)d, (cl_object)e, (cl_object)d, (cl_object)g, (cl_object)h, (cl_object)i));
}

XEN xen_ecl_reverse(XEN lst)
{
  return((XEN)cl_reverse((cl_object)lst));
}

XEN xen_ecl_append(XEN a, XEN b)
{
  return((XEN)ecl_append((cl_object)a, (cl_object)b));
}

int xen_ecl_list_length(XEN lst)
{
  return(XEN_TO_C_INT(cl_list_length((cl_object)lst)));
}

XEN xen_ecl_list_ref(XEN lst, int num)
{
  return((XEN)ecl_nth((cl_fixnum)num, (cl_object)lst));
}


bool xen_ecl_cons_p(XEN val)
{
  return((bool)CONSP((cl_object)val));
}

bool xen_ecl_null_p(XEN val)
{
  return(Null((cl_object)val));
}

bool xen_ecl_list_p(XEN val)
{
  return((bool)LISTP((cl_object)val));
}

bool xen_ecl_symbol_p(XEN val)
{
  return((bool)SYMBOLP((cl_object)val));
}

bool xen_ecl_char_p(XEN val)
{
  return((bool)CHARACTERP((cl_object)val));
}

bool xen_ecl_number_p(XEN val)
{
  return(ecl_numberp((cl_object)val));
}

bool xen_ecl_double_p(XEN val)
{
  return(floatp((cl_object)val));
}

bool xen_ecl_integer_p(XEN val)
{
  cl_type t = type_of((cl_object)val);
  return((t == t_fixnum) || (t == t_bignum));
}

bool xen_ecl_vector_p(XEN val)
{
  return((bool)VECTORP((cl_object)val));
}

bool xen_ecl_string_p(XEN val)
{
  return(ecl_stringp((cl_object)val));
}


bool xen_ecl_eq_p(XEN a, XEN b)
{
  return(ecl_eql((cl_object)a, (cl_object)b));
}

bool xen_ecl_eqv_p(XEN a, XEN b)
{
  return(ecl_equal((cl_object)a, (cl_object)b));
}

bool xen_ecl_equal_p(XEN a, XEN b)
{
  return(ecl_equalp((cl_object)a, (cl_object)b));
}


XEN xen_ecl_c_to_xen_string(const char *str)
{
  return((XEN)make_simple_base_string((char *)str));
}

char *xen_ecl_xen_to_c_string(XEN obj)
{
  return(((cl_object)obj)->base_string.self);
}

XEN xen_ecl_c_string_to_xen_symbol(const char *str)
{
  return((XEN)cl_intern(1, make_simple_base_string((char *)str)));
}

XEN xen_ecl_xen_to_string(XEN obj)
{
  return((XEN)cl_princ_to_string(1, (cl_object)obj));
}

void xen_initialize(void)
{ 
  int argc = 1;
  char *argv[1];
  argv[0] = "";
  cl_boot(argc, argv);
}


int xen_to_c_int_or_else(XEN obj, int fallback) {return(0);}

off_t xen_to_c_off_t_or_else(XEN obj, off_t fallback) {return(0);}

off_t xen_to_c_off_t(XEN obj) {return(0);}

XEN c_to_xen_off_t(off_t val) {return(0);}

char *xen_version(void) {return("unknown");}


XEN xen_ecl_eval_c_string(char *str, bool free_str)
{
  cl_object form;
  form = c_string_to_object(str);
  if (free_str) MY_FREE(str);
  return((XEN)si_safe_eval(3, form, Cnil, OBJNULL));
}


XEN xen_ecl_eval_form(XEN form)
{
  return((XEN)si_safe_eval(3, (cl_object)form, Cnil, OBJNULL));
}

void xen_repl(int argc, char **argv) 
{
  int ctr = 0;
  int size = 512;
  char **buffer = NULL;
  buffer = (char **)calloc(1, sizeof(char *));
  buffer[0] = (char *)calloc(size, sizeof(char));

  while (true)
    {
      cl_object form, result, prin_str;
      fprintf(stdout, "\n>");
      fgets(buffer[0], size, stdin);      

      form = c_string_to_object(buffer[0]);
      result = si_safe_eval(3, form, Cnil, OBJNULL); /* last is "error value" */
      if (result == OBJNULL)
	fprintf(stdout, "error?");
#if 0
      else
	{
	  prin_str = cl_princ_to_string(1, result);
	  fprintf(stdout, prin_str->base_string.self);
	}
#else
      else fprintf(stdout, XEN_AS_STRING(result));
#endif
      ctr++;
      if (ctr > 100) break;
    }

  free(buffer[0]);
  free(buffer);
}

void xen_gc_mark(XEN val) {}



void xen_no_ext_lang_check_args(const char *name, int args, int req_args, int opt_args, int rst_args) {}

#endif


--------------------------------------------------------------------------------

configure.ac

#   --with-ecl            try to use ECL as the extension language
#   --with-ecl-prefix     set location of ECL

AC_ARG_WITH(ecl,         [  --with-ecl	  	  use ECL])

AC_ARG_WITH(ecl-prefix,[  --with-ecl-prefix=PFX where ECL is installed],
            ecl_prefix="$withval", ecl_prefix="")

#--------------------------------------------------------------------------------
# ECL
#--------------------------------------------------------------------------------

if test "$with_ecl" = yes && test "$ac_snd_have_extension_language" = yes ; then
  with_ecl=no
  AC_MSG_WARN([You asked for both ECL and $LOCAL_LANGUAGE -- $LOCAL_LANGUAGE will be used])
fi

if test "$with_ecl" = yes ; then
  AC_MSG_CHECKING([for ECL])
  AC_DEFINE(HAVE_ECL)	
  AC_DEFINE(HAVE_CL)	
  ac_snd_have_extension_language=yes
  AC_DEFINE(HAVE_EXTENSION_LANGUAGE)
  XEN_LIBS="-lecl"
  LOCAL_LANGUAGE="ECL"
  AC_MSG_RESULT([yes])  
fi
--------------------------------------------------------------------------------

snd-main.c

#if HAVE_ECL
  #define SND_PREFS "~/.snd_prefs_ecl"
#endif

--------------------------------------------------------------------------------

snd-xen.c

#if HAVE_ECL
  #define SND_EXT_CONF "/etc/snd_ecl.conf"
  #define SND_PREFS "~/.snd_prefs_ecl"
  #define SND_INIT "~/.snd_ecl"
#endif

#if HAVE_ECL
  XEN_YES_WE_HAVE("snd-ecl");
#endif

--------------------------------------------------------------------------------
mus-config.h.in

#undef HAVE_ECL

--------------------------------------------------------------------------------
