<html>
<!-- documentation for some of the Scheme code included with Snd -->
<head>
<title>Scheme and Ruby Functions included with Snd</title>
<style type="text/css">
<!-- 
	EM.red {color:red; font-style:normal}
        EM.error {color:chocolate; font-style:normal}
        EM.narg {color:chocolate; font-style:italic}
        EM.targ {color:darkgreen; font-style:italic}
        EM.typing {color:maroon; font-style: normal}
        EM.listener {color:darkblue; font-style: normal}
	EM.def {font-weight: bold; font-style: normal}
	H1 {text-align: center}
	UL {list-style-type: none}
-->

</style>
</head>
<body bgcolor=white>
<table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h1>Scheme and Ruby Functions included with Snd</h1></td></tr></table>
<br>
<center>
<table border=1><tr><td>
<table bgcolor="aliceblue" border=0 cellspacing=8><tr><td><small>related documentation:</small></td><td><small><a href="snd.html">snd.html</a></small></td>
<td><small><a href="extsnd.html">extsnd.html</a></small></td><td><small><a href="grfsnd.html">grfsnd.html</a></small></td><td><small><a href="clm.html">clm.html</a></small></td><td><small><a href="sndlib.html">sndlib.html</a></small></td><td><small><a href="fm.html">fm.html</a></small></td><td><small><a href="libxm.html">libxm.html</a></small></td><td><small><a href="index.html">index.html</a></small></td></tr></table>
</td></tr></table>
</center>
<br>

<!-- I'm using A NAME (i.e caps) where the entity should be ignored by the indexer (index.cl) -->

<center><A NAME="introduction"></a>
<ul>
  <li><a href="#autosavedoc">autosave.scm: auto-save support</a>
  <li><a href="#bessdoc">bess.scm, bess.rb: FM demo</a>
  <li><a href="#bess1doc">bess1.scm, bess1.rb: FM violin demo</a>
  <li><a href="#birddoc">bird.scm, bird.rb: North-American birds</a>
  <li><a href="#clminsdoc">clm-ins.scm, clm-ins.rb: more CLM instruments</a>
  <li><a href="#debugdoc">debug.scm: debugging aids</a>
  <li><a href="#dlocsigdoc">dlocsig.rb (Michael Scholz)</a>
  <li><a href="#dlpdoc">dlp and tutorial directories from Dave Phillips</a>
  <li><a href="#drawdoc">draw.scm: graphics additions</a>
  <li><a href="#dspdoc">dsp.scm: various DSP-related procedures</a>
  <li><a href="#editmenudoc">edit-menu.scm: Edit menu additions</a>
  <li><a href="#effectsdoc">new-effects.scm, gtk-effects.scm, effects.rb: an Effects menu</a>
  <li><a href="#envdoc">env.scm, env.rb: envelope functions</a>
  <li><a href="#enveddoc">enved.scm: envelope editor</a>
  <li><a href="#eventdoc">event.scm: xm module stuff</a>
  <li><a href="#exampdoc">examp.scm, examp.rb: many examples</a>
  <li><a href="#extensionsdoc">extensions.scm: various generally useful Snd extensions</a>
  <li><a href="#fadedoc">fade.scm: frequency-domain cross-fades</a>
  <li><a href="#fmvdoc">fmv.scm: a controller for the fm-violin</a>
  <li><a href="#freeverbdoc">freeverb.scm, freeverb.rb: a reverb</a>
  <li><a href="#goopsnddoc">goopsnd.scm: look at Goops</a>
  <li><a href="#hooksdoc">hooks.scm: functions related to hooks</a>
  <li><a href="#indexdoc">index.scm, index.rb: snd-help extension</a>
  <li><a href="#jcrevdoc">jcrev.scm: John Chowning's ancient reverb</a>
  <li><a href="#ladspadoc">ladspa.scm: Kjetil S. Matheussen's LADSPA GUI-builder and previewer.</a>
  <li><a href="#maracadoc">maraca.scm: Perry Cook's maraca physical model</a>
  <li><a href="#marksdoc">marks.scm: functions related to marks</a>
  <li><a href="#maxfdoc">maxf.scm, maxf.rb: Max Mathews resonator</a>
  <li><a href="#mixdoc">mix.scm: functions related to mixes and tracks</a>
  <li><a href="#moogdoc">moog.scm: Moog filter</a>
  <li><a href="#musglyphs">musglyphs.scm: Music notation symbols (from CMN)</a>
  <li><a href="#nbdoc">nb.scm, nb.rb: Popup File info etc</a>
  <li><a href="#noisedoc">noise.scm: noise.ins from CLM translated to Scheme/Ruby by Michael Scholz</a>
  <li><a href="#peakenvdoc">peak-env.scm: peak envelope support</a>
  <li><a href="#pianodoc">piano.scm, piano.rb: piano physical model</a>
  <li><a href="#playdoc">play.scm: play-related functions</a>
  <li><a href="#popupdoc">popup.scm, gtk-popup.scm, popup.rb: Popup menu specializations</a>
  <li><a href="#prc95doc">prc95.scm: Perry Cook's physical model examples</a>
  <li><a href="#pvocdoc">pvoc.scm: phase-vocoder</a>
  <li><a href="#rgbdoc">rgb.scm, rgb.rb: colors</a>
  <li><a href="#rtiodoc">rtio.scm: real-time stuff</a>
  <li><a href="#rubberdoc">rubber.scm, rubber.rb: rubber-sound</a>
  <li><a href="#singerdoc">singer.scm: Perry Cook's vocal-tract physical model</a>
  <li><a href="#snd4doc">snd4.scm: Backwards compatibility for version 4</a>
  <li><a href="#snd5doc">snd5.scm: Backwards compatibility for version 5</a>
  <li><a href="#snd6doc">snd6.scm: Backwards compatibility for version 6</a>
  <li><a href="#sndgldoc">snd-gl.scm: OpenGL examples (gl.c)</a>
  <li><a href="#sndmotifdoc">snd-motif.scm, snd-gtk.scm: Motif/Gtk module (xm.c, xg.c)</a>
  <li><a href="#sndtestdoc">snd-test.scm, snd_test.rb, and event.scm: Snd regression tests</a>
  <li><a href="#spectrdoc">spectr.scm, spectr.rb: instrument steady state spectra</a>
  <li><a href="#straddoc">strad.scm, strad.rb: string physical model (from CLM)</a>
  <li><a href="#vdoc">v.scm, v.rb: fm-violin</a>
  <li><a href="#wsdoc">ws.scm, ws.rb: with-sound</a>
  <li><a href="#xmenveddoc">xm-enved.scm, xm-enved.rb</a>
  <li><a href="#zipdoc">zip.scm: the zipper (a cross-fader)</a>
  <li><a href="#extsndvarexpl">A Note on Scheme variables in Snd</a>
  <li><a href="#extsndasneededexpl">A Note on "As-Needed" input functions</a>
  <li><a href="#extsndcgens">A Note on User-defined Generators in C-CLM</a>
  <li><a href="#continuations">About Continuations</a>
</ul>
</center>
<br>

<p>This file contains notes on the Scheme and Ruby files included with Snd.
To use any of these files, (load &lt;file&gt;); for example <code>(load "v.scm")</code>.  To start Snd with
the file already loaded, <code>snd -l v.scm</code>, or put the load statement in ~/.snd.
</p>

<A NAME="autosavedoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>autosave.scm</h2></td></tr></table>

<pre>
  <em class=def><a name="exautosave">auto-save</a></em>
  <em class=def>cancel-auto-save</em>
</pre>
<!-- I(auto save):L(auto-save)(exautosave) -->
<!-- I(auto save):A(exautosave) -->

<p>The auto-save code sets up a background process that checks periodically for
unsaved edits, and if any are found it saves them in a temporary file.
The time between checks
is set by the variable <i>auto-save-interval</i> which defaults to 60.0 seconds.
To start auto-saving, (load "autosave.scm").  Thereafter <code>(cancel-auto-save)</code>
stops autosaving, and <code>(auto-save)</code> restarts it.
</p>

<A NAME="bessdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>bess.scm, bess.rb</h2></td></tr></table>

<p>bess.scm is a Guile script (independent of Snd) that loads sndlib and xmlib into Guile,
opens the DAC, puts up a bunch of scale widgets, and starts two CLM oscils doing
frequency modulation in semi-real-time (how "real-time" it is depends on your
audio setup).  This is a translation to the Sndlib/Libxm system of bess.cl in CLM.
Michael Scholz has contributed a Ruby translation of this with many improvements:
bess.rb.
</p>


<A NAME="bess1doc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>bess1.scm, bess1.rb</h2></td></tr></table>

<p>bess1.scm and bess1.rb are scripts (independent of Snd), similar to bess.scm and bess.rb,
that give you real-time GUI-based control over the fm-violin while it cycles around in a simple
compositional algorithm.  Both were written by
Michael Scholz, based on CLM's bess5.cl and rt.lisp.
</p>


<A NAME="birddoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>bird.scm</h2></td></tr></table>
<pre>
  <em class=def>bird</em> start dur frequency freqskew amplitude freq-envelope amp-envelope
  <em class=def><a name="bigbird">bigbird</a></em> start dur frequency freqskew amplitude freq-envelope amp-envelope partials
  <em class=def>one-bird</em> beg maxdur func birdname
  <em class=def>make-birds</em> #:optional (output-file "test.snd")
</pre>
<p>
bird.scm is a translation of the Sambox/CLM bird songs.  The two instruments set
up a simple sine wave (bird) and simple waveshaping synthesis (bigbird).  Use a
low-pass filter for distance effects (a bird song sounds really silly
reverberated).  All the real information is in the amplitude and frequency
envelopes.  These were transcribed from sonograms found in some bird guides and articles from
the Cornell Ornithology Lab. 
Many of these birds were used in "Colony".  To hear all the
birds, <code>(make-birds)</code>.  This writes the sequence out as "test.snd" using with-sound.
Waveshaping is described in Le Brun, "Digital Waveshaping Synthesis", JAES 1979 April, vol 27, no 4, p250.
The lines
</p>
<pre>
           ...
	   (coeffs (partials-&gt;polynomial (normalize-partials partials)))
           ...
		     (polynomial coeffs
				 (oscil os (env gls-env))))))
				 <!-- ((( -->
</pre>
<p>setup and run the waveshaping synthesis (in this case it's just a fast
additive synthesis).  <b>partials-&gt;polynomial</b> calculates the Chebyshev
polynomial coefficients given the desired spectrum; the spectrum then
results from driving that polynomial with an oscillator.  Besides the
bird guides, there are now numerous recordings of birds that could
easily be turned into sonograms and transcribed as envelopes.
</p>
<p>In CLM, the bird is:</p>
<pre>
(definstrument bird (startime dur frequency freq-skew amplitude freq-envelope amp-envelope 
	             &amp;optional (lpfilt 1.0) (degree 0) (reverb-amount 0))
  (multiple-value-bind (beg end) (times-&gt;samples startime dur)
    (let* ((amp-env (make-env amp-envelope amplitude dur))
	   (gls-env (make-env freq-envelope (hz-&gt;radians freq-skew) dur))
	   (loc (make-locsig :degree degree :distance 1.0 :reverb reverb-amount))
	   (fil (make-one-pole lpfilt (- 1.0 lpfilt)))
	   (s (make-oscil :frequency frequency)))
      (run
       (loop for i from beg to end do
	 (locsig loc i (one-pole fil (* (env amp-env) (oscil s (env gls-env))))))))))
</pre>
<p>The bird.scm version could easily include the one-pole filter and so on.
The Ruby version of this file is bird.rb.  Just for comparison, the bird instrument
in Ruby is:</p>
<pre>
def bird(start, dur, frequency, freqskew, amplitude, freq_envelope, amp_envelope)
  gls_env = make_env(freq_envelope, hz2radians(freqskew), dur)
  os = make_oscil(frequency)
  amp_env = make_env(amp_envelope, amplitude, dur)
  beg = (srate() * start).round
  len = (srate() * dur).round
  local_data  = make_vct len
  vct_map!(local_data, Proc.new { || env(amp_env) * oscil(os, env(gls_env)) })
  vct_add!($out_data, local_data, beg)
end
</pre>
<p>The Forth version (written by Michael Scholz) is:
</p>
<pre>
instrument: bird { f: start f: dur f: freq f: freq-skew f: amp freq-env amp-envel }
    freq make-oscil-1 { os }
    amp-envel amp dur make-env { amp-env }
    freq-env freq-skew hz&gt;radians dur make-env { gls-env }
    90e random 1e make-locsig { loc }
    start dur run  amp-env env  gls-env env os oscil-1  f*  i loc locsig  loop
;instrument
</pre>

<br>

<A NAME="clminsdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>clm-ins.scm, clm-ins.rb</h2></td></tr></table>

<p>These are instruments from the CLM tarball translated for use in Snd.
</p>
<!-- remember to add corresponding entry to grfsnd instrument table -->
<pre>
  <em class=def>anoi</em> file (etc)
  <em class=def>attract</em> beg dur amp c
  <em class=def>bes-fm</em> beg dur freq amp ratio index
  <em class=def>canter</em> beg dur freq amp (etc)
  <em class=def>cellon</em> beg dur freq amp (etc)
  <em class=def>drone</em> beg dur freq amp (etc)
  <em class=def>expfil</em> start duration hopsecs rampsecs steadysecs file1 file2
  <em class=def>exp-snd</em> file beg dur amp (etc)
  <em class=def>fm-bell</em> beg dur frequency amplitude amp-env index-env index
  <em class=def>fm-drum</em> beg dur freq amp ind (etc)
  <em class=def>fm-insect</em> beg dur freq amp (etc)
  <em class=def>fm-trumpet</em> beg dur (etc)
  <em class=def>fofins</em> beg dur frq amp uvib f0 a0 f1 a1 f2 a2 (amp-env '(0 0 1 1 2 1 3 0))
  <em class=def>fullmix</em> infile (etc)
  <em class=def>gong</em> beg dur freq amp (etc)
  <em class=def>gran-synth</em> beg dur freq grain-dur grain-hop amp
  <em class=def>graphEq</em> file (etc)
  <em class=def>hammondoid</em> beg dur freq amp
  <em class=def>jl-reverb</em>
  <em class=def>lbj-piano</em> beg dur freq amp (etc)
  <em class=def>metal</em> beg dur freq amp
  <em class=def>nrev</em> (reverb-factor 1.09) (lp-coeff 0.7) (volume-1 1.0)
  <em class=def>pins</em> beg dur file amp (transposition 1.0) (time-scaler 1.0) (etc)
  <em class=def>pluck</em> beg dur freq amp (weighting .5) (lossfact .9)
  <em class=def>pqw-vox</em> beg dur freq spacing-freq amp ampfun freqfun freqscl phonemes formant-amps formant-shapes
  <em class=def>pqw</em> beg dur freq (etc)
  <em class=def>resflt</em> beg dur driver (etc)
  <em class=def>reson</em> beg dur freq amp (etc)
  <em class=def>rhodey</em> beg dur freq amp (base .5)
  <em class=def><A NAME="scratch">scratch</a></em> beg file src-ratio turnlist
  <em class=def>spectra</em> beg dur freq amp (etc)
  <em class=def>stereo-flute</em> beg dur freq flow (etc)
  <em class=def>touch-tone</em> beg number
  <em class=def>tubebell</em> beg dur freq amp (base 32.0)
  <em class=def>two-tab</em> beg dur freq amp (etc)
  <em class=def>vox</em> beg dur freq amp ampfun freqfun freqscl voxfun index vibscl
  <em class=def>wurley</em> beg dur freq amp
  <em class=def>zc</em> time dur freq amp length1 length2 feedback
  <em class=def>zn</em> time dur freq amp length1 length2 feedforward
  <em class=def>za</em> time dur freq amp length1 length2 feedback feedforward
</pre>
<p>
<b>fofins</b> is an implementation of FOF synthesis, taken originally from
fof.c of Perry Cook and the article
"Synthesis of the Singing Voice" by Bennett and Rodet in
"Current Directions in Computer Music Research" (MIT Press).
</p><p><b>pluck</b> is based on
the Karplus-Strong algorithm as extended by David Jaffe and Julius Smith -- see 
Jaffe and Smith, "Extensions of the Karplus-Strong Plucked-String Algorithm"
CMJ vol 7 no 2 Summer 1983, reprinted in "The Music Machine".
Another physical model is Nicky Hind's stereo-flute.
</p>
<p>
<b>vox</b> is a translations of Marc LeBrun's MUS10 waveshaping voice instrument
using FM in this case.  The waveshaping version is <b>pqwvox</b>
("phase-quadrature waveshaping voice").
The basic idea is that each of the three vocal formants is created by two
sets of waveshapers, one centered on the even multiple of the base frequency closest to the desired formant frequency,
and the other on the nearest odd multiple.  As the base frequency moves (vibrato, glissando),
these center frequencies are recalculated (on each sample), and the respective amplitudes
set from the distance to the desired frequency.  If a center frequency moves (for example,
the base frequency moves down far enough that the previous upper member of the pair has
to become the lower member), the upper waveshaper (which has ramped to zero amplitude), jumps
down to its new center. The formant table was provided by Robert Poor.
The phase-quadrature part of the business creates single side-band spectra.
For details on waveshaping, see Le Brun, "Digital Waveshaping Synthesis", JAES 1979 April, vol 27, no 4, p250.
It might be simpler to set up three formant generators and drive them with the waveshapers,
but the leap-frog idea was a neat hack -- such things are worth keeping even when
they aren't all that sensible anymore.  (Also, I noticed while writing this paragraph that
the single-sideband cancellation is not working as I expected -- another bug to track down...)
</p>
<p>The FM bell was developed by Michael McNabb in Mus10 in the late '70s.  It is intended
for low bell sounds (say middle C or so). The lines
</p>
<pre>
	   (mod1 (make-oscil (* frequency 2)))
	   (mod2 (make-oscil (* frequency 1.41)))
	   (mod3 (make-oscil (* frequency 2.82)))
	   (mod4 (make-oscil (* frequency 2.4)))
	   (car1 (make-oscil frequency))
	   (car2 (make-oscil frequency))
	   (car3 (make-oscil (* frequency 2.4)))
</pre>
<p>set up three FM pairs, car1+mod1 handling the basic harmonic spectra,
car2+mod2 creating inharmonic spectra (using the square root of 2 more or less
at random), and car3+mod3 putting a sort of formant at the minor third
(2.4 = a ratio of 12/5 = octave+6/5 = minor tenth).
</p>
<pre>
  (define fbell '(0 1 2 1.1000 25 .7500 75 .5000 100 .2000 ))
  (define abell '(0 0 .1000 1 10 .6000 25 .3000 50 .1500 90 .1000 100 0 ))
  (fm-bell 0.0 1.0 220.0 .5 abell fbell 1.0)
</pre>
<p><b>scratch</b> moves back and forth in a sound file according to
a list of turn times (see also <a href="#exenvsoundinterp">env-sound-interp</a>).
</p>
<p><b>pins</b> is a simple implementation of thje spectral modeling synthesis
of Xavier Serra and Julius Smith.  It is similar to the phase vocoder.
</p>
<p>The "z" instruments demonstrate "zdelay" effects -- interpolating
comb, notch, and all-pass filters.
</p>
<p><b>exp-snd</b> is a granular synthesis instrument with envelopes on
nearly every variable. <i>expfile</i> interleaves two granulate processes.
</p>
<p><b>graphEq</b> mimics a graphical equalizer by setting up a bank of formant
generators, with an optional envelope on each formant.
</p>
<p>
<b>anoi</b> is a stab at noise reduction
based on Perry Cook's Scrubber.m.
</p>
<p><b>fullmix</b> is a complicated way to mix stuff.
</p>
<br>

<A NAME="debugdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>debug.scm</h2></td></tr></table>

<pre>
  <em class=def><a name="exsnddebug">snd-debug</a></em>
  <em class=def><a name="exsndtrace">snd-trace</a></em>
  <em class=def><a name="exsndbreak">snd-break</a></em> (message #f)
</pre>
<!-- INDEX debugdoc:Debugging (break/trace) -->

<p>debug.scm is a package of debugging aids.
<b>snd-break</b> sets a breakpoint; if it is called, you drop into the Snd debugger.
You can continue from the breakpoint, optionally returning any value you like.
While in the break context (while the listener prompt says "break"), 
these functions are available:
</p>
<pre>
  <em class=def>break-go</em> (returned-value #f)
  <em class=def>break-locals</em> (stack-location 0)
  <em class=def>break-local</em> local-var (stack-location 0)
  <em class=def>break-backtrace</em> (all #f)
  <em class=def>break-help</em>
  <em class=def>break-quit</em>
  <em class=def>break-quit!</em>
</pre>
<p>
<b>break-locals</b> prints out the local variables and their values.
<b>break-local</b> prints one such variable's value (the <i>local-var</i> argument should be a symbol or a string).
<b>break-help</b> prints out help.
<b>break-backtrace</b> shows the stack at the point of the snd-break call.  The stack trace
is normally truncated to show just the 5 or so inner frames; to get the full
backtrace, call break-backtrace with an argument of #t.
<b>break-quit</b> exits the current break level.
<b>break-quit!</b> exits all break levels, returning you to the true top-level.
<b>break-go</b> continues from the point of the breakpoint.
The 'returned-value' is the value to return from the original call on snd-break.
Here is a brief session in Snd's listener:
</p>
<pre>
<em class=listener>:</em><em class=typing>(define (test-break a) (let ((b (+ a (snd-break "hiho")))) b))</em>
<em class=listener>#&lt;unspecified&gt;</em>
<em class=listener>:</em><em class=typing>(define hi 123)</em>
<em class=listener>#&lt;unspecified&gt;</em>
<em class=listener>:</em><em class=typing>(set! hi (test-break 1))</em>
<em class=listener>break:("hiho")</em>
<em class=listener>break:</em><em class=typing>hi</em>
<em class=listener>123</em>
<em class=listener>break:</em><em class=typing>(break-go 32)</em>
<em class=listener>:#&lt;unspecified&gt;</em>
<em class=listener>:</em><em class=typing>hi</em>
<em class=listener>33</em>
</pre>
<p>In words, we put a breakpoint in the midst of an expression in the test-break function,
asking it to type "hiho" and drop into the debugger if it is executed.  Then we call
test-break in an expression that sets the variable hi.  The breakpoint is hit, "hiho"
gets reported, and we're placed in the debugger.  As you can probably tell, this is
just the Snd listener, but with some extra context to implement the break support.
After poking around, we call break-go with an argument of 32.  This causes the original
set! to continue with 32 plugged in where the snd-break call was, setting hi to 33.
</p>
<p>
<b>snd-debug</b> sets up a debugger. You can examine the stack or local variables etc.
After calling snd-debug, there are functions similar to the break functions listed above:
</p>
<pre>
  <em class=def>bt</em> -- show backtrace
  <em class=def>lv (obj)</em> -- show local vars
</pre>
<p><b>snd-trace</b> activates any tracing
that you may have requested and redirects its output to the Snd listener.
Here's how to trace fm-violin calls in a notelist:
</p>
<pre>
(trace fm-violin)
(<em class=red>snd-trace</em> (with-sound () (fm-violin 0 1 440 .1)))
</pre>
<p>To turn off the trace</p>
<pre>
(untrace fm-violin)
</pre>
<br>

<A NAME="dlocsigdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>dlocsig.rb</h2></td></tr></table>

<p>dlocsig.rb is Michael Scholz's translation to Ruby of Fernando Lopez-Lezcano's
dlocsig in CLM.  Fernando's documentation can be found in the CLM tarball
(dlocsig/index.html).  dlocsig is a CLM generator that can produce moving sounds.
</p>
<p>See dlocsig.rb for documentation and examples.
</p>
<br>

<A NAME="dlpdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>dlp directory entries</h2></td></tr></table>

<p>The dlp directory contains a variety of useful additions written by Dave Phillips.  These
include:
</p>
<pre>
  <em class=def>misc.scm</em>               loads files for enhanced interface, many new menu options
  <em class=def>new-icons.scm</em>          icon box entries
  <em class=def>special-menu.scm</em>       the Special menu (OGG/MP3 etc)
  <em class=def>mix-menu.scm</em>           the Mix menu
  <em class=def>panic.scm</em>              the Panic menu (to stop sound output)
  <em class=def>track-colors.scm</em>       track color choices (for mixing)
  <em class=def>fft-menu.scm</em>           FFT-based editing
  <em class=def>new-backgrounds.scm</em>    background choices (granite Snd!)
  <em class=def>marks-menu.scm</em>         the Marks menu
  <em class=def>new-buttons.scm</em>        sets the icon box actions
  <em class=def>README</em>                 loading info
</pre>
<p>See the individual files and Dave's tutorial (in the tutorial directory) for more details.
</p>

<p>There are a few other files in the main directory that I haven't documented yet:</p>
<pre>
  <em class=def>DotEmacs</em>               Emacs init file (Fernando Lopez-Lezcano)
  <em class=def>edit123.scm</em>            Handy editing sequences (Tom Roth)
  <em class=def>inf-snd.el</em>             Ruby/Guile Emacs connection (Michael Scholz)
  <em class=def>rmsgain.scm</em>            amplitude via rms (Fabio Furlanete)
  <em class=def>snd_conffile.scm</em>       Snd init file (Kjetil S. Matheussen)
</pre>


<A NAME="drawdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>draw.scm</h2></td></tr></table>

<p>draw.scm has examples of graphics additions; some of these are shown in extsnd.html.
</p><p><b>display-energy</b> is a lisp-graph-hook procedure that displays the current time
domain data as energy, not amplitude, using the y zoom slider to control the
y axis.  The other procedures in draw.scm are intended for use with the
after-graph-hook.  
</p><p><b>display-colored-samples</b> (color beg dur snd chn) displays samples from beg for dur in color
whenever they're in the current view. This is intended for use with <b>color-samples</b>. 
(<a name="colorsamples">color-samples</a> color #:optional beg dur snd chn) causes samples from beg to beg+dur to be displayed in color;
to undo this, use <b>uncolor-samples</b>.
</p><p><b>display-previous-edits</b> displays all edits of the current sound, with older versions gradually fading away.
</p><p><b>overlay-sounds</b> overlays onto its first argument all subsequent arguments: (overlay-sounds 1 0 3).
</p><p><b>make-current-window-display</b>
displays in the upper right corner the overall current sound and where the current window fits in it.
This info is implicit in the x sliders, but a redundant graph doesn't hurt.  If you click in that graph,
the cursor is moved to the clicked point.
</p>
<center><img src="uppergrf.png" alt="make-current-window-display"></center>
<br>
<p>
<b>click-for-listener-help</b> is intended as a <a href="extsnd.html#listenerclickhook">listener-click-hook</a> entry.  It posts help about
the closest entity it can find whenever you double click in the listener.  Unfortunately, the help
dialog is a bit clunky for a use like this, but the minibuffer has only one line, and
tooltips are irritating in their own way; perhaps it should post the help at the bottom of
the listener?
</p>
<br>

<A NAME="dspdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>dsp.scm</h2></td></tr></table>

<p>A DSP grabbag, mostly filters.
</p>
<table border=1>
  <tr><td><em class=def><A NAME="exdolph">dolph</a></em> n gamma</td><td>Dolph-Chebyshev fft data window</td></tr>
  <tr><td><em class=def><A NAME="exdht">dht</a></em> data</td><td>slow Hartley transform </td></tr>
  <tr><td><em class=def>find-sine</em> freq beg dur</td><td>DFT at a particular frequency</td></tr>
  <tr><td><em class=def>make-butter-high-pass</em> freq</td><td>2nd order Butterworth highpass</td></tr>
  <tr><td><em class=def>make-butter-low-pass</em> freq</td><td>2nd order Butterworth lowpass</td></tr>
  <tr><td><em class=def>make-butter-band-pass</em> freq bandwidth</td><td>2nd order Butterworth bandpass</td></tr>
  <tr><td><em class=def>make-butter-band-reject</em> freq bandwidth</td><td>2nd order Butterworth bandstop</td></tr>
  <tr><td><em class=def>fltit-1</em></td><td></td></tr>
  <tr><td><em class=def>spectrum-&gt;coeffs</em> order spectrum-envelope</td><td>frequency-response envelope -&gt; FIR coeffs</td></tr>
  <tr><td><em class=def><A NAME="exdownoct">down-oct</a></em></td><td>move sound down 8ve using fft</td></tr>
  <tr><td><em class=def>freqdiv</em> n</td><td>"frequency division" effect</td></tr>
  <tr><td><em class=def>adsat</em> size</td><td>"adaptive saturation" effect</td></tr>
  <tr><td><em class=def>spike</em></td><td>spikey sound effect</td></tr>
  <tr><td><em class=def><A NAME="excomputeuniformcircularstring">compute-uniform-circular-string</a></em> size ...</td><td>scanned synthesis</td></tr>
  <tr><td><em class=def>compute-string</em> size ...</td><td></td></tr>
  <tr><td><em class=def>spot-freq</em></td><td>easily-fooled autocorrelation-based pitch tracker</td></tr>
  <tr><td><em class=def><A NAME="zerophase">zero-phase, rotate-phase</a></em></td><td>phase-based effects</td></tr>
  <tr><td><em class=def>both forms of asymmetric-fm</em></td><td></td></tr>
  <tr><td><em class=def>cosine-summation</em></td><td>sum-of-cosines stuff</td></tr>
  <tr><td><em class=def>legendre-summation</em></td><td></td></tr>
  <tr><td><em class=def>brighten-slightly</em> amount</td><td>add harmonics</td></tr>
  <tr><td><em class=def><a name="makehilberttransform">make-hilbert-transform</a></em> length</td><td>Hilbert transform</td></tr>
  <tr><td><em class=def><a name="makelowpass">make-lowpass</a></em> fc length</td><td>FIR lowpass</td></tr>
  <tr><td><em class=def><a name="makehighpass">make-highpass</a></em> fc length</td><td>FIR highpass</td></tr>
  <tr><td><em class=def><a name="makebandpass">make-bandpass</a></em> flo fhi length</td><td>FIR bandpass</td></tr>
  <tr><td><em class=def><a name="makebandstop">make-bandstop</a></em> flo fhi length</td><td>FIR bandstop</td></tr>
  <tr><td><em class=def><a name="makedifferentiator">make-differentiator</a></em> length</td><td>FIR differentiator</td></tr>
  <tr><td><em class=def><a name="makebiquad">make-biquad</a></em> a0 a1 a2 b1 b2</td><td>IIR cascade section</td></tr>
  <tr><td><em class=def>make-iir-low-pass-1</em> fc</td><td>IIR 1st order lowpass</td></tr>
  <tr><td><em class=def>make-iir-high-pass-1</em> fc</td><td>IIR 1st order highpass</td></tr>
  <tr><td><em class=def>make-iir-low-pass-2</em> fc d</td><td>IIR 2nd order lowpass</td></tr>
  <tr><td><em class=def>make-iir-high-pass-2</em> fc d</td><td>IIR 2nd order highpass</td></tr>
  <tr><td><em class=def>make-iir-band-pass-2</em> f1 f2</td><td>IIR 2nd order bandpass</td></tr>
  <tr><td><em class=def>make-iir-band-stop-2</em> f1 f2</td><td>IIR 2nd order bandstop</td></tr>
  <tr><td><em class=def>make-eliminate-hum</em> freq ...</td><td>hum eliminator (cascaded bandstops)</td></tr>
  <tr><td><em class=def>make-peaking-2</em> f1 f2 m</td><td>slight resonance effect</td></tr>
  <tr><td><em class=def>cascade-&gt;canonical</em> coeffs</td><td>convert cascade coeffs to canonical (for CLM's filter gen)</td></tr>
  <tr><td><em class=def>make-butter-lp</em> M fc</td><td>any even order Butterworth lowpass</td></tr>
  <tr><td><em class=def>make-butter-hp</em> M fc</td><td>any even order Butterworth highpass</td></tr>
  <tr><td><em class=def>make-butter-bp</em> M f1 f2</td><td>any even order Butterworth bandpass</td></tr>
  <tr><td><em class=def>make-butter-bs</em> M f1 f2</td><td>any even order Butterworth bandstop</td></tr>
</table>

<p><b>dolph</b> is the Dolph-Chebyshev fft data window, taken
from Richard Lyons, "Understanding DSP".
</p><p><b>dht</b> is the slow form of the Hartley transform, 
taken from Perry Cook's SignalProcessor.m.
The Hartley transform is a kind of Fourier transform.
A similar function, using the DFT, is <b>find-sine</b>.
It returns the amplitude and initial-phase (for sin) at freq between beg and dur.
</p><p>The simple Butterworth filters are taken from Sam Heisz's CLM version
of Paris Smaragdis's Csound version of Charles Dodge's code from "Computer Music: synthesis, composition, and performance".
The second set (make-butter-lp et al) provide arbitrary order Butterworths.
See also the notch filter in new-effects.scm.
<b>spectrum-&gt;coeffs</b> is a Scheme
version of Snd's very simple spectrum-&gt;coefficients procedure ("frequency sampling").
It returns the FIR filter coefficients given the filter order and desired spectral envelope.
</p>
<pre>
(map-chan (fltit-1 10 (list-&gt;vct '(0 1.0 0 0 0 0 0 0 1.0 0))))
</pre>
<p>
<b>down-oct</b> tries to move a sound down an octave by goofing with the fft data,
then inverse ffting.  
<b>freqdiv</b> implements
"frequency division", taken from an effects package of sed_sed@my-dejanews.com.
</p>
<pre>
(freqdiv 8)
</pre>
<p>
Also from that package is <b>adsat</b>, "adaptive saturation".  </p><p><b>spike</b> performs 
a product of samples (as opposed to the more common sum); that is, it multiplies
together several successive samples, causing a more spikey output.
</p><p><b>compute-uniform-circular-string</b> and <b>compute-string</b> implement
scanned synthesis of Bill Verplank and Max Mathews.
To watch the wave, open some sound (so Snd has some place to put the graph), turn off
the time domain display (to give our graph all the window)
then <code>(testunif 1.0 0.1 0.0)</code>.
</p><p>The <A NAME="spotfreq"><b>spot-freq</b></a> function is a simple first-pass at using autocorrelation for
pitch tracking; it's easily fooled, but could probably be made relatively robust.
The code:
</p>
<pre>
 (let* ((logla (log10 (/ (+ cor-peak (vct-ref data i)) (* 2 cor-peak))))
	(logca (log10 (/ (+ cor-peak (vct-ref data (+ i 1))) (* 2 cor-peak))))
	(logra (log10 (/ (+ cor-peak (vct-ref data (+ i 2))) (* 2 cor-peak))))
	(offset (/ (* 0.5 (- logla logra))
		   (+ logla logra (* -2.0 logca)))))
   (return (/ (srate snd)
	      (* 2 (+ i 1 offset)))))
</pre>
<p>is using Xavier Serra's interpolation technique to find the true location
of the autocorrelation peak.  The <i>cor-peak</i> business is making sure the
log10 arguments fall between 0.0 and 1.0.
</p>

<p><b>zero-phase</b> and <b>rotate-phase</b> are fft-manipulators taken from
the phazor package of Scott McNab.
</p>

<p><b>asyfm-J</b> is a Scheme version of the CLM asymmetric-fm generator;
<b>asyfm-I</b> is the Modifier Bessel version of this generator.  In both
cases, the "r" variable is accessible, so it's easy to experiment with 
the moving formant idea mentioned in the original article.
</p>

<p><b>cosine-summation</b> is a variation on Moorer's sine-summation;
the generating formula is much simpler, but the result is the same.  This
can also be viewed as a version of the sum-of-cosines generator, giving control
on the ratio between successive cosines in the sum (i.e. the "r" parameter in
sine-summation, applied within the sum-of-cosines output).  <b>legendre-summation</b>
uses the sum-of-cosines generator to produce a band-limited pulse-train whose
cosine components have a decreasing amplitude (as if it were a sum of Lengendre
Polynomials driven by a cosine). Three other similar functions are <b>sum-of-n-sines</b>,
<b>sum-of-n-odd-sines</b>, and <b>sum-of-n-odd-cosines</b>.
</p>

<p><b>brighten-slightly</b> is a slight simplification of contrast-enhancement.
</p><p><b>make-hilbert-transform</b> and <b>hilbert-transform</b> provide an FIR filter approach to the Hilbert transform.
<b>make-lowpass</b> and <b>lowpass</b> provide FIR low pass filtering.
<b>make-highpass</b> and <b>highpass</b> provide FIR high pass filtering.
<b>make-bandpass</b> and <b>bandpass</b> provide FIR band pass filtering.
<b>make-bandstop</b> and <b>bandstop</b> provide FIR notch filtering.
<b>make-differentiator</b> and <b>differentiator</b> provide an FIR filter-based differentiator.
</p>
<p>The Ruby version of this is in examp.rb.
</p>

<A NAME="editmenudoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>edit-menu.scm</h2></td></tr></table>

<p>edit-menu.scm adds some useful options to the Edit menu:
</p>
<pre>
  trim front and trim back (to/from marks)
  crop (first and last marks)
  selection-&gt;new
  cut selection-&gt;new
  append selection (and append sound)
</pre>
<!-- I(trim sound):M(Edit: Trim)(editmenudoc) -->
<!-- I(trim sound):A(editmenudoc) -->


<A NAME="effectsdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>new-effects.scm, gtk-effects.scm</h2></td></tr></table>

<p>new-effects.scm implements an Effects menu.  If you have Motif,
you can load xm.so (or build Snd with it preloaded), and get sliders
to control most of the effects.  (Use gtk-effects.scm with Gtk, obviously).
The effects include:
</p>
<pre>
  reverse
  normalize (normalization)
  gain (gain-amount)
  invert
  chordalize (chordalize-amount, chordalize-base)
  flange (increase speed and amount to get phasing, flange-speed, flange-amount, flange-time)
  compand, compand-channel
  reverberate (reverb-amount)
  intensify (contrast-amount)
  echo (echo-length, echo-amount)
  squelch (squelch-amount, omit-silence)
  add silence (at cursor) (silence-amount)
  remove DC
  expsrc (independent pitch/time scaling) (time-scale and pitch-scale)
  various filters
  cross synthesis
</pre>

<!-- I(reverse samples):M(Effects: Reverse)(effectsdoc) -->
<!-- I(reverberate file):M(Effects: Reverberate)(effectsdoc) -->
<!-- I(normalize sound):M(Effects: Normalize)(effectsdoc) -->
<!-- I(normalize sound):A(effectsdoc) -->
<!-- I(normalize sound):L(scale-to)(sndscaleto) -->
<!-- I(insert zeros):M(Effects: Add Silence)(effectsdoc) -->
<!-- I(change tempo):M(Effects: Expsrc)(effectsdoc) -->

<p>Most of these are either simple calls on Snd functions ("invert" is <code>(scale-by -1)</code>),
or use functions in the other scm files.  The actual operations follow the sync chain of the
currently active channel.  
</p>
<p>One possibly interesting part of new-effects.scm is the implementation of the
Effects menu.  If you change one of the variables, you'll notice that the
menu updates its notion of that variable as well.  This is handled through
<i>update-callback</i> argument to <a href="extsnd.html#sndaddtomainmenu">add-to-main-menu</a>
function.  Each effect is added (when new-effects.scm is loaded) to the <i>effects-list</i>.
Then each time you click the Effects menu, causing its options to be dispayed,
the update-callback function itself calls each effect's update function to
get its current option label.  That is,
</p>
<pre>
(define effects-list '())
(define effects-menu 
  (add-to-main-menu "Effects" 
                    (lambda ()
 		      (define (update-label effects)
		        (if (not (null? effects))
			    (begin
			      ((car effects))
			      (update-label (cdr effects)))))
		      (update-label effects-list))))
</pre>
<p>defines the update-callback to be a thunk (the outer lambda) that itself
defines a local function (update-label) that runs through the effects-list
calling each one via <code>((car effects))</code>.  Each effect that wants
to recalculate its option label then
adds its update function to the effects-list when it is loaded:
</p>
<pre>
(set! effects-list (cons (lambda ()
			   (let ((new-label (format #f "gain (~1,2F)" gain-amount)))
			     (change-menu-label effects-menu gain-label new-label)
			     (set! gain-label new-label)))
			 effects-list))
</pre>
<p>The sound effect itself is the callback function of the given option:
</p>
<pre>
(add-to-menu effects-menu "reverse" (lambda () (reverse-sound)))
</pre>
<p>I can't decide whether it would be useful to describe some of these
effects in more detail.  The code is mostly straightforward, and
it's not hard to try them out.
</p>	
<p>The Ruby/Motif version of this is in effects.rb.
</p>
<br>

<A NAME="envdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>env.scm, env.rb</h2></td></tr></table>

<p>An envelope in Snd/CLM is simply a list of breakpoint pairs.  (In the function names, 
I try to remember to use "envelope" to be a list of breakpoints, and "env" to be the result of make-env,
a CLM env structure passed to the env generator).
In an envelope,
the x axis extent
is arbitrary, though it's simplest to use 0.0 to 1.0.  env.scm provides several
envelope functions that are often useful:
</p>
<pre>
  <em class=def>envelope-interp</em> x env <i>base</i>
  <em class=def><a name="windowenvelope">window-envelope</a></em> beg end env
  <em class=def>map-envelopes</em> func env1 env2
  <em class=def>multiply-envelopes</em> env1 env2
  <em class=def>add-envelopes</em> env1 env2
  <em class=def><a name="maxenvelope">max-envelope</a></em> env
  <em class=def>min-envelope</em> env
  <em class=def>integrate-envelope</em> env
  <em class=def><a name="stretchenvelope">stretch-envelope</a></em> env old-attack new-attack <i>old-decay new-decay</i>
  <em class=def>envelope-last-x</em> env
  <em class=def><a name="scaleenvelope">scale-envelope</a></em> env scl <i>(offset 0.0)</i>
  <em class=def><a name="reverseenvelope">reverse-envelope</a></em> env
  <em class=def><a name="concatenateenvelopes">concatenate-envelopes</a></em> #:rest envs
  <em class=def>repeat-envelope</em> env repeats #:optional (reflected #f) (normalized #f)
  <em class=def><a name="powerenv">power-env</a></em> e
  <em class=def>make-power-env</em> e #:key (scaler 1.0) (offset 0.0) duration
  <em class=def>power-env-channel</em> pe #:optional (beg 0) dur snd chn edpos (edname "power-env-channel")
  <em class=def>envelope-exp</em> e #:optional (power 1.0) (xgrid 100)
</pre>
<p>These are translated from CLM's env.lisp.
<code>(envelope-interp x env base)</code> returns value of env at x.
If base is 0, env is treated as a step function; if base is 1.0 (the
default), its breakpoints are connected by a straight line, and
any other base connects the breakpoints with a kind of exponential
curve:
</p>
<pre>
:<em class=typing>(envelope-interp .1 '(0 0 1 1))</em>
<em class=listener>0.1</em>
:<em class=typing>(envelope-interp .1 '(0 0 1 1) 32.0)</em>
<em class=listener>0.0133617278184869</em>
:<em class=typing>(envelope-interp .1 '(0 0 1 1) .012)</em>
<em class=listener>0.361774730775292</em>
</pre>
<p>The corresponding function for a CLM env generator is <a href="clm.html#env-interp">env-interp</a>.
If you'd rather think in terms of e^-kt, set the base to (exp k).  
</p>
<p><b>window-envelope</b> returns (as an envelope) the portion of its envelope argument that lies
between the X axis values <i>beg</i> and <i>end</i>.  This is useful when you're treating an
envelope as a phrase-level control, applying successive portions of it to many underlying
notes.
</p>
<pre>
:<em class=typing>(window-envelope 1.0 3.0 '(0.0 0.0 5.0 1.0))</em>
<em class=listener>(1.0 0.2 3.0 0.6)</em>
</pre>
<p><b>map-envelopes</b> applies its <i>func</i> argument to the breakpoints in the two
envelope arguments, returning a new envelope. A simple application of this is
<b>multiply-envelopes</b> which multiplies two envelopes:
</p>
<pre>
:<em class=typing>(multiply-envelopes '(0 0 1 1) '(0 0 1 1 2 0))</em>
<em class=listener>(0 0 0.5 0.5 1 0)</em>
</pre>
<p>As this example shows, the new envelope goes from 0.0 to 1.0 along
the X axis; the multiplied envelopes are stretched or contracted to
fit 0.0 to 1.0, and wherever one has a breakpoint, the corresponding
point in the other envelope is interpolated, if necessary. The code
for multiply envelopes is simply:</p>
<pre>
(define multiply-envelopes
  (lambda (e1 e2)
    (map-envelopes * e1 e2)))
</pre>
<p><b>max-envelope</b> returns the maximum Y value in <i>env</i>, and <b>envelope-last-x</b>
returns the maximum X value:
</p>
<pre>
:<em class=typing>(max-envelope '(0 0 1 1 2 3 4 0))</em>
<em class=listener>3.0</em>
</pre>
<p>Similarly, <b>min-envelope</b> returns the minimum y value.</p>
<p><b>integrate-envelope</b> returns the area under the envelope; this is
useful when you need to know in advance the overall effect of an envelope
controlling the sampling rate.
</p>
<pre>
:<em class=typing>(integrate-envelope '(0 0 1 1))</em>
<em class=listener>0.5</em>
:<em class=typing>(integrate-envelope '(0 1 1 1))</em>
<em class=listener>1.0</em>
:<em class=typing>(integrate-envelope '(0 0 1 1 2 .5))</em>
<em class=listener>1.25</em>
</pre>
<p><b>stretch-envelope</b> applies attack and optionally decay times
to an envelope, much like divseg in clm-1.</p>
<pre>
:<em class=typing>(stretch-envelope '(0 0 1 1) .1 .2)</em>
<em class=listener>(0 0 0.2 0.1 1.0 1)</em>
:<em class=typing>(stretch-envelope '(0 0 1 1 2 0) .1 .2 1.5 1.6)</em>
<em class=listener>(0 0 0.2 0.1 1.1 1 1.6 0.5 2.0 0)</em>
</pre>
<p><b>scale-envelope</b> scales the y values of an envelope by <i>scl</i>,
<b>add-envelope</b> adds two envelopes together, <i>reverse-envelope</i>
reverses an envelope.
<b>repeat-envelope</b> repeats an envelope (concatenates copies of itself).
</p>
<pre>
:<em class=typing>(repeat-envelope '(0 0 100 1) 2)</em>
<em class=listener>(0 0 100 1 101 0 201 1)</em>
</pre>
<p>If the final y value is different from the first y value (as above), a quick ramp is
inserted between repeats. 'normalized' causes the new envelope's x axis
to have the same extent as the original's. 'reflected' causes every other
repetition to be in reverse.
</p>
<p><b>make-power-env</b> and <b>power-env</b> implement an extension of exponential
envelopes; each segment has its own base.  <b>power-env-channel</b> uses the same
mechanism as an extension of env-channel.
</p>
<pre>
(let ((pe (make-power-env '(0 0 32.0  1 1 0.0312  2 0 1) :duration 1.0)))
  (map-channel (lambda (y) (* y (power-env pe)))))

(let ((pe1 (make-power-env '(0 0 32.0  1 1 0.0312  2 0 1.0  3 .5 3.0  4 0 0) :duration 1.0)))
  (power-env-channel pe1))
</pre>
<p><b>envelope-exp</b> interpolates segments into envelope to approximate exponential curves.
</p>
<br>

<A NAME="enveddoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>enved.scm</h2></td></tr></table>
<br>
<img src="envs.png" alt="channel enveds">

<pre>
  <em class=def>start-enveloping</em>
  <em class=def>stop-enveloping</em>
  <em class=def><a name="channelenvelope">channel-envelope</a></em> <i>snd chn</i>
  <em class=def><A NAME="explaywithenvs">play-with-envs</A></em> snd
  <em class=def><A NAME="explaypanned">play-panned</A></em> snd
</pre>

<p>enved.scm implements an independent envelope editor in each channel.  <code>(start-enveloping)</code>
sets this in progress (for subsequently opened sounds), <code>(stop-enveloping)</code> turns it off.
Each envelope can be read or written via <code>(channel-envelope snd chn)</code>.
There are also two examples that use these envelopes: <b>play-with-envs</b> and
<b>play-panned</b>.  The former sets the channel's amplitude from its envelope
during playback (it should be obvious how to apply the envelope to any of the
control panel fields); the latter pans a mono sound into stereo following
the envelope. The lines:
</p>
<pre>
(define channel-envelope
  (make-procedure-with-setter
    (lambda (snd chn)
      ...)
    (lambda (snd chn new-env)
      ...)))
</pre>
<p>
use a feature of Guile 1.4 that provides a set! function
for channel-envelope.  The first lambda is called if you're
asking for the current value of that channel-envelope:
</p>
<pre>
(channel-envelope s c)
</pre>
<p>and
the second if you're setting it to something new:
</p>
<pre>
(set! (channel-envelope s c) e)
</pre>
<br clear=right>


<A NAME="eventdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>event.scm</h2></td></tr></table>

<p>event.scm has functions used by snd-test.scm to exercise the user interface.
These functions depend on the xm module and XSendEvent primarily, but there are
also Scheme implementations of some of the built-in functions (change-window-property).
</p>


<A NAME="exampdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>examp.scm</h2></td></tr></table>

<p>examp.scm has become a bit of a grab-bag; rather than get organized, I just
appended new stuff as it came to mind.  The following documentation is
a quick overview of the code; most of the examples are very simple, so (as
the saying goes) "the code is the documentation".  Also, there's some overlap
between these examples, other .scm files, and discussions in other documents.
I'm slowly dividing out related groups of procedures to separate files.
</p>

<ul>
<li><a href="#ssfilters">filters</a>
<small>
  <ul>
    <li>comb-filter, notch-filter, formant-filter
    <li>time varying FIR filter, notch filter
    <li>filtered-env (low-pass and amplitude follow envelope)
    <li>remove-clicks
  </ul>
</small>
<li><a href="#ssffts">ffts</a>
<small>
  <ul>
    <li>correlation
    <li>set transform-size based on current time domain window size
    <li>superimpose spectra of sycn'd sounds
    <li>fft-edit, fft-env-interp, fft-env-edit -- FFT based editing
    <li>fft-squelch -- noise reduction 
    <li>fft-cancel -- fft as very narrow notch filter
    <li>squelch-vowels -- remove steady-state (or the reverse)
    <li>fft-smoother -- fft-based smoothing
  </ul>
</small>
<li><a href="#ssuserinterface">user-interface</a>
<small>
  <ul>
    <li>XEmacs-like Buffers menu
    <li>Reopen menu
    <li>make dot size dependent on number of samples being displayed
    <li>flash selected data red and green
    <li>add date and time to title bar
    <li>how to get 'display' to write to Snd's listener
    <li>multi-colored rxvt printout
    <li>lisp graph with draggable x axis
    <li>pointer-focus
    <li>files-popup-buffer
    <li>Emacs-like C-x b handling
    <li>open-next-file-in-directory
  </ul>
</small>
<li><a href="#ssmarks">marks</a>
<small>
  <ul>
    <li>use loop info (if any) to set marks at loop points
    <li>move window left edge to mark upon 'm' key
  </ul>
</small>
<li><a href="#ssselections">selections</a>
<small>
  <ul>
    <li>swap selection chans
    <li>replace with selection
    <li>explode soundfont file
  </ul>
</small>
<li><a href="#ssmixes">mixes</a>
<small>
  <ul>
    <li>mix mono sound into stereo sound panning according to env, also simple sound placement
  </ul>
</small>
<li><a href="#sssoundeffects">sound effects</a>
<small>
  <ul>
    <li>echo (delays)
    <li>ring-modulation, am
    <li>src-related sound effects (src, rand-interp, etc)
    <li>compand, compand-channel (array-interp)
    <li>shift pitch keeping duration constant (src+granulate)
    <li>tempo change via envelope (granulate)
    <li>cross-synthesis (using a formant bank)
    <li>voiced-&gt;unvoiced (formants)
    <li>convolution (convolve)
    <li>"vector synthesis"
    <li>chain-dsps
  </ul>
</small>
<li><a href="#ssmiscellaneousextensions">miscellaneous extensions</a>
<small>
  <ul>
    <li>'info' from extsnd.html using format
    <li>make a system call
    <li>documentation examples made harder to break
    <li>example of c-g?
    <li>translate mpeg input to 16-bit linear and read into Snd
    <li>read and write OGG files
    <li>mapping extensions (map arbitrary single-channel function over various channel collections)
    <li>sound-interp, env-sound-interp
    <li>searching procedures (search-for-click, find-pitch, zero+, next-peak)
    <li>sound-data-&gt;list
    <li>smooth-channel-via-ptree -- smooth-channel as virtual op
  </ul>
</small>
</ul>



<!-- -------------------------------- FILTERS -------------------------------- -->
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="ssfilters">filters</a></h3></td></tr></table>

<pre>
  <em class=def>comb-filter</em> scaler size
  <em class=def>comb-chord</em> scaler size amp
  <em class=def>zcomb</em> scaler size pm
  <em class=def>notch-filter</em> scaler size
  <em class=def>formant-filter</em> radius frequency
  <em class=def>formants</em> r1 f1 r2 f2 r3 f3
  <em class=def>moving-formant</em> radius move-envelope
  <em class=def>osc-formants</em> radius bases amounts freqs
  <em class=def><A NAME="exremoveclick">remove-click</a></em>
</pre>
<p>The two versions of <b>comb-filter</b> implement a comb filter,
"by hand" and using CLM. <b>comb-chord</b> uses comb filters at harmonically
related sizes to create a chord (see also chordalize in new-effects.scm).  <i>amp</i>
here is an overall amplitude scaler.  <b>zcomb</b> is a time-varying comb
filter using the envelope <i>pm</i>.  <b>notch-filter</b> parallels comb-filter.
<b>formant-filter</b> applies a formant to its input.
Some examples:
</p>
<pre>
(map-chan (comb-filter .8 32))
(map-chan (comb-chord .95 100 .3))
(map-chan (comb-chord .95 60 .3))
(map-chan (zcomb .8 32 '(0 0 1 10)))
(map-chan (notch-filter .8 32))
(map-chan (formant-filter .99 2400))
</pre>
<p>In all these cases, however, it's actually much faster to pass the
filter to filter-sound:</p>
<pre>
(filter-sound (make-formant .99 2400))
</pre>
<p><b>formants</b> applies three formants in parallel.
<b>moving-formant</b> moves a formant according to an envelope.
<b>osc-formants</b> sets up any number of independently oscillating formants.
</p>
<pre>
(map-chan (formants .99 900 .98 1800 .99 2700))
(map-chan (moving-formant .99 '(0 1200 1 2400)))
(map-chan (osc-formants .99 '(400 800 1200) '(400 800 1200) '(4 2 3)))
</pre>
<pre>
  <em class=def>filtered-env</em> envelope
</pre>
<p><b>filtered-env</b> creates an amplitude envelope and a one-pole
filter, and moves them in parallel over a sound; 
as the sound gets softer, the low-pass filter's cutoff frequency
gets lower, a sort of poor-man's distance effect.  When <i>envelope</i>
is at 1.0, no filtering takes place.
</p>
<pre>
  <em class=def>fltit</em>
  <em class=def>remove-clicks</em>
</pre>
<p><b>fltit</b> is a simple FIR filter call.
<b>remove-clicks</b> looks for obvious clicks and uses smooth-sound to remove them.
</p>

<!-- -------------------------------- FFTS -------------------------------- -->
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="ssffts">ffts</a></h3></td></tr></table>
<pre>
  <em class=def><A NAME="excorrelate">correlate</a></em> snd chn y0 y1
  <em class=def><a name="exsuperimposeffts">superimpose-ffts</a></em> snd chn y0 y1
  <em class=def><a name="exfftedit">fft-edit</a></em> low-freq high-freq
  <em class=def><A NAME="exfftenvedit">fft-env-edit</a></em> env
  <em class=def><A NAME="exfftenvinterp">fft-env-interp</a></em> env1 env2 interp
  <em class=def><a name="exfftsquelch">fft-squelch</a></em> squelch
  <em class=def><A NAME="exfftcancel">fft-cancel</a></em> lo-freq hi-freq
  <em class=def>squelch-vowels</em>
  <em class=def><A NAME="exfftsmoother">fft-smoother</a></em> cutoff start samps snd chn
</pre>
<p><b>correlate</b> graphs the correlation of <i>snd</i>'s 2 channels.
To make this happen automatically as you move the time domain position
slider, <code>(add-hook! graph-hook correlate)</code>.
<b>superimpose-ffts</b> is a similar graph-hook function that
superimposes the ffts of multiple (syncd) sounds.
<b>fft-edit</b> is a simple example of fft-based editing.
It takes an fft of the entire sound, removes all energy below <i>low-freq</i> and above <i>high-freq</i>,
then inverse fft's. <b>fft-env-edit</b> is the same, but applies an envelope to the spectral magnitudes;
<b>fft-env-interp</b> takes two such filtered versions and mixes them following the interpolation
envelope. Another similar function is <b>fft-smoother</b> that uses fft-filtering to
smooth a portion of a sound.
<b>fft-squelch</b> is similar, but removes all energy below the squelch amount (normalized to
be between 0.0 and 1.0).  This is sometimes useful for noise-reduction.
<b>fft-cancel</b> ffts an entire sound, sets the bin(s) representing lo-freq to hi-freq to 0.0, then inverse ffts,
giving a high quality notch filter.
<b>squelch-vowels</b> uses fft data to distinguish the steady state portion (a vowel in speech) from
noise (a consonant, sometimes), and does whatever you want based on that (remove vowels, remove
consonants, make consonants louder, etc).
Finally there are two examples
of using graph-hook to set the fft size based on the current time domain window
size.  The simpler one is:
</p>
<pre>
(add-hook! graph-hook 
	   (lambda (snd chn y0 y1)
	     (if (and (transform-graph? snd chn) 
                      (= (transform-graph-type snd chn) graph-once))
		 (begin
		   (set! (transform-size snd chn)
			 (expt 2 (ceiling 
				  (/ (log (- (right-sample snd chn) (left-sample snd chn))) 
				     (log 2.0)))))
		   (set! (spectro-cutoff snd chn) (y-zoom-slider snd chn))))))

</pre>
<p>The <i>expt...</i> code is rounding the current window size (right-sample - left-sample)
up to the nearest power of 2. 
</p>

<!-- -------------------------------- USER-INTERFACE -------------------------------- -->
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="ssuserinterface">user-interface</a></h3></td></tr></table>

<p><b>show-draggable-graph</b>, in imitation of Snd's FFT display, implements a
draggable X axis in the lisp graph window.  (This is slightly messier than
it ought to be).
Two of the examples are imitations of Xemacs: a Buffers menu and an auto-save hook (now in <a href="autosavedoc">autosave.scm</a>).</p>
<pre>
  <em class=def><A NAME="exopenbuffer">open-buffer</a></em> filename
  <em class=def>close-buffer</em> snd
</pre>

<p>The Buffers menu provides a list of currently open sounds; selecting one
in the menu causes it to become the selected sound; <b>open-buffer</b>
adds a menu item that will select a file, <b>close-buffer</b> removes it.
To activate this, we need
to:
</p>
<pre>
(add-hook! open-hook open-buffer)
(add-hook! close-hook close-buffer)
</pre>

<p>A similar menu is the "reopen menu"; it presents a list of previously
closed (and not subsequently re-opened) files in reverse order of closing.
</p>

<pre>
  <em class=def>snd-out</em>
</pre>
<p>A minor irritation in the current Guile system is that Scheme's "display" function
writes to <i>current-output-port</i>, but there's no simple way to redirect that
elsewhere (and with-output-to-string is not completely integrated with
Guile's help system).  So, if your code calls display, the result may be invisible.
One way around this is to reset the current-output-port to be a soft port
that actually calls <a href="extsnd.html#sndprint">snd-print</a> instead:
</p>
<pre>
(define stdout (current-output-port)) ;save it in case we want to go back to it
(define snd-out
  (make-soft-port
   (vector                      ;soft port is a vector of procedures:
    (lambda (c) (snd-print c))  ;  procedure accepting one character for output 
    (lambda (s) (snd-print s))  ;  procedure accepting a string for output 
    (lambda () #f)              ;  thunk for flushing output (not needed here)
    #f                          ;  thunk for getting one character (also not needed)
    (lambda () #f))             ;  thunk for closing port -- hmm should this go back to the previous?
   "w"))
(set-current-output-port snd-out)
</pre>
<p>You could also <code>(set! display snd-print)</code>, if you're willing to
live dangerously; this replaces Guile's built-in <i>display</i> procedure with
Snd's <i>snd-print</i>.
</p>

<p>There are also a few brief examples showing simple display customizations.
The following makes the graph dot size dependent on the
number of samples in the graph:
</p>
<pre>
  <em class=def>auto-dot</em> snd chn y0 y1

(add-hook! graph-hook auto-dot)
</pre>
<p>There are also examples tying the channel graph sliders to the fft display.
Finally there are several somewhat frivolous examples:
</p>
<pre>
  <em class=def><A NAME="titlewithdate">title-with-date</a></em>
  <em class=def>flash-selected-data</em> time-interval
</pre>
<p><code>(title-with-date)</code> adds a clock to the Snd window's title bar.
Set the variable <i>retitle-time</i> to 0 to turn this off.
<b>flash-selected-data</b> cause the selected channel's graph to
flash red and green.  And the there are functions to display colored text
in rxvt:
</p>
<pre>
(display (format #f "~Athis is red!~Abut this is not" red-text normal-text))
(display (format #f "~A~Ahiho~Ahiho" yellow-bg red-fg normal-text))
</pre>
<p>It's possible to use the same escape sequences in a normal shell script, of course:
</p>
<pre>
echo '\e[41m This is red! \e[0m'
</pre>
<br>
<pre>
  <em class=def>files-popup-buffer</em>
</pre>
<p>This is a mouse-enter-label-hook function for the View:Files dialog;
it hides all sounds but the one the mouse is pointing to in the current files list.
The pointer-focus style of interaction uses similar hooks.  There is also
a first stab at Emacs-like C-x b support here; the file name in the prompt
should be a string (i.e. in quotes), unlike Emacs.  This still needs work
especially for multichannel sounds.
</p>
<pre>
  <em class=def>open-next-file-in-directory</em>
</pre>
<p>This is a mouse-click-hook function. If you call</p>
<pre>
(click-middle-button-to-open-next-file-in-directory)
</pre>
<p>it sets up the mouse-click-hook and open-hook so that clicking the middle
mouse button closes the current file and opens for the next (alphabetical
by filename) in the current directory.
</p>


<!-- -------------------------------- MARKS -------------------------------- -->
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="ssmarks">marks</a></h3></td></tr></table>

<p><a href="#marksdoc">marks.scm</a> has most of the mark-related extensions.
The two in examp.scm are:
</p>
<pre>
  <em class=def>first-mark-in-window-at-left</em>
  <em class=def><a name="exmarkloops">mark-loops</a></em>

(bind-key (char-&gt;integer #\l) 0 
          (lambda () 
            (first-mark-in-window-at-left)))
</pre>
<p><b>first-mark-in-window-at-left</b> moves the (time domain) 
graph so that the leftmost visible mark is at the left edge;
<b>mark-loops</b> places marks at any loop points found in the selected sound's header.
Only a few headers support loop points (these are apparently used in synthesizers
to mark portions of a waveform that can be looped without causing clicks, thereby lengthening
a sound as a key is held down). 
</p>

<!-- -------------------------------- SELECTIONS -------------------------------- -->
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="ssselections">selections</a></h3></td></tr></table>

<pre>
  <em class=def>all-chans</em>
  <em class=def><a name="exswapselectionchannels">swap-selection-channels</a></em>
  <em class=def>selection-rms-1</em>
  <em class=def><A NAME="exselectionrms">selection-rms</a></em>
  <em class=def><A NAME="exregionrms">region-rms</a></em> <i>region</i>
  <em class=def><A NAME="exreplacewithselection">replace-with-selection</a></em>
  <em class=def><a name="exexplodesf2">explode-sf2</a></em>
</pre>
<p>
<b>swap-selection-channels</b> swaps the currently selected data's channels.
The various rms functions return the rms value of the desired data in a variety
of ways. The fastest and simplest uses CLM's dot-product function:
</p>
<pre>
(define (region-rms n)
  "(region-rms n) -&gt; rms of region n's data (chan 0)"
  (if (region? n)
      (let* ((data (region-samples-&gt;vct 0 0 n)))
	(sqrt (/ (dot-product data data) (vct-length data))))
      (throw 'no-such-region (list "region-rms" n))))
</pre>
<p><b>replace-with-selection</b> replaces data at the cursor with the
current selection.  <b>explode-sf2</b> turns a soundfont file (assuming it
is the currently selected sound) into a bunch of files of the form sample-name.aif.
</p>



<!-- -------------------------------- MIXES -------------------------------- -->
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="ssmixes">mixes</a></h3></td></tr></table>

<p><a href="#mixdoc">mix.scm</a> has mix and track related functions.
</p>
<pre>
  <em class=def><A NAME="placesound">place-sound</a></em> mono-snd stereo-snd panning-envelope-or-degree
</pre>
<p>If <i>panning-envelope-or-degree</i> is a number (in degrees),
the <b>place-sound</b> function has the same effect as using
CLM's locate generator; it mixes a mono sound into a stereo sound, splitting 
it into two copies whose amplitudes depend on the desired location.
0 degrees: all in channel 0, 90: all in channel 1.
If <i>panning-envelope-or-degree</i> is an envelope,
the split depends on the panning envelope (0 = all in chan 0, etc).
</p>
<table border=3 bordercolor="tan" hspace=40><tr><td>
<blockquote><small>
<br>
Panning or Sound Placement<br>
Place sound: <a href="#placesound">place-sound</a> above.<br>
Pan mix: <a href="#panmix">pan-mix</a>, or via the amplitude and envelope controls in the mix dialog<br>
Place mix: <a href="grfsnd.html#musmix">mus-mix</a><br>
Play sound with panning: <a href="#explaypanned">play-panned</a><br>
CLM placement generator: <a href="clm.html#locsig">locsig</a><br>
CLM moving sound generator: <a href="#dlocsigdoc">dlocsig</a><br>
Move sound via flanging: see flanging effect in new-effects.scm<br>
Cross fade in frequency domain: <a href="#fadedoc">fade.scm</a><br>
<br>
</small></blockquote>
</td></tr></table>
<br>

<!-- -------------------------------- SOUND EFFECTS -------------------------------- -->
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="sssoundeffects">sound effects</a></h3></td></tr></table>

<p>Most of these sound effects are based on CLM generators.
</p>
<pre>
  <em class=def>echo</em> scaler secs
  <em class=def>zecho</em> scaler secs frq amp      ; modulated echo
  <em class=def>flecho</em> scaler secs             ; filtered echo
  <em class=def>ring-mod</em> freq gliss-env        ; ring-modulation
  <em class=def>am</em> freq                        ; amplitude modulation
  <em class=def><A NAME="exhellodentist">hello-dentist</a></em> frq amp          ; randomized sampling rate changes
  <em class=def><A NAME="exfp">fp</a></em> sr osamp osfrq              ; osc-driven src ("Forbidden Planet")
  <em class=def>compand</em>
  <em class=def><a name="excompandchannel">compand-channel</a></em> beg dur snd chn edpos
  <em class=def><A NAME="exexpsrc">expsrc</a></em> rate snd chn
  <em class=def><A NAME="exexpsnd">expsnd</a></em> rate-envelope
  <em class=def><a name="excrosssynthesis">cross-synthesis</a></em> cross-snd amp fftsize radius
  <em class=def><a name="exvoiced2unvoiced">voiced-&gt;unvoiced</a></em> amp fftsize r tempo
  <em class=def>cnvtest</em> snd0 snd1 amp
  <em class=def>"vector synthesis"</em>	
  <em class=def>chained-dsps</em> beg dur #:rest dsps
</pre>
<p><b>expsrc</b> uses sampling rate conversion (the src gen) and granular synthesis (granulate)
to lengthen or shorten a sound without changing its pitch.  The same idea is used in the effects menu.
<b>expsnd</b> is the same but the
change follows an envelope.  In <b>cross-synthesis</b>, <i>cross-snd</i> is the index
of the sound that controls the spectra, not the affected sound.  <b>voiced-&gt;unvoiced</b>
is essentially the same idea, but drives the synthesis with white noise.
<b>cnvtest</b> demonstrates convolution.
Here are some sample calls:
</p>
<pre>
(map-chan (echo .5 .5) 0 44100)
(map-chan (zecho .5 .75 6 10.0) 0 65000)
(map-chan (flecho .5 .9) 0 75000)
(map-chan (ring-mod 100 '(0 0 1 0)))
(map-chan (ring-mod 10 (list 0 0 1 (hz-&gt;radians 100))))
(map-chan (am 440))
(hello-dentist 40.0 .1)
(fp 1.0 .3 20)
(map-chan (compand))
(expsnd '(0 1 2 .4))
(expsnd '(0 .5 2 2.0))
(map-chan (cross-synthesis 1 .5 128 6.0))
(voiced-&gt;unvoiced 1.0 256 2.0 2.0)
(cnvtest 0 1 .1)
</pre>
<p>There are lots more sound effects scattered around the Snd distribution.
"vector synthesis" cycles through a collection of incoming audio streams, playing whatever
happens to be on the chosen one, with fade-ins and fade-outs to avoid clicks.
<b>chain-dsps</b> creates a patch of chained generators from its arguments.
</p>


<!-- -------------------------------- MISCELLANEOUS EXTENSIONS -------------------------------- -->
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="ssmiscellaneousextensions">miscellaneous extensions</a></h3></td></tr></table>

<pre>
  <em class=def>finfo</em> filename
  <em class=def>shell</em> cmd
  <em class=def><a name="exmpg">mpg</a></em> mpgfile rawfile 
  <em class=def>read-ogg</em> file
  <em class=def>write-ogg</em> snd
</pre>
<p><b>finfo</b> returns a description of the file <i>filename</i>. <b>shell</b> is similar
to Guile's <i>system</i> function, but output is sent to Snd's listener, rather than stdout.
<b>mpg</b> uses the system function to call the program mpg123 to translate an MPEG
format sound file to a headerless ("raw") file containing 16-bit samples.
</p>
<pre>
(shell "df")
(add-hook! close-hook (lambda (snd) (shell \"sndplay wood16.wav\")))
(mpg "mpeg.mpg" "mpeg.raw")
</pre>
<p>
Presumably a similar function could be written to call TiMidity to translate
MIDI files to something Snd can read, but I'm not having any luck getting it
to work. OGG Vorbis files can be handled in a similar manner: read-ogg and
write-ogg are examples.
</p>
<p>
Several of the functions in this section are slight robustifications of the
corresponding code in extsnd.html.  These include:
</p>
<pre>
  <em class=def>do-chans</em> func origin
  <em class=def>do-all-chans</em> func origin
  <em class=def>do-sound-chans</em> func origin
  <em class=def>update-graphs</em>
  <em class=def><a name="exeverysample">every-sample?</a></em> func
  <em class=def>sort-samples</em> bins
  <em class=def><a name="exwindowsamples">window-samples</a></em> <i>snd chn</i>
  <em class=def>display-energy</em> snd chn y0 y1
  <em class=def>window-rms</em>
  <em class=def>fft-peak</em> snd chn scale
</pre>
<p>
<b>do-chans</b> applies <i>func</i> to all syncd channels using <i>origin</i> as the edit history indication.
<b>do-all-chans</b> is the same but applies <i>func</i> to all active channels.
<b>do-sound-chans</b> applies <i>func</i> to all selected channels.
<b>update-graphs</b> updates (redraws) all graphs.
<b>every-sample?</b> applies <i>func</i> to each sample in the current channel and returns
#t if <i>func</i> is not #f for all samples; otherwise it moves the cursor to the first offending sample.
<b>sort-samples</b> provides a histogram of the samples (by amplitude) in <i>bins</i> bins.
<b>window-samples</b> returns (via the function <a href="extsnd.html#sndsamples">samples</a>) the samples
displayed in the current window for <i>snd</i>'s channel <i>chn</i>.
<b>display-energy</b> is a graph-hook function to display the time domain data squared.
<b>window-rms</b> returns the rms of the data in currently selected graph window.
<b>fft-peak</b> is a transform-hook function that returns the peak spectral magnitude.
</p>
<pre>
  <em class=def>locate-zero</em> limit
</pre>
<p>
<b>locate-zero</b> looks for the next sample where adjacent samples together are less than <i>limit</i>
and moves the cursor to that sample. It can be interrupted by C-g.
</p>
<pre>
  <em class=def>make-sound-interp</em> start #:optional snd chn
  <em class=def><a name="exsoundinterp">sound-interp</a></em> reader loc
  <em class=def><a name="exenvsoundinterp">env-sound-interp</a></em> envelope #:optional (time-scale 1.0) snd chn
</pre>
<p><b>make-sound-interp</b> returns an interpolating reader for <i>snd</i>'s channel <i>chn</i>.
The interpolating reader reads a channel at an arbitary location,
interpolating between samples if necessary.  The corresponding generator is <b>sound-interp</b>.
The function <b>test-interp</b> shows one way to use this, using a sine wave to lookup the
current sound.
<b>env-sound-interp</b> reads <i>snd</i>'s channel <i>chn</i> (via a sound-interp generator)
according to <i>envelope</i> and <i>time-scale</i>.
It takes an envelope that goes between 0 and 1 (y-axis), and a time-scaler
(1.0 = original length) and returns a new version of the data in the specified channel
that follows that envelope (that is, when the envelope is 0 we get sample 0, when the
envelope is 1 we get the last sample, envelope = .5 we get the middle sample of the 
sound and so on). <code>(env-sound-interp '(0 0 1 1))</code> returns a copy of the
current sound; <code>(env-sound-interp '(0 0 1 1 2 0) 2.0)</code> returns a new sound 
with the sound copied first in normal order, then reversed.  src-sound with an
envelope could be used for this effect, but it is much more direct to apply the
envelope to sound sample positions.  A similar function is <a href="#scratch">scratch</a> in clm-ins.scm.
</p>
<pre>
  <em class=def><A NAME="exsearchforclick">search-for-click</a></em>
  <em class=def><A NAME="exzeroplus">zero+</a></em>
  <em class=def>next-peak</em>
  <em class=def>find-pitch</em> pitch
</pre>
<p>These are examples of searching procedures (to be used with C-s and so on).  <b>zero+</b> finds the next
positive-going zero crossing (if searching forwards), <b>next-peak</b> finds
the next max or min in the waveform, and <b>find-pitch</b> finds the next
place where the given pitch is predominate.
</p>
<pre>
  <em class=def>sound-data-&gt;list</em> sdata
</pre>
<p>This converts a sound-data object into a list of lists, each inner list
holding the samples of one channel.
</p>
<pre>
  <em class=def>smooth-channel-via-ptree</em> #:optional beg dur snd chn edpos
</pre>
<p>This is <a href="extsnd.html#smoothchannel">smooth-channel</a> as a virtual op.
</p>
<br>

<A NAME="extensionsdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>extensions.scm</h2></td></tr></table>

<p>These were originally scattered around examp.scm; I thought it would be more
convenient if they were in one file.
</p>

<pre>
  <em class=def><a name="exchannelproperty">channel-property</a></em> key snd chn
  <em class=def><a name="exsoundproperty">sound-property</a></em> key snd

  <em class=def><a name="exmakeselection">make-selection</a></em> #:optional beg end snd chn
  <em class=def><a name="exdeleteselectionandsmooth">delete-selection-and-smooth</a></em>
  <em class=def><a name="exevaloverselection">eval-over-selection</a></em> func snd
  <em class=def><a name="exselectionmembers">selection-members</a></em>

  <em class=def><a name="exmapsoundfiles">map-sound-files</a></em> func #:optional dir
  <em class=def><a name="exforeachsoundfile">for-each-sound-file</a></em> func #:optional dir
  <em class=def><a name="exmatchsoundfiles">match-sound-files</a></em> func #:optional dir

  <em class=def><a name="exnormalizedmix">normalized-mix</a></em> filename beg in-chan snd chn
  <em class=def><a name="exenvelopedmix">enveloped-mix</a></em> filename beg env
  <em class=def>enveloped-mix-1</em> filename beg env

  <em class=def><a name="exunsavededits">check-for-unsaved-edits</a></em> #:optional (on #t)
  <em class=def><a name="exremembersoundstate">remember-sound-state</a></em>

  <em class=def><a name="mixchannel">mix-channel</a></em> filedat beg dur snd chn edpos
  <em class=def><a name="insertchannel">insert-channel</a></em> filedat beg dur snd chn edpos
  <em class=def><a name="redochannel">redo-channel</a></em> edits snd chn
  <em class=def><a name="undochannel">undo-channel</a></em> edits snd chn
</pre>

<p><b>channel-property</b> returns the value associated with <i>key</i> in the given channel's
property list.  To add or change a property, use set! with this procedure.  Similarly,
<b>sound-property</b> provides access to a sound's property list.
These properties are normally saved when Snd's state is saved (via <a href="extsnd.html#sndsavestate">save-state</a>
or the Options:Save State menu).  To omit a given property at that time, add its name (a symbol) to
the property 'save-state-ignore (a list of symbols); see 'inset-envelope in extensions.scm.
</p>

<p><b>selection-members</b> returns a list of lists of (snd chn) indicating the channels participating in the current selection.
It is very similar to <b>all-chans</b> which returns a list of lists of all (snd chn)'s.
<b>delete-selection-and-smooth</b> deletes the current selection and smooths the splice.
</p>

<p><b>eval-over-selection</b> evaluates <i>func</i> on each sample in the current selection. A better
name might be map-selection.
The code:
</p>
<pre>
(bind-key (char-&gt;integer #\x) 4
	  (lambda ()
	    (if (selection?)
		(prompt-in-minibuffer "selection eval:" eval-over-selection)
		(report-in-minibuffer "no selection")))
	  #t)
</pre>
<p>binds the key sequence C-x x to a function that checks for an active selection,
then prompts (in the minibuffer) for the function to apply, and when
you eventually reply with a function, applies that function
to each sample in the selection.
make-selection makes a selection (like make-region but without creating
a region).
</p>
<p>
<b>map-sound-files</b> applies <i>func</i> to each sound file in <i>dir</i>.
<b>match-sound-files</b> applies <i>func</i> to each sound file in <i>dir</i> and returns a list of files for which func does not return #f.
</p>
<pre>
(for-each-sound-file
  (lambda (n) 
    (if (&gt; (mus-sound-duration n) 10.0) 
      (snd-print n)))
  (sound-files-in-directory "."))
</pre>
<p>We can use Guile's regexp support here to search for all .snd and .wav files:
</p>
<pre>
(let ((reg (make-regexp "\\.(wav|.snd)$")))
  (match-sound-files (lambda (file) (regexp-exec reg file))))
</pre>
<p>In fact, we could replace the built-in procedures <A NAME="addsoundextension1">add-sound-file-extension</a> and
sound-files in directory.  We're using some procedures written by Dirk Herrman here.
</p>
<pre>
(define (filter-list pred? objects)
  (let loop ((objs objects)
	     (result '()))
    (cond ((null? objs) (reverse! result))
	  ((pred? (car objs)) (loop (cdr objs) (cons (car objs) result)))
	  (else (loop (cdr objs) result)))))

(define (grep rx strings)
  (let ((r (make-regexp rx)))
    (filter-list (lambda (x) (regexp-exec r x)) strings)))

(define (directory-&gt;list dir)
  (let ((dport (opendir dir)))
    (let loop ((entry (readdir dport))
	       (files '()))
      (if (not (eof-object? entry))
	  (loop (readdir dport) (cons entry files))
	  (begin
	    (closedir dport)
	    (reverse! files))))))

;;; and now the Snd replacements
(define sound-file-extensions (list "snd" "aiff" "aif" "wav" "au" "aifc" "voc" "wve"))

(define (add-sound-file-extension-1 ext) 
  (set! sound-file-extensions (cons ext sound-file-extensions)))

(define* (sound-files-in-directory-1 #:optional (dir "."))
  (sort (grep
	 (format #f "\\.(~{~A~^|~})$" sound-file-extensions)
	 (directory-&gt;list dir))
	string&lt;?))
</pre>

<p><b>normalized-mix</b> is like <a href="extsnd.html#sndmix">mix</a> but the mixed result has same peak amplitude as the 
original data. <b>enveloped-mix</b> is like <a href="#mixsound">mix-sound</a>, but includes an
amplitude envelope over the mixed-in data.
</p>
<pre>
(enveloped-mix "pistol.snd" 0 '(0 0 1 1 2 0))
</pre>
<p><b>check-for-unsaved-edits</b> adds functions to the exit-hook and close-hook to check
for unsaved edits before exiting Snd or closing a file.  If its argument is #f, it removes
those hooks.
</p>
<p><b>remember-sound-state</b> saves most of a sound's display state when it is closed,
and if that same sound is subsquently re-opened, restores the previous state.
</p>

<p><b>mix-channel</b> is a regularized version of the file mixing functions (mix and mix-sound).
It's first argument can be either a filename (a string) or a list containing the filename, the
start point in the file, and (optionally) the channel of the file to mix:
</p>
<pre>
  (mix-channel "pistol.snd")
  (mix-channel "pistol.snd" 10000)       ; mixing starts at sample 10000 in current sound
  (mix-channel (list "pistol.snd" 1000)) ; mixed data starts at sample 1000 in pistol.snd
  (mix-channel (list "2.snd" 0 1))       ; mixed data reads channel 1 in 2.snd
</pre>
<p><b>insert-channel</b> is the same as mix-channel, but inserts the specified data.
</p>

<p><b>redo-channel</b> and <b>undo-channel</b> are regularized versions of
<a href="extsnd.html#sndredo">redo</a> and <a href="extsnd.html#sndundo">undo</a>.
</p>
<br><br>


<A NAME="fadedoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>fade.scm</h2></td></tr></table>

<p>
The two instruments in fade.scm perform frequency-domain cross-fades, that is, the
cross-fade is handled by a bank of bandpass filters (formant generators).  The effect
is sometimes only slightly different from a normal (time-domain) cross-fade, but
there are some interesting possibilities ("sound evaporation", etc).
</p>

<A NAME="fmvdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>fmv.scm</h2></td></tr></table>

<p>fmv.scm implements the fm-violin (v.scm) as a CLM-style generator, making it possible
to call the violin anywhere a generator could be called; since each call on the fm-violin
function produces the next sample of the given violin, this form of the fm-violin is easy
to call in "real-time" situations.  Any other CLM-style instrument could
be rewritten in the same form.
</p>
<pre>
  <em class=def>make-fm-violin</em>
    frequency amplitude #:key (fm-index 1.0) (amp-env #f) (periodic-vibrato-rate 5.0) (random-vibrato-rate 16.0)
    (periodic-vibrato-amplitude 0.0025) (random-vibrato-amplitude 0.005) (noise-amount 0.0) (noise-freq 1000.0)
    (ind-noise-freq 10.0) (ind-noise-amount 0.0) (amp-noise-freq 20.0) (amp-noise-amount 0.0) (gliss-env #f)
    (fm1-env #f) (fm2-env #f) (fm3-env #f) (fm1-rat 1.0) (fm2-rat 3.0) (fm3-rat 4.0) (fm1-index #f) (fm2-index #f) 
    (fm3-index #f) (base 1.0) #:allow-other-keys

  <em class=def>fm-violin</em> gen
  <em class=def>fm-violin-ins</em> [same args as original violin in v.scm]
</pre>
<p><i>fm-violin-ins</i> shows how this generator can be fitted into the original fm-violin code.
The <b>make-fm-violin</b> function uses the optional arguments support from Guile (optargs.scm, loaded
via <code>(use-modules (ice-9 optargs))</code>). The plethora of arguments is an historical artifact;
normally only a few of them are used at a time.  There are two examples of calling this generator
in fmv.scm, the simpler one being:
</p>
<pre>
(define test-v 
  (lambda (beg dur freq amp amp-env)
    (let ((v (make-fm-violin 
	      freq amp 
	      :amp-env (let ((e (make-env :envelope (or amp-env '(0 0 1 1 2 0)) 
					  :scaler amp 
					  :end dur)))
			 (lambda () (env e)))))
	  (data (samples-&gt;vct beg dur)))
      (do ((i 0 (1+ i)))
	  ((= i dur))
	(vct-set! data i (+ (vct-ref data i)
			    (v))))
      (set-samples beg dur data))))
</pre>
<p>Here we are setting up an fm-violin generator (via make-fm-violin), then
calling it <i>dur</i> times, mixing its output into the current data (this could
also use mix-vct and so on).  The generator is called via <code>(v)</code>.
As can be seen here, each envelope is treated as a function called on each sample
very much like the "as-needed" input in src or granulate; the envelopes could actually be any
arbitrary function you like (see test-v1 in fmv.scm which uses an oscillator as one of
the fm index envelopes).  One complication in some "real-time" situations is that
you don't know in advance how long a note will be; in this case, the envelope
generating functions should have attack and decay ramps, triggered by note-on and
note-off; once the ramp has reached its end point, the end value should be held;
the note itself should be called until it has had time to ramp off; an exercise
for the interested reader.
</p>

<A NAME="freeverbdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>freeverb.scm, freeverb.rb</h2></td></tr></table>

<p>These are translations by Michael Scholz of CLM's freeverb.ins.
</p>

<A NAME="goopsnddoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>goopsnd.scm</h2></td></tr></table>

<p>goopsnd.scm goofs around with goops, the Guile Object System.  As it stands, it
might provide simple examples of goops syntax, but I'm not sure it's of any value
yet. 
Fabio Furlanete's rmsgain.scm uses goops.
</p>



<A NAME="hooksdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>hooks.scm</h2></td></tr></table>
<pre>
  <em class=def>describe-hook</em> hook
  <em class=def>remove-local-hook!</em> hook func
  <em class=def><a name="withlocalhook">with-local-hook</a></em> hook local-hook-procs thunk
  <em class=def><a name="resetallhooks">reset-all-hooks</a></em>
  <em class=def>snd-hooks</em>
  <em class=def>hook-member</em> func hook
</pre>
<p>hooks.scm has various hook-related functions.
<b>describe-hook</b> tries to decipher the functions on the hook list.
<b>remove-local-hook!</b> is a kludge to get around a bug in Guile's remove-hook! function;
it makes it possible to remove a locally-defined function from a hook.
<b>with-local-hook</b> is a kind of "let" for hooks.  <b>snd-hooks</b> returns
a list of all Snd-specific hooks; this is used by <b>reset-all-hooks</b> which
returns all hooks to the empty state. 
<b>hook-member</b> returns #t if <i>func</i> is already on the hook list.
</p>

<A NAME="indexdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>index.scm, index.rb</h2></td></tr></table>
<pre>
  <em class=def>*html-reader*</em> "mozilla"
  <em class=def>html</em> obj
  <em class=def>?</em> obj
</pre>
<p>index.scm provides a connection between mozilla or netscape
and the Snd documentation.  The index itself is
built by index.cl, then accessed through the <b>html</b> and <b>?</b> functions.
<code>(html arg)</code> where arg can be a string, symbol, or procedure sends mozilla to the corresponding url
in the Snd documents.
<code>(? obj)</code> prints out any help it can find for obj, and tries to find obj in the documentation.
The function that actually passes the url to the reader is <a href="extsnd.html#sendnetscape">send-netscape</a>.
</p>

<A NAME="jcrevdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>jcrev.scm</h2></td></tr></table>
<p>
jc-reverb is a reverberator developed by John Chowning a long time ago
(I can't actually remember when -- before 1976 probably). It "colors" the
sound much more than <a href="clminsdoc">nrev</a>, and has noticeable echos,
but I liked the effect a lot.  new-effects.scm has a version of jc-reverb
that run as a normal snd editing function (via map-channel), whereas the
jcrev.scm version assumes it is being called within with-sound:
</p>
<pre>
(with-sound (:reverb jc-reverb) 
  (fm-violin 0 .1 440 .1 :reverb-amount .1))
</pre>
<p>It is possible to use the CLM/with-sound reverbs (or any such instrument) as
an ordinary editing function:
</p>

<pre>
(if (not (defined? '*output*)) (load-from-path "ws.scm"))
(define* (clm-reverb-sound reverb-amount reverb #:optional (reverb-data '()) snd)
  (let ((output (snd-tempnam))
	(revout (snd-tempnam))
	(len (+ (frames snd) (srate snd))))
    (scale-by (- 1.0 reverb-amount) snd)
    (save-sound-as output snd)
    (undo 1 snd)
    (scale-by reverb-amount snd)
    (save-sound-as revout snd)
    (undo 1 snd)
    (set! *output* (continue-sample-&gt;file output))
    (set! (mus-srate) (srate snd))
    (set! *reverb* (make-file-&gt;sample revout))
    (apply reverb reverb-data)
    (mus-close *reverb*)
    (mus-close *output*)
    (delete-file revout)
    (set! (samples 0 len snd #f #f #f 0 #f #t) output)))

;;; (clm-reverb-sound .1 (lambda (dur) (jc-reverb #f 1.0 #f dur)))
</pre>
<p>Another approach to this problem would be to use <a href="extsnd.html#snd2sample">snd-&gt;sample</a> to
redirect the *reverb* input (without any change to the reverberator),
getting its data from the current sound (probably after scaling it
by the reverb amount). 
</p>
<br>

<!-- INDEX reverbexamples:Reverb -->
<A NAME="reverbexamples"></a>
<TABLE border=3 bordercolor="tan" hspace=40><tr><td>
<blockquote><small>
<br>
Reverbs in Snd<br>
freeverb: <a href="#freeverbdoc">freeverb.scm, freeverb.rb</a><br>
jc-reverb: <a href="#jcrevdoc">jcrev.scm</a><br>
jl-reverb: <a href="#clminsdoc">clm-ins.scm</a><br>
nrev: <a href="#clminsdoc">clm-ins.scm</a><br>
control panel reverb: <a href="snd.html#reverb">Reverb</a>, <a href="extsnd.html#reverbdecay">control variables</a><br>
convolution reverb: <a href="extsnd.html#sndconvolvewith">conrev</a><br>
plate-reverb: ladspa.scm (a LADSPA effect)<br>
*reverb*: <a href="#wsdoc">with-sound</a><br>
<br>
</small></blockquote>
</td></tr></TABLE>
<br>

<A NAME="ladspadoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>ladspa.scm</h2></td></tr></table>

<p>This file takes your LADSPA library and builds a set of dialogs
to control and preview each effect.  The related help strings are in ladspa-help.scm.
</p>


<A NAME="maracadoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>maraca.scm</h2></td></tr></table>

<p>This file has a translation to Snd/Scheme of Perry Cook's maraca physical model.
</p>

<A NAME="marksdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>marks.scm</h2></td></tr></table>

<p>marks.scm is a collection of mark-related functions.</p>

<pre>
  <em class=def><a name="markname2id">mark-name-&gt;id</a></em> name
  <em class=def><a name="describemark">describe-mark</a></em> id
  <em class=def><A NAME="syncup">syncup</a></em> ids
  <em class=def><A NAME="fitselectionbetweenmarks">fit-selection-between-marks</a></em> m1 m2
  <em class=def><a name="padmarks">pad-marks</a></em> ids secs
  <em class=def><A NAME="movesyncdmarks">move-syncd-marks</a></em> sync samples-to-move
  <em class=def><a name="playsyncdmarks">play-syncd-marks</a></em> sync
  <em class=def><a name="exevalbetweenmarks">eval-between-marks</a></em> func snd
  <em class=def><A NAME="exsnapmarks">snap-marks</a></em>
  <em class=def><a name="exdefineselectionviamarks">define-selection-via-marks</a></em> m1 m2
  <em class=def><a name="exsnapmarktobeat">snap-mark-to-beat</a></em>
  <em class=def><a name="exmarkexplode">mark-explode</a></em>
  <em class=def><a name="markproperty">mark-property</a></em> key id
  <em class=def><A NAME="markclickinfo">mark-click-info</a></em> id
  <em class=def><A NAME="savemarkproperties">save-mark-properties</a></em>
</pre>

<p><b>mark-name-&gt;id</b> is like <a href="extsnd.html#sndfindmark">find-mark</a> but searches all currently accessible channels.
</p><p><b>describe-mark</b> returns a description of the movements of mark id over the channel's edit history:
</p>
<pre>
:<em class=typing>(describe-mark 0)</em>
<em class=listener>((mark 0 sound 0 "oboe.snd" channel 0) 654 478)</em>
</pre>
<p>Here I placed a mark in oboe.snd at sample 654, then deleted a few samples
before it, causing it to move to sample 478.
</p><p><b>pad-marks</b> inserts <i>secs</i> seconds of silence before each in a list of marks (<i>ids</i>).
</p><p><b>fit-selection-between-marks</b> tries to squeeze the current selection between two marks,
using the granulate generator to fix up the selection duration (this still is not perfect).
</p><p><b>syncup</b> synchronizes a list of marks by inserting silences as needed.
</p><p><b>move-syncd-marks</b> moves any marks sharing the sync value <i>sync</i> by
<i>samples-to-move</i> samples.  Similarly, <b>play-syncd-marks</b> starts
playing from all marks sharing its <i>sync</i> argument.
</p>
<p>marks.scm also has code that tries to make it simpler to sync marks together
(see <b>start-sync</b> and <b>stop-sync</b>), and <b>report-mark-names</b>
that causes any named mark to display its name in the minibuffer when 
the underlying sample happens to be played.  There are also many mark-related
functions in examp.scm and scattered around the documentation.
</p>
<p><b>eval-between-marks</b> evaluates <i>func</i>
between the leftmost marks in <i>snd</i>.
</p>
<pre>
(bind-key (char-&gt;integer #\m) 0 
	  (lambda ()
	    (prompt-in-minibuffer "mark eval:" eval-between-marks)))
</pre>
<p><b>snap-marks</b> places marks at the start and end of the current selection.
</p><p><b>define-selection-via-marks</b> selects the portion between the given marks.
</p><p><b>snap-mark-to-beat</b> forces a dragged mark to end up on a beat.
</p><p><b>mark-explode</b> splits a sound into a bunch of separate files based on mark placements.
</p><p><b>mark-property</b> associates a property list with each mark.
There is also some code (look for "eval-header") that saves mark info in the
sound file header, and reads it when the file is subsequently reopened.
</p><p><b>mark-click-info</b> is a mark-click-hook function that describes a mark and its properties.  It
is used by with-marked-sound in ws.scm.
</p><p><b>save-mark-properties</b> sets up an <a href="extsnd.html#aftersavestatehook">after-save-state-hook</a> function to save any mark-properties.
</p>
<br>

<A NAME="maxfdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>maxf.scm, maxf.rb</h2></td></tr></table>

<p>These files are translations (thanks to Michael Scholz!) of CLM's maxf.ins
(thanks to Juan Reyes!). They implement a new kind of resonator designed by
Max Mathews.
</p>


<A NAME="mixdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>mix.scm</h2></td></tr></table>

<p>mix.scm provides various mix and track related utilities. 

</p>
<pre>
  <em class=def><a name="mixsound">mix-sound</a></em> file start
  <em class=def><a name="mixproperty">mix-property</a></em> key id
  <em class=def><A NAME="mixclicksetsamp">mix-click-sets-amp</A></em>
  <em class=def><a name="mix2vct">mix-&gt;vct</a></em> id
  <em class=def><a name="panmix">pan-mix</a></em> file (frame 0) (env 1.0) snd
  <em class=def><a name="snapmixtobeat">snap-mix-to-beat</a></em> (at-anchor)
  <em class=def><A NAME="deleteallmixes">delete-all-mixes</a></em>
  <em class=def><a name="findmix">find-mix</a></em> sample snd chn
  <em class=def><A NAME="mixmaxamp">mix-maxamp</a></em> id
  <em class=def><A NAME="savemix">save-mix</a></em> id filename
</pre>
<p>
<b>mix-sound</b> mixes <i>file</i> (all chans) into the currently selected sound at <i>start</i>.
<b>mix-&gt;vct</b> returns the current samples
of mix <i>id</i> (taking into account its current amplitude an so on). 
<b>pan-mix</b>
mixes <i>file</i> into the current sound starting at <i>frame</i> using the envelope <i>env</i>
to pan the mixed samples (0: all chan 1, 1: all chan 0).
The resultant mixes (if more than one) are placed in their own track, and the
track amp env is interpreted as a panning envelope.
To tie this into C-x C-q, in place of the default "mix" function,
</p>
<pre>
(bind-key (char-&gt;integer #\q) 4 ; C-q
	  (lambda ()
	    (prompt-in-minibuffer "mix:" (lambda (str) ; use pan-mix at cursor
					   (<em class=red>pan-mix</em> str (or (cursor) 0)) #f #t)))
	  #t  ; an extended (C-x) command
          "C-x C-q")
</pre>
<p>
<b>snap-mix-to-beat</b> forces a dragged mix to end up on a beat.
If <i>at-anchor</i> is #t, the anchor point, rather than the mix beginning falls on the beat.
<b>mix-property</b> associates a property list with each mix.
<b>track-property</b> associates a property list with each track.
<b>mix-click-sets-amp</b> uses the property lists to keep track of
whether the next click should set the mix amps to zero, or to the
pre-zero value.
<b>find-mix</b> returns the identifier of the mix at sample <i>sample</i> (or anywhere in the given channel if 
<i>sample</i> is not specified), or #f if no mix is found.
<b>mix-maxamp</b> returns the maxamp in the given mix.
<b>save-mix</b> saves a given mix's data in a file.
</p>
<center><img src="pan.png" alt="picture of panning"></center>
<pre>
  <em class=def><a name="track2vct">track-&gt;vct</a></em> track (chan 0)
  <em class=def><a name="savetrack">save-track</a></em> track filename (chan #t)
  <em class=def><a name="transposetrack">transpose-track</a></em> track semitones
  <em class=def><A NAME="retempotrack">retempo-track</a></em> track tempo
  <em class=def><a name="reversetrack">reverse-track</a></em> track
  <em class=def><a name="filtertrack">filter-track</a></em> track coeffs
  <em class=def>delete-all-tracks</em>
  <em class=def><a name="trackproperty">track-property</a></em> key id
  <em class=def><A NAME="trackmaxamp">track-maxamp</a></em> id chan
</pre>
<p>
<b>track-&gt;vct</b> places all the mix samples
in the track into a vct.  Similarly, <b>save-track</b> places the track's samples into a file.
If the 'chan' arg is #t, all channels are saved.
<b>retempo-track</b> affects the time between the successive mix begin points (tempo &gt; 1.0 makes the
mixes happen more quickly):
</p>
<pre>
:<em class=typing>(retempo-track (track 1) 2.0)</em>
<em class=listener>(1500 7770)</em>
:<em class=typing>(mix-position 0)</em>
<em class=listener>1500</em>
:<em class=typing>(mix-position 1)</em>
<em class=listener>7770</em>
:<em class=typing>(+ 1500 (* .5 (- 14039 1500))) ; 14039 is the former mix 1 begin time (see above)</em>
<em class=listener>7769.5</em>
</pre>
<p>
<b>filter-track</b> applies a filter to each mix sound at the pre-mix point (that is, the
mixed in sound is filtered, then the mix takes place).
<b>reverse-track</b> reverses the order in which a track's member mixes occur.
<b>track-maxamp</b> returns the maxamp in the given track.
</p>


<A NAME="moogdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>moog.scm</h2></td></tr></table>
<pre>
  <em class=def>make-moog-filter</em> frequency Q
  <em class=def><a name="moogfilter">moog-filter</a></em> gen input
</pre>
<p>moog.scm is a translation of CLM's moog.lisp (written by Fernando Lopez-Lezcano --
http://www-ccrma.stanford.edu/~nando/clm/moog),
itself a translation of Tim Stilson's original C code.  The functions provide
a kind of CLM generator view of the filter.  Fernando describes it as a
"Moog style four pole lowpass (24db/Oct) filter clm unit generator,
variable resonance, warm, analog sound ;-)". <!-- ( -->
In <b>make-moog-filter</b> "frequency" is the cutoff frequency
in Hz (more or less) and "Q" is the resonance: 0 = no resonance,
1 causes the filter to oscillate at frequency.  My translation is
a bit simple-minded; with a little effort, this could run much
faster.
</p>
<pre>
  (define (moog freq Q)
    (let ((gen (<em class=red>make-moog-filter</em> freq Q)))
      (lambda (inval)
        (<em class=red>moog-filter</em> gen inval))))

  (map-chan (moog 1200.0 .7))
</pre>
<p>The Ruby version of this is in examp.rb.
</p>

<A NAME="musglyphs"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>musglyphs.scm</h2></td></tr></table>

<p>musglyphs.scm provides Scheme/Snd wrappers to load CMN's cmn-glyphs.lisp (directly!),
thereby defining most of the standard music notation symbols.  Each of the original
functions (e.g. draw-bass-clef) becomes a Snd/Scheme procedure of the form
<code>(name #:optional x y size style snd chn context)</code>. 
<code>(draw-bass-clef 100 100 50)</code> draws a bass clef in the current graph
at position (100 100) of size 50; since the <i>style</i> argument defaults to
#f, the clef is displayed as a filled polygon; use #t to get an outline of
the clef instead.  You need CMN, or at least the CMN file cmn-glyphs.lisp
before loading this file.
</p>
<img src="sndcmn.png" alt="Snd with music symbols">
<br>
<p>(The dot size bug in this picture has been fixed, but I'm too lazy
to make a new version of the picture).
</p>
<br>

<A NAME="nbdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>nb.scm, nb.rb</h2></td></tr></table>

<p>nb.scm provides popup help for files in the View:Files dialog; as you move
the mouse through the lists, the help dialog posts information about the file
underneath the mouse.  This uses a slightly fancier file information procedure
than 'finfo' in examp.scm.  If you have the guile-gdbm package, you can use
its database procedures to associate arbitrary information with files which
will be posted along with the header info:
</p>
<pre>
  <em class=def>nb</em> file note
  <em class=def>unb</em> file
  <em class=def>prune-db</em>
</pre>
<p><code>(nb "test.snd" "this is a test")</code> adds the note "this is a test" to
the data associated with "test.snd".  <code>(unb "test.snd")</code> erases anything
associated with "test.snd".  <code>(prune-db)</code> erases anything associated with
any files that no longer exist.  (nb.scm will work fine without guile-gdbm; to load
guile-gdbm, set the variable <b>use-gdbm</b> to #t).
</p>
<p>Michael Scholz's translation of this to Ruby is included in examp.rb.
</p>

<A NAME="noisedoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>noise.scm, noise.rb</h2></td></tr></table>

<p>The noise files are translations (thanks to Michael Scholz) of CLM's noise.ins.
noise.ins has a very long pedigree; I think it dates back to about 1978.  It can produce
those all-important whooshing sounds.
</p>


<A NAME="peakenvdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>peak-env.scm</h2></td></tr></table>

<p>The functions in peak-env.scm provide relatively robust access to
peak envelope files.  These files save Snd's overall amplitude envelopes
for a given sound so that a subsequent re-open of that sound has the
waveform immediately.  For very large sounds, this can save as much as
a minute during which Snd is running the amplitude envelope builders
in the background and displaying whatever it can.  That is, it makes
opening a large sound much faster after the initial read and save.
The file has a variable <b>save-peak-env-info</b> (default #t) which
determines whether these envelopes are being saved.  The procedure
</p>
<pre>
(define (peak-env-info-file-name snd chn)	
  (format #f "~A/~A-peaks-~D" save-peak-env-info-directory (short-file-name snd) chn))
</pre>
<p>determines the saved peak env file name; in the default
case, it looks for the directory ~/peaks, but obviously this
could be changed to suit your situation.
</p>

<A NAME="pianodoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>piano.scm, piano.rb</h2></td></tr></table>

<p>These files are translations of CLM's piano.ins, a piano physical
model by Scott van Duyne.
</p>

<A NAME="playdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>play.scm</h2></td></tr></table>

<p>These functions play sounds in various ways.</p>
<pre>
  <em class=def><A NAME="explaysound">play-sound</A></em> <i>func</i>
</pre>
<p><b>play-sound</b> plays the current sound, calling (func data) on each buffer if func is passed.
It is also an example of calling the low level mus-audio functions, rather than calling
play-channel and friends. The latter are easier to use, in most cases.
To set up the keyboard
as a kind of extended piano, we could map keys to sounds:
</p>
<pre>
(bind-key (char-&gt;integer #\o) 0 (lambda () (play "oboe.snd")))
(bind-key (char-&gt;integer #\p) 0 (lambda () (play "pistol.snd")))
</pre>
<p>The various play hooks can be used to play sounds over and over. 
</p>
<pre>
  <em class=def><A NAME="explayoften">play-often</A></em> times
  <em class=def><A NAME="explayuntilcg">play-until-c-g</A></em>
  <em class=def><A NAME="explayregionforever">play-region-forever</a></em> region

(bind-key (char-&gt;integer #\p) 0 (lambda (n) (play-often (max 1 n))))
(bind-key (char-&gt;integer #\r) 0 (lambda (n) (play-region-forever (max 0 n))))
</pre>
<p>Now C-u 31 p plays the current sound 31 times; C-u 3 r plays region 3 until we type C-g.
<b>play-often</b> uses stop-playing-hook, and <b>play-region-forever</b> uses stop-playing-region-hook.
With a sufficiently fast computer, it's possible to create the samples to be played 
in "real-time".  <b>play-fun</b> starts and stops the DAC, <i>ampit</i> and <i>amprt</i>
fill up the audio buffer with data.
</p>
<pre>
(play-fun (ampit (frames) 2.0) 256)
</pre>
<p>scales sound 0's samples by 2 and sends them to the DAC. (These three functions are now obsolete).
More useful is:</p>
<pre>
  <em class=def><A NAME="exloopbetweenmarks">loop-between-marks</a></em> mark1 mark2 buffer-size
</pre>
<p>which loops continuously between the two specified marks.
The marks can be moved as the sound is played; C-g stops loop-between-marks.
If you want the DAC to be held open in the background,
</p>
<pre>
  <em class=def><A NAME="exstartdac">start-dac</A></em>
  <em class=def>stop-dac</em>
</pre>
<p>The vector-synthesis 
idea (and weird name) came from a linux-audio-development mailing list.
Apparently some commercial synths (or software?) provide this.
It reads any number of sound files, using a function to
decide which one to send to the DAC.
</p>



<A NAME="popupdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>popup.scm and gtk-popup.scm</h2></td></tr></table>
<pre>
  <em class=def><a name="addselectionpopup">add-selection-popup</a></em> 
  <em class=def><a name="addlistenerpopup">add-listener-popup</a></em> 
</pre>
<p>
gtk-popup.scm is the Gtk/xg version; popup.scm is Motif/xm based.
<b>add-selection-popup</b> creates a selection-oriented popup menu that is
posted if you click button3 in the selected portion, as well as a time-domain popup
menu, and an fft-specific menu.
<b>add-listener-popup</b> creates a listener-oriented popup menu that is
posted if you click button3 in the listener.
</p>


<A NAME="prc95doc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>prc95.scm</h2></td></tr></table>

<!-- INDEX prc95doc:Physical Models -->
<p>prc95.scm is a translation to Snd of Perry Cook's (1995) physical modelling toolkit; prc-toolkit95.lisp 
in CLM.  One starting point for physical modelling is Smith, "Music Applications of Digital Waveguides", CCRMA, Stan-M-39, 1987,
or Julius's <a href="http://www-ccrma.stanford.edu/~jos">home</a> page, or
any of several classic papers also by Julius Smith.  Perry's own version of this code can be
found in <a href="www-ccrma.stanford.edu/CCRMA/Software/STK/">STK</a>.
The example instruments are:
</p>
<pre>
  <em class=def>plucky</em> beg dur freq amplitude maxa
  <em class=def>bow</em> beg dur frq amplitude maxa
  <em class=def>brass</em> beg dur freq amplitude maxa
  <em class=def>clarinet</em> beg dur freq amplitude maxa
  <em class=def>flute</em> beg dur freq amplitude maxa

(define (test-prc95)
  (plucky 0 .3 440 .2 1.0)
  (bow .5 .3 220 .2 1.0)
  (brass 1 .3 440 .2 1.0)
  (clarinet 1.5 .3 440 .2 1.0)
  (flute 2 .3 440 .2 1.0))
</pre>

<table border=3 bordercolor="tan" hspace=40><tr><td>
<blockquote><small>
<br>
See also:<br>
maraca: <a href="#maracadoc">maraca.scm</a><br>
piano: <a href="#pianodoc">piano.scm, piano.rb</a><br>
singer: <a href="#singerdoc">singer.scm</a><br>
bowed string: <a href="#straddoc">strad.scm, strad.rb</a><br>
flute: <a href="#clminsdoc">clm-ins.scm</a><br>
string: <a href="#excomputeuniformcircularstring">compute-string</a><br>
plucked string: pluck in clm-ins.scm<br>
plate-reverb: ladspa.scm<br>
<br>
</small></blockquote>
</td></tr></table>
<br>

<A NAME="pvocdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>pvoc.scm</h2></td></tr></table>
<p>
This is the same as the CLM phase-vocoder generator, but implemented in Scheme.  If you're interested
in how the thing works, I think the Scheme version is easiest to understand; the Common Lisp version 
is in mus.lisp, and the C version is in clm.c.
</p>
<pre>
  <em class=def>make-pvocoder</em> fftsize overlap interp analyze edit synthesize
  <em class=def>pvocoder</em> gen input
  <em class=def>pvoc</em> #:key (fftsize 512) (overlap 4) (time 1.0) (pitch 1.0) (gate 0.0) (hoffset 0.0) (snd 0) (chn 0)
</pre>
<p>The <i>analyze</i>, <i>edit</i>, and <i>synthesize</i> arguments to make-pvocoder are
functions that are applied as needed during pvocoder processing; similarly, the <i>input</i>
argument to pvocoder can be a function.
pvoc.scm also contains a few examples of using the CLM phase-vocoder generator:
</p>
<pre>
(define test-pv-4
  (lambda (gate)
    (let ((pv (make-phase-vocoder #f
				  512 4 128 1.0
				  #f ;no change to analysis
				  (lambda (v)
				    (let ((N (mus-length v)))
				      (do ((i 0 (1+ i)))
					  ((= i N))
					(if (&lt; (vct-ref (pv-amp-increments v) i) gate)
					    (vct-set! (pv-amp-increments v) i 0.0)))
				      #t))
				  #f ;no change to synthesis))
	  (reader (make-sample-reader 0)))
      (map-chan (lambda (val)
		  (phase-vocoder pv (lambda (dir) 
				      (reader)))))
      (free-sample-reader reader))))
</pre>
<p>sets up a phase-vocoder generator whose edit function is squelching soft partials.
In this case, the input function is reading the currently selected channel.  The fastest
way to try out this generator is to use it as the argument to filter-sound.
<i>pvoc</i> is yet another a phase-vocoder;
it applies the phase-vocoder (i.e. fft analysis, oscil bank resynthesis)
to the current sound; <i>pitch</i> specifies the pitch transposition ratio, 
<i>time</i> specifies the time dilation ratio,
<i>gate</i> specifies a resynthesis gate in dB (partials with amplitudes lower than
the gate value will not be synthesized), <i>hoffset</i> is a pitch offset in Hz.
</p>

<A NAME="rgbdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>rgb.scm</h2></td></tr></table>
<p>rgb.scm (rgb.rb) is a simple translation of the standard X11 color names into Snd
color objects.
</p>
<pre>
(define snow (make-color 1.00 0.98 0.98))
</pre>
<p>is taken from the line</p>
<pre>
255 250 250             snow
</pre>
<p>/usr/lib/X11/rgb.txt.  The choice of a float between 0.0 and 1.0 (rather
than an integer between 0 and 255) mimics PostScript;
as video hardware has improved over the years, there's
less and less need for these elaborate color names, and less
reason (except perhaps psychophysical) to limit these numbers to bytes.
There is one gotcha in this file -- X11 defines a color named "tan"
which is already used by Scheme, so (at the suggestion of Dave Phillips)
this color is named "tawny" in rgb.scm.
</p>

<A NAME="rtiodoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>rtio.scm</h2></td></tr></table>

<p>rtio.scm has a collection of functions oriented loosely around
"real-time" operations.
</p>
<pre>
  <em class=def>show-input</em> #:optional (in-sys 0)
  <em class=def><A NAME="exshowinputfft">show-input-fft</a></em> #:optional (in-sys 0)
  <em class=def><A NAME="exshowdraggableinputfft">show-draggable-input-fft</a></em> #:optional (in-sys 0)
  <em class=def>in-out</em> func in-sys out-sys
</pre>
<p>These three functions show how to read incoming data (from the adc),
write data (to the dac), and interpose a function while reading and
writing data.  There are several example functions (for the "func" argument) that filter the data or
change its amplitude. <b>show-input-fft</b> displays the input data's
spectrum.  <b>show-draggable-input-fft</b> is the same, but the X axis
(the frequency axis in this case) is draggable, as in Snd's FFT display.
</p>

<A NAME="rubberdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>rubber.scm, rubber.rb</h2></td></tr></table>

<pre>
  <em class=def><a name="rubbersound">rubber-sound</a></em> stretch-factor
</pre>
<p>
<b>rubber-sound</b> tries to stretch or contract a sound (in time); it scans the sound
looking for stable (periodic) sections, then either deletes periods or interpolates new ones
to shorten or lengthen the sound.  It still needs a lot of robustification.
The algorithm is 1) remove all frequencies below 16 Hz, 2) resample the file to be
ten times longer (interpolating samples), 3) make a list of upward zero crossings,
4) using autocorrelation decide where the next fundamental zero crossing probably
is and see how much difference there is between the current period and the next,
5) check intermediate crossing weights and if the autocorrelation weight is not
the smallest, throw away this crossing, 6) sort the remaining crossings by least weight,
7) interpolate or delete periods until the sound has been sufficiently lengthened or
shortened.
<!-- ((((((( --><!-- this matches the preceding open parens for index.cl's benefit -->
</p>

<A NAME="singerdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>singer.scm</h2></td></tr></table>

<p>singer.scm is a translation of CLM's singer.ins.  It implements
a physical model of the vocal tract described in
</p>
<pre>
  Cook, Perry R. "Synthesis of the Singing Voice Using a Physically Parameterized Model of the Human Vocal Tract"
     Published in the Proceedings of the International Computer Music Conference, Ohio 1989 
     and as Stanford University Department of Music Technical Report Stan-M-57, August 1989.
 
 ---- "Identification of Control Parameters in an Articulatory Vocal Tract Model, with Applications 
    to the Synthesis of Singing," Ph.D. Thesis, Stanford University Department of Music Technical Report 
    Stan-M-68, December 1990.

 ----  "SPASM, a Real-time Vocal Tract Physical Model Controller; and Singer, the Companion Software 
    Synthesis System", Computer Music Journal, vol 17 no 1 Spring 1993.
</pre>
<p>
There are a couple example calls at the end of the instrument code.
</p>


<A NAME="snd4doc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>snd4.scm</h2></td></tr></table>

<p>The Snd-4 compatibilty file contains a number of the procedures
that were removed from or renamed in Snd-5.  
</p>

<A NAME="snd5doc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>snd5.scm</h2></td></tr></table>

<p>The Snd-5 compatibilty file contains a number of the procedures
that were moved from C to Scheme during Snd-5 development.
</p>
<table border=0 cellspacing=10>
<!-- backward-sample -->
<tr><td colspan=2>
<span class=defbox><code><em class=def>backward-sample</em> (<i>count snd chn</i>)</code></span>
</td></tr>
<tr><td></td><td>
move back <i>count</i> samples (C-b), return new cursor position.
</td></tr>
<tr><td colspan=2></td></tr>

<!-- forward-sample -->
<tr><td colspan=2>
<span class=defbox><code><em class=def>forward-sample</em> (<i>count snd chn</i>)</code></span>
</td></tr>
<tr><td></td><td>
move forward <i>count</i> samples (C-f), return new cursor position.
</td></tr>
<tr><td colspan=2></td></tr>
</table>

<table border=0 cellspacing=5>
<!-- vct-do! -->
<tr><td><span class=defbox><code><em class=def>vct-do!</em> (vobj proc)</code></span></td>
<td><code>vobj[i] = (funcall proc i)</code>.</td></tr>

<!-- vcts-do! -->
<tr><td><span class=defbox><code><em class=def>vcts-do!</em> (vobj... proc)</code></span></td>
<td><code>vobj[vi][i] = (nth vi (funcall proc num i))</code>.</td></tr>

<!-- vcts-map! -->
<tr><td><span class=defbox><code><em class=def>vcts-map!</em> (vobj... proc)</code></span></td>
<td><code>vobj[vi][i] = (nth vi (funcall proc num))</code>.</td></tr>

</table>

<p><b>vct-do!</b>
is the same as <b>vct-map!</b> except that the called function should take one
argument, the current loop index.  Similarly, <b>vcts-map!</b> and <b>vcts-do!</b>
take any number of vcts, followed by a trailing function, and map the function's
results (assumed to be a list that matches the current number of vcts) into the
vct array.  In the map! case, the function takes one argument, the current number
of vcts awaiting values; in the do! case, it takes two arguments, the vct
number and the current loop index.
</p>

<A NAME="snd6doc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>snd6.scm</h2></td></tr></table>

<p>As with snd5.scm and snd4.scm, snd6.scm has functions that provide
backwards compatibility within version 6.
Currently, these are just some old (untypable) constant names,
and some slightly inconsistent old function names.
</p><p><b><a name="sndclearaudioinputs">clear-audio-inputs</a></b>
in Linux/OSS, tries to reduce soundcard background racket.
</p><p><b><a name="sndappendtominibuffer">append-to-minibuffer</a></b> (msg <i>snd</i>)
appends <i>msg</i> to whatever is in <i>snd</i>'s minibuffer.
</p><p><b>dismiss-all-dialogs</b> deactivates all active dialogs.
</p><p><b><a name="mixname">mix-name</a></b> asociates a name with a mix, and
<b><a name="mixname2id">mix-name-&gt;id</a></b> returns the id given a mix name.
</p>


<A NAME="sndgldoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>snd-gl.scm</h2></td></tr></table>

<p>snd-gl.scm has examples of using OpenGL.
</p>
<pre>
  <em class=def>gl-info</em>
  <em class=def><a name="startwaterfall">start-waterfall</a></em> #:optional (scl 1.0) (pc-spectrum 0.2) (fft-size 512)
  <em class=def>stop-waterfall</em>
  <em class=def>gl-dump-state</em>
</pre>
<p><b>gl-info</b> prints out information about the current GL system setup.  <b>start-waterfall</b> starts a
waterfall spectrum display of the incoming audio data.  <b>stop-waterfall</b> turns it off.
<b>gl-dump-state</b> displays much of the current GL graphics state.
</p>

<A NAME="sndmotifdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>snd-motif.scm</h2></td></tr></table>

<pre>
  <em class=def>install-searcher</em> proc
  <em class=def>zync</em> 
  <em class=def><a name="foreachchild">for-each-child</a></em> w func
  <em class=def>make-hidden-controls-dialog</em> 
  <em class=def>create-fmv-dialog</em> 
  <em class=def>make-pixmap</em> strs
  <em class=def>display-scanned-synthesis</em> 
  <em class=def>disable-control-panel</em> 
  <em class=def><a name="addmarkpane">add-mark-pane</a></em> 
  <em class=def>select-file</em> func <i>title dir filter help</i>
  <em class=def>snd-clock-icon</em> snd hour
  <em class=def><a name="makesoundbox">make-sound-box</a></em> name parent select-func peak-func sounds args
  <em class=def>show-sounds-in-directory</em> (dir ".")
  <em class=def><a name="showsmptelabel">show-smpte-label</a></em> on-or-off
  <em class=def>make-level-meter</em> parent width height
  <em class=def>show-disk-space</em>
  <em class=def>keep-file-dialog-open-upon-ok</em>
  <em class=def>add-amp-controls</em>
  <em class=def>add-very-useful-icons</em>
  <em class=def><A NAME="adddeleteoption">add-delete-option, add-rename-option</a></em>
  <em class=def>mark-sync-color</em> new-color
  <em class=def>add-tooltip</em> widget tip
  <em class=def>menu-option</em> menu-name
  <em class=def>show-all-atoms</em>
  <em class=def>make-channel-drop-site</em> snd chn
  <em class=def>set-channel-drop</em> drop snd chn
  <em class=def>show-font-name</em> font
  <em class=def>show-widget-font</em>
  <em class=def>add-find-to-listener</em>
  <em class=def><A NAME="uponsaveyourself">upon-save-yourself, upon-take-focus</a></em>
  <em class=def>add-text-to-status-area</em>
  <em class=def><a name="makevariabledisplay">make-variable-display</a></em> page-name variable-name (type 'text) (range (list 0.0 1.0))
  <em class=def><a name="variabledisplay">variable-display</a></em> val widget
  <em class=def>with-minmax-button</em>
  <em class=def>set-root-window-color</em> color
  <em class=def>notebook-with-top-tabs</em>
</pre>
<!-- INDEX variabledisplay:Debugging (instruments) -->
<p>snd-motif.scm has procedures that rely on the Motif module (xm.c).
Some of these have been translated to Gtk and xg.c -- snd-gtk.scm.
</p><p>
<b>install-searcher</b> places
our own search procedure into the filter mechanism in the File:Open
dialog. </p><p>The pair <b>zync</b> and <b>unzync</b> cause the
y-axis zoom sliders of a multi-channel file to move together or separately.
</p><p><b>make-hidden-controls-dialog</b> adds "Hidden controls" to the Option
menu.  If you click it, it
creates a dialog that controls all the hidden control-panel variables.
The "expand-hop" control sets the hop size (per grain), "expand-length"
sets the grain length, "expand-ramp" sets the slope of the grain amplitude envelope,
"contrast-amp" sets the prescaler for the contrast effect, "reverb-feedback" sets the feedback
amount in the reverberator (it sets all the comb filter scalers), and "reverb-lowpass" sets
the lowpass filter coefficient in the reverberator. 
</p><p><b>create-fmv-dialog</b> sets up a very simple dialog with amplitude control on
the fm-violin (fmv.scm) running (interpreted!) in "real-time".
</p><p><b>make-pixmap</b> turns an xpm-style description into pixmap.
</p><p><b>display-scanned-synthesis</b> opens a pane for experimenting with scanned synthesis.
</p><p><b>disable-control-panel</b> does away with the control panel.
</p><p><b>add-mark-pane</b> adds a pane to each channel giving the current mark locations (sample values).
These can be edited to move the mark, or deleted to delete the mark.
</p><p><b>select-file</b> starts a file selection dialog, running <i>func</i> if a file is selected:
</p>
<pre>
 (add-to-menu 0 "Insert File" 
   (lambda () 
     (select-file 
       (lambda (filename)
         (insert-sound filename))
       "Insert File" "." "*" "file will be inserted at cursor")))
</pre>
<p><b>snd-clock-icon</b> replaces Snd's hourglass with a clock.
</p><p><b>make-sound-box</b> makes a container of sound file icons, each icon
containing a little sketch of the waveform, the length of the
file, and the filename.  What happens when an icon is selected
is up to the caller-supplied procedure.  However, if you drag (via 
button 2) the icon to the menubar, that sound will be opened,
and if you drag it to a channel graph, it will be mixed at the
mouse location in that channel.
</p>
<pre>
(make-sound-box "sounds"
		(list-ref (main-widgets) 3)
		(lambda (file) 
                  (snd-print file))
		peak-env-info-filename ; this points to ~/peaks in my case
		(list "oboe.snd" "pistol.snd" "cardinal.snd" "storm.snd")
		'())
</pre>
<p><b>show-sounds-in-directory</b> calls make-sound-box, filling it with
any sounds found in the directory passed as its argument, defaulting to 
the current directory.
</p>
<img src="soundbox.png" alt="show-sounds-in-directory">

<p><b>show-smpte-label</b> shows the current SMPTE frame number in a box
in the upper left corner of the graph.
</p><p><b>make-level-meter</b> creates A VU meter of any width and height, returning
a list of information associated with that meter.  Pass that list to 
<b>display-level</b> to move the needle and the red bubble.  This meter
assumes you'll call it periodically so that the momentum of the needle and the viscosity of
the bubble will appear to behave naturally.  <b>with-level-meters</b> adds
any number of these meters to the topmost pane in the Snd main window,
then adds various <a href="extsnd.html#dachook">dac-hook</a> functions to display the current playback volume
in the respective meter.  
</p><p><b>show-disk-space</b> adds a label in the
minibuffer area which shows the current amount of disk space available
on the partition of the associated sound.
</p><p><b>keep-file-dialog-open-upon-ok</b> changes File:Open so that clicking "ok" does not unmanage (dismiss) the dialog.
</p><p><b>add-amp-controls</b> adds amp sliders to the control panel
for multi-channel sounds (each channel gets its own amp control slider).
</p><p><b>add-rename-option</b> adds a "Rename" option to the File menu; similarly
<b>add-delete-option</b> adds a "Delete" option.
</p><p><b>mark-sync-color</b> uses the <a href="extsnd.html#drawmarkhook">draw-mark-hook</a> to set the color of sync'd marks.
</p><p><b>add-tooltip</b> adds a tooltip (also known as bubble-help) to a widget.  Once added,
set the variable <b>with-tooltips</b> to #f to turn it off.
</p><p><b>menu-option</b> returns the widget associated with a given menu item name ("Print" for example).
</p><p><b>show-all-atoms</b> displays (via Guile's <i>display</i>) all current X atom names.
</p><p><b>make-channel-drop-site</b> shows how to add a drop site panel to a channel.  
<b>set-channel-drop</b> changes the channel's graph's drop function to <i>drop</i>, a 
function of 3 arguments, the dropped filename (a string) and the current sound index and
channel number.
</p><p><b>show-font-name</b> shows the Snd-related name and the X-related name of each font in a font list
(it searches for the XA_FULL_NAME associated with an XFontStruct).
<b>show-widget-font</b> uses that function to show what fonts are associated with a widget.
</p><p><b>add-find-to-listener</b> activates C-s and C-r in the listener via a separate dialog.
</p><p><b>upon-save-yourself</b> causes a thunk (a function of no args) to be called if the window
manager sends a SAVE_YOURSELF message; similarly <b>upon-take-focus</b> causes a thunk to be called
whenever Snd receives focus from the window manager.
</p><p><b>add-text-to-status-area</b> puts a text widget in the notebook's status area
(the lower left portion of the main Snd window when using the -notebook invocation switch).
It returns the widget; you can write to it via XmTextFieldSetString.
</p>

<p><b>make-variable-display</b> sets up a display point for an arbitrary expression which
is updated via <b>variable-display</b>.  The latter returns its argument, so it acts as a sort of
probe, picking out any arbitrary point in an instrument and displaying it as the
instrument is running.  Display points can be organized as pages in a notebook
widget:
</p>
<pre>
(define wid (make-variable-display "do-loop" "i*2" 'text))
(define wid1 (make-variable-display "do-loop" "i" 'text))
(do ((i 0 (1+ i)))
    ((= i 10))
  (variable-display (* (variable-display i wid1) 2) wid))
</pre>
<p>The 'graph and 'spectrum cases create legitimate Snd channel displays,
accessible via a sound index (and channel 0); these respond to the
various channel-related functions such as <a href="extsnd.html#showfftpeaks">show-transform-peaks</a>,
although you have to give the sound index explicitly:
</p>
<pre>
(define wid2 (make-variable-display "do-loop" "x" 'spectrum))
(set! (show-transform-peaks (car wid2)) #t)
</pre>
<p>Each graph or spectrum display is placed in its own pane (this is a desperate
kludge), whereas all the others are ordered vertically in a single pane.
The 'scale choice has an additional argument that gives the range of the
scale as a list (low high):
</p>
<pre>
(define wid2 (make-variable-display "do-loop" "i*2" 'scale '(-1.0 1.0)))
</pre>
<p>You can watch a generator's state on a sample-by-sample basis by
putting it in a text display:
</p>
<pre>
(define wid1 (make-variable-display "do-loop" "beg" 'text))
(define wid2 (make-variable-display "do-loop" "oscil" 'text))
(definstrument (simp)
  (let* ((beg 0)
	 (dur 1000)
	 (end (+ beg dur))
	 (osc (make-oscil 440.0)))
    (do ((i beg (1+ i)))
	((= i end))
      (variable-display i wid1)
      (oscil (variable-display osc wid2) 0.0))))
(simp)
</pre>
<p>variable-display doesn't work within the run macro, but if you're debugging
an instrument, you're presumably not primarily concerned with optimization.
</p>
<p><b>with-minmax-button</b> adds an open/close button to each sound's pane.
<b>set-root-window-color</b> sets the background color of the root window.
<b>notebook-with-top-tabs</b> originally changed an existing notebook window (assuming Snd
was started with the -notebook switch) so that its orientation mimics
Xemacs, but that's now the default. 
</p>
<br>

<A NAME="sndtestdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>snd-test.scm and event.scm</h2></td></tr></table>
<p>
snd-test.scm is a test suite for Snd. The simplest use is:
</p>
<pre>
snd -l snd-test
</pre>
<p>
which will run all the tests, assuming you have the various sound files it is expecting to find.
event.scm has some XEvent-related functions used by snd-test.scm.  The Ruby version (very incomplete) is
snd_test.rb.
</p>

<A NAME="straddoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>strad.scm, strad.rb</h2></td></tr></table>

<p>strad.scm is a translation (by Michael Scholz) of CLM's strad.ins (by Juan Reyes).
It implements a physical model of a bowed string with stiffness.
</p>


<A NAME="spectrdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>spectr.scm, spectr.rb: instrument steady state spectra</h2></td></tr></table>

<p>The spectr files were translated by Michael Scholz from CLM's spectr.clm.  They contain a large 
set of instrument steady-state spectra, gathered many years ago (before 1976) by James A Moorer.
The variable names are taken from the file names used by JAM, but by the time I got around to
rescuing the data from mouldering magtapes, he had long since moved on, so I don't actually
know what instrument some of the labels refer to. 
</p>
<br>

<A NAME="vdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>v.scm</h2></td></tr></table>

<p>The fm violin was my favorite instrument while working in the 70's and 80's,
primarily on the Samson box.  It was developed in Mus10 (ca 1977) based on ideas of John Chowning;
a Mus10 version was (in this code ":=" is used in place of the original SAIL left arrow character,
and so on):
</p>
<pre>
ARRAY GlissFunc, DecayFunc, AttackFunc, SineWave, AmpFunc(512);
SYNTH(Sinewave); 1,1 999;
SEG(AmpFunc); 0,0 1,25 1,50 0,75 0,100;
SEG(GlissFunc);0,1 1,50, 0,100;
SEG(AttackFunc);0,0 1,100;
SEG(DecayFunc);1,1 .6,5 .3,10 .15,25 .07,50 0,100;
	
INSTRUMENT VN1;
VARIABLE Reset1,Noise,/NewMag,OtherFreq,/Gliss,Distance,Stereo,
	Freq,Amp1,Amp2,Duration,AttackTime,DecayTime,Memory1,
	Index1,Index2,Index3,scFreq,DecayLength,Switch1,Switch2,
	/Mod1,/Mod2,/Mod3,/Env,/Att,/Vibrato,IMult,/Snd,
	/Flutter,VibRate,VibAmp,/Ramp,/Decay,VibSwitch,LogFreq,
	GlissLength,Bowing,DecayCall,VibCall,GlissCall,RampCall;
	
Memory1:=1;
	
I_ONLY BEGIN
  Duration:=P2;
  Freq:=P3;
  Amp1:=P4;
  Amp2:=P5;
  OtherFreq:=P6;
  IF Freq&gt;=C THEN Freq:=Freq+Freq/100;
  IF Freq&lt;C THEN Freq:=Freq-20/Freq;
	
  Switch1:=P14;
  Switch2:=1-Switch1;
  IMult:=P7-(Switch2/4);
  VibSwitch:=P8;
  Bowing:=P9;
	
  Distance:=P10;
  Stereo:=P11;
  Noise:=P12;
  GlissLength:=P13;
  LogFreq:=ALOG(Freq);
  
  DecayCall:=VibCall:=RampCall:=GlissCall:=20;
  IF Amp1=Amp2 THEN RampCall:=SRATE;
  IF Freq=OtherFreq THEN GlissCall:=SRATE;
  IF VibSwitch=0 THEN VibCall:=SRATE;
  IF Switch1=1 THEN DecayCall:=SRATE;
	
  Vibrate:=5.25+RAND*.75;
  VibAmp:=.006+RAND*.001;
	
  IF Bowing=0
    THEN
      IF Memory1&gt;.08
	THEN
	  BEGIN
	  DecayTime:=.7;
	  AttackTime:=.2;
	  END
	ELSE
	  BEGIN
	  DecayTime:=.7;
	  AttackTime:=.05;
	  Noise:=0;
	  END
    ELSE
      IF Memory1&gt;.05
	THEN
	  BEGIN
	  DecayTime:=.05;
	  AttackTime:=.2;
	  END
	ELSE
	  BEGIN
	  DecayTime:=.05;
	  AttackTime:=.05;
	  Noise:=0;
	  END;
	
  Memory1:=DecayTime;
	
  IF AttackTime+DecayTime&gt;=Duration
    THEN
      BEGIN
      AttackTime:=Duration*AttackTime;
      DecayTime:=DecayTime*Duration;
      IF AttackTime&lt;=.05 THEN AttackTime:=Duration-DecayTime-.01;
      END;
	
  ScFreq:=Freq*MAG;
  DecayLength:=1000/Freq;
  IF Switch1=0 THEN Noise:=.1;
  Index1:=7.5*IMult/LogFreq;
  Index2:=5/SQRT(Freq);
  Index3:=IMult*30*(8.5-LogFreq)/Freq;
END;
	
Decay:=Switch1+EXPEN[DecayCall](Switch2,MAG*20/DecayLength,DecayFunc);
ENV:=Switch2+LINEN[20](Switch1,AttackTime/20,DecayTime/20,Duration/20,AmpFunc,Reset1:=0);
Ramp:=Amp1+NOSCIL[RampCall](Amp2-Amp1,20*MAG/Duration,AttackFunc);
Gliss:=Freq+EXPEN[GlissCall](OtherFreq-Freq,20*MAG/GlissLength,GlissFunc);
FLutter:=RANDI[VibCall](1,200*Mag);
Vibrato:=NOSCIL[VibCall](ENV,Vibrate*MAG*20,SineWave);
Att:=1-EXPEN[20](1,MAG*640,AttackFunc);
	
NewMag:=(1+Flutter*.005)*(1+Vibrato*VibAmp)*(1+RANDI(Noise*Att,2000*Mag))*Gliss*Mag;
	
Mod1:=NOSCIL(Decay*ScFreq*(Att+Index1),NewMag,Sinewave);
Mod2:=NOSCIL(Decay*ScFreq*(Att+Index2),4*NewMag,Sinewave);
Mod3:=NOSCIL(Decay*ScFreq*(Att+Index3),3*NewMag,Sinewave);
Snd:=ZOSCIL(Decay*ENV*Ramp,NewMag+Mod1+Mod2+Mod3,Sinewave);
OUTA:=OUTA+Snd*0.5;
END;
</pre>
<p>
This instrument required about 60 seconds of computing on a PDP-10
(a $250,000 minicomputer) for 1 second of sound (our normal sampling
rate was 12800).  Since the PDP was massively time-shared, 60 seconds
of computing could involve many minutes of sitting around watching
AI scientists play Space War.
Mus10 was an extension of Music V for the PDP-10 family of computers.
To give a feel for how one worked in those days, here's a brief quote from the Mus10 manual (by Tovar and
Leland Smith, May 1977):
</p>
<pre>
The following generates  1 second of a  440 Hz sine wave  followed by
1/2 sec. of a  660Hz sine wave. The output goes to a file, MUSIC.MSB,
which is written on DSKM.  

COMMENT Fill array with sine wave;
ARRAY SINETABLE[511];
FOR I:=0 STEP 1 UNTIL 511 DO SINETABLE[I]:=SIN(2*PI/512);

INSTRUMENT SINE;
  COMMENT Generate simple sine wave.  P4 = Amplitude, P3 = frequency;
  OUTA:=OUTA+OSCIL(P4,P3*MAG,SINETABLE);
  END;

COMMENT Now, generate the sound;
PLAY ;
  SIMP 0, 1, 440, 1000;
  SIMP 1, 1/2, 660, 1000;
  FINISH;
</pre>
<p>
The computation involved was considered so burdensome, that the names of
the main users were posted in the AI lab halls, apparently to try to
get us to go away.  I was normally the primary user (in terms of computrons) for the entire lab, and I had no intention
of going away.  
In the Samson box world, this (in its initial "chorus" version) was:</p>
<pre>
Instrument(Violin);
RECORD_POINTER(seg) nullfunc;
INTEGER ARRAY gens[1:4],indgens[1:6], GensA[1:4],AmpGens[1:2];
					! synthesizer addresses;
REAL ARRAY ratsA[1:4],Indrats[1:6],ratsB[1:4],AmpRats[1:2];
					! envelope data;
INTEGER ModGens1Sum,i,FuncOffSet,k,GenOutLoc,GenInLoc,ModGens2Sum,x1,x2;

Pars(&lt;(InsName,Beg,Dur,Freq,Amp,Function AmpFunc,Function IndFunc,IndMult,
	SkewMult,Nothing,PcRev,No11,No12,No13,Function SkewFunc)&gt;);
					! the parameters of this instrument;

Dbugit(Pns);				! debugging aid;
GenOutLoc:=CASE (Pn[1] MOD 4) OF (Outma,Outmb,Outmc,Outmd);
					! OUTMA is channel 1, OUTMB channel 2, etc;
if freq&gt;srate/3 then return;		! note too high, so leave it out;
x1:=3;					! modulating frequency checks;
x2:=4;					! (we want them less than srate/2);
If x1*freq&gt;srate/2 Then x1:=1;
If x2*freq&gt;srate/2 then x2:=1;
amp:=Amp/2;				! two carriers, so halve the amplitude;

waiter(Beg);				! wait for the beginning of the note;

indRats[1]:=(x1*Freq*IndMult*((8.5-log(freq))/(3+(freq/1000)))*4/srate) MIN .999;
indRats[2]:=(x2*Freq*IndMult*(1/(freq^.5))*4/srate) MIN .999;
indRats[3]:=(freq*IndMult*(5/log(freq))*4/srate) MIN .999;
indrats[4]:=indrats[1]; indrats[5]:=indrats[2]; indrats[6]:=indrats[3];

ratsA[1]:=x1; ratsA[2]:=x2;     ratsA[3]:=1;     ratsA[4]:=1;	
ratsB[1]:=x1+.002; ratsB[2]:=x2+.003;     ratsB[3]:=1.002;     ratsB[4]:=1;	
					! this is the skewing for the chorus effect;
Gens[1]:=Osc(Pns,ModGens1Sum);		! now set up the oscillators;
Gens[2]:=Osc(Pns,ModGens1Sum);
Gens[3]:=Osc(Pns,ModGens1Sum);
Gens[4]:=Osc(Pns,genInLoc,ModGens1Sum);	! carrier 1;

GensA[1]:=Osc(Pns,ModGens2Sum);
GensA[2]:=Osc(Pns,ModGens2Sum);
GensA[3]:=Osc(Pns,ModGens2Sum);
GensA[4]:=Osc(Pns,genInLoc,ModGens2Sum);! carrier 2;

indgens[1]:=gens[1];   indgens[2]:=gens[2];  indgens[3]:=gens[3];
indgens[4]:=gensA[1];   indgens[5]:=gensA[2];  indgens[6]:=gensA[3];
					! set up envelope addressing;

ModSig(Pns,GenOutLoc,GenInLoc,1-pcRev);	! send signal to DACs;
ModSig(Pns,RevIn,GenInLoc,pcRev);	! and signal to reverberator;

AmpGens[1]:=Gens[4]; AmpGens[2]:=GensA[4]; AmpRats[1]:=1; AmpRats[2]:=1;
					! now add the envelopes;
AddArrEnv(Pns,AmpGens,2,"A",0,Amp/2,AmpFunc,AmpRats);
AddArrEnv(Pns,IndGens,6,"A",0,1,IndFunc,Indrats);
AddArrEnv(Pns,Gens,4,"F",freq,Freq*skewmult,skewfunc,ratsA,
	5,.011,.011,nullfunc,6,.017,.017,nullfunc,0,0);
AddArrEnv(Pns,GensA,4,"F",freq,Freq*skewmult,skewfunc,ratsA,
	6,.010,.010,nullfunc,5,.017,.017,nullfunc,1,0);
End!Instrument(Pns);			! deallocation;
</pre>
<p>
The Sambox version eventually became incredibly complicated, mainly to
try to handle note list problems in the instrument.  The Samson box could
run about 5 or 6 of these in "real-time", similar to a modern-day
500 MHz Pentium running CLM.
The parallel in the Sambox world to the SIMP example above is (this is
taken from SAMBOX.BIL, November 1984):</p>
<pre>
    Instrument(Simp);
    Integer Gen1;
    Gen1:=Osc(Pns,OutA,Zero,SineMode,0,0,Pn[3]);
    AddEnv(Pns,Gen1,"A",0,Pn[4],Pf[5]);
    End_Instrument(Pns);
</pre>
<p>The CLM version of this is:</p>
<pre>
(definstrument simp (start-time duration frequency amplitude
                     &amp;optional (amp-env '(0 0 50 1 100 0)))
  (multiple-value-bind (beg end) (times-&gt;samples start-time duration)
    (let ((s (make-oscil frequency))
          (amp (make-env amp-env :scaler amplitude :duration duration)))
      (run
       (loop for i from beg below end do
         (outa i (* (env amp) (oscil s))))))))
</pre>
<p>
In CLM, the fm-violin became (fm.html, 1989):</p>
<pre>
(definstrument violin (beg end frequency amplitude fm-index)
  (let* ((frq-scl (in-hz frequency))
         (maxdev (* frq-scl fm-index))
         (index1 (* maxdev (/ 5.0 (log frequency))))
         (index2 (* maxdev 3.0 (/ (- 8.5 (log frequency)) (+ 3.0 (/ frequency 1000)))))
         (index3 (* maxdev (/ 4.0 (sqrt frequency))))
         (carrier (make-oscil frequency))
         (fmosc1 (make-oscil frequency))
         (fmosc2 (make-oscil (* 3 frequency)))
         (fmosc3 (make-oscil (* 4 frequency)))
         (ampf  (make-env '(0 0 25 1 75 1 100 0) :scaler amplitude))
         (indf1 (make-env '(0 1 25 .4 75 .6 100 0) :scaler index1))
         (indf2 (make-env '(0 1 25 .4 75 .6 100 0) :scaler index2))
         (indf3 (make-env '(0 1 25 .4 75 .6 100 0) :scaler index3))
         (pervib (make-triangle-wave :frequency 5 :amplitude (* .0025 frq-scl)))
         (ranvib (make-randi :frequency 16 :amplitude (* .005 frq-scl)))
         (vib 0.0))
    (run
     (loop for i from beg to end do
       (setf vib (+ (triangle-wave pervib) (randi ranvib)))
       (outa i (* (env ampf)
                  (oscil carrier
                         (+ vib 
                            (* (env indf1) (oscil fmosc1 vib))
                            (* (env indf2) (oscil fmosc2 (* 3.0 vib)))
                            (* (env indf3) (oscil fmosc3 (* 4.0 vib)))))))))))
</pre>
<p>or in its actual (non-simplified) form:
</p>
<pre>
(defun bit20 (x)			;Samson box modifier got 2's complement 20 bit interpreted as fraction 
  (if (&gt;= x (expt 2 19))                ;(this needed to keep fm-violin backwards compatible with old note lists)
      (float (/ (- x (expt 2 20)) (expt 2 19)))
    (float (/ x (expt 2 19)))))

(defun make-frobber-function (beg end frobl)
  (let ((result (list beg))
	(val (bit20 (cadr frobl))))
    (loop for x in frobl by #'cddr and 
              y in (cdr frobl) by #'cddr do
      (when (and (&gt;= x beg)
		 (&lt;= x end))
	(push val result)
	(push x result)
	(setf val (bit20 y))))
    (push val result)
    (push end result)
    (push val result)
    (nreverse result)))

(definstrument fm-violin 
  (startime dur frequency amplitude &amp;key
	    (fm-index 1.0)
	    (amp-env '(0 0  25 1  75 1  100 0))
	    (periodic-vibrato-rate 5.0) 
            (random-vibrato-rate 16.0)
	    (periodic-vibrato-amplitude 0.0025) 
            (random-vibrato-amplitude 0.005)
	    (noise-amount 0.0) (noise-freq 1000.0)
	    (ind-noise-freq 10.0) (ind-noise-amount 0.0)
	    (amp-noise-freq 20.0) (amp-noise-amount 0.0)
	    (gliss-env '(0 0  100 0)) (glissando-amount 0.0) 
	    (fm1-env '(0 1  25 .4  75 .6  100 0)) 
            (fm2-env '(0 1  25 .4  75 .6  100 0)) 
            (fm3-env '(0 1  25 .4  75 .6  100 0))
	    (fm1-rat 1.0) (fm2-rat 3.0)	 (fm3-rat 4.0)                    
	    (fm1-index nil) (fm2-index nil) (fm3-index nil)
	    (base nil) (frobber nil)
	    (reverb-amount 0.01)
	    (index-type :violin)
	    (degree nil) (distance 1.0) (degrees nil)
	    (no-waveshaping nil) (denoise nil)
	    (denoise-dur .1) (denoise-amp .005)
	    &amp;allow-other-keys)
  (if (&gt; (abs amplitude) 1.0) 
      (setf amplitude (clm-cerror ".1?" .1 #'numberp "amplitude = ~A?" amplitude)))
  (if (&lt;= (abs frequency) 1.0) 
      (setf frequency (clm-cerror "440.0?" 440.0 #'numberp "frequency = ~A?" frequency)))
  (let* ((beg (floor (* startime *srate*)))
	 (end (+ beg (floor (* dur *srate*))))
	 (frq-scl (hz-&gt;radians frequency))
	 (modulate (not (zerop fm-index)))
	 (maxdev (* frq-scl fm-index))
	 (vln (not (eq index-type :cello)))
	 (logfreq (log frequency))
	 (sqrtfreq (sqrt frequency))
	 (index1 (or fm1-index (min pi (* maxdev (/ (if vln 5.0 7.5) logfreq)))))
	 (index2 (or fm2-index (min pi (* maxdev 3.0 (if vln 
							     (/ (- 8.5 logfreq) (+ 3.0 (* frequency .001)))
							   (/ 15.0 sqrtfreq))))))
	 (index3 (or fm3-index (min pi (* maxdev (/ (if vln 4.0 8.0) sqrtfreq)))))

	 (easy-case (and (not no-waveshaping)
			 (zerop noise-amount)
			 (eq fm1-env fm2-env)
			 (eq fm1-env fm3-env)
			 (zerop (- fm1-rat (floor fm1-rat)))
			 (zerop (- fm2-rat (floor fm2-rat)))
			 (zerop (- fm3-rat (floor fm3-rat)))
			 (zerop (nth-value 1 (floor fm2-rat fm1-rat)))
			 (zerop (nth-value 1 (floor fm3-rat fm1-rat)))))
	 (coeffs (and easy-case modulate
	 	      (partials-&gt;polynomial
	 	       (list fm1-rat index1
	 		     (floor fm2-rat fm1-rat) index2
	 		     (floor fm3-rat fm1-rat) index3))))
	 ;; that is, we're doing the polynomial evaluation using fm1osc running at fm1-rat * frequency
	 ;; so everything in the polynomial table should be in terms of harmonics of fm1-rat
	 
	 (norm (or (and easy-case modulate 1.0) index1))
	 
	 (carrier (make-oscil frequency))
	 (fmosc1  (and modulate (make-oscil (* fm1-rat frequency))))
	 (fmosc2  (and modulate (or easy-case (make-oscil (* fm2-rat frequency)))))
	 (fmosc3  (and modulate (or easy-case (make-oscil (* fm3-rat frequency)))))
	 (ampf  (make-env 
                  (if denoise
                       (reduce-amplitude-quantization-noise amp-env dur amplitude denoise-dur denoise-amp) 
                     amp-env)
	          amplitude :base base :duration dur))
	 (indf1 (and modulate (make-env fm1-env norm :duration dur)))
	 (indf2 (and modulate (or easy-case (make-env fm2-env index2 :duration dur))))
	 (indf3 (and modulate (or easy-case (make-env fm3-env index3 :duration dur))))
	 (frqf (make-env gliss-env (* glissando-amount frq-scl) :duration dur))
	 (pervib (make-triangle-wave periodic-vibrato-rate (* periodic-vibrato-amplitude frq-scl)))
	 (ranvib (make-rand-interp random-vibrato-rate (* random-vibrato-amplitude frq-scl)))
	 (fm-noi (if (and (/= 0.0 noise-amount)
			  (null frobber))
		     (make-rand noise-freq (* pi noise-amount))))
	 (ind-noi (if (and (/= 0.0 ind-noise-amount) (/= 0.0 ind-noise-freq))
		      (make-rand-interp ind-noise-freq ind-noise-amount)))
	 (amp-noi (if (and (/= 0.0 amp-noise-amount) (/= 0.0 amp-noise-freq))
		      (make-rand-interp amp-noise-freq amp-noise-amount)))
	 (frb-env (if (and (/= 0.0 noise-amount) frobber)
		      (make-env (make-frobber-function startime (+ startime dur) frobber) :duration dur
				:base 0	:scaler (* two-pi noise-amount))))
	 (vib 0.0) 
	 (modulation 0.0)
	 (loc (make-locsig :degree (or degree degrees (random 90.0)) :reverb reverb-amount :distance distance))
	 (fuzz 0.0)
	 (ind-fuzz 1.0)
	 (amp-fuzz 1.0))
    (run
     (loop for i from beg to end do
       (if (/= 0.0 noise-amount)
	   (if (null frobber)
	       (setf fuzz (rand fm-noi))
	     (setf fuzz (env frb-env))))
       (setf vib (+ (env frqf) (triangle-wave pervib) (rand-interp ranvib)))
       (if ind-noi (setf ind-fuzz (+ 1.0 (rand-interp ind-noi))))
       (if amp-noi (setf amp-fuzz (+ 1.0 (rand-interp amp-noi))))
       (if modulate
	   (if easy-case
	       (setf modulation
		 (* (env indf1) 
		    (polynomial coeffs (oscil fmosc1 vib)))) ;(* vib fm1-rat)??
	     (setf modulation
	       (+ (* (env indf1) (oscil fmosc1 (+ (* fm1-rat vib) fuzz)))
		  (* (env indf2) (oscil fmosc2 (+ (* fm2-rat vib) fuzz)))
		  (* (env indf3) (oscil fmosc3 (+ (* fm3-rat vib) fuzz)))))))
       (locsig loc i
	     (* (env ampf) amp-fuzz
		(oscil carrier (+ vib (* ind-fuzz modulation)))))))))
</pre>
<p>which is very similar to the Scheme version (v.scm).
It's basically setting up several parallel modulators of one carrier (see <a href="fm.html">fm.html</a>
for details, or (ah nostalgia...) 
Schottstaedt,  "The Simulation of Natural Instrument Tones Using Frequency Modulation with a Complex Modulating Wave", CMJ vol 1 no 4 1977 p46-50). 
The modulators
themselves are modulated (vibrato, noise, etc). The FM indices were chosen to try
to mimic violin or cello sounds over a wide range of frequencies.
There's no limit on what this instrument can do; nearly all my compositions in the 80's used
it.  In CLM, there's fmviolin.clm which shows some of the effects (although it's unfortunately
hard to read due to the way the Sambox system worked).
And I just found this out on the net; I'm no csound expert, so I merely quote what I find:
</p>
<pre>
;ORC
; edited by R. Pinkston, modified for use with MIDI2CS by R. Borrmann
;
;==========================================================================;
;                Schottstaedt FM String Instrument from Dodge              ;
;                                                                          ;
;p4 = amp p5 = pch p6 = rise p7 = dec p8 = vibdel p9 = vibwth p10 = vibrte ;
;==========================================================================;
;        sr      =       44100
;        kr      =       4410
;        ksmps   =       10
;        nchnls  =       1
;
;                instr   1

par
  p_maxamplitude 32000
  p_cps
endpar

        iamp    =       p4

        irise   = .2    ;p6
        idec    = .2    ;p7
        ivibdel = .75   ;p8
        ivibwth = .03   ;p9
        ivibrte = 5.5   ;p10

        ifc     =       p5
        ifm1    =       ifc
        ifm2    =       ifc*3
        ifm3    =       ifc*4
        indx1   =       7.5/log(ifc)    ;range from ca 2 to 1
        indx2   =       15/sqrt(ifc)    ;range from ca 2.6 to .5
        indx3   =       1.25/sqrt(ifc)  ;range from ca .2 to .038
        kvib    init    0 

                timout  0,ivibdel,transient  ;delays vibrato for p8 seconds
        kvbctl  linen   1,.5,p3-ivibdel,.1   ;vibrato control envelope
        krnd    randi   .0075,15        ;random deviation in vib width 
        kvib    oscili  kvbctl*ivibwth+krnd,ivibrte*kvbctl,1 ;vibrato generator
               
transient:
        timout  .2,p3,continue          ;execute for .2 secs only
        ktrans  linseg  1,.2,0,1,0      ;transient envelope 
        anoise  randi   ktrans,.2*ifc   ;noise... 
        attack  oscil   anoise,2000,1   ;...centered around 2kHz

continue: 
        amod1   oscili  ifm1*(indx1+ktrans),ifm1,1
        amod2   oscili  ifm2*(indx2+ktrans),ifm2,1
        amod3   oscili  ifm3*(indx3+ktrans),ifm3,1
        asig    oscili  iamp,(ifc+amod1+amod2+amod3)*(1+kvib),1
        asig    linen   asig+attack,irise,p3,idec
;                out     asig
; 
;                endin
        aright  = asig
        aleft   = asig
</pre>
<p>There's a C/CLM version of this instrument in sndlib.html.  The body of the fm-violin
in C/CLM is:
</p>
<pre>
      if (noise_amount != 0.0) fuzz = mus_rand(fmnoi,0.0);
      if (frqf) vib = mus_env(frqf); else vib = 0.0;
      vib += mus_triangle_wave(pervib, 0.0) + 
             mus_rand_interp(ranvib, 0.0);
      if (easy_case)
        modulation = mus_env(indf1) * 
                     mus_polynomial(coeffs, mus_oscil(fmosc1, vib, 0.0), npartials);
      else
        modulation = mus_env(indf1) * mus_oscil(fmosc1, (fuzz + fm1_rat * vib), 0.0) +
                     mus_env(indf2) * mus_oscil(fmosc2, (fuzz + fm2_rat * vib), 0.0) +
                     mus_env(indf3) * mus_oscil(fmosc3, (fuzz + fm3_rat * vib), 0.0);
      mus_locsig(loc, i, mus_env(ampf) *
                         mus_oscil(carrier, vib + indfuzz * modulation, 0.0));
</pre>

<p>And here is the Ruby version, written by Michael Scholz (see examp.rb):</p>
<pre>
#
# fm_violin([start=0.0[, dur=1.0[, freq=440.0[, amp=0.3[, *args]]]]])
#

def fm_violin(start = 0.0, dur = 1.0, freq = 440.0, amp = 0.3, *args)
  include Math;			# PI

  usage = "fm_violin([start=0.0[, dur=1.0[, freq=440.0[, amp=0.3[, *args]]]]])

	[:fm_index, 1.0]
	[:amp_env, [0, 0, 25, 1, 75, 1, 100, 0]]
	[:periodic_vibrato_rate, 5.0]
	[:random_vibrato_rate, 16.0]
	[:periodic_vibrato_amp, 0.0025]
	[:random_vibrato_amp, 0.005]
	[:noise_amount, 0.0]
	[:noise_freq, 1000.0]
	[:ind_noise_freq, 10.0]
	[:ind_noise_amount, 0.0]
	[:amp_noise_freq, 20.0]
	[:amp_noise_amount, 0.0]
	[:gliss_env, [0, 0,  100, 0]]
	[:gliss_amount, 0.0]
	[:fm1_env, [0, 1, 25, 0.4, 75, 0.6, 100, 0]]
	[:fm2_env, [0, 1, 25, 0.4, 75, 0.6, 100, 0]]
	[:fm3_env, [0, 1, 25, 0.4, 75, 0.6, 100, 0]]
	[:fm1_rat, 1.0]
	[:fm2_rat, 3.0]
	[:fm3_rat, 4.0]
	[:fm1_index, false]
	[:fm2_index, false]
	[:fm3_index, false]
	[:base, 1.0]
	[:reverb_amount, 0.01]
	[:index_type, :violin]
	[:degree, false]
	[:distance, 1.0]
	[:degrees, false]

  Ruby: fm_violin(0, 1, 440, .1, [[:fm_index, 2.0]])
 Guile: (fm-violin 0 1 440 .1 :fm-index 2.0)\n\n";

  fm_index = (args.assoc(:fm_index)[1] rescue 1.0);
  amp_env = (args.assoc(:amp_env)[1] rescue [0, 0, 25, 1, 75, 1, 100, 0]);
  periodic_vibrato_rate = (args.assoc(:periodic_vibrato_rate)[1] rescue 5.0);
  random_vibrato_rate = (args.assoc(:random_vibrato_rate)[1] rescue 16.0);
  periodic_vibrato_amp = (args.assoc(:periodic_vibrato_amp)[1] rescue 0.0025);
  random_vibrato_amp = (args.assoc(:random_vibrato_amp)[1] rescue 0.005);
  noise_amount = (args.assoc(:noise_amount)[1] rescue 0.0);
  noise_freq = (args.assoc(:noise_freq)[1] rescue 1000.0);
  ind_noise_freq = (args.assoc(:ind_noise_freq)[1] rescue 10.0);
  ind_noise_amount = (args.assoc(:ind_noise_amount)[1] rescue 0.0);
  amp_noise_freq = (args.assoc(:amp_noise_freq)[1] rescue 20.0);
  amp_noise_amount = (args.assoc(:amp_noise_amount)[1] rescue 0.0);
  gliss_env = (args.assoc(:gliss_env)[1] rescue [0, 0,  100, 0]);
  gliss_amount = (args.assoc(:gliss_amount)[1] rescue 0.0);
  fm1_env = (args.assoc(:fm1_env)[1] rescue [0, 1, 25, 0.4, 75, 0.6, 100, 0]);
  fm2_env = (args.assoc(:fm2_env)[1] rescue [0, 1, 25, 0.4, 75, 0.6, 100, 0]);
  fm3_env = (args.assoc(:fm3_env)[1] rescue [0, 1, 25, 0.4, 75, 0.6, 100, 0]);
  fm1_rat = (args.assoc(:fm1_rat)[1] rescue 1.0);
  fm2_rat = (args.assoc(:fm2_rat)[1] rescue 3.0);
  fm3_rat = (args.assoc(:fm3_rat)[1] rescue 4.0);
  fm1_index = (args.assoc(:fm1_index)[1] rescue false);
  fm2_index = (args.assoc(:fm2_index)[1] rescue false);
  fm3_index = (args.assoc(:fm3_index)[1] rescue false);
  base = (args.assoc(:base)[1] rescue 1.0);
  reverb_amount = (args.assoc(:reverb_amount)[1] rescue 0.01);
  index_type = (args.assoc(:index_type)[1] rescue :violin);
  degree = (args.assoc(:degree)[1] rescue false);
  distance = (args.assoc(:distance)[1] rescue 1.0);
  degrees = (args.assoc(:degrees)[1] rescue false);

  srate = (srate() rescue $rbm_srate);
  chans = (channels() rescue $rbm_channels);
  beg = (srate * start).round;
  len = (srate * dur).round;
  frq_scl = hz2radians(freq);
  modulate = fm_index.nonzero?;
  maxdev = frq_scl * fm_index;
  vln = (not (index_type == :cello))
  logfreq = log(freq);
  sqrtfreq = sqrt(freq);
  index1 = (fm1_index or [PI, maxdev * (vln ? 5.0 : 7.5) / logfreq].min);
  index2 = (fm2_index or [PI, maxdev * 3.0 * 
	      (vln ? ((8.5 - logfreq) / (3.0 + freq * 0.001)) : (15.0 / sqrtfreq))].min);
  index3 = (fm3_index or [PI, maxdev * (vln ? 4.0 : 8.0) / sqrtfreq].min);
  easy_case = (noise_amount.zero? and
	       (fm1_env == fm2_env) and 
	       (fm1_env == fm3_env) and 
	       (fm1_rat - fm1_rat.floor).zero? and 
	       (fm2_rat - fm2_rat.floor).zero? and 
	       (fm3_rat - fm3_rat.floor).zero?);
  coeffs = (easy_case and modulate and 
	    partials2polynomial([fm1_rat, index1, 
				  (fm2_rat / fm1_rat).floor, index2,
				  (fm3_rat / fm1_rat).floor, index3]));
  norm = ((easy_case and modulate and 1.0) or index1);
  carrier = make_oscil(freq);
  fmosc1 = (modulate and make_oscil(fm1_rat * freq));
  fmosc2 = (modulate and (easy_case or make_oscil(fm2_rat * freq)));
  fmosc3 = (modulate and (easy_case or make_oscil(fm3_rat * freq)));
  ampf = make_env(amp_env, amp, dur, 0.0, base);
  indf1 = (modulate and make_env(fm1_env, norm, dur));
  indf2 = (modulate and (easy_case or make_env(fm2_env, index2, dur)));
  indf3 = (modulate and (easy_case or make_env(fm3_env, index3, dur)));
  frqf = make_env(gliss_env, gliss_amount * frq_scl, dur);
  pervib = make_triangle_wave(periodic_vibrato_rate, periodic_vibrato_amp *  frq_scl);
  ranvib = make_rand_interp(random_vibrato_rate, random_vibrato_amp * frq_scl);
  fm_noi = (noise_amount.nonzero? and make_rand(noise_freq, PI * noise_amount));
  ind_noi = ((ind_noise_amount.nonzero? and ind_noise_freq.nonzero?) and 
	     make_rand_interp(ind_noise_freq, ind_noise_amount));
  amp_noi = ((amp_noise_amount.nonzero? and amp_noise_freq.nonzero?) and
	     make_rand_interp(amp_noise_freq, amp_noise_amount));
  vib = 0.0;
  modulation = 0.0;
  # make_locsig(degree=0.0, distance=1.0, reverb=0.0, output, revout, chans=1, type=Mus_linear)
  # Ruby's rand() is shadowed by CLM's rand(), that's why mus_random().abs.
  loc = make_locsig((degree or degrees or mus_random(90.0).abs), 
		    distance, reverb_amount, false, false, chans);
  fuzz = 0.0;
  ind_fuzz = 1.0;
  amp_fuzz = 1.0;
  out_data = make_vct(len);

  vct_map!(out_data,
	   lambda { | |
	     fuzz = rand(fm_noi) if noise_amount.nonzero?;
	     vib = env(frqf) + triangle_wave(pervib) + rand_interp(ranvib);
	     ind_fuzz = 1.0 + rand_interp(ind_noi) if ind_noi;
	     amp_fuzz = 1.0 + rand_interp(amp_noi) if amp_noi;

	     if(modulate)
	       if(easy_case)
		 modulation = env(indf1) * polynomial(coeffs, oscil(fmosc1, vib));
	       else
		 modulation = env(indf1) * oscil(fmosc1, fm1_rat * vib + fuzz) +
		   env(indf2) * oscil(fmosc2, fm2_rat * vib + fuzz) +
		   env(indf3) * oscil(fmosc3, fm3_rat * vib + fuzz);
	       end
	     end

	     env(ampf) * amp_fuzz * oscil(carrier, vib + ind_fuzz * modulation);
	   });

  if(chans == 2)
    mix_vct(vct_scale!(vct_copy(out_data), locsig_ref(loc, 1)), beg, $rbm_snd, 1, false);
    mix_vct(vct_scale!(out_data, locsig_ref(loc, 0)), beg, $rbm_snd, 0, false);
  else
    mix_vct(out_data, beg, $rbm_snd, 0, false);
  end
rescue
  die(usage + "fm_violin()");
end

</pre>
<br>

<A NAME="wsdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>ws.scm, ws.rb</h2></td></tr></table>
<p>
<i>with-sound</i> is the primary sound producing macro in CLM (in a sense, it is CLM's user-interface).
In Common Lisp it's defined as:</p>
<pre>
 (defmacro with-sound ((&amp;key (srate 22050) ...) &amp;body body) 
   (unwind-protect
     (let (...) ,.body)
     (progn (cleanup...))))
</pre>
<p>and makes extensive use of Lisp's dynamic binding to handle nested with-sound calls and so on.
Kalle Olavi Niemitalo came up with this Scheme/Guile replacement:
</p>
<pre>
(define* (with-sound-helper thunk #:key (srate 22050) (explode #f))
  (let ((old-srate (mus-srate)))
    (dynamic-wind 
      (lambda () 
        (set! (mus-srate) srate))
      thunk
      (lambda () 
        (set! (mus-srate) old-srate)))))

(defmacro with-sound (args . body)
  `(with-sound-helper (lambda () ,@body)
                      ,@args))
</pre>
<p>
The version in ws.scm is simply an amplification of this code.
The global variables that parallel CLM's *clm-...* are:
</p>
<pre>
  <em class=def>*clm-srate*</em> (default-output-srate)        ; default srate
  <em class=def>*clm-file-name*</em> "test.snd"                ; default output file name
  <em class=def>*clm-channels*</em> (default-output-chans)     ; default number of output chans
  <em class=def>*clm-data-format*</em> (default-output-format) ; default output data format
  <em class=def>*clm-header-type*</em> (default-output-type)   ; default output header type
  <em class=def>*clm-delete-reverb*</em> #f                    ; should reverb stream be deleted?
  <em class=def>*clm-verbose*</em> #f                          ; currently unused
  <em class=def>*clm-play*</em> #f                             ; should the output be played at the end
  <em class=def>*clm-statistics*</em> #f                       ; should stats be printed out at the end
  <em class=def>*clm-reverb*</em> #f                           ; reverb function, if any
  <em class=def>*clm-reverb-channels*</em> 1                   ; reverb stream chans
  <em class=def>*clm-reverb-data*</em> '()                     ; args pass to reverb function

  <em class=def>with-sound</em>
    #:key (srate *clm-srate*)
          (output *clm-file-name*)
	  (channels *clm-channels*)
	  (header-type *clm-header-type*)
	  (data-format *clm-data-format*)
	  (comment #f)
	  ;(verbose *clm-verbose*)
	  (reverb *clm-reverb*)
	  (revfile "test.rev")
	  (reverb-data *clm-reverb-data*)
	  (reverb-channels *clm-reverb-channels*)
	  (continue-old-file #f)
	  (statistics *clm-statistics*)
	  (scaled-to #f)
	  (play *clm-play*)
	  (to-snd *to-snd*)
	  (scaled-by #f)
</pre>
<p>As far as possible, this parallels CLM's <a href="clm.html#with-sound">with-sound</a>.</p>
<pre>
  (with-sound (:srate 44100) (fm-violin 0 1 440 .1))
</pre>
<p>
<b>with-sound</b> opens its output file (<i>output</i> above)
via make-sample-&gt;file, setting the global variable *output*.  This
is equivalent to CLM's *output* variable, and can be used the same
way in outa or locsig.  If <i>reverb</i> is specified, *reverb* is also
opened (corresponding to CLM's *reverb*).  So the cooperating instrument code is:
</p>
<pre>
(definstrument (ins args)
  (let ...
    (ws-interrupt?) ; see below
    (run
      (lambda ()
        (do ((i start (1+ i)))
            ((= i end))
          (outa i ... *output*))))))
</pre>
<p>which parallels the Common Lisp CLM (change the loop statement to a do statement,
add the lambda wrapper (needed by the run macro unfortunately),
and you're ready to go).  If the run macro can handle the instrument code (and
it can handle anything the CL version can handle, I think), then the Snd with-sound
should run within a factor of four of the fastest CL-based CLM, even though the
latter is going through the C intermediate file and the (very good) C compiler!  
The easiest way to mix an existing file into the with-sound output is to use
mus-mix with *output*:
</p>
<pre>
(with-sound () 
  (fm-violin 0 .1 440 .1) 
  (mus-mix *output* "oboe.snd") 
  (fm-violin .1 .1 660 .1))
</pre>
<p>To continue adding notes to an existing file, set <i>continue-old-file</i>:
</p>
<pre>
(with-sound (:continue-old-file #t) (fm-violin 0 1 440 .1))
</pre>
<p>with-sound returns the output file name. If a previous file of the same name
is currently open, it is closed before the new version is opened.
</p>
<p>ws.scm also has a version of <a href="clm.html#def-clm-struct">def-clm-struct</a>,
<a href="clm.html#sound-let">sound-let</a>, and <a href="clm.html#mix-and-with-mix">with-mix</a>.  with-sounds and sound-lets can be nested --
see clm.html.
<b>def-clm-struct</b> in Snd/Guile provides a way to package up heterogenous data 
for user-defined generators.  In pure-Scheme it just sets up functions to make
and access such a list, but in Snd's run macro, it also provides type declarations:
</p>
<pre>
(def-clm-struct hiho i x (s "hiho") (ii 3 :type int) (xx 0.0 :type float))
</pre>
<p>defines a structure type ("hiho") with 5 fields.  "hiho-s" defaults to the
string "hiho", "hiho-ii" defaults to 3, and declares that its type will always
be int (so it can be used without restriction in run), and so on.
</p>
<pre>
(define hi (make-hiho :xx 3.14))
</pre>
<p>defines a variable named hi whose value is a hiho structure (a list) with
all the fields taking their default value except "xx" which is set to 3.14.
So, hi's value is <code>(list 'hiho #f #f "hiho" 3 3.14)</code>.
</p>
<p><b>init-with-sound</b> and <b>finish-with-sound</b>
split with-sound into two pieces, primarily for Common Music's benefit.
</p>
<pre>
(define w (init-with-sound :scaled-to .5))
(fm-violin 0 1 440 .1)
(finish-with-sound w)
</pre>
<p>is equivalent to 
</p>
<pre>
(with-sound (:scaled-to .5)
  (fm-violin 0 1 440 .1))
</pre>

<!-- INDEX wsdebug:Debugging (notelists) -->
<A NAME="wsdebug"></a>
<p>with-sound establishes a catch for debugging: 'with-sound-interrupt.  If you
place the macro <b>ws-interrupt?</b> in your instrument, C-g will be caught at
each such point, and control transferred to the with-sound debugging context.
Currently, ws-interrupt? is not supported by the run macro, but each of the
clm-ins.scm instruments includes it just before the run loop.  
Once in the debugger, you are simply in the standard listener loop, but
there are several additional functions to help with debugging:
</p>
<pre>
  <em class=def>ws-go</em> (returned-value #f)
  <em class=def>ws-locals</em> (stack-location 0)
  <em class=def>ws-local</em> local-var (stack-location 0)
  <em class=def>ws-backtrace</em> (all #f)
  <em class=def>ws-help</em>
  <em class=def>ws-quit</em>
  <em class=def>ws-quit!</em>
  <em class=def>ws-stop</em>
  <em class=def>ws-stop!</em>
</pre>
<p>
<b>ws-locals</b> prints out the current instrument's local variables and their values.
<b>ws-local</b> prints one such variable's value (the <i>local-var</i> argument should be a symbol or a string).
<b>ws-help</b> prints out help.
<b>ws-backtrace</b> shows the stack at the point of the interrupt.  The stack trace
is normally truncated to show just the 5 or so inner frames; to get the full
backtrace, call ws-backtrace with an argument of #t.
<b>ws-quit</b> exits with-sound without running the reverb (it does, however, close the current output file).
<b>ws-quit!</b> exits all interrupt levels (in case you called with-sound while in a previous interrupted one, then
interrupted that one as well), returning you to the true top-level.
<b>ws-stop</b> jumps out of the notelist at the interrupted point, but goes ahead and runs any reverb
before closing the output.
<b>ws-stop!</b> is similar to ws-stop, but it also makes sure you're back at the top level at the end.
<b>ws-go</b> continues from the point of the interrupt.
The 'returned-value' is the value to return from the original call on ws-interrupt? (or its equivalent).
</p>
<p>Toward the end of ws.scm is an example, <b>with-marked-sound</b>, that is just
like with-sound except that it adds a mark at the start of each note in the output
sound; the corresponding code in your instrument sets the mark's :ws property
to contain any info you might find amusing.  You then click the mark to see
that info.
</p>
<p>Also defined in ws.scm are the CLM functions <b>seconds-&gt;samples</b> and <b>time-&gt;samples</b>,
and the saved-state-prettification functions <b>mus-data-format-&gt;string</b> and
<b>mus-header-type-&gt;string</b>.  The *clm-* variables are saved in the save-state
file by <b>ws-save-state</b>, which may not be a good idea -- feedback welcome!
</p>
<br>

<A NAME="xmenveddoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>xm-enved.scm, xm-enved.rb</h2></td></tr></table>
<pre>
  <em class=def>xe-create-enved</em> name parent args axis
  <em class=def>xe-envelope</em> xe-editor
</pre>
<p>This file implements an envelope editor using the xm module.  <b>xe-create-enved</b>
returns a new envelope editor whose X axis label is <i>name</i>, the X and Y axis bounds
are in the list <i>axis</i>, the editor's parent widget is <i>parent</i>,  and the Xt-style
resource argument list is <i>args</i>.  The editor's current envelope is accessible
(read and write) via <i>xe-envelope</i>:
</p>
<pre>
(define outer (add-main-pane "hiho" xmFormWidgetClass '()))
(define editor (xe-create-enved "a name" outer 
			     (list XmNleftAttachment   XmATTACH_FORM
				   XmNtopAttachment    XmATTACH_FORM
				   XmNbottomAttachment XmATTACH_FORM
				   XmNrightAttachment  XmATTACH_FORM)
			     '(0.0 1.0 0.0 1.0)))
(set! (xe-envelope editor) (list 0.0 1.0 1.0 0.5))
</pre>


<A NAME="zipdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>zip.scm</h2></td></tr></table>
<pre>
  <em class=def>make-zipper</em> ramp-env <i>frame-size frame-env</i>
  <em class=def><a name="zipper">zipper</a></em> gen in1 in2
  <em class=def><a name="zipsound">zip-sound</a></em> beg dur file1 file2 <i>ramp size</i>
</pre>
<p>The zipper generator performs a kind of cross fade, but not one that
tries to be smooth!  It marches through the two sounds taking equal short
portions of each, then abutting them while resampling so that as one
takes less overall frame space, the other takes more.  The <i>frame-size</i>
argument is the maximum length of each twosome in seconds (for initial array allocation), the <i>frame-env</i>
argument determines the current such length as new frames are needed, and the
<i>ramp-env</i> argument determines which of the files gets more space
in the frame (0: all first, 1: all second).
The following function sets up two sounds,
an upward ramp and a downward ramp, then zips them together:
</p>
<pre>
(define (ramp-test)
  (let ((data (make-vct 10000)))
    (new-sound "new-0.snd")
    (do ((i 0 (1+ i))) ((= i 10000)) 
      (vct-set! data i (* i .0001)))
    (vct-&gt;samples 0 10000 data 0)
    (new-sound "new-1.snd")
    (do ((i 0 (1+ i))) ((= i 10000)) 
      (vct-set! data i (- 1.0 (* i .0001))))
    (vct-&gt;samples 0 10000 data 1)
    (let* ((dur (frames))
	   (zp (<em class=red>make-zipper</em> (let ((e (make-env '(0 0 1 1) :end dur)))
			      (lambda () (env e)))))
	  (reader0 (make-sample-reader 0 0 0))
	  (reader1 (make-sample-reader 0 1 0)))
      (map-chan (lambda (val) (<em class=red>zipper</em> zp reader0 reader1))))))
</pre>
<center><img src="zramp.png" alt="zipper ramp output"></center>
<p>Needless to say, this is not intended to be a suave, romantic gesture!
</p>
<br>

<table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2><A NAME="extsndvarexpl">A Note on Scheme variables in Snd</a></h2></td></tr></table>

<p>At first glance, Snd's use of functions for nearly all variable accesses, i.e. <code>(listener-prompt)</code>
rather than the simpler <code>listener-prompt</code>, seems unmotivated.  The following little
program defines "counter" as a scheme variable, accessible in C:
</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;libguile.h&gt;

void inner_main(void *closure, int argc, char **argv)
{
  SCM counter;
  int size = 512;
  char **buffer = NULL;
  buffer = (char **)calloc(1, sizeof(char *));
  buffer[0] = (char *)calloc(size, sizeof(char));
  counter = scm_permanent_object(scm_c_define("counter", scm_long2num(0)));
  while (1)
    {
      getline(buffer, &amp;size, stdin);
      scm_eval_str0(buffer[0]);
      fprintf(stdout, "counter is %d\n", scm_num2int(SCM_VARIABLE_REF(counter), 0, "main"));
    }
}

int main(int argc, char *argv[])
{
  scm_boot_guile(argc, argv, inner_main, 0);
  return(0);
}
</pre>
<p>Now we compile and load it (in Linux: cc g.c -o g -lguile), and it sits in a loop
reading a line at a time, evaluating it, and printing the current value of
our counter:
</p>
<pre>
/home/bil/cl/ g
(+ 1 2)
counter is 0
(set! counter 123)
counter is 123
(set! counter (* counter 2))
counter is 246
</pre>
<p>But the C code itself doesn't see the set!, and there's no way to
tell set! in Guile to call an auxiliary function when our counter
is set.  We need to see that set! as soon as it happens to make the user interface
responsive.  <code>(set! basic-color red)</code> would have no effect unless
our C code could be informed that the <code>basic-color</code> variable's value had changed.
In addition, in Snd, there are perhaps several hundred such variables, and
our C code will run faster if we access C variables as much as possible, rather
than calling scm_num2int (or whatever) every time the value is needed.
So, we first defined each variable along these lines:
</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;libguile.h&gt;

int counter = 0;

SCM g_counter(void)
{
  return(scm_long2num(counter));
}

SCM g_set_counter(SCM newval)
{
  counter = scm_num2int(newval, 0, "set-counter");
  return(newval);
}

void inner_main(void *closure, int argc, char **argv)
{
  int size = 512;
  char **buffer = NULL;
  buffer = (char **)calloc(1, sizeof(char *));
  buffer[0] = (char *)calloc(size, sizeof(char));
  scm_c_define_gsubr("counter", 0, 0, 0, g_counter);
  scm_c_define_gsubr("set-counter", 1, 0, 0, g_set_counter);
  while (1)
    {
      getline(buffer, &amp;size, stdin);
      scm_eval_str0(buffer[0]);
      fprintf(stdout, "counter is %d\n", counter);
    }
}

int main(int argc, char *argv[])
{
  scm_boot_guile(argc,argv, inner_main, 0);
  return(0);
}
</pre>
<p>Now we have two functions:  <code>counter</code> returns (to the Scheme world)
the current value of the C variable <code>counter</code>, and <code>set-counter</code>
sets it:
</p>
<pre>
/home/bil/cl/ g
(+ 1 2)
counter is 0
(set-counter 123)
counter is 123
(set-counter (* (counter) 2))
counter is 246
</pre>
<p>Now the g_set_counter procedure can reflect counter's new value within C,
and the variable lives in C, so two of our problems are solved.
But we don't really want the extra name "set-counter".
So, we use Guile's generalized set! by replacing the two
scm_c_define_gsubr calls above with:
</p>
<pre>
  scm_c_define("counter",
    scm_make_procedure_with_setter(
      scm_c_define_gsubr("", 0, 0, 0, g_counter),
      scm_c_define_gsubr("", 1, 0, 0, g_set_counter)));
</pre>
<p>Now we have Snd's way of handling things:
</p>
<pre>
/home/bil/cl/ g
(+ 1 2)
counter is 0
(set! (counter) 123)
counter is 123
(set! (counter) (* (counter) 2)) 
counter is 246
</pre>
<p>It's not completely ideal, but it's close enough that I don't find it painful to use.
If you run the program above, you'll be annoyed to discover that any error causes
it to exit!  Guile's default is to have no error handler installed, so the throw
that an error generates is not caught, causing the program to exit.  The next
version of our program adds error handling, a cleaner exit mechanism (you can
call the exit procedure to exit), and a simple procedure that adds some amount
to the counter:
</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;libguile.h&gt;

int counter = 0;
SCM g_counter(void) {return(scm_long2num(counter));}

SCM g_set_counter(SCM newval)
{
  counter = scm_num2int(newval, 0, "set-counter");
  return(newval);
}

/* this code needs Guile 1.5 or later */
/* the error handler:  it prints out whatever information the error sent us and returns */

static SCM report_error(void *data, SCM tag, SCM throw_args)
{
  if (SCM_EQ_P(tag, scm_str2symbol("quit"))) exit(0);
  fprintf(stdout, "%s: %s\n", 
	  SCM_STRING_CHARS(scm_object_to_string(tag, SCM_UNDEFINED)), 
	  SCM_STRING_CHARS(scm_object_to_string(throw_args, SCM_UNDEFINED)));
  return(tag);
}

static SCM add_to_counter(SCM val)
{
  SCM_ASSERT_TYPE(SCM_EQ_P(scm_integer_p(val), SCM_BOOL_T), val, SCM_ARGn, "add-to-counter", "an integer");
  counter += scm_num2int(val, 0, "add-to-counter");   /* convert from Scheme to C */
  return(scm_long2num(counter));  /* return our new counter value */
}

static void inner_main(void *closure, int argc, char **argv)
{
  SCM result;
  int size = 512;
  char **buffer = NULL;
  scm_c_define_gsubr("add-to-counter", 1, 0, 0, add_to_counter);

  scm_c_define("counter",
    scm_make_procedure_with_setter(
      scm_c_define_gsubr("", 0, 0, 0, g_counter),
      scm_c_define_gsubr("", 1, 0, 0, g_set_counter)));

  buffer = (char **)calloc(1, sizeof(char *));
  buffer[0] = (char *)calloc(size, sizeof(char));
  while (1)
    {
      /* (exit) to exit */
      fprintf(stdout, "&gt;");
      getline(buffer, &amp;size, stdin);
      result = scm_internal_stack_catch(SCM_BOOL_T, /* this is our "catch" */
					scm_eval_str0, 
					(void *)(buffer[0]), 
					report_error,
					buffer[0]);
      fprintf(stdout, "%s\n",
	      SCM_STRING_CHARS(scm_object_to_string(result, SCM_UNDEFINED)));
    }
}

int main(int argc, char *argv[])
{
  scm_boot_guile(argc, argv, inner_main, 0);
  return(0);
}
</pre>
<p>Now we have our own "read-eval-print" loop:
</p>
<pre>
/home/bil/cl/ g
&gt;(+ 1 2)
3
&gt;counter 
#&lt;procedure-with-setter&gt;
&gt;(counter)
0
&gt;(add-to-counter 32)
32
&gt;(counter)
32
&gt;(add-to-counter 1)
33
&gt;(counter)
33
&gt;(add-to-counter 3.41)
wrong-type-arg: ("add-to-counter" "Wrong type argument (expecting ~A): ~S" ("an integer" 3.41) #f)
wrong-type-arg
&gt;asdf
unbound-variable: (#f "Unbound variable: ~S" (asdf) #f)
unbound-variable
&gt;(exit)
</pre>
<p>But now the <i>scm_eval_str0</i> use generates a compiler complaint about type
mismatches (though it works).  We can fix that by:
</p>
<pre>
static SCM eval_str_wrapper(void *data) {return(scm_eval_str0((char *)data));}

/* ... */

      result = scm_internal_stack_catch(SCM_BOOL_T,
					eval_str_wrapper, 
					(void *)(buffer[0]), 
					report_error,
					buffer[0]);
</pre>

<br>

<table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2><A NAME="extsndasneededexpl">A Note on "As-Needed" input functions</a></h2></td></tr></table>

<p>Several CLM generators work internally on buffers of data; only the code internal
to the generator knows when it needs input, and how much it needs.  So, src, granulate,
convolve, and phase-vocoder are passed a function either at run-time or when the
generator is allocated that they can call whenever a new value is needed.
A simple C case is:
</p>
<pre>
#include &lt;stdio.h&gt;
#include "clm.h"

typedef struct {
  float val;
} src_state;

float src_input_as_needed(void *arg, int dir) 
{
  src_state *sr = (src_state *)arg;
  sr-&gt;val += (dir * .01); /* just return a ramp */
  return(sr-&gt;val);
}

int main(int argc, char **argv)
{
  mus_any *gen;
  src_state *input;
  int i;
  input = (src_state *)calloc(1, sizeof(src_state));
  input-&gt;val = 0.0;
  gen = mus_make_src(&amp;src_input_as_needed, 0.5, 10, (void *)input);
  for (i=0; i &lt; 100; i++)
    fprintf(stdout, "%f ", mus_src(gen, 0.0, NULL));
    /* or: fprintf(stdout, "%f ", mus_src(gen, 0.0, src_input_as_needed)); */
  mus_free(gen);
  free(input);
  return(0);
}

/* cc g1.c -o g1 -L/usr/local/lib -lguile /home/bil/sndlib/sndlib.a */
/* g1: 0.010000 0.015440 0.020000 0.024761 0.029999 0.035170 0.039999 ... */
</pre>
<p>To put that code in words, the src generator uses the function
<code>src_input_as_needed</code> to fill its internal buffer (convolving
it with sinc); in this case, the "srate" argument is 0.5, so src will
pick up a new input sample (calling src_input_as_needed) on every other
output sample.  In the Scheme CLM (and Snd), the "as-needed" input
function is a Scheme function passed in as Scheme code:
</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;libguile.h&gt;
#include "clm.h"

typedef struct {
  SCM input_func;
} src_state;

float src_input_as_needed(void *ptr, int direction)
{
  src_state *sr = (src_state *)ptr;
  return(scm_num2dbl(scm_call_1(sr-&gt;input_func, scm_long2num(direction)), "input-as-needed"));
}

void inner_main(void *closure, int argc, char **argv)
{
  mus_any *gen;
  src_state *input;
  int i;
  int size = 512;
  char **buffer = NULL;
  buffer = (char **)calloc(1, sizeof(char *));
  buffer[0] = (char *)calloc(size, sizeof(char));
  input = (src_state *)calloc(1, sizeof(src_state));
  fprintf(stdout, "input function: ");
  getline(buffer, &amp;size, stdin);
  input-&gt;input_func = scm_eval_str0(buffer[0]);
  gen = mus_make_src(&amp;src_input_as_needed, 0.5, 10, (void *)input);
  for (i=0; i &lt; 100; i++)
    fprintf(stdout, "%f ", mus_src(gen, 0.0, src_input_as_needed));
  mus_free(gen);
  free(input);
}

int main(int argc, char *argv[])
{
  scm_boot_guile(argc, argv, inner_main, 0);
  return(0);
}

/* cc g1.c -o g1 -L/usr/local/lib -lguile /home/bil/sndlib/sndlib.a */
/* g1
   input function: (let ((val 0.0)) (lambda (dir) (set! val (+ val (* dir .01))) val))
   0.010000 0.015440 0.020000 0.024761 0.029999 0.035170 0.039999
*/
</pre>
<p>In this case, <code>src_input_as_needed</code> is calling the
user-supplied Scheme function (via <code>scm_call_1</code>).
</p>
<br>

<table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2><A NAME="extsndcgens">A Note on User-defined Generators in C-CLM</a></h2></td></tr></table>

<p>In the Common Lisp version of CLM, it's relatively easy to define a new generator. Take for
example, Fernando Lopez-Lezcano's fcomb (a comb filter with a low-pass filter on the feedback), defined as a part of his 
translation of Jezar Wakefield's freeverb reverberator:
</p>
<pre>
(def-clm-struct fcomb
  delay
  filter
  (feedback 0.0))
  
(defmacro fcomb (comb input)
  `(delay (fcomb-delay ,comb)
	  (+ ,input (* (one-zero (fcomb-filter ,comb)
				 (tap (fcomb-delay ,comb)))
		       (fcomb-feedback ,comb)))))
</pre>
<p>An fcomb generator is then created (in freeverb) via:
</p>
<pre>
(make-fcomb :delay (make-delay len)
            :feedback room-decay-val
            :filter (make-one-zero :a0 (- 1.0 dmp) :a1 dmp))
</pre>
<p>and called at run-time with:</p>
<pre>
(fcomb (aref combs c j) (frame-ref in c))
</pre>
<p>(In this case we have a two dimensional array of these generators).  This, of course,
does not make fcomb a full-fledged generator like oscil -- it doesn't
respond to mus-scaler or the other methods.  To do that
requires a bit of defclass/defmethod overhead in Lisp, something
along the lines of:
</p>
<pre> 
(in-package :clm)

(defclass fcomb (comb one-zero) ())

(defmethod fcomb? ((g fcomb)) t)
(defmethod fcomb? ((g t)) nil)

(defun fcomb (gen input)
  (delay gen
	 (+ input (* (one-zero gen (tap gen))
		     (mus-feedback gen)))))

(def-optkey-fun make-fcomb (length feedback a0 a1)
  (make-instance 'fcomb :loc 0 :xscl feedback :size length :zsize length :zdly nil
		 :line (make-double-float-array length)
		 :a0 a0 :a1 a1 :x1 0.0))

(defmethod print-object ((d fcomb) stream)
  (format stream "#&lt;(fcomb: size: ~A, loc: ~A, feedback: ~A, a0: ~A, a1: ~A, x1: ~A, line: ~A&gt;"
	  (dly-size d) (dly-loc d) (dly-xscl d)
	  (mus-a0 d) (mus-a1 d) (mus-x1 d)
	  (prettified-array (dly-line d)))))
</pre>
<p>And to get the
new (lisp-side, non-macro) generator to be callable within the run macro is yet another set
of headaches (see <a href="clm.html#user-defined-ugs">user-defined generators</a>).
In CLM-in-Scheme, the first (simpler) fcomb above might be:
</p>
<pre>
(define (fcomb gen input)
  (delay (car gen)
	 (+ input (* (one-zero (cadr gen) (tap (car gen)))
		     (caddr gen)))))

(define (make-fcomb length feedback a0 a1)
  (list (make-delay length)
	(make-one-zero a0 a1)
	feedback))
</pre>
<p>Or perhaps a more Schemey (Schemish?) method would be:
</p>
<pre>
(define (fcomb gen input)
  (gen input))	

(define (make-fcomb length feedback a0 a1)
  (let ((dly (make-delay length))
        (flt (make-one-zero a0 a1)))
    (lambda (input)
      (dly (+ input (* (flt (tap dly)) feedback))))))
</pre>
<p>(Here we're returning a closure that packages up the generator's state). 
We could use Guile's object system to conjure up fcomb
classes and methods in Scheme:
</p>
<pre>
(use-modules (oop goops))

(define-class fcmb ()
  (dly :accessor fcomb-delay)
  (flt :accessor fcomb-filter)
  (fdb :accessor fcomb-feedback))

(define (fcomb gen input)
  ((fcomb-delay gen) 
   (+ input (* ((fcomb-filter gen) 
		(tap (fcomb-delay gen)))
	       (fcomb-feedback gen)))))

(define-method (initialize (obj fcmb) initargs)
  (next-method)
  (let* ((len (get-keyword :length initargs 0))
	 (feedback (get-keyword :feedback initargs 0.5))
	 (a0 (get-keyword :a0 initargs 0.5))
	 (a1 (get-keyword :a1 initargs 0.5)))
    (set! (fcomb-delay obj) (make-delay len))
    (set! (fcomb-filter obj) (make-one-zero a0 a1))
    (set! (fcomb-feedback obj) feedback)
    obj))

(define-method (write (obj fcmb) port)
  (display (format #f "#&lt;fcomb: delay: ~A, filter: ~A, feedback: ~A&gt;"
		   (fcomb-delay obj)
		   (fcomb-filter obj)
		   (fcomb-feedback obj))
	   port))
</pre>
<p>
But our real interest here is how to do the same thing in CLM-in-C (clm.c).
The following code implements a comb filter with a one-zero filter on the feedback.
</p>
<pre>
#include "sndlib.h"
#include "clm.h"
#include "xen.h"
#include "clm2xen.h"

static int MUS_FCOMB = 0; /* this will be our fcomb type identifier */

typedef struct {
  mus_any_class *core;
  int loc, size;
  Float *line;
  Float xscl, a0, a1, x1;
} fcomb;

/* each CLM-in-C generator has mus_any_class *core as the first thing in its structure.
 *   it defines most of the built-in "generic" functions like mus-describe.
 * The next set of functions implement the core functions/
 *   The address of the function is stored in the class's core struct.
 *   For example, the scaler method is defined as Float (*scaler)(mus_any *ptr);
 *   in the mus_any_class declaration (clm.h); for fcomb it will correspond
 *   to the fcomb_scaler function below; it is invoked via mus_scaler(gen)
 *   where gen is an fcomb generator (the actual call is (*((gen-&gt;core)-&gt;scaler))(gen)).
 *   the core-&gt;scaler pointer (the function address) is set in the declaration
 *   of mus_any_class FCOMB_CLASS below.  If a method doesn't apply to a given
 *   generator class, just set its slot to 0.
 */

static bool mus_fcomb_p(mus_any *ptr) {return((ptr) &amp;&amp; ((ptr-&gt;core)-&gt;type == MUS_FCOMB));}

static char *describe_fcomb(mus_any *ptr) 
{
  char *desc = NULL;
  fcomb *gen = (fcomb *)ptr;
  desc = (char *)calloc(1024, sizeof(char));
  if (desc)
    {
      if (mus_fcomb_p((mus_any *)ptr))
	sprintf(desc, "fcomb: scaler: %.3f,  a0: %.3f,  a1: %.3f,  line[%d]", 
		gen-&gt;xscl, gen-&gt;a0, gen-&gt;a1, gen-&gt;size);
      else sprintf(desc, "not an fcomb gen");
    }
  return(desc);
}

static bool fcomb_equalp(mus_any *p1, mus_any *p2) {return(p1 == p2);}
static int fcomb_length(mus_any *ptr) {return(((fcomb *)ptr)-&gt;size);}
static Float *fcomb_data(mus_any *ptr) {return(((fcomb *)ptr)-&gt;line);}
static Float fcomb_scaler(mus_any *ptr) {return(((fcomb *)ptr)-&gt;xscl);}
static Float set_fcomb_scaler(mus_any *ptr, Float val) {((fcomb *)ptr)-&gt;xscl = val; return(val);}

static int free_fcomb(mus_any *uptr) 
{
  fcomb *ptr = (fcomb *)uptr;
  if (ptr)
    {
      if (ptr-&gt;line) 
        free(ptr-&gt;line);
      free(ptr); 
    }
  return(0);
}

/* now the actual run-time code executed by fcomb */
/* the extra "ignored" argument is for the run method */

static Float mus_fcomb (mus_any *ptr, Float input, Float ignored) 
{
  fcomb *gen = (fcomb *)ptr;
  Float tap_result, filter_result;
  tap_result = gen-&gt;line[gen-&gt;loc];
  filter_result = (gen-&gt;a0 * tap_result) + (gen-&gt;a1 * gen-&gt;x1);
  gen-&gt;x1 = tap_result;
  gen-&gt;line[gen-&gt;loc] = input + filter_result * gen-&gt;xscl;
  gen-&gt;loc++;
  if (gen-&gt;loc &gt;= gen-&gt;size) gen-&gt;loc = 0;
  return(tap_result);
}

/* this is our core class descriptor */

static mus_any_class FCOMB_CLASS = {
  -1, /* MUS_FCOMB eventually */ /* mus_type: this is assigned at run-time via mus_make_class_tag below */
  "fcomb",                       /* mus_name: class name (used in descriptive/error messages) */
  &amp;free_fcomb,                   /* mus_free: free gen's struct etc */
  &amp;describe_fcomb,               /* mus_describe: user-friendly description */
  &amp;describe_fcomb,               /* mus_inspect: internal debugging description */
  &amp;fcomb_equalp,                 /* mus_equalp: check equality of fcomb gens */
  &amp;fcomb_data,                   /* mus_data: the fcomb delay line, a float array */
  0,                             /* mus_set_data: not implemented for fcomb */
  &amp;fcomb_length,                 /* mus_length: delay line length */
  0,                             /* mus_set_length: not implemented for fcomb */
  0,0,                           /* mus_frequency, mus_set_frequency */
  0,0,                           /* mus_phase, mus_set_phase */
  &amp;fcomb_scaler,                 /* mus_scaler: the feedback term */
  &amp;set_fcomb_scaler,             /* mus_set_scaler */
  0, 0,
  &amp;mus_fcomb,                    /* mus_run: the run-time fcomb function, MUS_RUN(gen) for speed */
  0,                             /* type extension (normally 0) */
  NULL, 0                         
};

/* now a function to make a new generator */

static mus_any *mus_make_fcomb (Float scaler, int size, Float a0, Float a1)
{
  fcomb *gen = NULL;
  gen = (fcomb *)calloc(1, sizeof(fcomb));
  if (gen == NULL) 
    mus_error(MUS_MEMORY_ALLOCATION_FAILED, 
              "can't allocate struct for mus_make_fcomb!");
  else
    {
      gen-&gt;core = &amp;FCOMB_CLASS;
      if (MUS_FCOMB == 0) 
        {
          MUS_FCOMB = mus_make_class_tag();  /* this gives us a unique fcomb type id */
          gen-&gt;core-&gt;type = MUS_FCOMB;
        }
      gen-&gt;loc = 0;
      gen-&gt;xscl = scaler;
      gen-&gt;x1 = 0.0;
      gen-&gt;a0 = a0;
      gen-&gt;a1 = a1;
      gen-&gt;size = size;
      gen-&gt;line = (Float *)calloc(size, sizeof(Float));
      if (gen-&gt;line == NULL) 
	mus_error(MUS_MEMORY_ALLOCATION_FAILED, 
		  "can't allocate %d bytes for fcomb delay line in mus_make_fcomb!",
		  (int)(size * sizeof(Float)));
    }
  return((mus_any *)gen);
}

/* that is the end of the C side; the rest ties this generator into Guile/Ruby via the Xen package */
/*   in Snd's case, it's actually not needed because the generator is only called from C */

static XEN g_fcomb(XEN obj, XEN input)
{
  return(C_TO_XEN_DOUBLE(mus_fcomb(MUS_XEN_TO_CLM(obj), XEN_TO_C_DOUBLE(input), 0.0)));
}

static XEN g_fcomb_p(XEN obj)
{
  return(C_TO_XEN_BOOLEAN((mus_xen_p(obj)) &amp;&amp; (mus_fcomb_p(MUS_XEN_TO_CLM(obj)))));
}

static XEN g_make_fcomb(XEN scaler, XEN size, XEN a0, XEN a1)
{
  mus_xen *gn;
  gn = (mus_xen *)CALLOC(1,sizeof(mus_xen));
  gn-&gt;gen = mus_make_fcomb(XEN_TO_C_DOUBLE(scaler),
                           XEN_TO_C_INT(size),
                           XEN_TO_C_DOUBLE(a0),
                           XEN_TO_C_DOUBLE(a1));
  gn-&gt;nvcts = 0;
  return(mus_xen_to_object(gn));
}

static void init_fcomb(void)
{
  XEN_DEFINE_PROCEDURE("fcomb?", g_fcomb_p, 1, 0, 0, "(fcomb? gen) -&gt; #t if gen is an fcomb generator");
  XEN_DEFINE_PROCEDURE("make-fcomb", g_make_fcomb, 4, 0, 0, "(make-fcomb scaler size a0 a1) -&gt; new fcomb gen");
  XEN_DEFINE_PROCEDURE("fcomb", g_fcomb, 2, 0, 0, "(fcomb gen input) returns result of running fcomb gen");
}
</pre>

<table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2><A NAME="continuations">About Continuations</a></h2></td></tr></table>

<p>A continuation is a kind of GOTO, a jump to the end of the 
defining call-with-current-continuation form:
</p>
<pre>

(define (con-return)
  "use call/cc to break out of a loop"
  (call-with-current-continuation
   (lambda (return)              ; declare our "escape" procedure
     (let ((i 0))
       (while (&lt; i 123)
	 (if (= i 3) 
	     (return 'quitting)) ; goto end of continuation form
	 (display i)
	 (set! i (+ i 1)))
       'oops)))
   )                             ; i.e. here (with value 'quitting)

;;; (con-return)
;;;  =&gt; 'quitting

(define (con-go-on)
  "use call/cc to continue where we left off if a non-serious error is reported"
  (catch #t
	 (lambda ()
	   (do ((i 0 (1+ i)))
	       ((= i 123) 'oops)
	     (if (= i 3)
		 (call-with-current-continuation
		  (lambda (keep-going)
		    (throw 'not-really-an-error keep-going)))
		 (if (= i 6)
		     (throw 'an-error)))
	     (display i)))
	 (lambda args
	     (if (eq? (car args) 'not-really-an-error)
		 ((cadr args) #f)  ;; here we are invoking the continuation passed as an arg to throw
		                   ;;   it will "goto" the "display i" statement with i = 3
		 (display "got a real error")))))

;;; (con-go-on)
;;;   prints "012345got a real error"

;;; here's one that is not just a simple exit:

(let ((a 1)
      (b 1))
  (let ((cont1 #f)
	(cont2 #f))
    (call-with-current-continuation
     (lambda (x) 
       (set! cont1 x)))      ; set cont1
    ;; this is now where (cont1) will jump: label it CONT1
    (set! a (+ a 2))
    (display "a")
    (if cont2
	(cont2) ; if cont2 has been set, use it to jump to CONT2 below
	(begin
	  (call-with-current-continuation
	   (lambda (x) 
	     (set! cont2 x)  ; set cont2
	     (set! b (+ b 1))
	     (display "b")))
	  ;; this is where (cont2) will jump: CONT2
	  (set! b (+ b 2))
	  (display "!")
	  (if (&lt; b 6) 
	      (cont1)        ; goto CONT1 above
              #f)))))

;;; this prints "ab!a!"

</pre>

<center>
<table border=1><tr><td>
<table bgcolor="aliceblue" border=0 cellspacing=8><tr><td><small>related documentation:</small></td><td><small><a href="snd.html">snd.html</a></small></td>
<td><small><a href="extsnd.html">extsnd.html</a></small></td><td><small><a href="grfsnd.html">grfsnd.html</a></small></td><td><small><a href="clm.html">clm.html</a></small></td><td><small><a href="sndlib.html">sndlib.html</a></small></td><td><small><a href="fm.html">fm.html</a></small></td><td><small><a href="libxm.html">libxm.html</a></small></td><td><small><a href="index.html">index.html</a></small></td></tr></table>
</td></tr></table>
</center>
</body>
</html>


