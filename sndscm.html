<html>
<!-- documentation for some of the Scheme/Ruby/Forth code included with Snd -->

<head>
<title>Scheme, Ruby, and Forth Functions included with Snd</title>
<style type="text/css">
<!-- 
	EM.red {color:red; font-style:normal}
        EM.error {color:chocolate; font-style:normal}
        EM.typing {color:maroon; font-style: normal}
        EM.listener {color:darkblue; font-style: normal}
	EM.emdef {font-weight: bold; font-style: normal}
	H1 {text-align: center}
	UL {list-style-type: none}

	A {text-decoration:none}
	A:hover {text-decoration:underline}
	A.quiet {color:black; text-decoration:none}
	A.quiet:hover {text-decoration:underline}
	A.def {font-weight: bold; font-style: normal; text-decoration:none; text-color:black}
-->

</style>
</head>
<body bgcolor=white>
<table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h1>Scheme, Ruby, and Forth Functions included with Snd</h1></td></tr></table>
<br>

<center>
<table bgcolor="aliceblue" border=0 cellspacing=8><tr>
<td><small>related documentation:</small></td>
<td><small><a href="snd.html" onmouseover="return escape('basic Snd user-interface documentation')">snd.html</a></small></td>
<td><small><a href="extsnd.html" onmouseover="return escape('Snd extension and customization')">extsnd.html</a></small></td>
<td><small><a href="grfsnd.html" onmouseover="return escape('Snd configuration, connection to other libraries and programs')">grfsnd.html</a></small></td>
<td><small><a href="clm.html" onmouseover="return escape('sound synthesis generators, with-sound, instruments')">clm.html</a></small></td>
<td><small><a href="sndlib.html" onmouseover="return escape('library that handles sound files')">sndlib.html</a></small></td>
<td><small><a href="libxm.html" onmouseover="return escape('library that ties Motif and Gtk into Snd')">libxm.html</a></small></td>
<td><small><a href="fm.html" onmouseover="return escape('introduction to frequency modulation')">fm.html</a></small></td>
<td><small><a href="index.html" onmouseover="return escape('an actual index, not some introductory file')">index.html</a></small></td>
</tr></table>
</center>

<br>

<!-- I'm using A NAME (i.e caps) where the entity should be ignored by the indexer (index.cl) -->

<A NAME="introduction"></a>

<p>This file contains notes on the Scheme, Ruby, and Forth files included with Snd.
To use any of these files, load them:
</p>
<pre>
  Scheme: (load "dsp.scm") or (load-from-path "dsp.scm")
  Ruby:   load "dsp.rb"
  Forth:  "dsp.fs" file-eval
</pre>
<p>
To start Snd with
the file already loaded, <code>snd -l v.scm</code>, or put the load statement in your initialization file.
For help with Forth and Snd/CLM, see the Forth documentation section "Snd, CLM, and Fth".
</p>

<br>

<table border=8 bordercolor="lightsteelblue" cellpadding=6><tr><td>
<table border=0 cellspacing=0 cellpadding=2>
<tr><th colspan=2 bgcolor="beige">Contents</th></tr>

<tr><td><a href="#analogfilterdoc">analog-filter</a></td>
    <td onmouseover="return escape('These are the traditional IIR filters, any type, any even order.\
 The elliptic function filters need GSL')">standard IIR filters (Butterworth, Chebyshev, Bessel, Elliptic)</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#autosavedoc">autosave</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('periodically save current sound edits in a backup file,\
 useful if your machine crashes a lot.')">auto-save (edit backup) support</td></tr>

<tr><td><a href="#bessdoc">bess</a></td>
    <td onmouseover="return escape('This sets up a dialog to experiment with simple FM, the fm-violin,\
 or with a compositional algorithm')">FM demo</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#birddoc">bird</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('bird and bigbird instruments with calls that imitate about 50\
 species using additive synthesis and fancy envelopes.')">North-American birds</td></tr>

<tr><td><a href="#clminsdoc">clm-ins, clm23</a></td>
    <td onmouseover="return escape('Instruments using many standard synthesis techniques, including a bagpipe\
 FOF synthesis, many FM examples, granular synthesis, spectral modeling, reverbs, and physical modeling.')">various CLM instruments</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#debugdoc">debug</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('These are guile-specific debugging functions for tracing execution,\
 inserting breakpoints, and displaying a stack trace.')">debugging aids</td></tr>

<tr><td><a href="#dlocsigdoc">dlocsig</a></td>
    <td onmouseover="return escape('dlocsig sets up envelopes to mimic a moving sound; included are many powerful path-specification functions')">moving sounds (Michael Scholz)</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#drawdoc">draw</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('Examples of drawing extensions, primarily one that puts a thumbnail graph\
 of the current sound in the upper right corner.')">graphics additions</td></tr>

<tr><td><a href="#dspdoc">dsp</a></td>
    <td onmouseover="return escape('This has all the usual DSP stuff: filters, ffts, sample rate conversion, sound effects, statistics,\
 scanned synthesis, transforms, etc')">various DSP-related procedures</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#dotsnd">edit123.scm, snd_conffile.scm, snd_frg.scm</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('Initialization files.  snd_frg.scm sets up key bindings to imitate\
  Soundforge.')">.snd examples (Tom Roth, Kjetil S. Matheussen, Olivier Doare)</td></tr>

<tr><td><a href="#envdoc">env</a></td>
    <td onmouseover="return escape('Various operations on envelopes: add, scale, copy, stretch')">envelope functions</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#enveddoc">enved</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('This adds an envelope editor to each displayed channel.  You can\
  set it up to be an amplitude envelope.')">envelope editor</td></tr>

<tr><td><a href="#exampdoc">examp</a></td>
    <td onmouseover="return escape('A pile of examples of things like ffts, filters, marks, selections, graphics extensions,\
 sound effects, and generators.')">many examples</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#extensionsdoc">extensions</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('channel and sound property lists, several enveloping functions,\
 and commonly used editing sequences such as channel extraction.')">various generally useful Snd extensions</td></tr>

<tr><td><a href="#fadedoc">fade</a></td>
    <td onmouseover="return escape('sound mixing using envelopes in the frequency domain')">frequency-domain cross-fades</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#framedoc">frame</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('various frame, vct, and sound-data functions')">frames, vcts, sound-data objects</td></tr>

<tr><td><a href="#freeverbdoc">freeverb</a></td>
    <td onmouseover="return escape('a reverberator along the lines of nrev, but with more options.')">a reverb</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#granidoc">grani</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('a very flexible granular synthesis instrument')">CLM's grani (Fernando Lopez-Lezcano) translated by Mike Scholz</td></tr>

<tr><td><a href="#greendoc">green</a></td>
    <td onmouseover="return escape('generators similar to rand and rand-interp.')">bounded brownian noise generators</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#heartdoc">heart</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('This particular code is aimed at blood pressure readings.')">use Snd with non-sound (arbitrary range) data</td></tr>

<tr><td><a href="#hooksdoc">hooks</a></td>
    <td onmouseover="return escape('describe-hook, with-local-hook, reset-all-hooks.')">functions related to hooks</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#indexdoc">index</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('connection between mozilla and the snd-help mechanism.')">snd-help extension</td></tr>

<tr><td><a href="#dotemacs">inf-snd.el, DotEmacs</a></td>
    <td onmouseover="return escape('a Snd emacs mode implementation.  You can use emacs as the listener, rather\
 than the built-in Snd window.')">Emacs subjob support (Michael Scholz, Fernando Lopez-Lezcano)</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#jcrevdoc">jcrev</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('probably the first Schroeder reverb, based on all-pass and comb filters.')">John Chowning's ancient reverb</td></tr>

<tr><td><a href="#ladspadoc">ladspa.scm, ladspa-help.scm, gui.scm</a></td>
    <td onmouseover="return escape('LADSPA is the linux audio group plugin standard. There are a lot\
 of plugin collections.')">Kjetil S. Matheussen's LADSPA GUI-builder and previewer.</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#maracadoc">maraca</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('includes the maraca and related noise makers: tambourine, wind-chimes, etc')">Perry Cook's maraca physical model</td></tr>

<tr><td><a href="#marksdoc">marks</a></td>
    <td onmouseover="return escape('includes describe-mark, eval-between-marks, mark-property,\
 play-between-marks, snap-marks.')">functions related to marks</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#maxfdoc">maxf</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('This is a collection of modal synthesis demos.  For the actual filter, see mfilter\
 in dsp.scm.')">Max Mathews resonator</td></tr>

<tr><td><a href="#menusdoc">menus</a></td>
    <td onmouseover="return escape('Menu additions for things like crop, trim,\
 fft notch filter, mark and mix functions, etc.  The main one loads a huge set of sound effects.')">additional menus</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#mixdoc">mix</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('mix-property, delete-all-mixes, mix-sound, pan-mix, save-mix,\
 snap-mix-to-beat; similar functions for tracks')">functions related to mixes and tracks</td></tr>

<tr><td><a href="#mixerdoc">mixer</a></td>
    <td onmouseover="return escape('matrix determinant, transpose, invert, using the CLM\
 mixer and frame generators')">functions related to mixers and frames (linear algebra)</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#moogdoc">moog</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('four pole lowpass (24db/Oct) filter clm generator, variable resonance,\
 warm, analog sound.')">Moog filter</td></tr>

<tr><td><a href="#musglyphs">musglyphs</a></td>
    <td onmouseover="return escape('A music symbol font in lisp using bezier curves')">Music notation symbols (from CMN)</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#nbdoc">nb</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('As you move the mouse through the view-files list, the help dialog posts information about\
 the file underneath the mouse')">Popup File info etc</td></tr>

<tr><td><a href="#noisedoc">noise</a></td>
    <td onmouseover="return escape('The ancient noise instrument can produce those all-important whooshing\
 sounds')">noise.ins from CLM translated to Scheme/Ruby by Michael Scholz</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#oscopedoc">oscope</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('oscope.scm sets up a dialog with a Snd channel window (time domain, fft etc) that displays the\
 data read from the microphone in real time.')">an oscilloscope/spectrum analysis dialog</td></tr>

<tr><td><a href="#peakenvdoc">peak-env</a></td>
    <td onmouseover="return escape('These files save the overall amplitude envelopes for a given sound so\
 that a subsequent re-open of that sound can display the full waveform immediately')">peak envelope support</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#pianodoc">piano</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('the model includes multiple coupled strings, a nonlinear hammer, and an arbitrarily\
 large soundboard and enclosure')">piano physical model</td></tr>

<tr><td><a href="#playdoc">play</a></td>
    <td onmouseover="return escape('play between marks, play continuously, play a set of sines, etc')">play-related functions</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#polydoc">poly</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('polynomial addition, multiplication, division, gcd, roots, and discriminant')">polynomial-related stuff</td></tr>

<tr><td><a href="#popupdoc">popup, gtk-popup</a></td>
    <td onmouseover="return escape('context-sensitive popup menus.  You get a different popup menu over\
 the main graph, the fft, the selection, the listener, etc')">Popup menu specializations</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#prc95doc">prc95</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('The basic physical models: pluck, bow, clarinet, brass, flute')">Perry Cook's physical model examples</td></tr>

<tr><td><a href="#pvocdoc">pvoc</a></td>
    <td onmouseover="return escape('A scheme implementation of the CLM phase-vocoder generator.')">phase-vocoder</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#rgbdoc">rgb</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('a translation of the standard X11 color names into Snd color objects.')">color names</td></tr>

<tr><td><a href="#rtexdoc">rt-examples and friends</a></td>
    <td onmouseover="return escape('hard (glitch-free) real-time support for CLM instruments, as well as numerous other\
 extensions of Snd for user interface development')">hard real-time support</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#rtiodoc">rtio</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('show graph of real-time input and so on')">real-time stuff</td></tr>

<tr><td><a href="#rubberdoc">rubber</a></td>
    <td onmouseover="return escape('rubber-sound tries to stretch or contract a sound (in time); it scans the\
 sound looking for stable sections, then either deletes periods or interpolates new ones to shorten or lengthen the sound')">rubber-sound</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#singerdoc">singer</a></td>
    <td bgcolor="#f6f8ff">Perry Cook's vocal-tract physical model</td></tr>

<tr><td><a href="#snd4doc">snd4|5|6|7|8.scm</a></td>
    <td>Backwards compatibility</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#sndgldoc">snd-gl</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('a waterfall fft graph, GL state readbacks')">OpenGL examples (gl.c)</td></tr>

<tr><td><a href="#sndmotifdoc">snd-motif, snd-gtk, snd-xm</a></td>
    <td onmouseover="return escape('user interface extensions using the libxm modules: add-mark-pane,\
 display-scanned-synthesis, load-font, with-level-meters, variable-display, smpte labels, etc')">Motif/Gtk module (xm.c, xg.c)</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#sndtestdoc">snd-test</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('a zillion tests -- useful as a source of examples')">Snd regression tests</td></tr>

<tr><td><a href="#sndwarpdoc">sndwarp</a></td>
    <td onmouseover="return escape('stretch a sound')">Bret Battey's sndwarp instrument</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#spectrdoc">spectr</a></td>
    <td bgcolor="#f6f8ff">instrument steady state spectra</td></tr>

<tr><td><a href="#stochasticdoc">stochastic</a></td>
    <td>Bill Sack's dynamic stochastic synthesis</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#straddoc">strad</a></td>
    <td bgcolor="#f6f8ff">string physical model (from CLM)</td></tr>

<tr><td><a href="#vdoc">v</a></td>
    <td onmouseover="return escape('a wonderful instrument!')">fm-violin</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#wsdoc">ws</a></td>
    <td bgcolor="#f6f8ff" onmouseover="return escape('with-sound provides a simple way to package up a bunch of instrument calls into a new sound file,\
 and open that file in Snd when the computation is complete')">with-sound</td></tr>

<tr><td><a href="#zipdoc">zip</a></td>
    <td onmouseover="return escape('The zipper marches through the two sounds taking equal short portions of each,\
 then abutting them while resampling so that as one takes less overall frame space, the other takes more.')">the zipper (the anti-cross-fader)</td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#extsndasneededexpl">A Note on "As-Needed" input functions</a></td>
    <td bgcolor="#f6f8ff"></td></tr>

<tr><td><a href="#extsndcgens">A Note on User-defined Generators in C-CLM</a></td>
    <td ></td></tr>

<tr><td bgcolor="#f6f8ff"><a href="#noisystory">A Note on Noise Reduction</a></td>
    <td bgcolor="#f6f8ff"></td></tr>

</table>
</td></tr></table>

<br><br>


<!-- ---------------------------------------- FILE: analog-filter ---------------------------------------- -->

<A NAME="analogfilterdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>analog-filter</h2></td></tr></table>

<!-- main-index |analogfilterdoc:butterworth filters -->
<!-- main-index |analogfilterdoc:bessel filters -->
<!-- main-index |analogfilterdoc:elliptic filters -->
<!-- main-index |analogfilterdoc:chebyshev filters -->
<pre>
    <em class=emdef>make-butterworth-lowpass</em> order fcut
    <em class=emdef>make-butterworth-highpass</em> order fcut
    <em class=emdef>make-butterworth-bandpass</em> order flo fhi
    <em class=emdef>make-butterworth-bandstop</em> order flo fhi

    <em class=emdef>make-chebyshev-lowpass</em> order fcut (ripple-dB 1.0)
    <em class=emdef>make-chebyshev-highpass</em> order fcut (ripple-dB 1.0)
    <em class=emdef>make-chebyshev-bandpass</em> order flo fhi (ripple-dB 1.0)
    <em class=emdef>make-chebyshev-bandstop</em> order flo fhi (ripple-dB 1.0)

    <em class=emdef>make-inverse-chebyshev-lowpass</em> order fcut (loss-dB 60.0)
    <em class=emdef>make-inverse-chebyshev-highpass</em> order fcut (loss-dB 60.0)
    <em class=emdef>make-inverse-chebyshev-bandpass</em> order flo fhi (loss-dB 60.0)
    <em class=emdef>make-inverse-chebyshev-bandstop</em> order flo fhi (loss-dB 60.0)

    <em class=emdef>make-bessel-lowpass</em> order fcut
    <em class=emdef>make-bessel-highpass</em> order fcut
    <em class=emdef>make-bessel-bandpass</em> order flo fh
    <em class=emdef>make-bessel-bandstop</em> order flo fh

    <em class=emdef>make-elliptic-lowpass</em> order fcut (ripple-dB 1.0) (loss-dB 60.0)
    <em class=emdef>make-elliptic-highpass</em> order fcut (ripple-dB 1.0) (loss-dB 60.0)
    <em class=emdef>make-elliptic-bandpass</em> order flo fhi (ripple-dB 1.0) (loss-dB 60.0)
    <em class=emdef>make-elliptic-bandstop</em> order flo fhi (ripple-dB 1.0) (loss-dB 60.0)

    ;; fcut = cutoff frequency in terms of srate = 1.0, flo = low freq of band, fhi = high freq of band
</pre>

<p>analog-filter.scm has the usual IIR filters: Butterworth, Chebyshev, inverse Chebyshev, Bessel,
and Elliptic filters in lowpass, highpass, bandpass, and bandstop versions.  Each of the associated
"make" functions returns a function ready for use as a filter (using the CLM filter generator).
The filter order should be an even number; very high orders can cause numerical disaster!  If you
want to push these guys, be sure to build Snd with the --with-doubles configuration switch.  The
elliptic filters depend on GSL, so you'll also need GSL (Snd's configure script includes it by default, if possible).
</p>
<pre>
    (let* ((flt (make-elliptic-lowpass 8 .1))) ; 8th order elliptic with cutoff at .1 * srate
      (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> flt))                       ; flt is a clm filter generator
</pre>
<p>
One quick way to see the frequency response of your filter is to create a sound that sweeps a sinewave upward
in frequency, run it through the filter, then view the entire sound, treating the x axis as frequency
in terms of srate = 1.0 (for convenience):
</p>
<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(define (filter-sweep flt)
  (let ((ind (<a class=quiet href="extsnd.html#newsound">new-sound</a> "flt.snd" mus-next mus-bfloat 44100 1 #f 22050))
	(phase 0.0)
	(freq 0.0)
	(incr (/ (* 2 pi) 44100.0)))   ; go to srate/2 in 0.5 secs
    (<a class=quiet href="extsnd.html#mapchannel">map-channel</a>                       ; 0.5 secs because we preset the length above to 22050
     (lambda (y)                       ; ignore current value (0.0)
       (let ((val (* .5 (sin phase))))
	 (set! phase (+ phase freq)) 
	 (set! freq (+ freq incr))
	 (<a class=quiet href="clm.html#filter">filter</a> flt val))))
    (set! (<a class=quiet href="extsnd.html#xbounds">x-bounds</a>) (list 0.0 0.5)))) ; view entire sound

(filter-sweep (<em class=red>make-butterworth-lowpass</em> 8 .1))
</pre></td></tr></table>

<table border=0 cellpadding=5 vspace=10 hspace=20><tr><td>
<img src="iir.png" alt="iir filters">
</td><td>
<pre>
;; this shows filter-sweep with:
(make-butterworth-lowpass 8 .1)
(make-elliptic-lowpass 8 .1)
(make-butterworth-bandpass 8 .1 .2)
(make-elliptic-bandpass 8 .1 .2)
</pre>
</td></tr>
</table>


<table bgcolor="aliceblue" border=0><tr><td>
<pre>see also: <a href="#dspdoc" onmouseover="return escape('many more filters')">dsp</a> <a href="#exampdoc" onmouseover="return escape('comb-filter, time-varying filters, etc')">examp</a> <a href="#moogdoc" onmouseover="return escape('Moog filter')">moog</a> <a href="#maxfdoc" onmouseover="return escape('Mathews resonator')">maxf</a> <a href="#prc95doc" onmouseover="return escape('DC block')">prc95</a> <a href="#grapheqdoc" onmouseover="return escape('graphic equalizer instrument')">graphEq</a> <a href="clm.html#filter" onmouseover="return escape('CLM filter generators')">clm</a>
</pre></td>
</tr></table>
<br>



<!-- ---------------------------------------- FILE: autosave ---------------------------------------- -->

<A NAME="autosavedoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>autosave</h2></td></tr></table>

<!-- main-index |autosavedoc:auto-save -->
<A NAME="autosave"></A>
<pre>
  <em class=emdef>auto-save</em>
  <em class=emdef>cancel-auto-save</em>
</pre>
<!-- I(auto save):L(auto-save)(exautosave) -->
<!-- I(auto save):A(exautosave) -->

<p>The auto-save code sets up a background process that checks periodically for
unsaved edits, and if any are found it saves them in a temporary file (the name is the base file name enclosed in "#...#" and placed in
the <a href="extsnd.html#tempdir">temp-dir</a> directory).
The time between checks
is set by the variable <i>auto-save-interval</i> which defaults to 60.0 seconds.
To start auto-saving, <code>(load "autosave.scm")</code>.  Thereafter <code>(cancel-auto-save)</code>
stops autosaving, and <code>(auto-save)</code> restarts it.
</p>
<br>


<!-- ---------------------------------------- FILE: bess ---------------------------------------- -->

<A NAME="bessdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>bess</h2></td></tr></table>

<p>bess.scm is a Guile script (independent of Snd) that loads sndlib and xmlib into Guile,
opens the DAC, puts up a bunch of scale widgets, and starts two CLM oscils doing
frequency modulation in semi-real-time (how "real-time" it is depends on your
audio setup).  This is a translation to the Sndlib/Libxm system of bess.cl in CLM.
Michael Scholz has contributed a Ruby translation of this with many improvements:
bess.rb.  You may need to make bess.scm executable before running it: <code>chmod 777 bess.scm</code>.
If you get "command not found", you need to edit the path to guile in the source.
</p>

<table border=0 hspace=20>
<tr><td>
<img src="fm.png" alt="fm dialog">
</td><td>
<pre>
   ;; bess opens the DAC, continuously sends the following:
   (* amp 
      (<a class=quiet href="clm.html#oscil">oscil</a> carosc 
        (+ (<a class=quiet href="clm.html#hztoradians">hz-&gt;radians</a> frequency)
           (* index (<a class=quiet href="clm.html#oscil">oscil</a> modosc 
                      (<a class=quiet href="clm.html#hztoradians">hz-&gt;radians</a> (* ratio frequency)))))))
</pre>
</td></tr></table>
<br>

<p>bess1.scm and bess1.rb are scripts (independent of Snd), similar to bess.scm and bess.rb,
that give you real-time GUI-based control over the fm-violin while it cycles around in a simple
compositional algorithm.  Both were written by
Michael Scholz, based on CLM's bess5.cl and rt.lisp.
</p>

<table bgcolor="aliceblue" border=0><tr><td>
<pre>see also: <a href="fm.html#fmintro" onmouseover="return escape('introduction to FM')">fm</a>
</pre></td>
</tr></table>

<br>
<br>


<!-- ---------------------------------------- FILE: bird ---------------------------------------- -->

<A NAME="birddoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>bird</h2></td></tr></table>
<pre>
  <a class=def name="bird">bird</a> start dur frequency freqskew amplitude freq-envelope amp-envelope
  <a class=def name="bigbird">bigbird</a> start dur frequency freqskew amplitude freq-envelope amp-envelope partials
  <em class=emdef>one-bird</em> beg maxdur func birdname
  <a class=def name="makebirds">make-birds</a> :optional (output-file "test.snd")
</pre>
<p>
bird.scm is a translation of the Sambox/CLM bird songs.  The two instruments set
up a simple sine wave (bird) and simple waveshaping synthesis (bigbird).  Use a
low-pass filter for distance effects (a bird song sounds really silly
reverberated).  All the real information is in the amplitude and frequency
envelopes.  These were transcribed from sonograms found in some bird guides and articles from
the Cornell Ornithology Lab. 

Many of these birds were used in "Colony".  To hear all the
birds, <code>(make-birds)</code>.  This writes the sequence out as "test.snd" using with-sound.
Waveshaping is described in Le Brun, "Digital Waveshaping Synthesis", JAES 1979 April, vol 27, no 4, p250.
The lines
</p>
<pre>
   ...
   (coeffs (<a class=quiet href="clm.html#partialstopolynomial">partials-&gt;polynomial</a> (normalize-partials partials)))
   ...
	     (<a class=quiet href="clm.html#polynomial">polynomial</a> coeffs
			 (<a class=quiet href="clm.html#oscil">oscil</a> os (<a class=quiet href="clm.html#env">env</a> gls-env))))))
			 <!-- ((( -->
</pre>
<p>setup and run the waveshaping synthesis (in this case it's just a fast
additive synthesis).  <b>partials-&gt;polynomial</b> calculates the Chebyshev
polynomial coefficients given the desired spectrum; the spectrum then
results from driving that polynomial with an oscillator.  Besides the
bird guides, there are now numerous recordings of birds that can
be turned into sonograms and transcribed as envelopes.
</p>
<p>In CLM, the bird is:</p>

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(<a class=quiet href="clm.html#definstrument">definstrument</a> bird (startime dur frequency freq-skew amplitude freq-envelope amp-envelope 
	             &amp;optional (lpfilt 1.0) (degree 0) (reverb-amount 0))
  (multiple-value-bind (beg end) (<a class=quiet href="clm.html#timestosamples">times-&gt;samples</a> startime dur)
    (let* ((amp-env (<a class=quiet href="clm.html#make-env">make-env</a> amp-envelope amplitude dur))
	   (gls-env (<a class=quiet href="clm.html#make-env">make-env</a> freq-envelope (<a class=quiet href="clm.html#hztoradians">hz-&gt;radians</a> freq-skew) dur))
	   (loc (<a class=quiet href="clm.html#make-locsig">make-locsig</a> :degree degree :distance 1.0 :reverb reverb-amount))
	   (fil (<a class=quiet href="clm.html#make-one-pole">make-one-pole</a> lpfilt (- 1.0 lpfilt)))
	   (s (<a class=quiet href="clm.html#make-oscil">make-oscil</a> :frequency frequency)))
      (run
       (loop for i from beg to end do
	 (<a class=quiet href="clm.html#locsig">locsig</a> loc i (<a class=quiet href="clm.html#one-pole">one-pole</a> fil (* (<a class=quiet href="clm.html#env">env</a> amp-env) (<a class=quiet href="clm.html#oscil">oscil</a> s (<a class=quiet href="clm.html#env">env</a> gls-env))))))))))
</pre></td></tr></table>

<p>The bird.scm version could easily include the one-pole filter and so on.
The Ruby version of this file is bird.rb.  Just for comparison, the bird instrument
in Ruby is:</p>

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
def bird(start, dur, frequency, freqskew, amplitude, freq_envelope, amp_envelope)
  gls_env = make_env(freq_envelope, hz2radians(freqskew), dur)
  os = make_oscil(frequency)
  amp_env = make_env(amp_envelope, amplitude, dur)
  beg = (srate() * start).round
  len = (srate() * dur).round
  local_data  = make_vct len
  vct_map!(local_data, Proc.new { || env(amp_env) * oscil(os, env(gls_env)) })
  vct_add!($out_data, local_data, beg)
end
</pre></td></tr></table>

<p>The Forth version (written by Michael Scholz) is:
</p>

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
instrument: bird { f: start f: dur f: freq f: freq-skew f: amp freq-env amp-envel }
    freq make-oscil-1 { os }
    amp-envel amp dur make-env { amp-env }
    freq-env freq-skew hz&gt;radians dur make-env { gls-env }
    90e random 1e make-locsig { loc }
    start dur run  amp-env env  gls-env env os oscil-1  f*  i loc locsig  loop
;instrument
</pre></td></tr></table>
<br>
<br>



<!-- ---------------------------------------- FILE: clm-ins ---------------------------------------- -->

<A NAME="clminsdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>clm-ins</h2></td></tr></table>

<p>These are instruments from CLM translated for use in Snd.  All expect to be called within <a href="clm.html#with-sound">with-sound</a>
or some equivalent environment. This set of instruments is a bit of a grab-bag; some are just examples of synthesis techniques;
a few others are historical, rather than useful.  If I were using, for example, the fm trumpet,
I'd remove all the attack and decay parameters, moving that up a level to Common Music or whoever calls the trumpet,
and combine several other parameters to reflect the desired output, rather than the details of the algorithm;
30 parameters could be reduced to less than 10, and the resulting instrument would be much easier to use.
But, it is an historical artifact, so I'm reluctant to change it.  
</p>

<p>To try out any of these instruments, start Snd, set optimization to 6, load ws.scm and clm-ins.scm, then
simply paste the with-sound call into the listener.  It will automatically write the
new sound file and open it in Snd.
</p>

<table border=0 cellspacing=0 hspace=20>

<!-- anoi -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>anoi</em> <code>(file start dur :optional (fftsize 128) (amp-scaler 1.0) (r 6.28))</code>
</td></tr><tr><td width=60></td><td>
anoi is a stab at noise reduction
based on Perry Cook's Scrubber.m.  It tracks an on-going average spectrum, then tries
to squelch that, obviously aimed at reducing background noise in an intermittent signal.
<pre>
    (with-sound () (anoi "now.snd" 0 2))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- attract -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>attract</em> <code>(beg dur amp c)</code>
</td></tr><tr><td></td><td>
attract is a translation to CLM of an instrument developed by James McCartney (CMJ vol 21 no 3 p 6),
based on a "chaotic" equation.
'c' should be between 1 and 10 or thereabouts.
<pre>
    (with-sound () (attract 0 1 .1 1) (attract 1 1 .1 5))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- bes-fm -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>bes-fm</em> <code>(beg dur freq amp ratio index)</code>
</td></tr><tr><td></td><td>
bes-fm is J1(J1): <code>(bes-j1 (* index (bes-j1 phase)))</code>; it uses the Bessel functions where FM uses sinusoids.  J0 is also good in this context,
and the few other Jn options that I've tried were ok.
<pre>
   Scheme:  (with-sound () (bes-fm 0 1 440 10.0 1.0 4.0))
   Ruby:    with_sound() do bes_fm(0, 0.5, 440, 5, 1, 8) end
</pre>
So why does this work?  My "back-of-the-envelope" guess is that the Bessel functions
are basically a bump at the start followed by a decaying sinusoid, so
the bump
gives us a percussive attack, and the damped sinusoid gives us
a dynamic spectrum, mimicking FM more or less.

The Bessel functions I0, Jn, and Yn are built-in; Kn and In are implemented in Scheme in snd-test.scm.
</td></tr><tr><td colspan=2 height=16></td></tr>

<!-- main-index |bagpipe:bagpipe -->
<!-- canter -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="bagpipe">canter</A> <code>(beg dur freq amp ...)</code>
</td></tr><tr><td></td><td>
canter is half of a bagpipe instrument developed by Peter Commons (the other portion is <a href="#drone">drone</a> below).
The (required) trailing parameters are:
<pre>
  deg dis pcrev ampfun ranfun skewfun skewpc ranpc ranfreq indexfun atdr dcdr
  ampfun1 indfun1 fmtfun1 ampfun2 indfun2 fmtfun2 ampfun3 indfun3 fmtfun3 ampfun4 indfun4 fmtfun4
</pre>
Here is a portion of a bagpipe tune:
<pre>
(let ((fmt1 '(0 1200 100 1000))
      (fmt2 '(0 2250 100 1800))
      (fmt3 '(0 4500 100 4500))
      (fmt4 '(0 6750 100 8100))
      (amp1 '(0 .67 100 .7))
      (amp2 '(0 .95 100 .95))
      (amp3 '(0 .28 100 .33))
      (amp4 '(0 .14 100 .15))
      (ind1 '(0 .75 100 .65))
      (ind2 '(0 .75 100 .75))
      (ind3 '(0 1 100 1))
      (ind4 '(0 1 100 1))
      (skwf '(0 0 100 0))
      (ampf '(0 0 25 1 75 1 100 0))
      (ranf '(0 .5 100 .5))
      (index '(0 1 100 1))
      (solid '(0 0 5 1 95 1 100 0))
      (bassdr2 '(.5 .06 1 .62 1.5 .07 2.0 .6 2.5 .08 3.0 .56 4.0 .24 5 .98 6 .53 7 
                 .16 8 .33 9 .62 10 .12 12 .14 14 .86 16 .12 23 .14 24 .17))
      (tenordr '(.3 .04 1 .81 2 .27 3 .2 4 .21 5 .18 6 .35 7 .03 8 .07 9 .02 10 .025 11 .035)))
  (with-sound (:reverb nrev)
    (drone .000 4.000 115.000 (* .25 .500) solid bassdr2 .100 .500 .030 45.000 1 .010 10)
    (drone .000 4.000 229.000 (* .25 .500) solid tenordr .100 .500 .030 45.000 1 .010 11)
    (drone .000 4.000 229.500 (* .25 .500) solid tenordr .100 .500 .030 45.000 1 .010 9)
    (canter .000 2.100 918 (* .25 .700) 45.000 1 .050 ampf ranf skwf 
             .050 .010 10 index .005 .005 amp1 ind1 fmt1 amp2 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
    (canter  2.100  .300 688.5  (* .25 .700)  45.000 1  .050 ampf ranf skwf
	     .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
    (canter  2.400  .040 826.2  (* .25 .700)  45.000 1  .050 ampf ranf skwf
	     .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
    (canter  2.440  .560 459  (* .25 .700)  45.000 1  .050 ampf ranf skwf
	     .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
    (canter  3.000  .040 408  (* .25 .700)  45.000 1  .050 ampf ranf skwf
	     .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
    (canter  3.040  .040 619.65  (* .25 .700)  45.000 1  .050 ampf ranf skwf
	     .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
    (canter  3.080  .040 408  (* .25 .700)  45.000 1  .050 ampf ranf skwf
	     .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
    (canter  3.120  .040 688.5  (* .25 .700)  45.000 1  .050 ampf ranf skwf
	     .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
    (canter  3.160  .290 459  (* .25 .700)  45.000 1  .050 ampf ranf skwf
	     .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
    (canter  3.450  .150 516.375  (* .25 .700)  45.000 1  .050 ampf ranf skwf
	     .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
    (canter  3.600  .040 826.2  (* .25 .700)  45.000 1  .050 ampf ranf skwf
	     .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
    (canter  3.640  .040 573.75  (* .25 .700)  45.000 1  .050 ampf ranf skwf
	     .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
    (canter  3.680  .040 619.65  (* .25 .700)  45.000 1  .050 ampf ranf skwf
	     .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
    (canter  3.720  .180 573.75  (* .25 .700)  45.000 1  .050 ampf ranf skwf
	     .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
    (canter  3.900  .040 688.5  (* .25 .700)  45.000 1  .050 ampf ranf skwf
	     .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
    (canter  3.940  .260 459  (* .25 .700)  45.000 1  .050 ampf ranf skwf
	     .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)))
</pre>
It is not easy to keep track of all these arguments in a long note-list; hence the
development of programs such as Score (Leland Smith), Pla (yers truly), and Common Music (Rick Taube).
The full note list is bag.clm in the CLM tarball.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- main-index |cellon:feedback fm -->
<!-- cellon -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="cellon">cellon</A> <code>(beg dur freq amp ...)</code>
</td></tr><tr><td></td><td>
cellon, developed by Stanislaw Krupowiecz, uses feedback FM as in some old synthesizers.  There's a brief discussion of it in fm.html.
The trailing parameters are:
<pre>
    ampfun betafun beta0 beta1 betaat betadc ampat ampdc dis pcrev deg pitch1 glissfun glissat 
    glissdc pvibfreq pvibpc pvibfun pvibat pvibdc rvibfreq rvibpc rvibfun
</pre>
and I actually don't know what they all do.  I think they're dealing with attack and decay portions
of envelopes; in the old days we felt we had to store one envelope, then kludge around with attack and decay
timings to bash that envelope into the correct shape; this made instruments needlessly messy.
Here's a call:
<pre>
    (with-sound () 
      (cellon 0 2 220 .1 '(0 0 25 1 75 1 100 0) '(0 0 25 1 75 1 100 0) .75 1.0 0 0 0 0 1 0 0 220 
              '(0 0 25 1 75 1 100 0) 0 0 0 0 '(0 0 100 0) 0 0 0 0 '(0 0 100 0)))
</pre>
The use of x axis values between 0 and 100, rather than 0.0 and 1.0 is a dead give-away that
this is really ancient stuff.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- clm-expsrc -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="clmexpsrc">clm-expsrc</A> <code>(beg dur input-file exp-ratio src-ratio amp :optional rev start-in-file)</code>
</td></tr><tr><td></td><td>
clm-expsrc can stretch or compress a sound (using granular synthesis) while optionally changing its sampling rate.
'exp-ratio' sets the expansion amount (greater than 1.0 makes the sound longer), and
'src-ratio' sets the sampling rate change (greater than 1.0 makes it higher in pitch).
So to make a sound twice as long, but keep the pitch the same:
<pre>
    (with-sound () (clm-expsrc 0 4 "oboe.snd" 2.0 1.0 1.0))
</pre>
'start-in-file' sets where we start reading the input file (in seconds); it defaults to 0.0.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- drone -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="drone">drone</A> <code>(beg dur freq amp ampfun synth ampat ampdc amtrev deg dis rvibamt rvibfreq)</code>
</td></tr><tr><td></td><td>
This is the other half of Peter Common's bagpipe -- see canter above.
'synth' is a list of partials loaded into a table and read via <a href="clm.html#table-lookup">table-lookup</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- expfil -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>expfil</em> <code>(start duration hopsecs rampsecs steadysecs file1 file2)</code>
</td></tr><tr><td></td><td>
expfile interleaves two granular synthesis processes (two readers pasting in tiny sections
of their file, one after the other).
<pre>
    (with-sound () 
      (expfil 0 2 .2 .01 .1 "oboe.snd" "fyow.snd")
      (expfil 2 2 .01 .01 .02 "oboe.snd" "fyow.snd"))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- exp-snd -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>exp-snd</em> <code>(file beg dur amp :optional (exp-amt 1.0) (ramp .4) (seglen .15) (sr 1.0) (hop .05) ampenv)</code>
</td></tr><tr><td></td><td>
exp-snd is a granular synthesis instrument with envelopes on
the expansion amount ('exp-amt' as a list), segment ramp steepness ('ramp' as a list), 
segment length ('seglen' as a list), hop length ('hop' as a list), amplitude ('ampenv'),
and resampling rate ('sr' as a list).
In the next example, the expansion amount in both calls goes from 1 to 3 over the course of the note,
the ramp time and segment lengths stay the same, the sampling rate changes from 2 to 0.5, and the hop
stays the same (.05 in the first, and .2 in the second).
<pre>
    (with-sound ()
      (exp-snd "fyow.snd" 0 3 1 '(0 1 1 3) 0.4 .15 '(0 2 1 .5) 0.05)
      (exp-snd "oboe.snd" 1 3 1 '(0 1 1 3) 0.4 .15 '(0 2 1 .5) 0.2))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- main-index |fmbell:fm-bell -->
<!-- fm-bell -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="fmbell">fm-bell</A> <code>(beg dur frequency amplitude amp-env index-env index)</code>
</td></tr><tr><td></td><td>
fm-bell is an <a href="fm.html#fmintro">FM</a> instrument developed by Michael McNabb in Mus10 in the late '70s.  It is intended
for low bell sounds (say middle C or so). The lines
<pre>
  (mod1 (<a class=quiet href="clm.html#make-oscil">make-oscil</a> (* frequency 2)))
  (mod2 (<a class=quiet href="clm.html#make-oscil">make-oscil</a> (* frequency 1.41)))
  (mod3 (<a class=quiet href="clm.html#make-oscil">make-oscil</a> (* frequency 2.82)))
  (mod4 (<a class=quiet href="clm.html#make-oscil">make-oscil</a> (* frequency 2.4)))
  (car1 (<a class=quiet href="clm.html#make-oscil">make-oscil</a> frequency))
  (car2 (<a class=quiet href="clm.html#make-oscil">make-oscil</a> frequency))
  (car3 (<a class=quiet href="clm.html#make-oscil">make-oscil</a> (* frequency 2.4)))
</pre>
set up three FM pairs, car1 and mod1 handling the basic harmonic spectra,
car2 and mod2 creating inharmonic spectra (using the square root of 2 more or less
at random), and car3 and mod3 putting a sort of formant at the minor third
(2.4 = a ratio of 12/5 = octave+6/5 = minor tenth).
<pre>
(with-sound ()
  (let ((fbell '(0 1 2 1.1000 25 .7500 75 .5000 100 .5000))
        (abell '(0 0 .1000 1 10 .6000 25 .3000 50 .1500 90 .1000 100 0)))
    (fm-bell 0.0 2.0 220.0 .5 abell fbell 0.5)))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- main-index |fmdrum:fm-drum -->
<!-- fm-drum -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="fmdrum">fm-drum</A> <code>(beg dur freq amp ind :optional (high #f) (deg 0.0) (dist 1.0) (rev-amount 0.01))</code>
</td></tr><tr><td></td><td>
The fm-drum uses "cascade FM" (see fm.html); it was developed by Jan Mattox.
<pre>
    (with-sound () (fm-drum 0 1.5 55 .3 5 #f) (fm-drum 1.5 1.5 66 .3 4 #t))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- fm-insect -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>fm-insect</em> <code>(beg dur freq amp ampenv modfreq modskew modenv index indexenv fmindex ratio deg dist rev)</code>
</td></tr><tr><td></td><td>
The fm-insect started as an attempt to get cicada sounds from FM (for the 5th movement of "Colony"), but
ended with:
<pre>
(with-sound (:srate 22050) 
  (let ((locust '(0 0 40 1 95 1 100 .5))
	(bug_hi '(0 1 25 .7 75 .78 100 1))
	(amp    '(0 0 25 1 75 .7 100 0)))
    (fm-insect 0      1.699  4142.627  .015 amp 60 -16.707 locust 500.866 bug_hi  .346  .500)
    (fm-insect 0.195   .233  4126.284  .030 amp 60 -12.142 locust 649.490 bug_hi  .407  .500)
    (fm-insect 0.217  2.057  3930.258  .045 amp 60 -3.011  locust 562.087 bug_hi  .591  .500)
    (fm-insect 2.100  1.500   900.627  .06  amp 40 -16.707 locust 300.866 bug_hi  .346  .500)
    (fm-insect 3.000  1.500   900.627  .06  amp 40 -16.707 locust 300.866 bug_hi  .046  .500)
    (fm-insect 3.450  1.500   900.627  .09  amp 40 -16.707 locust 300.866 bug_hi  .006  .500)
    (fm-insect 3.950  1.500   900.627  .12  amp 40 -10.707 locust 300.866 bug_hi  .346  .500)
    (fm-insect 4.300  1.500   900.627  .09  amp 40 -20.707 locust 300.866 bug_hi  .246  .500)))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- main-index |fmtrumpet:fm-trumpet -->
<!-- fm-trumpet -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="fmtrumpet">fm-trumpet</A> <code>(beg dur ...)</code>
</td></tr><tr><td></td><td>
This is Dexter Morrill's FM-trumpet; see CMJ feb 77 p51.
<pre>
    (with-sound () (fm-trumpet 0 .25))
</pre>
As with many instruments from that era, it has a million parameters:
<pre>
    beg dur :key (frq1 250.0) (frq2 1500.0) (amp1 0.5) (amp2 0.1)
    (ampatt1 0.03) (ampdec1 0.35) (ampatt2 0.03) (ampdec2 0.3)
    (modfrq1 250.0) (modind11 0.0) (modind12 2.66) 
    (modfrq2 250.0) (modind21 0.0) (modind22 1.8) 
    (rvibamp 0.007) (rvibfrq 125.0) (vibamp 0.007) (vibfrq 7.0) (vibatt 0.6) (vibdec 0.2)
    (frqskw 0.03) (frqatt 0.06) 
    (ampenv1 '(0 0  25 1  75 .9  100 0)) (ampenv2 '(0 0  25 1  75 .9  100 0)) 
    (indenv1 '(0 0  25 1  75 .9  100 0)) (indenv2 '(0 0  25 1  75 .9  100 0))
    (degree 0.0) (distance 1.0) (reverb-amount 0.005)
</pre>
The pitch depends on the 'modfrq1' and 'modfrq2' parameters, as well as 'frq1' and 'frq2':
<pre>
    (with-sound () (fm-trumpet 0 1 :frq1 400 :frq2 1600 :modfrq1 400 :modfrq2 400))
</pre>
</td></tr>
<tr><td colspan=2 height=16></td></tr>

<!-- main-index |fofins:FOF synthesis -->
<!-- fofins -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="fofins">fofins</A> <code>(beg dur frq amp uvib f0 a0 f1 a1 f2 a2 :optional (amp-env '(0 0 1 1 2 1 3 0)))</code>
</td></tr>
<tr><td></td><td>
fofins is an implementation of <A HREF="http://www-ccrma.stanford.edu/~serafin/320/lab3/FOF_synthesis.html">FOF synthesis</A>, taken originally from
fof.c of Perry Cook and the article
"Synthesis of the Singing Voice" by Bennett and Rodet in
"Current Directions in Computer Music Research" (MIT Press).
FOF synthesis sets up a wave with the desired spectrum (to mimic vocal formats, for example),
then calls <a href="clm.html#wave-train">wave-train</a> to turn that into a tone.
fofins just adds an amplitude envelope and vibrato.
In the Scheme version, there is also an optional trailing vibrato envelope argument (this is slightly different from the CL version):
<pre>
(with-sound ()  ; slowly ramp up the vibrato
  (fofins 0 4 270 .1 0.005 730 .6 1090 .3 2440 .1 
          '(0 0 .5 1 3 .5 10 .2 20 .1 50 .1 60 .2 85 1 100 0)
	  '(0 0 40 0 75 .2 100 1) )
  (fofins 0 4 (* 6/5 540) .1 0.005 730 .6 1090 .3 2440 .1 
          '(0 0 .5 .5 3 .25 6 .1 10 .1 50 .1 60 .2 85 1 100 0)
	  '(0 0 40 0 75 .2 100 1) )
  (fofins 0 4 135 .1 0.005 730 .6 1090 .3 2440 .1 
          '(0 0 1 3 3 1 6 .2 10 .1 50 .1 60 .2 85 1 100 0)
	  '(0 0 40 0 75 .2 100 1)))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- main-index |fullmix:fullmix -->
<!-- fullmix -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="fullmix">fullmix</A> <code>(infile :optional beg outdur inbeg matrix srate reverb-amount)</code>
</td></tr><tr><td></td><td>
fullmix is a complicated way to mix stuff. It's built into the CL version of CLM, so there was clamor for some sort
of replacement in other versions of CLM. 
fullmix provides a mixer that can handle any number
of channels of data in and out with scalers and envelopes on any path, sampling rate conversion,
reverb -- you name it! 
'infile' is the file to be mixed:
<pre>
    (with-sound () (fullmix "pistol.snd")) ; this places pistol.snd at time 0
</pre>
'beg' is the start time of the mix in the output sound; 
'outdur' is the duration of the mixed-in portion in the output;
'inbeg' is where to start the mix in the input file:
<pre>
    (with-sound () (fullmix "pistol.snd" 1.0 2.0 0.25)) 
    ;; start at 0.25 in pistol.snd, include next 2 secs, put at time 1.0 in output
</pre>
'srate' is the amount of sampling rate conversion to apply, and
'reverb' is the amount of the signal to send to the reverberator:
<pre>
    (with-sound (:reverb nrev) (fullmix "pistol.snd" 1.0 2.0 0.25 #f 2.0 0.1)) ; up an octave, lots of reverb!
</pre>
The 'matrix' parameter is much harder to describe.  It is either a number or a list of lists.
In the first case, that number is the amplitude scaler on the output:
<pre>
    (with-sound (:reverb nrev) (fullmix "pistol.snd" 1.0 2.0 0.25 0.2 2.0 0.1)) ; same but much softer (0.2 amp)
</pre>
If 'matrix' is a list of lists, each element of the inner lists can be either a number or list a breakpoints (an envelope).
If a number, it is treated as an amplitude scaler for that input and output channel combination.  Each inner list
represents an input channel, so if we have a stereo input file going to a stereo output file and we want
the channels to be mixed straight, but channel 0 at .5 amp and channel 1 at .75:
<pre>
    (with-sound (:channels 2) (fullmix "2a.snd" #f #f #f '((0.5 0.0) (0.0 0.75))))
    ;;                                                       ^   ^     ^   ^
    ;;                                                       |   |     |   |
    ;;                                                    0->0   |  1->0   |
    ;;                                                        0->1      1->1
</pre>
So, 2a.snd's first channel gets mixed into the output's first channel, scaled by 0.5, 
and its second channel goes to the output second channel scaled by 0.75.
If we have four channels in and are writing a mono file, and want to mix in
only the second channel of the input:
<pre>
   (with-sound (:channels 1) (fullmix "4.aiff" #f #f #f '((0.0) (1.0) (0.0) (0.0))))
</pre>
The next complication is that each entry in the inner lists can also be a list of
envelope breakpoints.  In that case, an envelope is applied to that portion of the
mix, rather than just a scaler:
<pre>
    (with-sound (:channels 2) (fullmix "oboe.snd" #f #f #f (list (list (list 0 0 1 1 2 0) 0.5))))
    ;; mono input so one list, envelope output chan 0, scale output chan 1 (two copies of input) 
</pre>
And finally(!) each inner list element can also be a CLM env generator:
<pre>
    (with-sound (:channels 2)
      (fullmix "oboe.snd" 1 2 0 (list (list .1 (<a class=quiet href="clm.html#make-env">make-env</a> '(0 0 1 1) :duration 2 :scaler .5)))))
</pre>
Here's a Ruby example:
<pre>
    with_sound(:channels, 2, :statistics, true) do
      fullmix("pistol.snd")
      fullmix("oboe.snd", 1, 2, 0, [[0.1, make_env([0, 0, 1, 1], :duration, 2, :scaler, 0.5)]])
    end
</pre>
Now we need filters!
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- gong -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>gong</em> <code>(beg dur freq amp :key (degree 0.0) (distance 1.0) (reverb-amount 0.005))</code>
</td></tr><tr><td></td><td>
gong is an FM instrument developed by Paul Weineke.
<pre>
    Scheme:  (with-sound () (gong 0 3 261.61 .3))
    Ruby:    with_sound() do gong(0, 3, 261.61, 0.6) end
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- gran-synth -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>gran-synth</em> <code>(beg dur freq grain-dur grain-hop amp)</code>
</td></tr><tr><td></td><td>
gran-synth sets up a <a href="clm.html#wave-train">wave-train</a> playing an enveloped
sinusoid (the "grain" in this case).  'grain-dur' sets the grain's length (in seconds),
'grain-hop' sets the frequency of the wave-train generator (how quickly the grain is
repeated), and 'freq' sets the grain sinusoid's frequency.
<pre>
    (with-sound () (gran-synth 0 1 300 .0189 .03 .4)) ; grain freq 300Hz, repetition rate 33Hz
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- main-index |grapheq:graphic equalizer -->
<!-- graphEq -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="grapheq">graphEq</A> <code>(file :key beg dur or-beg amp (amp-env '(0 1.0 0.8 1.0 1.0 0.0)) (amp-base 1.0) ...)</code>
</td></tr><tr><td></td><td>
<A NAME="grapheqdoc">graphEq</A> is a sort of non-graphical graphical equalizer, developed by Marco Trevisani. It sets up a bank of formant
generators with an optional envelope on each formant, then filters and envelopes the input file.
Its trailing parameters are:
<pre>
    (offset-gain 0)  
    (gain-freq-list '((0 1 1 0) 440 (0 0 1 1) 660))      
    (filt-gain-scale 1)                   
    (filt-gain-base 1)                    
    (a1 .99)
    (stats #t)
</pre>
'a1' is the formant radius.
'gain-freq-list' is a list of gains and frequencies to
filter
The gains can be either numbers or envelopes (one or the other, not a mixture).
'offset-gain' is an offset (addition) to all the gains.
'filt-gain-scale' and 'filt-gain-base' are similar, but apply to the envelopes, if any.
'stats' prints encouraging numbers if #t.
<pre>
    (with-sound () (graphEq "oboe.snd")) ; accept all the defaults (Scheme is case sensitive)
</pre>
If we want just steady bands:
<pre>
    (with-sound () (graphEq "oboe.snd" 0 0 0 1.0 '(0 1 1 0) 1.0 0 '(.1 440 .3 1500 .2 330)))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- hammondoid -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>hammondoid</em> <code>(beg dur freq amp)</code>
</td></tr><tr><td></td><td>
hammondoid is Perry Cook's additive-synthesis Hammond organ.
<pre>
    (with-sound () (hammondoid 0 1 440 .1))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- jl-reverb -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>jl-reverb</em> <code>(:optional (decay 3.0))</code>
</td></tr><tr><td></td><td>
jl-reverb is a cavernous version of John Chowning's ancient reverberator.  You can never get enough reverb!
<pre>
    (with-sound (:reverb jl-reverb) (fm-violin 0 .1 440 .1 :reverb-amount .1))
</pre>
'decay' is the reverb decay time tacked onto the end of the output sound.
To pass parameters to a reverberator, use the with-sound parameter :reverb-data.  So, if we want
5 seconds of decay:
<pre>
    (with-sound (:reverb jl-reverb :reverb-data '(5.0)) (fm-violin 0 .1 440 .1 :reverb-amount .1))
    ;;                                            ^ this is passed as (jl-reverb 5.0)
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- lbj-piano -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>lbj-piano</em> <code>(beg dur freq amp :key (pfreq frequency) (degree 45) (reverb-amount 0) (distance 1))</code>
</td></tr><tr><td></td><td>
lbj-piano, developed by Doug Fulton, uses James A Moorer's piano spectra and
additive synthesis to mimic a piano.
<pre>
    (with-sound () (lbj-piano 0 2 110.0 .2))
</pre>
Doug says, "The high notes sound pretty rotten" and thinks perhaps
one major problem is the lack of mechanical noise.
'pfreq' sets which spectrum to use; it defaults to whatever matches 'freq'.
<pre>
    (with-sound () (lbj-piano 0 2 110.0 .2 :pfreq 550))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- metal -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>metal</em> <code>(beg dur freq amp)</code>
</td></tr><tr><td></td><td>
metal is another Perry Cook creation (HeavyMtl); it's an FM instrument:
<pre>
    (with-sound () (metal 0 1 440 .2))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- main-index |nrev:nrev -->
<!-- nrev -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="nrev">nrev</A> <code>(:key (reverb-factor 1.09) (lp-coeff 0.7) (volume-1 1.0))</code>
</td></tr><tr><td></td><td>
nrev, developed by Michael McNabb, is one of the more popular old-style reverbs. 
It is much cleaner than jc-reverb.
<pre>
    (with-sound (:reverb nrev) (fm-violin 0 .1 440 .1 :reverb-amount .1))
</pre>
'reverb-factor' controls the length of the decay -- it should not exceed 1.21 or so.
'lp-coeff' controls the strength of the low pass filter inserted in the feedback loop.
'volume-1' can be used to boost the reverb output.
<pre>
    (with-sound (:reverb nrev :reverb-data '(:lp-coeff 0.9 :volume-1 2.0)) 
      (fm-violin 0 .1 440 .1 :reverb-amount .1))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- main-index |pins:SMS synthesis -->
<!-- pins -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="pins">pins</A> <code>(beg dur file amp ...)</code>
</td></tr><tr><td></td><td>
pins is a simple implementation of the spectral modeling synthesis
of Xavier Serra and Julius Smith (sometimes known as "Sansy" or "SMS").  See
Serra, X., J. O. Smith. 1990. "Spectral Modeling Synthesis:A Sound Analysis/Synthesis Based on a Deterministic plus Stochastic Decomposition". Computer Music Journal, vol. 14(4), 1990.
The idea behind SMS is similar to the phase vocoder,
but tracks spectral peaks so that its resynthesis options are much more sophisticated.
The trailing parameters are:
<pre>
  :key (transposition 1.0) (time-scaler 1.0) (fft-size 256) 
       (highest-bin 128) (max-peaks 16) printit attack
</pre>
'transposition' can be used to transpose a sound;
'time-scaler' changes the sound's duration;
'fft-size' may need to be larger if your sampling rate is 44100, or the input sound's
fundamental is below 300 Hz;
'highest-bin' sets how many fft bins we search for spectral peaks;
'max-peaks' sets how many peaks we track (at a maximum) through the sound;
'printit', if set to #t, causes the peak envelopes to be printied;
'attack' is an optional vct containing the attack portion of the new sound.
<pre>
    Scheme:  (with-sound () (pins 0.0 1.0 "now.snd" 1.0 :time-scaler 2.0))
    Ruby:    with_sound() do pins(0, 1, "now.snd", 1, :time_scaler, 2) end
</pre>
Xavier has a website devoted to this system:
<A HREF="http://www.iua.upf.es/mtg/sms">Spectral Modeling Synthesis</A>
which has moved to the CLAM site:
<A HREF="http://clam.iua.upf.es/">CLAM-SMSTools</A>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- main-index |pluck:pluck -->
<!-- pluck -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="pluck">pluck</A> <code>(beg dur freq amp :optional (weighting .5) (lossfact .9))</code>
</td></tr><tr><td></td><td>
pluck is based on
the <A HREF="http://ccrma.stanford.edu/~jos/SimpleStrings/Karplus_Strong_Algorithm.html">Karplus-Strong</A> algorithm as extended by David Jaffe and Julius Smith -- see 
Jaffe and Smith, "Extensions of the Karplus-Strong Plucked-String Algorithm"
CMJ vol 7 no 2 Summer 1983, reprinted in "The Music Machine".
The basic idea is to fill an array with noise, then filter the array values as it is played repeatedly,
giving a sharp attack and a ringing decay, much like plucking a guitar.  The CMJ article
gives many variations, changing pick position and so on.  Jaffe's "Silicon Valley Breakdown"
makes great use of this instrument.
'weighting' is the ratio of the once-delayed to the twice-delayed samples.  It defaults to .5 which gives a short decay;
anything other than .5 produces a longer decay.  It should be between 0.0 and 1.0. 
'lossfact' can be used to shorten decays.  The most useful values are between .8 and 1.0. 
<pre>
(with-sound () 
  (pluck 0 1 330 .3 .95 .95) 
  (pluck 1 2 330 .3 .9 .9999) 
  (pluck 3 2 330 .3 .8 .99))
</pre>
In Ruby:
<pre>
  with_sound() do pluck(0.05, 0.1, 330, 0.1, 0.95, 0.95) end
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- main-index |pqwvox:waveshaping voice -->
<!-- pqw-vox -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="pqwvox">pqw-vox</A> <code>(beg dur freq spacing-freq amp ampfun freqfun freqscl phonemes formant-amps formant-shapes)</code>
</td></tr><tr><td></td><td>
pqw-vox is an extension of Marc LeBrun's instrument vox (described below) to use phase-quadrature (single-sideband)
waveshaping.  It uses both Chebyshev polynomial kinds to set up spectra-producing pairs of waveshapers that will
add in such a way as to cancel either the upper or lower set of sidebands.  These are then ganged together as in
the vox instrument to mimic moving formants.
<pre>
    (with-sound () 
      (pqw-vox 0 1 300 300 .1 '(0 0 50 1 100 0) '(0 0 100 1) .3 '(0 L 100 L) '(.5 .25 .1) 
              '((1 1 2 .5) (1 .5 2 .5 3 1) (1 1 4 .5))))

    (with-sound ()
      (pqw-vox 0 2 200 200 .1 '(0 0 50 1 100 0) '(0 0 100 1) .1 '(0 UH 100 ER) '(.8 .15 .05) 
               '((1 1 2 .5) (1 1 2 .5 3 .2 4 .1) (1 1 3 .1 4 .5)))
      (pqw-vox 2 2 200 314 .1 '(0 0 50 1 100 0) '(0 0 100 1) .01 '(0 UH 100 ER) '(.8 .15 .05) 
               '((1 1 2 .5) (1 1 4 .1) (1 1 2 .1 4 .05)))
      (pqw-vox 4 2 100 414 .2 '(0 0 50 1 100 0) '(0 0 100 1) .01 '(0 OW 50 E 100 ER) '(.8 .15 .05) 
               '((1 1 2 .5 3 .1 4 .01) (1 1 4 .1) (1 1 2 .1 4 .05))))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- pqw -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>pqw</em> <code>(beg dur freq spacing-freq carrier-freq amplitude ampfun indexfun partials ...)</code>
</td></tr><tr><td></td><td>
pqw is a simple phase-quadrature waveshaping instrument which produces asymmetric spectra.
The trailing parameters just set the usual degree, distance, and reverb values.
<pre>
    (with-sound () (pqw 0 .5 200 1000 .2 '(0 0 25 1 100 0) '(0 1 100 0) '(2 .1 3 .3 6 .5)))
</pre>
To see the asymmetric spectrum most clearly, set the index function above to '(0 1 100 1).
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- resflt -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>resflt</em> <code>(beg dur driver ...)</code>
</td></tr><tr><td></td><td>
resflt, developed by Richard Karpen and Xavier Serra, sets up three resonators (two-pole filters), 
then drives them with either white noise or a sum-of-cosines pulse train.
Both can be used for vocal effects:
<pre>
    (with-sound () 
      (resflt 0 1.0 0 0 0 #f .1 200 230 10 '(0 0 50 1 100 0) '(0 0 100 1) 
              500 .995 .1 1000 .995 .1 2000 .995 .1)
      (resflt 1 1.0 1 10000 .01 '(0 0 50 1 100 0) 0 0 0 0 #f #f 
              500 .995 .1 1000 .995 .1 2000 .995 .1))
</pre>
The trailing parameters are:
<pre>
     ranfreq noiamp noifun cosamp cosfreq1 cosfreq0 cosnum ampcosfun freqcosfun 
     frq1 r1 g1 frq2 r2 g2 frq3 r3 g3
     :key (degree 0.0) (distance 1.0)(reverb-amount 0.005)
</pre>
Set 'driver' to 0 to get the pulse train, or to 1 to get white noise.
In the latter case, 'ranfreq' is the random number generator frequency, 'noiamp' is its amplitude,
and 'noifun' is an amplitude envelope on its output (filter input)
In the pulse case, 'cosamp' is the pulse train amplitude, 'ampcosfun' the amplitude envelope,
'cosfreq0' and 'cosfreq1' set the frequency limits of 'freqcosfun',
and 'cosnum' sets the number of cosines in the pulse.
The three resonators are centered at 'frq1', 'frq2', 'frq3',
with pole-radius 'r1', 'r2', and 'r3' respectively, and
with gains of 'g1', 'g2', and 'g3'.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- main-index |reson:fm-voice -->
<!-- reson -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="reson">reson</A> <code>(beg dur freq amp ...)</code>
</td></tr><tr><td></td><td>
reson is a vocal simulator developed by John Chowning.  Its trailing parameters are:
<pre>
    numformants indxfun skewfun pcskew skewat skewdc vibfreq vibpc ranvibfreq ranvibpc 
    degree distance reverb-amount data

    'data' is a list of lists of form 
      '(ampf resonfrq resonamp ampat ampdc dev0 dev1 indxat indxdc)
</pre>
Needless to say, no one has ever written out these parameters by hand, so here's an all-time first:
<pre>
    (with-sound ()
      (reson 0.0 1.0 440 .1 2 '(0 0 100 1) '(0 0 100 1) .1 .1 .1 5 .01 5 .01 0 1.0 0.01
   	     '(((0 0 100 1) 1200 .5 .1 .1 0 1.0 .1 .1) ((0 1 100 0) 2400 .5 .1 .1 0 1.0 .1 .1))))
</pre>
But JC got very nice vocal sounds from this -- I must have mistyped somewhere...
Here's another stab at it:
<pre>
(with-sound ()
      (reson 0.0 1.0 440 .1 2 '(0 1 100 0) '(0 0 100 1) .01 .1 .1 5 .01 5 .01 0 1.0 0.01
   	     '(((0 1 100 1) 1000 .65 .1 .1 0 1.0 .1 .1) ((0 0 100 1) 2400 .15 .1 .1 0 1.0 .1 .1))))
</pre>
If you find a good example, please send me it!
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- rhodey -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>rhodey</em> <code>(beg dur freq amp :optional (base .5))</code>
</td></tr><tr><td></td><td>
rhodey is another of Perry Cook's instruments (an electric piano), based on a pair of FM generators.
<pre>
    (with-sound () (rhodey 0 1 440 .2))
</pre>
One of the oscillators is set to a frequency 15 times the requested 'freq', so for higher notes, you'll need to set the srate higher:
<pre>
    (with-sound (:srate 44100) (rhodey 0 1 880 .2))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- main-index |rmsgain:rms, gain, balance gens -->
<!-- rms gain balance -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="rmsgain">rms</a> <code>gen sig</code><br>
<em class=emdef>balance</em> <code>gen sig comparison</code><br>
<em class=emdef>gain</em> <code>gen sig rsmval</code><br>
<em class=emdef>make-rmsgain</em> <code>:optional (hp 10.0)</code>
</td></tr><tr><td></td><td>
rms, balance, and gain are an implementation of the balance generators of CLM (based
on CSound originals, Scheme versions originally provided by Fabio Furlanete). 
This section is a paraphrase of balance.html in the CLM tarball which was
written by Sam Hiesz.
balance, rms, and gain are used to track the RMS value of a signal and use
that information to scale some other signal.  rms returns the RMS value;
gain takes a signal and an RMS value and modifies the signal to track the RMS
value; balance packages gain and rms into one function call.
make-rmsgain returns the generator used by rms, gain, and balance.
The 'hp' parameter sets the speed with which the balance process
tracks the RMS signal.  An example is worth a zillion words:

<table border=0 cellpadding=5 hspace=10 vspace=10><tr><td bgcolor="#fafafa"><pre>
      (with-sound (:channels 3)
        (let ((rg (make-rmsgain))
	      (rg1 (make-rmsgain 40))
	      (rg2 (make-rmsgain 2))
	      (e (<a class=quiet href="clm.html#make-env">make-env</a> '(0 0 1 1 2 0) :end 10000))
	      (e1 (<a class=quiet href="clm.html#make-env">make-env</a> '(0 0 1 1) :end 10000))
	      (e2 (<a class=quiet href="clm.html#make-env">make-env</a> '(0 0 1 1 2 0 10 0) :end 10000))
	      (o (<a class=quiet href="clm.html#make-oscil">make-oscil</a> 440.0)))
	  (do ((i 0 (1+ i)))
	      ((= i 10000))
	    (let ((sig (<a class=quiet href="clm.html#env">env</a> e)))
	      (<a class=quiet href="clm.html#outa">outa</a> i (balance rg sig (<a class=quiet href="clm.html#env">env</a> e2)) *output*)
	      (<a class=quiet href="clm.html#outa">outb</a> i (balance rg1 sig (<a class=quiet href="clm.html#env">env</a> e1)) *output*)
	      (<a class=quiet href="clm.html#outa">outc</a> i (balance rg2 (* .1 (<a class=quiet href="clm.html#oscil">oscil</a> o)) (<a class=quiet href="clm.html#env">env</a> e2)) *output*)))))
</pre></td></tr></table>
</td></tr><tr><td colspan=2 height=16></td></tr>



<!-- scratch -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="scratch">scratch</a> <code>(beg file src-ratio turnlist)</code>
</td></tr><tr><td></td><td>
scratch moves back and forth in a sound file according to
a list of turn times much like <a href="#envsoundinterp">env-sound-interp</a>.
With voice input, we can create a "Remembrance of Bugs Bunny":
<pre>
    Scheme: (with-sound () (scratch 0.0 "now.snd" 1.5 '(0.0 .5 .25 1.0)))
    Ruby:   with_sound() do scratch(0, "now.snd", 1.5, [0.0, 0.5, 0.25, 1.0]) end
</pre>
I translate this as: "go forward from 0.0 to 0.5 secs, backwards to 0.25 secs, then forward to 1.0 secs".
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- main-index |spectra:additive synthesis -->
<!-- spectra -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="spectra">spectra</A> <code>(beg dur freq amp ...)</code>
</td></tr><tr><td></td><td>
spectra is an additive-synthesis instrument with vibrato and an amplitude envelope.  It was intended originally
to be used with the spectra in spectra.scm (information laboriously gathered at the dawn of the computer era
by James A Moorer).  One such spectrum is labelled "p-a4", so we can hear it via:
<pre>
    (load "spectr.scm")
    (with-sound () 
      (spectra 0 1 440.0 .1 p-a4 '(0.0 0.0 1.0 1.0 5.0 0.9 12.0 0.5 25.0 0.25 100.0 0.0)))
</pre>
The trailing parameters are:
<pre>
 :optional (partials '(1 1 2 0.5))
           (amp-envelope '(0 0 50 1 100 0))
           (vibrato-amplitude 0.005)
           (vibrato-speed 5.0)
           (degree 0.0)
           (distance 1.0)
           (reverb-amount 0.005)
</pre>
We can pass our own partials:
<pre>
    (with-sound ()
      (spectra 0 1 440.0 .1 '(1.0 .4 2.0 .2 3.0 .2 4.0 .1 6.0 .1) 
               '(0.0 0.0 1.0 1.0 5.0 0.9 12.0 0.5 25.0 0.25 100.0 0.0)))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- ssb-fm -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="ssbfm">ssb-fm</a> gen <code>modsig</code><br>
<em class=emdef>make-ssb-fm</em> <code>freq</code>
</td></tr><tr><td></td><td>
These two functions implement
a sort of asymmetric FM using ideas similar to those used in <a href="clm.html#ssb-am">ssb-am</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- main-index |stereoflute:flute model -->
<!-- stereo-flute -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="stereoflute">stereo-flute</A> <code>(beg dur freq flow ...)</code>
</td></tr><tr><td></td><td>
This is a physical model of a flute developed by Nicky Hind.
<pre>
    Scheme:
    (with-sound (:channels 2) 
       (stereo-flute 0 1 440 0.55 :flow-envelope '(0 0 1 1 2 1 3 0))
       (stereo-flute 1 3 220 0.55 :flow-envelope '(0 0 1 1 2 1 3 0)))

    Ruby:
    with_sound() do stereo_flute(0, 2, 440, 0.55, :flow_envelope, [0, 0, 1, 1, 2, 1, 3, 0]) end
</pre>

The trailing parameters are:

<pre>
:key (flow-envelope '(0 1 100 1))
     (decay 0.01) 		; additional time for instrument to decay
     (noise 0.0356) 
     (embouchure-size 0.5)
     (fbk-scl1 0.5)		; these two are crucial for good results
     (fbk-scl2 0.55)
     (offset-pos 0.764264)      ; from 0.0 to 1.0 along the bore
     (out-scl 1.0)
     (a0 0.7) (b1 -0.3)	        ; filter coefficients
     (vib-rate 5) 
     (vib-amount 0.03)
     (ran-rate 5) 
     (ran-amount 0.03)
</pre>
As with physical models in general, you may need to experiment a bit to find
parameters that work.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- main-index |telephone:telephone -->
<!-- touch-tone -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="telephone">touch-tone</A> <code>(beg number)</code>
</td></tr><tr><td></td><td>
This instrument produces telephone tones:
<pre>
    Scheme:  (with-sound () (touch-tone 0.0 '(7 2 3 4 9 7 1)))
    Ruby:    with_sound() do touch_tone(0, [7, 2, 3, 4, 9, 7, 1]) end
</pre>
It is just two sine waves whose frequencies are chosen based on the number pressed.
<pre>
  1     2     3   697 Hz
  4     5     6   770 Hz
  7     8     9   852 Hz
        0         941 Hz
 1209  1336  1477 Hz
</pre>
For more than you really want to know about other such sounds, see
<A HREF="http://www.tech-faq.com/telephone-tone-frequencies.shtml">Telephone Tone Frequencies</A>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- main-index |tubebell:tubular bell -->
<!-- tubebell -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="tubebell">tubebell</A> <code>beg dur freq amp :optional (base 32.0)</code>
</td></tr><tr><td></td><td>
Perry Cook's tubular bell:
<pre>
    (with-sound () 
      (tubebell 0 2 440 .1 32.0) 
      (tubebell 2 2 220 .1 64.0) 
      (tubebell 4 2 660 .1 .032))
</pre>
'base' is the envelope base:
<pre>
    (with-sound () 
      (tubebell 0 2 440 .1 32.0) 
      (tubebell 2 2 220 .1 2048.0) 
      (tubebell 4 3 660 .1 .032))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- main-index |twotab:spectral interpolation -->
<!-- two-tab -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="twotab">two-tab</A> <code>beg dur freq amp ...</code>
</td></tr><tr><td></td><td>
two-tab interpolates between two spectra.
<pre>
    (with-sound () (two-tab 0 2 440 .1 '(1.0 1.0) '(3.0 1.0)))
    ;; go from harmonic 1 to harmonic 3
</pre>
The trailing parameters are:
<pre>
:optional (partial-1 '(1.0 1.0 2.0 0.5))
          (partial-2 '(1.0 0.0 3.0 1.0))
          (amp-envelope '(0 0 50 1 100 0))
          (interp-func '(0 1 100 0))
          (vibrato-amplitude 0.005)
          (vibrato-speed 5.0)
          (degree 0.0)
          (distance 1.0)
          (reverb-amount 0.005)
</pre>
'interp-func' determines how we interpolate between the two spectra.  When
it is at 1.0, we get only the first, at 0.0 only the second.
<pre>
    (with-sound () (two-tab 0 2 440 .1 '(1.0 1.0) '(3.0 1.0) '(0 0 1 1 2 0) '(0 0 1 1)))
</pre>
is the reverse of the earlier sound.  To go out and back:
<pre>
    (with-sound () (two-tab 0 2 440 .1 '(1.0 1.0) '(3.0 1.0) '(0 0 1 1 2 0) '(0 0 1 1 2 0)))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- main-index |fmvox:fm-talker -->
<!-- vox -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="fmvox">vox</A> <code>(beg dur freq amp ampfun freqfun freqscl voxfun index vibscl)</code>
</td></tr><tr><td></td><td>
vox is a translation of Marc LeBrun's MUS10 waveshaping voice instrument
using FM in this case.  
The basic idea is that each of the three vocal formants is created by two
sets of waveshapers (or oscils producing FM), one centered on the even multiple of the base frequency closest to the desired formant frequency,
and the other on the nearest odd multiple.  As the base frequency moves (due to vibrato or glissando),
these center frequencies are recalculated on each sample, and the respective amplitudes
set to reflect the distance of the current center frequency from the desired formant frequency.  If a center frequency moves 
enough that the previous upper member of the pair has
to become the lower member, the upper waveshaper (which has meanwhile ramped to zero amplitude), jumps
down to its new center. The male-speaker formant table was provided by Robert Poor (see the code
for the complete table of formants).
For details on waveshaping, see Le Brun, "Digital Waveshaping Synthesis", JAES 1979 April, vol 27, no 4, p250.
I used vox in the 5th movement of "Colony" and in "The New Music Liberation Army".
<pre>
(with-sound ()
  (let ((amp-env '(0 0 25 1 75 1 100 0))
        (frq-env '(0 0 5 .5 10 0 100 1)))
  (vox 0 2 170 .4 amp-env frq-env .1 
    '(0 E 25 AE 35 ER 65 ER 75 I 100 UH) '(.8 .15 .05) '(.005 .0125 .025) .05 .1)
  (vox 2 2 110 .4 amp-env frq-env .5 
    '(0 UH 25 UH 35 ER 65 ER 75 UH 100 UH) '(.8 .15 .05) '(.005 .0125 .025))
  (vox 4 2 300 .4 amp-env frq-env .1 
    '(0 I 5 OW 10 I 50 AE 100 OO) '(.8 .15 .05) '(.05 .0125 .025) .02 .1)))
</pre>

Or in Ruby:
<pre>
with_sound() do
  amp_env = [0, 0, 25, 1, 75, 1, 100, 0]
  frq_env = [0, 0, 5, 0.5, 10, 0, 100, 1]
  vox(0, 2, 170, 0.4, amp_env, frq_env, 0.1, 
       [0, :E, 25, :AE, 35, :ER, 65, :ER, 75, :I, 100, :UH], 0.05, 0.1)
  vox(2, 2, 300, 0.4, amp_env, frq_env, 0.1, 
       [0, :I, 5, :OW, 10, :I, 50, :AE, 100, :OO], 0.02, 0.1)
  vox(4, 5, 600, 0.4, amp_env, frq_env, 0.1, 
       [0, :I, 5, :OW, 10, :I, 50, :AE, 100, :OO], 0.01, 0.1)
end
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- wurley -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>wurley</em> <code>beg dur freq amp</code>
</td></tr><tr><td></td><td>
Perry Cook's Wurlitzer (I assume).
<pre>
    (with-sound () (wurley 0 1 440 .1))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- za, zc, zn -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>za</em> <code>time dur freq amp length1 length2 feedback feedforward</code><br>
<em class=emdef>zc</em> <code>time dur freq amp length1 length2 feedback</code><br>
<em class=emdef>zn</em> <code>time dur freq amp length1 length2 feedforward</code>
</td></tr><tr><td></td><td>
The "z" instruments demonstrate "zdelay" effects -- interpolating
comb, notch, and all-pass filters.
<pre>
    (with-sound () (zn 0 1   100 .1 20 100 .995) 
		   (zn 1.5 1 100 .1 100 20 .995)
		   (zc 3 1   100 .1 20 100 .95) 
		   (zc 4.5 1 100 .1 100 20 .95)
		   (za 6 1   100 .1 20 100 .95 .95) 
		   (za 7.5 1 100 .1 100 20 .95 .95))
</pre>
</td></tr>

</table>

<p>snd-test.scm has examples of calling all these instruments.  For more examples of instruments,
there are a variety of separate files such as v.scm, and 
clm23.scm has a translation of
the CLM test instruments.  It also has some comments about
the differences between the CL and Scheme instruments.
</p>

<table bgcolor="aliceblue" border=0><tr>
<td>
<pre>see also: <a href="#birddoc" onmouseover="return escape('bird and bigbird')">bird</a> <a href="clm.html#clmtop" onmouseover="return escape('many examples')">clm</a> <a href="#dlocsigdoc" onmouseover="return escape('moving sounds')">dlocsig</a> <a href="#exampdoc" onmouseover="return escape('sound effects')">examp</a> <a href="#fadedoc" onmouseover="return escape('frequency domain cross fade')">fade</a> <a href="fm.html#fmintro" onmouseover="return escape('FM examples')">fm</a> <a href="#vdoc" onmouseover="return escape('realtime fm-violin controls')">fmv</a> <a href="#freeverbdoc" onmouseover="return escape('a reverberator')">freeverb</a> <a href="#grapheqdoc" onmouseover="return escape('graphic equalizer')">graphEq</a> <a href="#granidoc" onmouseover="return escape('granular synthesis')">grani</a> <a href="#jcrevdoc" onmouseover="return escape('an old reverberator')">jcrev</a> <a href="#maracadoc" onmouseover="return escape('maraca physical models')">maraca</a> 
          <a href="#maxfdoc" onmouseover="return escape('a resonator')">maxf</a> <a href="#noisedoc" onmouseover="return escape('noise-maker')">noise</a> <a href="#pianodoc" onmouseover="return escape('piano physical model')">piano</a> <a href="#prc95doc" onmouseover="return escape('several physical models')">prc95</a> <a href="#pvocdoc" onmouseover="return escape('phase-vocoder')">pvoc</a> <a href="#rtexdoc" onmouseover="return escape('real-time examples')">rt-examples</a> <a href="#singerdoc" onmouseover="return escape('singer physical model')">singer</a> <a href="#sndwarpdoc" onmouseover="return escape('sound effect')">sndwarp</a> <a href="#stochasticdoc" onmouseover="return escape('dynamic stochastic synthesis')">stochastic</a> <a href="#straddoc" onmouseover="return escape('violin physical model')">strad</a> <a href="#wsdoc" onmouseover="return escape('with-sound')">ws</a>
</pre>
</td></tr></table>

<br>
<br>


<!-- ---------------------------------------- FILE: debug ---------------------------------------- -->

<A NAME="debugdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>debug</h2></td></tr></table>

<pre>
  <a class=def name="snddebug">snd-debug</a>               ; enable some command shortcuts
  <a class=def name="sndtrace">snd-trace</a>               ; enable trace output
  <a class=def name="sndbreak">snd-break</a> (message #f)  ; set a breakpoint
</pre>
<!-- INDEX debugdoc:Debugging (break/trace) -->

<p>debug.scm is a package of Guile-specific debugging aids.
snd-break sets a breakpoint; if it is called, you drop into the Snd debugger.
You can continue from the breakpoint, optionally returning any value you like.
While in the break context (while the listener prompt says "break"), 
these functions are available:
</p>
<pre>
  <em class=emdef>break-go</em> (returned-value #f)    ; continue execution from breakpoint, return 'returned-value'
  <em class=emdef>break-locals</em> (stack-location 0) ; display local variables 
  <em class=emdef>break-local</em> local-var (stack-location 0) ; print a local's value ('local-var' is a symbol or string)
  <em class=emdef>break-backtrace</em> (all #f)        ; display stack at breakpoint (5 levels by default, 'all' = #t: all levels)
  <em class=emdef>break-help</em>                      ; display some help
  <em class=emdef>break-quit</em>                      ; exit current break level
  <em class=emdef>break-quit!</em>                     ; exit all break levels, return to top level
</pre>
<p>
Here is a brief session in Snd's listener:
</p>
<pre>
    <em class=listener>:</em><em class=typing>(define (test-break a) (let ((b (+ a (snd-break "hiho")))) b))</em>
    <em class=listener>#&lt;unspecified&gt;</em>
    <em class=listener>:</em><em class=typing>(define hi 123)</em>
    <em class=listener>#&lt;unspecified&gt;</em>
    <em class=listener>:</em><em class=typing>(set! hi (test-break 1))</em>
    <em class=listener>break:("hiho")</em>
    <em class=listener>break:</em><em class=typing>hi</em>
    <em class=listener>123</em>
    <em class=listener>break:</em><em class=typing>(break-go 32)</em>
    <em class=listener>:#&lt;unspecified&gt;</em>
    <em class=listener>:</em><em class=typing>hi</em>
    <em class=listener>33</em>
</pre>
<p>We put a breakpoint in the midst of an expression in the 'test-break' function,
asking it to type "hiho" and drop into the debugger if it is executed.  Then we call
'test-break' in an expression that sets the variable 'hi'.  The breakpoint is hit, "hiho"
gets reported, and we're placed in the debugger.  The debugger is
just the Snd listener, but with some extra context to implement the break support.
After poking around, we call break-go with an argument of 32.  This causes the original
set! to continue with 32 plugged in where the snd-break call was, setting hi to 33.
</p>
<p>
snd-debug sets up some information needed by the 'bt' and 'lv' commands:
</p>
<pre>
  <em class=emdef>bt</em>                 ; show backtrace
  <em class=emdef>lv</em> (:optional obj) ; show local var(s)
</pre>
<p>
These are active outside a breakpoint, so once set up, you can use them whenever an error occurs.
snd-trace activates any tracing
that you may have requested and redirects its output to the Snd listener.
Here's how to trace fm-violin calls in a notelist:
</p>
<pre>
    (trace fm-violin)
    (<em class=red>snd-trace</em> (with-sound () (fm-violin 0 1 440 .1)))
</pre>
<p>To turn off the trace</p>
<pre>
    (untrace fm-violin)
</pre>
<br>


<!-- ---------------------------------------- FILE: dlocsig ---------------------------------------- -->

<A NAME="dlocsigdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>dlocsig</h2></td></tr></table>

<p><a name="dlocsig">dlocsig</a> is a CLM generator developed by Fernando Lopez-Lezcano that can move sounds in two or three dimensions.
Fernando's CLM/lisp-oriented documentation can be found in
<a href="dlocsig.html">dlocsig.html</a>.
dlocsig.rb is Michael Scholz's translation of dlocsig to Ruby.
It has lots of documentation and examples.  If you load dlocsig.rb, a new menu is added named "Dlocsig".
If you choose a path from this menu, you get a graphical user-interface to play with the various
envelopes that drive dlocsig.  Click the "With_Snd" button to apply the current path choices to the
currently selected sound.  Click "Gnuplot" to get a pretty picture of the path (in 3D!).
A simple instrument that uses dlocsig is:
</p>

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(define* (sinewave start-time duration freq amp :key (amp-env '(0 1 1 1))
		   (path (make-path :path '(-10 10 0 5 10 10))))
  (let* ((vals (<em class=red>make-dlocsig</em> :start-time start-time :duration duration :path path))
	 (dloc (car vals))
	 (beg (cadr vals))
	 (end (caddr vals)))
    (let* ((osc (<a class=quiet href="clm.html#make-oscil">make-oscil</a> :frequency freq))
	   (aenv (<a class=quiet href="clm.html#make-env">make-env</a> :envelope amp-env :scaler amp :duration duration)))
      (run
       (lambda ()
	 (do ((i beg (1+ i)))
	     ((= i end))
	   (<em class=red>dlocsig</em> dloc i (* (<a class=quiet href="clm.html#env">env</a> aenv) (<a class=quiet href="clm.html#oscil">oscil</a> osc)))))))))

(with-sound (:channels 2) (sinewave 0 1.0 440 .5 :path (make-path '((-10 10) (0.5 0.5) (10 10)) :3d #f)))
</pre></td></tr></table>
<br><br>



<!-- ---------------------------------------- FILE: draw ---------------------------------------- -->

<A NAME="drawdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>draw</h2></td></tr></table>

<p>draw.scm has examples of graphics-oriented extensions.  The most useful one is make-current-window-display.
</p>

<table border=0 cellspacing=0 hspace=20>

<!-- click-for-listener-help -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="clickforlistenerhelp">click-for-listener-help</A> <code>pos</code>
</td></tr><tr><td width=60></td><td>
click-for-listener-help is intended as a <a href="extsnd.html#listenerclickhook">listener-click-hook</a> function.  It posts help about
the closest entity it can find whenever you double click in the listener.  Unfortunately, the help
dialog is a bit clunky for a use like this, but the minibuffer has only one line, and
tooltips are irritating in their own way; perhaps it should post the help at the bottom of
the listener?
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- color-samples -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>color-samples</em> <code>color :optional beg dur snd chn</code><br>
<em class=emdef>uncolor-samples</em> <code>:optional snd chn</code>
</td></tr><tr><td width=60></td><td>
color-samples displays the samples from sample 'beg' for 'dur' samples in 'color'
whenever they're in the current time domain view. uncolor-samples cancels this action.
<a href="extsnd.html#displaysampsinred">Here</a> is a representative picture.
To activate this, add it to <a href="extsnd.html#aftergraphhook">after-graph-hook</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- display-previous-edits -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>display-previous-edits</em> <code>snd chn</code>
</td></tr><tr><td width=60></td><td>
display-previous-edits displays all the edits of the current sound, with older edits gradually fading away.
To activate this, add it to <a href="extsnd.html#aftergraphhook">after-graph-hook</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- make-current-window-display -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="makecurrentwindowdisplay">make-current-window-display</a> ()
</td></tr><tr><td width=60></td><td>
make-current-window-display
displays in the upper right corner the overall current sound and where the current window fits in it.
This information is implicit in the x axis zoom and position sliders, but a redundant graph doesn't hurt.  If you click in that graph,
the cursor is moved to the clicked point.

<img src="uppergrf.png" alt="make-current-window-display" hspace=20 vspace=10>
<br>
If you're using a line cursor (if <a href="extsnd.html#cursorstyle">cursor-style</a> is <code>cursor-line</code>), it may 
collide at times with the little graph; 
to get a more polite cursor, use <a href="#smartlinecursor">smart-line-cursor</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- overlay-rms-env -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="overlayrmsenv">overlay-rms-env</a> <code>snd chn</code>
</td></tr><tr><td width=60></td><td>
overlay-rms-env displays the running rms value of the currently displayed data in red, overlayed upon the 
normal graph. To activate it, add it to the <a href="extsnd.html#aftergraphhook">after-graph-hook</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- overlay-sounds -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>overlay-sounds</em> <code>:rest sounds</code>
</td></tr><tr><td width=60></td><td>
overlay-sounds overlays onto its first argument (a sound index) all subsequent arguments: <code>(overlay-sounds 1 0 3)</code>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- samples-via-colormap -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>samples-via-colormap</em> <code>snd chn</code>
</td></tr><tr><td width=60></td><td>
samples-via-colormap displays the time domain graph using the current colormap (it is really just an example of 
<a href="extsnd.html#colormapref">colormap-ref</a>).  
To activate this, add it to <a href="extsnd.html#aftergraphhook">after-graph-hook</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- smart-line-cursor -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="smartlinecursor">smart-line-cursor</A> <code>snd chn tracking</code>
</td></tr><tr><td width=60></td><td>
smart-line-cursor is a <a href="extsnd.html#cursorstyle">cursor-style</a> function that tries 
not to overwrite the thumbnail graph drawn by <a href="#makecurrentwindowdisplay">make-current-window-display</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>

</table>

<br><br>



<!-- ---------------------------------------- FILE: dsp ---------------------------------------- -->

<A NAME="dspdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>dsp</h2></td></tr></table>

<p>dsp.scm is a DSP grabbag, mostly filters.  There are more than 100 functions to describe here, so
an alphabetical list is just a jumble of names.  Instead, I've tried to divide them into several vague
categories: 
<a href="#dspdocfft">FFTs</a>, <a href="#dspdocfir">FIR filters</a>,
<a href="#dspdociir">IIR filters</a>, <a href="#dspdocgens">synthesis</a>,
<a href="#dspdoceffects">sound effects</a>, 
<a href="#dspdocsrc">sampling rate conversion</a>, 
<a href="#dspdocalgebra">linear algebra and stats</a>,
and <a href="#dspdocscanned">scanned synthesis</a>.
</p>

<p><small><blockquote>If you're new to DSP, I recommend Lyons' "Understanding Digital Signal Processing" and Steiglitz, "A
Digital Signal Processing Primer"; 
there are many good books
on advanced calculus -- I especially liked Hildebrand, "Advanced Calculus for Applications", but it may
be out of print (this was about 25 years ago, I think); a great book on complex analysis is Needham, "Visual
Complex Analysis"; Poole's "Linear Algebra" is a very straightforward
introduction; also Halmos, "Linear Algebra Problem Book"; the most enjoyable
Fourier Analysis book is by K&ouml;rner, but you don't want to start with it.
For the ambitious, there is the encyclopedic set of books by Julius Smith.
His "Mathematics of the DFT" is a very clear introduction.
</blockquote></small></p>
<br>

<table border=0 cellspacing=0 hspace=20>

<!-- ---------------------------------------- dsp FFT ---------------------------------------- -->
<tr><td colspan=2 bgcolor="lightgreen"><center><A NAME="dspdocfft">FFTs</A></center></td><td></td></tr>

<!-- main-index |dht:Hartley transform -->
<!-- dht -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="dht">dht</A> <code>data</code>
</td></tr><tr><td width=60></td><td>
dht is the slow form of the Hartley transform, 
taken from Perry Cook's SignalProcessor.m.
The Hartley transform is a kind of Fourier transform.
</td></tr><tr><td colspan=2 height=16></td></tr>

  
<!-- display-bark-fft -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="displaybarkfft">display-bark-fft</a><br>
<em class=emdef>undisplay-bark-fft</em>
</td></tr><tr><td></td><td>
display-bark-fft shows the current spectrum in the "lisp" graph in three
different frequency scales: bark, mel, and erb, each in a different color.
The default ticks follow the bark scale; click anywhere in the lisp graph
to switch to a different tick scale choice.  undisplay-bark-fft turns this
graph off.
<br>
<img src="bark.png" alt="bark display" vspace=10>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- dolph -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="dolph">dolph</A> <code>n gamma</code>
</td></tr><tr><td></td><td>
dolph is the Dolph-Chebyshev fft data window, taken
from Richard Lyons, "Understanding DSP".  The C version used by Snd/CLM is in clm.c.
Another version of the same function,
taken (with a few minor changes) from Julius Smith's "Spectral Audio", is named dolph-1.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- down-oct and stretch-sound-via-dft -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="downoct">down-oct</A> <code>n :optional snd chn</code><br>
<em class=emdef>stretch-sound-via-dft</em> <code>factor :optional snd chn</code>
</td></tr><tr><td></td><td>
down-oct 
tries to move a sound down by a factor of n (assumed to be a power of 2, 1 = no change) by goofing with the fft data,
then inverse ffting.  
I think this is "stretch" in DSP jargon; to interpolate in the time domain we're squeezing the frequency domain.
The power-of-2 limitation is based on the underlying fft function's insistence on power-of-2 data sizes.
A more general version of this is stretch-sound-via-dft, but it's
extremely slow.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- goertzel and find-sine -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="goertzel">goertzel</a> <code>freq :optional beg dur</code><br>
<em class=emdef>find-sine</em> <code>freq beg dur</code>
</td></tr><tr><td></td><td>
goertzel and find-sine find the amplitude of a single component of a spectrum ('freq').
<pre>
    :<em class=typing>(find-sine 550.0 0.0 (frames))</em>
    <em class=listener>(0.00116420908413177 0.834196665512423)</em>   ; car is amplitude, cadr is phase in radians
    :<em class=typing>(* (goertzel 550.0 0.0 (frames)) (/ 2.0 (frames)))</em>
    <em class=listener>0.00116630805062827</em>
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- periodogram -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>periodogram</em> <code>N</code>
</td></tr><tr><td></td><td>
periodogram (the "Bartlett" version, I think) runs over an entire file, piling up 'N' sized junks of data,
then displays the results in the "lisp graph" area; this needs a lot of work to be useful!
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- scentroid -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="scentroid">scentroid</a> <code>file :key (beg 0.0) dur (db-floor -40.0) (rfreq 100.0) (fftsize 4096)</code>
</td></tr><tr><td></td><td>
scentroid is Brett Battey's CLM scentroid instrument, translated to Snd/Scheme.
To paraphrase Brett:
scentroid returns (in a vct) the continuous spectral centroid envelope of a sound.
The spectral centroid is the "center of gravity" of the spectrum, and it
has a rough correlation to our sense of "brightness" of a sound. 
'db-floor' sets a lower limit on which frames are included in the analysis.
'rfreq' sets the number of  measurements per second.
'fftsize' sets the fft window size (a power of 2).
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- spot-freq -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="spotfreq">spot-freq</a> <code>samp :optional snd chn</code>
</td></tr><tr><td></td><td>
spot-freq is a simple first-pass at using autocorrelation for
pitch tracking; it's easily fooled, but could probably be made relatively robust.
<pre>
    :<em class=typing>(spot-freq 10000)</em>  ; this is oboe.snd, in about .5 secs
    <em class=listener>555.262096862931</em>    ; 555Hz is correct(!)
</pre>
In the next example, we add spot-freq to the <a href="extsnd.html#mouseclickhook">mouse-click-hook</a> (in Ruby),
so that each time we click somewhere in the graph, the pitch at that point is reported:
<pre>
   $mouse_click_hook.add_hook!("examp-cursor-hook") do |snd, chn, button, state, x, y, axis|
     if axis == Time_graph
       report_in_minibuffer(format("(freq: %.3f)", spot_freq(cursor(snd, chn))))
     end
   end
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- rotate-phase and zero-phase -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>rotate-phase</em> <code>func :optional snd chn</code><br>
<A class=def NAME="zerophase">zero-phase</A> <code>:optional snd chn</code>
</td></tr><tr><td></td><td>
These are fft phase manipulators taken from the phazor package of Scott McNab.
zero-phase takes ffts, sets all phases to 0.0, then unffts.  rotate-phase
is similar, but applies 'func' to the phases.
<pre>
    (rotate-phase (lambda (x) 0.0))             ; same as (zero-phase)
    (rotate-phase (lambda (x) (random 3.1415))) ; randomizes phases
    (rotate-phase (lambda (x) x))               ; returns original
    (rotate-phase (lambda (x) (- x)))           ; reverses original
</pre>
or in Ruby:
<pre>
    rotate_phase(lambda {|x| random(PI) })      # randomizes phases
</pre>
and Forth:
<pre>
    lambda: &lt;{ x }&gt; pi random ; #f #f rotate-phase \ randomizes phases
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- z-transform and fractional-fourier-transform -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="ztransform">z-transform</a> <code>rl size z</code><br>
<a class=def name="fractionalfouriertransform">fractional-fourier-transform</a> <code>rl im size angle</code>
</td></tr><tr><td></td><td>
z-transform performs a z-transform returning a vector (to accommodate complex results):
<pre>
    :<em class=typing>(define d0 (make-vct 8))</em>
    <em class=listener>#&lt;unspecified&gt;</em>
    ;; and similarly for d1 and d2 ...
    :<em class=typing>(vct-set! d0 2 1.0)</em>
    <em class=listener>1.0</em>
    :<em class=typing>(vct-set! d1 2 1.0)</em>
    <em class=listener>1.0</em>
    :<em class=typing>(z-transform d0 8 (exp (make-rectangular 0.0 (* .25 pi))))</em>
    ;; Ruby: z_transform(d0, 8, exp(Complex(0.0, (2.0 / 8) * PI)))
    <em class=listener>#(1.0  0.0+1.0i  -1.0  0.0-1.0i  1.0  0.0+1.0i  -1.0  0.0-1.0i)</em>
    :<em class=typing>(mus-fft d1 d2 8)</em>
    <em class=listener>#&lt;vct[len=8]: 1.000 0.000 -1.000 -0.000 1.000 0.000 -1.000 -0.000&gt;</em>
    :<em class=typing>d2</em>
    <em class=listener>#&lt;vct[len=8]: 0.000 1.000 0.000 -1.000 0.000 1.000 0.000 -1.000&gt;</em>
</pre>
which is a complicated way of showing that if 'z' is e^2*pi*/n, you get a fourier transform.
fractional-fourier-transform is the slow (DFT) version
of the fractional Fourier Transform. If 'angle' is 1.0, you get a fourier transform.
</td></tr><tr><td colspan=2 height=32></td></tr>


<!-- ---------------------------------------- dsp FIR ---------------------------------------- -->
<tr><td colspan=2 bgcolor="lightgreen"><center><A NAME="dspdocfir">FIR filters</A></center></td><td></td></tr>

<!-- FIR filters -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="makehighpass">make-highpass</a> <code>fc :optional length</code>, <em class=emdef>highpass</em> <code>f in</code><br>
<a class=def name="makelowpass">make-lowpass</a> <code>fc :optional length</code>, <em class=emdef>lowpass</em> <code>f in</code><br>
<a class=def name="makebandpass">make-bandpass</a> <code>flo fhi :optional length</code>, <em class=emdef>bandpass</em> <code>f in</code><br>
<a class=def name="makebandstop">make-bandstop</a> <code>flo fhi :optional length</code>, <em class=emdef>bandstop</em> <code>f in</code><br>
<a class=def name="makedifferentiator">make-differentiator</a> <code>:optional length</code>, <em class=emdef>differentiator</em> <code>f in</code><br>
</td></tr><tr><td></td><td>
make-lowpass and lowpass provide FIR low pass filtering, and similarly for the other four choices.
The order chosen is twice the 'length'; 'fc', 'flo', and 'fhi' are
the edge frequencies in terms of srate = 2 * pi.
<pre>
    (let ((hp (make-bandpass (* .1 pi) (* .2 pi))))
      (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (lambda (y)
		     (bandpass hp y))))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- hilbert-transform -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="makehilberttransform">make-hilbert-transform</a> <code>:optional length</code><br>
<a class=def name="hilberttransform">hilbert-transform</a> <code>f in</code><br>
<em class=emdef>hilbert-transform-via-fft</em> <code>:optional snd chn</code><br>
<a class=def name="soundtoamp_env">sound-&gt;amp-env</a> <code>:optional snd chn</code>
</td></tr><tr><td></td><td>
These functions perform the hilbert transform using either an FIR filter (the first two) or an FFT.
One example of its use is sound-&gt;amp-env (from R Lyons).  Another is the <a href="clm.html#ssb-am">ssb-am</a> generator in CLM.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- invert-filter -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>invert-filter</em> <code>coeffs</code>
</td></tr><tr><td></td><td>
invert-filter inverts an FIR filter.
Say we previously filtered a sound via 
<pre>
    (<a class=quiet href="extsnd.html#filterchannel">filter-channel</a> (<a class=quiet href="extsnd.html#vct">vct</a> .5 .25 .125))
</pre>
and our mouse is broken so we can't use the Undo menu, and we've forgotten that
we could type <code>(undo)</code>.  Nothing daunted, we use:
<pre>
    (<a class=quiet href="extsnd.html#filterchannel">filter-channel</a> (invert-filter (vct .5 .25 .125)))
</pre>
There are a million gotchas here.  The primary one is that the inverse filter
can "explode" -- the coefficients can grow without bound.  For example, any
filter returned by spectrum-&gt;coeffs will be problematic.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- make-spencer-filter -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>make-spencer-filter</em>
</td></tr><tr><td></td><td>
This returns a CLM fir-filter generator with the standard "Spencer Filter" coefficients.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- notch -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="notchsound">notch-sound</a> <code>freqs :optional order s c width</code><br>
<a class=def name="notchchannel">notch-channel</a> <code>freqs :optional order beg dur s c e trunc width</code><br>
<a class=def name="notchselection">notch-selection</a> <code>freqs :optional order width</code>
</td></tr><tr><td></td><td>
notch-channel, notch-selection, and notch-sound are aimed at noise reduction.
Each takes a list of frequencies (in Hz), and an optional filter order, and
notches out each frequency.  The sharpness of the notch is settable
explicitly via the 'width' argument, and implicitly via the
filter 'order'.  A common application cancels 60 Hz hum:
<pre>
    (notch-channel (let ((freqs '())) 
                     (do ((i 60 (+ i 60))) 
                         ((= i 3000)) 
                       (set! freqs (cons i freqs))) (reverse freqs)))
</pre>
Here we've built a list of multiples of 60 and passed it to notch-channel. Its default notch
width is 2 Hz, and its default order tries to maintain that width given the channel's sampling rate,
so the default filter order can be very high (65536).  The filtering is normally done via
convolution (by CLM's convolve generator), so a high filter order is not a big deal.  In ideal
cases, this can reduce the hum and its harmonics by about 90%.
But, if the hum is not absolutely stable, you'll probably want wider notches:
<pre>
    (notch-channel (let ((freqs '())) 
                     (do ((i 60 (+ i 60))) 
                         ((= i 3000)) 
                       (set! freqs (cons i freqs))) (reverse freqs)) 1024)
</pre>
The order of 1024 means we get 20 Hz width minima (44100 Hz srate), so this
notches out much bigger chunks of the spectrum.  You get 98% cancellation, but
also lose more of the original signal.  
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- spectrum->coeffs and fltit -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="spectrumtocoeffs">spectrum-&gt;coeffs</a> <code>order spectrum</code><br>
<em class=emdef>fltit-1</em> <code>order spectr</code>
</td></tr><tr><td></td><td>
spectrum-&gt;coeffs is a
version of Snd's very simple spectrum-&gt;coefficients procedure ("frequency sampling").
It returns the FIR filter coefficients given the filter 'order' and desired 'spectrum' (a vct).
An example of its use is fltit-1.
<pre>
    (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (fltit-1 10 (<a class=quiet href="extsnd.html#vct">vct</a> 0 1.0 0 0 0 0 0 0 1.0 0)))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- volterra-filter -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>make-volterra-filter</em> <code>acoeffs bcoeffs</code><br>
<a class=def name="volterrafilter">volterra-filter</a> <code>flt x</code>
</td></tr><tr><td></td><td>
volterra-filter and
make-volterra-filter implement one form
of a common non-linear FIR filter.
This version is taken from Monson Hayes "Statistical DSP and Modeling";
it is a slight specialization of the form mentioned by J O Smith and others.
The 'acoeffs' apply to the linear terms, and the 'bcoeffs' to the quadratic.
<pre>
   (let ((flt (make-volterra-filter (vct .5 .1) (vct .3 .2 .1))))
     (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (lambda (x) (volterra-filter flt x))))
</pre>
</td></tr><tr><td colspan=2 height=32></td></tr>


<!-- ---------------------------------------- dsp IIR ---------------------------------------- -->
<tr><td colspan=2 bgcolor="lightgreen"><center><A NAME="dspdociir">IIR filters</A></center></td><td></td></tr>

<!-- make-biquad -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="makebiquad">make-biquad</a> <code>a0 a1 a2 b1 b2</code>
</td></tr><tr><td></td><td>
make-biquad is a wrapper for <a href="clm.html#make-filter">make-filter</a>
to return a biquad filter section.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- cascade->canonical -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="cascadetocanonical">cascade-&gt;canonical</a> <code>coeffs</code>
</td></tr><tr><td></td><td>
cascade-&gt;canonical 
converts cascade coefficients to canonical form (the form used by CLM's <a href="clm.html#filter">filter</a> generator).
'coeffs' is a list of filter coefficients; the function returns a vct, ready for
<a href="clm.html#make-filter">make-filter</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- make-butter* -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>make-butter-high-pass</em> <code>fq</code>, <em class=emdef>make-butter-hp</em> <code>M fc</code><br>
<em class=emdef>make-butter-low-pass</em> <code>fq</code>, <em class=emdef>make-butter-lp</em> <code>M fc</code><br>
<em class=emdef>make-butter-band-pass</em> <code>fq bw</code>, <em class=emdef>make-butter-bp</em> <code>M f1 f2</code><br>
<em class=emdef>make-butter-band-reject</em> <code>fq bw</code>, <em class=emdef>make-butter-bs</em> <code>M f1 f2</code>
</td></tr><tr><td></td><td>
These functions produce Butterworth filters, returning a CLM <a href="clm.html#filter">filter</a> generator.
The first named ones (make-butter-high-pass et al) are taken from Sam Heisz's CLM version
of Paris Smaragdis's Csound version of Charles Dodge's code from "Computer Music: synthesis, composition, and performance".
The second set (make-butter-lp et al) provide arbitrary order Butterworths.
'M' * 2 is the filter order, 'f1' and 'f2' are the band edges in Hz.
<pre>
    (<a class=quiet href="extsnd.html#clmchannel">clm-channel</a> (make-butter-bp 3 1000 2000))
    (<a class=quiet href="extsnd.html#filtersound">filter-sound</a> (make-butter-low-pass 500.0))
</pre>
See also the notch filter in new-effects.scm, and of course <a href="#analogfilterdoc">analog-filter.scm</a>: the latter renders this section obsolete.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- IIR filters -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>make-iir-high-pass-2</em> <code>fc :optional din</code><br>
<em class=emdef>make-iir-low-pass-2</em> <code>fc :optional din</code><br>
<em class=emdef>make-iir-band-pass-2</em> <code>f1 f2</code><br>
<em class=emdef>make-iir-band-stop-2</em> <code>f1 f2</code><br>
<em class=emdef>make-eliminate-hum </em> <code>:optional (hum-freq 60.0) (hum-harmonics 5) (bandwidth 10)</code><br>
<em class=emdef>eliminate-hum</em> <code>gen x0</code><br>
<em class=emdef>make-peaking-2</em> <code>f1 f2 m</code>
</td></tr><tr><td></td><td>
More IIR filters.  Except for make-peaking-2, each function returns a CLM <a href="clm.html#filter">filter</a> generator.
<pre>
    (let ((hummer (make-eliminate-hum))) 
       (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (lambda (x) (eliminate-hum hummer x))))
</pre>
make-peaking (a bandpass filter) returns a function suitable for map-channel (it takes one argument, the current sample,
and returns a sample):
<pre>
    (let ((peaker (make-peaking-2 500 1000 1.0)))
      (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> peaker))
</pre>
In this case 'm' is the gain in the pass band.
Use the functions in <a href="#analogfilterdoc">analog-filter.scm</a>, rather than this group.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- mfilter -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>make-mfilter</em> <code>:key (frequency 1000) (decay .99)</code><br>
<a class=def NAME="mfilter">mfilter</a> <code>gen :optional x-input y-input</code>
</td></tr><tr><td></td><td>
These implement a high Q two-pole <a href="http://ccrma.stanford.edu/~jos/smac03maxjos/">filter</a>
developed by Max Mathews and Julius Smith.  It is very  
similar to CLM's <a href="clm.html#formant">formant</a>.
A slightly different view of the same filter is provided
by <a href="#maxfdoc">maxf</a>.  
<pre>
(with-sound ()    ; filter "now.snd" with default freq/decay
  (let ((rd (<a class=quiet href="extsnd.html#makesamplereader">make-sample-reader</a> 0 "now.snd")) 
	(m (<em class=red>make-mfilter</em>))) 
    (run (lambda () 
	   (do ((i 0 (1+ i))) 
	       ((= i 10000))
	     (<a class=quiet href="clm.html#outa">outa</a> i (<em class=red>mfilter</em> m (* .1 (rd))) *output*))))))

(with-sound ()    ; sweep center freq from 100Hz to 2000Hz
  (let ((rd (<a class=quiet href="extsnd.html#makesamplereader">make-sample-reader</a> 0 "oboe.snd")) 
        (m (<em class=red>make-mfilter</em> :decay .99 :frequency 1000)) 
        (e (<a class=quiet href="clm.html#make-env">make-env</a> '(0 100 1 2000) :end 10000))) 
    (run (lambda () 
	   (do ((i 0 (1+ i))) 
	       ((= i 10000))
	     (<a class=quiet href="clm.html#outa">outa</a> i (<em class=red>mfilter</em> m (* .1 (rd))) *output*) 
	     (set! (<em class=red>mflt-eps</em> m) (* 2.0 (sin (/ (* pi (<a class=quiet href="clm.html#env">env</a> e)) (<a class=quiet href="clm.html#mussrate">mus-srate</a>))))))))))
</pre>
</td></tr><tr><td colspan=2 height=32></td></tr>


<!-- ---------------------------------------- dsp generators ---------------------------------------- -->
<tr><td colspan=2 bgcolor="lightgreen"><center><A NAME="dspdocgens">synthesis</A></center></td><td></td></tr>


<!-- cosine-summation -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="cosinesummation">cosine-summation</a> <code>gen r</code><br>
<em class=emdef>kosine-summation</em> <code>gen r k</code>
</td></tr><tr><td></td><td>
cosine-summation 
is a variation on Moorer's <a href="clm.html#sine-summation">sine-summation</a>;
the generating formula is much simpler, but the result is the same.  This
can also be viewed as a version of the <a href="clm.html#sum-of-cosines">sum-of-cosines</a> generator, giving control
over the ratio between successive cosines in the sum (i.e. the "r" parameter in
sine-summation, applied within the sum-of-cosines output).  
<br><br>
kosine-summation
is a variation on cosine-summation; it includes
a sort of "FM index" parameter ('k', hence the generator name) to vary the harmonic content at run-time.
There is also a <a href="clm.html#sinc-train">sinc-train</a> generator in clm.html. 
In both cases, the associated "make" function is actually just <a href="clm.html#make-oscil">make-oscil</a>
suitably renamed (make-cosine-summation, etc).
<pre>
    (let ((gen (make-kosine-summation 100.0))) 
      (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (lambda (y) (* .2 (kosine-summation gen 0.5 5.0)))))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- legendre-sum -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>legendre-sum</em> <code>angle n</code><br>
<A class=def NAME="fejersum">fejer-sum</A> <code>angle n</code><br>
<em class=emdef>poussin-sum</em> <code>angle n</code><br>
<em class=emdef>jackson-sum</em> <code>angle n</code>
</td></tr><tr><td></td><td>
These functions
produce a band-limited pulse-train.
<pre>
    (let ((angle 0.0)) 
      (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (lambda (y) 
                     (let ((val (fejer-sum angle 3))) 
                       (set! angle (+ angle .1)) 
                       (* .1 val)))))
</pre>
fejer-sum harmonics are scaled by (/ (- n i) (+ n 1)); decreasing evenly.
poussin-sum harmonic amplitudes start at 0, go up to a peak at n, then decrease to 0.
(This section of dsp.scm also has an implementation of signum -- perhaps I should
make it a built-in function?).
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- sum-of-n-sines -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="sumofnsines">sum-of-n-sines</a> <code>angle n</code><br>
<em class=emdef>sum-of-n-odd-sines</em> <code>angle n</code><br>
<em class=emdef>sum-of-n-odd-cosines</em> <code>angle n</code>
</td></tr><tr><td></td><td>
These three functions produce various spectra, similar to the cosine-summation function above.
<pre>
    (let ((angle 0.0)) 
      (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (lambda (y) 
                     (let ((val (sum-of-n-sines angle 3))) 
                       (set! angle (+ angle .1)) 
                       (* .1 val)))))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- band-limited-sawtooth -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="bandlimitedsawtooth">band-limited-sawtooth</a> <code>x a N fi</code><br>
<a class=def name="bandlimitedsquarewave">band-limited-square-wave</a> <code>theta n</code>
</td></tr><tr><td></td><td>
band-limited-square-wave uses the formula tanh(n * sin(theta)) ('n' here is a float).
As 'n' increases, you get closer to a square-wave.
band-limited-sawtooth is apparently originally from Tim Stilson and Julius Smith (I got it via Alexander Kritov);
it had the name "discrete summation formula" which conveys nothing to me.  The parameter
'a' is more or less the amplitude, 'N' should be between 1 and 10, 'fi' is the
phase increment, 'x' the current phase.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- asymfm -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>make-asyfm</em> <code>:key (frequency 440.0) (initial-phase 0.0) (ratio 1.0) (r 1.0) (index 1.0)</code><br>
<em class=emdef>asyfm-J</em> <code>gen input</code><br>
<em class=emdef>asyfn-I</em> <code>gen input</code>
</td></tr><tr><td></td><td>
These functions are    
versions of the CLM <a href="clm.html#asymmetric-fm">asymmetric-fm</a> generator.
asyfm-I is the Modifier Bessel version of this generator.  In both
cases, the 'r' parameter is accessible, so it's easy to experiment with 
the moving formant idea mentioned in the original article ('r' should be greater than 0.0).
<pre>
     (let ((gen (make-asyfm :frequency 2000 :ratio .1))
           (e (<a class=quiet href="clm.html#make-env">make-env</a> '(0 0.5 1 1.5) :end (frames))))
       (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (lambda (n)
                      (set! (asyfm-r gen) (<a class=quiet href="clm.html#env">env</a> e))
                      (asyfm-J gen 0.0))))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- ssb-bank -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="ssbbank">ssb-bank</a> <code>old-freq new-freq pairs-1 :optional (order 40) (bw 50.0) (beg 0) dur snd chn edpos</code><br>
<a class=def name="ssbbankenv">ssb-bank-env</a> <code>old-freq new-freq freq-env pairs-1 :optional (order 40) (bw 50.0) (beg 0) dur snd chn edpos</code><br>
<em class=emdef>shift-channel-pitch</em> <code>freq :optional (order 40) (beg 0) dur snd chn edpos</code>
</td></tr><tr><td></td><td>
The 
ssb-bank functions provide single-sideband amplitude modulation, and pitch/time changes
based on the ssb-am generator.  
If you run ssb-am on some input signal, the signal is shifted in pitch by
the 'freq' amount.  The higher the 'order', the better the sideband cancellation
(amplitude modulation creates symmetrical sidebands, one of which is cancelled by the ssb-am
generator).  ssb-bank uses a bank of ssb-am generators, each with its own bandpass filter to
shift a sound's pitch without changing its duration;
the ssb-am generators do the pitch
shift, and the filters pick out successive harmonics,
so each harmonic gets shifted individually (i.e. harmonic relations are maintained despite the pitch shift).
For an oboe at 557 Hz, good values are:
<code>(ssb-bank 557 new-freq 6 40 50)</code>.
For a person talking at ca. 150 Hz:
<code>(ssb-bank 150 300 30 100 30)</code> or
<code>(ssb-bank 150 100 40 100 20)</code>.
To get a duration change without a pitch change, use this function
followed by sampling rate conversion back to the original pitch:
<pre>
    (define (stretch-oboe factor)
      (ssb-bank 557 (* factor 557) 7 40 40)
      (<a class=quiet href="extsnd.html#srcsound">src-sound</a> (/ 1.0 factor)))
</pre>
ssb-bank-env is the same as ssb-bank, but includes a frequency envelope:
<code>(ssb-bank-env 557 880 '(0 0 1 100.0) 7)</code>.
shift-channel-pitch applies an <a href="clm.html#ssb-am">ssb-am</a> generator to a sound's channel (this
is a variant of amplitude modulation).
'freq' and 'order' are the corresponding arguments to <a href="clm.html#make-ssb-am">make-ssb-am</a>.
There is a dialog that runs ssb-bank in snd-motif.scm: create-ssb-dialog.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- any-random -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="anyrandom">any-random</A> <code>:optional e</code><br>
<a class=def name="gaussiandistribution">gaussian-distribution</a> <code>s</code><br>
<em class=emdef>pareto-distribution</em> <code>a</code><br>
<em class=emdef>gaussian-envelope</em> <code>s</code>
</td></tr><tr><td></td><td>
any-random provides the same output as <a href="clm.html#rand">rand</a> if the latter's
envelope (distribution function) argument is used, but using a slightly different method
to generate the numbers.  
gaussian-envelope makes a gaussian distribution envelope suitable for rand.
Also included is inverse-integrate, a version of
CLM's distribution-to-weighting function.
<pre>
    (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (lambda (y) (any-random 1.0 '(0 1 1 1))))          ; uniform distribution
    (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (lambda (y) (any-random 1.0 '(0 0 0.95 0.1 1 1)))) ; mostly toward 1.0
    (let ((g (gaussian-distribution 1.0))) (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (lambda (y) (any-random 1.0 g))))
    (let ((g (pareto-distribution 1.0))) (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (lambda (y) (any-random 1.0 g))))
</pre>
In Ruby:
<pre>
    map_channel(lambda do |y| any_random(1.0, [0, 1, 1, 1]))            # uniform distribution
    map_channel(lambda do |y| any_random(1.0, [0, 0, 0.95, 0.1, 1, 1])) # mostly toward 1.0
    let(gaussian-distribution(1.0)) do |g|  map_channel(lambda do |y| any_random(1.0, g)) end
    let(pareto-distribution(1.0))   do |g| map_channel(lambda do |y| any_random(1.0, g)) end
</pre>

<!-- INDEX allrandomnumbers:Random Numbers --><a name="allrandomnumbers"></a>
<TABLE border=3 bordercolor="tan" hspace=20 vspace=10><tr><td>
<blockquote><small>
<br>
Random Numbers in Snd/CLM:<br>
generators, arbitrary distributions, fractals, 1/f: <a href="clm.html#randomnumbers">rand and rand-interp</a><br>
dithering: <a href="sndscm.html#ditherchannel">dither-channel</a>, <a href="sndscm.html#dithersound">dither-sound</a><br>
noise-making instrument: <a href="#noisedoc">noise.scm, noise.rb</a><br>
physical modeling of noisy instruments: <a href="#maracadoc">maraca.scm, maraca.rb</a><br>
arbitrary distribution via rejection method: <a href="#anyrandom">any-random</a><br>
CL: random, *random-state*, make-random-state*: random number between 0 and arg, arg can't be 0!<br>
Guile: random, *random-state*, seed-&gt;random-state: random number between 0 and arg, arg can't be 0!<br>
Gauche: random (based on CLM random functions)<br>
Ruby: kernel_rand (alias for Ruby's rand), srand: random integer between 0 and arg, or float between 0 and 1<br>
CLM (all versions): <a href="clm.html#mus-random">mus-random, mus_random</a>: random float between -arg and arg<br>
CLM (CL): <a href="clm.html#clm-random">clm-random</a>: random float between 0.0 and arg<br>
CLM (C): mus_irandom: random int between 0 and arg<br>
CLM (C): mus_frandom: random float between 0.0 and arg<br>
CLM (CL): <a href="clm.html#mus-set-rand-seed">mus-set-rand-seed</a><br>
CLM (Scheme): mus-rand-seed (settable)<br>
bounded brownian noise: <a href="sndscm.html#greendoc">green.scm</a><br>
<br>
</small></blockquote>
</td></tr></TABLE>

</td></tr><tr><td colspan=2 height=32></td></tr>


<!-- ---------------------------------------- dsp effects ---------------------------------------- -->
<tr><td colspan=2 bgcolor="lightgreen"><center><A NAME="dspdoceffects">effects</A></center></td><td></td></tr>

<!-- adsat, freqdiv -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>adsat</em> <code>size :optional beg dur snd chn</code><br>
<em class=emdef>freqdiv</em> <code>n :optional snd chn</code>
</td></tr><tr><td></td><td>
These two functions come from a package of effects developed by sed_sed@my-dejanews.com.
adsat is "adaptive saturation", and freqdiv is "frequency division".
<code>(freqdiv n)</code> repeats each nth sample 'n' times, clobbering the intermediate samples: <code>(freqdiv 8)</code>.
It turns your sound into a bunch of square waves.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- brighten-slightly -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>brighten-slightly</em> <code>amount :optional snd chn</code>
</td></tr><tr><td></td><td>
brighten-slightly is a slight simplification of <a href="clm.html#contrast-enhancement">contrast-enhancement</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- chordalize -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="chordalize">chordalize</A> ()
</td></tr><tr><td></td><td>
chordalize uses harmonically-related comb-filters to bring out a chord in a sound.
The comb filters are controled by <code>chordalize-amount</code> (the default is .95),
<code>chordalize-base</code> (the default is 100 Hz), and <code>chordalize-chord</code>
(the default is <code>(list 1 3/4 5/4)</code>).  chordalize returns a function suitable
for map-channel:
<pre>
   (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (chordalize))
</pre>
chordalize seems to work best with vocal sounds.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- chorus -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>chorus</em> ()
</td></tr><tr><td></td><td>
chorus tries to produce the chorus sound effect, but it needs work.
It is controlled by the following variables:
<pre>
    chorus-size (5)        ; number of flangers
    chorus-time (.05)      ; scales delay line length (flanger)
    chorus-amount (20.0)   ; amp of rand-interp (flanger)
    chorus-speed (10.0)    ; freq of rand-interp (flanger)
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- harmonicizer -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="harmonicizer">harmonicizer</a> <code>freq coeffs pairs :optional (order 40) (bw 50.0) (beg 0) dur snd chn edpos</code>
</td></tr><tr><td></td><td>
harmonicizer splits a sound into separate sinusoids, then splits each resultant harmonic
into a set of harmonics, then reassembles the sound.  The basic idea is very similar to
<a href="#ssbbank">ssb-bank</a>, but harmonicizer splits harmonics, rather than pitch-shifting them.
The result can be a brighter or richer sound.
<pre>
    (harmonicizer 550.0 (list 1 .5 2 .3 3 .2) 10)
</pre>
'coeffs' is a list of harmonic-number and amplitude pairs, describing the spectrum
produced by each harmonic.  'pairs' controls how many bands are used to split the original sound.
'order' is the bandpass filter's order in each such pair, and 'bw' controls its bandwidth.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- lpc-coeffs -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="lpccoeffs">lpc-coeffs</a> <code>data n m</code>
</td></tr><tr><td></td><td>
lpc-coeffs returns 'm' LPC coeffients (in a vector) given 'n' data points in the vct 'data'.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- lpc-predict -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="lpcpredict">lpc-predict</a> <code>data n coeffs m nf :optional clipped</code>
</td></tr><tr><td></td><td>
lpc-predict takes the output of lpc-coeffs ('coeffs') and the length thereof ('m'),
'n' data points 'data', and produces 'nf' new data points (in a vct) as its prediction.
If 'clipped' is #t, the new data is assumed to be outside -1.0 to 1.0.
<pre>
    :<em class=typing>(lpc-predict (vct 0 1 2 3 4 5 6 7) 8 (lpc-coeffs (vct 0 1 2 3 4 5 6 7) 8 4) 4 2)</em>
    <em class=listener>#&lt;vct[len=2]: 7.906 8.557&gt;</em>
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- spike -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>spike</em> <code>:optional snd chn</code>
</td></tr><tr><td></td><td>
spike returns a product (rather than the more usual sum) of succesive samples, with the current sample's sign;
this normally produces a more spikey output.
The more successive samples we include in the product, the more we
limit the output to pulses placed at (just after) wave peaks.
In spike's case, just three samples are multiplied.
See also the <a href="#volterrafilter">volterra filter</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- unclip-channel -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="unclipchannel">unclip-channel</a> <code>:optional snd chn</code>
</td></tr><tr><td></td><td>
unclip-channel tries to reconstruct clipped portions of a sound by using LPC to predict (backwards and forwards)
the lost samples. 
This works much better than the sinusoidal reconstruction used in the appendix on <a href="sndscm.html#noisystory">Noise Reduction</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- unclip-sound -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>unclip-sound</em> <code>:optional snd</code>
</td></tr><tr><td></td><td>
unclip-sound calls unclip-channel on each channel in the sound 'snd'.
</td></tr><tr><td colspan=2 height=32></td></tr>



<!-- ---------------------------------------- dsp src ---------------------------------------- -->
<tr><td colspan=2 bgcolor="lightgreen"><center><A NAME="dspdocsrc">sampling rate conversion</A></center></td><td></td></tr>


<!-- linear-src-channel -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="linearsrcchannel">linear-src-channel</a> <code>srinc :optional snd chn</code>
</td></tr><tr><td></td><td>
linear-src-channel performs sampling rate conversion using linear interpolation;
this can sometimes be a nice effect.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- src-duration -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="srcduration">src-duration</a> <code>env</code>
</td></tr><tr><td></td><td>
src-duration 
takes an envelope representing the
input (src change) to <a href="clm.html#src">src</a>, and returns the resultant sound
length.
<pre>
    (src-duration '(0 1 1 2)) ; -&gt; 0.693147180559945
</pre>
which means that if the original sound was 2 seconds long, and we apply the envelope <code>'(0 1 1 2)</code>
(via <a href="extsnd.html#srcchannel">src-channel</a>, for example) to that sound, the result will be
.693 * 2 seconds long.
</td></tr><tr><td colspan=2 height=32></td></tr>


<!-- ---------------------------------------- dsp algebra ---------------------------------------- -->
<tr><td colspan=2 bgcolor="lightgreen"><center><A NAME="dspdocalgebra">stats, linear algebra, etc</A></center></td><td></td></tr>

<!-- JOS -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<br>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><em class=emdef>channel-mean</em> <code>:optional snd chn</code></td>                <td><code>; &lt;f, 1&gt; / n</code></td></tr>
<tr><td><em class=emdef>channel-total-energy</em> <code>:optional snd chn</code></td>        <td><code>; &lt;f, f&gt;</code></td></tr>
<tr><td><em class=emdef>channel-average-power</em> <code>:optional snd chn</code></td>       <td><code>; &lt;f, f&gt; / n</code></td></tr>
<tr><td><em class=emdef>channel-norm</em> <code>:optional snd chn</code></td>                <td><code>; sqrt(&lt;f, f&gt;)</code></td></tr>
<tr><td><a class=def name="channelrms">channel-rms</a> <code>:optional snd chn</code></td>   <td><code>; sqrt(&lt;f, f&gt; / n)</code></td></tr>
<tr><td><em class=emdef>channel-variance</em> <code>:optional snd chn</code></td>            <td><code>; &lt;f, f&gt; - ((&lt;f, 1&gt; / n) ^ 2) with quibbles</code></td></tr>
<tr><td><em class=emdef>channel-lp</em> u-p <code>:optional snd chn</code></td>              <td></td></tr>
<tr><td><em class=emdef>channel-lp-inf</em> <code>:optional snd chn</code></td>              <td><code>; max abs f</code></td></tr>
<tr><td><em class=emdef>channel2-inner-product</em> <code>s1 c1 s2 c2</code></td>            <td><code>; &lt;f, g&gt;</code></td></tr>
<tr><td><em class=emdef>channel2-orthogonal?</em> <code>s1 c1 s2 c2</code></td>              <td><code>; &lt;f, g&gt; == 0</code></td></tr>
<tr><td><em class=emdef>channel2-angle</em> <code>s1 c1 s2 c2</code></td>                    <td><code>; acos(&lt;f, g&gt; / (sqrt(&lt;f, f&gt;) * sqrt(&lt;g, g&gt;)))</code></td></tr>
<tr><td><em class=emdef>channel2-coefficient-of-projection</em> <code>s1 c1 s2 c2</code></td><td><code>; &lt;f, g&gt; / &lt;f, f&gt;</code></td></tr>
<tr><td><em class=emdef>channel-distance</em> <code>s1 c1 s2 c2</code></td>                  <td><code>; sqrt(&lt;f - g, f - g&gt;)</code></td></tr>
</table>
</td></tr><tr><td></td><td>
These functions are taken from (or at least inspired by) Julius Smith's "Mathematics of the
DFT".  Many are standard ways of describing a signal in statistics; others treat a signal
as a vector (channel-distance, for example, returns the Euclidean distance between two
sounds).  The 's1' and 's2' parameters refer to sound indices, and the 'c1' and 'c2'
parameters refer to channel numbers.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- channel-polynomial -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="channelpolynomial">channel-polynomial</a> <code>coeffs :optional snd chn</code><br>
<a class=def name="spectralpolynomial">spectral-polynomial</a> <code>coeffs :optional snd chn</code><br>
<a class=def name="vctpolynomial">vct-polynomial</a> <code>v coeffs</code>
</td></tr><tr><td></td><td>
vct-polynomial returns the evaluation of the polynomial (given its coefficients) over an entire
vct, each element being treated as "x".  
channel-polynomial performs the same operation over
a sound channel.  
spectral-polynomial is similar, but operates in the frequency domain (each
multiply being a convolution).
<pre>
    <em class=listener>:</em><em class=typing>(vct-polynomial (vct 0.0 2.0) (vct 1.0 2.0))</em> ; x*2 + 1
    <em class=listener>#&lt;vct[len=2]: 1.000 5.000&gt;</em>
    <em class=listener>:</em><em class=typing>(channel-polynomial (vct 0.0 1.0 1.0 1.0))</em> ; x*x*x + x*x + x
</pre>
The "constant" (0-th coefficient) term in spectral polynomial is treated as a dither amount (that is,
it has the given magnitude, but its phase is randomized, rather than being simple DC).
See also <a href="#polydoc">poly.scm</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- moving-max -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>make-moving-max</em> <code>:optional (size 128)</code><br>
<a class=def name="movingmax">moving-max</a> <code>gen y</code><br>
<em class=emdef>make-moving-sum</em> <code>:optional (size 128)</code><br>
<a class=def name="movingsum">moving-sum</a> <code>gen y</code><br>
<em class=emdef>make-moving-rms</em> <code>:optional (size 128)</code><br>
<a class=def name="movingrms">moving-rms</a> <code>gen y</code><br>
<em class=emdef>make-moving-length</em> <code>:optional (size 128)</code><br>
<a class=def name="movinglength">moving-length</a> <code>gen y</code>
</td></tr><tr><td></td><td>
moving-max is a specialization
of the <a href="clm.html#delay">delay</a> generator; it produces an envelope that tracks the peak amplitude of the last 'size' samples.
<code>(make-moving-max 256)</code> returns the generator (this one's window size is 256),
and <code>(moving-max gen y)</code> then returns the envelope traced out by the signal 'y'.
The harmonicizer (above) uses this generator to normalize an in-coming signal to 1.0
so that the Chebyshev polynomials it is driving will produce a full spectrum at all times.
Here is a similar, but simpler, example; we use the moving-max generator to track the
current peak amplitude over a small window, use that value to drive a <a href="clm.html#contrast-enhancement">contrast-enhancement</a>
generator (so that its output is always fully modulated), and rescale by the same value
upon output (to track the original sound's amplitude envelope):
<pre>
    (define (intensify index)
      (let* ((mx (make-moving-max))
	     (flt (<a class=quiet href="#makelowpass">make-lowpass</a> (* pi .1) 8))) ; smooth the maxamp signal
        (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (lambda (y)
		       (let ((amp (max .1 (<a class=quiet href="clm.html#fir-filter">fir-filter</a> flt (moving-max mx y)))))
		         (* amp (<a class=quiet href="clm.html#contrast-enhancement">contrast-enhancement</a> (/ y amp) index)))))))
</pre>
This can also be used for automatic gain control -- see dsp.scm for the agc function.
The other "moving" generators are specializations of the <a href="clm.html#moving-average">moving-average</a>
generator.  moving-sum keeps the ongoing sum of absolute values, moving-length the square root of the sum
of squares, and moving-rms the square root of the sum of squares divided by the size.
moving-rms is used in <a href="#overlayrmsenv">overlay-rms-env</a> in draw.scm.
</td></tr><tr><td colspan=2 height=32></td></tr>


<!-- ---------------------------------------- scanned synthesis ---------------------------------------- -->
<tr><td colspan=2 bgcolor="lightgreen"><center><A NAME="dspdocscanned">scanned synthesis</A></center></td><td></td></tr>

<!-- main-index |dspdocscanned:scanned synthesis -->
<!-- scanned synthesis -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="computeuniformcircularstring">compute-uniform-circular-string</A> <code>size x0 x1 x2 mass xspring damp</code><br>
<em class=emdef>compute-string</em> <code>size x0 x1 x2 masses xsprings esprings damps haptics</code>
</td></tr><tr><td></td><td>
These functions implement
scanned synthesis of Bill Verplank and Max Mathews.
To watch the wave, open some sound (so Snd has some place to put the graph), turn off
the time domain display (to give our graph all the window)
then
<pre>
    (let* ((size 128)
	   (x0 (make-vct size))	   
	   (x1 (make-vct size))	   
	   (x2 (make-vct size)))
      (do ((i 0 (1+ i)))
	  ((= i 12))
	(let ((val (sin (/ (* 2 pi i) 12.0))))
	  (vct-set! x1 (+ i (- (/ size 4) 6)) val)))
      (do ((i 0 (1+ i)))
	  ((or (c-g?) (= i 1024)))
	(<em class=red>compute-uniform-circular-string</em> size x0 x1 x2 1.0 0.1 0.0)
	(graph x0 "string" 0 1.0 -10.0 10.0)))
</pre>
There's also a dialog to experiment with this:
<a href="#displayscannedsynthesis">display-scanned-synthesis</a> in snd-motif.scm.
</td></tr><tr><td colspan=2 height=16></td></tr>

</table>

<br>
<br>


<!-- ---------------------------------------- FILE: edit123.scm, snd_conffile.scm, snd_frg.scm ---------------------------------------- -->

<A NAME="dotsnd"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>edit123.scm, snd_conffile.scm, snd_frg.scm</h2></td></tr></table>

<p>These files are examples of Snd customization files, suitable for inclusion in ~/.snd.
edit123.scm is by Tom Roth, snd_conffile.scm is by Kjetil S. Matheussen, and
snd_frg.scm is by Olivier Doare.
There are other examples in <a href="grfsnd.html#sndinitfile">Snd init file</a>.
Olivier Doare describes snd_frg.scm:
</p>
<blockquote>
<pre>
[It] tries to emulate the workflow i had with Sound Forge: 

Main features are: 

- mouse wheel zooming (+ctrl to zoom vertically) 
- up/down arrows to zoom (+ctrl to zoom vertically) 
- left/right key to move one pixel (or one sample at high zoom ratios) (+ctrl to extend selection) 
- double click between marks to select range 
- m to make a mark (named mark is now done with M) 
- ctrl-x , ctrl-c , ctrl-v , ctrl-b to cut, copy, paste, mix. 
- many other shortcuts
</pre>
</blockquote>

<br>



<!-- ---------------------------------------- FILE: env ---------------------------------------- -->

<A NAME="envdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>env</h2></td></tr></table>

<p>
env.scm provides a variety envelope functions.
An envelope in Snd/CLM is simply a list of breakpoint pairs.  In the function names, 
I try to remember to use "envelope" to be a list of breakpoints, and "env" to be the result of <a href="clm.html#make-env">make-env</a>,
a CLM env structure passed to the <a href="clm.html#env">env</a> generator.
In an envelope,
the x axis extent
is arbitrary, though it's simplest to use 0.0 to 1.0.
</p>

<table border=0 cellspacing=0 hspace=20>

<!-- add-envelopes -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>add-envelopes</em> <code>env1 env2</code>
</td></tr><tr><td width=60></td><td>
add-envelopes adds two envelopes together:
<pre>
    :<em class=typing>(add-envelopes '(0 0 1 1) '(0 0 1 1 2 0))</em>
    <em class=listener>(0 0 1/2 3/2 1 1)</em>  ; i.e. (0 0 1 1.5 2 1) in the 2nd env's terms
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- concatenate-envelopes -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="concatenateenvelopes">concatenate-envelopes</a> <code>:rest envs</code>
</td></tr><tr><td></td><td>
concatenate-envelopes concatenates its arguments:
<pre>
    :<em class=typing>(concatenate-envelopes '(0 1 1 0) '(0 0 1 1))</em>
    <em class=listener>(0.0 1 1.0 0 2.0 1)</em>
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- envelope-exp -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>envelope-exp</em> <code>e :optional (power 1.0) (xgrid 100)</code>
</td></tr><tr><td></td><td>
envelope-exp interpolates segments into envelope to approximate exponential curves.
<pre>
    :<em class=typing>(format #f "~{~,3F ~}" (envelope-exp '(0 0 1 1) 3.0 6))</em>
    <em class=listener>"0.000 0.000 0.167 0.005 0.333 0.037 0.500 0.125 0.667 0.296 0.833 0.579 1.000 1.000 "</em>
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- envelope-interp -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="envelopeinterp">envelope-interp</A> <code>x env (base 1.0)</code>
</td></tr><tr><td></td><td>
<code>(envelope-interp x env base)</code> returns value of 'env' at 'x'.
If 'base' is 0, 'env' is treated as a step function; if 'base' is 1.0 (the
default), The breakpoints of 'env' are connected by a straight line, and
any other 'base' connects the breakpoints with a kind of exponential
curve:
<pre>
    :<em class=typing>(envelope-interp .1 '(0 0 1 1))</em>
    <em class=listener>0.1</em>
    :<em class=typing>(envelope-interp .1 '(0 0 1 1) 32.0)</em>
    <em class=listener>0.0133617278184869</em>
    :<em class=typing>(envelope-interp .1 '(0 0 1 1) .012)</em>
    <em class=listener>0.361774730775292</em>
</pre>
The corresponding function for a CLM env generator is <a href="clm.html#env-interp">env-interp</a>.
If you'd rather think in terms of e^-kt, set the 'base' to (exp k).  
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- envelope-last-x -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>envelope-last-x</em> <code>env</code>
</td></tr><tr><td></td><td>
envelope-last-x returns the maximum x value:
<pre>
    :<em class=typing>(envelope-last-x '(0 1 1 0 2 0))</em>
    <em class=listener>2</em>
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- integrate-envelope -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="integrateenvelope">integrate-envelope</a> <code>env</code>
</td></tr><tr><td></td><td>
integrate-envelope returns the area under the envelope.
<pre>
    :<em class=typing>(integrate-envelope '(0 0 1 1))</em>
    <em class=listener>0.5</em>
    :<em class=typing>(integrate-envelope '(0 1 1 1))</em>
    <em class=listener>1.0</em>
    :<em class=typing>(integrate-envelope '(0 0 1 1 2 .5))</em>
    <em class=listener>1.25</em>
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- make-power-env -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>make-power-env</em> <code>e :key (scaler 1.0) (offset 0.0) duration</code><br>
<a class=def name="powerenv">power-env</a> <code>e</code><br>
<em class=emdef>power-env-channel</em> <code>pe :optional (beg 0) dur snd chn edpos (edname "power-env-channel")</code><br>
<em class=emdef>powenv-channel</em> <code>envelope :optional (beg 0) dur snd chn edpos</code>
</td></tr><tr><td></td><td>
make-power-env and power-env implement an extension of exponential
envelopes; each segment has its own base.  power-env-channel uses the same
mechanism as an extension of env-channel.
<pre>
    (let ((pe (make-power-env '(0 0 32.0  1 1 0.0312  2 0 1) :duration 1.0)))
      (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (lambda (y) (* y (power-env pe)))))
    
    (let ((pe1 (make-power-env '(0 0 32.0  1 1 0.0312  2 0 1.0  3 .5 3.0  4 0 0) :duration 1.0)))
      (power-env-channel pe1))
</pre>
powenv-channel is a simplification of power-env-channel; it takes a breakpoint list rather
than a power-env structure: 
<pre>
    (powenv-channel '(0 0 .325  1 1 32.0 2 0 32.0))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- map-envelopes -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>map-envelopes</em> <code>func env1 env2</code>
</td></tr><tr><td></td><td>
map-envelopes applies 'func' to the breakpoints in the two
envelope arguments, returning a new envelope.
<pre>
    :<em class=typing>(map-envelopes + '(0 0 1 1 2 0) '(0 1 2 0))</em>
    <em class=listener>(0 1 1/2 3/2 1 0)</em>  ; i.e. '(0 1 1 1.5 2 0) in the original x-axis bounds
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- max-envelope -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>min-envelope</em> <code>env</code><br>
<a class=def name="maxenvelope">max-envelope</a> <code>env</code>
</td></tr><tr><td></td><td>
max-envelope returns the maximum y value in 'env', and min-envelope returns the minimum y value:
<pre>
    :<em class=typing>(max-envelope '(0 0 1 1 2 3 4 0))</em>
    <em class=listener>3.0</em>
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- multiply-envelopes -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>multiply-envelopes</em> <code>env1 env2</code>
</td></tr><tr><td></td><td>
<b>multiply-envelopes</b> uses map-envelopes to multiply two envelopes:
<pre>
    Scheme:
    :<em class=typing>(multiply-envelopes '(0 0 1 1) '(0 0 1 1 2 0))</em>
    <em class=listener>(0 0 0.5 0.5 1 0)</em>

    Ruby:
    :<em class=typing>multiply_envelopes([0, 0, 1, 1], [0, 0, 1, 1, 2, 0])</em>
    <em class=listener>[0.0, 0.0, 0.5, 0.5, 1.0, 0.0]</em>
 
    Forth:
    <em class=listener>snd&gt;</em><em class=typing> '( 0e 0e 1.0 1.0 ) '( 0e 0e 1.0 1.0 2.0 0.0 ) multiply-envelopes</em>
    <em class=listener>'( 0.0 0.0 0.5 0.5 1.0 0.0 )</em>
</pre>
The new envelope goes from 0.0 to 1.0 along
the X axis; the multiplied envelopes are stretched or contracted to
fit 0.0 to 1.0, and wherever one has a breakpoint, the corresponding
point in the other envelope is interpolated, if necessary.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- normalize-envelope -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="normalizeenvelope">normalize-envelope</a> <code>env :optional (new-max 1.0)</code>
</td></tr><tr><td></td><td>
normalize-envelope returns a version of 'env' scaled so that its maximum y value is 'new-max'.
<pre>
    :<em class=typing>(normalize-envelope '(0 0 1 1 2 3 4 0) .5)</em>
    <em class=listener>(0 0.0 1 0.167 2 0.5 4 0.0)</em>
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>



<!-- repeat-envelope -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>repeat-envelope</em> <code>env repeats :optional reflected normalized</code>
</td></tr><tr><td></td><td>
repeat-envelope repeats an envelope (concatenates copies of itself).
It's usually easier to use <a href="clm.html#mus-reset">mus-reset</a> to restart an envelope over and over.

<table border=0><tr><td>
<pre>
    :<em class=typing>(repeat-envelope '(0 0 .1 .9 1 1 1.3 .2 2 0) 2)</em>
    <em class=listener>(0 0 0.1 0.9 1.0 1 1.3 0.2 2.0 0 2.1 0.9 3.0 1 3.3 0.2 4.0 0)</em>
</pre>
</td></tr><tr>
<td><img src="repenv.png" alt="repeated envelope" hspace=20>
</td></tr></table>

If the final y value is different from the first y value (as above), a quick ramp is
inserted between repeats. 'normalized' causes the new envelope's x axis
to have the same extent as the original's. 'reflected' causes every other
repetition to be in reverse.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- reverse-envelope -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="reverseenvelope">reverse-envelope</a> <code>env</code>
</td></tr><tr><td></td><td>
reverse-envelope reverses an envelope.
<pre>
    :<em class=typing>(reverse-envelope '(0 0 1 1 2 1))</em>
    <em class=listener>(0 1 1 1 2 0)</em>
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- rms-envelope -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="rmsenvelope">rms-envelope</a> <code>file :key (beg 0.0) dur (rfreq 30.0) db</code>
</td></tr><tr><td></td><td>
rms-envelope returns an rms envelope of a file; it is based on rmsenv.ins in the CLM package.
<pre>
    :<em class=typing>(format #f "~{~,3F ~}" (rms-envelope "1a.snd"))</em>
    <em class=listener>"0.000 0.049 0.033 0.069 0.067 0.049 0.100 0.000 0.133 0.000 0.167 0.000 0.200 0.000 "</em>
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- scale-envelope -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="scaleenvelope">scale-envelope</a> <code>env scl (offset 0.0)</code>
</td></tr><tr><td></td><td>
scale-envelope scales the y values of an envelope by 'scl', and optionally adds 'offset'.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- stretch-envelope -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="stretchenvelope">stretch-envelope</a> <code>env old-attack new-attack (old-decay #f) (new-decay #f)</code>
</td></tr><tr><td></td><td>
stretch-envelope applies attack and optionally decay times
to an envelope, much like divseg in clm-1.
<pre>
    :<em class=typing>(stretch-envelope '(0 0 1 1) .1 .2)</em>
    <em class=listener>(0 0 0.2 0.1 1.0 1)</em>
    :<em class=typing>(stretch-envelope '(0 0 1 1 2 0) .1 .2 1.5 1.6)</em>
    <em class=listener>(0 0 0.2 0.1 1.1 1 1.6 0.5 2.0 0)</em>
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- window-envelope -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>window-envelope</em> <code>beg end env</code>
</td></tr><tr><td></td><td>
window-envelope returns (as an envelope) the portion of its envelope argument that lies
between the x axis values 'beg' and 'end'.  This is useful when you're treating an
envelope as a phrase-level control, applying successive portions of it to many underlying
notes.
<pre>
    :<em class=typing>(window-envelope 1.0 3.0 '(0.0 0.0 5.0 1.0))</em>
    <em class=listener>(1.0 0.2 3.0 0.6)</em>
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>

</table>

<table bgcolor="aliceblue" border=0><tr>
<td>
<pre>see also: <a href="clm.html#envelopes" onmouseover="return escape('env and make-env: envelopes in CLM')">make-env</a> <a href="extsnd.html#envchannel" onmouseover="return escape('the main Snd enveloping function')">env-channel</a> <a href="snd.html#editenvelope" onmouseover="return escape('the envelope editor dialog')">Enved</a> <a href="#envexptchannel">env-expt-channel</a>
</pre>
</td></tr></table>

<br>
<br>


<!-- ---------------------------------------- FILE: enved ---------------------------------------- -->

<A NAME="enveddoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>enved</h2></td></tr></table>

<p>enved.scm implements an independent envelope editor in each channel.  
</p>

<pre>
  <em class=emdef>start-enveloping</em>          ; start including envelope editor windows
  <em class=emdef>stop-enveloping</em>           ; stop including them
  <a class=def name="channelenvelope">channel-envelope</a> snd chn  ; current envelope in a given channel's envelope editor
  <A class=def NAME="playwithenvs">play-with-envs</A> snd        ; apply envelope as sound plays
  <A class=def NAME="playpanned">play-panned</A> snd           ; treat envelope as panning control during playback
</pre>

<p>
<code>(start-enveloping)</code> opens an envelope editor for each subsequently opened sound.
<code>(stop-enveloping)</code> turns this off.
Each envelope can be read or written via <code>(channel-envelope snd chn)</code>.
There are also two examples that use these envelopes: play-with-envs and
play-panned.  The former sets the channel's amplitude from its envelope
during playback (it should be obvious how to apply the envelope to any of the
control panel fields); the latter pans a mono sound into stereo following
the envelope. 
</p>

<img src="envs.png" alt="channel enveds" hspace=20 vspace=10>
<br>
<p>
Closely related to this is xm-enved.scm which implements a separate envelope editor widget.
</p>
<pre>
  <em class=emdef>xe-create-enved</em> name parent args axis   ; make a new editor
  <em class=emdef>xe-envelope</em> xe-editor                   ; current envelope in 'xe-editor'
</pre>
<p>
xe-create-enved returns a new envelope editor whose x axis label is 'name', the x and y axis bounds
are in the list 'axis', the editor's parent widget is 'parent',  and the Xt-style
resource argument list is 'args'.  The editor's current envelope is accessible
(read and write) as 'xe-envelope':
</p>

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(define outer (add-main-pane "hiho" xmFormWidgetClass '()))
(define editor (<em class=red>xe-create-enved</em> "a name" outer 
			     (list XmNleftAttachment   XmATTACH_FORM
				   XmNtopAttachment    XmATTACH_FORM
				   XmNbottomAttachment XmATTACH_FORM
				   XmNrightAttachment  XmATTACH_FORM)
			     '(0.0 1.0 0.0 1.0)))
(set! (<em class=red>xe-envelope</em> editor) (list 0.0 1.0 1.0 0.5))
</pre></td></tr>
</table>
<br>

<table bgcolor="aliceblue" border=0><tr>
<td>
<pre>see also: <a href="clm.html#envelopes" onmouseover="return escape('env and make-env: envelopes in CLM')">make-env</a> <a href="extsnd.html#envchannel" onmouseover="return escape('the main Snd enveloping function')">env-channel</a> <a href="snd.html#editenvelope" onmouseover="return escape('the envelope editor dialog')">Enved</a> <a href="#envdoc">functions</a> <a href="#envexptchannel">env-expt-channel</a>
</pre>
</td></tr></table>

<br>
<br>


<!-- ---------------------------------------- FILE: examp ---------------------------------------- -->

<A NAME="exampdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>examp</h2></td></tr></table>

<p>examp.scm has become a bit of a mess; rather than get organized, I just
appended new stuff as it came to mind.  In this documentation, I'll divide the functions into the following non-orthogonal categories:
<a href="#ssffts">ffts</a>,
<a href="#ssfilters">filters</a>,
<a href="#sseffects">sound effects</a>,
<a href="#ssmarks">marks</a>,
<a href="#ssselections">selections</a>,
<a href="#ssgraphics">graphics</a>, and
<a href="#ssmisc">miscellaneous stuff</a>
</p>

<table border=0 cellspacing=0 hspace=20 vspace=10>


<!-- -------------------------------- examp FFTS -------------------------------- -->
<tr><td colspan=2 bgcolor="lightgreen"><center><A NAME="ssffts">FFTs</A></center></td><td></td></tr>

<!-- correlate -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="correlate">correlate</a> <code>snd chn y0 y1</code>
</td></tr><tr><td width=60></td><td>
correlate graphs the correlation of the 2 channels of the sound 'snd'.
To make this happen automatically as you move the time domain position
slider: <code>(add-hook! <a class=quiet href="extsnd.html#graphhook">graph-hook</a> correlate)</code>.
The last three parameters are unused; they are just for compatibility with graph-hook.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- fft-cancel -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="fftcancel">fft-cancel</a> <code>lo-freq hi-freq :optional snd chn</code>
</td></tr><tr><td></td><td>
fft-cancel ffts an entire channel, zeroes the bins between 'lo-freq' and 'hi-freq' (in Hz), then inverse ffts,
giving a good notch filter.
<pre>
    (fft-cancel 500 1000)  ; squelch frequencies between 500 and 1000 Hz
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- fft-edit -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="fftedit">fft-edit</a> <code>low-freq high-freq :optional snd chn</code>
</td></tr><tr><td></td><td>
fft-edit takes an fft of the entire sound, removes all energy below 'low-freq' and above 'high-freq' (in Hz),
then inverse fft's.  This is the complement of fft-cancel.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- fft-env-edit -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="fftenvedit">fft-env-edit</a> <code>env :optional snd chn</code>
</td></tr><tr><td></td><td>
fft-env-edit is similar to fft-edit, but applies an envelope to the spectral magnitudes.
<pre>
    (fft-env-edit '(0 0 .1 1 .2 1 .3 0 .5 1 1.0 0)) ; 1.0 = srate / 2 here
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- fft-env-interp -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="fftenvinterp">fft-env-interp</a> <code>env1 env2 interp :optional snd chn</code>
</td></tr><tr><td></td><td>
fft-env-interp performs fft-env-edit twice (using 'env1' and 'env2'), then mixes the two results following the interpolation
envelope 'interp'.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- fft-peak -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>fft-peak</em> <code>snd chn scale</code>
</td></tr><tr><td></td><td>
fft-peak is an <a href="extsnd.html#aftertransformhook">after-transform-hook</a> function that reports the peak spectral magnitude in the minibuffer.
<pre>
    Scheme: (add-hook! <a class=quiet href="extsnd.html#aftertransformhook">after-transform-hook</a> fft-peak)

    Ruby:   $after_transform_hook.add_hook!(\"fft-peak\") do |snd, chn, scale|
              fft_peak(snd, chn, scale)
            end
</pre>
This can be helpful if you're scanning a sound with the fft graph displayed; since it normalizes
to 1.0 (to keep the graph from jumping around simply because the amplitude is changing), it's nice to know what the current peak
actually represents.  You can, of course, turn off the normalization:
<pre>
    (set! (<a class=quiet href="extsnd.html#normalizefft">transform-normalization</a>) dont-normalize)
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- fft-smoother -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="fftsmoother">fft-smoother</a> <code>cutoff start samps :optional snd chn</code>
</td></tr><tr><td></td><td>
fft-smoother uses fft filtering to
smooth a portion of a sound, returning a vct with the smoothed data.  'cutoff' sets where we starting zeroing out high frequencies.
<pre>
    Scheme: (<a class=quiet href="extsnd.html#vcttochannel">vct-&gt;channel</a> (fft-smoother .1 (<a class=quiet href="extsnd.html#cursor">cursor</a>) 400 0 0) (<a class=quiet href="extsnd.html#cursor">cursor</a>) 400)
    Ruby:   vct2channel(fft_smoother(0.1, cursor, 400, 0, 0), cursor, 400)
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- fft-squelch -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="fftsquelch">fft-squelch</a> <code>squelch :optional snd chn</code>
</td></tr><tr><td></td><td>
fft-squelch is similar to fft-edit; any fft bin whose (normalized) magnitude is below 'squelch' is set to 0.0.
This is sometimes useful for noise-reduction.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- filter-fft -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="filterfft">filter-fft</a> <code>func :optional (normalize #t) snd chn</code>
</td></tr><tr><td></td><td>
This a sort of generalization of the preceding functions.  It gets the spectrum of all the data in the given channel,
applies the function 'func' to it, then inverse ffts.  'func' should take one argument, the
current spectrum value.
<pre>
    (let ((op (make-one-zero .5 .5))) (filter-fft op))
    (let ((op (make-one-pole .05 .95))) (filter-fft op))
    (filter-fft (lambda (y) (if (&lt; y .1) 0.0 y))) ; like fft-squelch
    (let ((rd (make-sample-reader 0 0 0 1 0))) 
      (scale-by 0) 
      (filter-fft (lambda (y) (rd))))             ; treat sound as spectrum
    (filter-fft contrast-enhancement)
    (filter-fft (lambda (y) (* y y y)))           ; extreme low pass
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- squelch-vowels -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="squelchvowels">squelch-vowels</a> <code>:optional snd chn</code>
</td></tr><tr><td></td><td>
squelch-vowels uses fft data to try to distinguish a steady state portion (a vowel in speech) from
noise (a consonant, sometimes), then tries to remove (set to 0.0) the vowel-like portions.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- superimpose-ffts -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="superimposeffts">superimpose-ffts</a> <code>snd chn y0 y1</code>
</td></tr><tr><td></td><td>
superimpose-ffts is a graph-hook function that
superimposes the ffts of multiple (sync'd) sounds.
<code>(add-hook! <a class=quiet href="extsnd.html#graphhook">graph-hook</a> superimpose-ffts)</code>
This function needs some work...
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- zoom-spectrum -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>zoom-spectrum</em> <code>snd chn y0 y1</code>
</td></tr><tr><td></td><td>
zoom-spectrum sets the transform size to correspond to the time-domain window size.
<code>(add-hook! <a class=quiet href="extsnd.html#graphhook">graph-hook</a> zoom-spectrum)</code>.
</td></tr><tr><td colspan=2 height=16></td></tr>
<tr><td colspan=2 height=16></td></tr>


<!-- -------------------------------- examp FILTERS -------------------------------- -->
<tr><td colspan=2 bgcolor="lightgreen"><center><A NAME="ssfilters">filters</A></center></td><td></td></tr>

<!-- comb-filter -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>comb-filter</em> <code>scaler size</code><br>
<em class=emdef>zcomb</em> <code>scaler size pm</code>
</td></tr><tr><td></td><td>
comb-filter is a simple example of using the CLM <a href="clm.html#comb">comb</a> generator.
<pre>
    Scheme:  (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (comb-filter .8 32))
    Ruby:    map_channel(comb_filter(0.8, 32))
    Forth:   0.8 32 comb-filter-1 map-channel
</pre>
it would be faster to use the comb filter directly:
<pre>
    (<a class=quiet href="extsnd.html#clmchannel">clm-channel</a> (<a class=quiet href="clm.html#make-comb">make-comb</a> .8 32))
</pre>
zcomb is a time-varying comb
filter using the envelope 'pm' (the envelope is applied to the comb filter delay length).
<pre>
    (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (zcomb .8 32 '(0 0 1 10)))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- comb-chord -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>comb-chord</em> <code>scaler size amp</code>
</td></tr><tr><td></td><td>
comb-chord uses comb filters at harmonically
related sizes to create a chord (see also <a href="#chordalize">chordalize</a> in dsp.scm).
'amp' is an overall amplitude scaler.
<pre>
    (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (comb-chord .95 100 .3))
    (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (comb-chord .95 60 .3))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- filtered-env -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>filtered-env</em> <code>e :optional snd chn</code>
</td></tr><tr><td></td><td>
filtered-env takes an amplitude envelope 'e' and creates a one-pole
filter, and moves them in parallel over a sound; 
as the sound gets softer, the low-pass filter's cutoff frequency
gets lower, a sort of poor-man's distance effect.  When 'e'
is at 1.0, no filtering takes place.
<pre>
    (filtered-env '(0 1 1 0)) ; fade out
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- formant-filter -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>formant-filter</em> <code>radius frequency</code>
</td></tr><tr><td></td><td>
formant-filter applies a formant to its input.
<pre>
    (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (formant-filter .99 2400))
</pre>
It's probably faster to use the CLM filter directly:
<pre>
    (<a class=quiet href="extsnd.html#filtersound">filter-sound</a> (<a class=quiet href="clm.html#make-formant">make-formant</a> .99 2400))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- formants -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>formants</em> <code>r1 f1 r2 f2 r3 f3</code>
</td></tr><tr><td></td><td>
formants applies three formants in parallel.
<pre>
    (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (formants .99 900 .98 1800 .99 2700))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- moving-formant -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>moving-formant</em> <code>radius move-envelope</code>
</td></tr><tr><td></td><td>
moving-formant moves a formant according to an envelope (the envelope y value is in Hz).
<pre>
    (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (moving-formant .99 '(0 1200 1 2400)))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- notch-filter -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>notch-filter</em> <code>scaler size</code>
</td></tr><tr><td></td><td>
This is a simple example of calling the CLM <a href="clm.html#notch">notch</a> filter.
<pre>
    (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (notch-filter .8 32))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- osc-formants -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>osc-formants</em> <code>radius bases amounts freqs</code>
</td></tr><tr><td></td><td>
osc-formants sets up any number of independently oscillating formants, then calls map-channel.
<pre>
    Scheme: (osc-formants .99 (vct 400.0 800.0 1200.0) (vct 80.0 80.0 120.0) (vct 4.0 2.0 3.0))
    Ruby:   osc_formants(0.99, vct(400, 800, 1200), vct(80, 80, 120), vct(4, 2, 3))
</pre>
'bases' are the formant center frequencies; 'freqs' are the oscillator frequencies;
'amounts' are "deviations" -- they scale the oscillator outputs which set the runtime
formant frequencies (thereby setting the width of the warbling).
</td></tr><tr><td colspan=2 height=16></td></tr>
<tr><td colspan=2 height=16></td></tr>


<!-- -------------------------------- examp SOUND EFFECTS -------------------------------- -->
<tr><td colspan=2 bgcolor="lightgreen"><center><A NAME="sseffects">sound effects</A></center></td><td></td></tr>


<!-- add-notes -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>add-notes</em> <code>notes :optional snd chn</code>
</td></tr><tr><td></td><td>
add-notes adds (mixes) 'notes' starting at the cursor in the currently selected channel.
'notes' is a list of lists of the form: <code>(list file :optional offset amp)</code>.
<pre>
    Scheme: (add-notes '(("oboe.snd") 
                         ("pistol.snd" 1.0 2.0)))

    Ruby:   add_notes([["oboe.snd"], 
                       ["pistol.snd", 1.0, 2.0]])
</pre>
This mixes "oboe.snd" at time 0.0,
then "pistol.snd" at 1.0 (second) scaled by 2.0.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- am -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>am</em> <code>freq</code><br>
<em class=emdef>ring-mod</em> <code>freq gliss-env</code><br>
<em class=emdef>ring-modulate-channel</em> <code>freq :optional beg dur snd chn edpos</code><br>
<em class=emdef>vibro</em> <code>speed depth</code>
</td></tr><tr><td></td><td>
These functions perform amplitude modulation and ring-modulation. 'freq' is the modulation frequency.
<pre>
    (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (am 440))
    (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (ring-mod 10 (list 0 0 1 (<a class=quiet href="clm.html#hztoradians">hz-&gt;radians</a> 100))))
    (ring-modulate-channel 100.0)
    (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (vibro 440 0.5))
</pre>
am uses the CLM <a href="clm.html#amplitude-modulate">amplitude-modulate</a> generator;
the others are little more than <a href="clm.html#oscil">oscil</a> and a multiply.
'gliss-env' in ring-mod controls the frequency of the modulation.
ring-modulate-channel uses <a href="extsnd.html#ptreechannel">ptree-channel</a> for maximum speed and efficiency.
See also <a href="clm.html#ssb-am">ssb-am</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- chain-dsps -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="chaindsps">chain-dsps</a> <code>beg dur :rest dsps</code>
</td></tr><tr><td></td><td>
chain-dsps creates a patch of chained generators from its arguments.
Someone wanted to set up generator patches in a note list:
<pre>
    (with-sound ()
      (chain-dsps 0 1.0 '(0 0 1 .25 2 0) (<a class=quiet href="clm.html#make-oscil">make-oscil</a> 440))
      (chain-dsps 1.0 1.0 '(0 0 1 1 2 0) (<a class=quiet href="clm.html#make-one-zero">make-one-zero</a> .5) (<a class=quiet href="clm.html#make-readin">make-readin</a> "oboe.snd"))
      (chain-dsps 2.0 1.0 '(0 0 1 .125 2 0) (let ((osc1 (<a class=quiet href="clm.html#make-oscil">make-oscil</a> 220)) 
					          (osc2 (<a class=quiet href="clm.html#make-oscil">make-oscil</a> 440))) 
				              (lambda (val) (+ (osc1 val) 
						               (osc2 (* 2 val)))))))
</pre>
The 'dsps' is a sequence of breakpoint lists and generators; the breakpoint lists
are treated as envelopes, and the generators are connected (previous) output to (current) input in the reverse of the order
received.  <a href="clm.html#readin">readin</a> is an exception; since its input comes
from a file, it is added to the current output.
So, the first call is an <a href="clm.html#oscil">oscil</a> multiplied
by an envelope.  The second filters and envelopes readin input.
The third sets up an additive synthesis patch.
In Ruby, this example is:
<pre>
    with_sound() do
      chain_dsps(0, 1.0, [0, 0, 1, 1, 2, 0], make_oscil(:frequency, 440))
      chain_dsps(0, 1.0, [0, 0, 1, 1, 2, 0], make_one_pole(0.5), make_readin("oboe.snd"))
      chain_dsps(0, 1.0, [0, 0, 1, 1, 2, 0], 
       let(make_oscil(:frequency, 220),
           make_oscil(:frequency, 440)) 
         do |osc1, osc2|
           lambda do |val| 
             osc1.run(val) + osc2.run(2.0 * val) 
         end
       end)
    end
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- compand -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>compand</em><br>
<a class=def name="compandchannel">compand-channel</a> <code>:optional beg dur snd chn edpos</code>
</td></tr><tr><td></td><td>
These functions lookup a table value based on the current sample amplitude; the table is set up
so that soft portions are slightly amplified.  compand-channel is the same as compand except
that it uses <a href="extsnd.html#ptreechannel">ptree-channel</a>.  The companding curve is
taken from Steiglitz "A DSP Primer".
<pre>
    (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (compand))
    (compand-channel)
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- compand-sound -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="compandsound">compand-sound</a> <code>:optional (beg 0) dur snd</code>
</td></tr><tr><td width=60></td><td>
compand-sound applies companding to every channel of the sound 'snd'.
It is the multichannel version of <a href="#compandchannel">compand-channel</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- cnvtest -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>cnvtest</em> <code>snd0 snd1 amp</code>
</td></tr><tr><td></td><td>
This is a simple example of using convolution.
It convolves 'snd0' and 'snd1' (using the CLM <a href="clm.html#convolve">convolve</a> generator), 
then scales by 'amp'. It returns the new maximum amplitude.
<pre>
    (cnvtest 0 1 .1)
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- cross-synthesis -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="crosssynthesis">cross-synthesis</a> <code>cross-snd amp fftsize radius</code>
</td></tr><tr><td></td><td>
cross-synthesis performs cross-synthesis between 'cross-snd' (a sound index) and the currently 
selected sound.
'cross-snd' is the sound that controls the spectra.
<pre>
    (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (cross-synthesis 1 .5 128 6.0))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- echo -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>echo</em> <code>scaler secs</code><br>
<em class=emdef>flecho</em> <code>scaler secs</code><br>
<em class=emdef>zecho</em> <code>scaler secs frq amp</code>
</td></tr><tr><td></td><td>
These are simple delay-based sound effects. 
echo returns an echo maker ('secs' is the delay in seconds between echos, 'scaler' is
the amplitude ratio between successive echoes).
zecho is similar, but also modulates the echoes.
flecho is a low-pass filtered echo maker.
See <a href="grfsnd.html#sndwithclm">Snd with CLM</a> for
a discussion.
<pre>
    Scheme:
    (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (echo .5 .5) 0 44100)
    (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (zecho .5 .75 6 10.0) 0 65000)
    (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (flecho .5 .9) 0 75000)

    Ruby:
    map_channel(echo(0.5, 0.5), 0 44100)
    map_channel(zecho(0.5, 0.75, 6, 10.0), 0, 65000)
    map_channel(flecho(0.5, 0.9), 0, 75000)
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- expsrc -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="expsrc">expsrc</a> <code>rate :optional snd chn</code>
</td></tr><tr><td></td><td>
expsrc uses sampling rate conversion (the <a href="clm.html#src">src</a> generator) and granular synthesis (the <a href="clm.html#granulate">granulate</a> generator)
to change the pitch of a sound without changing its duration.
<pre>
    (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (expsrc 2.0)) ; up an octave
</pre>
There are lots of other related examples: see for example <a href="#clmexpsrc">clm-expsrc</a>, expsnd below,
<a href="#ssbbank">ssb-bank</a>, or the <a href="clm.html#phase-vocoder">phase-vocoder</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- expsnd -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="expsnd">expsnd</a> <code>rate-envelope :optional snd chn</code>
</td></tr><tr><td></td><td>
expsnd uses the same technique as expsrc, but uses it to change the tempo according to an envelope while
maintaining the original pitch.
expsnd needs dsp.scm (but doesn't check that it is loaded).
<pre>
    (expsnd '(0 1 2 .4))   ; speed up
    (expsnd '(0 .5 2 2.0)) ; start fast, end slow
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- main-index |fp:Forbidden Planet -->
<!-- fp -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="fp">fp</a> <code>sr osamp osfrq :optional snd chn</code>
</td></tr><tr><td></td><td>
fp drives an <a href="clm.html#src">src</a> generator with an oscillator, modulating
a sound.  'sr' is the base sampling rate; 'osamp' is the modulation depth; 'osfrq' is
the modulation frequency.  hello-dentist below is a randomized version of this.  The name "fp"
refers to "Forbidden Planet" which used this kind of sound effect a lot.
<pre>
    (fp 1.0 .3 20)
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- hello-dentist -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="hellodentist">hello-dentist</a> <code>frq amp :optional snd chn</code>
</td></tr><tr><td></td><td>
hello-dentist drives n <a href="clm.html#src">src</a> generator with a <a href="clm.html#rand-interp">rand-interp</a>
generator, producing a random quavering effect, hence the name.
<pre>
    (hello-dentist 40.0 .1)
</pre>
'frq' is the random number frequency; 'amp' sets the depth of the modulation.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- place-sound -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="placesound">place-sound</a> <code>mono-snd stereo-snd panning-envelope-or-degree</code>
</td></tr><tr><td></td><td>
place-sound mixes a mono sound ('mono-snd', an index) into a stereo sound ('stereo-snd') 
with panning determined by 'panning-envelope-or-degree'.
If 'panning-envelope-or-degree' is a number (in degrees),
the place-sound function has the same effect as using
CLM's <a href="clm.html#locsig">locsig</a> generator; it mixes a mono sound into a stereo sound, splitting 
it into two copies whose amplitudes depend on the desired location.
0 degrees: all in channel 0, 90: all in channel 1.
<pre>
    (place-sound 0 1 45.0) 
    ;; 0=sound 0 (mono), 1=sound 1 (stereo), 45 deg, so outa * 0.5 and outb * 0.5
</pre>
If 'panning-envelope-or-degree' is an envelope,
the split depends on the panning envelope (0 = all in chan 0, etc).
<pre>
    (place-sound 0 1 '(0 0 1 1)) ; mix goes from all in outa to all in outb
</pre>
This function could use at least a start time parameter.

<table border=3 bordercolor="tan" hspace=20 vspace=20><tr><td>
<blockquote><small>
<br>
Panning or Sound Placement<br>
Place sound: <a href="#placesound">place-sound</a> above.<br>
Pan mix: <a href="#panmix">pan-mix</a>, or via the amplitude and envelope controls in the mix dialog<br>
Place mix: <a href="clm.html#musmix">mus-mix</a><br>
Play sound with panning: <a href="#playpanned">play-panned</a><br>
CLM placement generator: <a href="clm.html#locsig">locsig</a><br>
CLM moving sound generator: <a href="#dlocsigdoc">dlocsig</a><br>
Move sound via flanging: see flanging effect in new-effects.scm<br>
Cross fade in frequency domain: <a href="#fadedoc">fade.scm</a><br>
<br>
</small></blockquote>
</td></tr></table>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- pulse-voice -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>pulse-voice</em> <code>cosines :optional (freq 440.0) (amp 1.0) (fftsize 256) (r 2.0) snd chn</code>
</td></tr><tr><td></td><td>
This function is a form of cross-synthesis which drives the resynthesis with a <a href="clm.html#sum-of-cosines">sum-of-cosines</a> pulse train.
'freq' is the sum-of-cosines frequency; 'amp' is an overall amplitude scaler;
'cosines' is the number of cosines in the pulse (the more the spikier);
'fftsize' and 'r' (radius) control the <a href="clm.html#formant">formant</a> bank
used to get the current spectrum.
<pre>
    (pulse-voice 80 20.0 1.0 1024 0.01)
    (pulse-voice 80 120.0 1.0 1024 0.2)
    (pulse-voice 30 240.0 1.0 1024 0.1)
    (pulse-voice 6 1000.0 1.0 512)
</pre>
See also voice-&gt;unvoiced below.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- ramp -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>ramp</em> <code>gen up</code><br>
<em class=emdef>make-ramp</em> <code>:optional (size 128)</code>
</td></tr><tr><td></td><td>
ramp is a generator that produces a ramp of a given length, then sticks at 0.0 or 1.0 until the 'up' argument changes.
The idea here is that we want to ramp in or out a portion of a sound based on some
factor of the sound data; the ramp generator produces a ramp up when 'up' is #t, sticking
at 1.0, and a ramp down when 'up' is #f, sticking at 0.0.
'size' sets the steepness of the ramp.
A similar, less bumpy effect uses the <a href="clm.html#moving-average">moving-average</a> generator.
The following produces a very jittery, wandering amplitude envelope (brownian motion):
<pre>
    (let ((ramper (make-ramp 1000)))  ; ramp via increments of .001
      (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (lambda (y) 
                     (* y (ramp ramper (&lt; (random 1.0) .5))))))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- reverse-by-blocks -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="reversebyblocks">reverse-by-blocks</A> <code>block-len :optional snd chn</code><br>
<em class=emdef>reverse-within-blocks</em> <code>block-len :optional snd chn</code>
</td></tr><tr><td></td><td>
reverse-by-blocks and reverse-within-blocks work best with
speech. reverse-by-blocks divides a sound into blocks, then recombines those blocks in reverse order.
reverse-within-blocks divides a sound into blocks, then recombines them in order, but with each block internally reversed.
'block-len' is the block length in seconds.
<pre>
   (reverse-by-blocks .1)
   (reverse-within-blocks .1) ; .5 is also good
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- scramble-channels -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>scramble-channels</em> <code>:rest new-order</code><br>
<em class=emdef>scramble-channel</em> <code>silence</code>
</td></tr><tr><td></td><td>
scramble-channels uses <a href="extsnd.html#swapchannels">swap-channels</a>
to arbitrarily reorder the current sound's channels.  The new channel order
is 'new-order' so
<pre>
    (scramble-channels 3 2 0 1)
</pre>
replaces chan0 with chan3, chan1 with chan2 and so on.
scramble-channel searches for silences, sets up a list of segments based on
those silences, and randomly re-orders the segments.
'silence' determines the background level that is treated as silence.
<pre>
    (scramble-channel .01)
</pre>
This function needs cleaner splices between the sections.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- smooth-channel-via-ptree -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>smooth-channel-via-ptree</em> <code>:optional beg dur snd chn edpos</code>
</td></tr><tr><td></td><td>
This function is a "virtual edit" (<a href="extsnd.html#ptreechannel">ptree-channel</a>) version of 
<a href="extsnd.html#smoothchannel">smooth-channel</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- sound-interp -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="soundinterp">sound-interp</a> <code>reader loc</code><br>
<em class=emdef>make-sound-interp</em> <code>start :optional snd chn</code><br>
<a class=def name="envsoundinterp">env-sound-interp</a> <code>envelope :optional (time-scale 1.0) snd chn</code><br>
<table border=0><tr><td colspan=2><a class=def name="granulatedsoundinterp">granulated-sound-interp</a> <code>envelope :optional (time-scale 1.0) (grain-length 0.10)</code></td></tr><tr><td width=180></td><td><code>(grain-envelope '(0 0 1 1 2 1 3 0)) (output-hop 0.05)  snd chn</code></td></tr></table>
</td></tr><tr><td></td><td>
make-sound-interp returns an interpolating reader for the given channel.
The interpolating reader reads a channel at an arbitary location,
interpolating between samples if necessary.  The corresponding generator is sound-interp.
Here we use a sine wave to lookup the current sound:
<pre>
    (let ((osc (<a class=quiet href="clm.html#make-oscil">make-oscil</a> :frequency 0.5 :initial-phase (+ pi (/ pi 2))))
	  (reader (make-sound-interp 0 0 0)) 
	  (len (1- (<a class=quiet href="extsnd.html#frames">frames</a> 0 0))))
      (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (lambda (val) 
		     (sound-interp reader (* len (+ 0.5 (* 0.5 (<a class=quiet href="clm.html#oscil">oscil</a> osc))))))))
</pre>
env-sound-interp reads the given channel (via a sound-interp generator)
according to 'envelope' and 'time-scale',
returning a new version of the data in the specified channel
that follows that envelope; that is, when the envelope is 0.0 we get sample 0, when the
envelope is 1.0 we get the last sample, when it is 0.5 we get the middle sample of the 
sound and so on. 
<pre>
    Scheme: (env-sound-interp '(0 0 1 1))
    Ruby:   env_sound_interp([0, 0, 1, 1])
</pre> 
returns an unchanged copy of the
current sound. To get the entire sound in reverse:
<pre>
    Scheme: (env-sound-interp '(0 1 1 0))
    Ruby:   env_sound_interp([0, 1, 1, 0])
</pre>
And to go forward then backward, taking twice the original duration:
<pre>
    Scheme: (env-sound-interp '(0 0 1 1 2 0) 2.0)
    Ruby:   env_sound_interp([0, 0, 1, 1, 2, 0], 2.0)
</pre>
<a href="extsnd.html#srcsound">src-sound</a> with an
envelope could be used for this effect, but it is much more direct to apply the
envelope to sound sample positions.  A similar function is <a href="#scratch">scratch</a> in clm-ins.scm.
<br><br>
granulated-sound-interp is similar to env-sound-interp, but uses granular synthesis rather than
sampling rate conversion to recreate the sound, so the effect is one of changing tempo rather
than changing speed (pitch).  Here we dawdle for awhile, then race at the end to get the whole sound in:
<pre>
   (granulated-sound-interp '(0 0 1 .1 2 1) 1.0 0.2 '(0 0 1 1 2 0))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- voiced-&gt;unvoiced -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="voicedtounvoiced">voiced-&gt;unvoiced</a> <code>amp fftsize r tempo :optional snd chn</code>
</td></tr><tr><td></td><td>
This function is a form of cross-synthesis which drives the resynthesis with white noise (see also pulse-voice above).
<pre>
     (voiced-&gt;unvoiced 1.0 256 2.0 2.0) ; whispered, twice as fast as original
</pre>
'tempo' is the speed of the resynthesis.
</td></tr><tr><td colspan=2 height=16></td></tr>
<tr><td colspan=2 height=16></td></tr>



<!-- -------------------------------- examp MARKS -------------------------------- -->
<tr><td colspan=2 bgcolor="lightgreen"><center><A NAME="ssmarks">marks</A></center></td><td></td></tr>

<!-- first-mark-in-window-at-left -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>first-mark-in-window-at-left</em>
</td></tr><tr><td></td><td>
first-mark-in-window-at-left moves the (time domain) 
graph so that the leftmost visible mark is at the left edge.
In large sounds it can be pain to get the left edge of the window
aligned with a specific spot in the sound.  In the following code, we assume
the desired left edge has a mark, and the 'l' key (without control)
will move the window left edge to that mark.
<pre>
    (<a class=quiet href="extsnd.html#bindkey">bind-key</a> #\l 0 
      (lambda () 
        "move window to align with mark"
        (first-mark-in-window-at-left)))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- mark-loops -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="markloops">mark-loops</a>
</td></tr><tr><td></td><td>
mark-loops places marks at any loop points found in the current sound's header.
Only a few headers support loop points which are apparently used in synthesizers
to mark portions of a waveform that can be looped without causing clicks, thereby lengthening
a sound as a key is held down. 
</td></tr><tr><td colspan=2 height=16></td></tr>
<tr><td colspan=2 height=16></td></tr>



<!-- -------------------------------- examp SELECTIONS -------------------------------- -->
<tr><td colspan=2 bgcolor="lightgreen"><center><A NAME="ssselections">selections</A></center></td><td></td></tr>

<!-- region-play-list -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="regionplaylist">region-play-list</a> <code>data</code><br>
<em class=emdef>region-play-sequence</em> <code>data</code>
</td></tr><tr><td></td><td>
region-play-list plays a list of regions.  'data' is list of lists:
<code>(list (list time reg)...)</code>; region 'reg' is played at time 'time' (in seconds).
<pre>
    (region-play-list (list (list 0.0 0) (list 0.5 1) (list 1.0 2) (list 1.0 0)))
</pre>
which plays region 0 at time 0.0 and 1.0, region 1 at 0.5, and region 2 at 1.0.
Similarly, region-play-sequence plays a sequence of regions, one after the other:
<pre>
    (region-play-sequence '(0 1 2 0)) ; play in same order as before, but one after the other
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- region-rms -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="regionrms">region-rms</a> <code>:optional reg</code>
</td></tr><tr><td></td><td>
region-rms returns the rms value of the region's data (in chan 0).
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- replace-with-selection -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="replacewithselection">replace-with-selection</a>
</td></tr><tr><td></td><td>
replace-with-selection replaces any data at the cursor with the
current selection.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- selection-rms -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="selectionrms">selection-rms</a><br>
</td></tr><tr><td></td><td>
selection-rms returns the rms value of the selection's data (in chan 0).
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- swap-selection-channels -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="swapselectionchannels">swap-selection-channels</a>
</td></tr><tr><td></td><td>
swap-selection-channels swaps the current selection's channels.
</td></tr><tr><td colspan=2 height=16></td></tr>
<tr><td colspan=2 height=16></td></tr>



<!-- -------------------------------- examp GRAPHICS -------------------------------- -->
<tr><td colspan=2 bgcolor="lightgreen"><center><A NAME="ssgraphics">graphics</A></center></td><td></td></tr>

<!-- auto-dot -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>auto-dot</em> <code>snd chn y0 y1</code>
</td></tr><tr><td></td><td>
auto-dot sets the dot size (when you're using dots in the time domain) based on 
the current graph size.
<pre>
    (add-hook! <a class=quiet href="extsnd.html#graphhook">graph-hook</a> auto-dot)
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- display-db -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="displaydb">display-db</a> <code>snd chn</code>
</td></tr><tr><td></td><td>
display-db is a <a href="extsnd.html#lispgraphhook">lisp-graph-hook</a> function to display the time domain data in dB.
<pre>
    (add-hook! <a class=quiet href="extsnd.html#lispgraphhook">lisp-graph-hook</a> display-db)
</pre>
I just noticed that its y axis is labelled upside down.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- display-energy -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="displayenergy">display-energy</A> <code>snd chn</code>
</td></tr><tr><td></td><td>
display-energy is a <a href="extsnd.html#lispgraphhook">lisp-graph-hook</a> function to display the time domain data squared.
<a href="extsnd.html#xdisplayenergy">Here</a> is a picture of it in action.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- flash-selected-data -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>flash-selected-data</em> <code>time-interval</code>
</td></tr><tr><td></td><td>
flash-selected-data causes the selected channel's graph to
flash red and green.  'time-interval' is in milliseconds:
<pre>
    (flash-selected-data 100)
</pre>
Not sure why anyone would want such a thing...
examp.scm also has (commented out) functions to display colored text
in rxvt:
<pre>
    (display (format #f "~Athis is red!~Abut this is not" red-text normal-text))
    (display (format #f "~A~Ahiho~Ahiho" yellow-bg red-fg normal-text))
</pre>
It's possible to use the same escape sequences in a normal shell script, of course:
<pre>
    echo '\e[41m This is red! \e[0m'
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- title-with-date -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="titlewithdate">title-with-date</a>
</td></tr><tr><td></td><td>
title-with-date adds a clock to the Snd window's title bar.
Set the variable 'retitle-time' to 0 to turn this off.
</td></tr><tr><td colspan=2 height=16></td></tr>
<tr><td colspan=2 height=16></td></tr>



<!-- -------------------------------- examp MISCELLANEOUS EXTENSIONS -------------------------------- -->
<tr><td colspan=2 bgcolor="lightgreen"><center><A NAME="ssmisc">miscellaneous stuff</A></center></td><td></td></tr>

<!-- all-chans -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="allchans">all-chans</A>
</td></tr><tr><td></td><td>
all-chans returns two parallel lists, the first a list of sound indices, the second of channel numbers.  If we have 
two sounds open (indices 0 and 1 for example), and the second has two channels, <code>(all-chans)</code> returns 
<code>'((0 1 1) (0 0 1))</code>.  The interpretation is: <code>'((index0 index1 index1) (chan0 chan0 chan1))</code>,
so if we're mapping some function with the usual <code>snd chn</code> parameters over all the current channels,
we can get the sound and channel values from these lists.  
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- channel-clipped? -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>channel-clipped?</em> <code>:optional snd chn</code>
</td></tr><tr><td></td><td>
channel-clipped? returns #t and a sample number if it finds clipping in the given channel.
examp.scm also has commented out code that places a mark at the start of each clipped
section in a sound, and adds a menu item ("Show Clipping") under the View menu.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- do? -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="dop">do?</a><br>
<em class=emdef>do-go-on</em>
</td></tr><tr><td></td><td>
do? provides an interruptable and continuable "do".
If do? is running and you type C-g, the current continuation is stored in do-go-on-continuation, and do? exits.
To pick up where you interrupted it, type <code>(do-go-on)</code>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- do-chans -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>do-chans</em> <code>func :optional origin</code><br>
<em class=emdef>do-all-chans</em> <code>func :optional origin</code><br>
<em class=emdef>do-sound-chans</em> <code>func :optional origin</code>
</td></tr><tr><td></td><td>
do-chans applies 'func' to all the sync'd channels using 'origin' as the edit history indication.
do-all-chans is the same but applies 'func' to all channels of all sounds.
do-sound-chans applies 'func' to all channels in the currently selected sound.
<pre>
    (do-all-chans (lambda (val) (* 2.0 val))) ; double all samples
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- every-sample? -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="everysample">every-sample?</a> <code>func</code>
</td></tr><tr><td></td><td>
every-sample? applies 'func' to each sample in the current channel and returns
#t if 'func' is not #f for all samples; otherwise it moves the cursor to the first offending sample.
<pre>
    :<em class=typing>(every-sample? (lambda (y) (&lt; (abs y) .1)))</em>
    <em class=listener>#f</em>
    :<em class=typing>(cursor)</em>
    <em class=listener>4423</em>
    :<em class=typing>(sample (cursor))</em>
    <em class=listener>0.101104736328125</em>
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- explode-sf2 -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="explodesf2">explode-sf2</a>
</td></tr><tr><td></td><td>
explode-sf2 turns a soundfont file (assuming it
is the currently selected sound) into a bunch of files of the form sample-name.aif.
It is based on <a href="extsnd.html#soundfontinfo">soundfont-info</a>; that documentation
includes a function, mark-sf2, that places a named mark at start of each new member of the font
and unnamed marks at the various loop points.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- find-click -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>find-click</em> <code>loc</code>
</td></tr><tr><td></td><td>
find-click finds the next click, starting its search at 'loc'.
It returns #f if it can't find a click.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- finfo -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="finfo">finfo</A> <code>filename</code>
</td></tr><tr><td></td><td>
finfo returns a description of the file 'filename'.
<pre>
    :<em class=typing>(finfo "oboe.snd")</em>
    <em class=listener>"oboe.snd: chans: 1, srate: 22050, Sun/Next, big endian short (16 bits), len: 2.305"</em>
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- if-cursor-follows-play-it-stays-where-play-stopped -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>if-cursor-follows-play-it-stays-where-play-stopped</em> <code>:optional (enable #t)</code>
</td></tr><tr><td></td><td>
If you want the cursor to travel along in the waveform while playing, then stay wherever you stop the
playback, call this function after setting <a href="extsnd.html#withtrackingcursor">with-tracking-cursor</a> to #t.
To disable this choice, call it again with #f as the 'enable' argument.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- locate-zero -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>find-pitch</em> <code>pitch</code><br>
<A class=def NAME="locatezero">locate-zero</A> <code>limit</code><br>
<em class=emdef>next-peak</em><br>
<A class=def NAME="searchforclick">search-for-click</a>
<A class=def NAME="zeroplus">zero+</a>
</td></tr><tr><td></td><td>
locate-zero looks for the next sample where adjacent samples together are less than 'limit'
and moves the cursor to that sample. It can be interrupted by C-g.
The others are
examples of searching procedures (to be used with C-s and so on):
zero+ finds the next
positive-going zero crossing (if searching forwards).
next-peak finds
the next maximum or minimum in the waveform.
search-for-click looks for a click.
find-pitch finds the next
place where 'pitch' (in Hz) is predominate.
For example, type C-s (in the graph), then in the minibuffer:
<code>(find-pitch 600)</code>, and if the function finds some place in the sound
where 600 Hz seems to be the basic pitch, it moves the cursor there and
reports the time in the minibuffer text window.
See also the multichannel case: <a href="sndscm.html#simultaneouszerocrossing">simultaneous-zero-crossing</a> in frame.scm.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- mpg -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="mpg">mpg</a> <code>mpgfile rawfile</code>
</td></tr><tr><td></td><td>
mpg uses the "system" function to call mpg123 to translate an MPEG
format sound file to a headerless ("raw") file containing 16-bit samples.
<pre>
    (shell "df")
    (add-hook! <a class=quiet href="extsnd.html#closehook">close-hook</a> (lambda (snd) (shell \"sndplay wood16.wav\")))
    (mpg "mpeg.mpg" "mpeg.raw")
</pre>
This is now built-in if the Snd configuration process can find mpg123.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- open-buffer -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="openbuffer">open-buffer</a> <code>filename</code><br>
<em class=emdef>close-buffer</em> <code>snd</code>
</td></tr><tr><td></td><td>
These two function implement a "Buffers" menu
which provides a list of currently open sounds; select one
in the menu to make it the selected sound; open-buffer
adds a menu item that selects a file, close-buffer removes it.
To activate this, we need
to:
<pre>
    (add-hook! <a class=quiet href="extsnd.html#openhook">open-hook</a> open-buffer)
    (add-hook! <a class=quiet href="extsnd.html#closehook">close-hook</a> close-buffer)
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- open-next-file-in-directory -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="opennextfileindirectory">open-next-file-in-directory</a><br>
<em class=emdef>click-middle-button-to-open-next-file-in-directory</em>
</td></tr><tr><td></td><td>
click-middle-button-to-open-next-file-in-directory sets up the mouse-click-hook and open-hook so that clicking the middle
mouse button closes the current file and opens the next (alphabetical
by filename) in the current directory.  These are used in edit123.scm.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- play-ac3 -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>play-ac3</em> <code>name</code>
</td></tr><tr><td></td><td>
play-ac3 tries to play an AC3 encoded sound file by calling a52dec.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- read-ascii -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>read-ascii</em> <code>file :optional (out-filename "test.snd") (out-type mus-next) (out-format mus-bshort) (out-srate 44100)</code>
</td></tr><tr><td></td><td>
read-ascii tries to turn a text file into a sound file.
Octave or perhaps WaveLab produce these files; each line has one integer (as text), apparently a signed short.
The read-ascii parameters describe the output file.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- read-flac -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>read-flac</em> <code>file</code><br>
<em class=emdef>write-flac</em> <code>snd</code>
</td></tr><tr><td></td><td>
read-flac and write-flac deal with FLAC files.  This is now built into Snd if the flac
program can be found at configuration time.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- read-ogg -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>read-ogg</em> <code>file</code><br>
<em class=emdef>write-ogg</em> <code>snd</code>
</td></tr><tr><td></td><td>
read-ogg and write-ogg deal with OGG files.  This is now built into Snd if the oggdec and offenc
programs can be found at configuration time.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- read-speex -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>read-speex</em> <code>file</code><br>
<em class=emdef>write-speex</em> <code>snd</code>
</td></tr><tr><td></td><td>
read-speex and write-speex deal with SPEEX files.  This is now built into Snd if speexdec and speexenc
can be found at configuration time.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- remove-clicks -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="removeclicks">remove-clicks</A>
</td></tr><tr><td></td><td>
remove-clicks looks for obvious clicks and uses smooth-sound to remove them.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- shell -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>shell</em> <code>cmd</code>
</td></tr><tr><td></td><td>
shell is similar
to Guile's 'system' function, but output is sent to Snd's listener, rather than stdout.
<pre>
    :<em class=typing>(shell "ls -la oboe.snd")</em>
    <em class=listener>"-rw-r--r-- 1 bil bil 101684 Jul 10  2005 oboe.snd"</em>
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- snd-out -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>snd-out</em>
</td></tr><tr><td></td><td>
A minor irritation in the current Guile system is that Scheme's "display" function
writes to 'current-output-port', but there's no simple way to redirect that
elsewhere.  So, if your code calls display, the result may be invisible.
One way around this is to reset the current-output-port to be a soft port
that actually calls <a href="extsnd.html#sndprint">snd-print</a> instead:
<pre>
    (set-current-output-port snd-out) ; snd-out is a soft port sending stuff to the listener
</pre>
To return to the standard display behaviour:
<pre>
    (set-current-output-port stdout) ; stdout was saved at load time
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>



<!-- sounds->segment-data -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def NAME="soundstosegmentdata">sounds-&gt;segment-data</A> <code>main-dir (output-file "sounds.data")</code>
</td></tr><tr><td></td><td>
This function takes a directory name, and runs through all the sounds in the embedded
directories, returning a text file with segment start and end times, and segment maxamps.
<pre>
    (sounds-&gt;segment-data "/home/bil/test/iowa/sounds/" "iowa.data")
</pre>
It was written to find the note boundaries in the Iowa musical instrument sound library.
</td></tr><tr><td colspan=2 height=16></td></tr>



<!-- sort-samples -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>sort-samples</em> <code>bins</code>
</td></tr><tr><td></td><td>
sort-samples provides a histogram of the samples (by amplitude) in 'bins' bins.
<pre>
    :<em class=typing>(sort-samples 20)</em>  ; bins go by 0.05
    <em class=listener>:#(129017 90569 915 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)</em>
    ;; so 915 samples were &gt; 0.1 in absolute value
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- sync-all -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="sync-all">sync-all</a>
</td></tr><tr><td></td><td>
sync-all sets the sync fields of all currently open sounds to the same unique value.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- update-graphs -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="updategraphs">update-graphs</a>
</td></tr><tr><td></td><td>
update-graphs updates (redraws) all graphs.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- window-rms -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>window-rms</em>
</td></tr><tr><td></td><td>
window-rms returns the rms of the data in currently selected graph window.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- window-samples -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="windowsamples">window-samples</a> <code>:optional snd chn</code>
</td></tr><tr><td></td><td>
window-samples returns (in a vct) the samples
displayed in the current window for the given channel.
This is just a trivial wrapper for <a href="extsnd.html#channeltovct">channel-&gt;vct</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- xb-open -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="xbopen">xb-open</A> <code>snd</code><br>
<em class=emdef>xb-close</em> <code>snd</code><br>
<em class=emdef>switch-to-buf</em>
</td></tr><tr><td></td><td>
These provide Emacs-like C-x b support where only one sound is visible at a time.
To activate it:
<pre>
    (bind-key #\b 0 switch-to-buf #t)
    (add-hook! <a class=quiet href="extsnd.html#closehook">close-hook</a> xb-close)
    (add-hook! <a class=quiet href="extsnd.html#afteropenhook">after-open-hook</a> xb-open)	    
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


</table>
<br>
<br>



<!-- ---------------------------------------- FILE: extensions ---------------------------------------- -->

<A NAME="extensionsdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>extensions</h2></td></tr></table>

<p>These were originally scattered around examp.scm; I thought it would be more
convenient if they were in one file.
</p>

<table border=0 cellspacing=0 hspace=20>


<!-- channels-equal? -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="channelsequal">channels-equal?</a> <code>snd1 chn1 snd2 chn2 allowable-difference</code><br>
<a class=def name="channels=">channels=?</a> <code>snd1 chn1 snd2 chn2 allowable-difference</code>
</td></tr><tr><td width=60></td><td>
channels=? returns #t if the two specified channels are the same within the
given 'allowable-difference'.
The 'allowable-difference' is checked on each sample, so any sample-wise difference
larger than that causes the comparison to return #f.
channels-equal? returns #t if channels=?
and the channels are the same length.  In channels=? one the other hand, the trailing (extra) samples
in one channel are compared with 0.0 (that is, the shorter channel is padded out with zeros).
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- channel-property -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="channelproperty">channel-property</a> <code>key snd chn</code>
</td></tr><tr><td></td><td>
channel-property returns the value associated with 'key' in the given channel's
<a href="extsnd.html#channelproperties">property list</a>.  To add or change a property, use set! with this procedure. 
<pre>
    Scheme:
    :<em class=typing>(set! (channel-property 'info 0 0) "this is sound 0, first channel")</em>
    <em class=listener>"this is sound 0, first channel"</em>
    :<em class=typing>(channel-property 'info 0 0)</em>
    <em class=listener>"this is sound 0, first channel"</em>

    Ruby:
    ><em class=typing>set_channel_property(:info, "this is info", 0, 0)</em>
    <em class=listener>this is info</em>
    ><em class=typing>channel_property(:info, 0, 0)</em>
    <em class=listener>this is info</em>

    Forth:
    ><em class=typing>'info "this is info" 0 0 set-channel-property</em>
    <em class=listener>'( '( 'info . this is info ) )</em>
    ><em class=typing>'info 0 0 channel-property</em>
    <em class=listener>this is info</em>
</pre>
The property list is convenient because the associated information goes away automatically
when the channel is closed, and the property lists are saved by <a href="extsnd.html#savestate">save-state</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- channel-sync -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="channelsync">channel-sync</a> snd chn
</td></tr><tr><td></td><td>
channel-sync uses the channel-properties list to implement a channel-local sync field.  (This property is currently
not used anywhere).
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- check-for-unsaved-edits -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="checkforunsavededits">check-for-unsaved-edits</a> <code>:optional (check #t)</code>
</td></tr><tr><td></td><td>
check-for-unsaved-edits adds functions to the <a href="extsnd.html#beforeexithook">before-exit-hook</a>
and the <a href="extsnd.html#beforeclosehook">before-close-hook</a> to check
for unsaved edits before exiting Snd or closing a file.  If its argument 'check' is #f, it removes
those hooks.  Normally Snd just closes such a sound, or exits silently, flushing any unsaved edits.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- contrast-channel -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="contrastchannel">contrast-channel</a> <code>index :optional beg dur snd chn edpos</code>
</td></tr><tr><td></td><td>
contrast-channel applies the CLM <a href="clm.html#contrast-enhancement">contrast-enhancement</a> function to a channel;
this is largely equivalent to the control panel Contrast slider.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- contrast-sound -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="contrastsound">contrast-sound</a> <code>index :optional (beg 0) dur snd</code>
</td></tr><tr><td width=60></td><td>
contrast-sound applies contrast-enhancement to every channel of the sound 'snd'.
It is the multichannel version of <a href="#contrastchannel">contrast-channel</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- delete-selection-and-smooth -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="deleteselectionandsmooth">delete-selection-and-smooth</a>
</td></tr><tr><td></td><td>
delete-selection-and-smooth deletes the current selection and smooths the splice.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- dither-channel -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="ditherchannel">dither-channel</a> <code>:optional (amount .00006) beg dur snd chn edpos</code>	
</td></tr><tr><td></td><td>
dither-channel adds "dithering" (noise) to a channel; some experts insist this makes everything copacetic.
The noise consists of two white noise generators adding together.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- dither-sound -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="dithersound">dither-sound</a> <code>:optional (amount .00006) (beg 0) dur snd</code>
</td></tr><tr><td width=60></td><td>
dither-sound adds dithering to every channel of the sound 'snd'.
It is the multichannel version of <a href="#ditherchannel">dither-channel</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- enveloped-mix -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="envelopedmix">enveloped-mix</a> <code>filename beg env</code><br>
</td></tr><tr><td></td><td>
enveloped-mix is like <a href="#mixsound">mix-sound</a>, but includes an
amplitude envelope over the mixed-in data.
<pre>
    (enveloped-mix "pistol.snd" 0 '(0 0 1 1 2 0))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- env-expt-channel -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="envexptchannel">env-expt-channel</a> <code>env exponent :optional (symmetric #t) beg dur snd chn edpos</code><br>
<a class=def name="anyenvchannel">any-env-channel</a> <code>env func :optional beg dur snd chn edpos</code><br>
<em class=emdef>ramp-expt</em> <code>a0 a1 exponent :optional (symmetric #t) beg dur snd chn edpos</code><br>
<a class=def name="sineenvchannel">sine-env-channel</a> <code>env :optional beg dur snd chn edpos</code><br>
<a class=def name="sineramp">sine-ramp</a> <code>a0 a1 :optional beg dur snd chn edpos</code><br>
<A class=def NAME="blackman4envchannel">blackman4-env-channel</A> <code>env :optional beg dur snd chn edpos</code><br>
<em class=emdef>blackman4-ramp</em> <code>a0 a1 :optional beg dur snd chn edpos</code><br>
<A class=def NAME="envsquaredchannel">env-squared-channel</A> <code>env :optional (symmetric #t) beg dur snd chn edpos</code><br>
<em class=emdef>ramp-squared</em> <code>a0 a1 :optional (symmetric #t) beg dur snd chn edpos</code>
</td></tr><tr><td></td><td>
These functions goof around with envelopes in various amusing ways.
any-env-channel takes an envelope and a function to produce the connection between successive
breakpoints, and applies the two to the current channel as an envelope.  This packages up most of
the "boilerplate" associated with applying an envelope to a sound.  It is used by the other
enveloping functions: sine-env-channel, blackman4-env-channel, and env-squared-channel.
sine-ramp and sine-env-channel are the sinusoidal versions of <a href="extsnd.html#rampchannel">ramp-channel</a>
and <a href="extsnd.html#envchannel">env-channel</a>.
<pre>
    (sine-env-channel '(0 0 1 1 2 -.5 3 1))
</pre>
applies the given envelope to the current channel,
connecting the points with a sinusoidal curve.
Similarly, blackman4-env-channel connects the dots with
a sum of cosines, and env-squared-channel connects the dots with an x^2 curve.  To get any other positive exponent,
use env-expt-channel.  The 'symmetric' argument determines whether the
up and down moving ramps look symmetrical around a break point.

<table border=0>
<tr><td><img src="exptenvs.png" alt="exponential envelopes"></td><td>
<pre>
(env-channel '(0 0 1 1 2 -.75 3 0)) 
(env-sound '(0 0 1 1 2 -.75 3 0) 0 100 32.0)  
(env-sound '(0 0 1 1 2 -.75 3 0) 0 100 .032) 
(env-sound '(0 0 1 1 2 -.75 3 0) 0 100 0.0)
(sine-env-channel '(0 0 1 1 2 -.75 3 0))
(env-squared-channel '(0 0 1 1 2 -.75 3 0))
(blackman4-env-channel '(0 0 1 1 2 -.75 3 0))
(env-squared-channel '(0 0 1 1 2 -.75 3 0) #f)
(env-expt-channel '(0 0 1 1 2 -.75 3 0) 3.0)
(env-expt-channel '(0 0 1 1 2 -.75 3 0) 3.0 #f)
(env-expt-channel '(0 0 1 1 2 -.75 3 0) .3)
(env-expt-channel '(0 0 1 1 2 -.75 3 0) .3)
</pre>
</td></tr></table>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- eval-over-selection -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="evaloverselection">eval-over-selection</a> <code>func :optional snd</code>
</td></tr><tr><td></td><td>
eval-over-selection evaluates 'func' on each sample in the current selection. A better
name might be map-selection.
The code:

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(<a class=quiet href="extsnd.html#bindkey">bind-key</a> #\x 4
  (lambda () "eval over selection"
    (if (<a class=quiet href="extsnd.html#selectionok">selection?</a>)
	(<a class=quiet href="extsnd.html#promptinminibuffer">prompt-in-minibuffer</a> "selection eval:" <em class=red>eval-over-selection</em>)
	(<a class=quiet href="extsnd.html#reportinminibuffer">report-in-minibuffer</a> "no selection")))
  #t)
</pre></td></tr></table>

binds the key sequence C-x x to a function that checks for an active selection,
then prompts (in the minibuffer) for the function to apply, and when
you eventually reply with a function, applies that function
to each sample in the selection.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- focus-follows-mouse -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="focusfollowsmouse">focus-follows-mouse</a>
</td></tr><tr><td></td><td>
focus-follows-mouse sets up various hook functions to activate whatever widget is underneath the mouse cursor
(this is sometimes known as "point-to-focus" mode).
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- for-each-sound-file -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="foreachsoundfile">for-each-sound-file</a> <code>func :optional dir</code><br>
<a class=def name="mapsoundfiles">map-sound-files</a> <code>func :optional dir</code><br>
<a class=def name="matchsoundfiles">match-sound-files</a> <code>func :optional dir</code>
</td></tr><tr><td></td><td>
for-each-sound-file and 
map-sound-files apply 'func' to each sound file in 'dir'.
The 'func' is passed one argument, the sound file name.
map-sound-files returns a list of the results, if any, returned from 'func'.
match-sound-files applies 'func' to each sound file in 'dir' and returns a list of files for which func does not return #f.

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(for-each-sound-file
  (lambda (n) 
    (if (&gt; (<a class=quiet href="extsnd.html#mussoundduration">mus-sound-duration</a> n) 10.0) 
      (<a class=quiet href="extsnd.html#sndprint">snd-print</a> n)))
  (<a class=quiet href="extsnd.html#soundfilesindirectory">sound-files-in-directory</a> "."))
</pre></td></tr></table>

We can use Guile's regexp support here to search for all .snd and .wav files:

<pre>
    (let ((reg (make-regexp "\\.(wav|.snd)$")))
      (match-sound-files (lambda (file) (regexp-exec reg file))))
</pre>

In fact, we could replace the built-in procedures <a href="extsnd.html#addsoundfileextension">add-sound-file-extension</a> and
<a href="extsnd.html#soundfilesindirectory">sound-files-in-directory</a> (we're using some procedures written by Dirk Herrman here):

<table border=0 cellpadding=5 hspace=20 vspace=10><tr><td bgcolor="#fafafa"><pre>
(define (filter-list pred? objects)
  (let loop ((objs objects)
	     (result '()))
    (cond ((null? objs) (reverse! result))
	  ((pred? (car objs)) (loop (cdr objs) (cons (car objs) result)))
	  (else (loop (cdr objs) result)))))

(define (grep rx strings)
  (let ((r (make-regexp rx)))
    (filter-list (lambda (x) (regexp-exec r x)) strings)))

(define (directory-&gt;list dir)
  (let ((dport (opendir dir)))
    (let loop ((entry (readdir dport))
	       (files '()))
      (if (not (eof-object? entry))
	  (loop (readdir dport) (cons entry files))
	  (begin
	    (closedir dport)
	    (reverse! files))))))

;;; and now the Snd replacements
(define sound-file-extensions (list "snd" "aiff" "aif" "wav" "au" "aifc" "voc" "wve"))

(define (add-sound-file-extension-1 ext) 
  (set! sound-file-extensions (cons ext sound-file-extensions)))

(define* (sound-files-in-directory-1 :optional (dir "."))
  (sort (grep
	 (format #f "\\.(~{~A~^|~})$" sound-file-extensions)
	 (directory-&gt;list dir))
	string&lt;?))
</pre></td></tr></table>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- insert-channel -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="insertchannel">insert-channel</a> <code>filedat :optional beg dur snd chn edpos</code>
</td></tr><tr><td></td><td>
insert-channel inserts the specified data ('filedat') in the given channel at the given location.
See mix-channel below for a description of 'filedat'.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- make-selection -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="makeselection">make-selection</a> <code>beg end snd chn</code>
</td></tr><tr><td></td><td>
make-selection makes a selection, like <a href="extsnd.html#makeregion">make-region</a> but without creating
a region.  It selects the 'dur' samples starting at 'beg' in the given channel.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- mix-channel -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="mixchannel">mix-channel</a> <code>filedat :optional beg dur snd chn edpos</code>
</td></tr><tr><td></td><td>
mix-channel is a "regularized" version of the file mixing functions (<a class=quiet href="extsnd.html#mix">mix</a> and 
<a href="#mixsound">mix-sound</a>).
Its first argument can be either a filename (a string) or a list containing the filename, the
start point in the file, and (optionally) the channel of the file to mix:
<pre>
    (mix-channel "pistol.snd")             ; mixing starts at sample 0, entire sound is mixed
    (mix-channel "pistol.snd" 10000)       ; mixing starts at sample 10000 in current sound
    (mix-channel (list "pistol.snd" 1000)) ; mixed data starts at sample 1000 in pistol.snd
    (mix-channel (list "2.snd" 0 1))       ; mixed data reads channel 1 in 2.snd
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- mono->stereo -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="monotostereo">mono-&gt;stereo</a> <code>new-name snd1 chn1 snd2 chn2</code><br>
<a class=def name="stereotomono">stereo-&gt;mono</a> <code>orig-snd chan1-name chan2-name</code><br>
<em class=emdef>mono-files-&gt;stereo</em> <code>new-name chan1-file chan2-file</code>
</td></tr><tr><td></td><td>
mono-&gt;stereo combines two mono sounds (currently open in Snd) into one (new) stereo file. 
mono-files-&gt;stereo
is the same, but the source sounds are files, not necessarily already open in Snd.
stereo-&gt;mono takes a stereo sound and produces two new mono sounds.
(The corresponding stereo-&gt;mono-files can be based on the existing
<a href="extsnd.html#extractchannel">extract-channel</a> function).
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- normalized-mix -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="normalizedmix">normalized-mix</a> <code>filename beg in-chan snd chn</code>
</td></tr><tr><td></td><td>
normalized-mix is like <a href="extsnd.html#mix">mix</a> but the mixed result has same peak amplitude as the 
original data. 
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- normalize-sound -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="normalizesound">normalize-sound</a> <code>amp :optional (beg 0) dur snd</code>
</td></tr><tr><td width=60></td><td>
normalize-sound scales the sound 'snd' to peak amplitude 'amp'.
It is the multichannel version of <a href="extsnd.html#normalizechannel">normalize-channel</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- offset-channel -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="offsetchannel">offset-channel</a> <code>amount :optional beg dur snd chn edpos</code>	
</td></tr><tr><td></td><td>
offset-channel adds a constant (DC offset) to a channel.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- offset-sound -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="offsetsound">offset-sound</a> <code>off :optional (beg 0) dur snd</code>
</td></tr><tr><td width=60></td><td>
offset-sound adds 'off' to every sample in the sound 'snd'.  
It is the multichannel version of <a href="#offsetchannel">offset-channel</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- pad-sound -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="padsound">pad-sound</a> <code>beg dur :optional snd</code>
</td></tr><tr><td width=60></td><td>
pad-sound places a block of 'dur' zeros in every channel of the sound 'snd' starting at 'beg'.
It is the multichannel version of <a href="extsnd.html#padchannel">pad-channel</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- redo-channel -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>redo-channel</em> <code>:optional (edits 1) snd chn</code>
</td></tr><tr><td></td><td>
redo-channel is a "regularized" version of <a href="extsnd.html#redo">redo</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- remember-sound-state -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="remembersoundstate">remember-sound-state</a>
</td></tr><tr><td></td><td>
remember-sound-state saves most of a sound's display state when it is closed,
and if that same sound is later re-opened, restores the previous state.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- scale-sound -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="scalesound">scale-sound</a> <code>scl :optional (beg 0) dur snd</code>
</td></tr><tr><td width=60></td><td>
scale-sound multiplies every sample in the sound 'snd' by 'scl'.
It is the multichannel version of <a href="extsnd.html#scalechannel">scale-channel</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- selection-members -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="selectionmembers">selection-members</a>
</td></tr><tr><td></td><td>
selection-members returns a list of lists of <code>'(snd chn)</code> indicating the channels participating in the current selection.
It is the selection-oriented version of <a href="#allchans">all-chans</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- set-global-sync -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="setglobalsync">set-global-sync</a> <code>choice</code>
</td></tr><tr><td></td><td>
set-global-sync sets up a hook function that syncs all of a sound's channels ('choice' == 2),
or all channels (across all sounds) ('choice' == 1).  'choice' == 0 turns off the syncing.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- show-selection -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="showselection">show-selection</a>
</td></tr><tr><td></td><td>
show-selection finds the bounds of the current selection (in all channels), and 
sets the time domain view to show it.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- sound-property -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="soundproperty">sound-property</a> <code>key snd</code>
</td></tr><tr><td></td><td>
sound-property provides access to a sound's <a href="extsnd.html#soundproperties">property list</a>.
These properties are saved when Snd's state is saved (via <a href="extsnd.html#savestate">save-state</a>
or the Options:Save session menu).  To omit a given property at that time, add its name (a symbol) to
the property 'save-state-ignore (a list of symbols); see 'inset-envelope in extensions.scm.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- undo-channel -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>undo-channel</em> <code>:optional (edits 1) snd chn</code>
</td></tr><tr><td></td><td>
undo-channel is a "regularized" version of <a href="extsnd.html#undo">undo</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- with-reopen-menu -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="withreopenmenu">with-reopen-menu</a>
</td></tr><tr><td></td><td>
with-reopen-menu creates a top-level Reopen menu, similar to the Emacs Buffers menu.
It presents a list of previously
closed (and not subsequently re-opened) files in the reverse order of closing.
If you choose one, it is opened.
</td></tr><tr><td colspan=2 height=16></td></tr>

</table>

<br><br>



<!-- ---------------------------------------- FILE: fade ---------------------------------------- -->

<A NAME="fadedoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>fade</h2></td></tr></table>

<!-- main-index |fadedoc:cross-fade (frequency domain) -->

<p>
The two functions in fade.scm perform frequency-domain cross-fades, that is, the
cross-fade is handled by a bank of bandpass filters (<a class=quiet href="clm.html#formant">formant</a> generators).  The effect
is sometimes only slightly different from a normal (time-domain) cross-fade, but
there are some interesting possibilities ("sound evaporation", etc).
</p>
<pre>
    <em class=emdef>cross-fade</em> beg dur amp file1 file2 ramp-beg ramp-dur ramp-type bank-dur fs fwidth
</pre>
<p>
cross-fade stitches 'file1' to 'file2' using filtering to provide the
join (rather than amplitude ramps).  'ramp-type' can be 0: sweep up,
1: sweep down, 2: sweep split from the middle; "sweep up" means that the
low frequencies are filtered out first, etc.  'fs' is how many formants to
set up; 'fwidth' is the formant resonance width control; 'ramp-beg' and
'ramp-dur' set the start point and length of the sweep; 'bank-dur'
controls how much time is spent in the formant bank before starting or after ending
the ramp.
</p>
<pre>
    (with-sound () (cross-fade 0 2 1.0 "oboe.snd" "trumpet.snd" 0.5 1.0 0 .1 256 2))
    (<a class=quiet href="extsnd.html#vcttochannel">vct-&gt;channel</a> (cross-fade 0 1.5 1.0 0 1 0.5 .5 0 1.0 256 2))
</pre>
<p>
These fades seem more successful to me when done relatively quickly (the opposite of the dissolve-fade below
which is best if done as slowly as possible).  With any luck the "sweep up" case can produce a sort of "evaporation" effect.
A similar idea is behind dissolve-fade:
</p>
<pre>
    <a class=def name="dissolvefade">dissolve-fade</a> beg dur amp file1 file2 fsize r lo hi
</pre>
<p>It ramps in and out frequency bands chosen at random.  The original hope was to get something like a graphical dissolve,
but it turns out to be better to let the random changes float along with no overall
direction.  If the current band amplitude is 1.0, we send it toward 0.0 and vice versa.  Given patience
and a suitably noisy original, strange pitches emerge and submerge.  'fsize' is the formant bank size;
'r' is the same as 'fwidth' in cross-fade (resonance width) modulo a factor of 2 (sigh...).
'lo' and 'hi' set the portion of the formant bank that is active during the dissolve.
</p>
<pre>
    (with-sound () (dissolve-fade 0 1 1.0 "oboe.snd" "trumpet.snd" 256 2 0 128))
    (<a class=quiet href="extsnd.html#vcttochannel">vct-&gt;channel</a> (dissolve-fade 0 2 1 0 1 1024 2 2 #f))
</pre>

<table bgcolor="aliceblue" border=0><tr>
<td>
<pre>see also: <a href="#mixdoc" onmouseover="return escape('cross-fade in amplitude')">pan-mix</a>
</pre>
</td></tr></table>

<br>


<!-- ---------------------------------------- FILE: frame ---------------------------------------- -->

<A NAME="framedoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>frame</h2></td></tr></table>

<p>This file implements a bunch of functions using frames, vcts, and sound-data objects: primarily multichannel sound operations
where we want to handle all channels in parallel.  I may
move some of these into C.
</p>

<table border=0 cellspacing=0 hspace=20>

<!-- file->sound-data -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="filetosounddata">file-&gt;sound-data</a> <code>file</code>
</td></tr><tr><td width=60></td><td>
file-&gt;sound-data returns the data of the file 'file' in a sound-data object.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- file->vct -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="filetovct">file-&gt;vct</a> <code>file</code>
</td></tr><tr><td width=60></td><td>
file-&gt;vct returns the data of the file 'file' (channel 0 anyway) in a vct.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- frame-copy -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="framecopy">frame-copy</a> <code>frame</code>
</td></tr><tr><td></td><td>
frame-copy returns a copy of its argument.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- frame-reverse! -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="framereverse">frame-reverse!</a> <code>frame</code>
</td></tr><tr><td></td><td>
frame-reverse! reverses the entries in the given frame.
<pre>
    :<em class=typing>(frame-reverse (make-frame 2 .1 .2))</em>
    <em class=listener>#&lt;frame[2]: [0.200 0.100]&gt;</em>
</pre>
</td></tr><tr><td colspan=2></td></tr>


<!-- frame->sound -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="frametosound">frame-&gt;sound</a> <code>fr pos :optional snd</code>
</td></tr><tr><td></td><td>
frame-&gt;sound places the contents of frame fr into sound snd at position pos.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- frame->sound-data -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="frametosounddata">frame-&gt;sound-data</a> <code>fr sd pos:optional sd</code>
</td></tr><tr><td></td><td>
frame-&gt;sound-data places the contents of its frame argument in its sound-data argument at position pos.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- frame->vct -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="frametovct">frame-&gt;vct</a> <code>frame :optional vct</code>
</td></tr><tr><td></td><td>
frame-&gt;vct places the contents of its frame argument in its vct argument, or in a newly created vct
if the vct argument is omitted.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- insert-frame -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="insertframe">insert-frame</a> <code>fr :optional beg snd edpos</code>
</td></tr><tr><td></td><td>
insert-frame inserts the frame of samples into sound snd (one sample in each channel) at beg.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- insert-sound-data -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="insertsounddata">insert-sound-data</a> <code>sd :optional beg dur snd edpos</code>
</td></tr><tr><td></td><td>
insert-sound-data inserts the sound-data (sd) contents into sound snd at beg.  This provides a sound
insertion function that automatically handles multichannel possibilities (unlike <a href="extsnd.html#insertsamples">insert-samples</a>).
<pre>
(insert-sound-data 
 (<a class=quiet href="#withtempsound">with-temp-sound</a> (:output (<a class=quiet href="extsnd.html#makesounddata">make-sound-data</a> 2 (* 44100 2.0))
		   :srate 44100
		   :channels 2)
   (do ((i 0 (1+ i)))    ; 20 fm-violin notes moving from channel 0 to channel 1
       ((= i 20))
     (<a class=quiet href="sndscm.html#vdoc">fm-violin</a> (* i .1) .1 440 .1 :degree (* i (/ 90 20))))))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- insert-vct -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="insertvct">insert-vct</a> <code>v :optional beg dur snd chn edpos</code>
</td></tr><tr><td></td><td>
insert-vct inserts the vct data into sound snd at beg.  It is just a wrapper
for <a href="extsnd.html#insertsamples">insert-samples</a> that puts the vct argument first.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- map-sound -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="mapsound">map-sound</a> <code>func :optional beg dur snd</code>
</td></tr><tr><td></td><td>
map-sound is a version of <a href="extsnd.html#mapchannel">map-channel</a> that passes func a frame on each call, rather than a sample.
<pre>
    (map-sound (lambda (fr) (<a class=quiet href="clm.html#frame*">frame*</a> fr 2.0)))
</pre>
is another way to scale a sound by 2.0.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- mix-frame -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="mixframe">mix-frame</a> <code>fr :optional beg snd</code>
</td></tr><tr><td></td><td>
mix-frame mixes the frame (fr) of samples into sound snd (one sample in each channel) at beg.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- mix-sound-data -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="mixsounddata">mix-sound-data</a> <code>sd :optional beg dur snd tagged trk</code>
</td></tr><tr><td></td><td>
mix-sound-data mixes the contents of sound-data sd into sound snd at beg.  tagged determines whether
the resulting mixes have tags, and trk is the track they are placed in (0 = none).
See <a href="#insertsounddata">insert-sound-data</a> for an example that could easily be changed to use mixing instead.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- region->frame -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="regiontoframe">region-&gt;frame</a> <code>pos reg</code>
</td></tr><tr><td></td><td>
region-&gt;frame returns a frame containing the contents of the region ref at position pos.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- region->sound-data -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="regiontosounddata">region-&gt;sound-data</a> <code>reg</code>
</td></tr><tr><td></td><td>
region-&gt;sound-data returns a sound-data object containing the contents of the region 'reg'.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- scan-sound -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="scansound">scan-sound</a> <code>func :optional beg dur snd with-sync</code>
</td></tr><tr><td></td><td>
scan-sound is a version of <a href="extsnd.html#scanchannel">scan-channel</a> that passes func a frame on each call, rather than a sample.
If 'with-sync' is #t, the frame read includes all channels currently sync'd to the sound 'snd'.
<pre>
(define* (simultaneous-zero-crossing :optional (beg 0) dur snd)
  (let ((last-fr (<a class=quiet href="clm.html#make-frame">make-frame</a> (<a class=quiet href="extsnd.html#chans">chans</a> snd))))
    (<em class=red>scan-sound</em> (lambda (fr)
		  (let ((result #t))
		    (do ((chn 0 (1+ chn)))
			((= chn (<a class=quiet href="clm.html#framemuschannels">mus-length</a> fr)))
		      (set! result (and result 
                                        (&lt; (* (<a class=quiet href="clm.html#frame-ref">frame-ref</a> fr chn) (<a class=quiet href="clm.html#frame-ref">frame-ref</a> last-fr chn)) 0.0)))
		      (<a class=quiet href="clm.html#frame-set!">frame-set!</a> last-fr chn (<a class=quiet href="clm.html#frame-ref">frame-ref</a> fr chn)))
		    result))
		beg dur snd)))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- selection->sound-data -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="selectiontosounddata">selection-&gt;sound-data</a> <code>:optional beg</code>
</td></tr><tr><td></td><td>
selection-&gt;sound-data returns a sound-data object containing the contents of the current selection.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- simultaneous-zero-crossing -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="simultaneouszerocrossing">simultaneous-zero-crossing</A> <code>:optional (beg 0) dur snd</code>
</td></tr><tr><td></td><td>
simultaneous-zero-crossing looks through all channels of the sound 'snd' for a zero crossing that happens on the
same sample in all channels.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- sound-data->file -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="sounddatatofile">sound-data-&gt;file</a> <code>sd file :optional (srate 22050) (comment "")</code>
</td></tr><tr><td></td><td>
sound-data-&gt;file places the contents of its sound-data argument 'sd' in the newly created sound file 'file'.
<pre>
  (sound-data-&gt;file (sound-&gt;sound-data 44100 44100) "test.snd" 44100)
</pre>
writes the sound data in the currently selected sound between seconds 1 and 2 to "test.snd".
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- sound-data->frame -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="sounddatatoframe">sound-data-&gt;frame</a> <code>sd pos fr</code>
</td></tr><tr><td></td><td>
sound-data-&gt;frame places the contents of its sound-data argument at position pos into its frame argument.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- sound-data->sound -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="sounddatatosound">sound-data-&gt;sound</a> <code>sd beg :optional dur snd</code>
</td></tr><tr><td></td><td>
sound-data-&gt;sound places the contents of its sound-data argument sd into the sound snd starting at beg and going for dur frames.
dur defaults to the sound-data object's length.
See <a href="#insertsounddata">insert-sound-data</a> for an example that could easily be changed to use this 
function (and replacement, of course, rather than insertion).
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- sound->sound-data -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="soundtosounddata">sound-&gt;sound-data</a> <code>beg dur :optional snd</code>
</td></tr><tr><td></td><td>
sound-&gt;sound-data returns a sound-data object containing the contents of the sound snd starting from beg for dur frames.
<pre>
  (sound-data-&gt;sound (sound-data* (sound-&gt;sound-data) 2.0))
</pre>
is yet another way to scale a sound by 2.0.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- sound->frame -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="soundtoframe">sound-&gt;frame</a> <code>pos :optional snd</code>
</td></tr><tr><td></td><td>
sound-&gt;frame returns a frame containing the contents of the sound snd at position pos.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- track->sound-data -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="tracktosounddata">track-&gt;sound-data</a> <code>trk :optional (beg 0)</code>
</td></tr><tr><td></td><td>
track-&gt;sound-data returns a sound-data object containing the contents of the track 'trk'.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- vct->file -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="vcttofile">vct-&gt;file</a> <code>vct file :optional (srate 22050) (comment "")</code>
</td></tr><tr><td></td><td>
vct-&gt;file places the contents of its vct argument in the newly created (mono) sound file 'file'.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- vct->frame -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="vcttoframe">vct-&gt;frame</a> <code>vct :optional frame</code>
</td></tr><tr><td></td><td>
vct-&gt;frame places the contents of its vct argument in its frame argument, or in a newly created frame
if the frame argument is omitted.
</td></tr><tr><td colspan=2 height=16></td></tr>


</table>


<A NAME="framereaders"></a>
<p>To read sound data as an array of frames, there is a set of functions that are parallel
to the sample-reader functions, but which deal in frames.  I will probably move these to C
once the dust settles.
</p>

<table border=0 cellspacing=0 hspace=20>

<!-- copy-frame-reader -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="copyframereader">copy-frame-reader</a> <code>obj</code></td></tr>
<tr><td width=60><br></td><td>
copy-frame-reader returns a copy of the frame-reader 'obj'.
</td></tr><tr><td colspan=2 height=16></td></tr>

<!-- frame-reader-at-end? -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="framereaderatendQ">frame-reader-at-end?</a> <code>obj</code></td></tr>
<tr><td></td><td>
frame-reader-at-end? returns #t if the frame-reader 'obj' is at the end of the sound.
</td></tr><tr><td colspan=2 height=16></td></tr>

<!-- frame-reader-chans -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="framereaderchans">frame-reader-chans</a> <code>obj</code></td></tr>
<tr><td></td><td>
frame-reader-chans returns the number of channels read by the frame-reader 'obj'.
</td></tr><tr><td colspan=2 height=16></td></tr>

<!-- frame-reader-home -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="framereaderhome">frame-reader-home</a> <code>obj</code></td></tr>
<tr><td></td><td>
frame-reader-home returns the sound index associated with the frame-reader 'obj'.
</td></tr><tr><td colspan=2 height=16></td></tr>

<!-- frame-reader-position -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="framereaderposition">frame-reader-position</a> <code>obj</code></td></tr>
<tr><td></td><td>
frame-reader-position returns the current (frame-wise) location of the frame-reader 'obj'.
</td></tr><tr><td colspan=2 height=16></td></tr>

<!-- frame-reader? -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="framereaderQ">frame-reader?</a> <code>obj</code></td></tr>
<tr><td></td><td>
frame-reader? returns #t if 'obj' is a frame-reader.
</td></tr><tr><td colspan=2 height=16></td></tr>

<!-- free-frame-reader -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="freeframereader">free-frame-reader</a> <code>obj</code></td></tr>
<tr><td></td><td>
free-frame-reader releases the frame-reader 'obj'.
</td></tr><tr><td colspan=2 height=16></td></tr>

<!-- make-frame-reader -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="makeframereader">make-frame-reader</a> <code>'start snd dir pos'</code></td></tr>
<tr><td></td><td>
make-frame-reader creates a frame-reader reading the sound 'snd'
starting at frame 'start' with initial read direction 'dir' 
(1=forward, -1=backward).  'pos' is the edit history position to read 
(it defaults to current position).
</td></tr><tr><td colspan=2 height=16></td></tr>

<!-- make-region-frame-reader -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="makeregionframereader">make-region-frame-reader</a> <code>start reg 'dir'</code></td></tr>
<tr><td></td><td>
make-region-frame-reader creates a frame-reader reading region 'reg'.
</td></tr><tr><td colspan=2 height=16></td></tr>

<!-- make-selection-frame-reader -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="makeselectionframereader">make-selection-frame-reader</a> <code>start</code></td></tr>
<tr><td></td><td>
make-selection-frame-reader returns a frame reader that reads all channels of the current selection.
</td></tr><tr><td colspan=2 height=16></td></tr>

<!-- make-sync-frame-reader -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="makesyncframereader">make-sync-frame-reader</a> <code>start snd dir edpos</code></td></tr>
<tr><td></td><td>
make-sync-frame-reader returns a frame reader that reads all channels sync'd to the sound 'snd'.
</td></tr><tr><td colspan=2 height=16></td></tr>

<!-- make-track-frame-reader -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="maketrackframereader">make-track-frame-reader</a> <code>start</code></td></tr>
<tr><td></td><td>
make-track-frame-reader returns a frame reader that reads all channels of the track 'trk'.
</td></tr><tr><td colspan=2 height=16></td></tr>

<!-- next-frame -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="nextframe">next-frame</a> <code>obj</code></td></tr>
<tr><td></td><td>
next-frame returns the next frame (reading forward) read by the frame-reader 'obj'.
</td></tr><tr><td colspan=2 height=16></td></tr>

<!-- previous-frame -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="previousframe">previous-frame</a> <code>obj</code></td></tr>
<tr><td></td><td>
previous-frame returns the previous frame in the stream read by the frame-reader 'obj'.
</td></tr><tr><td colspan=2 height=16></td></tr>

<!-- read-frame -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="readframe">read-frame</a> <code>obj</code></td></tr>
<tr><td></td><td>
read-frame returns the next frame (reading in the direction set by <a class=quiet href="#makeframereader">make-frame-reader</a>) 
from the frame-reader 'obj'.
</td></tr><tr><td colspan=2 height=16></td></tr>

<!-- read-track-frame -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="readtrackframe">read-track-frame</a> <code>obj</code></td></tr>
<tr><td></td><td>
read-track-frame returns the next frame read by the track-frame-reader 'obj'.
</td></tr><tr><td colspan=2 height=16></td></tr>

</table>

<br>



<!-- ---------------------------------------- FILE: freeverb ---------------------------------------- -->

<A NAME="freeverbdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>freeverb</h2></td></tr></table>

<p>freeverb is Jezar Wakefield's reverberator, translated by Michael Scholz from CLM's freeverb.ins (written by Fernando Lopez-Lezcano), and documented
in freeverb.html in the CLM tarball.
</p>
<pre>
    <a class=def name="freeverb">freeverb</a>
       :key (room-decay 0.5)
            (damping 0.5)
            (global 0.3)
            (predelay 0.03)
            (output-gain 1.0)
            (output-mixer #f)
            (scale-room-decay 0.28)
            (offset-room-decay 0.7)
            (combtuning '(1116 1188 1277 1356 1422 1491 1557 1617))
            (allpasstuning '(556 441 341 225))
            (scale-damping 0.4)
            (stereo-spread 23)
            (verbose #f)
</pre>

<p>Here is a paraphrase of some of Fernando's documentation.
'room-decay'
determines the decay time of the reverberation.
'damping' set the high frequency damping; this parameter can be a number, or an array or a list (with same number of elements as output channels). It is possible to control the damping for each output channel.
'global'
controls how the outputs of all reverbs (one per channel) are mixed into the output stream. Specifying "0" will connect each reverberator directly to each output channel, "1" will mix all reverberated channels equally into all output channels. Intermediate values will allow for an arbitrary balance between local and global reverberation. The overall gain of the mixing matrix is kept constant. 'output-mixer' overrides this parameter.
'predelay' 
sets the predelay that is applied to the input streams. An array or list lets you specify the individual predelays for all chanenels.
'output-gain'
is the overall gain multiplier for the output streams.
'output-mixer'
sets the output mixing matrix directly (rather than through 'global').
</p>
<pre>
    (with-sound (:reverb freeverb :reverb-data '(:output-gain 3.0)) 
      (fm-violin 0 .1 440 .1 :reverb-amount .1))
</pre>

<table bgcolor="aliceblue" border=0><tr>
<td>
<pre>see also: <a href="#jcrevdoc" onmouseover="return escape('an old reverberator')">jcrev</a> <a href="#nrev">nrev</a> <a href="extsnd.html#convolvewith">convolution</a>
</pre>
</td></tr></table>

<br>




<!-- ---------------------------------------- FILE: grani ---------------------------------------- -->

<A NAME="granidoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>grani</h2></td></tr></table>

<p>This is Fernando Lopez-Lezcano's CLM <A HREF="http://ccrma.stanford.edu/~nando/clm/grani/">grani</a> 
granular synthesis instrument translated to Scheme by Mike Scholz.
The Ruby version is in clm-ins.rb.  There is further documentation <A HREF="http://ccrma.stanford.edu/courses/220b/topics/granularsynthesis/">here</a>.
Rather than repeat everything, I'll merely paraphrase the main points, for completeness' sake
or something.
</p>

<pre>
    <a class=def name="grani">grani</a> start-time duration amplitude file :key
      (input-channel 0)                       ; input file channel from which samples are read
      (grains 0)                              ; if not 0, total number of grains to be generated
      (amp-envelope '(0 0 0.3 1 0.7 1 1 0))   ; overall amplitude envelope for note
      (grain-envelope '(0 0 0.3 1 0.7 1 1 0)) ; env for each individual grain
      (grain-envelope-end #f)                 ; if not #f, a 2nd grain env
      (grain-envelope-transition '(0 0 1 1))  ; interp 0: use grain-envelope, 1: use grain-envelope-end
      (grain-envelope-array-size 512)         ; make-table-lookup table size
      (grain-duration 0.1)                    ; number or envelope setting grain duration (in seconds)
      (grain-duration-spread 0.0)             ; random spread around 'grain-duration'
      (grain-duration-limit 0.002)            ; minimum grain duration (in seconds)
      (srate 0.0)                             ; number or envelope setting sampling rate conversion
      (srate-spread 0.0)                      ; random spread of src around 'srate'
      (srate-linear #f)                       ; if #f, srate (envelope) is exponential
      (srate-base (expt 2 (/ 12)))            ; srate env base if exponential
      (srate-error 0.01)                      ; error bound for exponential conversion
      (grain-start '(0 0 1 1))                ; env that sets input file read point of current grain
      (grain-start-spread 0.0)                ; random spread around 'grain-start'
      (grain-start-in-seconds #f)             ; if #f, treat 'grain-start' as a percentage
      (grain-density 10.0)                    ; env on number of grains / second in output
      (grain-density-spread 0.0)              ; random spread around 'grain-density'
      (reverb-amount 0.01)
      (reverse #f)                            ; if #t, input is read backwards
      (where-to 0)                            ; locsig stuff -- see the full documentation
      (where-bins '())
      (grain-distance 1.0)                    ; distance of sound source (<a href="clm.html#locsig">locsig</a>)
      (grain-distance-spread 0.0)             ; random spread around 'grain-distance'
      (grain-degree 45.0)
      (grain-degree-spread 0.0)
      (verbose #t)

    (with-sound (:channels 2 :reverb jc-reverb :reverb-channels 1)
      (grani 0 1 .5 "oboe.snd" :grain-envelope '(0 0 0.2 0.2 0.5 1 0.8 0.2 1 0)))
</pre>

<table bgcolor="aliceblue" border=0><tr><td>
<pre>see also: <a href="clm.html#granulate" onmouseover="return escape('CLM granular synthesis generator')">granulate</a> <a href="#expsrc" onmouseover="return escape('granular synthesis to stretch sound')">expsrc</a> <a href="extsnd.html#customcontrols" onmouseover="return escape('expand in the control panel')">expand</a> 
</pre></td>
</tr></table>

<br>
<br>


<!-- ---------------------------------------- FILE: green ---------------------------------------- -->

<A NAME="greendoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>green</h2></td></tr></table>

<p>This file provides two generators that produce bounded brownian noise: green-noise and green-noise-interp,
and one that produces straight brownian noise: <a name="browniannoise">brownian-noise</a>.
Unlike CLM's <a href="clm.html#rand">rand</a> or <a href="clm.html#rand-interp">rand-interp</a> which
produce white noise centered around 0.0, "green" (brownian) noise wanders around, bouncing off its bounds
every now and then.
</p>
<pre>
    make-green-noise :key (frequency 440.0) (amplitude 1.0) (high 1.0) (low -1.0)
    green-noise r sweep

    make-green-noise-interp :key (frequency 440.0) (amplitude 1.0) (high 1.0) (low -1.0)
    green-noise-interp r sweep

    brownian-noise r
</pre>
<p>'amplitude' controls how large individual steps can be; 'high' and 'low' set
the overall bounds; 'frequency' controls how often a new random number is chosen.
Here's an instrument that fuzzes up its amplitude envelope a bit using green noise:
</p>

<table border=0 cellpadding=5 hspace=20 vspace=10><tr><td bgcolor="#fafafa"><pre>
(<a class=quiet href="clm.html#definstrument">definstrument</a> (green3 start dur freq amp amp-env noise-freq noise-width noise-max-step)
  (let* ((grn (<em class=red>make-green-noise-interp</em> :frequency noise-freq 
                                       :amplitude noise-max-step 
                                       :high (* 0.5 noise-width) :low (* -0.5 noise-width)))
	 (osc (<a class=quiet href="clm.html#make-oscil">make-oscil</a> freq))
	 (e (<a class=quiet href="clm.html#make-env">make-env</a> amp-env :scaler amp :duration dur))
	 (beg (inexact->exact (floor (* start (<a class=quiet href="clm.html#mussrate">mus-srate</a>)))))
	 (end (+ beg (inexact->exact (floor (* dur (<a class=quiet href="clm.html#mussrate">mus-srate</a>)))))))
    (run
     (lambda ()
       (do ((i beg (1+ i)))
	   ((= i end))
	 (<a class=quiet href="clm.html#outa">outa</a> i (* (<a class=quiet href="clm.html#env">env</a> e) 
		    (+ 1.0 (<em class=red>green-noise-interp</em> grn 0.0))
		    (<a class=quiet href="clm.html#oscil">oscil</a> osc)) 
	       *output*))))))

(with-sound () (green3 0 2.0 440 .5 '(0 0 1 1 2 1 3 0) 100 .2 .02))
</pre></td></tr></table>

<br>
<br>


<!-- ---------------------------------------- FILE: heart ---------------------------------------- -->

<A NAME="heartdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>heart</h2></td></tr></table>

<table vspace=10 hspace=10><tr><td>
Snd can be used with non-sound data, and <a href="#wsdoc">with-sound</a> makes it easy to
write such data to a sound file.  An example is heart.scm.  In this code, we search a file for blood pressure
readings (they are scattered around with a bunch of other stuff), then write those numbers to a stereo
sound file (the sphygmometer readings are between 70 and 150), then open that file in Snd with all the sound-related
clipping features turned off.  We also tell Snd to skip the data file in its start-up load process (since it
is an uninterpretable text file) by incrementing script-arg.
</td><td>
<img src="usync.png" alt="heart picture">
</td></tr></table>
<br>
<br>


<!-- ---------------------------------------- FILE: hooks ---------------------------------------- -->

<A NAME="hooksdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>hooks</h2></td></tr></table>

<p>hooks.scm and hooks.rb have various <a href="extsnd.html#sndhooks">hook</a>-related functions.
</p>

<table border=0 cellspacing=0 hspace=20>

<!-- describe-hook -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="describehook">describe-hook</a> <code>(hook)</code>
</td></tr><tr><td width=60></td><td>
describe-hook tries to decipher the functions on the hook list; this is almost identical to Guile's hook-&gt;list.
<pre>
    :<em class=typing>(hook-&gt;list exit-hook)</em>
    <em class=listener>(#&lt;procedure #f (() (for-each save-peak-env-info (sounds)))&gt;)</em>
    :<em class=typing>(describe-hook exit-hook)</em>
    <em class=listener>#&lt;procedure #f (() (for-each save-peak-env-info (sounds)))&gt;
    #&lt;unspecified&gt;</em>
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- hook-member -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="hookmember">hook-member</a> <code>(func hook)</code>
</td></tr><tr><td></td><td>
hook-member returns #t if 'func' is already on the hook list.
It is simply <code>(member value (hook-&gt;list hook))</code>
<pre>
    :<em class=typing>(hook-member save-peak-env-info <a class=quiet href="extsnd.html#closehook">close-hook</a>)</em>
    <em class=listener>(#&lt;procedure save-peak-env-info ((snd) ...))&gt;</em>
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- remove-local-hook! -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>remove-local-hook!</em> <code>(hook func)</code>
</td></tr><tr><td></td><td>
remove-local-hook! tries to
remove a locally-defined function from a hook.
There are examples in examp.scm and marks.scm.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- reset-all-hooks -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="resetallhooks">reset-all-hooks</a> <code>()</code>
</td></tr><tr><td></td><td>
reset-all-hooks resets all of Snd's built-in hooks.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- snd-hooks -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="sndscmhooks">snd-hooks</a> <code>()</code>
</td></tr><tr><td></td><td>
snd-hooks returns a list of all Snd built-in non-channel hooks.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- with-local-hook -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="withlocalhook">with-local-hook</a> <code>(hook local-hook-procs thunk)</code>
</td></tr><tr><td></td><td>
with-local-hook is a kind of "let" for hooks; 
it evaluates 'thunk' with 'hook' set to 'local-hook-procs' (a list which can be nil), then restores 'hook' to its previous state upon exit.
The result returned by 'thunk' is returned by with-local-hook.
In the following example, <a href="extsnd.html#closehook">close-hook</a> has several functions, mainly related to <a href="#peakenvdoc">peak-env</a> files;
we want to close all currently open sounds without invoking the peak-env stuff:
<pre>
    :<em class=typing>(hook-&gt;list close-hook)</em>
    <em class=listener>(#&lt;procedure #f ((snd) ...)&gt; ...)</em> ; <a class=quiet href="extsnd.html#closehook">close-hook</a> has functions, exhaustive print out deleted
    :<em class=typing>(with-local-hook
       close-hook 
       (list (lambda (snd)</em>            ; close hook's local function just prints a message
               <em class=typing>(snd-print (format #f "~%;closing ~S" (short-file-name snd))))) 
       (lambda ()</em>                     ; this is evaluated with the local close-hook
         <em class=typing>(for-each (lambda (snd) (close-sound snd)) (sounds))))</em>
    <em class=listener>;closing "oboe.snd"
    #&lt;unspecified&gt;</em>
    :<em class=typing>(hook-&gt;list close-hook)</em>  ; upon return from with-local-hook, old close-hook list is restored
    <em class=listener>(#&lt;procedure save-peak-env-info ((snd) ...)&gt; ...)</em>
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>

</table>

<br><br>



<!-- ---------------------------------------- FILE: index ---------------------------------------- -->

<A NAME="indexdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>index</h2></td></tr></table>
<pre>
  <A class=def NAME="html">html</A> obj
  <em class=emdef>?</em> obj
</pre>
<p>index.scm provides a connection between mozilla or netscape
and the Snd documentation.  The index itself is
built by index.cl, then accessed through the functions html and ?.
<code>(html arg)</code>, where 'arg' can be a string, a symbol, or a procedure sends mozilla to the corresponding url
in the Snd documents.
<code>(? obj)</code> prints out any help it can find for 'obj', and tries to find 'obj' in the documentation.
The function that actually passes the url to the reader is <a href="extsnd.html#sendmozilla">send-mozilla</a>.
</p>
<pre>
    :<em class=typing>(html "open-sound")</em>  ; mozilla starts (if necessary), and goes to the open-sound documentation
    <em class=listener>#t</em>
    :<em class=typing>(? "open-sound")</em>
    <em class=listener>(open-sound filename): open filename (as if opened from File:Open menu option), 
    and return the new sound's index</em>

</pre>

<table bgcolor="aliceblue" border=0><tr><td>
<pre>see also: <a href="extsnd.html#htmlprogram" onmouseover="return escape('name of html reader')">html-program</a> <a href="extsnd.html#sendmozilla" onmouseover="return escape('direct mozilla to a url')">send-mozilla</a> <a href="extsnd.html#sndhelp" onmouseover="return escape('main Snd help function')">snd-help</a> <a href="extsnd.html#sndurls" onmouseover="return escape('table of Snd documentation urls')">snd-urls</a>
</pre></td>
</tr></table>

<br>
<br>


<!-- ---------------------------------------- FILE: inf-snd.el, DotEmacs ---------------------------------------- -->

<A NAME="dotemacs"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>inf-snd.el, DotEmacs</h2></td></tr></table>

<p>These two files provide support for Snd as an Emacs subjob.  inf-snd.el is by Michael Scholz,
and DotEmacs is by Fernando Lopez-Lezcano. Both can be loaded in your ~/.emacs file (or ~/.xemacs/init.el if you're
using xemacs).

DotEmacs sets up "dialects" for various versions of Common Lisp and for Snd, then
binds C-x C-l to run ACL.  This is intended for CCRMA'S 220 class, but it might
be of interest to others.  Much fancier is inf-snd.el.  What follows is taken almost
verbatim from Mike Scholz's comments in that file:
</p>

<p>
inf-snd.el defines a snd-in-a-buffer package for Emacs.
It includes a Snd-Ruby mode (snd-ruby-mode), a Snd-Scheme mode
(snd-scheme-mode), and a Snd-Forth mode (snd-forth-mode) for editing source files. 
The commands <b>inf-snd-help</b> and <b>snd-help</b>
access the description which Snd provides for many functions.
Using the prefix key C-u you get the HTML version of Snd's help.
With tab-completion in the minibuffer you can scan all functions at
a glance. 
A menu "Snd/Ruby" is placed in the Emacs menu bar.  Entries in this
menu are disabled if no inferior Snd process exists.
These variables may need to be customized to fit your system:
</p>
<pre>
inf-snd-ruby-program-name   "snd-ruby"    Snd-Ruby program name
inf-snd-scheme-program-name "snd-gauche"  Snd-Scheme program name using Gauche
inf-snd-scheme-program-name "snd-guile"   Snd-Scheme program name using Guile
inf-snd-forth-program-name  "snd-forth"   Snd-Forth program name
inf-snd-working-directory   "~/"          where Ruby or Scheme scripts reside
inf-snd-index-path          "~/"          path to snd-xref.c
inf-snd-prompt-char         ">"           listener prompt
snd-ruby-mode-hook          nil           to customize snd-ruby-mode
snd-scheme-mode-hook         nil           to customize snd-scheme-mode
snd-forth-mode-hook         nil           to customize inf-snd-forth-mode
</pre>
<p>
You can start inf-snd-ruby-mode either with the prefix-key
(C-u M-x run-snd-ruby) -- you will be asked for program name and
optional arguments -- or directly via (M-x run-snd-ruby).  In the latter
case, the variable inf-snd-ruby-program-name needs to be set correctly.
inf-snd-scheme-mode and inf-snd-forth-mode are handled in the same way.
Here's an example for your ~/.emacs file:
</p>

<pre>
(autoload 'run-snd-ruby     "inf-snd" "Start inferior Snd-Ruby process" t)
(autoload 'run-snd-scheme    "inf-snd" "Start inferior Snd-Scheme process" t)
(autoload 'run-snd-forth    "inf-snd" "Start inferior Snd-Forth process" t)
(autoload 'snd-ruby-mode    "inf-snd" "Load snd-ruby-mode." t)
(autoload 'snd-scheme-mode   "inf-snd" "Load snd-scheme-mode." t)
(autoload 'snd-forth-mode   "inf-snd" "Load snd-forth-mode." t)

(setq inf-snd-ruby-program-name "snd-ruby -notebook")
(setq inf-snd-scheme-program-name "snd-scheme -separate")
(setq inf-snd-forth-program-name "snd-forth")
(setq inf-snd-working-directory "~/Snd/")
(setq inf-snd-index-path "~/Snd/snd/")
</pre>

<p>
See inf-snd.el for more info and examples of specializing these modes.
You can change the mode while editing a Snd-Ruby, Snd-Scheme, or Snd-Forth source file with
M-x snd-ruby-mode, M-x snd-scheme-mode, or M-x snd-forth-mode.  To have Emacs determine
automatically which mode to set, you can use special
file-extensions.  I use file-extension ".rbs" for Snd-Ruby source
files, ".cms" for Snd-Scheme, and ".fth" for Snd-Forth.
</p>

<pre>
(set-default 'auto-mode-alist
	     (append '(("\\.rbs$" . snd-ruby-mode)
                    ("\\.cms$" . snd-scheme-mode))
		     auto-mode-alist))
</pre>

<p>
Or you can use the local mode variable in source files, e.g. by
"-*- snd-ruby -*-" or "-*- snd-scheme -*-" in first line.
</p>

<p>
Key bindings for inf-* and snd-*-modes
</p>
<pre>
\e\TAB        snd-completion    symbol completion at point
C-h m         describe-mode     describe current major mode
</pre>
<p>
Key bindings of inf-snd-ruby|scheme|forth-mode:
</p>
<pre>
C-c C-s   	 inf-snd-run-snd   (Snd-Ruby|Scheme|Forth from a dead Snd process buffer)
M-C-l		 inf-snd-load      load script in current working directory
C-c C-f   	 inf-snd-file      open view-files-dialog of Snd
M-C-p		 inf-snd-play      play current sound file
C-c C-t 	 inf-snd-stop      stop playing all sound files
C-c C-i   	 inf-snd-help      help on Snd-function (snd-help)
C-u C-c C-i	 inf-snd-help-html help on Snd-function (html)
C-c C-q   	 inf-snd-quit      send exit to Snd process
C-c C-k   	 inf-snd-kill      kill Snd process and buffer
</pre>
<p>
Key bindings of snd-ruby|scheme|forth-mode editing source
files:
</p>
<pre>
C-c C-s   	 snd-run-snd
M-C-x     	 snd-send-definition
C-x C-e   	 snd-send-last-sexp
C-c M-e   	 snd-send-definition
C-c C-e   	 snd-send-definition-and-go
C-c M-r   	 snd-send-region
C-c C-r   	 snd-send-region-and-go
C-c M-o   	 snd-send-buffer
C-c C-o   	 snd-send-buffer-and-go
C-c M-b   	 snd-send-block          (Ruby only)
C-c C-b   	 snd-send-block-and-go   (Ruby only)
C-c C-z   	 snd-switch-to-snd
C-c C-l   	 snd-load-file
C-u C-c C-l 	 snd-load-file-protected (Ruby only)
C-c C-f   	 snd-file    	   open view-files-dialog of Snd
C-c C-p   	 snd-play    	   play current sound file
C-c C-t   	 snd-stop    	   stop playing all sound files
C-c C-i   	 snd-help    	   help on Snd-function (snd-help)
C-u C-c C-i	 snd-help-html	   help on Snd-function (html)
C-c C-q   	 snd-quit    	   send exit to Snd process
C-c C-k   	 snd-kill    	   kill Snd process and buffer
</pre>

<p>If xemacs complains that comint-snapshot-last-prompt is not defined,
get the latest comint.el; I had to go to the xemacs CVS site since
Fedora Core 5's xemacs (21.4) had an obsolete copy.  Then scrounge
around until you find xemacs-packages/xemacs-base/comint.el.
Don't use the comint.el in the emacs package.  It's not a tragedy
if this variable isn't defined -- you just don't get a prompt in
the Snd Emacs window, but things still work.
If either emacs or
xemacs complains that it can't find gforth.el, you can find that
file in the gforth package or site (or perhaps you can comment out
the line (require 'forth-mode "gforth") in inf-snd.el).  Finally, if temporary-file-directory
is undefined, you can set it alongside the rest of the variables.
So, for example, I (Bill S) have the following in my ~/.xemacs/init.el:
</p>
<pre>
(setq load-path
      (append (list nil 
		    "/home/bil/cl"
                    "/home/bil/rpm"               ; comint.el (ignore emacs version)
		    "/home/bil/test/gforth-0.6.2" ; gforth.el
		    )
	      load-path))

(autoload 'run-snd-ruby     "inf-snd" "Start inferior Snd-Ruby process" t)
(autoload 'run-snd-scheme   "inf-snd" "Start inferior Snd-Scheme process" t)
(autoload 'run-snd-forth    "inf-snd" "Start inferior Snd-Forth process" t)
(autoload 'snd-ruby-mode    "inf-snd" "Load snd-ruby-mode." t)
(autoload 'snd-scheme-mode  "inf-snd" "Load snd-scheme-mode." t)
(autoload 'snd-forth-mode   "inf-snd" "Load snd-forth-mode." t)

(setq inf-snd-ruby-program-name "~/ruby-snd/snd") ; these are my local Snd's
(setq inf-snd-scheme-program-name "~/cl/snd")
(setq inf-snd-forth-program-name "~/forth-snd/snd")
(setq inf-snd-working-directory "~/cl/")
(setq inf-snd-index-path "~/cl/")
(setq inf-snd-working-directory   "~/cl/")
(setq inf-snd-index-path          "~/cl/")
(setq temporary-file-directory    "~/zap/")
</pre>

<br>



<!-- ---------------------------------------- FILE: jcrev ---------------------------------------- -->

<A NAME="jcrevdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>jcrev</h2></td></tr></table>
<p>

<!-- main-index |jcrevdoc:jc-reverb -->

jc-reverb is a reverberator developed by John Chowning a long time ago
(I can't actually remember when -- before 1976 probably), based 
on <a href="http://ccrma.stanford.edu/~jos/pasp/Schroeder_Reverberator_called_JCRev.html">ideas</a>
of Manfred Schroeder.
It "colors" the
sound much more than <a href="#clminsdoc">nrev</a>, and has noticeable echoes,
but I liked the effect a lot.  new-effects.scm has a version of jc-reverb
that runs as a normal snd editing function (via <a href="extsnd.html#mapchannel">map-channel</a>), whereas the
jcrev.scm version assumes it is being called within with-sound:
</p>
<pre>
    Scheme:
        (with-sound (:reverb jc-reverb) (fm-violin 0 .1 440 .1 :reverb-amount .1))

    Ruby:
        with_sound(:reverb, :jc_reverb) do fm_violin(0, 0.1, 440, 0.1) end

    Forth:
        0 1 440 0.2 ' fm-violin :reverb ' jc-reverb with-sound
</pre>
<p>jc-reverb has three parameters:
</p>
<pre>
    <a class=def name="jcreverb">jc-reverb</a> :optional low-pass (volume 1.0) amp-env
</pre>

<p>
if 'low-pass' if #t, a low pass filter is inserted before the output;
'volume' can be used to boost the output;
'amp-env' is an amplitude envelope that can be used to squelch the reverb ringing at the end of a piece.
</p>
<pre>
    (with-sound (:reverb jc-reverb :reverb-data '(#t 1.5 (0 0 1 1 2 1 3 0))) (fm-violin 0 .1 440 .1))
</pre>

<p>It is possible to use the CLM/with-sound reverbs (or any such instrument) as
an ordinary editing function:
</p>

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(if (not (defined? '*output*)) (load-from-path "ws.scm"))
(define* (clm-reverb-sound reverb-amount reverb :optional (reverb-data '()) snd)
  (let ((output (<a class=quiet href="extsnd.html#sndtempnam">snd-tempnam</a>))
	(revout (<a class=quiet href="extsnd.html#sndtempnam">snd-tempnam</a>))
	(len (+ (<a class=quiet href="extsnd.html#frames">frames</a> snd) (<a class=quiet href="extsnd.html#srate">srate</a> snd))))
    (<a class=quiet href="extsnd.html#scaleby">scale-by</a> (- 1.0 reverb-amount) snd)
    (<a class=quiet href="extsnd.html#savesoundas">save-sound-as</a> output snd)
    (<a class=quiet href="extsnd.html#undo">undo</a> 1 snd)
    (<a class=quiet href="extsnd.html#scaleby">scale-by</a> reverb-amount snd)
    (<a class=quiet href="extsnd.html#savesoundas">save-sound-as</a> revout snd)
    (<a class=quiet href="extsnd.html#undo">undo</a> 1 snd)
    (dynamic-wind
      (lambda ()
        (set! *output* (<a class=quiet href="clm.html#continue-sampletofile">continue-sample-&gt;file</a> output))
        (set! (<a class=quiet href="clm.html#mussrate">mus-srate</a>) (<a class=quiet href="extsnd.html#srate">srate</a> snd))
        (set! *reverb* (<a class=quiet href="clm.html#make-filetosample">make-file-&gt;sample</a> revout)))
      (lambda ()
        (apply reverb reverb-data))
      (lambda ()
        (<a class=quiet href="clm.html#mus-close">mus-close</a> *reverb*)
        (<a class=quiet href="clm.html#mus-close">mus-close</a> *output*)
        (set! *reverb* #f)
        (set! *output* #f)
        (delete-file revout)
        (set! (<a class=quiet href="extsnd.html#samples">samples</a> 0 len snd #f #f #f 0 #f #t) output)))))

(clm-reverb-sound .1 jc-reverb)
</pre></td></tr></table>

<p>Another approach to this problem would be to use <a href="extsnd.html#sndtosample">snd-&gt;sample</a> to
redirect the *reverb* input (without any change to the reverberator),
getting its data from the current sound (probably after scaling it
by the reverb amount). 
</p>

<!-- INDEX reverbexamples:Reverb -->
<A NAME="reverbexamples"></a>
<TABLE border=3 bordercolor="tan" hspace=40>
<tr><td width="50%">
<blockquote><small>
<br>
Reverbs in Snd<br>
freeverb: <a href="#freeverbdoc">freeverb.scm, freeverb.rb</a><br>
jc-reverb: <a href="#jcrevdoc">jcrev.scm</a><br>
jl-reverb: <a href="#clminsdoc">clm-ins.scm</a><br>
nrev: <a href="#clminsdoc">clm-ins.scm</a><br>
control panel reverb: <a href="snd.html#reverb">Reverb</a>, <a href="extsnd.html#reverbdecay">control variables</a><br>
convolution reverb: <a href="extsnd.html#convolvewith">conrev</a><br>
plate-reverb: ladspa.scm (a LADSPA effect)<br>
*reverb*: <a href="#wsdoc">with-sound</a><br>
<br>
</small></blockquote>
</td></tr></TABLE>
<br>

<br>


<!-- ---------------------------------------- FILE: ladspa.scm, ladspa-help.scm, gui.scm ---------------------------------------- -->

<A NAME="ladspadoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>ladspa.scm, ladspa-help.scm, gui.scm</h2></td></tr></table>

<p>ladspa.scm, written by Kjetil Matheussen, takes your LADSPA library and builds a set of dialogs
to control and preview each effect.  Some of the related help strings are in ladspa-help.scm, and
the GUI extensions are in gui.scm.  This file currently works best if you're running the Gtk
version of Snd with the xg module already loaded (configure with --with-gtk and --with-static-xg).
If you don't have librdf, you need to comment out the line (provide 'snd-lrdf).  Before loading
ladspa.scm, be sure you've set either <a href="extsnd.html#ladspadir">ladspa-dir</a> or the
environment variable LADSPA_PATH.  Once loaded, you get a new top-level menu "Ladspa" with
an alphabetical set of submenus.  Some of the functions assume you have a sound open.
</p>
<p>ladspa.scm loads gui.scm which changes a lot of things in Snd's user interface.
</p>

<br>



<!-- ---------------------------------------- FILE: maraca ---------------------------------------- -->

<A NAME="maracadoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>maraca</h2></td></tr></table>

<!-- main-index |maracadoc:maracas -->

<p>The maracas are physical models developed by Perry Cook (CMJ, vol 21 no 3 Fall 97, p 44).
</p>
<pre>
    <em class=emdef>maraca</em> beg dur :optional 
           (amp .1) 
           (sound-decay 0.95) 
           (system-decay 0.999) 
           (probability .0625)
           (shell-freq 3200.0)
           (shell-reso 0.96)

    maraca: (with-sound () (maraca 0 5 .5))
    cabasa: (with-sound () (maraca 0 5 .5 0.95 0.997 0.5 3000.0 0.7))

    <em class=emdef>big-maraca</em> beg dur :optional 
               (amp .1) 
               (sound-decay 0.95) 
               (system-decay 0.999) 
               (probability .0625)
               (shell-freqs '(3200.0))
               (shell-resos '(0.96))
               (randiff .01)
               (with-filters #t)

    tambourine: 
        (with-sound () 
          (big-maraca 0 1 .25 0.95 0.9985 .03125 '(2300 5600 8100) '(0.96 0.995 0.995) .01))

    sleighbells: 
        (with-sound () 
          (big-maraca 0 2 .15 0.97 0.9994 0.03125 '(2500 5300 6500 8300 9800) 
            '(0.999 0.999 0.999 0.999 0.999)))

    sekere: 
        (with-sound ()
          (big-maraca 0 2 .5 0.96 0.999 .0625 '(5500) '(0.6)))

    windchimes: 
        (with-sound () 
          (big-maraca 0 4 .5 0.99995 0.95 .001 '(2200 2800 3400) '(0.995 0.995 0.995) .01 #f))
</pre>
<p>
big-maraca is like maraca, but takes a list of resonances and includes low-pass filter (or no filter).
</p>

<table bgcolor="aliceblue" border=0><tr><td>
<pre>see also: <a href="#noisedoc" onmouseover="return escape('FM noise instrument')">noise</a> <a href="clm.html#randomnumbers" onmouseover="return escape('random number generators')">rand</a>
</pre></td>
</tr></table>

<br>


<!-- ---------------------------------------- FILE: marks ---------------------------------------- -->

<A NAME="marksdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>marks</h2></td></tr></table>

<p>marks.scm/rb is a collection of mark-related functions.
</p>

<table border=0 cellspacing=0 hspace=20>

<!-- define-selection-via-marks -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="defineselectionviamarks">define-selection-via-marks</a> <code>m1 m2</code>
</td></tr><tr><td width=60></td><td>
define-selection-via-marks selects the portion between the given marks, then returns the selection length.
The marks defining the selection bounds must be in the same channel.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- describe-mark -->
<tr><td colspan=2 bgcolor="#f6f8ff">
  <a class=def name="describemark">describe-mark</a> <code>id</code>
</td></tr><tr><td></td><td>
describe-mark returns a description of the movements of mark 'id' over the channel's edit history:
<pre>
    :<em class=typing>(describe-mark 0)</em>
    <em class=listener>((mark 0 sound 0 "oboe.snd" channel 0) 654 478)</em>
</pre>
Here I placed a mark in oboe.snd at sample 654, then deleted a few samples
before it, causing it to move to sample 478.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- eval-bewteen-marks -->
<tr><td colspan=2 bgcolor="#f6f8ff">
  <a class=def name="evalbetweenmarks">eval-between-marks</a> <code>func</code>
</td></tr><tr><td></td><td>
eval-between-marks evaluates 'func'
between the leftmost marks in the currently selected channel.
'func' should take one argument, a sample, and return the new sample value.
<pre>
    (eval-between-marks (lambda (y) (* y 2)))
</pre>
doubles the samples between the two chosen marks, then returns a vct with the new data (I can't
remember why this is returned -- it doesn't seem necessary).
<pre>
    (<a class=quiet href="extsnd.html#bindkey">bind-key</a> #\m 0 
      (lambda () "eval between marks"
        (<a class=quiet href="extsnd.html#promptinminibuffer">prompt-in-minibuffer</a> "mark eval:" eval-between-marks)))
</pre>
prompts for a function in the minibuffer, then evaluates it between the marks.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- fit-selection-between-marks -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="fitselectionbetweenmarks">fit-selection-between-marks</A> <code>m1 m2</code>
</td></tr><tr><td></td><td>
fit-selection-between-marks tries to squeeze the current selection between two marks,
using the granulate generator to fix up the selection duration (it currently does a less than perfect job).
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- mark-click-info -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="markclickinfo">mark-click-info</a> <code>id</code>
</td></tr><tr><td></td><td>
mark-click-info is a <a href="extsnd.html#markclickhook">mark-click-hook</a> function that describes a mark and its properties.  It
is used by <a href="#withmarkedsound">with-marked-sound</a> in ws.scm.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- mark-explode -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="markexplode">mark-explode</a> <code>:optional (htype mus-next) (dformat mus-bfloat)</code>
</td></tr><tr><td></td><td>
mark-explode splits a sound into a bunch of separate files based on mark placements.  Each mark becomes the
first sample of a separate sound.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- mark-name-&gt;id -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="marknametoid">mark-name-&gt;id</a> <code>name</code>
</td></tr><tr><td></td><td>
mark-name-&gt;id is like <a href="extsnd.html#findmark">find-mark</a>, but searches all currently accessible channels.
If a such a mark doesn't exist, it returns <code>'no-such-mark</code>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- mark-property -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="markproperty">mark-property</a> <code>key id</code>
</td></tr><tr><td></td><td>
mark-property associates a property list with a mark.
<pre>
    :<em class=typing>(set! (mark-property :weight 3) 2.5)</em>   ; 3 is the mark id
    <em class=listener>2.5</em>
    :<em class=typing>(mark-property :weight 3)</em>
    <em class=listener>2.5</em>
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- move-syncd-marks -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="movesyncdmarks">move-syncd-marks</a> <code>sync samples-to-move</code>
</td></tr><tr><td></td><td>
move-syncd-marks moves any marks sharing the <a href="extsnd.html#marksync">mark-sync</a> value 'sync' by
'samples-to-move' samples.  
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- pad-marks -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="padmarks">pad-marks</a> <code>ids secs</code>
</td></tr><tr><td></td><td>
pad-marks inserts 'secs' seconds of silence before each in a list of marks ('ids').
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- play-between-marks -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="playbetweenmarks">play-between-marks</a> <code>:optional snd m1 m2</code>
</td></tr><tr><td></td><td>
play-between-marks
plays the portion in the sound 'snd' between the given marks.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- play-syncd-marks -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="playsyncdmarks">play-syncd-marks</a> <code>sync</code>
</td></tr><tr><td></td><td>
play-syncd-marks starts
playing from all the marks sharing its 'sync' argument (see <a href="extsnd.html#marksync">mark-sync</a>).
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- report-mark-names -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="reportmarknames">report-mark-names</A>
</td></tr><tr><td></td><td>
report-mark-names causes a named mark to display its name in the minibuffer when 
its sample happens to be played.
</td></tr><tr><td colspan=2 height=16></td></tr>
  

<!-- save-mark-properties -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="savemarkproperties">save-mark-properties</a>
</td></tr><tr><td></td><td>
save-mark-properties sets up an <a href="extsnd.html#aftersavestatehook">after-save-state-hook</a> function to save any mark-properties.
</td></tr><tr><td colspan=2 height=16></td></tr>
  

<!-- snap-mark-to-beat -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="snapmarktobeat">snap-mark-to-beat</a>
</td></tr><tr><td></td><td>
snap-mark-to-beat forces a dragged mark to end up on a beat.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- snap-marks -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="snapmarks">snap-marks</a>
</td></tr><tr><td></td><td>
snap-marks places marks at the start and end of the current selection in all its portions (i.e. in every channel that
has selected data).
It returns a list of all the marks it has added.
<pre>
    :<em class=typing>(selection-position)</em>
    <em class=listener>360</em>
    :<em class=typing>(selection-frames)</em>
    <em class=listener>259</em>
    :<em class=typing>(snap-marks)</em>
    <em class=listener>(8 9)</em>
    :<em class=typing>(mark-sample 8)</em>
    <em class=listener>360</em>
    :<em class=typing>(mark-sample 9)</em>
    <em class=listener>619</em>
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- syncup -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="syncup">syncup</a> <code>ids</code>
</td></tr><tr><td></td><td>
syncup synchronizes a list of marks (positions them all at the same sample number) by inserting silences as needed.
</td></tr><tr><td colspan=2 height=16></td></tr>

</table>

<p>marks.scm also has code that tries to make it simpler to sync marks together --
you simply click the marks that should share a <a href="extsnd.html#marksync">mark-sync</a> field,
rather than laboriously setting each one in the listener;
see <b>start-sync</b> and <b>stop-sync</b>.
There is also some code (look for "eval-header" toward the end of the file) that saves mark info in a
sound file header, and reads it when the file is subsequently reopened.
</p>


<table bgcolor="aliceblue" border=0><tr><td>
<pre>see also: <a href="#addmarkpane" onmouseover="return escape('channel pane describing marks')">add-mark-pane</a> <a href="extsnd.html#sndmarks" onmouseover="return escape('general discussion of marks in Snd')">Marks</a> <a href="#markloops" onmouseover="return escape('place marks at loop points')">mark-loops</a> <a href="#menusdoc" onmouseover="return escape('add a top-level Marks menu')">marks-menu</a>
</pre></td>
</tr></table>

<br>
<br>


<!-- ---------------------------------------- FILE: maxf ---------------------------------------- -->

<A NAME="maxfdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>maxf</h2></td></tr></table>

<p>These files are translations (thanks to Michael Scholz!) of CLM's maxf.ins
(thanks to Juan Reyes!). They implement a variant of the CLM <a href="clm.html#formant">formant</a> generator developed
by Max Mathews and Julius Smith (see their online <a href="http://ccrma.stanford.edu/~jos/smac03maxjos/">paper</a>).
For a version of the filter closer to the paper, see <a href="#mfilter">mfilter</a> in dsp.scm.
maxf.scm and maxf.rb provide a kind of demo instrument showing various ways to
use the filter (banks tuned to different sets of frequencies, etc).
</p>
<pre>
 (with-sound () (maxfilter "dog.snd" 0))
 (with-sound (:srate 44100) (maxfilter "dog.snd" 0 :numf 12))
 (with-sound (:srate 44100) (maxfilter "dog.snd" 0 :numf 13 :att 0.75))
 (with-sound (:srate 44100) (maxfilter "dog.snd" 0 :numf 2 :att 0.25 :freqfactor 0.5))
</pre>
<pre>
<em class=emdef>maxfilter</em> file beg :key (att 1.0) (numf 1) (freqfactor 1.0) (amplitude 1.0)
		    (amp-env '(0 1 100 1)) (degree (random 90.0)) (distance 1.0) (reverb-amount 0.2)
</pre>

<br><br>


<!-- ---------------------------------------- FILE: menus ---------------------------------------- -->

<A NAME="menusdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>menus</h2></td></tr></table>

<!-- main-index |menusdoc:menus, optional -->

<p>The files described in this section either add new top-level menus to Snd, or
modify existing ones.  Most were written by Dave Phillips; see his tutorial for
pictures and a more complete discussion.
</p>

<table border=0 cellspacing=0 hspace=20 vspace=10>

<!-- edit-menu -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>edit-menu.scm</em>
</td></tr><tr><td width=60></td><td>
edit-menu.scm adds some useful options to the Edit menu:
<pre>
  Selection-&gt;new      ; save selection in a new file, open that file
  Cut selection-&gt;new  ; save selection in a new file, delete selection, open the file
  Append selection    ; append selection to end of selected sound
  Make stereofile     ; make a new 2-chan file, copy currently selected sound to it
  Trim front          ; find first mark in each sync'd channel and remove all samples before it
  Trim back           ; find last mark in each sync'd channel and remove all samples after it
  Crop                ; find first and last mark in each sync'd channel and remove all samples outside them
</pre>
<!-- I(trim sound):M(Edit: Trim)(menusdoc) -->
<!-- I(trim sound):A(menusdoc) -->
</td></tr><tr><td colspan=2 height=16></td></tr>



<!-- fft-menu.scm -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>mix-menu.scm</em>
</td></tr><tr><td></td><td>
fft-menu.scm adds an "FFT Edits" top-level menu.  It has entries for:
<pre>
  FFT notch filter   ; use FFT to notch out a portion of the spectrum
  FFT squelch        ; use FFT to squelch low-level noise
  Squelch vowels     ; use FFT to squelch vowel-like portions of speech
</pre>

</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- kmenu.scm -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>kmenu.scm</em>
</td></tr><tr><td></td><td>
kmenu.scm adds a bunch of mnemonics to the Gtk main menus.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- marks-menu.scm -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>marks-menu.scm</em>
</td></tr><tr><td></td><td>
marks-menu.scm adds a "Marks" top-level menu with entries:
<pre>
  Play between marks         ; play samples between marks
  Loop play between marks    ; continuous play looping between marks
  Trim before mark           ; remove samples before mark
  Trim behind mark           ; remove samples after mark
  Crop around marks          ; remove samples outside marks
  Fit selection to marks     ; squeeze selection to fit between marks
  Define selection by marks  ; define selection based on marks
  Mark sync                  ; if on, click mark to sync with other marks
  Mark sample loop points    ; place marks at header loop points, if any
  Show loop editor           ; edit loop points; this dialog is not really functional yet
  Delete all marks           ; delete all marks
  Explode marks to files     ; writes a separate file for each set of marks
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- mix-menu.scm -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>mix-menu.scm</em>
</td></tr><tr><td></td><td>
mix-menu.scm adds a top-level "Mix/Track" menu with entries for:
<pre>
  Delete mix            ; delete mix (set its amp to 0.0)
  Snap mix to beat      ; if on, make mixes start on a beat
  Assign all tracks     ; set track numbers
  Delete track          ; delete track (set its amp to 0.0)
  Play track
  Reverse track         ; reverse order of constituent mixes in track
  Set track amplitude
  Set track speed       ; track sampling rate conversion (2.0 = up octave)
  Set track tempo       ; change tempo at which constituent mixes occur
  Transpose track       ; transpose each mix
  Save track            ; save track to file "track-1.snd" (number increments)
  Colorize tracks       ; load track-colors.scm to get tracks in many colors
  Delete all mixes and tracks
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- new-effects.scm -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>new-effects.scm, effects-utils.scm, gtk-effects.scm, gtk-effects-utils.scm, effects.rb, effects.fs</em>
</td></tr><tr><td></td><td>

new-effects.scm (effects.rb, effects.fs) implements an Effects menu.  
Use gtk-effects.scm with Gtk.  There are a ton of choices, most of them
presented in separate dialogs.  The gain dialog is illustrated below.
Some of the outer menu items are:

<table border=0 cellpadding=10><tr><td>
<pre>
  Amplitude effects (gain, normalize)
  Delay effects (various echos)
  Filter effects (various filters)
  Frequency effects (src, expsrc)
  Modulation effects (AM)
  Reverbs (nrev, jcrev, convolution)
  Various (flange, locsig, etc)
  Octave down
  Remove clicks
  Remove DC
  Compand
  Reverse
</pre>
</td><td>
<img src="gain.png" alt="gain effect dialog">
</td></tr></table>

<!-- I(reverse samples):M(Effects: Reverse)(menusdoc) -->
<!-- I(reverberate file):M(Effects: Reverberate)(menusdoc) -->
<!-- I(normalize sound):M(Effects: Normalize)(menusdoc) -->
<!-- I(normalize sound):A(menusdoc) -->
<!-- I(normalize sound):L(scale-to)(scaleto) -->
<!-- I(insert zeros):M(Effects: Add Silence)(menusdoc) -->
<!-- I(change tempo):M(Effects: Expsrc)(menusdoc) -->

Most of these are either simple calls on Snd functions ("invert" is <code>(<a class=quiet href="extsnd.html#scaleby">scale-by</a> -1)</code>),
or use functions in the other scm files.  The actual operations follow the <a class=quiet href="extsnd.html#sync">sync</a> chain of the
currently active channel.  
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- panic.scm -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>panic.scm</em>
</td></tr><tr><td></td><td>
panic.scm adds a "Panic Control" top-level menu with two
entries: 
<pre>
  Stop play!   ; stop dac output (<a class=quiet href="extsnd.html#stopplaying">stop-playing</a>)
  Stop all!    ; interrupt any on-going computation (<a class=quiet href="extsnd.html#cgp">C-g</a>)
</pre>
These are equivalent to C-g.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- special-menu.scm -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>special-menu.scm</em>
</td></tr><tr><td></td><td>
special-menu.scm adds a "Special" menu with entries:
<pre>
  Append file
  MIDI to WAV (using Timidity)
  Record input channel 
  Envelope new file (see <a href="#enveddoc">start-enveloping</a>)
  Play panned 
  Save as MP3 (using bladeenc)
  Save as Ogg (using oggenc)
  Explode SF2 (using the code <a href="#explodesf2">explode-sf2</a> in examp.scm) 
</pre>
</td></tr>

</table>

<p>Associated with these menus is a group of files that change Snd's overall appearance, add a box of
handy icons, and so on: misc.scm, track-colors.scm, toolbar.scm, and new-backgrounds.scm.
<b>track-colors.scm</b> defines the color choices for the tracks, based on rgb.scm.
<b>new-backgrounds.scm</b> defines some background pictures that can be applied to all the
Snd widgets: wood, granite, rough, blueish, and smoke.  I think "rough" is the
default used by misc.scm.
<b>toolbar.scm</b> builds the menu bar full of icons providing convenient access
to things like Zoom, and Quit.
</p>

<img src="newbuttons.png" alt="button bar" hspace=20>

<p>
<b>misc.scm</b> loads these menus and interface improvements, adds several sound file extensions,
makes sure all the widget backgrounds
reflect the current background choice (metal, granite, wood, etc), changes the popup menu colors,
adds some hook functions for mpeg files etc,
and
includes a number of options such as show-disk-space.
It then adds these menu items:
</p>
<pre>
  File:Delete                 ; delete the selected file
  File:Rename                 ; rename the selected file
  Edit:Append selection       ; append selection to end of current sound
  Edit:Replace with selection ; put copy of selection at cursor
</pre>

<p>I think Dave expects you to customize this to suit yourself, perhaps even moving the stuff
you want to your initialization file.
</p>


<table bgcolor="aliceblue" border=0><tr><td>
<pre>see also: <a href="extsnd.html#addtomainmenu" onmouseover="return escape('add-to-main-menu and add-to-menu documentation')">add-to-main-menu</a> <a href="#withreopenmenu">Reopen menu</a> <a href="#openbuffer">Buffers menu</a> <a href="#ladspadoc">Ladspa menu</a> <a href="#popupdoc">Popup menus</a>
</pre></td>
</tr></table>

<br>
<br>


<!-- ---------------------------------------- FILE: mix ---------------------------------------- -->

<A NAME="mixdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>mix</h2></td></tr></table>

<!-- main-index |mixdoc:cross-fade (amplitude) -->

<p>mix.scm provides various mix and track related utilities. 
</p>

<table width="60%" border=0><tr><td bgcolor="lightgreen" align="center" valign="middle"><h3>mixes</h3></td></tr></table>

<table border=0 cellspacing=0 hspace=20>

<!-- delete-all-mixes -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="deleteallmixes">delete-all-mixes</a>
</td></tr><tr><td width=60></td><td>
This removes all mixes (sets all mix amplitudes to 0.0).
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- find-mix -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="findmix">find-mix</a> <code>sample snd chn</code>
</td></tr><tr><td></td><td>
find-mix returns the identifier of the mix at sample 'sample' (or anywhere in the given channel if 
'sample' is not specified), or #f if no mix is found.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- mix-click-info -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="mixclickinfo">mix-click-info</a> <code>id</code>
</td></tr><tr><td></td><td>
mix-click-info is a <a href="extsnd.html#mixclickhook">mix-click-hook</a> function that posts a description of the
clicked mix in the help dialog.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- mix-click-sets-amp -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="mixclicksetsamp">mix-click-sets-amp</A>
</td></tr><tr><td></td><td>
mix-click-sets-amp adds a <a href="extsnd.html#mixclickhook">mix-click-hook</a> function so that 
if you click a mix, it is removed (its amplitudes are set to 0.0);
a subsequent click resets it to its previous value.
This is intended to make it easy to compare renditions with and without a given mix.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- mix-maxamp -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="mixmaxamp">mix-maxamp</a> <code>id</code>
</td></tr><tr><td></td><td>
mix-maxamp returns the maxamp in the given mix.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- mix-name->id -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="mixnametoid">mix-name-&gt;id</a> <code>name</code>
</td></tr><tr><td></td><td>
mix-name-&gt;id returns the if of the mix with the given name, or 'no-such-mix if none can be found.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- mix-property -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="mixproperty">mix-property</a> <code>key id</code>
</td></tr><tr><td></td><td>
mix-property associates a property list with each mix.
<pre>
    :<em class=typing>(set! (mix-property :info 0) "this is a mix")</em>
    <em class=listener>"this is a mix"</em>
    :<em class=typing>(mix-property :info 0)</em>
    <em class=listener>"this is a mix"</em>
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- mix-sound -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="mixsound">mix-sound</a> <code>file start</code>
</td></tr><tr><td></td><td>
mix-sound mixes 'file' (all chans) into the currently selected sound at 'start'.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- mix->vct -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="mixtovct">mix-&gt;vct</a> <code>id</code>
</td></tr><tr><td></td><td>
mix-&gt;vct returns in a vct the current samples
of mix 'id'.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- pan-mix -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="panmix">pan-mix</a> <code>file (frame 0) (env 1.0) snd (chn 0) auto-delete</code>
</td></tr><tr><td></td><td>
pan-mix
mixes 'file' into the current sound starting at 'frame' using the envelope 'env'
to pan the mixed samples (0: all chan 1, 1: all chan 0).

So, <code>(pan-mix \"oboe.snd\" .1 '(0 0 1 1))</code> goes from all chan 0 to all chan 1.  If
the variable <a href="extsnd.html#withmixtags">with-mix-tags</a> is #t, the resultant mixes are placed in their own track, and 
the track envelope controls the panning. 
If 'envelope' is a scaler, it is turned into an evelope at that value. 'auto-delete' determines
whether the in-coming file should be treated as a temporary file and deleted when the mix
is no longer accessible.
To tie this into C-x C-q, in place of the default "mix" function,
<pre>
(<a class=quiet href="extsnd.html#bindkey">bind-key</a> #\q 4 ; C-q
  (lambda () "pan mix"
    (<a class=quiet href="extsnd.html#promptinminibuffer">prompt-in-minibuffer</a> "mix:" (lambda (str) ; use pan-mix at cursor
				   (pan-mix str (or (<a class=quiet href="extsnd.html#cursor">cursor</a>) 0)) #f #t)))
  #t  ; an extended (C-x) command
  "C-x C-q")
</pre>
See <a href="#usepanmixinmixmenu">use-pan-mix-in-mix-menu</a> to change the
File:Mix menu to use pan-mix.  
<br>
<img src="pan.png" alt="picture of panning" hspace=20 vspace=10>

</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- pan-mix-region -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="panmixregion">pan-mix-region</A> <code>region (frame 0) (env 1.0) snd (chn 0)</code>
</td></tr><tr><td></td><td>
pan-mix-region is similar to pan-mix above, but mixes a region, rather than a file.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- pan-mix-selection -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="panmixselection">pan-mix-selection</A> <code>(frame 0) (env 1.0) snd (chn 0)</code>
</td></tr><tr><td></td><td>
pan-mix-selection is similar to pan-mix above, but mixes the current selection, rather than a file.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- pan-mix-vct -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="panmixvct">pan-mix-vct</A> <code>vct (frame 0) (env 1.0) snd (chn 0)</code>
</td></tr><tr><td></td><td>
pan-mix-vct is similar to pan-mix above, but mixes a vct, rather than a file.
The vct data represents one channel of sound.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- save-mix -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="savemix">save-mix</a> <code>id filename</code>
</td></tr><tr><td></td><td>
save-mix saves a given mix's data in a file.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- snap-mix-to-beat -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="snapmixtobeat">snap-mix-to-beat</a> <code>(at-tag-position)</code>
</td></tr><tr><td></td><td>
snap-mix-to-beat forces a dragged mix to end up on a beat (see <a href="extsnd.html#xaxisstyle">x-axis-in-beats</a>).
If 'at-tag-position' is #t, the tagged point, rather than the mix beginning falls on the beat.
Reset <a href="extsnd.html#mixreleasehook">mix-release-hook</a> to cancel this action.
</td></tr><tr><td colspan=2 height=16></td></tr>

</table>

<br>
<table width="60%" border=0><tr><td bgcolor="lightgreen" align="center" valign="middle"><h3>tracks</h3></td></tr></table>

<table border=0 cellspacing=0 hspace=20>

<!-- delete-all-tracks -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="deletealltracks">delete-all-tracks</a>
</td></tr><tr><td width=60></td><td>
delete-all-tracks removes all mixes (by setting their amplitudes to 0.0) that have an associated track.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- filter-track -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="filtertrack">filter-track</a> <code>track fir-coeffs</code>
</td></tr><tr><td></td><td>
filter-track applies an FIR filter to each mix sound at the pre-mix point (that is, the
mixed in sound is filtered, then the mix takes place).
'fir-coeffs' are the filter coefficients:
<pre>
    (filter-track track-id '(.1 .2 .3 .3 .2 .1)) ; a low-pass filter
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- retempo-track -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="retempotrack">retempo-track</a> <code>track tempo</code>
</td></tr><tr><td></td><td>
retempo-track affects the time between the successive mix begin points ('tempo' &gt; 1.0 makes the
mixes happen more quickly):
<pre>
    :<em class=typing>(retempo-track (track 1) 2.0)</em>
    <em class=listener>(1500 7770)</em>
    :<em class=typing>(mix-position 0)</em>
    <em class=listener>1500</em>
    :<em class=typing>(mix-position 1)</em>
    <em class=listener>7770</em>
    :<em class=typing>(+ 1500 (* .5 (- 14039 1500))) ; 14039 is the former mix 1 begin time (see above)</em>
    <em class=listener>7769.5</em>
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- reverse-track -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="reversetrack">reverse-track</a> <code>track</code>
</td></tr><tr><td></td><td>
reverse-track reverses the order in which a track's member mixes occur.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- save-track -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="savetrack">save-track</a> <code>track filename (chan #t)</code>
</td></tr><tr><td></td><td>
save-track places the track's samples into the file 'filename'.
If the 'chan' arg is #t, all channels are saved.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- track-maxamp -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="trackmaxamp">track-maxamp</a> <code>id :optional chan</code>
</td></tr><tr><td></td><td>
track-maxamp returns the maxamp in the given track channel.  If 'chan' is #t,
track-maxamp returns a list of all channel maxamps (much like <a href="extsnd.html#maxamp">maxamp</a>).
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- track-name->id -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="tracknametoid">track-name-&gt;id</a> <code>name</code>
</td></tr><tr><td></td><td>
track-name-&gt;id returns the if of the track with the given name, or 'no-such-track if none can be found.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- track-property -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="trackproperty">track-property</a> <code>key id</code>
</td></tr><tr><td></td><td>
track-property associates a property list with each track.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- transpose-track -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="transposetrack">transpose-track</a> <code>track semitones</code>
</td></tr><tr><td></td><td>
transpose-track transposes each mix in 'track' by 'semitones'.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- track-&gt;vct -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="tracktovct">track-&gt;vct</a> <code>track (chan 0)</code>
</td></tr><tr><td></td><td>
track-&gt;vct places all the track samples (the samples of all the constituent mixes)
into a vct.  
</td></tr><tr><td colspan=2 height=16></td></tr>

</table>

<table bgcolor="aliceblue" border=0><tr><td>
<pre>see also: <a href="extsnd.html#sndmixes">Mixes</a> <a href="snd.html#mixingfiles">View:Mix</a> <a href="#mixchannel">mix-channel</a> <a href="#fadedoc">dissolve-fade</a> <a href="clm.html#musmix">mus-mix</a> <a href="clm.html#with-mix">with-mix</a>
</pre></td>
</tr></table>


<br>
<!-- INDEX mixerdoc:Matrices -->
<br>


<!-- ---------------------------------------- FILE: mixer ---------------------------------------- -->

<A NAME="mixerdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>mixer</h2></td></tr></table>

<!-- main-index |mixerdoc:mixer as matrix -->

<p>mixer.scm has functions related to mixers and frames (linear algebra).  There are some
others in the relevant section of snd-test. (In Ruby, see mix.rb).
</p>
<pre>
  <em class=emdef>make-zero-mixer</em> size
  <em class=emdef>mixer-diagonal?</em> mixer
  <a class=def name="mixer-transpose">mixer-transpose</a> mixer
  <a class=def name="mixer-determinant">mixer-determinant</a> mixer
  <em class=emdef>mixer-trace</em> mixer
  <a class=def name="mixer-poly">mixer-poly</a> mixer coeffs
  <a class=def name="mixer-inverse">mixer-inverse</a> mixer
  <a class=def name="mixer-solve">mixer-solve</a> mixer frame
  <a class=def name="mixercopy">mixer-copy</a> mixer
</pre>

<p>
mixer-solve is probably the most useful of these functions. 
If passed a mixer representing the coefficients of a set of simultaneous
linear equations, and a frame representing the values thereof, it
returns (in the original frame) the values of the independent
variables, and (in the original mixer) the inverse of the matrix
of coefficients.  
</p>
<pre>
    :<em class=typing>(mixer-inverse (make-mixer 2  2.0 0.0  0.0 1.4))</em>
    <em class=listener>#&lt;mixer: chans: 2, vals: [
     0.500 0.000
     0.000 0.714
    ]&gt;</em>
    :<em class=typing>(mixer-solve (make-mixer 2 1.0 1.0 2.0 1.0) (make-frame 2 4.0 5.0))</em>
    <em class=listener>#&lt;frame[2]: [1.000 3.000]&gt;</em>
    ;; that is, x+y=4, 2x+y=5, so x=1, y=3
</pre>
<p>
The rest should be obvious -- these are mostly
treating mixers as square matrices, and frames as row or column
vectors, then performing the usual tricks upon them.  There are
more such functions in snd-test.
</p>
<pre>
    :<em class=typing>(mixer-determinant (make-mixer 2 1.0 0.0 2.0 1.0))</em>
    <em class=listener>1.0</em>
    :<em class=typing>(mixer-trace (make-mixer 2 1.0 0.0 2.0 1.5))</em>
    <em class=listener>2.5</em>
    :<em class=typing>(mixer-transpose (make-mixer 2 1.0 0.0 2.0 1.5))</em>
    <em class=listener>#&lt;mixer: chans: 2, vals: [
     1.000 2.000
     0.000 1.500
    ]&gt;</em>
    :<em class=typing>(mixer-diagonal? (make-mixer 2 1.0 0.0 2.0 1.5))</em>
    <em class=listener>#f</em>
    :<em class=typing>(mixer-poly (make-mixer 2  1.0 0.0 0.0 1.0)  0.5 2.0)</em>
    <em class=listener>#&lt;mixer: chans: 2, vals: [
     2.500 0.000
     0.000 2.500
    ]&gt;</em>
</pre>
<p>mixer-poly treats its mixer argument as the variable in a polynomial.
The rest of the arguments are the polynomial coefficients starting with the constant term,
so the example above computes 
</p>
<pre>
    2.0 * <b>M</b> + 0.5 * <b>I</b>
</pre>

<table bgcolor="aliceblue" border=0><tr><td>
<pre>see also: <a href="clm.html#polynomial">polynomial</a> <a href="#polydoc" onmouseover="return escape('polynomial stuff')">poly</a> <a href="clm.html#framesandmixers" onmouseover="return escape('frames and mixers in CLM')">mixers</a>
</pre></td>
</tr></table>

<br>



<!-- ---------------------------------------- FILE: moog ---------------------------------------- -->

<A NAME="moogdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>moog</h2></td></tr></table>
<pre>
  <em class=emdef>make-moog-filter</em> frequency Q
  <a class=def name="moogfilter">moog-filter</a> gen input
</pre>
<p>moog is a translation of CLM's moog.lisp (written by Fernando Lopez-Lezcano --
http://ccrma.stanford.edu/~nando/clm/moog),
itself a translation of Tim Stilson's original C code.  The functions provide
a kind of CLM generator view of the filter.  Fernando describes it as a
"Moog style four pole lowpass (24db/Oct) filter clm unit generator,
variable resonance, warm, analog sound ;-)". <!-- ( -->
In make-moog-filter, 'frequency' is the cutoff frequency
in Hz (more or less) and 'Q' controls the resonance: 0.0 = no resonance, whereas
1.0 causes the filter to oscillate at 'frequency'. 
</p>

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
  (define (moog freq Q)
    (let ((gen (<em class=red>make-moog-filter</em> freq Q)))
      (lambda (inval)
        (<em class=red>moog-filter</em> gen inval))))

  (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (moog 1200.0 .7))
</pre></td></tr></table>

<p>The Ruby version of this is in examp.rb, and the Forth version is in examp.fs.
</p>

<br>


<!-- ---------------------------------------- FILE: musglyphs ---------------------------------------- -->

<A NAME="musglyphs"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>musglyphs</h2></td></tr></table>

<p>musglyphs.scm provides Scheme/Snd wrappers to load CMN's cmn-glyphs.lisp (directly!),
thereby defining most of the standard music notation symbols.  Each of the original
functions (e.g. draw-bass-clef) becomes a Snd/Scheme procedure of the form
<code>(name :optional x y size style snd chn context)</code>. 
<code>(draw-bass-clef 100 100 50)</code> draws a bass clef in the current graph
at position (100 100) of size 50; since the 'style' argument defaults to
#f, the clef is displayed as a filled polygon; use #t to get an outline of
the clef instead.
</p>
<img src="sndcmn.png" alt="Snd with music symbols" hspace=20>
<br>
<p>This was created with:
</p>
<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(with-sound () (fm-violin 0 1 440 .1))

(define (draw-staff x0 y0 width line-sep)
  (do ((line 0 (1+ line))
       (x x0) 
       (y y0 (+ y line-sep)))
      ((= line 5))
    (<a class=quiet href="extsnd.html#drawline">draw-line</a> x y (+ x width) y)))

(define (draw-a-440 x0 y0 size)
  (let ((width (* size 100))
        (line-sep (* size 20))
        (qsize (* size 80)))
    (draw-staff (+ x0 (* size 5)) y0 width line-sep)	
    (draw-treble-clef x0 (+ y0 (* size 61)) qsize)
    (draw-quarter-note (+ x0 (* 70 size)) (+ y0 (* size 52)) qsize)
    (<a class=quiet href="extsnd.html#fillrectangle">fill-rectangle</a> (+ x0 (* 90 size)) (- y0 (* size 10)) (* size 3) (* size 60))))

(draw-a-440 50 80 1.0)
</pre></td></tr></table>
<p>
We obviously need a direct connection to CMN!
</p>

<br>


<!-- ---------------------------------------- FILE: nb ---------------------------------------- -->

<A NAME="nbdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>nb</h2></td></tr></table>

<p>nb.scm provides popup help for files in the View:Files dialog.  As you move
the mouse through the file list, the help dialog posts information about the file
underneath the mouse.  This uses a slightly fancier file information procedure
than <a href="#finfo">finfo</a> in examp.scm.  If you have the guile-gdbm package, you can use
its database procedures to associate arbitrary information with files which
is posted along with the header info:
</p>
<!-- main-index |nbdoc:file database -->
<pre>
  <em class=emdef>nb</em> file note     ; add note to file's info: (nb "test.snd" "test's info")
  <em class=emdef>unb</em> file         ; erase file's info:       (unb "test.snd")
  <em class=emdef>prune-db</em>         ; remove info associated with defunct files
</pre>
<p>
nb.scm works fine without guile-gdbm; to load
guile-gdbm, set the variable 'use-gdbm' to #t.
The Ruby version of nb (written by Mike Scholz) has several other features -- see nb.rb
for details.
</p>

<br>


<!-- ---------------------------------------- FILE: noise ---------------------------------------- -->

<A NAME="noisedoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>noise</h2></td></tr></table>

<p>The noise files are translations (thanks to Michael Scholz) of CLM's noise.ins.
noise.ins has a very long pedigree; I think it dates back to about 1978.  It can produce
those all-important whooshing sounds.
</p>
<pre>
    <a class=def name="fmnoise">fm-noise</a> <code>(startime dur freq0 amp ampfun ampat ampdc
	      freq1 glissfun freqat freqdc rfreq0 rfreq1 rfreqfun rfreqat rfreqdc
	      dev0 dev1 devfun devat devdc
	      :key (degree 0.0) (distance 1.0) (reverb-amount 0.005))</code>
</pre>

<p>
This is an old instrument, so one must make allowances.  'ampat' and 'ampdc'
are the amplitude envelope ('ampfun') attack and decay times, and similarly for
the frequency envelope 'glissfun', the random number frequency envelope 'rfreqfun'
and the index envelope 'devfun' (dev = "deviation", and old radio-style name for the
FM index).  Each envelope must go on the x axis from 0 to 100; the attack portion ends
at 25, the decay portion starts at 75 (once upon a time there was
a generator named LINEN; his full name was Line-Segment Envelope, but everyone
just called him LINEN; they had to shout because he was a bit deaf).
'rfreq' is the frequency of the random number generator;
if it is below about 25 Hz, you get automatic composition; above that
you start to get noise.  Well, you get a different kind of noise.
'dev' is the bandwidth of the noise; very narrow 'dev' gives a
whistle, very broad more of a whoosh.  This is simple FM 
where the modulating signal is white noise.
</p>
<pre>
   (with-sound ()
     (fm-noise 0 2.0 500 0.25 '(0 0 25 1 75 1 100 0) 0.1 0.1 1000 '(0 0 100 1) 0.1 0.1
 	       10 1000 '(0 0 100 1) 0 0 100 500 '(0 0 100 1) 0 0))
</pre>
<p>
There is also a generator-like version of the instrument:
</p>
<pre>
    <em class=emdef>make-fm-noise</em> <code>(len freq :key (amp 0.25) (ampfun '(0 0 25 1 75 1 100 0)) (ampat 0.1)
                  (ampdc 0.1) (freq1 1000) (glissfun '(0 0 100 1)) (freqat 0.1) (freqdc 0.1)
                  (rfreq0 10) (rfreq1 1000) (rfreqfun '(0 0 100 1)) (rfreqat 0) (rfreqdc 0)
                  (dev0 100) (dev1 500) (devfun '(0 0 100 1)) (devat 0) (devdc 0) 
                  (degree (random 90.0)) (distance 1.0) (reverb-amount 0.005))</code>
</pre>

<table bgcolor="aliceblue" border=0><tr><td>
<pre>see also: <a href="#maracadoc" onmouseover="return escape('noisy physical models')">maraca</a> <a href="clm.html#randomnumbers" onmouseover="return escape('random number generators')">rand</a>
</pre></td>
</tr></table>

<br>


<!-- ---------------------------------------- FILE: oscope ---------------------------------------- -->

<A NAME="oscopedoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>oscope</h2></td></tr></table>

<!-- main-index |oscopedoc:oscilloscope dialog -->

<p>oscope.scm sets up a dialog with a standard Snd channel window (time domain, fft etc) that
displays the data read from the microphone in "real time".
</p>

<table border=0 cellpadding=10 hspace=20><tr><td>
<img src="sndosc.png" alt="oscilloscope dialog">
</td><td>
This is a snapshot of the oscope display (I'm singing "eeahhee" into the microphone); in normal operation, it's constantly updating both the
waveform and the FFT.  Eventually I hope to add a "waterfall" FFT display.
</td></tr></table>

<br>


<!-- ---------------------------------------- FILE: peak-env ---------------------------------------- -->

<A NAME="peakenvdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>peak-env</h2></td></tr></table>

<p>The functions in peak-env.scm provide relatively robust access to
peak envelope files.  These files save Snd's overall amplitude envelopes
for a given sound so that a subsequent re-open of that sound has the
waveform immediately.  For very large sounds, this can save as much as
a minute during which Snd is running the amplitude envelope builders
in the background and displaying whatever it can.  That is, it makes
opening a large sound much faster after the initial read and save.
The variable 'save-peak-env-info' 
determines whether these envelopes are being saved (its default is #t).  The procedure
</p>

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(define (peak-env-info-file-name snd chn)	
  (format #f "~A/~A-peaks-~D" save-peak-env-info-directory (<a class=quiet href="extsnd.html#shortfilename">short-file-name</a> snd) chn))
</pre></td></tr></table>

<p>determines the saved peak env file name; in the default
case, it looks for the directory ~/peaks, but this
could be changed to suit your situation.
For Guile and Gauche, you can load the code in your initialization file:
</p>
<pre>
    (load-from-path "peak-env.scm")
</pre>
<p>
to start the peak-env save/restore process using the directory ~/peaks.
Every now and then, I check that directory and delete any obviously out-of-date
files.  The peak files have names like "_home_bil_cl_1234.snd-peaks-0" which
refers to channel 0 of ~/cl/1234.snd.
If Forth, use:
</p>
<pre>
    require peak-env
</pre>
<p>
In Ruby, this functionality is in env.rb.  It can be activated via:
</p>
<pre>
    install_save_peak_env
</pre>

<br>


<!-- ---------------------------------------- FILE: piano ---------------------------------------- -->

<A NAME="pianodoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>piano</h2></td></tr></table>

<!-- main-index |pianodoc:piano model -->

<p>These files are translations of CLM's piano.ins, a <A HREF="http://ccrma.stanford.edu/overview/pastmodeling.html#SECTION000922600000000000000">piano physical model</A> by Scott van Duyne.  There is also a paper:
Julius O. Smith and Scott A. Van Duyne, "Commuted piano synthesis," in Proc. Int. Computer Music Conf., Banff, Canada, September 1995, pp. 335--342.
To paraphrase these sources, the model includes multiple coupled strings, a nonlinear hammer, and an arbitrarily large soundboard and enclosure.
The actual instrument name is 'p':
</p>
<pre>
    (with-sound ()
      (do ((i 0 (1+ i))) ((= i 7))
        (p (* i .5) :duration .5                    ; generate a sequence of 1/2 second tones
                    :keyNum (+ 24 (* 12 i))         ; jump by octaves
                    :strike-velocity .5             ; 0 to 1, 0 is softest played note, 1 is loud note
                    :amp .4		            ; overall volume level
                    :DryPedalResonanceFactor .25))) ; 0 no open string resonance
					            ; 1.0 is about full resonance of dampers raised
					            ; can be greater than 1.0
</pre>
<p>This instrument has lots of parameters, and I really don't know what they do.  The interested reader should
goof around with them.
</p>
<pre>
    <em class=emdef>p</em> (start :key 
       (duration 1.0)
       (keyNum 60.0)              ; middleC=60: can use fractional part to detune
       (strike-velocity 0.5)      ; corresponding normalized velocities (range: 0.0--1.0)
       (pedal-down #f)	      ; set to t for sustain pedal down...pedal-down-times not yet impl.
       (release-time-margin 0.75) ; extra compute time allowed beyond duration
       (amp .5)                   ; amp scale of noise inputs...
       (detuningFactor 1.0)
       (detuningFactor-table '())
       (stiffnessFactor 1.0)
       (stiffnessFactor-table '())
       (pedalPresenceFactor .3)
       (longitudinalMode 10.5)
       (StrikePositionInvFac -0.9)
       (singleStringDecayRateFactor 1.0)
       
       ;; parameter tables indexed by keyNum
       ;; you can override the loudPole-table by directly setting :loudPole to a value
    
       loudPole (loudPole-table default-loudPole-table)
       softPole (softPole-table default-softPole-table)
       loudGain (loudGain-table default-loudGain-table)
       softGain (softGain-table default-softGain-table)
       strikePosition (strikePosition-table default-strikePosition-table)
       detuning2 (detuning2-table default-detuning2-table)
       detuning3 (detuning3-table default-detuning3-table)
       stiffnessCoefficient (stiffnessCoefficient-table default-stiffnessCoefficient-table)
       singleStringDecayRate (singleStringDecayRate-table default-singleStringDecayRate-table)
       singleStringZero (singleStringZero-table default-singleStringZero-table)
       singleStringPole (singleStringPole-table default-singleStringPole-table)
       releaseLoopGain (releaseLoopGain-table default-releaseLoopGain-table)
       DryTapFiltCoeft60 (DryTapFiltCoeft60-table default-DryTapFiltCoeft60-table)
       DryTapFiltCoefTarget (DryTapFiltCoefTarget-table default-DryTapFiltCoefTarget-table)
       DryTapFiltCoefCurrent (DryTapFiltCoefCurrent-table default-DryTapFiltCoefCurrent-table)
       DryTapAmpt60 (DryTapAmpt60-table default-DryTapAmpt60-table)
       sustainPedalLevel (sustainPedalLevel-table default-sustainPedalLevel-table)
       pedalResonancePole (pedalResonancePole-table default-pedalResonancePole-table)
       pedalEnvelopet60 (pedalEnvelopet60-table default-pedalEnvelopet60-table)
       soundboardCutofft60 (soundboardCutofft60-table default-soundboardCutofft60-table)
       DryPedalResonanceFactor (DryPedalResonanceFactor-table default-DryPedalResonanceFactor-table)
       unaCordaGain (unaCordaGain-table default-unaCordaGain-table))
</pre>
<p>Here is another example; there are a couple other examples at the end of piano.scm:
</p>
<pre>
    (with-sound ()
      (do ((i 0 (1+ i))) ((= i 8))
        (p (* i .5) :duration .5 :keyNum (+ 24 (* 12 i)) :strike-velocity .5 :amp .4 :DryPedalResonanceFactor .25
         :detuningFactor-table '(24 5 36 7.0 48 7.5 60 12.0 72 20 84 30 96 100 108 300)
    		    ; scales the above detuning values so 1.0 is nominal detuning, 
                    ;  0.0 is exactly in tune,  &gt; 1.0 is out of tune
         :stiffnessFactor-table '(21 1.5 24 1.5 36 1.5 48 1.5 60 1.4 72 1.3 84 1.2 96 1.0 108 1.0))))
    		    ; 0.0 to 1.0 is less stiff, 1.0 to 2.0 is more stiff
</pre>
<p>In Ruby:
</p>
<pre>
    include Piano
    with_sound(:clm, false, :channels, 1) do
      7.times do |i|
        p(i * 0.5,
          :duration, 0.5,
          :keyNum, 24 + 12.0 * i,
          :strike_velocity, 0.5,
          :amp, 0.4,
          :dryPedalResonanceFactor, 0.25)
      end
    end
</pre>

<table bgcolor="aliceblue" border=0><tr>
<td>
<pre>see also: <a href="#stereoflute" onmouseover="return escape('flute physical model')">flute</a> <a href="#maracadoc" onmouseover="return escape('maraca physical models')">maraca</a> <a href="#pluck" onmouseover="return escape('plucked string physical model')">pluck</a> <a href="#prc95doc" onmouseover="return escape('several physical models')">prc95</a> <a href="#singerdoc" onmouseover="return escape('singer physical model')">singer</a> <a href="#straddoc" onmouseover="return escape('violin physical model')">strad</a>
</pre>
</td></tr></table>

<br>

<br>


<!-- ---------------------------------------- FILE: play ---------------------------------------- -->

<A NAME="playdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>play</h2></td></tr></table>

<p>This file has a variety of "real-time" audio output examples.
</p>

<table border=0 cellspacing=0 hspace=20>


<!-- loop-between-marks -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="loopbetweenmarks">loop-between-marks</a> <code>mark1 mark2 buffer-size</code>
</td></tr><tr><td width=60></td><td>
loop-between-marks loops continuously between the two specified marks.
The marks can be moved as the sound is played; C-g stops loop-between-marks.
<code>(loop-between-marks 0 1 512)</code>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- open-play-output -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="openplayoutput">open-play-output</A> <code>:optional chans srate format buffer-size</code>
</td></tr><tr><td></td><td>
open-play-output opens an output audio port.  It
takes the desired number of channels, sampling rate, data format, and DAC buffer size (in samples),
and returns a list containing the audio port (-1 on failure), the opened output channels,
and the actual DAC buffer size (these can differ from the requested amounts in various hardware
situations).
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- play-with-amps -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>play-with-amps</em> <code>snd :rest amps</code>
</td></tr><tr><td></td><td>
play-with-amps plays the sound 'snd' with each channel scaled by the corresponding 
amp: <code>(play-with-amps 0 1.0 0.5)</code> plays sound 0's
channel 1 at full amplitude, and
channel 2 at half amplitude.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- play-often -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="playoften">play-often</A> <code>n</code><br>
<A class=def NAME="playuntilcg">play-until-c-g</A><br>
<A class=def NAME="playregionforever">play-region-forever</a> <code>reg</code>
</td></tr><tr><td></td><td>
play-often plays the selected sound 'n' times.
play-until-c-g plays the selected sound until you interrupt it via C-g.
Similarly, play-region-forever plays region 'reg' until you interrupt it with C-g.

<table border=0 cellpadding=5><tr><td bgcolor="#fafafa"><pre>
    (<a class=quiet href="extsnd.html#bindkey">bind-key</a> #\p 0 
      (lambda (n) 
        "play often" 
        (play-often (max 1 n))))

    (<a class=quiet href="extsnd.html#bindkey">bind-key</a> #\r 0 
      (lambda (n) 
        "play region forever" 
        (play-region-forever (max 0 n))))
</pre></td></tr></table>
Now <code>C-u 31 p</code> plays the current sound 31 times; <code>C-u 3 r</code> plays region 3 until we type C-g.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- play-sines -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="playsine">play-sine</A> <code>freq amp</code><br>
<a class=def name="playsines">play-sines</a> <code>freqs-and-amps</code>
</td></tr><tr><td></td><td>
play-sine plays a one-second sine wave at the given frequency and amplitude: <code>(play-sine 440 .1)</code>.
play-sines produces a spectrum given a list of lists of frequency and amplitude:
<pre>
    (play-sines '((425 .05) (450 .01) (470 .01) (546 .02) (667 .01) (789 .034) (910 .032)))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- play-sound -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="playsound">play-sound</A> <code>:optional func</code>
</td></tr><tr><td></td><td>
play-sound plays the current sound, calling <code>(func data)</code> on each buffer if 'func' is passed.
The following doubles each sample in channel 0 during playback:

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(<em class=red>play-sound</em>
 (lambda (data)
   (let ((len (<a class=quiet href="extsnd.html#sounddatalength">sound-data-length</a> data)))
     (do ((i 0 (1+ i)))
	 ((= i len))
       (<a class=quiet href="extsnd.html#sounddataset">sound-data-set!</a> data 0 i (* 2.0 (<a class=quiet href="extsnd.html#sounddataref">sound-data-ref</a> data 0 i)))))))
</pre></td></tr></table>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- start-dac -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="startdac">start-dac</A><br>
<em class=emdef>stop-dac</em>
</td></tr><tr><td></td><td>
start-dac opens the DAC ready for sound output, and stop-dac closes it.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- vector-synthesis -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>vector-synthesis</em> <code>driver files read-even-when-not-playing</code>
</td></tr><tr><td></td><td>
vector-synthesis cycles through a collection of incoming audio streams, playing whatever
happens to be on the chosen one, with fade-ins and fade-outs to avoid clicks.
It uses 'driver', a 
function of two arguments (the number of files, and the number of samples between calls) to decide which file to play.  If 
'read-even-when-not-playing' is #t (the default is #f), the input files are constantly 
read, even if not playing.  'files' is a list of files to be played.

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(vector-synthesis 
  (let ((ctr 0) (file 0)) 
    (lambda (files bufsize)
      (if (&gt; ctr 4)
	  (begin
	    (set! file (1+ file))
	    (set! ctr 0)
	    (if (&gt;= file files)
		(set! file 0)))
	  (set! ctr (1+ ctr)))
      file))
  (list "oboe.snd" "pistol.snd") #t)
</pre></td></tr></table>
The vector-synthesis 
idea (and the weird name) came from a linux-audio-development mailing list.
Apparently some commercial synths (or software?) provide this.
</td></tr><tr><td colspan=2 height=16></td></tr>

</table>

<table bgcolor="aliceblue" border=0><tr>
<td>
<pre>see also: <a href="extsnd.html#playexamples">Playing</a> <a href="extsnd.html#extsndlib">Sndlib</a>
</pre>
</td></tr></table>

<br>
<br>


<!-- ---------------------------------------- FILE: poly ---------------------------------------- -->

<A NAME="polydoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>poly</h2></td></tr></table>

<p>This file contains various functions related to the CLM polynomial function.  A polynomial here
is a vct or a vector (for complex coefficients) holding the polynomial coefficients from lowest
to highest (i.e. the constant is vct[0], x+2 is (vct 2 1), etc).
</p>

<!-- main-index |polydoc:polynomial operations -->

<pre>
  <em class=emdef>poly+</em> p1 p2           ; new poly = p1 + p2
  <em class=emdef>poly*</em> p1 p2           ; new poly = p1 * p2
  <em class=emdef>poly/</em> p1 p2           ; (list quotient-poly remainder-poly) = p1 / p2
  <em class=emdef>poly-derivative</em> p1    ; new poly = Dp1
  <em class=emdef>poly-reduce</em> p1        ; new poly = p1 without high zeros
  <em class=emdef>poly-gcd</em> p1 p2        ; new poly = gcd(p1, p2)
  <em class=emdef>poly-roots</em> p1         ; list of roots of p1
  <em class=emdef>poly-resultant</em> p1 p2  ; resultant of p1 and p2
  <em class=emdef>poly-discriminant</em> p1  ; discriminant of p1
</pre>

<p>
poly+ adds two polynomials, and poly* multiplies two polynomials.
poly/ divides two polynomials, with a few restrictions, and returns
a list containing the quotient and remainder polynomials.  poly-derivative
returns the derivative of a polynomial.  In all these cases, the resultant
polynomials may have extra high-degree entries whose coefficients are zero.
To remove these pointless coefficients, use poly-reduce.
The last functions are
just for fun.
</p>

<p>You can treat a sound as a set of polynomial coefficients; then, for example,
convolution the infinitely slow way is poly*:
</p>
<pre>
    (<a class=quiet href="extsnd.html#vcttochannel">vct-&gt;channel</a> (poly* (<a class=quiet href="extsnd.html#channeltovct">channel-&gt;vct</a> 0 (<a class=quiet href="extsnd.html#frames">frames</a>)) (<a class=quiet href="extsnd.html#vct">vct</a> 2.0))) ; no, this is not serious
</pre>

<table bgcolor="aliceblue" border=0><tr><td>
<pre>see also: <a href="clm.html#polynomial">polynomial</a> <a href="#mixerdoc" onmouseover="return escape('linear algebra stuff')">mixer</a> <a href="extsnd.html#Vcts" onmouseover="return escape('array processing')">vcts</a>
</pre></td>
</tr></table>

<br><br>


<!-- ---------------------------------------- FILE: popup, gtk-popup ---------------------------------------- -->

<A NAME="popupdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>popup, gtk-popup</h2></td></tr></table>
<p>
gtk-popup.scm is the Gtk/xg version; popup.scm is Motif/xm based.
These files create a set of context-sensitive popup menus.  Which menu
is posted under the mouse depends on where the mouse is:  there are
special menus for the current selection, the fft, the time domain window
other than the selection, the edit history list, and the listener.
Press button3 in one of these areas to get a menu.
Here are the selection and fft popups:
</p>

<table border=0 hspace=20 cellpadding=10>
<tr><td>
<img src="selpop.png" alt="selection popup menu">
</td><td>
<img src="fftpop.png" alt="fft popup menu">
</td></tr></table>

<br>
<br>


<!-- ---------------------------------------- FILE: prc95 ---------------------------------------- -->

<A NAME="prc95doc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>prc95</h2></td></tr></table>

<!-- INDEX prc95doc:Physical Models -->
<p>prc95.scm is a translation to Snd of Perry Cook's (1995) physical modelling toolkit; prc-toolkit95.lisp 
in CLM.  One starting point for physical modelling is Smith, "Music Applications of Digital Waveguides", CCRMA, Stan-M-39, 1987,
or Julius's <A HREF="http://ccrma.stanford.edu/~jos">home</A> page, or
any of several classic papers also by Julius Smith.  Perry's own version of this code can be
found in <A HREF="http://ccrma.stanford.edu/CCRMA/Software/STK/">STK</A>.
The example instruments are:
</p>
<table border=0 hspace=20>
<tr><td>
<pre>
  <em class=emdef>plucky</em> beg dur freq amplitude maxa  ; plucked string
  <em class=emdef>bow</em> beg dur frq amplitude maxa      ; bowed string
  <em class=emdef>brass</em> beg dur freq amplitude maxa   
  <em class=emdef>clarinet</em> beg dur freq amplitude maxa 
  <em class=emdef>flute</em> beg dur freq amplitude maxa

  (with-sound ()
    (plucky 0 .3 440 .2 1.0)
    (bow .5 .3 220 .2 1.0)
    (brass 1 .3 440 .2 1.0)
    (clarinet 1.5 .3 440 .2 1.0)
    (flute 2 .3 440 .2 1.0))
</pre>
</td>
<td>
<table border=3 bordercolor="tan" hspace=40><tr><td>
<blockquote><small>
<br>
See also:<br>
maraca: <a href="#maracadoc">maraca.scm, maraca.rb</a><br>
piano: <a href="#pianodoc">piano.scm, piano.rb</a><br>
singer: <a href="#singerdoc">singer.scm, singer.rb</a><br>
bowed string: <a href="#straddoc">strad.scm, strad.rb</a><br>
flute: <a href="#clminsdoc">clm-ins.scm</a><br>
string: <a href="#computeuniformcircularstring">compute-string</a><br>
plucked string: pluck in clm-ins.scm<br>
plate-reverb: ladspa.scm<br>
<br>
</small></blockquote>
</td></tr></table>
</td></tr></table>
<br>

<br>


<!-- ---------------------------------------- FILE: pvoc ---------------------------------------- -->

<A NAME="pvocdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>pvoc</h2></td></tr></table>
<p>
This is the same as the CLM <a href="clm.html#phase-vocoder">phase-vocoder</a> generator, but implemented in Scheme.  If you're interested
in how the thing works, I think the Scheme version is easiest to understand; the Common Lisp version 
is in mus.lisp, and the C version is in clm.c.
</p>
<pre>
  <em class=emdef>make-pvocoder</em> fftsize overlap interp analyze edit synthesize
  <em class=emdef>pvocoder</em> gen input
  <em class=emdef>pvoc</em> :key (fftsize 512) (overlap 4) (time 1.0) (pitch 1.0) (gate 0.0) (hoffset 0.0) (snd 0) (chn 0)
</pre>
<p>The 'analyze', 'edit', and 'synthesize' arguments to make-pvocoder are
functions that are applied as needed during pvocoder processing; similarly, the 'input'
argument to pvocoder can be a function.
</p>
<pre>
    (let* ((ind (<a class=quiet href="extsnd.html#opensound">open-sound</a> "oboe.snd"))
	   (pv (<em class=red>make-pvocoder</em> 256 4 64))
           (rd (<a class=quiet href="extsnd.html#makesamplereader">make-sample-reader</a> 0)))
      (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (lambda (y) (<em class=red>pvocoder</em> pv rd))))
</pre>
<p>
pvoc.scm also contains a few examples of using the CLM phase-vocoder generator:
</p>
<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(define test-pv-4
  (lambda (gate)
    (let ((pv (<a class=quiet href="clm.html#make-phase-vocoder">make-phase-vocoder</a> #f
				  512 4 128 1.0
				  #f ;no change to analysis
				  (lambda (v)
				    (let ((N (<a class=quiet href="clm.html#mus-length">mus-length</a> v)))
				      (do ((i 0 (1+ i)))
					  ((= i N))
					(if (&lt; (<a class=quiet href="extsnd.html#vctref">vct-ref</a> (phase-vocoder-amp-increments v) i) gate)
					    (<a class=quiet href="extsnd.html#vctset">vct-set!</a> (phase-vocoder-amp-increments v) i 0.0)))
				      #t))
				  #f ;no change to synthesis))
	  (reader (<a class=quiet href="extsnd.html#makesamplereader">make-sample-reader</a> 0)))
      (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (lambda (val)
		  (<a class=quiet href="clm.html#phase-vocoder">phase-vocoder</a> pv (lambda (dir) 
				      (reader)))))
      (<a class=quiet href="extsnd.html#freesamplereader">free-sample-reader</a> reader))))
</pre></td></tr></table>

<p>This sets up a phase-vocoder generator whose edit function is squelching soft partials.
In this case, the input function is reading the currently selected channel.
</p>
<p>
pvoc is yet another (unoptimized) phase-vocoder;
it applies the phase-vocoder
to the current sound; 'pitch' specifies the pitch transposition ratio, 
'time' specifies the time dilation ratio,
'gate' specifies a resynthesis gate in dB (partials with amplitudes lower than
the gate value will not be synthesized), 'hoffset' is a pitch offset in Hz.
</p>
<pre>
    (pvoc :time 2.0)
</pre>

<table bgcolor="aliceblue" border=0><tr>
<td>
<pre>see also: <a href="clm.html#phase-vocoder" onmouseover="return escape('CLM phase-vocoder generator')">phase-vocoder</a> <a href="#pins" onmouseover="return escape('SMS instrument, an extension of the phase-vocoder')">pins</a>
</pre>
</td></tr></table>

<br>
<br>


<!-- ---------------------------------------- FILE: rgb ---------------------------------------- -->

<A NAME="rgbdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>rgb</h2></td></tr></table>
<p>rgb.scm (rgb.rb) is a simple translation of the standard X11 color names into Snd
color objects.
</p>
<pre>
    (define snow (<a class=quiet href="extsnd.html#makecolor">make-color</a> 1.00 0.98 0.98))
</pre>
<p>is taken from the line</p>
<pre>
    255 250 250             snow
</pre>
<p>/usr/lib/X11/rgb.txt.  The choice of a float between 0.0 and 1.0 (rather
than an integer between 0 and 255) mimics PostScript;
as video hardware has improved over the years, there's
less and less need for these elaborate color names, and less
reason (except perhaps psychophysical) to limit these numbers to bytes.
There is one gotcha in this file -- X11 defines a color named "tan"
which is already used by Scheme, so (at the suggestion of Dave Phillips)
this color is named "tawny" in rgb.scm.
</p>
<br>



<!-- ---------------------------------------- FILE: rt-examples and friends ---------------------------------------- -->

<A NAME="rtexdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>rt-examples and friends</h2></td></tr></table>

<p>The files rt-compile.scm, rt-engine.scm, rt-examples.scm, oo.scm, gui.scm, and eval-c.scm, all
written by Kjetil Matheussen, provide hard (glitch-free) real-time support for CLM instruments,
as well as numerous other extensions of Snd for user interface development, optimization, etc.
See rt.tex for complete details.
</p>
<br>


<!-- ---------------------------------------- FILE: rtio ---------------------------------------- -->

<A NAME="rtiodoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>rtio</h2></td></tr></table>

<p>rtio.scm has a collection of functions oriented loosely around
"real-time" operations.
</p>
<pre>
  <em class=emdef>show-input</em> :optional (in-sys 0)
  <A class=def NAME="showinputfft">show-input-fft</a> :optional (in-sys 0)
  <A class=def NAME="showdraggableinputfft">show-draggable-input-fft</a> :optional (in-sys 0)
  <em class=emdef>in-out</em> func in-sys out-sys
</pre>
<p>These functions show how to read incoming data (from the adc),
write data (to the dac), and interpose a function while reading and
writing data.  There are several example functions (for the 'func' argument) that filter the data or
change its amplitude. show-input-fft displays the input data's
spectrum.  show-draggable-input-fft is the same, but the X axis
(the frequency axis in this case) is draggable, as in Snd's FFT display.
See <a href="#oscopedoc">oscope</a> for a fancier version of the fft stuff.
</p>
<p>Here's some info from Michael Scholz about the Ruby version of rtio:
</p>

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
rt = make_rtio
rt.show_input
rt.show_input_fft
rt.chans = 2
rt.show_drag
rt.amplify(1.5).in_out(1, 0)
rt.lp.in_out
rt.hp(1150).in_out
rt.close
</pre>
</td></tr></table>


<br>
<br>


<!-- ---------------------------------------- FILE: rubber ---------------------------------------- -->

<A NAME="rubberdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>rubber</h2></td></tr></table>

<pre>
  <a class=def name="rubbersound">rubber-sound</a> stretch-factor :optional snd chn
</pre>
<p>
rubber-sound tries to stretch or contract a sound (in time); it scans the sound
looking for stable (periodic) sections, then either deletes periods or interpolates new ones
to shorten or lengthen the sound.  It still needs a lot of robustification.
The algorithm is 1) remove all frequencies below 16 Hz, 2) resample the file to be
ten times longer (interpolating samples), 3) make a list of upward zero crossings,
4) using autocorrelation decide where the next fundamental zero crossing probably
is and see how much difference there is between the current period and the next,
5) check intermediate crossing weights and if the autocorrelation weight is not
the smallest, throw away this crossing, 6) sort the remaining crossings by least weight,
7) interpolate or delete periods until the sound has been sufficiently lengthened or
shortened.
rubber-sound is incredibly slow, and almost never works.  The idea seems good however...

<!-- ((((((( --><!-- this matches the preceding open parens for index.cl's benefit -->
</p>

<table bgcolor="aliceblue" border=0><tr>
<td>
<pre>see also: <a href="#clmexpsrc" onmouseover="return escape('clm-ins version of expsrc')">clm-expsrc</a> <a href="#expsrc" onmouseover="return escape('granular synthesis to stretch sound')">expsrc</a> <a href="#pvocdoc" onmouseover="return escape('phase-vocoder')">pvoc</a> <a href="#ssbbank" onmouseover="return escape('use ssb-am for time stretch')">ssb-bank</a>
</pre>
</td></tr></table>

<br>


<!-- ---------------------------------------- FILE: singer ---------------------------------------- -->

<A NAME="singerdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>singer</h2></td></tr></table>

<!-- main-index |singerdoc:singer -->
<!-- main-index |singerdoc:voice physical model -->

<p>singer.scm is an implementation of Perry Cook's
physical model of the vocal tract as described in:
</p>
<pre>
  Cook, Perry R. "Synthesis of the Singing Voice Using a Physically Parameterized Model of the Human Vocal Tract"
     Published in the Proceedings of the International Computer Music Conference, Ohio 1989 
     and as Stanford University Department of Music Technical Report Stan-M-57, August 1989.
 
 ---- "Identification of Control Parameters in an Articulatory Vocal Tract Model, with Applications 
    to the Synthesis of Singing," Ph.D. Thesis, Stanford University Department of Music Technical Report 
    Stan-M-68, December 1990.

 ----  "SPASM, a Real-time Vocal Tract Physical Model Controller; and Singer, the Companion Software 
    Synthesis System", Computer Music Journal, vol 17 no 1 Spring 1993.
</pre>
<p>
singer.scm is a translation of Perry's singer.c.
I think that Perry's code assumes a sampling rate of 22050; you'll need to fix up lots of
lengths in the code to run at 44100.  
The singer instrument looks deceptively simple:
</p>
<pre>
    <em class=emdef>singer</em> beg amp data
</pre>
<p>
but all the complexity is hidden in the 'data' parameter.  
'data' is a list of lists; each imbedded list has the form: <code>'(dur shape glot pitch glotamp noiseamps vibramt)</code>.
The 'shape' and 'glot' entries are themselves lists; I think the 'glot'
list describes the glottal pulse.  I wish I could fully explain all these lists, but 
I translated this code a very long time ago, and can't remember any details.  You'll
have to read the code, or perhaps find something in Perry's publications.
In any case, here's a simple example:
</p>
<pre>
    (with-sound () 
      (singer 0 .1 (list (list .4 ehh.shp test.glt 523.0 .8 0.0 .01) 
                         (list .6 oo.shp test.glt 523.0 .7 .1 .01))))
</pre>
<p>
The *.shp and *.glt data is defined at the end of singer.scm.  For example:
</p>
<pre>
    (define test.glt (list 10 .65 .65))
    (define ee.shp (list 8 1.02 1.637 1.67 1.558 0.952 0.501 0.681 0.675 0.9 -0.4 1.0 0.0 0.0 0.0 0.0 0.0 0.0))
</pre>
<p>
A more complex example is singer's attempt to say "requiem":
</p>
<pre>
    (with-sound ()
      (singer 0 .1 (list (list .05 ehh.shp test.glt 523.0 0.8 0.0 .01) 
		         (list .15 ehh.shp test.glt 523.0 0.8 0.0 .01) 
		         (list .05 kkk.shp test.glt 523.0 0.0 0.0 .01) 
		         (list .05 kkk.shp test.glt 523.0 0.0 0.0 .01) 
		         (list .02 kk+.shp test.glt 523.0 0.0 1.0 .01) 
		         (list .08 kk+.shp test.glt 523.0 0.0 0.2 .01) 
		         (list .05 ooo.shp test.glt 523.0 0.8 0.0 .01) 
		         (list .15 ooo.shp test.glt 523.0 0.8 0.0 .01) 
		         (list .05 eee.shp test.glt 523.0 0.8 0.0 .01) 
		         (list .15 eee.shp test.glt 523.0 0.8 0.0 .01) 
		         (list .05 ehh.shp test.glt 523.0 0.8 0.0 .01) 
		         (list .15 ehh.shp test.glt 523.0 0.8 0.0 .01) 
		         (list .05 mmm.shp test.glt 523.0 0.8 0.0 .01) 
		         (list .15 mmm.shp test.glt 523.0 0.8 0.0 .01) 			      
		         (list .10 mmm.shp test.glt 523.0 0.0 0.0 .01))))
</pre>

<table bgcolor="aliceblue" border=0><tr>
<td>
<pre>see also: <a href="#fofins" onmouseover="return escape('FOF synthesis')">fofins</a> <a href="#reson" onmouseover="return escape('FM voice via formants')">reson</a> <a href="#pqwvox" onmouseover="return escape('waveshaping voice')">pqw-vox</a> <a href="#fmvox" onmouseover="return escape('FM voice with movable formants')">vox</a>
</pre>
</td></tr></table>

<br>
<br>


<!-- ---------------------------------------- FILE: snd4|5|6|7|8 ---------------------------------------- -->

<A NAME="snd4doc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>snd4|5|6|7|8</h2></td></tr></table>

<p>These files contain a number of the procedures
that were removed from or renamed in earlier versions of Snd (in Ruby, look in extensions.rb).  Some of them are:
</p>

<table border=0 cellspacing=0 hspace=20>

<!-- append-to-minibuffer -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>append-to-minibuffer</em> msg :optional snd
</td></tr><tr><td></td><td>
appends 'msg' to whatever is in the sound's minibuffer. (snd6.scm)
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- backward-graph -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>backward-graph</em> :optional count snd chn
</td></tr><tr><td></td><td>
move the selected channel back (up or left) 'count' graphs (C-x C-o), returning a list of the new sound index and channel number.
(snd7.scm)
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- backward-mark -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>backward-mark</em> :optional count snd chn
</td></tr><tr><td></td><td>
move the cursor back 'count' marks (C-j), returning mark id, or #f if none. (snd7.scm)
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- backward-mix -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>backward-mix</em> :optional count snd chn
</td></tr><tr><td width=50><br></td><td>
move the cursor back 'count' mix tags (C-x C-j), returning the mix id. (snd7.scm)
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- clear-audio-inputs -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>clear-audio-inputs</em> ()
</td></tr><tr><td></td><td>
try to reduce soundcard noise by turning off various inputs (OSS only). (snd6.scm)
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- emacs-style-save-as -->
<tr><td colspan=2 bgcolor="#f6f8ff"><a class=def name="emacsstylesaveas">emacs-style-save-as</a>
</td></tr><tr><td></td><td colspan=2>
After File:Save-as dialog option, should Snd remain with the current file (#f) or go to the new file (#t).
(snd7.scm)
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- forward-graph -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>forward-graph</em> :optional count snd chn
</td></tr><tr><td></td><td>
move the selected channel forward (down or right) 'count' graphs (C-x C-o), returning a list of the new sound index and channel number.
(snd7.scm)
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- forward-mark -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>forward-mark</em> :optional count snd chn
</td></tr><tr><td></td><td>
move the cursor forward 'count' marks (C-j), returning mark id, or #f if none. (snd7.scm)
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- forward-mix -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>forward-mix</em> :optional count snd chn
</td></tr><tr><td></td><td>
move the cursor forward 'count' mix tags (C-x C-j), returning the mix id. (snd7.scm)
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- samples->sound-data -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>samples-&gt;sound-data</em> :optional samp samps snd chn sdobj edpos sdchan
</td></tr><tr><td></td><td>
This is similar to <a href="extsnd.html#channeltovct">channel-&gt;vct</a>, but it fills a <a href="extsnd.html#sndsounddata">sound-data</a> object.
(snd8.scm)
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- samples->vct -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>samples-&gt;vct</em> samp samps :optional snd chn v edpos
</td></tr><tr><td></td><td>
return vct struct with the data specified.
Use <a href="extsnd.html#channeltovct">channel-&gt;vct</a> instead. (snd7.scm)
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- scale-sound-by -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>scale-sound-by</em> scaler :optional beg num snd chn edpos
</td></tr><tr><td></td><td>
scales the samples in the given channel between beg and beg + num by scaler.  If the channel argument is omitted,
<b>scale-sound-by</b> scales the entire sound.  'beg' defaults to 0; 'num' defaults to the length of the channel.
'snd' defaults to the selected sound, and 'chn' to the selected channel.  Unlike scale-by, this ignores the <a class=quiet href="extsnd.html#sync">sync</a> setting.
(snd7.scm)
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- scale-sound-to -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>scale-sound-to</em> norm :optional beg num snd chn
</td></tr><tr><td></td><td>
normalizes the samples in the given channel between beg and beg + num to norm.  If the channel argument is omitted,
<b>scale-sound-to</b> normalizes the entire sound.  'beg' defaults to 0; 'num' defaults to the length of the channel.
'snd' defaults to the selected sound, and 'chn' to the selected channel.  Unlike scale-to, this ignores the <a class=quiet href="extsnd.html#sync">sync</a> setting.
(snd7.scm)
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- vct->samples -->
<tr><td colspan=2 bgcolor="#f6f8ff"><em class=emdef>vct-&gt;samples</em> samp samps data :optional snd chn
</td></tr><tr><td></td><td>
A synonym for <a href="extsnd.html#setsamples">set-samples</a>, but you can also pass just a vct as the first argument, or a start
sample and a vct as the second argument.  Use <a href="extsnd.html#vcttochannel">vct-&gt;channel</a> instead.
(snd7.scm)
</td></tr><tr><td colspan=2 height=16></td></tr>

</table>

<br><br>


<!-- ---------------------------------------- FILE: snd-gl ---------------------------------------- -->

<A NAME="sndgldoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>snd-gl</h2></td></tr></table>

<p>snd-gl.scm has examples of using <A HREF="http://www.mesa3d.org/">OpenGL</A>.  To try out these functions, build Snd
with GL: <code>configure --with-gl</code>.  You can tell if your current Snd has OpenGL loaded by checking the
*features* list for 'gl: <code>(provided? 'gl)</code>.
</p>

<table border=0 cellspacing=0 hspace=20>

<!-- complexify -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="complexify">complexify</a> <code>()</code>
</td></tr><tr><td width=60></td><td>
complexify displays FFT data in the complex plane; each bin is 
rotated so that they all stack along the x axis, with
a line drawn from the x axis to the current real/imaginary
point (as (z, y)), so as you move (slowly) through a
file, you'll see the phase info as well as the magnitude --
the vectors whirl around in each slice of the complex 
plane.  Use the View:Orientation dialog to change the
viewing angle.  To move one sample at a time through a sound,
you could bind the arrow keys:

<table border=0 cellpadding=5 hspace=20 vspace=10><tr><td bgcolor="#fafafa"><pre>
(<a class=quiet href="extsnd.html#bindkey">bind-key</a> "Left" 0 (lambda () 
                     (set! (<a class=quiet href="extsnd.html#leftsample">left-sample</a>) (max 0 (1- (<a class=quiet href="extsnd.html#leftsample">left-sample</a>)))) 
                     keyboard-no-action))
(<a class=quiet href="extsnd.html#bindkey">bind-key</a> "Right" 0 (lambda () 
                     (set! (<a class=quiet href="extsnd.html#leftsample">left-sample</a>) (min (<a class=quiet href="extsnd.html#frames">frames</a>) (1+ (<a class=quiet href="extsnd.html#leftsample">left-sample</a>)))) 
                     keyboard-no-action))
</pre></td></tr></table>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- gl-dump-state -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>gl-dump-state</em> <code>()</code>
</td></tr><tr><td></td><td>
gl-dump-state displays much of the current GL graphics state.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- gl-info -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>gl-info</em> <code>()</code>
</td></tr><tr><td></td><td>
gl-info prints out information about the current GL system setup.  
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- start-waterfall -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="startwaterfall">start-waterfall</a> <code>:optional (scl 1.0) (pc-spectrum 0.2) (fft-size 512)</code>
</td></tr><tr><td></td><td>
start-waterfall starts a
waterfall spectrum display of the incoming audio data. 
'pc-spectrum' determines how much of the spectrum is displayed (very often the high portions are not interesting; we'd
rather zoom in on the stuff we can hear).
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- stop-waterfall -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>stop-waterfall</em> <code>()</code>
</td></tr><tr><td></td><td>
stop-waterfall turns off the waterfall spectrum display.
</td></tr><tr><td colspan=2 height=16></td></tr>

</table>

<table bgcolor="aliceblue" border=0><tr>
<td>
<pre>see also: <a href="extsnd.html#glspectrogram">glSpectrogram</a> <a href="grfsnd.html#sndandgl" onmouseover="return escape('OpenGL (Mesa) extensions via gl.c')">OpenGL</a>
</pre>
</td></tr></table>


<br>
<br>

<!-- INDEX variabledisplay:Debugging (instruments) -->
<!-- main-index |sndmotifdoc:user interface extensions -->


<!-- ---------------------------------------- FILE: snd-motif, snd-xm ---------------------------------------- -->

<A NAME="sndmotifdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>snd-motif, snd-xm</h2></td></tr></table>

<p>snd-motif.scm has a variety of user-interface extensions that rely on the Motif module (xm.c).
Some of these have been translated to Gtk and xg.c -- snd-gtk.scm.  In Ruby, see snd-xm.rb.
</p>

<table border=0 cellspacing=0 hspace=20>

<!-- add-amp-controls -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="addampcontrols">add-amp-controls</a> ()
</td></tr><tr><td width=60></td><td>
add-amp-controls adds amplitude sliders to the control panel
for multichannel sounds so that each channel gets its own amplitude control slider.
To make this the default, add <code>(add-amp-controls)</code> to your initialization file.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- add-delete-option -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="adddeleteoption">add-delete-option</a>
</td></tr><tr><td></td><td>
add-delete-option adds a "Delete" (file) option to the File menu.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- add-find-to-listener -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>add-find-to-listener</em> ()
</td></tr><tr><td></td><td>
add-find-to-listener causes C-s and C-r in the listener to start a separate "Find" dialog.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- add-mark-pane -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="addmarkpane">add-mark-pane</a> 
</td></tr><tr><td></td><td>
add-mark-pane adds a pane to each channel giving the current mark locations (sample values).
These can be edited to move the mark, or deleted to delete the mark.
Here's a picture (it also shows <a href="#showsmptelabel">show-smpte-label</a>, 
<a href="#makecurrentwindowdisplay">make-current-window-display</a> (draw.scm), and <a href="#showdiskspace">show-disk-space</a>).
<br>
<img src="markpane.png" alt="mark pane" hspace=20 vspace=10>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- add-rename-option -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>add-rename-option</em>
</td></tr><tr><td></td><td>
add-rename-option adds a "Rename" (file) option to the File menu.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- add-text-to-status-area -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>add-text-to-status-area</em> ()
</td></tr><tr><td></td><td>
add-text-to-status-area puts a text widget in the notebook's status area
(the lower left portion of the main Snd window when using the -notebook invocation switch).
It returns the widget; you can write to it via XmTextFieldSetString.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- add-tooltip -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="addtooltip">add-tooltip</a> <code>widget tip</code>
</td></tr><tr><td></td><td>
add-tooltip adds a tooltip (also known as bubble-help) to a widget.  Once added,
set the variable with-tooltips to #f to turn it off.
<pre>
    (add-tooltip (cadr (<a class=quiet href="extsnd.html#channelwidgets">channel-widgets</a>)) "show the time domain waveform")
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- create-audit-dialog -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>create-audit-dialog</em> 
</td></tr><tr><td></td><td>
create-audit-dialog sets up a frequency and an amplitude
slider, the frequency running up to 20 KHz. Be careful with this thing!  If you push the
amplitude way up trying to hear some high frequency, you'll end up with a very unpleasant
after-effect in your ears, a sort of deaf feeling (which thankfully does wear off).
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- create-fmv-dialog -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="createfmvdialog">create-fmv-dialog</A> ()
</td></tr><tr><td></td><td>
create-fmv-dialog sets up a very simple dialog with amplitude, frequency, and fm-index controls on
the fm-violin (fmv.scm) running (interpreted!) in "real-time".
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- create-ssb-dialog -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="createssbdialog">create-ssb-dialog</a> 
</td></tr><tr><td></td><td>
create-ssb-dialog sets up an <a href="clm.html#ssb-am">ssb-am</a> + bandpass filter bank (like <a href="#ssbbank">ssb-bank</a> in dsp.scm) that can
change the pitch of a (well-behaved) sound without changing its duration.
It is important to get the "old freq" setting as close as possible to the
actual original frequency.  If this were slightly faster and smarter, I'd
replace the control panel expand option (which currently uses granular synthesis) with
this idea.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- disable-control-panel -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="disablecontrolpanel">disable-control-panel</a> <code>snd</code>
</td></tr><tr><td></td><td>
disable-control-panel does away with the control panel.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- display-scanned-synthesis -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="displayscannedsynthesis">display-scanned-synthesis</A> ()
</td></tr><tr><td></td><td>
display-scanned-synthesis opens a pane for experimenting with
scanned synthesis developed by Bill Verplank and Max Mathews.
It is not impossible that you can close this pane via <code>close-scanned-synthesis-pane</code>.
The synthesis code is also in <a href="#dspdocscanned">dsp.scm</a>.
<table border=0 hspace=20 vspace=10><tr><td>
<img src="scanned.png" alt="scanned synthesis dialog"></td><td>
<pre>
    top slider = mass,
    2nd slider = spring,
    3rd slider = damping,
    lower two are frequency and amplitude
    see <A HREF="http://www.billverplank.com/ScannedSynthesis.PDF">Bill Verplank's paper</A>
</pre>
</td></tr></table>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- display-widget-tree -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>display-widget-tree</em> <code>widget</code>
</td></tr><tr><td></td><td>
display-widget-tree displays the hierarchy of widgets beneath 'widget'.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- for-each-child -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="foreachchild">for-each-child</a> <code>w func</code><br>
<em class=emdef>find-child</em> <code>w name</code>
</td></tr><tr><td></td><td>
for-each-child applies 'func' the widget 'w' and to each widget in the hierarchy of widgets below it.
'func' takes one argument, the child widget.  for-each-child is used by find-child which searches
for a widget named 'name' belonging to 'w'.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- install-searcher -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>install-searcher</em> <code>proc</code>
</td></tr><tr><td></td><td>
install-searcher places
our own search procedure into the filter mechanism in the File:Open
dialog.  This has been superseded by the <a href="extsnd.html#addfilefilter">file-filter</a> mechanism now built into Snd.
<pre>
    (install-searcher (lambda (file) (= (<a class=quiet href="extsnd.html#mussoundsrate">mus-sound-srate</a> file) 44100)))
    (install-searcher (lambda (file) (= (<a class=quiet href="extsnd.html#mussoundchans">mus-sound-chans</a> file) 4)))
</pre>
There's a fancier version, install-searcher-with-colors, that distinguishes between categories
of files by using different colors.
<pre>
    (install-searcher-with-colors (lambda (file) #t))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- keep-file-dialog-open-upon-ok -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>keep-file-dialog-open-upon-ok</em> ()
</td></tr><tr><td></td><td>
keep-file-dialog-open-upon-ok changes File:Open so that clicking "ok" does not unmanage (dismiss) the dialog.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- load-font -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>load-font</em> <code>font-name</code>
</td></tr><tr><td></td><td>
load-font loads a font and returns a handle for it.

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(define new-font (<em class=red>load-font</em> "-*-helvetica-bold-r-*-*-14-*-*-*-*-*-*-*"))

(define show-hiho
  ;; show a red "hiho" in the helvetica bold font on a gray background
  (lambda (snd chn)
    (let ((ls (<a class=quiet href="extsnd.html#leftsample">left-sample</a> snd chn))
          (rs (<a class=quiet href="extsnd.html#rightsample">right-sample</a> snd chn)))
      (if (and (&lt; ls 1000)
               (&gt; rs 1000))
	  (let ((pos (<a class=quiet href="extsnd.html#xtoposition">x-&gt;position</a> (/ 1000.0 (<a class=quiet href="extsnd.html#srate">srate</a>))))
		(old-color (<a class=quiet href="extsnd.html#foregroundcolor">foreground-color</a>)))
	    (set! (<a class=quiet href="extsnd.html#foregroundcolor">foreground-color</a>) (<a class=quiet href="extsnd.html#makecolor">make-color</a> .75 .75 .75))
            (<a class=quiet href="extsnd.html#fillrectangle">fill-rectangle</a> pos 10 50 20)
	    (set! (<a class=quiet href="extsnd.html#foregroundcolor">foreground-color</a>) (<a class=quiet href="extsnd.html#makecolor">make-color</a> 1 0 0))
	    (if new-font (set! (<a class=quiet href="extsnd.html#currentfont">current-font</a>) new-font))
            (<a class=quiet href="extsnd.html#drawstring">draw-string</a> "hiho" (+ pos 5) 24)
	    (set! (<a class=quiet href="extsnd.html#foregroundcolor">foreground-color</a>) old-color))))))
</pre></td></tr></table>

</td></tr><tr><td colspan=2 height=16></td></tr>

<!-- main-index |makedropsite:drop sites -->
<!-- make-channel-drop-site -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="makedropsite">make-channel-drop-site</A> <code>snd chn</code><br>
<em class=emdef>set-channel-drop</em> <code>drop snd chn</code>
</td></tr><tr><td></td><td>
make-channel-drop-site shows how to add a drop site panel to a channel.  
set-channel-drop changes the channel's graph's drop function to 'drop', a 
function of 3 arguments, the dropped filename (a string) and the current sound index and
channel number.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- make-color-selector-dialog -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="makecolorselectordialog">make-color-selector-dialog</A><br>
<A class=def NAME="makefontselectordialog">make-font-selector-dialog</A>
</td></tr><tr><td></td><td>
snd-gtk.scm defines make-font-selector-dialog that creates a dialog
showing a list of available fonts with sample output, and a set of toggle buttons;
to start the dialog, click the Options:Choose Font menu option;
choose which of Snd's fonts you want to change, then click 'ok'. This isn't available
in snd-motif.scm because the corresponding font selection widget in Motif is still
under development.
The corresponding color selector is make-color-selector-dialog, but some of the
color variables don't actually work.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- make-hidden-controls-dialog -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="makehiddencontrolsdialog">make-hidden-controls-dialog</a> ()
</td></tr><tr><td></td><td>
make-hidden-controls-dialog adds a menu "Hidden controls" to the Option
menu.  If you activate it, it
creates a dialog that controls all the otherwise hidden control-panel variables.
The 'expand-hop' control sets the hop size (per grain), 'expand-length'
sets the grain length, 'expand-ramp' sets the slope of the grain amplitude envelope,
'contrast-amp' sets the prescaler for the contrast effect, 'reverb-feedback' sets the feedback
amount in the reverberator (affecting all the comb filter scalers), and 'reverb-lowpass' sets
the lowpass filter coefficient in the reverberator. 
</td></tr><tr><td colspan=2 height=16></td></tr>

<!-- main-index |makelevelmeter:level meters -->
<!-- make-level-meter -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="makelevelmeter">make-level-meter</A> <code>parent width height args :optional (resizable #t)</code><br>
<A class=def NAME="withlevelmeters">with-level-meters</A> <code>n</code>
<em class=emdef>display-level</em> <code>meter-data</code>
</td></tr><tr><td></td><td>
make-level-meter creates a VU meter of any width and height, returning
a list of information associated with that meter.  Pass that list to 
display-level to move the needle and the red bubble.  This meter
assumes you'll call it periodically so that the momentum of the needle and the viscosity of
the bubble will appear to behave naturally.  with-level-meters adds 'n'
of these meters to the topmost pane in the Snd main window,
then adds various <a href="extsnd.html#dachook">dac-hook</a> functions to display the current playback volume
in the respective meter.  
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- make-pixmap -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="makepixmap">make-pixmap</a> <code>widget strs</code>
</td></tr><tr><td></td><td>
make-pixmap turns an XPM-style description into pixmap.  Briefly an XPM pixmap description
is an array of strings; the first gives the size in pixels of the pixmap, and the number of colors;
the next set give characters followed by the color desired for that character; then comes the
pixmap itself using those characters.  The following defines a 16 X 12 arrow using 6 colors:
<pre>
    (define arrow-strs (list
    "16 12 6 1"
    " 	c None s None"
    ".	c gray50"
    "X	c black"
    "o	c white"
    "O	c yellow"
    "-      c ivory2 s basiccolor"
    "--------X---------"
    "---------X--------"
    "----------X-------"
    "-----------X------"
    "------------X-----"
    "XXXXXXXXXXXXXX----"
    "------------X-----"
    "-----------X------"
    "----------X-------"
    "---------X--------"
    "--------X---------"
    "-------X----------"))
</pre>
<code>(make-pixmap (cadr (<a class=quiet href="extsnd.html#mainwidgets">main-widgets</a>)) arrow-strs)</code> then creates the actual pixmap.
The 'widget' argument is needed to give us access to the current colormap and so on.
<code>(cadr (main-widgets))</code> is just Snd's outer shell, which will do the trick in most cases.
See new-backgrounds.scm for many examples.  The following example paints all of Snd's widgets using the
same background:
<pre>
  (for-each-child 
    (cadr (<a class=quiet href="extsnd.html#mainwidgets">main-widgets</a>))
    (lambda (w) 
      (XtSetValues w (list XmNbackgroundPixmap wd))
      (if (XmIsLabel w)
	  (let ((val (cadr (XtVaGetValues w (list XmNlabelType 0)))))
	    (if (= val XmPIXMAP)
		(XtVaSetValues w (list XmNlabelPixmap wd)))))))
</pre>
You can also use bitmaps:
<pre>
    (define right-arrow (list
       #x00 #x04 #x10 #x08 #x00 #x10 #x04 #x20 #x00 #x40 #xa5 #xbf
       #x00 #x40 #x04 #x20 #x00 #x10 #x10 #x08 #x00 #x04 #x00 #x00))
    
    (define (bitmap-&gt;pixmap widget bits width height)
      (XCreateBitmapFromData (XtDisplay widget) (XtWindow widget) bits width height))
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- make-variable-display -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="makevariabledisplay">make-variable-display</a> <code>page-name variable-name (type 'text) (range (list 0.0 1.0))</code><br>
<a class=def name="variabledisplay">variable-display</a> <code>val widget</code>
</td></tr><tr><td></td><td>
make-variable-display sets up a display point (a dialog) for an arbitrary expression which
is updated via variable-display.  The latter returns its argument, so it acts as a sort of
probe, picking out any arbitrary point in an instrument and displaying it as the
instrument is running.  Display points can be organized as pages in a notebook
widget:

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(define wid (make-variable-display "do-loop" "i*2" 'text))
(define wid1 (make-variable-display "do-loop" "i" 'text))
(do ((i 0 (1+ i)))
    ((= i 10))
  (variable-display (* (variable-display i wid1) 2) wid))
</pre></td></tr></table>

The 'type' argument to make-variable-display can be one of <code>'text</code>
<code>'scale</code>, <code>'graph</code>, <code>'spectrum</code>, or <code>'meter</code>.
It determines the kind of widget(s) used to display that variable.
The <code>'graph</code> and <code>'spectrum</code> cases create Snd channel displays,
accessible via a sound index (and channel 0); these respond to the
various channel-related functions such as <a href="extsnd.html#showtransformpeaks">show-transform-peaks</a>,
although you have to give the sound index explicitly:

<pre>
    (define wid2 (make-variable-display "do-loop" "x" 'spectrum))
    (set! (<a class=quiet href="extsnd.html#showtransformpeaks">show-transform-peaks</a> (car wid2)) #t)
</pre>

Each graph or spectrum display is placed in its own pane (this is a desperate
kludge), whereas all the others are ordered vertically in a single pane.
The <code>'scale</code> choice has an additional argument that gives the range of the
scale as a list (low high):

<pre>
    (define wid2 (make-variable-display "do-loop" "i*2" 'scale '(-1.0 1.0)))
</pre>

You can watch a generator's state on a sample-by-sample basis by
putting it in a text display:

<table border=0 cellpadding=10><tr><td>
<pre>
(define wid1 (make-variable-display "simp" "beg" 'text))
(define wid2 (make-variable-display "simp" "oscil" 'text))
(define wid3 (make-variable-display "simp" "outa" 'graph))
(<a class=quiet href="clm.html#definstrument">definstrument</a> (simp)
  (let* ((beg 0)
	 (dur 1000)
	 (end (+ beg dur))
	 (osc (<a class=quiet href="clm.html#make-oscil">make-oscil</a> 440.0)))
    (do ((i beg (1+ i)))
	((= i end))
      (variable-display i wid1)
      (variable-display
        (<a class=quiet href="clm.html#oscil">oscil</a> (variable-display osc wid2) 0.0)
       wid3))))
(simp)
</pre>
</td><td>
<img src="vardpy.png" alt="variable display">
</td></tr></table>

variable-display doesn't work within the run macro, but if you're debugging
an instrument, you're presumably not primarily concerned with optimization.
To clear display state, there's also variable-display-reset.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- mark-sync-color -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="marksynccolor">mark-sync-color</A> <code>new-color</code>
</td></tr><tr><td></td><td>
mark-sync-color uses the <a href="extsnd.html#drawmarkhook">draw-mark-hook</a> to set the color of sync'd marks.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- menu-option -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>menu-option</em> <code>menu-name</code>
</td></tr><tr><td></td><td>
menu-option returns the widget associated with a given menu item name ("Print" for example).
This is actually a bad idea since the menu names can change without warning.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- select-file -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>select-file</em> func 'title dir filter help'
</td></tr><tr><td></td><td>
select-file starts a file selection dialog, running 'func' if a file is selected:
<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
 (<a class=quiet href="extsnd.html#addtomenu">add-to-menu</a> 0 "Insert File" 
   (lambda () 
     (<em class=red>select-file</em>
       (lambda (filename)
         (<a class=quiet href="extsnd.html#insertsound">insert-sound</a> filename))
       "Insert File" "." "*" "file will be inserted at cursor")))
</pre></td></tr></table>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- set-root-window-color -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>set-root-window-color</em> <code>color</code>
</td></tr><tr><td></td><td>
set-root-window-color sets the background color of the root window.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- show-all-atoms -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>show-all-atoms</em>
</td></tr><tr><td></td><td>
show-all-atoms displays all current X atom names (there are several hundred of these atoms normally).
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- show-disk-space -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="showdiskspace">show-disk-space</A>
</td></tr><tr><td></td><td>
show-disk-space adds a label in the
minibuffer area which shows the current amount of disk space available
on the partition of the associated sound.  There's a picture of it in action above (add-mark-pane).
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- show-font-name -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>show-font-name</em> <code>font</code><br>
<em class=emdef>show-widget-font</em> <code>widget</code>
</td></tr><tr><td></td><td>
show-font-name shows the Snd-related name and the X-related name of each font in a font list
(it searches for the XA_FULL_NAME associated with an XFontStruct).
show-widget-font uses show-font-name to show what fonts are associated with a widget.
<pre>
    :<em class=typing>(show-widget-font (list-ref (<a class=quiet href="extsnd.html#mainwidgets">main-widgets</a>) 4))</em>   ; 4=listener
    <em class=listener>listener_font: Fixed</em>
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- show-sounds-in-directory -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="makesoundbox">make-sound-box</a> <code>name parent select-func peak-func sounds args</code><br>
<em class=emdef>show-sounds-in-directory</em> <code>(dir ".")</code>
</td></tr><tr><td></td><td>
make-sound-box makes a container of sound file icons, each icon
containing a little sketch of the waveform, the length of the
file, and the filename.  What happens when an icon is selected
is up to 'select-func'.  However, if you drag (via 
button 2) the icon to the menubar, that sound is opened,
and if you drag it to a channel graph, it is mixed at the
mouse location in that channel.
'select-func' called when sound icon is selected; it is passed the sound file's name.
'peak-func' (if any) tells the soundbox code where to find any associated <a href="#peakenvdoc">peak env</a> files.
'sounds' is list of sound file names.
'args' is list of resource settings for each icon.

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(<em class=red>make-sound-box</em> "sounds"
		(list-ref (<a class=quiet href="extsnd.html#mainwidgets">main-widgets</a>) 3)
		(lambda (file) 
                  (<a class=quiet href="extsnd.html#sndprint">snd-print</a> file))
		peak-env-info-filename ; this points to ~/peaks in my case
		(list "oboe.snd" "pistol.snd" "cardinal.snd" "storm.snd")
		'())
</pre></td></tr></table>

show-sounds-in-directory calls make-sound-box, filling it with
any sounds found in the directory passed as its argument (which defaults to 
the current directory).
<br>
<img src="soundbox.png" alt="show-sounds-in-directory" hspace=20 vspace=10>

</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- show-smpte-label -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="showsmptelabel">show-smpte-label</a> <code>on-or-off</code>
</td></tr><tr><td></td><td>
show-smpte-label shows the current SMPTE frame number in a box
in the upper left corner of the graph (see the picture above under add-mark-pane).
To turn off the SMPTE labelling, call show-smpte-label with an argument of #f.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- snd-clock-icon -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>snd-clock-icon</em> <code>snd hour</code>
</td></tr><tr><td></td><td>
snd-clock-icon replaces Snd's hourglass with a (very primitive) clock.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- upon-save-yourself -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="uponsaveyourself">upon-save-yourself</a> <code>thunk</code>
</td></tr><tr><td></td><td>
upon-save-yourself causes 'thunk' (a function of no arguments) to be called if the window
manager sends a SAVE_YOURSELF message.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- upon-take-focus -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>upon-take-focus</em> <code>thunk</code>
</td></tr><tr><td></td><td>
upon-take-focus causes 'thunk' (a function of no arguments) to be called
whenever Snd receives focus from the window manager.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- use-pan-mix-in-mix-menu -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="usepanmixinmixmenu">use-pan-mix-in-mix-menu</a> ()
</td></tr><tr><td></td><td>
use-pan-mix-in-mix-menu changes the File:Mix dialog to use <a href="#panmix">pan-mix</a> rather than <a href="extsnd.html#mix">mix</a>.
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- with-minmax-button -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>with-minmax-button</em>
</td></tr><tr><td></td><td>
with-minmax-button adds an open/close button to each sound's pane.  To activate it:
<pre>
    (add-hook! <a class=quiet href="extsnd.html#afteropenhook">after-open-hook</a> with-minmax-button)
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- zync -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>unzync</em> ()<br>
<em class=emdef>zync</em> ()
</td></tr><tr><td></td><td>
The pair zync and unzync cause the
y-axis zoom sliders of a multichannel file to move together (zync) or separately (unzync, the default).
</td></tr><tr><td colspan=2 height=16></td></tr>

</table>

<table bgcolor="aliceblue" border=0><tr>
<td>
<pre>see also: <a href="grfsnd.html#sndwithmotif" onmouseover="return escape('Motif extensions from xm.c')">motif</a> <a href="grfsnd.html#sndwithgtk" onmouseover="return escape('Gtk extensions from xg.c')">gtk</a> <a href="extsnd.html#snddialogs" onmouseover="return escape('customizing the built-in dialogs, etc')">dialogs</a> <a href="extsnd.html#graphics" onmouseover="return escape('write your own sound display functions or customize Snd\'s')">graphics</a> <a href="#menusdoc" onmouseover="return escape('various dialogs')">menus</a> <a href="#makecurrentwindowdisplay" onmouseover="return escape('draw thumbnail sketch in upper right corner')">make-current-window-display</a> <a href="#popupdoc" onmouseover="return escape('context-sensitive popup menus')">popup</a> <a href="#enveddoc" onmouseover="return escape('envelope editors')">enved</a> <a href="libxm.html" onmouseover="return escape('library that ties Motif and Gtk into Snd')">libxm</a>
</pre>
</td></tr></table>


<br>
<br>


<!-- ---------------------------------------- FILE: snd-test and event ---------------------------------------- -->

<A NAME="sndtestdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>snd-test and event</h2></td></tr></table>

<p>
snd-test.scm and snd-test.rb are test suites for Snd. The simplest use is:
</p>
<pre>
    snd -l snd-test
</pre>
<p>
which will run all the tests, assuming you have the various sound files it is expecting to find.
You can run a particular test with:
</p>
<pre>
    snd -l snd-test 23
</pre>
<p>which runs test 23. 
snd-test is primarily useful to non-developers as a source of
a huge number of examples. 
event.scm has functions used by snd-test.scm to exercise the user interface.
</p>


<br><br>



<!-- ---------------------------------------- FILE: sndwarp ---------------------------------------- -->

<A NAME="sndwarpdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>sndwarp</h2></td></tr></table>

<p>
This is a translation from CLM of Bret Battey's sndwarp instrument, itself based on Richard Karpen's sndwarp csound generator. 
It is similar to <a href="#expsrc">expsrc</a>.
</p>
<pre>
    <a class=def name="sndwarp">sndwarp</a> beg dur file 
	 :key (amp 1.0)
	      (amp-env '(0 1 100 1))  ; amplitude envelope
	      (stretch 1.0)           ; time stretch -- 2.0 -> twice as long
	      (srate 1.0)             ; src -- 0.5 -> octave down
	      (inputbeg 0.0)          ; source file start point
	      (wsize 0.1)             ; size of windows in seconds
	      (randw 0.02)            ; randomness of wsize
	      (overlaps 15)           ; window overlaps per sec
	      (time-ptr #f)           ; #f=stretch mode, #t=time-ptr mode
	      (scale-time-ptr #f)     ; #f=absolute, #t=rescale
	      (zero-start-time-ptr #f); #t=start at 0
	      (window-offset #f)      ; #f=spread windows evenly
	      (loc 0.5)               ; stereo loc, 0=left, 1=right
	      (rev 0.1)               ; reverb amount
	      (srcwidth 5)            ; src interpolation width
</pre>
<p>
Many of the parameters can also be envelopes.  The source has commentary
which I'll slightly paraphrase here for convenience.
'time-ptr' is a flag that determines whether stretching or time-pointer mode
is to be used in interpreting the 'stretch' parameter.
In stretch mode, the value of 'stretch' scales the time 
of the sound. For example, a value of 2 will stretch the sound 
In time-ptr mode, the value(s) of 'stretch' are <a href="clm.html#readin">readin</a> pointers
into the soundfile. For example, to read through a file
backwards from 2 seconds at half speed, use a 
stretch envelope such as '(0 2 1 0) with a 4 second note duration.
'scale-time-ptr' is a 
flag that determines whether the time-ptr envelope is
interpreted in absolute seconds or rescaled to fit the 
duration of the input sound file.
'zero-start-time-ptr' is a flag that determines (in time-ptr mode) whether
the first section of the windows start at 
time-ptr = 0.
'window-offset' is a flag that determines how the windows are offset
in time. 
</p>
<pre>
    (with-sound () (sndwarp 0 1 "oboe.snd"))
    (with-sound () (sndwarp 0 4 "oboe.snd" :stretch 2.0 :srate 0.5))
</pre>

<table bgcolor="aliceblue" border=0><tr>
<td>
<pre>see also: <a href="#clmexpsrc" onmouseover="return escape('clm-ins version of expsrc')">clm-expsrc</a> <a href="#expsrc" onmouseover="return escape('granular synthesis to stretch sound')">expsrc</a> <a href="#pvocdoc" onmouseover="return escape('phase-vocoder')">pvoc</a> <a href="#rubberdoc" onmouseover="return escape('phase-locked time stretch')">rubber</a> <a href="#ssbbank" onmouseover="return escape('use ssb-am for time stretch')">ssb-bank</a>
</pre>
</td></tr></table>

<br>
<br>



<!-- ---------------------------------------- FILE: spectr ---------------------------------------- -->

<A NAME="spectrdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>spectr</h2></td></tr></table>

<p>The spectr files were translated by Michael Scholz from CLM's spectr.clm.  They contain a large 
set of instrument steady-state spectra, gathered many years ago (before 1976) by James A Moorer.
The variable names are taken from the file names used by JAM, but by the time I got around to
rescuing the data from mouldering magtapes, he had long since moved on, so I don't actually
know what instrument some of the labels refer to. The data is in the form of a bunch of lists,
each given a name:
</p>
<pre>
    (define  trp-gs5 '(  1.02 .0114  2.02 .0346  3.02 .0045  4.04 .0013  5.06 .0002))
</pre>
<p>
which (I think) refers to a trumpet playing the note gs5.  The first number is the harmonic,
the second its amplitude, the third the next harmonic, then its amplitude, and so on.
These spectra can be used directly in the instrument <a href="#spectra">spectra</a> in clm-ins.scm.
</p>

<table bgcolor="aliceblue" border=0><tr>
<td>
<pre>see also: <a href="#twotab" onmouseover="return escape('interpolate between spectra')">two-tab</a>
</pre>
</td></tr></table>

<br>
<br>


<!-- ---------------------------------------- FILE: stochastic ---------------------------------------- -->

<A NAME="stochasticdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>stochastic</h2></td></tr></table>

<p>stochastic is Bill Sack's implementation of Xenakis' Dynamic Stochastic Synthesis as heard in his GENDY3, S.709, Legende d'Eer, etc.
</p>
<pre>
    <em class=emdef>stochastic</em> start dur :key
               (amp .9)       ; overall amplitude
               (bits 16)      ; resolution of the wave's amplitude dimension
               (xmin 1)       ; minimum number of samples between time breakpoints, must be &gt;= 1
               (xmax 20)      ; maximum number of samples between time breakpoints
               (xwig 0)       ; amplitude applied to random walk function in time dimension
               (xstep 1)      ; quantization of freedom in time dimension, in samples, minimum: 1
               (ywig 0)       ; amplitude applied to random walk function in amplitude dimension, as %amp
               (xfb 0)        ; FIR filter
               (init-array '((10 0) (10 1) (10 0) (10 -.7) (10 0) (10 .5) 
                             (10 0) (10 -.3) (10 0) (10 .2) (10 0) (10 -.1)))
                              ; initial x and y breakpoints for wave,
                              ;    x values must be integers &gt;= 1, y values between -1.0 and 1.0
</pre>
<p>stochastic.ins in the CLM tarball has an elaborate Common Music-based example.
Here is one that is much simpler, but very loud:
</p>
<pre>
    (with-sound () (stochastic 0 10 :xwig .25 :ywig 10.0))
</pre>

<br>


<!-- ---------------------------------------- FILE: strad ---------------------------------------- -->

<A NAME="straddoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>strad</h2></td></tr></table>

<p>strad.scm is a translation (by Michael Scholz) of CLM's strad.ins (by Juan Reyes).
It implements a physical model of a bowed string with stiffness.
</p>

<br>


<!-- ---------------------------------------- FILE: v and fmv ---------------------------------------- -->

<A NAME="vdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>v and fmv</h2></td></tr></table>

<!-- main-index |vdoc:fm-violin -->

<p>The <A NAME="fmviolin">fm violin</A> was my favorite instrument while working in the 70's and 80's,
primarily on the Samson box.  It was developed in Mus10 (ca 1977) based on ideas of John Chowning.
</p>
<pre>
<em class=emdef>fm-violin</em> startime dur frequency amplitude :key
	    (fm-index 1.0)                        ; scales all indices
	    (amp-env '(0 0  25 1  75 1  100 0))   ; amplitude envelope
	    (periodic-vibrato-rate 5.0) 
	    (random-vibrato-rate 16.0)            ; jitter added to vibrato
	    (periodic-vibrato-amplitude 0.0025) 
	    (random-vibrato-amplitude 0.005)
	    (noise-amount 0.0)                    ; noise added to modulation
	    (noise-freq 1000.0)
	    (ind-noise-freq 10.0)                 ; index envelope jitter
	    (ind-noise-amount 0.0)
	    (amp-noise-freq 20.0)                 ; amplitude envelope jitter
	    (amp-noise-amount 0.0)
	    (gliss-env '(0 0  100 0))             ; frequency envelope
	    (glissando-amount 0.0) 
	    (fm1-env '(0 1  25 .4  75 .6  100 0)) ; 1:1 modulator amp (fm index) env
	    (fm2-env '(0 1  25 .4  75 .6  100 0)) ; 3:1 mod env
	    (fm3-env '(0 1  25 .4  75 .6  100 0)) ; 4:1 mod env
	    (fm1-rat 1.0)                         ; 1:1 actual mod:carrier freq ratio
	    (fm2-rat 3.0)	                  ; 3:1 same
	    (fm3-rat 4.0)                         ; 4:1 same
	    (fm1-index #f)                        ; 1:1 mod local index scaler
	    (fm2-index #f)                        ; 3:1 same
	    (fm3-index #f)                        ; 4:1 same
	    (degree 0)
	    (distance 1.0)
	    (reverb-amount 0.01)
	    (base 1.0)                            ; amp env base (1.0 = line segments)
</pre>
<p>Most of these parameters are for special cases; normally you need only:
</p>
<pre>
  Scheme:    (with-sound () (fm-violin 0 1 440 .1))
  Ruby:      with_sound() do fm_violin(0, 1, 440, .1, [[:fm_index, 2.0]]) end
</pre>
<p>
fm-violin sets up several parallel modulators of one carrier (see <A HREF="fm.html">fm.html</A>
for details, or (ah nostalgia...) 
Schottstaedt,  "The Simulation of Natural Instrument Tones Using Frequency Modulation with a Complex Modulating Wave", CMJ vol 1 no 4 1977 p46-50). 
The modulators
themselves are modulated (vibrato, noise, etc). The FM indices were chosen to try
to mimic violin or cello sounds over a wide range of frequencies.
The various envelope "jitter" parameters set up slow moving random changes in
the associated envelopes; in some case this can produce a much richer sound.
There's no limit on what this instrument can do; nearly all my compositions in the 80's used
it.  To hear some of the effects, load fmviolin.clm (it is a CLM notelist, but it is
completely compatible with Snd/Scheme).
</p>


<p>fmv.scm (or v.rb in Ruby) implements the fm-violin as a CLM-style generator, making it possible
to call the violin anywhere a generator could be called; since each call on the fm-violin
function produces the next sample of the given violin, this form of the fm-violin is easy
to call in "real-time" situations.  Any other CLM-style instrument could
be rewritten in the same form.
</p>

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
  <em class=emdef>make-fm-violin</em>
    frequency amplitude :key (fm-index 1.0) (amp-env #f) 
    (periodic-vibrato-rate 5.0) (random-vibrato-rate 16.0)
    (periodic-vibrato-amplitude 0.0025) (random-vibrato-amplitude 0.005) 
    (noise-amount 0.0) (noise-freq 1000.0)
    (ind-noise-freq 10.0) (ind-noise-amount 0.0) 
    (amp-noise-freq 20.0) (amp-noise-amount 0.0) (gliss-env #f)
    (fm1-env #f) (fm2-env #f) (fm3-env #f) 
    (fm1-rat 1.0) (fm2-rat 3.0) (fm3-rat 4.0) 
    (fm1-index #f) (fm2-index #f) (fm3-index #f) (base 1.0)

  <em class=emdef>fm-violin</em> gen
  <em class=emdef>fm-violin-ins</em> [same args as original violin in v.scm]
</pre></td></tr></table>

<p>fm-violin-ins shows how this generator can be fitted into the original fm-violin code.
The make-fm-violin function uses the optional arguments support from Guile (optargs.scm, loaded
via <code>(use-modules (ice-9 optargs))</code>). The plethora of arguments is an historical artifact;
normally only a few of them are used at a time.  There are two examples of calling this generator
in fmv.scm, the simpler one being:
</p>

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(define test-v 
  (lambda (beg dur freq amp amp-env)
    (let ((v (<em class=red>make-fm-violin</em>
	      freq amp 
	      :amp-env (let ((e (<a class=quiet href="clm.html#make-env">make-env</a> :envelope (or amp-env '(0 0 1 1 2 0)) 
					  :scaler amp 
					  :end dur)))
			 (lambda () (<a class=quiet href="clm.html#env">env</a> e)))))
	  (data (<a class=quiet href="extsnd.html#channeltovct">channel-&gt;vct</a> beg dur)))
      (do ((i 0 (1+ i)))
	  ((= i dur))
	(<a class=quiet href="extsnd.html#vctset">vct-set!</a> data i (+ (<a class=quiet href="extsnd.html#vctref">vct-ref</a> data i)
			    (<em class=red>v</em>))))
      (<a class=quiet href="extsnd.html#setsamples">set-samples</a> beg dur data))))
</pre></td></tr></table>

<p>Here we are setting up an fm-violin generator (via make-fm-violin), then
calling it 'dur' times, mixing its output into the current data (this could
also use mix-vct and so on).  The generator is called via <code>(v)</code>.
As can be seen here, each envelope is treated as a function called on each sample
very much like the "as-needed" input in src or granulate; the envelopes could actually be any
arbitrary function you like (see test-v1 in fmv.scm which uses an oscillator as one of
the fm index envelopes).  One complication in some "real-time" situations is that
you don't know in advance how long a note will be; in this case, the envelope
generating functions should have attack and decay ramps, triggered by note-on and
note-off; once the ramp has reached its end point, the end value should be held;
the note itself should be called until it has had time to ramp off.
Another example is <a href="#createfmvdialog">create-fmv-dialog</a> in snd-motif.
</p>

<p>
I can't resist including an historical digression.
Here is a Mus10 version of fm-violin (in this code ":=" is used in place of the original SAIL left arrow character,
and so on):
</p>
<table border=0 hspace=20><tr><td bgcolor="#fafafa"><pre><small>
ARRAY GlissFunc, DecayFunc, AttackFunc, SineWave, AmpFunc(512);
SYNTH(Sinewave); 1,1 999;
SEG(AmpFunc); 0,0 1,25 1,50 0,75 0,100;
SEG(GlissFunc);0,1 1,50, 0,100;
SEG(AttackFunc);0,0 1,100;
SEG(DecayFunc);1,1 .6,5 .3,10 .15,25 .07,50 0,100;
	
INSTRUMENT VN1;
VARIABLE Reset1,Noise,/NewMag,OtherFreq,/Gliss,Distance,Stereo,
	Freq,Amp1,Amp2,Duration,AttackTime,DecayTime,Memory1,
	Index1,Index2,Index3,scFreq,DecayLength,Switch1,Switch2,
	/Mod1,/Mod2,/Mod3,/Env,/Att,/Vibrato,IMult,/Snd,
	/Flutter,VibRate,VibAmp,/Ramp,/Decay,VibSwitch,LogFreq,
	GlissLength,Bowing,DecayCall,VibCall,GlissCall,RampCall;
	
Memory1:=1;
	
I_ONLY BEGIN
  Duration:=P2;
  Freq:=P3;
  Amp1:=P4;
  Amp2:=P5;
  OtherFreq:=P6;
  IF Freq&gt;=C THEN Freq:=Freq+Freq/100;
  IF Freq&lt;C THEN Freq:=Freq-20/Freq;
	
  Switch1:=P14;
  Switch2:=1-Switch1;
  IMult:=P7-(Switch2/4);
  VibSwitch:=P8;
  Bowing:=P9;
	
  Distance:=P10;
  Stereo:=P11;
  Noise:=P12;
  GlissLength:=P13;
  LogFreq:=ALOG(Freq);
  
  DecayCall:=VibCall:=RampCall:=GlissCall:=20;
  IF Amp1=Amp2 THEN RampCall:=SRATE;
  IF Freq=OtherFreq THEN GlissCall:=SRATE;
  IF VibSwitch=0 THEN VibCall:=SRATE;
  IF Switch1=1 THEN DecayCall:=SRATE;
	
  Vibrate:=5.25+RAND*.75;
  VibAmp:=.006+RAND*.001;
	
  IF Bowing=0
    THEN
      IF Memory1&gt;.08
	THEN
	  BEGIN
	  DecayTime:=.7;
	  AttackTime:=.2;
	  END
	ELSE
	  BEGIN
	  DecayTime:=.7;
	  AttackTime:=.05;
	  Noise:=0;
	  END
    ELSE
      IF Memory1&gt;.05
	THEN
	  BEGIN
	  DecayTime:=.05;
	  AttackTime:=.2;
	  END
	ELSE
	  BEGIN
	  DecayTime:=.05;
	  AttackTime:=.05;
	  Noise:=0;
	  END;
	
  Memory1:=DecayTime;
	
  IF AttackTime+DecayTime&gt;=Duration
    THEN
      BEGIN
      AttackTime:=Duration*AttackTime;
      DecayTime:=DecayTime*Duration;
      IF AttackTime&lt;=.05 THEN AttackTime:=Duration-DecayTime-.01;
      END;
	
  ScFreq:=Freq*MAG;
  DecayLength:=1000/Freq;
  IF Switch1=0 THEN Noise:=.1;
  Index1:=7.5*IMult/LogFreq;
  Index2:=5/SQRT(Freq);
  Index3:=IMult*30*(8.5-LogFreq)/Freq;
END;
	
Decay:=Switch1+EXPEN[DecayCall](Switch2,MAG*20/DecayLength,DecayFunc);
ENV:=Switch2+LINEN[20](Switch1,AttackTime/20,DecayTime/20,Duration/20,AmpFunc,Reset1:=0);
Ramp:=Amp1+NOSCIL[RampCall](Amp2-Amp1,20*MAG/Duration,AttackFunc);
Gliss:=Freq+EXPEN[GlissCall](OtherFreq-Freq,20*MAG/GlissLength,GlissFunc);
FLutter:=RANDI[VibCall](1,200*Mag);
Vibrato:=NOSCIL[VibCall](ENV,Vibrate*MAG*20,SineWave);
Att:=1-EXPEN[20](1,MAG*640,AttackFunc);
	
NewMag:=(1+Flutter*.005)*(1+Vibrato*VibAmp)*(1+RANDI(Noise*Att,2000*Mag))*Gliss*Mag;
	
Mod1:=NOSCIL(Decay*ScFreq*(Att+Index1),NewMag,Sinewave);
Mod2:=NOSCIL(Decay*ScFreq*(Att+Index2),4*NewMag,Sinewave);
Mod3:=NOSCIL(Decay*ScFreq*(Att+Index3),3*NewMag,Sinewave);
Snd:=ZOSCIL(Decay*ENV*Ramp,NewMag+Mod1+Mod2+Mod3,Sinewave);
OUTA:=OUTA+Snd*0.5;
END;
</small></pre></td></tr></table>

<p><small>
This instrument required about 60 seconds of computing on a PDP-10
(a $250,000 minicomputer) for 1 second of sound (our normal sampling
rate was 12800).  Since the PDP was massively time-shared, 60 seconds
of computing could involve many minutes of sitting around watching
AI scientists play Space War.
Mus10 was an extension of Music V for the PDP-10 family of computers.
To give a feel for how one worked in those days, here's a brief quote from the Mus10 manual (by Tovar and
Leland Smith, May 1977):
</small></p>

<table border=0 hspace=20><tr><td bgcolor="#fafafa"><pre><small>
The following generates  1 second of a  440 Hz sine wave  followed by
1/2 sec. of a  660Hz sine wave. The output goes to a file, MUSIC.MSB,
which is written on DSKM.  

COMMENT Fill array with sine wave;
ARRAY SINETABLE[511];
FOR I:=0 STEP 1 UNTIL 511 DO SINETABLE[I]:=SIN(2*PI/512);

INSTRUMENT SINE;
  COMMENT Generate simple sine wave.  P4 = Amplitude, P3 = frequency;
  OUTA:=OUTA+OSCIL(P4,P3*MAG,SINETABLE);
  END;

COMMENT Now, generate the sound;
PLAY ;
  SIMP 0, 1, 440, 1000;
  SIMP 1, 1/2, 660, 1000;
  FINISH;
</small></pre></td></tr></table>

<p><small>
The computation involved was considered so burdensome, that the names of
the main users were posted in the AI lab halls, apparently to try to
get us to go away.  I was normally the primary user (in terms of computrons) for the entire lab, and I had no intention
of going away.  
In the Samson box world, this (in its initial "chorus" version) was:
</small></p>

<table border=0 hspace=20><tr><td bgcolor="#fafafa"><pre><small>
Instrument(Violin);
RECORD_POINTER(seg) nullfunc;
INTEGER ARRAY gens[1:4],indgens[1:6], GensA[1:4],AmpGens[1:2];
					! synthesizer addresses;
REAL ARRAY ratsA[1:4],Indrats[1:6],ratsB[1:4],AmpRats[1:2];
					! envelope data;
INTEGER ModGens1Sum,i,FuncOffSet,k,GenOutLoc,GenInLoc,ModGens2Sum,x1,x2;

Pars(&lt;(InsName,Beg,Dur,Freq,Amp,Function AmpFunc,Function IndFunc,IndMult,
	SkewMult,Nothing,PcRev,No11,No12,No13,Function SkewFunc)&gt;);
					! the parameters of this instrument;

Dbugit(Pns);				! debugging aid;
GenOutLoc:=CASE (Pn[1] MOD 4) OF (Outma,Outmb,Outmc,Outmd);
					! OUTMA is channel 1, OUTMB channel 2, etc;
if freq&gt;srate/3 then return;		! note too high, so leave it out;
x1:=3;					! modulating frequency checks;
x2:=4;					! (we want them less than srate/2);
If x1*freq&gt;srate/2 Then x1:=1;
If x2*freq&gt;srate/2 then x2:=1;
amp:=Amp/2;				! two carriers, so halve the amplitude;

waiter(Beg);				! wait for the beginning of the note;

indRats[1]:=(x1*Freq*IndMult*((8.5-log(freq))/(3+(freq/1000)))*4/srate) MIN .999;
indRats[2]:=(x2*Freq*IndMult*(1/(freq^.5))*4/srate) MIN .999;
indRats[3]:=(freq*IndMult*(5/log(freq))*4/srate) MIN .999;
indrats[4]:=indrats[1]; indrats[5]:=indrats[2]; indrats[6]:=indrats[3];

ratsA[1]:=x1; ratsA[2]:=x2;     ratsA[3]:=1;     ratsA[4]:=1;	
ratsB[1]:=x1+.002; ratsB[2]:=x2+.003;     ratsB[3]:=1.002;     ratsB[4]:=1;	
					! this is the skewing for the chorus effect;
Gens[1]:=Osc(Pns,ModGens1Sum);		! now set up the oscillators;
Gens[2]:=Osc(Pns,ModGens1Sum);
Gens[3]:=Osc(Pns,ModGens1Sum);
Gens[4]:=Osc(Pns,genInLoc,ModGens1Sum);	! carrier 1;

GensA[1]:=Osc(Pns,ModGens2Sum);
GensA[2]:=Osc(Pns,ModGens2Sum);
GensA[3]:=Osc(Pns,ModGens2Sum);
GensA[4]:=Osc(Pns,genInLoc,ModGens2Sum);! carrier 2;

indgens[1]:=gens[1];   indgens[2]:=gens[2];  indgens[3]:=gens[3];
indgens[4]:=gensA[1];   indgens[5]:=gensA[2];  indgens[6]:=gensA[3];
					! set up envelope addressing;

ModSig(Pns,GenOutLoc,GenInLoc,1-pcRev);	! send signal to DACs;
ModSig(Pns,RevIn,GenInLoc,pcRev);	! and signal to reverberator;

AmpGens[1]:=Gens[4]; AmpGens[2]:=GensA[4]; AmpRats[1]:=1; AmpRats[2]:=1;
					! now add the envelopes;
AddArrEnv(Pns,AmpGens,2,"A",0,Amp/2,AmpFunc,AmpRats);
AddArrEnv(Pns,IndGens,6,"A",0,1,IndFunc,Indrats);
AddArrEnv(Pns,Gens,4,"F",freq,Freq*skewmult,skewfunc,ratsA,
	5,.011,.011,nullfunc,6,.017,.017,nullfunc,0,0);
AddArrEnv(Pns,GensA,4,"F",freq,Freq*skewmult,skewfunc,ratsA,
	6,.010,.010,nullfunc,5,.017,.017,nullfunc,1,0);
End!Instrument(Pns);			! deallocation;
</small></pre></td></tr></table>

<p><small>
The Sambox version eventually became incredibly complicated, mainly to
try to handle note list problems in the instrument.  The Samson box could
run about 5 or 6 of these in "real-time", similar to a modern-day
500 MHz Pentium running CLM.
The parallel in the Sambox world to the SIMP example above is (this is
taken from SAMBOX.BIL, November 1984):
</small></p>

<table border=0 hspace=20><tr><td bgcolor="#fafafa"><pre><small>
    Instrument(Simp);
    Integer Gen1;
    Gen1:=Osc(Pns,OutA,Zero,SineMode,0,0,Pn[3]);
    AddEnv(Pns,Gen1,"A",0,Pn[4],Pf[5]);
    End_Instrument(Pns);
</small></pre></td></tr></table>

<p><small>The CLM version of this is:</small></p>

<table border=0 hspace=20><tr><td bgcolor="#fafafa"><pre><small>
(<a class=quiet href="clm.html#definstrument">definstrument</a> simp (start-time duration frequency amplitude
                     &amp;optional (amp-env '(0 0 50 1 100 0)))
  (multiple-value-bind (beg end) (<a class=quiet href="clm.html#timestosamples">times-&gt;samples</a> start-time duration)
    (let ((s (<a class=quiet href="clm.html#make-oscil">make-oscil</a> frequency))
          (amp (<a class=quiet href="clm.html#make-env">make-env</a> amp-env :scaler amplitude :duration duration)))
      (run
       (loop for i from beg below end do
         (<a class=quiet href="clm.html#outa">outa</a> i (* (<a class=quiet href="clm.html#env">env</a> amp) (<a class=quiet href="clm.html#oscil">oscil</a> s))))))))
</small></pre></td></tr></table>

<p><small>
In CLM, the fm-violin became (fm.html, 1989):
</small></p>

<table border=0 hspace=20><tr><td bgcolor="#fafafa"><pre><small>
(<a class=quiet href="clm.html#definstrument">definstrument</a> violin (beg end frequency amplitude fm-index)
  (let* ((frq-scl (hz-&gt;radians frequency))
         (maxdev (* frq-scl fm-index))
         (index1 (* maxdev (/ 5.0 (log frequency))))
         (index2 (* maxdev 3.0 (/ (- 8.5 (log frequency)) (+ 3.0 (/ frequency 1000)))))
         (index3 (* maxdev (/ 4.0 (sqrt frequency))))
         (carrier (<a class=quiet href="clm.html#make-oscil">make-oscil</a> frequency))
         (fmosc1 (<a class=quiet href="clm.html#make-oscil">make-oscil</a> frequency))
         (fmosc2 (<a class=quiet href="clm.html#make-oscil">make-oscil</a> (* 3 frequency)))
         (fmosc3 (<a class=quiet href="clm.html#make-oscil">make-oscil</a> (* 4 frequency)))
         (ampf  (<a class=quiet href="clm.html#make-env">make-env</a> '(0 0 25 1 75 1 100 0) :scaler amplitude))
         (indf1 (<a class=quiet href="clm.html#make-env">make-env</a> '(0 1 25 .4 75 .6 100 0) :scaler index1))
         (indf2 (<a class=quiet href="clm.html#make-env">make-env</a> '(0 1 25 .4 75 .6 100 0) :scaler index2))
         (indf3 (<a class=quiet href="clm.html#make-env">make-env</a> '(0 1 25 .4 75 .6 100 0) :scaler index3))
         (pervib (<a class=quiet href="clm.html#make-triangle-wave">make-triangle-wave</a> :frequency 5 :amplitude (* .0025 frq-scl)))
         (ranvib (make-randi :frequency 16 :amplitude (* .005 frq-scl)))
         (vib 0.0))
    (run
     (loop for i from beg to end do
       (setf vib (+ (<a class=quiet href="clm.html#triangle-wave">triangle-wave</a> pervib) (randi ranvib)))
       (<a class=quiet href="clm.html#outa">outa</a> i (* (<a class=quiet href="clm.html#env">env</a> ampf)
                  (<a class=quiet href="clm.html#oscil">oscil</a> carrier
                         (+ vib 
                            (* (<a class=quiet href="clm.html#env">env</a> indf1) (<a class=quiet href="clm.html#oscil">oscil</a> fmosc1 vib))
                            (* (<a class=quiet href="clm.html#env">env</a> indf2) (<a class=quiet href="clm.html#oscil">oscil</a> fmosc2 (* 3.0 vib)))
                            (* (<a class=quiet href="clm.html#env">env</a> indf3) (<a class=quiet href="clm.html#oscil">oscil</a> fmosc3 (* 4.0 vib)))))))))))
</small></pre></td></tr></table>

<p><small>or in its actual (non-simplified) form:
</small></p>

<table border=0 hspace=20><tr><td bgcolor="#fafafa"><pre><small>
(defun bit20 (x)			;Samson box modifier got 20 bit int interpreted as fraction 
  (if (&gt;= x (expt 2 19))                ;(keep fm-violin compatible with old note lists)
      (float (/ (- x (expt 2 20)) (expt 2 19)))
    (float (/ x (expt 2 19)))))

(defun make-frobber-function (beg end frobl)
  (let ((result (list beg))
	(val (bit20 (cadr frobl))))
    (loop for x in frobl by #'cddr and 
              y in (cdr frobl) by #'cddr do
      (when (and (&gt;= x beg)
		 (&lt;= x end))
	(push val result)
	(push x result)
	(setf val (bit20 y))))
    (push val result)
    (push end result)
    (push val result)
    (nreverse result)))

(<a class=quiet href="clm.html#definstrument">definstrument</a> fm-violin 
  (startime dur frequency amplitude &amp;key
	    (fm-index 1.0)
	    (amp-env '(0 0  25 1  75 1  100 0))
	    (periodic-vibrato-rate 5.0) 
            (random-vibrato-rate 16.0)
	    (periodic-vibrato-amplitude 0.0025) 
            (random-vibrato-amplitude 0.005)
	    (noise-amount 0.0) (noise-freq 1000.0)
	    (ind-noise-freq 10.0) (ind-noise-amount 0.0)
	    (amp-noise-freq 20.0) (amp-noise-amount 0.0)
	    (gliss-env '(0 0  100 0)) (glissando-amount 0.0) 
	    (fm1-env '(0 1  25 .4  75 .6  100 0)) 
            (fm2-env '(0 1  25 .4  75 .6  100 0)) 
            (fm3-env '(0 1  25 .4  75 .6  100 0))
	    (fm1-rat 1.0) (fm2-rat 3.0)	 (fm3-rat 4.0)                    
	    (fm1-index nil) (fm2-index nil) (fm3-index nil)
	    (base nil) (frobber nil)
	    (reverb-amount 0.01)
	    (index-type :violin)
	    (degree nil) (distance 1.0) (degrees nil)
	    (no-waveshaping nil) (denoise nil)
	    (denoise-dur .1) (denoise-amp .005)
	    &amp;allow-other-keys)
  (if (&gt; (abs amplitude) 1.0) 
      (setf amplitude (clm-cerror ".1?" .1 #'numberp "amplitude = ~A?" amplitude)))
  (if (&lt;= (abs frequency) 1.0) 
      (setf frequency (clm-cerror "440.0?" 440.0 #'numberp "frequency = ~A?" frequency)))
  (let* ((beg (floor (* startime *srate*)))
	 (end (+ beg (floor (* dur *srate*))))
	 (frq-scl (<a class=quiet href="clm.html#hztoradians">hz-&gt;radians</a> frequency))
	 (modulate (not (zerop fm-index)))
	 (maxdev (* frq-scl fm-index))
	 (vln (not (eq index-type :cello)))
	 (logfreq (log frequency))
	 (sqrtfreq (sqrt frequency))
	 (index1 (or fm1-index (min pi (* maxdev (/ (if vln 5.0 7.5) logfreq)))))
	 (index2 (or fm2-index (min pi (* maxdev 3.0 (if vln 
							     (/ (- 8.5 logfreq) (+ 3.0 (* frequency .001)))
							   (/ 15.0 sqrtfreq))))))
	 (index3 (or fm3-index (min pi (* maxdev (/ (if vln 4.0 8.0) sqrtfreq)))))

	 (easy-case (and (not no-waveshaping)
			 (zerop noise-amount)
			 (eq fm1-env fm2-env)
			 (eq fm1-env fm3-env)
			 (zerop (- fm1-rat (floor fm1-rat)))
			 (zerop (- fm2-rat (floor fm2-rat)))
			 (zerop (- fm3-rat (floor fm3-rat)))
			 (zerop (nth-value 1 (floor fm2-rat fm1-rat)))
			 (zerop (nth-value 1 (floor fm3-rat fm1-rat)))))
	 (coeffs (and easy-case modulate
	 	      (partials-&gt;polynomial
	 	       (list fm1-rat index1
	 		     (floor fm2-rat fm1-rat) index2
	 		     (floor fm3-rat fm1-rat) index3))))
	 ;; that is, we're doing the polynomial evaluation using fm1osc running at fm1-rat * frequency
	 ;; so everything in the polynomial table should be in terms of harmonics of fm1-rat
	 
	 (norm (or (and easy-case modulate 1.0) index1))
	 
	 (carrier (<a class=quiet href="clm.html#make-oscil">make-oscil</a> frequency))
	 (fmosc1  (and modulate (<a class=quiet href="clm.html#make-oscil">make-oscil</a> (* fm1-rat frequency))))
	 (fmosc2  (and modulate (or easy-case (<a class=quiet href="clm.html#make-oscil">make-oscil</a> (* fm2-rat frequency)))))
	 (fmosc3  (and modulate (or easy-case (<a class=quiet href="clm.html#make-oscil">make-oscil</a> (* fm3-rat frequency)))))
	 (ampf  (<a class=quiet href="clm.html#make-env">make-env</a> 
                  (if denoise
                       (reduce-amplitude-quantization-noise amp-env dur amplitude denoise-dur denoise-amp) 
                     amp-env)
	          amplitude :base base :duration dur))
	 (indf1 (and modulate (<a class=quiet href="clm.html#make-env">make-env</a> fm1-env norm :duration dur)))
	 (indf2 (and modulate (or easy-case (<a class=quiet href="clm.html#make-env">make-env</a> fm2-env index2 :duration dur))))
	 (indf3 (and modulate (or easy-case (<a class=quiet href="clm.html#make-env">make-env</a> fm3-env index3 :duration dur))))
	 (frqf (<a class=quiet href="clm.html#make-env">make-env</a> gliss-env (* glissando-amount frq-scl) :duration dur))
	 (pervib (<a class=quiet href="clm.html#make-triangle-wave">make-triangle-wave</a> periodic-vibrato-rate (* periodic-vibrato-amplitude frq-scl)))
	 (ranvib (<a class=quiet href="clm.html#make-rand-interp">make-rand-interp</a> random-vibrato-rate (* random-vibrato-amplitude frq-scl)))
	 (fm-noi (if (and (/= 0.0 noise-amount)
			  (null frobber))
		     (<a class=quiet href="clm.html#make-rand">make-rand</a> noise-freq (* pi noise-amount))))
	 (ind-noi (if (and (/= 0.0 ind-noise-amount) (/= 0.0 ind-noise-freq))
		      (<a class=quiet href="clm.html#make-rand-interp">make-rand-interp</a> ind-noise-freq ind-noise-amount)))
	 (amp-noi (if (and (/= 0.0 amp-noise-amount) (/= 0.0 amp-noise-freq))
		      (<a class=quiet href="clm.html#make-rand-interp">make-rand-interp</a> amp-noise-freq amp-noise-amount)))
	 (frb-env (if (and (/= 0.0 noise-amount) frobber)
		      (<a class=quiet href="clm.html#make-env">make-env</a> (make-frobber-function startime (+ startime dur) frobber) :duration dur
				:base 0	:scaler (* two-pi noise-amount))))
	 (vib 0.0) 
	 (modulation 0.0)
	 (loc (<a class=quiet href="clm.html#make-locsig">make-locsig</a> :degree (or degree degrees (random 90.0)) 
                :reverb reverb-amount :distance distance))
	 (fuzz 0.0)
	 (ind-fuzz 1.0)
	 (amp-fuzz 1.0))
    (run
     (loop for i from beg to end do
       (if (/= 0.0 noise-amount)
	   (if (null frobber)
	       (setf fuzz (<a class=quiet href="clm.html#rand">rand</a> fm-noi))
	     (setf fuzz (<a class=quiet href="clm.html#env">env</a> frb-env))))
       (setf vib (+ (<a class=quiet href="clm.html#env">env</a> frqf) (<a class=quiet href="clm.html#triangle-wave">triangle-wave</a> pervib) (<a class=quiet href="clm.html#rand-interp">rand-interp</a> ranvib)))
       (if ind-noi (setf ind-fuzz (+ 1.0 (<a class=quiet href="clm.html#rand-interp">rand-interp</a> ind-noi))))
       (if amp-noi (setf amp-fuzz (+ 1.0 (<a class=quiet href="clm.html#rand-interp">rand-interp</a> amp-noi))))
       (if modulate
	   (if easy-case
	       (setf modulation
		 (* (<a class=quiet href="clm.html#env">env</a> indf1) 
		    (<a class=quiet href="clm.html#polynomial">polynomial</a> coeffs (<a class=quiet href="clm.html#oscil">oscil</a> fmosc1 vib)))) ;(* vib fm1-rat)??
	     (setf modulation
	       (+ (* (<a class=quiet href="clm.html#env">env</a> indf1) (<a class=quiet href="clm.html#oscil">oscil</a> fmosc1 (+ (* fm1-rat vib) fuzz)))
		  (* (<a class=quiet href="clm.html#env">env</a> indf2) (<a class=quiet href="clm.html#oscil">oscil</a> fmosc2 (+ (* fm2-rat vib) fuzz)))
		  (* (<a class=quiet href="clm.html#env">env</a> indf3) (<a class=quiet href="clm.html#oscil">oscil</a> fmosc3 (+ (* fm3-rat vib) fuzz)))))))
       (<a class=quiet href="clm.html#locsig">locsig</a> loc i
	     (* (<a class=quiet href="clm.html#env">env</a> ampf) amp-fuzz
		(<a class=quiet href="clm.html#oscil">oscil</a> carrier (+ vib (* ind-fuzz modulation)))))))))
</small></pre></td></tr></table>

<p><small>which is very similar to the Scheme version (v.scm).
And I just found this out on the net; I'm no csound expert, so I merely quote what I find:
</small></p>

<table border=0 hspace=20><tr><td bgcolor="#fafafa"><pre><small>
;ORC
; edited by R. Pinkston, modified for use with MIDI2CS by R. Borrmann
;
;==========================================================================;
;                Schottstaedt FM String Instrument from Dodge              ;
;                                                                          ;
;p4 = amp p5 = pch p6 = rise p7 = dec p8 = vibdel p9 = vibwth p10 = vibrte ;
;==========================================================================;
;        sr      =       44100
;        kr      =       4410
;        ksmps   =       10
;        nchnls  =       1
;
;                instr   1

par
  p_maxamplitude 32000
  p_cps
endpar

        iamp    =       p4

        irise   = .2    ;p6
        idec    = .2    ;p7
        ivibdel = .75   ;p8
        ivibwth = .03   ;p9
        ivibrte = 5.5   ;p10

        ifc     =       p5
        ifm1    =       ifc
        ifm2    =       ifc*3
        ifm3    =       ifc*4
        indx1   =       7.5/log(ifc)    ;range from ca 2 to 1
        indx2   =       15/sqrt(ifc)    ;range from ca 2.6 to .5
        indx3   =       1.25/sqrt(ifc)  ;range from ca .2 to .038
        kvib    init    0 

                timout  0,ivibdel,transient  ;delays vibrato for p8 seconds
        kvbctl  linen   1,.5,p3-ivibdel,.1   ;vibrato control envelope
        krnd    randi   .0075,15        ;random deviation in vib width 
        kvib    oscili  kvbctl*ivibwth+krnd,ivibrte*kvbctl,1 ;vibrato generator
               
transient:
        timout  .2,p3,continue          ;execute for .2 secs only
        ktrans  linseg  1,.2,0,1,0      ;transient envelope 
        anoise  randi   ktrans,.2*ifc   ;noise... 
        attack  oscil   anoise,2000,1   ;...centered around 2kHz

continue: 
        amod1   oscili  ifm1*(indx1+ktrans),ifm1,1
        amod2   oscili  ifm2*(indx2+ktrans),ifm2,1
        amod3   oscili  ifm3*(indx3+ktrans),ifm3,1
        asig    oscili  iamp,(ifc+amod1+amod2+amod3)*(1+kvib),1
        asig    linen   asig+attack,irise,p3,idec
;                out     asig
; 
;                endin
        aright  = asig
        aleft   = asig
</small></pre></td></tr></table>

<p><small>There's a C/CLM version of this instrument in sndlib.html.  The body of the fm-violin
in C/CLM is:
</small></p>

<table border=0 hspace=20><tr><td bgcolor="#fafafa"><pre><small>
      if (noise_amount != 0.0) fuzz = mus_rand(fmnoi,0.0);
      if (frqf) vib = mus_env(frqf); else vib = 0.0;
      vib += mus_triangle_wave(pervib, 0.0) + 
             mus_rand_interp(ranvib, 0.0);
      if (easy_case)
        modulation = mus_env(indf1) * 
                     mus_polynomial(coeffs, mus_oscil(fmosc1, vib, 0.0), npartials);
      else
        modulation = mus_env(indf1) * mus_oscil(fmosc1, (fuzz + fm1_rat * vib), 0.0) +
                     mus_env(indf2) * mus_oscil(fmosc2, (fuzz + fm2_rat * vib), 0.0) +
                     mus_env(indf3) * mus_oscil(fmosc3, (fuzz + fm3_rat * vib), 0.0);
      mus_locsig(loc, i, mus_env(ampf) *
                         mus_oscil(carrier, vib + indfuzz * modulation, 0.0));
</small></pre></td></tr></table>


<p><small>And here is the Ruby version, written by Michael Scholz (see examp.rb):</small></p>

<table border=0 hspace=20><tr><td bgcolor="#fafafa"><pre><small>
#
# fm_violin([start=0.0[, dur=1.0[, freq=440.0[, amp=0.3[, *args]]]]])
#

def fm_violin(start = 0.0, dur = 1.0, freq = 440.0, amp = 0.3, *args)
  include Math;			# PI

  usage = "fm_violin([start=0.0[, dur=1.0[, freq=440.0[, amp=0.3[, *args]]]]])

	[:fm_index, 1.0]
	[:amp_env, [0, 0, 25, 1, 75, 1, 100, 0]]
	[:periodic_vibrato_rate, 5.0]
	[:random_vibrato_rate, 16.0]
	[:periodic_vibrato_amp, 0.0025]
	[:random_vibrato_amp, 0.005]
	[:noise_amount, 0.0]
	[:noise_freq, 1000.0]
	[:ind_noise_freq, 10.0]
	[:ind_noise_amount, 0.0]
	[:amp_noise_freq, 20.0]
	[:amp_noise_amount, 0.0]
	[:gliss_env, [0, 0,  100, 0]]
	[:gliss_amount, 0.0]
	[:fm1_env, [0, 1, 25, 0.4, 75, 0.6, 100, 0]]
	[:fm2_env, [0, 1, 25, 0.4, 75, 0.6, 100, 0]]
	[:fm3_env, [0, 1, 25, 0.4, 75, 0.6, 100, 0]]
	[:fm1_rat, 1.0]
	[:fm2_rat, 3.0]
	[:fm3_rat, 4.0]
	[:fm1_index, false]
	[:fm2_index, false]
	[:fm3_index, false]
	[:base, 1.0]
	[:reverb_amount, 0.01]
	[:index_type, :violin]
	[:degree, false]
	[:distance, 1.0]
	[:degrees, false]

  Ruby: fm_violin(0, 1, 440, .1, [[:fm_index, 2.0]])
 Guile: (fm-violin 0 1 440 .1 :fm-index 2.0)\n\n";

  fm_index = (args.assoc(:fm_index)[1] rescue 1.0);
  amp_env = (args.assoc(:amp_env)[1] rescue [0, 0, 25, 1, 75, 1, 100, 0]);
  periodic_vibrato_rate = (args.assoc(:periodic_vibrato_rate)[1] rescue 5.0);
  random_vibrato_rate = (args.assoc(:random_vibrato_rate)[1] rescue 16.0);
  periodic_vibrato_amp = (args.assoc(:periodic_vibrato_amp)[1] rescue 0.0025);
  random_vibrato_amp = (args.assoc(:random_vibrato_amp)[1] rescue 0.005);
  noise_amount = (args.assoc(:noise_amount)[1] rescue 0.0);
  noise_freq = (args.assoc(:noise_freq)[1] rescue 1000.0);
  ind_noise_freq = (args.assoc(:ind_noise_freq)[1] rescue 10.0);
  ind_noise_amount = (args.assoc(:ind_noise_amount)[1] rescue 0.0);
  amp_noise_freq = (args.assoc(:amp_noise_freq)[1] rescue 20.0);
  amp_noise_amount = (args.assoc(:amp_noise_amount)[1] rescue 0.0);
  gliss_env = (args.assoc(:gliss_env)[1] rescue [0, 0,  100, 0]);
  gliss_amount = (args.assoc(:gliss_amount)[1] rescue 0.0);
  fm1_env = (args.assoc(:fm1_env)[1] rescue [0, 1, 25, 0.4, 75, 0.6, 100, 0]);
  fm2_env = (args.assoc(:fm2_env)[1] rescue [0, 1, 25, 0.4, 75, 0.6, 100, 0]);
  fm3_env = (args.assoc(:fm3_env)[1] rescue [0, 1, 25, 0.4, 75, 0.6, 100, 0]);
  fm1_rat = (args.assoc(:fm1_rat)[1] rescue 1.0);
  fm2_rat = (args.assoc(:fm2_rat)[1] rescue 3.0);
  fm3_rat = (args.assoc(:fm3_rat)[1] rescue 4.0);
  fm1_index = (args.assoc(:fm1_index)[1] rescue false);
  fm2_index = (args.assoc(:fm2_index)[1] rescue false);
  fm3_index = (args.assoc(:fm3_index)[1] rescue false);
  base = (args.assoc(:base)[1] rescue 1.0);
  reverb_amount = (args.assoc(:reverb_amount)[1] rescue 0.01);
  index_type = (args.assoc(:index_type)[1] rescue :violin);
  degree = (args.assoc(:degree)[1] rescue false);
  distance = (args.assoc(:distance)[1] rescue 1.0);
  degrees = (args.assoc(:degrees)[1] rescue false);

  srate = (srate() rescue $rbm_srate);
  chans = (channels() rescue $rbm_channels);
  beg = (srate * start).round;
  len = (srate * dur).round;
  frq_scl = hz2radians(freq);
  modulate = fm_index.nonzero?;
  maxdev = frq_scl * fm_index;
  vln = (not (index_type == :cello))
  logfreq = log(freq);
  sqrtfreq = sqrt(freq);
  index1 = (fm1_index or [PI, maxdev * (vln ? 5.0 : 7.5) / logfreq].min);
  index2 = (fm2_index or [PI, maxdev * 3.0 * 
	      (vln ? ((8.5 - logfreq) / (3.0 + freq * 0.001)) : (15.0 / sqrtfreq))].min);
  index3 = (fm3_index or [PI, maxdev * (vln ? 4.0 : 8.0) / sqrtfreq].min);
  easy_case = (noise_amount.zero? and
	       (fm1_env == fm2_env) and 
	       (fm1_env == fm3_env) and 
	       (fm1_rat - fm1_rat.floor).zero? and 
	       (fm2_rat - fm2_rat.floor).zero? and 
	       (fm3_rat - fm3_rat.floor).zero?);
  coeffs = (easy_case and modulate and 
	    partials2polynomial([fm1_rat, index1, 
				  (fm2_rat / fm1_rat).floor, index2,
				  (fm3_rat / fm1_rat).floor, index3]));
  norm = ((easy_case and modulate and 1.0) or index1);
  carrier = make_oscil(freq);
  fmosc1 = (modulate and make_oscil(fm1_rat * freq));
  fmosc2 = (modulate and (easy_case or make_oscil(fm2_rat * freq)));
  fmosc3 = (modulate and (easy_case or make_oscil(fm3_rat * freq)));
  ampf = make_env(amp_env, amp, dur, 0.0, base);
  indf1 = (modulate and make_env(fm1_env, norm, dur));
  indf2 = (modulate and (easy_case or make_env(fm2_env, index2, dur)));
  indf3 = (modulate and (easy_case or make_env(fm3_env, index3, dur)));
  frqf = make_env(gliss_env, gliss_amount * frq_scl, dur);
  pervib = make_triangle_wave(periodic_vibrato_rate, periodic_vibrato_amp *  frq_scl);
  ranvib = make_rand_interp(random_vibrato_rate, random_vibrato_amp * frq_scl);
  fm_noi = (noise_amount.nonzero? and make_rand(noise_freq, PI * noise_amount));
  ind_noi = ((ind_noise_amount.nonzero? and ind_noise_freq.nonzero?) and 
	     make_rand_interp(ind_noise_freq, ind_noise_amount));
  amp_noi = ((amp_noise_amount.nonzero? and amp_noise_freq.nonzero?) and
	     make_rand_interp(amp_noise_freq, amp_noise_amount));
  vib = 0.0;
  modulation = 0.0;
  # make_locsig(degree=0.0, distance=1.0, reverb=0.0, output, revout, chans=1, type=Mus_linear)
  # Ruby's rand() is shadowed by CLM's rand(), that's why mus_random().abs.
  loc = make_locsig((degree or degrees or mus_random(90.0).abs), 
		    distance, reverb_amount, false, false, chans);
  fuzz = 0.0;
  ind_fuzz = 1.0;
  amp_fuzz = 1.0;
  out_data = make_vct(len);

  vct_map!(out_data,
	   lambda { | |
	     fuzz = rand(fm_noi) if noise_amount.nonzero?;
	     vib = env(frqf) + triangle_wave(pervib) + rand_interp(ranvib);
	     ind_fuzz = 1.0 + rand_interp(ind_noi) if ind_noi;
	     amp_fuzz = 1.0 + rand_interp(amp_noi) if amp_noi;

	     if(modulate)
	       if(easy_case)
		 modulation = env(indf1) * polynomial(coeffs, oscil(fmosc1, vib));
	       else
		 modulation = env(indf1) * oscil(fmosc1, fm1_rat * vib + fuzz) +
		   env(indf2) * oscil(fmosc2, fm2_rat * vib + fuzz) +
		   env(indf3) * oscil(fmosc3, fm3_rat * vib + fuzz);
	       end
	     end

	     env(ampf) * amp_fuzz * oscil(carrier, vib + ind_fuzz * modulation);
	   });

  if(chans == 2)
    mix_vct(vct_scale!(vct_copy(out_data), locsig_ref(loc, 1)), beg, $rbm_snd, 1, false);
    mix_vct(vct_scale!(out_data, locsig_ref(loc, 0)), beg, $rbm_snd, 0, false);
  else
    mix_vct(out_data, beg, $rbm_snd, 0, false);
  end
rescue
  die(usage + "fm_violin()");
end

</small></pre></td></tr></table>


<br>
<br>


<!-- ---------------------------------------- FILE: ws ---------------------------------------- -->

<A NAME="wsdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>ws</h2></td></tr></table>

<p>
with-sound provides a simple way to package up a bunch of instrument calls into a new
sound file, and open that file in Snd when the computation is complete. 
To hear (and see) the fm-violin, for example, we first load with-sound and the instrument:
</p>
<table border=0 cellspacing=0 hspace=20>
<tr>
<td bgcolor="#fbfbff">
<pre>
;; Scheme:
(load "ws.scm")
(load "v.scm")
</pre></td><td width=60></td>

<td bgcolor="#FdFdf2">
<pre>
# Ruby:
load("ws.rb")
load("v.rb")
</pre></td><td width=60></td>

<td bgcolor="#EefdEe">
<pre>
\ Forth:
"clm.fs" file-eval
"clm-ins.fs" file-eval
</pre></td>
</tr></table>

<p>Then call with-sound, accepting the default sound file settings, with one fm-violin note at A4 (440 Hz):
</p>

<table border=0 cellspacing=0 hspace=20>
<tr>
<td bgcolor="#fbfbff">
<pre>
(with-sound () 
  (fm-violin 0 1 440 .1))
</pre></td><td width=30></td>

<td bgcolor="#FdFdf2">
<pre>
with_sound() do 
  fm_violin_rb(0, 1, 440, 0.1) 
end
</pre></td><td width=30></td>

<td bgcolor="#EefdEe">
<pre>
0 1 440 0.1 ' fm-violin with-sound
</pre></td>
</tr></table>

<p>The body of with-sound can hold any number of notes, or any arbitrary code.  For example, say
we want to hear an arpeggio from the fm-violin:
</p>

<pre>
    (with-sound ()
      (do ((i 0 (1+ i)))
          ((= i 4))                ; 4 notes in all
        (fm-violin (* i 0.25)      ; notes 1/4 secs apart
                   0.25            ; each note 1/4 sec long
		   (* 220.0 (1+ i)); go up by 220 Hz on each note
                   .1)))           ; all notes .1 amp
</pre>

<p>
See the <a href="#clminsdoc">clm instrument</a> documentation for more examples.
</p>
<pre>
  <em class=emdef>with-sound</em>
     :key (srate *clm-srate*)                    ; output sampling rate (22050)
          (output *clm-file-name*)               ; output file name ("test.snd")
	  (channels *clm-channels*)              ; channels in output (1)
	  (header-type *clm-header-type*)        ; output header type (mus-next or mus-aifc)
	  (data-format *clm-data-format*)        ; output sample data type (mus-bfloat or mus-lshort)
	  (comment #f)                           ; any comment to store in the header (a string)
	  (verbose *clm-verbose*)                ; if #t, print out some info
	  (reverb *clm-reverb*)                  ; reverb instrument (jc-reverb)
	  (revfile "test.rev")                   ; reverb intermediate output file name ("test.rev")
	  (reverb-data *clm-reverb-data*)        ; arguments passed to the reverb
	  (reverb-channels *clm-reverb-channels*); chans in the reverb intermediate file
	  (continue-old-file #f)                 ; if #t, continue a previous computation
	  (statistics *clm-statistics*)          ; if #t, print info at end of with-sound (compile time, maxamps)
	  (scaled-by #f)                         ; is a number, scale output by that amp
	  (scaled-to #f)                         ; if a number, scale the output to peak at that amp
	  (play *clm-play*)                      ; if #t, play the sound automatically
	  (to-snd *to-snd*)                      ; if #t, open the output file in Snd
</pre>
<p>As far as possible, this parallels CLM's <a href="clm.html#with-sound">with-sound</a>.</p>
<pre>
    :<em class=typing>(with-sound (:statistics #t :channels 2 :reverb jc-reverb)
       (fm-violin 0 .1 440 .1 :reverb-amount .1 :degree 0)
       (fm-violin 1 .1 660 .2 :degree 90))</em>
    <em class=listener>test.snd:
      maxamp: 0.1000 0.2032
      rev max: 0.0100
      compute time: 0.050
    "test.snd"</em>               ; with-sound returns the new file name
</pre>
<p>or in Ruby:
</p>
<pre>
    :<em class=typing>with_sound(:channels, 2, :play, false, :statistics, true) do 
      fm_violin(0, 1, 440, 0.1); 
      fm_violin(1, 1, 660, 0.1);
      end</em>
    <em class=listener># filename: "test.snd"
    #    chans: 2, srate: 22050
    #   length: 2.000 (44100 frames)
    #   format: big endian short (16 bits) [Sun/Next]
    #     real: 2.248  (utime 2.240, stime 0.000)
    #    ratio: 1.12  (uratio 1.12)
    #  max out: [0.098, 0.024]
    #&lt;With_Snd: output: "test.snd", channels: 2, srate: 22050&gt;</em>
</pre>

<p>and in Forth:
</p>
<pre>
    snd&gt; <em class=typing>0.0 1.0 330.0 0.5 ' simp :play #f :channels 2 with-sound</em>
    <em class=listener>\ filename: test.snd
    \    chans: 2, srate: 22050
    \   format: little endian float (32 bits) [Sun/Next]
    \   length: 1.000  (22050 frames)
    \     real: 0.162  (utime 0.267, stime 0.000)
    \    ratio: 0.16  (uratio 0.27)
    \ maxamp A: 0.500 (near 0.680 secs)
    \ maxamp B: 0.000 (near 0.000 secs)
    \  comment: Written on Fri Jul 14 07:41:47 PDT 2006 by bil at cat using clm (fth) of 30-Jun-06</em>
</pre>

<p>
<b>with-sound</b> opens its output file ('output' above)
via make-sample-&gt;file, setting the global variable *output*.  This
is equivalent to CLM's *output* variable, and can be used the same
way in <a class=quiet href="clm.html#outa">outa</a> or <a class=quiet href="clm.html#locsig">locsig</a>.  If 'reverb' is specified, *reverb* is also
opened (corresponding to CLM's *reverb*).  So the cooperating instrument code is:
</p>

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(definstrument (ins args)
  (let ...
    (ws-interrupt?) ; see below
    (run                             ; run is optional, but speeds up computation
      (lambda ()
        (do ((i start (1+ i)))
            ((= i end))
          (<a class=quiet href="clm.html#outa">outa</a> i ... *output*))))))
</pre></td></tr></table>

<p>which parallels the Common Lisp CLM (change the loop statement to a do statement,
add the lambda wrapper, needed by the run macro unfortunately,
and you're ready to go).  If the run macro can handle the instrument code (and
it can handle anything the CL version can handle, I think), then the Snd with-sound
should run within a factor of four of the fastest CL-based CLM, even though the
latter is going through the C intermediate file and the (very good) C compiler!  
</p>

<p>In scheme, you can also use <a name="defoptkeyinstrument">def-optkey-instrument</a>
which is a combination of definstrument and <a href="clm.html#def-optkey-fun">def-optkey-fun</a>:
</p>

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(def-optkey-instrument (simp beg dur (frequency 440.0) (amplitude 0.1))
  (let* ((os (make-oscil frequency)))
    (run (lambda ()
      (do ((i 0 (1+ i))) ((= i dur))
	(outa (+ i beg) (* amplitude (oscil os)) *output*))))))

(with-sound () 
  (simp 0 10000) 
  (simp 10000 10000 550.0 :amplitude 0.1) 
  (simp 20000 10000 :amplitude 0.2))
</pre></td></tr></table>

<p>with-sound returns the output file name. If a previous file of the same name
is currently open in Snd, it is closed before the new version is opened.
To display the entire sound automatically (independent of <a href="extsnd.html#afteropenhook">after-open-hook</a>),
use <b>with-full-sound</b>.  It is:
</p>
<pre>
    (defmacro with-full-sound (args . body)
      `(let ((snd (with-sound-helper (lambda () ,@body) ,@args)))
         (set! (<a class=quiet href="extsnd.html#xbounds">x-bounds</a> *snd-opened-sound*) (list 0.0 (/ (<a class=quiet href="extsnd.html#frames">frames</a> *snd-opened-sound*) (<a class=quiet href="extsnd.html#srate">srate</a> *snd-opened-sound*))))
         snd))
</pre>
<p>Since with-sound returns the new sound's file name, we save that, get the new sound's index (<a href="extsnd.html#sndopenedsound">*snd-opened-sound*</a>),
and set the <a href="extsnd.html#xbounds">x-bounds</a> to display the full sound, then return the file name.  You could obviously customize this any way
you like.
</p>

<p>
The easiest way to mix an existing file into the with-sound output is to use
mus-mix with *output*:
</p>

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(with-sound () 
  (fm-violin 0 .1 440 .1) 
  (<a class=quiet href="clm.html#musmix">mus-mix</a> *output* "oboe.snd") 
  (fm-violin .1 .1 660 .1))
</pre></td></tr></table>

<p>To continue adding notes to an existing file, set 'continue-old-file':
</p>
<pre>
    (with-sound (:continue-old-file #t) (fm-violin 0 1 440 .1))
</pre>

<p>You don't have to use definstrument; in the next example we make a Shepard tone
by calling the oscils and whatnot directly in the with-sound body:
</p>
<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(define (<a name="shepardtone">shepard-tone</a>)
  (let* ((x 0.0)
	 (incr .000001)               ; sets speed of glissandoes
	 (oscs (make-vector 12)))
    (do ((i 0 (1+ i)))
	((= i 12))
      (vector-set! oscs i (<a class=quiet href="clm.html#make-oscil">make-oscil</a> :frequency 0.0)))
    (with-sound (:srate 44100)
      (run                            ; use "run" to speed up computation by about a factor of 10
       (lambda ()
	 (do ((samp 0 (1+ samp)))
	     ((= samp 300000))
	   (let ((sum 0.0))
	     (do ((i 0 (1+ i)))
		 ((= i 12))
	       (let ((loc (+ x (/ i 12.0))))  ; location of current oscil in overall trajectory
		 (if (&gt; loc 1.0) (set! loc (- loc 1.0)))
		 (set! sum (+ sum (* (let ((y (- 4.0 (* 8.0 loc))))
				       (exp (* -0.5 y y)))  ; Gaussian normal curve as amplitude envelope
				     (<a class=quiet href="clm.html#oscil">oscil</a> (vector-ref oscs i) 
					    (<a class=quiet href="clm.html#hztoradians">hz-&gt;radians</a> (expt 2.0 (+ 2 (* loc 12.0)))))))))) ; (- 1.0 loc) to go down
	     (set! x (+ x incr))
	     (<a class=quiet href="clm.html#outa">outa</a> samp (* .1 sum) *output*))))))))
</pre></td></tr></table>
<img src="shepard.png" alt="shepard tone spectrum" vspace=10 hspace=40>


<br><br>
<table width="30%" border=0><tr><td bgcolor="#EEFDEE" valign="middle"><h4>other forms of with-sound</h4></td></tr></table>

<p>There are several other versions of with-sound: with-temp-sound, sound-let, clm-load, with-mix, and the Common Music
handles, init-with-sound and finish-with-sound.
</p>

<p>
<b>with-temp-sound</b> and <b>sound-let</b> set up temporary bindings for embedded with-sounds.
Sound-let is documented in <a href="clm.html#sound-let">clm.html</a>; briefly it is a combination
of "let" and with-sound:
</p>
<pre>
  (with-sound ()
    (sound-let ((temp-sound () (fm-violin 0 1 440 .1))) ; create temp-sound with an fm-violin note (v.scm)
       (pins 0.0 2.0 temp-sound 1.0 :time-scaler 2.0))  ; stretch it with the pins instrument (clm-ins.scm)
    (fm-violin 1 1 550 .1))                             ; add another fm-violin note
</pre>

<p>Similarly, <a name="withtempsound">with-temp-sound</a> creates a temporary sound file (using <a href="extsnd.html#sndtempnam">snd-tempnam</a>),
and it does not open the result in Snd (it assumes its output is some intermediate file); here is an example that
parallels the sound-let example above:
</p>
<pre>
  (with-sound ()
    (let ((temp-sound (with-temp-sound () (fm-violin 0 1 440 .1))))
      (clm-expsrc 0 2 temp-sound 2.0 1.0 1.0)))
</pre>
<p>Here are Ruby examples:
</p>
<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
with_sound() do
  clm_mix(with_sound(:output, "hiho.snd") do
            fm_violin(0, 1, 440, 0.1)
          end.output, :scale, 0.5)
end

with_sound() do
  with_mix "s1", %Q{
  sound_let(lambda do fm_violin(0, 1, 440, 0.1) end) do |tmp|
    clm_mix(tmp)
  end
  }
end
</pre></td></tr></table>


<p>Another variant of with-sound is <b><a name="clmload">clm-load</a></b>.  Its first argument is a filename, assumed to
be a text file containing the body of with-sound, followed by the usual with-sound arguments, if any.
For example, if we have a file named clm-load-test.clm with these contents:
</p>
<pre>
    (fm-violin 0 1 440 .1)
    (fm-violin 1 1 660 .1)
</pre>
<p>
then <code>(clm-load "clm-load-test.clm")</code> is the same as <code>(with-sound () (fm-violin 0 1 440 .1) (fm-violin 1 1 660 .1))</code>.
Similarly for, <code>(clm-load "clm-load-test.clm" :srate 44100 :channels 2)</code> and so on.
</p>

<p><b>init-with-sound</b> and <b>finish-with-sound</b>
split with-sound into two pieces, primarily for Common Music's benefit.
</p>
<pre>
    (define w (init-with-sound :scaled-to .5))
    (fm-violin 0 1 440 .1)
    (finish-with-sound w)
</pre>
<p>is equivalent to 
</p>
<pre>
    (with-sound (:scaled-to .5)
      (fm-violin 0 1 440 .1))
</pre>

<p><b>with-mix</b> is a "checkpointing" with-sound; it takes extended explication: see <a href="clm.html#mix-and-with-mix">clm.html</a>
for details.
</p>

<br>
<A NAME="wsdebug"></a><table width="30%" border=0><tr><td bgcolor="#EEFDEE" valign="middle"><h4>debugging help in with-sound</h4></td></tr></table>

<!-- INDEX wsdebug:Debugging (notelists) -->

<p>with-sound establishes a catch for debugging: 'with-sound-interrupt.  If you
place the macro <b>ws-interrupt?</b> in your instrument, C-g will be caught at
each such point, and control transferred to the with-sound debugging context.
Currently, ws-interrupt? is not supported by the run macro, but each of the
clm-ins.scm instruments includes it just before the run loop.  
Once in the debugger, you are simply in the standard listener loop, but
there are several additional functions to help with debugging:
</p>
<pre>
  <em class=emdef>ws-go</em> (returned-value #f)             ; continue with-sound from interrupt point
  <em class=emdef>ws-locals</em> (stack-location 0)          ; display current instrument's local variables
  <em class=emdef>ws-local</em> local-var (stack-location 0) ; display one local variable ('local-var', a symbol or string)
  <em class=emdef>ws-backtrace</em> (all #f)                 ; show backtrace at point of interrupt
  <em class=emdef>ws-help</em>                               ; print debugger help
  <em class=emdef>ws-quit</em>                               ; exit with-sound, omitting reverb, if any
  <em class=emdef>ws-quit!</em>                              ; exit with-sound and return to the top-level
  <em class=emdef>ws-stop</em>                               ; exit with-sound, but run the reverb, if any
  <em class=emdef>ws-stop!</em>                              ; same as ws-stop, but also force return to top-level
</pre>

<p>
The <b>ws-backtrace</b> stack trace
is normally truncated to show just the 5 or so inner frames; to get the full
backtrace, call ws-backtrace with an argument of #t.
The <b>ws-go</b> 'returned-value' is the value to return from the original call on ws-interrupt? (or its equivalent).
</p>

<br>
<table width="30%" border=0><tr><td bgcolor="#EEFDEE" valign="middle"><h4>functions associated with with-sound</h4></td></tr></table>

<p>
<b>definstrument</b> and <b>def-clm-struct</b> make sound-producing functions compatible with with-sound.
See clm.html for documentation. 
</p>

<p>Toward the end of ws.scm is an example, <A NAME="withmarkedsound">with-marked-sound</A>, that is just
like with-sound except that it adds a mark at the start of each note in the output
sound; the corresponding code in your instrument sets the mark's :ws property
to contain any info you might find amusing.  You then click the mark to see
that info.
</p>

<p>Also defined in ws.scm are the CLM functions <b>seconds-&gt;samples</b> and <b>time-&gt;samples</b>.
The *clm-* variables are saved in the save-state
file by <A NAME="wssavestate">ws-save-state</A>, which may not be a good idea -- feedback welcome!
Two more convenience functions are <b>-&gt;frequency</b> and <b>-&gt;sample</b>.
<b>-&gt;frequency</b> takes either a number or a common-music pitch symbol ('c4 is middle C),
and returns either the number or the frequency associated with that pitch:
</p>
<pre>
    <em class=listener>&gt;</em> <em class=typing>(-&gt;frequency 'cs5)</em>
    <em class=listener>554.365261953744</em>
</pre>
<p>It's optional second argument can be #t to get integer ratios, rather than
the default equal temperment.
<b>-&gt;sample</b> returns a sample number given a time in seconds:
</p>
<pre>
    <em class=listener>&gt;</em> <em class=typing>(-&gt;sample 1.0)</em>
    <em class=listener>22050</em>
</pre>
<br>



<!-- ---------------------------------------- FILE: zip ---------------------------------------- -->

<A NAME="zipdoc"></a><table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>zip</h2></td></tr></table>
<pre>
  <em class=emdef>make-zipper</em> ramp-env :optional frame-size frame-env
  <a class=def name="zipper">zipper</a> gen in1 in2
  <a class=def name="zipsound">zip-sound</a> beg dur file1 file2 :optional ramp size
</pre>
<p>The zipper generator performs a kind of cross fade, but not one that
tries to be smooth!  It marches through the two sounds taking equal short
portions of each, then abutting them while resampling so that as one
takes less overall frame space, the other takes more.  The 'frame-size'
argument is the maximum length of each twosome in seconds (for initial array allocation), the 'frame-env'
argument determines the current such length as new frames are needed, and the
'ramp-env' argument determines which of the files gets more space
in the frame (0: all first, 1: all second).
The following function sets up two sounds,
an upward ramp and a downward ramp, then zips them together:
</p>

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(define (ramp-test)
  (let ((data (<a class=quiet href="extsnd.html#makevct">make-vct</a> 10000)))
    (<a class=quiet href="extsnd.html#newsound">new-sound</a> "new-0.snd")
    (do ((i 0 (1+ i))) ((= i 10000)) 
      (<a class=quiet href="extsnd.html#vctset">vct-set!</a> data i (* i .0001)))
    (<a class=quiet href="extsnd.html#vcttochannel">vct-&gt;channel</a> data 0 10000 0)
    (<a class=quiet href="extsnd.html#newsound">new-sound</a> "new-1.snd")
    (do ((i 0 (1+ i))) ((= i 10000)) 
      (<a class=quiet href="extsnd.html#vctset">vct-set!</a> data i (- 1.0 (* i .0001))))
    (<a class=quiet href="extsnd.html#vcttochannel">vct-&gt;channel</a> data 0 10000 1)
    (let* ((dur (<a class=quiet href="extsnd.html#frames">frames</a>))
	   (zp (<em class=red>make-zipper</em> (<a class=quiet href="clm.html#make-env">make-env</a> '(0 0 1 1) :end dur)
			    0.05
			    (<a class=quiet href="clm.html#make-env">make-env</a> (list 0 (* (<a class=quiet href="extsnd.html#srate">srate</a>) 0.05)) :end dur)))
	  (reader0 (<a class=quiet href="extsnd.html#makesamplereader">make-sample-reader</a> 0 0 0))
	  (reader1 (<a class=quiet href="extsnd.html#makesamplereader">make-sample-reader</a> 0 1 0)))
      (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (lambda (val) (<em class=red>zipper</em> zp reader0 reader1))))))
</pre></td></tr></table>

<br>
<img src="zramp.png" alt="zipper ramp output" hspace=20>
<p>Needless to say, this is not intended to be a suave, romantic gesture!
</p>

<p>zip-sound applies the zipper to a pair of sounds:
</p>
<pre>
    (zip-sound 0 1 "fyow.snd" "now.snd" '(0 0 1 1) .05)
    (zip-sound 0 3 "mb.snd" "fyow.snd" '(0 0 1.0 0 1.5 1.0 3.0 1.0) .025)
</pre>
<br>



<!-- ---------------------------------------- as needed functions ---------------------------------------- -->

<table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2><A NAME="extsndasneededexpl">A Note on "As-Needed" input functions</a></h2></td></tr></table>

<p>Several CLM generators work internally on buffers of data; only the code internal
to the generator knows when it needs input, and how much it needs.  So, src, granulate,
convolve, and phase-vocoder are passed a function either at run-time or when the
generator is allocated that they can call whenever a new value is needed.
A simple C case is:
</p>

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
#include &lt;stdio.h&gt;
#include "clm.h"

typedef struct {
  float val;
} src_state;

float src_input_as_needed(void *arg, int dir) 
{
  src_state *sr = (src_state *)arg;
  sr-&gt;val += (dir * .01); /* just return a ramp */
  return(sr-&gt;val);
}

int main(int argc, char **argv)
{
  mus_any *gen;
  src_state *input;
  int i;
  input = (src_state *)calloc(1, sizeof(src_state));
  input-&gt;val = 0.0;
  gen = mus_make_src(&amp;src_input_as_needed, 0.5, 10, (void *)input);
  for (i=0; i &lt; 100; i++)
    fprintf(stdout, "%f ", mus_src(gen, 0.0, NULL));
    /* or: fprintf(stdout, "%f ", mus_src(gen, 0.0, src_input_as_needed)); */
  mus_free(gen);
  free(input);
  return(0);
}

/* cc g1.c -o g1 -L/usr/local/lib -lguile /home/bil/sndlib/sndlib.a */
/* g1: 0.010000 0.015440 0.020000 0.024761 0.029999 0.035170 0.039999 ... */
</pre></td></tr></table>

<p>To put that code in words, the src generator uses the function
<code>src_input_as_needed</code> to fill its internal buffer (convolving
it with sinc); in this case, the "srate" argument is 0.5, so src will
pick up a new input sample (calling src_input_as_needed) on every other
output sample.  In the Scheme CLM (and Snd), the "as-needed" input
function is a Scheme function passed in as Scheme code.
</p>
<br>



<!-- ---------------------------------------- user-defined generators ---------------------------------------- -->

<table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2><A NAME="extsndcgens">A Note on User-defined Generators in C-CLM</a></h2></td></tr></table>
<p>To define a new generator type in Scheme is not difficult.  For example, here is a comb filter with
a low-pass filter on the feedback (this is now built into CLM as <a href="clm.html#filtered-comb">filtered-comb</a>):
</p>

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(define (fcomb gen input)
  (gen input))	

(define (make-fcomb length feedback a0 a1)
  (let ((dly (<a class=quiet href="clm.html#make-delay">make-delay</a> length))
        (flt (<a class=quiet href="clm.html#make-one-zero">make-one-zero</a> a0 a1)))
    (lambda (input)
      (dly (+ input (* (flt (<a class=quiet href="clm.html#tap">tap</a> dly)) feedback))))))
</pre></td></tr></table>

<p>We could use Guile's object system to conjure up fcomb
classes and methods in Scheme:
</p>

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(use-modules (oop goops))

(define-class fcmb ()
  (dly :accessor fcomb-delay)
  (flt :accessor fcomb-filter)
  (fdb :accessor fcomb-feedback))

(define (fcomb gen input)
  ((fcomb-delay gen) 
   (+ input (* ((fcomb-filter gen) 
		(<a class=quiet href="clm.html#tap">tap</a> (fcomb-delay gen)))
	       (fcomb-feedback gen)))))

(define-method (initialize (obj fcmb) initargs)
  (next-method)
  (let* ((len (get-keyword :length initargs 0))
	 (feedback (get-keyword :feedback initargs 0.5))
	 (a0 (get-keyword :a0 initargs 0.5))
	 (a1 (get-keyword :a1 initargs 0.5)))
    (set! (fcomb-delay obj) (<a class=quiet href="clm.html#make-delay">make-delay</a> len))
    (set! (fcomb-filter obj) (<a class=quiet href="clm.html#make-one-zero">make-one-zero</a> a0 a1))
    (set! (fcomb-feedback obj) feedback)
    obj))

(define-method (write (obj fcmb) port)
  (display (format #f "#&lt;fcomb: delay: ~A, filter: ~A, feedback: ~A&gt;"
		   (fcomb-delay obj)
		   (fcomb-filter obj)
		   (fcomb-feedback obj))
	   port))
</pre></td></tr></table>

<p>
To do the same thing in CLM-in-C (clm.c) takes a bit more effort:
</p>

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
#include &lt;stddef.h&gt;
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include "sndlib.h"
#include "clm.h"
#include "xen.h"
#include "clm2xen.h"

static int MUS_FCOMB = 0; /* this will be our fcomb type identifier */

typedef struct {
  mus_any_class *core;
  int loc, size;
  Float *line;
  Float xscl, a0, a1, x1;
} fcomb;

/* each CLM-in-C generator has mus_any_class *core as the first thing in its structure.
 *   it defines most of the built-in "generic" functions like mus-describe.
 * The next set of functions implement the core functions/
 *   The address of the function is stored in the class's core struct.
 *   For example, the scaler method is defined as Float (*scaler)(mus_any *ptr);
 *   in the mus_any_class declaration (clm.h); for fcomb it will correspond
 *   to the fcomb_scaler function below; it is invoked via mus_scaler(gen)
 *   where gen is an fcomb generator (the actual call is (*((gen-&gt;core)-&gt;scaler))(gen)).
 *   the core-&gt;scaler pointer (the function address) is set in the declaration
 *   of mus_any_class FCOMB_CLASS below.  If a method doesn't apply to a given
 *   generator class, just set its slot to 0.
 */

static bool mus_fcomb_p(mus_any *ptr) {return((ptr) &amp;&amp; ((ptr-&gt;core)-&gt;type == MUS_FCOMB));}

static char *describe_fcomb(mus_any *ptr) 
{
  char *desc = NULL;
  fcomb *gen = (fcomb *)ptr;
  desc = (char *)calloc(1024, sizeof(char));
  if (desc)
    {
      if (mus_fcomb_p((mus_any *)ptr))
	sprintf(desc, "fcomb: scaler: %.3f,  a0: %.3f,  a1: %.3f,  line[%d]", 
		gen-&gt;xscl, gen-&gt;a0, gen-&gt;a1, gen-&gt;size);
      else sprintf(desc, "not an fcomb gen");
    }
  return(desc);
}

static bool fcomb_equalp(mus_any *p1, mus_any *p2) {return(p1 == p2);}
static off_t fcomb_length(mus_any *ptr) {return(((fcomb *)ptr)-&gt;size);}
static Float *fcomb_data(mus_any *ptr) {return(((fcomb *)ptr)-&gt;line);}
static Float fcomb_scaler(mus_any *ptr) {return(((fcomb *)ptr)-&gt;xscl);}
static Float set_fcomb_scaler(mus_any *ptr, Float val) {((fcomb *)ptr)-&gt;xscl = val; return(val);}

static void fcomb_reset(mus_any *ptr)
{
  fcomb *gen = (fcomb *)ptr;
  gen-&gt;loc = 0;
  memset((void *)(gen-&gt;line), 0, gen-&gt;size * sizeof(Float));
}

static int free_fcomb(mus_any *uptr) 
{
  fcomb *ptr = (fcomb *)uptr;
  if (ptr)
    {
      if (ptr-&gt;line) 
        free(ptr-&gt;line);
      free(ptr); 
    }
  return(0);
}

/* now the actual run-time code executed by fcomb */
/* the extra "ignored" argument is for the run method */

static Float mus_fcomb (mus_any *ptr, Float input, Float ignored) 
{
  fcomb *gen = (fcomb *)ptr;
  Float tap_result, filter_result;
  tap_result = gen-&gt;line[gen-&gt;loc];
  filter_result = (gen-&gt;a0 * tap_result) + (gen-&gt;a1 * gen-&gt;x1);
  gen-&gt;x1 = tap_result;
  gen-&gt;line[gen-&gt;loc] = input + filter_result * gen-&gt;xscl;
  gen-&gt;loc++;
  if (gen-&gt;loc &gt;= gen-&gt;size) gen-&gt;loc = 0;
  return(tap_result);
}

/* this is our generator class descriptor */

static mus_any_class FCOMB_CLASS = {
  -1, /* MUS_FCOMB eventually */ /* mus_type: this is assigned at run-time via mus_make_class_tag below */
  "fcomb",                       /* mus_name: class name (used in descriptive/error messages) */
  &amp;free_fcomb,                   /* mus_free: free gen's struct etc */
  &amp;describe_fcomb,               /* mus_describe: user-friendly description */
  &amp;fcomb_equalp,                 /* mus_equalp: check equality of fcomb gens */
  &amp;fcomb_data,                   /* mus_data: the fcomb delay line, a float array */
  0,
  &amp;fcomb_length,                 /* mus_length: delay line length */
  0,
  0,0,
  0,0,
  &amp;fcomb_scaler,                 /* mus_scaler: the feedback term */
  &amp;set_fcomb_scaler,             /* mus_set_scaler */
  0, 0,
  &amp;mus_fcomb,                    /* mus_run|apply: the run-time fcomb function */
  MUS_NOT_SPECIAL,               /* type extension */
  NULL,                     
  0,
  0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  &amp;fcomb_reset,
  0
};

/* now a function to make a new generator */

static mus_any *mus_make_fcomb (Float scaler, int size, Float a0, Float a1)
{
  fcomb *gen = NULL;
  gen = (fcomb *)calloc(1, sizeof(fcomb));
  if (gen == NULL) 
    mus_error(MUS_MEMORY_ALLOCATION_FAILED, 
              "can't allocate struct for mus_make_fcomb!");
  else
    {
      gen-&gt;core = &amp;FCOMB_CLASS;
      if (MUS_FCOMB == 0) 
        {
          MUS_FCOMB = mus_make_class_tag();  /* this gives us a unique fcomb type id */
          gen-&gt;core-&gt;type = MUS_FCOMB;
        }
      gen-&gt;loc = 0;
      gen-&gt;xscl = scaler;
      gen-&gt;x1 = 0.0;
      gen-&gt;a0 = a0;
      gen-&gt;a1 = a1;
      gen-&gt;size = size;
      gen-&gt;line = (Float *)calloc(size, sizeof(Float));
      if (gen-&gt;line == NULL) 
	mus_error(MUS_MEMORY_ALLOCATION_FAILED, 
		  "can't allocate %d bytes for fcomb delay line in mus_make_fcomb!",
		  (int)(size * sizeof(Float)));
    }
  return((mus_any *)gen);
}

/* that is the end of the C side; the rest ties this generator into Guile/Ruby/Forth via the Xen package */
/*   in Snd's case, it's actually not needed because the generator is only called from C */

static XEN g_fcomb(XEN obj, XEN input)
{
  return(C_TO_XEN_DOUBLE(mus_fcomb(MUS_XEN_TO_CLM(obj), XEN_TO_C_DOUBLE(input), 0.0)));
}

static XEN g_fcomb_p(XEN obj)
{
  return(C_TO_XEN_BOOLEAN((mus_xen_p(obj)) &amp;&amp; (mus_fcomb_p(MUS_XEN_TO_CLM(obj)))));
}

static XEN g_make_fcomb(XEN scaler, XEN size, XEN a0, XEN a1)
{
  mus_xen *gn;
  gn = (mus_xen *)CALLOC(1,sizeof(mus_xen));
  gn-&gt;gen = mus_make_fcomb(XEN_TO_C_DOUBLE(scaler),
                           XEN_TO_C_INT(size),
                           XEN_TO_C_DOUBLE(a0),
                           XEN_TO_C_DOUBLE(a1));
  gn-&gt;nvcts = 0;
  return(mus_xen_to_object(gn));
}

static void init_fcomb(void)
{
  XEN_DEFINE_PROCEDURE("fcomb?", g_fcomb_p, 1, 0, 0, "(fcomb? gen) -&gt; #t if gen is an fcomb generator");
  XEN_DEFINE_PROCEDURE("make-fcomb", g_make_fcomb, 4, 0, 0, "(make-fcomb scaler size a0 a1) -&gt; new fcomb gen");
  XEN_DEFINE_PROCEDURE("fcomb", g_fcomb, 2, 0, 0, "(fcomb gen input) returns result of running fcomb gen");
}
</pre></td></tr></table>
<br>

<br>


<!-- ---------------------------------------- noise reduction ---------------------------------------- -->

<table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2><A NAME="noisystory">A Note on Noise Reduction</a></h2></td></tr></table>
<!-- INDEX noisystory:Noise Reduction -->

<p>There is no built-in noise reduction function in Snd.  There are so many kinds of
noise (clicks, pops, rumble, hiss, hum, crackle, clips, flutter, "distortion", modulation, echoes, etc),
and what is noise in one context is signal in another (consonants, percussion, etc)
that it's hard to write a single function that can handle every case.
As far as I can tell, looking at other programs that
offer noise reduction, the main trick used is similar to Perry Cook's
Scrubber program, translated to Scheme as anoi in clm-ins.scm or fft-squelch in examp.scm.
Secondary tricks involve smoothing functions similar to smooth-channel,
and enveloping to silence stuff between tracks, etc.
I'd certainly be happy to include in Snd an all-inclusive function for noise reduction,
if anyone sends me one as a gift!  But in the meantime, 
the tools exist to do most of what you normally want to do in
this situation.  
</p>
<p>
In my case, I blithely offered to clean up some recorded telephone conversations.
The first step was to find the clipped locations (where the conversation was
accidentally over-recorded).  I did this first because there were places in the
recordings where the DC offset was huge, causing clipping in a signal that would
otherwise have been safe.  I hoped to reconstruct the signal at the clipped
points, but these would be hard to find once the DC was removed.  A quick check:
</p>

<pre>
  (<a class=quiet href="extsnd.html#countmatches">count-matches</a> (lambda (y) (or (&gt; y .9999) (&lt; y -.9999))))
</pre>
<p>
returned 5437 (in 18 minutes of sound).  That seemed high, and I thought "maybe
those are just one sample clicks that can easily be smoothed over", so
</p>

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(define* (count-clips :optional snd chn)
  (let ((y0 0.0))
    (<a class=quiet href="extsnd.html#countmatches">count-matches</a> 
     (lambda (y) (let ((val (and (or (&gt; y0 .9999) (&lt; y0 -.9999))
				 (or (&gt; y .9999) (&lt; y -.9999)))))
		   (set! y0 y)
		   val))
     0 snd chn)))
</pre></td></tr></table>

<p>
But this returned 4768!  So, it's time to make a list of clipped
portions (this function has at least one bug, but I plowed past it -- no
time for perfection...):
</p>

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(define* (list-clips :optional snd chn)
  (let* ((max-clips (count-clips snd chn))
	 (clip-data (make-vector (* 2 max-clips) 0))
	 (clip-ctr 0)
	 (clip-beg 0)
	 (clip-end 0)
	 (clip-max-len 0)
	 (in-clip #f)
	 (samp 0))
    (scan-channel
     (lambda (y)
       (if (or (&gt; y .9999) (&lt; y -.9999))
	   (if in-clip
	       (set! clip-end samp)
	       (begin
		 (set! in-clip #t)
		 (set! clip-beg samp)
		 (set! clip-end samp)))
	   (if in-clip
	       (begin
		 (set! in-clip #f)
		 (vector-set! clip-data clip-ctr clip-beg)
		 (vector-set! clip-data (1+ clip-ctr) clip-end)
		 (set! clip-max-len (max clip-max-len (1+ (- clip-end clip-beg))))
		 (set! clip-ctr (+ clip-ctr 2)))))
       (set! samp (1+ samp))
       #f)) ; make sure scan doesn't quit prematurely
    (list clip-ctr clip-max-len clip-data)))
</pre></td></tr></table>

<p>
which returned a vector of 669 clipped portions, the worst being 42 samples long!
I saved that data in a separate file, just in case of disaster:
</p>
<pre>
    (with-output-to-file "clips" (display (list-clips)))
</pre>
<p>
Since filtering can pad the sound at the beginning, and tends to
change the clipped portions, I decide to reconstruct them first.  This will
produce sample values outside -1.0 to 1.0, but I can scale everything
back down at the end.
To see how things look, I reset the graph y bounds:
</p>
<pre>
    (set! (<a class=quiet href="extsnd.html#ybounds">y-bounds</a>) (list -1.5 1.5))
</pre>
<p>
Now to conjure up a plausible sine wave between the clip begin and
end points.  (This is also "just-good-enough" software).
</p>

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(if (not (defined? 'pi)) (define pi 3.141592653589793))

(define (fix-clip clip-beg-1 clip-end-1)
  (if (&gt; clip-end-1 clip-beg-1)
      (let* ((dur (1+ (- clip-end-1 clip-beg-1)))
	     (samps (<a class=quiet href="extsnd.html#channeltovct">channel-&gt;vct</a> (- clip-beg-1 4) (+ dur 9)))
	     (clip-beg 3)
	     (clip-end (+ dur 4)))
	(let ((samp0 (<a class=quiet href="extsnd.html#vctref">vct-ref</a> samps clip-beg))
	      (samp1 (<a class=quiet href="extsnd.html#vctref">vct-ref</a> samps clip-end)))
	  (if (or (&gt; samp0 .99) (&lt; samp0 -.99))
	      (begin
	        ;; weird!  some of the clipped passages have "knees"
		;;   this looks nuts, but no time to scratch my head
		(set! clip-beg (1- clip-beg))
		(set! samp0 (<a class=quiet href="extsnd.html#vctref">vct-ref</a> samps clip-beg))
		(if (or (&gt; samp0 .99) (&lt; samp0 -.99))
		    (begin
		      (set! clip-beg (1- clip-beg))
		      (set! samp0 (<a class=quiet href="extsnd.html#vctref">vct-ref</a> samps clip-beg))))))
	  (if (or (&gt; samp1 .99) (&lt; samp1 -.99))
	      (begin
		(set! clip-end (1+ clip-end))
		(set! samp1 (<a class=quiet href="extsnd.html#vctref">vct-ref</a> samps clip-end))
		(if (or (&gt; samp1 .99) (&lt; samp1 -.99))
		    (begin
		      (set! clip-end (1+ clip-end))
		      (set! samp1 (<a class=quiet href="extsnd.html#vctref">vct-ref</a> samps clip-end))))))
          ;; now we have semi-plausible bounds
          ;; make sine dependent on rate of change of current 
	  (let* ((samp00 (<a class=quiet href="extsnd.html#vctref">vct-ref</a> samps (1- clip-beg)))
		 (samp11 (<a class=quiet href="extsnd.html#vctref">vct-ref</a> samps (1+ clip-end)))
		 (dist (- clip-end clip-beg))
		 (incr (/ pi dist))
		 (amp (* .125 (+ (abs (- samp0 samp00)) (abs (- samp1 samp11))) dist)))
	    (if (&gt; samp0 0.0)
                ;; clipped at 1.0
		(do ((i (1+ clip-beg) (1+ i))
		     (angle incr (+ angle incr)))
		    ((= i clip-end))
		  (<a class=quiet href="extsnd.html#vctset">vct-set!</a> samps i (+ 1.0 (* amp (sin angle)))))
                ;; clipped at -1.0
		(do ((i (1+ clip-beg) (1+ i))
		     (angle incr (+ angle incr)))
		    ((= i clip-end))
		  (<a class=quiet href="extsnd.html#vctset">vct-set!</a> samps i (- -1.0 (* amp (sin angle))))))
	    (<a class=quiet href="extsnd.html#vcttochannel">vct-&gt;channel</a> samps (- clip-beg-1 4))))
	#t) ; return values so I can tell when I hit a 1-sample section during testing
      #f))

(define (fix-it n)
  ;; turn off graphics and fix all the clipped sections
  (set! (<a class=quiet href="extsnd.html#squelchupdate">squelch-update</a>) #t)
  (do ((i 0 (1+ i)))
      ((or (= i n) (c-g?))) 
      ;; "clips" here is a list form of the earlier vector of clip locations
    (fix-clip (list-ref clips (* i 2)) 
	      (list-ref clips (1+ (* i 2)))))
  (set! (<a class=quiet href="extsnd.html#squelchupdate">squelch-update</a>) #f))

(fix-it 669)
</pre></td></tr></table>

<p>
This produced 418 edits, with a maxamp of 2.26.  So scale it back down:
<code>(<a class=quiet href="extsnd.html#scaleto">scale-to</a> .9)</code>.
Next I ran some large ffts to see what sort of overall spectrum I had:
<code>(set! (<a class=quiet href="extsnd.html#transformsize">transform-size</a>) (expt 2 23))</code>.
This showed a massive DC component, and numerous harmonics of 60 Hz.
I decided to get rid of the portions that were clearly noise.  Since I was dealing with
telephone recordings, I assumed anything under 40 Hz or above
4000 Hz was extraneous.
</p>


<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(define* (<a name="notchoutrumbleandhiss">notch-out-rumble-and-hiss</a> :optional snd chn)
  (let* ((cur-srate (exact-&gt;inexact (<a class=quiet href="extsnd.html#srate">srate</a> snd))))
    (<a class=quiet href="extsnd.html#filtersound">filter-sound</a>
     (list 0.0 0.0                    ; get rid of DC
	   (/ 80.0 cur-srate) 0.0     ; get rid of anything under 40 Hz (1.0=srate/2 here)
	   (/ 90.0 cur-srate) 1.0     ; now the passband
	   (/ 7000.0 cur-srate) 1.0 
	   (/ 8000.0 cur-srate) 0.0   ; end passband (40..4000)
	   1.0 0.0)                   ; get rid of some of the hiss
     ;; since I'm assuming the minimum band is 10 Hz here, 
     ;;   cur-srate/10 rounded up to next power of 2 seems a safe filter size
     ;;   filter-sound will actually use overlap-add convolution in this case
     (inexact-&gt;exact (expt 2 (ceiling (/ (log (/ cur-srate 10.0)) (log 2.0)))))
     snd chn)))

(notch-out-rumble-and-hiss)
</pre></td></tr></table>

<p>
By now it was obvious I needed a simple way to play portions of the
sound before and after an edit, sometimes with a tracking cursor.
So I bound a few keys:
</p>


<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(define (play-from-cursor current)
  (<a class=quiet href="extsnd.html#play">play</a> (<a class=quiet href="extsnd.html#cursor">cursor</a>) #f #f #f #f (if current #f (1- (<a class=quiet href="extsnd.html#editposition">edit-position</a>)))))

(define (play-from-cursor-with-tracking current)
  ;; patterned after pfc in extsnd.html
  (let ((old-tracking (<a class=quiet href="extsnd.html#withtrackingcursor">with-tracking-cursor</a>)))
    (set! (<a class=quiet href="extsnd.html#withtrackingcursor">with-tracking-cursor</a>) #t)
    (add-hook! <a class=quiet href="extsnd.html#stopplayinghook">stop-playing-hook</a> 
	       (lambda (snd)
		 (set! (<a class=quiet href="extsnd.html#withtrackingcursor">with-tracking-cursor</a>) old-tracking)))
    (<a class=quiet href="extsnd.html#play">play</a> (<a class=quiet href="extsnd.html#cursor">cursor</a>) #f #f #f #f (if current #f (1- (<a class=quiet href="extsnd.html#editposition">edit-position</a>))))))

(<a class=quiet href="extsnd.html#bindkey">bind-key</a> #\p 0 (lambda () "play from cursor" (play-from-cursor #t) keyboard-no-action))
(<a class=quiet href="extsnd.html#bindkey">bind-key</a> #\P 0 (lambda () "play previous from cursor" (play-from-cursor #f) keyboard-no-action))
(<a class=quiet href="extsnd.html#bindkey">bind-key</a> #\p 4 (lambda () "play from cursor with tracking" (play-from-cursor-with-tracking #t) keyboard-no-action))
</pre></td></tr></table>

<p>
So, if the mouse is in the channel graph, 'p' plays from the cursor,
'P' plays the previous version from the cursor, and 'C-p' plays from
the cursor with a "tracking cursor".
</p>
<p>
In several of the sections (the overall sound consisted of a couple dozen
separate conversations), there was some very loud mid-range tone that I
dubbed "transformer noise".  To figure out what frequencies it represented,
I FFT'd a portion containing only that noise and got this spectrum
(plus a zillion other peaks that didn't look interesting):
</p>
<pre>
    ((425 .05) (450 .01) (546 .02) (667 .01) (789 .034) (910 .032) (470 .01))
</pre>
<p>To hear that, I took play-sound from play.scm, and
changed it to play a list of sine tones generated on the fly (the changes are in red):
</p>

<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(define (<em class=red>play-sines freqs-and-amps</em>)
  ;; <em class=red>(play-sines '((440 .4) (660 .3)))</em>
  (let* ((size 256)
	 (audio-info (<a class=quiet href="#openplayoutput">open-play-output</a> <em class=red>1 22050</em> #f size))
	 (audio-fd (car audio-info)))
    (set! size (caddr audio-info))
    (if (not (= audio-fd -1))
	(let ((len <em class=red>22050</em>) ; <em class=red>play a one-second tone</em>
	      (<em class=red>oscs (map make-oscil (map car freqs-and-amps))</em>)
	      (<em class=red>amps (map cadr freqs-and-amps)</em>)
	      (data (<a class=quiet href="extsnd.html#makesounddata">make-sound-data</a> outchans size)))  
	      ;; the data buffer passed to the function (func above), then to mus-audio-write
	  (set! (dac-size) outbytes)
	  (do ((beg 0 (+ beg size)))
	      ((or (c-g?)                   ; C-g to stop in mid-stream
		   (&lt; beg len)))
	    (do ((i 0 (1+ i)))
		((= i size))
	      (<em class=red>sound-data-set! data 0 i (apply + (map (lambda (o a) (* a (<a class=quiet href="clm.html#oscil">oscil</a> o))) oscs amps))</em>))
	    (<a class=quiet href="extsnd.html#musaudiowrite">mus-audio-write</a> audio-fd data size))
	  (<a class=quiet href="extsnd.html#musaudioclose">mus-audio-close</a> audio-fd))
        #f)))
</pre></td></tr></table>

<p>
The only changes to the original function set up and use a list of oscillators, each with
its own amplitude, rather than opening and reading a sound file. (I added this function to play.scm).
I could then resynthesize the suspect tone with:
</p>
<pre>
    (play-sines '((425 .05) (450 .01) (546 .02) (667 .01) (789 .034) (910 .032) (470 .01)))
</pre>
<p>
And to my surprise, the result was close to the main portion of the hum.  So now to notch out those frequencies,
and see what is left:
</p>


<table border=0 cellpadding=5 hspace=20><tr><td bgcolor="#fafafa"><pre>
(define* (make-notch-frequency-response cur-srate freqs :optional (notch-width 2))
  (let ((freq-response (list 0.0 0.0)))
    (for-each
     (lambda (i)
      (set! freq-response (cons (/ (* 2 (- i notch-width)) cur-srate) freq-response))       ; left upper y hz
      (set! freq-response (cons 1.0 freq-response))                                         ; left upper y resp
      (set! freq-response (cons (/ (* 2 (- i (/ notch-width 2))) cur-srate) freq-response)) ; left bottom y hz
      (set! freq-response (cons 0.0 freq-response))                                         ; left bottom y resp
      (set! freq-response (cons (/ (* 2 (+ i (/ notch-width 2))) cur-srate) freq-response)) ; right bottom y hz
      (set! freq-response (cons 0.0 freq-response))                                         ; right bottom y resp
      (set! freq-response (cons (/ (* 2 (+ i notch-width)) cur-srate) freq-response))       ; right upper y hz
      (set! freq-response (cons 1.0 freq-response)))                                        ; right upper y resp
     freqs)
    (set! freq-response (cons 1.0 freq-response))
    (set! freq-response (cons 1.0 freq-response)) 
    (reverse freq-response)))

(define* (notch-channel freqs :optional filter-order snd chn (notch-width 2))
  (<a class=quiet href="extsnd.html#filtersound">filter-sound</a> (make-notch-frequency-response (exact-&gt;inexact (<a class=quiet href="extsnd.html#srate">srate</a> snd)) freqs notch-width)
		(or filter-order 
                    (inexact-&gt;exact (expt 2 (ceiling (/ (log (/ (<a class=quiet href="extsnd.html#srate">srate</a> snd) notch-width))
                                                        (log 2.0))))))
		snd chn))

(define* (notch-sound freqs :optional filter-order snd (notch-width 2))
  (<a class=quiet href="extsnd.html#filtersound">filter-sound</a> (make-notch-frequency-response (exact-&gt;inexact (<a class=quiet href="extsnd.html#srate">srate</a> snd)) freqs notch-width)
		(or filter-order 
                    (inexact-&gt;exact (expt 2 (ceiling (/ (log (/ (<a class=quiet href="extsnd.html#srate">srate</a> snd) notch-width)) 
                                                        (log 2.0))))))
		snd))

(define* (notch-selection freqs :optional filter-order (notch-width 2))
  (<a class=quiet href="extsnd.html#filterselection">filter-selection</a> (make-notch-frequency-response (exact-&gt;inexact (<a class=quiet href="extsnd.html#selectionsrate">selection-srate</a>)) freqs notch-width)
		    (or filter-order 
                        (inexact-&gt;exact (expt 2 (ceiling (/ (log (/ (<a class=quiet href="extsnd.html#selectionsrate">selection-srate</a>) notch-width)) 
                                                            (log 2.0))))))))

(notch-sound (list 425 450 470 546 667 789 910) #f 1 10)
</pre></td></tr></table>

<p>

And the steady hum was largely erased.  (I added these functions to dsp.scm, with some subsequent changes). Unfortunately, in many cases,
this also changed the timbre of the voices, and that wasn't acceptable
in this context.  
I goofed around with the notch-width and filter-size parameters, looking
for something that that would still do the trick without removing half
the personal side of the voices, but in only a few cases was the result
usable. (The human ear is so attuned to the voice, that you can remove
all but a small passband and still get understandable speech).
In my case, what was being said was not very important, but the
individual characteristics of each voice were.
</p>
<p>
The next step was to take out noisy sections between snippets, mostly
using <code>(<a class=quiet href="extsnd.html#envsoundselection">env-selection</a> '(0 1 1 0 10 0 11 1))</code>
and equalizing each snippet, more or less, with scale-selection-by.
There were a few "you-are-being-recorded" beeps which I deleted (via the Edit
menu delete selection option).  
In some of the conversations,
between sections of speech the background hum would gradually increase, then
the voice would abruptly start with a large peak amplitude. These
were fixed mostly with small-section scale-by's and envelopes.
In the female voice sections, it seemed to help to:
<code>(<a class=quiet href="extsnd.html#filterselection">filter-selection</a> '(0 0 .01 0 .02 1 1 1) 1024)</code>
which got rid of some of the rumble without noticeably affecting
the vocal timbre.
</p>

<p>This may seem like a lot of programming for a simple problem, but
I hadn't previously thought about noise reduction (so nothing was
already written), and once this stuff is written, no one else has
to do anything but load it.  Most of the functions mentioned
here are now in play.scm or dsp.scm.
(Note added much later: <a href="sndscm.html#unclipchannel">unclip-channel</a>
does a much better job at reconstruction than the code described here; it uses
LPC to predict what the lost samples were; see dsp.scm).
</p>

<TABLE border=3 bordercolor="tan" hspace=40><tr><td>
<blockquote><small>
<br>
clicks: <a href="extsnd.html#smoothchannel">smooth-channel</a>, <a href="#removeclicks">remove-clicks</a>, <a href="sndscm.html#fftsmoother">fft-smoother</a><br>
rumble, hiss: <a href="#notchoutrumbleandhiss">notch-out-rumble-and-hiss</a>, <a href="#fftsquelch">fft-squelch</a>, <a href="#fftcancel">fft-cancel</a><br>
hum: <a href="#notchchannel">notch-channel</a><br>
via CLM ins: <a href="anoi.ins">anoi.ins</a><br>
<br>
</small></blockquote>
</td></tr></TABLE>
<br>

<center>
<table bgcolor="aliceblue" border=0 cellspacing=8><tr>
<td><small>related documentation:</small></td>
<td><small><a href="snd.html" onmouseover="return escape('basic Snd user-interface documentation')">snd.html</a></small></td>
<td><small><a href="extsnd.html" onmouseover="return escape('Snd extension and customization')">extsnd.html</a></small></td>
<td><small><a href="grfsnd.html" onmouseover="return escape('Snd configuration, connection to other libraries and programs')">grfsnd.html</a></small></td>
<td><small><a href="clm.html" onmouseover="return escape('sound synthesis generators, with-sound, instruments')">clm.html</a></small></td>
<td><small><a href="sndlib.html" onmouseover="return escape('library that handles sound files')">sndlib.html</a></small></td>
<td><small><a href="libxm.html" onmouseover="return escape('library that ties Motif and Gtk into Snd')">libxm.html</a></small></td>
<td><small><a href="fm.html" onmouseover="return escape('introduction to frequency modulation')">fm.html</a></small></td>
<td><small><a href="index.html" onmouseover="return escape('an actual index, not some introductory file')">index.html</a></small></td>
</tr></table>
</center>

<script language=JavaScript type="text/javascript" src="wz_tooltip.js"></script>
</body>
</html>


