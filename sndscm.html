<html>
<!-- documentation for some of the Scheme code included with Snd -->
<head>
<title>Scheme Functions included with Snd</title>
<style type="text/css">
<!-- 
	EM.red {color:red; font-style:normal}
        EM.error {color:chocolate; font-style:normal}
        EM.narg {color:chocolate; font-style:italic}
        EM.targ {color:darkgreen; font-style:italic}
        EM.typing {color:maroon; font-style: normal}
        EM.listener {color:darkblue; font-style: normal}
	EM.def {font-weight: bold; font-style: normal}
	H1 {text-align: center}
	UL {list-style-type: none}
	SPAN.box {background: beige; width: 100%; font-style: normal; text-align: center; border-width: thin; border-style: ridge}
	SPAN.bbox {background: lightsteelblue; width: 100%; font-style: normal; border-width: thin; border-style: ridge}
	SPAN.cbox {background: lightgreen; width: 100%; font-style: normal; border-width: thin; border-style: ridge}
	SPAN.htmlbox {background: tan; font-style: normal; font-size: small; border-width: thin; border-style: ridge}
-->
</style>
</head>
<body bgcolor=white>
<span class=box><h1>Scheme Functions included with Snd</h1></span>
<br>
<center>
<span class=htmlbox>related documentation</span><span class=htmlbox><a href="snd.html">snd.html</a><spacer type=horizontal size=25><a href="extsnd.html">extsnd.html</a><spacer type=horizontal size=25><a href="grfsnd.html">grfsnd.html</a><spacer type=horizontal size=25><a href="clm.html">clm.html</a><spacer type=horizontal size=25><a href="sndlib.html">sndlib.html</a><spacer type=horizontal size=25><a href="libxm.html">libxm.html</a><spacer type=horizontal size=25><a href="index.html">index.html</a></span>
</center>

<!-- I'm using A NAME (i.e caps) where the entity should be ignored by the indexer (index.cl) -->

<center><A NAME="introduction"></a>
<ul>
  <li><a href="#autosavedoc">autosave.scm: auto-save support</a>
  <li><a href="#belldoc">bell.scm: the fm-bell from CLM</a>
  <li><a href="#bessdoc">bess.scm, bess.rb: FM demo</a>
  <li><a href="#birddoc">bird.scm, bird.rb: North-American birds</a>
  <li><a href="#dlpdoc">dlp and tutorial directories from Dave Phillips</a>
  <li><a href="#drawdoc">draw.scm: graphics additions</a>
  <li><a href="#dspdoc">dsp.scm: various DSP-related procedures</a>
  <li><a href="#editmenudoc">edit-menu.scm: Edit menu additions</a>
  <li><a href="#effectsdoc">new-effects.scm, gtk-effects.scm, effects.rb: an Effects menu</a>
  <li><a href="#envdoc">env.scm: envelope functions</a>
  <li><a href="#enveddoc">enved.scm: envelope editor</a>
  <li><a href="#eventdoc">event.scm: xm module stuff</a>
  <li><a href="#exampdoc">examp.scm, examp.rb: many examples</a>
  <li><a href="#extensionsdoc">extensions.scm: various generally useful Snd extensions</a>
  <li><a href="#fadedoc">fade.scm: frequency-domain cross-fades</a>
  <li><a href="#fmvdoc">fmv.scm: a controller for the fm-violin</a>
  <li><a href="#gmdoc">gm.scm: gmeteor support</a>
  <li><a href="#goopsnddoc">goopsnd.scm: look at Goops</a>
  <li><a href="#hooksdoc">hooks.scm: functions related to hooks</a>
  <li><a href="#indexdoc">index.scm, index.rb: snd-help extension</a>
  <li><a href="#maracadoc">maraca.scm: Perry Cook's maraca physical model</a>
  <li><a href="#marksdoc">marks.scm: functions related to marks</a>
  <li><a href="#maxfdoc">maxf.scm, maxf.rb: Max Mathews resonator</a>
  <li><a href="#mixdoc">mix.scm: functions related to mixes and tracks</a>
  <li><a href="#moogdoc">moog.scm: Moog filter</a>
  <li><a href="#musglyphs">musglyphs.scm: Music notation symbols (from CMN)</a>
  <li><a href="#nbdoc">nb.scm: Popup File info etc</a>
  <li><a href="#peakenvdoc">peak-env.scm: peak envelope support</a>
  <li><a href="#pianodoc">piano.scm, piano.rb: piano physical model</a>
  <li><a href="#playdoc">play.scm: play-related functions</a>
  <li><a href="#popupdoc">popup.scm, gtk-popup.scm, popup.rb: Popup menu specializations</a>
  <li><a href="#pqwvoxdoc">pqwvox.scm: phase-quadrature waveshaping</a>
  <li><a href="#prc95doc">prc95.scm: Perry Cook's physical model examples</a>
  <li><a href="#pvocdoc">pvoc.scm: phase-vocoder</a>
  <li><a href="#rgbdoc">rgb.scm, rgb.rb: colors</a>
  <li><a href="#rtiodoc">rtio.scm: real-time stuff</a>
  <li><a href="#rubberdoc">rubber.scm, rubber.rb: rubber-sound</a>
  <li><a href="#singerdoc">singer.scm: Perry Cook's vocal-tract physical model</a>
  <li><a href="#snd4doc">snd4.scm: Backwards compatibility for version 4</a>
  <li><a href="#snd5doc">snd5.scm: Backwards compatibility for version 5</a>
  <li><a href="#snd6doc">snd6.scm: Backwards compatibility for version 6</a>
  <li><a href="#sndgldoc">snd-gl.scm: OpenGL examples (gl.c)</a>
  <li><a href="#sndmotifdoc">snd-motif.scm, snd-gtk.scm: Motif/Gtk module (xm.c, xg.c)</a>
  <li><a href="#sndtestdoc">snd-test.scm, snd_test.rb, and event.scm: Snd regression tests</a>
  <li><a href="#straddoc">strad.scm, strad.rb: string physical model (from CLM)</a>
  <li><a href="#vdoc">v.scm, v.rb: fm-violin</a>
  <li><a href="#wsdoc">ws.scm: with-sound</a>
  <li><a href="#xmenveddoc">xm-enved.scm, xm-enved.rb</a>
  <li><a href="#zipdoc">zip.scm: the zipper (a cross-fader)</a>
  <li><a href="#extsndvarexpl">A Note on Scheme variables in Snd</a>
  <li><a href="#extsndasneededexpl">A Note on "As-Needed" input functions</a>
  <li><a href="#extsndcgens">A Note on User-defined Generators in C-CLM</a>
  <li><a href="#continuations">About Continuations</a>
</ul>
</center>
<br>

<p>This file contains notes on the Scheme and Ruby files included with Snd.
To use any of these files, (load &lt;file&gt;); for example <code>(load "bell.scm")</code>.  To start Snd with
the file already loaded, <code>snd -l bell.scm</code>, or put the load statement in ~/.snd.
</p>

<A NAME="autosavedoc"></a><span class=box><h2>autosave.scm</h2></span>

<pre>
  <em class=def><a name="exautosave">auto-save</a></em>
  <em class=def><a name="excancelautosave">cancel-auto-save</a></em>
</pre>
<!-- I(auto save):L(auto-save)(exautosave) -->
<!-- I(auto save):A(exautosave) -->

<p>The auto-save code sets up a background process that checks periodically for
unsaved edits, and if any are found it saves them in a temporary file.
The time between checks
is set by the variable <i>auto-save-interval</i> which defaults to 60.0 seconds.
To start auto-saving, (load "autosave.scm").  Thereafter <code>(cancel-auto-save)</code>
stops autosaving, and <code>(auto-save)</code> restarts it.
</p>

<A NAME="belldoc"></a><span class=box><h2>bell.scm</h2></span>
<pre>
  <em class=def><A NAME="fmbell">fm-bell</a></em> startime dur frequency amplitude amp-env index-env index
</pre>
<p>The FM bell was developed by Michael McNabb in Mus10 in the late '70s.  It is intended
for low bell sounds (say middle C or so). The lines
</p>
<pre>
	   (mod1 (make-oscil (* frequency 2)))
	   (mod2 (make-oscil (* frequency 1.41)))
	   (mod3 (make-oscil (* frequency 2.82)))
	   (mod4 (make-oscil (* frequency 2.4)))
	   (car1 (make-oscil frequency))
	   (car2 (make-oscil frequency))
	   (car3 (make-oscil (* frequency 2.4)))
</pre>
<p>set up three FM pairs, car1+mod1 handling the basic harmonic spectra,
car2+mod2 creating inharmonic spectra (using the square root of 2 more or less
at random), and car3+mod3 putting a sort of formant at the minor third
(2.4 = a ratio of 12/5 = octave+6/5 = minor tenth).
</p>
<pre>
  (define fbell '(0 1 2 1.1000 25 .7500 75 .5000 100 .2000 ))
  (define abell '(0 0 .1000 1 10 .6000 25 .3000 50 .1500 90 .1000 100 0 ))
  (fm-bell 0.0 1.0 220.0 .5 abell fbell 1.0)
</pre>

<A NAME="bessdoc"></a><span class=box><h2>bess.scm</h2></span>

<p>bess.scm is a Guile script (independent of Snd) that loads sndlib and xmlib into Guile,
opens the DAC, puts up a bunch of scale widgets, and starts two CLM oscils doing
frequency modulation in semi-real-time (how "real-time" it is depends on your
audio setup).  This is a translation to the Sndlib/Libxm system of bess.cl in CLM.
Michael Scholz has contributed a Ruby translation of this with many improvements:
bess.rb.
</p>


<A NAME="birddoc"></a><span class=box><h2>bird.scm</h2></span>
<pre>
  <em class=def><A NAME="bird">bird</a></em> start dur frequency freqskew amplitude freq-envelope amp-envelope
  <em class=def><A NAME="bigbird">bigbird</a></em> start dur frequency freqskew amplitude freq-envelope amp-envelope partials
  <em class=def><A NAME="one-bird">one-bird</a></em> beg maxdur func birdname
  <em class=def><A NAME="make-birds">make-birds</a></em> &amp;optional (output-file "test.snd")
</pre>
<p>
bird.scm is a translation of the Sambox/CLM bird songs.  The two instruments set
up a simple sine wave (bird) and simple waveshaping synthesis (bigbird).  Use a
low-pass filter for distance effects (a bird song sounds really silly
reverberated).  All the real information is in the amplitude and frequency
envelopes.  These were transcribed from sonograms found in some bird guides and articles from
the Cornell Ornithology Lab.  The variable <i>with-editable-mixes</i> controls
whether each bird is tagged so that you can move it around later (for a pretty picture of the
result, check <a href="snd.html#mixingfiles">this</a> out).  The function
<i>one-bird</i> mixes in one complete birdsong, using the bird's name for the
edit history list.  Many of these birds were used in "Colony".  To hear all the
birds, <code>(make-birds)</code>.  This writes the sequence out as "test.snd"; give the
desired file name as the (optional) argument to <i>make-birds</i>: <code>(make-birds "birds.snd")</code>.
Waveshaping is described in Le Brun, "Digital Waveshaping Synthesis", JAES 1979 April, vol 27, no 4, p250.
</p>
<pre>
(define (one-bird beg maxdur func birdname)
  (set! out-data (make-vct (round (* (srate) maxdur))))
  (func)
  (as-one-edit 
   (lambda ()
     (mix-vct out-data (round (* beg (srate))) out-file 0 with-editable-mixes))
   birdname))
</pre>
<p>The <i>one-bird</i> function collects all the individual tweets of a given bird song
into one vct object, then mixes that into the output sound.  The <i>beg</i> and <i>maxdur</i>
arguments set the begin time and maximum duration in seconds of the mix; the duration is
used to allocate the global vct object (<i>out-data</i>. The <i>func</i> argument is
a Scheme function of no arguments (known in Scheme as a thunk).  It is called
via <code>(func)</code>; the assumption is that <i>func</i> will actually provide
a complete bird song.  For example:</p>
<pre>
(define (bobwhite beg)
  (let ((bobup1 '(.00 .00 .40 1.00 1.00 1.0))
	(bobup2 '(.00 .00 .65 .50 1.00 1.0)))
    (one-bird beg 2.0
     (lambda ()
       (bigbird .4 .2 1800 200 .1 bobup1 main-amp '(1 1 2 .02))
       (bigbird 1 .20 1800 1200 .2 bobup2 main-amp '(1 1 2 .02)))
     (report-in-minibuffer "bobwhite"))))
</pre>
<p>defines a Bobwhite call (a kind of mid-western quail, <i>Colinus virginianus</i> -- I grew up in Oklahoma
and heard these calls every day). The <i>func</i> in this case is:</p>
<pre>
     (lambda ()
       (bigbird .4 .2 1800 200 .1 bobup1 main-amp '(1 1 2 .02))
       (bigbird 1 .20 1800 1200 .2 bobup2 main-amp '(1 1 2 .02)))
</pre>
<p>which calls bigbird twice (the "bob" and the "white"). It also reports the
name "bobwhite" in the minibuffer (this is mostly to let the caller know that
something is happening -- since we aren't calling update-graph, there's no
visual indication that a bird has been mixed in).
In <i>bigbird</i> the lines
</p>
<pre>
           ...
	   (coeffs (partials-&gt;polynomial (normalize-partials partials)))
           ...
		     (polynomial coeffs
				 (oscil os (env gls-env))))))
</pre>
<p>setup and run the waveshaping synthesis (in this case it's just a fast
additive synthesis).  <i>partials-&gt;polynomial</i> calculates the Chebyshev
polynomial coefficients given the desired spectrum; the spectrum then
results from driving that polynomial with an oscillator.  Besides the
bird guides, there are now numerous recordings of birds that could
easily be turned into sonograms and transcribed as envelopes.
</p>
<p>In CLM, the bird is:</p>
<pre>
(definstrument bird (startime dur frequency freq-skew amplitude freq-envelope amp-envelope 
	             &amp;optional (lpfilt 1.0) (degree 0) (reverb-amount 0))
  (multiple-value-bind (beg end) (times-&gt;samples startime dur)
    (let* ((amp-env (make-env amp-envelope amplitude dur))
	   (gls-env (make-env freq-envelope (hz-&gt;radians freq-skew) dur))
	   (loc (make-locsig :degree degree :distance 1.0 :reverb reverb-amount))
	   (fil (make-one-pole lpfilt (- 1.0 lpfilt)))
	   (s (make-oscil :frequency frequency)))
      (run
       (loop for i from beg to end do
	 (locsig loc i (one-pole fil (* (env amp-env) (oscil s (env gls-env))))))))))
</pre>
<p>The bird.scm version could easily include the one-pole filter and so on.
The Ruby version of this file is bird.rb.  Just for comparison, the bird instrument
in Ruby is:</p>
<pre>
def bird(start, dur, frequency, freqskew, amplitude, freq_envelope, amp_envelope)
  gls_env = make_env(freq_envelope, hz2radians(freqskew), dur)
  os = make_oscil(frequency)
  amp_env = make_env(amp_envelope, amplitude, dur)
  beg = (srate() * start).round
  len = (srate() * dur).round
  local_data  = make_vct len
  vct_map!(local_data, Proc.new { || env(amp_env) * oscil(os, env(gls_env)) })
  vct_add!($out_data, local_data, beg)
end
</pre>
<br>

<A NAME="dlpdoc"></a><span class=box><h2>dlp directory entries</h2></span>

<p>The dlp directory contains a variety of useful additions written by Dave Phillips.  These
include:
</p>
<pre>
  <em class=def>dp-new-effects.scm</em>     a version of new-effects.scm 
  <em class=def>misc.scm</em>               loads files for enhanced interface, many new menu options
  <em class=def>new-icons.scm</em>          icon box entries
  <em class=def>special-menu.scm</em>       the Special menu (OGG/MP3 etc)
  <em class=def>mix-menu.scm</em>           the Mix menu
  <em class=def>panic.scm</em>              the Panic menu (to stop sound output)
  <em class=def>track-colors.scm</em>       track color choices (for mixing)
  <em class=def>fft-menu.scm</em>           FFT-based editing
  <em class=def>new-backgrounds.scm</em>    background choices (granite Snd!)
  <em class=def>plugins-menu.scm</em>       ladspa menu
  <em class=def>marks-menu.scm</em>         the Marks menu
  <em class=def>new-buttons.scm</em>        sets the icon box actions
  <em class=def>README</em>                 loading info
</pre>
<p>See the individual files and Dave's tutorial (in the tutorial directory) for more details.
</p>

<p>There are a few other files in the main directory that I haven't documented yet:</p>
<pre>
  <em class=def>DotEmacs</em>               Emacs init file (Fernando Lopez-Lezcano)
  <em class=def>edit123.scm</em>            Handy editing sequences (Tom Roth)
  <em class=def>inf-snd.el</em>             Ruby/Guile Emacs connection (Michael Scholz)
  <em class=def>rmsgain.scm</em>            amplitude via rms (Fabio Furlanete)
</pre>


<A NAME="drawdoc"></a><span class=box><h2>draw.scm</h2></span>

<p>draw.scm has examples of graphics additions; some of these are shown in extsnd.html.
<b>display-energy</b> is a lisp-graph-hook procedure that displays the current time
domain data as energy, not amplitude, using the y zoom slider to control the
y axis.  The other procedures in draw.scm are intended for use with the
after-graph-hook.  
<b>display-colored-samples</b> (color beg dur snd chn) displays samples from beg for dur in color
whenever they're in the current view. This is intended for use with <b>color-samples</b>. 
(<a name="colorsamples">color-samples</a> color &amp;optional beg dur snd chn) causes samples from beg to beg+dur to be displayed in color;
to undo this, use <b>uncolor-samples</b>.
<b>display-previous-edits</b> displays all edits of the current sound, with older versions gradually fading away.
<b>overlay-sounds</b> overlays onto its first argument all subsequent arguments: (overlay-sounds 1 0 3).
<b>make-current-window-display</b>
displays in the upper right corner the overall current sound and where the current window fits in it.
This info is implicit in the x sliders, but a redundant graph doesn't hurt.  If you click in that graph,
the cursor is moved to the clicked point.
</p>
<center><img src="uppergrf.png" alt="make-current-window-display"></center>
<br>
<p>
<b>click-for-listener-help</b> is intended as a <a href="extsnd.html#listenerclickhook">listener-click-hook entry</a>.  It posts help about
the closest entity it can find whenever you double click in the listener.  Unfortunately, the help
dialog is a bit clunky for a use like this, but the minibuffer has only one line, and
tooltips are irritating in their own way; perhaps it should post the help at the bottom of
the listener?
</p>
<br>

<A NAME="dspdoc"></a><span class=box><h2>dsp.scm</h2></span>

  <ul>
    <li>Dolph-Chebyshev fft data window
    <li>dht -- slow Hartley transform 
    <li>find-sine -- DFT at a particular frequency
    <li>Butterworth filters
    <li>frequency-response -&gt; FIR coeffs
    <li>move sound down 8ve using fft
    <li>compute-uniform-circular-string (and scanned-synthesis)
    <li>"frequency division"
    <li>"adaptive saturation"
    <li>spike effect
    <li>easily-fooled autocorrelation-based pitch tracker 
    <li>zero-phase, rotate-phase
    <li>asyfm
    <li>cosine-summation, legendre-summation
    <li>brighten-slightly
    <li>simple FIR filters
  </ul>

<p>These are DSP-related procedures that aren't closely tied to CLM.
</p>
<pre>
  <em class=def><A NAME="exdolph">dolph</a></em> n gamma
  <em class=def><A NAME="exdht">dht</a></em> data
  <em class=def><A NAME="exfindsine">find-sine</a></em> freq beg dur
  <em class=def><A NAME="exbutter">butter</a></em> gen
  <em class=def><A NAME="exmakebutterhighpass">make-butter-high-pass</a></em> freq
  <em class=def><A NAME="exmakebutterlowpass">make-butter-low-pass</a></em> freq
  <em class=def><A NAME="exmakebutterbandpass">make-butter-band-pass</a></em> freq bandwidth
  <em class=def><A NAME="exmakebutterbandreject">make-butter-band-reject</a></em> freq bandwidth
  <em class=def><A NAME="exfltit1">fltit-1</a></em>
  <em class=def><A NAME="exspectrum2coeffs">spectrum-&gt;coeffs</a></em> order spectrum-envelope
  <em class=def><A NAME="exdownoct">down-oct</a></em>
  <em class=def><A NAME="exfreqdiv">freqdiv</a></em> n
  <em class=def><A NAME="exadsat">adsat</a></em> size
  <em class=def><A NAME="exspike">spike</a></em>
  <em class=def><a name="excomputeuniformcircularstring">compute-uniform-circular-string</a></em> size x0 x1 x2 mass xspring damp
  <em class=def><A NAME="excomputestring">compute-string</a></em>size x0 x1 x2 masses xsprings esprings damps haptics
  <em class=def><A NAME="exppitcher">spot-freq</a></em>
  <em class=def><A NAME="zerophase">zero-phase, rotate-phase</a></em>
  <em class=def><A NAME="asyfm">both forms of asymmetric-fm</a></em>
  <em class=def><a name="cosinesummation">cosine-summation</a></em>
  <em class=def><a name="legendresummation">legendre-summation</a></em>
  <em class=def><A NAME="brightenslightly">brighten-slightly</a></em> amount
  <em class=def><a name="makehilberttransform">make-hilbert-transform</a></em> length
  <em class=def><a name="makelowpass">make-lowpass</a></em> fc length
  <em class=def><a name="makehighpass">make-highpass</a></em> fc length
  <em class=def><a name="makebandpass">make-bandpass</a></em> flo fhi length
  <em class=def><a name="makebandstop">make-bandstop</a></em> flo fhi length
  <em class=def><a name="makedifferentiator">make-differentiator</a></em> length
</pre>

<p><i>dolph</i> is the Dolph-Chebyshev fft data window, taken
from Richard Lyons, "Understanding DSP".
<i>dht</i> is the slow form of the Hartley transform, 
taken from Perry Cook's SignalProcessor.m.
The Hartley transform is a kind of Fourier transform.
A similar function, using the DFT, is <i>find-sine</i>.
It returns the amplitude and initial-phase (for sin) at freq between beg and dur.
The Butterworth filters are taken from Sam Heisz's CLM version
of Paris Smaragdis's Csound version of Charles Dodge's code from "Computer Music: synthesis, composition, and performance".
See also the notch filter in new-effects.scm.
<i>spectrum-&gt;coeffs</i> is a Scheme
version of Snd's very simple spectrum-&gt;coefficients procedure ("frequency sampling").
It returns the FIR filter coefficients given the filter order and desired spectral envelope.
</p>
<pre>
(map-chan (fltit-1 10 (list-&gt;vct '(0 1.0 0 0 0 0 0 0 1.0 0))))
</pre>
<p>
<i>down-oct</i> tries to move a sound down an octave by goofing with the fft data,
then inverse ffting.  
<i>freqdiv</i> implements
"frequency division", taken from an effects package of sed_sed@my-dejanews.com.
</p>
<pre>
(freqdiv 8)
</pre>
<p>
Also from that package is <i>adsat</i>, "adaptive saturation".  <i>spike</i> performs 
a product of samples (as opposed to the more common sum); that is, it multiplies
together several successive samples, causing a more spikey output.
<i>compute-uniform-circular-string</i> and <i>compute-string</i> implement
scanned synthesis of Bill Verplank and Max Mathews.
To watch the wave, open some sound (so Snd has some place to put the graph), turn off
the time domain display (to give our graph all the window)
then <code>(testunif 1.0 0.1 0.0)</code>.
The <A NAME="spotfreq">spot-freq</a> function is a simple first-pass at using autocorrelation for
pitch tracking; it's easily fooled, but could probably be made relatively robust.
The code:
</p>
<pre>
 (let* ((logla (log10 (/ (+ cor-peak (vct-ref data i)) (* 2 cor-peak))))
	(logca (log10 (/ (+ cor-peak (vct-ref data (+ i 1))) (* 2 cor-peak))))
	(logra (log10 (/ (+ cor-peak (vct-ref data (+ i 2))) (* 2 cor-peak))))
	(offset (/ (* 0.5 (- logla logra))
		   (+ logla logra (* -2.0 logca)))))
   (return (/ (srate snd)
	      (* 2 (+ i 1 offset)))))
</pre>
<p>is using Xavier Serra's interpolation technique to find the true location
of the autocorrelation peak.  The <i>cor-peak</i> business is making sure the
log10 arguments fall between 0.0 and 1.0.
</p>

<p><i>zero-phase</i> and <i>rotate-phase</i> are fft-manipulators taken from
the phazor package of Scott McNab.
</p>

<p><i>asyfm-J</i> is a Scheme version of the CLM asymmetric-fm generator;
<i>asyfm-I</i> is the Modifier Bessel version of this generator.  In both
cases, the "r" variable is accessible, so it's easy to experiment with 
the moving formant idea mentioned in the original article.
</p>

<p><i>cosine-summation</i> is a variation on J.A.Moorer's sine-summation;
the generating formula is much simpler, but the result is the same.  This
can also be viewed as a version of the sum-of-cosines generator, giving control
on the ratio between successive cosines in the sum (i.e. the "r" parameter in
sine-summation, applied within the sum-of-cosines output).  <i>legendre-summation</i>
uses the sum-of-cosines generator to produce a band-limited pulse-train whose
cosine components have a decreasing amplitude (as if it were a sum of Lengendre
Polynomials driven by a cosine). Three other similar functions are <i>sum-of-n-sines</i>,
<i>sum-of-n-odd-sines</i>, and <i>sum-of-n-odd-cosines</i>.
</p>

<p><i>brighten-slightly</i> is a slight simplification of contrast-enhancement.
<i>make-hilbert-transform</i> and <i>hilbert-transform</i> provide an FIR filter approach to the Hilbert transform.
<i>make-lowpass</i> and <i>lowpass</i> provide FIR low pass filtering.
<i>make-highpass</i> and <i>highpass</i> provide FIR high pass filtering.
<i>make-bandpass</i> and <i>bandpass</i> provide FIR band pass filtering.
<i>make-bandstop</i> and <i>bandstop</i> provide FIR notch filtering.
<i>make-differentiator</i> and <i>differentiator</i> provide an FIR filter-based differentiator.
</p>
<p>The Ruby version of this is in examp.rb.
</p>

<A NAME="editmenudoc"></a><span class=box><h2>edit-menu.scm</h2></span>

<p>edit-menu.scm adds some useful options to the Edit menu:
</p>
<pre>
  trim front and trim back (to/from marks)
  crop (first and last marks)
  selection-&gt;new
  cut selection-&gt;new
  append selection (and append sound)
</pre>
<!-- I(trim sound):M(Edit: Trim)(editmenudoc) -->
<!-- I(trim sound):A(editmenudoc) -->



<A NAME="effectsdoc"></a><span class=box><h2>new-effects.scm, gtk-effects.scm</h2></span>

<p>new-effects.scm implements an Effects menu.  If you have Motif,
you can load xm.so (or build Snd with it preloaded), and get sliders
to control most of the effects.  (Use gtk-effects.scm with Gtk, obviously).
The effects include:
</p>
<pre>
  reverse
  normalize (normalization)
  gain (gain-amount)
  invert
  chordalize (chordalize-amount, chordalize-base)
  flange (increase speed and amount to get phasing, flange-speed, flange-amount, flange-time)
  compand, compand-channel
  reverberate (reverb-amount)
  intensify (contrast-amount)
  echo (echo-length, echo-amount)
  squelch (squelch-amount, omit-silence)
  add silence (at cursor) (silence-amount)
  remove DC
  expsrc (independent pitch/time scaling) (time-scale and pitch-scale)
  various filters
  cross synthesis
</pre>

<!-- I(reverse samples):M(Effects: Reverse)(effectsdoc) -->
<!-- I(reverberate file):M(Effects: Reverberate)(effectsdoc) -->
<!-- I(normalize sound):M(Effects: Normalize)(effectsdoc) -->
<!-- I(normalize sound):A(effectsdoc) -->
<!-- I(normalize sound):L(scale-to)(sndscaleto) -->
<!-- I(insert zeros):M(Effects: Add Silence)(effectsdoc) -->
<!-- I(change tempo):M(Effects: Expsrc)(effectsdoc) -->

<p>Most of these are either simple calls on Snd functions ("invert" is <code>(scale-by -1)</code>),
or use functions in the other scm files.  The actual operations follow the sync chain of the
currently active channel.  
</p>
<p>One possibly interesting part of new-effects.scm is the implementation of the
Effects menu.  If you change one of the variables, you'll notice that the
menu updates its notion of that variable as well.  This is handled through
<i>update-callback</i> argument to <a href="extsnd.html#sndaddtomainmenu">add-to-main-menu</a>
function.  Each effect is added (when new-effects.scm is loaded) to the <i>effects-list</i>.
Then each time you click the Effects menu, causing its options to be dispayed,
the update-callback function itself calls each effect's update function to
get its current option label.  That is,
</p>
<pre>
(define effects-list '())
(define effects-menu 
  (add-to-main-menu "Effects" 
                    (lambda ()
 		      (define (update-label effects)
		        (if (not (null? effects))
			    (begin
			      ((car effects))
			      (update-label (cdr effects)))))
		      (update-label effects-list))))
</pre>
<p>defines the update-callback to be a thunk (the outer lambda) that itself
defines a local function (update-label) that runs through the effects-list
calling each one via <code>((car effects))</code>.  Each effect that wants
to recalculate its option label then
adds its update function to the effects-list when it is loaded:
</p>
<pre>
(set! effects-list (cons (lambda ()
			   (let ((new-label (format #f "gain (~1,2F)" gain-amount)))
			     (change-menu-label effects-menu gain-label new-label)
			     (set! gain-label new-label)))
			 effects-list))
</pre>
<p>The sound effect itself is the callback function of the given option:
</p>
<pre>
(add-to-menu effects-menu "reverse" (lambda () (reverse-sound)))
</pre>
<p>I can't decide whether it would be useful to describe some of these
effects in more detail.  The code is mostly straightforward, and
it's not hard to try them out.
</p>	
<p>The Ruby/Motif version of this is in effects.rb.
</p>
<br>

<A NAME="envdoc"></a><span class=box><h2>env.scm</h2></span>

<p>An envelope in Snd/CLM is simply a list of breakpoint pairs.  (In the function names, 
I try to remember to use "envelope" to be a list of breakpoints, and "env" to be the result of make-env,
a CLM env structure passed to the env generator).
In an envelope,
the x axis extent
is arbitrary, though it's simplest to use 0.0 to 1.0.  env.scm provides several
envelope functions that are often useful:
</p>
<pre>
  <em class=def><A NAME="envelopeinterp">envelope-interp</a></em> x env <i>base</i>
  <em class=def><a name="windowenvelope">window-envelope</a></em> beg end env
  <em class=def><a name="mapenvelopes">map-envelopes</a></em> func env1 env2
  <em class=def><A NAME="multiplyenvelopes">multiply-envelopes</a></em> env1 env2
  <em class=def><A NAME="addenvelopes">add-envelopes</a></em> env1 env2
  <em class=def><a name="maxenvelope">max-envelope</a></em> env
  <em class=def><a name="integrateenvelope">integrate-envelope</a></em> env
  <em class=def><a name="stretchenvelope">stretch-envelope</a></em> env old-attack new-attack <i>old-decay new-decay</i>
  <em class=def><A NAME="envelopelastx">envelope-last-x</a></em> env
  <em class=def><a name="scaleenvelope">scale-envelope</a></em> env scl <i>(offset 0.0)</i>
  <em class=def><a name="reverseenvelope">reverse-envelope</a></em> env
  <em class=def><a name="concatenateenvelopes">concatenate-envelopes</a></em> #:rest envs
  <em class=def><a name="repeatenvelope">repeat-envelope</a></em> env repeats #:optional (reflected #f) (normalized #f)
  <em class=def><a name="powerenv">power-env</a></em> e
  <em class=def><a name="makepowerenv">make-power-env</a></em> e #:key (scaler 1.0) (offset 0.0) duration
  <em class=def><a name="powerenvchannel">power-env-channel</a></em> pe #:optional (beg 0) dur snd chn edpos (edname "power-env-channel")
</pre>
<p>These are translated from CLM's env.lisp.
<code>(envelope-interp x env base)</code> returns value of env at x.
If base is 0, env is treated as a step function; if base is 1.0 (the
default), its breakpoints are connected by a straight line, and
any other base connects the breakpoints with a kind of exponential
curve:
</p>
<pre>
:<em class=typing>(envelope-interp .1 '(0 0 1 1))</em>
<em class=listener>0.1</em>
:<em class=typing>(envelope-interp .1 '(0 0 1 1) 32.0)</em>
<em class=listener>0.0133617278184869</em>
:<em class=typing>(envelope-interp .1 '(0 0 1 1) .012)</em>
<em class=listener>0.361774730775292</em>
</pre>
<p>The corresponding function for a CLM env generator is <a href="clm.html#env-interp">env-interp</a>.
If you'd rather think in terms of e^-kt, set the base to (exp k).  
</p>
<p><i>window-envelope</i> returns (as an envelope) the portion of its envelope argument that lies
between the X axis values <i>beg</i> and <i>end</i>.  This is useful when you're treating an
envelope as a phrase-level control, applying successive portions of it to many underlying
notes.
</p>
<pre>
:<em class=typing>(window-envelope 1.0 3.0 '(0.0 0.0 5.0 1.0))</em>
<em class=listener>(1.0 0.2 3.0 0.6)</em>
</pre>
<p><i>map-envelopes</i> applies its <i>func</i> argument to the breakpoints in the two
envelope arguments, returning a new envelope. A simple application of this is
<i>multiply-envelopes</i> which multiplies two envelopes:
</p>
<pre>
:<em class=typing>(multiply-envelopes '(0 0 1 1) '(0 0 1 1 2 0))</em>
<em class=listener>(0 0 0.5 0.5 1 0)</em>
</pre>
<p>As this example shows, the new envelope goes from 0.0 to 1.0 along
the X axis; the multiplied envelopes are stretched or contracted to
fit 0.0 to 1.0, and wherever one has a breakpoint, the corresponding
point in the other envelope is interpolated, if necessary. The code
for multiply envelopes is simply:</p>
<pre>
(define multiply-envelopes
  (lambda (e1 e2)
    (map-envelopes * e1 e2)))
</pre>
<p><i>max-envelope</i> returns the maximum Y value in <i>env</i>, and <i>envelope-last-x</i>
returns the maximum X value:
</p>
<pre>
:<em class=typing>(max-envelope '(0 0 1 1 2 3 4 0))</em>
<em class=listener>3.0</em>
</pre>
<p><i>integrate-envelope</i> returns the area under the envelope; this is
useful when you need to know in advance the overall effect of an envelope
controlling the sampling rate, for example.
</p>
<pre>
:<em class=typing>(integrate-envelope '(0 0 1 1))</em>
<em class=listener>0.5</em>
:<em class=typing>(integrate-envelope '(0 1 1 1))</em>
<em class=listener>1.0</em>
:<em class=typing>(integrate-envelope '(0 0 1 1 2 .5))</em>
<em class=listener>1.25</em>
</pre>
<p><i>stretch-envelope</i> applies attack and optionally decay times
to an envelope, much like divseg in clm-1.</p>
<pre>
:<em class=typing>(stretch-envelope '(0 0 1 1) .1 .2)</em>
<em class=listener>(0 0 0.2 0.1 1.0 1)</em>
:<em class=typing>(stretch-envelope '(0 0 1 1 2 0) .1 .2 1.5 1.6)</em>
<em class=listener>(0 0 0.2 0.1 1.1 1 1.6 0.5 2.0 0)</em>
</pre>
<p><i>scale-envelope</i> scales the y values of an envelope by <i>scl</i>,
<i>add-envelope</i> adds two envelopes together, <i>reverse-envelope</i>
reverses an envelope.
<i>repeat-envelope</i> repeats an envelope (concatenates copies of itself).
</p>
<pre>
:<em class=typing>(repeat-envelope '(0 0 100 1) 2)</em>
<em class=listener>(0 0 100 1 101 0 201 1)</em>
</pre>
<p>If the final y value is different from the first y value (as above), a quick ramp is
inserted between repeats. 'normalized' causes the new envelope's x axis
to have the same extent as the original's. 'reflected' causes every other
repetition to be in reverse.
</p>
<p><i>make-power-env</i> and <i>power-env</i> implement an extension of exponential
envelopes; each segment has its own base.  <i>power-env-channel</i> uses the same
mechanism as an extension of env-channel.
</p>
<pre>
(let ((pe (make-power-env '(0 0 32.0  1 1 0.0312  2 0 1) :duration 1.0)))
  (map-channel (lambda (y) (* y (power-env pe)))))

(let ((pe1 (make-power-env '(0 0 32.0  1 1 0.0312  2 0 1.0  3 .5 3.0  4 0 0) :duration 1.0)))
  (power-env-channel pe1))
</pre>
<br>

<A NAME="enveddoc"></a><span class=box><h2>enved.scm</h2></span>
<br>
<img src="envs.png" alt="channel enveds">

<pre>
  <em class=def><A NAME="startenveloping">start-enveloping</a></em>
  <em class=def><A NAME="stopenveloping">stop-enveloping</a></em>
  <em class=def><a name="channelenvelope">channel-envelope</a></em> <i>snd chn</i>
  <em class=def><A NAME="playwithenvs">play-with-envs</a></em> snd
  <em class=def><A NAME="playpanned">play-panned</a></em> snd
</pre>

<p>enved.scm implements an independent envelope editor in each channel.  <code>(start-enveloping)</code>
sets this in progress (for subsequently opened sounds), <code>(stop-enveloping)</code> turns it off.
Each envelope can be read or written via <code>(channel-envelope snd chn)</code>.
There are also two examples that use these envelopes: <i>play-with-envs</i> and
<i>play-panned</i>.  The former sets the channel's amplitude from its envelope
during playback (it should be obvious how to apply the envelope to any of the
control panel fields); the latter pans a mono sound into stereo following
the envelope. The lines:
</p>
<pre>
(define channel-envelope
  (make-procedure-with-setter
    (lambda (snd chn)
      ...)
    (lambda (snd chn new-env)
      ...)))
</pre>
<p>
use a feature of Guile 1.4 that provides a set! function
for channel-envelope.  The first lambda is called if you're
asking for the current value of that channel-envelope:
</p>
<pre>
(channel-envelope s c)
</pre>
<p>and
the second if you're setting it to something new:
</p>
<pre>
(set! (channel-envelope s c) e)
</pre>
<br clear=right>


<A NAME="eventdoc"></a><span class=box><h2>event.scm</h2></span>

<p>event.scm has functions used by snd-test.scm to exercise the user interface.
These functions depend on the xm module and XSendEvent primarily, but there are
also Scheme implementations of some of the built-in functions (change-prop).
</p>


<A NAME="exampdoc"></a><span class=box><h2>examp.scm</h2></span>

<p>examp.scm has become a bit of a grab-bag; rather than get organized, I just
appended new stuff as it came to mind.  The following documentation is mostly 
a quick overview of the code; most of the examples are very simple, so (as
the saying goes) "the code is the documentation".  Also, there's some overlap
between these examples, other .scm files, and discussions in other documents.
I'm slowly dividing out related groups of procedures to separate files.
</p>

<ul>
<li><a href="#ssfilters">filters</a>
<small>
  <ul>
    <li>comb-filter, notch-filter, formant-filter
    <li>time varying FIR filter, notch filter
    <li>filtered-env (low-pass and amplitude follow envelope)
    <li>remove-clicks
  </ul>
</small>
<li><a href="#ssffts">ffts</a>
<small>
  <ul>
    <li>correlation
    <li>set transform-size based on current time domain window size
    <li>superimpose spectra of sycn'd sounds
    <li>fft-edit, fft-env-interp, fft-env-edit -- FFT based editing
    <li>fft-squelch -- noise reduction 
    <li>fft-cancel -- fft as very narrow notch filter
    <li>squelch-vowels -- remove steady-state (or the reverse)
    <li>fft-smoother -- fft-based smoothing
  </ul>
</small>
<li><a href="#ssuserinterface">user-interface</a>
<small>
  <ul>
    <li>XEmacs-like Buffers menu
    <li>Reopen menu
    <li>make dot size dependent on number of samples being displayed
    <li>flash selected data red and green
    <li>add date and time to title bar
    <li>how to get 'display' to write to Snd's listener
    <li>multi-colored rxvt printout
    <li>lisp graph with draggable x axis
    <li>pointer-focus
    <li>files-popup-buffer
    <li>Emacs-like C-x b handling
    <li>redirect stdin/stdout: snd-debug, read-listener-line, snd-trace
    <li>open-next-file-in-directory
  </ul>
</small>
<li><a href="#ssmarks">marks</a>
<small>
  <ul>
    <li>use loop info (if any) to set marks at loop points
    <li>move window left edge to mark upon 'm' key
  </ul>
</small>
<li><a href="#ssselections">selections</a>
<small>
  <ul>
    <li>swap selection chans
    <li>replace with selection
    <li>explode soundfont file
  </ul>
</small>
<li><a href="#ssmixes">mixes</a>
<small>
  <ul>
    <li>mix mono sound into stereo sound panning according to env, also simple sound placement
  </ul>
</small>
<li><a href="#sssoundeffects">sound effects</a>
<small>
  <ul>
    <li>echo (delays)
    <li>ring-modulation, am
    <li>src-related sound effects (src, rand-interp, etc)
    <li>compand, compand-channel (array-interp)
    <li>shift pitch keeping duration constant (src+granulate)
    <li>tempo change via envelope (granulate)
    <li>cross-synthesis (using a formant bank)
    <li>voiced-&gt;unvoiced (formants)
    <li>convolution (convolve)
    <li>reverb (all-pass etc)
    <li>fancier locsig
    <li>"vector synthesis"
  </ul>
</small>
<li><a href="#sssynthesis">synthesis</a>
<small>
  <ul>
    <li>scissor-tailed flycatcher (waveshaping)
    <li>fm-violin (FM and various other generators, #&amp;key args)
    <li>FOF voice synthesis (wave-train, #&amp;optional args)
    <li>pluck instrument (physical modelling)
    <li>voice instrument (formants via FM)
    <li>chain-dsps
  </ul>
</small>
<li><a href="#ssmiscellaneousextensions">miscellaneous extensions</a>
<small>
  <ul>
    <li>'info' from extsnd.html using format
    <li>make a system call
    <li>documentation examples made harder to break
    <li>example of c-g?
    <li>translate mpeg input to 16-bit linear and read into Snd
    <li>read and write OGG files
    <li>mapping extensions (map arbitrary single-channel function over various channel collections)
    <li>sound-interp, env-sound-interp
    <li>searching procedures (search-for-click, find-pitch, zero+, next-peak)
    <li>sound-data-&gt;list
    <li>smooth-channel-via-ptree -- smooth-channel as virtual op
  </ul>
</small>
</ul>



<!-- -------------------------------- FILTERS -------------------------------- -->
<span class=bbox><h3><A NAME="ssfilters">filters</a></h3></span>

<pre>
  <em class=def><A NAME="excombfilter">comb-filter</a></em> scaler size
  <em class=def><A NAME="excombchord">comb-chord</a></em> scaler size amp
  <em class=def><A NAME="exzcomb">zcomb</a></em> scaler size pm
  <em class=def><A NAME="exnotchfilter">notch-filter</a></em> scaler size
  <em class=def><A NAME="exformantfilter">formant-filter</a></em> radius frequency
  <em class=def><A NAME="exformants">formants</a></em> r1 f1 r2 f2 r3 f3
  <em class=def><A NAME="exmovingformant">moving-formant radius</a></em> move-envelope
  <em class=def><A NAME="exoscformants">osc-formants</a></em> radius bases amounts freqs
  <em class=def><A NAME="exremoveclick">remove-click</a></em>
</pre>
<p>The two versions of <i>comb-filter</i> implement a comb filter,
"by hand" and using CLM. <i>comb-chord</i> uses comb filters at harmonically
related sizes to create a chord (see also chordalize in new-effects.scm).  <i>amp</i>
here is an overall amplitude scaler.  <i>zcomb</i> is a time-varying comb
filter using the envelope <i>pm</i>.  <i>notch-filter</i> parallels comb-filter.
<i>formant-filter</i> applies a formant to its input.
Some examples:
</p>
<pre>
(map-chan (comb-filter .8 32))
(map-chan (comb-chord .95 100 .3))
(map-chan (comb-chord .95 60 .3))
(map-chan (zcomb .8 32 '(0 0 1 10)))
(map-chan (notch-filter .8 32))
(map-chan (formant-filter .99 2400))
</pre>
<p>In all these cases, however, it's actually much faster to pass the
filter to filter-sound:</p>
<pre>
(filter-sound (make-formant .99 2400))
</pre>
<p><i>formants</i> applies three formants in parallel.
<i>moving-formant</i> moves a formant according to an envelope.
<i>osc-formants</i> sets up any number of independently oscillating formants.
</p>
<pre>
(map-chan (formants .99 900 .98 1800 .99 2700))
(map-chan (moving-formant .99 '(0 1200 1 2400)))
(map-chan (osc-formants .99 '(400 800 1200) '(400 800 1200) '(4 2 3)))
</pre>
<pre>
  <em class=def><A NAME="exfilteredenv">filtered-env</a></em> envelope
</pre>
<p><i>filtered-env</i> creates an amplitude envelope and a one-pole
filter, and moves them in parallel over a sound; 
as the sound gets softer, the low-pass filter's cutoff frequency
gets lower, a sort of poor-man's distance effect.  When <i>envelope</i>
is at 1.0, no filtering takes place.
</p>
<pre>
  <em class=def><A NAME="exfltit">fltit</a></em>
  <em class=def><A NAME="exremoveclicks">remove-clicks</a></em>
</pre>
<p><i>fltit</i> is a simple FIR filter call.
<i>remove-clicks</i> looks for obvious clicks and uses smooth-sound to remove them.
</p>

<!-- -------------------------------- FFTS -------------------------------- -->
<span class=bbox><h3><A NAME="ssffts">ffts</a></h3></span>
<pre>
  <em class=def><A NAME="excorrelate">correlate</a></em> snd chn y0 y1
  <em class=def><a name="exsuperimposeffts">superimpose-ffts</a></em> snd chn y0 y1
  <em class=def><a name="exfftedit">fft-edit</a></em> low-freq high-freq
  <em class=def><a name="exfftenvedit">fft-env-edit</a></em> env
  <em class=def><A NAME="exfftenvinterp">fft-env-interp</a></em> env1 env2 interp
  <em class=def><a name="exfftsquelch">fft-squelch</a></em> squelch
  <em class=def><A NAME="exfftcancel">fft-cancel</a></em> lo-freq hi-freq
  <em class=def><a name="exsquelchvowels">squelch-vowels</a></em>
  <em class=def><A NAME="exfftsmoother">fft-smoother</a></em> cutoff start samps snd chn
</pre>
<p><i>correlate</i> graphs the correlation of <i>snd</i>'s 2 channels.
To make this happen automatically as you move the time domain position
slider, <code>(add-hook! graph-hook correlate)</code>.
<i>superimpose-ffts</i> is a similar graph-hook function that
superimposes the ffts of multiple (syncd) sounds.
<i>fft-edit</i> is a simple example of fft-based editing.
It takes an fft of the entire sound, removes all energy below <i>low-freq</i> and above <i>high-freq</i>,
then inverse fft's. <i>fft-env-edit</i> is the same, but applies an envelope to the spectral magnitudes;
<i>fft-env-interp</i> takes two such filtered versions and mixes them following the interpolation
envelope. Another similar function is <i>fft-smoother</i> that uses fft-filtering to
smooth a portion of a sound.
<i>fft-squelch</i> is similar, but removes all energy below the squelch amount (normalized to
be between 0.0 and 1.0).  This is sometimes useful for noise-reduction.
<i>fft-cancel</i> ffts an entire sound, sets the bin(s) representing lo-freq to hi-freq to 0.0, then inverse ffts,
giving a high quality notch filter.
<i>squelch-vowels</i> uses fft data to distinguish the steady state portion (a vowel in speech) from
noise (a consonant, sometimes), and does whatever you want based on that (remove vowels, remove
consonants, make consonants louder, etc).
Finally there are two examples
of using graph-hook to set the fft size based on the current time domain window
size.  The simpler one is:
</p>
<pre>
(add-hook! graph-hook 
	   (lambda (snd chn y0 y1)
	     (if (and (transform-graph? snd chn) 
                      (= (transform-graph-type snd chn) graph-once))
		 (begin
		   (set! (transform-size snd chn)
			 (expt 2 (ceiling 
				  (/ (log (- (right-sample snd chn) (left-sample snd chn))) 
				     (log 2.0)))))
		   (set! (spectro-cutoff snd chn) (y-zoom-slider snd chn))))))

</pre>
<p>The <i>expt...</i> code is rounding the current window size (right-sample - left-sample)
up to the nearest power of 2. 
</p>

<!-- -------------------------------- USER-INTERFACE -------------------------------- -->
<span class=bbox><h3><A NAME="ssuserinterface">user-interface</a></h3></span>

<p><i>show-draggable-graph</i>, in imitation of Snd's FFT display, implements a
draggable X axis in the lisp graph window.  (This is slightly messier than
it ought to be).
Two of the examples are imitations of Xemacs: a Buffers menu and an auto-save hook (now in <a href="autosavedoc">autosave.scm</a>).</p>
<pre>
  <em class=def><A NAME="exopenbuffer">open-buffer</a></em> filename
  <em class=def><A NAME="exclosebuffer">close-buffer</a></em> snd
</pre>

<p>The Buffers menu provides a list of currently open sounds; selecting one
in the menu causes it to become the selected sound; <i>open-buffer</i>
adds a menu item that will select a file, <i>close-buffer</i> removes it.
To activate this, we need
to:
</p>
<pre>
(add-hook! open-hook open-buffer)
(add-hook! close-hook close-buffer)
</pre>

<p>A similar menu is the "reopen menu"; it presents a list of previously
closed (and not subsequently re-opened) files in reverse order of closing.
</p>

<pre>
  <em class=def><A NAME="exsndout">snd-out</a></em>
</pre>
<p>A minor irritation in the current Guile system is that Scheme's "display" function
writes to <i>current-output-port</i>, but there's no simple way to redirect that
elsewhere (and with-output-to-string is not completely integrated with
Guile's help system).  So, if your code calls display, the result may be invisible.
One way around this is to reset the current-output-port to be a soft port
that actually calls <a href="extsnd.html#sndprint">snd-print</a> instead:
</p>
<pre>
(define stdout (current-output-port)) ;save it in case we want to go back to it
(define snd-out
  (make-soft-port
   (vector                      ;soft port is a vector of procedures:
    (lambda (c) (snd-print c))  ;  procedure accepting one character for output 
    (lambda (s) (snd-print s))  ;  procedure accepting a string for output 
    (lambda () #f)              ;  thunk for flushing output (not needed here)
    #f                          ;  thunk for getting one character (also not needed)
    (lambda () #f))             ;  thunk for closing port -- hmm should this go back to the previous?
   "w"))
(set-current-output-port snd-out)
</pre>
<p>You could also <code>(set! display snd-print)</code>, if you're willing to
live dangerously; this replaces Guile's built-in <i>display</i> procedure with
Snd's <i>snd-print</i>.  Another example of this is snd-debug. 
</p>

<p>There are also a few brief examples showing simple display customizations.
For example, the following makes the graph dot size dependent on the
number of samples in the graph:
</p>
<pre>
  <em class=def><a name="exautodot">auto-dot</a></em> snd chn y0 y1

(add-hook! graph-hook auto-dot)
</pre>
<p>There are also examples tying the channel graph sliders to the fft display.
Finally there are several somewhat frivolous examples:
</p>
<pre>
  <em class=def><a name="extitlewithdate">title-with-date</a></em>
  <em class=def><A NAME="exflashselecteddata">flash-selected-data</a></em> time-interval
</pre>
<p><code>(title-with-date)</code> adds a clock to the Snd window's title bar.
Set the variable <i>retitle-time</i> to 0 to turn this off.
<i>flash-selected-data</i> cause the selected channel's graph to
flash red and green.  And the there are functions to display colored text
in rxvt:
</p>
<pre>
(display (format #f "~Athis is red!~Abut this is not" red-text normal-text))
(display (format #f "~A~Ahiho~Ahiho" yellow-bg red-fg normal-text))
</pre>
<p>It's possible to use the same escape sequences in a normal shell script, of course:
</p>
<pre>
echo '\e[41m This is red! \e[0m'
</pre>
<br>
<pre>
  <em class=def><A NAME="filespopupbuffer">files-popup-buffer</a></em>
</pre>
<p>This is a mouse-enter-label-hook function for the View:Files dialog;
it hides all sounds but the one the mouse is pointing to in the current files list.
The pointer-focus style of interaction uses similar hooks.  There is also
a first stab at Emacs-like C-x b support here; the file name in the prompt
should be a string (i.e. in quotes), unlike Emacs.  This still needs work
especially for multichannel sounds.
</p>
<pre>
  <em class=def><A NAME="opennextfileindirectory">open-next-file-in-directory</a></em>
</pre>
<p>This is a mouse-click-hook function. If you call</p>
<pre>
(click-middle-button-to-open-next-file-in-directory)
</pre>
<p>it sets up the mouse-click-hook and open-hook so that clicking the middle
mouse button closes the current file and opens for the next (alphabetical
by filename) in the current directory.
</p>


<!-- -------------------------------- MARKS -------------------------------- -->
<span class=bbox><h3><A NAME="ssmarks">marks</a></h3></span>

<p><a href="#marksdoc">marks.scm</a> has most of the mark-related extensions.
The two in examp.scm are:
</p>
<pre>
  <em class=def><a name="exfirstmarkinwindowatleft">first-mark-in-window-at-left</a></em>
  <em class=def><a name="exmarkloops">mark-loops</a></em>

(bind-key (char-&gt;integer #\l) 0 
          (lambda () 
            (first-mark-in-window-at-left)))
</pre>
<p><i>first-mark-in-window-at-left</i> moves the (time domain) 
graph so that the leftmost visible mark is at the left edge;
<i>mark-loops</i> places marks at any loop points found in the selected sound's header.
Only a few headers support loop points (these are apparently used in synthesizers
to mark portions of a waveform that can be looped without causing clicks, thereby lengthening
a sound as a key is held down). 
</p>

<!-- -------------------------------- SELECTIONS -------------------------------- -->
<span class=bbox><h3><A NAME="ssselections">selections</a></h3></span>

<pre>
  <em class=def><a name="exallchans">all-chans</a></em>
  <em class=def><a name="exswapselectionchannels">swap-selection-channels</a></em>
  <em class=def><A NAME="exselectionrms1">selection-rms-1</a></em>
  <em class=def><a name="exselectionrms">selection-rms</a></em>
  <em class=def><a name="exregionrms">region-rms</a></em> <i>region</i>
  <em class=def><A NAME="exreplacewithselection">replace-with-selection</a></em>
  <em class=def><a name="exexplodesf2">explode-sf2</a></em>
</pre>
<p>
<i>swap-selection-channels</i> swaps the currently selected data's channels.
The various rms functions return the rms value of the desired data in a variety
of ways. The fastest and simplest uses CLM's dot-product function:
</p>
<pre>
(define (region-rms n)
  "(region-rms n) -&gt; rms of region n's data (chan 0)"
  (if (region? n)
      (let* ((data (region-samples-&gt;vct 0 0 n)))
	(sqrt (/ (dot-product data data) (vct-length data))))
      (throw 'no-such-region (list "region-rms" n))))
</pre>
<p><i>replace-with-selection</i> replaces data at the cursor with the
current selection.  <i>explode-sf2</i> turns a soundfont file (assuming it
is the currently selected sound) into a bunch of files of the form sample-name.aif.
</p>



<!-- -------------------------------- MIXES -------------------------------- -->
<span class=bbox><h3><A NAME="ssmixes">mixes</a></h3></span>

<p><a href="#mixdoc">mix.scm</a> has mix and track related functions.
</p>
<pre>
  <em class=def><A NAME="explacesound">place-sound</A></em> mono-snd stereo-snd panning-envelope-or-degree
</pre>
<p>If <i>panning-envelope-or-degree</i> is a number (in degrees),
the <i>place-sound</i> function has the same effect as using
CLM's locate generator; it mixes a mono sound into a stereo sound, splitting 
it into two copies whose amplitudes depend on the desired location.
0 degrees: all in channel 0, 90: all in channel 1.
If <i>panning-envelope-or-degree</i> is an envelope,
the split depends on the panning envelope (0 = all in chan 0, etc).
</p>

<!-- -------------------------------- SOUND EFFECTS -------------------------------- -->
<span class=bbox><h3><A NAME="sssoundeffects">sound effects</a></h3></span>

<p>Most of these sound effects are based on CLM generators.
</p>
<pre>
  <em class=def><A NAME="execho">echo</a></em> scaler secs
  <em class=def><A NAME="exzecho">zecho</a></em> scaler secs frq amp      ; modulated echo
  <em class=def><A NAME="exflecho">flecho</a></em> scaler secs             ; filtered echo
  <em class=def><A NAME="exringmod">ring-mod</a></em> freq gliss-env        ; ring-modulation
  <em class=def><A NAME="exam">am</a></em> freq                        ; amplitude modulation
  <em class=def><A NAME="exhellodentist">hello-dentist</a></em> frq amp          ; randomized sampling rate changes
  <em class=def><A NAME="exfp">fp</a></em> sr osamp osfrq              ; osc-driven src ("Forbidden Planet")
  <em class=def><a name="excompand">compand</a></em>
  <em class=def><a name="excompandchannel">compand-channel</a></em> beg dur snd chn edpos
  <em class=def><A NAME="exexpsrc">expsrc</a></em> rate snd chn
  <em class=def><A NAME="exexpsnd">expsnd</a></em> rate-envelope
  <em class=def><a name="excrosssynthesis">cross-synthesis</a></em> cross-snd amp fftsize radius
  <em class=def><a name="exvoiced2unvoiced">voiced-&gt;unvoiced</a></em> amp fftsize r tempo
  <em class=def><A NAME="excnvtest">cnvtest</a></em> snd0 snd1 amp
  <em class=def><A NAME="exjcreverb">jc-reverb</a></em> decay-dur low-pass volume amp-env
  <em class=def><A NAME="excvectorsynthesis">"vector synthesis"</a></em>	
</pre>
<p><i>expsrc</i> uses sampling rate conversion (the src gen) and granular synthesis (granulate)
to lengthen or shorten a sound without changing its pitch.  The same idea is used in the effects menu.
<i>expsnd</i> is the same but the
change follows an envelope.  In <i>cross-synthesis</i>, <i>cross-snd</i> is the index
of the sound that controls the spectra, not the affected sound.  <i>voiced-&gt;unvoiced</i>
is essentially the same idea, but drives the synthesis with white noise.
<i>cnvtest</i> demonstrates convolution.  <i>jc-reverb</i> is an old Mus10 reverberator
written originally by John Chowning; see jcrev.ins in CLM or jcrev.scm. 
Here are some sample calls:
</p>
<pre>
(map-chan (echo .5 .5) 0 44100)
(map-chan (zecho .5 .75 6 10.0) 0 65000)
(map-chan (flecho .5 .9) 0 75000)
(map-chan (ring-mod 100 '(0 0 1 0)))
(map-chan (ring-mod 10 (list 0 0 1 (hz-&gt;radians 100))))
(map-chan (am 440))
(hello-dentist 40.0 .1)
(fp 1.0 .3 20)
(map-chan (compand))
(expsnd '(0 1 2 .4))
(expsnd '(0 .5 2 2.0))
(map-chan (cross-synthesis 1 .5 128 6.0))
(voiced-&gt;unvoiced 1.0 256 2.0 2.0)
(cnvtest 0 1 .1)
(jc-reverb 2.0 #f .1 #f)
</pre>
<p>There are lots more sound effects scattered around the Snd distribution.
"vector synthesis" cycles through a collection of incoming audio streams, playing whatever
happens to be on the chosen one, with fade-ins and fade-outs to avoid clicks.
</p>

<!-- -------------------------------- SYNTHESIS -------------------------------- -->
<span class=bbox><h3><A NAME="sssynthesis">synthesis</a></h3></span>

<p>The synthesis examples are taken primarily from CLM:</p>
<pre>
  <em class=def><A NAME="exscissor">scissor</a></em> begin-time
  <em class=def><A NAME="exfmviolin">fm-violin</a></em> ...many args...
  <em class=def><A NAME="exfofins">fofins</a></em> ...many args...
  <em class=def><A NAME="expluck">pluck</a></em> start dur freq amp weighting lossfact
  <em class=def><A NAME="exvox">vox</a></em> beg dur freq amp ampfun freqfun freqscl voxfun index vibscl
  <em class=def><A NAME="chaineddsps">chained-dsps</a></em> beg dur &amp;rest dsps
</pre>
<p><i>scissor</i> synthesizes the squawk of the scissor-tailed flycatcher (state bird of Oklahoma, <i>Tyrannus forficatus</i>);
see <a href="#birddoc">bird.scm</a> for more birds.  The fm-violin is discussed in <a href="#vdoc">v.scm</a>.
<i>fofins</i> is an implementation of FOF synthesis, taken originally from
fof.c of Perry Cook and the article
"Synthesis of the Singing Voice" by Bennett and Rodet in
"Current Directions in Computer Music Research" (MIT Press).
<i>pluck</i> is based on
the Karplus-Strong algorithm as extended by David Jaffe and Julius Smith -- see 
Jaffe and Smith, "Extensions of the Karplus-Strong Plucked-String Algorithm"
CMJ vol 7 no 2 Summer 1983, reprinted in "The Music Machine".
Another physical model is Nicky Hind's flute in flute.scm.
<i>vox</i> is a translations of Marc LeBrun's MUS10 waveshaping voice instrument
using FM in this case.  The waveshaping version can be found in <a href="#pqwvoxdoc">pqwvox.scm</a>.
<i>chain-dsps</i> creates a patch of chained generators from its arguments.
</p>

<!-- -------------------------------- MISCELLANEOUS EXTENSIONS -------------------------------- -->
<span class=bbox><h3><A NAME="ssmiscellaneousextensions">miscellaneous extensions</a></h3></span>

<pre>
  <em class=def><A NAME="exfinfo">finfo</a></em> filename
  <em class=def><A NAME="exshell">shell</a></em> cmd
  <em class=def><a name="exmpg">mpg</a></em> mpgfile rawfile 
  <em class=def><A NAME="readogg">read-ogg</a></em> file
  <em class=def><A NAME="writeogg">write-ogg</a></em> snd
</pre>
<p><i>finfo</i> returns a description of the file <i>filename</i>. <i>shell</i> is similar
to Guile's <i>system</i> function, but output is sent to Snd's listener, rather than stdout.
<i>mpg</i> uses the system function to call the program mpg123 to translate an MPEG
format sound file to a headerless ("raw") file containing 16-bit samples.
</p>
<pre>
(shell "df")
(add-hook! close-hook (lambda (snd) (shell \"sndplay wood16.wav\")))
(mpg "mpeg.mpg" "mpeg.raw")
</pre>
<p>
Presumably a similar function could be written to call TiMidity to translate
MIDI files to something Snd can read, but I'm not having any luck getting it
to work. OGG Vorbis files can be handled in a similar manner: read-ogg and
write-ogg are examples.
</p>
<p>
Several of the functions in this section are slight robustifications of the
corresponding code in extsnd.html.  These include:
</p>
<pre>
  <em class=def><a name="exdochans">do-chans</a></em> func origin
  <em class=def><a name="exdoallchans">do-all-chans</a></em> func origin
  <em class=def><a name="exdosoundchans">do-sound-chans</a></em> func origin
  <em class=def><a name="exupdategraphs">update-graphs</a></em>
  <em class=def><a name="exeverysample">every-sample?</a></em> func
  <em class=def><a name="exsortsamples">sort-samples</a></em> bins
  <em class=def><a name="exwindowsamples">window-samples</a></em> <i>snd chn</i>
  <em class=def><a name="exdisplayenergy">display-energy</a></em> snd chn y0 y1
  <em class=def><a name="exwindowrms">window-rms</a></em>
  <em class=def><A NAME="exfftpeak">fft-peak</a></em> snd chn scale
</pre>
<p>
<i>do-chans</i> applies <i>func</i> to all syncd channels using <i>origin</i> as the edit history indication.
<i>do-all-chans</i> is the same but applies <i>func</i> to all active channels.
<i>do-sound-chans</i> applies <i>func</i> to all selected channels.
<i>update-graphs</i> updates (redraws) all graphs.
<i>every-sample?</i> applies <i>func</i> to each sample in the current channel and returns
#t if <i>func</i> is not #f for all samples; otherwise it moves the cursor to the first offending sample.
<i>sort-samples</i> provides a histogram of the samples (by amplitude) in <i>bins</i> bins.
<i>window-samples</i> returns (via the function <a href="extsnd.html#sndsamples">samples</a>) the samples
displayed in the current window for <i>snd</i>'s channel <i>chn</i>.
<i>display-energy</i> is a graph-hook function to display the time domain data squared.
<i>window-rms</i> returns the rms of the data in currently selected graph window.
<i>fft-peak</i> is a transform-hook function that returns the peak spectral magnitude.
</p>
<pre>
  <em class=def><A NAME="exlocatezero">locate-zero</a></em> limit
</pre>
<p>
<i>locate-zero</i> looks for the next sample where adjacent samples together are less than <i>limit</i>
and moves the cursor to that sample. It can be interrupted by C-g.
</p>
<pre>
  <em class=def><a name="exmakesoundinterp">make-sound-interp</a></em> start &amp;optional snd chn
  <em class=def><a name="exsoundinterp">sound-interp</a></em> reader loc
  <em class=def><a name="exenvsoundinterp">env-sound-interp</a></em> envelope &amp;optional (time-scale 1.0) snd chn) 
</pre>
<p><i>make-sound-interp</i> returns an interpolating reader for <i>snd</i>'s channel <i>chn</i>.
The interpolating reader reads a channel at an arbitary location,
interpolating between samples if necessary.  The corresponding generator is <i>sound-interp</i>.
The function <i>test-interp</i> shows one way to use this, using a sine wave to lookup the
current sound.
<i>env-sound-interp</i> reads <i>snd</i>'s channel <i>chn</i> (via a sound-interp generator)
according to <i>envelope</i> and <i>time-scale</i>.
It takes an envelope that goes between 0 and 1 (y-axis), and a time-scaler
(1.0 = original length) and returns a new version of the data in the specified channel
that follows that envelope (that is, when the envelope is 0 we get sample 0, when the
envelope is 1 we get the last sample, envelope = .5 we get the middle sample of the 
sound and so on). <code>(env-sound-interp '(0 0 1 1))</code> returns a copy of the
current sound; <code>(env-sound-interp '(0 0 1 1 2 0) 2.0)</code> returns a new sound 
with the sound copied first in normal order, then reversed.  src-sound with an
envelope could be used for this effect, but it is much more direct to apply the
envelope to sound sample positions.
</p>
<pre>
  <em class=def><A NAME="exsearchforclick">search-for-click</a></em>
  <em class=def><A NAME="exzeroplus">zero+</a></em>
  <em class=def><A NAME="exnextpeak">next-peak</a></em>
  <em class=def><A NAME="exfindpitch">find-pitch</a></em> pitch
</pre>
<p>These are examples of searching procedures (to be used with C-s and so on).  <i>zero+</i> finds the next
positive-going zero crossing (if searching forwards), <i>next-peak</i> finds
the next max or min in the waveform, and <i>find-pitch</i> finds the next
place where the given pitch is predominate.
</p>
<pre>
  <em class=def><A NAME="exsounddata2list">sound-data-&gt;list</a></em> sdata
</pre>
<p>This converts a sound-data object into a list of lists, each inner list
holding the samples of one channel.
</p>
<pre>
  <em class=def><A NAME="exsmoothchannelviaptree">smooth-channel-via-ptree</a></em> &amp;optional beg dur snd chn edpos
</pre>
<p>This is <a href="extsnd.html#smoothchannel">smooth-channel</a> as a virtual op.
</p>
<br>

<A NAME="extensionsdoc"></a><span class=box><h2>extensions.scm</h2></span>

<p>These were originally scattered around examp.scm; I thought it would be more
convenient if they were in one file.
</p>

<pre>
  <em class=def><a name="exchannelproperty">channel-property</a></em> key snd chn
  <em class=def><a name="exsoundproperty">sound-property</a></em> key snd

  <em class=def><a name="exsnddebug">snd-debug</a></em>
  <em class=def><a name="readlistenerline">read-listener-line</a></em> prompt
  <em class=def><a name="exsndtrace">snd-trace</a></em>

  <em class=def><a name="exmakeselection">make-selection</a></em> &amp;optional beg end snd chn
  <em class=def><a name="exdeleteselectionandsmooth">delete-selection-and-smooth</a></em>
  <em class=def><a name="exevaloverselection">eval-over-selection</a></em> func snd
  <em class=def><a name="exselectionmembers">selection-members</a></em>

  <em class=def><a name="exmapsoundfiles">map-sound-files</a></em> func &amp;optional dir
  <em class=def><a name="exforeachsoundfile">for-each-sound-file</a></em> func &amp;optional dir
  <em class=def><a name="exmatchsoundfiles">match-sound-files</a></em> func &amp;optional dir

  <em class=def><a name="exnormalizedmix">normalized-mix</a></em> filename beg in-chan snd chn
  <em class=def><a name="exenvelopedmix">enveloped-mix</a></em> filename beg env
  <em class=def><A NAME="exenvelopedmix1">enveloped-mix-1</a></em> filename beg env

  <em class=def><a name="exunsavededits">check-for-unsaved-edits</a></em> on
  <em class=def><a name="exremembersoundstate">remember-sound-state</a></em>

  <em class=def><a name="mixchannel">mix-channel</a></em> filedat beg dur snd chn edpos
  <em class=def><a name="insertchannel">insert-channel</a></em> filedat beg dur snd chn edpos
  <em class=def>redo-channel</em> edits snd chn
  <em class=def>undo-channel</em> edits snd chn
</pre>

<p><i>channel-property</i> returns the value associated with <i>key</i> in the given channel's
property list.  To add or change a property, use set! with this procedure.  Similarly,
<i>sound-property</i> provides access to a sound's property list.
</p>

<p>In <i>snd-debug</i> we're 
redirecting the Guile debugger's stdin and stdout IO via a read-write soft-port
and Snd's read-hook.  If you hit an error, call (snd-debug) rather than (debug).
<i>read-listener-line</i> is somewhat like read-line
but gets its input from the listener.  <i>snd-trace</i> activates any tracing
that you may have requested and redirects its output to the Snd listener.
</p>

<p><i>selection-members</i> returns a list of lists of (snd chn) indicating the channels participating in the current selection.
It is very similar to <i>all-chans</i> which returns a list of lists of all (snd chn)'s.
<i>delete-selection-and-smooth</i> deletes the current selection and smooths the splice.
</p>

<p><i>eval-over-selection</i> evaluates <i>func</i> on each sample in the current selection. The code:
</p>
<pre>
(bind-key (char-&gt;integer #\x) 4
	  (lambda ()
	    (if (selection?)
		(prompt-in-minibuffer "selection eval:" eval-over-selection)
		(report-in-minibuffer "no selection")))
	  #t)
</pre>
<p>binds the key sequence C-x x to a function that checks for an active selection,
then prompts (in the minibuffer) for the function to apply, and when
you eventually reply with a function, applies that function
to each sample in the selection.
make-selection makes a selection (like make-region but without creating
a region).
</p>
<p>
<i>map-sound-files</i> applies <i>func</i> to each sound file in <i>dir</i>.
<i>match-sound-files</i> applies <i>func</i> to each sound file in <i>dir</i> and returns a list of files for which func does not return #f.
</p>
<pre>
(for-each-sound-file
  (lambda (n) 
    (if (&gt; (mus-sound-duration n) 10.0) 
      (snd-print n)))
  (sound-files-in-directory "."))
</pre>
<p>We can use Guile's regexp support here to search for all .snd and .wav files:
</p>
<pre>
(let ((reg (make-regexp "\\.(wav|.snd)$")))
  (match-sound-files (lambda (file) (regexp-exec reg file))))
</pre>
<p>In fact, we could replace the built-in procedures <A NAME="addsoundextension1">add-sound-file-extension</a> and
sound-files in directory.  We're using some procedures written by Dirk Herrman here.
</p>
<pre>
(define (filter-list pred? objects)
  (let loop ((objs objects)
	     (result '()))
    (cond ((null? objs) (reverse! result))
	  ((pred? (car objs)) (loop (cdr objs) (cons (car objs) result)))
	  (else (loop (cdr objs) result)))))

(define (grep rx strings)
  (let ((r (make-regexp rx)))
    (filter-list (lambda (x) (regexp-exec r x)) strings)))

(define (directory-&gt;list dir)
  (let ((dport (opendir dir)))
    (let loop ((entry (readdir dport))
	       (files '()))
      (if (not (eof-object? entry))
	  (loop (readdir dport) (cons entry files))
	  (begin
	    (closedir dport)
	    (reverse! files))))))

;;; and now the Snd replacements
(define sound-file-extensions (list "snd" "aiff" "aif" "wav" "au" "aifc" "voc" "wve"))

(define (add-sound-file-extension-1 ext) 
  (set! sound-file-extensions (cons ext sound-file-extensions)))

(define* (sound-files-in-directory-1 #:optional (dir "."))
  (sort (grep
	 (format #f "\\.(~{~A~^|~})$" sound-file-extensions)
	 (directory-&gt;list dir))
	string&lt;?))
</pre>

<p><i>normalized-mix</i> is like <a href="extsnd.html#sndmix">mix</a> but the mixed result has same peak amplitude as the 
original data. <i>enveloped-mix</i> is like <a href="extsnd.html#sndmixsound">mix-sound</a>, but includes an
amplitude envelope over the mixed-in data.
</p>
<pre>
(enveloped-mix "pistol.snd" 0 '(0 0 1 1 2 0))
</pre>
<p><i>check-for-unsaved-edits</i> adds functions to the exit-hook and close-hook to check
for unsaved edits before exiting Snd or closing a file.  If its argument is #f, it removes
those hooks.
</p>
<p><i>remember-sound-state</i> saves most of a sound's display state when it is closed,
and if that same sound is subsquently re-opened, restores the previous state.
</p>

<p><i>mix-channel</i> is a regularized version of the file mixing functions (mix and mix-sound).
It's first argument can be either a filename (a string) or a list containing the filename, the
start point in the file, and (optionally) the channel of the file to mix.  For example:
</p>
<pre>
  (mix-channel "pistol.snd")
  (mix-channel "pistol.snd" 10000)       ; mixing starts at sample 10000 in current sound
  (mix-channel (list "pistol.snd" 1000)) ; mixed data starts at sample 1000 in pistol.snd
  (mix-channel (list "2.snd" 0 1))       ; mixed data reads channel 1 in 2.snd
</pre>
<p><i>insert-channel</i> is the same as mix-channel, but inserts the specified data.
</p>

<p><i>redo-channel</i> and <i>undo-channel</i> are regularized versions of
<a href="extsnd.html#sndredo">redo</a> and <a href="extsnd.html#sndundo">undo</a>.
</p>
<br><br>


<A NAME="fadedoc"></a><span class=box><h2>fade.scm</h2></span>

<p>
The two instruments in fade.scm perform frequency-domain cross-fades, that is, the
cross-fade is handled by a bank of bandpass filters (formant generators).  The effect
is sometimes only slightly different from a normal (time-domain) cross-fade, but
there are some interesting possibilities ("sound evaporation", etc).
</p>

<A NAME="fmvdoc"></a><span class=box><h2>fmv.scm</h2></span>

<p>fmv.scm implements the fm-violin (v.scm) as a CLM-style generator, making it possible
to call the violin anywhere a generator could be called; since each call on the fm-violin
function produces the next sample of the given violin, this form of the fm-violin is easy
to call in "real-time" situations.  Any other CLM-style instrument could
be rewritten in the same form.
</p>
<pre>
  <em class=def><A NAME="fmakefmviolin">make-fm-violin</a></em>
    frequency amplitude #:key (fm-index 1.0) (amp-env #f) (periodic-vibrato-rate 5.0) (random-vibrato-rate 16.0)
    (periodic-vibrato-amplitude 0.0025) (random-vibrato-amplitude 0.005) (noise-amount 0.0) (noise-freq 1000.0)
    (ind-noise-freq 10.0) (ind-noise-amount 0.0) (amp-noise-freq 20.0) (amp-noise-amount 0.0) (gliss-env #f)
    (fm1-env #f) (fm2-env #f) (fm3-env #f) (fm1-rat 1.0) (fm2-rat 3.0) (fm3-rat 4.0) (fm1-index #f) (fm2-index #f) 
    (fm3-index #f) (base 1.0) #:allow-other-keys)

  <em class=def><A NAME="ffmviolin">fm-violin</a></em> gen
  <em class=def><A NAME="ffmviolinins">fm-violin-ins</a></em> [same args as original violin in v.scm]
</pre>
<p><i>fm-violin-ins</i> shows how this generator can be fitted into the original fm-violin code.
The <i>make-fm-violin</i> function uses the optional arguments support from Guile (optargs.scm, loaded
via <code>(use-modules (ice-9 optargs))</code>). The plethora of arguments is an historical artifact;
normally only a few of them are used at a time.  There are two examples of calling this generator
in fmv.scm, the simpler one being:
</p>
<pre>
(define test-v 
  (lambda (beg dur freq amp amp-env)
    (let ((v (make-fm-violin 
	      freq amp 
	      :amp-env (let ((e (make-env :envelope (or amp-env '(0 0 1 1 2 0)) 
					  :scaler amp 
					  :end dur)))
			 (lambda () (env e)))))
	  (data (samples-&gt;vct beg dur)))
      (do ((i 0 (1+ i)))
	  ((= i dur))
	(vct-set! data i (+ (vct-ref data i)
			    (v))))
      (set-samples beg dur data))))
</pre>
<p>Here we are setting up an fm-violin generator (via make-fm-violin), then
calling it <i>dur</i> times, mixing its output into the current data (this could
also use mix-vct and so on).  The generator is called via <code>(v)</code>.
As can be seen here, each envelope is treated as a function called on each sample
very much like the "as-needed" input in src or granulate; the envelopes could actually be any
arbitrary function you like (see test-v1 in fmv.scm which uses an oscillator as one of
the fm index envelopes).  One complication in some "real-time" situations is that
you don't know in advance how long a note will be; in this case, the envelope
generating functions should have attack and decay ramps, triggered by note-on and
note-off; once the ramp has reached its end point, the end value should be held;
the note itself should be called until it has had time to ramp off; an exercise
for the interested reader.
</p>

<A NAME="gmdoc"></a><span class=box><h2>gm.scm</h2></span>

<p>gm.scm provides a simple way to get gmeteor to run in Snd.  See <a href="grfsnd.html#sndwithgmeteor">Snd with gmeteor</a>
for details.
</p>

<A NAME="goopsnddoc"></a><span class=box><h2>goopsnd.scm</h2></span>

<p>goopsnd.scm goofs around with goops, the Guile Object System.  As it stands, it
might provide simple examples of goops syntax, but I'm not sure it's of any value
yet. 
Fabio Furlanete's rmsgain.scm uses goops.
</p>



<A NAME="hooksdoc"></a><span class=box><h2>hooks.scm</h2></span>
<pre>
  <em class=def><a name="exdescribehook">describe-hook</a></em> hook
  <em class=def><A NAME="removelocalhook">remove-local-hook!</a></em> hook func
  <em class=def><a name="withlocalhook">with-local-hook</a></em> hook local-hook-procs thunk
  <em class=def><a name="resetallhooks">reset-all-hooks</a></em>
  <em class=def><a name="sndhooks1">snd-hooks</a></em>
</pre>
<p>hooks.scm has various hook-related functions.
<i>describe-hook</i> tries to decipher the functions on the hook list.
<i>remove-local-hook!</i> is a kludge to get around a bug in Guile's remove-hook! function;
it makes it possible to remove a locally-defined function from a hook.
<i>with-local-hook</i> is a kind of "let" for hooks.  <i>snd-hooks</i> returns
a list of all Snd-specific hooks; this is used by <i>reset-all-hooks</i> which
returns all hooks to the empty state. 
</p>

<A NAME="indexdoc"></a><span class=box><h2>index.scm, index.rb</h2></span>
<pre>
  <em class=def><A NAME="htmlreader">*html-reader*</a></em> "netscape"
  <em class=def><A NAME="html">html</a></em> obj
  <em class=def><A NAME="Q">?</a></em> obj
</pre>
<p>index.scm provides a connection between an HTML reader (default: netscape, determined
by the value of <i>*html-reader*</i>) and the Snd documentation.  The index itself is
built by index.cl, then accessed through the <i>html</i> and <i>?</i> functions.
<code>(html arg)</code> where arg can be a string, symbol, or procedure looks for a corresponding url
in the various Snd documents, 
and if one is found, calls *html-reader* with it.
<code>(? obj)</code> prints out any help it can find for obj, and tries to find obj in the documentation.
The function that actually passes the url to the reader is <a href="extsnd.html#sendnetscape">send-netscape</a>.
Since it uses X window properties specific to netscape, it's not obvious how any other HTML
reader can work.  All the following forms are acceptable:
</p>
<pre>
  (html "open-sound")
  (html 'open-sound)
  (html open-sound)
</pre>

<A NAME="maracadoc"></a><span class=box><h2>maraca.scm</h2></span>

<p>This file has a translation to Snd/Scheme of Perry Cook's maraca physical model.
</p>

<A NAME="marksdoc"></a><span class=box><h2>marks.scm</h2></span>

<p>marks.scm is a collection of mark-related functions.</p>

<pre>
  <em class=def><a name="markname2id">mark-name-&gt;id</a></em> name
  <em class=def><a name="describemark">describe-mark</a></em> id
  <em class=def><A NAME="syncup">syncup</a></em> ids
  <em class=def><a name="fitselectionbetweenmarks">fit-selection-between-marks</a></em> m1 m2
  <em class=def><a name="padmarks">pad-marks</a></em> ids secs
  <em class=def><a name="movesyncdmarks">move-syncd-marks</a></em> sync samples-to-move
  <em class=def><a name="playsyncdmarks">play-syncd-marks</a></em> sync
  <em class=def><a name="exevalbetweenmarks">eval-between-marks</a></em> func snd
  <em class=def><a name="exsnapmarks">snap-marks</a></em>
  <em class=def><a name="exdefineselectionviamarks">define-selection-via-marks</a></em> m1 m2
  <em class=def><a name="exsnapmarktobeat">snap-mark-to-beat</a></em>
  <em class=def><a name="exmarkexplode">mark-explode</a></em>
</pre>

<p><i>mark-name-&gt;id</i> is like <a href="extsnd.html#sndfindmark">find-mark</a> but searches all currently accessible channels.
<i>describe-mark</i> returns a description of the movements of mark id over the channel's edit history:
</p>
<pre>
:<em class=typing>(describe-mark 0)</em>
<em class=listener>((mark 0 sound 0 "oboe.snd" channel 0) 654 478)</em>
</pre>
<p>Here I placed a mark in oboe.snd at sample 654, then deleted a few samples
before it, causing it to move to sample 478.
<i>pad-marks</i> inserts <i>secs</i> seconds of silence before each in a list of marks (<i>ids</i>).
<i>fit-selection-between-marks</i> tries to squeeze the current selection between two marks,
using the granulate generator to fix up the selection duration (this still is not perfect).
<i>syncup</i> synchronizes a list of marks by inserting silences as needed.
<i>move-syncd-marks</i> moves any marks sharing the sync value <i>sync</i> by
<i>samples-to-move</i> samples.  Similarly, <i>play-syncd-marks</i> starts
playing from all marks sharing its <i>sync</i> argument.
</p>
<p>marks.scm also has code that tries to make it simpler to sync marks together
(see <i>start-sync</i> and <i>stop-sync</i>), and <i>report-mark-names</i>
that causes any named mark to display its name in the minibuffer when 
the underlying sample happens to be played.  There are also many mark-related
functions in examp.scm and scattered around the documentation.
</p>
<p><i>eval-between-marks</i> evaluates <i>func</i>
between the leftmost marks in <i>snd</i>.
</p>
<pre>
(bind-key (char-&gt;integer #\m) 0 
	  (lambda ()
	    (prompt-in-minibuffer "mark eval:" eval-between-marks)))
</pre>
<p><i>snap-marks</i> places marks at the start and end of the current selection.
<i>define-selection-via-marks</i> selects the portion between the given marks.
<i>snap-mark-to-beat</i> forces a dragged mark to end up on a beat.
<i>mark-explode</i> splits a sound into a bunch of separate files based on mark placements.
</p>


<A NAME="maxfdoc"></a><span class=box><h2>maxf.scm, maxf.rb</h2></span>

<p>These files are translations (thanks to Michael Scholz!) of CLM's maxf.ins
(thanks to Juan Reyes!). They implement a new kind of resonator designed by
Max Mathews.
</p>


<A NAME="mixdoc"></a><span class=box><h2>mix.scm</h2></span>

<p>mix.scm provides various mix-related utilities, including support for tracks.  The latter were originally
called groups in Snd, with their own elaborate dialog and what-not. That was jettisoned soon after it
was written.  The next thing to go were the mix consoles -- originally each mix encapsulated the
current Mix Panel in a little (but incredibly complicated) widget set that followed the mix around
in the time domain graph.  This was too hard to implement in Gtk+, and too hard to use in any case.
The current version has only the tag to drag a mix around, the Mix Panel to set mix amplitudes
and so on, and a bunch of hooks.  These hooks are used in mix.scm to implement one view of tracks,
which I assume are groups of related mixes.
</p>
<pre>
  <em class=def><a name="mixname2id">mix-name-&gt;id</a></em> name
  <em class=def><a name="mix2vct">mix-&gt;vct</a></em> id
  <em class=def><a name="panmix">pan-mix</a></em> file frame env
  <em class=def><a name="snapmixtobeat">snap-mix-to-beat</a></em>
  <em class=def><a name="deletemix">delete-mix</a></em> id
  <em class=def><a name="deleteallmixes">delete-all-mixes</a></em>
  <em class=def><a name="deletetrack">delete-track</a></em> id
  <em class=def><a name="deletealltracks">delete-all-tracks</a></em>
  <em class=def><a name="setalltracks">set-all-tracks</a></em> new-id
</pre>
<p>These are the mix utilities in mix.scm (unrelated to tracks). <i>mix-name-&gt;id</i>
returns the id of a given (named) mix. <i>mix-&gt;vct</i> returns the current samples
of mix <i>id</i> (taking into account its current amplitude an so on). <i>pan-mix</i>
mixes <i>file</i> into the current (stereo) sound starting at <i>frame</i> using the envelope <i>env</i>
to pan the mixed samples (0: all chan 0, 1: all chan 1).
<i>snap-mix-to-beat</i> forces a dragged mix to end up on a beat.
<i>delete-mix</i> deletes the mix referred to by its argument; this
operation can be undone (bringing the mix back to life).
</p>
<center><img src="pan.png" alt="picture of panning"></center>
<pre>
  <em class=def><a name="maketrack">make-track</a></em> id mixes
  <em class=def><a name="track">track</a></em> id
  <em class=def><a name="track2vct">track-&gt;vct</a></em> track
  <em class=def><a name="savetrack">save-track</a></em> track filename

  <em class=def><a name="trackcolor">track-color</a></em> track
  <em class=def><a name="settrackcolor">set-track-color</a></em> track color
  <em class=def><a name="settrackamp">set-track-amp</a></em> track amp
  <em class=def><A NAME="incftrackamp">incf-track-amp</a></em> track amp-increment
  <em class=def><a name="settrackspeed">set-track-speed</a></em> track speed
  <em class=def><a name="transposetrack">transpose-track</a></em> track semitones
  <em class=def><a name="trackposition">track-position</a></em> track
  <em class=def><a name="settrackposition">set-track-position</a></em> track position
  <em class=def><a name="trackend">track-end</a></em> track
  <em class=def><a name="tracklength">track-length</a></em> track
  <em class=def><a name="settracktempo">set-track-tempo</a></em> track tempo
  <em class=def><a name="settrackampenv">set-track-amp-env</a></em> track chan env
  <em class=def><a name="reversetrack">reverse-track</a></em> track
  <em class=def><a name="filtertrack">filter-track</a></em> track coeffs

  <em class=def><A NAME="mixpanelappliestotrack">mix-panel-applies-to-track</a></em>
</pre>
<p>A track is a list of mixes, each member mix having its track set to the track id.  The <i>make-track</i>
function takes the track id and the list of member mixes, returning the list of mixes.  Thereafter, the
<i>track</i> function returns the mix list given the track <i>id</i>.  The rest of the track functions
take the track mix list as their initial argument.  <i>track-&gt;vct</i> places all the mix samples
in the track into a vct object.  Similarly, <i>save-track</i> places the track's samples into a file.
</p>
<p>
The track-color refers to the color of the mix waveform (the thing displayed to the right
of the red tag).  <i>set-track-color</i> sets this color using Snd <a href="extsnd.html#colors">colors</a>.
</p>
<pre>  
:<em class=typing>(define hi (make-track 1 (list 0 1)))</em>
<em class=listener>#&lt;unspecified&gt;</em>
:<em class=typing>(track 1)</em>
<em class=listener>(0 1)</em>
:<em class=typing>(mix-track 0)</em>
<em class=listener>1</em>
:<em class=typing>(set-track-color (track 1) (make-color 0 0 1))</em>
<em class=listener>(#&lt;color: (0.00 0.00 1.00)&gt; #&lt;color: (0.00 0.00 1.00)&gt;)</em>
</pre>
<p>The track-position is the position (begin sample) of the first mix in the track.
<i>set-track-position</i> moves all the mixes in the track so that its first sample
is <i>position</i>:
</p>
<pre>
:<em class=typing>(track-position (track 1))</em>
<em class=listener>10748</em>
:<em class=typing>(mix-position 0)</em>
<em class=listener>10748</em>
:<em class=typing>(mix-position 1)</em>
<em class=listener>23287</em>
:<em class=typing>(set-track-position (track 1) 1500)</em>
<em class=listener>(1500 14039)</em>
:<em class=typing>(mix-position 0)</em>
<em class=listener>1500</em>
:<em class=typing>(mix-position 1)</em>
<em class=listener>14039</em>
</pre>
<p>The track-amp reflects the mix amps (unless you set them individually, but I guess that
quibble is true of all these settings). <i>set-track-amp</i> sets each mix channel's <i>chan</i>
amplitude to <i>amp</i>.  Similarly, <i>incf-track-amp</i> increments each amplitude by
<i>amp-increment</i>.  The track-speed refers to its mix's speeds: <i>set-track-speed</i>
sets all of them to <i>speed</i>, and <i>transpose-track</i> moves them all by <i>semitones</i>.
<i>track-length</i> returns the total duration (samples) of the track, <i>track-end</i> returns
the last sample:
</p>
<pre>
:<em class=typing>(track-length (track 1))</em>
<em class=listener>16346</em>
:<em class=typing>(- (+ (mix-position 1) (mix-frames 1)) (mix-position 0))</em>
<em class=listener>16346</em>
:<em class=typing>(track-end (track 1))</em>
<em class=listener>17846</em>
:<em class=typing>(max (+ (mix-position 0) (mix-frames 0)) (+ (mix-position 1) (mix-frames 1)))</em>
<em class=listener>17846</em>
</pre>
<p><i>set-track-tempo</i> affects the time between the successive mix begin points (tempo &gt; 1.0 makes the
mixes happen more quickly):
</p>
<pre>
:<em class=typing>(set-track-tempo (track 1) 2.0)</em>
<em class=listener>(1500 7770)</em>
:<em class=typing>(mix-position 0)</em>
<em class=listener>1500</em>
:<em class=typing>(mix-position 1)</em>
<em class=listener>7770</em>
:<em class=typing>(+ 1500 (* .5 (- 14039 1500))) ; 14039 is the former mix 1 begin time (see above)</em>
<em class=listener>7769.5</em>
</pre>
<p><i>set-track-amp-env</i> applies an amplitude envelope over the entire track, setting
each mix's amp env(s) to match the portion of that envelope that happens to fall over them
(multiplying envelopes if the mix aready has one).
<i>filter-track</i> applies a filter to each mix sound at the pre-mix point (that is, the
mixed in sound is being edited, then the mix takes place); any kind of edit can follow the
same sequence.  <i>reverse-track</i> reverses the order in which a track's members occur.
</p>
<p>Finally, the various mix hooks can be tied into these functions so that (for example) the
entire track moves when you drag one mix in it, or all the amplitudes change at once.
<i>mix-panel-applies-to-track</i>, for example,
causes multichannel mixes to be placed in a separate track,
and subsequent srate or position changes affect all channels in parallel (this makes
it easier to mix multichannel files into other multichannel files and keep the mixed
channels in sync).
Most of the "set-" functions also exist in the generalized set! form, for example
<code>(set! (track-position trk) 0)</code>.
</p>

<A NAME="moogdoc"></a><span class=box><h2>moog.scm</h2></span>
<pre>
  <em class=def><A NAME="makemoogfilter">make-moog-filter</a></em> frequency Q
  <em class=def><A NAME="moogfilter">moog-filter</a></em> gen input
</pre>
<p>moog.scm is a translation of CLM's moog.lisp (written by Fernando Lopez-Lezcano --
http://www-ccrma.stanford.edu/~nando/clm/moog),
itself a translation of Tim Stilson's original C code.  The functions provide
a kind of CLM generator view of the filter.  Fernando describes it as a
"Moog style four pole lowpass (24db/Oct) filter clm unit generator,
variable resonance, warm, analog sound ;-)".
In <i>make-moog-filter</i> "frequency" is the cutoff frequency
in Hz (more or less) and "Q" is the resonance: 0 = no resonance,
1 causes the filter to oscillate at frequency.  My translation is
a bit simple-minded; with a little effort, this could run much
faster.
</p>
<pre>
  (define (moog freq Q)
    (let ((gen (<em class=red>make-moog-filter</em> freq Q)))
      (lambda (inval)
        (<em class=red>moog-filter</em> gen inval))))

  (map-chan (moog 1200.0 .7))
</pre>
<p>The Ruby version of this is in examp.rb.
</p>

<A NAME="musglyphs"></a><span class=box><h2>musglyphs.scm</h2></span>

<p>musglyphs.scm provides Scheme/Snd wrappers to load CMN's cmn-glyphs.lisp (directly!),
thereby defining most of the standard music notation symbols.  Each of the original
functions (e.g. draw-bass-clef) becomes a Snd/Scheme procedure of the form
<code>(name &amp;optional x y size style snd chn context)</code>.  For example,
<code>(draw-bass-clef 100 100 50)</code> draws a bass clef in the current graph
at position (100 100) of size 50; since the <i>style</i> argument defaults to
#f, the clef is displayed as a filled polygon; use #t to get an outline of
the clef instead.  You need CMN, or at least the CMN file cmn-glyphs.lisp
before loading this file.
</p>
<img src="sndcmn.png" alt="Snd with music symbols">
<br>
<p>(The dot size bug in this picture has been fixed, but I'm too lazy
to make a new version of the picture).
</p>
<br>

<A NAME="nbdoc"></a><span class=box><h2>nb.scm</h2></span>

<p>nb.scm provides popup help for files in the View:Files dialog; as you move
the mouse through the lists, the help dialog posts information about the file
underneath the mouse.  This uses a slightly fancier file information procedure
than 'finfo' in examp.scm.  If you have the guile-gdbm package, you can use
its database procedures to associate arbitrary information with files which
will be posted along with the header info:
</p>
<pre>
  <em class=def><A NAME="nbdb">nb</a></em> file note
  <em class=def><A NAME="unbdb">unb</a></em> file
  <em class=def><A NAME="prunedb">prune-db</a></em>
</pre>
<p><code>(nb "test.snd" "this is a test")</code> adds the note "this is a test" to
the data associated with "test.snd".  <code>(unb "test.snd")</code> erases anything
associated with "test.snd".  <code>(prune-db)</code> erases anything associated with
any files that no longer exist.  (nb.scm will work fine without guile-gdbm; to load
guile-gdbm, set the variable <b>use-gdbm</b> to #t).
</p>
<p>Michael Scholz's translation of this to Ruby is included in examp.rb.
</p>

<A NAME="peakenvdoc"></a><span class=box><h2>peak-env.scm</h2></span>

<p>The functions in peak-env.scm provide relatively robust access to
peak envelope files.  These files save Snd's overall amplitude envelopes
for a given sound so that a subsequent re-open of that sound has the
waveform immediately.  For very large sounds, this can save as much as
a minute during which Snd is running the amplitude envelope builders
in the background and displaying whatever it can.  That is, it makes
opening a large sound much faster after the initial read and save.
The file has a variable <b>save-peak-env-info</b> (default #t) which
determines whether these envelopes are being saved.  The procedure
</p>
<pre>
(define (peak-env-info-file-name snd chn)	
  (format #f "~A/~A-peaks-~D" save-peak-env-info-directory (short-file-name snd) chn))
</pre>
<p>determines the saved peak env file name; in the default
case, it looks for the directory ~/peaks, but obviously this
could be changed to suit your situation.
</p>

<A NAME="pianodoc"></a><span class=box><h2>piano.scm, piano.rb</h2></span>

<p>These files are translations of CLM's piano.ins, a piano physical
model by Scott van Duyne.
</p>

<A NAME="playdoc"></a><span class=box><h2>play.scm</h2></span>

<p>These functions play sounds in various ways.</p>
<pre>
  <em class=def><A NAME="playsound">playsound</a></em> <i>func</i>
</pre>
<p><i>play-sound</i> plays the current sound, calling (func data) on each buffer if func is passed.
It is also an example of calling the low level mus-audio functions, rather than calling
play-channel and friends. The latter are easier to use, in most cases.  For example,
to set up the keyboard
as a kind of extended piano, we could map keys to sounds:
</p>
<pre>
(bind-key (char-&gt;integer #\o) 0 (lambda () (play "oboe.snd")))
(bind-key (char-&gt;integer #\p) 0 (lambda () (play "pistol.snd")))
</pre>
<p>The various play hooks can be used to play sounds over and over. 
</p>
<pre>
  <em class=def><A NAME="expl">play-often</a></em> times
  <em class=def><A NAME="expluntil">play-until-c-g</a></em>
  <em class=def><a name="explayregionforever">play-region-forever</a></em> region

(bind-key (char-&gt;integer #\p) 0 (lambda (n) (play-often (max 1 n))))
(bind-key (char-&gt;integer #\r) 0 (lambda (n) (play-region-forever (max 0 n))))
</pre>
<p>Now C-u 31 p plays the current sound 31 times; C-u 3 r plays region 3 until we type C-g.
<i>play-often</i> uses stop-playing-hook, and <i>play-region-forever</i> uses stop-playing-region-hook.
With a sufficiently fast computer, it's possible to create the samples to be played 
in "real-time".  <i>play-fun</i> starts and stops the DAC, <i>ampit</i> and <i>amprt</i>
fill up the audio buffer with data.
</p>
<pre>
(play-fun (ampit (frames) 2.0) 256)
</pre>
<p>scales sound 0's samples by 2 and sends them to the DAC. (These three functions are now obsolete).
More useful is:</p>
<pre>
  <em class=def><A NAME="exloopbetweenmarks">loop-it</a></em> mark1 mark2 buffer-size
</pre>
<p>which loops continuously between the two specified marks.
The marks can be moved as the sound is played; C-g stops loop-between-marks.
If you want the DAC to be held open in the background,
</p>
<pre>
  <em class=def><A NAME="exstartdac">start-dac</a></em>
  <em class=def><A NAME="exstopdac">stop-dac</a></em>
</pre>
<p>The vector-synthesis 
idea (and weird name) came from a linux-audio-development mailing list.
Apparently some commercial synths (or software?) provide this.
It reads any number of sound files, using a function to
decide which one to send to the DAC.
</p>



<A NAME="popupdoc"></a><span class=box><h2>popup.scm and gtk-popup.scm</h2></span>
<pre>
  <em class=def><a name="addselectionpopup">add-selection-popup</a></em> 
  <em class=def><a name="addlistenerpopup">add-listener-popup</a></em> 
</pre>
<p>
gtk-popup.scm is the Gtk/xg version; popup.scm is Motif/xm based.
<b>add-selection-popup</b> creates a selection-oriented popup menu that is
posted if you click button3 in the selected portion, as well as a time-domain popup
menu, and an fft-specific menu.
<b>add-listener-popup</b> creates a listener-oriented popup menu that is
posted if you click button3 in the listener.
</p>


<A NAME="pqwvoxdoc"></a><span class=box><h2>pqwvox.scm</h2></span>
<pre>
  <em class=def><A NAME="pqwvox">pqw-vox</a></em> beg dur freq spacing-freq amp ampfun freqfun freqscl phonemes formant-amps formant-shapes
</pre>
<p>pqwvox ("phase-quadrature waveshaping voice") was originally written by Marc LeBrun in the late 70's using waveshaping.  It was 
changed to use FM for the Samson Box since the box had trouble performing waveshaping, then
changed back to waveshaping in this version.
The basic idea is that each of the three vocal formants is created by two
sets of waveshapers, one centered on the even multiple of the base frequency closest to the desired formant frequency,
and the other on the nearest odd multiple.  As the base frequency moves (vibrato, glissando),
these center frequencies are recalculated (on each sample), and the respective amplitudes
set from the distance to the desired frequency.  If a center frequency moves (for example,
the base frequency moves down far enough that the previous upper member of the pair has
to become the lower member), the upper waveshaper (which has ramped to zero amplitude), jumps
down to its new center. The formant table was provided by Robert Poor.
The phase-quadrature part of the business creates single side-band spectra.
For details on waveshaping, see Le Brun, "Digital Waveshaping Synthesis", JAES 1979 April, vol 27, no 4, p250.
It might be simpler to set up three formant generators and drive them with the waveshapers,
but the leap-frog idea was a neat hack -- such things are worth keeping even when
they aren't all that sensible anymore.  (Also, I noticed while writing this paragraph that
the single-sideband cancellation is not working as I expected -- another bug to track down...)
</p>

<A NAME="prc95doc"></a><span class=box><h2>prc95.scm</h2></span>

<p>prc95.scm is a translation to Snd of Perry Cook's (1995) physical modelling toolkit; prc-toolkit95.lisp 
in CLM.  One starting point for physical modelling is Smith, "Music Applications of Digital Waveguides", CCRMA, Stan-M-39, 1987,
or Julius's <a href="http://www-ccrma.stanford.edu/~jos">home</a> page, or
any of several classic papers also by Julius Smith.  Perry's own version of this code can be
found in <a href="www-ccrma.stanford.edu/CCRMA/Software/STK/">STK</a>.
The example instruments are:
</p>
<pre>
  <em class=def><A NAME="plucky">plucky</a></em> beg dur freq amplitude maxa
  <em class=def><A NAME="bow">bow</a></em> beg dur frq amplitude maxa
  <em class=def><A NAME="brass">brass</a></em> beg dur freq amplitude maxa
  <em class=def><A NAME="clarinet">clarinet</a></em> beg dur freq amplitude maxa
  <em class=def><A NAME="flute">flute</a></em> beg dur freq amplitude maxa

(define (test-prc95)
  (plucky 0 .3 440 .2 1.0)
  (bow .5 .3 220 .2 1.0)
  (brass 1 .3 440 .2 1.0)
  (clarinet 1.5 .3 440 .2 1.0)
  (flute 2 .3 440 .2 1.0))
</pre>

<A NAME="pvocdoc"></a><span class=box><h2>pvoc.scm</h2></span>
<p>
This is the same as the CLM phase-vocoder generator, but implemented in Scheme.  If you're interested
in how the thing works, I think the Scheme version is easiest to understand; the Common Lisp version 
is in mus.lisp, and the C version is in clm.c.
</p>
<pre>
  <em class=def><A NAME="makepvocoder">make-pvocoder</a></em> fftsize overlap interp analyze edit synthesize
  <em class=def><A NAME="pvocoder">pvocoder</a></em> gen input
  <em class=def><A NAME="expvoc">pvoc</a></em> #:key (fftsize 512) (overlap 4) (time 1.0) (pitch 1.0) (gate 0.0) (hoffset 0.0) (snd 0) (chn 0)
</pre>
<p>The <i>analyze</i>, <i>edit</i>, and <i>synthesize</i> arguments to make-pvocoder are
functions that are applied as needed during pvocoder processing; similarly, the <i>input</i>
argument to pvocoder can be a function.
pvoc.scm also contains a few examples of using the CLM phase-vocoder generator.
For example:
</p>
<pre>
(define test-pv-4
  (lambda (gate)
    (let ((pv (make-phase-vocoder #f
				  512 4 128 1.0
				  #f ;no change to analysis
				  (lambda (v)
				    (let ((N (mus-length v)))
				      (do ((i 0 (1+ i)))
					  ((= i N))
					(if (&lt; (vct-ref (pv-amp-increments v) i) gate)
					    (vct-set! (pv-amp-increments v) i 0.0)))
				      #t))
				  #f ;no change to synthesis))
	  (reader (make-sample-reader 0)))
      (map-chan (lambda (val)
		  (phase-vocoder pv (lambda (dir) 
				      (reader)))))
      (free-sample-reader reader))))
</pre>
<p>sets up a phase-vocoder generator whose edit function is squelching soft partials.
In this case, the input function is reading the currently selected channel.  The fastest
way to try out this generator is to use it as the argument to filter-sound.
<i>pvoc</i> is yet another a phase-vocoder;
it applies the phase-vocoder (i.e. fft analysis, oscil bank resynthesis)
to the current sound; <i>pitch</i> specifies the pitch transposition ratio, 
<i>time</i> specifies the time dilation ratio,
<i>gate</i> specifies a resynthesis gate in dB (partials with amplitudes lower than
the gate value will not be synthesized), <i>hoffset</i> is a pitch offset in Hz.
</p>

<A NAME="rgbdoc"></a><span class=box><h2>rgb.scm</h2></span>
<p>rgb.scm (rgb.rb) is a simple translation of the standard X11 color names into Snd
color objects.
</p>
<pre>
(define snow (make-color 1.00 0.98 0.98))
</pre>
<p>is taken from the line</p>
<pre>
255 250 250             snow
</pre>
<p>/usr/lib/X11/rgb.txt.  The choice of a float between 0.0 and 1.0 (rather
than an integer between 0 and 255) mimics PostScript;
as video hardware has improved over the years, there's
less and less need for these elaborate color names, and less
reason (except perhaps psychophysical) to limit these numbers to bytes.
There is one gotcha in this file -- X11 defines a color named "tan"
which is already used by Scheme, so (at the suggestion of Dave Phillips)
this color is named "tawny" in rgb.scm.
</p>

<A NAME="rtiodoc"></a><span class=box><h2>rtio.scm</h2></span>

<p>rtio.scm has a collection of functions oriented loosely around
"real-time" operations.
</p>
<pre>
  <em class=def><A NAME="exshowinput">show-input</a></em> &amp;optional (in-sys 0)
  <em class=def><A NAME="exshowinputfft">show-input-fft</a></em> &amp;optional (in-sys 0)
  <em class=def><A NAME="exshowdraggableinputfft">show-draggable-input-fft</a></em> &amp;optional (in-sys 0)
  <em class=def><A NAME="exinout">in-out</a></em> func in-sys out-sys
</pre>
<p>These three functions show how to read incoming data (from the adc),
write data (to the dac), and interpose a function while reading and
writing data.  There are several example functions (for the "func" argument) that filter the data or
change its amplitude. <i>show-input-fft</i> displays the input data's
spectrum.  <i>show-draggable-input-fft</i> is the same, but the X axis
(the frequency axis in this case) is draggable, as in Snd's FFT display.
</p>

<A NAME="rubberdoc"></a><span class=box><h2>rubber.scm, rubber.rb</h2></span>

<pre>
  <em class=def><a name="rubbersound">rubber-sound</a></em> stretch-factor
</pre>
<p>
<i>rubber-sound</i> tries to stretch or contract a sound (in time); it scans the sound
looking for stable (periodic) sections, then either deletes periods or interpolates new ones
to shorten or lengthen the sound.  It still needs a lot of robustification.
The algorithm is 1) remove all frequencies below 16 Hz, 2) resample the file to be
ten times longer (interpolating samples), 3) make a list of upward zero crossings,
4) using autocorrelation decide where the next fundamental zero crossing probably
is and see how much difference there is between the current period and the next,
5) check intermediate crossing weights and if the autocorrelation weight is not
the smallest, throw away this crossing, 6) sort the remaining crossings by least weight,
7) interpolate or delete periods until the sound has been sufficiently lengthened or
shortened.
</p>

<A NAME="singerdoc"></a><span class=box><h2>singer.scm</h2></span>

<p>singer.scm is a translation of CLM's singer.ins.  It implements
a physical model of the vocal tract described in
</p>
<pre>
  Cook, Perry R. "Synthesis of the Singing Voice Using a Physically Parameterized Model of the Human Vocal Tract"
     Published in the Proceedings of the International Computer Music Conference, Ohio 1989 
     and as Stanford University Department of Music Technical Report Stan-M-57, August 1989.
 
 ---- "Identification of Control Parameters in an Articulatory Vocal Tract Model, with Applications 
    to the Synthesis of Singing," Ph.D. Thesis, Stanford University Department of Music Technical Report 
    Stan-M-68, December 1990.

 ----  "SPASM, a Real-time Vocal Tract Physical Model Controller; and Singer, the Companion Software 
    Synthesis System", Computer Music Journal, vol 17 no 1 Spring 1993.
</pre>
<p>
There are a couple example calls at the end of the instrument code.
</p>


<A NAME="snd4doc"></a><span class=box><h2>snd4.scm</h2></span>

<p>The Snd-4 compatibilty file contains a number of the procedures
that were removed from or renamed in Snd-5.  
</p>

<A NAME="snd5doc"></a><span class=box><h2>snd5.scm</h2></span>

<p>The Snd-5 compatibilty file contains a number of the procedures
that were moved from C to Scheme during Snd-5 development.
</p>
<table border=0 cellspacing=10>
<!-- backward-sample -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><A NAME="sndbackwardsample">backward-sample</a></em> (<i>count snd chn</i>)</code></span>
</td></tr>
<tr><td></td><td>
move back <i>count</i> samples (C-b), return new cursor position.
</td></tr>
<tr><td colspan=2></td></tr>

<!-- forward-sample -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><A NAME="sndforwardsample">forward-sample</a></em> (<i>count snd chn</i>)</code></span>
</td></tr>
<tr><td></td><td>
move forward <i>count</i> samples (C-f), return new cursor position.
</td></tr>
<tr><td colspan=2></td></tr>
</table>

<table border=0 cellspacing=5>
<!-- vct-do! -->
<tr><td><span class=defbox><code><em class=def><A NAME="vctdo">vct-do!</a></em> (vobj proc)</code></span></td>
<td><code>vobj[i] = (funcall proc i)</code>.</td></tr>

<!-- vcts-do! -->
<tr><td><span class=defbox><code><em class=def><A NAME="vctsdo">vcts-do!</a></em> (vobj... proc)</code></span></td>
<td><code>vobj[vi][i] = (nth vi (funcall proc num i))</code>.</td></tr>

<!-- vcts-map! -->
<tr><td><span class=defbox><code><em class=def><A NAME="vctsmap">vcts-map!</a></em> (vobj... proc)</code></span></td>
<td><code>vobj[vi][i] = (nth vi (funcall proc num))</code>.</td></tr>

</table>

<p><i>vct-do!</i>
is the same as <i>vct-map!</i> except that the called function should take one
argument, the current loop index.  Similarly, <i>vcts-map!</i> and <i>vcts-do!</i>
take any number of vcts, followed by a trailing function, and map the function's
results (assumed to be a list that matches the current number of vcts) into the
vct array.  In the map! case, the function takes one argument, the current number
of vcts awaiting values; in the do! case, it takes two arguments, the vct
number and the current loop index.  For example, we could rewrite the cnvtest
function to take stereo sounds:
</p>
<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(define cnvtest
  (lambda (snd0 snd1 amp0 amp1)
    (if (and (= (channels snd0) 2)
	     (= (channels snd1) 2))
	(let* ((flt-len (frames snd0))
	       (total-len (+ flt-len (frames snd1)))
	       (cnv10 (make-convolve :filter (samples-&gt;vct 0 flt-len snd0 0)))
	       (cnv11 (make-convolve :filter (samples-&gt;vct 0 flt-len snd0 1)))
	       (sf10 (make-sample-reader 0 snd1 0))
	       (sf11 (make-sample-reader 0 snd1 1))
	       (out-data10 (make-vct total-len))
	       (out-data11 (make-vct total-len)))
	  (<em class=red>vcts-map!</em> out-data10 out-data11 
		     (lambda (num)
		       (list
			(convolve cnv10 (lambda (dir) (read-sample sf10)))
			(convolve cnv11 (lambda (dir) (read-sample sf11))))))
	  (free-sample-reader sf10)
	  (free-sample-reader sf11)
	  (vct-scale! out-data10 amp0)
	  (vct-scale! out-data11 amp1)
	  (vct-&gt;samples 0 total-len out-data10 snd1 0)
	  (vct-&gt;samples 0 total-len out-data11 snd1 1))
	(snd-print "oops -- need stereo input"))))
</pre></td></tr></table>
<br><br>

<A NAME="snd6doc"></a><span class=box><h2>snd6.scm</h2></span>

<p>As with snd5.scm and snd4.scm, snd6.scm has functions that provide
backwards compatibility within version 6.
Currently, these are just some old (untypable) constant names,
and some slightly inconsistent old function names.
<b><a name="sndclearaudioinputs">clear-audio-inputs</a></b>
in Linux/OSS, tries to reduce soundcard background racket.
<b><a name="sndappendtominibuffer">append-to-minibuffer</a></b> (msg <i>snd</i>)
appends <i>msg</i> to whatever is in <i>snd</i>'s minibuffer.
<b><a name="sndselectmix">select-mix</a></b> sets the selected mix (#f = none).
</td></tr>

</p>



<A NAME="sndgldoc"></a><span class=box><h2>snd-gl.scm</h2></span>

<p>snd-gl.scm has examples of using OpenGL.
</p>
<pre>
  <em class=def><A NAME="glinfo">gl-info</a></em>
  <em class=def><a name="startwaterfall">start-waterfall</a></em> &amp;optional (scl 1.0) (pc-spectrum 0.2) (fft-size 512)
  <em class=def><A NAME="stopwaterfall">stop-waterfall</a></em>
  <em class=def><A NAME="gldumpstate">gl-dump-state</a></em>
</pre>
<p><b>gl-info</b> prints out information about the current GL system setup.  <b>start-waterfall</b> starts a
waterfall spectrum display of the incoming audio data.  <b>stop-waterfall</b> turns it off.
<b>gl-dump-state</b> displays much of the current GL graphics state.
</p>

<A NAME="sndmotifdoc"></a><span class=box><h2>snd-motif.scm</h2></span>

<pre>
  <em class=def><a name="installsearcher">install-searcher</a></em> proc
  <em class=def><a name="zync">zync</a></em> 
  <em class=def><a name="foreachchild">for-each-child</a></em> w func
  <em class=def><a name="makehiddencontrols-dialog">make-hidden-controls-dialog</a></em> 
  <em class=def><a name="createfmvdialog">create-fmv-dialog</a></em> 
  <em class=def><a name="makepixmap">make-pixmap</a></em> strs
  <em class=def><a name="displayscannedsynthesis">display-scanned-synthesis</a></em> 
  <em class=def><a name="disablecontrolpanel">disable-control-panel</a></em> 
  <em class=def><a name="addmarkpane">add-mark-pane</a></em> 
  <em class=def><a name="selectfile">select-file</a></em> func <i>title dir filter help</i>
  <em class=def><a name="sndclockicon">snd-clock-icon</a></em> snd hour
  <em class=def><a name="makesoundbox">make-sound-box</a></em> name parent select-func peak-func sounds args
  <em class=def><a name="showsmptelabel">show-smpte-label</a></em> on-or-off
  <em class=def><a name="makelevelmeter">make-level-meter</a></em> parent width height
  <em class=def><a name="showdiskspace">show-disk-space</a></em>
  <em class=def><A NAME="keepfiledialogopenuponok">keep-file-dialog-open-upon-ok</a></em>
  <em class=def><A NAME="addampcontrols">add-amp-controls</a></em>
  <em class=def><A NAME="addveryusefulicons">add-very-useful-icons</a></em>
  <em class=def><A NAME="adddeleteoption">add-delete-option, add-rename-option</a></em>
  <em class=def><A NAME="marksynccolor">mark-sync-color</a></em> new-color
  <em class=def><A NAME="addtooltip">add-tooltip</a></em> widget tip
  <em class=def><A NAME="menuoption">menu-option</a></em> menu-name
  <em class=def><A NAME="showallatoms">show-all-atoms</a></em>
  <em class=def><A NAME="makechanneldropsite">make-channel-drop-site</a></em> snd chn
  <em class=def><A NAME="setchanneldrop">set-channel-drop</a></em> drop snd chn
  <em class=def><A NAME="showfontname">show-font-name</a></em> font
  <em class=def><A NAME="showminibufferfont">show-minibuffer-font</a></em>
  <em class=def><A NAME="addfindtolistener">add-find-to-listener</a></em>
  <em class=def><A NAME="uponsaveyourself">upon-save-yourself, upon-take-focus</a></em>
</pre>

<p>snd-motif.scm has procedures that rely on the Motif module (xm.c).
Some of these have been translated to Gtk and xg.c -- snd-gtk.scm.
<b>install-searcher</b> places
our own search procedure into the filter mechanism in the File:Open
dialog. The pair <b>zync</b> and <b>unzync</b> cause the
y-axis zoom sliders of a multi-channel file to move together or separately.
<b>make-hidden-controls-dialog</b> adds "Hidden controls" to the Option
menu.  If you click it, it
creates a dialog that controls all the hidden control-panel variables.
The "expand-hop" control sets the hop size (per grain), "expand-length"
sets the grain length, "expand-ramp" sets the slope of the grain amplitude envelope,
"contrast-amp" sets the prescaler for the contrast effect, "reverb-feedback" sets the feedback
amount in the reverberator (it sets all the comb filter scalers), and "reverb-lowpass" sets
the lowpass filter coefficient in the reverberator. 
<b>create-fmv-dialog</b> sets up a very simple dialog with amplitude control on
the fm-violin (fmv.scm) running (interpreted!) in "real-time".
<b>make-pixmap</b> turns xpm-style description into pixmap.
<b>display-scanned-synthesis</b> opens a pane for experimenting with scanned synthesis.
<b>disable-control-panel</b> does away with the control panel.
<b>add-mark-pane</b> adds a pane to each channel giving the current mark locations (sample values).
These can be edited to move the mark, or deleted to delete the mark.
<b>select-file</b> starts a file selection dialog, running func if a file is selected.
</p>
<pre>
 (add-to-menu 0 "Insert File" 
   (lambda () 
     (select-file 
       (lambda (filename)
         (insert-sound filename))
       "Insert File" "." "*" "file will be inserted at cursor")))
</pre>
<p><b>snd-clock-icon</b> replaces Snd's hourglass with a clock.
<b>make-sound-box</b> makes a container of sound file icons, each icon
containing a little sketch of the waveform, the length of the
file, and the filename.  What happens when an icon is selected
is up to the caller-supplied procedure.
</p>
<pre>
(make-sound-box "sounds"
		(list-ref (main-widgets) 3)
		(lambda (file) (snd-print file))
		peak-env-info-filename ; this points to ~/peaks in my case
		(list "oboe.snd" "pistol.snd" "cardinal.snd" "storm.snd")
		'())
</pre>
<p><b>show-smpte-label</b> shows the current SMPTE frame number in a box
in the upper left corner of the graph.
<b>make-level-meter</b> creates A VU meter of any width and height, returning
a list of information associated with that meter.  Pass that list to 
<b>display-level</b> to move the needle and the red bubble.  This meter
assumes you'll call it periodically so that the momentum needle and viscosity of
the bubble will appear to behave naturally.  <b>with-level-meters</b> adds
any number of these meters to the topmost pane in the Snd main window,
then adds a dac-hook function to display the current playback volume
in the respective meter.  <b>show-disk-space</b> adds a label in the
minibuffer area which shows the current amount of disk space available
on the partition of the associated sound.
<b>keep-file-dialog-open-upon-ok</b> changes File:Open so that clicking "ok" does not unmanage the dialog.
<b>add-amp-controls</b> adds amp sliders to the control panel
for multi-channel sounds.
<b>add-very-useful-icons</b> adds some very useful icons. (It is now commented out, replaced 
by dlp/new-buttons.scm).
<b>add-rename-option</b> adds a "Rename" option to the File menu; similarly
<b>add-delete-option</b> adds a "Delete" option.
<b>mark-sync-color</b> uses the draw-mark-hook to set the color of sync'd marks.
<b>add-tooltip</b> adds a tooltip (also known as bubble-help) to a widget.  Once added,
set the variable <b>with-tooltips</b> to #f to turn it off.
<b>menu-option</b> returns the widget associated with a given menu item name ("Print" for example).
<b>show-all-atoms</b> displays (via Guile's <i>display</i>) all current X atom names.
<b>make-channel-drop-site</b> shows how to add a drop site panel to a channel.  
<b>set-channel-drop</b> changes the channel's graph's drop function to <i>drop</i>, a 
function of 3 arguments, the dropped filename (a string) and the current sound index and
channel number.
<b>show-font-name</b> shows the Snd-related name and the X-related name of each font in a font list (it searches
for the XA_FULL_NAME associated with an XFontStruct).
<b>show-minibuffer-font</b> uses that function to show what fonts are associated with the minibuffer.
<b>add-find-to-listener</b> activates C-s and C-r in the listener via a separate dialog.
<b>upon-save-yourself</b> causes a thunk (a function of no args) to be called if the window
manager sends a SAVE_YOURSELF message; similarly upon-take-focus causes a thunk to be called
whenever Snd receives focus from the window manager.
</p>

<A NAME="sndtestdoc"></a><span class=box><h2>snd-test.scm and event.scm</h2></span>
<p>
snd-test.scm is a large test suite for Snd. The simplest use is:
</p>
<pre>
snd -l snd-test
</pre>
<p>
which will run all the tests, assuming you have the various sound files it is expecting to find.
event.scm has some XEvent-related functions used by snd-test.scm.  The Ruby version (very incomplete) is
snd_test.rb.
</p>

<A NAME="straddoc"></a><span class=box><h2>strad.scm, strad.rb</h2></span>

<p>strad.scm is a translation (by Michael Scholz) of CLM's strad.ins (by Juan Reyes).
It implements a physical model of a bowed string with stiffness.
</p>

<A NAME="vdoc"></a><span class=box><h2>v.scm</h2></span>

<p>The fm violin was my favorite instrument while working in the 70's and 80's,
primarily on the Samson box.  It was developed in Mus10 (ca 1977) based on ideas of John Chowning;
a Mus10 version was (in this code ":=" is used in place of the original SAIL left arrow character,
and so on):
</p>
<pre>
ARRAY GlissFunc, DecayFunc, AttackFunc, SineWave, AmpFunc(512);
SYNTH(Sinewave); 1,1 999;
SEG(AmpFunc); 0,0 1,25 1,50 0,75 0,100;
SEG(GlissFunc);0,1 1,50, 0,100;
SEG(AttackFunc);0,0 1,100;
SEG(DecayFunc);1,1 .6,5 .3,10 .15,25 .07,50 0,100;
	
INSTRUMENT VN1;
VARIABLE Reset1,Noise,/NewMag,OtherFreq,/Gliss,Distance,Stereo,
	Freq,Amp1,Amp2,Duration,AttackTime,DecayTime,Memory1,
	Index1,Index2,Index3,scFreq,DecayLength,Switch1,Switch2,
	/Mod1,/Mod2,/Mod3,/Env,/Att,/Vibrato,IMult,/Snd,
	/Flutter,VibRate,VibAmp,/Ramp,/Decay,VibSwitch,LogFreq,
	GlissLength,Bowing,DecayCall,VibCall,GlissCall,RampCall;
	
Memory1:=1;
	
I_ONLY BEGIN
  Duration:=P2;
  Freq:=P3;
  Amp1:=P4;
  Amp2:=P5;
  OtherFreq:=P6;
  IF Freq&gt;=C THEN Freq:=Freq+Freq/100;
  IF Freq&lt;C THEN Freq:=Freq-20/Freq;
	
  Switch1:=P14;
  Switch2:=1-Switch1;
  IMult:=P7-(Switch2/4);
  VibSwitch:=P8;
  Bowing:=P9;
	
  Distance:=P10;
  Stereo:=P11;
  Noise:=P12;
  GlissLength:=P13;
  LogFreq:=ALOG(Freq);
  
  DecayCall:=VibCall:=RampCall:=GlissCall:=20;
  IF Amp1=Amp2 THEN RampCall:=SRATE;
  IF Freq=OtherFreq THEN GlissCall:=SRATE;
  IF VibSwitch=0 THEN VibCall:=SRATE;
  IF Switch1=1 THEN DecayCall:=SRATE;
	
  Vibrate:=5.25+RAND*.75;
  VibAmp:=.006+RAND*.001;
	
  IF Bowing=0
    THEN
      IF Memory1&gt;.08
	THEN
	  BEGIN
	  DecayTime:=.7;
	  AttackTime:=.2;
	  END
	ELSE
	  BEGIN
	  DecayTime:=.7;
	  AttackTime:=.05;
	  Noise:=0;
	  END
    ELSE
      IF Memory1&gt;.05
	THEN
	  BEGIN
	  DecayTime:=.05;
	  AttackTime:=.2;
	  END
	ELSE
	  BEGIN
	  DecayTime:=.05;
	  AttackTime:=.05;
	  Noise:=0;
	  END;
	
  Memory1:=DecayTime;
	
  IF AttackTime+DecayTime&gt;=Duration
    THEN
      BEGIN
      AttackTime:=Duration*AttackTime;
      DecayTime:=DecayTime*Duration;
      IF AttackTime&lt;=.05 THEN AttackTime:=Duration-DecayTime-.01;
      END;
	
  ScFreq:=Freq*MAG;
  DecayLength:=1000/Freq;
  IF Switch1=0 THEN Noise:=.1;
  Index1:=7.5*IMult/LogFreq;
  Index2:=5/SQRT(Freq);
  Index3:=IMult*30*(8.5-LogFreq)/Freq;
END;
	
Decay:=Switch1+EXPEN[DecayCall](Switch2,MAG*20/DecayLength,DecayFunc);
ENV:=Switch2+LINEN[20](Switch1,AttackTime/20,DecayTime/20,Duration/20,AmpFunc,Reset1:=0);
Ramp:=Amp1+NOSCIL[RampCall](Amp2-Amp1,20*MAG/Duration,AttackFunc);
Gliss:=Freq+EXPEN[GlissCall](OtherFreq-Freq,20*MAG/GlissLength,GlissFunc);
FLutter:=RANDI[VibCall](1,200*Mag);
Vibrato:=NOSCIL[VibCall](ENV,Vibrate*MAG*20,SineWave);
Att:=1-EXPEN[20](1,MAG*640,AttackFunc);
	
NewMag:=(1+Flutter*.005)*(1+Vibrato*VibAmp)*(1+RANDI(Noise*Att,2000*Mag))*Gliss*Mag;
	
Mod1:=NOSCIL(Decay*ScFreq*(Att+Index1),NewMag,Sinewave);
Mod2:=NOSCIL(Decay*ScFreq*(Att+Index2),4*NewMag,Sinewave);
Mod3:=NOSCIL(Decay*ScFreq*(Att+Index3),3*NewMag,Sinewave);
Snd:=ZOSCIL(Decay*ENV*Ramp,NewMag+Mod1+Mod2+Mod3,Sinewave);
OUTA:=OUTA+Snd*0.5;
END;
</pre>
<p>
This instrument required about 60 seconds of computing on a PDP-10
(a $250,000 minicomputer) for 1 second of sound (our normal sampling
rate was 12800).  Since the PDP was massively time-shared, 60 seconds
of computing could involve many minutes of sitting around watching
AI scientists play Space War.
Mus10 was an extension of Music V for the PDP-10 family of computers.
To give a feel for how one worked in those days, here's a brief quote from the Mus10 manual (by Tovar and
Leland Smith, May 1977):
</p>
<pre>
The following generates  1 second of a  440 Hz sine wave  followed by
1/2 sec. of a  660Hz sine wave. The output goes to a file, MUSIC.MSB,
which is written on DSKM.  

COMMENT Fill array with sine wave;
ARRAY SINETABLE[511];
FOR I:=0 STEP 1 UNTIL 511 DO SINETABLE[I]:=SIN(2*PI/512);

INSTRUMENT SINE;
  COMMENT Generate simple sine wave.  P4 = Amplitude, P3 = frequency;
  OUTA:=OUTA+OSCIL(P4,P3*MAG,SINETABLE);
  END;

COMMENT Now, generate the sound;
PLAY ;
  SIMP 0, 1, 440, 1000;
  SIMP 1, 1/2, 660, 1000;
  FINISH;
</pre>
<p>
The computation involved was considered so burdensome, that the names of
the main users were posted in the AI lab halls, apparently to try to
get us to go away.  I was normally the primary user (in terms of computrons) for the entire lab, and I had no intention
of going away.  
In the Samson box world, this (in its initial "chorus" version) was:</p>
<pre>
Instrument(Violin);
RECORD_POINTER(seg) nullfunc;
INTEGER ARRAY gens[1:4],indgens[1:6], GensA[1:4],AmpGens[1:2];
					! synthesizer addresses;
REAL ARRAY ratsA[1:4],Indrats[1:6],ratsB[1:4],AmpRats[1:2];
					! envelope data;
INTEGER ModGens1Sum,i,FuncOffSet,k,GenOutLoc,GenInLoc,ModGens2Sum,x1,x2;

Pars(&lt;(InsName,Beg,Dur,Freq,Amp,Function AmpFunc,Function IndFunc,IndMult,
	SkewMult,Nothing,PcRev,No11,No12,No13,Function SkewFunc)&gt;);
					! the parameters of this instrument;

Dbugit(Pns);				! debugging aid;
GenOutLoc:=CASE (Pn[1] MOD 4) OF (Outma,Outmb,Outmc,Outmd);
					! OUTMA is channel 1, OUTMB channel 2, etc;
if freq&gt;srate/3 then return;		! note too high, so leave it out;
x1:=3;					! modulating frequency checks;
x2:=4;					! (we want them less than srate/2);
If x1*freq&gt;srate/2 Then x1:=1;
If x2*freq&gt;srate/2 then x2:=1;
amp:=Amp/2;				! two carriers, so halve the amplitude;

waiter(Beg);				! wait for the beginning of the note;

indRats[1]:=(x1*Freq*IndMult*((8.5-log(freq))/(3+(freq/1000)))*4/srate) MIN .999;
indRats[2]:=(x2*Freq*IndMult*(1/(freq^.5))*4/srate) MIN .999;
indRats[3]:=(freq*IndMult*(5/log(freq))*4/srate) MIN .999;
indrats[4]:=indrats[1]; indrats[5]:=indrats[2]; indrats[6]:=indrats[3];

ratsA[1]:=x1; ratsA[2]:=x2;     ratsA[3]:=1;     ratsA[4]:=1;	
ratsB[1]:=x1+.002; ratsB[2]:=x2+.003;     ratsB[3]:=1.002;     ratsB[4]:=1;	
					! this is the skewing for the chorus effect;
Gens[1]:=Osc(Pns,ModGens1Sum);		! now set up the oscillators;
Gens[2]:=Osc(Pns,ModGens1Sum);
Gens[3]:=Osc(Pns,ModGens1Sum);
Gens[4]:=Osc(Pns,genInLoc,ModGens1Sum);	! carrier 1;

GensA[1]:=Osc(Pns,ModGens2Sum);
GensA[2]:=Osc(Pns,ModGens2Sum);
GensA[3]:=Osc(Pns,ModGens2Sum);
GensA[4]:=Osc(Pns,genInLoc,ModGens2Sum);! carrier 2;

indgens[1]:=gens[1];   indgens[2]:=gens[2];  indgens[3]:=gens[3];
indgens[4]:=gensA[1];   indgens[5]:=gensA[2];  indgens[6]:=gensA[3];
					! set up envelope addressing;

ModSig(Pns,GenOutLoc,GenInLoc,1-pcRev);	! send signal to DACs;
ModSig(Pns,RevIn,GenInLoc,pcRev);	! and signal to reverberator;

AmpGens[1]:=Gens[4]; AmpGens[2]:=GensA[4]; AmpRats[1]:=1; AmpRats[2]:=1;
					! now add the envelopes;
AddArrEnv(Pns,AmpGens,2,"A",0,Amp/2,AmpFunc,AmpRats);
AddArrEnv(Pns,IndGens,6,"A",0,1,IndFunc,Indrats);
AddArrEnv(Pns,Gens,4,"F",freq,Freq*skewmult,skewfunc,ratsA,
	5,.011,.011,nullfunc,6,.017,.017,nullfunc,0,0);
AddArrEnv(Pns,GensA,4,"F",freq,Freq*skewmult,skewfunc,ratsA,
	6,.010,.010,nullfunc,5,.017,.017,nullfunc,1,0);
End!Instrument(Pns);			! deallocation;
</pre>
<p>
The Sambox version eventually became incredibly complicated, mainly to
try to handle note list problems in the instrument.  The Samson box could
run about 5 or 6 of these in "real-time", similar to a modern-day
500 MHz Pentium running CLM.
The parallel in the Sambox world to the SIMP example above is (this is
taken from SAMBOX.BIL, November 1984):</p>
<pre>
    Instrument(Simp);
    Integer Gen1;
    Gen1:=Osc(Pns,OutA,Zero,SineMode,0,0,Pn[3]);
    AddEnv(Pns,Gen1,"A",0,Pn[4],Pf[5]);
    End_Instrument(Pns);
</pre>
<p>The CLM version of this is:</p>
<pre>
(definstrument simp (start-time duration frequency amplitude
                      &amp;optional (amp-env '(0 0 50 1 100 0)))
  (multiple-value-bind (beg end) (times-&gt;samples start-time duration)
    (let ((s (make-oscil frequency))
          (amp (make-env amp-env :scaler amplitude :duration duration)))
      (run
       (loop for i from beg below end do
         (outa i (* (env amp) (oscil s))))))))
</pre>
<p>
In CLM, the fm-violin became (fm.html, 1989):</p>
<pre>
(definstrument violin (beg end frequency amplitude fm-index)
  (let* ((frq-scl (in-hz frequency))
         (maxdev (* frq-scl fm-index))
         (index1 (* maxdev (/ 5.0 (log frequency))))
         (index2 (* maxdev 3.0 (/ (- 8.5 (log frequency)) (+ 3.0 (/ frequency 1000)))))
         (index3 (* maxdev (/ 4.0 (sqrt frequency))))
         (carrier (make-oscil frequency))
         (fmosc1 (make-oscil frequency))
         (fmosc2 (make-oscil (* 3 frequency)))
         (fmosc3 (make-oscil (* 4 frequency)))
         (ampf  (make-env '(0 0 25 1 75 1 100 0) :scaler amplitude))
         (indf1 (make-env '(0 1 25 .4 75 .6 100 0) :scaler index1))
         (indf2 (make-env '(0 1 25 .4 75 .6 100 0) :scaler index2))
         (indf3 (make-env '(0 1 25 .4 75 .6 100 0) :scaler index3))
         (pervib (make-triangle-wave :frequency 5 :amplitude (* .0025 frq-scl)))
         (ranvib (make-randi :frequency 16 :amplitude (* .005 frq-scl)))
         (vib 0.0))
    (run
     (loop for i from beg to end do
       (setf vib (+ (triangle-wave pervib) (randi ranvib)))
       (outa i (* (env ampf)
                  (oscil carrier
                         (+ vib 
                            (* (env indf1) (oscil fmosc1 vib))
                            (* (env indf2) (oscil fmosc2 (* 3.0 vib)))
                            (* (env indf3) (oscil fmosc3 (* 4.0 vib))))))))))))
</pre>
<p>or in its actual (non-simplified) form):
</p>
<pre>
(defun bit20 (x)			;Samson box modifier got 2's complement 20 bit interpreted as fraction 
  (if (&gt;= x (expt 2 19))                ;(this needed to keep fm-violin backwards compatible with old note lists)
      (float (/ (- x (expt 2 20)) (expt 2 19)))
    (float (/ x (expt 2 19)))))

(defun make-frobber-function (beg end frobl)
  (let ((result (list beg))
	(val (bit20 (cadr frobl))))
    (loop for x in frobl by #'cddr and 
              y in (cdr frobl) by #'cddr do
      (when (and (&gt;= x beg)
		 (&lt;= x end))
	(push val result)
	(push x result)
	(setf val (bit20 y))))
    (push val result)
    (push end result)
    (push val result)
    (nreverse result)))

(definstrument fm-violin 
  (startime dur frequency amplitude &amp;key
	    (fm-index 1.0)
	    (amp-env '(0 0  25 1  75 1  100 0))
	    (periodic-vibrato-rate 5.0) 
            (random-vibrato-rate 16.0)
	    (periodic-vibrato-amplitude 0.0025) 
            (random-vibrato-amplitude 0.005)
	    (noise-amount 0.0) (noise-freq 1000.0)
	    (ind-noise-freq 10.0) (ind-noise-amount 0.0)
	    (amp-noise-freq 20.0) (amp-noise-amount 0.0)
	    (gliss-env '(0 0  100 0)) (glissando-amount 0.0) 
	    (fm1-env '(0 1  25 .4  75 .6  100 0)) 
            (fm2-env '(0 1  25 .4  75 .6  100 0)) 
            (fm3-env '(0 1  25 .4  75 .6  100 0))
	    (fm1-rat 1.0) (fm2-rat 3.0)	 (fm3-rat 4.0)                    
	    (fm1-index nil) (fm2-index nil) (fm3-index nil)
	    (base nil) (frobber nil)
	    (reverb-amount 0.01)
	    (index-type :violin)
	    (degree nil) (distance 1.0) (degrees nil)
	    (no-waveshaping nil) (denoise nil)
	    (denoise-dur .1) (denoise-amp .005)
	    &amp;allow-other-keys)
  (if (&gt; (abs amplitude) 1.0) 
      (setf amplitude (clm-cerror ".1?" .1 #'numberp "amplitude = ~A?" amplitude)))
  (if (&lt;= (abs frequency) 1.0) 
      (setf frequency (clm-cerror "440.0?" 440.0 #'numberp "frequency = ~A?" frequency)))
  (let* ((beg (floor (* startime *srate*)))
	 (end (+ beg (floor (* dur *srate*))))
	 (frq-scl (hz-&gt;radians frequency))
	 (modulate (not (zerop fm-index)))
	 (maxdev (* frq-scl fm-index))
	 (vln (not (eq index-type :cello)))
	 (logfreq (log frequency))
	 (sqrtfreq (sqrt frequency))
	 (index1 (or fm1-index (min pi (* maxdev (/ (if vln 5.0 7.5) logfreq)))))
	 (index2 (or fm2-index (min pi (* maxdev 3.0 (if vln 
							     (/ (- 8.5 logfreq) (+ 3.0 (* frequency .001)))
							   (/ 15.0 sqrtfreq))))))
	 (index3 (or fm3-index (min pi (* maxdev (/ (if vln 4.0 8.0) sqrtfreq)))))

	 (easy-case (and (not no-waveshaping)
			 (zerop noise-amount)
			 (eq fm1-env fm2-env)
			 (eq fm1-env fm3-env)
			 (zerop (- fm1-rat (floor fm1-rat)))
			 (zerop (- fm2-rat (floor fm2-rat)))
			 (zerop (- fm3-rat (floor fm3-rat)))
			 (zerop (nth-value 1 (floor fm2-rat fm1-rat)))
			 (zerop (nth-value 1 (floor fm3-rat fm1-rat)))))
	 (coeffs (and easy-case modulate
	 	      (partials-&gt;polynomial
	 	       (list fm1-rat index1
	 		     (floor fm2-rat fm1-rat) index2
	 		     (floor fm3-rat fm1-rat) index3))))
	 ;; that is, we're doing the polynomial evaluation using fm1osc running at fm1-rat * frequency
	 ;; so everything in the polynomial table should be in terms of harmonics of fm1-rat
	 
	 (norm (or (and easy-case modulate 1.0) index1))
	 
	 (carrier (make-oscil frequency))
	 (fmosc1  (and modulate (make-oscil (* fm1-rat frequency))))
	 (fmosc2  (and modulate (or easy-case (make-oscil (* fm2-rat frequency)))))
	 (fmosc3  (and modulate (or easy-case (make-oscil (* fm3-rat frequency)))))
	 (ampf  (make-env 
                  (if denoise
                       (reduce-amplitude-quantization-noise amp-env dur amplitude denoise-dur denoise-amp) 
                     amp-env)
	          amplitude :base base :duration dur))
	 (indf1 (and modulate (make-env fm1-env norm :duration dur)))
	 (indf2 (and modulate (or easy-case (make-env fm2-env index2 :duration dur))))
	 (indf3 (and modulate (or easy-case (make-env fm3-env index3 :duration dur))))
	 (frqf (make-env gliss-env (* glissando-amount frq-scl) :duration dur))
	 (pervib (make-triangle-wave periodic-vibrato-rate (* periodic-vibrato-amplitude frq-scl)))
	 (ranvib (make-rand-interp random-vibrato-rate (* random-vibrato-amplitude frq-scl)))
	 (fm-noi (if (and (/= 0.0 noise-amount)
			  (null frobber))
		     (make-rand noise-freq (* pi noise-amount))))
	 (ind-noi (if (and (/= 0.0 ind-noise-amount) (/= 0.0 ind-noise-freq))
		      (make-rand-interp ind-noise-freq ind-noise-amount)))
	 (amp-noi (if (and (/= 0.0 amp-noise-amount) (/= 0.0 amp-noise-freq))
		      (make-rand-interp amp-noise-freq amp-noise-amount)))
	 (frb-env (if (and (/= 0.0 noise-amount) frobber)
		      (make-env (make-frobber-function startime (+ startime dur) frobber) :duration dur
				:base 0	:scaler (* two-pi noise-amount))))
	 (vib 0.0) 
	 (modulation 0.0)
	 (loc (make-locsig :degree (or degree degrees (random 90.0)) :reverb reverb-amount :distance distance))
	 (fuzz 0.0)
	 (ind-fuzz 1.0)
	 (amp-fuzz 1.0))
    (run
     (loop for i from beg to end do
       (if (/= 0.0 noise-amount)
	   (if (null frobber)
	       (setf fuzz (rand fm-noi))
	     (setf fuzz (env frb-env))))
       (setf vib (+ (env frqf) (triangle-wave pervib) (rand-interp ranvib)))
       (if ind-noi (setf ind-fuzz (+ 1.0 (rand-interp ind-noi))))
       (if amp-noi (setf amp-fuzz (+ 1.0 (rand-interp amp-noi))))
       (if modulate
	   (if easy-case
	       (setf modulation
		 (* (env indf1) 
		    (polynomial coeffs (oscil fmosc1 vib)))) ;(* vib fm1-rat)??
	     (setf modulation
	       (+ (* (env indf1) (oscil fmosc1 (+ (* fm1-rat vib) fuzz)))
		  (* (env indf2) (oscil fmosc2 (+ (* fm2-rat vib) fuzz)))
		  (* (env indf3) (oscil fmosc3 (+ (* fm3-rat vib) fuzz)))))))
       (locsig loc i
	     (* (env ampf) amp-fuzz
		(oscil carrier (+ vib (* ind-fuzz modulation)))))))))
</pre>
<p>which is very similar to the Scheme version (v.scm).
It's basically setting up several parallel modulators of one carrier (see <a href="fm.html">fm.html</a>
for details, or (ah nostalgia...) 
Schottstaedt,  "The Simulation of Natural Instrument Tones Using Frequency Modulation with a Complex Modulating Wave", CMJ vol 1 no 4 1977 p46-50). 
The modulators
themselves are modulated (vibrato, noise, etc). The FM indices were chosen to try
to mimic violin or cello sounds over a wide range of frequencies.
There's no limit on what this instrument can do; nearly all my compositions in the 80's used
it.  In CLM, there's fmviolin.clm which shows some of the effects (although it's unfortunately
hard to read due to the way the Sambox system worked).
And I just found this out on the net; I'm no csound expert, so I merely quote what I find:
</p>
<pre>
;ORC
; edited by R. Pinkston, modified for use with MIDI2CS by R. Borrmann
;
;==========================================================================;
;                Schottstaedt FM String Instrument from Dodge              ;
;                                                                          ;
;p4 = amp p5 = pch p6 = rise p7 = dec p8 = vibdel p9 = vibwth p10 = vibrte ;
;==========================================================================;
;        sr      =       44100
;        kr      =       4410
;        ksmps   =       10
;        nchnls  =       1
;
;                instr   1

par
  p_maxamplitude 32000
  p_cps
endpar

        iamp    =       p4

        irise   = .2    ;p6
        idec    = .2    ;p7
        ivibdel = .75   ;p8
        ivibwth = .03   ;p9
        ivibrte = 5.5   ;p10

        ifc     =       p5
        ifm1    =       ifc
        ifm2    =       ifc*3
        ifm3    =       ifc*4
        indx1   =       7.5/log(ifc)    ;range from ca 2 to 1
        indx2   =       15/sqrt(ifc)    ;range from ca 2.6 to .5
        indx3   =       1.25/sqrt(ifc)  ;range from ca .2 to .038
        kvib    init    0 

                timout  0,ivibdel,transient  ;delays vibrato for p8 seconds
        kvbctl  linen   1,.5,p3-ivibdel,.1   ;vibrato control envelope
        krnd    randi   .0075,15        ;random deviation in vib width 
        kvib    oscili  kvbctl*ivibwth+krnd,ivibrte*kvbctl,1 ;vibrato generator
               
transient:
        timout  .2,p3,continue          ;execute for .2 secs only
        ktrans  linseg  1,.2,0,1,0      ;transient envelope 
        anoise  randi   ktrans,.2*ifc   ;noise... 
        attack  oscil   anoise,2000,1   ;...centered around 2kHz

continue: 
        amod1   oscili  ifm1*(indx1+ktrans),ifm1,1
        amod2   oscili  ifm2*(indx2+ktrans),ifm2,1
        amod3   oscili  ifm3*(indx3+ktrans),ifm3,1
        asig    oscili  iamp,(ifc+amod1+amod2+amod3)*(1+kvib),1
        asig    linen   asig+attack,irise,p3,idec
;                out     asig
; 
;                endin
        aright  = asig
        aleft   = asig
</pre>
<p>There's a C/CLM version of this instrument in sndlib.html.  The body of the fm-violin
in C/CLM is:
</p>
<pre>
      if (noise_amount != 0.0) fuzz = mus_rand(fmnoi,0.0);
      if (frqf) vib = mus_env(frqf); else vib = 0.0;
      vib += mus_triangle_wave(pervib, 0.0) + 
             mus_rand_interp(ranvib, 0.0);
      if (easy_case)
        modulation = mus_env(indf1) * 
                     mus_polynomial(coeffs, mus_oscil(fmosc1, vib, 0.0), npartials);
      else
        modulation = mus_env(indf1) * mus_oscil(fmosc1, (fuzz + fm1_rat * vib), 0.0) +
                     mus_env(indf2) * mus_oscil(fmosc2, (fuzz + fm2_rat * vib), 0.0) +
                     mus_env(indf3) * mus_oscil(fmosc3, (fuzz + fm3_rat * vib), 0.0);
      mus_locsig(loc, i, mus_env(ampf) *
                         mus_oscil(carrier, vib + indfuzz * modulation, 0.0));
</pre>

<p>And here is the Ruby version, written by Michael Scholz (see examp.rb):</p>
<pre>
#
# fm_violin([start=0.0[, dur=1.0[, freq=440.0[, amp=0.3[, *args]]]]])
#

def fm_violin(start = 0.0, dur = 1.0, freq = 440.0, amp = 0.3, *args)
  include Math;			# PI

  usage = "fm_violin([start=0.0[, dur=1.0[, freq=440.0[, amp=0.3[, *args]]]]])

	[:fm_index, 1.0]
	[:amp_env, [0, 0, 25, 1, 75, 1, 100, 0]]
	[:periodic_vibrato_rate, 5.0]
	[:random_vibrato_rate, 16.0]
	[:periodic_vibrato_amp, 0.0025]
	[:random_vibrato_amp, 0.005]
	[:noise_amount, 0.0]
	[:noise_freq, 1000.0]
	[:ind_noise_freq, 10.0]
	[:ind_noise_amount, 0.0]
	[:amp_noise_freq, 20.0]
	[:amp_noise_amount, 0.0]
	[:gliss_env, [0, 0,  100, 0]]
	[:gliss_amount, 0.0]
	[:fm1_env, [0, 1, 25, 0.4, 75, 0.6, 100, 0]]
	[:fm2_env, [0, 1, 25, 0.4, 75, 0.6, 100, 0]]
	[:fm3_env, [0, 1, 25, 0.4, 75, 0.6, 100, 0]]
	[:fm1_rat, 1.0]
	[:fm2_rat, 3.0]
	[:fm3_rat, 4.0]
	[:fm1_index, false]
	[:fm2_index, false]
	[:fm3_index, false]
	[:base, 1.0]
	[:reverb_amount, 0.01]
	[:index_type, :violin]
	[:degree, false]
	[:distance, 1.0]
	[:degrees, false]

  Ruby: fm_violin(0, 1, 440, .1, [[:fm_index, 2.0]])
 Guile: (fm-violin 0 1 440 .1 :fm-index 2.0)\n\n";

  fm_index = (args.assoc(:fm_index)[1] rescue 1.0);
  amp_env = (args.assoc(:amp_env)[1] rescue [0, 0, 25, 1, 75, 1, 100, 0]);
  periodic_vibrato_rate = (args.assoc(:periodic_vibrato_rate)[1] rescue 5.0);
  random_vibrato_rate = (args.assoc(:random_vibrato_rate)[1] rescue 16.0);
  periodic_vibrato_amp = (args.assoc(:periodic_vibrato_amp)[1] rescue 0.0025);
  random_vibrato_amp = (args.assoc(:random_vibrato_amp)[1] rescue 0.005);
  noise_amount = (args.assoc(:noise_amount)[1] rescue 0.0);
  noise_freq = (args.assoc(:noise_freq)[1] rescue 1000.0);
  ind_noise_freq = (args.assoc(:ind_noise_freq)[1] rescue 10.0);
  ind_noise_amount = (args.assoc(:ind_noise_amount)[1] rescue 0.0);
  amp_noise_freq = (args.assoc(:amp_noise_freq)[1] rescue 20.0);
  amp_noise_amount = (args.assoc(:amp_noise_amount)[1] rescue 0.0);
  gliss_env = (args.assoc(:gliss_env)[1] rescue [0, 0,  100, 0]);
  gliss_amount = (args.assoc(:gliss_amount)[1] rescue 0.0);
  fm1_env = (args.assoc(:fm1_env)[1] rescue [0, 1, 25, 0.4, 75, 0.6, 100, 0]);
  fm2_env = (args.assoc(:fm2_env)[1] rescue [0, 1, 25, 0.4, 75, 0.6, 100, 0]);
  fm3_env = (args.assoc(:fm3_env)[1] rescue [0, 1, 25, 0.4, 75, 0.6, 100, 0]);
  fm1_rat = (args.assoc(:fm1_rat)[1] rescue 1.0);
  fm2_rat = (args.assoc(:fm2_rat)[1] rescue 3.0);
  fm3_rat = (args.assoc(:fm3_rat)[1] rescue 4.0);
  fm1_index = (args.assoc(:fm1_index)[1] rescue false);
  fm2_index = (args.assoc(:fm2_index)[1] rescue false);
  fm3_index = (args.assoc(:fm3_index)[1] rescue false);
  base = (args.assoc(:base)[1] rescue 1.0);
  reverb_amount = (args.assoc(:reverb_amount)[1] rescue 0.01);
  index_type = (args.assoc(:index_type)[1] rescue :violin);
  degree = (args.assoc(:degree)[1] rescue false);
  distance = (args.assoc(:distance)[1] rescue 1.0);
  degrees = (args.assoc(:degrees)[1] rescue false);

  srate = (srate() rescue $rbm_srate);
  chans = (channels() rescue $rbm_channels);
  beg = (srate * start).round;
  len = (srate * dur).round;
  frq_scl = hz2radians(freq);
  modulate = fm_index.nonzero?;
  maxdev = frq_scl * fm_index;
  vln = (not (index_type == :cello))
  logfreq = log(freq);
  sqrtfreq = sqrt(freq);
  index1 = (fm1_index or [PI, maxdev * (vln ? 5.0 : 7.5) / logfreq].min);
  index2 = (fm2_index or [PI, maxdev * 3.0 * 
	      (vln ? ((8.5 - logfreq) / (3.0 + freq * 0.001)) : (15.0 / sqrtfreq))].min);
  index3 = (fm3_index or [PI, maxdev * (vln ? 4.0 : 8.0) / sqrtfreq].min);
  easy_case = (noise_amount.zero? and
	       (fm1_env == fm2_env) and 
	       (fm1_env == fm3_env) and 
	       (fm1_rat - fm1_rat.floor).zero? and 
	       (fm2_rat - fm2_rat.floor).zero? and 
	       (fm3_rat - fm3_rat.floor).zero?);
  coeffs = (easy_case and modulate and 
	    partials2polynomial([fm1_rat, index1, 
				  (fm2_rat / fm1_rat).floor, index2,
				  (fm3_rat / fm1_rat).floor, index3]));
  norm = ((easy_case and modulate and 1.0) or index1);
  carrier = make_oscil(freq);
  fmosc1 = (modulate and make_oscil(fm1_rat * freq));
  fmosc2 = (modulate and (easy_case or make_oscil(fm2_rat * freq)));
  fmosc3 = (modulate and (easy_case or make_oscil(fm3_rat * freq)));
  ampf = make_env(amp_env, amp, dur, 0.0, base);
  indf1 = (modulate and make_env(fm1_env, norm, dur));
  indf2 = (modulate and (easy_case or make_env(fm2_env, index2, dur)));
  indf3 = (modulate and (easy_case or make_env(fm3_env, index3, dur)));
  frqf = make_env(gliss_env, gliss_amount * frq_scl, dur);
  pervib = make_triangle_wave(periodic_vibrato_rate, periodic_vibrato_amp *  frq_scl);
  ranvib = make_rand_interp(random_vibrato_rate, random_vibrato_amp * frq_scl);
  fm_noi = (noise_amount.nonzero? and make_rand(noise_freq, PI * noise_amount));
  ind_noi = ((ind_noise_amount.nonzero? and ind_noise_freq.nonzero?) and 
	     make_rand_interp(ind_noise_freq, ind_noise_amount));
  amp_noi = ((amp_noise_amount.nonzero? and amp_noise_freq.nonzero?) and
	     make_rand_interp(amp_noise_freq, amp_noise_amount));
  vib = 0.0;
  modulation = 0.0;
  # make_locsig(degree=0.0, distance=1.0, reverb=0.0, output, revout, chans=1, type=Mus_linear)
  # Ruby's rand() is shadowed by CLM's rand(), that's why mus_random().abs.
  loc = make_locsig((degree or degrees or mus_random(90.0).abs), 
		    distance, reverb_amount, false, false, chans);
  fuzz = 0.0;
  ind_fuzz = 1.0;
  amp_fuzz = 1.0;
  out_data = make_vct(len);

  vct_map!(out_data,
	   lambda { | |
	     fuzz = rand(fm_noi) if noise_amount.nonzero?;
	     vib = env(frqf) + triangle_wave(pervib) + rand_interp(ranvib);
	     ind_fuzz = 1.0 + rand_interp(ind_noi) if ind_noi;
	     amp_fuzz = 1.0 + rand_interp(amp_noi) if amp_noi;

	     if(modulate)
	       if(easy_case)
		 modulation = env(indf1) * polynomial(coeffs, oscil(fmosc1, vib));
	       else
		 modulation = env(indf1) * oscil(fmosc1, fm1_rat * vib + fuzz) +
		   env(indf2) * oscil(fmosc2, fm2_rat * vib + fuzz) +
		   env(indf3) * oscil(fmosc3, fm3_rat * vib + fuzz);
	       end
	     end

	     env(ampf) * amp_fuzz * oscil(carrier, vib + ind_fuzz * modulation);
	   });

  if(chans == 2)
    mix_vct(vct_scale!(vct_copy(out_data), locsig_ref(loc, 1)), beg, $rbm_snd, 1, false);
    mix_vct(vct_scale!(out_data, locsig_ref(loc, 0)), beg, $rbm_snd, 0, false);
  else
    mix_vct(out_data, beg, $rbm_snd, 0, false);
  end
rescue
  die(usage + "fm_violin()");
end

</pre>
<br>

<A NAME="wsdoc"></a><span class=box><h2>ws.scm</h2></span>
<p>
<i>with-sound</i> is the primary sound producing macro in CLM (in a sense, it is CLM's user-interface).
In Common Lisp it's defined as:</p>
<pre>
 (defmacro with-sound ((&amp;key (srate 22050) ...) &amp;body body) 
   (unwind-protect
     (let (...) ,.body)
     (progn (cleanup...))))
</pre>
<p>and makes extensive use of Lisp's dynamic binding to handle nested with-sound calls and so on.
Kalle Olavi Niemitalo came up with this Scheme/Guile replacement:
</p>
<pre>
(define* (with-sound-helper thunk #&amp;key (srate 22050) (explode #f))
  (let ((old-srate (mus-srate)))
    (dynamic-wind 
      (lambda () 
        (set! (mus-srate) srate))
      thunk
      (lambda () 
        (set! (mus-srate) old-srate)))))

(defmacro with-sound (args . body)
  `(with-sound-helper (lambda () ,@body)
                      ,@args))
</pre>
<p>
The version in ws.scm is simply an amplification of this code.
The global variables that parallel CLM's *clm-...* are:
</p>
<pre>
  <em class=def><A NAME="wssndsrate">*srate*</a></em> (default-output-srate)
  <em class=def><A NAME="wssndfilename">*file-name*</a></em> "test.snd"
  <em class=def><A NAME="wssndchannels">*channels*</a></em> (default-output-chans)
  <em class=def><A NAME="wssnddataformat">*data-format*</a></em> (default-output-format)
  <em class=def><A NAME="wssndheadertype">*header-type*</a></em> (default-output-type)

  <em class=def><A NAME="wswithsound">with-sound</a></em>
    #:key (srate *srate*) 
          (output *file-name*)   ; default="test.snd"
	  (channels *channels*)
	  (header-type *header-type*)
	  (data-format *data-format*)
	  (comment #f)
	  (continue-old-file #f)
	  (play #f)
  	  (reverb #f)
  	  (revfile "test.rev")
	  (statistics #f)
	  (scaled-to #f)
	  (scaled-by #f))
</pre>
<p>As far as possible, this parallels CLM's <a href="clm.html#with-sound">with-sound</a>.</p>
<pre>
  (with-sound (:srate 44100) (fm-violin 0 1 440 .1))
</pre>
<p>
<b>with-sound</b> opens its output file (<i>output</i> above)
via make-sample-&gt;file, setting the global variable *output*.  This
is equivalent to CLM's *output* variable, and can be used the same
way in outa or locsig.  If <i>reverb</i> is specified, *reverb* is also
opened (corresponding to CLM's *reverb*).  So the cooperating instrument code should be:
</p>
<pre>
(define (ins args)
  (let ...
    (run
      (lambda ()
        (do ((i start (1+ i)))
            ((= i end))
          (outa i ... *output*))))))
</pre>
<p>which is the same as in the standard CLM (change the loop statement to a do statement,
add the lambda wrapper (needed by the run macro unfortunately),
and you're ready to go!  If the run macro can handle the instrument code (and
it can handle anything the CL version can handle, I think), then the Snd with-sound
should run within a factor of two of the fastest CL-based CLM, even though the
latter is going through the C intermediate file!  
</p>
<p>To continue adding notes to an existing file, set <i>continue-old-file</i>:
</p>
<pre>
(with-sound (:continue-old-file #t) (fm-violin 0 1 440 .1))
</pre>
<p>with-sound returns the output file name.</p>
<p>ws.scm also has a scheme version of <a href="clm.html#def-clm-struct">def-clm-struct</a>
and <a href="clm.html#sound-let">sound-let</a>.  with-sounds and sound-lets can be nested --
see clm.html for examples.
<b>def-clm-struct</b> in Snd/Guile provides a way to package up heterogenous data 
for user-defined generators.  In pure-Scheme it just sets up functions to make
and access such a list, but in Snd's run macro, it also provides type declarations.
For example,
</p>
<pre>
(def-clm-struct hiho i x (s "hiho") (ii 3 :type int) (xx 0.0 :type float))
</pre>
<p>defines a structure type ("hiho") with 5 fields.  "hiho-s" defaults to the
string "hiho", "hiho-ii" defaults to 3, and declares that its type will always
be int (so it can be used without restriction in run), and so on.
</p>
<pre>
(define hi (make-hiho :xx 3.14))
</pre>
<p>defines a variable named hi whose value is a hiho structure (a list) with
all the fields taking their default value except "xx" which is set to 3.14.
So, hi's value is <code>(list 'hiho #f #f "hiho" 3 3.14))</code>.
</p>
<p><b><a name="initwithsound">init-with-sound</a></b> and <b><a name="finishwithsound">finish-with-sound</a></b>
split with-sound into two pieces, primarily for Common Music's benefit.
</p>
<pre>
(define w (init-with-sound :scaled-to .5))
(fm-violin 0 1 440 .1)
(finish-with-sound w)
</pre>
<p>is equivalent to 
</p>
<pre>
(with-sound (:scaled-to .5)
  (fm-violin 0 1 440 .1))
</pre>
<br>

<A NAME="xmenveddoc"></a><span class=box><h2>xm-enved.scm, xm-enved.rb</h2></span>
<pre>
  <em class=def><A NAME="xecreateenved">xe-create-enved</a></em> name parent args axis
  <em class=def><A NAME="xeenvelope">xe-envelope</a></em> xe-editor
</pre>
<p>This file implements an envelope editor using the xm module.  <b>xe-create-enved</b>
returns a new envelope editor whose X axis label is <i>name</i>, the X and Y axis bounds
are in the list <i>axis</i>, the editor's parent widget is <i>parent</i>,  and the Xt-style
resource argument list is <i>args</i>.  The editor's current envelope is accessible
(read and write) via <i>xe-envelope</i>.  For example,
</p>
<pre>
(define outer (add-main-pane "hiho" xmFormWidgetClass '()))
(define editor (xe-create-enved "a name" outer 
			     (list XmNleftAttachment   XmATTACH_FORM
				   XmNtopAttachment    XmATTACH_FORM
				   XmNbottomAttachment XmATTACH_FORM
				   XmNrightAttachment  XmATTACH_FORM)
			     '(0.0 1.0 0.0 1.0)))))
(set! (xe-envelope editor) (list 0.0 1.0 1.0 0.5))
</pre>


<A NAME="zipdoc"></a><span class=box><h2>zip.scm</h2></span>
<pre>
  <em class=def><a name="makezipper">make-zipper</a></em> ramp-env <i>frame-size frame-env</i>
  <em class=def><a name="zipper">zipper</a></em> gen in1 in2
  <em class=def><a name="zipsound">zip-sound</a></em> beg dur file1 file2 <i>ramp size</i>
</pre>
<p>The zipper generator performs a kind of cross fade, but not one that
tries to be smooth!  It marches through the two sounds taking equal short
portions of each, then abutting them while resampling so that as one
takes less overall frame space, the other takes more.  The <i>frame-size</i>
argument is the maximum length of each twosome in seconds (for initial array allocation), the <i>frame-env</i>
argument determines the current such length as new frames are needed, and the
<i>ramp-env</i> argument determines which of the files gets more space
in the frame (0: all first, 1: all second).
For example, the following function sets up two sounds,
an upward ramp and a downward ramp, then zips them together:
</p>
<pre>
(define (ramp-test)
  (let ((data (make-vct 10000)))
    (new-sound "new-0.snd")
    (do ((i 0 (1+ i))) ((= i 10000)) 
      (vct-set! data i (* i .0001)))
    (vct-&gt;samples 0 10000 data 0)
    (new-sound "new-1.snd")
    (do ((i 0 (1+ i))) ((= i 10000)) 
      (vct-set! data i (- 1.0 (* i .0001))))
    (vct-&gt;samples 0 10000 data 1)
    (let* ((dur (frames))
	   (zp (<em class=red>make-zipper</em> (let ((e (make-env '(0 0 1 1) :end dur)))
			      (lambda () (env e)))))
	  (reader0 (make-sample-reader 0 0 0))
	  (reader1 (make-sample-reader 0 1 0)))
      (map-chan (lambda (val) (<em class=red>zipper</em> zp reader0 reader1))))))
</pre>
<center><img src="zramp.png" alt="zipper ramp output"></center>
<p>Needless to say, this is not intended to be a suave, romantic gesture!
</p>
<br>

<span class=box><h2><A NAME="extsndvarexpl">A Note on Scheme variables in Snd</a></h2></span>

<p>At first glance, Snd's use of functions for nearly all variable accesses, i.e. <code>(listener-prompt)</code>
rather than the simpler <code>listener-prompt</code>, seems unmotivated.  For example, the following little
program defines "counter" as a scheme variable, accessible in C:
</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;guile/gh.h&gt;

void inner_main(void *closure, int argc, char **argv)
{
  SCM counter;
  int size = 512;
  char **buffer = NULL;
  buffer = (char **)calloc(1, sizeof(char *));
  buffer[0] = (char *)calloc(size, sizeof(char));
  counter = scm_permanent_object(scm_c_define("counter", scm_long2num(0)));
  while (1)
    {
      getline(buffer, &amp;size, stdin);
      scm_eval_str0(buffer[0]);
      fprintf(stdout, "counter is %d\n", scm_num2int(SCM_VARIABLE_REF(counter), 0, "main"));
    }
}

int main(int argc, char *argv[])
{
  scm_boot_guile(argc, argv, inner_main, 0);
  return(0);
}
</pre>
<p>Now we compile and load it (in Linux: cc g.c -o g -lguile), and it sits in a loop
reading a line at a time, evaluating it, and printing the current value of
our counter:
</p>
<pre>
/home/bil/cl/ g
(+ 1 2)
counter is 0
(set! counter 123)
counter is 123
(set! counter (* counter 2))
counter is 246
</pre>
<p>But the C code itself doesn't see the set!, and there's no way to
tell set! in Guile to call an auxiliary function when (for example) our counter
is set.  We need to see that set! as soon as it happens to make the user interface
responsive.  <code>(set! basic-color red)</code> would have no effect unless
our C code could be informed that the <code>basic-color</code> variable's value had changed.
In addition, in Snd, there are perhaps several hundred such variables, and
our C code will run faster if we access C variables as much as possible, rather
than calling scm_num2int (or whatever) every time the value is needed.
So, we first defined each variable along these lines:
</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;guile/gh.h&gt;

int counter = 0;

SCM g_counter(void)
{
  return(scm_long2num(counter));
}

SCM g_set_counter(SCM newval)
{
  counter = scm_num2int(newval, 0, "set-counter");
  return(newval);
}

void inner_main(void *closure, int argc, char **argv)
{
  int size = 512;
  char **buffer = NULL;
  buffer = (char **)calloc(1, sizeof(char *));
  buffer[0] = (char *)calloc(size, sizeof(char));
  scm_c_define_gsubr("counter", 0, 0, 0, g_counter);
  scm_c_define_gsubr("set-counter", 1, 0, 0, g_set_counter);
  while (1)
    {
      getline(buffer, &amp;size, stdin);
      scm_eval_str0(buffer[0]);
      fprintf(stdout, "counter is %d\n", counter);
    }
}

int main(int argc, char *argv[])
{
  scm_boot_guile(argc,argv, inner_main, 0);
  return(0);
}
</pre>
<p>Now we have two functions:  <code>counter</code> returns (to the Scheme world)
the current value of the C variable <code>counter</code>, and <code>set-counter</code>
sets it:
</p>
<pre>
/home/bil/cl/ g
(+ 1 2)
counter is 0
(set-counter 123)
counter is 123
(set-counter (* (counter) 2))
counter is 246
</pre>
<p>Now the g_set_counter procedure can reflect counter's new value within C,
and the variable lives in C, so two of our problems are solved.
But we don't really want the extra name "set-counter".
So, we use Guile's generalized set! by replacing the two
scm_c_define_gsubr calls above with:
</p>
<pre>
  scm_c_define("counter",
    scm_make_procedure_with_setter(
      scm_c_define_gsubr("", 0, 0, 0, g_counter),
      scm_c_define_gsubr("", 1, 0, 0, g_set_counter)));
</pre>
<p>Now we have Snd's way of handling things:
</p>
<pre>
/home/bil/cl/ g
(+ 1 2)
counter is 0
(set! (counter) 123)
counter is 123
(set! (counter) (* (counter) 2)) 
counter is 246
</pre>
<p>It's not completely ideal, but it's close enough that I don't find it painful to use.
If you run the program above, you'll be annoyed to discover that any error causes
it to exit!  Guile's default is to have no error handler installed, so the throw
that an error generates is not caught, causing the program to exit.  The next
version of our program adds error handling, a cleaner exit mechanism (you can
call the exit procedure to exit), and a simple procedure that adds some amount
to the counter:
</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;guile/gh.h&gt;

int counter = 0;
SCM g_counter(void) {return(scm_long2num(counter));}

SCM g_set_counter(SCM newval)
{
  counter = scm_num2int(newval, 0, "set-counter");
  return(newval);
}

/* this code needs the Guile 1.5 or later */
/* the error handler:  it prints out whatever information the error sent us and returns */

static SCM report_error(void *data, SCM tag, SCM throw_args)
{
  if (SCM_EQ_P(tag, scm_str2symbol("quit"))) exit(0);
  fprintf(stdout, "%s: %s\n", 
	  SCM_STRING_CHARS(scm_object_to_string(tag, SCM_UNDEFINED)), 
	  SCM_STRING_CHARS(scm_object_to_string(throw_args, SCM_UNDEFINED)));
  return(tag);
}

static SCM add_to_counter(SCM val)
{
  SCM_ASSERT_TYPE(SCM_EQ_P(scm_integer_p(val), SCM_BOOL_T), val, SCM_ARGn, "add-to-counter", "an integer");
  counter += scm_num2int(val, 0, "add-to-counter");   /* convert from Scheme to C */
  return(scm_long2num(counter));  /* return our new counter value */
}

static void inner_main(void *closure, int argc, char **argv)
{
  SCM result;
  int size = 512;
  char **buffer = NULL;
  scm_c_define_gsubr("add-to-counter", 1, 0, 0, add_to_counter);

  scm_c_define("counter",
    scm_make_procedure_with_setter(
      scm_c_define_gsubr("", 0, 0, 0, g_counter),
      scm_c_define_gsubr("", 1, 0, 0, g_set_counter)));

  buffer = (char **)calloc(1, sizeof(char *));
  buffer[0] = (char *)calloc(size, sizeof(char));
  while (1)
    {
      /* (exit) to exit */
      fprintf(stdout, "&gt;");
      getline(buffer, &amp;size, stdin);
      result = scm_internal_stack_catch(SCM_BOOL_T, /* this is our "catch" */
					scm_eval_str0, 
					(void *)(buffer[0]), 
					report_error,
					buffer[0]);
      fprintf(stdout, "%s\n",
	      SCM_STRING_CHARS(scm_object_to_string(result, SCM_UNDEFINED)));
    }
}

int main(int argc, char *argv[])
{
  scm_boot_guile(argc, argv, inner_main, 0);
  return(0);
}
</pre>
<p>Now we have our own "read-eval-print" loop:
</p>
<pre>
/home/bil/cl/ g
&gt;(+ 1 2)
3
&gt;counter 
#&lt;procedure-with-setter&gt;
&gt;(counter)
0
&gt;(add-to-counter 32)
32
&gt;(counter)
32
&gt;(add-to-counter 1)
33
&gt;(counter)
33
&gt;(add-to-counter 3.41)
wrong-type-arg: ("add-to-counter" "Wrong type argument (expecting ~A): ~S" ("an integer" 3.41) #f)
wrong-type-arg
&gt;asdf
unbound-variable: (#f "Unbound variable: ~S" (asdf) #f)
unbound-variable
&gt;(exit)
</pre>
<p>But now the <i>scm_eval_str0</i> use generates a compiler complaint about type
mismatches (though it works).  We can fix that by:
</p>
<pre>
static SCM eval_str_wrapper(void *data) {return(scm_eval_str0((char *)data));}

/* ... */

      result = scm_internal_stack_catch(SCM_BOOL_T,
					eval_str_wrapper, 
					(void *)(buffer[0]), 
					report_error,
					buffer[0]);
</pre>

<br>

<span class=box><h2><A NAME="extsndasneededexpl">A Note on "As-Needed" input functions</a></h2></span>

<p>Several CLM generators work internally on buffers of data; only the code internal
to the generator knows when it needs input, and how much it needs.  So, src, granulate,
convolve, and phase-vocoder are passed a function either at run-time or when the
generator is allocated that they can call whenever a new value is needed.
A simple C case is:
</p>
<pre>
#include &lt;stdio.h&gt;
#include "clm.h"

typedef struct {
  float val;
} src_state;

float src_input_as_needed(void *arg, int dir) 
{
  src_state *sr = (src_state *)arg;
  sr-&gt;val += (dir * .01); /* just return a ramp */
  return(sr-&gt;val);
}

int main(int argc, char **argv)
{
  mus_any *gen;
  src_state *input;
  int i;
  input = (src_state *)calloc(1, sizeof(src_state));
  input-&gt;val = 0.0;
  gen = mus_make_src(&amp;src_input_as_needed, 0.5, 10, (void *)input);
  for (i=0; i &lt; 100; i++)
    fprintf(stdout, "%f ", mus_src(gen, 0.0, NULL));
    /* or: fprintf(stdout, "%f ", mus_src(gen, 0.0, src_input_as_needed)); */
  mus_free(gen);
  free(input);
  return(0);
}

/* cc g1.c -o g1 -L/usr/local/lib -lguile /home/bil/sndlib/sndlib.a */
/* g1: 0.010000 0.015440 0.020000 0.024761 0.029999 0.035170 0.039999 ... */
</pre>
<p>To put that code in words, the src generator uses the function
<code>src_input_as_needed</code> to fill its internal buffer (convolving
it with sinc); in this case, the "srate" argument is 0.5, so src will
pick up a new input sample (calling src_input_as_needed) on every other
output sample.  In the Scheme CLM (and Snd), the "as-needed" input
function is a Scheme function passed in as Scheme code.  A highly
simplified example is:
</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;guile/gh.h&gt;
#include "clm.h"

typedef struct {
  SCM input_func;
} src_state;

float src_input_as_needed(void *ptr, int direction)
{
  src_state *sr = (src_state *)ptr;
  return(scm_num2dbl(scm_call_1(sr-&gt;input_func, scm_long2num(direction)), "input-as-needed"));
}

void inner_main(void *closure, int argc, char **argv)
{
  mus_any *gen;
  src_state *input;
  int i;
  int size = 512;
  char **buffer = NULL;
  buffer = (char **)calloc(1, sizeof(char *));
  buffer[0] = (char *)calloc(size, sizeof(char));
  input = (src_state *)calloc(1, sizeof(src_state));
  fprintf(stdout, "input function: ");
  getline(buffer, &amp;size, stdin);
  input-&gt;input_func = scm_eval_str0(buffer[0]);
  gen = mus_make_src(&amp;src_input_as_needed, 0.5, 10, (void *)input);
  for (i=0; i &lt; 100; i++)
    fprintf(stdout, "%f ", mus_src(gen, 0.0, src_input_as_needed));
  mus_free(gen);
  free(input);
}

int main(int argc, char *argv[])
{
  scm_boot_guile(argc, argv, inner_main, 0);
  return(0);
}

/* cc g1.c -o g1 -L/usr/local/lib -lguile /home/bil/sndlib/sndlib.a */
/* g1
   input function: (let ((val 0.0)) (lambda (dir) (set! val (+ val (* dir .01))) val))
   0.010000 0.015440 0.020000 0.024761 0.029999 0.035170 0.039999
*/
</pre>
<p>In this case, <code>src_input_as_needed</code> is calling the
user-supplied Scheme function (via <code>scm_call_1</code>).
</p>
<br>

<span class=box><h2><A NAME="extsndcgens">A Note on User-defined Generators in C-CLM</a></h2></span>

<p>In the Common Lisp version of CLM, it's relatively easy to define a new generator. Take for
example, Fernando Lopez-Lezcano's fcomb (a comb filter with a low-pass filter on the feedback), defined as a part of his 
translation of Jezar Wakefield's freeverb reverberator:
</p>
<pre>
(def-clm-struct fcomb
  delay
  filter
  (feedback 0.0))
  
(defmacro fcomb (comb input)
  `(delay (fcomb-delay ,comb)
	  (+ ,input (* (one-zero (fcomb-filter ,comb)
				 (tap (fcomb-delay ,comb)))
		       (fcomb-feedback ,comb)))))
</pre>
<p>An fcomb generator is then created (in freeverb) via:
</p>
<pre>
(make-fcomb :delay (make-delay len)
            :feedback room-decay-val
            :filter (make-one-zero :a0 (- 1.0 dmp) :a1 dmp))
</pre>
<p>and called at run-time with:</p>
<pre>
(fcomb (aref combs c j) (frame-ref in c))
</pre>
<p>(In this case we have a two dimensional array of these generators).  This, of course,
does not make fcomb a full-fledged generator like oscil -- it doesn't
respond to mus-scaler or the other methods, for example.  To do that
requires a bit of defclass/defmethod overhead in Lisp, something
along the lines of:
</p>
<pre> 
(in-package :clm)

(defclass fcomb (comb one-zero) ())

(defmethod fcomb? ((g fcomb)) t)
(defmethod fcomb? ((g t)) nil)

(defun fcomb (gen input)
  (delay gen
	 (+ input (* (one-zero gen (tap gen))
		     (mus-feedback gen)))))

(def-optkey-fun make-fcomb (length feedback a0 a1)
  (make-instance 'fcomb :loc 0 :xscl feedback :size length :zsize length :zdly nil
		 :line (make-double-float-array length)
		 :a0 a0 :a1 a1 :x1 0.0))

(defmethod print-object ((d fcomb) stream)
  (format stream "#&lt;(fcomb: size: ~A, loc: ~A, feedback: ~A, a0: ~A, a1: ~A, x1: ~A, line: ~A&gt;"
	  (dly-size d) (dly-loc d) (dly-xscl d)
	  (mus-a0 d) (mus-a1 d) (mus-x1 d)
	  (prettified-array (dly-line d))))
</pre>
<p>And to get the
new (lisp-side, non-macro) generator to be callable within the run macro is yet another set
of headaches (see <a href="clm.html#user-defined-ugs">user-defined generators</a>).
In CLM-in-Scheme, the first (simpler) fcomb above might be:
</p>
<pre>
(define (fcomb gen input)
  (delay (car gen)
	 (+ input (* (one-zero (cadr gen) (tap (car gen)))
		     (caddr gen)))))

(define (make-fcomb length feedback a0 a1)
  (list (make-delay length)
	(make-one-zero a0 a1)
	feedback))
</pre>
<p>Or perhaps a more Schemey (Schemish?) method would be:
</p>
<pre>
(define (fcomb gen input)
  (gen input))	

(define (make-fcomb length feedback a0 a1)
  (let ((dly (make-delay length))
        (flt (make-one-zero a0 a1)))
    (lambda (input)
      (dly (+ input (* (flt (tap dly)) feedback))))))
</pre>
<p>(Here we're returning a closure that packages up the generator's state). 
We could use Guile's object system to conjure up fcomb
classes and methods in Scheme:
</p>
<pre>
(use-modules (oop goops))

(define-class fcmb ()
  (dly :accessor fcomb-delay)
  (flt :accessor fcomb-filter)
  (fdb :accessor fcomb-feedback))

(define (fcomb gen input)
  ((fcomb-delay gen) 
   (+ input (* ((fcomb-filter gen) 
		(tap (fcomb-delay gen)))
	       (fcomb-feedback gen)))))

(define-method (initialize (obj fcmb) initargs)
  (next-method)
  (let* ((len (get-keyword :length initargs 0))
	 (feedback (get-keyword :feedback initargs 0.5))
	 (a0 (get-keyword :a0 initargs 0.5))
	 (a1 (get-keyword :a1 initargs 0.5)))
    (set! (fcomb-delay obj) (make-delay len))
    (set! (fcomb-filter obj) (make-one-zero a0 a1))
    (set! (fcomb-feedback obj) feedback)
    obj))

(define-method (write (obj fcmb) port)
  (display (format #f "#&lt;fcomb: delay: ~A, filter: ~A, feedback: ~A&gt;"
		   (fcomb-delay obj)
		   (fcomb-filter obj)
		   (fcomb-feedback obj))
	   port))
</pre>
<p>
But our real interest here is how to do the same thing in CLM-in-C (clm.c).
The following example implements a comb filter with a one-zero filter on the feedback.
</p>
<pre>
#include "sndlib.h"
#include "clm.h"
#include "xen.h"
#include "clm2xen.h"

static int MUS_FCOMB = 0; /* this will be our fcomb type identifier */

typedef struct {
  mus_any_class *core;
  int loc, size;
  Float *line;
  Float xscl, a0, a1, x1;
} fcomb;

/* each CLM-in-C generator has mus_any_class *core as the first thing in its structure.
 *   it defines most of the built-in "generic" functions like mus-describe.
 * The next set of functions implement the core functions/
 *   The address of the function is stored in the class's core struct.
 *   For example, the scaler method is defined as Float (*scaler)(void *ptr);
 *   in the mus_any_class declaration (clm.h); for fcomb it will correspond
 *   to the fcomb_scaler function below; it is invoked via mus_scaler(gen)
 *   where gen is an fcomb generator (the actual call is (*((gen-&gt;core)-&gt;scaler))(gen)).
 *   the core-&gt;scaler pointer (the function address) is set in the declaration
 *   of mus_any_class FCOMB_CLASS below.  If a method doesn't apply to a given
 *   generator class, just set its slot to 0.
 */

static int mus_fcomb_p(mus_any *ptr) {return((ptr) &amp;&amp; ((ptr-&gt;core)-&gt;type == MUS_FCOMB));}

static char *describe_fcomb(void *ptr) 
{
  char *desc = NULL;
  fcomb *gen = (fcomb *)ptr;
  desc = (char *)calloc(1024, sizeof(char));
  if (desc)
    {
      if (mus_fcomb_p((mus_any *)ptr))
	sprintf(desc, "fcomb: scaler: %.3f,  a0: %.3f,  a1: %.3f,  line[%d]", 
		gen-&gt;xscl, gen-&gt;a0, gen-&gt;a1, gen-&gt;size);
      else sprintf(desc, "not an fcomb gen");
    }
  return(desc);
}

static int fcomb_equalp(void *p1, void *p2) {return(p1 == p2);}
static int fcomb_length(void *ptr) {return(((fcomb *)ptr)-&gt;size);}
static Float *fcomb_data(void *ptr) {return(((fcomb *)ptr)-&gt;line);}
static Float fcomb_scaler(void *ptr) {return(((fcomb *)ptr)-&gt;xscl);}
static Float set_fcomb_scaler(void *ptr, Float val) {((fcomb *)ptr)-&gt;xscl = val; return(val);}

static int free_fcomb(void *uptr) 
{
  fcomb *ptr = (fcomb *)uptr;
  if (ptr)
    {
      if (ptr-&gt;line) 
        free(ptr-&gt;line);
      free(ptr); 
    }
  return(0);
}

/* now the actual run-time code executed by fcomb */
/* the extra "ignored" argument is for the run method */

static Float mus_fcomb (mus_any *ptr, Float input, Float ignored) 
{
  fcomb *gen = (fcomb *)ptr;
  Float tap_result, filter_result;
  tap_result = gen-&gt;line[gen-&gt;loc];
  filter_result = (gen-&gt;a0 * tap_result) + (gen-&gt;a1 * gen-&gt;x1);
  gen-&gt;x1 = tap_result;
  gen-&gt;line[gen-&gt;loc] = input + filter_result * gen-&gt;xscl;
  gen-&gt;loc++;
  if (gen-&gt;loc &gt;= gen-&gt;size) gen-&gt;loc = 0;
  return(tap_result);
}

/* this is our core class descriptor */

static mus_any_class FCOMB_CLASS = {
  -1, /* MUS_FCOMB eventually */ /* mus_type: this is assigned at run-time via mus_make_class_tag below */
  "fcomb",                       /* mus_name: class name (used in descriptive/error messages */
  &amp;free_fcomb,                   /* mus_free: free gen's struct etc */
  &amp;describe_fcomb,               /* mus_describe: user-friendly description */
  &amp;describe_fcomb,               /* mus_inspect: internal debugging description */
  &amp;fcomb_equalp,                 /* mus_equalp: check equality of fcomb gens */
  &amp;fcomb_data,                   /* mus_data: the fcomb delay line, a float array */
  0,                             /* mus_set_data: not implemented for fcomb */
  &amp;fcomb_length,                 /* mus_length: delay line length */
  0,                             /* mus_set_length: not implemented for fcomb */
  0,0,                           /* mus_frequency, mus_set_frequency */
  0,0,                           /* mus_phase, mus_set_phase */
  &amp;fcomb_scaler,                 /* mus_scaler: the feedback term */
  &amp;set_fcomb_scaler,             /* mus_set_scaler */
  0, 0,
  &amp;mus_fcomb,                    /* mus_run: the run-time fcomb function, MUS_RUN(gen) for speed */
  0,                             /* type extension (normally 0) */
  NULL, 0                         
};

/* now a function to make a new generator */

static mus_any *mus_make_fcomb (Float scaler, int size, Float a0, Float a1)
{
  fcomb *gen = NULL;
  gen = (fcomb *)calloc(1, sizeof(fcomb));
  if (gen == NULL) 
    mus_error(MUS_MEMORY_ALLOCATION_FAILED, 
              "can't allocate struct for mus_make_fcomb!");
  else
    {
      gen-&gt;core = &amp;FCOMB_CLASS;
      if (MUS_FCOMB == 0) 
        {
          MUS_FCOMB = mus_make_class_tag();  /* this gives us a unique fcomb type id */
          gen-&gt;core-&gt;type = MUS_FCOMB;
        }
      gen-&gt;loc = 0;
      gen-&gt;xscl = scaler;
      gen-&gt;x1 = 0.0;
      gen-&gt;a0 = a0;
      gen-&gt;a1 = a1;
      gen-&gt;size = size;
      gen-&gt;line = (Float *)calloc(size, sizeof(Float));
      if (gen-&gt;line == NULL) 
	mus_error(MUS_MEMORY_ALLOCATION_FAILED, 
		  "can't allocate %d bytes for fcomb delay line in mus_make_fcomb!",
		  (int)(size * sizeof(Float)));
    }
  return((mus_any *)gen);
}

/* that is the end of the C side; the rest ties this generator into Guile/Ruby via the Xen package */
/*   in Snd's case, it's actually not needed because the generator is only called from C */

static XEN g_fcomb(XEN obj, XEN input)
{
  return(C_TO_XEN_DOUBLE(mus_fcomb(MUS_XEN_TO_CLM(obj), XEN_TO_C_DOUBLE(input), 0.0)));
}

static XEN g_fcomb_p(XEN obj)
{
  return(C_TO_XEN_BOOLEAN((mus_xen_p(obj)) &amp;&amp; (mus_fcomb_p(MUS_XEN_TO_CLM(obj)))));
}

static XEN g_make_fcomb(XEN scaler, XEN size, XEN a0, XEN a1)
{
  mus_xen *gn;
  gn = (mus_xen *)CALLOC(1,sizeof(mus_xen));
  gn-&gt;gen = mus_make_fcomb(XEN_TO_C_DOUBLE(scaler),
                           XEN_TO_C_INT(size),
                           XEN_TO_C_DOUBLE(a0),
                           XEN_TO_C_DOUBLE(a1));
  gn-&gt;nvcts = 0;
  return(mus_xen_to_object(gn));
}

static void init_fcomb(void)
{
  XEN_DEFINE_PROCEDURE("fcomb?", g_fcomb_p, 1, 0, 0, "(fcomb? gen) -&gt; #t if gen is an fcomb generator");
  XEN_DEFINE_PROCEDURE("make-fcomb", g_make_fcomb, 4, 0, 0, "(make-fcomb scaler size a0 a1) -&gt; new fcomb gen");
  XEN_DEFINE_PROCEDURE("fcomb", g_fcomb, 2, 0, 0, "(fcomb gen input) returns result of running fcomb gen");
}
</pre>

<span class=box><h2><A NAME="continuations">About Continuations</a></h2></span>

<p>A continuation is a GOTO, a jump to the end of the 
defining call-with-current-continuation form. 
Here are a few simple examples:</p>
<pre>

(define (con-return)
  "use call/cc to break out of a loop"
  (call-with-current-continuation
   (lambda (return)              ; declare our "escape" procedure
     (let ((i 0))
       (while (&lt; i 123)
	 (if (= i 3) 
	     (return 'quitting)) ; goto end of continuation form
	 (display i)
	 (set! i (+ i 1)))
       'oops)))
   )                             ; i.e. here (with value 'quitting)

;;; (con-return)
;;;  =&gt; 'quitting

;;; don't use a continuation named "break" in while -- while
;;; itself defines a break continuation that will shadow your break:

(define (con-broken)
  "use call/cc to break out of a loop"
  (call-with-current-continuation
   (lambda (break)
     (let ((i 0))
       (while (&lt; i 123)
	 (if (= i 3) 
	     (break 'quitting)) ; this is while's break, not ours
	 (display i)
	 (set! i (+ i 1)))
       'oops)                   ; so we end up here
      ))
  )                             ; not here as we intended

;;; (con-broken)
;;;  =&gt; 'oops


(define (con-go-on)
  "use call/cc to continue where we left off if a non-serious error is reported"
  (catch #t
	 (lambda ()
	   (do ((i 0 (1+ i)))
	       ((= i 123) 'oops)
	     (if (= i 3)
		 (call-with-current-continuation
		  (lambda (keep-going)
		    (throw 'not-really-an-error keep-going)))
		 (if (= i 6)
		     (throw 'an-error)))
	     (display i)))
	 (lambda args
	     (if (eq? (car args) 'not-really-an-error)
		 ((cadr args) #f)  ;; here we are invoking the continuation passed as an arg to throw
		                   ;;   it will "goto" the "display i" statement with i = 3
		 (display "got a real error")))))

;;; (con-go-on)
;;;   prints "012345got a real error"

;;; here's an example that is not just a simple exit:

(let ((a 1)
      (b 1))
  (let ((cont1 #f)
	(cont2 #f))
    (call-with-current-continuation
     (lambda (x) 
       (set! cont1 x)))      ; set cont1
    ;; this is now where (cont1) will jump: label it CONT1
    (set! a (+ a 2))
    (display "a")
    (if cont2
	(cont2) ; if cont2 has been set, use it to jump to CONT2 below
	(begin
	  (call-with-current-continuation
	   (lambda (x) 
	     (set! cont2 x)  ; set cont2
	     (set! b (+ b 1))
	     (display "b")))
	  ;; this is where (cont2) will jump: CONT2
	  (set! b (+ b 2))
	  (display "!")
	  (if (&lt; b 6) 
	      (cont1)        ; goto CONT1 above
              #f)))))

;;; this prints "ab!a!"

</pre>

<center>
<span class=htmlbox>related documentation</span><span class=htmlbox><a href="snd.html">snd.html</a><spacer type=horizontal size=25><a href="extsnd.html">extsnd.html</a><spacer type=horizontal size=25><a href="grfsnd.html">grfsnd.html</a><spacer type=horizontal size=25><a href="clm.html">clm.html</a><spacer type=horizontal size=25><a href="sndlib.html">sndlib.html</a><spacer type=horizontal size=25><a href="libxm.html">libxm.html</a><spacer type=horizontal size=25><a href="index.html">index.html</a></span>
</center>
</body>
</html>


