<html>
<!-- documentation for some of the Scheme code included with Snd -->
<head>
<title>Scheme and Ruby Functions included with Snd</title>
<style type="text/css">
<!-- 
	EM.red {color:red; font-style:normal}
        EM.error {color:chocolate; font-style:normal}
        EM.typing {color:maroon; font-style: normal}
        EM.listener {color:darkblue; font-style: normal}
	EM.emdef {font-weight: bold; font-style: normal}
	H1 {text-align: center}
	UL {list-style-type: none}

	A {text-decoration:none}
	A:hover {text-decoration:underline}
	A.quiet {color:black; text-decoration:none}
	A.quiet:hover {text-decoration:underline}
	A.def {font-weight: bold; font-style: normal; text-decoration:none; text-color:black}
-->

</style>
</head>
<body bgcolor=white>
<table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h1>Scheme and Ruby Functions included with Snd</h1></td></tr></table>
<br>
<center>
<table border=1><tr><td>
<table bgcolor="aliceblue" border=0 cellspacing=8><tr><td><small>related documentation:</small></td><td><small><a href="snd.html">snd.html</a></small></td>
<td><small><a href="extsnd.html">extsnd.html</a></small></td><td><small><a href="grfsnd.html">grfsnd.html</a></small></td><td><small><a href="clm.html">clm.html</a></small></td><td><small><a href="sndlib.html">sndlib.html</a></small></td><td><small><a href="fm.html">fm.html</a></small></td><td><small><a href="libxm.html">libxm.html</a></small></td><td><small><a href="index.html">index.html</a></small></td></tr></table>
</td></tr></table>
</center>
<br>

<!-- I'm using A NAME (i.e caps) where the entity should be ignored by the indexer (index.cl) -->

<A NAME="introduction"></a>
<ul>
  <li><a href="#autosavedoc">autosave.scm</a>: auto-save support
  <li><a href="#bessdoc">bess.scm, bess.rb</a>: FM demo
  <li><a href="#bess1doc">bess1.scm, bess1.rb</a>: FM violin demo
  <li><a href="#birddoc">bird.scm, bird.rb</a>: North-American birds
  <li><a href="#clminsdoc">clm-ins.scm, clm-ins.rb</a>: more CLM instruments
  <li><a href="#debugdoc">debug.scm</a>: debugging aids
  <li><a href="#dlocsigdoc">dlocsig.rb</a>: moving sounds (Michael Scholz)
  <li><a href="#dlpdoc">dlp</a>: tutorial directories from Dave Phillips
  <li><a href="#drawdoc">draw.scm</a>: graphics additions
  <li><a href="#dspdoc">dsp.scm</a>: various DSP-related procedures
  <li><a href="#editmenudoc">edit-menu.scm</a>: Edit menu additions
  <li><a href="#dotsnd">edit123.scm, snd_conffile.scm</a>: .snd examples (Tom Roth, Kjetil S. Matheussen)
  <li><a href="#effectsdoc">new-effects.scm, gtk-effects.scm, effects.rb</a>: an Effects menu
  <li><a href="#envdoc">env.scm, env.rb</a>: envelope functions
  <li><a href="#enveddoc">enved.scm</a>: envelope editor
  <li><a href="#eventdoc">event.scm</a>: xm module stuff
  <li><a href="#exampdoc">examp.scm, examp.rb</a>: many examples
  <li><a href="#extensionsdoc">extensions.scm, extensions.rb</a>: various generally useful Snd extensions
  <li><a href="#fadedoc">fade.scm</a>: frequency-domain cross-fades
  <li><a href="#fmvdoc">fmv.scm</a>: a controller for the fm-violin
  <li><a href="#freeverbdoc">freeverb.scm, freeverb.rb</a>: a reverb
  <li><a href="#hooksdoc">hooks.scm, hooks.rb</a>: functions related to hooks
  <li><a href="#indexdoc">index.scm, index.rb</a>: snd-help extension
  <li><a href="#dotemacs">inf-snd.el, DotEmacs</a>: Emacs subjob support (Michael Scholz, Fernando Lopez-Lezcano)
  <li><a href="#jcrevdoc">jcrev.scm</a>: John Chowning's ancient reverb
  <li><a href="#ladspadoc">ladspa.scm, ladspa-help.scm</a>: Kjetil S. Matheussen's LADSPA GUI-builder and previewer.
  <li><a href="#maracadoc">maraca.scm</a>: Perry Cook's maraca physical model
  <li><a href="#marksdoc">marks.scm</a>: functions related to marks
  <li><a href="#maxfdoc">maxf.scm, maxf.rb</a>: Max Mathews resonator
  <li><a href="#mixdoc">mix.scm</a>: functions related to mixes and tracks
  <li><a href="#moogdoc">moog.scm</a>: Moog filter
  <li><a href="#musglyphs">musglyphs.scm</a>: Music notation symbols (from CMN)
  <li><a href="#nbdoc">nb.scm, nb.rb</a>: Popup File info etc
  <li><a href="#noisedoc">noise.scm</a>: noise.ins from CLM translated to Scheme/Ruby by Michael Scholz
  <li><a href="#peakenvdoc">peak-env.scm</a>: peak envelope support
  <li><a href="#pianodoc">piano.scm, piano.rb</a>: piano physical model
  <li><a href="#playdoc">play.scm</a>: play-related functions
  <li><a href="#popupdoc">popup.scm, gtk-popup.scm, popup.rb</a>: Popup menu specializations
  <li><a href="#prc95doc">prc95.scm</a>: Perry Cook's physical model examples
  <li><a href="#pvocdoc">pvoc.scm</a>: phase-vocoder
  <li><a href="#rgbdoc">rgb.scm, rgb.rb</a>: colors
  <li><A href="#rmsgaindoc">rmsgain.scm</a>: RMS-based gain and balance methods (Fabio Furlanete)
  <li><a href="#rtiodoc">rtio.scm, rtio.rb</a>: real-time stuff
  <li><a href="#rubberdoc">rubber.scm, rubber.rb</a>: rubber-sound
  <li><a href="#singerdoc">singer.scm</a>: Perry Cook's vocal-tract physical model
  <li><a href="#snd4doc">snd4|5|6|7.scm</a>: Backwards compatibility
  <li><a href="#sndgldoc">snd-gl.scm</a>: OpenGL examples (gl.c)
  <li><a href="#sndmotifdoc">snd-motif.scm, snd-gtk.scm, snd-xm.rb</a>: Motif/Gtk module (xm.c, xg.c)
  <li><a href="#sndtestdoc">snd-test.scm, snd_test.rb, and event.scm</a>: Snd regression tests
  <li><a href="#spectrdoc">spectr.scm, spectr.rb</a>: instrument steady state spectra
  <li><a href="#straddoc">strad.scm, strad.rb</a>: string physical model (from CLM)
  <li><a href="#vdoc">v.scm, v.rb</a>: fm-violin
  <li><a href="#wsdoc">ws.scm, ws.rb</a>: with-sound
  <li><a href="#xmenveddoc">xm-enved.scm, xm-enved.rb</a>: envelope editors
  <li><a href="#zipdoc">zip.scm</a>: the zipper (a cross-fader)
  <li><a href="#extsndvarexpl">A Note on Scheme variables in Snd</a>
  <li><a href="#extsndasneededexpl">A Note on "As-Needed" input functions</a>
  <li><a href="#extsndcgens">A Note on User-defined Generators in C-CLM</a>
  <li><a href="#noisystory">A Note on Noise Reduction</a>
</ul>
<br>

<p>This file contains notes on the Scheme and Ruby files included with Snd.
To use any of these files, (load &lt;file&gt;); for example <code>(load "v.scm")</code>.  To start Snd with
the file already loaded, <code>snd -l v.scm</code>, or put the load statement in ~/.snd.
</p>

<A NAME="autosavedoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>autosave.scm</h2></td></tr></table>

<pre>
  <a class=def name="exautosave">auto-save</a>
  <em class=emdef>cancel-auto-save</em>
</pre>
<!-- I(auto save):L(auto-save)(exautosave) -->
<!-- I(auto save):A(exautosave) -->

<p>The auto-save code sets up a background process that checks periodically for
unsaved edits, and if any are found it saves them in a temporary file.
The time between checks
is set by the variable <i>auto-save-interval</i> which defaults to 60.0 seconds.
To start auto-saving, (load "autosave.scm").  Thereafter <code>(cancel-auto-save)</code>
stops autosaving, and <code>(auto-save)</code> restarts it.
</p>

<A NAME="bessdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>bess.scm, bess.rb</h2></td></tr></table>

<p>bess.scm is a Guile script (independent of Snd) that loads sndlib and xmlib into Guile,
opens the DAC, puts up a bunch of scale widgets, and starts two CLM oscils doing
frequency modulation in semi-real-time (how "real-time" it is depends on your
audio setup).  This is a translation to the Sndlib/Libxm system of bess.cl in CLM.
Michael Scholz has contributed a Ruby translation of this with many improvements:
bess.rb.
</p>


<A NAME="bess1doc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>bess1.scm, bess1.rb</h2></td></tr></table>

<p>bess1.scm and bess1.rb are scripts (independent of Snd), similar to bess.scm and bess.rb,
that give you real-time GUI-based control over the fm-violin while it cycles around in a simple
compositional algorithm.  Both were written by
Michael Scholz, based on CLM's bess5.cl and rt.lisp.
</p>


<A NAME="birddoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>bird.scm</h2></td></tr></table>
<pre>
  <em class=emdef>bird</em> start dur frequency freqskew amplitude freq-envelope amp-envelope
  <a class=def name="bigbird">bigbird</a> start dur frequency freqskew amplitude freq-envelope amp-envelope partials
  <em class=emdef>one-bird</em> beg maxdur func birdname
  <em class=emdef>make-birds</em> #:optional (output-file "test.snd")
</pre>
<p>
bird.scm is a translation of the Sambox/CLM bird songs.  The two instruments set
up a simple sine wave (bird) and simple waveshaping synthesis (bigbird).  Use a
low-pass filter for distance effects (a bird song sounds really silly
reverberated).  All the real information is in the amplitude and frequency
envelopes.  These were transcribed from sonograms found in some bird guides and articles from
the Cornell Ornithology Lab. 
Many of these birds were used in "Colony".  To hear all the
birds, <code>(make-birds)</code>.  This writes the sequence out as "test.snd" using with-sound.
Waveshaping is described in Le Brun, "Digital Waveshaping Synthesis", JAES 1979 April, vol 27, no 4, p250.
The lines
</p>
<pre>
           ...
	   (coeffs (<a class=quiet href="clm.html#partials-&gt;polynomial">partials-&gt;polynomial</a> (normalize-partials partials)))
           ...
		     (<a class=quiet href="clm.html#polynomial">polynomial</a> coeffs
				 (<a class=quiet href="clm.html#oscil">oscil</a> os (<a class=quiet href="clm.html#env">env</a> gls-env))))))
				 <!-- ((( -->
</pre>
<p>setup and run the waveshaping synthesis (in this case it's just a fast
additive synthesis).  <b>partials-&gt;polynomial</b> calculates the Chebyshev
polynomial coefficients given the desired spectrum; the spectrum then
results from driving that polynomial with an oscillator.  Besides the
bird guides, there are now numerous recordings of birds that could
easily be turned into sonograms and transcribed as envelopes.
</p>
<p>In CLM, the bird is:</p>
<pre>
(<a class=quiet href="clm.html#definstrument">definstrument</a> bird (startime dur frequency freq-skew amplitude freq-envelope amp-envelope 
	             &amp;optional (lpfilt 1.0) (degree 0) (reverb-amount 0))
  (multiple-value-bind (beg end) (<a class=quiet href="clm.html#times-&gt;samples">times-&gt;samples</a> startime dur)
    (let* ((amp-env (<a class=quiet href="clm.html#make-env">make-env</a> amp-envelope amplitude dur))
	   (gls-env (<a class=quiet href="clm.html#make-env">make-env</a> freq-envelope (<a class=quiet href="clm.html#hz-&gt;radians">hz-&gt;radians</a> freq-skew) dur))
	   (loc (<a class=quiet href="clm.html#make-locsig">make-locsig</a> :degree degree :distance 1.0 :reverb reverb-amount))
	   (fil (<a class=quiet href="clm.html#make-one-pole">make-one-pole</a> lpfilt (- 1.0 lpfilt)))
	   (s (<a class=quiet href="clm.html#make-oscil">make-oscil</a> :frequency frequency)))
      (run
       (loop for i from beg to end do
	 (<a class=quiet href="clm.html#locsig">locsig</a> loc i (<a class=quiet href="clm.html#one-pole">one-pole</a> fil (* (<a class=quiet href="clm.html#env">env</a> amp-env) (<a class=quiet href="clm.html#oscil">oscil</a> s (<a class=quiet href="clm.html#env">env</a> gls-env))))))))))
</pre>
<p>The bird.scm version could easily include the one-pole filter and so on.
The Ruby version of this file is bird.rb.  Just for comparison, the bird instrument
in Ruby is:</p>
<pre>
def bird(start, dur, frequency, freqskew, amplitude, freq_envelope, amp_envelope)
  gls_env = make_env(freq_envelope, hz2radians(freqskew), dur)
  os = make_oscil(frequency)
  amp_env = make_env(amp_envelope, amplitude, dur)
  beg = (srate() * start).round
  len = (srate() * dur).round
  local_data  = make_vct len
  vct_map!(local_data, Proc.new { || env(amp_env) * oscil(os, env(gls_env)) })
  vct_add!($out_data, local_data, beg)
end
</pre>
<p>The Forth version (written by Michael Scholz) is:
</p>
<pre>
instrument: bird { f: start f: dur f: freq f: freq-skew f: amp freq-env amp-envel }
    freq make-oscil-1 { os }
    amp-envel amp dur make-env { amp-env }
    freq-env freq-skew hz&gt;radians dur make-env { gls-env }
    90e random 1e make-locsig { loc }
    start dur run  amp-env env  gls-env env os oscil-1  f*  i loc locsig  loop
;instrument
</pre>

<br>

<A NAME="clminsdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>clm-ins.scm, clm-ins.rb</h2></td></tr></table>

<p>These are instruments from the CLM tarball translated for use in Snd.
</p>
<!-- remember to add corresponding entry to grfsnd instrument table -->
<pre>
  <em class=emdef>anoi</em> file (etc)
  <em class=emdef>attract</em> beg dur amp c
  <em class=emdef>bes-fm</em> beg dur freq amp ratio index
  <em class=emdef>canter</em> beg dur freq amp (etc)
  <em class=emdef>cellon</em> beg dur freq amp (etc)
  <em class=emdef>drone</em> beg dur freq amp (etc)
  <em class=emdef>expfil</em> start duration hopsecs rampsecs steadysecs file1 file2
  <em class=emdef>exp-snd</em> file beg dur amp (etc)
  <em class=emdef>fm-bell</em> beg dur frequency amplitude amp-env index-env index
  <em class=emdef>fm-drum</em> beg dur freq amp ind (etc)
  <em class=emdef>fm-insect</em> beg dur freq amp (etc)
  <em class=emdef>fm-trumpet</em> beg dur (etc)
  <em class=emdef>fofins</em> beg dur frq amp uvib f0 a0 f1 a1 f2 a2 (amp-env '(0 0 1 1 2 1 3 0))
  <em class=emdef>fullmix</em> infile (etc)
  <em class=emdef>gong</em> beg dur freq amp (etc)
  <em class=emdef>gran-synth</em> beg dur freq grain-dur grain-hop amp
  <em class=emdef>graphEq</em> file (etc)
  <em class=emdef>hammondoid</em> beg dur freq amp
  <em class=emdef>jl-reverb</em>
  <em class=emdef>lbj-piano</em> beg dur freq amp (etc)
  <em class=emdef>metal</em> beg dur freq amp
  <em class=emdef>nrev</em> (reverb-factor 1.09) (lp-coeff 0.7) (volume-1 1.0)
  <em class=emdef>pins</em> beg dur file amp (transposition 1.0) (time-scaler 1.0) (etc)
  <em class=emdef>pluck</em> beg dur freq amp (weighting .5) (lossfact .9)
  <em class=emdef>pqw-vox</em> beg dur freq spacing-freq amp ampfun freqfun freqscl phonemes formant-amps formant-shapes
  <em class=emdef>pqw</em> beg dur freq (etc)
  <em class=emdef>resflt</em> beg dur driver (etc)
  <em class=emdef>reson</em> beg dur freq amp (etc)
  <em class=emdef>rhodey</em> beg dur freq amp (base .5)
  <A class=def NAME="scratch">scratch</a> beg file src-ratio turnlist
  <em class=emdef>spectra</em> beg dur freq amp (etc)
  <em class=emdef>stereo-flute</em> beg dur freq flow (etc)
  <em class=emdef>touch-tone</em> beg number
  <em class=emdef>tubebell</em> beg dur freq amp (base 32.0)
  <em class=emdef>two-tab</em> beg dur freq amp (etc)
  <em class=emdef>vox</em> beg dur freq amp ampfun freqfun freqscl voxfun index vibscl
  <em class=emdef>wurley</em> beg dur freq amp
  <em class=emdef>zc</em> time dur freq amp length1 length2 feedback
  <em class=emdef>zn</em> time dur freq amp length1 length2 feedforward
  <em class=emdef>za</em> time dur freq amp length1 length2 feedback feedforward
</pre>
<p>
<b>fofins</b> is an implementation of FOF synthesis, taken originally from
fof.c of Perry Cook and the article
"Synthesis of the Singing Voice" by Bennett and Rodet in
"Current Directions in Computer Music Research" (MIT Press).
</p><p><b>pluck</b> is based on
the Karplus-Strong algorithm as extended by David Jaffe and Julius Smith -- see 
Jaffe and Smith, "Extensions of the Karplus-Strong Plucked-String Algorithm"
CMJ vol 7 no 2 Summer 1983, reprinted in "The Music Machine".
Another physical model is Nicky Hind's stereo-flute.
</p>
<p>
<b>vox</b> is a translations of Marc LeBrun's MUS10 waveshaping voice instrument
using FM in this case.  The waveshaping version is <b>pqwvox</b>
("phase-quadrature waveshaping voice").
The basic idea is that each of the three vocal formants is created by two
sets of waveshapers, one centered on the even multiple of the base frequency closest to the desired formant frequency,
and the other on the nearest odd multiple.  As the base frequency moves (vibrato, glissando),
these center frequencies are recalculated (on each sample), and the respective amplitudes
set from the distance to the desired frequency.  If a center frequency moves (for example,
the base frequency moves down far enough that the previous upper member of the pair has
to become the lower member), the upper waveshaper (which has ramped to zero amplitude), jumps
down to its new center. The formant table was provided by Robert Poor.
The phase-quadrature part of the business creates single side-band spectra.
For details on waveshaping, see Le Brun, "Digital Waveshaping Synthesis", JAES 1979 April, vol 27, no 4, p250.
It might be simpler to set up three formant generators and drive them with the waveshapers,
but the leap-frog idea was a neat hack -- such things are worth keeping even when
they aren't all that sensible anymore.
</p>
<p>The FM bell was developed by Michael McNabb in Mus10 in the late '70s.  It is intended
for low bell sounds (say middle C or so). The lines
</p>
<pre>
	   (mod1 (<a class=quiet href="clm.html#make-oscil">make-oscil</a> (* frequency 2)))
	   (mod2 (<a class=quiet href="clm.html#make-oscil">make-oscil</a> (* frequency 1.41)))
	   (mod3 (<a class=quiet href="clm.html#make-oscil">make-oscil</a> (* frequency 2.82)))
	   (mod4 (<a class=quiet href="clm.html#make-oscil">make-oscil</a> (* frequency 2.4)))
	   (car1 (<a class=quiet href="clm.html#make-oscil">make-oscil</a> frequency))
	   (car2 (<a class=quiet href="clm.html#make-oscil">make-oscil</a> frequency))
	   (car3 (<a class=quiet href="clm.html#make-oscil">make-oscil</a> (* frequency 2.4)))
</pre>
<p>set up three FM pairs, car1+mod1 handling the basic harmonic spectra,
car2+mod2 creating inharmonic spectra (using the square root of 2 more or less
at random), and car3+mod3 putting a sort of formant at the minor third
(2.4 = a ratio of 12/5 = octave+6/5 = minor tenth).
</p>
<pre>
  (define fbell '(0 1 2 1.1000 25 .7500 75 .5000 100 .2000 ))
  (define abell '(0 0 .1000 1 10 .6000 25 .3000 50 .1500 90 .1000 100 0 ))
  (fm-bell 0.0 1.0 220.0 .5 abell fbell 1.0)
</pre>
<p><b>scratch</b> moves back and forth in a sound file according to
a list of turn times (see also <a href="#exenvsoundinterp">env-sound-interp</a>).
</p>
<p><b>pins</b> is a simple implementation of thje spectral modeling synthesis
of Xavier Serra and Julius Smith.  It is similar to the phase vocoder.
</p>
<p>The "z" instruments demonstrate "zdelay" effects -- interpolating
comb, notch, and all-pass filters.
</p>
<p><b>exp-snd</b> is a granular synthesis instrument with envelopes on
nearly every variable. <i>expfile</i> interleaves two granulate processes.
</p>
<p><b>graphEq</b> mimics a graphical equalizer by setting up a bank of formant
generators, with an optional envelope on each formant.
</p>
<p>
<b>anoi</b> is a stab at noise reduction
based on Perry Cook's Scrubber.m.
</p>
<p><b>fullmix</b> is a complicated way to mix stuff.
</p>
<br>

<A NAME="debugdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>debug.scm</h2></td></tr></table>

<pre>
  <a class=def name="exsnddebug">snd-debug</a>
  <a class=def name="exsndtrace">snd-trace</a>
  <a class=def name="exsndbreak">snd-break</a> (message #f)
</pre>
<!-- INDEX debugdoc:Debugging (break/trace) -->

<p>debug.scm is a package of debugging aids.
<b>snd-break</b> sets a breakpoint; if it is called, you drop into the Snd debugger.
You can continue from the breakpoint, optionally returning any value you like.
While in the break context (while the listener prompt says "break"), 
these functions are available:
</p>
<pre>
  <em class=emdef>break-go</em> (returned-value #f)
  <em class=emdef>break-locals</em> (stack-location 0)
  <em class=emdef>break-local</em> local-var (stack-location 0)
  <em class=emdef>break-backtrace</em> (all #f)
  <em class=emdef>break-help</em>
  <em class=emdef>break-quit</em>
  <em class=emdef>break-quit!</em>
</pre>
<p>
<b>break-locals</b> prints out the local variables and their values.
<b>break-local</b> prints one such variable's value (the <i>local-var</i> argument should be a symbol or a string).
<b>break-help</b> prints out help.
<b>break-backtrace</b> shows the stack at the point of the snd-break call.  The stack trace
is normally truncated to show just the 5 or so inner frames; to get the full
backtrace, call break-backtrace with an argument of #t.
<b>break-quit</b> exits the current break level.
<b>break-quit!</b> exits all break levels, returning you to the true top-level.
<b>break-go</b> continues from the point of the breakpoint.
The 'returned-value' is the value to return from the original call on snd-break.
Here is a brief session in Snd's listener:
</p>
<pre>
<em class=listener>:</em><em class=typing>(define (test-break a) (let ((b (+ a (snd-break "hiho")))) b))</em>
<em class=listener>#&lt;unspecified&gt;</em>
<em class=listener>:</em><em class=typing>(define hi 123)</em>
<em class=listener>#&lt;unspecified&gt;</em>
<em class=listener>:</em><em class=typing>(set! hi (test-break 1))</em>
<em class=listener>break:("hiho")</em>
<em class=listener>break:</em><em class=typing>hi</em>
<em class=listener>123</em>
<em class=listener>break:</em><em class=typing>(break-go 32)</em>
<em class=listener>:#&lt;unspecified&gt;</em>
<em class=listener>:</em><em class=typing>hi</em>
<em class=listener>33</em>
</pre>
<p>In words, we put a breakpoint in the midst of an expression in the test-break function,
asking it to type "hiho" and drop into the debugger if it is executed.  Then we call
test-break in an expression that sets the variable hi.  The breakpoint is hit, "hiho"
gets reported, and we're placed in the debugger.  As you can probably tell, this is
just the Snd listener, but with some extra context to implement the break support.
After poking around, we call break-go with an argument of 32.  This causes the original
set! to continue with 32 plugged in where the snd-break call was, setting hi to 33.
</p>
<p>
<b>snd-debug</b> sets up a debugger. You can examine the stack or local variables etc.
After calling snd-debug, there are functions similar to the break functions listed above:
</p>
<pre>
  <em class=emdef>bt</em> -- show backtrace
  <em class=emdef>lv (obj)</em> -- show local vars
</pre>
<p><b>snd-trace</b> activates any tracing
that you may have requested and redirects its output to the Snd listener.
Here's how to trace fm-violin calls in a notelist:
</p>
<pre>
(trace fm-violin)
(<em class=red>snd-trace</em> (with-sound () (fm-violin 0 1 440 .1)))
</pre>
<p>To turn off the trace</p>
<pre>
(untrace fm-violin)
</pre>
<br>

<A NAME="dlocsigdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>dlocsig.rb</h2></td></tr></table>

<p>dlocsig.rb is Michael Scholz's translation to Ruby of Fernando Lopez-Lezcano's
dlocsig in CLM.  Fernando's documentation can be found in the CLM tarball
(dlocsig/index.html).  dlocsig is a CLM generator that can produce moving sounds.
</p>
<p>See dlocsig.rb for documentation and examples.
</p>
<br>

<A NAME="dlpdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>dlp directory entries</h2></td></tr></table>

<p>The dlp directory contains a variety of useful additions written by Dave Phillips.  These
include:
</p>
<pre>
  <em class=emdef>misc.scm</em>               loads files for enhanced interface, many new menu options
  <em class=emdef>new-icons.scm</em>          icon box entries
  <em class=emdef>special-menu.scm</em>       the Special menu (OGG/MP3 etc)
  <em class=emdef>mix-menu.scm</em>           the Mix menu
  <em class=emdef>panic.scm</em>              the Panic menu (to stop sound output)
  <em class=emdef>track-colors.scm</em>       track color choices (for mixing)
  <em class=emdef>fft-menu.scm</em>           FFT-based editing
  <em class=emdef>new-backgrounds.scm</em>    background choices (granite Snd!)
  <em class=emdef>marks-menu.scm</em>         the Marks menu
  <em class=emdef>new-buttons.scm</em>        sets the icon box actions
  <em class=emdef>README</em>                 loading info
</pre>
<p>See the individual files and Dave's tutorial (in the tutorial directory) for more details.
</p>


<A NAME="drawdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>draw.scm</h2></td></tr></table>

<p>draw.scm has examples of graphics additions; some of these are shown in extsnd.html.
</p><p><b>display-energy</b> is a lisp-graph-hook procedure that displays the current time
domain data as energy, not amplitude, using the y zoom slider to control the
y axis.  The other procedures in draw.scm are intended for use with the
after-graph-hook.  
</p><p><b>display-colored-samples</b> (color beg dur snd chn) displays samples from beg for dur in color
whenever they're in the current view. This is intended for use with <b>color-samples</b>. 
(<a class=def name="colorsamples">color-samples</a> color #:optional beg dur snd chn) causes samples from beg to beg+dur to be displayed in color;
to undo this, use <b>uncolor-samples</b>.
</p><p><b>display-previous-edits</b> displays all edits of the current sound, with older versions gradually fading away.
</p><p><b>overlay-sounds</b> overlays onto its first argument all subsequent arguments: (overlay-sounds 1 0 3).
</p><p><b>make-current-window-display</b>
displays in the upper right corner the overall current sound and where the current window fits in it.
This info is implicit in the x sliders, but a redundant graph doesn't hurt.  If you click in that graph,
the cursor is moved to the clicked point.
</p>
<center><img src="uppergrf.png" alt="make-current-window-display"></center>
<br>
<p>
<b>click-for-listener-help</b> is intended as a <a href="extsnd.html#listenerclickhook">listener-click-hook</a> entry.  It posts help about
the closest entity it can find whenever you double click in the listener.  Unfortunately, the help
dialog is a bit clunky for a use like this, but the minibuffer has only one line, and
tooltips are irritating in their own way; perhaps it should post the help at the bottom of
the listener?
</p>
<br>

<A NAME="dspdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>dsp.scm</h2></td></tr></table>

<p>A DSP grabbag, mostly filters.
</p>
<table border=1>
  <tr><td><A class=def NAME="exdolph">dolph</a> n gamma</td><td>Dolph-Chebyshev fft data window</td></tr>
  <tr><td><A class=def NAME="exdownoct">down-oct</a></td><td>move sound down 8ve using fft</td></tr>
  <tr><td><em class=emdef>freqdiv</em> n</td><td>"frequency division" effect</td></tr>
  <tr><td><em class=emdef>adsat</em> size</td><td>"adaptive saturation" effect</td></tr>
  <tr><td><em class=emdef>spike</em></td><td>spikey sound effect</td></tr>
  <tr><td><A class=def NAME="excomputeuniformcircularstring">compute-uniform-circular-string</a> size ...</td><td>scanned synthesis</td></tr>
  <tr><td><em class=emdef>compute-string</em> size ...</td><td></td></tr>
  <tr><td><em class=emdef>spot-freq</em></td><td>easily-fooled autocorrelation-based pitch tracker</td></tr>
  <tr><td><A class=def NAME="zerophase">zero-phase, rotate-phase</a></td><td>phase-based effects</td></tr>
  <tr><td><em class=emdef>both forms of asymmetric-fm</em></td><td></td></tr>
  <tr><td><em class=emdef>cosine-summation</em></td><td>sum-of-cosines stuff</td></tr>
  <tr><td><em class=emdef>kosine-summation</em></td><td>more sum-of-cosines stuff</td></tr>
  <tr><td><em class=emdef>legendre-sum</em></td><td></td></tr>
  <tr><td><em class=emdef>fejer-sum</em></td><td></td></tr>
  <tr><td><em class=emdef>brighten-slightly</em> amount</td><td>add harmonics</td></tr>
  <tr><td><em class=emdef>spectrum-&gt;coeffs</em> order spectrum-envelope</td><td>frequency-response envelope -&gt; FIR coeffs</td></tr>
  <tr><td><a class=def name="makehilberttransform">make-hilbert-transform</a> length</td><td>Hilbert transform</td></tr>
  <tr><td><a class=def name="makelowpass">make-lowpass</a> fc length</td><td>FIR lowpass</td></tr>
  <tr><td><a class=def name="makehighpass">make-highpass</a> fc length</td><td>FIR highpass</td></tr>
  <tr><td><a class=def name="makebandpass">make-bandpass</a> flo fhi length</td><td>FIR bandpass</td></tr>
  <tr><td><a class=def name="makebandstop">make-bandstop</a> flo fhi length</td><td>FIR bandstop</td></tr>
  <tr><td><a class=def name="makedifferentiator">make-differentiator</a> length</td><td>FIR differentiator</td></tr>
  <tr><td><a class=def name="makebiquad">make-biquad</a> a0 a1 a2 b1 b2</td><td>IIR cascade section</td></tr>
  <tr><td><em class=emdef>make-butter-high-pass</em> freq</td><td>2nd order Butterworth highpass</td></tr>
  <tr><td><em class=emdef>make-butter-low-pass</em> freq</td><td>2nd order Butterworth lowpass</td></tr>
  <tr><td><em class=emdef>make-butter-band-pass</em> freq bandwidth</td><td>2nd order Butterworth bandpass</td></tr>
  <tr><td><em class=emdef>make-butter-band-reject</em> freq bandwidth</td><td>2nd order Butterworth bandstop</td></tr>
  <tr><td><em class=emdef>fltit-1</em></td><td></td></tr>
  <tr><td><em class=emdef>make-iir-low-pass-1</em> fc</td><td>IIR 1st order lowpass</td></tr>
  <tr><td><em class=emdef>make-iir-high-pass-1</em> fc</td><td>IIR 1st order highpass</td></tr>
  <tr><td><em class=emdef>make-iir-low-pass-2</em> fc d</td><td>IIR 2nd order lowpass</td></tr>
  <tr><td><em class=emdef>make-iir-high-pass-2</em> fc d</td><td>IIR 2nd order highpass</td></tr>
  <tr><td><em class=emdef>make-iir-band-pass-2</em> f1 f2</td><td>IIR 2nd order bandpass</td></tr>
  <tr><td><em class=emdef>make-iir-band-stop-2</em> f1 f2</td><td>IIR 2nd order bandstop</td></tr>
  <tr><td><em class=emdef>make-eliminate-hum</em> freq ...</td><td>hum eliminator (cascaded bandstops)</td></tr>
  <tr><td><em class=emdef>make-peaking-2</em> f1 f2 m</td><td>slight resonance effect</td></tr>
  <tr><td><em class=emdef>cascade-&gt;canonical</em> coeffs</td><td>convert cascade coeffs to canonical (for CLM's filter gen)</td></tr>
  <tr><td><em class=emdef>make-butter-lp</em> M fc</td><td>any even order Butterworth lowpass</td></tr>
  <tr><td><em class=emdef>make-butter-hp</em> M fc</td><td>any even order Butterworth highpass</td></tr>
  <tr><td><em class=emdef>make-butter-bp</em> M f1 f2</td><td>any even order Butterworth bandpass</td></tr>
  <tr><td><em class=emdef>make-butter-bs</em> M f1 f2</td><td>any even order Butterworth bandstop</td></tr>
  <tr><td><a class=def name="notchchannel">notch-channel</a> freqs order beg dur s c e trunc width</td><td>arbitrary notch filter applied to channel</td></tr>
  <tr><td><a class=def name="notchsound">notch-sound</a> freqs order s c width</td><td>arbitrary notch filter applied to sound</td></tr>
  <tr><td><a class=def name="notchselection">notch-selection</a> freqs order width</td><td>arbitrary notch filter applied to selection</td></tr>
  <tr><td><a class=def name="fractionalfouriertransform">fractional-fourier-transform</a> rl im size angle</td></tr>
  <tr><td><a class=def name="ztransform">z-transform</a> rl size z</td></tr>
  <tr><td><A class=def NAME="exdht">dht</A> data</td><td>slow Hartley transform </td></tr>
  <tr><td><em class=emdef>find-sine</em> freq beg dur</td><td>DFT at a particular frequency</td></tr>
  <tr><td><em class=emdef>goertzel</em> freq beg dur</td><td>same as find-sine but faster</td></tr>
  <tr><td><em class=emdef>make-spencer-filter</em></td><td>return FIR filter with Spencer coefficients</td></tr>
  <tr><td><A class=def NAME="anyrandom">any-random</A></td><td>random numbers of arbitrary distribution using rejection method</td></tr>
</table>

<p><b>dolph</b> is the Dolph-Chebyshev fft data window, taken
from Richard Lyons, "Understanding DSP".
</p><p><b>dht</b> is the slow form of the Hartley transform, 
taken from Perry Cook's SignalProcessor.m.
The Hartley transform is a kind of Fourier transform.
A similar function, using the DFT, is <b>find-sine</b>.
It returns the amplitude and initial-phase (for sin) at freq between beg and dur.
A faster version is <b>goertzel</b>.
</p><p>The simple Butterworth filters are taken from Sam Heisz's CLM version
of Paris Smaragdis's Csound version of Charles Dodge's code from "Computer Music: synthesis, composition, and performance".
The second set (make-butter-lp et al) provide arbitrary order Butterworths.
See also the notch filter in new-effects.scm.
<b>spectrum-&gt;coeffs</b> is a Scheme
version of Snd's very simple spectrum-&gt;coefficients procedure ("frequency sampling").
It returns the FIR filter coefficients given the filter order and desired spectral envelope.
</p>
<pre>
(<a class=quiet href="extsnd.html#mapchan">map-chan</a> (fltit-1 10 (<a class=quiet href="extsnd.html#vct">vct</a> 0 1.0 0 0 0 0 0 0 1.0 0)))
</pre>
<p>
<b>down-oct</b> tries to move a sound down an octave by goofing with the fft data,
then inverse ffting.  
<b>freqdiv</b> implements
"frequency division", taken from an effects package of sed_sed@my-dejanews.com.
</p>
<pre>
(freqdiv 8)
</pre>
<p>
Also from that package is <b>adsat</b>, "adaptive saturation".  </p><p><b>spike</b> performs 
a product of samples (as opposed to the more common sum); that is, it multiplies
together several successive samples, causing a more spikey output.
</p><p><b>compute-uniform-circular-string</b> and <b>compute-string</b> implement
scanned synthesis of Bill Verplank and Max Mathews.
To watch the wave, open some sound (so Snd has some place to put the graph), turn off
the time domain display (to give our graph all the window)
then <code>(testunif 1.0 0.1 0.0)</code>.
</p><p>The <A class=def NAME="spotfreq"><b>spot-freq</b></a> function is a simple first-pass at using autocorrelation for
pitch tracking; it's easily fooled, but could probably be made relatively robust.
The code:
</p>
<pre>
 (let* ((logla (log10 (/ (+ cor-peak (<a class=quiet href="extsnd.html#vctref">vct-ref</a> data i)) (* 2 cor-peak))))
	(logca (log10 (/ (+ cor-peak (<a class=quiet href="extsnd.html#vctref">vct-ref</a> data (+ i 1))) (* 2 cor-peak))))
	(logra (log10 (/ (+ cor-peak (<a class=quiet href="extsnd.html#vctref">vct-ref</a> data (+ i 2))) (* 2 cor-peak))))
	(offset (/ (* 0.5 (- logla logra))
		   (+ logla logra (* -2.0 logca)))))
   (return (/ (<a class=quiet href="extsnd.html#srate">srate</a> snd)
	      (* 2 (+ i 1 offset)))))
</pre>
<p>is using Xavier Serra's interpolation technique to find the true location
of the autocorrelation peak.  The <i>cor-peak</i> business is making sure the
log10 arguments fall between 0.0 and 1.0.
</p>

<p><b>zero-phase</b> and <b>rotate-phase</b> are fft-manipulators taken from
the phazor package of Scott McNab.
</p>

<p><b>asyfm-J</b> is a Scheme version of the CLM asymmetric-fm generator;
<b>asyfm-I</b> is the Modifier Bessel version of this generator.  In both
cases, the "r" variable is accessible, so it's easy to experiment with 
the moving formant idea mentioned in the original article.
</p>

<p><b>cosine-summation</b> is a variation on Moorer's sine-summation;
the generating formula is much simpler, but the result is the same.  This
can also be viewed as a version of the sum-of-cosines generator, giving control
on the ratio between successive cosines in the sum (i.e. the "r" parameter in
sine-summation, applied within the sum-of-cosines output).  <b>legendre-sum</b> and <b>fejer-sum</b>
produce a band-limited pulse-train whose
cosine components have a decreasing amplitude.
Three other similar functions are <b>sum-of-n-sines</b>,
<b>sum-of-n-odd-sines</b>, and <b>sum-of-n-odd-cosines</b>.
<b>kosine-summation</b> is a variation on <b>cosine-summation</b>; it includes
a sort of "FM index" parameter (named "k", hence the generator name) to vary the harmonic content at run-time.
</p>

<p><b>brighten-slightly</b> is a slight simplification of contrast-enhancement.
</p><p><b>make-hilbert-transform</b> and <b>hilbert-transform</b> provide an FIR filter approach to the Hilbert transform.
<b>make-lowpass</b> and <b>lowpass</b> provide FIR low pass filtering.
<b>make-highpass</b> and <b>highpass</b> provide FIR high pass filtering.
<b>make-bandpass</b> and <b>bandpass</b> provide FIR band pass filtering.
<b>make-bandstop</b> and <b>bandstop</b> provide FIR notch filtering.
<b>make-differentiator</b> and <b>differentiator</b> provide an FIR filter-based differentiator.
</p>
<p>The Ruby version of this is in examp.rb.
</p>
<p>
<b>notch-channel</b> and <b>notch-selection</b> are aimed at noise reduction.
Each takes a list of frequencies (in Hz), and an optional filter order, and
notches out each frequency.  The sharpness of the notch is settable
explicitly via the <i>width</i> argument, and implicitly via the
filter <i>order</i>.  A common application cancels 60 Hz hum:
</p>
<pre>
(notch-channel (let ((freqs '())) (do ((i 60 (+ i 60))) ((= i 3000)) (set! freqs (cons i freqs))) (reverse freqs)))
</pre>
<p>Here we've built a list of multiples of 60 and passed it to notch-channel. Its default notch
width is 2 Hz, and its default order tries to maintain that width given the channel's sampling rate,
so the default filter order can be very high (65536).  The filtering is normally done via
convolutuion (CLM's convolve generator), so a high filter order is not a big deal.  In ideal
cases, this can reduce the hum and its harmonics by about 90%.
But, if the hum is not absolutely stable, you'll probably want wider notches:
</p>
<pre>
(notch-channel (let ((freqs '())) (do ((i 60 (+ i 60))) ((= i 3000)) (set! freqs (cons i freqs))) (reverse freqs)) 1024)
</pre>
<p>The order of 1024 means we get 20 Hz width minima (44100 Hz srate), so this
notches out much bigger chunks of the spectrum.  You get 98% cancellation, but
also lose more of the original signal.
</p>
<p><b>fractional-fourier-transform</b> is the slow (dft) version of the fractional Fourier Transform.
<b>z-transform</b> performs a z transform.
<b>any-random</b> provides the same output as <a href="clm.html#rand">rand</a> if the latter's
envelope (distribution function) argument is used, but using a slightly different method
to generate the numbers.  Also included is <b>inverse-integrate</b>, a Scheme version of
CLM's distribution-to-weighting function, and <b>gaussion-envelope</b> which makes
a gaussian distribution envelope suitable for <b>rand</b>.
</p>

<!-- INDEX allrandomnumbers:Random Numbers --><a name="allrandomnumbers"></a>
<TABLE border=3 bordercolor="tan" hspace=40><tr><td>
<blockquote><small>
<br>
Random Numbers in Snd/CLM:<br>
generators, arbitrary distributions, fractals, 1/f: <a href="clm.html#randomnumbers">rand and rand-interp</a><br>
dithering: <a href="sndscm.html#ditherchannel">dither-channel</a><br>
noise-making instrument: <a href="#noisedoc">noise.scm, noise.rb</a><br>
physical modeling of noisy instruments: <a href="#maracadoc">maraca.scm</a><br>
arbitrary distribution via rejection method: <a href="#anyrandom">any-random</a><br>
CL: random, *random-state*, make-random-state*: random number between 0 and arg, arg can't be 0!<br>
Guile: random, *random-state*, see-&gt;random-state: random number between 0 and arg, arg can't be 0!<br>
Ruby: kernel_rand (alias for Ruby's rand), srand: random integer between 0 and arg, or float between 0 and 1<br>
CLM (all versions): <a href="clm.html#mus-random">mus-random, mus_random</a>: random float between -arg and arg<br>
CLM (CL): <a href="clm.html#clm-random">clm-random</a>: random float between 0.0 and arg<br>
CLM (C): mus_irandom: random int between 0 and arg<br>
CLM (C): mus_frandom: random float between 0.0 and arg<br>
CLM (CL): <a href="clm.html#mus-set-rand-seed">mus-set-rand-seed</a><br>
CLM (Scheme): mus-rand-seed (settable)<br>
<br>
</small></blockquote>
</td></tr></TABLE>
<br>

<A NAME="editmenudoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>edit-menu.scm</h2></td></tr></table>

<p>edit-menu.scm adds some useful options to the Edit menu:
</p>
<pre>
  <b>trim front</b> and <b>trim back</b> (to/from marks)
  <b>crop</b> (first and last marks)
  <b>selection-&gt;new</b>
  <b>cut selection-&gt;new</b>
  <b>append selection</b> (and append sound)
</pre>
<!-- I(trim sound):M(Edit: Trim)(editmenudoc) -->
<!-- I(trim sound):A(editmenudoc) -->


<A NAME="dotsnd"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>edit123.scm, snd_conffile.scm</h2></td></tr></table>

<p>These two files are examples of Snd customization files, suitable for inclusion in ~/.snd.
edit123.scm is by Tom Roth, and snd_conffile.scm is by Kjetil S. Matheussen.
</p>


<A NAME="effectsdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>new-effects.scm, gtk-effects.scm, effects.rb</h2></td></tr></table>

<p>new-effects.scm implements an Effects menu.  If you have Motif,
you can load xm.so (or build Snd with it preloaded), and get sliders
to control most of the effects.  (Use gtk-effects.scm with Gtk, obviously).
The effects include:
</p>
<pre>
  <b>reverse</b>
  <b>normalize</b> (normalization)
  <b>gain</b> (gain-amount)
  <b>invert</b>
  <b>chordalize</b> (chordalize-amount, chordalize-base)
  <b>flange</b> (increase speed and amount to get phasing, flange-speed, flange-amount, flange-time)
  <b>compand</b>, compand-channel
  <b>reverberate</b> (reverb-amount)
  <b>intensify</b> (contrast-amount)
  <b>echo</b> (echo-length, echo-amount)
  <b>squelch</b> (squelch-amount, omit-silence)
  <b>add silence</b> (at cursor) (silence-amount)
  <b>remove DC</b>
  <b>expsrc</b> (independent pitch/time scaling) (time-scale and pitch-scale)
  <b>filter</b>
  <b>cross synthesis</b>
</pre>

<!-- I(reverse samples):M(Effects: Reverse)(effectsdoc) -->
<!-- I(reverberate file):M(Effects: Reverberate)(effectsdoc) -->
<!-- I(normalize sound):M(Effects: Normalize)(effectsdoc) -->
<!-- I(normalize sound):A(effectsdoc) -->
<!-- I(normalize sound):L(scale-to)(scaleto) -->
<!-- I(insert zeros):M(Effects: Add Silence)(effectsdoc) -->
<!-- I(change tempo):M(Effects: Expsrc)(effectsdoc) -->

<p>Most of these are either simple calls on Snd functions ("invert" is <code>(<a class=quiet href="extsnd.html#scaleby">scale-by</a> -1)</code>),
or use functions in the other scm files.  The actual operations follow the sync chain of the
currently active channel.  
</p>
<p>One possibly interesting part of new-effects.scm is the implementation of the
Effects menu.  If you change one of the variables, you'll notice that the
menu updates its notion of that variable as well.  This is handled through
<i>update-callback</i> argument to <a href="extsnd.html#addtomainmenu">add-to-main-menu</a>
function.  Each effect is added (when new-effects.scm is loaded) to the <i>effects-list</i>.
Then each time you click the Effects menu, causing its options to be dispayed,
the update-callback function itself calls each effect's update function to
get its current option label.  That is,
</p>
<pre>
(define effects-list '())
(define effects-menu 
  (<a class=quiet href="extsnd.html#addtomainmenu">add-to-main-menu</a> "Effects" 
                    (lambda ()
 		      (define (update-label effects)
		        (if (not (null? effects))
			    (begin
			      ((car effects))
			      (update-label (cdr effects)))))
		      (update-label effects-list))))
</pre>
<p>defines the update-callback to be a thunk (the outer lambda) that itself
defines a local function (update-label) that runs through the effects-list
calling each one via <code>((car effects))</code>.  Each effect that wants
to recalculate its option label then
adds its update function to the effects-list when it is loaded.
The sound effect itself is the callback function of the given option:
</p>
<pre>
(<a class=quiet href="extsnd.html#addtomenu">add-to-menu</a> effects-menu "reverse" (lambda () (<a class=quiet href="extsnd.html#reversesound">reverse-sound</a>)))
</pre>
<p>I can't decide whether it would be useful to describe some of these
effects in more detail.  The code is straightforward, and
it's not hard to try them out.
</p>	
<p>The Ruby/Motif version of this is in effects.rb.
</p>
<br>

<A NAME="envdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>env.scm, env.rb</h2></td></tr></table>

<p>An envelope in Snd/CLM is simply a list of breakpoint pairs.  (In the function names, 
I try to remember to use "envelope" to be a list of breakpoints, and "env" to be the result of make-env,
a CLM env structure passed to the env generator).
In an envelope,
the x axis extent
is arbitrary, though it's simplest to use 0.0 to 1.0.  env.scm provides several
envelope functions that are often useful:
</p>
<pre>
  <em class=emdef>envelope-interp</em> x env <i>base</i>
  <em class=emdef>window-envelope</em> beg end env
  <em class=emdef>map-envelopes</em> func env1 env2
  <em class=emdef>multiply-envelopes</em> env1 env2
  <em class=emdef>add-envelopes</em> env1 env2
  <a class=def name="maxenvelope">max-envelope</a> env
  <em class=emdef>min-envelope</em> env
  <em class=emdef>integrate-envelope</em> env
  <em class=emdef>stretch-envelope</em> env old-attack new-attack <i>old-decay new-decay</i>
  <em class=emdef>envelope-last-x</em> env
  <a class=def name="scaleenvelope">scale-envelope</a> env scl <i>(offset 0.0)</i>
  <a class=def name="reverseenvelope">reverse-envelope</a> env
  <a class=def name="concatenateenvelopes">concatenate-envelopes</a> #:rest envs
  <em class=emdef>repeat-envelope</em> env repeats #:optional (reflected #f) (normalized #f)
  <a class=def name="powerenv">power-env</a> e
  <em class=emdef>make-power-env</em> e #:key (scaler 1.0) (offset 0.0) duration
  <em class=emdef>power-env-channel</em> pe #:optional (beg 0) dur snd chn edpos (edname "power-env-channel")
  <em class=emdef>envelope-exp</em> e #:optional (power 1.0) (xgrid 100)
</pre>
<p>These are translated from CLM's env.lisp.
<code>(envelope-interp x env base)</code> returns value of env at x.
If base is 0, env is treated as a step function; if base is 1.0 (the
default), its breakpoints are connected by a straight line, and
any other base connects the breakpoints with a kind of exponential
curve:
</p>
<pre>
:<em class=typing>(envelope-interp .1 '(0 0 1 1))</em>
<em class=listener>0.1</em>
:<em class=typing>(envelope-interp .1 '(0 0 1 1) 32.0)</em>
<em class=listener>0.0133617278184869</em>
:<em class=typing>(envelope-interp .1 '(0 0 1 1) .012)</em>
<em class=listener>0.361774730775292</em>
</pre>
<p>The corresponding function for a CLM env generator is <a href="clm.html#env-interp">env-interp</a>.
If you'd rather think in terms of e^-kt, set the base to (exp k).  
</p>
<p><b>window-envelope</b> returns (as an envelope) the portion of its envelope argument that lies
between the X axis values <i>beg</i> and <i>end</i>.  This is useful when you're treating an
envelope as a phrase-level control, applying successive portions of it to many underlying
notes.
</p>
<pre>
:<em class=typing>(window-envelope 1.0 3.0 '(0.0 0.0 5.0 1.0))</em>
<em class=listener>(1.0 0.2 3.0 0.6)</em>
</pre>
<p><b>map-envelopes</b> applies its <i>func</i> argument to the breakpoints in the two
envelope arguments, returning a new envelope. A simple application of this is
<b>multiply-envelopes</b> which multiplies two envelopes:
</p>
<pre>
:<em class=typing>(multiply-envelopes '(0 0 1 1) '(0 0 1 1 2 0))</em>
<em class=listener>(0 0 0.5 0.5 1 0)</em>
</pre>
<p>As this example shows, the new envelope goes from 0.0 to 1.0 along
the X axis; the multiplied envelopes are stretched or contracted to
fit 0.0 to 1.0, and wherever one has a breakpoint, the corresponding
point in the other envelope is interpolated, if necessary. The code
for multiply envelopes is simply:</p>
<pre>
(define multiply-envelopes
  (lambda (e1 e2)
    (map-envelopes * e1 e2)))
</pre>
<p><b>max-envelope</b> returns the maximum Y value in <i>env</i>, and <b>envelope-last-x</b>
returns the maximum X value:
</p>
<pre>
:<em class=typing>(max-envelope '(0 0 1 1 2 3 4 0))</em>
<em class=listener>3.0</em>
</pre>
<p>Similarly, <b>min-envelope</b> returns the minimum y value.</p>
<p><b>integrate-envelope</b> returns the area under the envelope.
</p>
<pre>
:<em class=typing>(integrate-envelope '(0 0 1 1))</em>
<em class=listener>0.5</em>
:<em class=typing>(integrate-envelope '(0 1 1 1))</em>
<em class=listener>1.0</em>
:<em class=typing>(integrate-envelope '(0 0 1 1 2 .5))</em>
<em class=listener>1.25</em>
</pre>
<p><b>stretch-envelope</b> applies attack and optionally decay times
to an envelope, much like divseg in clm-1.</p>
<pre>
:<em class=typing>(stretch-envelope '(0 0 1 1) .1 .2)</em>
<em class=listener>(0 0 0.2 0.1 1.0 1)</em>
:<em class=typing>(stretch-envelope '(0 0 1 1 2 0) .1 .2 1.5 1.6)</em>
<em class=listener>(0 0 0.2 0.1 1.1 1 1.6 0.5 2.0 0)</em>
</pre>
<p><b>scale-envelope</b> scales the y values of an envelope by <i>scl</i>,
<b>add-envelope</b> adds two envelopes together, <i>reverse-envelope</i>
reverses an envelope.
<b>repeat-envelope</b> repeats an envelope (concatenates copies of itself).
</p>

<table border=0><tr><td>
<pre>
:<em class=typing>(repeat-envelope '(0 0 .1 .9 1 1 1.3 .2 2 0) 2)</em>
<em class=listener>(0 0 0.1 0.9 1.0 1 1.3 0.2 2.0 0 2.1 0.9 3.0 1 3.3 0.2 4.0 0)</em>
</pre>
</td><td><img src="repenv.png">
</td></tr></table>

<p>If the final y value is different from the first y value (as above), a quick ramp is
inserted between repeats. 'normalized' causes the new envelope's x axis
to have the same extent as the original's. 'reflected' causes every other
repetition to be in reverse.
</p>
<p><b>make-power-env</b> and <b>power-env</b> implement an extension of exponential
envelopes; each segment has its own base.  <b>power-env-channel</b> uses the same
mechanism as an extension of env-channel.
</p>
<pre>
(let ((pe (make-power-env '(0 0 32.0  1 1 0.0312  2 0 1) :duration 1.0)))
  (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (lambda (y) (* y (power-env pe)))))

(let ((pe1 (make-power-env '(0 0 32.0  1 1 0.0312  2 0 1.0  3 .5 3.0  4 0 0) :duration 1.0)))
  (power-env-channel pe1))
</pre>
<p><b>envelope-exp</b> interpolates segments into envelope to approximate exponential curves.
</p>
<br>

<A NAME="enveddoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>enved.scm</h2></td></tr></table>
<br>
<img src="envs.png" alt="channel enveds">

<pre>
  <em class=emdef>start-enveloping</em>
  <em class=emdef>stop-enveloping</em>
  <a class=def name="channelenvelope">channel-envelope</a> <i>snd chn</i>
  <A class=def NAME="explaywithenvs">play-with-envs</A> snd
  <A class=def NAME="explaypanned">play-panned</A> snd
</pre>

<p>enved.scm implements an independent envelope editor in each channel.  <code>(start-enveloping)</code>
sets this in progress (for subsequently opened sounds), <code>(stop-enveloping)</code> turns it off.
Each envelope can be read or written via <code>(channel-envelope snd chn)</code>.
There are also two examples that use these envelopes: <b>play-with-envs</b> and
<b>play-panned</b>.  The former sets the channel's amplitude from its envelope
during playback (it should be obvious how to apply the envelope to any of the
control panel fields); the latter pans a mono sound into stereo following
the envelope. The lines:
</p>
<pre>
(define channel-envelope
  (make-procedure-with-setter
    (lambda (snd chn)
      ...)
    (lambda (snd chn new-env)
      ...)))
</pre>
<p>
use a feature of Guile 1.4 that provides a set! function
for channel-envelope.  The first lambda is called if you're
asking for the current value of that channel-envelope:
</p>
<pre>
(channel-envelope s c)
</pre>
<p>and
the second if you're setting it to something new:
</p>
<pre>
(set! (channel-envelope s c) e)
</pre>
<br clear=right>


<A NAME="eventdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>event.scm</h2></td></tr></table>

<p>event.scm has functions used by snd-test.scm to exercise the user interface.
These functions depend on the xm module and XSendEvent primarily, but there are
also Scheme implementations of some of the built-in functions (<a class=quiet href="extsnd.html#windowproperty">window-property</a>).
</p>


<A NAME="exampdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>examp.scm</h2></td></tr></table>

<p>examp.scm has become a bit of a grab-bag; rather than get organized, I just
appended new stuff as it came to mind.  The following documentation is
a quick overview of the code; most of the examples are very simple, so (as
the saying goes) "the code is the documentation".  Also, there's some overlap
between these examples, other .scm files, and discussions in other documents.
I'm slowly dividing out related groups of procedures to separate files.
</p>

<ul>
<li><a href="#ssfilters">filters</a>
<small>
  <ul>
    <li>comb-filter, notch-filter, formant-filter
    <li>time varying FIR filter, notch filter
    <li>filtered-env (low-pass and amplitude follow envelope)
    <li>remove-clicks
  </ul>
</small>
<li><a href="#ssffts">ffts</a>
<small>
  <ul>
    <li>correlation
    <li>set transform-size based on current time domain window size
    <li>superimpose spectra of sycn'd sounds
    <li>fft-edit, fft-env-interp, fft-env-edit -- FFT based editing
    <li>fft-squelch -- noise reduction 
    <li>fft-cancel -- fft as very narrow notch filter
    <li>squelch-vowels -- remove steady-state (or the reverse)
    <li>fft-smoother -- fft-based smoothing
  </ul>
</small>
<li><a href="#ssuserinterface">user-interface</a>
<small>
  <ul>
    <li>XEmacs-like Buffers menu
    <li>Reopen menu
    <li>make dot size dependent on number of samples being displayed
    <li>flash selected data red and green
    <li>add date and time to title bar
    <li>how to get 'display' to write to Snd's listener
    <li>multi-colored rxvt printout
    <li>lisp graph with draggable x axis
    <li>pointer-focus
    <li>files-popup-buffer
    <li>Emacs-like C-x b handling
    <li>open-next-file-in-directory
  </ul>
</small>
<li><a href="#ssmarks">marks</a>
<small>
  <ul>
    <li>use loop info (if any) to set marks at loop points
    <li>move window left edge to mark upon 'm' key
  </ul>
</small>
<li><a href="#ssselections">selections</a>
<small>
  <ul>
    <li>swap selection chans
    <li>replace with selection
    <li>explode soundfont file
  </ul>
</small>
<li><a href="#ssmixes">mixes</a>
<small>
  <ul>
    <li>mix mono sound into stereo sound panning according to env, also simple sound placement
  </ul>
</small>
<li><a href="#sssoundeffects">sound effects</a>
<small>
  <ul>
    <li>echo (delays)
    <li>ring-modulation, am
    <li>src-related sound effects (src, rand-interp, etc)
    <li>compand, compand-channel (<a class=quiet href="clm.html#array-interp">array-interp</a>)
    <li>shift pitch keeping duration constant (src+granulate)
    <li>tempo change via envelope (<a class=quiet href="clm.html#granulate">granulate</a>)
    <li>cross-synthesis (using a formant bank)
    <li>voiced-&gt;unvoiced (formants)
    <li>convolution (<a class=quiet href="clm.html#convolve">convolve</a>)
    <li>"vector synthesis"
    <li>chain-dsps
  </ul>
</small>
<li><a href="#ssmiscellaneousextensions">miscellaneous extensions</a>
<small>
  <ul>
    <li>'info' from extsnd.html using format
    <li>make a system call
    <li>documentation examples made harder to break
    <li>example of c-g?
    <li>translate mpeg input to 16-bit linear and read into Snd
    <li>read and write OGG files
    <li>read and write Speex files
    <li>read and write FLAC files
    <li>mapping extensions (map arbitrary single-channel function over various channel collections)
    <li>sound-interp, env-sound-interp
    <li>searching procedures (search-for-click, find-pitch, zero+, next-peak)
    <li>sound-data-&gt;list
    <li>smooth-channel-via-ptree -- smooth-channel as virtual op
    <li>ring-modulate-channel -- ring-modulation as virtual op
  </ul>
</small>
</ul>



<!-- -------------------------------- FILTERS -------------------------------- -->
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="ssfilters">filters</a></h3></td></tr></table>

<pre>
  <em class=emdef>comb-filter</em> scaler size
  <em class=emdef>comb-chord</em> scaler size amp
  <em class=emdef>zcomb</em> scaler size pm
  <em class=emdef>notch-filter</em> scaler size
  <em class=emdef>formant-filter</em> radius frequency
  <em class=emdef>formants</em> r1 f1 r2 f2 r3 f3
  <em class=emdef>moving-formant</em> radius move-envelope
  <em class=emdef>osc-formants</em> radius bases amounts freqs
  <A class=def NAME="exremoveclick">remove-click</a>
</pre>
<p>The two versions of <b>comb-filter</b> implement a comb filter,
"by hand" and using CLM. <b>comb-chord</b> uses comb filters at harmonically
related sizes to create a chord (see also chordalize in new-effects.scm).  <i>amp</i>
here is an overall amplitude scaler.  <b>zcomb</b> is a time-varying comb
filter using the envelope <i>pm</i>.  <b>notch-filter</b> parallels comb-filter.
<b>formant-filter</b> applies a formant to its input.
Some examples:
</p>
<pre>
(<a class=quiet href="extsnd.html#mapchan">map-chan</a> (comb-filter .8 32))
(<a class=quiet href="extsnd.html#mapchan">map-chan</a> (comb-chord .95 100 .3))
(<a class=quiet href="extsnd.html#mapchan">map-chan</a> (comb-chord .95 60 .3))
(<a class=quiet href="extsnd.html#mapchan">map-chan</a> (zcomb .8 32 '(0 0 1 10)))
(<a class=quiet href="extsnd.html#mapchan">map-chan</a> (notch-filter .8 32))
(<a class=quiet href="extsnd.html#mapchan">map-chan</a> (formant-filter .99 2400))
</pre>
<p>In all these cases, however, it's actually much faster to pass the
filter to filter-sound:</p>
<pre>
(<a class=quiet href="extsnd.html#filtersound">filter-sound</a> (<a class=quiet href="clm.html#make-formant">make-formant</a> .99 2400))
</pre>
<p><b>formants</b> applies three formants in parallel.
<b>moving-formant</b> moves a formant according to an envelope.
<b>osc-formants</b> sets up any number of independently oscillating formants.
</p>
<pre>
(<a class=quiet href="extsnd.html#mapchan">map-chan</a> (formants .99 900 .98 1800 .99 2700))
(<a class=quiet href="extsnd.html#mapchan">map-chan</a> (moving-formant .99 '(0 1200 1 2400)))
(<a class=quiet href="extsnd.html#mapchan">map-chan</a> (osc-formants .99 '(400 800 1200) '(400 800 1200) '(4 2 3)))
</pre>
<pre>
  <em class=emdef>filtered-env</em> envelope
</pre>
<p><b>filtered-env</b> creates an amplitude envelope and a one-pole
filter, and moves them in parallel over a sound; 
as the sound gets softer, the low-pass filter's cutoff frequency
gets lower, a sort of poor-man's distance effect.  When <i>envelope</i>
is at 1.0, no filtering takes place.
</p>
<pre>
  <em class=emdef>fltit</em>
  <em class=emdef>remove-clicks</em>
</pre>
<p><b>fltit</b> is a simple FIR filter call.
<b>remove-clicks</b> looks for obvious clicks and uses smooth-sound to remove them.
</p>

<!-- -------------------------------- FFTS -------------------------------- -->
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="ssffts">ffts</a></h3></td></tr></table>
<pre>
  <A class=def NAME="excorrelate">correlate</a> snd chn y0 y1
  <a class=def name="exsuperimposeffts">superimpose-ffts</a> snd chn y0 y1
  <a class=def name="exfftedit">fft-edit</a> low-freq high-freq
  <A class=def NAME="exfftenvedit">fft-env-edit</a> env
  <A class=def NAME="exfftenvinterp">fft-env-interp</a> env1 env2 interp
  <a class=def name="exfftsquelch">fft-squelch</a> squelch
  <A class=def NAME="exfftcancel">fft-cancel</a> lo-freq hi-freq
  <em class=emdef>squelch-vowels</em>
  <A class=def NAME="exfftsmoother">fft-smoother</a> cutoff start samps snd chn
</pre>
<p><b>correlate</b> graphs the correlation of <i>snd</i>'s 2 channels.
To make this happen automatically as you move the time domain position
slider, <code>(add-hook! graph-hook correlate)</code>.
<b>superimpose-ffts</b> is a similar graph-hook function that
superimposes the ffts of multiple (syncd) sounds.
<b>fft-edit</b> is a simple example of fft-based editing.
It takes an fft of the entire sound, removes all energy below <i>low-freq</i> and above <i>high-freq</i>,
then inverse fft's. <b>fft-env-edit</b> is the same, but applies an envelope to the spectral magnitudes;
<b>fft-env-interp</b> takes two such filtered versions and mixes them following the interpolation
envelope. Another similar function is <b>fft-smoother</b> that uses fft-filtering to
smooth a portion of a sound.
<b>fft-squelch</b> is similar, but removes all energy below the squelch amount (normalized to
be between 0.0 and 1.0).  This is sometimes useful for noise-reduction.
<b>fft-cancel</b> ffts an entire sound, sets the bin(s) representing lo-freq to hi-freq to 0.0, then inverse ffts,
giving a high quality notch filter.
<b>squelch-vowels</b> uses fft data to distinguish the steady state portion (a vowel in speech) from
noise (a consonant, sometimes), and does whatever you want based on that (remove vowels, remove
consonants, make consonants louder, etc).
Finally there are two examples
of using graph-hook to set the fft size based on the current time domain window
size.  The simpler one is:
</p>
<pre>
(add-hook! <a class=quiet href="extsnd.html#graphhook">graph-hook</a> 
	   (lambda (snd chn y0 y1)
	     (if (and (<a class=quiet href="extsnd.html#transformgraphp">transform-graph?</a> snd chn) 
                      (= (<a class=quiet href="extsnd.html#transformgraphtype">transform-graph-type</a> snd chn) <a class=quiet href="extsnd.html#transformgraphtype">graph-once</a>))
		 (begin
		   (set! (<a class=quiet href="extsnd.html#lfftsize">transform-size</a> snd chn)
			 (expt 2 (ceiling 
				  (/ (log (- (<a class=quiet href="extsnd.html#rightsample">right-sample</a> snd chn) (<a class=quiet href="extsnd.html#leftsample">left-sample</a> snd chn))) 
				     (log 2.0)))))
		   (set! (<a class=quiet href="extsnd.html#spectrocutoff">spectro-cutoff</a> snd chn) (<a class=quiet href="extsnd.html#yzoomslider">y-zoom-slider</a> snd chn))))))

</pre>
<p>The <i>expt...</i> code is rounding the current window size (<a class=quiet href="extsnd.html#rightsample">right-sample</a> - left-sample)
up to the nearest power of 2. 
</p>

<!-- -------------------------------- USER-INTERFACE -------------------------------- -->
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="ssuserinterface">user-interface</a></h3></td></tr></table>

<p><b>show-draggable-graph</b>, in imitation of Snd's FFT display, implements a
draggable X axis in the lisp graph window.  (This is slightly messier than
it ought to be).
Two of the examples are imitations of Xemacs: a Buffers menu and an auto-save hook (now in <a href="#autosavedoc">autosave.scm</a>).</p>
<pre>
  <A class=def NAME="exopenbuffer">open-buffer</a> filename
  <em class=emdef>close-buffer</em> snd
</pre>

<p>The Buffers menu provides a list of currently open sounds; selecting one
in the menu causes it to become the selected sound; <b>open-buffer</b>
adds a menu item that will select a file, <b>close-buffer</b> removes it.
To activate this, we need
to:
</p>
<pre>
(add-hook! <a class=quiet href="extsnd.html#openhook">open-hook</a> open-buffer)
(add-hook! <a class=quiet href="extsnd.html#closehook">close-hook</a> close-buffer)
</pre>

<p>A similar menu is the "reopen menu"; it presents a list of previously
closed (and not subsequently re-opened) files in reverse order of closing.
</p>

<pre>
  <em class=emdef>snd-out</em>
</pre>
<p>A minor irritation in the current Guile system is that Scheme's "display" function
writes to <i>current-output-port</i>, but there's no simple way to redirect that
elsewhere (and with-output-to-string is not completely integrated with
Guile's help system).  So, if your code calls display, the result may be invisible.
One way around this is to reset the current-output-port to be a soft port
that actually calls <a href="extsnd.html#sndprint">snd-print</a> instead:
</p>
<pre>
(define stdout (current-output-port)) ;save it in case we want to go back to it
(define snd-out
  (make-soft-port
   (vector                      ;soft port is a vector of procedures:
    (lambda (c) (<a class=quiet href="extsnd.html#sndprint">snd-print</a> c))  ;  procedure accepting one character for output 
    (lambda (s) (<a class=quiet href="extsnd.html#sndprint">snd-print</a> s))  ;  procedure accepting a string for output 
    (lambda () #f)              ;  thunk for flushing output (not needed here)
    #f                          ;  thunk for getting one character (also not needed)
    (lambda () #f))             ;  thunk for closing port -- hmm should this go back to the previous?
   "w"))
(set-current-output-port snd-out)
</pre>
<p>You could also <code>(set! display snd-print)</code>, if you're willing to
live dangerously; this replaces Guile's built-in <i>display</i> procedure with
Snd's <i>snd-print</i>.
</p>

<p>There are also a few brief examples showing simple display customizations.
The following makes the graph dot size dependent on the
number of samples in the graph:
</p>
<pre>
  <em class=emdef>auto-dot</em> snd chn y0 y1

(add-hook! <a class=quiet href="extsnd.html#graphhook">graph-hook</a> auto-dot)
</pre>
<p>There are also examples tying the channel graph sliders to the fft display.
Finally there are several somewhat frivolous examples:
</p>
<pre>
  <A class=def NAME="titlewithdate">title-with-date</a>
  <em class=emdef>flash-selected-data</em> time-interval
</pre>
<p><code>(title-with-date)</code> adds a clock to the Snd window's title bar.
Set the variable <i>retitle-time</i> to 0 to turn this off.
<b>flash-selected-data</b> cause the selected channel's graph to
flash red and green.  And the there are functions to display colored text
in rxvt:
</p>
<pre>
(display (format #f "~Athis is red!~Abut this is not" red-text normal-text))
(display (format #f "~A~Ahiho~Ahiho" yellow-bg red-fg normal-text))
</pre>
<p>It's possible to use the same escape sequences in a normal shell script, of course:
</p>
<pre>
echo '\e[41m This is red! \e[0m'
</pre>
<br>
<pre>
  <em class=emdef>files-popup-buffer</em>
</pre>
<p>This is a mouse-enter-label-hook function for the View:Files dialog;
it hides all sounds but the one the mouse is pointing to in the current files list.
The pointer-focus style of interaction uses similar hooks.  There is also
a first stab at Emacs-like C-x b support here; the file name in the prompt
should be a string (i.e. in quotes), unlike Emacs.  This still needs work
especially for multichannel sounds.
</p>
<pre>
  <em class=emdef>open-next-file-in-directory</em>
</pre>
<p>This is a mouse-click-hook function. If you call</p>
<pre>
(click-middle-button-to-open-next-file-in-directory)
</pre>
<p>it sets up the mouse-click-hook and open-hook so that clicking the middle
mouse button closes the current file and opens for the next (alphabetical
by filename) in the current directory.
</p>


<!-- -------------------------------- MARKS -------------------------------- -->
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="ssmarks">marks</a></h3></td></tr></table>

<p><a href="#marksdoc">marks.scm</a> has most of the mark-related extensions.
The two in examp.scm are:
</p>
<pre>
  <em class=emdef>first-mark-in-window-at-left</em>
  <a class=def name="exmarkloops">mark-loops</a>

(<a class=quiet href="extsnd.html#bindkey">bind-key</a> (char-&gt;integer #\l) 0 
          (lambda () "move window to align with mark"
            (first-mark-in-window-at-left)))
</pre>
<p><b>first-mark-in-window-at-left</b> moves the (time domain) 
graph so that the leftmost visible mark is at the left edge;
<b>mark-loops</b> places marks at any loop points found in the selected sound's header.
Only a few headers support loop points (these are apparently used in synthesizers
to mark portions of a waveform that can be looped without causing clicks, thereby lengthening
a sound as a key is held down). 
</p>

<!-- -------------------------------- SELECTIONS -------------------------------- -->
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="ssselections">selections</a></h3></td></tr></table>

<pre>
  <em class=emdef>all-chans</em>
  <a class=def name="exswapselectionchannels">swap-selection-channels</a>
  <em class=emdef>selection-rms-1</em>
  <A class=def NAME="exselectionrms">selection-rms</a>
  <A class=def NAME="exregionrms">region-rms</a> <i>region</i>
  <A class=def NAME="exreplacewithselection">replace-with-selection</a>
  <a class=def name="exexplodesf2">explode-sf2</a>
</pre>
<p>
<b>swap-selection-channels</b> swaps the currently selected data's channels.
The various rms functions return the rms value of the desired data in a variety
of ways. The fastest and simplest uses CLM's dot-product function:
</p>
<pre>
(define (region-rms n)
  "(region-rms n) -&gt; rms of region n's data (chan 0)"
  (if (<a class=quiet href="extsnd.html#regionok">region?</a> n)
      (let* ((data (<a class=quiet href="extsnd.html#regionsamples_to_vct">region-samples-&gt;vct</a> 0 0 n)))
	(sqrt (/ (<a class=quiet href="clm.html#dot-product">dot-product</a> data data) (<a class=quiet href="extsnd.html#vctlength">vct-length</a> data))))
      (throw 'no-such-region (list "region-rms" n))))
</pre>
<p><b>replace-with-selection</b> replaces data at the cursor with the
current selection.  <b>explode-sf2</b> turns a soundfont file (assuming it
is the currently selected sound) into a bunch of files of the form sample-name.aif.
</p>



<!-- -------------------------------- MIXES -------------------------------- -->
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="ssmixes">mixes</a></h3></td></tr></table>

<p><a href="#mixdoc">mix.scm</a> has mix and track related functions.
</p>
<pre>
  <A class=def NAME="placesound">place-sound</a> mono-snd stereo-snd panning-envelope-or-degree
</pre>
<p>If <i>panning-envelope-or-degree</i> is a number (in degrees),
the <b>place-sound</b> function has the same effect as using
CLM's locate generator; it mixes a mono sound into a stereo sound, splitting 
it into two copies whose amplitudes depend on the desired location.
0 degrees: all in channel 0, 90: all in channel 1.
If <i>panning-envelope-or-degree</i> is an envelope,
the split depends on the panning envelope (0 = all in chan 0, etc).
</p>
<table border=3 bordercolor="tan" hspace=40><tr><td>
<blockquote><small>
<br>
Panning or Sound Placement<br>
Place sound: <a href="#placesound">place-sound</a> above.<br>
Pan mix: <a href="#panmix">pan-mix</a>, or via the amplitude and envelope controls in the mix dialog<br>
Place mix: <a href="grfsnd.html#musmix">mus-mix</a><br>
Play sound with panning: <a href="#explaypanned">play-panned</a><br>
CLM placement generator: <a href="clm.html#locsig">locsig</a><br>
CLM moving sound generator: <a href="#dlocsigdoc">dlocsig</a><br>
Move sound via flanging: see flanging effect in new-effects.scm<br>
Cross fade in frequency domain: <a href="#fadedoc">fade.scm</a><br>
<br>
</small></blockquote>
</td></tr></table>
<br>

<!-- -------------------------------- SOUND EFFECTS -------------------------------- -->
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="sssoundeffects">sound effects</a></h3></td></tr></table>

<p>Most of these sound effects are based on CLM generators.
</p>
<pre>
  <em class=emdef>echo</em> scaler secs
  <em class=emdef>zecho</em> scaler secs frq amp      ; modulated echo
  <em class=emdef>flecho</em> scaler secs             ; filtered echo
  <em class=emdef>ring-mod</em> freq gliss-env        ; ring-modulation
  <em class=emdef>am</em> freq                        ; amplitude modulation
  <A class=def NAME="exhellodentist">hello-dentist</a> frq amp          ; randomized sampling rate changes
  <A class=def NAME="exfp">fp</a> sr osamp osfrq              ; osc-driven src ("Forbidden Planet")
  <em class=emdef>compand</em>
  <a class=def name="excompandchannel">compand-channel</a> beg dur snd chn edpos
  <A class=def NAME="exexpsrc">expsrc</a> rate snd chn
  <A class=def NAME="exexpsnd">expsnd</a> rate-envelope
  <a class=def name="excrosssynthesis">cross-synthesis</a> cross-snd amp fftsize radius
  <a class=def name="exvoiced2unvoiced">voiced-&gt;unvoiced</a> amp fftsize r tempo
  <em class=emdef>cnvtest</em> snd0 snd1 amp
  <em class=emdef>"vector synthesis"</em>	
  <em class=emdef>chain-dsps</em> beg dur #:rest dsps
</pre>
<p><b>expsrc</b> uses sampling rate conversion (the src gen) and granular synthesis (<a class=quiet href="clm.html#granulate">granulate</a>)
to lengthen or shorten a sound without changing its pitch.  The same idea is used in the effects menu.
<b>expsnd</b> is the same but the
change follows an envelope.  In <b>cross-synthesis</b>, <i>cross-snd</i> is the index
of the sound that controls the spectra, not the affected sound.  <b>voiced-&gt;unvoiced</b>
is essentially the same idea, but drives the synthesis with white noise.
<b>cnvtest</b> demonstrates convolution.
Here are some sample calls:
</p>
<pre>
(<a class=quiet href="extsnd.html#mapchan">map-chan</a> (echo .5 .5) 0 44100)
(<a class=quiet href="extsnd.html#mapchan">map-chan</a> (zecho .5 .75 6 10.0) 0 65000)
(<a class=quiet href="extsnd.html#mapchan">map-chan</a> (flecho .5 .9) 0 75000)
(<a class=quiet href="extsnd.html#mapchan">map-chan</a> (ring-mod 100 '(0 0 1 0)))
(<a class=quiet href="extsnd.html#mapchan">map-chan</a> (ring-mod 10 (list 0 0 1 (<a class=quiet href="clm.html#hz-&gt;radians">hz-&gt;radians</a> 100))))
(<a class=quiet href="extsnd.html#mapchan">map-chan</a> (am 440))
(hello-dentist 40.0 .1)
(fp 1.0 .3 20)
(<a class=quiet href="extsnd.html#mapchan">map-chan</a> (compand))
(expsnd '(0 1 2 .4))
(expsnd '(0 .5 2 2.0))
(<a class=quiet href="extsnd.html#mapchan">map-chan</a> (cross-synthesis 1 .5 128 6.0))
(voiced-&gt;unvoiced 1.0 256 2.0 2.0)
(cnvtest 0 1 .1)
</pre>
<p>There are lots more sound effects scattered around the Snd distribution.
"vector synthesis" cycles through a collection of incoming audio streams, playing whatever
happens to be on the chosen one, with fade-ins and fade-outs to avoid clicks.
<b>chain-dsps</b> creates a patch of chained generators from its arguments.
</p>


<!-- -------------------------------- MISCELLANEOUS EXTENSIONS -------------------------------- -->
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="ssmiscellaneousextensions">miscellaneous extensions</a></h3></td></tr></table>

<pre>
  <em class=emdef>finfo</em> filename
  <em class=emdef>shell</em> cmd
  <a class=def name="exmpg">mpg</a> mpgfile rawfile 
  <em class=emdef>read-ogg</em> file
  <em class=emdef>write-ogg</em> snd
  <em class=emdef>read-speex</em> file
  <em class=emdef>write-speex</em> snd
  <em class=emdef>read-flac</em> file
  <em class=emdef>write-flac</em> snd
</pre>
<p><b>finfo</b> returns a description of the file <i>filename</i>. <b>shell</b> is similar
to Guile's <i>system</i> function, but output is sent to Snd's listener, rather than stdout.
<b>mpg</b> uses the system function to call the program mpg123 to translate an MPEG
format sound file to a headerless ("raw") file containing 16-bit samples.
</p>
<pre>
(shell "df")
(add-hook! <a class=quiet href="extsnd.html#closehook">close-hook</a> (lambda (snd) (shell \"sndplay wood16.wav\")))
(mpg "mpeg.mpg" "mpeg.raw")
</pre>
<p>
Presumably a similar function could be written to call TiMidity to translate
MIDI files to something Snd can read, but I'm not having any luck getting it
to work. OGG Vorbis files can be handled in a similar manner: see read-ogg and
write-ogg.  For Speeex files: read-speex and write-speex. For FLAC files:
read-flac and write-flac.
</p>
<p>
Several of the functions in this section are slight robustifications of the
corresponding code in extsnd.html.  These include:
</p>
<pre>
  <em class=emdef>do-chans</em> func origin
  <em class=emdef>do-all-chans</em> func origin
  <em class=emdef>do-sound-chans</em> func origin
  <em class=emdef>update-graphs</em>
  <a class=def name="exeverysample">every-sample?</a> func
  <em class=emdef>sort-samples</em> bins
  <a class=def name="exwindowsamples">window-samples</a> <i>snd chn</i>
  <em class=emdef>display-energy</em> snd chn y0 y1
  <em class=emdef>window-rms</em>
  <em class=emdef>fft-peak</em> snd chn scale
</pre>
<p>
<b>do-chans</b> applies <i>func</i> to all syncd channels using <i>origin</i> as the edit history indication.
<b>do-all-chans</b> is the same but applies <i>func</i> to all active channels.
<b>do-sound-chans</b> applies <i>func</i> to all selected channels.
<b>update-graphs</b> updates (redraws) all graphs.
<b>every-sample?</b> applies <i>func</i> to each sample in the current channel and returns
#t if <i>func</i> is not #f for all samples; otherwise it moves the cursor to the first offending sample.
<b>sort-samples</b> provides a histogram of the samples (by amplitude) in <i>bins</i> bins.
<b>window-samples</b> returns (via the function <a href="extsnd.html#samples">samples</a>) the samples
displayed in the current window for <i>snd</i>'s channel <i>chn</i>.
<b>display-energy</b> is a graph-hook function to display the time domain data squared.
<b>window-rms</b> returns the rms of the data in currently selected graph window.
<b>fft-peak</b> is a transform-hook function that returns the peak spectral magnitude.
</p>
<pre>
  <em class=emdef>locate-zero</em> limit
</pre>
<p>
<b>locate-zero</b> looks for the next sample where adjacent samples together are less than <i>limit</i>
and moves the cursor to that sample. It can be interrupted by C-g.
</p>
<pre>
  <em class=emdef>make-sound-interp</em> start #:optional snd chn
  <a class=def name="exsoundinterp">sound-interp</a> reader loc
  <a class=def name="exenvsoundinterp">env-sound-interp</a> envelope #:optional (time-scale 1.0) snd chn
</pre>
<p><b>make-sound-interp</b> returns an interpolating reader for <i>snd</i>'s channel <i>chn</i>.
The interpolating reader reads a channel at an arbitary location,
interpolating between samples if necessary.  The corresponding generator is <b>sound-interp</b>.
The function <b>test-interp</b> shows one way to use this, using a sine wave to lookup the
current sound.
<b>env-sound-interp</b> reads <i>snd</i>'s channel <i>chn</i> (via a sound-interp generator)
according to <i>envelope</i> and <i>time-scale</i>.
It takes an envelope that goes between 0 and 1 (y-axis), and a time-scaler
(1.0 = original length) and returns a new version of the data in the specified channel
that follows that envelope (that is, when the envelope is 0 we get sample 0, when the
envelope is 1 we get the last sample, envelope = .5 we get the middle sample of the 
sound and so on). <code>(env-sound-interp '(0 0 1 1))</code> returns a copy of the
current sound; <code>(env-sound-interp '(0 0 1 1 2 0) 2.0)</code> returns a new sound 
with the sound copied first in normal order, then reversed.  src-sound with an
envelope could be used for this effect, but it is much more direct to apply the
envelope to sound sample positions.  A similar function is <a href="#scratch">scratch</a> in clm-ins.scm.
</p>
<pre>
  <A class=def NAME="exsearchforclick">search-for-click</a>
  <A class=def NAME="exzeroplus">zero+</a>
  <em class=emdef>next-peak</em>
  <em class=emdef>find-pitch</em> pitch
</pre>
<p>These are examples of searching procedures (to be used with C-s and so on).  <b>zero+</b> finds the next
positive-going zero crossing (if searching forwards), <b>next-peak</b> finds
the next max or min in the waveform, and <b>find-pitch</b> finds the next
place where the given pitch is predominate.
</p>
<pre>
  <em class=emdef>sound-data-&gt;list</em> sdata
</pre>
<p>This converts a sound-data object into a list of lists, each inner list
holding the samples of one channel.
</p>
<pre>
  <em class=emdef>smooth-channel-via-ptree</em> #:optional beg dur snd chn edpos
  <em class=emdef>ring-modulate-channel</em> freq #:optional beg dur snd chn edpos
</pre>
<p>The first is <a href="extsnd.html#smoothchannel">smooth-channel</a> as a virtual op,
and the second applies ring-modulation (multiplication by a sine wave, similar to 
Craig Sapp's ring-modulate.ins in CLM), also as a virtual op.
</p>
<br>

<A NAME="extensionsdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>extensions.scm, extensions.rb</h2></td></tr></table>

<p>These were originally scattered around examp.scm; I thought it would be more
convenient if they were in one file.
</p>

<pre>
  <a class=def name="exchannelproperty">channel-property</a> key snd chn
  <a class=def name="exsoundproperty">sound-property</a> key snd
  <a class=def name="channelsync">channel-sync</a> snd chn

  <a class=def name="exmakeselection">make-selection</a> beg end snd chn
  <a class=def name="exdeleteselectionandsmooth">delete-selection-and-smooth</a>
  <a class=def name="exevaloverselection">eval-over-selection</a> func #:optional snd
  <a class=def name="exselectionmembers">selection-members</a>

  <a class=def name="exmapsoundfiles">map-sound-files</a> func #:optional dir
  <a class=def name="exforeachsoundfile">for-each-sound-file</a> func #:optional dir
  <a class=def name="exmatchsoundfiles">match-sound-files</a> func #:optional dir

  <a class=def name="exnormalizedmix">normalized-mix</a> filename beg in-chan snd chn
  <a class=def name="exenvelopedmix">enveloped-mix</a> filename beg env
  <em class=emdef>enveloped-mix-1</em> filename beg env

  <a class=def name="exunsavededits">check-for-unsaved-edits</a> #:optional (check #t)
  <a class=def name="exremembersoundstate">remember-sound-state</a>

  <a class=def name="mixchannel">mix-channel</a> filedat #:optional beg dur snd chn edpos
  <a class=def name="insertchannel">insert-channel</a> filedat #:optional beg dur snd chn edpos
  <em class=emdef>redo-channel</em> #:optional (edits 1) snd chn
  <em class=emdef>undo-channel</em> #:optional (edits 1) snd chn

  <a class=def name="anyenvchannel">any-env-channel</a> env func #:optional beg dur snd chn edpos
  <a class=def name="sineramp">sine-ramp</a> a0 a1 #:optional beg dur snd chn edpos
  <a class=def name="sineenvchannel">sine-env-channel</a> env #:optional beg dur snd chn edpos
  <A class=def NAME="blackman4ramp">blackman4-ramp</A> a0 a1 #:optional beg dur snd chn edpos
  <A class=def NAME="blackman4envchannel">blackman4-env-channel</A> env #:optional beg dur snd chn edpos
  <A class=def NAME="rampsquared">ramp-squared</A> a0 a1 #:optional (symmetric #t) beg dur snd chn edpos
  <A class=def NAME="envsquaredchannel">env-squared-channel</A> env #:optional (symmetric #t) beg dur snd chn edpos
  <A class=def NAME="rampexpt">ramp-expt</A> a0 a1 exponent #:optional (symmetric #t) beg dur snd chn edpos
  <a class=def name="envexptchannel">env-expt-channel</a> env exponent #:optional (symmetric #t) beg dur snd chn edpos

  <a class=def name="offsetchannel">offset-channel</a> amount #:optional beg dur snd chn edpos	
  <a class=def name="ditherchannel">dither-channel</a> #:optional (amount .00006) beg dur snd chn edpos	
  <a class=def name="contrastchannel">contrast-channel</a> index #:optional beg dur snd chn edpos
  <a class=def name="channelsequal">channels-equal?</a> snd1 chn1 snd2 chn2 allowable-difference	
  <a class=def name="channels=">channels=?</a> snd1 chn1 snd2 chn2 allowable-difference	
</pre>

<p><b>channel-property</b> returns the value associated with <i>key</i> in the given channel's
property list.  To add or change a property, use set! with this procedure.  Similarly,
<b>sound-property</b> provides access to a sound's property list.
These properties are normally saved when Snd's state is saved (via <a href="extsnd.html#savestate">save-state</a>
or the Options:Save State menu).  To omit a given property at that time, add its name (a symbol) to
the property 'save-state-ignore (a list of symbols); see 'inset-envelope in extensions.scm.
<b>channel-sync</b> uses the channel-properties list to implement a channel-local sync field.
</p>

<p><b>selection-members</b> returns a list of lists of (snd chn) indicating the channels participating in the current selection.
It is very similar to <b>all-chans</b> which returns a list of lists of all (snd chn)'s.
<b>delete-selection-and-smooth</b> deletes the current selection and smooths the splice.
</p>

<p><b>eval-over-selection</b> evaluates <i>func</i> on each sample in the current selection. A better
name might be map-selection.
The code:
</p>
<pre>
(<a class=quiet href="extsnd.html#bindkey">bind-key</a> (char-&gt;integer #\x) 4
	  (lambda () "eval over selection"
	    (if (<a class=quiet href="extsnd.html#selectionok">selection?</a>)
		(<a class=quiet href="extsnd.html#promptinminibuffer">prompt-in-minibuffer</a> "selection eval:" eval-over-selection)
		(<a class=quiet href="extsnd.html#reportinminibuffer">report-in-minibuffer</a> "no selection")))
	  #t)
</pre>
<p>binds the key sequence C-x x to a function that checks for an active selection,
then prompts (in the minibuffer) for the function to apply, and when
you eventually reply with a function, applies that function
to each sample in the selection.
make-selection makes a selection (like make-region but without creating
a region).
</p>
<p>
<b>map-sound-files</b> applies <i>func</i> to each sound file in <i>dir</i>.
The <i>func</i> is passed one argument, the sound file name.
<b>match-sound-files</b> applies <i>func</i> to each sound file in <i>dir</i> and returns a list of files for which func does not return #f.
</p>
<pre>
(for-each-sound-file
  (lambda (n) 
    (if (&gt; (<a class=quiet href="extsnd.html#soundduration">mus-sound-duration</a> n) 10.0) 
      (<a class=quiet href="extsnd.html#sndprint">snd-print</a> n)))
  (<a class=quiet href="extsnd.html#soundfilesindirectory">sound-files-in-directory</a> "."))
</pre>
<p>We can use Guile's regexp support here to search for all .snd and .wav files:
</p>
<pre>
(let ((reg (make-regexp "\\.(wav|.snd)$")))
  (match-sound-files (lambda (file) (regexp-exec reg file))))
</pre>
<p>In fact, we could replace the built-in procedures <A class=def NAME="addsoundextension1">add-sound-file-extension</a> and
sound-files in directory.  We're using some procedures written by Dirk Herrman here.
</p>
<pre>
(define (filter-list pred? objects)
  (let loop ((objs objects)
	     (result '()))
    (cond ((null? objs) (reverse! result))
	  ((pred? (car objs)) (loop (cdr objs) (cons (car objs) result)))
	  (else (loop (cdr objs) result)))))

(define (grep rx strings)
  (let ((r (make-regexp rx)))
    (filter-list (lambda (x) (regexp-exec r x)) strings)))

(define (directory-&gt;list dir)
  (let ((dport (opendir dir)))
    (let loop ((entry (readdir dport))
	       (files '()))
      (if (not (eof-object? entry))
	  (loop (readdir dport) (cons entry files))
	  (begin
	    (closedir dport)
	    (reverse! files))))))

;;; and now the Snd replacements
(define sound-file-extensions (list "snd" "aiff" "aif" "wav" "au" "aifc" "voc" "wve"))

(define (add-sound-file-extension-1 ext) 
  (set! sound-file-extensions (cons ext sound-file-extensions)))

(define* (sound-files-in-directory-1 #:optional (dir "."))
  (sort (grep
	 (format #f "\\.(~{~A~^|~})$" sound-file-extensions)
	 (directory-&gt;list dir))
	string&lt;?))
</pre>

<p><b>normalized-mix</b> is like <a href="extsnd.html#mix">mix</a> but the mixed result has same peak amplitude as the 
original data. <b>enveloped-mix</b> is like <a href="#mixsound">mix-sound</a>, but includes an
amplitude envelope over the mixed-in data.
</p>
<pre>
(enveloped-mix "pistol.snd" 0 '(0 0 1 1 2 0))
</pre>
<p><b>check-for-unsaved-edits</b> adds functions to the exit-hook and close-hook to check
for unsaved edits before exiting Snd or closing a file.  If its argument is #f, it removes
those hooks.
</p>
<p><b>remember-sound-state</b> saves most of a sound's display state when it is closed,
and if that same sound is subsquently re-opened, restores the previous state.
</p>

<p><b>mix-channel</b> is a regularized version of the file mixing functions (<a class=quiet href="extsnd.html#mix">mix</a> and mix-sound).
It's first argument can be either a filename (a string) or a list containing the filename, the
start point in the file, and (optionally) the channel of the file to mix:
</p>
<pre>
  (mix-channel "pistol.snd")
  (mix-channel "pistol.snd" 10000)       ; mixing starts at sample 10000 in current sound
  (mix-channel (list "pistol.snd" 1000)) ; mixed data starts at sample 1000 in pistol.snd
  (mix-channel (list "2.snd" 0 1))       ; mixed data reads channel 1 in 2.snd
</pre>
<p><b>insert-channel</b> is the same as mix-channel, but inserts the specified data.
</p>

<p><b>redo-channel</b> and <b>undo-channel</b> are regularized versions of
<a href="extsnd.html#redo">redo</a> and <a href="extsnd.html#undo">undo</a>.
<b>offset-channel</b> adds a constant to a sound, using <a href="extsnd.html#ptreechannel">ptree-channel</a>.
<b>dither-channel</b> adds "dithering" (noise) which supposedly makes everything copacetic.
<b>contrast-channel</b> is the CLM <a href="clm.html#contrast-enhancement">contrast-enhancement</a> function,
equivalent to the control panel Contrast slider.
<b>channels=?</b> returns #t is the two specified channels are the same within the
given tolerance (which can be 0.0).  <b>channels-equal?</b> returns #t if channels=?
and the channels are the same length.  In the "=" case, the trailing (extra) samples
in one channel are checked against 0.0.
</p>
<p>
<b>any-env-channel</b> takes an envelope and a function to produce the connection between successive
breakpoints, and applies the two to the current channel as an envelope.  This packages up most of
the "boilerplate" associated with applying an envelope to a sound.  It is used by the other three
enveloping functions, sine-env-channel, blackman4-env-channel, and env-squared-channel.
<b>sine-ramp</b> and <b>sine-env-channel</b> are the sinusoidal versions of <a href="extsnd.html#rampchannel">ramp-channel</a>
and <a href="extsnd.html#envchannel">env-channel</a>.
<code>(sine-env-channel '(0 0 1 1 2 -.5 3 1))</code> applies the given envelope to the current channel,
connecting the points with a sinusoidal curve.  It uses <a href="extsnd.html#ptreechannel">ptree-channel</a>,
so it's just as fast as env-channel.  Similarly, <b>blackman4-env-channel</b> connects the dots with
a sum of cosines, and <b>env-squared-channel</b> connects the dots with an x^2 curve.  For any
positive exponent, use <b>env-expt-channel</b>.  The <i>symmetric</i> argument determines whether the
up and down moving ramps look symmetrical around a break point.
</p>

<!--
(env-channel '(0 0 1 1 2 -.75 3 0)) 
(env-sound '(0 0 1 1 2 -.75 3 0) 0 100 32.0)  
(env-sound '(0 0 1 1 2 -.75 3 0) 0 100 .032) 
(env-sound '(0 0 1 1 2 -.75 3 0) 0 100 0.0)
(sine-env-channel '(0 0 1 1 2 -.75 3 0))
(env-squared-channel '(0 0 1 1 2 -.75 3 0))
(blackman4-env-channel '(0 0 1 1 2 -.75 3 0))
(env-squared-channel '(0 0 1 1 2 -.75 3 0) #f)
(env-expt-channel '(0 0 1 1 2 -.75 3 0) 3.0)
(env-expt-channel '(0 0 1 1 2 -.75 3 0) 3.0 #f)
(env-expt-channel '(0 0 1 1 2 -.75 3 0) .3)
(env-expt-channel '(0 0 1 1 2 -.75 3 0) .3)
-->

<center><img src="exptenvs.png"></center>
<br><br>


<A NAME="fadedoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>fade.scm</h2></td></tr></table>

<p>
The two instruments in fade.scm perform frequency-domain cross-fades, that is, the
cross-fade is handled by a bank of bandpass filters (<a class=quiet href="clm.html#formant">formant</a> generators).  The effect
is sometimes only slightly different from a normal (time-domain) cross-fade, but
there are some interesting possibilities ("sound evaporation", etc).
</p>

<A NAME="fmvdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>fmv.scm</h2></td></tr></table>

<p>fmv.scm implements the fm-violin (v.scm) as a CLM-style generator, making it possible
to call the violin anywhere a generator could be called; since each call on the fm-violin
function produces the next sample of the given violin, this form of the fm-violin is easy
to call in "real-time" situations.  Any other CLM-style instrument could
be rewritten in the same form.
</p>
<pre>
  <em class=emdef>make-fm-violin</em>
    frequency amplitude #:key (fm-index 1.0) (amp-env #f) (periodic-vibrato-rate 5.0) (random-vibrato-rate 16.0)
    (periodic-vibrato-amplitude 0.0025) (random-vibrato-amplitude 0.005) (noise-amount 0.0) (noise-freq 1000.0)
    (ind-noise-freq 10.0) (ind-noise-amount 0.0) (amp-noise-freq 20.0) (amp-noise-amount 0.0) (gliss-env #f)
    (fm1-env #f) (fm2-env #f) (fm3-env #f) (fm1-rat 1.0) (fm2-rat 3.0) (fm3-rat 4.0) (fm1-index #f) (fm2-index #f) 
    (fm3-index #f) (base 1.0) #:allow-other-keys

  <em class=emdef>fm-violin</em> gen
  <em class=emdef>fm-violin-ins</em> [same args as original violin in v.scm]
</pre>
<p><i>fm-violin-ins</i> shows how this generator can be fitted into the original fm-violin code.
The <b>make-fm-violin</b> function uses the optional arguments support from Guile (optargs.scm, loaded
via <code>(use-modules (ice-9 optargs))</code>). The plethora of arguments is an historical artifact;
normally only a few of them are used at a time.  There are two examples of calling this generator
in fmv.scm, the simpler one being:
</p>
<pre>
(define test-v 
  (lambda (beg dur freq amp amp-env)
    (let ((v (make-fm-violin 
	      freq amp 
	      :amp-env (let ((e (<a class=quiet href="clm.html#make-env">make-env</a> :envelope (or amp-env '(0 0 1 1 2 0)) 
					  :scaler amp 
					  :end dur)))
			 (lambda () (<a class=quiet href="clm.html#env">env</a> e)))))
	  (data (<a class=quiet href="extsnd.html#samples_to_vct">samples-&gt;vct</a> beg dur)))
      (do ((i 0 (1+ i)))
	  ((= i dur))
	(<a class=quiet href="extsnd.html#vctset">vct-set!</a> data i (+ (<a class=quiet href="extsnd.html#vctref">vct-ref</a> data i)
			    (v))))
      (<a class=quiet href="extsnd.html#setsamples">set-samples</a> beg dur data))))
</pre>
<p>Here we are setting up an fm-violin generator (via make-fm-violin), then
calling it <i>dur</i> times, mixing its output into the current data (this could
also use mix-vct and so on).  The generator is called via <code>(v)</code>.
As can be seen here, each envelope is treated as a function called on each sample
very much like the "as-needed" input in src or granulate; the envelopes could actually be any
arbitrary function you like (see test-v1 in fmv.scm which uses an oscillator as one of
the fm index envelopes).  One complication in some "real-time" situations is that
you don't know in advance how long a note will be; in this case, the envelope
generating functions should have attack and decay ramps, triggered by note-on and
note-off; once the ramp has reached its end point, the end value should be held;
the note itself should be called until it has had time to ramp off; an exercise
for the interested reader.
</p>

<A NAME="freeverbdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>freeverb.scm, freeverb.rb</h2></td></tr></table>

<p>These are translations by Michael Scholz of CLM's freeverb.ins.
</p>


<A NAME="hooksdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>hooks.scm, hooks.rb</h2></td></tr></table>
<pre>
  <em class=emdef>describe-hook</em> hook
  <em class=emdef>remove-local-hook!</em> hook func
  <a class=def name="withlocalhook">with-local-hook</a> hook local-hook-procs thunk
  <a class=def name="resetallhooks">reset-all-hooks</a>
  <em class=emdef>snd-hooks</em>
  <em class=emdef>hook-member</em> func hook
</pre>
<p>hooks.scm and hooks.rb have various hook-related functions.
<b>describe-hook</b> tries to decipher the functions on the hook list.
<b>remove-local-hook!</b> is a kludge to get around a bug in Guile's remove-hook! function;
it makes it possible to remove a locally-defined function from a hook.
<b>with-local-hook</b> is a kind of "let" for hooks.  <b>snd-hooks</b> returns
a list of all Snd-specific hooks; this is used by <b>reset-all-hooks</b> which
returns all hooks to the empty state. 
<b>hook-member</b> returns #t if <i>func</i> is already on the hook list.
</p>

<A NAME="indexdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>index.scm, index.rb</h2></td></tr></table>
<pre>
  <em class=emdef>html</em> obj
  <em class=emdef>?</em> obj
</pre>
<p>index.scm provides a connection between mozilla or netscape
and the Snd documentation.  The index itself is
built by index.cl, then accessed through the <b>html</b> and <b>?</b> functions.
<code>(html arg)</code> where arg can be a string, symbol, or procedure sends mozilla to the corresponding url
in the Snd documents.
<code>(? obj)</code> prints out any help it can find for obj, and tries to find obj in the documentation.
The function that actually passes the url to the reader is <a href="extsnd.html#sendnetscape">send-netscape</a>.
</p>

<A NAME="dotemacs"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>inf-snd.el, DotEmacs</h2></td></tr></table>

<p>These two files provide support for Snd as an Emacs subjob.  inf-snd.el is by Michael Scholz,
and DotEmacs is by Fernando Lopez-Lezcano.
</p>


<A NAME="jcrevdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>jcrev.scm</h2></td></tr></table>
<p>
jc-reverb is a reverberator developed by John Chowning a long time ago
(I can't actually remember when -- before 1976 probably). It "colors" the
sound much more than <a href="#clminsdoc">nrev</a>, and has noticeable echos,
but I liked the effect a lot.  new-effects.scm has a version of jc-reverb
that run as a normal snd editing function (via map-channel), whereas the
jcrev.scm version assumes it is being called within with-sound:
</p>
<pre>
(with-sound (:reverb jc-reverb) 
  (fm-violin 0 .1 440 .1 :reverb-amount .1))
</pre>
<p>It is possible to use the CLM/with-sound reverbs (or any such instrument) as
an ordinary editing function:
</p>

<pre>
(if (not (defined? '*output*)) (load-from-path "ws.scm"))
(define* (clm-reverb-sound reverb-amount reverb #:optional (reverb-data '()) snd)
  (let ((output (<a class=quiet href="extsnd.html#sndtempnam">snd-tempnam</a>))
	(revout (<a class=quiet href="extsnd.html#sndtempnam">snd-tempnam</a>))
	(len (+ (<a class=quiet href="extsnd.html#frames">frames</a> snd) (<a class=quiet href="extsnd.html#srate">srate</a> snd))))
    (<a class=quiet href="extsnd.html#scaleby">scale-by</a> (- 1.0 reverb-amount) snd)
    (<a class=quiet href="extsnd.html#savesoundas">save-sound-as</a> output snd)
    (<a class=quiet href="extsnd.html#undo">undo</a> 1 snd)
    (<a class=quiet href="extsnd.html#scaleby">scale-by</a> reverb-amount snd)
    (<a class=quiet href="extsnd.html#savesoundas">save-sound-as</a> revout snd)
    (<a class=quiet href="extsnd.html#undo">undo</a> 1 snd)
    (set! *output* (<a class=quiet href="clm.html#continue-sample-&gt;file">continue-sample-&gt;file</a> output))
    (set! (<a class=quiet href="grfsnd.html#mussrate">mus-srate</a>) (<a class=quiet href="extsnd.html#srate">srate</a> snd))
    (set! *reverb* (<a class=quiet href="clm.html#make-file-&gt;sample">make-file-&gt;sample</a> revout))
    (apply reverb reverb-data)
    (<a class=quiet href="clm.html#mus-close">mus-close</a> *reverb*)
    (<a class=quiet href="clm.html#mus-close">mus-close</a> *output*)
    (delete-file revout)
    (set! (<a class=quiet href="extsnd.html#samples">samples</a> 0 len snd #f #f #f 0 #f #t) output)))

;;; (clm-reverb-sound .1 (lambda (dur) (jc-reverb #f 1.0 #f dur)))
</pre>
<p>Another approach to this problem would be to use <a href="extsnd.html#snd_to_sample">snd-&gt;sample</a> to
redirect the *reverb* input (without any change to the reverberator),
getting its data from the current sound (probably after scaling it
by the reverb amount). 
</p>
<br>

<!-- INDEX reverbexamples:Reverb -->
<A NAME="reverbexamples"></a>
<TABLE border=3 bordercolor="tan" hspace=40><tr><td>
<blockquote><small>
<br>
Reverbs in Snd<br>
freeverb: <a href="#freeverbdoc">freeverb.scm, freeverb.rb</a><br>
jc-reverb: <a href="#jcrevdoc">jcrev.scm</a><br>
jl-reverb: <a href="#clminsdoc">clm-ins.scm</a><br>
nrev: <a href="#clminsdoc">clm-ins.scm</a><br>
control panel reverb: <a href="snd.html#reverb">Reverb</a>, <a href="extsnd.html#reverbdecay">control variables</a><br>
convolution reverb: <a href="extsnd.html#convolvewith">conrev</a><br>
plate-reverb: ladspa.scm (a LADSPA effect)<br>
*reverb*: <a href="#wsdoc">with-sound</a><br>
<br>
</small></blockquote>
</td></tr></TABLE>
<br>

<A NAME="ladspadoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>ladspa.scm, ladspa-help.scm</h2></td></tr></table>

<p>This file takes your LADSPA library and builds a set of dialogs
to control and preview each effect.  The related help strings are in ladspa-help.scm.
</p>


<A NAME="maracadoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>maraca.scm</h2></td></tr></table>

<p>This file has a translation to Snd/Scheme of Perry Cook's maraca physical model.
</p>

<A NAME="marksdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>marks.scm</h2></td></tr></table>

<p>marks.scm is a collection of mark-related functions.</p>

<pre>
  <a class=def name="markname2id">mark-name-&gt;id</a> name
  <a class=def name="describemark">describe-mark</a> id
  <A class=def NAME="syncup">syncup</a> ids
  <A class=def NAME="fitselectionbetweenmarks">fit-selection-between-marks</a> m1 m2
  <a class=def name="padmarks">pad-marks</a> ids secs
  <A class=def NAME="movesyncdmarks">move-syncd-marks</a> sync samples-to-move
  <a class=def name="playsyncdmarks">play-syncd-marks</a> sync
  <a class=def name="exevalbetweenmarks">eval-between-marks</a> func snd
  <A class=def NAME="exsnapmarks">snap-marks</a>
  <a class=def name="exdefineselectionviamarks">define-selection-via-marks</a> m1 m2
  <a class=def name="exsnapmarktobeat">snap-mark-to-beat</a>
  <a class=def name="exmarkexplode">mark-explode</a>
  <a class=def name="markproperty">mark-property</a> key id
  <A class=def NAME="markclickinfo">mark-click-info</a> id
  <A class=def NAME="savemarkproperties">save-mark-properties</a>
</pre>

<p><b>mark-name-&gt;id</b> is like <a href="extsnd.html#findmark">find-mark</a> but searches all currently accessible channels.
</p><p><b>describe-mark</b> returns a description of the movements of mark id over the channel's edit history:
</p>
<pre>
:<em class=typing>(describe-mark 0)</em>
<em class=listener>((mark 0 sound 0 "oboe.snd" channel 0) 654 478)</em>
</pre>
<p>Here I placed a mark in oboe.snd at sample 654, then deleted a few samples
before it, causing it to move to sample 478.
</p><p><b>pad-marks</b> inserts <i>secs</i> seconds of silence before each in a list of marks (<i>ids</i>).
</p><p><b>fit-selection-between-marks</b> tries to squeeze the current selection between two marks,
using the granulate generator to fix up the selection duration (this still is not perfect).
</p><p><b>syncup</b> synchronizes a list of marks by inserting silences as needed.
</p><p><b>move-syncd-marks</b> moves any marks sharing the sync value <i>sync</i> by
<i>samples-to-move</i> samples.  Similarly, <b>play-syncd-marks</b> starts
playing from all marks sharing its <i>sync</i> argument.
</p>
<p>marks.scm also has code that tries to make it simpler to sync marks together
(see <b>start-sync</b> and <b>stop-sync</b>), and <b>report-mark-names</b>
that causes any named mark to display its name in the minibuffer when 
the underlying sample happens to be played.  There are also many mark-related
functions in examp.scm and scattered around the documentation.
</p>
<p><b>eval-between-marks</b> evaluates <i>func</i>
between the leftmost marks in <i>snd</i>.
</p>
<pre>
(<a class=quiet href="extsnd.html#bindkey">bind-key</a> (char-&gt;integer #\m) 0 
	  (lambda () "eval between marks"
	    (<a class=quiet href="extsnd.html#promptinminibuffer">prompt-in-minibuffer</a> "mark eval:" eval-between-marks)))
</pre>
<p><b>snap-marks</b> places marks at the start and end of the current selection.
</p><p><b>define-selection-via-marks</b> selects the portion between the given marks.
</p><p><b>snap-mark-to-beat</b> forces a dragged mark to end up on a beat.
</p><p><b>mark-explode</b> splits a sound into a bunch of separate files based on mark placements.
</p><p><b>mark-property</b> associates a property list with each mark.
There is also some code (look for "eval-header") that saves mark info in the
sound file header, and reads it when the file is subsequently reopened.
</p><p><b>mark-click-info</b> is a mark-click-hook function that describes a mark and its properties.  It
is used by with-marked-sound in ws.scm.
</p><p><b>save-mark-properties</b> sets up an <a href="extsnd.html#aftersavestatehook">after-save-state-hook</a> function to save any mark-properties.
</p>
<br>

<A NAME="maxfdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>maxf.scm, maxf.rb</h2></td></tr></table>

<p>These files are translations (thanks to Michael Scholz!) of CLM's maxf.ins
(thanks to Juan Reyes!). They implement a new kind of resonator designed by
Max Mathews.
</p>


<A NAME="mixdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>mix.scm</h2></td></tr></table>

<p>mix.scm provides various mix and track related utilities. 

</p>
<pre>
  <a class=def name="mixsound">mix-sound</a> file start
  <a class=def name="mixproperty">mix-property</a> key id
  <A class=def NAME="mixclicksetsamp">mix-click-sets-amp</A>
  <a class=def name="mix2vct">mix-&gt;vct</a> id
  <a class=def name="panmix">pan-mix</a> file (frame 0) (env 1.0) snd (chn 0)
  <A class=def NAME="panmixselection">pan-mix-selection</A> (frame 0) (env 1.0) snd (chn 0)
  <A class=def NAME="panmixregion">pan-mix-region</A> region (frame 0) (env 1.0) snd (chn 0)
  <A class=def NAME="panmixvct">pan-mix-vct</A> vct (frame 0) (env 1.0) snd (chn 0)
  <a class=def name="snapmixtobeat">snap-mix-to-beat</a> (at-anchor)
  <A class=def NAME="deleteallmixes">delete-all-mixes</a>
  <a class=def name="findmix">find-mix</a> sample snd chn
  <A class=def NAME="mixmaxamp">mix-maxamp</a> id
  <A class=def NAME="savemix">save-mix</a> id filename
  <A class=def NAME="mixclickinfo">mix-click-info</a> id
</pre>
<p>
<b>mix-sound</b> mixes <i>file</i> (all chans) into the currently selected sound at <i>start</i>.
<b>mix-&gt;vct</b> returns the current samples
of mix <i>id</i> (taking into account its current amplitude an so on). 
<b>pan-mix</b>
mixes <i>file</i> into the current sound starting at <i>frame</i> using the envelope <i>env</i>
to pan the mixed samples (0: all chan 1, 1: all chan 0).
The resultant mixes (if more than one) are placed in their own track, and the
track amp env is interpreted as a panning envelope.
To tie this into C-x C-q, in place of the default "mix" function,
</p>
<pre>
(<a class=quiet href="extsnd.html#bindkey">bind-key</a> (char-&gt;integer #\q) 4 ; C-q
	  (lambda () "pan mix"
	    (<a class=quiet href="extsnd.html#promptinminibuffer">prompt-in-minibuffer</a> "mix:" (lambda (str) ; use pan-mix at cursor
					   (<em class=red>pan-mix</em> str (or (<a class=quiet href="extsnd.html#cursor">cursor</a>) 0)) #f #t)))
	  #t  ; an extended (C-x) command
          "C-x C-q")
</pre>
<p>
See <a href="#usepanmixinmixmenu">use-pan-mix-in-mix-menu</a> to change the
File:Mix menu to use pan-mix.  The other pan-mix-* functions perform the
same operation on a region (<b>pan-mix-region</b>), the current selection
(<b>pan-mix-selection</b>), or a vct assumed to represent one channel of
sound (<b>pan-mix-vct</b>).
</p>
<p>
<b>snap-mix-to-beat</b> forces a dragged mix to end up on a beat.
If <i>at-anchor</i> is #t, the anchor point, rather than the mix beginning falls on the beat.
<b>mix-property</b> associates a property list with each mix.
<b>track-property</b> associates a property list with each track.
<b>mix-click-sets-amp</b> uses the property lists to keep track of
whether the next click should set the mix amps to zero, or to the
pre-zero value.
<b>find-mix</b> returns the identifier of the mix at sample <i>sample</i> (or anywhere in the given channel if 
<i>sample</i> is not specified), or #f if no mix is found.
<b>mix-maxamp</b> returns the maxamp in the given mix.
<b>mix-click-info</b> is a <a href="extsnd.html#mixclickhook">mix-click-hook</a> function that posts a description of the
clicked mix in the help dialog.
<b>save-mix</b> saves a given mix's data in a file.
</p>
<center><img src="pan.png" alt="picture of panning"></center>
<pre>
  <a class=def name="track2vct">track-&gt;vct</a> track (chan 0)
  <a class=def name="savetrack">save-track</a> track filename (chan #t)
  <a class=def name="transposetrack">transpose-track</a> track semitones
  <A class=def NAME="retempotrack">retempo-track</a> track tempo
  <a class=def name="reversetrack">reverse-track</a> track
  <a class=def name="filtertrack">filter-track</a> track coeffs
  <em class=emdef>delete-all-tracks</em>
  <a class=def name="trackproperty">track-property</a> key id
  <A class=def NAME="trackmaxamp">track-maxamp</a> id chan
</pre>
<p>
<b>track-&gt;vct</b> places all the mix samples
in the track into a vct.  Similarly, <b>save-track</b> places the track's samples into a file.
If the 'chan' arg is #t, all channels are saved.
<b>retempo-track</b> affects the time between the successive mix begin points (tempo &gt; 1.0 makes the
mixes happen more quickly):
</p>
<pre>
:<em class=typing>(retempo-track (track 1) 2.0)</em>
<em class=listener>(1500 7770)</em>
:<em class=typing>(mix-position 0)</em>
<em class=listener>1500</em>
:<em class=typing>(mix-position 1)</em>
<em class=listener>7770</em>
:<em class=typing>(+ 1500 (* .5 (- 14039 1500))) ; 14039 is the former mix 1 begin time (see above)</em>
<em class=listener>7769.5</em>
</pre>
<p>
<b>filter-track</b> applies a filter to each mix sound at the pre-mix point (that is, the
mixed in sound is filtered, then the mix takes place).
<b>reverse-track</b> reverses the order in which a track's member mixes occur.
<b>track-maxamp</b> returns the maxamp in the given track.
</p>


<A NAME="moogdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>moog.scm</h2></td></tr></table>
<pre>
  <em class=emdef>make-moog-filter</em> frequency Q
  <a class=def name="moogfilter">moog-filter</a> gen input
</pre>
<p>moog.scm is a translation of CLM's moog.lisp (written by Fernando Lopez-Lezcano --
http://ccrma.stanford.edu/~nando/clm/moog),
itself a translation of Tim Stilson's original C code.  The functions provide
a kind of CLM generator view of the filter.  Fernando describes it as a
"Moog style four pole lowpass (24db/Oct) filter clm unit generator,
variable resonance, warm, analog sound ;-)". <!-- ( -->
In <b>make-moog-filter</b> "frequency" is the cutoff frequency
in Hz (more or less) and "Q" is the resonance: 0 = no resonance,
1 causes the filter to oscillate at frequency.  My translation is
a bit simple-minded; with a little effort, this could run much
faster.
</p>
<pre>
  (define (moog freq Q)
    (let ((gen (<em class=red>make-moog-filter</em> freq Q)))
      (lambda (inval)
        (<em class=red>moog-filter</em> gen inval))))

  (<a class=quiet href="extsnd.html#mapchan">map-chan</a> (moog 1200.0 .7))
</pre>
<p>The Ruby version of this is in examp.rb.
</p>

<A NAME="musglyphs"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>musglyphs.scm</h2></td></tr></table>

<p>musglyphs.scm provides Scheme/Snd wrappers to load CMN's cmn-glyphs.lisp (directly!),
thereby defining most of the standard music notation symbols.  Each of the original
functions (e.g. draw-bass-clef) becomes a Snd/Scheme procedure of the form
<code>(name #:optional x y size style snd chn context)</code>. 
<code>(draw-bass-clef 100 100 50)</code> draws a bass clef in the current graph
at position (100 100) of size 50; since the <i>style</i> argument defaults to
#f, the clef is displayed as a filled polygon; use #t to get an outline of
the clef instead.  You need CMN, or at least the CMN file cmn-glyphs.lisp
before loading this file, and Rick Taube's loop.scm (from Common Music).
</p>
<img src="sndcmn.png" alt="Snd with music symbols">
<br>
<p>(The dot size bug in this picture has been fixed, but I'm too lazy
to make a new version of the picture).
</p>
<br>

<A NAME="nbdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>nb.scm, nb.rb</h2></td></tr></table>

<p>nb.scm provides popup help for files in the View:Files dialog; as you move
the mouse through the lists, the help dialog posts information about the file
underneath the mouse.  This uses a slightly fancier file information procedure
than 'finfo' in examp.scm.  If you have the guile-gdbm package, you can use
its database procedures to associate arbitrary information with files which
will be posted along with the header info:
</p>
<pre>
  <a class=def NAME="nb">nb</a> file note
  <em class=emdef>unb</em> file
  <em class=emdef>prune-db</em>
</pre>
<p><code>(nb "test.snd" "this is a test")</code> adds the note "this is a test" to
the data associated with "test.snd".  <code>(unb "test.snd")</code> erases anything
associated with "test.snd".  <code>(prune-db)</code> erases anything associated with
any files that no longer exist.  (nb.scm will work fine without guile-gdbm; to load
guile-gdbm, set the variable <b>use-gdbm</b> to #t).
</p>
<p>Michael Scholz's translation of this to Ruby is included in examp.rb.
</p>

<A NAME="noisedoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>noise.scm, noise.rb</h2></td></tr></table>

<p>The noise files are translations (thanks to Michael Scholz) of CLM's noise.ins.
noise.ins has a very long pedigree; I think it dates back to about 1978.  It can produce
those all-important whooshing sounds.
</p>


<A NAME="peakenvdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>peak-env.scm</h2></td></tr></table>

<p>The functions in peak-env.scm provide relatively robust access to
peak envelope files.  These files save Snd's overall amplitude envelopes
for a given sound so that a subsequent re-open of that sound has the
waveform immediately.  For very large sounds, this can save as much as
a minute during which Snd is running the amplitude envelope builders
in the background and displaying whatever it can.  That is, it makes
opening a large sound much faster after the initial read and save.
The file has a variable <b>save-peak-env-info</b> (default #t) which
determines whether these envelopes are being saved.  The procedure
</p>
<pre>
(define (peak-env-info-file-name snd chn)	
  (format #f "~A/~A-peaks-~D" save-peak-env-info-directory (<a class=quiet href="extsnd.html#shortfilename">short-file-name</a> snd) chn))
</pre>
<p>determines the saved peak env file name; in the default
case, it looks for the directory ~/peaks, but obviously this
could be changed to suit your situation.
</p>

<A NAME="pianodoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>piano.scm, piano.rb</h2></td></tr></table>

<p>These files are translations of CLM's piano.ins, a piano physical
model by Scott van Duyne.
</p>

<A NAME="playdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>play.scm</h2></td></tr></table>

<p>These functions play sounds in various ways.</p>
<pre>
  <A class=def NAME="explaysound">play-sound</A> <i>func</i>
  <A class=def NAME="playsine">play-sine</A> freq amp
  <a class=def name="playsines">play-sines</a> freqs-and-amps
  <A class=def NAME="openplayoutput">open-play-output</A> <i>chans srate format buffer-size</i>
</pre>
<p><b>play-sound</b> plays the current sound, calling (func data) on each buffer if func is passed.
It is also an example of calling the low level mus-audio functions, rather than calling
play-channel and friends. The latter are easier to use, in most cases.
The following doubles each sample in channel 0 during playback:
</p>
<pre>
(<em class=red>play-sound</em>
 (lambda (data)
   (let ((len (sound-data-length data)))
     (do ((i 0 (1+ i)))
	 ((= i len))
       (sound-data-set! data 0 i (* 2.0 (sound-data-ref data 0 i)))))))
</pre>
<p>
This calls <b>open-dac-output</b> to open an output audio port.  open-dac-output
takes the desired number of channels, sampling rate, data format, and DAC buffer size (in samples),
and returns a list containing the audio port (-1 on failure), the opened output channels,
and the actual DAC buffer size (these can differ from the requested amounts in various hardware
situations).
<b>play-sine</b> plays a one-second sine wave at the given frequency and amplitude: <code>(play-sine 440 .1)</code>
and <b>play-sines</b> produces a spectrum given a list of lists of frequency and amplitude:
</p>
<pre>
(play-sines '((425 .05) (450 .01) (470 .01) (546 .02) (667 .01) (789 .034) (910 .032)))
</pre>
<p>
To set up the keyboard
as a kind of extended piano, we could map keys to sounds:
</p>
<pre>
(<a class=quiet href="extsnd.html#bindkey">bind-key</a> (char-&gt;integer #\o) 0 (lambda () "play oboe" (<a class=quiet href="extsnd.html#play">play</a> "oboe.snd")))
(<a class=quiet href="extsnd.html#bindkey">bind-key</a> (char-&gt;integer #\p) 0 (lambda () "play pistol" (<a class=quiet href="extsnd.html#play">play</a> "pistol.snd")))
</pre>
<p>The various play hooks can be used to play sounds over and over. 
</p>
<pre>
  <A class=def NAME="explayoften">play-often</A> times
  <A class=def NAME="explayuntilcg">play-until-c-g</A>
  <A class=def NAME="explayregionforever">play-region-forever</a> region

(<a class=quiet href="extsnd.html#bindkey">bind-key</a> (char-&gt;integer #\p) 0 (lambda (n) "play often" (play-often (max 1 n))))
(<a class=quiet href="extsnd.html#bindkey">bind-key</a> (char-&gt;integer #\r) 0 (lambda (n) "play region forever" (play-region-forever (max 0 n))))
</pre>
<p>Now C-u 31 p plays the current sound 31 times; C-u 3 r plays region 3 until we type C-g.
<b>play-often</b> uses stop-playing-hook, and <b>play-region-forever</b> uses stop-playing-region-hook.
With a sufficiently fast computer, it's possible to create the samples to be played 
in "real-time".  <b>play-fun</b> starts and stops the DAC, <i>ampit</i> and <i>amprt</i>
fill up the audio buffer with data.
</p>
<pre>
(play-fun (ampit (<a class=quiet href="extsnd.html#frames">frames</a>) 2.0) 256)
</pre>
<p>scales sound 0's samples by 2 and sends them to the DAC. (These three functions are now obsolete).
More useful is:</p>
<pre>
  <A class=def NAME="exloopbetweenmarks">loop-between-marks</a> mark1 mark2 buffer-size
</pre>
<p>which loops continuously between the two specified marks.
The marks can be moved as the sound is played; C-g stops loop-between-marks.
If you want the DAC to be held open in the background,
</p>
<pre>
  <A class=def NAME="exstartdac">start-dac</A>
  <em class=emdef>stop-dac</em>
</pre>
<p>The vector-synthesis 
idea (and weird name) came from a linux-audio-development mailing list.
Apparently some commercial synths (or software?) provide this.
It reads any number of sound files, using a function to
decide which one to send to the DAC.
</p>



<A NAME="popupdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>popup.scm and gtk-popup.scm</h2></td></tr></table>
<pre>
  <a class=def name="addselectionpopup">add-selection-popup</a> 
  <a class=def name="addlistenerpopup">add-listener-popup</a> 
</pre>
<p>
gtk-popup.scm is the Gtk/xg version; popup.scm is Motif/xm based.
<b>add-selection-popup</b> creates a selection-oriented popup menu that is
posted if you click button3 in the selected portion, as well as a time-domain popup
menu, and an fft-specific menu.
<b>add-listener-popup</b> creates a listener-oriented popup menu that is
posted if you click button3 in the listener.
</p>


<A NAME="prc95doc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>prc95.scm</h2></td></tr></table>

<!-- INDEX prc95doc:Physical Models -->
<p>prc95.scm is a translation to Snd of Perry Cook's (1995) physical modelling toolkit; prc-toolkit95.lisp 
in CLM.  One starting point for physical modelling is Smith, "Music Applications of Digital Waveguides", CCRMA, Stan-M-39, 1987,
or Julius's <a href="http://ccrma.stanford.edu/~jos">home</a> page, or
any of several classic papers also by Julius Smith.  Perry's own version of this code can be
found in <a href="http://ccrma.stanford.edu/CCRMA/Software/STK/">STK</a>.
The example instruments are:
</p>
<table border=0>
<tr><td>
<pre>
  <em class=emdef>plucky</em> beg dur freq amplitude maxa
  <em class=emdef>bow</em> beg dur frq amplitude maxa
  <em class=emdef>brass</em> beg dur freq amplitude maxa
  <em class=emdef>clarinet</em> beg dur freq amplitude maxa
  <em class=emdef>flute</em> beg dur freq amplitude maxa

  (define (test-prc95)
    (plucky 0 .3 440 .2 1.0)
    (bow .5 .3 220 .2 1.0)
    (brass 1 .3 440 .2 1.0)
    (clarinet 1.5 .3 440 .2 1.0)
    (flute 2 .3 440 .2 1.0))
</pre>
</td>
<td>
<table border=3 bordercolor="tan" hspace=40><tr><td>
<blockquote><small>
<br>
See also:<br>
maraca: <a href="#maracadoc">maraca.scm</a><br>
piano: <a href="#pianodoc">piano.scm, piano.rb</a><br>
singer: <a href="#singerdoc">singer.scm</a><br>
bowed string: <a href="#straddoc">strad.scm, strad.rb</a><br>
flute: <a href="#clminsdoc">clm-ins.scm</a><br>
string: <a href="#excomputeuniformcircularstring">compute-string</a><br>
plucked string: pluck in clm-ins.scm<br>
plate-reverb: ladspa.scm<br>
<br>
</small></blockquote>
</td></tr></table>
</td></tr></table>
<br>

<A NAME="pvocdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>pvoc.scm</h2></td></tr></table>
<p>
This is the same as the CLM phase-vocoder generator, but implemented in Scheme.  If you're interested
in how the thing works, I think the Scheme version is easiest to understand; the Common Lisp version 
is in mus.lisp, and the C version is in clm.c.
</p>
<pre>
  <em class=emdef>make-pvocoder</em> fftsize overlap interp analyze edit synthesize
  <em class=emdef>pvocoder</em> gen input
  <em class=emdef>pvoc</em> #:key (fftsize 512) (overlap 4) (time 1.0) (pitch 1.0) (gate 0.0) (hoffset 0.0) (snd 0) (chn 0)
</pre>
<p>The <i>analyze</i>, <i>edit</i>, and <i>synthesize</i> arguments to make-pvocoder are
functions that are applied as needed during pvocoder processing; similarly, the <i>input</i>
argument to pvocoder can be a function.
pvoc.scm also contains a few examples of using the CLM phase-vocoder generator:
</p>
<pre>
(define test-pv-4
  (lambda (gate)
    (let ((pv (<a class=quiet href="clm.html#make-phase-vocoder">make-phase-vocoder</a> #f
				  512 4 128 1.0
				  #f ;no change to analysis
				  (lambda (v)
				    (let ((N (<a class=quiet href="clm.html#mus-length">mus-length</a> v)))
				      (do ((i 0 (1+ i)))
					  ((= i N))
					(if (&lt; (<a class=quiet href="extsnd.html#vctref">vct-ref</a> (pv-amp-increments v) i) gate)
					    (<a class=quiet href="extsnd.html#vctset">vct-set!</a> (pv-amp-increments v) i 0.0)))
				      #t))
				  #f ;no change to synthesis))
	  (reader (<a class=quiet href="extsnd.html#makesamplereader">make-sample-reader</a> 0)))
      (<a class=quiet href="extsnd.html#mapchan">map-chan</a> (lambda (val)
		  (<a class=quiet href="clm.html#phase-vocoder">phase-vocoder</a> pv (lambda (dir) 
				      (reader)))))
      (<a class=quiet href="extsnd.html#freesamplereader">free-sample-reader</a> reader))))
</pre>
<p>sets up a phase-vocoder generator whose edit function is squelching soft partials.
In this case, the input function is reading the currently selected channel.  The fastest
way to try out this generator is to use it as the argument to filter-sound.
<i>pvoc</i> is yet another a phase-vocoder;
it applies the phase-vocoder (i.e. fft analysis, oscil bank resynthesis)
to the current sound; <i>pitch</i> specifies the pitch transposition ratio, 
<i>time</i> specifies the time dilation ratio,
<i>gate</i> specifies a resynthesis gate in dB (partials with amplitudes lower than
the gate value will not be synthesized), <i>hoffset</i> is a pitch offset in Hz.
</p>

<A NAME="rgbdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>rgb.scm</h2></td></tr></table>
<p>rgb.scm (rgb.rb) is a simple translation of the standard X11 color names into Snd
color objects.
</p>
<pre>
(define snow (<a class=quiet href="extsnd.html#makecolor">make-color</a> 1.00 0.98 0.98))
</pre>
<p>is taken from the line</p>
<pre>
255 250 250             snow
</pre>
<p>/usr/lib/X11/rgb.txt.  The choice of a float between 0.0 and 1.0 (rather
than an integer between 0 and 255) mimics PostScript;
as video hardware has improved over the years, there's
less and less need for these elaborate color names, and less
reason (except perhaps psychophysical) to limit these numbers to bytes.
There is one gotcha in this file -- X11 defines a color named "tan"
which is already used by Scheme, so (at the suggestion of Dave Phillips)
this color is named "tawny" in rgb.scm.
</p>

<A NAME="rmsgaindoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>rmsgain.scm</h2></td></tr></table>

<p>rmsgain.scm is an implementation of the balance generators of CLM (based
on CSound originals).  I assume, from a glance at the code, that they're used
something like this:
</p>
<pre>
(define gen (make-instance &lt;rmsgain&gt;))
(map-channel (lambda (y) (balance gen y (rms gen y))))
</pre>
<br>

<A NAME="rtiodoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>rtio.scm</h2></td></tr></table>

<p>rtio.scm has a collection of functions oriented loosely around
"real-time" operations.
</p>
<pre>
  <em class=emdef>show-input</em> #:optional (in-sys 0)
  <A class=def NAME="exshowinputfft">show-input-fft</a> #:optional (in-sys 0)
  <A class=def NAME="exshowdraggableinputfft">show-draggable-input-fft</a> #:optional (in-sys 0)
  <em class=emdef>in-out</em> func in-sys out-sys
</pre>
<p>These three functions show how to read incoming data (from the adc),
write data (to the dac), and interpose a function while reading and
writing data.  There are several example functions (for the "func" argument) that filter the data or
change its amplitude. <b>show-input-fft</b> displays the input data's
spectrum.  <b>show-draggable-input-fft</b> is the same, but the X axis
(the frequency axis in this case) is draggable, as in Snd's FFT display.
</p>
<p>Here's some info from Michael Scholz about the Ruby version of rtio:
</p>
<pre>
rt = make_rtio
rt.show_input
rt.show_input_fft
rt.chans = 2
rt.show_drag
rt.amplify(1.5).in_out(1, 0)
rt.lp.in_out
rt.hp(1150).in_out
rt.close
</pre>
<br>

<A NAME="rubberdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>rubber.scm, rubber.rb</h2></td></tr></table>

<pre>
  <a class=def name="rubbersound">rubber-sound</a> stretch-factor
</pre>
<p>
<b>rubber-sound</b> tries to stretch or contract a sound (in time); it scans the sound
looking for stable (periodic) sections, then either deletes periods or interpolates new ones
to shorten or lengthen the sound.  It still needs a lot of robustification.
The algorithm is 1) remove all frequencies below 16 Hz, 2) resample the file to be
ten times longer (interpolating samples), 3) make a list of upward zero crossings,
4) using autocorrelation decide where the next fundamental zero crossing probably
is and see how much difference there is between the current period and the next,
5) check intermediate crossing weights and if the autocorrelation weight is not
the smallest, throw away this crossing, 6) sort the remaining crossings by least weight,
7) interpolate or delete periods until the sound has been sufficiently lengthened or
shortened.
<!-- ((((((( --><!-- this matches the preceding open parens for index.cl's benefit -->
</p>

<A NAME="singerdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>singer.scm</h2></td></tr></table>

<p>singer.scm is a translation of CLM's singer.ins.  It implements
a physical model of the vocal tract described in
</p>
<pre>
  Cook, Perry R. "Synthesis of the Singing Voice Using a Physically Parameterized Model of the Human Vocal Tract"
     Published in the Proceedings of the International Computer Music Conference, Ohio 1989 
     and as Stanford University Department of Music Technical Report Stan-M-57, August 1989.
 
 ---- "Identification of Control Parameters in an Articulatory Vocal Tract Model, with Applications 
    to the Synthesis of Singing," Ph.D. Thesis, Stanford University Department of Music Technical Report 
    Stan-M-68, December 1990.

 ----  "SPASM, a Real-time Vocal Tract Physical Model Controller; and Singer, the Companion Software 
    Synthesis System", Computer Music Journal, vol 17 no 1 Spring 1993.
</pre>
<p>
There are a couple example calls at the end of the instrument code.
</p>


<A NAME="snd4doc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>snd4|5|6|7.scm</h2></td></tr></table>

<p>These files contain a number of the procedures
that were removed from or renamed in earlier versions of Snd.  Some of them are:
</p>

<table border=0 cellspacing=10>

<!-- backward-graph -->
<tr><td colspan=2>
<a class=def name="backwardgraph">backward-graph</a> (<i>count snd chn</i>)
</td></tr>
<tr><td></td><td>
move the selected channel back (up or left) <i>count</i> graphs (C-x C-o), returning a list of the new sound index and channel number.
</td></tr>

<!-- backward-mark -->
<tr><td colspan=2><a class=def name="backwardmark">backward-mark</a> (<i>count snd chn</i>)</td></tr>
<tr><td></td><td>move the cursor back <i>count</i> marks (C-j), returning mark id, or #f if none.
</td></tr>

<!-- backward-mix -->
<tr><td colspan=2><a class=def name="backwardmix">backward-mix</a> (<i>count snd chn</i>)</td></tr>
<tr><td width=50><br></td><td>move the cursor back <i>count</i> mix tags (C-x C-j), returning the mix id.
</td></tr>

<!-- backward-sample -->
<tr><td colspan=2>
<A class=def NAME="backwardsample">backward-sample</a> (<i>count snd chn</i>)
</td></tr>
<tr><td></td><td>
move back <i>count</i> samples (C-b), return new cursor position.
</td></tr>

<!-- forward-graph -->
<tr><td colspan=2>
<a class=def name="forwardgraph">forward-graph</a> (<i>count snd chn</i>)
</td></tr>
<tr><td></td><td>
move the selected channel forward (down or right) <i>count</i> graphs (C-x C-o), returning a list of the new sound index and channel number.
</td></tr>

<!-- forward-mark -->
<tr><td colspan=2><a class=def name="forwardmark">forward-mark</a> (<i>count snd chn</i>)</td></tr>
<tr><td></td><td>move the cursor forward <i>count</i> marks (C-j), returning mark id, or #f if none.
</td></tr>

	<!-- I(move to mark):L(forward-mark)(forwardmark) -->

<!-- forward-mix -->
<tr><td colspan=2><a class=def name="forwardmix">forward-mix</a> (<i>count snd chn</i>)</td></tr>
<tr><td></td><td>move the cursor forward <i>count</i> mix tags (C-x C-j), returning the mix id.
</td></tr>

 	<!-- I(move to mix):L(forward-mix)(forwardmix) -->

<!-- forward-sample -->
<tr><td colspan=2>
<A class=def NAME="forwardsample">forward-sample</a> (<i>count snd chn</i>)
</td></tr>
<tr><td></td><td>
move forward <i>count</i> samples (C-f), return new cursor position.
</td></tr>
<tr><td colspan=2></td></tr>

</table>

<table border=0 cellspacing=5>
<!-- vct-do! -->
<tr><td><em class=emdef>vct-do!</em> (vobj proc)</td>
<td><code>vobj[i] = (funcall proc i)</code>.</td></tr>

<!-- vcts-do! -->
<tr><td><em class=emdef>vcts-do!</em> (vobj... proc)</td>
<td><code>vobj[vi][i] = (nth vi (funcall proc num i))</code>.</td></tr>

<!-- vcts-map! -->
<tr><td><em class=emdef>vcts-map!</em> (vobj... proc)</td>
<td><code>vobj[vi][i] = (nth vi (funcall proc num))</code>.</td></tr>

</table>

<p><b>vct-do!</b>
is the same as <b>vct-map!</b> except that the called function should take one
argument, the current loop index.  Similarly, <b>vcts-map!</b> and <b>vcts-do!</b>
take any number of vcts, followed by a trailing function, and map the function's
results (assumed to be a list that matches the current number of vcts) into the
vct array.  In the map! case, the function takes one argument, the current number
of vcts awaiting values; in the do! case, it takes two arguments, the vct
number and the current loop index.
</p>

<p>snd6.scm has functions that provide
backwards compatibility within version 6.
Currently, these are just some old (untypable) constant names,
and some slightly inconsistent old function names.
</p><p><b>clear-audio-inputs</b>
in Linux/OSS, tries to reduce soundcard background racket.
</p><p><b>append-to-minibuffer</b> (msg <i>snd</i>)
appends <i>msg</i> to whatever is in <i>snd</i>'s minibuffer.
</p><p><b>dismiss-all-dialogs</b> deactivates all active dialogs.
</p><p><b>mix-name</b> asociates a name with a mix, and
<b>mix-name-&gt;id</b> returns the id given a mix name.
</p>



<A NAME="sndgldoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>snd-gl.scm</h2></td></tr></table>

<p>snd-gl.scm has examples of using OpenGL.
</p>
<pre>
  <em class=emdef>gl-info</em>
  <a class=def name="startwaterfall">start-waterfall</a> #:optional (scl 1.0) (pc-spectrum 0.2) (fft-size 512)
  <em class=emdef>stop-waterfall</em>
  <em class=emdef>gl-dump-state</em>
  <A class=def NAME="complexify">complexify</A>
</pre>
<p><b>gl-info</b> prints out information about the current GL system setup.  <b>start-waterfall</b> starts a
waterfall spectrum display of the incoming audio data.  <b>stop-waterfall</b> turns it off.
<b>gl-dump-state</b> displays much of the current GL graphics state.
<b>complexify</b> shows the FFT data in the complex plane; each bin is 
rotated so that they all stack along the "x" axis, with
a line drawn from the x axis to the current real/imaginary
point (as (z, y)), so as you move (slowly) through a
file, you'll see the phase info as well as the magnitude --
the vectors whirl around in each slice of the complex 
plane.  Use the View:Orientation dialog to change the
viewing angle.  To move one sample at a time through a sound,
you could bind the arrow keys:
</p>
<pre>
(bind-key #xff51 0 (lambda () 
                     (set! (left-sample) (max 0 (1- (left-sample)))) 
                     keyboard-no-action))
(bind-key #xff53 0 (lambda () 
                     (set! (left-sample) (min (frames) (1+ (left-sample)))) 
                     keyboard-no-action))
</pre>
<br>

<A NAME="sndmotifdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>snd-motif.scm</h2></td></tr></table>

<pre>
  <A class=def NAME="installsearcher">install-searcher</a> proc
  <em class=emdef>zync</em> 
  <a class=def name="foreachchild">for-each-child</a> w func
  <a class=def NAME="makehiddencontrolsdialog">make-hidden-controls-dialog</a> 
  <A class=def NAME="createfmvdialog">create-fmv-dialog</A> 
  <em class=emdef>make-pixmap</em> strs
  <em class=emdef>display-scanned-synthesis</em> 
  <A class=def NAME="disablecontrolpanel">disable-control-panel</a> 
  <a class=def name="addmarkpane">add-mark-pane</a> 
  <A class=def NAME="selectfile">select-file</a> func <i>title dir filter help</i>
  <em class=emdef>snd-clock-icon</em> snd hour
  <a class=def name="makesoundbox">make-sound-box</a> name parent select-func peak-func sounds args
  <em class=emdef>show-sounds-in-directory</em> (dir ".")
  <a class=def name="showsmptelabel">show-smpte-label</a> on-or-off
  <em class=emdef>make-level-meter</em> parent width height
  <em class=emdef>show-disk-space</em>
  <A class=def NAME="keepfiledialogopenuponok">keep-file-dialog-open-upon-ok</a>
  <A class=def NAME="usepanmixinmixmenu">use-pan-mix-in-mix-menu</a>
  <a class=def name="addampcontrols">add-amp-controls</a>
  <A class=def NAME="adddeleteoption">add-delete-option, add-rename-option</a>
  <em class=emdef>mark-sync-color</em> new-color
  <em class=emdef>add-tooltip</em> widget tip
  <em class=emdef>menu-option</em> menu-name
  <em class=emdef>show-all-atoms</em>
  <em class=emdef>make-channel-drop-site</em> snd chn
  <em class=emdef>set-channel-drop</em> drop snd chn
  <em class=emdef>show-font-name</em> font
  <em class=emdef>show-widget-font</em>
  <A class=def NAME="addfindtolistener">add-find-to-listener</a>
  <A class=def NAME="uponsaveyourself">upon-save-yourself, upon-take-focus</a>
  <em class=emdef>add-text-to-status-area</em>
  <a class=def name="makevariabledisplay">make-variable-display</a> page-name variable-name (type 'text) (range (list 0.0 1.0))
  <a class=def name="variabledisplay">variable-display</a> val widget
  <em class=emdef>with-minmax-button</em>
  <em class=emdef>set-root-window-color</em> color
  <em class=emdef>notebook-with-top-tabs</em>
  <A class=def NAME="makefontselectordialog">make-font-selector-dialog</A>
  <A class=def NAME="makecolorselectordialog">make-color-selector-dialog</A>
</pre>
<!-- INDEX variabledisplay:Debugging (instruments) -->
<p>snd-motif.scm has procedures that rely on the Motif module (xm.c).
Some of these have been translated to Gtk and xg.c -- snd-gtk.scm.
</p><p>
<b>install-searcher</b> places
our own search procedure into the filter mechanism in the File:Open
dialog. </p><p>The pair <b>zync</b> and <b>unzync</b> cause the
y-axis zoom sliders of a multi-channel file to move together or separately.
</p><p><b>make-hidden-controls-dialog</b> adds "Hidden controls" to the Option
menu.  If you click it, it
creates a dialog that controls all the hidden control-panel variables.
The "expand-hop" control sets the hop size (per grain), "expand-length"
sets the grain length, "expand-ramp" sets the slope of the grain amplitude envelope,
"contrast-amp" sets the prescaler for the contrast effect, "reverb-feedback" sets the feedback
amount in the reverberator (it sets all the comb filter scalers), and "reverb-lowpass" sets
the lowpass filter coefficient in the reverberator. 
</p><p><b>create-fmv-dialog</b> sets up a very simple dialog with amplitude control on
the fm-violin (fmv.scm) running (interpreted!) in "real-time".
</p><p><b>make-pixmap</b> turns an xpm-style description into pixmap.
</p><p><b>display-scanned-synthesis</b> opens a pane for experimenting with scanned synthesis.
</p><p><b>disable-control-panel</b> does away with the control panel.
</p><p><b>add-mark-pane</b> adds a pane to each channel giving the current mark locations (sample values).
These can be edited to move the mark, or deleted to delete the mark.
</p><p><b>select-file</b> starts a file selection dialog, running <i>func</i> if a file is selected:
</p>
<pre>
 (<a class=quiet href="extsnd.html#addtomenu">add-to-menu</a> 0 "Insert File" 
   (lambda () 
     (select-file 
       (lambda (filename)
         (<a class=quiet href="extsnd.html#insertsound">insert-sound</a> filename))
       "Insert File" "." "*" "file will be inserted at cursor")))
</pre>
<p><b>snd-clock-icon</b> replaces Snd's hourglass with a clock.
</p><p><b>make-sound-box</b> makes a container of sound file icons, each icon
containing a little sketch of the waveform, the length of the
file, and the filename.  What happens when an icon is selected
is up to the caller-supplied procedure.  However, if you drag (via 
button 2) the icon to the menubar, that sound will be opened,
and if you drag it to a channel graph, it will be mixed at the
mouse location in that channel.
</p>
<pre>
(make-sound-box "sounds"
		(list-ref (<a class=quiet href="extsnd.html#mainwidgets">main-widgets</a>) 3)
		(lambda (file) 
                  (<a class=quiet href="extsnd.html#sndprint">snd-print</a> file))
		peak-env-info-filename ; this points to ~/peaks in my case
		(list "oboe.snd" "pistol.snd" "cardinal.snd" "storm.snd")
		'())
</pre>
<p><b>show-sounds-in-directory</b> calls make-sound-box, filling it with
any sounds found in the directory passed as its argument, defaulting to 
the current directory.
</p>
<img src="soundbox.png" alt="show-sounds-in-directory">

<p><b>show-smpte-label</b> shows the current SMPTE frame number in a box
in the upper left corner of the graph.
</p><p><b>make-level-meter</b> creates A VU meter of any width and height, returning
a list of information associated with that meter.  Pass that list to 
<b>display-level</b> to move the needle and the red bubble.  This meter
assumes you'll call it periodically so that the momentum of the needle and the viscosity of
the bubble will appear to behave naturally.  <b>with-level-meters</b> adds
any number of these meters to the topmost pane in the Snd main window,
then adds various <a href="extsnd.html#dachook">dac-hook</a> functions to display the current playback volume
in the respective meter.  
</p><p><b>show-disk-space</b> adds a label in the
minibuffer area which shows the current amount of disk space available
on the partition of the associated sound.
</p><p><b>keep-file-dialog-open-upon-ok</b> changes File:Open so that clicking "ok" does not unmanage (dismiss) the dialog.
<b>keep-mix-file-dialog-open-upon-ok</b> does the same for the File:Mix dialog.
<b>use-pan-mix-in-mix-menu</b> changes the File:Mix dialog to use <a href="#panmix">pan-mix</a> rather than <a href="extsnd.html#mix">mix</a>.
</p><p><b>add-amp-controls</b> adds amp sliders to the control panel
for multi-channel sounds (each channel gets its own amp control slider).
</p><p><b>add-rename-option</b> adds a "Rename" option to the File menu; similarly
<b>add-delete-option</b> adds a "Delete" option.
</p><p><b>mark-sync-color</b> uses the <a href="extsnd.html#drawmarkhook">draw-mark-hook</a> to set the color of sync'd marks.
</p><p><b>add-tooltip</b> adds a tooltip (also known as bubble-help) to a widget.  Once added,
set the variable <b>with-tooltips</b> to #f to turn it off.
</p><p><b>menu-option</b> returns the widget associated with a given menu item name ("Print" for example).
</p><p><b>show-all-atoms</b> displays (via Guile's <i>display</i>) all current X atom names.
</p><p><b>make-channel-drop-site</b> shows how to add a drop site panel to a channel.  
<b>set-channel-drop</b> changes the channel's graph's drop function to <i>drop</i>, a 
function of 3 arguments, the dropped filename (a string) and the current sound index and
channel number.
</p><p><b>show-font-name</b> shows the Snd-related name and the X-related name of each font in a font list
(it searches for the XA_FULL_NAME associated with an XFontStruct).
<b>show-widget-font</b> uses that function to show what fonts are associated with a widget.
</p><p><b>add-find-to-listener</b> activates C-s and C-r in the listener via a separate dialog.
</p><p><b>upon-save-yourself</b> causes a thunk (a function of no args) to be called if the window
manager sends a SAVE_YOURSELF message; similarly <b>upon-take-focus</b> causes a thunk to be called
whenever Snd receives focus from the window manager.
</p><p><b>add-text-to-status-area</b> puts a text widget in the notebook's status area
(the lower left portion of the main Snd window when using the -notebook invocation switch).
It returns the widget; you can write to it via XmTextFieldSetString.
</p>
<p>snd-gtk.scm also defines <b>make-font-selector-dialog</b> that creates a dialog
showing a list of available fonts with sample output, and a set of toggle buttons;
to start the dialog, click the Options:Choose Font menu option;
choose which of Snd's fonts you want to change, then click 'ok'. This isn't available
in snd-motif.scm because the corresponding font selection widget in Motif is still
under development.
The corresponding color selector is <b>make-color-selector-dialog</b>, but some of the
color variables don't actually work.
</p>

<p><b>make-variable-display</b> sets up a display point for an arbitrary expression which
is updated via <b>variable-display</b>.  The latter returns its argument, so it acts as a sort of
probe, picking out any arbitrary point in an instrument and displaying it as the
instrument is running.  Display points can be organized as pages in a notebook
widget:
</p>
<pre>
(define wid (make-variable-display "do-loop" "i*2" 'text))
(define wid1 (make-variable-display "do-loop" "i" 'text))
(do ((i 0 (1+ i)))
    ((= i 10))
  (variable-display (* (variable-display i wid1) 2) wid))
</pre>
<p>The 'graph and 'spectrum cases create legitimate Snd channel displays,
accessible via a sound index (and channel 0); these respond to the
various channel-related functions such as <a href="extsnd.html#showfftpeaks">show-transform-peaks</a>,
although you have to give the sound index explicitly:
</p>
<pre>
(define wid2 (make-variable-display "do-loop" "x" 'spectrum))
(set! (<a class=quiet href="extsnd.html#showfftpeaks">show-transform-peaks</a> (car wid2)) #t)
</pre>
<p>Each graph or spectrum display is placed in its own pane (this is a desperate
kludge), whereas all the others are ordered vertically in a single pane.
The 'scale choice has an additional argument that gives the range of the
scale as a list (low high):
</p>
<pre>
(define wid2 (make-variable-display "do-loop" "i*2" 'scale '(-1.0 1.0)))
</pre>
<p>You can watch a generator's state on a sample-by-sample basis by
putting it in a text display:
</p>
<pre>
(define wid1 (make-variable-display "do-loop" "beg" 'text))
(define wid2 (make-variable-display "do-loop" "oscil" 'text))
(definstrument (simp)
  (let* ((beg 0)
	 (dur 1000)
	 (end (+ beg dur))
	 (osc (<a class=quiet href="clm.html#make-oscil">make-oscil</a> 440.0)))
    (do ((i beg (1+ i)))
	((= i end))
      (variable-display i wid1)
      (<a class=quiet href="clm.html#oscil">oscil</a> (variable-display osc wid2) 0.0))))
(simp)
</pre>
<p>variable-display doesn't work within the run macro, but if you're debugging
an instrument, you're presumably not primarily concerned with optimization.
</p>
<p><b>with-minmax-button</b> adds an open/close button to each sound's pane.
<b>set-root-window-color</b> sets the background color of the root window.
<b>notebook-with-top-tabs</b> originally changed an existing notebook window (assuming Snd
was started with the -notebook switch) so that its orientation mimics
Xemacs, but that's now the default. 
</p>
<br>

<A NAME="sndtestdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>snd-test.scm and event.scm</h2></td></tr></table>
<p>
snd-test.scm is a test suite for Snd. The simplest use is:
</p>
<pre>
snd -l snd-test
</pre>
<p>
which will run all the tests, assuming you have the various sound files it is expecting to find.
event.scm has some XEvent-related functions used by snd-test.scm.  The Ruby version (very incomplete) is
snd_test.rb.
</p>

<A NAME="straddoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>strad.scm, strad.rb</h2></td></tr></table>

<p>strad.scm is a translation (by Michael Scholz) of CLM's strad.ins (by Juan Reyes).
It implements a physical model of a bowed string with stiffness.
</p>


<A NAME="spectrdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>spectr.scm, spectr.rb</h2></td></tr></table>

<p>The spectr files were translated by Michael Scholz from CLM's spectr.clm.  They contain a large 
set of instrument steady-state spectra, gathered many years ago (before 1976) by James A Moorer.
The variable names are taken from the file names used by JAM, but by the time I got around to
rescuing the data from mouldering magtapes, he had long since moved on, so I don't actually
know what instrument some of the labels refer to. 
</p>
<br>

<A NAME="vdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>v.scm</h2></td></tr></table>

<p>The fm violin was my favorite instrument while working in the 70's and 80's,
primarily on the Samson box.  It was developed in Mus10 (ca 1977) based on ideas of John Chowning;
a Mus10 version was (in this code ":=" is used in place of the original SAIL left arrow character,
and so on):
</p>
<pre>
ARRAY GlissFunc, DecayFunc, AttackFunc, SineWave, AmpFunc(512);
SYNTH(Sinewave); 1,1 999;
SEG(AmpFunc); 0,0 1,25 1,50 0,75 0,100;
SEG(GlissFunc);0,1 1,50, 0,100;
SEG(AttackFunc);0,0 1,100;
SEG(DecayFunc);1,1 .6,5 .3,10 .15,25 .07,50 0,100;
	
INSTRUMENT VN1;
VARIABLE Reset1,Noise,/NewMag,OtherFreq,/Gliss,Distance,Stereo,
	Freq,Amp1,Amp2,Duration,AttackTime,DecayTime,Memory1,
	Index1,Index2,Index3,scFreq,DecayLength,Switch1,Switch2,
	/Mod1,/Mod2,/Mod3,/Env,/Att,/Vibrato,IMult,/Snd,
	/Flutter,VibRate,VibAmp,/Ramp,/Decay,VibSwitch,LogFreq,
	GlissLength,Bowing,DecayCall,VibCall,GlissCall,RampCall;
	
Memory1:=1;
	
I_ONLY BEGIN
  Duration:=P2;
  Freq:=P3;
  Amp1:=P4;
  Amp2:=P5;
  OtherFreq:=P6;
  IF Freq&gt;=C THEN Freq:=Freq+Freq/100;
  IF Freq&lt;C THEN Freq:=Freq-20/Freq;
	
  Switch1:=P14;
  Switch2:=1-Switch1;
  IMult:=P7-(Switch2/4);
  VibSwitch:=P8;
  Bowing:=P9;
	
  Distance:=P10;
  Stereo:=P11;
  Noise:=P12;
  GlissLength:=P13;
  LogFreq:=ALOG(Freq);
  
  DecayCall:=VibCall:=RampCall:=GlissCall:=20;
  IF Amp1=Amp2 THEN RampCall:=SRATE;
  IF Freq=OtherFreq THEN GlissCall:=SRATE;
  IF VibSwitch=0 THEN VibCall:=SRATE;
  IF Switch1=1 THEN DecayCall:=SRATE;
	
  Vibrate:=5.25+RAND*.75;
  VibAmp:=.006+RAND*.001;
	
  IF Bowing=0
    THEN
      IF Memory1&gt;.08
	THEN
	  BEGIN
	  DecayTime:=.7;
	  AttackTime:=.2;
	  END
	ELSE
	  BEGIN
	  DecayTime:=.7;
	  AttackTime:=.05;
	  Noise:=0;
	  END
    ELSE
      IF Memory1&gt;.05
	THEN
	  BEGIN
	  DecayTime:=.05;
	  AttackTime:=.2;
	  END
	ELSE
	  BEGIN
	  DecayTime:=.05;
	  AttackTime:=.05;
	  Noise:=0;
	  END;
	
  Memory1:=DecayTime;
	
  IF AttackTime+DecayTime&gt;=Duration
    THEN
      BEGIN
      AttackTime:=Duration*AttackTime;
      DecayTime:=DecayTime*Duration;
      IF AttackTime&lt;=.05 THEN AttackTime:=Duration-DecayTime-.01;
      END;
	
  ScFreq:=Freq*MAG;
  DecayLength:=1000/Freq;
  IF Switch1=0 THEN Noise:=.1;
  Index1:=7.5*IMult/LogFreq;
  Index2:=5/SQRT(Freq);
  Index3:=IMult*30*(8.5-LogFreq)/Freq;
END;
	
Decay:=Switch1+EXPEN[DecayCall](Switch2,MAG*20/DecayLength,DecayFunc);
ENV:=Switch2+LINEN[20](Switch1,AttackTime/20,DecayTime/20,Duration/20,AmpFunc,Reset1:=0);
Ramp:=Amp1+NOSCIL[RampCall](Amp2-Amp1,20*MAG/Duration,AttackFunc);
Gliss:=Freq+EXPEN[GlissCall](OtherFreq-Freq,20*MAG/GlissLength,GlissFunc);
FLutter:=RANDI[VibCall](1,200*Mag);
Vibrato:=NOSCIL[VibCall](ENV,Vibrate*MAG*20,SineWave);
Att:=1-EXPEN[20](1,MAG*640,AttackFunc);
	
NewMag:=(1+Flutter*.005)*(1+Vibrato*VibAmp)*(1+RANDI(Noise*Att,2000*Mag))*Gliss*Mag;
	
Mod1:=NOSCIL(Decay*ScFreq*(Att+Index1),NewMag,Sinewave);
Mod2:=NOSCIL(Decay*ScFreq*(Att+Index2),4*NewMag,Sinewave);
Mod3:=NOSCIL(Decay*ScFreq*(Att+Index3),3*NewMag,Sinewave);
Snd:=ZOSCIL(Decay*ENV*Ramp,NewMag+Mod1+Mod2+Mod3,Sinewave);
OUTA:=OUTA+Snd*0.5;
END;
</pre>
<p>
This instrument required about 60 seconds of computing on a PDP-10
(a $250,000 minicomputer) for 1 second of sound (our normal sampling
rate was 12800).  Since the PDP was massively time-shared, 60 seconds
of computing could involve many minutes of sitting around watching
AI scientists play Space War.
Mus10 was an extension of Music V for the PDP-10 family of computers.
To give a feel for how one worked in those days, here's a brief quote from the Mus10 manual (by Tovar and
Leland Smith, May 1977):
</p>
<pre>
The following generates  1 second of a  440 Hz sine wave  followed by
1/2 sec. of a  660Hz sine wave. The output goes to a file, MUSIC.MSB,
which is written on DSKM.  

COMMENT Fill array with sine wave;
ARRAY SINETABLE[511];
FOR I:=0 STEP 1 UNTIL 511 DO SINETABLE[I]:=SIN(2*PI/512);

INSTRUMENT SINE;
  COMMENT Generate simple sine wave.  P4 = Amplitude, P3 = frequency;
  OUTA:=OUTA+OSCIL(P4,P3*MAG,SINETABLE);
  END;

COMMENT Now, generate the sound;
PLAY ;
  SIMP 0, 1, 440, 1000;
  SIMP 1, 1/2, 660, 1000;
  FINISH;
</pre>
<p>
The computation involved was considered so burdensome, that the names of
the main users were posted in the AI lab halls, apparently to try to
get us to go away.  I was normally the primary user (in terms of computrons) for the entire lab, and I had no intention
of going away.  
In the Samson box world, this (in its initial "chorus" version) was:</p>
<pre>
Instrument(Violin);
RECORD_POINTER(seg) nullfunc;
INTEGER ARRAY gens[1:4],indgens[1:6], GensA[1:4],AmpGens[1:2];
					! synthesizer addresses;
REAL ARRAY ratsA[1:4],Indrats[1:6],ratsB[1:4],AmpRats[1:2];
					! envelope data;
INTEGER ModGens1Sum,i,FuncOffSet,k,GenOutLoc,GenInLoc,ModGens2Sum,x1,x2;

Pars(&lt;(InsName,Beg,Dur,Freq,Amp,Function AmpFunc,Function IndFunc,IndMult,
	SkewMult,Nothing,PcRev,No11,No12,No13,Function SkewFunc)&gt;);
					! the parameters of this instrument;

Dbugit(Pns);				! debugging aid;
GenOutLoc:=CASE (Pn[1] MOD 4) OF (Outma,Outmb,Outmc,Outmd);
					! OUTMA is channel 1, OUTMB channel 2, etc;
if freq&gt;srate/3 then return;		! note too high, so leave it out;
x1:=3;					! modulating frequency checks;
x2:=4;					! (we want them less than srate/2);
If x1*freq&gt;srate/2 Then x1:=1;
If x2*freq&gt;srate/2 then x2:=1;
amp:=Amp/2;				! two carriers, so halve the amplitude;

waiter(Beg);				! wait for the beginning of the note;

indRats[1]:=(x1*Freq*IndMult*((8.5-log(freq))/(3+(freq/1000)))*4/srate) MIN .999;
indRats[2]:=(x2*Freq*IndMult*(1/(freq^.5))*4/srate) MIN .999;
indRats[3]:=(freq*IndMult*(5/log(freq))*4/srate) MIN .999;
indrats[4]:=indrats[1]; indrats[5]:=indrats[2]; indrats[6]:=indrats[3];

ratsA[1]:=x1; ratsA[2]:=x2;     ratsA[3]:=1;     ratsA[4]:=1;	
ratsB[1]:=x1+.002; ratsB[2]:=x2+.003;     ratsB[3]:=1.002;     ratsB[4]:=1;	
					! this is the skewing for the chorus effect;
Gens[1]:=Osc(Pns,ModGens1Sum);		! now set up the oscillators;
Gens[2]:=Osc(Pns,ModGens1Sum);
Gens[3]:=Osc(Pns,ModGens1Sum);
Gens[4]:=Osc(Pns,genInLoc,ModGens1Sum);	! carrier 1;

GensA[1]:=Osc(Pns,ModGens2Sum);
GensA[2]:=Osc(Pns,ModGens2Sum);
GensA[3]:=Osc(Pns,ModGens2Sum);
GensA[4]:=Osc(Pns,genInLoc,ModGens2Sum);! carrier 2;

indgens[1]:=gens[1];   indgens[2]:=gens[2];  indgens[3]:=gens[3];
indgens[4]:=gensA[1];   indgens[5]:=gensA[2];  indgens[6]:=gensA[3];
					! set up envelope addressing;

ModSig(Pns,GenOutLoc,GenInLoc,1-pcRev);	! send signal to DACs;
ModSig(Pns,RevIn,GenInLoc,pcRev);	! and signal to reverberator;

AmpGens[1]:=Gens[4]; AmpGens[2]:=GensA[4]; AmpRats[1]:=1; AmpRats[2]:=1;
					! now add the envelopes;
AddArrEnv(Pns,AmpGens,2,"A",0,Amp/2,AmpFunc,AmpRats);
AddArrEnv(Pns,IndGens,6,"A",0,1,IndFunc,Indrats);
AddArrEnv(Pns,Gens,4,"F",freq,Freq*skewmult,skewfunc,ratsA,
	5,.011,.011,nullfunc,6,.017,.017,nullfunc,0,0);
AddArrEnv(Pns,GensA,4,"F",freq,Freq*skewmult,skewfunc,ratsA,
	6,.010,.010,nullfunc,5,.017,.017,nullfunc,1,0);
End!Instrument(Pns);			! deallocation;
</pre>
<p>
The Sambox version eventually became incredibly complicated, mainly to
try to handle note list problems in the instrument.  The Samson box could
run about 5 or 6 of these in "real-time", similar to a modern-day
500 MHz Pentium running CLM.
The parallel in the Sambox world to the SIMP example above is (this is
taken from SAMBOX.BIL, November 1984):</p>
<pre>
    Instrument(Simp);
    Integer Gen1;
    Gen1:=Osc(Pns,OutA,Zero,SineMode,0,0,Pn[3]);
    AddEnv(Pns,Gen1,"A",0,Pn[4],Pf[5]);
    End_Instrument(Pns);
</pre>
<p>The CLM version of this is:</p>
<pre>
(<a class=quiet href="clm.html#definstrument">definstrument</a> simp (start-time duration frequency amplitude
                     &amp;optional (amp-env '(0 0 50 1 100 0)))
  (multiple-value-bind (beg end) (<a class=quiet href="clm.html#times-&gt;samples">times-&gt;samples</a> start-time duration)
    (let ((s (<a class=quiet href="clm.html#make-oscil">make-oscil</a> frequency))
          (amp (<a class=quiet href="clm.html#make-env">make-env</a> amp-env :scaler amplitude :duration duration)))
      (run
       (loop for i from beg below end do
         (<a class=quiet href="clm.html#outa">outa</a> i (* (<a class=quiet href="clm.html#env">env</a> amp) (<a class=quiet href="clm.html#oscil">oscil</a> s))))))))
</pre>
<p>
In CLM, the fm-violin became (fm.html, 1989):</p>
<pre>
(<a class=quiet href="clm.html#definstrument">definstrument</a> violin (beg end frequency amplitude fm-index)
  (let* ((frq-scl (<a class=quiet href="grfsnd.html#inhz">in-hz</a> frequency))
         (maxdev (* frq-scl fm-index))
         (index1 (* maxdev (/ 5.0 (log frequency))))
         (index2 (* maxdev 3.0 (/ (- 8.5 (log frequency)) (+ 3.0 (/ frequency 1000)))))
         (index3 (* maxdev (/ 4.0 (sqrt frequency))))
         (carrier (<a class=quiet href="clm.html#make-oscil">make-oscil</a> frequency))
         (fmosc1 (<a class=quiet href="clm.html#make-oscil">make-oscil</a> frequency))
         (fmosc2 (<a class=quiet href="clm.html#make-oscil">make-oscil</a> (* 3 frequency)))
         (fmosc3 (<a class=quiet href="clm.html#make-oscil">make-oscil</a> (* 4 frequency)))
         (ampf  (<a class=quiet href="clm.html#make-env">make-env</a> '(0 0 25 1 75 1 100 0) :scaler amplitude))
         (indf1 (<a class=quiet href="clm.html#make-env">make-env</a> '(0 1 25 .4 75 .6 100 0) :scaler index1))
         (indf2 (<a class=quiet href="clm.html#make-env">make-env</a> '(0 1 25 .4 75 .6 100 0) :scaler index2))
         (indf3 (<a class=quiet href="clm.html#make-env">make-env</a> '(0 1 25 .4 75 .6 100 0) :scaler index3))
         (pervib (<a class=quiet href="clm.html#make-triangle-wave">make-triangle-wave</a> :frequency 5 :amplitude (* .0025 frq-scl)))
         (ranvib (make-randi :frequency 16 :amplitude (* .005 frq-scl)))
         (vib 0.0))
    (run
     (loop for i from beg to end do
       (setf vib (+ (<a class=quiet href="clm.html#triangle-wave">triangle-wave</a> pervib) (randi ranvib)))
       (<a class=quiet href="clm.html#outa">outa</a> i (* (<a class=quiet href="clm.html#env">env</a> ampf)
                  (<a class=quiet href="clm.html#oscil">oscil</a> carrier
                         (+ vib 
                            (* (<a class=quiet href="clm.html#env">env</a> indf1) (<a class=quiet href="clm.html#oscil">oscil</a> fmosc1 vib))
                            (* (<a class=quiet href="clm.html#env">env</a> indf2) (<a class=quiet href="clm.html#oscil">oscil</a> fmosc2 (* 3.0 vib)))
                            (* (<a class=quiet href="clm.html#env">env</a> indf3) (<a class=quiet href="clm.html#oscil">oscil</a> fmosc3 (* 4.0 vib)))))))))))
</pre>
<p>or in its actual (non-simplified) form:
</p>
<pre>
(defun bit20 (x)			;Samson box modifier got 2's complement 20 bit interpreted as fraction 
  (if (&gt;= x (expt 2 19))                ;(this needed to keep fm-violin backwards compatible with old note lists)
      (float (/ (- x (expt 2 20)) (expt 2 19)))
    (float (/ x (expt 2 19)))))

(defun make-frobber-function (beg end frobl)
  (let ((result (list beg))
	(val (bit20 (cadr frobl))))
    (loop for x in frobl by #'cddr and 
              y in (cdr frobl) by #'cddr do
      (when (and (&gt;= x beg)
		 (&lt;= x end))
	(push val result)
	(push x result)
	(setf val (bit20 y))))
    (push val result)
    (push end result)
    (push val result)
    (nreverse result)))

(<a class=quiet href="clm.html#definstrument">definstrument</a> fm-violin 
  (startime dur frequency amplitude &amp;key
	    (fm-index 1.0)
	    (amp-env '(0 0  25 1  75 1  100 0))
	    (periodic-vibrato-rate 5.0) 
            (random-vibrato-rate 16.0)
	    (periodic-vibrato-amplitude 0.0025) 
            (random-vibrato-amplitude 0.005)
	    (noise-amount 0.0) (noise-freq 1000.0)
	    (ind-noise-freq 10.0) (ind-noise-amount 0.0)
	    (amp-noise-freq 20.0) (amp-noise-amount 0.0)
	    (gliss-env '(0 0  100 0)) (glissando-amount 0.0) 
	    (fm1-env '(0 1  25 .4  75 .6  100 0)) 
            (fm2-env '(0 1  25 .4  75 .6  100 0)) 
            (fm3-env '(0 1  25 .4  75 .6  100 0))
	    (fm1-rat 1.0) (fm2-rat 3.0)	 (fm3-rat 4.0)                    
	    (fm1-index nil) (fm2-index nil) (fm3-index nil)
	    (base nil) (frobber nil)
	    (reverb-amount 0.01)
	    (index-type :violin)
	    (degree nil) (distance 1.0) (degrees nil)
	    (no-waveshaping nil) (denoise nil)
	    (denoise-dur .1) (denoise-amp .005)
	    &amp;allow-other-keys)
  (if (&gt; (abs amplitude) 1.0) 
      (setf amplitude (clm-cerror ".1?" .1 #'numberp "amplitude = ~A?" amplitude)))
  (if (&lt;= (abs frequency) 1.0) 
      (setf frequency (clm-cerror "440.0?" 440.0 #'numberp "frequency = ~A?" frequency)))
  (let* ((beg (floor (* startime *srate*)))
	 (end (+ beg (floor (* dur *srate*))))
	 (frq-scl (<a class=quiet href="clm.html#hz-&gt;radians">hz-&gt;radians</a> frequency))
	 (modulate (not (zerop fm-index)))
	 (maxdev (* frq-scl fm-index))
	 (vln (not (eq index-type :cello)))
	 (logfreq (log frequency))
	 (sqrtfreq (sqrt frequency))
	 (index1 (or fm1-index (min pi (* maxdev (/ (if vln 5.0 7.5) logfreq)))))
	 (index2 (or fm2-index (min pi (* maxdev 3.0 (if vln 
							     (/ (- 8.5 logfreq) (+ 3.0 (* frequency .001)))
							   (/ 15.0 sqrtfreq))))))
	 (index3 (or fm3-index (min pi (* maxdev (/ (if vln 4.0 8.0) sqrtfreq)))))

	 (easy-case (and (not no-waveshaping)
			 (zerop noise-amount)
			 (eq fm1-env fm2-env)
			 (eq fm1-env fm3-env)
			 (zerop (- fm1-rat (floor fm1-rat)))
			 (zerop (- fm2-rat (floor fm2-rat)))
			 (zerop (- fm3-rat (floor fm3-rat)))
			 (zerop (nth-value 1 (floor fm2-rat fm1-rat)))
			 (zerop (nth-value 1 (floor fm3-rat fm1-rat)))))
	 (coeffs (and easy-case modulate
	 	      (partials-&gt;polynomial
	 	       (list fm1-rat index1
	 		     (floor fm2-rat fm1-rat) index2
	 		     (floor fm3-rat fm1-rat) index3))))
	 ;; that is, we're doing the polynomial evaluation using fm1osc running at fm1-rat * frequency
	 ;; so everything in the polynomial table should be in terms of harmonics of fm1-rat
	 
	 (norm (or (and easy-case modulate 1.0) index1))
	 
	 (carrier (<a class=quiet href="clm.html#make-oscil">make-oscil</a> frequency))
	 (fmosc1  (and modulate (<a class=quiet href="clm.html#make-oscil">make-oscil</a> (* fm1-rat frequency))))
	 (fmosc2  (and modulate (or easy-case (<a class=quiet href="clm.html#make-oscil">make-oscil</a> (* fm2-rat frequency)))))
	 (fmosc3  (and modulate (or easy-case (<a class=quiet href="clm.html#make-oscil">make-oscil</a> (* fm3-rat frequency)))))
	 (ampf  (<a class=quiet href="clm.html#make-env">make-env</a> 
                  (if denoise
                       (reduce-amplitude-quantization-noise amp-env dur amplitude denoise-dur denoise-amp) 
                     amp-env)
	          amplitude :base base :duration dur))
	 (indf1 (and modulate (<a class=quiet href="clm.html#make-env">make-env</a> fm1-env norm :duration dur)))
	 (indf2 (and modulate (or easy-case (<a class=quiet href="clm.html#make-env">make-env</a> fm2-env index2 :duration dur))))
	 (indf3 (and modulate (or easy-case (<a class=quiet href="clm.html#make-env">make-env</a> fm3-env index3 :duration dur))))
	 (frqf (<a class=quiet href="clm.html#make-env">make-env</a> gliss-env (* glissando-amount frq-scl) :duration dur))
	 (pervib (<a class=quiet href="clm.html#make-triangle-wave">make-triangle-wave</a> periodic-vibrato-rate (* periodic-vibrato-amplitude frq-scl)))
	 (ranvib (<a class=quiet href="clm.html#make-rand-interp">make-rand-interp</a> random-vibrato-rate (* random-vibrato-amplitude frq-scl)))
	 (fm-noi (if (and (/= 0.0 noise-amount)
			  (null frobber))
		     (<a class=quiet href="clm.html#make-rand">make-rand</a> noise-freq (* pi noise-amount))))
	 (ind-noi (if (and (/= 0.0 ind-noise-amount) (/= 0.0 ind-noise-freq))
		      (<a class=quiet href="clm.html#make-rand-interp">make-rand-interp</a> ind-noise-freq ind-noise-amount)))
	 (amp-noi (if (and (/= 0.0 amp-noise-amount) (/= 0.0 amp-noise-freq))
		      (<a class=quiet href="clm.html#make-rand-interp">make-rand-interp</a> amp-noise-freq amp-noise-amount)))
	 (frb-env (if (and (/= 0.0 noise-amount) frobber)
		      (<a class=quiet href="clm.html#make-env">make-env</a> (make-frobber-function startime (+ startime dur) frobber) :duration dur
				:base 0	:scaler (* two-pi noise-amount))))
	 (vib 0.0) 
	 (modulation 0.0)
	 (loc (<a class=quiet href="clm.html#make-locsig">make-locsig</a> :degree (or degree degrees (random 90.0)) :reverb reverb-amount :distance distance))
	 (fuzz 0.0)
	 (ind-fuzz 1.0)
	 (amp-fuzz 1.0))
    (run
     (loop for i from beg to end do
       (if (/= 0.0 noise-amount)
	   (if (null frobber)
	       (setf fuzz (<a class=quiet href="clm.html#rand">rand</a> fm-noi))
	     (setf fuzz (<a class=quiet href="clm.html#env">env</a> frb-env))))
       (setf vib (+ (<a class=quiet href="clm.html#env">env</a> frqf) (<a class=quiet href="clm.html#triangle-wave">triangle-wave</a> pervib) (<a class=quiet href="clm.html#rand-interp">rand-interp</a> ranvib)))
       (if ind-noi (setf ind-fuzz (+ 1.0 (<a class=quiet href="clm.html#rand-interp">rand-interp</a> ind-noi))))
       (if amp-noi (setf amp-fuzz (+ 1.0 (<a class=quiet href="clm.html#rand-interp">rand-interp</a> amp-noi))))
       (if modulate
	   (if easy-case
	       (setf modulation
		 (* (<a class=quiet href="clm.html#env">env</a> indf1) 
		    (<a class=quiet href="clm.html#polynomial">polynomial</a> coeffs (<a class=quiet href="clm.html#oscil">oscil</a> fmosc1 vib)))) ;(* vib fm1-rat)??
	     (setf modulation
	       (+ (* (<a class=quiet href="clm.html#env">env</a> indf1) (<a class=quiet href="clm.html#oscil">oscil</a> fmosc1 (+ (* fm1-rat vib) fuzz)))
		  (* (<a class=quiet href="clm.html#env">env</a> indf2) (<a class=quiet href="clm.html#oscil">oscil</a> fmosc2 (+ (* fm2-rat vib) fuzz)))
		  (* (<a class=quiet href="clm.html#env">env</a> indf3) (<a class=quiet href="clm.html#oscil">oscil</a> fmosc3 (+ (* fm3-rat vib) fuzz)))))))
       (<a class=quiet href="clm.html#locsig">locsig</a> loc i
	     (* (<a class=quiet href="clm.html#env">env</a> ampf) amp-fuzz
		(<a class=quiet href="clm.html#oscil">oscil</a> carrier (+ vib (* ind-fuzz modulation)))))))))
</pre>
<p>which is very similar to the Scheme version (v.scm).
It's basically setting up several parallel modulators of one carrier (see <a href="fm.html">fm.html</a>
for details, or (ah nostalgia...) 
Schottstaedt,  "The Simulation of Natural Instrument Tones Using Frequency Modulation with a Complex Modulating Wave", CMJ vol 1 no 4 1977 p46-50). 
The modulators
themselves are modulated (vibrato, noise, etc). The FM indices were chosen to try
to mimic violin or cello sounds over a wide range of frequencies.
There's no limit on what this instrument can do; nearly all my compositions in the 80's used
it.  In CLM, there's fmviolin.clm which shows some of the effects (although it's unfortunately
hard to read due to the way the Sambox system worked).
And I just found this out on the net; I'm no csound expert, so I merely quote what I find:
</p>
<pre>
;ORC
; edited by R. Pinkston, modified for use with MIDI2CS by R. Borrmann
;
;==========================================================================;
;                Schottstaedt FM String Instrument from Dodge              ;
;                                                                          ;
;p4 = amp p5 = pch p6 = rise p7 = dec p8 = vibdel p9 = vibwth p10 = vibrte ;
;==========================================================================;
;        sr      =       44100
;        kr      =       4410
;        ksmps   =       10
;        nchnls  =       1
;
;                instr   1

par
  p_maxamplitude 32000
  p_cps
endpar

        iamp    =       p4

        irise   = .2    ;p6
        idec    = .2    ;p7
        ivibdel = .75   ;p8
        ivibwth = .03   ;p9
        ivibrte = 5.5   ;p10

        ifc     =       p5
        ifm1    =       ifc
        ifm2    =       ifc*3
        ifm3    =       ifc*4
        indx1   =       7.5/log(ifc)    ;range from ca 2 to 1
        indx2   =       15/sqrt(ifc)    ;range from ca 2.6 to .5
        indx3   =       1.25/sqrt(ifc)  ;range from ca .2 to .038
        kvib    init    0 

                timout  0,ivibdel,transient  ;delays vibrato for p8 seconds
        kvbctl  linen   1,.5,p3-ivibdel,.1   ;vibrato control envelope
        krnd    randi   .0075,15        ;random deviation in vib width 
        kvib    oscili  kvbctl*ivibwth+krnd,ivibrte*kvbctl,1 ;vibrato generator
               
transient:
        timout  .2,p3,continue          ;execute for .2 secs only
        ktrans  linseg  1,.2,0,1,0      ;transient envelope 
        anoise  randi   ktrans,.2*ifc   ;noise... 
        attack  oscil   anoise,2000,1   ;...centered around 2kHz

continue: 
        amod1   oscili  ifm1*(indx1+ktrans),ifm1,1
        amod2   oscili  ifm2*(indx2+ktrans),ifm2,1
        amod3   oscili  ifm3*(indx3+ktrans),ifm3,1
        asig    oscili  iamp,(ifc+amod1+amod2+amod3)*(1+kvib),1
        asig    linen   asig+attack,irise,p3,idec
;                out     asig
; 
;                endin
        aright  = asig
        aleft   = asig
</pre>
<p>There's a C/CLM version of this instrument in sndlib.html.  The body of the fm-violin
in C/CLM is:
</p>
<pre>
      if (noise_amount != 0.0) fuzz = mus_rand(fmnoi,0.0);
      if (frqf) vib = mus_env(frqf); else vib = 0.0;
      vib += mus_triangle_wave(pervib, 0.0) + 
             mus_rand_interp(ranvib, 0.0);
      if (easy_case)
        modulation = mus_env(indf1) * 
                     mus_polynomial(coeffs, mus_oscil(fmosc1, vib, 0.0), npartials);
      else
        modulation = mus_env(indf1) * mus_oscil(fmosc1, (fuzz + fm1_rat * vib), 0.0) +
                     mus_env(indf2) * mus_oscil(fmosc2, (fuzz + fm2_rat * vib), 0.0) +
                     mus_env(indf3) * mus_oscil(fmosc3, (fuzz + fm3_rat * vib), 0.0);
      mus_locsig(loc, i, mus_env(ampf) *
                         mus_oscil(carrier, vib + indfuzz * modulation, 0.0));
</pre>

<p>And here is the Ruby version, written by Michael Scholz (see examp.rb):</p>
<pre>
#
# fm_violin([start=0.0[, dur=1.0[, freq=440.0[, amp=0.3[, *args]]]]])
#

def fm_violin(start = 0.0, dur = 1.0, freq = 440.0, amp = 0.3, *args)
  include Math;			# PI

  usage = "fm_violin([start=0.0[, dur=1.0[, freq=440.0[, amp=0.3[, *args]]]]])

	[:fm_index, 1.0]
	[:amp_env, [0, 0, 25, 1, 75, 1, 100, 0]]
	[:periodic_vibrato_rate, 5.0]
	[:random_vibrato_rate, 16.0]
	[:periodic_vibrato_amp, 0.0025]
	[:random_vibrato_amp, 0.005]
	[:noise_amount, 0.0]
	[:noise_freq, 1000.0]
	[:ind_noise_freq, 10.0]
	[:ind_noise_amount, 0.0]
	[:amp_noise_freq, 20.0]
	[:amp_noise_amount, 0.0]
	[:gliss_env, [0, 0,  100, 0]]
	[:gliss_amount, 0.0]
	[:fm1_env, [0, 1, 25, 0.4, 75, 0.6, 100, 0]]
	[:fm2_env, [0, 1, 25, 0.4, 75, 0.6, 100, 0]]
	[:fm3_env, [0, 1, 25, 0.4, 75, 0.6, 100, 0]]
	[:fm1_rat, 1.0]
	[:fm2_rat, 3.0]
	[:fm3_rat, 4.0]
	[:fm1_index, false]
	[:fm2_index, false]
	[:fm3_index, false]
	[:base, 1.0]
	[:reverb_amount, 0.01]
	[:index_type, :violin]
	[:degree, false]
	[:distance, 1.0]
	[:degrees, false]

  Ruby: fm_violin(0, 1, 440, .1, [[:fm_index, 2.0]])
 Guile: (fm-violin 0 1 440 .1 :fm-index 2.0)\n\n";

  fm_index = (args.assoc(:fm_index)[1] rescue 1.0);
  amp_env = (args.assoc(:amp_env)[1] rescue [0, 0, 25, 1, 75, 1, 100, 0]);
  periodic_vibrato_rate = (args.assoc(:periodic_vibrato_rate)[1] rescue 5.0);
  random_vibrato_rate = (args.assoc(:random_vibrato_rate)[1] rescue 16.0);
  periodic_vibrato_amp = (args.assoc(:periodic_vibrato_amp)[1] rescue 0.0025);
  random_vibrato_amp = (args.assoc(:random_vibrato_amp)[1] rescue 0.005);
  noise_amount = (args.assoc(:noise_amount)[1] rescue 0.0);
  noise_freq = (args.assoc(:noise_freq)[1] rescue 1000.0);
  ind_noise_freq = (args.assoc(:ind_noise_freq)[1] rescue 10.0);
  ind_noise_amount = (args.assoc(:ind_noise_amount)[1] rescue 0.0);
  amp_noise_freq = (args.assoc(:amp_noise_freq)[1] rescue 20.0);
  amp_noise_amount = (args.assoc(:amp_noise_amount)[1] rescue 0.0);
  gliss_env = (args.assoc(:gliss_env)[1] rescue [0, 0,  100, 0]);
  gliss_amount = (args.assoc(:gliss_amount)[1] rescue 0.0);
  fm1_env = (args.assoc(:fm1_env)[1] rescue [0, 1, 25, 0.4, 75, 0.6, 100, 0]);
  fm2_env = (args.assoc(:fm2_env)[1] rescue [0, 1, 25, 0.4, 75, 0.6, 100, 0]);
  fm3_env = (args.assoc(:fm3_env)[1] rescue [0, 1, 25, 0.4, 75, 0.6, 100, 0]);
  fm1_rat = (args.assoc(:fm1_rat)[1] rescue 1.0);
  fm2_rat = (args.assoc(:fm2_rat)[1] rescue 3.0);
  fm3_rat = (args.assoc(:fm3_rat)[1] rescue 4.0);
  fm1_index = (args.assoc(:fm1_index)[1] rescue false);
  fm2_index = (args.assoc(:fm2_index)[1] rescue false);
  fm3_index = (args.assoc(:fm3_index)[1] rescue false);
  base = (args.assoc(:base)[1] rescue 1.0);
  reverb_amount = (args.assoc(:reverb_amount)[1] rescue 0.01);
  index_type = (args.assoc(:index_type)[1] rescue :violin);
  degree = (args.assoc(:degree)[1] rescue false);
  distance = (args.assoc(:distance)[1] rescue 1.0);
  degrees = (args.assoc(:degrees)[1] rescue false);

  srate = (srate() rescue $rbm_srate);
  chans = (channels() rescue $rbm_channels);
  beg = (srate * start).round;
  len = (srate * dur).round;
  frq_scl = hz2radians(freq);
  modulate = fm_index.nonzero?;
  maxdev = frq_scl * fm_index;
  vln = (not (index_type == :cello))
  logfreq = log(freq);
  sqrtfreq = sqrt(freq);
  index1 = (fm1_index or [PI, maxdev * (vln ? 5.0 : 7.5) / logfreq].min);
  index2 = (fm2_index or [PI, maxdev * 3.0 * 
	      (vln ? ((8.5 - logfreq) / (3.0 + freq * 0.001)) : (15.0 / sqrtfreq))].min);
  index3 = (fm3_index or [PI, maxdev * (vln ? 4.0 : 8.0) / sqrtfreq].min);
  easy_case = (noise_amount.zero? and
	       (fm1_env == fm2_env) and 
	       (fm1_env == fm3_env) and 
	       (fm1_rat - fm1_rat.floor).zero? and 
	       (fm2_rat - fm2_rat.floor).zero? and 
	       (fm3_rat - fm3_rat.floor).zero?);
  coeffs = (easy_case and modulate and 
	    partials2polynomial([fm1_rat, index1, 
				  (fm2_rat / fm1_rat).floor, index2,
				  (fm3_rat / fm1_rat).floor, index3]));
  norm = ((easy_case and modulate and 1.0) or index1);
  carrier = make_oscil(freq);
  fmosc1 = (modulate and make_oscil(fm1_rat * freq));
  fmosc2 = (modulate and (easy_case or make_oscil(fm2_rat * freq)));
  fmosc3 = (modulate and (easy_case or make_oscil(fm3_rat * freq)));
  ampf = make_env(amp_env, amp, dur, 0.0, base);
  indf1 = (modulate and make_env(fm1_env, norm, dur));
  indf2 = (modulate and (easy_case or make_env(fm2_env, index2, dur)));
  indf3 = (modulate and (easy_case or make_env(fm3_env, index3, dur)));
  frqf = make_env(gliss_env, gliss_amount * frq_scl, dur);
  pervib = make_triangle_wave(periodic_vibrato_rate, periodic_vibrato_amp *  frq_scl);
  ranvib = make_rand_interp(random_vibrato_rate, random_vibrato_amp * frq_scl);
  fm_noi = (noise_amount.nonzero? and make_rand(noise_freq, PI * noise_amount));
  ind_noi = ((ind_noise_amount.nonzero? and ind_noise_freq.nonzero?) and 
	     make_rand_interp(ind_noise_freq, ind_noise_amount));
  amp_noi = ((amp_noise_amount.nonzero? and amp_noise_freq.nonzero?) and
	     make_rand_interp(amp_noise_freq, amp_noise_amount));
  vib = 0.0;
  modulation = 0.0;
  # make_locsig(degree=0.0, distance=1.0, reverb=0.0, output, revout, chans=1, type=Mus_linear)
  # Ruby's rand() is shadowed by CLM's rand(), that's why mus_random().abs.
  loc = make_locsig((degree or degrees or mus_random(90.0).abs), 
		    distance, reverb_amount, false, false, chans);
  fuzz = 0.0;
  ind_fuzz = 1.0;
  amp_fuzz = 1.0;
  out_data = make_vct(len);

  vct_map!(out_data,
	   lambda { | |
	     fuzz = rand(fm_noi) if noise_amount.nonzero?;
	     vib = env(frqf) + triangle_wave(pervib) + rand_interp(ranvib);
	     ind_fuzz = 1.0 + rand_interp(ind_noi) if ind_noi;
	     amp_fuzz = 1.0 + rand_interp(amp_noi) if amp_noi;

	     if(modulate)
	       if(easy_case)
		 modulation = env(indf1) * polynomial(coeffs, oscil(fmosc1, vib));
	       else
		 modulation = env(indf1) * oscil(fmosc1, fm1_rat * vib + fuzz) +
		   env(indf2) * oscil(fmosc2, fm2_rat * vib + fuzz) +
		   env(indf3) * oscil(fmosc3, fm3_rat * vib + fuzz);
	       end
	     end

	     env(ampf) * amp_fuzz * oscil(carrier, vib + ind_fuzz * modulation);
	   });

  if(chans == 2)
    mix_vct(vct_scale!(vct_copy(out_data), locsig_ref(loc, 1)), beg, $rbm_snd, 1, false);
    mix_vct(vct_scale!(out_data, locsig_ref(loc, 0)), beg, $rbm_snd, 0, false);
  else
    mix_vct(out_data, beg, $rbm_snd, 0, false);
  end
rescue
  die(usage + "fm_violin()");
end

</pre>
<br>

<A NAME="wsdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>ws.scm, ws.rb</h2></td></tr></table>
<p>
<i>with-sound</i> is the primary sound producing macro in CLM (in a sense, it is CLM's user-interface).
In Common Lisp it's defined as:</p>
<pre>
 (defmacro with-sound ((&amp;key (srate 22050) ...) &amp;body body) 
   (unwind-protect
     (let (...) ,.body)
     (progn (cleanup...))))
</pre>
<p>and makes extensive use of Lisp's dynamic binding to handle nested with-sound calls and so on.
Kalle Olavi Niemitalo came up with this Scheme/Guile replacement:
</p>
<pre>
(define* (with-sound-helper thunk #:key (srate 22050) (explode #f))
  (let ((old-srate (<a class=quiet href="grfsnd.html#mussrate">mus-srate</a>)))
    (dynamic-wind 
      (lambda () 
        (set! (<a class=quiet href="grfsnd.html#mussrate">mus-srate</a>) srate))
      thunk
      (lambda () 
        (set! (<a class=quiet href="grfsnd.html#mussrate">mus-srate</a>) old-srate)))))

(defmacro with-sound (args . body)
  `(with-sound-helper (lambda () ,@body)
                      ,@args))
</pre>
<p>
The version in ws.scm is simply an amplification of this code.
The global variables that parallel CLM's *clm-...* are:
</p>
<pre>
  <em class=emdef>*clm-srate*</em> (<a class=quiet href="extsnd.html#defaultoutputsrate">default-output-srate</a>)        ; default srate
  <em class=emdef>*clm-file-name*</em> "test.snd"                ; default output file name
  <em class=emdef>*clm-channels*</em> (<a class=quiet href="extsnd.html#defaultoutputchans">default-output-chans</a>)     ; default number of output chans
  <em class=emdef>*clm-data-format*</em> (<a class=quiet href="extsnd.html#defaultoutputformat">default-output-format</a>) ; default output data format
  <em class=emdef>*clm-header-type*</em> (<a class=quiet href="extsnd.html#defaultoutputtype">default-output-type</a>)   ; default output header type
  <em class=emdef>*clm-delete-reverb*</em> #f                    ; should reverb stream be deleted?
  <em class=emdef>*clm-verbose*</em> #f                          ; currently unused
  <em class=emdef>*clm-play*</em> #f                             ; should the output be played at the end
  <em class=emdef>*clm-statistics*</em> #f                       ; should stats be printed out at the end
  <em class=emdef>*clm-reverb*</em> #f                           ; reverb function, if any
  <em class=emdef>*clm-reverb-channels*</em> 1                   ; reverb stream chans
  <em class=emdef>*clm-reverb-data*</em> '()                     ; args pass to reverb function

  <em class=emdef>with-sound</em>
    #:key (srate *clm-srate*)
          (output *clm-file-name*)
	  (channels *clm-channels*)
	  (header-type *clm-header-type*)
	  (data-format *clm-data-format*)
	  (comment #f)
	  ;(verbose *clm-verbose*)
	  (reverb *clm-reverb*)
	  (revfile "test.rev")
	  (reverb-data *clm-reverb-data*)
	  (reverb-channels *clm-reverb-channels*)
	  (continue-old-file #f)
	  (statistics *clm-statistics*)
	  (scaled-to #f)
	  (play *clm-play*)
	  (to-snd *to-snd*)
	  (scaled-by #f)
</pre>
<p>As far as possible, this parallels CLM's <a href="clm.html#with-sound">with-sound</a>.</p>
<pre>
  (with-sound (:srate 44100) (fm-violin 0 1 440 .1))
</pre>
<p>
<b>with-sound</b> opens its output file (<i>output</i> above)
via make-sample-&gt;file, setting the global variable *output*.  This
is equivalent to CLM's *output* variable, and can be used the same
way in outa or locsig.  If <i>reverb</i> is specified, *reverb* is also
opened (corresponding to CLM's *reverb*).  So the cooperating instrument code is:
</p>
<pre>
(definstrument (ins args)
  (let ...
    (ws-interrupt?) ; see below
    (run
      (lambda ()
        (do ((i start (1+ i)))
            ((= i end))
          (<a class=quiet href="clm.html#outa">outa</a> i ... *output*))))))
</pre>
<p>which parallels the Common Lisp CLM (change the loop statement to a do statement,
add the lambda wrapper (needed by the run macro unfortunately),
and you're ready to go).  If the run macro can handle the instrument code (and
it can handle anything the CL version can handle, I think), then the Snd with-sound
should run within a factor of four of the fastest CL-based CLM, even though the
latter is going through the C intermediate file and the (very good) C compiler!  
The easiest way to mix an existing file into the with-sound output is to use
mus-mix with *output*:
</p>
<pre>
(with-sound () 
  (fm-violin 0 .1 440 .1) 
  (<a class=quiet href="grfsnd.html#musmix">mus-mix</a> *output* "oboe.snd") 
  (fm-violin .1 .1 660 .1))
</pre>
<p>To continue adding notes to an existing file, set <i>continue-old-file</i>:
</p>
<pre>
(with-sound (:continue-old-file #t) (fm-violin 0 1 440 .1))
</pre>
<p>with-sound returns the output file name. If a previous file of the same name
is currently open, it is closed before the new version is opened.
</p>
<p>ws.scm also has a version of <a href="clm.html#def-clm-struct">def-clm-struct</a>,
<a href="clm.html#sound-let">sound-let</a>, and <a href="clm.html#mix-and-with-mix">with-mix</a>.  with-sounds and sound-lets can be nested --
see clm.html.
<b>def-clm-struct</b> in Snd/Guile provides a way to package up heterogenous data 
for user-defined generators.  In pure-Scheme it just sets up functions to make
and access such a list, but in Snd's run macro, it also provides type declarations:
</p>
<pre>
(def-clm-struct hiho i x (s "hiho") (ii 3 :type int) (xx 0.0 :type float))
</pre>
<p>defines a structure type ("hiho") with 5 fields.  "hiho-s" defaults to the
string "hiho", "hiho-ii" defaults to 3, and declares that its type will always
be int (so it can be used without restriction in run), and so on.
</p>
<pre>
(define hi (make-hiho :xx 3.14))
</pre>
<p>defines a variable named hi whose value is a hiho structure (a list) with
all the fields taking their default value except "xx" which is set to 3.14.
So, hi's value is <code>(list 'hiho #f #f "hiho" 3 3.14)</code>.
</p>
<p><b>init-with-sound</b> and <b>finish-with-sound</b>
split with-sound into two pieces, primarily for Common Music's benefit.
</p>
<pre>
(define w (init-with-sound :scaled-to .5))
(fm-violin 0 1 440 .1)
(finish-with-sound w)
</pre>
<p>is equivalent to 
</p>
<pre>
(with-sound (:scaled-to .5)
  (fm-violin 0 1 440 .1))
</pre>
<p>ws.scm also has a lightly tested translation of CLM's <a href="clm.html#optional-key">def-optkey-fun</a>.
</p>

<!-- INDEX wsdebug:Debugging (notelists) -->
<A NAME="wsdebug"></a>
<p>with-sound establishes a catch for debugging: 'with-sound-interrupt.  If you
place the macro <b>ws-interrupt?</b> in your instrument, C-g will be caught at
each such point, and control transferred to the with-sound debugging context.
Currently, ws-interrupt? is not supported by the run macro, but each of the
clm-ins.scm instruments includes it just before the run loop.  
Once in the debugger, you are simply in the standard listener loop, but
there are several additional functions to help with debugging:
</p>
<pre>
  <em class=emdef>ws-go</em> (returned-value #f)
  <em class=emdef>ws-locals</em> (stack-location 0)
  <em class=emdef>ws-local</em> local-var (stack-location 0)
  <em class=emdef>ws-backtrace</em> (all #f)
  <em class=emdef>ws-help</em>
  <em class=emdef>ws-quit</em>
  <em class=emdef>ws-quit!</em>
  <em class=emdef>ws-stop</em>
  <em class=emdef>ws-stop!</em>
</pre>
<p>
<b>ws-locals</b> prints out the current instrument's local variables and their values.
<b>ws-local</b> prints one such variable's value (the <i>local-var</i> argument should be a symbol or a string).
<b>ws-help</b> prints out help.
<b>ws-backtrace</b> shows the stack at the point of the interrupt.  The stack trace
is normally truncated to show just the 5 or so inner frames; to get the full
backtrace, call ws-backtrace with an argument of #t.
<b>ws-quit</b> exits with-sound without running the reverb (it does, however, close the current output file).
<b>ws-quit!</b> exits all interrupt levels (in case you called with-sound while in a previous interrupted one, then
interrupted that one as well), returning you to the true top-level.
<b>ws-stop</b> jumps out of the notelist at the interrupted point, but goes ahead and runs any reverb
before closing the output.
<b>ws-stop!</b> is similar to ws-stop, but it also makes sure you're back at the top level at the end.
<b>ws-go</b> continues from the point of the interrupt.
The 'returned-value' is the value to return from the original call on ws-interrupt? (or its equivalent).
</p>
<p>Toward the end of ws.scm is an example, <b>with-marked-sound</b>, that is just
like with-sound except that it adds a mark at the start of each note in the output
sound; the corresponding code in your instrument sets the mark's :ws property
to contain any info you might find amusing.  You then click the mark to see
that info.
</p>
<p>Also defined in ws.scm are the CLM functions <b>seconds-&gt;samples</b> and <b>time-&gt;samples</b>,
and the saved-state-prettification functions <b>mus-data-format-&gt;string</b> and
<b>mus-header-type-&gt;string</b>.  The *clm-* variables are saved in the save-state
file by <b>ws-save-state</b>, which may not be a good idea -- feedback welcome!
</p>
<br>

<A NAME="xmenveddoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>xm-enved.scm, xm-enved.rb</h2></td></tr></table>
<pre>
  <em class=emdef>xe-create-enved</em> name parent args axis
  <em class=emdef>xe-envelope</em> xe-editor
</pre>
<p>This file implements an envelope editor using the xm module.  <b>xe-create-enved</b>
returns a new envelope editor whose X axis label is <i>name</i>, the X and Y axis bounds
are in the list <i>axis</i>, the editor's parent widget is <i>parent</i>,  and the Xt-style
resource argument list is <i>args</i>.  The editor's current envelope is accessible
(read and write) via <i>xe-envelope</i>:
</p>
<pre>
(define outer (add-main-pane "hiho" xmFormWidgetClass '()))
(define editor (xe-create-enved "a name" outer 
			     (list XmNleftAttachment   XmATTACH_FORM
				   XmNtopAttachment    XmATTACH_FORM
				   XmNbottomAttachment XmATTACH_FORM
				   XmNrightAttachment  XmATTACH_FORM)
			     '(0.0 1.0 0.0 1.0)))
(set! (xe-envelope editor) (list 0.0 1.0 1.0 0.5))
</pre>


<A NAME="zipdoc"></a><table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>zip.scm</h2></td></tr></table>
<pre>
  <em class=emdef>make-zipper</em> ramp-env <i>frame-size frame-env</i>
  <a class=def name="zipper">zipper</a> gen in1 in2
  <a class=def name="zipsound">zip-sound</a> beg dur file1 file2 <i>ramp size</i>
</pre>
<p>The zipper generator performs a kind of cross fade, but not one that
tries to be smooth!  It marches through the two sounds taking equal short
portions of each, then abutting them while resampling so that as one
takes less overall frame space, the other takes more.  The <i>frame-size</i>
argument is the maximum length of each twosome in seconds (for initial array allocation), the <i>frame-env</i>
argument determines the current such length as new frames are needed, and the
<i>ramp-env</i> argument determines which of the files gets more space
in the frame (0: all first, 1: all second).
The following function sets up two sounds,
an upward ramp and a downward ramp, then zips them together:
</p>
<pre>
(define (ramp-test)
  (let ((data (<a class=quiet href="extsnd.html#makevct">make-vct</a> 10000)))
    (<a class=quiet href="extsnd.html#newsound">new-sound</a> "new-0.snd")
    (do ((i 0 (1+ i))) ((= i 10000)) 
      (<a class=quiet href="extsnd.html#vctset">vct-set!</a> data i (* i .0001)))
    (<a class=quiet href="extsnd.html#vct_to_samples">vct-&gt;samples</a> 0 10000 data 0)
    (<a class=quiet href="extsnd.html#newsound">new-sound</a> "new-1.snd")
    (do ((i 0 (1+ i))) ((= i 10000)) 
      (<a class=quiet href="extsnd.html#vctset">vct-set!</a> data i (- 1.0 (* i .0001))))
    (<a class=quiet href="extsnd.html#vct_to_samples">vct-&gt;samples</a> 0 10000 data 1)
    (let* ((dur (<a class=quiet href="extsnd.html#frames">frames</a>))
	   (zp (<em class=red>make-zipper</em> (let ((e (<a class=quiet href="clm.html#make-env">make-env</a> '(0 0 1 1) :end dur)))
			      (lambda () (<a class=quiet href="clm.html#env">env</a> e)))))
	  (reader0 (<a class=quiet href="extsnd.html#makesamplereader">make-sample-reader</a> 0 0 0))
	  (reader1 (<a class=quiet href="extsnd.html#makesamplereader">make-sample-reader</a> 0 1 0)))
      (<a class=quiet href="extsnd.html#mapchan">map-chan</a> (lambda (val) (<em class=red>zipper</em> zp reader0 reader1))))))
</pre>
<center><img src="zramp.png" alt="zipper ramp output"></center>
<p>Needless to say, this is not intended to be a suave, romantic gesture!
</p>
<br>

<table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2><A NAME="extsndvarexpl">A Note on Scheme variables in Snd</a></h2></td></tr></table>

<p>At first glance, Snd's use of functions for nearly all variable accesses, i.e. <code>(<a class=quiet href="extsnd.html#listenerprompt">listener-prompt</a>)</code>
rather than the simpler <code>listener-prompt</code>, seems unmotivated.  The following little
program defines "counter" as a scheme variable, accessible in C:
</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;libguile.h&gt;

void inner_main(void *closure, int argc, char **argv)
{
  SCM counter;
  int size = 512;
  char **buffer = NULL;
  buffer = (char **)calloc(1, sizeof(char *));
  buffer[0] = (char *)calloc(size, sizeof(char));
  counter = scm_permanent_object(scm_c_define("counter", scm_long2num(0)));
  while (1)
    {
      getline(buffer, &amp;size, stdin);
      scm_eval_str0(buffer[0]);
      fprintf(stdout, "counter is %d\n", scm_num2int(SCM_VARIABLE_REF(counter), 0, "main"));
    }
}

int main(int argc, char *argv[])
{
  scm_boot_guile(argc, argv, inner_main, 0);
  return(0);
}
</pre>
<p>Now we compile and load it (in Linux: cc g.c -o g -lguile), and it sits in a loop
reading a line at a time, evaluating it, and printing the current value of
our counter:
</p>
<pre>
/home/bil/cl/ g
(+ 1 2)
counter is 0
(set! counter 123)
counter is 123
(set! counter (* counter 2))
counter is 246
</pre>
<p>But the C code itself doesn't see the set!, and there's no way to
tell set! in Guile to call an auxiliary function when our counter
is set.  We need to see that set! as soon as it happens to make the user interface
responsive.  <code>(set! basic-color red)</code> would have no effect unless
our C code could be informed that the <code>basic-color</code> variable's value had changed.
In addition, in Snd, there are perhaps several hundred such variables, and
our C code will run faster if we access C variables as much as possible, rather
than calling scm_num2int (or whatever) every time the value is needed.
So, we first defined each variable along these lines:
</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;libguile.h&gt;

int counter = 0;

SCM g_counter(void)
{
  return(scm_long2num(counter));
}

SCM g_set_counter(SCM newval)
{
  counter = scm_num2int(newval, 0, "set-counter");
  return(newval);
}

void inner_main(void *closure, int argc, char **argv)
{
  int size = 512;
  char **buffer = NULL;
  buffer = (char **)calloc(1, sizeof(char *));
  buffer[0] = (char *)calloc(size, sizeof(char));
  scm_c_define_gsubr("counter", 0, 0, 0, g_counter);
  scm_c_define_gsubr("set-counter", 1, 0, 0, g_set_counter);
  while (1)
    {
      getline(buffer, &amp;size, stdin);
      scm_eval_str0(buffer[0]);
      fprintf(stdout, "counter is %d\n", counter);
    }
}

int main(int argc, char *argv[])
{
  scm_boot_guile(argc,argv, inner_main, 0);
  return(0);
}
</pre>
<p>Now we have two functions:  <code>counter</code> returns (to the Scheme world)
the current value of the C variable <code>counter</code>, and <code>set-counter</code>
sets it:
</p>
<pre>
/home/bil/cl/ g
(+ 1 2)
counter is 0
(set-counter 123)
counter is 123
(set-counter (* (counter) 2))
counter is 246
</pre>
<p>Now the g_set_counter procedure can reflect counter's new value within C,
and the variable lives in C, so two of our problems are solved.
But we don't really want the extra name "set-counter".
So, we use Guile's generalized set! by replacing the two
scm_c_define_gsubr calls above with:
</p>
<pre>
  scm_c_define("counter",
    scm_make_procedure_with_setter(
      scm_c_define_gsubr("", 0, 0, 0, g_counter),
      scm_c_define_gsubr("", 1, 0, 0, g_set_counter)));
</pre>
<p>Now we have Snd's way of handling things:
</p>
<pre>
/home/bil/cl/ g
(+ 1 2)
counter is 0
(set! (counter) 123)
counter is 123
(set! (counter) (* (counter) 2)) 
counter is 246
</pre>
<p>It's not completely ideal, but it's close enough that I don't find it painful to use.
If you run the program above, you'll be annoyed to discover that any error causes
it to exit!  Guile's default is to have no error handler installed, so the throw
that an error generates is not caught, causing the program to exit.  The next
version of our program adds error handling, a cleaner exit mechanism (you can
call the exit procedure to exit), and a simple procedure that adds some amount
to the counter:
</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;libguile.h&gt;

int counter = 0;
SCM g_counter(void) {return(scm_long2num(counter));}

SCM g_set_counter(SCM newval)
{
  counter = scm_num2int(newval, 0, "set-counter");
  return(newval);
}

/* this code needs Guile 1.5 or later */
/* the error handler:  it prints out whatever information the error sent us and returns */

static SCM report_error(void *data, SCM tag, SCM throw_args)
{
  if (SCM_EQ_P(tag, scm_str2symbol("quit"))) exit(0);
  fprintf(stdout, "%s: %s\n", 
	  SCM_STRING_CHARS(scm_object_to_string(tag, SCM_UNDEFINED)), 
	  SCM_STRING_CHARS(scm_object_to_string(throw_args, SCM_UNDEFINED)));
  return(tag);
}

static SCM add_to_counter(SCM val)
{
  SCM_ASSERT_TYPE(SCM_EQ_P(scm_integer_p(val), SCM_BOOL_T), val, SCM_ARGn, "add-to-counter", "an integer");
  counter += scm_num2int(val, 0, "add-to-counter");   /* convert from Scheme to C */
  return(scm_long2num(counter));  /* return our new counter value */
}

static void inner_main(void *closure, int argc, char **argv)
{
  SCM result;
  int size = 512;
  char **buffer = NULL;
  scm_c_define_gsubr("add-to-counter", 1, 0, 0, add_to_counter);

  scm_c_define("counter",
    scm_make_procedure_with_setter(
      scm_c_define_gsubr("", 0, 0, 0, g_counter),
      scm_c_define_gsubr("", 1, 0, 0, g_set_counter)));

  buffer = (char **)calloc(1, sizeof(char *));
  buffer[0] = (char *)calloc(size, sizeof(char));
  while (1)
    {
      /* (exit) to exit */
      fprintf(stdout, "&gt;");
      getline(buffer, &amp;size, stdin);
      result = scm_internal_stack_catch(SCM_BOOL_T, /* this is our "catch" */
					scm_eval_str0, 
					(void *)(buffer[0]), 
					report_error,
					buffer[0]);
      fprintf(stdout, "%s\n",
	      SCM_STRING_CHARS(scm_object_to_string(result, SCM_UNDEFINED)));
    }
}

int main(int argc, char *argv[])
{
  scm_boot_guile(argc, argv, inner_main, 0);
  return(0);
}
</pre>
<p>Now we have our own "read-eval-print" loop:
</p>
<pre>
/home/bil/cl/ g
&gt;(+ 1 2)
3
&gt;counter 
#&lt;procedure-with-setter&gt;
&gt;(counter)
0
&gt;(add-to-counter 32)
32
&gt;(counter)
32
&gt;(add-to-counter 1)
33
&gt;(counter)
33
&gt;(add-to-counter 3.41)
wrong-type-arg: ("add-to-counter" "Wrong type argument (expecting ~A): ~S" ("an integer" 3.41) #f)
wrong-type-arg
&gt;asdf
unbound-variable: (#f "Unbound variable: ~S" (asdf) #f)
unbound-variable
&gt;(<a class=quiet href="extsnd.html#exit">exit</a>)
</pre>
<p>But now the <i>scm_eval_str0</i> use generates a compiler complaint about type
mismatches (though it works).  We can fix that by:
</p>
<pre>
static SCM eval_str_wrapper(void *data) {return(scm_eval_str0((char *)data));}

/* ... */

      result = scm_internal_stack_catch(SCM_BOOL_T,
					eval_str_wrapper, 
					(void *)(buffer[0]), 
					report_error,
					buffer[0]);
</pre>

<br>

<table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2><A NAME="extsndasneededexpl">A Note on "As-Needed" input functions</a></h2></td></tr></table>

<p>Several CLM generators work internally on buffers of data; only the code internal
to the generator knows when it needs input, and how much it needs.  So, src, granulate,
convolve, and phase-vocoder are passed a function either at run-time or when the
generator is allocated that they can call whenever a new value is needed.
A simple C case is:
</p>
<pre>
#include &lt;stdio.h&gt;
#include "clm.h"

typedef struct {
  float val;
} src_state;

float src_input_as_needed(void *arg, int dir) 
{
  src_state *sr = (src_state *)arg;
  sr-&gt;val += (dir * .01); /* just return a ramp */
  return(sr-&gt;val);
}

int main(int argc, char **argv)
{
  mus_any *gen;
  src_state *input;
  int i;
  input = (src_state *)calloc(1, sizeof(src_state));
  input-&gt;val = 0.0;
  gen = mus_make_src(&amp;src_input_as_needed, 0.5, 10, (void *)input);
  for (i=0; i &lt; 100; i++)
    fprintf(stdout, "%f ", mus_src(gen, 0.0, NULL));
    /* or: fprintf(stdout, "%f ", mus_src(gen, 0.0, src_input_as_needed)); */
  mus_free(gen);
  free(input);
  return(0);
}

/* cc g1.c -o g1 -L/usr/local/lib -lguile /home/bil/sndlib/sndlib.a */
/* g1: 0.010000 0.015440 0.020000 0.024761 0.029999 0.035170 0.039999 ... */
</pre>
<p>To put that code in words, the src generator uses the function
<code>src_input_as_needed</code> to fill its internal buffer (convolving
it with sinc); in this case, the "srate" argument is 0.5, so src will
pick up a new input sample (calling src_input_as_needed) on every other
output sample.  In the Scheme CLM (and Snd), the "as-needed" input
function is a Scheme function passed in as Scheme code:
</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;libguile.h&gt;
#include "clm.h"

typedef struct {
  SCM input_func;
} src_state;

float src_input_as_needed(void *ptr, int direction)
{
  src_state *sr = (src_state *)ptr;
  return(scm_num2dbl(scm_call_1(sr-&gt;input_func, scm_long2num(direction)), "input-as-needed"));
}

void inner_main(void *closure, int argc, char **argv)
{
  mus_any *gen;
  src_state *input;
  int i;
  int size = 512;
  char **buffer = NULL;
  buffer = (char **)calloc(1, sizeof(char *));
  buffer[0] = (char *)calloc(size, sizeof(char));
  input = (src_state *)calloc(1, sizeof(src_state));
  fprintf(stdout, "input function: ");
  getline(buffer, &amp;size, stdin);
  input-&gt;input_func = scm_eval_str0(buffer[0]);
  gen = mus_make_src(&amp;src_input_as_needed, 0.5, 10, (void *)input);
  for (i=0; i &lt; 100; i++)
    fprintf(stdout, "%f ", mus_src(gen, 0.0, src_input_as_needed));
  mus_free(gen);
  free(input);
}

int main(int argc, char *argv[])
{
  scm_boot_guile(argc, argv, inner_main, 0);
  return(0);
}

/* cc g1.c -o g1 -L/usr/local/lib -lguile /home/bil/sndlib/sndlib.a */
/* g1
   input function: (let ((val 0.0)) (lambda (dir) (set! val (+ val (* dir .01))) val))
   0.010000 0.015440 0.020000 0.024761 0.029999 0.035170 0.039999
*/
</pre>
<p>In this case, <code>src_input_as_needed</code> is calling the
user-supplied Scheme function (via <code>scm_call_1</code>).
</p>
<br>

<table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2><A NAME="extsndcgens">A Note on User-defined Generators in C-CLM</a></h2></td></tr></table>

<p>In the Common Lisp version of CLM, it's relatively easy to define a new generator. Take for
example, Fernando Lopez-Lezcano's fcomb (a comb filter with a low-pass filter on the feedback), defined as a part of his 
translation of Jezar Wakefield's freeverb reverberator:
</p>
<pre>
(def-clm-struct fcomb
  delay
  filter
  (feedback 0.0))
  
(defmacro fcomb (<a class=quiet href="clm.html#comb">comb</a> input)
  `(<a class=quiet href="clm.html#delay">delay</a> (fcomb-delay ,comb)
	  (+ ,input (* (<a class=quiet href="clm.html#one-zero">one-zero</a> (fcomb-filter ,comb)
				 (<a class=quiet href="clm.html#tap">tap</a> (fcomb-delay ,comb)))
		       (fcomb-feedback ,comb)))))
</pre>
<p>An fcomb generator is then created (in freeverb) via:
</p>
<pre>
(make-fcomb :delay (<a class=quiet href="clm.html#make-delay">make-delay</a> len)
            :feedback room-decay-val
            :filter (<a class=quiet href="clm.html#make-one-zero">make-one-zero</a> :a0 (- 1.0 dmp) :a1 dmp))
</pre>
<p>and called at run-time with:</p>
<pre>
(fcomb (aref combs c j) (<a class=quiet href="clm.html#frame-ref">frame-ref</a> in c))
</pre>
<p>(In this case we have a two dimensional array of these generators).  This, of course,
does not make fcomb a full-fledged generator like oscil -- it doesn't
respond to mus-scaler or the other methods.  To do that
requires a bit of defclass/defmethod overhead in Lisp, something
along the lines of:
</p>
<pre> 
(in-package :clm)

(defclass fcomb (<a class=quiet href="clm.html#comb">comb</a> one-zero) ())

(defmethod fcomb? ((g fcomb)) t)
(defmethod fcomb? ((g t)) nil)

(defun fcomb (gen input)
  (<a class=quiet href="clm.html#delay">delay</a> gen
	 (+ input (* (<a class=quiet href="clm.html#one-zero">one-zero</a> gen (<a class=quiet href="clm.html#tap">tap</a> gen))
		     (<a class=quiet href="clm.html#mus-feedback">mus-feedback</a> gen)))))

(def-optkey-fun make-fcomb (length feedback a0 a1)
  (make-instance 'fcomb :loc 0 :xscl feedback :size length :zsize length :zdly nil
		 :line (make-double-float-array length)
		 :a0 a0 :a1 a1 :x1 0.0))

(defmethod print-object ((d fcomb) stream)
  (format stream "#&lt;(fcomb: size: ~A, loc: ~A, feedback: ~A, a0: ~A, a1: ~A, x1: ~A, line: ~A&gt;"
	  (dly-size d) (dly-loc d) (dly-xscl d)
	  (<a class=quiet href="clm.html#mus-a0">mus-a0</a> d) (<a class=quiet href="clm.html#mus-a1">mus-a1</a> d) (mus-x1 d)
	  (prettified-array (dly-line d)))))
</pre>
<p>And to get the
new (lisp-side, non-macro) generator to be callable within the run macro is yet another set
of headaches (see <a href="clm.html#user-defined-ugs">user-defined generators</a>).
In CLM-in-Scheme, the first (simpler) fcomb above might be:
</p>
<pre>
(define (fcomb gen input)
  (<a class=quiet href="clm.html#delay">delay</a> (car gen)
	 (+ input (* (<a class=quiet href="clm.html#one-zero">one-zero</a> (cadr gen) (<a class=quiet href="clm.html#tap">tap</a> (car gen)))
		     (caddr gen)))))

(define (make-fcomb length feedback a0 a1)
  (list (<a class=quiet href="clm.html#make-delay">make-delay</a> length)
	(<a class=quiet href="clm.html#make-one-zero">make-one-zero</a> a0 a1)
	feedback))
</pre>
<p>Or perhaps a more Schemey (Schemish?) method would be:
</p>
<pre>
(define (fcomb gen input)
  (gen input))	

(define (make-fcomb length feedback a0 a1)
  (let ((dly (<a class=quiet href="clm.html#make-delay">make-delay</a> length))
        (flt (<a class=quiet href="clm.html#make-one-zero">make-one-zero</a> a0 a1)))
    (lambda (input)
      (dly (+ input (* (flt (<a class=quiet href="clm.html#tap">tap</a> dly)) feedback))))))
</pre>
<p>(Here we're returning a closure that packages up the generator's state). 
We could use Guile's object system to conjure up fcomb
classes and methods in Scheme:
</p>
<pre>
(use-modules (oop goops))

(define-class fcmb ()
  (dly :accessor fcomb-delay)
  (flt :accessor fcomb-filter)
  (fdb :accessor fcomb-feedback))

(define (fcomb gen input)
  ((fcomb-delay gen) 
   (+ input (* ((fcomb-filter gen) 
		(<a class=quiet href="clm.html#tap">tap</a> (fcomb-delay gen)))
	       (fcomb-feedback gen)))))

(define-method (initialize (obj fcmb) initargs)
  (next-method)
  (let* ((len (get-keyword :length initargs 0))
	 (feedback (get-keyword :feedback initargs 0.5))
	 (a0 (get-keyword :a0 initargs 0.5))
	 (a1 (get-keyword :a1 initargs 0.5)))
    (set! (fcomb-delay obj) (<a class=quiet href="clm.html#make-delay">make-delay</a> len))
    (set! (fcomb-filter obj) (<a class=quiet href="clm.html#make-one-zero">make-one-zero</a> a0 a1))
    (set! (fcomb-feedback obj) feedback)
    obj))

(define-method (write (obj fcmb) port)
  (display (format #f "#&lt;fcomb: delay: ~A, filter: ~A, feedback: ~A&gt;"
		   (fcomb-delay obj)
		   (fcomb-filter obj)
		   (fcomb-feedback obj))
	   port))
</pre>
<p>
But our real interest here is how to do the same thing in CLM-in-C (clm.c).
The following code implements a comb filter with a one-zero filter on the feedback.
</p>
<pre>
#include &lt;stddef.h&gt;
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include "sndlib.h"
#include "clm.h"
#include "xen.h"
#include "clm2xen.h"

static int MUS_FCOMB = 0; /* this will be our fcomb type identifier */

typedef struct {
  mus_any_class *core;
  int loc, size;
  Float *line;
  Float xscl, a0, a1, x1;
} fcomb;

/* each CLM-in-C generator has mus_any_class *core as the first thing in its structure.
 *   it defines most of the built-in "generic" functions like mus-describe.
 * The next set of functions implement the core functions/
 *   The address of the function is stored in the class's core struct.
 *   For example, the scaler method is defined as Float (*scaler)(mus_any *ptr);
 *   in the mus_any_class declaration (clm.h); for fcomb it will correspond
 *   to the fcomb_scaler function below; it is invoked via mus_scaler(gen)
 *   where gen is an fcomb generator (the actual call is (*((gen-&gt;core)-&gt;scaler))(gen)).
 *   the core-&gt;scaler pointer (the function address) is set in the declaration
 *   of mus_any_class FCOMB_CLASS below.  If a method doesn't apply to a given
 *   generator class, just set its slot to 0.
 */

static bool mus_fcomb_p(mus_any *ptr) {return((ptr) &amp;&amp; ((ptr-&gt;core)-&gt;type == MUS_FCOMB));}

static char *describe_fcomb(mus_any *ptr) 
{
  char *desc = NULL;
  fcomb *gen = (fcomb *)ptr;
  desc = (char *)calloc(1024, sizeof(char));
  if (desc)
    {
      if (mus_fcomb_p((mus_any *)ptr))
	sprintf(desc, "fcomb: scaler: %.3f,  a0: %.3f,  a1: %.3f,  line[%d]", 
		gen-&gt;xscl, gen-&gt;a0, gen-&gt;a1, gen-&gt;size);
      else sprintf(desc, "not an fcomb gen");
    }
  return(desc);
}

static bool fcomb_equalp(mus_any *p1, mus_any *p2) {return(p1 == p2);}
static off_t fcomb_length(mus_any *ptr) {return(((fcomb *)ptr)-&gt;size);}
static Float *fcomb_data(mus_any *ptr) {return(((fcomb *)ptr)-&gt;line);}
static Float fcomb_scaler(mus_any *ptr) {return(((fcomb *)ptr)-&gt;xscl);}
static Float set_fcomb_scaler(mus_any *ptr, Float val) {((fcomb *)ptr)-&gt;xscl = val; return(val);}

static int free_fcomb(mus_any *uptr) 
{
  fcomb *ptr = (fcomb *)uptr;
  if (ptr)
    {
      if (ptr-&gt;line) 
        free(ptr-&gt;line);
      free(ptr); 
    }
  return(0);
}

/* now the actual run-time code executed by fcomb */
/* the extra "ignored" argument is for the run method */

static Float mus_fcomb (mus_any *ptr, Float input, Float ignored) 
{
  fcomb *gen = (fcomb *)ptr;
  Float tap_result, filter_result;
  tap_result = gen-&gt;line[gen-&gt;loc];
  filter_result = (gen-&gt;a0 * tap_result) + (gen-&gt;a1 * gen-&gt;x1);
  gen-&gt;x1 = tap_result;
  gen-&gt;line[gen-&gt;loc] = input + filter_result * gen-&gt;xscl;
  gen-&gt;loc++;
  if (gen-&gt;loc &gt;= gen-&gt;size) gen-&gt;loc = 0;
  return(tap_result);
}

/* this is our core class descriptor */

static mus_any_class FCOMB_CLASS = {
  -1, /* MUS_FCOMB eventually */ /* mus_type: this is assigned at run-time via mus_make_class_tag below */
  "fcomb",                       /* mus_name: class name (used in descriptive/error messages) */
  &amp;free_fcomb,                   /* mus_free: free gen's struct etc */
  &amp;describe_fcomb,               /* mus_describe: user-friendly description */
  &amp;describe_fcomb,               /* mus_inspect: internal debugging description */
  &amp;fcomb_equalp,                 /* mus_equalp: check equality of fcomb gens */
  &amp;fcomb_data,                   /* mus_data: the fcomb delay line, a float array */
  0,                             /* mus_set_data: not implemented for fcomb */
  &amp;fcomb_length,                 /* mus_length: delay line length */
  0,                             /* mus_set_length: not implemented for fcomb */
  0,0,                           /* mus_frequency, mus_set_frequency */
  0,0,                           /* mus_phase, mus_set_phase */
  &amp;fcomb_scaler,                 /* mus_scaler: the feedback term */
  &amp;set_fcomb_scaler,             /* mus_set_scaler */
  0, 0,
  &amp;mus_fcomb,                    /* mus_run: the run-time fcomb function, MUS_RUN(gen) for speed */
  MUS_NOT_SPECIAL,               /* type extension */
  NULL,                     
  0,
  0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0
};

/* now a function to make a new generator */

static mus_any *mus_make_fcomb (Float scaler, int size, Float a0, Float a1)
{
  fcomb *gen = NULL;
  gen = (fcomb *)calloc(1, sizeof(fcomb));
  if (gen == NULL) 
    mus_error(MUS_MEMORY_ALLOCATION_FAILED, 
              "can't allocate struct for mus_make_fcomb!");
  else
    {
      gen-&gt;core = &amp;FCOMB_CLASS;
      if (MUS_FCOMB == 0) 
        {
          MUS_FCOMB = mus_make_class_tag();  /* this gives us a unique fcomb type id */
          gen-&gt;core-&gt;type = MUS_FCOMB;
        }
      gen-&gt;loc = 0;
      gen-&gt;xscl = scaler;
      gen-&gt;x1 = 0.0;
      gen-&gt;a0 = a0;
      gen-&gt;a1 = a1;
      gen-&gt;size = size;
      gen-&gt;line = (Float *)calloc(size, sizeof(Float));
      if (gen-&gt;line == NULL) 
	mus_error(MUS_MEMORY_ALLOCATION_FAILED, 
		  "can't allocate %d bytes for fcomb delay line in mus_make_fcomb!",
		  (int)(size * sizeof(Float)));
    }
  return((mus_any *)gen);
}

/* that is the end of the C side; the rest ties this generator into Guile/Ruby via the Xen package */
/*   in Snd's case, it's actually not needed because the generator is only called from C */

static XEN g_fcomb(XEN obj, XEN input)
{
  return(C_TO_XEN_DOUBLE(mus_fcomb(MUS_XEN_TO_CLM(obj), XEN_TO_C_DOUBLE(input), 0.0)));
}

static XEN g_fcomb_p(XEN obj)
{
  return(C_TO_XEN_BOOLEAN((mus_xen_p(obj)) &amp;&amp; (mus_fcomb_p(MUS_XEN_TO_CLM(obj)))));
}

static XEN g_make_fcomb(XEN scaler, XEN size, XEN a0, XEN a1)
{
  mus_xen *gn;
  gn = (mus_xen *)CALLOC(1,sizeof(mus_xen));
  gn-&gt;gen = mus_make_fcomb(XEN_TO_C_DOUBLE(scaler),
                           XEN_TO_C_INT(size),
                           XEN_TO_C_DOUBLE(a0),
                           XEN_TO_C_DOUBLE(a1));
  gn-&gt;nvcts = 0;
  return(mus_xen_to_object(gn));
}

static void init_fcomb(void)
{
  XEN_DEFINE_PROCEDURE("fcomb?", g_fcomb_p, 1, 0, 0, "(fcomb? gen) -&gt; #t if gen is an fcomb generator");
  XEN_DEFINE_PROCEDURE("make-fcomb", g_make_fcomb, 4, 0, 0, "(make-fcomb scaler size a0 a1) -&gt; new fcomb gen");
  XEN_DEFINE_PROCEDURE("fcomb", g_fcomb, 2, 0, 0, "(fcomb gen input) returns result of running fcomb gen");
}
</pre>


<table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2><A NAME="noisystory">A Note on Noise Reduction</a></h2></td></tr></table>
<!-- INDEX noisystory:Noise Reduction -->

<p>There is no built-in noise reduction function in Snd.  There are so many kinds of
noise (clicks, pops, rumble, hiss, hum, crackle, clips, flutter, "distortion", modulation, echoes, etc),
and what is noise in one context is signal in another (consonants, percussion, etc)
that it's hard to write a single function that can handle every case.
As far as I can tell, looking at other programs that
offer noise reduction, the main trick used is similar to Perry Cook's
Scrubber program, translated to Scheme as anoi in clm-ins.scm or fft-squelch in examp.scm.
Secondary tricks involve smoothing functions similar to smooth-channel,
and enveloping to silence stuff between tracks, etc.
I'd certainly be happy to include in Snd an all-inclusive function for noise reduction,
if anyone sends me one as a gift!  But in the meantime, 
the tools exist to do most of what you normally want to do in
this situation.  
</p>
<p>
In my case, I blithely offered to clean up some recorded telephone conversations.
The first step was to find the clipped locations (where the conversation was
accidentally over-recorded).  I did this first because there were places in the
recordings where the DC offset was huge, causing clipping in a signal that would
otherwise have been safe.  I hoped to reconstruct the signal at the clipped
points, but these would be hard to find once the DC was removed.  A quick check:
</p>

<pre>
  (<a class=quiet href="extsnd.html#lcountmatches">count-matches</a> (lambda (y) (or (&gt; y .9999) (&lt; y -.9999))))
</pre>
<p>
returned 5437 (in 18 minutes of sound).  That seemed high, and I thought "maybe
those are just one sample clicks that can easily be smoothed over", so
</p>
<pre>
(define* (count-clips #:optional snd chn)
  (let ((y0 0.0))
    (<a class=quiet href="extsnd.html#lcountmatches">count-matches</a> 
     (lambda (y) (let ((val (and (or (&gt; y0 .9999) (&lt; y0 -.9999))
				 (or (&gt; y .9999) (&lt; y -.9999)))))
		   (set! y0 y)
		   val))
     0 snd chn)))
</pre>
<p>
But this returned 4768!  So, it's time to make a list of clipped
portions (this function has at least one bug, but I plowed past it -- no
time for perfection...):
</p>
<pre>
(define* (list-clips #:optional snd chn)
  (let* ((max-clips (count-clips snd chn))
	 (clip-data (make-vector (* 2 max-clips) 0))
	 (clip-ctr 0)
	 (clip-beg 0)
	 (clip-end 0)
	 (clip-max-len 0)
	 (in-clip #f)
	 (samp 0))
    (scan-channel
     (lambda (y)
       (if (or (&gt; y .9999) (&lt; y -.9999))
	   (if in-clip
	       (set! clip-end samp)
	       (begin
		 (set! in-clip #t)
		 (set! clip-beg samp)
		 (set! clip-end samp)))
	   (if in-clip
	       (begin
		 (set! in-clip #f)
		 (vector-set! clip-data clip-ctr clip-beg)
		 (vector-set! clip-data (1+ clip-ctr) clip-end)
		 (set! clip-max-len (max clip-max-len (1+ (- clip-end clip-beg))))
		 (set! clip-ctr (+ clip-ctr 2)))))
       (set! samp (1+ samp))
       #f)) ; make sure scan doesn't quit prematurely
    (list clip-ctr clip-max-len clip-data)))
</pre>
<p>
which returned a vector of 669 clipped portions, the worst being 42 samples long!
I saved that data in a separate file, just in case of disaster:
</p>
<pre>
(with-output-to-file "clips" (display (list-clips)))
</pre>
<p>
Since filtering can pad the sound at the beginning, and tends to
change the clipped portions, I decide reconstruct them first.  This will
produce sample values outside -1.0 to 1.0, but I can scale everything
back down at the end.
To see how things look, I reset the graph y bounds:
</p>
<pre>
(set! (<a class=quiet href="extsnd.html#ybounds">y-bounds</a>) (list -1.5 1.5))
</pre>
<p>
Now to conjure up a plausible sine wave between the clip begin and
end points.  (This is also "just-good-enough" software).
</p>
<pre>
(if (not (defined? 'pi)) (define pi 3.141592653589793))

(define (fix-clip clip-beg-1 clip-end-1)
  (if (&gt; clip-end-1 clip-beg-1)
      (let* ((dur (1+ (- clip-end-1 clip-beg-1)))
	     (samps (<a class=quiet href="extsnd.html#channel_to_vct">channel-&gt;vct</a> (- clip-beg-1 4) (+ dur 9)))
	     (clip-beg 3)
	     (clip-end (+ dur 4)))
	(let ((samp0 (<a class=quiet href="extsnd.html#vctref">vct-ref</a> samps clip-beg))
	      (samp1 (<a class=quiet href="extsnd.html#vctref">vct-ref</a> samps clip-end)))
	  (if (or (&gt; samp0 .99) (&lt; samp0 -.99))
	      (begin
	        ;; weird!  some of the clipped passages have "knees"
		;;   this looks nuts, but no time to scratch my head
		(set! clip-beg (1- clip-beg))
		(set! samp0 (<a class=quiet href="extsnd.html#vctref">vct-ref</a> samps clip-beg))
		(if (or (&gt; samp0 .99) (&lt; samp0 -.99))
		    (begin
		      (set! clip-beg (1- clip-beg))
		      (set! samp0 (<a class=quiet href="extsnd.html#vctref">vct-ref</a> samps clip-beg))))))
	  (if (or (&gt; samp1 .99) (&lt; samp1 -.99))
	      (begin
		(set! clip-end (1+ clip-end))
		(set! samp1 (<a class=quiet href="extsnd.html#vctref">vct-ref</a> samps clip-end))
		(if (or (&gt; samp1 .99) (&lt; samp1 -.99))
		    (begin
		      (set! clip-end (1+ clip-end))
		      (set! samp1 (<a class=quiet href="extsnd.html#vctref">vct-ref</a> samps clip-end))))))
          ;; now we have semi-plausible bounds
          ;; make sine dependent on rate of change of current 
	  (let* ((samp00 (<a class=quiet href="extsnd.html#vctref">vct-ref</a> samps (1- clip-beg)))
		 (samp11 (<a class=quiet href="extsnd.html#vctref">vct-ref</a> samps (1+ clip-end)))
		 (dist (- clip-end clip-beg))
		 (incr (/ pi dist))
		 (amp (* .125 (+ (abs (- samp0 samp00)) (abs (- samp1 samp11))) dist)))
	    (if (&gt; samp0 0.0)
                ;; clipped at 1.0
		(do ((i (1+ clip-beg) (1+ i))
		     (angle incr (+ angle incr)))
		    ((= i clip-end))
		  (<a class=quiet href="extsnd.html#vctset">vct-set!</a> samps i (+ 1.0 (* amp (sin angle)))))
                ;; clipped at -1.0
		(do ((i (1+ clip-beg) (1+ i))
		     (angle incr (+ angle incr)))
		    ((= i clip-end))
		  (<a class=quiet href="extsnd.html#vctset">vct-set!</a> samps i (- -1.0 (* amp (sin angle))))))
	    (<a class=quiet href="extsnd.html#vct_to_channel">vct-&gt;channel</a> samps (- clip-beg-1 4))))
	#t) ; return values so I can tell when I hit a 1-sample section during testing
      #f))

(define (fix-it n)
  ;; turn off graphics and fix all the clipped sections
  (set! (<a class=quiet href="extsnd.html#squelchupdate">squelch-update</a>) #t)
  (do ((i 0 (1+ i)))
      ((or (= i n) (c-g?))) 
      ;; "clips" here is a list form of the earlier vector of clip locations
    (fix-clip (list-ref clips (* i 2)) 
	      (list-ref clips (1+ (* i 2)))))
  (set! (<a class=quiet href="extsnd.html#squelchupdate">squelch-update</a>) #f))

(fix-it 669)
</pre>
<p>
This produced 418 edits, with a maxamp of 2.26.  So scale it back down:
<code>(<a class=quiet href="extsnd.html#scaleto">scale-to</a> .9)</code>.
Next I ran some large ffts to see what sort of overall spectrum I had:
<code>(set! (<a class=quiet href="extsnd.html#lfftsize">transform-size</a>) (expt 2 23))</code>.
This showed a massive DC component, and numerous harmonics of 60 Hz.
I decided to get rid of the portions that were clearly noise.  Since I was dealing with
telephone recordings, I assumed anything under 40 Hz or above
4000 Hz was extraneous.
</p>

<pre>
(define* (<a name="notchoutrumbleandhiss">notch-out-rumble-and-hiss</a> #:optional (snd #f) (chn #f))
  (let* ((cur-srate (exact-&gt;inexact (<a class=quiet href="extsnd.html#srate">srate</a> snd))))
    (<a class=quiet href="extsnd.html#filtersound">filter-sound</a>
     (list 0.0 0.0                    ; get rid of DC
	   (/ 80.0 cur-srate) 0.0     ; get rid of anything under 40 Hz (1.0=srate/2 here)
	   (/ 90.0 cur-srate) 1.0     ; now the passband
	   (/ 7000.0 cur-srate) 1.0 
	   (/ 8000.0 cur-srate) 0.0   ; end passband (40..4000)
	   1.0 0.0)                   ; get rid of some of the hiss
     ;; since I'm the minimum band is 10 Hz here, 
     ;;   cur-srate/10 rounded up to next power of 2 seems a safe filter size
     ;;   filter-sound will actually use overlap-add convolution in this case
     (inexact-&gt;exact (expt 2 (ceiling (/ (log (/ cur-srate 10.0)) (log 2.0)))))
     snd chn)))

(notch-out-rumble-and-hiss)
</pre>
<p>
By now it was obvious I needed a simple way to play portions of the
sound before and after an edit, sometimes with a tracking cursor.
So I bound a few keys:
</p>

<pre>
(define (play-from-cursor current)
  (<a class=quiet href="extsnd.html#play">play</a> (<a class=quiet href="extsnd.html#cursor">cursor</a>) #f #f #f #f (if current #f (1- (<a class=quiet href="extsnd.html#editposition">edit-position</a>)))))

(define (play-from-cursor-with-tracking current)
  ;; patterned after pfc in extsnd.html
  (let ((old-tracking (<a class=quiet href="extsnd.html#cursorfollowsplay">cursor-follows-play</a>)))
    (set! (<a class=quiet href="extsnd.html#cursorfollowsplay">cursor-follows-play</a>) #t)
    (add-hook! <a class=quiet href="extsnd.html#stopplayinghook">stop-playing-hook</a> 
	       (lambda (snd)
		 (set! (<a class=quiet href="extsnd.html#cursorfollowsplay">cursor-follows-play</a>) old-tracking)))
    (<a class=quiet href="extsnd.html#play">play</a> (<a class=quiet href="extsnd.html#cursor">cursor</a>) #f #f #f #f (if current #f (1- (<a class=quiet href="extsnd.html#editposition">edit-position</a>))))))

(<a class=quiet href="extsnd.html#bindkey">bind-key</a> (char-&gt;integer #\p) 0 (lambda () "play from cursor" (play-from-cursor #t) keyboard-no-action))
(<a class=quiet href="extsnd.html#bindkey">bind-key</a> (char-&gt;integer #\P) 1 (lambda () "play previous from cursor" (play-from-cursor #f) keyboard-no-action))
(<a class=quiet href="extsnd.html#bindkey">bind-key</a> (char-&gt;integer #\p) 4 (lambda () "play from cursor with tracking" (play-from-cursor-with-tracking #t) keyboard-no-action))
</pre>
<p>
So, if the mouse is in the channel graph, 'p' plays from the cursor,
'P' plays the previous version from the cursor, and 'C-p' plays from
the cursor with a "tracking cursor".
</p>
<p>
In several of the sections (the overall sound consisted of a couple dozen
separate conversations), there was some very loud mid-range tone that I
dubbed "transformer noise".  To figure out what frequencies it represented,
I FFT'd a portion containing only that noise and got this spectrum
(plus a zillion other peaks that didn't look interesting):
</p>
<pre>
((425 .05) (450 .01) (546 .02) (667 .01) (789 .034) (910 .032) (470 .01))
</pre>
<p>To hear that, I took play-sound from play.scm, and
changed it to play a list of sine tones generated on the fly (the changes are in red):
</p>
<pre>
(define (<em class=red>play-sines freqs-and-amps</em>)
  ;; <em class=red>(play-sines '((440 .4) (660 .3)))</em>
  (let* ((size 256)
	 (audio-info (<a class=quiet href="#openplayoutput">open-play-output</a> <em class=red>1 22050</em> #f size))
	 (audio-fd (car audio-info)))
    (set! size (caddr audio-info))
    (if (not (= audio-fd -1))
	(let ((len <em class=red>22050</em>) ; <em class=red>play a one-second tone</em>
	      (<em class=red>oscs (map make-oscil (map car freqs-and-amps))</em>)
	      (<em class=red>amps (map cadr freqs-and-amps)</em>)
	      (data (<a class=quiet href="extsnd.html#makesounddata">make-sound-data</a> outchans size)))  ; the data buffer passed to the function (func above), then to mus-audio-write
	  (set! (dac-size) outbytes)
	  (do ((beg 0 (+ beg size)))
	      ((or (c-g?)                   ; C-g to stop in mid-stream
		   (&lt; beg len)))
	    (do ((i 0 (1+ i)))
		((= i size))
	      (<em class=red>sound-data-set! data 0 i (apply + (map (lambda (o a) (* a (<a class=quiet href="clm.html#oscil">oscil</a> o))) oscs amps))</em>))
	    (<a class=quiet href="extsnd.html#musaudiowrite">mus-audio-write</a> audio-fd data size))
	  (<a class=quiet href="extsnd.html#musaudioclose">mus-audio-close</a> audio-fd))
        #f)))
</pre>
<p>
The only changes to the original function set up and use a list of oscillators, each with
its own amplitude, rather than opening and reading a sound file. (I added this function to play.scm).
I could then resynthesize the suspect tone with:
</p>
<pre>
(play-sines '((425 .05) (450 .01) (546 .02) (667 .01) (789 .034) (910 .032) (470 .01)))
</pre>
<p>
And to my surprise, the result was close to the main portion of the hum.  So now to notch out those frequencies,
and see what is left:
</p>

<pre>
(define* (make-notch-frequency-response cur-srate freqs #:optional (notch-width 2))
  (let ((freq-response (list 0.0 0.0)))
    (for-each
     (lambda (i)
      (set! freq-response (cons (/ (* 2 (- i notch-width)) cur-srate) freq-response))       ; left upper y hz
      (set! freq-response (cons 1.0 freq-response))                                         ; left upper y resp
      (set! freq-response (cons (/ (* 2 (- i (/ notch-width 2))) cur-srate) freq-response)) ; left bottom y hz
      (set! freq-response (cons 0.0 freq-response))                                         ; left bottom y resp
      (set! freq-response (cons (/ (* 2 (+ i (/ notch-width 2))) cur-srate) freq-response)) ; right bottom y hz
      (set! freq-response (cons 0.0 freq-response))                                         ; right bottom y resp
      (set! freq-response (cons (/ (* 2 (+ i notch-width)) cur-srate) freq-response))       ; right upper y hz
      (set! freq-response (cons 1.0 freq-response)))                                        ; right upper y resp
     freqs)
    (set! freq-response (cons 1.0 freq-response))
    (set! freq-response (cons 1.0 freq-response)) 
    (reverse freq-response)))

(define* (notch-channel freqs #:optional (filter-order #f) (snd #f) (chn #f) (notch-width 2))
  (<a class=quiet href="extsnd.html#filtersound">filter-sound</a> (make-notch-frequency-response (exact-&gt;inexact (<a class=quiet href="extsnd.html#srate">srate</a> snd)) freqs notch-width)
		(or filter-order (inexact-&gt;exact (expt 2 (ceiling (/ (log (/ (<a class=quiet href="extsnd.html#srate">srate</a> snd) notch-width)) (log 2.0))))))
		snd chn))

(define* (notch-sound freqs #:optional (filter-order #f) (snd #f) (notch-width 2))
  (<a class=quiet href="extsnd.html#filtersound">filter-sound</a> (make-notch-frequency-response (exact-&gt;inexact (<a class=quiet href="extsnd.html#srate">srate</a> snd)) freqs notch-width)
		(or filter-order (inexact-&gt;exact (expt 2 (ceiling (/ (log (/ (<a class=quiet href="extsnd.html#srate">srate</a> snd) notch-width)) (log 2.0))))))
		snd))

(define* (notch-selection freqs #:optional (filter-order #f) (notch-width 2))
  (<a class=quiet href="extsnd.html#filterselection">filter-selection</a> (make-notch-frequency-response (exact-&gt;inexact (<a class=quiet href="extsnd.html#selectionsrate">selection-srate</a>)) freqs notch-width)
		    (or filter-order (inexact-&gt;exact (expt 2 (ceiling (/ (log (/ (<a class=quiet href="extsnd.html#selectionsrate">selection-srate</a>) notch-width)) (log 2.0))))))))

(notch-sound (list 425 450 470 546 667 789 910) #f 1 10)
</pre>
<p>

And the steady hum was largely erased.  (I added these functions to dsp.scm, with some subsequent changes). Unfortunately, in many cases,
this also changed the timbre of the voices, and that wasn't acceptable
in this context.  
I goofed around with the notch-width and filter-size parameters, looking
for something that that would still do the trick without removing half
the personal side of the voices, but in only a few cases was the result
usable. (The human ear is so attuned to the voice, that you can remove
all but a small passband and still get understandable speech).
In my case, what was being said was not very important, but the
individual characteristics of each voice were.
</p>
<p>
The next step was to take out noisy sections between snipits, mostly
using <code>(<a class=quiet href="extsnd.html#envsoundselection">env-selection</a> '(0 1 1 0 10 0 11 1))</code>
and equalizing each snipit, more or less, with scale-selection-by.
There were a few "you-are-being-recorded" beeps which I deleted (via the Edit
menu delete selection option).  
In some of the conversations,
between sections of speech the background hum would gradually increase, then
the voice would abruptly start with a large peak amplitude. These
were fixed mostly with small-section scale-by's and envelopes.
In the female voice sections, it seemed to help to:
<code>(<a class=quiet href="extsnd.html#filterselection">filter-selection</a> '(0 0 .01 0 .02 1 1 1) 1024)</code>
which got rid of some of the rumble without noticeably affecting
the vocal timbre.
</p>

<p>This may seem like a lot of programming for a simple problem, but
I hadn't previously thought about noise reduction (so nothing was
already written), and once this stuff is written, no one else has
to do anything but load it.  Most of the functions mentioned
here are now in play.scm or dsp.scm.
</p>

<TABLE border=3 bordercolor="tan" hspace=40><tr><td>
<blockquote><small>
<br>
clicks: <a href="extsnd.html#smoothchannel">smooth-channel</a>, <a href="#exremoveclick">remove-click</a>, <a href="sndscm.html#exfftsmoother">fft-smoother</a><br>
rumble, hiss: <a href="#notchoutrumbleandhiss">notch-out-rumble-and-hiss</a>, <a href="#exfftsquelch">fft-squelch</a>, <a href="#exfftcancel">fft-cancel</a><br>
hum: <a href="#notchchannel">notch-channel</a><br>
via CLM ins: <a href="anoi.ins">anoi.ins</a><br>
<br>
</small></blockquote>
</td></tr></TABLE>
<br>


<center>
<table border=1><tr><td>
<table bgcolor="aliceblue" border=0 cellspacing=8><tr><td><small>related documentation:</small></td><td><small><a href="snd.html">snd.html</a></small></td>
<td><small><a href="extsnd.html">extsnd.html</a></small></td><td><small><a href="grfsnd.html">grfsnd.html</a></small></td><td><small><a href="clm.html">clm.html</a></small></td><td><small><a href="sndlib.html">sndlib.html</a></small></td><td><small><a href="fm.html">fm.html</a></small></td><td><small><a href="libxm.html">libxm.html</a></small></td><td><small><a href="index.html">index.html</a></small></td></tr></table>
</td></tr></table>
</center>
</body>
</html>


