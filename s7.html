<html>
<!-- documentation for s7 -->

<head>
<title>s7</title>
<style type="text/css">
<!-- 
	EM.red {color:red; font-style:normal}
        EM.error {color:chocolate; font-style:normal}
        EM.typing {color:maroon; font-style: normal}
        EM.listener {color:darkblue; font-style: normal}
	EM.emdef {font-weight: bold; font-style: normal}
	H1 {text-align: center}
	UL {list-style-type: none}

	A {text-decoration:none}
	A:hover {text-decoration:underline}
	A.quiet {color:black; text-decoration:none}
	A.quiet:hover {text-decoration:underline}
	A.def {font-weight: bold; font-style: normal; text-decoration:none; text-color:black}

	EM.green {color:green; font-style:normal}
-->

</style>
</head>
<body bgcolor=white>

<!-- INDEX s7doc:s7 scheme -->


<br>

<table border=0 bordercolor="lightgreen" width=100% cellpadding=2 cellspacing=0><tr><td bgcolor="lightgreen">
<A NAME="s7doc"></a>
<table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>s7</h2></td></tr></table>
</td></tr></table>


<p>s7 is a Scheme implementation intended as an extension language
for other applications, primarily Snd and Common Music.  It exists as just two files, s7.c and
s7.h, that want only to disappear into someone else's source tree.  There are no libraries,
no run-time init files, and no configuration scripts.
It can be built as a stand-alone
interpreter (see <a href="#repl">below</a>).  s7test.scm is a regression test for s7.
A tarball is available: ftp://ccrma-ftp.stanford.edu/pub/Lisp/s7.tar.gz.  
</p>

<p>
s7 is the default extension language of Snd and sndlib (http://ccrma.stanford.edu/software/snd/),
and Rick Taube's Common Music (commonmusic at sourceforge).  There are X, Motif, Gtk, and openGL bindings
in libxm in the Snd tarball, or at ftp://ccrma-ftp.stanford.edu/pub/Lisp/libxm.tar.gz.
If you're running s7 in a context
that has getenv, file-exists?, and system (Snd for example), you can use s7-slib-init.scm
to gain easy access to slib.  This init file is named "s7.init" in the slib distribution.
</p>

<p>Although it is a descendant of tinyScheme, s7 is closest as a Scheme dialect to Guile 1.8.
I believe it is compatible with r5rs:  you can just ignore all the additions discussed in this file.
It has continuations, dynamic-wind, sort!, 
ratios and complex numbers,
define-macro, keywords, hash-tables, 
threads, multiprecision arithmetic,
generalized set!, format, define*, and so on.
It does not have syntax-rules or any of
its friends, and it does not think there is any such thing
as an inexact integer.  
</p>

<p>This file assumes you know about Scheme and all its problems,
and want a quick tour of where s7 is different.  (Well, it was quick once upon a time).
</p>

<ul>
  <li><a href="#multiprecision">multiprecision arithmetic</a>
  <li><a href="#math">math functions</a>
  <li><a href="#define*">define*</a>
  <li><a href="#macros">define-macro</a>
  <li><a href="#constants">define-constant, symbol-access</a>
  <li><a href="#maketype">make-type</a>
  <li><a href="#pws">procedure-with-setter</a>
  <li><a href="#generalizedset">generalized set!</a>
  <li><a href="#multidimensionalvectors">multidimensional vectors</a>
  <li><a href="#hashtables">hash tables</a>
  <li><a href="#multithreading">multithreading</a>
  <li><a href="#multiplevalues">multiple-values</a>
  <li><a href="#callwithexit">call-with-exit</a>
  <li><a href="#format">format</a>
  <li><a href="#errors">errors, stacktrace, trace</a>
  <li><a href="#procedureinfo">procedure info</a>
  <li><a href="#environments">environments</a>
  <li><a href="#evalstring">eval</a>
  <li><a href="#IO">string IO</a>
  <li><a href="#miscellanea">miscellanea</a>
  <li><a href="#s7rundoc">the run macro</a>
  <li><a href="#FFIexamples">FFI examples</a>
</ul>

<br>
<dl>

<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="multiprecision"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>multiprecision arithmetic</h4></td></tr></table>
</td></tr></table>
</dt>

<dd>
<p>All numeric types, integers, ratios, reals, and complex numbers are supported.
The basic integer and real
types are defined in s7.h, defaulting to long long int and double.  
pi is predefined, as are
most-positive-fixnum and most-negative-fixnum.
s7 can be built with multiprecision support 
for all types,  using the gmp, mpfr, and mpc libraries (set WITH_GMP to 1 in s7.c).  
If multiprecision arithmetic is
enabled, the following functions are included: bignum, bignum?, and bignum-precision.
bignum-precision, which defaults to 128, sets the number of bits each float takes.
pi automatically reflects the current bignum-precision:
</p>

<pre>
&gt; pi
3.141592653589793238462643383279502884195E0

&gt; (bignum-precision)
128

&gt; (set! (bignum-precision) 256)
256

&gt; pi
3.141592653589793238462643383279502884197169399375105820974944592307816406286198E0
</pre>

<p>
bignum? returns #t if its argument is a big number of some type; I use "bignum" 
for any big number, not just integers.  To create a big number,
either include enough digits to overflow the default types, or use the bignum function.
Its argument is a string representing the desired number:
</p>

<pre>
&gt; (bignum "123456789123456789")
123456789123456789

&gt; (bignum "1.123123123123123123123123123")
1.12312312312312312312312312300000000009E0
</pre>

<small>
<blockquote>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>In the non-gmp case, if s7 is built using doubles (s7_Double in s7.h), the float "epsilon" is
around (expt 2 -53), or about 1e-16.  In the gmp case, it is around (expt 2 (- (bignum-precision))).
So in the default case (precision = 128), using gmp:
</p>

<pre>
&gt; (= 1.0 (+ 1.0 (expt 2.0 -128)))
#t
&gt; (= 1.0 (+ 1.0 (expt 2.0 -127)))
#f
</pre>

<p>and in the non-gmp case:
</p>

<pre>
&gt; (= 1.0 (+ 1.0 (expt 2 -53)))
#t
&gt; (= 1.0 (+ 1.0 (expt 2 -52)))
#f
</pre>

</blockquote>
</small>


</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="math"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>math functions</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>
s7 includes:
</p>

<ul>
<li>sinh, cosh, tanh, asinh, acosh, atanh
<li>logior, logxor, logand, lognot, ash, integer-length, integer-decode-float
<li>random
<li>nan?, infinite?
</ul>

<p>
The random function can take any numeric argument, including 0.
The following constants are predefined: pi, most-positive-fixnum, most-negative-fixnum.
Other math-related differences between s7 and r5rs:
</p>

<ul>
<li>rational? and exact mean integer or ratio (i.e. not floating point), inexact means not exact.
<li>floor, ceiling, truncate, and round return (exact) integer results.
<li>"#" does not stand for an unknown digit.
<li>the "@" complex number notation is not supported.
<li>"+i" is not considered a number; include the real part.
<li>modulo, remainder, and quotient take integer, ratio, or real arguments.
<li>lcm and gcd can take integer or ratio arguments.
<li>log takes an optional second argument, the base.
<li>'.' and an exponent can occur in a number in any base.
<li>rationalize returns a ratio! 
</ul>

<pre>
&gt; (exact? 1.0)
#f
&gt; (rational? 1.5)
#f
&gt; (floor 1.4)
1
&gt; (remainder 2.4 1)
0.4
&gt; (modulo 1.4 1.0)
0.4
&gt; (lcm 3/4 1/6)
3/2
&gt; (log 8 2)
3
&gt; (number-&gt;string 0.5 2)
"0.1"
&gt; (string-&gt;number "0.1" 2)
0.5
&gt; (rationalize 1.5)
3/2
</pre>

<small>
<blockquote>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>The exponent itself is always in base 10; this follows gmp usage.
Since Scheme uses "@" for its useless polar notation, s7 doesn't use it for the exponent marker, but that
means <code>(string-&gt;number "1e1" 16)</code> is ambiguous &mdash; is the "e" a digit or an exponent marker?
s7 could perhaps substitute "s" in this case, but instead it just prohibits exponents if the
radix is greater than 10.
</p>

<pre>
&gt; (string-&gt;number "1e9" 2)  ; (expt 2 9)
512.0
&gt; (string-&gt;number "1e1" 12) ; "e" is not a digit in base 12
#f
&gt; (string-&gt;number "1e1" 16) ; (+ (* 1 16 16) (* 14 16) 1)
481
&gt; (string-&gt;number "1.2e1" 3); (* 3 (+ 1 2/3))
5.0
</pre>

<p>Perhaps s7 should use "@"!
</p>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Should s7 predefine the numbers +inf.0, -inf.0, and nan.0?  It doesn't currently, but you can
get them via log:
</p>

<pre>
(define -inf.0 (real-part (log 0.0)))
(define +inf.0 (- (real-part (log 0.0))))
(define nan.0 (/ +inf.0 +inf.0))
</pre>

<p>But what is <code>(/ 1.0 0.0)</code>?  s7 gives a "division by zero" error here, and also in <code>(/ 1 0)</code>.
Guile returns +inf.0 in the first case, which seems reasonable, but a "numerical overflow" error in the second.
Slightly weirder is <code>(expt 0.0 0+i)</code>.  Currently s7 returns 0.0, Guile returns +nan.0+nan.0i,
Clisp and sbcl throw an error.  Everybody agrees that <code>(expt 0 0)</code> is 1, and Guile thinks
that <code>(expt 0.0 0.0)</code> is 1.0.  But <code>(expt 0 0.0)</code> and <code>(expt 0.0 0)</code> return different
results in Guile (1 and 1.0), both are 0.0 in s7, the first is an error in Clisp, but the second returns 1,
and so on &mdash; what a mess!  This mess was made a lot worse than it needs to be when the IEEE decreed that
0.0 equals -0.0, so we can't tell them apart, but that they produce different results in nearly every use!  
</p>

<pre>
scheme@(guile-user)&gt; (= -0.0 0.0)
#t
scheme@(guile-user)&gt; (negative? -0.0)
#f
scheme@(guile-user)&gt; (= (/ 1.0 0.0) (/ 1.0 -0.0))
#f
scheme@(guile-user)&gt;  (&lt; (/ 1.0 -0.0) -1e100 1e100 (/ 1.0 0.0))
#t
</pre>

<p>
How can they be equal? In s7, the sign
of -0.0 is ignored, and they really are equal.
</p>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>The random function takes a range and an optional state, and returns a number 
between zero and the range, of the same type as the range.  It is perfectly reasonable
to use a range of 0, in which case random returns 0.
make-random-state creates a new random state from a seed.  If no state is passed,
random uses some default state initialized from the current time.
</p>

<pre>
&gt; (random 0)
0
&gt; (random 1.0)
0.86331198514245
&gt; (random 3/4)
654/1129
&gt; (random 1+i)
0.86300308872748+0.83601002730848i
&gt; (random -1.0)
-0.037691127513267
&gt; (define r0 (make-random-state 1234))
r0
&gt; (random 100 r0)
94
&gt; (random 100 r0)
19
&gt; (define r1 (make-random-state 1234))
r1
&gt; (random 100 r1)
94
&gt; (random 100 r1)
19
</pre>

</blockquote>
</small>

</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="define*"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>define*, lambda*</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>These are extensions of define and lambda that make it easier to
to deal with optional, keyword, and rest arguments.  
The syntax is very simple: every argument to define* has a default value
and is automatically available as a keyword argument.  The default value
is either #f if unspecified, or given in a list whose first member is
the argument name.
The last argument
can be preceded by :rest or a dot to indicate that all other trailing arguments
should be packaged as a list under that argument's name.  A trailing or rest
argument's default value is '().
You can use
:optional and :key, but they are ignored.  
</p>

<pre>
(<em class=red>define*</em> (hi a (b 32) (c "hi")) (list a b c))
</pre>

<p>Here the argument "a" defaults to #f, "b" to 32, etc.
When the function is called, 
the argument names are bound to their default values, then the function's
current argument list is scanned.  Any name that occurs as a keyword, :arg for example where the parameter name is arg,
sets that argument's new value.  Otherwise, as values occur, they
are plugged into the actual argument list based on their position, counting a keyword/value pair as one argument.
This is called an optional-key list in CLM.  So, taking the function
above as an example:
</p>

<pre>
(hi 1) -&gt; '(1 32 "hi")
(hi :b 2 :a 3) -&gt; '(3 2 "hi")
(hi 3 2 1) -&gt; '(3 2 1)
</pre>

<p>See s7test.scm for many examples.
</p>

<pre>
(<em class=red>define*</em> (make-parameter initial-value converter)
  (let* ((unspecified (if #f #f))   ; #&lt;unspecified&gt;
	 (value (if (procedure? converter) (converter initial-value) initial-value)))
    (<em class=red>lambda*</em> ((val unspecified))
      (if (not (eq? val unspecified))
	  (set! value (if (procedure? converter) (converter val) val)))
      value)))

&gt; (define hiho (make-parameter 12))
hiho
&gt; (hiho)
12
&gt; (hiho 32)
32
&gt; (hiho)
32
</pre>

<small>
<blockquote>
<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>If you want a version of define* that insists
that any arguments before the keyword :optional are required:
</p>

<pre>
(define-macro (define** declarations . forms)
  (let ((name (car declarations))
	(args (cdr declarations)))
    (define (position thing lst count)
      (if (or (null? lst)
	      (not (pair? (cdr lst)))) ; for dotted arg = "rest" arg
	  #f
	  (if (eq? thing (car lst))
	      count
	      (position thing (cdr lst) (+ count 1)))))
    (let ((required-args (position :optional args 0)))
      (if required-args
	  `(define* (,name . func-args)
	     (if (&lt; (length func-args) ,required-args)
		 (error "~A requires ~D argument~A: ~A" 
			',name ,required-args 
                        (if (&gt; ,required-args 1) "s" "") 
                        func-args)
		 (apply (lambda* ,args ,@forms) func-args)))
	  `(define* ,declarations ,@forms)))))

&gt; (define** (hi a :optional (b 23)) (list a b))
hi
&gt; (hi 1)
(1 23)
&gt; (hi)
;hi requires 1 argument: ()
</pre>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>If a define* argument's default value is an expression, it is evaluated in the definition environment at
the time of the procedure call:
</p>

<pre>
(let ((c 1))
  (define* (a (b (+ c 1))) b)
  (set! c 2)
  (let ((c 123))
    (a))) ; (+ c 1) here is (+ 2 1) so this returns 3
</pre>

<p>Since the expression is not evaluated until the procedure is called, it is ok
to use variables that are undefined at the definition point:
</p>

<pre>
&gt; (define* (a (b c)) b)
a
&gt; c
;c: unbound variable
&gt; (define c 123)
c
&gt; (a)
123
</pre>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>To try to catch what I believe are usually mistakes, I added two
error checks.  One is triggered if you set the same parameter twice
in the same call, and the other if an unknown keyword is encountered
in the key position.  These problems arise in a case such as
</p>

<pre>
(define* (f (a 1) (b 2)) (list a b))
</pre>

<p>You could do any of the following by accident:
</p>

<pre>
(f 1 :a 2)  ; what is a?
(f :b 1 2)  ; what is b?
(f :c 3)    ; did you really want a to be :c and b to be 3?
</pre>

<p>In the last case, to pass a keyword deliberately, either include the
argument keyword: <code>(f :a :c)</code>, or make the default value a keyword:
<code>(define* (f (a :c) ...))</code>.
To turn off this error check, add :allow-other-keys at the end of the parameter list.
</p>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>s7's lambda* arglist handling is not the same as CL's lambda-list.  First,
you can have more than one :rest parameter:
</p>

<pre>
&gt; ((lambda* ((a 1) :rest b :rest c) (list a b c)) 1 2 3 4 5)
(1 (2 3 4 5) (3 4 5))
</pre>

<p>and second, the rest parameter, if any, takes up an argument slot just like any other
argument:
</p>

<pre>
&gt; ((lambda* ((b 3) :rest x (c 1)) (list b c x)) 32)
(32 1 ())

&gt; ((lambda* ((b 3) :rest x (c 1)) (list b c x)) 1 2 3 4 5)
(1 3 (2 3 4 5))
</pre>

<p>CL would agree with the first case if we used &amp;key for 'c', but would give an error in the second.
Of course, the major difference is that s7 keyword arguments don't insist that the key be present.
The :rest argument is needed in cases like these because we can't use expression
such as:
</p>

<pre>
&gt; ((lambda* ((a 3) . b c) (list a b c)) 1 2 3 4 5)
stray dot?
</pre>

<p>Yet another nit: the :rest argument is not considered a keyword argument, so
</p>

<pre>
&gt; (define* (f :rest a) a)
f
&gt; (f :a 1)
(:a 1)
</pre>

</blockquote>
</small>

</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="macros"></a>
<table border=0 bordercolor="lightgreen" width=80% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>macros</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>define-macro, define-macro*, defmacro, defmacro*, macroexpand, gensym, and macro?
implement the standard (CL-style) macro definers.  
</p>

<pre>
(define-macro (add-1 arg) `(+ 1 ,arg))
(defmacro add-1 (arg) `(+ 1 ,arg))
</pre>

<p>macroexpand can help debug a macro:
</p>

<pre>
&gt; (define-macro (add-1 arg) `(+ 1 ,arg))
add-1
&gt; (macroexpand (add-1 32))
(+ 1 32)
</pre>

<p>gensym returns a symbol that is guaranteed to be unused.  It takes an optional string argument
giving the new symbol name's prefix.
</p>

<pre>
(defmacro pop! (sym)
  (let ((v (<em class=red>gensym</em>)))
    `(let ((,v (car ,sym)))
       (set! ,sym (cdr ,sym))
       ,v)))
</pre>

<p>As in define*, the starred forms give optional and keyword arguments:
</p>

<pre>
&gt; (define-macro* (add-2 a (b 2)) `(+ ,a ,b))
add-2
&gt; (add-2 1 3)
4
&gt; (add-2 1)
3
&gt; (add-2 :b 3 :a 1)
4
</pre>

<p>See s7test.scm for many examples including such perennial favorites as
when, loop, dotimes, do*, enum, pushnew, and defstruct.
</p>

<p>macro? returns #t if its argument is a macro or a symbol whose value is a macro.
We can use it, and other macro-related stuff to make a version of macroexpand-all:
</p>

<pre>
(define-macro (fully-expand form)
  (define (expand form)
    (if (pair? form)
	(if (<em class=red>macro?</em> (car form))
	    (expand ((eval (procedure-source (car form))) form))
	    (cons (expand (car form))
		  (expand (cdr form))))
	form))
  (expand form))

&gt; (define-macro (hi a) `(+ 1 ,a))
hi
&gt; (define-macro (ha c) `(hi (+ ,c 1)))
ha
&gt; (fully-expand (define (ho b) (+ 1 (ha b))))
ho
&gt; (procedure-source ho)
(lambda (b) (+ 1 (+ 1 (+ b 1))))
</pre>

<p>fully-expand expands each macro it encounters by using the
procedure-source of that macro, that is, the function that the macro definition
expanded into:
</p>

<pre>
(define-macro (hi a) `(+ ,a 1))

&gt; (procedure-source hi)
(lambda ({defmac}-18) (apply (lambda (a) ({list} '+ a 1)) (cdr {defmac}-18)))
</pre>

<small>
<blockquote>
<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>I hesitate to mention this, but macros are first-class entities in s7.  You can
pass one as a function argument, apply it to a list, return it from a function,
and assign it to a variable:
</p>

<pre>
&gt; (define-macro (hi a) `(+ ,a 1))
hi
&gt; (apply hi '(4))
5
&gt; (define (fmac mac) (apply mac '(4)))
fmac
&gt; (fmac hi)
5
&gt; (define (fmac mac) (mac 4))
fmac
&gt; (fmac hi)
5
&gt; (define (make-mac)
    (define-macro (hi a) `(+ ,a 1))
    hi)
make-mac

&gt; (let ((x (make-mac)))
    (x 2))
3
</pre>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Backquote (quasiquote) in s7 is almost trivial.  Constants are unchanged, symbols are quoted,
",arg" becomes "arg", and ",@arg" becomes "(apply values arg)" &mdash; hooray for real multiple values!
It's almost as easy to write the actual macro body as the backquoted version of it.
</p>

<pre>
&gt; (define-macro (hi a) `(+ 1 ,a))
hi
&gt; (procedure-source hi)
(lambda ({defmac}-16) (apply (lambda (a) <em class=red>({list} '+ 1 a))</em> (cdr {defmac}-16)))

;; so (define-macro (hi a) ({list} + 1 a)) is the same

&gt; (define-macro (hi a) `(+ 1 ,@a))
hi
&gt; (procedure-source hi)
(lambda ({defmac}-17) (apply (lambda (a) <em class=red>({list} '+ 1 ({apply} {values} a)))</em> (cdr {defmac}-17)))

;; same: (define-macro (hi a) ({list} + 1 ({apply} {values} a)))

&gt; (define-macro (hi a) ``(+ 1 ,,a))
hi
&gt; (procedure-source hi)
(lambda ({defmac}-18) (apply (lambda (a) <em class=red>({list} '{list} ({list} 'quote '+) 1 a))</em> (cdr {defmac}-18)))
</pre>

<p>and so on.  "{list}" is a special version of "list" to avoid name collisions
and handle a few tricky details (similarly for "{values}" and "{apply}").
</p>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>s7 macros are not hygienic.  For example,
</p>

<pre>
  (define-macro (mac b) 
    `(let ((a 12)) 
       (+ a ,b)))

  (let ((a 1) 
        (+ *))
    (mac a))
</pre>

<p>returns 144 because "+" has turned into "*", and "a" is the internal "a",
not the argument "a".  We get <code>(* 12 12)</code> where we probably expected <code>(+ 12 1)</code>.
It is possible to use gensym to clean this up, but that makes the macro 
unreadable in all but the simplest cases.  It is also possible, but not very easy, to
write a macro to do the gensymification for us, but in s7 it is much more straightforward
to use the environment functions.
The procedure-environment of a macro is the environment at its definition time, just like a function.
By wrapping the macro body in with-environment, we make sure anything in that body reflects 
the definition environment, not the calling environment.  We then augment that environment
with the macro arguments getting their values from the call-time environment:
</p>

<pre>
(define-macro (define-immaculo name-and-args . body)
  (let* ((gensyms (map (lambda (g) (gensym)) (cdr name-and-args)))
	 (args (cdr (copy name-and-args)))
	 (name (car name-and-args))
	 (set-args (map (lambda (a g) `(list ',g ,a)) args gensyms))
	 (get-args (map (lambda (a g) `(quote (cons ',a ,g))) args gensyms)))

    `(define-macro ,name-and-args
       `(let ,(list ,@set-args)                 ; get the current macro arg values
	  ,(list 'with-environment 
		 (append (list 'augment-environment) 
			 (list (list 'procedure-environment ,name)) 
			 (list ,@get-args))     ; import the current arg values into the definition environment
		 ,@body)))))
</pre>

<p>In this version of define-immaculo, don't unquote the macro arguments in the body, and
use <code>(apply values body)</code> in place of ",@body".
</p>

<pre>
&gt; (define-immaculo (mac b) `(let ((a 12)) (+ a b)))
mac
&gt; (let ((a 21) (+ *)) (mac a))
33
</pre>

<p>
If the slight difference in syntax is a problem
</p>

<pre>
(define-macro (define-immaculo name-and-args . body)
  (let* ((gensyms (map (lambda (g) (gensym)) (cdr name-and-args)))
	 (args (cdr (copy name-and-args)))
	 (name (car name-and-args))
	 (set-args (map (lambda (a g) `(list ',g ,a)) args gensyms))
	 (get-args (map (lambda (a g) `(quote (cons ',a ,g))) args gensyms))
	 (blocked-args (map (lambda (a) `(,a ',a)) args))        
	 (new-body (list (eval `(let (,@blocked-args) ,@body)))))

    `(define-macro ,name-and-args
       `(let ,(list ,@set-args)
          ,(list 'with-environment 
                 (append (list 'augment-environment) 
                         (list (list 'procedure-environment ,name)) 
                         (list ,@get-args))
                 ',@new-body)))))

&gt; (define-immaculo (mac c d) `(let ((a 12) (b 3)) (+ a b ,c ,d)))
mac
&gt; (let ((a 21) (b 10) (+ *)) (mac a b))
46
&gt; (let ((a 21) (b 10) (+ *)) (mac a (+ b 10))) ; here '+' is '*'
136

&gt; (macroexpand (define-immaculo (mac c d) `(let ((a 12) (b 3)) (+ a b ,c ,d))))
(define-macro (mac c d) 
  ({list} 'let 
    (list (list '{gensym}-23 c)        ; here we get the call-time macro argument values
          (list '{gensym}-24 d)) 
      (list 'with-environment 
            (append (list 'augment-environment) 
                                       ; now wrap the body in the augmented definition-time environment
                    (list (list 'procedure-environment mac)) 
                                       ; add the macro args to the definition-time env
                    (list '(cons 'c {gensym}-23) 
                          '(cons 'd {gensym}-24))) 
    '(let ((a 12) 
           (b 3)) 
       (+ a b c d)))))

&gt; (let ((a 21) (b 10) (+ *)) (macroexpand (mac a b)))

(let (({gensym}-22 a)    ; pick up mac args, this is arg 'c' with the value 'a'
      ({gensym}-23 b)) 
  (with-environment (augment-environment (procedure-environment #&lt;macro&gt;)
                      (cons 'c {gensym}-22) ; add them to definition-time env
		      (cons 'd {gensym}-23)) 
    (let ((a 12) 
	  (b 3)) 
      (+ a b c d)))) ; 'a' and 'b' are local, 'c' and 'd' are from the augmented env
</pre>


<p>This is not the end of the story.
Macro expansion happens
in two different environments.  Leaving aside quasiquote which operates at read-time without reference to any environment,
a macro first evaluates its body to form a piece
of code, a list with the macro's arguments plugged in.  Then
it evaluates that code.  So the expansion into a piece of code takes place in one
environment (the definition-time environment), and the code evaluation takes place
in another (the call-time environment).  This can be very frustrating!  Say we
decide to write a "symbol-set!" macro (borrowed in an oblique way from CL's set).
<code>(symbol-set! var val)</code> should evaluate "var", getting a symbol as its
value, then plug that symbol into <code>(set! var-value val)</code>.  For example,
after expansion we want something like:
</p>

<pre>
&gt; (let ((x 32) (y 'x)) 
    (eval (list 'set! y 123)) ; (symbol-set! y 123) ideally
    (list x y))
(123 x)
</pre>

<p>If we define our macro in the local context, then the initial expansion
into (set! x 123) takes place in a context where "y" is defined:
</p>

<pre>
&gt; (let ((x 32) (y 'x))
    (define-macro (symbol-set! var val)
      `(set! ,(symbol-&gt;value var) ,val))
    (symbol-set! y 123)
    (list x y))
(123 x)
</pre>

<p>But if we try to define that at the top level so we can use it anywhere, 
"var" may not be defined in the environment where the initial list is created:
</p>

<pre>
&gt; (define-macro (symbol-set! var val)
    `(set! ,(symbol-&gt;value var) ,val))
symbol-set!
&gt; (let ((x 32) (y 'x))
    (symbol-set! y 123)
    (list x y))
;y: unbound variable, line 3
;    ({list} 'set! (symbol-&gt;value var) val)
</pre>

<p>Exactly the same thing happens in CL:
</p>

<pre>
&gt; (defmacro symbol-set (var val) `(setf ,(eval var) ,val))
SYMBOL-SET
&gt; (let ((x 32) (y 'x)) (symbol-set y 123))
*** - EVAL: variable Y has no value
</pre>

<p>Our "unhygienic" macros are too clean!  We want both the expansion into
code and the evaluation of the code to happen in the call-time environment.
Since this is a step backward for computer science, I've called these
dirty macros, "bacros":
</p>

<pre>
&gt; (define-bacro (symbol-set! var val) 
   `(set! ,(symbol-&gt;value var) ,val))
symbol-set!
&gt; (let ((x 32) (y 'x)) 
    (symbol-set! y 123) 
    (list x y))
(123 x)
</pre>

<p>Or maybe "hacro"?  Use eval in place of symbol-&gt;value, and...
</p>

<pre>
&gt; (let ((x #(1 2 3)) 
        (y `(x 1))) 
    (symbol-set! y 123) 
    (list x y))
(#(1 123 3) (x 1))
</pre>

<p>s7 uses a bacro to implement macroexpand so that it can handle locally defined macros.
By the way, bacros solve part of our original problem:
</p>

<pre>
  (define-bacro (mac b) 
    `(let ((a 12)) 
       (+ a ,(symbol-&gt;value b))))

  (let ((a 1))
    (mac a))
</pre>

<p>returns 13! No variable capture! Perhaps we can massage this idea a bit:
</p>

<pre>
(set! *#readers*
  (cons (cons #\_ (lambda (str)
		    `(with-environment 
                       (initial-environment) 
                       ,(string-&gt;symbol (substring str 1)))))
	*#readers*))

(define-bacro* (mac b)
  `(#_let ((a 12)) 
     (#_+ a ,(eval b)))) ; eval rather than symbol-&gt;value so that 'b' can be any expression
</pre>

<p>Guaranteed hygienic!  
I'm not sure it's a big improvement over immaculos or gensyms, but it works.
</p>



<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>There is another problem with macros: accidental loops.  Take the following
example; we're trying to write a macro that defines a function
that returns its argument in a list statement.
</p>

<pre>
&gt; (define-macro (hang arg) `(define ,arg `(list (cdr ,,arg)))) ; obvious, no?
hang

&gt; (macroexpand (hang (f a)))
(define #1=(f a) ({list} 'list ({list} 'cdr #1#)))

&gt; (hang (f a))
f

&gt; (procedure-source f)
(lambda #1=(a) ({list} 'list ({list} 'cdr (f . #1#))))

&gt;(f 1)
</pre>

<p>And now we are hung.  As I think is clear from the procedure source, we've created a procedure with a
circular list in its definition!  This is surprisingly easy to do by accident.
Here's one way out:
</p>

<pre>
&gt; (define-macro (hang arg) `(define ,arg `(list ,,@(cdr arg))))
hang
&gt; (macroexpand (hang (f a)))
(define (f a) ({list} 'list a))
&gt; (hang (f a))
f
&gt; (f 1)
(list 1)
</pre>

<p>The moral of this story is: if you see a circular list in macroexpand, break
the loop! Unfortunately, there are insidious hidden loops:
</p>

<pre>
(define-macro* (mac (env (current-environment))) 
  `(display ,env))
</pre>

<p>looks innocuous, and its expanded source shows no loops, but we should have quoted the
env reference!  This code is structurally equivalent to
</p>

<pre>
(let ((lst (list (cons 1 2)))) 
  (set! (cdr (car lst)) lst) 
  (eval lst))
</pre>

<p>because the 'env' argument is in the current environment and points to it at the same time.
This (or its CL equivalent) will cause stack overflow in sbcl and clisp, and
will segfault s7 due to a stack overflow internally.
</p>



<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>But we should end on a happy note.  Here is Peter Seibel's once-only macro:
</p>

<pre>
  (defmacro once-only (names . body)
    (let ((gensyms (map (lambda (n) (gensym)) names)))
      `(let (,@(map (lambda (g) `(,g (gensym))) gensyms))
	 `(let (,,@(map (lambda (g n) ``(,,g ,,n)) gensyms names))
	    ,(let (,@(map (lambda (n g) `(,n ,g)) names gensyms))
	       ,@body)))))
</pre>

<p>From the land of sparkling bacros:
</p>

<pre>
(define-bacro (once-only names . body)
  `(let (,@(map (lambda (name) `(,name ,(eval name))) names))
     ,@body))
</pre>

<!--
A bacro is expanded in the call-time environment, so it can't be optimized in the same
way that CL macros sometimes are.  Since a CL macro does not evaluate its arguments, and
its expansion depends only on its definition environment, some lisps conclude that it can be expanded once and
for all the first time it is encountered, and replaced by its result (some piece of code) &mdash;
self-modifying code in effect.  This optimization is available in s7 under the name
define-expansion, with some caveats.  The thing defined by define-expansion is fully
expanded at read-time, so it must have a globally unique name, and it must depend
only on the global read-time environment.  But the CL way of doing macros is problematic.
Normally in lisp, if you redefine a function in its definition environment, then evaluate some code that calls
that function, you get the new version.  If a macro has already been expanded out of existence, 
it effectively ignores redefinition.  Similar gotchas apply to macros defined after they appear.

example:
(define (hi a) (+ 1 a))
(define (use-hi b) (hi b))
(let ((x (use-hi 1)))
  (format #t "x: ~A~%" x))
(define (hi a) (+ 2 a))
(let ((x (use-hi 1)))
  (format #t "x: ~A~%" x))

prints:
x: 2
x: 3
in s7, Guile, clisp, sbcl (using CL syntax of course),

but

(defmacro hi (a) `(+ 1 ,a))
(define (use-hi b) (hi b))
(let ((x (use-hi 1)))
  (format #t "x: ~A~%" x))
(defmacro hi (a) `(+ 2 ,a))
(let ((x (use-hi 1)))
  (format #t "x: ~A~%" x))

prints:
x: 2
x: 2

in every case but s7 which still says the 2nd x is 3.  

If we use the macro before defining it (as is perfectly legal for functions):

(define (use-hi b) (hi b))
(defmacro hi (a) `(+ 1 ,a))
(let ((x (use-hi 1)))
  (format #t "x: ~A~%" x))
(defmacro hi (a) `(+ 2 ,a))
(let ((x (use-hi 1)))
  (format #t "x: ~A~%" x))

s7 still says x is 2 then 3, Guile throws an error: "Wrong type to apply: #<syntax-transformer hi>";
clisp says 2 then 3! and sbcl gives the error: "HI is being redefined as a macro when it was previously assumed to be a function."
Incredible.


A bacro can be viewed as a function that does not
evaluate its arguments, but to avoid the extra evaluation after expansion we need
to quote the result (if the result does not already evaluate to itself):

(define-bacro (when test . body)
  (if (eval test)
      `',(eval `(let () ,@body))))

(let ((x 1)) (when (> x 0) '(list '+ x 3)))
-> '(list + x 3)


-->




</blockquote>
</small>

</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="constants"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>define-constant, constant?, symbol-access</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>define-constant defines a constant and constant? returns #t if its argument
is a constant.  A constant in s7 is really constant: it can't be set or rebound.
</p>

<pre>
&gt; (define-constant var 32)
var

&gt; (set! var 1)
;set!: can't alter immutable object: var

&gt; (let ((var 1)) var)
;can't bind or set an immutable object: var, line 1
</pre>

<p>This has the possibly surprising side effect that previous uses of the constant name
become constants:
</p>

<pre>
 (define (func a) (let ((cvar (+ a 1))) cvar))
 (define-constant cvar 23)
 (func 1)
 ;can't bind or set an immutable object: cvar
</pre>

<p>So, obviously, choose unique names for your constants, or don't use define-constant.
A function can also be a constant. 
</p>

<p>Constants are very similar to things such as keywords (no set, always return itself as its value),
variable trace (informative function upon set or keeping a history of past values), typed variables (restricting a
variable's values or doing automatic conversions upon set), and notification upon set (either in Scheme
or in C; I wanted this many years ago in Snd).  The notification function is especially useful if
you have a Scheme variable and want to reflect any change in its value immediately in C (see <a href="#notify">below</a>).
All of these cases modify
the path between a symbol and its value.  
s7 gives you a handle on that path via the procedure-with-setter <b>symbol-access</b>.
<code>(symbol-access symbol)</code> returns that symbol's accessors, and <code>(set! (symbol-access symbol) accessor-list)</code>
changes them.  The accessor-list is a list of three functions, the get, set, and bind functions.
The set and bind functions take two arguments, the symbol in question
and the value that it is about to be set or bound to.  The variable is set or bound to the value they return.
We could replace define-constant, and add
local constants with:
</p>

<pre>
(define constant-access 
  (list #f
	(lambda (symbol new-value) 
	  (format #t "can't change constant ~A's value to ~A" symbol new-value)
          'error)
	(lambda (symbol new-value) 
	  (format #t "can't bind constant ~A to a new value, ~A" symbol new-value)
          'error)))

(define-macro (define-constant symbol value)
  `(begin
     (define ,symbol ,value)
     (set! (<em class=red>symbol-access</em> ',symbol) constant-access)
     ',symbol))

(define-macro (let-constant vars . body)
  (let ((varlist (map car vars)))
    `(let ,vars
       ,@(map (lambda (var)
		`(set! (<em class=red>symbol-access</em> ',var) constant-access))
	      varlist)
       ,@body)))
</pre>


<p>In the next example, we restrict the values a variable can take to integers:
</p>

<pre>
(define-macro (define-integer var value)
  `(begin
     (define ,var ,value)
     (set! (<em class=red>symbol-access</em> ',var) 
	   (list #f
		 (lambda (symbol new-value)
		   (if (real? new-value)
		       (floor new-value) ; or min/max to restrict it to some range etc
                       (begin 
                         (format #t "~A can only take an integer value, not ~S" symbol new-value)
                         'error)))
		 #f))
     ',var))

&gt; (define-integer int 123)
int
&gt; (set! int 321.67)
321
&gt; (set! int (list 1 2))
;int can only take an integer value, not (1 2)
</pre>

<p>Here are trace and untrace.  We save the previous accessors in trace, restore them upon untrace,
and in between, call the previous set accessor, if any, after reporting the set:
</p>

<pre>
(define (trace var)
  (let* ((cur-access (<em class=red>symbol-access</em> var))
	 (cur-set (and cur-access (cadr cur-access))))
    (set! (<em class=red>symbol-access</em> var)
	  (list (and cur-access (car cur-access))
		(lambda (symbol new-value) 
		  (format #t "~A set to ~A~%" symbol new-value) 
		  (if cur-set 
		      (cur-set symbol new-value)
		      new-value))
		(and cur-access (caddr cur-access))
		cur-access)))) ; save the old version 

(define (untrace var)
  (if (and (symbol-access var)
	   (cdddr (symbol-access var)))
      (set! (symbol-access var) (cadddr (symbol-access var)))))
</pre>

<p>The "get" function is currently not implemented.
I believe symbol-access is similar to Ruby's hooked variables, or perhaps Perl's tied variables.
We could implement all kinds of things
with this mechanism, including property lists.
</p>

</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="maketype"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>make-type</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>
<b>make-type</b>, borrowed from Alaric Snell-Pym,
returns a type-object: a list of three functions
'?, 'make, and 'ref.  The <b>?</b> func returns #t if its argument
is of the new type, the <b>make</b> function returns a new object of the new type with the
value of the argument to the make function, and the <b>ref</b> function returns that value
when passed that object. 
</p>

<A NAME="recordexample"></a>
<pre>
(define special-value ((cadr (<em class=red>make-type</em>)) 'special))
;; now special-value's value can't be eq? to any other scheme object

;; expand, for example, (define-record rec (a 1) (b 2))
(begin
  (define rec? #f)
  (define make-rec #f)
  (define rec-a #f)
  (define rec-b #f)

  (let* ((rec-type (<em class=red>make-type</em>))
	 (? (car rec-type))
	 (make (cadr rec-type))
	 (ref (caddr rec-type)))

    (set! make-rec (lambda* ((a 1) (b 2))
		     (make (vector a b))))

    (set! rec? ?)
  
    (set! rec-a (make-procedure-with-setter
		 (lambda (obj)
		   (and (rec? obj)
			(vector-ref (ref obj) 0)))
		 (lambda (obj val)
		   (if (rec? obj)
		       (vector-set! (ref obj) 0 val)))))

    (set! rec-b (make-procedure-with-setter
		 (lambda (obj)
		   (and (rec? obj)
			(vector-ref (ref obj) 1)))
		 (lambda (obj val)
		   (if (rec? obj)
		       (vector-set! (ref obj) 1 val)))))))

#|
(let ((hi (make-rec 32 '(1 2))))
  (set! (rec-b hi) 123)
  (format #t "rec: ~A ~A" 
	  (rec-a hi)
	  (rec-b hi)))

"rec: 32 123"
|#
</pre>

<p>Currently make-type takes some optional arguments to specify other actions.  
I might change this to be an alist of (operation function) pairs, but for now,
the optional (optkey) arguments are: print equal getter setter length name copy fill.
Except for the 'name' argument, these are functions.
When these functions are called, the argument representing the object is
the value of the object, not the object itself; see the examples below.
If no print function is specified, the 'name' argument is used when the
object is displayed.
The 'equal' function checks two objects of the new type for equality.
The 'getter' function applies the object to whatever arguments are
passed, and the 'setter' function does the same in the context of set!.
The 'length' function returns the length of the object's value.
The 'copy function returns a new object of the same type with the copy
function applied to the old object's value.
The 'fill' function takes two arguments, the object and what to
fill its value with.
So, remembering that (cadr type) is the make function:
</p>

<pre>
&gt; ((cadr (make-type)) 3.14)
#&lt;anonymous-type 3.14&gt;

&gt; ((cadr (make-type :name "hiho")) 123)
#&lt;hiho 123&gt;

&gt; ((cadr (make-type :print (lambda (a) (format #f "#&lt;typo: |~A|&gt;" a)))) 1)
#&lt;typo: |1|&gt;

&gt; (((cadr (make-type :getter (lambda (a b) (vector-ref a b)))) (vector 1 2 3)) 1)
2
</pre>

<p>The last is easier to read if we separate out the steps:
</p>

<pre>
&gt; (let* ((type (make-type 
                 :getter (lambda (a b) 
                           (vector-ref a b))))   ; make a new type with its own getter function
         (object ((cadr type) (vector 1 2 3))))  ; create an object of the new type, its value is a vector
       (object 1))                               ; apply the object to 1 =&gt; (vector-ref object 1) via the getter
2
</pre>

<p>The objects created in this way, or via s7_new_type in C, can be passed to for-each
if you supply the length and getter functions to make-type.
</p>

<small>
<blockquote>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Here is define-record using make-type.  It has a few Common Lisp extensions:
</p>

<pre>
(define-macro (define-record struct-name . fields)
  (let* ((name (if (list? struct-name) (car struct-name) struct-name))
	 (sname (if (string? name) name (symbol-&gt;string name)))
		 
	 (fsname (if (list? struct-name)
		     (let ((cname (assoc :conc-name (cdr struct-name))))
		       (if cname 
			   (symbol-&gt;string (cadr cname))
			   sname))
		     sname))
		 
	 (make-name (if (list? struct-name)
			(let ((cname (assoc :constructor (cdr struct-name))))
			  (if cname 
			      (cadr cname)
			      (string-&gt;symbol (string-append "make-" sname))))
			(string-&gt;symbol (string-append "make-" sname))))

	 (is-name (string-&gt;symbol (string-append sname "?")))
		 
	 (copy-name (if (list? struct-name)
			(let ((cname (assoc :copier (cdr struct-name))))
			  (if cname 
			      (cadr cname)
			      (string-&gt;symbol (string-append "copy-" sname))))
			(string-&gt;symbol (string-append "copy-" sname))))
		 
	 (field-names (map (lambda (n)
			     (symbol-&gt;string (if (list? n) (car n) n)))
			   fields))
		 
	 (field-types (map (lambda (field)
			     (if (list? field)
				 (apply (lambda* (val type read-only) type) (cdr field))
				 #f))
			   fields))
		 
	 (field-read-onlys (map (lambda (field)
				  (if (list? field)
				      (apply (lambda* (val type read-only) read-only) (cdr field))
				      #f))
				fields)))
    `(begin

       ;; declare our globally-accessible names
       (define ,is-name #f)
       (define ,make-name #f)
       (define ,copy-name #f)

       ,@(map (lambda (n)
		`(define ,(string-&gt;symbol (string-append fsname "-" n)) #f))
	      field-names)

       (let* ((rec-type (<em class=red>make-type</em>))
	      (? (car rec-type))
	      (make (cadr rec-type))
	      (ref (caddr rec-type)))
	       
	 (set! ,is-name ?)

	 (set! ,make-name (lambda* ,(map (lambda (n)
					    (if (and (list? n)
						     (&gt;= (length n) 2))
						(list (car n) (cadr n))
						(list n #f)))
					  fields)
			    (make (vector ',(string-&gt;symbol sname) ,@(map string-&gt;symbol field-names)))))

	 (set! ,copy-name (lambda (obj) 
			    (make (copy (ref obj)))))	       

	 ,@(map (let ((ctr 1))
		  (lambda (n type read-only)
		    (let ((val (if read-only
				   `(set! ,(string-&gt;symbol (string-append fsname "-" n))
					  (lambda (arg) ((ref arg) ,ctr)))
				   `(set! ,(string-&gt;symbol (string-append fsname "-" n))
					  (make-procedure-with-setter 
					   (lambda (arg) ((ref arg) ,ctr)) 
					   (lambda (arg val) (set! ((ref arg) ,ctr) val)))))))
		      (set! ctr (+ 1 ctr))
		      val)))
		field-names field-types field-read-onlys)

	',struct-name))))

&gt; (define-record point (x 0.0) (y 0.0))
point
&gt; (let ((pt (make-point 1.0))) 
    (set! (point-y pt) 3.0)
    (list (point? pt) (point-x pt) (point-y pt)))
(#t 1.0 3.0)
</pre>	


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>In the next example, we define a float-vector type:
</p>

<pre>
(begin
  (define make-float-vector #f)
  (define float-vector? #f)
  (define float-vector #f)

  (let* ((fv-type (<em class=red>make-type</em>
		   :getter vector-ref :length length :copy copy :fill fill!
		   :setter (lambda (obj index value)
			     (if (not (real? value))
				 (error 'wrong-type-arg-error "float-vector element must be real: ~S" value))
			     (vector-set! obj index (exact-&gt;inexact value)))
		   :name "float-vector"))
	 (fv? (car fv-type))
	 (make-fv (cadr fv-type))
	 (fv-ref (caddr fv-type)))

    (set! make-float-vector 
      (lambda* (len (initial-element 0.0))
        (if (not (real? initial-element))
	    (error 'wrong-type-arg-error "make-float-vector initial element must be real: ~S" initial-element))
	(make-fv (make-vector len (exact-&gt;inexact initial-element)))))
    
    (set! float-vector? fv?)
    
    (set! float-vector
      (lambda args
	(let* ((len (length args))
	       (fv (make-float-vector len))
	       (v (fv-ref fv)))
	  (do ((lst args (cdr lst)))
	       (i 0 (+ i 1)))
	      ((null? lst) fv)
	    (let ((arg (car lst)))
	      (if (not (real? arg))
		  (error 'wrong-type-arg-error "float-vector element must be real: ~S in ~S" arg args))
	      (set! (v i) (exact-&gt;inexact arg))))))))

&gt; (let ((v (make-float-vector 3))) (set! (v 1) 32) v)
#&lt;float-vector #(0.0 32.0 0.0)&gt;

&gt; (let ((v (make-float-vector 3))) (set! (v 1) "hi") v)
;float-vector element must be real: "hi"

&gt; (map + (list 1 2 3) (float-vector 1 2 3)) ; we have a getter and length, so map and for-each will work
(2.0 4.0 6.0)
</pre>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>I seem to be using the same construct over and over; a begin to hold the names defined in the outer
environment, a let to hold internal stuff, and set!s to give the names values.  It's a clumsy, but 
simple way for multiple functions to share a closure.
Maybe it rates a macro:
</p>

<pre>
(define-macro (blet* names bindings . body)
  `(begin
     ,@(map (lambda (name)
	      `(define ,name #f))
	    names)
     (let* ,bindings
	,@body)))

(blet* (make-adjustable-vector adjustable-vector? adjust-vector)

       ((av-type (<em class=red>make-type</em> :name "adjustable-vector"
			    :getter (lambda (obj index)
				      ((car obj) index))
			    :setter (lambda (obj index value)
				      (set! ((car obj) index) value))
		            :length (lambda (obj)
			              (vector-length (car obj)))
			    :print (lambda (obj)
				     (object-&gt;string (car obj)))))
	(av? (car av-type))
	(make-av (cadr av-type))
	(av-ref (caddr av-type)))

  (set! make-adjustable-vector (lambda args 
				 (make-av (list (apply make-vector args)))))
  (set! adjustable-vector? av?)
  (set! adjust-vector (lambda* (obj new-length initial-element)
		        (let* ((new-vector (make-vector new-length initial-element))
			       (copy-len (min new-length (length obj))))
			  (do ((i 0 (+ i 1)))
			      ((= i copy-len))
			    (set! (new-vector i) (obj i)))
			  (set! (car (av-ref obj)) new-vector)))))

&gt; (define v (make-adjustable-vector 3 #f))
v

&gt; v
#(#f #f #f)

&gt; (set! (v 1) 32.0)
32.0

&gt; v
#(#f 32.0 #f)

&gt; (adjust-vector v 10 #f)
#(#f 32.0 #f #f #f #f #f #f #f #f)
</pre>

</blockquote>
</small>

</dd>
<br><br>



<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="pws"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>procedure-with-setter</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>A procedure-with-setter consists of two functions, the "getter" and the "setter".
The getter is called when the object is encountered as a function, and the setter when
it is set:
</p>

<pre>
(define xx (let ((x 32))
             (<em class=red>make-procedure-with-setter</em>
               (lambda () x) 
               (lambda (val) (set! x val) x))))
(xx) -&gt; 32
(set! (xx) 1)
(xx) -&gt; 1
</pre>

<p>The setter's last argument is the value passed to set!.  That is, 
</p>

<pre>
(define v123 
  (let ((vect (vector 1 2 3)))
    (make-procedure-with-setter
      (lambda (index) 
        (vector-ref vect index))     ; using explicit indexing -- (vect index) is the same (see "generalized set!" below)
      (lambda (index value) 
        (vector-set! vect index value)))))

&gt; (v123 2)
3
&gt; (set! (v123 2) 32)
32
&gt; (v123 2)
32
</pre>

<small>
<blockquote>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Here is a pretty example of make-procedure-with-setter:
</p>

<pre>
(define-macro (c?r path)
  ;; "path" is a list and "X" marks the spot in it that we are trying to access
  ;; (a (b ((c X)))) -- anything after the X is ignored, other symbols are just placeholders
  ;; c?r returns a procedure-with-setter that gets/sets X

  (define (X-marks-the-spot accessor tree)
    (if (pair? tree)
	(or (X-marks-the-spot (cons 'car accessor) (car tree))
	    (X-marks-the-spot (cons 'cdr accessor) (cdr tree)))
	(if (eq? tree 'X) accessor #f)))

  (let ((body 'lst))
    (for-each
     (lambda (f)
       (set! body (list f body)))
     (reverse (X-marks-the-spot '() path)))

    `(<em class=red>make-procedure-with-setter</em>
      (lambda (lst) 
	,body)
      (lambda (lst val)
	(set! ,body val)))))

&gt; ((c?r (a b (X))) '(1 2 (3 4) 5))
3

&gt; (let ((lst (list 1 2 (list 3 4) 5))) 
   (set! ((c?r (a b (X))) lst) 32)
   lst)
(1 2 (32 4) 5)

&gt; (procedure-source (c?r (a b (X))))
(lambda (lst) (car (car (cdr (cdr lst)))))

&gt; ((c?r (a b . X)) '(1 2 (3 4) 5))
((3 4) 5)

&gt; (let ((lst (list 1 2 (list 3 4) 5))) 
   (set! ((c?r (a b . X)) lst) '(32))
   lst)
(1 2 32)

&gt; (procedure-source (c?r (a b . X)))
(lambda (lst) (cdr (cdr lst)))

&gt; ((c?r (((((a (b (c (d (e X)))))))))) '(((((1 (2 (3 (4 (5 6)))))))))) 
6

&gt; (let ((lst '(((((1 (2 (3 (4 (5 6))))))))))) 
    (set! ((c?r (((((a (b (c (d (e X)))))))))) lst) 32) 
    lst)
(((((1 (2 (3 (4 (5 32)))))))))

&gt; (procedure-source (c?r (((((a (b (c (d (e X)))))))))))
(lambda (lst) (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (car (car (car lst)))))))))))))))
</pre>	

<br>

<p>We can extend c?r into something incredibly useful!  A goto implementation using circular lists:
</p>

<pre>
(define-macro (define-with-goto name-and-args . body)
  ;; run through the body collecting label accessors, (label name)
  ;; run through getting goto positions, (goto name)
  ;; tie all the goto's to their respective labels (via set-cdr! essentially)
  
  (define (find-accessor type)
    (let ((labels '()))
      (define (gather-labels accessor tree)
	(if (pair? tree)
	    (if (equal? (car tree) type)
		(begin
		  (set! labels (cons (cons (cadr tree) 
					   (let ((body 'lst))
					     (for-each
					      (lambda (f)
						(set! body (list f body)))
					      (reverse (cdr accessor)))
					     (make-procedure-with-setter
					      (apply lambda '(lst) (list body))
					      (apply lambda '(lst val) `((set! ,body val))))))
				     labels))
		  (gather-labels (cons 'cdr accessor) (cdr tree)))
		(begin
		  (gather-labels (cons 'car accessor) (car tree))
		  (gather-labels (cons 'cdr accessor) (cdr tree))))))
      (gather-labels '() body)
      labels))
	
  (let ((labels (find-accessor 'label))
	(gotos (find-accessor 'goto)))
    (if (not (null? gotos))
	(for-each
	 (lambda (goto)
	   (let* ((name (car goto))
		  (goto-accessor (cdr goto))
		  (label (assoc name labels))
		  (label-accessor (and label (cdr label))))
	     (if label-accessor
		 (set! (goto-accessor body) (label-accessor body))
		 (error 'bad-goto "can't find label: ~S" name))))
	   gotos))

    `(define ,name-and-args
       (let ((label (lambda (name) #f))
	     (goto (lambda (name) #f)))
	 ,@body))))

(define-with-goto (hi)
  (display "start ")
  (<em class=red>goto</em> 'the-end)
  (display "oops")
  (<em class=red>label</em> 'the-end)
  (display "all done"))

(hi) -&gt; "start all done"
</pre>



<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>
I wonder if it would be more consistent to use the
name "procedure/setter" in place of "make-procedure-with-setter".
Its syntax is closer to
vector than make-vector, for example.  
Even better: "dilambda":
</p>

<pre>
(define-macro (dilambda getter setter)
  `(make-procedure-with-setter
     (lambda ,@getter)
     (lambda ,@setter)))

(let ((a 32)) 
  (dilambda (() a) 
            ((b) (set! a b))))
</pre>

<p>"bilambda" would mix Latin and Greek since the Romans used "el", not "lambda", according to Wikipedia.
</p>

</blockquote>
</small>
<br>

</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="generalizedset"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>applicable objects, generalized set!, generic functions</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>procedure-with-setters can be viewed as one generalization of set!.  Another
treats objects as having predefined get and set functions.  In s7
lists, strings, vectors, hash-tables, and any cooperating C or Scheme-defined objects
are both applicable and settable.  newLisp calls this implicit indexing, Gauche implements it
via object-apply, Guile via procedure-with-setter; CL's funcallable instance might be the same idea.
</p>

<p>
In <code>(vector-ref #(1 2) 0)</code>, for example, vector-ref is just a type
declaration.  But in Scheme, type declarations are unnecessary, so we get exactly
the same result from <code>(#(1 2) 0)</code>.  Similarly, <code>(lst 1)</code> is the
same as <code>(list-ref lst 1)</code>, and <code>(set! (lst 1) 2)</code> is the same
as <code>(list-set! lst 1 2)</code>.
I like this syntax:  the less noise, the better!
</p>

<pre>
;; an example taken from R Cox's website

(define dense (make-vector 128))
(define sparse (make-vector 128))
(define n 0)

(define (add-member i)
  (set! (dense n) i)
  (set! (sparse i) n)
  (set! n (+ n 1)))

(define (is-member i)
  (and (number? (sparse i))
       (&lt; (sparse i) n)
       (= (dense (sparse i)) i)))

(define (clear-all) (set! n 0))

(define (remove-member i)
  (if (is-member i)
      (begin
	(let ((j (dense (- n 1))))
	  (set! (dense (sparse i)) j)
	  (set! (sparse j) (sparse i))
	  (set! n (- n 1))))))

(add-member 32)
1
(add-member 12)
2
(is-member 14)
#f
(is-member 12)
#t
</pre>

<p>Some more examples:
</p>

<pre>
(let ((lst (list 1 2 3)))
  (set! (lst 1) 32)
  (list (lst 0) (lst 1)))
-&gt; '(1 32)

(let ((hash (make-hash-table)))
  (set! (hash 'hi) 32)
  (hash 'hi))
-&gt; 32

&gt; (let ((str "123")) 
    (set! (str 1) #\x) str)
"1x3"
</pre>

<small>
<blockquote>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Well, maybe applicable strings look weird: <code>("hi" 1)</code> is #\i, but worse,
so is <code>(cond (1 =&gt; "hi"))</code>!  Even though a string, list, or vector is "applicable", it is
not currently considered to be a procedure, so <code>(procedure? "hi")</code> is #f, and
<code>(map #(0 1) '(1 0))</code> is an error.  
</p>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>The applicable object syntax makes it easy to write generic functions.
For example, s7test.scm has implementations of Common Lisp's sequence functions.
length, copy, reverse, fill!, map and for-each are generic in this sense (map always returns a list).
</p>

<pre>
&gt; (map (lambda (a b) (- a b)) (list 1 2) (vector 3 4))
(5 -3 9)

&gt; (length "hi")
2
</pre>

<p>
string-&gt;list and vector-&gt;list are <code>(map values object)</code>.
Their inverses are (and always have been) equally trivial.
Here's an FFT procedure that accepts lists or vectors, or any similar object:
</p>

<pre>
        (define* (cfft! data n (dir 1)) ; (complex data)
          (if (not n) (set! n (<em class=red>length</em> data)))
          (do ((i 0 (+ i 1))
               (j 0))
              ((= i n))
            (if (&gt; j i)
        	(let ((temp (data j)))
        	  (set! (data j) (data i))
        	  (set! (data i) temp)))
            (let ((m (/ n 2)))
              (do () 
        	  ((or (&lt; m 2) (&lt; j m)))
        	(set! j (- j m))
        	(set! m (/ m 2)))
              (set! j (+ j m))))
          (let ((ipow (floor (log n 2)))
        	(prev 1))
            (do ((lg 0 (+ lg 1))
        	 (mmax 2 (* mmax 2))
        	 (pow (/ n 2) (/ pow 2))
        	 (theta (make-rectangular 0.0 (* pi dir)) (* theta 0.5)))
        	((= lg ipow))
              (let ((wpc (exp theta))
        	    (wc 1.0))
        	(do ((ii 0 (+ ii 1)))
        	    ((= ii prev))
        	  (do ((jj 0 (+ jj 1))
        	       (i ii (+ i mmax))
        	       (j (+ ii prev) (+ j mmax)))
        	      ((&gt;= jj pow))
        	    (let ((tc (* wc (data j))))
        	      (set! (data j) (- (data i) tc))
        	      (set! (data i) (+ (data i) tc))))
        	  (set! wc (* wc wpc)))
        	(set! prev mmax))))
          data)
        
        &gt; (cfft! (list 0.0 1+i 0.0 0.0))
        (1+1i -1+1i -1-1i 1-1i)
        &gt; (cfft! (vector 0.0 1+i 0.0 0.0))
        #(1+1i -1+1i -1-1i 1-1i)
</pre>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>There is one place where list-set! and friends are not the same as set!: the former
evaluate their first argument, but set! does not (with a quibble; see below):
</p>

<pre>
&gt; (let ((str "hi")) (string-set! (let () str) 1 #\a) str)
"ha"

&gt; (let ((str "hi")) (set! (let () str) 1 #\a) str)
;((let () str) 1 #\a): too many arguments to set!

&gt; (let ((str "hi")) (set! ((let () str) 1) #\a) str)
"ha"

&gt; (let ((str "hi")) (set! (str 1) #\a) str)
"ha"
</pre>

<p>set! looks at its first argument to decide what to set.
If it's a symbol, no problem.  If it's a list, set! looks at its car to see if it is
some object that has a setter.  If the car is itself a list, set! evaluates the internal
expression, and tries again.  So the second case above is the only one that won't work.
And of course:
</p>

<pre>
&gt; (let ((x (list 1 2))) 
    (set! ((((lambda () (list x))) 0) 0) 3) 
    x) 
(3 2)
</pre>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>By my count, around 20 of the scheme built-in functions are already generic in the sense
that they accept arguments of many types (leaving aside the numeric functions).  s7 extends that list with map, for-each, reverse,
and length, and adds a few others such as copy, fill!, sort!, object-&gt;string, and continuation?.
newLisp takes a more radical approach than s7: it extends operators such as '&gt;' 
to compare strings and lists, as well as numbers.  In map and for-each, however, you can mix the argument
types, so I'm not as attracted to making '&gt;' generic; you can't, for example, <code>(&gt; "hi" 32.1)</code>,
or even <code>(&gt; 1 0+i)</code>.
</p>

</blockquote>
</small>
</dd>

<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="multidimensionalvectors"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>multidimensional vectors</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>
s7 supports
vectors with any number of dimensions.  It is here, in particular, that the generalized
set! stuff shines.  make-vector's second argument can be a list of dimensions, rather than
an integer as in the one dimensional case:
</p>

<pre>
    (make-vector (list 2 3 4))
    (make-vector '(2 3) 1.0)
    (vector-dimensions (make-vector (list 2 3 4))) -&gt; (2 3 4)
</pre>

<p>The second example includes the optional initial element.
<code>(vect i ...)</code> or <code>(vector-ref vect i ...)</code> return the given
element, and <code>(set! (vect i ...) value)</code> and <code>(vector-set! vect i ... value)</code>
set it.  vector-length (or just length) returns the total number of elements.
vector-dimensions returns a list of the dimensions.
</p>

<pre>
    &gt; (define v (make-vector '(2 3) 1.0))
    #2D((1.0 1.0 1.0) (1.0 1.0 1.0))

    &gt; (set! (v 0 1) 2.0)
    #2D((1.0 2.0 1.0) (1.0 1.0 1.0))

    &gt; (v 0 1)
    2.0

    &gt; (vector-length v)
    6
</pre>

<small>
<blockquote>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>matrix multiplication:
</p>

<pre>
(define (matrix-multiply A B)
  ;; assume square matrices and so on here for simplicity
  (let* ((size (car (vector-dimensions A)))
	 (C (make-vector (list size size) 0)))
    (do ((i 0 (+ i 1)))
	((= i size) C)
      (do ((j 0 (+ j 1)))
	  ((= j size))
	(let ((sum 0))
	  (do ((k 0 (+ k 1)))
	      ((= k size))
	    (set! sum (+ sum (* (A i k) (B k j)))))
	  (set! (C i j) sum))))))
</pre>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Multidimensional vector constant syntax is modelled after CL: #nd(...) or #nD(...) 
signals that the lists specify the elements of an 'n' dimensional vector: <code>#2D((1 2 3) (4 5 6))</code>
</p>

<pre>
    &gt; (vector-ref #2D((1 2 3) (4 5 6)) 1 2)
    6

    &gt; (matrix-multiply #2d((-1 0) (0 -1)) #2d((2 0) (-2 2)))
    #2D((-2 0) (2 -2))
</pre>

<p>If any dimension has 0 length, you get an n-dimensional empty vector.  It is not
equal to a 1-dimensional empty vector.
</p>

<pre>
    &gt; (make-vector '(10 0 3))
    #3D()

    &gt; (equal? #() #3D())
    #f
</pre>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>To save on costly parentheses, and make it easier to write generic multidimensional sequence functions,
you can use this same syntax with lists.
</p>

<pre>
&gt; (let ((L '((1 2 3) (4 5 6))))
    (L 1 0))              ; same as (list-ref (list-ref L 1) 0) or ((L 1) 0)
4

&gt; (let ((L '(((1 2 3) (4 5 6)) ((7 8 9) (10 11 12))))) 
    (set! (L 1 0 2) 32)   ; same as (list-set! (list-ref (list-ref L 1) 0) 2 32) which is unreadable!
    L)
(((1 2 3) (4 5 6)) ((7 8 32) (10 11 12)))
</pre>

<p>Or with vectors of vectors, of course:
</p>

<pre>
&gt; (let ((V '#(#(1 2 3) #(4 5 6)))) 
    (V 1 2))              ; same as (vector-ref (vector-ref V 1) 2) or ((V 1) 2)
6

&gt; (let ((V #2d((1 2 3) (4 5 6))))
    (V 0))
#(1 2 3)
</pre>

<p>There's one difference between a vector-of-vectors and a multidimensional vector:
in the latter case, you can't clobber one of the inner vectors. 
</p>

<pre>
&gt; (let ((V '#(#(1 2 3) #(4 5 6)))) (set! (V 1) 32) V)
#(#(1 2 3) 32)

&gt; (let ((V #2d((1 2 3) (4 5 6)))) (set! (V 1) 32) V)
;not enough args for vector-set!: (#2D((1 2 3) (4 5 6)) 1 32)
</pre>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Using lists to display the inner vectors may not be optimal, especially when the elements are also lists:
</p>

<pre>
#2D(((0) (0) ((0))) ((0) 0 ((0))))
</pre>

<p>The "#()" notation is no better (the elements can be vectors), and I'm not a fan of "[]" parentheses.
Perhaps we could use different colors?  Or different size parentheses?
</p>

<pre>
#2D<em class=green>(</em><em class=red>(</em>(0) (0) ((0))<em class=red>)</em> <em class=red>(</em>(0) 0 ((0))<em class=red>)</em><em class=green>)</em>
#2D<big><big>(</big>(</big>(0) (0) ((0))<big>)</big> <big>(</big>(0) 0 ((0))<big>)<big>)</big></big>
</pre>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>I'm not sure how to handle vector-&gt;list and list-&gt;vector in the multidimensional case.
Currently, vector-&gt;list flattens the vector, and list-&gt;vector always returns a
one dimensional vector, so the two are not inverses.
</p>

<pre>
&gt; (vector-&gt;list #2d((1 2) (3 4)))
(1 2 3 4)             ; should this be '((1 2) (3 4)) or '(#(1 2) #(3 4))?
&gt; (list-&gt;vector '(#(1 2) #(3 4))) ; what about '((1 2) (3 4))?
#(#(1 2) #(3 4))      
</pre>

<p>Perhaps I should add an optional number-of-dimensions argument?
This also affects format and sort!:
</p>

<pre>
&gt; (format #f "~{~A~^ ~}" #2d((1 2) (3 4)))
"1 2 3 4"

&gt; (sort! #2d((1 4) (3 2)) &gt;) 
#2D((4 3) (2 1))
</pre>

</blockquote>
</small>
</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="hashtables"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>hash-tables</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><br>
<ul>
<li>(make-hash-table (size 512))
<li>(hash-table ...)
<li>(hash-table-ref ht key)
<li>(hash-table-set! ht key value)
<li>(hash-table? obj)
<li>(hash-table-size ht)
</ul>

<p>
Any s7 object can be the key or the key's value.
Each hash-table keeps track of the keys it contains, optimizing the search wherever possible.
If you pass a table size that is not a power of 2, make-hash-table rounds it up to the next power of 2.
</p>

<pre>
(let ((ht (make-hash-table)))
  (set! (ht "hi") 123)
  (ht "hi"))

-&gt; 123
</pre>

<p>hash-table (the function) parallels (the functions) vector, list, and string.  Its arguments are cons's containing key/value pairs.
The result is a new hash-table with those values preinstalled: <code>(hash-table '("hi" . 32) '("ho" . 1))</code>.
</p>

<small>
<blockquote>
<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Since hash-tables accept the same applicable-object syntax that vectors use, we can 
treat a hash-table as, for example, a sparse array:
</p>

<pre>
&gt; (define make-sparse-array make-hash-table)
make-sparse-array

&gt; (let ((arr (make-sparse-array)))
   (set! (arr 1032) "1032")
   (set! (arr -23) "-23")
   (list (arr 1032) (arr -23)))
("1032" "-23")
</pre>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>for-each and map accept hash-table arguments. On each iteration, the map or for-each function is passed
an entry, <code>'(key . value)</code>, in whatever order the entries are encountered in the table.
</p>

<pre>
(define (hash-table-&gt;alist table)
  (map (lambda (x) x) table)) ; clearer perhaps than (map values table), append would also work here
</pre>

<p>reverse of a hash-table returns a new table with the keys and values reversed.
</p>

</blockquote>
</small>

</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="multithreading"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>threads</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>If s7 is built with HAVE_PTHREADS set, you get multithreading functions.
</p>

<pre>
    (make-thread thunk (stack-size 300)) ; create a thread running thunk, return id: pthread_create
    (join-thread thread)                 ; wait for thread to finish, return value returned by thunk: pthread_join
    (thread? obj)                        ; #t if obj is a thread 
    (make-lock)                          ; mutex allocation and pthread_mutext_init
    (grab-lock lock)                     ; pthread_mutex_lock
    (release-lock lock)                  ; pthread_mutex_unlock
    (lock? obj)                          ; #t if obj is a lock
    (make-thread-variable)               ; pthread_key_create
    (thread-variable? obj)               ; #t if obj is a thread-variable (pthread_key)
</pre>

<p>
Threads in s7 share the heap and symbol table, but have their own local environment, stack,
and evaluator locals.  I use the term "lock" in place of "mutex", and "thread-variable"
in place of "pthread_key".  The thread-variable is applicable and settable, so instead
of pthread_getspecific, just call it: <code>(var)</code>.
</p>

<pre>
(let ((a-lock (make-lock))
      (threads '())
      (a-thread-variable (make-thread-variable)))
  (let loop
      ((i 0))
    (set! threads (cons (make-thread
			 (lambda ()
			   (set! (a-thread-variable) i)
			   (grab-lock a-lock)
			   (format #t "thread ~A " (a-thread-variable))
			   (release-lock a-lock)))
			threads))
    (if (&lt; i 8)
	(loop (+ i 1))))
  (for-each 
   (lambda (thread) 
     (join-thread thread))
   threads))
</pre>

<p>join-thread returns the value returned by the function passed to make-thread:
</p>

<pre>
&gt; (let ((ctr1 1) 
        (ctr2 2))
    (let ((t1 (make-thread (lambda () (* ctr1 2))))
          (t2 (make-thread (lambda () (* ctr2 3)))))
      (+ (join-thread t1) 
         (join-thread t2))))
8
</pre>


<small>
<blockquote>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<pre>
(define-macro (thread-let bindings . body)
  ;; just like "let", but each variable is set by running a separate thread
  `(let (,@(map (lambda (variable&amp;value)
                  `(,(car variable&amp;value) (make-thread (lambda () ,(cadr variable&amp;value)))))
                bindings))
     ,@(map (lambda (variable&amp;value)
              `(set! ,(car variable&amp;value) (join-thread ,(car variable&amp;value))))
            bindings)
     ,@body))

&gt; (thread-let ((x (abs -1)) 
               (y (* 3 2))) 
    (+ x y))
7

&gt; (macroexpand (thread-let ((x (abs -1)) (y (* 3 2))) (+ x y)))
(let ((x (make-thread (lambda () (abs -1)))) 
      (y (make-thread (lambda () (* 3 2))))) 
  (set! x (join-thread x)) 
  (set! y (join-thread y)) 
  (+ x y))


(define-macro (thread-values . vals)
  ;; just like "values", but each value is evaluated by a separate thread
  (let ((gs (map (lambda (var) (gensym)) vals)))
    `(thread-let (,@(map (lambda (g v) `(,g ,v)) gs vals))
       (values ,@gs))))

&gt; (+ 1 (thread-values (* 3 2) (abs -1)) 2)
10
</pre>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>There is some overhead in handling threads, so I usually
restrict thread use to long computations.  Since the heap is currently
shared, code like this is problematic:
</p>

<pre>
(define (fib n) 
  (define (fib-1 n)
    (if (&lt; n 2) 
	n 
	(+ (fib-1 (- n 1)) 
	   (fib-1 (- n 2)))))
  (apply + 
    (map join-thread 
         (list (make-thread (lambda () (fib-1 (- n 1))))
	       (make-thread (lambda () (fib-1 (- n 2))))))))
</pre>

<p>Lots of temporaries are being allocated here, causing the s7 internal new-cell lock to be set
and unset so often that almost 20% of the compute time is wasted.
Of course in real life you'd get the nth Fibonacci number from the formula for it:
</p>

<pre>
(define (fib n)
  (let ((phi (/ (+ 1 (sqrt 5)) 2)))
     (floor (/ (- (expt phi n)        ; "floor" to return an integer
                  (expt (- 1 phi) n)) 
               (sqrt 5)))))
</pre>

</blockquote>
</small>


</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="multiplevalues"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>multiple-values</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>
In s7, multiple values are spliced directly into the caller's argument list.
</p>

<pre>
  &gt; (+ (values 1 2 3) 4)
  10
  &gt; (string-ref ((lambda () (values "abcd" 2))))
  #\c
  &gt; ((lambda (a b) (+ a b)) ((lambda () (values 1 2))))
  3
  &gt; (+ (call/cc (lambda (ret) (ret 1 2 3))) 4) ; call/cc has an implicit "values"
  10
  &gt; ((lambda* ((a 1) (b 2)) (list a b)) (values :a 3))
  (3 2)

  ;; call-with-values: 
  (define-macro (call-with-values producer consumer) 
    `(,consumer (,producer)))

  ;; multiple-value-bind ("receive" in srfi-8):
  (define-macro (multiple-value-bind vars expr . body)
    `((lambda ,vars ,@body) ,expr))

  ;; multiple-value-set!:
  (define-macro (multiple-value-set! vars expr . body)
    (let ((local-vars (map (lambda (n) (gensym)) vars)))
      `((lambda ,local-vars ,@(map (lambda (n ln) `(set! ,n ,ln)) vars local-vars) ,@body) ,expr)))

  ;; let*-values is defined as a macro at the end of s7.c (commented out)
</pre>

<small>
<blockquote>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>There aren't that many real uses for multiple-values in Scheme.  Nearly all can be replaced by
a normal list.  There are two cases, however, that can't be handled easily with a list.
First, you can use "values" to return any number of values, including 0,
from map's function application:
</p>

<pre>
&gt; (map (lambda (x) (if (odd? x) (values x (* x 20)) (values))) (list 1 2 3))
(1 20 3 60)
</pre>

<p>As this example shows, if the map function returns <code>(values)</code>,
nothing is added to the map output list.
</p>

<pre>
&gt; (map (lambda (x) (if #f x (values))) (list 1 2))
()
</pre>

<p>Second, you can use multiple-values to turn off the short-circuit evaluation
of 'or' and 'and'.  Normally these operators 
stop evaluating their arguments as soon as they hit #t ('or') or #f ('and').
By wrapping the arguments in 'values', you can force all of them to be evaluated:
</p>

<pre>
&gt; (let ((x 1)) 
    (and (let () #f)             ; this returns #f so
         (let () (set! x 3) #f)) ;   this is never evaluated
    x)
1

&gt; (let ((x 1)) 
    (and (<em class=red>values</em> (let () #f) 
                 (let () (set! x 3) #f)))
  x) 
3
</pre>

<p>At the top-level, since there's nothing to splice into, so you simply get your values back:
</p>

<pre>
&gt; (values 1 (list 1 2) (+ 3 4 5))
(values 1 (1 2) 12)
</pre>

<p>But this printout is just trying to be informative.  There is no multiple-values object
in s7.  You can't <code>(set! x (values 1 2))</code>, for example.  The values function
tells s7 that its arguments should be handled in a special way, and the multiple-value indication goes away
as soon as the arguments are spliced into some caller's arguments.  
</p>

<p>Internally, s7 uses <code>(apply values ...)</code> to implement unquote splicing (",@") in quasiquote.
</p>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>In some Schemes, values behaves like CL's prog1:
</p>

<pre>
(not s7)&gt; (let ((x 1)) (cond ((values #f (set! x 2) #t) 3) (#t x)))
2
(not s7)&gt; (if (values #f #t) 1 2)
2
</pre>

<p>But in s7 we're trying to implement real multiple values (else why have them at all?).
There are many ways we could interpret <code>(cond ((values ...))...)</code> and
<code>(cond ((values...) =&gt; func))</code>, but surely
equivalent uses of "cond" and "if" should give the same result.
Currently in s7, where a test is in progress, only <code>(values #f)</code> is the same as #f.
</p>

<pre>
&gt; (if (values #f #f) 1 2)            ; (values #f #f) is not #f
1
&gt; (cond ((values #f #f) 1) (#t 2))
1
;;; but if we interpreted this as splicing in the values, we get an inconsistency:
&gt; (cond (#f #f 1) (#t 2))
2

&gt; (if (values #f) 1 2)
2
&gt; (cond ((values #f) 1) (#t 2))
2

&gt; (if (values) 1 2)
1
&gt; (cond ((values) 1) (#t 2))
1
;;; this is consistent with (cond (1) (#t 2))
</pre>

<p>
So "if" and "cond" agree, but it requires that in one case the "values"
behavior is slightly weird.  <code>(or (values #f #f))</code> is #f, but that isn't inconsistent because
"or" is not testing anything.
We might choose to say that <code>(if (values #f #f)...)</code>
is an error, but that would be hasty &mdash;
our troubles have only begun.  First, "cond" can omit the expressions that follow the test, unlike "if":
</p>

<pre>
&gt; (cond (3))
3
</pre>

<p>and even trickier, "cond" can pass the test value to a function:
</p>

<pre>
&gt; (cond (3 =&gt; +))
3
</pre>

<p>The various standards agree that in the "=&gt;" case, the "fed to" function
receives one argument, so
</p>

<pre>
(not s7)&gt; (cond ((values 1 2) =&gt; +))
1
</pre>

<p>If we were following the "splice immediately" model, this would be <code>(cond (1 2 =&gt; +))</code>
which is an error in some Schemes.
So something has to give.  My druthers is to make "values" work as consistently as possible, and hope
that the one odd corner will not trip anyone.  From that point of view, the "one arg" standard
looks like a wasted opportunity.
s7 handles it this way:
</p>

<pre>
&gt; (+ 1 (cond ((values 2 3))) 4)   ; trailing values are not ignored
10
&gt; (cond ((values 1 2 3) =&gt; +))
6
</pre>

<p>Of course, it is unproblematic that the expression can itself involve multiple values:
</p>

<pre>
&gt; (+ (cond (#t (values 1 2))))
3
</pre>

<p>Now, what have I missed?
</p>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Since set! does not evaluate its first argument, and
there is no setter for "values", <code>(set! (values x) ...)</code> is not
the same as <code>(set! x ...)</code>.  <code>(string-set! (values string) ...)</code>
works because string-set! does evaluate its first argument.  <code>((values + 1 2) (values 3 4) 5)</code>
is 15, as anyone would expect.
</p>

</blockquote>
</small>
</dd>
<br><br>



<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="callwithexit"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>call-with-exit and continuation?</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p><b>call-with-exit</b> is call/cc without the ability to jump back into the original context,
similar to "return" in C.  This takes the place of CL's catch/throw (s7 uses "catch" for error handling).
</p>

<pre>
(define (find-first-even-number arg)
  (<em class=red>call-with-exit</em>
   (lambda (return)
     (for-each
      (lambda (a)
	(if (even? a)
	    (return a)))
      arg))))

(find-first-even-number (list 1 3 9 13 8 2 4)) -&gt; 8

(define-macro (block . body) 
  `(<em class=red>call-with-exit</em> 
     (lambda (return) 
       ,@body)))

(block (display "hi") (return 32) (display "oops")) -&gt; 32
</pre>

<p><b>continuation?</b> returns #t if its argument is a continuation,
as opposed to a normal procedure.  I don't know why Scheme hasn't had this function from
the very beginning, but it's needed if you want to write a continuable error
handler.  Here is a sketch of the situation:
</p>

<pre>
(let ()
  (catch #t
	 (lambda ()
	   (let ((res (call/cc 
                        (lambda (ok) 
			  (error 'cerror "an error" ok)))))
	     (display res) (newline)))
	 (lambda args
	   (if (and (eq? (car args) 'cerror)
		    (<em class=red>continuation?</em> (cadadr args)))
	       (begin
		 (display "continuing...")
		 ((cadadr args) 2)))
	   (display "oops"))))

  -&gt; continuing...2
</pre>

<p>In a more general case, the error handler is separate from the
catch body, and needs a way to distinguish a real continuation
from a simple procedure.  Otherwise, it blithely announces that
it is continuing from the point of the error, but then fails to do so.
</p>

<small>
<blockquote>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>The call-with-exit function's argument (the "continuation") is only valid
within the call-with-exit function.  In call/cc, you can save it, then call it later
to jump back, but if you try that with call-with-exit (from outside the call-with-exit function's body), you'll get an error.
This is similar to trying to read from a closed input port. 
</p>

</blockquote>
</small>


</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="format"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>format, object-&gt;string</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>s7's built-in format function is very close to that in srfi-48.
</p>

<pre>
(format #f "~A ~D ~F" 'hi 123 3.14)
-&gt; "hi 123 3.140000"
</pre>


<p>The format directives (tilde chars) are:</p>
<pre>
~%        insert newline
~&amp;        insert newline if preceding char was not newline
~~        insert tilde
~\n       (tilde followed by newline): trim white space
~{        begin iteration (take arguments from a list, string, or vector)
~}        end iteration
~^        jump out of iteration
~*        ignore the current argument
~A        object-&gt;string as in display
~S        object-&gt;string as in write
~C        print as character
~P        insert 's' if current argument is not 1 or 1.0 (use ~@P for "ies" or "y")
~B        number-&gt;string in base 2
~O        number-&gt;string in base 8
~D        number-&gt;string in base 10
~X        number-&gt;string in base 16
~E        float to string, (format #f "~E" 100.1) -&gt; "1.001000e+02", (%e in C)
~F        float to string, (format #f "~F" 100.1) -&gt; "100.100000",   (%f in C)
~G        float to string, (format #f "~G" 100.1) -&gt; "100.1",        (%g in C)
~T        insert spaces (padding)
</pre>

<p>The last eight take the usual numeric arguments to specify field width and precision.
</p>
<p>
<code>(format #f ...)</code> simply returns the formatted string; <code>(format #t ...)</code>
also sends it to *stdout*.  To send the string to *stderr* instead, <code>(format *stderr* ...)</code>.
</p>

<small>
<blockquote>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Floats can occur in any base, so:
</p>

<pre>
&gt; #xf.c
15.75
</pre>

<p>This also affects format.  In most schemes, <code>(format #f "~X" 1.25)</code> is
an error.  In CL, it is equivalent to using ~A which is perverse.  But 
</p>

<pre>
&gt; (number-&gt;string 1.25 16)
"1.4"
</pre>

<p>and there's no obvious way to get the same effect from format unless we accept
floats in the "~X" case.  So in s7, 
</p>

<pre>
&gt; (format #f "~X" 21)
"15"

&gt; (format #f "~X" 1.25)
"1.4"

&gt; (format #f "~X" 1.25+i)
"1.4+1.0i"

&gt; (format #f "~X" 21/4)
"15/4"
</pre>

<p>That is, the output choice matches the argument.  A case that came up in the Guile mailing lists is:
<code>(format #f "~F" 1/3)</code>.  s7 currently returns "1/3", but Clisp returns "0.33333334".
</p>

<p>The curly bracket directive applies to strings and vectors, as well as lists:
</p>

<pre>
&gt; (format #f "~{~C~^ ~}" "hiho")
"h i h o"
</pre>


</blockquote>
</small>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>object-&gt;string returns the string representation of its argument:
</p>

<pre>
&gt; (object-&gt;string "hiho")
"\"hiho\""

&gt; (format #f "~S" "hiho")
"\"hiho\""
</pre>


<small>
<blockquote>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>I added object-&gt;string to s7 before deciding to include format.  format excites a
vague disquiet &mdash; why do we need this ancient unlispy thing?
We can almost replace it with:
</p>

<pre>
(define (objects-&gt;string . objects)
  (apply string-append (map (lambda (obj) (object-&gt;string obj #f)) objects)))
</pre>

<p>But how to handle lists (~{...~} in format), or columnized output (~T)?
I wonder whether formatted string output still matters outside a REPL.  Even in that context,
a modern GUI will leave formatting decisions to a text or table widget.
</p>

<pre>
(define-macro (string-&gt;objects str . objs)
  `(with-input-from-string ,str
     (lambda ()
       ,@(map (lambda (obj)
		`(set! ,obj (eval (read))))
	      objs))))
</pre>


<!--

:(objects->string "int: " 32 ", string: " "hi")
"int: 32, string: hi"

(define (cycle->string . objs)
  (call-with-exit
   (lambda (return)
     (for-each
      (lambda (obj)
	(if (pair? obj)
	    (return
	     (string-append 
	      (apply objects->string 
		     (map (lambda (obj)
			    (if (pair? obj)
				(car obj)
				obj))
			  objs))
	      (apply cycle->string 
		     (map (lambda (obj)
			    (if (pair? obj)
				(cdr obj)
				obj))
			  objs))))))
      objs)
     "")))

;;; (cycle->string ": " (list 1 2 3) " |")
:(objects->string "int: " 32 ", list with spaces: (" (cycle->string (list 1 2 3) " ") "), string: " "hi")
"int: 32, list with spaces: (1 2 3 ), string: hi"

:(let ((x 0) (y 0)) (string->objects "1 2" x y) (list x y))
(1 2)

-->


</blockquote>
</small>


</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="errors"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>error handling</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>s7's error handling mimics that of Guile.  An error is signalled
via the error function, and can be trapped and dealt with via catch.
</p>

<pre>
(<em class=red>catch</em> 'wrong-number-of-args
  (lambda ()     ; code protected by the catch
    (abs 1 2))
  (lambda args   ; the error handler
    (apply format (append (list #t) (cadr args)))))

-&gt; "abs: too many arguments: (1 2)"

(<em class=red>catch</em> 'division-by-zero
  (lambda () (/ 1.0 0.0))
  (lambda args (string-&gt;number "inf.0")))

-&gt; inf.0
</pre>

<p>
catch has 3 arguments: a tag indicating what error to catch (#t = anything),
the code, a thunk, that the catch is protecting, and the function to call
if a matching error occurs during the evaluation of the thunk.  The error handler
takes a rest argument which will hold whatever the error function chooses to pass it.
The error function itself takes at least 2 arguments, the error type, a symbol,
and the error message.  There may also be other arguments describing the error.
The default action, in the absence of any catch, is to treat the message as
a format control string, apply format to it and the other arguments, and
send that info to the current-error-port.
</p>

<p>When an error is encountered, the variable <a name="errorinfo">*error-info*</a>, a vector, contains
additional info about that error:
</p>

<ul>
<li>0: the error type or tag, e.g. 'division-by-zero
<li>1: the message or information passed by the error function
<li>2: if not #f, the code that s7 thinks triggered the error
<li>3: if not #f, the line number of that code
<li>4: if not #f, the file name of that code
<li>5: the environment at the point of the error
<li>6...: stack environment pointers, ending in #f
</ul>


<small>
<blockquote>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>To find a variable's value at the point of the error:
</p>

<pre>
(symbol-&gt;value var (vector-ref *error-info* 5))
</pre>

<p>To print the stack at the point of the error:
</p>

<pre>
(stacktrace *error-info*)
</pre>

<p>To evaluate the error handler in the environment of the error:
</p>

<pre>
(let ((x 1))
  (catch #t
	 (lambda ()
	   (let ((y 2))
	     (error 'oops)))
	 (lambda args
	   (with-environment
	    (augment-environment 
	     (*error-info* 5)      ; the error env
	     (cons 'args args))    ; add the error handler args
	    (list args x y)))))    ; we have access to 'y'
</pre>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

</blockquote>
</small>



<p>The variable <a name="errorhook">*error-hook*</a> provides a way to specialize error reporting.
It is a function of 2 arguments, the values passed by the error function:
the error type and whatever other info accompanies it.
</p>

<pre>
(set! *error-hook* (lambda (tag args) (apply format #t args)))
</pre>

<p>stacktrace can be called anytime to see the chain of function calls.  Its optional argument
can be *error-info* to show the stack at the point of the last error,
a thread object to show that thread's stack, or a continuation to
show the continuation stack. 
</p>

<pre>
    (let ()
      (define (a1 a) (+ a #\c))
      (define (a2 b) (+ b (a1 b)))
      (define (a3 c) (+ c (a2 c)))
      (catch #t
        (lambda () (a3 1))
        (lambda args (<em class=red>stacktrace</em> *error-info*))))

-&gt;    (a1 (a . 1))
      (a2 (b . 1))
      (a3 (c . 1))
</pre>

<p>
See also trace below.  There is a break macro defined in Snd (snd-xen.c)
which allows you to stop at some point, then evaluate arbitrary expressions in that context.
<!-- INDEX autoload:autoload -->
<A NAME="autoload"></A>
There's yet another hook, <a name="unboundvariablehook">*unbound-variable-hook*</a>, which is called
before the error is signalled
when an unbound variable
is encountered.
Its value is a function of one argument,
the unbound symbol.  In Snd, this is used to implement autoloading:
</p>

<pre>
(set! <em class=red>*unbound-variable-hook*</em>
  (lambda (sym)
    ;; add your own symbol checks here
    (let ((file (autoload-file (symbol-&gt;string sym))))
      ;; autoload-file is a Snd function that knows where a lot of Snd's scheme functions are
      (if file (load file))
      (symbol-&gt;value sym)))) ; this will return #&lt;undefined&gt; if we didn't find its source file
</pre>

<!--
<small>
<blockquote>
<p>Sly evil-doers can subvert this hook to provide something similar to Common Lisp's symbol-macros:
</p>
<pre>
&gt; (set! *unbound-variable-hook* 
    (lambda (sym)
      (if (eq? sym 'hiho)
          (sin (random 1.0))
          (symbol-&gt;value sym))))
&lt;closure&gt;

&gt; hiho
0.46727567824396

&gt; hiho
0.64985453979392
</pre>

</blockquote>
</small>
-->

<p>The s7-built-in catch tags are 'wrong-type-arg, 'syntax-error, 'read-error, 'thread-error,
'out-of-memory, 'wrong-number-of-args, 'format-error, 'out-of-range, 'division-by-zero, 'io-error, and 'bignum-error.  
</p>

<p>trace and untrace provide tracing:
</p>
<pre>
    (define (hiho arg) 
      (if (&gt; arg 0) 
          (+ 1 (hiho (- arg 1))) 
          0))

    (<em class=red>trace</em> hiho)

    (hiho 3)

    [hiho 3]
     [hiho 2]
      [hiho 1]
       [hiho 0]
        0
       1
      2
     3
</pre>

<p>trace adds a function to the list of functions being traced, and untrace removes it.
trace with no arguments causes everything to be traced, and untrace with no arguments
turns this off.
</p>

<p>There is also a hook, <a name="tracehook">*trace-hook*</a>, a function of 2 arguments the currently traced
function and the list of current arguments.  It is evaluated in the environment of the
function call (that is, global to the function, not the function's local environment).
</p>

<pre>
    (define (hiho a b c) (* a b c))
    (set! *trace-hook* (lambda (f args) (format #t "sum of args: ~A~%" (apply + args))))
    (trace hiho)
    (hiho 2 3 4)

    [hiho 2 3 4]
    sum of args: 9
     24
</pre>

</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="procedureinfo"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>procedure info</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>procedure-source, procedure-arity, procedure-documentation, and help provide a look into a
scheme function.
procedure-documentation returns the documentation string associated with a procedure: the initial string in the
function's body. procedure-arity returns a list describing the argument list of a function: <code>'(required-args optional-args rest-arg?)</code>.
procedure-source returns the source, as a list, of a procedure. procedure-environment returns
a procedure's environment.
</p>

<pre>
&gt; (define* (add-2 a (b 32)) "add-2 adds its 2 args" (+ a b))
add-2

&gt; (procedure-documentation add-2)
"add-2 adds its 2 args"

&gt; (procedure-arity add-2)
(0 2 #f)

&gt; (procedure-source add-2)
(lambda* (a (b 32)) "add-2 adds its 2 args" (+ a b))
</pre>

<p>We can use procedure-environment and <a href="#__func__">__func__</a> to 
write a function that tells us where the source is for a function:
</p>

<pre>
(define (where-is func)
  (let ((addr (cdr (assoc <em class=red>'__func__</em> (car (<em class=red>procedure-environment</em> func))))))
    (if (not (pair? addr))
	"not found"
	(format #f "~A is at line ~D of ~A" (car addr) (caddr addr) (cadr addr)))))

&gt; (where-is profile)
"profile is at line 1048 of extensions.scm"
</pre>


<small>
<blockquote>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>procedure-source returns the actual function source &mdash;
more fun than a barrel of monkeys. Here is a self-modifying factorial function:
</p>

<pre>
(define fact         ; Reini Urban, http://autocad.xarch.at/lisp/self-mod.lsp.txt
  (let ((old '())
	(result '()))

    (define (last lst)
      (list-tail lst (- (length lst) 1)))

    (define (butlast lis)
      (let ((len (length lis)))
	(if (&lt;= len 1) '()
	    (let ((result '()))
	      (do ((i 0 (+ i 1))
		   (lst lis (cdr lst)))
		  ((= i (- len 1)) (reverse result))
		(set! result (cons (car lst) result)))))))

    (lambda (n)
      (cond ((zero? n) 1)
	    (#t 
	     (set! old (<em class=red>procedure-source</em> fact))
	     (set! fact (apply lambda '(n)
			  `((cond 
			    ,@(butlast (cdr (car (cdr (cdr old)))))
			    ((= n ,n) ,(let ()
					 (set! result (* n (fact (- n 1))))
					 result))
			    ,@(last (cdr (car (cdr (cdr old)))))))))
	     result)))))
</pre>

<p>If you modify the procedure source directly, it is safest to redefine the procedure (as above)
so that everything in s7 knows about the change.  
<a href="#augmentenv">augment-environment</a> serves a similar purpose when editing environments.
Here's a more useful example; it adds trace and local variable info for debugging:
</p>

<pre>
(define-macro (procedure-annotate proc)
  (let ((orig (<em class=red>procedure-source</em> proc)))

    (define (proc-walk source)
      (if (pair? source)
	  (if (or (eq? (car source) 'let)     ; if let or let*, show local variables
		  (eq? (car source) 'let*))
	      (if (symbol? (cadr source))
		  ;; (let name vars . body) -&gt; (let name vars print-vars . body)
		  (append 
		   (list (car source)
			 (cadr source)
			 (caddr source)
			 `(format #t "    (let ~A (~{~A~^ ~}) ...)~%" ,(cadr source) (car (current-environment))))
		   (cdddr source))
		  ;; (let(*) vars . body) -&gt; (let vars print-vars . body)
		  (append 
		   (list (car source)
			 (cadr source)
			 `(format #t "    (~A (~{~A~^ ~}) ...)~%" ,(car source) (car (current-environment))))
		   (cddr source)))
	      (cons (proc-walk (car source))
		    (proc-walk (cdr source))))
	  source))

    (let* ((new-body (proc-walk orig))
	   (result (gensym))
	   (new-source 
	    `(lambda ,(cadr orig)
	       (let ((,result #&lt;undefined&gt;))
		 (dynamic-wind
		     (lambda ()       ; upon entry, show procedure name and args
		       (format #t "(~A~{ ~A~})~%" ',proc (caddr (current-environment))))
		     (lambda ()
		       (set! ,result (,new-body ,@(cadr orig)))
		       ,result)
		     (lambda ()       ; at exit, show result
		       (if (eq? ,result #&lt;undefined&gt;)
			   (format #t "  ~A returns early~%")
			   (format #t "  ~A returns ~A~%" ',proc ,result))))))))

      `(set! ,proc (eval ,new-source)))))
			 
&gt; (define (hi a) (let ((b 12)) (+ b a)))
hi
&gt; (procedure-annotate hi)
#&lt;closure&gt;
&gt; (let ((x 32)) (+ 1 (hi x)))
45
;; printing: 
(hi (a . 32))
    (let ((b . 12)) ...)
  hi returns 44
</pre>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>If procedure-arity is passed
a procedure-with-setter, it returns 6 values, rather than 3.  The first 3 describe the "getter"
and the following 3 describe the "setter".  
</p>

<p>Since define* accepts multiple rest arguments, perhaps procedure-arity should return that number,
rather than a boolean.  I haven't run into a case where it matters.  Another odd case: 
<code>(procedure-arity (lambda* (:allow-other-keys) #f))</code>.  How should we indicate
this in procedure-arity?
</p>


</blockquote>
</small>


</dd>
<br><br>



<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="environments"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>environment info</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>An environment holds symbols and their values.  The global environment, for example,
holds all the variables that are defined at the top level.
Environments are first class objects in s7.  
</p>

<pre>
  (global-environment)          the top-level environment
  (current-environment)         the currently visible variables and their values
  (procedure-environment proc)  the environment at the time when proc was defined
  (initial-environment)         the current environment, but all built-in functions have their original values

  (with-environment env . body) evaluate body in the environment env 

  (augment-environment env . bindings)   add bindings to env
  (augment-environment! env . bindings)
  (symbol-&gt;value sym (env (current-environment)))
  (defined? sym (env (current-environment)))
  (symbol-table)
</pre>

<A NAME="augmentenv"></A>
<p><code>(with-environment env . body)</code> evaluates its body in the environment env.
There are several examples of its use in the <a href="#macros">macro</a> section.
defined? returns #t if the symbol is defined in the environment, and
symbol-&gt;value returns the value associated with it.
To add or change a symbol's value, use augment-environment:
</p>

<pre>
(let ((a 1)) 
  (eval '(+ a b) 
         (<em class=red>augment-environment</em>
           (current-environment) 
           (cons 'b 32)))) ; add 'b with the value 32 to this environment

-&gt; 33
</pre>

<p>augment-environment does not change the environment passed to it.  It
just prepends the new bindings, shadowing any old ones,
as if you had called "let".  To add the bindings directly to the environment,
use augment-environment!.
</p>

<p>It is possible in Scheme to redefine built-in functions such as car.
To ensure that some code sees the original built-in function definitions,
wrap it in <code>(with-environment (initial-environment) ...)</code>:
</p>
<pre>
&gt; (let ((caar 123)) 
    (+ caar (with-environment (initial-environment) 
              (caar '((2) 3)))))
125
</pre>

<p>
with-environment and initial-environment are constants, so you can
use them in any context without worrying about whether they've been redefined.
I think these functions can implement the notions of libraries,
separate namespaces, or modules.  
Here's one way: first the library writer just writes his library.
The normal user simply loads it.  The abnormal user worries about everything,
so first he loads the library in a local let to make sure no bindings escape 
to pollute his code, and then he
uses initial-environment to
make sure that none of his bindings pollute the library code:
</p>

<pre>
(let ()
  (with-environment (initial-environment)
    (load "any-library.scm" (current-environment)) ; by default load puts stuff in the global environment
    ...))
</pre>

<p>Now Abnormal User can do what he wants with the library entities.
Say he wants to use "lognor" under the name "bitwise-not-or", and
all the other functions are of no interest:
</p>

<pre>
(begin
  (define bitwise-not-or #f)
  (let ()
    (with-environment (initial-environment)
      (load "any-library.scm" (current-environment))
      (set! bitwise-not-or (symbol-&gt;value 'lognor)))))
</pre>

<p>Or equivalently:
</p>

<pre>
(augment-environment! (current-environment)
  (cons 'bitwise-not-or 
    (symbol-&gt;value 'lognor
      (with-environment (initial-environment)
        (load "any-library.scm" (current-environment))
        (current-environment)))))
</pre>

<p>Say he wants to make sure the library is cleanly loaded, but all
its bindings are exported into the current environment:
</p>

<pre>
(apply augment-environment! (current-environment)
  (with-environment (initial-environment)
    (load "any-library.scm" (current-environment))
    (car (current-environment)))) ; these are the bindings introduced by loading the library
</pre>

<p>To do the same thing, but prepend "library:" to each name:
</p>

<pre>
(apply augment-environment! (current-environment)
  (with-environment (initial-environment)
    (load "any-library.scm" (current-environment))
    (map (lambda (binding)
	   (cons (string-&gt;symbol 
		  (string-append "library:" (symbol-&gt;string (car binding))))
		 (cdr binding)))
	 (car (current-environment)))))
</pre>

<p>That's all there is to it!
</p>

<p>
<code>(symbol-table)</code> returns the symbol table, a vector of lists of symbols.
Here we scan the symbol table looking for any function that doesn't have documentation:
</p>

<pre>
       (let ((st (<em class=red>symbol-table</em>)))
         (do ((i 0 (+ i 1))) 
             ((= i (vector-length st)))
           (let ((lst (vector-ref st i)))
             (for-each 
               (lambda (sym)
       	         (if (<em class=red>defined?</em> sym)
	             (let ((val (<em class=red>symbol-&gt;value</em> sym)))
	               (if (and (procedure? val)
			        (string=? "" (procedure-documentation val)))
		           (format #t "~A " sym)))))
               lst))))
</pre>

<p>
To use namespaces from C, see the FFI <a href="#namespace">example</a>
below.
</p>


<small>
<blockquote>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>
I think we could build an object system where each object is an environment (a list of alists),
and each method looks for itself in that environment.
</p>

<pre>
(define object (list (list (cons 'afield 1) 
                           (cons 'amethod (lambda args 
                                            (+ 1 (apply + args)))))))

(define (amethod obj . args) 
  (apply (symbol-&gt;value 'amethod obj) args)) ; perhaps pass obj too

&gt; (amethod object 3 4)
8
</pre>

<p>A class would be an environment with the various fields and methods predefined.
</p>


<!--
could we use expansions here? (so set! arg would be "evaluated" at read time etc)
-->

</blockquote>
</small>


</dd>
<br><br>



<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="evalstring"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>eval</h4></td></tr></table>
</td></tr></table>
</dt>

<dd>

<p>
<b>eval</b> evaluates its argument, a list representing a piece of code.  It takes an optional
second argument, the environment in which the evaluation should take place.  <b>eval-string</b>
is similar, but its argument is a string.
</p>

<pre>
&gt; (eval '(+ 1 2))
3

&gt; (eval-string "(+ 1 2)")
3
</pre>

<small>
<blockquote>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>The environment argument is mainly useful in debugging.  A breakpoint can be set, for
example, then any input is evaluated in the environment of the break.  Say we have the
following code in ex.scm:
</p>

<pre>
(define-macro (break)
  `(let ((break-env (<em class=red>current-environment</em>))
	 (prompt (format #f "~%~A &gt; " (if (defined? '__func__) __func__ "break"))))
     (call-with-exit
      (lambda (return)
	(do () ()                       ; our debugger's own REPL
	  (display prompt)              ; show where we stopped
	  (let ((str (read-line '())))  ; read a line of input, :go -&gt; exit the debugger
	    ;; the nil argument to read-line makes sure that we read C's stdin.  In any normal
	    ;;    program, we'd get the string from a text widget.
	    (if (&gt; (length str) 0)
		(catch #t               ; try to handle typing mistakes etc
		       (lambda ()
			 (let ((val (<em class=red>eval-string</em> str <em class=red>break-env</em>)))
			   (if (eq? val :go)
			       (return))
			   (write val)))
		       (lambda args
			 (format #t "error: ~A" args))))))))))

;; now some random code that has a breakpoint
(define (a-function b)
  (let ((x 32))
    (do ((i 0 (+ i 1)))
	((= i 10))
      (if (= i 3)
	  (<em class=red>break</em>)))
    x))

(a-function 123)
(display "done!") (newline)
</pre>

<p>
Start up a REPL, and:
</p>

<pre>
&gt; (load "ex.scm")
(a-function "ex.scm" 26) &gt; x    ; here we're in the debugger
32
(a-function "ex.scm" 26) &gt; (+ b i)
126
(a-function "ex.scm" 26) &gt; :go
done!
</pre>

</blockquote>
</small>
</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="IO"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>IO functions</h4></td></tr></table>
</td></tr></table>
</dt>

<dd>
<p>Besides files, ports can also represent strings and functions.  The string port functions
are:
</p>

<ul>
<li>with-output-to-string
<li>with-input-from-string
<li>call-with-output-string
<li>call-with-input-string,
<li>open-output-string
<li>open-input-string
<li>get-output-string
</ul>

<pre>
(let ((result #f) 
      (p (<em class=red>open-output-string</em>)))
  (format p "this ~A ~C test ~D" "is" #\a 3)
  (set! result (<em class=red>get-output-string</em> p))
  (close-output-port p)
  result)
-&gt; "this is a test 3"
</pre>

<p>Other functions:
</p>

<ul>
<li>read-byte and write-byte: binary IO, named "read-u8" and "write-u8" in r6rs, I think
<li>read-line: line-at-a-time reads (for write-line, use format or for-each with write-char).
</ul>

<p>The variable <a name="vectorprintlength">*vector-print-length*</a> sets
the upper limit on how many vector elements are printed by object-&gt;string and format.
</p>

<p>When running s7 behind a GUI, you often want input to come from and output to go to
arbitrary widgets. The function ports provide a way to redirect IO.  See <a href="#functionportexample">below</a>
for an example.
</p>

<p>s7 also includes current-error-port and set-current-error-port.
</p>


<small>
<blockquote>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>binary-io.scm in the Snd package has functions that read and write integers and floats in
both endian choices in a variety of sizes.  Besides read-byte and write-byte, it uses
integer-decode-float, and the various bitwise operators.
</p>

</blockquote>
</small>

</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="miscellanea"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>miscellanea</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p><b><a name="loadpath">*load-path*</a></b> is a list of directories to search when loading a file.
<b><a name="loadhook">*load-hook*</a></b> is a function called just before a file is loaded.  Its argument is the filename.
While loading, the port-filename and port-line-number of the current-input-port can tell you
where you are in the file.
</p>

<pre>
(set! *load-hook* (lambda (name) (format #t "loading ~S...~%" name)))
</pre>

<p>Here's a *load-hook* function that adds the loaded file's directory
to the *load-path* variable so that subsequent loads don't need to specify
the directory:
</p>

<pre>
(set! <em class=red>*load-hook*</em>
  (lambda (filename)
    (let ((pos -1)
	  (len (length filename)))
      (do ((i 0 (+ i 1)))
	  ((= i len))
	(if (char=? (filename i) #\/)
	    (set! pos i)))
      (if (positive? pos)
	  (let ((directory-name (substring filename 0 pos)))
	    (if (not (member directory-name <em class=red>*load-path*</em>))
		(set! <em class=red>*load-path*</em> (cons directory-name *load-path*))))))))
</pre>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>


<p>As in Common Lisp, <b><a name="featureslist">*features*</a></b> is a list describing what is currently loaded into s7.  You can
check it with the <b>provided?</b> function, or add something to it with <b>provide</b>.  In my version of Snd,
at startup *features* is:
</p>

<pre>
&gt; *features*
(snd11 snd snd-s7 snd-motif gsl alsa xm clm4 clm sndlib gmp s7)

&gt; (provided? 'gmp)
#t
</pre>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>



<p>Multi-line comments can be enclosed in either #| and |#, or #! and !# (the latter
is for compatibility with Guile).  These are also useful for in-line comments:
<code>(+ #| add |# 1 2)</code>.
</p>

<p>Leaving aside these two cases, and the booleans, #f and #t, you can specify your own handlers for 
tokens that start with "#".  <b><a name="sharpreaders">*#readers*</a></b> is a list of pairs: <code>(char . func)</code>.
"char" refers to the first character after the sharp sign (#). "func" is a function of
one argument, the string that follows the #-sign up to the next delimiter.  "func" is called
when #&lt;char&gt; is encountered.  If it returns something other than #f, the #-expression
is replaced with that value.  Scheme has several predefined #-readers for cases such
as #b1, #\a, #i123, and so on, but you can override these if you like.  If the string
passed in is not the complete #-expression, the function can use read-char or read to get the
rest.  Say we'd like #t&lt;number&gt; to interpret the number in base 12:
</p>

<pre>
(set! *#readers* 
      (cons (cons #\t (lambda (str) 
                        (string-&gt;number (substring str 1) 12)))
            *#readers*))

&gt; #tb
11
&gt; #t11.3
13.25
</pre>

<p>I use *#readers* primarily to implement a way to get the current line number and file name, along
the lines of C's __LINE__ and __FILE__.  port-line-number works if we're reading a file (during load
for example), and *error-info* has the same information if an error happens.  But during Snd's auto-test
sequence, there are many cases that aren't errors, and the file is no longer being loaded, but
I need to know where something unexpected happened.  So:
</p>

<pre>
(set! *#readers* 
      (cons (cons #\_ (lambda (str)
			(if (string=? str "__line__")
			    (port-line-number)
			    (if (string=? str "__file__")
			        (port-filename)
			        #f))))
            *#readers*))
</pre>

<p>Here's a reader macro for read-time evaluation:
</p>

<pre>
(set! *#readers*
  (cons (cons #\. (lambda (str)
		    (if (string=? str ".") (eval (read)) #f)))
	*#readers*))

&gt; '(1 2 #.(* 3 4) 5)
(1 2 12 5)
</pre>



<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>


<p>(<b>make-list</b> length (initial-element #f)) returns a list of 'length' elements defaulting to 'initial-element'.
</p>

<p><b>reverse!</b> is an in-place version of the built-in function reverse.  That is, 
it modifies the list passed to it in the process of reversing its contents.
<b>list-set!</b> sets a member of a list.  <b>sort!</b> sorts a list or a vector using the
function passed as its second argument to choose the new ordering.
</p>

<pre>
&gt; (sort! (list 3 4 8 2 0 1 5 9 7 6) &lt;)
(0 1 2 3 4 5 6 7 8 9)

(define (mix-notelists . notelists)
  ;; assume the 2nd parameter is the begin time in seconds (the 1st is the instrument name)
  (<em class=red>sort!</em>
   (apply append notelists)
   (lambda (note1 note2)
     (&lt; (cadr note1) (cadr note2)))))

(mix-notelists '((fm-violin 0 1 440 .1)
		 (fm-violin 1 1 550 .1))
	       '((bird 0 .1 )
		 (bird .2 .1)
		 (bird 1.2 .3)
		 (bird .5 .5)))

 -&gt; ((bird 0 0.1) (fm-violin 0 1 440 0.1) (bird 0.2 0.1) (bird 0.5 0.5) (fm-violin 1 1 550 0.1) (bird 1.2 0.3))
</pre>

<p>Despite the "!" in its name, sort! actually copies any list argument passed to it,
but vectors are sorted in place.
</p>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>


<p>
Keywords exist mainly for define*'s benefit.  The keyword functions are:
<b>keyword?</b>, <b>make-keyword</b>, <b>symbol-&gt;keyword</b>, and <b>keyword-&gt;symbol</b>.
A keyword is a symbol that starts or ends with a colon. The colon
is considered to be a part of the symbol name.  A keyword is a constant that evaluates to itself.
</p>



<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>


<p><b>help</b> tries to find information about its argument.
</p>

<pre>
&gt; (help 'caadar)
"(caadar lst) returns (car (car (cdr (car lst)))): (caadar '((1 (2 3)))) -&gt; 2"
</pre>

<p>If the initial expression in a function body is a string constant, it is assumed to be a documentation string (accessible via help or procedure-documentation):
</p>

<pre>
(define (add1 a)
  "(add1 a) adds 1 to its argument"
  (+ a 1))

&gt; (help add1)
"(add1 a) adds 1 to its argument"
</pre>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p><b>quit</b> exits s7.
</p>

<p><b>gc</b> calls the garbage collector.  <code>(gc #f)</code> turns off the GC, and <code>(gc #t)</code> turns it on.
In the multithread case, don't call gc yourself except from the top-level.
</p>

<!--
<p>
<b>define-expansion</b> defines read-time macros, which are just dangerous enough that
I probably shouldn't document them.  It has the same syntax as
define-macro, and the same result except that the macro is
dealt with at read time!  (This means it does not respect attempts to
bind it to something else, which is asking for confusion).
</p>
-->

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>


<p>Some other differences from r5rs:
</p>

<ul>
<li>after the initial binding, do sets its step variables, rather than rebinding them.
<li>no force or delay (use slib).
<li>no syntax-rules or any of its friends.
<li>s7-version returns the current s7 version.
<li>no scheme-report-environment (use initial-environment), null-environment, or interaction-environment (use current-environment).
<li>no transcript-on or transcript-off.
<li><A NAME="__func__">__func__</a> is the name (or name and location) of the function currently being defined or called, as in C.
<li>begin returns the value of the last form; it can contain both definitions and other statements.
<li>#&lt;unspecified&gt;, #&lt;eof&gt;, and #&lt;undefined&gt; are first-class objects.
<li>for-each and map accept different length arguments; the operation stops when any argument reaches its end.
<li>letrec*, but without conviction.
<li>set! and *-set! return the new value, not #&lt;unspecified&gt;.
<li>port-closed?
<li>current-input-port, current-output-port, and current-error-port have setters
<li>the default IO ports are named *stdin*, *stdout*, and *stderr*.
</ul>

<small>
<blockquote>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Schemes vary in their treatment of ().  s7 considers it a constant that evaluates to itself,
so you rarely need to quote it.  <code>(eq? () '())</code> is #t.
This is consistent with, for example,
<code>(eq? #f '#f)</code> which is also #t.
The standard says "the empty list is a special object of its own type", so surely either choice is
acceptable in that regard.  One place where the quote matters is in a case statement; the selector is
evaluated but the key is not:
</p>

<pre>
&gt; (case '() ((()) 2) (else 1))
2
&gt; (case '() (('()) 2) (else 1)) ; (eqv? '() ''()) is #f
1
;;; which parallels #f (or a number such as 2 etc):
&gt; (case '#f ((#f) 2) (else 1))
2
&gt; (case '#f (('#f) 2) (else 1)) ; (eqv? '#f ''#f) is #f
1
</pre>

<p>Similarly, vector constants do not have to be quoted.  A list constant is quoted
to keep it from being evaluated, but
#(1 2 3) is as unproblematic as "123" or 123.
</p>



<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Schemes also vary in handling trailing arguments:
<code>(* 0 "hi")</code> in Guile returns 0, but s7 gives an error.  
<code>(cond (1) (=&gt;))</code> is 1 in both,  and
<code>(or 1 2 . 3)</code> is an
error in Guile, and 1 in s7!
Because it flushes trailing arguments, Guile returns 0 from <code>(* 0 +inf.0)</code>, but I think it should return NaN.
</p>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>And a harder one... How should s7 treat this:
<code>(string-set! "hiho" 1 #\z)</code>, or 
<code>(vector-set! #(1 2 3) 1 32)</code>, or
<code>(list-set! '(1 2 3) 1 32)</code>?
Originally, in s7, the first two were errors, and the third was allowed, which doesn't make much sense.
Guile and Common Lisp accept all three, but that leads to weird cases where we can reach
into a function's body:
</p>

<pre>
&gt; (let ((x (lambda () '(1 2 3)))) (list-set! (x) 1 32) (x))
(1 32 3) ; s7, Guile

&gt; (flet ((x () '(1 2 3))) (setf (nth 1 (x)) 32) (x))
(1 32 3) ; Clisp

&gt; (let ((x (lambda () (list 1 2 3)))) (list-set! (x) 1 32) (x))
(1 2 3)
</pre>

<p>
But it's possible to reach into a function's closure, even when the
closed-over thing is a constant:
</p>

<pre>
&gt; (flet ((x () '(1 2 3))) (setf (nth 1 (x)) 32) (x))
(1 32 3)

&gt; (let ((xx (let ((x '(1 2 3))) (lambda () x)))) (list-set! (xx) 1 32) (xx))
(1 32 3)

&gt; (let ((xx (let ((x (list 1 2 3))) (lambda () x)))) (list-set! (xx) 1 32) (xx))
(1 32 3)
</pre>

<p>And it's possible to reach into a constant list via list-set! (or set-car! of course):
</p>

<pre>
&gt; (let* ((x '(1 2)) (y (list x)) (z (car y))) (list-set! z 1 32) (list x y z))
((1 32) ((1 32)) (1 32))
</pre>

<p>
It would be a programmer's nightmare to have to keep track of which piece of a list is
constant, and an implementor's nightmare to copy every list.  set! in all its forms is
used for its side-effects, so why should we try to put a fence around them?
<!--
(The argument for immutability goes: most programmers are not very bright and they're writing air-traffic
controllers.  Well, geez, can anything pass the dumb-but-deadly-programmer test?
Consider if-then: make one small mistake and people start falling out of the sky.
But dumb arguments aren't interesting...)
-->
If we flush "immutable constant" because it is a ham-fisted, whack-it-with-a-shovel approach,
the only real problem I can see is symbol-&gt;string.  In CL, this is explicitly an error:
</p>

<pre>
&gt; (setf (elt (symbol-name 'xyz) 1) #\X)
*** - Attempt to modify a read-only string: "XYZ"
</pre>

<p>And in Guile:
</p>

<pre>
&gt; (string-set! (symbol-&gt;string 'symbol-&gt;string) 1 #\X)
ERROR: string is read-only: "symbol-&gt;string"
</pre>

<p>So both have a notion of immutable strings.  
I wonder what other Scheme programmers (not implementors!) want in this situation.
Currently, there are no immutable list, string, or vector constants, and
symbol-&gt;string
returns a copy of the string.
One simple way to ensure immutability is to use copy:
</p>

<pre>
&gt; (let ((x (lambda () (copy "hiho")))) (string-set! (x) 1 #\x) (x))
"hiho"
</pre>

<p>A serpent lurks beneath this placid surface.  s7 normally tries to optimize garbage collection by
removing some constants from the heap.  If that constant is a list or a vector, and you later
set some member of it to something that needs GC protection, nobody in the heap points to it, so
it is GC'd.  Here is an example:
</p>

<pre>
(define (bad-idea)
  (let ((lst '(1 2 3)))              ; or #(1 2 3) and vector-ref|set
    (let ((result (list-ref lst 1)))
     (list-set! lst 1 (* 2.0 16.6))
     (gc)
     result)))
</pre>

<p>Put this is a file, load it into the interpreter, than call <code>(bad-idea)</code> a
few times.  You can turn off the optimization in question by setting the variable <b>*safety*</b>
to 1.  *safety* defaults to 0.
</p>



<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>s7 handles circular lists and vectors and dotted lists with its customary aplomb.  
You can pass them to memq, or print them, for example; you can even evaluate them.  
The print syntax is borrowed from CL:
</p>

<pre>
&gt; (let ((lst (list 1 2 3))) 
    (set! (cdr (cdr (cdr lst))) lst) 
    lst)
#1=(1 2 3 . #1#)

&gt; (let* ((x (cons 1 2)) 
         (y (cons 3 x))) 
    (list x y))
(#1=(1 . 2) (3 . #1#)) ; shared lists use the same syntax: '((1 . 2) (3 1 . 2)) spelled out
</pre>

<p>But should this syntax be readable as well?  I'm inclined to say no because
then it is part of the language, and it doesn't look like the rest of the language.
(I think it's kind of ugly).  Perhaps we could implement it via *#readers*.
</p>

<p>Length returns +inf.0 if passed a circular list, and returns a negative
number if passed a dotted list.  In the dotted case, the absolute value of the length is the list length not counting
the final cdr.  <code>(define (circular? lst) (infinite? (length lst)))</code>.
</p>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>s7 and Snd use "*" in a variable name, *features* for example, to indicate
that the variable is predefined.  It may occur unprotected in a macro, for
example.  The "*" doesn't mean that the variable is special in the CL sense of dynamic scope,
but some clear marker is needed for a global variable so that the programmer
doesn't accidentally step on it.  
</p>

<p>Although a variable name's first character is more restricted, currently
only #\null, #\newline, #\tab, #\space, #\), #\(, #\", and #\; can't
occur within the name.  I did not originally include double-quote in this set, so wild stuff like
<code>(let ((nam""e 1)) nam""e)</code>
would work, but that means that <code>'(1 ."hi")</code> is parsed as a 1 and the
symbol <code>."hi"</code>, and <code>(string-set! x"hi")</code> is an error.
The first character should not be #\#, #\', #\`, #\,, #\:, or any of those mentioned above,
and some characters can't occur by themselves.  For example, "." is not a legal variable
name, but ".." is. 
These weird symbols have to be printed sometimes:
</p>

<pre>
&gt; (list 1 (string-&gt;symbol (string #\; #\" #\\)) 2)
(1 ;"\ 2)            <!-- " -->
&gt; (list 1 (string-&gt;symbol (string #\.)) 2)
(1 . 2)
</pre>

<p>which is a mess.  Guile prints the first as <code>(1 #{\;\"\\}# 2)</code>.
In CL and some Schemes:
</p>

<pre>
[1]&gt; (list 1 (intern (coerce (list #\; #\" #\\) 'string)) 2) ; thanks to Rob Warnock
(1 |;"\\| 2)        <!-- " -->
[2]&gt; (equalp 'A '|A|) ; in CL case matters here
T
</pre>

<p>This is clean, and has the weight of tradition behind it, but 
I think I'll use "symbol" instead:
</p>

<pre>
&gt; (list 1 (string-&gt;symbol (string #\; #\" #\\)) 2)
(1 (symbol ";\"\\") 2)       <!-- " -->
</pre>

<p>
This output is readable, and does not eat up perfectly good
characters like vertical bar, but it means we can't easily use
variable names like "| e t c |".  We could allow a name to
contain any characters if it starts and ends with "|",
but then one vertical bar is trouble.  
</p>

<p>
These symbols are not just a silly optimization of string comparison:
</p>

<pre>
(define-macro (hi a) 
  (let ((funny-name (string-&gt;symbol (string #\;))))
    `(let ((,funny-name ,a)) (+ 1 ,funny-name))))

&gt; (hi 2)
3
&gt; (macroexpand (hi 2))
(let ((; 2)) (+ 1 ;))    ; for a good time, try (string #\") 

(define-macro (hi a) 
  (let ((funny-name (string-&gt;symbol "| e t c |")))
    `(let ((,funny-name ,a)) (+ 1 ,funny-name))))
&gt; (hi 2)
3
&gt; (macroexpand (hi 2))
(let ((| e t c | 2)) (+ 1 | e t c |))

&gt; (let ((funny-name (string-&gt;symbol "| e t c |"))) ; now use it as a keyword arg to a function
    (apply define* `((func (,funny-name 32)) (+ ,funny-name 1)))
    ;; (procedure-source func) is (lambda* ((| e t c | 32)) (+ | e t c | 1))
    (apply func (list (symbol-&gt;keyword funny-name) 2)))
3
</pre>

<p>I hope that makes you as happy as it makes me!
</p>



<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>The built-in syntactic names, such as "begin", are almost first-class citizens.
</p>

<pre>
&gt; (let ((progn begin)) 
    (progn 
      (define x 1) 
      (set! x 3) 
      (+ x 4)))
7

&gt; (let ((function lambda)) 
    ((function (a b) (list a b)) 3 4))
(3 4)

&gt; (apply begin '((define x 3) (+ x 2)))
5

&gt; ((lambda (n) (apply n '(((x 1)) (+ x 2)))) let)
3

&gt; (define-macro (symbol-set! var val) ; use apply instead of define-bacro
    `(apply set! ,var (list ,val)))
</pre>

<p>We can snap together program fragments ("look Ma, no macros!"):
</p>

<pre>
(let* ((x 3) 
       (arg '(x)) 
       (body `((+ ,x x 1)))) 
  ((apply lambda arg body) 12)) ; "legolambda"?
</pre>

<p>If you apply define or define-macro, the returned value is a symbol, so to apply the
new function or macro, you need to use either eval or symbol-&gt;value:
</p>

<pre>
&gt; ((symbol-&gt;value (apply define-macro '((m a) `(+ 1 ,a)))) 3)
4
&gt; ((symbol-&gt;value (apply define '((hi a) (+ a 1)))) 3)
4
</pre>

<p>This gives us a way to make anonymous macros, just as lambda returns an anonymous function:
</p>

<pre>
(define-macro (mu args . body)
  (let ((m (gensym)))
    `(symbol-&gt;value (apply define-macro '((,m ,@args) ,@body)))))

&gt; ((mu (a) `(+ 1 ,a)) 3)
4
</pre>

<p>You can't currently map a macro over a list because map wants its first
argument to be a procedure.  Perhaps this is unreasonable.
You also can't set the syntactic object to some new value:
<code>(set! if 3)</code>.
I hope this kind of thing is not actually very useful, but let me
know if you need it.  The issue is purely one of speed.
</p>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>
In s7, there is only one kind of begin statement,
and it can contain both definitions and expressions.  These are evaluated in the order
in which they occur, and in the environment at the point of the evaluation.  I think
of it as being a little REPL.  begin does not introduce a new frame in
the current environment, so defines happen at the enclosing level.
</p>

<pre>
&gt; (let ((y 2)) 
      (let ((x 1)) 
        (begin 
          (define x y)         ; x is 2 (this x is the same as the x in the let above it)
          (set! x (* x 2))     ; now it is 4
          (define y 123))      ; this is great, but it doesn't affect x 
         x))                   ; defines in begin are in the enclosing environment so
   4                           ;   we get 4
</pre>



<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>I can't find the right tone for this section; this is the 400-th revision; I wish I were a better writer!
I think the exact/inexact distinction in Scheme is confused and useless, and leads
to verbose and buggy code.  
In some Schemes,
"rational" means "could possibly be
expressed equally well as a ratio (floats are approximations)".  In s7 it's: "is actually expressed as a ratio (or an integer of course)";
otherwise "rational?" is the same as "real?":
</p>

<pre>
(not-s7-scheme)&gt; (rational? (sqrt 2))
#t
</pre>

<p>As I understand it, "inexact" originally meant "floating point", and "exact" meant integer or ratio of integers.
But words have a life of their own.
0.0 somehow became an "inexact" integer (although it can be represented exactly in floating
point).  
+inf.0 must be an integer &mdash;
its fractional part is explicitly zero!  But +nan.0... 
And then there's:
</p>

<pre>
(not-s7-scheme)&gt; (integer? 9007199254740993.1)
#t
</pre>

<p>
When does this matter?  I often need to index into a vector, but the index is a float (a "real" in Scheme-speak: its
fractional part can be non-zero).
In one scheme:
</p>

<pre>
(not-s7-scheme)&gt; (vector-ref #(0) (floor 0.1))
ERROR: Wrong type (expecting exact integer): 0.0   ; [why?  "it's probably a programmer mistake"!]
</pre>

<p>Not to worry, I'll use inexact-&gt;exact:
</p>

<pre>
(not-s7-scheme)&gt; (inexact-&gt;exact 0.1)              ; [why? "floats are ratios"!]
3602879701896397/36028797018963968
</pre>

<p>So I end up using the verbose <code>(floor (inexact-&gt;exact ...))</code> everywhere, and even
then I have no guarantee that I'll get a legal vector index.
When I started work on s7, I thought perhaps
"exact" could mean "is represented exactly in the computer".  We'd have integers and ratios exact; 
reals and complex exact if they are exactly
represented in the current floating point implementation.  
0.0 and 0.5 might be exact if the printout isn't misleading, and 0.1 is inexact.
"integer?" and friends would refer instead to the programmer's point of view.
That is, if the programmer uses 1 or if the thing prints as 1, it is the integer 1, whereas 1.0
means floating point (not integer!).
And to keep exactness in view, we'd have
to monitor which operations introduce inexactness &mdash; a kind of interval arithmetic.
But then what would inexact-&gt;exact do?  
If we discard the exact/inexact distinction,
we can maintain backwards compatibility via:
</p>

<pre>
    (define exact? rational?)
    (define (inexact? x) (not (rational? x)))
    (define inexact-&gt;exact rationalize) ; or floor
    (define (exact-&gt;inexact x) (* x 1.0))
</pre>

<p>#i and #e are also useless because you can
have any number after, for example, #b:
</p>

<pre>
    &gt; #b1.1
    1.5
    &gt; #b1e2
    4.0
    &gt; #o17.5+i
    15.625+1i
</pre>

<p>Speaking of #b and friends, what should <code>(string-&gt;number "#xffff" 2)</code> return?
</p>



<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Here are some additional changes I'd make to s7 if I didn't care about compatibility with other Schemes:
</p>

<pre>
   remove the exact/inexact distinction including #i and #e
   remove `#(...) support (quasiquoted vector constants)
   remove *-ci functions
   remove string&lt;-&gt;list and vector&lt;-&gt;list
   change string-&gt;symbol to symbol
   remove call-with-values and its friends
   remove char-ready?
   change eof-object? to eof? or better end-of-input?
   use @ as the exponent marker if base &gt; 10
</pre>

<p>and perhaps:
</p>

<pre>
   remove even? and odd?
   remove the 4-way cxxxxr functions
   add file-exists?, directory?, and delete-file
   add a generic position function
   remove list-ref|set!, string-ref|set!, vector-ref|set!, hash-table-ref|set!,
     set-car!|cdr!, and set-current-output|input|error-port.  All of these
     are redundant given generalized set!.  Also string-length and vector-length.
</pre>

<p>Scheme needs a more elegant way to define functions that share a closure.
</p>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>


<p>"Life", a poem.
</p>

<pre>
(+(*(+))(*)(+(+)(+)(*)))
(((((lambda () (lambda () (lambda () (lambda () 1))))))))
(+ (((lambda () values)) 1 2 3))
(map apply (list map) (list map) (list (list *)) '((((1 2)) ((3 4 5)))))
(do ((do do do)) (do do do))
</pre>

</blockquote>
</small>

</dd>
<br>
<br><br>




<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="s7rundoc"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>the run macro</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>s7 is primarily aimed at computer music, CLM-based sound synthesis in particular.
A CLM instrument is usually a do-loop running things like oscillators and envelopes
for zillions of sound samples.  These calculations do not involve recursion, or
complex numbers, or fancy list processing, so it is not too hard to write an
optimizer for them.  In sndlib, that optimizer is called "run".  It is a macro (in modern jargon, a JIT byte compiler)
that can be wrapped around any piece of Scheme code that you want to speed up.
If it can't optimize the code, it passes it to the s7 interpreter.  If run is successful,
you will normally get a speed up by a factor of 10 to 30.  For CLM instruments,
the result runs close to the speed of the equivalent compiled and optimized
C code.  Here are my timings for two instruments, bird and fm-violin, each running for 100 seconds.
I've included sbcl times for comparison.
</p>

<pre>
          s7 interpreted  s7+run  C (-O2)      sbcl
bird          9.6          .7       .65         .65
violin       21.6         1.44     1.28        1.28
</pre>

<p>
The sbcl and C compiler cases are the same because
CLM in sbcl uses a version of the run macro that translates the CL code to C, calls the C compiler
on that, then loads it as a foreign function, so it is essentially the
same as the straight C case.  In s7, however, we're running interpreted; there is
no separate compilation step.  Another comparison: the fft benchmark from the Gabriel
tests.  In s7 interpreted, it runs 1000 1024 point FFTs in 53 seconds; with "run",
the same takes 2 seconds.  In Guile 1.9.5 after compilation, it takes 10 seconds.
So, in general, s7 is not so slow as to be an annoyance.  
</p>

<!--
sbcl: (with-sound (:play nil :statistics t) (bird 0 100 440.0 10.0 0.5 '(0 0 1 1) '(0 0 1 1 2 1 3 0)))
      (with-sound (:play nil :statistics t) (fm-violin 0 100 440.0 .4))

C: in sndlib configure make
   gcc time-bird.c -o time-bird -O2 -I. libsndlib.a -lasound -lgsl -lgslcblas
   time time-bird

s7: use the sndlib example in s7.html
    gcc -o ex1 ex1.c s7.o -lm -I. -O2
    ex1
    (load "sndlib-ws.scm")
    (load "bird.scm")
    (load "v.scm")

(with-sound (:play #f :statistics #t) (bird 0 100 440.0 10.0 0.5 '(0 0 1 1) '(0 0 1 1 2 1 3 0)))
(with-sound (:play #f :statistics #t) (fm-violin 0 100 440.0 .4))


fft.sch interpreted: 53,  run: 2
guile 1.9.5 after compilation: 10.5
-->


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<small>
<blockquote>

<p>I can't resist giving another example.  Here's some vector arithmetic:
</p>

<pre>
(let* ((size (* 128 1024))
       (v1 (make-vector size 0.0))
       (v2 (make-vector size 0.0))
       (sum 0.0))
  (<em class=red>run</em>
   (do ((i 0 (+ i 1)))
       ((= i size))
     (set! (v1 i) (- (random 2.0) 1.0))
     (set! (v2 i) (- (random 2.0) 1.0)))
   (do ((i 0 (+ i 1)))
       ((= i size) sum)
     (set! sum (+ sum (* (v1 i) (v2 i)))))))
</pre>

<p>With run, this takes .092 seconds on my old machine; without run, it takes 1.94 seconds.
</p>

</blockquote>
</small>

</dd>
<br><br>

</dl>


<!-- -------------------------------------------------------------------------------- -->
<A NAME="FFIexamples"></a>
<table border=0 bordercolor="lightgreen" width=100% cellpadding=2 cellspacing=0><tr><td bgcolor="lightgreen">
<table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h3>FFI examples</h3></td></tr></table>
</td></tr></table>

<p>s7 exists only to serve as an extension of some other application, so
it is primarily a foreign function interface.  s7.h has lots of comments about the individual
functions.  Here I'll collect some complete examples.  s7.c depends on the following
compile-time flags:
</p>

<pre>
    HAVE_STDBOOL_H                 1 if you have stdbool.h
    HAVE_PTHREADS                  1 if you want multithreading support (requires pthreads, default is 0)
    WITH_GMP                       1 if you want multiprecision arithmetic (requires gmp, mpfr, and mpc, default is 0)
    WITH_COMPLEX                   1 if your compiler supports complex numbers
    HAVE_COMPLEX_TRIG              1 if your math library has complex versions of the trig functions
    WITH_PROFILING                 1 if you want profiling support (default is 0)
    S7_DISABLE_DEPRECATED          1 if you want to make sure you're not using any deprecated s7 stuff (default is 0)
</pre>

<p>See the comment at the start of s7.c for more information about these switches.
s7.h defines the two main number types: s7_Int and s7_Double.
The examples that follow show:
</p>

<ul>
<li><a href="#repl">read-eval-print loop</a>
<li><a href="#defun">define a function with arguments and a returned value, and define a variable </a>
<li><a href="#defvar">call a scheme function from C, and get/set scheme variable values in C</a>
<li><a href="#juce">C++ and Juce</a>
<li><a href="#sndlib">load sndlib using the XEN functions and macros</a>
<li><a href="#pwstype">add a new scheme type and a procedure-with-setter</a>
<li><a href="#functionportexample">redirect display output to a C procedure</a>
<li><a href="#extendop">extend a built-in operator ("+" in this case)</a>
<li><a href="#definestar">C-side define* (s7_define_function_star)</a>
<li><a href="#definemacro">C-side define-macro (s7_define_macro)</a>
<li><a href="#signal">signal handling (C-C to break out of an infinite loop)</a>
<li><a href="#vector">direct multidimensional vector element access</a>
<li><a href="#notify">notification in C that a Scheme variable has been set!</a>
<li><a href="#namespace">Load C defined stuff into a separate namespace</a>
<li><a href="#Cerrors">Error handling in C</a>
<li><a href="#closure">Closure defined in C</a>
</ul>

<br><br>

<p>
<A NAME="repl"></a>
First, a bare REPL:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include "s7.h"

static s7_pointer our_exit(s7_scheme *sc, s7_pointer args) 
{
  /* all added functions have this form, args is a list, 
   *    s7_car(args) is the 1st arg, etc 
   */
  exit(1);
  return(s7_nil(sc)); /* never executed, but makes the compiler happier */
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];

  s7 = <em class=red>s7_init</em>();                     /* initialize the interpreter */
  <em class=red>s7_define_function</em>(s7, "exit", our_exit, 0, 0, false, "(exit) exits the program");
                                      /* add the function "exit" to the interpreter.
                                       *   0, 0, false -&gt; no required args,
				       *                  no optional args,
				       *                  no "rest" arg
				       */
  while (1)                           /* fire up a REPL */
    {
      fprintf(stdout, "\n&gt; ");        /* prompt for input */
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  <em class=red>s7_eval_c_string</em>(s7, response); /* evaluate input and write the result */
	}
    }
}

/* make mus-config.h (it can be empty), then
 *
 *   gcc -c s7.c -I.
 *   gcc -o doc7 doc7.c s7.o -lm -I.
 *
 * run it:
 *
 *    doc7
 *    &gt; (+ 1 2)
 *    3
 *    &gt; (define (add1 x) (+ 1 x))
 *    add1
 *    &gt; (add1 2)
 *    3
 *    &gt; (exit)
 */
</pre>
</td></tr></table>



<br><br>
<A NAME="defun"></a>
<p>Define a function with arguments and a returned value, and a variable:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer our_exit(s7_scheme *sc, s7_pointer args)
{
  exit(1);
  return(s7_nil(sc));
}

static s7_pointer add1(s7_scheme *sc, s7_pointer args)
{
  if (<em class=red>s7_is_integer</em>(s7_car(args)))
    return(<em class=red>s7_make_integer</em>(sc, 1 + <em class=red>s7_integer</em>(s7_car(args))));
  return(s7_wrong_type_arg_error(sc, "add1", 1, s7_car(args), "an integer"));
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];

  s7 = s7_init();                     /* initialize the interpreter */
  
  s7_define_function(s7, "exit", our_exit, 0, 0, false, "(exit) exits the program");
  s7_define_function(s7, "add1", add1, 1, 0, false, "(add1 int) adds 1 to int");
  <em class=red>s7_define_variable</em>(s7, "my-pi", <em class=red>s7_make_real</em>(s7, 3.14159265));

  while (1)                           /* fire up a "repl" */
    {
      fprintf(stdout, "\n&gt; ");        /* prompt for input */
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response); /* evaluate input and write the result */
	}
    }
}

/*    doc7
 *    &gt; my-pi
 *    3.14159265
 *    &gt; (+ 1 (add1 1))
 *    3
 *    &gt; (exit)
 */
</pre>
</td></tr></table>



<br><br>
<A NAME="defvar"></a>
<p>Call a scheme-defined function from C, and get/set scheme variable values in C:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

int main(int argc, char **argv)
{
  s7_scheme *s7;
  s7 = s7_init();

  s7_define_variable(s7, "an-integer", s7_make_integer(s7, 1));
  s7_eval_c_string(s7, "(define (add1 a) (+ a 1))");
  
  fprintf(stderr, "an-integer: %d\n", 
	  s7_integer(<em class=red>s7_name_to_value</em>(s7, "an-integer")));

  <em class=red>s7_symbol_set_value</em>(s7, <em class=red>s7_make_symbol</em>(s7, "an-integer"), s7_make_integer(s7, 32));

  fprintf(stderr, "now an-integer: %d\n", 
	  s7_integer(<em class=red>s7_name_to_value</em>(s7, "an-integer")));

  fprintf(stderr, "(add1 2): %d\n", 
	  s7_integer(<em class=red>s7_call</em>(s7, 
			     s7_name_to_value(s7, "add1"), 
			     s7_cons(s7, s7_make_integer(s7, 2), s7_nil(s7)))));
}

/*
 *    doc7
 *    an-integer: 1
 *    now an-integer: 32
 *    (add1 2): 3
 */
</pre>
</td></tr></table>



<br><br>
<A NAME="juce"></a>
<p>C++ and Juce, from Rick Taube:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
int main(int argc, const char* argv[]) 
{ 
  initialiseJuce_NonGUI(); 

  s7_scheme *s7 = s7_init(); 
  if (!s7) 
    { 
      std::cout &lt;&lt;  "Can't start S7!\n"; 
      return -1; 
    } 

  s7_pointer val; 
  std::string str; 
  while (true) 
    { 
      std::cout &lt;&lt; "\ns7&gt; "; 
      std::getline(std::cin, str); 
      val = s7_eval_c_string(s7, str.c_str()); 
      std::cout &lt;&lt; s7_object_to_c_string(s7, val); 
    } 

  free(s7); 
  std::cout &lt;&lt; "Bye!\n"; 
  return 0; 
} 
</pre>
</td></tr></table>



<br><br>
<A NAME="sndlib"></a>
<p>Load sndlib using the XEN functions and macros into an s7 repl:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

/* assume we've configured and built sndlib, so it has created a mus-config.h file */

#include "mus-config.h"
#include "s7.h"
#include "xen.h"
#include "clm.h"
#include "clm2xen.h"

/* we need to redirect clm's mus_error calls to s7_error */

static void mus_error_to_s7(int type, char *msg)
{
  s7_error(s7,                               /* s7 is declared in xen.h */
	   s7_make_symbol(s7, "mus-error"),
	   s7_cons(s7, s7_make_string(s7, msg), s7_nil(s7)));
}

static s7_pointer our_exit(s7_scheme *sc, s7_pointer args)
{
  exit(1);
  return(s7_nil(sc));
}

/* the next functions are needed for either with-sound or many standard instruments, like fm-violin */
/*   (these are in the xen-style FFI) */

static XEN g_file_exists_p(XEN name)
{
  #define H_file_exists_p "(file-exists? filename): #t if the file exists"
  XEN_ASSERT_TYPE(XEN_STRING_P(name), name, XEN_ONLY_ARG, "file-exists?", "a string");
  return(C_TO_XEN_BOOLEAN(mus_file_probe(XEN_TO_C_STRING(name))));
}

XEN_NARGIFY_1(g_file_exists_p_w, g_file_exists_p)

static XEN g_delete_file(XEN name)
{
  #define H_delete_file "(delete-file filename): deletes the file"
  XEN_ASSERT_TYPE(XEN_STRING_P(name), name, XEN_ONLY_ARG, "delete-file", "a string");
  return(C_TO_XEN_BOOLEAN(unlink(XEN_TO_C_STRING(name))));
}

XEN_NARGIFY_1(g_delete_file_w, g_delete_file)

int main(int argc, char **argv)
{
  char buffer[512];
  char response[1024];

  s7 = s7_init();                     /* initialize the interpreter */
  xen_initialize();                   /* initialize the xen stuff (hooks and the xen s7 FFI used by sndlib) */
  Init_sndlib();                      /* initialize sndlib with all the functions linked into s7 */  

  mus_error_set_handler(mus_error_to_s7); /* catch low-level errors and pass them to s7-error */

  XEN_DEFINE_PROCEDURE("file-exists?", g_file_exists_p_w, 1, 0, 0, H_file_exists_p);
  XEN_DEFINE_PROCEDURE("delete-file",  g_delete_file_w,   1, 0, 0, H_delete_file);
  s7_define_function(s7, "exit", our_exit, 0, 0, false, "(exit) exits the program");

  while (1)                           /* fire up a "repl" */
    {
      fprintf(stdout, "\n&gt; ");        /* prompt for input */
      fgets(buffer, 512, stdin);

      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response); /* evaluate input and write the result */
	}
    }
}

/* gcc -o doc7 doc7.c -lm -I. /usr/local/lib/libsndlib.a -lasound
 *
 *   (load "sndlib-ws.scm")
 *   (with-sound () (outa 10 .1))
 *   (load "v.scm")
 *   (with-sound () (fm-violin 0 .1 440 .1))
 *
 * you might also need -lgsl -lgslcblas
 */
</pre>
</td></tr></table>



<br><br>
<A NAME="pwstype"></a>
<p>Add a new scheme type and procedure-with-setters:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer our_exit(s7_scheme *sc, s7_pointer args)
{
  exit(1);
  return(s7_nil(sc));
}

/* define *listener-prompt* in scheme, add two accessors for C get/set */

static const char *listener_prompt(s7_scheme *sc)
{
  return(s7_string(s7_name_to_value(sc, "*listener-prompt*")));
}

static void set_listener_prompt(s7_scheme *sc, const char *new_prompt)
{
  s7_symbol_set_value(sc, s7_make_symbol(sc, "*listener-prompt*"), s7_make_string(sc, new_prompt));
}

/* now add a new type, a struct named "dax" with two fields, a real "x" and a list "data" */
/*   since the data field is an s7 object, we'll need to mark it to protect it from the GC */

typedef struct {
  s7_Double x;
  s7_pointer data;
} dax;

static char *print_dax(s7_scheme *sc, void *val)
{
  char *data_str, *str;
  int data_str_len;
  dax *o = (dax *)val;
  data_str = s7_object_to_c_string(sc, o-&gt;data);
  data_str_len = strlen(data_str);
  str = (char *)calloc(data_str_len + 32, sizeof(char));
  snprintf(str, data_str_len + 32, "#&lt;dax %.3f %s&gt;", o-&gt;x, data_str);
  free(data_str);
  return(str);
}

static void free_dax(void *val)
{
  if (val) free(val);
}

static bool equal_dax(void *val1, void *val2)
{
  return(val1 == val2);
}

static void mark_dax(void *val)
{
  dax *o = (dax *)val;
  if (o) s7_mark_object(o-&gt;data);
}

static int dax_type_tag = 0;

static s7_pointer make_dax(s7_scheme *sc, s7_pointer args)
{
  dax *o;
  o = (dax *)malloc(sizeof(dax));
  o-&gt;x = s7_real(s7_car(args));
  if (s7_cdr(args) != s7_nil(sc))
    o-&gt;data = s7_car(s7_cdr(args));
  else o-&gt;data = s7_nil(sc);
  return(<em class=red>s7_make_object</em>(sc, dax_type_tag, (void *)o));
}

static s7_pointer is_dax(s7_scheme *sc, s7_pointer args)
{
  return(s7_make_boolean(sc, 
			 <em class=red>s7_is_object</em>(s7_car(args)) &amp;&amp;
			 <em class=red>s7_object_type</em>(s7_car(args)) == dax_type_tag));
}

static s7_pointer dax_x(s7_scheme *sc, s7_pointer args)
{
  dax *o;
  o = (dax *)<em class=red>s7_object_value</em>(s7_car(args));
  return(s7_make_real(sc, o-&gt;x));
}

static s7_pointer set_dax_x(s7_scheme *sc, s7_pointer args)
{
  dax *o;
  o = (dax *)s7_object_value(s7_car(args));
  o-&gt;x = s7_real(s7_car(s7_cdr(args)));
  return(s7_car(s7_cdr(args)));
}

static s7_pointer dax_data(s7_scheme *sc, s7_pointer args)
{
  dax *o;
  o = (dax *)s7_object_value(s7_car(args));
  return(o-&gt;data);
}

static s7_pointer set_dax_data(s7_scheme *sc, s7_pointer args)
{
  dax *o;
  o = (dax *)s7_object_value(s7_car(args));
  o-&gt;data = s7_car(s7_cdr(args));
  return(o-&gt;data);
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];

  s7 = s7_init();
  
  s7_define_function(s7, "exit", our_exit, 0, 0, false, "(exit) exits the program");
  s7_define_variable(s7, "*listener-prompt*", s7_make_string(s7, "&gt;"));

  dax_type_tag = <em class=red>s7_new_type</em>("dax", print_dax, free_dax, equal_dax, mark_dax, NULL, NULL);
  s7_define_function(s7, "make-dax", make_dax, 2, 0, false, "(make-dax x data) makes a new dax");
  s7_define_function(s7, "dax?", is_dax, 1, 0, false, "(dax? anything) returns #t if its argument is a dax object");

  s7_define_variable(s7, "dax-x", 
                     <em class=red>s7_make_procedure_with_setter</em>(s7, "dax-x", dax_x, 1, 0, set_dax_x, 2, 0, "dax x field"));

  s7_define_variable(s7, "dax-data", 
                     <em class=red>s7_make_procedure_with_setter</em>(s7, "dax-data", dax_data, 1, 0, set_dax_data, 2, 0, "dax data field"));

  while (1)
    {
      fprintf(stdout, "\n%s ", listener_prompt(s7));
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response); /* evaluate input and write the result */
	}
    }
}

/*
 *    &gt; *listener-prompt*
 *    "&gt;"
 *    &gt; (set! *listener-prompt* ":")
 *    ":"
 *    : (define obj (make-dax 1.0 (list 1 2 3)))
 *    obj
 *    : obj
 *    #&lt;dax 1.000 (1 2 3)&gt;
 *    : (dax-x obj)
 *    1.0
 *    : (dax-data obj)
 *    (1 2 3)
 *    : (set! (dax-x obj) 123.0)
 *    123.0
 *    : obj
 *    #&lt;dax 123.000 (1 2 3)&gt;
 *    : (dax? obj)
 *    #t
 *    : (exit)
 */
</pre>
</td></tr></table>



<br><br>
<A NAME="functionportexample"></a>
<p>Redirect output (and input) to a C procedure:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static void my_print(s7_scheme *sc, char c, s7_pointer port)
{
  fprintf(stderr, "[%c] ", c);
}

static s7_pointer my_read(s7_scheme *sc, s7_read_t peek, s7_pointer port)
{
  return(<em class=red>s7_make_character</em>(s7, fgetc(stdin)));
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];

  s7 = s7_init();  

  <em class=red>s7_set_current_output_port</em>(s7, <em class=red>s7_open_output_function</em>(s7, my_print));
  s7_define_variable(s7, "io-port", <em class=red>s7_open_input_function</em>(s7, my_read));

  while (1) 
    {
      fprintf(stdout, "\n&gt; ");
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response);
	}
    }
}

/* 
 *    &gt; (+ 1 2)
 *    [3]
 *    &gt; (display "hiho")
 *    [h] [i] [h] [o] [#] [&lt;] [u] [n] [s] [p] [e] [c] [i] [f] [i] [e] [d] [&gt;] 
 *    &gt; (define (add1 x) (+ 1 x))
 *    [a] [d] [d] [1] 
 *    &gt; (add1 123)
 *    [1] [2] [4] 
 *    &gt; (read-char io-port)
 *    a                             ; here I typed "a" in the shell
 *    [#] [\] [a] 
 */
</pre>
</td></tr></table>


<br><br>
<A NAME="extendop"></a>
<p>Extend a built-in operator ("+" in this case):
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer old_add;           /* the original "+" function for non-string cases */
static s7_pointer old_string_append; /* same, for "string-append" */

static s7_pointer our_add(s7_scheme *sc, s7_pointer args)
{
  /* this will replace the built-in "+" operator, extending it to include strings:
   *   (+ "hi" "ho") -&gt; "hiho" and  (+ 3 4) -&gt; 7
   */
  if ((s7_is_pair(args)) &amp;&amp;
      (s7_is_string(s7_car(args))))
    return(<em class=red>s7_apply_function</em>(sc, old_string_append, args));

  return(s7_apply_function(sc, old_add, args));
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];

  s7 = s7_init();

  /* get built-in + and string-append */
  old_add = s7_name_to_value(s7, "+");      
  old_string_append = s7_name_to_value(s7, "string-append");

  /* redefine "+" */
  s7_define_function(s7, "+", our_add, 0, 0, true, "(+ ...) adds or appends its arguments");

  while (1)
    {
      fprintf(stdout, "\n&gt; ");
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response);
	}
    }
}

/* 
 *    &gt; (+ 1 2)
 *    3
 *    &gt; (+ "hi" "ho")
 *    "hiho"
 */
</pre>
</td></tr></table>



<br><br>
<A NAME="definestar"></a>
<p>C-side define* (s7_define_function_star):
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer plus(s7_scheme *sc, s7_pointer args)
{
  /* (define* (plus (red 32) blue) (+ (* 2 red) blue)) */
  return(s7_make_integer(sc, 2 * s7_integer(s7_car(args)) + s7_integer(s7_car(s7_cdr(args)))));
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];

  s7 = s7_init();
  <em class=red>s7_define_function_star</em>(s7, "plus", plus, "(red 32) blue", "an example of define* from C");

  while (1)
    {
      fprintf(stdout, "\n&gt; ");
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response);
	}
    }
}

/* 
 *    &gt; (plus 2 3)
 *    7
 *    &gt; (plus :blue 3)
 *    67
 *    &gt; (plus :blue 1 :red 4)
 *    9
 *    &gt; (plus 2 :blue 3)
 *    7
 *    &gt; (plus :blue 3 :red 1)
 *    5
 */
</pre>
</td></tr></table>



<br><br>
<A NAME="definemacro"></a>
<p>C-side define-macro (s7_define_macro):
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer plus(s7_scheme *sc, s7_pointer args)
{
  /* (define-macro (plus a b) `(+ ,a ,b)) */
  s7_pointer a, b;
  a = s7_car(args);
  b = s7_car(s7_cdr(args));
  return(s7_cons(sc, s7_make_symbol(sc, "+"),  /* we are forming the list `(+ ,a ,b) */
	   s7_cons(sc, a,
	     s7_cons(sc, b, s7_nil(sc)))));
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];

  s7 = s7_init();
  <em class=red>s7_define_macro</em>(s7, "plus", plus, 2, 0, false, "plus adds its two arguments");

  while (1)
    {
      fprintf(stdout, "\n&gt; ");
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response);
	}
    }
}

/* 
 *    &gt; (plus 2 3)
 *    5
 */
</pre>
</td></tr></table>



<br><br>
<A NAME="signal"></a>
<p>Signal handling (C-C to break out of an infinite loop), and s7_make_continuation
to pick up where we were interrupted:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;signal.h&gt;

#include "s7.h"

static s7_scheme *s7;
struct sigaction new_act, old_act;  
  
static void handle_sigint(int ignored)  
{  
  fprintf(stderr, "interrupted!\n");
  s7_symbol_set_value(s7, s7_make_symbol(s7, "*interrupt*"), <em class=red>s7_make_continuation</em>(s7)); /* save where we were interrupted */
  sigaction(SIGINT, &amp;new_act, NULL);  
  s7_quit(s7);                             /* get out of the eval loop if possible */
}  

static s7_pointer our_exit(s7_scheme *sc, s7_pointer args)
{ 
  /* this function is really needed if we are trapping C-C! */
  exit(1);
  return(s7_f(sc));
}

static s7_pointer our_sleep(s7_scheme *sc, s7_pointer args)
{
  /* slow down out infinite loop for demo purposes */
  sleep(1);
  return(s7_f(sc));
}

int main(int argc, char **argv)
{
  char buffer[512];
  char response[1024];

  s7 = s7_init();
  s7_define_function(s7, "exit", our_exit, 0, 0, false, "(exit) exits");
  s7_define_function(s7, "sleep", our_sleep, 0, 0, false, "(sleep) sleeps");
  s7_define_variable(s7, "*interrupt*", s7_f(s7)); 
  /* scheme variable *interrupt* holds the continuation at the point of the interrupt */

  sigaction(SIGINT, NULL, &amp;old_act);
  if (old_act.sa_handler != SIG_IGN)
    {
      memset(&amp;new_act, 0, sizeof(new_act));  
      new_act.sa_handler = &amp;handle_sigint;  
      sigaction(SIGINT, &amp;new_act, NULL);  
    }

  while (1)
    {
      fprintf(stderr, "\n&gt; ");
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response);
	}
    }
}

/*
 *    &gt; (do ((i 0 (+ i 1))) ((= i -1)) (format #t "~D " i) (sleep))
 *      ;;; now type C-C to break out of this loop
 *    0 1 2 ^Cinterrupted!
 *      ;;; call the continuation to continue from where we were interrupted
 *    &gt; (*interrupt*)
 *    3 4 5 ^Cinterrupted!
 *    &gt; *interrupt*
 *    #&lt;continuation&gt;
 *    &gt; (+ 1 2)
 *    3
 */
</pre>
</td></tr></table>



<br><br>
<A NAME="vector"></a>
<p>Multidimensional vector element access:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdarg.h&gt;

#include "s7.h"

static s7_pointer multivector_ref(s7_scheme *sc, s7_pointer vector, int indices, ...)
{
  /* multivector_ref returns an element of a multidimensional vector */
  int ndims;
  ndims = <em class=red>s7_vector_rank</em>(vector);

  if (ndims == indices)
    {
      va_list ap;
      s7_Int index = 0;
      va_start(ap, indices);

      if (ndims == 1)
	{
	  index = va_arg(ap, s7_Int);
	  va_end(ap);
	  return(s7_vector_ref(sc, vector, index));
	}
      else
	{
	  int i;
	  s7_pointer *elements;
	  s7_Int *offsets, *dimensions;

	  elements = <em class=red>s7_vector_elements</em>(vector);
	  dimensions = <em class=red>s7_vector_dimensions</em>(vector);
	  offsets = <em class=red>s7_vector_offsets</em>(vector);

	  for (i = 0; i &lt; indices; i++)
	    {
	      int ind;
	      ind = va_arg(ap, int);
	      if ((ind &lt; 0) ||
		  (ind &gt;= dimensions[i]))
		{
		  va_end(ap);
		  return(s7_out_of_range_error(sc, 
                                               "multivector_ref", i, 
                                               s7_make_integer(sc, ind), 
                                               "index should be between 0 and the dimension size"));
		}
	      index += (ind * offsets[i]);
	    }
	  va_end(ap);
	  return(elements[index]);
	}
    }
  return(s7_wrong_number_of_args_error(sc, 
                                       "multivector_ref: wrong number of indices: ~A", 
                                       s7_make_integer(sc, indices)));
}

int main(int argc, char **argv)
{
  char buffer[512];
  char response[1024];
  s7_scheme *s7;

  s7 = s7_init(); 
  s7_eval_c_string(s7, "(define vect (make-vector '(2 3 4) 0))");
  s7_eval_c_string(s7, "(set! (vect 1 1 1) 32)");

  fprintf(stdout, "vect[0,0,0]: %s, vect[1,1,1]: %s\n",
	  s7_object_to_c_string(s7, <em class=red>multivector_ref</em>(s7, s7_name_to_value(s7, "vect"), 3, 0, 0, 0)),
	  s7_object_to_c_string(s7, <em class=red>multivector_ref</em>(s7, s7_name_to_value(s7, "vect"), 3, 1, 1, 1)));
}

/* vect[0,0,0]: 0, vect[1,1,1]: 32
 */
</pre>
</td></tr></table>



<br><br>
<A NAME="notify"></a>
<p>Notification from Scheme that a given scheme variable has been set.
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer my_exit(s7_scheme *sc, s7_pointer args) {exit(0);}

static s7_pointer scheme_set_notification(s7_scheme *sc, s7_pointer args)
{
  /* this function is called when the scheme variable is set! */
  fprintf(stderr, "%s set to %s\n",
	  s7_object_to_c_string(sc, s7_car(args)),
	  s7_object_to_c_string(sc, s7_car(s7_cdr(args))));
  return(s7_car(s7_cdr(args)));
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  s7 = s7_init();  
  s7_define_function(s7, "exit", my_exit, 0, 0, false, "(exit) exits the program");

  s7_define_function(s7, "notify-C", scheme_set_notification, 2, 0, false, "called if notified-var is set!");
  s7_define_variable(s7, "notified-var", s7_make_integer(s7, 0));
  <em class=red>s7_symbol_set_access</em>(s7,   /* set symbol-access of notified-var to (list #f notify-C #f) */
		       s7_make_symbol(s7, "notified-var"),
		       s7_cons(s7, 
			       s7_f(s7), 
			       s7_cons(s7, 
				       s7_name_to_value(s7, "notify-C"), 
				       s7_cons(s7, 
					       s7_f(s7),
					       s7_nil(s7)))));

  if (argc == 2)
    {
      fprintf(stderr, "load %s\n", argv[1]);
      s7_load(s7, argv[1]);
    }
  else
    {
      char buffer[512];
      char response[1024];
      while (1) 
	{
	  fprintf(stdout, "\n&gt; ");
	  fgets(buffer, 512, stdin);
	  
	  if ((buffer[0] != '\n') || 
	      (strlen(buffer) &gt; 1))
	    {                            
	      sprintf(response, "(write %s)", buffer);
	      s7_eval_c_string(s7, response);
	    }
	}
    }
}

/*    &gt; notified-var
 *    0
 *    &gt; (set! notified-var 32)
 *    notified-var set to 32
 *    32
 */
</pre>
</td></tr></table>


<br><br>
<A NAME="namespace"></a>
<p>Load C defined stuff into a separate namespace.
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer my_exit(s7_scheme *sc, s7_pointer args) {exit(0);}

static s7_pointer func1(s7_scheme *sc, s7_pointer args)
{
  return(s7_make_integer(sc, s7_integer(s7_car(args)) + 1));
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  s7_pointer new_env;

  s7 = s7_init();  
  s7_define_function(s7, "exit", my_exit, 0, 0, false, "(exit) exits the program");

  /* "func1" and "var1" will be placed in an anonymous environment,
   *   accessible from Scheme via the global variable "lib-exports"
   */
  
  new_env = <em class=red>s7_augment_environment</em>(s7, s7_cons(s7, s7_current_environment(s7), s7_nil(s7)), s7_nil(s7));
  /* make a private environment for func1 and var1 below (this is our "namespace") */
  s7_gc_protect(s7, new_env);

  s7_define(s7, <em class=red>new_env</em>, 
	    s7_make_symbol(s7, "func1"),
	    <em class=red>s7_make_function</em>(s7, "func1", func1, 1, 0, false, "func1 adds 1 to its argument"));
  
  s7_define(s7, <em class=red>new_env</em>, s7_make_symbol(s7, "var1"), s7_make_integer(s7, 32));
  /* those two symbols are now defined in the new environment */

  /* add "lib-exports" to the global environment */
  s7_define_variable(s7, "lib-exports", s7_car(new_env));

  if (argc == 2)
    {
      fprintf(stderr, "load %s\n", argv[1]);
      s7_load(s7, argv[1]);
    }
  else
    {
      char buffer[512];
      char response[1024];
      while (1) 
	{
	  fprintf(stdout, "\n&gt; ");
	  fgets(buffer, 512, stdin);
	  
	  if ((buffer[0] != '\n') || 
	      (strlen(buffer) &gt; 1))
	    {                            
	      sprintf(response, "(write %s)", buffer);
	      s7_eval_c_string(s7, response);
	    }
	}
    }
}

/*     &gt; func1
 *     ;func1: unbound variable, line 1
 *     &gt; lib-exports
 *     ((var1 . 32) (func1 . func1))
 *     ;; so lib-exports has the C-defined names and values
 *     ;; we can use these directly:
 *
 *     &gt; (define lib-env (apply <em class=red>augment-environment</em> (current-environment) lib-exports))
 *     lib-env
 *     &gt; (<em class=red>with-environment</em> lib-env (func1 var1))
 *     33
 *
 *     ;; or rename them to prepend "lib:"
 *     &gt; (define lib-env (apply augment-environment 
                                (current-environment) 
                                (map (lambda (binding) 
                                       (cons (string-&gt;symbol 
                                               (string-append "lib:" (symbol-&gt;string (car binding)))) 
                                             (cdr binding))) 
                                     lib-exports)))
 *     lib-env
 *     &gt; (with-environment lib-env (lib:func1 lib:var1))
 *     33
 *
 *     ;;; now for convenience, place "func1" in the global environment under the name "func2"
 *     &gt; (define func2 (cdadr lib-exports)) 
 *     func2
 *     &gt; (func2 1)  
 *     2
 */
</pre>
</td></tr></table>



<br><br>

<A NAME="Cerrors"></a>
<p>Handle scheme errors in C.
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer my_exit(s7_scheme *sc, s7_pointer args) {exit(0);}

static s7_pointer error_handler(s7_scheme *sc, s7_pointer args)
{
  /* put &lt;&lt;&gt;&gt; around the string so it's obvious who is producing what */

  fprintf(stdout, "&lt;&lt;%s&gt;&gt;", s7_string(s7_car(args)));
  return(s7_make_symbol(sc, "our-error"));
}


int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];
  bool with_error_hook = false;

  s7 = s7_init();  
  s7_define_function(s7, "exit", my_exit, 0, 0, false, "(exit) exits the program");
  s7_define_function(s7, "error-handler", error_handler, 1, 0, false, "our error handler");

  if (with_error_hook)
    s7_eval_c_string(s7, "(set! *error-hook*                               \n\
                            (lambda (tag args)                             \n\
                              (error-handler                               \n\
                                (apply format #f (car args) (cdr args)))))");

  while (1) 
    {
      fprintf(stdout, "\n&gt; ");
      fgets(buffer, 512, stdin);
	  
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  s7_pointer old_port, result;
	  int gc_loc = -1;
	  const char *errmsg = NULL;

	  /* trap error messages */
	  old_port = s7_set_current_error_port(s7, s7_open_output_string(s7));
	  if (old_port != s7_nil(s7))
	    gc_loc = s7_gc_protect(s7, old_port);

	  /* evaluate the input string */
	  result = s7_eval_c_string(s7, buffer);

	  /* print out the value wrapped in "{}" so we can tell it from other IO paths */
	  fprintf(stdout, "{%s}", s7_object_to_c_string(s7, result));

	  /* look for error messages */
	  errmsg = s7_get_output_string(s7, s7_current_error_port(s7));

	  /* if we got something, wrap it in "[]" */
	  if ((errmsg) && (*errmsg))
	    fprintf(stdout, "[%s]", errmsg); 

	  s7_close_output_port(s7, s7_current_error_port(s7));
	  s7_set_current_error_port(s7, old_port);
	  if (gc_loc != -1)
	    s7_gc_unprotect_at(s7, gc_loc);
	}
    }
}

/* 
 *   gcc -c s7.c -I. -g3
 *   gcc -o ex3 ex3.c s7.o -lm -I.
 *
 * if with_error_hook is false,
 *
 *   &gt; (+ 1 2)
 *   {3}
 *   &gt; (+ 1 #\c)
 *   {wrong-type-arg}[
 *   ;+ argument 2, #\c, is character but should be a number, line 1
 *   ]
 *
 * so s7 by default prepends ";" to the error message, and appends "\n",
 *   sending that to current-error-port, and the error type ('wrong-type-arg here)
 *   is returned.
 *
 * if with_error_hook is true,
 *
 *   &gt; (+ 1 2)
 *   {3}
 *   &gt; (+ 1 #\c)
 *   &lt;&lt;+ argument 2, #\c, is character but should be a number&gt;&gt;{our-error}
 *
 * so now the *error-hook* code handles both the error reporting and
 *   the value returned ('our-error in this case).
 */
</pre>
</td></tr></table>

<br><br>

<A NAME="closure"></a>
<p>We often have hooks or callback lists in Scheme, and would like to place a C-defined
s7 function on such a list.  If the C-side function does not have
any state, we can just add its name to the list, but if it is effectively a closure, we have a problem.  C itself does not
provide closures, so the standard two-step is to include a void* pointer with the
C function in a struct, then when that is called, pass the pointer to the function
by hand.  This obviously does not work if we want that function to be a member of
a normal Scheme list of functions.  So in the next example, we define a closure
in C using s7_make_closure.  
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer closure_func(s7_scheme *sc, s7_pointer args)
{
  /* closure_func is the function portion of our closure.  It assumes its
   *   environment has an integer named "x".  The function also takes one argument,
   *   an integer we'll call it "y".
   */
  return(s7_make_integer(sc,                            /* return (+ y x) */
                         s7_integer(s7_car(args)) +     /*   this is y */
                         s7_integer(s7_name_to_value(sc, "x"))));
}

static s7_pointer define_closure(s7_scheme *sc, const char *name, s7_pointer func, s7_pointer x_value)
{
  /* make_closure creates a new closure with x_value as the local value of x,
   *   and func as the function.  It defines this in Scheme as "name".  
   *
   *   s7_make_closure's arguments are the closure code as (&lt;args&gt; &lt;code&gt;), and
   *   the closure's environment.  For the first part, we'll use '((y) (f y)),
   *   and for the second, we'll augment the current environment with
   *   ((x . x_value) (f . func)).
   */
  s7_define(sc, 
	    s7_global_environment(sc),
	    s7_make_symbol(sc, name),
	    <em class=red>s7_make_closure</em>(sc, 
			    s7_cons(sc, 
				    s7_cons(sc,            /* closure arg list: '(y) */
				            s7_make_symbol(sc, "y"), 
                                            s7_nil(sc)), 
				    s7_cons(sc,            /* closure code: (f y) */
					    s7_cons(sc,                              
						    s7_make_symbol(sc, "f"),
						    s7_cons(sc, 
                                                            s7_make_symbol(sc, "y"), 
                                                            s7_nil(sc))),
					    s7_nil(sc))),
			    <em class=red>s7_augment_environment</em>(sc, 
						   s7_current_environment(sc), 
						   s7_cons(sc, 
							   s7_cons(sc,  /* the local binding for "x" */
                                                                   s7_make_symbol(sc, "x"), 
                                                                   <em class=red>x_value</em>), 
							   s7_cons(sc,  /*     and "f" */
								   s7_cons(sc, 
                                                                           s7_make_symbol(sc, "f"), 
                                                                           <em class=red>func</em>), 
								   s7_nil(sc))))));
  return(s7_unspecified(sc));
}

static s7_pointer my_exit(s7_scheme *sc, s7_pointer args) {exit(0);}

int main(int argc, char **argv)
{
  char buffer[512];
  char response[1024];
  s7_pointer c_func;
  s7_scheme *s7;

  s7 = s7_init();  
  s7_define_function(s7, "exit", my_exit, 0, 0, false, "(exit) exits the program");

  c_func = s7_make_function(s7, "#&lt;closure function&gt;", closure_func, 1, 0, false, "function used by define_closure");

  define_closure(s7, "closure-1", c_func, s7_make_integer(s7, 32));  /* (let ((x 32)) (lambda (y) (+ y x))) */
  define_closure(s7, "closure-2", c_func, s7_make_integer(s7, 123)); /* (let ((x 123)) (lambda (y) (+ y x))) */

  while (1) 
    {
      fprintf(stdout, "\n&gt; ");
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response);
	}
    }
}

/*
 *   &gt; (closure-1 3)
 *   35
 *   &gt; (closure-2 3)
 *   126
 *   &gt; (procedure-source closure-1)
 *   (lambda (y) (f y))
 *   &gt; (procedure-environment closure-1)
 *   (((f . #&lt;closure function&gt;) (x . 32)) #(() () () () () ((caar . caar)) () () ...))
 */
</pre>
</td></tr></table>
<br><br>

</body>
</html>
