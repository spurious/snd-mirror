<html>
<!-- documentation for s7 -->

<head>
<title>s7</title>
<style type="text/css">
<!-- 
	EM.red {color:red; font-style:normal}
        EM.error {color:chocolate; font-style:normal}
        EM.typing {color:maroon; font-style: normal}
        EM.listener {color:darkblue; font-style: normal}
	EM.emdef {font-weight: bold; font-style: normal}
	H1 {text-align: center}
	UL {list-style-type: none}

	A {text-decoration:none}
	A:hover {text-decoration:underline}
	A.quiet {color:black; text-decoration:none}
	A.quiet:hover {text-decoration:underline}
	A.def {font-weight: bold; font-style: normal; text-decoration:none; text-color:black}
-->

</style>
</head>
<body bgcolor=white>

<!-- INDEX s7doc:s7 scheme -->


<br>

<table border=0 bordercolor="lightgreen" width=100% cellpadding=2 cellspacing=0><tr><td bgcolor="lightgreen">
<A NAME="s7doc"></a>
<table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>s7</h2></td></tr></table>
</td></tr></table>


<p>s7 is a Scheme implementation intended as an extension language
for other applications, primarily Snd and Common Music.  It exists as just two files, s7.c and
s7.h, that want only to disappear into someone else's source tree.  There are no libraries,
no run-time init files, and no configuration scripts.
It can be built as a stand-alone
interpreter (see below).  s7test.scm is a regression test for s7.
If you're running s7 in a context
that has getenv, file-exists?, and system (Snd for example), you can use s7-slib-init.scm
to gain easy access to slib (this init file is named "s7.init" in the slib distribution).
A tarball is available: ftp://ccrma-ftp.stanford.edu/pub/Lisp/s7.tar.gz.
</p>
<p>
s7 is the default extension language of Snd and sndlib (http://ccrma.stanford.edu/software/snd/),
and Rick Taube's Common Music (commonmusic at sourceforge).  There are X, Motif, Gtk, and openGL bindings
in libxm (in the Snd tarball, or at ftp://ccrma-ftp.stanford.edu/pub/Lisp/libxm.tar.gz).
</p>

<p>s7 has full continuations, dynamic-wind, sort!, 
error handling, ratios and complex numbers,
define-macro, keywords, hash-tables, block comments,
threads, multiprecision arithmetic for all numeric types,
generalized set!, format, define*, and a host of other
extensions of r5rs.  It does not have syntax-rules or any of
its friends, and it does not think there is any such thing
as an "inexact integer" (what were those guys smoking?).
</p>

<p>This file assumes you know about Scheme and all its problems,
and want a quick tour of where s7 is different.
</p>

<ul>
  <li><a href="#multiprecision">multiprecision arithmetic</a>
  <li><a href="#math">math functions</a>
  <li><a href="#define*">define*</a>
  <li><a href="#macros">define-macro</a>
  <li><a href="#constants">define-constant, symbol-access</a>
  <li><a href="#maketype">make-type</a>
  <li><a href="#pws">procedure-with-setter</a>
  <li><a href="#generalizedset">generalized set!</a>
  <li><a href="#multidimensionalvectors">multidimensional vectors</a>
  <li><a href="#hashtables">hash tables</a>
  <li><a href="#multithreading">multithreading</a>
  <li><a href="#multiplevalues">multiple-values</a>
  <li><a href="#callwithexit">call-with-exit</a>
  <li><a href="#format">format</a>
  <li><a href="#errors">errors, stacktrace</a>
  <li><a href="#trace">trace</a>
  <li><a href="#IO">string IO</a>
  <li><a href="#procedureinfo">procedure info</a>
  <li><a href="#symbolinfo">symbol table info</a>
  <li><a href="#environments">environments</a>
  <li><a href="#evalstring">eval</a>
  <li><a href="#miscellanea">miscellanea</a>
  <li><a href="#s7rundoc">the run macro</a>
  <li><a href="#FFIexamples">FFI examples</a>
</ul>

<br>
<dl>

<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="multiprecision"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>multiprecision arithmetic</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>All numeric types (integers, ratios, reals, complex numbers) are supported.
The basic integer and real
types are defined in s7.h, defaulting to long long int and double.  
pi is predefined, as are
most-positive-fixnum and most-negative-fixnum.
s7 can be built with multiprecision support 
for all types,  using the gmp, mpfr, and mpc libraries (set WITH_GMP to 1 in s7.c).  
If multiprecision arithmetic is
enabled, the following functions are included: bignum, bignum?, and bignum-precision.
bignum-precision, which defaults to 128, sets the number of bits each float takes.
pi automatically reflects the current bignum-precision:
</p>
<pre>
&gt; pi
3.141592653589793238462643383279502884195E0

&gt; (bignum-precision)
128

&gt; (set! (bignum-precision) 256)
256

&gt; pi
3.141592653589793238462643383279502884197169399375105820974944592307816406286198E0
</pre>
<p>
bignum? returns #t if its argument is a big number of some type (that is, I use "bignum" 
for any big number, not just integers).  To create a big number,
either include enough digits to overflow the default types, or use the bignum function.
Its argument is a string representing the desired number:
</p>
<pre>
&gt; (bignum "123456789123456789")
123456789123456789

&gt; (bignum "1.123123123123123123123123123")
1.12312312312312312312312312300000000009E0
</pre>

</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="math"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>math functions</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>
s7 includes:
</p>
<ul>
<li>sinh, cosh, tanh, asinh, acosh, atanh
<li>logior, logxor, logand, lognot, ash, integer-length
<li>random
<li>nan?, infinite?
</ul>
<p>
The random function can take any numeric argument, including 0.
The following constants are predefined: pi, most-positive-fixnum, most-negative-fixnum.
Other math-related differences between s7 and r5rs:
</p>
<ul>
<li>rational? and exact mean integer or ratio (i.e. not floating point), inexact means not exact.
<li>floor, ceiling, truncate, and round return (exact) integer results.
<li>"#" does not stand for an unknown digit.
<li>the "@" complex number notation is not supported.
<li>"+i" is not considered a number; include the real part.
<li>modulo, remainder, and quotient take integer, ratio, or real arguments.
<li>lcm and gcd can take integer or ratio arguments.
<li>log takes an optional 2nd arg (the base).
<li>'.' and an exponent can occur in a number in any base.
<li>rationalize returns a ratio! 
</ul>
<pre>
&gt; (exact? 1.0)
#f

&gt; (floor 1.4)
1

&gt; (rational? 1.5)
#f

&gt; (modulo 1.4 1.0)
0.4

&gt; (lcm 3/4 1/6)
3/2

&gt; (log 8 2)
3

&gt; (number-&gt;string 0.5 2)
"0.1"

&gt; (string-&gt;number "0.1" 2)
0.5

&gt; (rationalize 1.5)
3/2
</pre>

<small>
<blockquote>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

The exponent itself is always in base 10 (this follows gmp usage).
Since Scheme uses "@" for its useless polar notation, s7 doesn't use it for the exponent marker, but that
means (string-&gt;number "1e1", 16) is ambiguous &mdash; is the "e" a digit or an exponent marker?
s7 could perhaps substitute "s" in this case, but instead it just prohibits exponents if the
radix is greater than 10.
<pre>
&gt; (string-&gt;number "1e9" 2)  ; (expt 2 9)
512.0
&gt; (string-&gt;number "1e1" 12) ; "e" is not a digit in base 12
#f
&gt; (string-&gt;number "1e1" 16) ; (+ (* 1 16 16) (* 14 16) 1)
481
&gt; (string-&gt;number "1.2e1" 3); (* 3 (+ 1 2/3))
5.0
</pre>
<p>Perhaps s7 should use "@"!
</p>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>
"rational" in s7 does not mean "could possibly be
expressed equally well as a ratio (floats are approximations!)", but "is actually expressed as a ratio (or an integer of course)";
otherwise "rational?" is the same as "real?":
</p>
<pre>
(not-s7-scheme)&gt; (rational? (sqrt 2))
#t
</pre>
<!--
<p>Or even worse, <code>(rational? 0.1)</code> returns #t!  How can that be justified?
Currently in s7 inexact-&gt;exact is a synonym for rationalize, exact? is the same as rational?, and
inexact? means not exact, so the only useful portion of the exact number business is exact-&gt;inexact,
but surely a better name would be "float" or maybe "-&gt;float"?
</p>
<p>Ideally perhaps, 
"exact" would mean "is represented exactly in the computer".  We'd have integers and ratios exact; 
reals and complex exact if they are exactly
represented in the current floating point implementation.  So, 1+i is just as exact as 1 (but its polar representation 
involves sqrt(2) and pi/4 which are usually handled as floats);
0.0 and 0.5 might be exact if the printout isn't misleading, and 0.1 is inexact.
"integer?" and friends would refer instead to the programmer's point of view.
But then what would inexact-&gt;exact do?  C's nextafter is not what anyone expects.
And to keep exactness in view, we'd have
to monitor which operations introduce inexactness &mdash; a kind of interval arithmetic.
In other schemes, inexact means "has a dot, an exponent, or an imaginary part" which is silly.
Similarly "integer?" means "has zero fractional part", but that is useless in a case
like <code>(- 9007199254740993.0 9007199254740992.0)</code> which I bet is 0.0, even
though these things are called integers.  Or worse, you want a vector index, but
because integer? includes floats, you end
up putting ugly junk like <code>(inexact->exact (floor index))</code> everywhere, and
even then you worry that you're going to get some ridiculous fraction.
Since the exact/inexact distinction is an incoherent jumble that constantly gets in the way,
I think the best thing
would be to flush it entirely.
</p>
-->

</blockquote>
</small>
</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="define*"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>define*, lambda*</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>These are extensions of define and lambda that make it easier to
to deal with optional, keyword, and rest arguments.  
The syntax is very simple: every argument to define* has a default value
and is automatically available as a keyword argument.  The default value
is either #f (if unspecified), or given in a list whose first member is
the argument name.
The last argument
can be preceded by :rest or a dot to indicate that all other trailing arguments
should be packaged as a list under that argument's name.  A trailing or rest
argument's default value is '().
You can use
:optional and :key, but they are ignored.  
</p>
<pre>
(<em class=red>define*</em> (hi a (b 32) (c "hi")) (list a b c))
</pre>
<p>Here the argument "a" defaults to #f, "b" to 32, etc.
When the function is called, 
the argument names are bound to their default values, then the function's
current argument list is scanned.  Any name that occurs as a keyword (":a")
sets that argument's new value.  Otherwise, as values occur, they
are plugged into the actual argument list based on their position (counting a keyword/value pair as one argument).
This is called an optional-key list in CLM.  So, taking the function
above as an example:
</p>
<pre>
(hi 1) -&gt; '(1 32 "hi")
(hi :b 2 :a 3) -&gt; '(3 2 "hi")
(hi 3 2 1) -&gt; '(3 2 1)
</pre>
<p>See s7test.scm for many examples.
</p>
<pre>
(<em class=red>define*</em> (make-parameter initial-value converter)
  (let* ((unspecified (if #f #f))   ; #&lt;unspecified&gt;
	 (value (if (procedure? converter) (converter initial-value) initial-value)))
    (<em class=red>lambda*</em> ((val unspecified))
      (if (not (eq? val unspecified))
	  (set! value (if (procedure? converter) (converter val) val)))
      value)))

&gt; (define hiho (make-parameter 12))
hiho
&gt; (hiho)
12
&gt; (hiho 32)
32
&gt; (hiho)
32
</pre>

<small>
<blockquote>
<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>If you want a version of define* that insists
that any arguments before the keyword :optional are required:
</p>

<pre>
(define-macro (define** declarations . forms)
  (let ((name (car declarations))
	(args (cdr declarations)))
    (define (position thing lst count)
      (if (or (null? lst)
	      (not (pair? (cdr lst)))) ; for dotted arg = "rest" arg
	  #f
	  (if (eq? thing (car lst))
	      count
	      (position thing (cdr lst) (+ count 1)))))
    (let ((required-args (position :optional args 0)))
      (if required-args
	  `(define* (,name . func-args)
	     (if (&lt; (length func-args) ,required-args)
		 (error "~A requires ~D argument~A: ~A" 
			',name ,required-args 
                        (if (&gt; ,required-args 1) "s" "") 
                        func-args)
		 (apply (lambda* ,args ,@forms) func-args)))
	  `(define* ,declarations ,@forms)))))

&gt; (define** (hi a :optional (b 23)) (list a b))
hi
&gt; (hi 1)
(1 23)
&gt; (hi)
;hi requires 1 argument: ()
</pre>
<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>If a define* argument's default value is an expression, it is evaluated in the definition environment at
the time of the procedure call:
</p>
<pre>
(let ((c 1))
  (define* (a (b (+ c 1))) b)
  (set! c 2)
  (let ((c 123))
    (a))) ; (+ c 1) here is (+ 2 1) so this returns 3
</pre>
<p>Since the expression is not evaluated until the procedure is called, it is ok
to use variables that are undefined at the definition point:
</p>
<pre>
&gt; (define* (a (b c)) b)
a
&gt; c
;c: unbound variable
&gt; (define c 123)
c
&gt; (a)
123
</pre>
<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Another variant of define creates "curried" functions:
</p>
<pre>
(define-macro (define-curried name-and-args . body)	
  `(define ,@(let ((newlst `(begin ,@body)))
	       (define (rewrap lst)
		 (if (pair? (car lst))
		     (begin
		       (set! newlst (cons 'lambda (cons (cdr lst) (list newlst))))
		       (rewrap (car lst)))
		     (list (car lst) (list 'lambda (cdr lst) newlst))))
	       (rewrap name-and-args))))

&gt; (define-curried ((f a) b) (+ a b))
f
&gt; ((f 1) 2)
3
&gt; (define-curried (((((f a b) c) d e) f) g) (* a b c d e f g))
f
&gt; (((((f 1 2) 3) 4 5) 6) 7)
5040
</pre>
<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>


<p>To try to catch what I believe are usually mistakes, I added two
error checks.  One is triggered if you set the same parameter twice
in the same call, and the other if an unknown keyword is encountered
in the key position.  These problems arise in a case such as
</p>
<pre>
(define* (f (a 1) (b 2)) (list a b))
</pre>
<p>You could do any of the following by accident:
</p>
<pre>
(f 1 :a 2)  ; what is a?
(f :b 1 2)  ; what is b?
(f :c 3)    ; did you really want a to be :c and b to be 3?
</pre>
<p>In the last case, to pass a keyword deliberately, either include the
argument keyword: <code>(f :a :c)</code>, or make the default value a keyword:
<code>(define* (f (a :c) ...))</code>.
</p>

<!--
(define* (f a b . c) (list a b c))
(f 1 2 :d 4)
(1 2 (:d 4))
(f :d 1)
;f: unknown key: (:d 1) in (:d 1)
-->

</blockquote>
</small>

</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="macros"></a>
<table border=0 bordercolor="lightgreen" width=80% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>macros</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>define-macro, define-macro*, defmacro, defmacro*, macroexpand, gensym, and macro?
implement the standard (CL-style) macro definers.  
</p>

<pre>
(define-macro (add-1 arg) `(+ 1 ,arg))
(defmacro add-1 (arg) `(+ 1 ,arg))
</pre>
<p>macroexpand can help debug a macro:
</p>
<pre>
&gt; (define-macro (add-1 arg) `(+ 1 ,arg))
add-1
&gt; (macroexpand (add-1 32))
(+ 1 32)
</pre>
<p>gensym returns a symbol that is guaranteed to be currently unused.  It takes an optional string argument
giving the new symbol name's prefix.
</p>
<pre>
(defmacro pop! (sym)
  (let ((v (<em class=red>gensym</em>)))
    `(let ((,v (car ,sym)))
       (set! ,sym (cdr ,sym))
       ,v)))
</pre>
<p>As in define*, the starred forms give optional and keyword arguments:
</p>
<pre>
&gt; (define-macro* (add-2 a (b 2)) `(+ ,a ,b))
add-2
&gt; (add-2 1 3)
4
&gt; (add-2 1)
3
&gt; (add-2 :b 3 :a 1)
4
</pre>

<p>See s7test.scm for many examples including such perennial favorites as
when, loop, dotimes, do*, enum, pushnew, and defstruct.
</p>

<p>macro? returns #t if its argument is a macro or a symbol whose value is a macro.
We can use it, and other macro-related stuff to make a version of macroexpand-all:
</p>
<pre>
(define-macro (fully-expand form)
  (define (expand form)
    (if (pair? form)
	(if (<em class=red>macro?</em> (car form))
	    (expand ((eval (procedure-source (car form))) form))
	    (cons (expand (car form))
		  (expand (cdr form))))
	form))
  (expand form))


&gt; (define-macro (hi a) `(+ 1 ,a))
hi
&gt; (define-macro (ha c) `(hi (+ ,c 1)))
ha
&gt; (fully-expand (define (ho b) (+ 1 (ha b))))
ho
&gt; (procedure-source ho)
(lambda (b) (+ 1 (+ 1 (+ b 1))))
</pre>

<p>fully-expand expands each macro it encounters by using the
procedure-source of that macro, that is, the function that the macro definition
expanded into:
</p>
<pre>
(define-macro (hi a) `(+ ,a 1))

&gt; (procedure-source hi)
(lambda (defmac-13) (apply (lambda (a) (cons (quote +) (cons a (cons 1 (quote ()))))) (cdr defmac-13)))
</pre>

<small>
<blockquote>
<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>I hesitate to mention this, but macros are "first-class" entities in s7.  You can
pass one as a function argument, apply it to a list, return it from a function,
and assign it to a variable:
</p>
<pre>
&gt; (define-macro (hi a) `(+ ,a 1))
hi
&gt; (apply hi '((dummy-name 4)))
(+ 4 1)
&gt; (define (fmac mac) (apply mac '((xxx 4))))
fmac
&gt; (fmac hi)
(+ 4 1)
&gt; (define (fmac mac) (mac 4))
fmac
&gt; (fmac hi)
5
&gt; (define (make-mac)
    (define-macro (hi a) `(+ ,a 1))
    hi)
make-mac
&gt; (let ((x (make-mac)))
    (x 2))
3
</pre>
<p>The presence of the dummy name in the applied macro's arguments is an historical accident;
it could be removed.
</p>
<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>



<p>s7 macros are not "hygenic".  For example,
</p>
<pre>
  (define-macro (mac b) 
    `(let ((a 12)) 
       (+ a ,b)))

  (let ((a 1) 
        (+ *))
    (mac a))
</pre>
<p>returns 144 because "+" has turned into "*", and "a" is the internal "a",
not the argument "a".  We get (* 12 12) where we probably expected (+ 12 1).
It is possible to use gensym to clean this up, but that makes the macro 
unreadable in all but the simplest cases, and besides, gensymification is
something a macro can do for us:
</p>
<pre>
(define-macro (define-clean-macro name-and-args . body)
  (let ((syms ()))

    (define (walk func lst)
      (if (and (func lst)
	       (pair? lst))
	  (begin
	    (walk func (car lst))
	    (walk func (cdr lst)))))

    (define (car-member sym lst)
      (if (null? lst)
	  #f
	  (if (eq? sym (caar lst))
	      (cdar lst)
	      (car-member sym (cdr lst)))))

    (define (walker val)
      (if (pair? val)
	  (if (eq? (car val) 'quote)
	      (or (car-member (cadr val) syms)
		  (and (pair? (cadr val))
		       (or (and (eq? (caadr val) 'quote) ; 'sym -&gt; (quote (quote sym))
				val)
			   (append (list 'list) 
				   (walker (cadr val)))))
		  (cadr val))
	      (cons (walker (car val))
		    (walker (cdr val))))
	  (or (car-member val syms)
	      val)))

    (walk (lambda (val)
	    (if (and (pair? val)
		     (eq? (car val) 'quote)
		     (symbol? (cadr val))
		     (not (car-member (cadr val) syms)))
		(set! syms (cons 
			    (cons (cadr val) 
				  (gensym (symbol-&gt;string (cadr val))))
			    syms)))
	    (or (not (pair? val))
		(not (eq? (car val) 'quote))
		(not (pair? (cadr val)))
		(not (eq? (caadr val) 'quote))))
	  body)

    (let* ((new-body (walker body))
	   (new-syms (map (lambda (slot)
			    (list (cdr slot) `(gensym)))
			  syms))
	   (new-globals 
	    (let ((result '()))
	      (for-each
	       (lambda (slot)
		 (if (defined? (car slot))
		     (set! result (cons
				   (list 'set! (cdr slot) (car slot))
				   result))))
	       syms)
	      result)))

      `(define-macro ,name-and-args 
	 (let ,new-syms
	   ,@new-globals
	   `(begin ,,@new-body))))))
</pre>
<p>Now we can automatically generate hygenic macros:
</p>
<pre>
  (define-clean-macro (mac b) 
    `(let ((a 12)) 
       (+ a ,b)))

  (let ((a 1) 
        (+ *))
    (mac a))
</pre>
<p>which returns 13 as expected.
If you just want to make sure your macro arguments don't get captured
(how often does anyone actually redefine "+"?),
use lambda:
</p>
<pre>
(define-macro (mac a)
  `((lambda (b) 
      (let ((a 12))
	(+ a b)))
    ,a))
</pre>

</blockquote>
</small>

</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="constants"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>define-constant, constant?, symbol-access</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>define-constant defines a constant and constant? returns #t if its argument
is a constant.  A constant in s7 is really constant: it can't be set or rebound.
</p>
<pre>
&gt; (define-constant var 32)
var

&gt; (set! var 1)
;set!: can't alter immutable object: var

&gt; (let ((var 1)) var)
;can't bind or set an immutable object: var, line 1
</pre>
<p>This has the possibly surprising side effect that previous uses of the constant name
become constants:
</p>
<pre>
 (define (func a) (let ((cvar (+ a 1))) cvar))
 (define-constant cvar 23)
 (func 1)
 ;can't bind or set an immutable object: cvar
</pre>
<p>So, obviously, choose unique names for your constants, or don't use define-constant.
A function can also be a constant (define-constant is an extension of define).
</p>

<p>Constants are very similar to things such as keywords (no set, always return itself as its value),
variable trace (informative function upon set or keeping a history of past values), typed variables (restricting a
variable's values or doing automatic conversions upon set), and notification upon set (either in Scheme
or in C; I wanted this many years ago in Snd).  The notification function is especially useful if
you have a Scheme variable and want to reflect any change in its value immediately in C (see example <a href="#notify">below</a>).
All of these cases modify
the path between a symbol and its value.  
s7 gives you a handle on that path via the procedure-with-setter <b>symbol-access</b>.
(symbol-access symbol) returns that symbol's accessors (if any), and (set! (symbol-access symbol) accessor-list)
changes it.  The accessor-list is a list of three functions, the get, set, and bind functions.
The set and bind functions take two arguments, the symbol in question
and the value that it is about to be set or bound to.  The variable is set or bound to the value they return.
We could replace define-constant, and add
local constants with:
</p>
<pre>
(define constant-access 
  (list #f
	(lambda (symbol new-value) 
	  (error "can't change constant ~A's value to ~A" symbol new-value))
	(lambda (symbol new-value) 
	  (error "can't bind constant ~A to a new value, ~A" symbol new-value))))

(define-macro (define-constant symbol value)
  `(begin
     (define ,symbol ,value)
     (set! (<em class=red>symbol-access</em> ',symbol) constant-access)
     ',symbol))

(define-macro (let-constant vars . body)
  (let ((varlist (map car vars)))
    `(let ,vars
       ,@(map (lambda (var)
		`(set! (<em class=red>symbol-access</em> ',var) constant-access))
	      varlist)
       ,@body)))
</pre>

<p>In the next example, we restrict the values a variable can take to integers:
</p>

<pre>
(define-macro (define-integer var value)
  `(begin
     (define ,var ,value)
     (set! (<em class=red>symbol-access</em> ',var) 
	   (list #f
		 (lambda (symbol new-value)
		   (if (real? new-value)
		       (floor new-value) ; or min/max to restrict it to some range etc
		       (error "~A can only take an integer value, not ~S" symbol new-value)))
		 #f))
     ',var))

&gt; (define-integer int 123)
int
&gt; (set! int 321.67)
321
&gt; (set! int (list 1 2))
;int can only take an integer value, not (1 2)
</pre>

<p>Here are trace and untrace.  We save the previous accessors in trace, restore them upon untrace,
and in between, call the previous set accessor, if any, after reporting the set:
</p>
<pre>
(define (trace var)
  (let* ((cur-access (<em class=red>symbol-access</em> var))
	 (cur-set (and cur-access (cadr cur-access))))
    (set! (<em class=red>symbol-access</em> var)
	  (list (and cur-access (car cur-access))
		(lambda (symbol new-value) 
		  (format #t "~A set to ~A~%" symbol new-value) 
		  (if cur-set 
		      (cur-set symbol new-value)
		      new-value))
		(and cur-access (caddr cur-access))
		cur-access)))) ; save the old version 

(define (untrace var)
  (if (and (symbol-access var)
	   (cdddr (symbol-access var)))
      (set! (symbol-access var) (cadddr (symbol-access var)))))
</pre>

<p>The "get" function is currently not implemented.
I believe symbol-access is similar to Ruby's hooked variables, or perhaps Perl's tied variables.
You could implement all kinds of fancy things
with this mechanism.  (One amusing case: property lists.  Just tack
the properties onto the end of the accessor list, as in trace above).
</p>

<small>
<blockquote>
<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>We can use symbol-access to fix fluid-let.  The usual form of
that macro claims that it implements dynamic scope, but it doesn't:
</p>
<pre>
(let ((x 32)
      (y 0))
  (define (gx) x)
  (let ((x 100))
    (fluid-let ((x 12))
      (set! y (gx))))
  (list x y))
</pre>
<p>which returns '(32 32) whereas the correct value is '(32 12).  To fix it,
we block let-binding and add let-global:
</p>
<pre>
(define-macro (define-global variable value)
  `(begin
     (define ,variable ,value)
     (set! (symbol-access ',variable) 
           (list #f #f (lambda (symbol new-value) 
                         (error "use let-global to bind a global variable"))))))

(define-macro (let-global xexe . body)
  ;; all xexe vars are assumed to be global variables
  ;;    this is fluid-let, taken with changes from Teach Yourself Scheme
  (let ((xx (map car xexe))
	(ee (map cadr xexe))
	(old-xx (map (lambda (ig) 
                       (gensym))
                     xexe)))
    `(let ,(map (lambda (old-x x) 
                  `(,old-x ,x)) 
		old-xx xx)
       (dynamic-wind
	   (lambda () #f)
	   (lambda ()
	     ,@(map (lambda (x e)
		      `(set! ,x ,e)) 
		    xx ee)
	     (let ()
	       ,@body))
	   (lambda ()
	     ,@(map (lambda (x old-x)
		      `(set! ,x ,old-x)) 
		    xx old-xx))))))

(let ()
  (define-global x 32)
  (let ((y 0))
    (define (gx) x)
    (let-global ((x 100))
      (let-global ((x 12))
	(set! y (gx))))
    (list x y)))
</pre>
<p>which returns '(32 12).
</p>

</blockquote>
</small>
</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="maketype"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>make-type</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>
<b>make-type</b> (borrowed from Alaric Snell-Pym)
returns a type-object: a list of three functions
'?, 'make, and 'ref.  The <b>?</b> func returns #t if its argument
is of the new type, the <b>make</b> function returns a new object of the new type with the
value of the argument to the make function, and the <b>ref</b> function returns that value
when passed that object. 
</p>

<A NAME="recordexample"></a>
<pre>
(define special-value ((cadr (<em class=red>make-type</em>)) 'special))
;; now special-value's value can't be eq? to any other scheme object

;; expand, for example, (define-record rec (a 1) (b 2))
(begin
  (define rec? #f)
  (define make-rec #f)
  (define rec-a #f)
  (define rec-b #f)

  (let* ((rec-type (<em class=red>make-type</em>))
	 (? (car rec-type))
	 (make (cadr rec-type))
	 (ref (caddr rec-type)))

    (set! make-rec (lambda* ((a 1) (b 2))
		     (make (vector a b))))

    (set! rec? ?)
  
    (set! rec-a (make-procedure-with-setter
		 (lambda (obj)
		   (and (rec? obj)
			(vector-ref (ref obj) 0)))
		 (lambda (obj val)
		   (if (rec? obj)
		       (vector-set! (ref obj) 0 val)))))

    (set! rec-b (make-procedure-with-setter
		 (lambda (obj)
		   (and (rec? obj)
			(vector-ref (ref obj) 1)))
		 (lambda (obj val)
		   (if (rec? obj)
		       (vector-set! (ref obj) 1 val)))))))

#|
(let ((hi (make-rec 32 '(1 2))))
  (set! (rec-b hi) 123)
  (format #t "rec: ~A ~A" 
	  (rec-a hi)
	  (rec-b hi)))

"rec: 32 123"
|#
</pre>

<p>Currently make-type takes some optional arguments to specify other actions.  
I might change this to be an alist of (operation function) pairs, but for now,
the optional (optkey) arguments are: print equal getter setter length name copy fill.
Except for the 'name' argument, these are functions.
When these functions are called, the argument representing the object is
the value of the object, not the object itself (see the examples below).
If no print function is specified, the 'name' argument is used when the
object is displayed.
The 'equal' function checks two objects of the new type for equality.
The 'getter' function applies the object to whatever arguments are
passed, and the 'setter' function does the same in the context of set!.
The 'length' function returns the length of the object's value.
The 'copy function returns a new object of the same type with the copy
function applied to the old object's value.
The 'fill' function takes two arguments, the object and what to
fill its value with.
So, remembering that (cadr type) is the make function:
</p>
<pre>
&gt; ((cadr (make-type)) 3.14)
#&lt;anonymous-type 3.14&gt;

&gt; ((cadr (make-type :name "hiho")) 123)
#&lt;hiho 123&gt;

&gt; ((cadr (make-type :print (lambda (a) (format #f "#&lt;typo: |~A|&gt;" a)))) 1)
#&lt;typo: |1|&gt;

&gt; (((cadr (make-type :getter (lambda (a b) (vector-ref a b)))) (vector 1 2 3)) 1)
2
</pre>
<p>The last is easier to read if we separate out the steps:
</p>
<pre>
&gt; (let* ((type (make-type 
                 :getter (lambda (a b) 
                           (vector-ref a b))))   ; make a new type with its own getter function
         (object ((cadr type) (vector 1 2 3))))  ; create an object of the new type, its value is a vector
       (object 1))                               ; "apply" the object to 1 =&gt; (vector-ref object 1) via the getter
2
</pre>

<p>The objects created in this way, or via s7_new_type in C, can be passed to for-each
if you supply the length and getter functions to make-type.
</p>

<small>
<blockquote>
<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Here is define-record using make-type.  It has a few Common Lisp extensions:
</p>
<pre>
(define-macro (define-record struct-name . fields)
  (let* ((name (if (list? struct-name) (car struct-name) struct-name))
	 (sname (if (string? name) name (symbol-&gt;string name)))
		 
	 (fsname (if (list? struct-name)
		     (let ((cname (assoc :conc-name (cdr struct-name))))
		       (if cname 
			   (symbol-&gt;string (cadr cname))
			   sname))
		     sname))
		 
	 (make-name (if (list? struct-name)
			(let ((cname (assoc :constructor (cdr struct-name))))
			  (if cname 
			      (cadr cname)
			      (string-&gt;symbol (string-append "make-" sname))))
			(string-&gt;symbol (string-append "make-" sname))))

	 (is-name (string-&gt;symbol (string-append sname "?")))
		 
	 (copy-name (if (list? struct-name)
			(let ((cname (assoc :copier (cdr struct-name))))
			  (if cname 
			      (cadr cname)
			      (string-&gt;symbol (string-append "copy-" sname))))
			(string-&gt;symbol (string-append "copy-" sname))))
		 
	 (field-names (map (lambda (n)
			     (symbol-&gt;string (if (list? n) (car n) n)))
			   fields))
		 
	 (field-types (map (lambda (field)
			     (if (list? field)
				 (apply (lambda* (val type read-only) type) (cdr field))
				 #f))
			   fields))
		 
	 (field-read-onlys (map (lambda (field)
				  (if (list? field)
				      (apply (lambda* (val type read-only) read-only) (cdr field))
				      #f))
				fields)))
    `(begin

       ;; declare our globally-accessible names
       (define ,is-name #f)
       (define ,make-name #f)
       (define ,copy-name #f)

       ,@(map (lambda (n)
		`(define ,(string-&gt;symbol (string-append fsname "-" n)) #f))
	      field-names)

       (let* ((rec-type (<em class=red>make-type</em>))
	      (? (car rec-type))
	      (make (cadr rec-type))
	      (ref (caddr rec-type)))
	       
	 (set! ,is-name ?)

	 (set! ,make-name (lambda* ,(map (lambda (n)
					    (if (and (list? n)
						     (&gt;= (length n) 2))
						(list (car n) (cadr n))
						(list n #f)))
					  fields)
			    (make (vector ',(string-&gt;symbol sname) ,@(map string-&gt;symbol field-names)))))

	 (set! ,copy-name (lambda (obj) 
			    (make (copy (ref obj)))))	       

	 ,@(map (let ((ctr 1))
		  (lambda (n type read-only)
		    (let ((val (if read-only
				   `(set! ,(string-&gt;symbol (string-append fsname "-" n))
					  (lambda (arg) ((ref arg) ,ctr)))
				   `(set! ,(string-&gt;symbol (string-append fsname "-" n))
					  (make-procedure-with-setter 
					   (lambda (arg) ((ref arg) ,ctr)) 
					   (lambda (arg val) (set! ((ref arg) ,ctr) val)))))))
		      (set! ctr (+ 1 ctr))
		      val)))
		field-names field-types field-read-onlys)

	',struct-name))))

&gt; (define-record point (x 0.0) (y 0.0))
point
&gt; (let ((pt (make-point 1.0))) 
    (set! (point-y pt) 3.0)
    (list (point? pt) (point-x pt) (point-y pt)))
(#t 1.0 3.0)
</pre>	
<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>In the next example, we define a float-vector type:
</p>
<pre>
(begin
  (define make-float-vector #f)
  (define float-vector? #f)
  (define float-vector #f)

  (let* ((fv-type (<em class=red>make-type</em>
		   :getter vector-ref :length length :copy copy :fill fill!
		   :setter (lambda (obj index value)
			     (if (not (real? value))
				 (error 'wrong-type-arg-error "float-vector element must be real: ~S" value))
			     (vector-set! obj index (exact-&gt;inexact value)))
		   :name "float-vector"))
	 (fv? (car fv-type))
	 (make-fv (cadr fv-type))
	 (fv-ref (caddr fv-type)))

    (set! make-float-vector 
      (lambda* (len (initial-element 0.0))
        (if (not (real? initial-element))
	    (error 'wrong-type-arg-error "make-float-vector initial element must be real: ~S" initial-element))
	(make-fv (make-vector len (exact-&gt;inexact initial-element)))))
    
    (set! float-vector? fv?)
    
    (set! float-vector
      (lambda args
	(let* ((len (length args))
	       (fv (make-float-vector len))
	       (v (fv-ref fv)))
	  (do ((lst args (cdr lst)))
	       (i 0 (+ i 1)))
	      ((null? lst) fv)
	    (let ((arg (car lst)))
	      (if (not (real? arg))
		  (error 'wrong-type-arg-error "float-vector element must be real: ~S in ~S" arg args))
	      (set! (v i) (exact-&gt;inexact arg))))))))

&gt; (let ((v (make-float-vector 3))) (set! (v 1) 32) v)
#&lt;float-vector #(0.0 32.0 0.0)&gt;

&gt; (let ((v (make-float-vector 3))) (set! (v 1) "hi") v)
;float-vector element must be real: "hi"

&gt; (map + (list 1 2 3) (float-vector 1 2 3)) ; we have a getter and length, so map and for-each will work
(2.0 4.0 6.0)
</pre>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>I seem to be using the same construct over and over; a begin to hold the names defined in the outer
environment, a let to hold internal stuff, and set!s to give the names values.  It's a clumsy, but 
simple way for multiple functions to share a closure.
Maybe it rates a macro:
</p>
<pre>
(define-macro (blet* names bindings . body)
  `(begin
     ,@(map (lambda (name)
	      `(define ,name #f))
	    names)
     (let* ,bindings
	,@body)))

(blet* (make-adjustable-vector adjustable-vector? adjust-vector)

       ((av-type (<em class=red>make-type</em> :name "adjustable-vector"
			    :getter (lambda (obj index)
				      ((car obj) index))
			    :setter (lambda (obj index value)
				      (set! ((car obj) index) value))
		            :length (lambda (obj)
			              (vector-length (car obj)))
			    :print (lambda (obj)
				     (object-&gt;string (car obj)))))
	(av? (car av-type))
	(make-av (cadr av-type))
	(av-ref (caddr av-type)))

  (set! make-adjustable-vector (lambda args 
				 (make-av (list (apply make-vector args)))))
  (set! adjustable-vector? av?)
  (set! adjust-vector (lambda* (obj new-length initial-element)
		        (let* ((new-vector (make-vector new-length initial-element))
			       (copy-len (min new-length (length obj))))
			  (do ((i 0 (+ i 1)))
			      ((= i copy-len))
			    (set! (new-vector i) (obj i)))
			  (set! (car (av-ref obj)) new-vector)))))

&gt; (define v (make-adjustable-vector 3 #f))
v
&gt; v
#(#f #f #f)
&gt; (set! (v 1) 32.0)
32.0
&gt; v
#(#f 32.0 #f)
&gt; (adjust-vector v 10 #f)
#(#f 32.0 #f #f #f #f #f #f #f #f)
</pre>

</blockquote>
</small>

</dd>
<br><br>



<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="pws"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>procedure-with-setter</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>A procedure-with-setter consists of two functions, the "getter" and the "setter".
The getter is called when the object is encountered as a function, and the setter when
it is set:
</p>
<pre>
(define xx (let ((x 32))
             (<em class=red>make-procedure-with-setter</em>
               (lambda () x) 
               (lambda (val) (set! x val) x))))
(xx) -&gt; 32
(set! (xx) 1)
(xx) -&gt; 1
</pre>

<p>The setter's last argument is the value passed to set!.  That is, 
</p>
<pre>
(define v123 
  (let ((vect (vector 1 2 3)))
    (make-procedure-with-setter
      (lambda (index) 
        (vect index))
      (lambda (index value) 
        (set! (vect index) value)))))

&gt; (v123 2)
3
&gt; (set! (v123 2) 32)
32
&gt; (v123 2)
32
</pre>

<small>
<blockquote>
<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Here is a pretty example of make-procedure-with-setter:
</p>
<pre>
(define-macro (c?r path)
  ;; "path" is a list and "X" marks the spot in it that we are trying to access
  ;; (a (b ((c X)))) -- anything after the X is ignored, other symbols are just placeholders
  ;; c?r returns a procedure-with-setter that gets/sets X

  (define (X-marks-the-spot accessor tree)
    (if (pair? tree)
	(or (X-marks-the-spot (cons 'car accessor) (car tree))
	    (X-marks-the-spot (cons 'cdr accessor) (cdr tree)))
	(if (eq? tree 'X) accessor #f)))

  (let ((body 'lst))
    (for-each
     (lambda (f)
       (set! body (list f body)))
     (reverse (X-marks-the-spot '() path)))

    `(<em class=red>make-procedure-with-setter</em>
      (lambda (lst) 
	,body)
      (lambda (lst val)
	(set! ,body val)))))

&gt; ((c?r (a b (X))) '(1 2 (3 4) 5))
3

&gt; (let ((lst (list 1 2 (list 3 4) 5))) 
   (set! ((c?r (a b (X))) lst) 32)
   lst)
(1 2 (32 4) 5)

&gt; (procedure-source (c?r (a b (X))))
(lambda (lst) (car (car (cdr (cdr lst)))))

&gt; ((c?r (a b . X)) '(1 2 (3 4) 5))
((3 4) 5)

&gt; (let ((lst (list 1 2 (list 3 4) 5))) 
   (set! ((c?r (a b . X)) lst) '(32))
   lst)
(1 2 32)

&gt; (procedure-source (c?r (a b . X)))
(lambda (lst) (cdr (cdr lst)))

&gt; ((c?r (((((a (b (c (d (e X)))))))))) '(((((1 (2 (3 (4 (5 6)))))))))) 
6

&gt; (let ((lst '(((((1 (2 (3 (4 (5 6))))))))))) 
    (set! ((c?r (((((a (b (c (d (e X)))))))))) lst) 32) 
    lst)
(((((1 (2 (3 (4 (5 32)))))))))

&gt; (procedure-source (c?r (((((a (b (c (d (e X)))))))))))
(lambda (lst) (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (car (car (car lst)))))))))))))))
</pre>	

</blockquote>
</small>

</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="generalizedset"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>applicable objects, generalized set!, generic functions</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>Lists, strings, vectors, hash-tables, and any cooperating C or Scheme-defined objects
are both applicable and settable.  I think the syntax is pretty:
</p>
<pre>
(let ((lst (list 1 2 3)))
  (set! (lst 1) 32)
  (list (lst 0) (lst 1)))
-&gt; '(1 32)

(let ((hash (make-hash-table)))
  (set! (hash 'hi) 32)
  (hash 'hi))
-&gt; 32
</pre>
<p>You can use list-ref and friends, of course, but just try to read any serious vector arithmetic code
when it is buried in vector-refs and vector-set!s!  set! can also apply to string-ref, list-ref, vector-ref,
hash-table-ref, car, and cdr.  That is,
</p>
<pre>
&gt; (let ((str "123")) 
    (set! (string-ref str 1) #\x) str)
"1x3"
&gt; (let ((str "123")) 
    (set! (str 1) #\x) str)
"1x3"
</pre>

<small>
<blockquote>
<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Well, maybe applicable strings look weird: <code>("hi" 1)</code> is #\i, but worse,
so is <code>(cond (1 =&gt; "hi"))</code>!
</p>
<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>This syntax makes it easy to write generic functions.
For example, s7test.scm has implementations of Common Lisp's sequence functions.
length, copy, fill!, map and for-each are generic in this sense (map always returns a list).
</p>
<pre>
&gt; (map (lambda (a b) (- a b)) (list 1 2) (vector 3 4))
(5 -3 9)
&gt; (length "hi")
2
</pre>
<p>
We can write an FFT procedure that accepts lists or vectors:
</p>
<pre>
        (define* (cfft! data n (dir 1)) ; (complex data)
          (if (not n) (set! n (<em class=red>length</em> data)))
          (do ((i 0 (+ i 1))
               (j 0))
              ((= i n))
            (if (&gt; j i)
        	(let ((temp (data j)))
        	  (set! (data j) (data i))
        	  (set! (data i) temp)))
            (let ((m (/ n 2)))
              (do () 
        	  ((or (&lt; m 2) (&lt; j m)))
        	(set! j (- j m))
        	(set! m (/ m 2)))
              (set! j (+ j m))))
          (let ((ipow (floor (log n 2)))
        	(prev 1))
            (do ((lg 0 (+ lg 1))
        	 (mmax 2 (* mmax 2))
        	 (pow (/ n 2) (/ pow 2))
        	 (theta (make-rectangular 0.0 (* pi dir)) (* theta 0.5)))
        	((= lg ipow))
              (let ((wpc (exp theta))
        	    (wc 1.0))
        	(do ((ii 0 (+ ii 1)))
        	    ((= ii prev))
        	  (do ((jj 0 (+ jj 1))
        	       (i ii (+ i mmax))
        	       (j (+ ii prev) (+ j mmax)))
        	      ((&gt;= jj pow))
        	    (let ((tc (* wc (data j))))
        	      (set! (data j) (- (data i) tc))
        	      (set! (data i) (+ (data i) tc))))
        	  (set! wc (* wc wpc)))
        	(set! prev mmax))))
          data)
        
        &gt; (cfft! (list 0.0 1+i 0.0 0.0))
        (1+1i -1+1i -1-1i 1-1i)
        &gt; (cfft! (vector 0.0 1+i 0.0 0.0))
        #(1+1i -1+1i -1-1i 1-1i)
</pre>

</blockquote>
</small>
</dd>

<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="multidimensionalvectors"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>multidimensional vectors</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>
If s7 is built with WITH_MULTIDIMENSIONAL_VECTORS (the default), it supports 
vectors with any number of dimensions.  It is here, in particular, that the generalized
set! stuff shines.  make-vector's 2nd argument can be a list of dimensions, rather than
an integer (the one dimensional case):
</p>
<pre>
    (make-vector (list 2 3 4))
    (make-vector '(2 3) 1.0)
    (vector-dimensions (make-vector (list 2 3 4))) -&gt; (2 3 4)
</pre>
<p>The second example includes the optional initial element.
<code>(vect i ...)</code> or <code>(vector-ref vect i ...)</code> return the given
element, and <code>(set! (vect i ...) value)</code> and <code>(vector-set! vect i ... value)</code>
set it.  vector-length (or just length) returns the total number of elements.
vector-dimensions returns a list of the dimensions.
</p>
<pre>
    &gt; (define v (make-vector '(2 3) 1.0))
    #2D((1.0 1.0 1.0) (1.0 1.0 1.0))

    &gt; (set! (v 0 1) 2.0)
    #2D((1.0 2.0 1.0) (1.0 1.0 1.0))

    &gt; (v 0 1)
    2.0

    &gt; (vector-length v)
    6
</pre>

<small>
<blockquote>
<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>matrix multiplication:
</p>
<pre>
(define (matrix-multiply A B)
  ;; assume square matrices and so on here for simplicity
  (let* ((size (car (vector-dimensions A)))
	 (C (make-vector (list size size) 0)))
    (do ((i 0 (+ i 1)))
	((= i size) C)
      (do ((j 0 (+ j 1)))
	  ((= j size))
	(let ((sum 0))
	  (do ((k 0 (+ k 1)))
	      ((= k size))
	    (set! sum (+ sum (* (A i k) (B k j)))))
	  (set! (C i j) sum))))))
</pre>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Multidimensional vector constant syntax is modelled after CL: #nd(...) or #nD(...) 
signals that the lists specify the elements of an 'n' dimensional vector:
</p>
<pre>
    #2D((1 2 3) (4 5 6))

    &gt; (matrix-multiply #2d((-1 0) (0 -1)) #2d((2 0) (-2 2)))
    #2D((-2 0) (2 -2))
</pre>

</blockquote>
</small>
</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="hashtables"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>hash-tables</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><br>
<ul>
<li>(make-hash-table (size 461))
<li>(hash-table-ref ht obj)
<li>(hash-table-set! ht obj val)
<li>(hash-table? obj)
<li>(hash-table-size ht)
</ul>
<p>The hashed object can be a symbol, string, integer, or (problematically of course) a real.
</p>
<pre>
(let ((ht (make-hash-table)))
  (set! (ht "hi") 123)
  (ht "hi"))

-&gt; 123
</pre>
</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="multithreading"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>threads</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>If s7 is built with HAVE_PTHREADS set, you get multithreading functions.
</p>
<ul>
<li>(make-thread thunk)
<li>(join-thread thread)
<li>(thread? obj)
<li>(make-lock)
<li>(grab-lock lock)
<li>(release-lock lock)
<li>(lock? obj)
<li>(make-thread-variable)
<li>(thread-variable? obj)
</ul>
<p>
Threads in s7 share the heap and symbol table, but have their own local environment, stack,
and evaluator locals.  I use the term "lock" in place of "mutex", and "thread-variable"
in place of "pthread_key".  The thread-variable is applicable and settable, so instead
of pthread_getspecific, just call it: (var).
</p>

<pre>
(let ((a-lock (make-lock))
      (threads '())
      (a-thread-variable (make-thread-variable)))
  (let loop
      ((i 0))
    (set! threads (cons (make-thread
			 (lambda ()
			   (set! (a-thread-variable) i)
			   (grab-lock a-lock)
			   (format #t "thread ~A " (a-thread-variable))
			   (release-lock a-lock)))
			threads))
    (if (&lt; i 8)
	(loop (+ i 1))))
  (for-each 
   (lambda (thread) 
     (join-thread thread))
   threads))
</pre>

</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="multiplevalues"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>multiple-values</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>
The r5rs section about values makes no sense to me;  why have
multiple values at all if you're just going to throw away all
but the first value?
In s7 (+ (values 1 2 3) 4) is 10.  Similarly,
</p>
<pre>
  (string-ref ((lambda () (values "abcd" 2))))
  -&gt; #\c

  ((lambda (a b) (+ a b)) 
   ((lambda () (values 1 2))))
  -&gt; 3

  ;; call-with-values: 
  (define-macro (call-with-values producer consumer) 
    `(,consumer (,producer)))

  ;; multiple-value-bind ("receive" in srfi-8):
  (define-macro (multiple-value-bind vars expr . body)
    `((lambda ,vars ,@body) ,expr))

  ;; multiple-value-set!:
  (define-macro (multiple-value-set! vars expr . body)
    (let ((local-vars (map (lambda (n) (gensym)) vars)))
      `((lambda ,local-vars ,@(map (lambda (n ln) `(set! ,n ,ln)) vars local-vars) ,@body) ,expr)))

  ;; call/cc returns multiple values:
  (+ (call/cc (lambda (ret) (ret 1 2 3))) 4)
  -&gt; 10

  ;; let*-values is defined as a macro at the end of s7.c (commented out)
</pre>

<small>
<blockquote>
<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Is there any real need for multiple-values (even in its CL form)? 
Daniel Weinreb says the original intention was to avoid consing,
which it does in s7, but that's a gnat's eyelash of an optimization.
And what is: 
</p>
<pre>
(+ (values (values 1 2) (values 4 5)))
</pre>
<p>In Guile, the + operator returns multiple-values (1 and 4) in this case, 
whereas s7 returns 12.  But
</p>
<pre>(+ (values (values 1 2) (values 4 5)) 0)
</pre>
<p>
in Guile just returns 1!  In Clisp, both cases return 1.  This causes total confusion:
</p>
<pre>
(apply + (map (lambda (n) (values n (+ n 1))) (list 1 2)))
</pre>

</blockquote>
</small>
</dd>
<br><br>



<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="callwithexit"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>call-with-exit and continuation?</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p><b>call-with-exit</b> is call/cc without the ability to return (an escape or goto, "call/exit"?).
</p>
<pre>
(define (find-first-even-number arg)
  (<em class=red>call-with-exit</em>
   (lambda (return)
     (for-each
      (lambda (a)
	(if (even? a)
	    (return a)))
      arg))))

(find-first-even-number (list 1 3 9 13 8 2 4)) -&gt; 8
</pre>
<p><b>continuation?</b> returns #t if its argument is a continuation,
as opposed to a normal procedure.  I don't know why Scheme hasn't had this function from
the very beginning, but it's needed if you want to write a continuable error
handler.  Here is a sketch of the situation:
</p>
<pre>
(let ()
  (catch #t
	 (lambda ()
	   (let ((res (call/cc 
                        (lambda (ok) 
			  (error 'cerror "an error" ok)))))
	     (display res) (newline)))
	 (lambda args
	   (if (and (eq? (car args) 'cerror)
		    (<em class=red>continuation?</em> (cadadr args)))
	       (begin
		 (display "continuing...")
		 ((cadadr args) 2)))
	   (display "oops"))))

  -&gt; continuing...2
</pre>
<p>In a more general case, the error handler is separate from the
catch body, and needs a way to distinguish a real continuation
from a simple procedure.  Otherwise, it blithely announces that
it is continuing from the point of the error, but then fails to do so.
</p>

</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="format"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>format, object-&gt;string</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>s7's built-in format function is very close to that in srfi-48.</p>
<pre>
(format #f "~A ~D ~F" 'hi 123 3.14)
-&gt; "hi 123 3.140000"
</pre>
<p>object-&gt;string returns the string representation of its argument, like format with ~S:
</p>
<pre>
&gt; (object-&gt;string "hiho")
"\"hiho\""

&gt; (format #f "~S" "hiho")
"\"hiho\""
</pre>
</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="errors"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>error handling</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>s7's error handling mimics that of (pre-r6rs) Guile.  An error is signalled
via the error function, and can be trapped and dealt with via catch.
</p>
<pre>
(<em class=red>catch</em> 'wrong-number-of-args
  (lambda ()     ; code protected by the catch
    (abs 1 2))
  (lambda args   ; the error handler
    (apply format (append (list #t) (cadr args)))))

-&gt; "abs: too many arguments: (1 2)"

(<em class=red>catch</em> 'division-by-zero
  (lambda () (/ 1.0 0.0))
  (lambda args (string-&gt;number "inf.0")))

-&gt; inf.0
</pre>

<p>
catch has 3 arguments: a tag indicating what error to catch (#t = anything),
the code (a thunk) that the catch is protecting, and the function to call
if a matching error occurs during the evaluation of the thunk.  The error handler
takes a rest argument which will hold whatever the error function chooses to pass it.
The error function itself takes at least 2 arguments, the error type (a symbol),
and the error message.  There may also be other arguments describing the error.
The default action (in the absence of any catch) is to treat the message as
a format control string, apply format to it and the other arguments, and
send that info to the current-error-port.
</p>
<p>When an error is encountered, the variable <a name="errorinfo">*error-info*</a> (a vector) contains
additional info about that error:
</p>
<ul>
<li>0: the error type or tag (e.g. 'division-by-zero)
<li>1: the message or information passed by the error function
<li>2: if not #f, the code that s7 thinks triggered the error
<li>3: if not #f, the line number of that code
<li>4: if not #f, the file name of that code
<li>5: the environment at the point of the error
<li>6...: stack environment pointers (giving enough info to reconstruct the current call stack), ending in #f
</ul>
<p>To find a variable's value at the point of the error:
</p>
<pre>
(symbol-&gt;value var (vector-ref *error-info* 5))
</pre>
<p>To print the stack at the point of the error:
</p>
<pre>
(stacktrace *error-info*)
</pre>

<p>The variable <a name="errorhook">*error-hook*</a> provides a way to specialize error reporting.
It is a function of 2 arguments, the values passed by the error function
(the error type and whatever other info accompanies it).
</p>
<pre>
(set! *error-hook* (lambda (tag args) (apply format (cons #t args))))
</pre>

<p>stacktrace can be called anytime to see the chain of function calls.  Its optional argument
can be *error-info* (as above) to show the stack at the point of the last error,
a thread object to show that thread's stack, or a continuation to
show the continuation stack. 
</p>

<pre>
    (let ()
      (define (a1 a) (+ a #\c))
      (define (a2 b) (+ b (a1 b)))
      (define (a3 c) (+ c (a2 c)))
      (catch #t
        (lambda () (a3 1))
        (lambda args (<em class=red>stacktrace</em> *error-info*))))

-&gt;    (a1 (a . 1))
      (a2 (b . 1))
      (a3 (c . 1))
</pre>

<p>
See also trace below.  There is a break macro defined in Snd (see snd-xen.c)
which allows you to stop at some point, then evaluate arbitrary expressions in that context.
<!-- INDEX autoload:autoload -->
<A NAME="autoload"></A>
There's yet another hook, <a name="unboundvariablehook">*unbound-variable-hook*</a>, which is called when an unbound variable
is encountered (before the error is signalled).  Its value is a function of one argument,
the unbound symbol.  In Snd, this is used to implement autoloading:
</p>
<pre>
(set! <em class=red>*unbound-variable-hook*</em>
  (lambda (sym)
    ;; add your own symbol checks here
    (let ((file (autoload-file (symbol-&gt;string sym))))
      ;; autoload-file is a Snd function that knows where a lot of Snd's scheme functions are
      (if file (load file))
      (symbol-&gt;value sym)))) ; this will return #&lt;undefined&gt; if we didn't find its source file
</pre>

<!--
<small>
<blockquote>
<p>Sly evil-doers can subvert this hook to provide something similar to Common Lisp's symbol-macros:
</p>
<pre>
&gt; (set! *unbound-variable-hook* 
    (lambda (sym)
      (if (eq? sym 'hiho)
          (sin (random 1.0))
          (symbol-&gt;value sym))))
&lt;closure&gt;
&gt; hiho
0.46727567824396
&gt; hiho
0.64985453979392
</pre>

</blockquote>
</small>
-->

<p>The s7-built-in catch tags (error symbols) are 'wrong-type-arg, 'syntax-error, 'read-error, 'thread-error,
'out-of-memory, 'wrong-number-of-args, 'format-error, 'out-of-range, 'division-by-zero, 'io-error, and 'bignum-error.  
</p>
</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="trace"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>trace, untrace</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>These functions provide tracing:
</p>
<pre>
    (define (hiho arg) 
      (if (&gt; arg 0) 
          (+ 1 (hiho (- arg 1))) 
          0))

    (<em class=red>trace</em> hiho)

    (hiho 3)

    [hiho 3]
     [hiho 2]
      [hiho 1]
       [hiho 0]
        0
       1
      2
     3
</pre>
<p>trace adds a function to the list of functions being traced, and untrace removes it.
trace with no arguments causes everything to be traced, and untrace with no arguments
turns this off.
</p>
<p>There is also a hook, <a name="tracehook">*trace-hook*</a>, a function of 2 arguments (the currently traced
function and the list of current arguments).  It is evaluated in the environment of the
function call (that is, global to the function, not the function's local environment).
</p>
<pre>
    (define (hiho a b c) (* a b c))
    (set! *trace-hook* (lambda (f args) (format #t "sum of args: ~A~%" (apply + args))))
    (trace hiho)
    (hiho 2 3 4)

    [hiho 2 3 4]
    sum of args: 9
     24
</pre>
</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="IO"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>IO functions</h4></td></tr></table>
</td></tr></table>
</dt>

<dd>
<p>Besides files, ports can also represent strings and functions.  The string port functions
are:
</p>
<ul>
<li>with-output-to-string
<li>with-input-from-string
<li>call-with-output-string
<li>call-with-input-string,
<li>open-output-string
<li>open-input-string
<li>get-output-string
</ul>
<pre>
(let ((result #f) 
      (p (<em class=red>open-output-string</em>)))
  (format p "this ~A ~C test ~D" "is" #\a 3)
  (set! result (<em class=red>get-output-string</em> p))
  (close-output-port p)
  result)
-&gt; "this is a test 3"
</pre>
<p>Other functions:</p>
<ul>
<li>read-byte and write-byte (binary IO) (named "read-u8" and "write-u8" in r6rs, I think)
<li>read-line (line-at-a-time reads)
</ul>
<p>The variable <a name="vectorprintlength">*vector-print-length*</a> sets
the upper limit on how many vector elements are printed by object-&gt;string and format.
</p>
<p>When running s7 behind a GUI, you often want input to come from and output to go to
arbitrary widgets. The "function ports" provide a way to redirect IO.  See <a href="#functionportexample">below</a>
for an example.
</p>
<p>s7 also includes current-error-port and set-current-error-port.
</p>
</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="procedureinfo"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>procedure info</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>procedure-source, procedure-arity, procedure-documentation, and help provide a look into a
scheme function.
procedure-documentation returns the documentation string associated with a procedure (the initial string in the
function's body). procedure-arity returns a list describing the argument list of a function: '(required-args optional-args rest-arg).
procedure-source returns the source (as a list) of a procedure. procedure-environment returns
a procedure's environment.
</p>
<pre>
&gt; (define* (add-2 a (b 32)) "add-2 adds its 2 args" (+ a b))
add-2

&gt; (procedure-documentation add-2)
"add-2 adds its 2 args"

&gt; (procedure-arity add-2)
(0 2 #f)

&gt; (procedure-source add-2)
(lambda* (a (b 32)) "add-2 adds its 2 args" (+ a b))
</pre>

<p>We can use procedure-environment and __func__ (mentioned below) to 
write a function that tells us where the source is for a function:
</p>
<pre>
(define (where-is func)
  (let ((addr (cdr (assoc <em class=red>'__func__</em> (car (<em class=red>procedure-environment</em> func))))))
    (if (not (pair? addr))
	"not found"
	(format #f "~A is at line ~D of ~A" (car addr) (caddr addr) (cadr addr)))))

&gt; (where-is profile)
"profile is at line 1048 of extensions.scm"
</pre>

</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="symbolinfo"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>symbol table info</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>(symbol-table) returns the symbol table, a vector of lists of symbols.
(symbol-&gt;value sym :optional env) returns the binding of 'sym'
in the given environment which defaults to the current environment.
(defined? obj :optional env) returns #t if 'obj' has a binding (a value) in the environment 'env'.
If profiling is enabled (set WITH_PROFILING in s7.c), (symbol-calls sym) returns
the number of times that symbol's binding has been applied.
Here we scan the symbol table for any function that doesn't have documentation:
</p>
<pre>
       (let ((st (<em class=red>symbol-table</em>)))
         (do ((i 0 (+ i 1))) 
             ((= i (vector-length st)))
           (let ((lst (vector-ref st i)))
             (for-each 
               (lambda (sym)
       	         (if (<em class=red>defined?</em> sym)
	             (let ((val (<em class=red>symbol-&gt;value</em> sym)))
	               (if (and (procedure? val)
			        (string=? "" (procedure-documentation val)))
		           (format #t "~A " sym)))))
               lst))))
</pre>
</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="environments"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>environment info</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>environments are "first class objects" in s7.  An environment is
a list of alists ending with a hash-table (the global environment).
(current-environment :optional thread)
returns the current environment (symbol bindings).  (global-environment)
returns the top-level environment.  (procedure-environment proc) returns
the procedure proc's environment.
Here is an example of "apropos" that accesses both environments:
</p>
<pre>
        (define (apropos name)
          ;; (apropos "name") prints out a list of all symbols whose name includes "name" as a substring

          (define (substring? subs s) ; from Larceny
            (let* ((start 0)
	           (ls (string-length s))
	           (lu (string-length subs))
	           (limit (- ls lu)))
              (let loop ((i start))
	        (cond ((&gt; i limit) #f)
	              ((do ((j i (+ j 1))
	        	    (k 0 (+ k 1)))
	        	   ((or (= k lu)
	        		(not (char=? (string-ref subs k) (string-ref s j))))
	        	    (= k lu))) i)
	              (else (loop (+ i 1)))))))

          (define (apropos-1 alist)
            (for-each
             (lambda (binding)
               (if (substring? name (symbol-&gt;string (car binding)))
	           (format (current-output-port) "~A: ~A~%" 
	        	   (car binding) 
	        	   (if (procedure? (cdr binding))
	        	       (procedure-documentation (cdr binding))
	        	       (cdr binding)))))
             alist))

          (for-each
           (lambda (frame)
             (if (vector? frame) ; the global environment
	         (let ((len (vector-length frame)))
	           (do ((i 0 (+ i 1)))
	               ((= i len))
	             (apropos-1 (vector-ref frame i))))
	         (apropos-1 frame)))
           (<em class=red>current-environment</em>)))
</pre>

<p>(with-environment env . body) evaluates its body in the environment env.
Although the environment is just a list of alists of (symbol . value) pairs, you can't simply
add new pairs to it (or use set-cdr! to change the value in an existing binding) 
because symbol lookup is optimized to reduce the time
spent pawing through the environment.  So, to add a new value to an environment,
use <b>augment-environment</b>:
</p>
<pre>
(let ((a 1)) 
  (eval '(+ a b) 
         (<em class=red>augment-environment</em>
           (current-environment) 
           (cons 'b 32)))) ; add 'b with the value 32 to this environment

-&gt; 33
</pre>
<p>augment-environment does not change the environment passed to it.  It
just prepends the new bindings (shadowing any old ones),
as if you had called "let".  
I think these two functions can implement the notions of libraries,
separate namespaces, or modules.  The library file exports a list
of bindings: <code>(cons name value)</code>, keeping all its own
code in a let, or group of lets:
</p>
<pre>
(let ((var1 32))
  (define (func1 a) (+ a 1))
  (define (func2 a) (+ a 2))
  (list (cons 'func1 func1)
	(cons 'func2 func2)
	(cons 'var1 var1)))
</pre>
<p>Loading this file returns the list (load returns the last thing it evaluates).
For explicitness, we could put the list of names at the top of the file (an "export" statement),
and fill in the values as we define them (as in the make-type <a href="#recordexample">record</a> example above).
The file that wants to use this library uses with-environment and augment-environment
to "import" the exported values:
</p>
<pre>
(define (import file)
  (apply augment-environment (current-environment) (load file)))

(with-environment
 (import "lib1.scm")
 (display (* (func1 var1) (func2 var1)))) ; displays 1122, i.e. (* 33 34)
</pre>

<p>If we want to import these things under different names, or use only some subset,
the list passed to augment-environment is at our disposal.  
Loading a library file does not add anything to our environment unless we explicitly
ask for it, and subsets and renaming are trivial.  To import many libraries, just
nest the import statements, or make a version that loads up all the libraries,
saving the exported lists, and pass them concatenated to augment-environment.
And when we leave the with-environment body, all those new bindings go away too,
so the global state is unaffected.  
If we actually want to affect the top-level, we can forego the with-environment wrapper:
</p>
<pre>
(define lib1-exports (load "lib1.scm"))

(define global-func
  (let ((func1 (cdr (assoc 'func1 lib1-exports))))
    (lambda (a)
      (func1 a))))
</pre>
<p>
To use namespaces from C, see the FFI <a href="#namespace">example</a>
below.
</p>

<small>
<blockquote>
<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>
We have atoms, lists, namespaces (alists),
environments (lists of alists), procedures (source code and its environment),
and threads
(a procedure with a private stack).
So it
seems reasonable to define an object (in the "object-oriented" sense)
as a cons of two alists, the object's private
fields and its methods (in the class-inheritance case, we'd have
an environment of methods).
Then a generic function is:
</p>
<pre>
(define-macro (define-generic f)
  `(define (,f obj . args)
     (apply (cdr (or (assoc ',f (cdr obj))
		     (error "can't find the ~A method for ~A" ',f obj)))
	    obj args)))
</pre>
<p>and all the rest of the object machinery is equally straightforward,
at least conceptually.  We can even conjure up objects without any
explicit class:
</p>
<pre>
(define hi (cons (list (cons 'a 1) (cons 'b 2))                    ; its local data
                 (list (cons 'splice (lambda (obj) "splicing"))))) ; its "splice" method
(define-generic splice)
(splice hi)
"splicing"
</pre>

</blockquote>
</small>


</dd>
<br><br>



<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="evalstring"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>eval</h4></td></tr></table>
</td></tr></table>
</dt>

<dd>

<p>
<b>eval</b> evaluates its argument (a list representing a piece of code).  It takes an optional
second argument, the environment in which the evaluation should take place.  <b>eval-string</b>
is similar, but its argument is a string.
</p>
<pre>
&gt; (eval '(+ 1 2))
3

&gt; (eval-string "(+ 1 2)")
3
</pre>

<small>
<blockquote>
<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>The environment argument is mainly useful in debugging.  A breakpoint can be set, for
example, then any input is evaluated in the environment of the break.  Say we have the
following code in ex.scm:
</p>
<pre>
(define-macro (break)
  `(let ((break-env (<em class=red>current-environment</em>))
	 (prompt (format #f "~%~A &gt; " (if (defined? '__func__) __func__ "break"))))
     (call-with-exit
      (lambda (return)
	(do () ()                       ; our debugger's own REPL
	  (display prompt)              ; show where we stopped
	  (let ((str (read-line '())))  ; read a line of input, :go -&gt; exit the debugger
	    ;; the nil argument to read-line makes sure that we read C's stdin.  In any normal
	    ;;    program, we'd get the string from a text widget.
	    (if (&gt; (length str) 0)
		(catch #t               ; try to handle typing mistakes etc
		       (lambda ()
			 (let ((val (<em class=red>eval-string</em> str <em class=red>break-env</em>)))
			   (if (eq? val :go)
			       (return))
			   (write val)))
		       (lambda args
			 (format #t "error: ~A" args))))))))))

;; now some random code that has a breakpoint
(define (a-function b)
  (let ((x 32))
    (do ((i 0 (+ i 1)))
	((= i 10))
      (if (= i 3)
	  (<em class=red>break</em>)))
    x))

(a-function 123)

(display "done!") (newline)
</pre>
<p>
Start up a REPL, and:
</p>
<pre>
&gt; (load "ex.scm")

(a-function "ex.scm" 26) &gt; x    ; here we're in the debugger
32
(a-function "ex.scm" 26) &gt; (+ b i)
126
(a-function "ex.scm" 26) &gt; :go
done!
</pre>

</blockquote>
</small>
</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="miscellanea"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>miscellanea</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p><b><a name="loadpath">*load-path*</a></b> is a list of directories to search when loading a file.
<b><a name="loadhook">*load-hook*</a></b> is a function called just before a file is loaded.  Its argument is the filename.
While loading, port-filename and port-line-number (of the current-input-port) can tell you
where you are in the file.
</p>
<pre>
(set! *load-hook* (lambda (name) (format #t "loading ~S...~%" name)))
</pre>

<p>Here's a *load-hook* function that adds the loaded file's directory
to the *load-path* variable so that subsequent loads don't need to specify
the directory:
</p>
<pre>
(set! <em class=red>*load-hook*</em>
  (lambda (filename)
    (let ((pos -1)
	  (len (length filename)))
      (do ((i 0 (+ i 1)))
	  ((= i len))
	(if (char=? (filename i) #\/)
	    (set! pos i)))
      (if (positive? pos)
	  (let ((directory-name (substring filename 0 pos)))
	    (if (not (member directory-name <em class=red>*load-path*</em>))
		(set! <em class=red>*load-path*</em> (cons directory-name *load-path*))))))))
</pre>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>


<p>As in Common Lisp, <b><a name="featureslist">*features*</a></b> is a list describing what is currently loaded into s7.  You can
check it with the <b>provided?</b> function, or add something to it with <b>provide</b>.  In my version of Snd,
at startup *features* is:
</p>
<pre>
&gt; *features*
(snd10 snd snd-s7 snd-motif gsl alsa xm snd-ladspa run clm4 clm sndlib gmp multidimensional-vectors s7)

&gt; (provided? 'gmp)
#t
</pre>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>



<p>Multi-line comments can be enclosed in either #| and |#, or #! and !# (the latter
is for compatibility with Guile).  These are also useful for in-line comments:
<code>(+ #| add |# 1 2)</code>.
</p>

<p>Leaving aside these two cases, and the booleans, #f and #t, you can specify your own handlers for 
tokens that start with "#".  <b><a name="sharpreaders">*#readers*</a></b> is a list of pairs: (char . func).
"char" refers to the first character after the sharp sign (#). "func" is a function of
one argument, the string that follows the #-sign up to the next delimiter.  "func" is called
when #&lt;char&gt; is encountered.  If it returns something other than #f, the #-expression
is replaced with that value.  Scheme has several predefined #-readers for cases such
as #b1, #\a, #i123, and so on, but you can override these if you like.  If the string
passed in is not the complete #-expression, the function can use read-char to get the
rest.
</p>

<pre>
  &gt; (set! *#readers* (list (cons #\s (lambda (str) 123))))
  ((#\s . #&lt;closure&gt;))
  &gt; (+ 1 #s1)
  124
</pre>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>


<p>(<b>make-list</b> length (initial-element #f)) returns a list of 'length' elements defaulting to 'initial-element'.
</p>

<p><b>reverse!</b> is an in-place version of the built-in function reverse.  That is, 
it modifies the list passed to it in the process of reversing its contents.
<b>list-set!</b> sets a member of a list.  <b>sort!</b> sorts a list or a vector using the
function passed as its second argument to choose the new ordering.
</p>
<pre>
&gt; (sort! (list 3 4 8 2 0 1 5 9 7 6) &lt;)
(0 1 2 3 4 5 6 7 8 9)

(define (mix-notelists . notelists)
  ;; assume the 2nd parameter is the begin time in seconds (the 1st is the instrument name)
  (<em class=red>sort!</em>
   (apply append notelists)
   (lambda (note1 note2)
     (&lt; (cadr note1) (cadr note2)))))

(mix-notelists '((fm-violin 0 1 440 .1)
		 (fm-violin 1 1 550 .1))
	       '((bird 0 .1 )
		 (bird .2 .1)
		 (bird 1.2 .3)
		 (bird .5 .5)))

 -&gt; ((bird 0 0.1) (fm-violin 0 1 440 0.1) (bird 0.2 0.1) (bird 0.5 0.5) (fm-violin 1 1 550 0.1) (bird 1.2 0.3))
</pre>
<p>Despite the "!" in its name, sort! actually copies any list argument passed to it,
but vectors are sorted in place.
</p>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>


<p>
Keywords exist mainly for define*'s benefit.  The keyword functions are:
<b>keyword?</b>, <b>make-keyword</b>, <b>symbol-&gt;keyword</b>, and <b>keyword-&gt;symbol</b>.
A keyword is a symbol that starts or ends with a colon. The colon
is considered to be a part of the symbol name.
s7's keyword support is somewhat lackadaisical; I can't decide if it's worth complaining
about stuff like <code>(let ((:hi 1)) :hi)</code>.
</p>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>


<p><b>help</b> tries to find information about its argument.</p>
<pre>
&gt; (help 'caadar)
"(caadar lst) returns (car (car (cdr (car lst)))): (caadar '((1 (2 3)))) -> 2"
</pre>
<p>If the initial expression in a function body is a string constant, it is assumed to be a documentation string:
</p>
<pre>
(define (add1 a)
  "(add1 a) adds 1 to its argument"
  (+ a 1))

&gt; (help add1)
"(add1 a) adds 1 to its argument"
</pre>
<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p><b>quit</b> exits s7.</p>
<p><b>gc</b> calls the garbage collector.  (gc #f) turns off the GC, and (gc #t) turns it on.
In the multithread case, don't call gc yourself except from the top-level.
</p>

<!--
<p>
<b>define-expansion</b> defines read-time macros, which are just dangerous enough that
I probably shouldn't document them.  It has the same syntax as
define-macro, and the same result except that the macro is
dealt with at read time!  (This means it does not respect attempts to
bind it to something else, which is asking for confusion).
</p>
-->

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>


<p>Some other differences from r5rs:
</p>
<ul>
<li>letrec*.
<li>do sets its step variables, rather than rebinding them.
<li>no syntax-rules or any of its friends.
<li>force and delay are implemented as in slib and depend on the WITH_FORCE switch, normally 0.
<li>s7-version returns the current s7 version.
<li>no scheme-report-environment, null-environment, or interaction-environment (= current-environment?).
<li>no transcript-on or transcript-off.
<li>__func__ is the name (or name and location) of the function currently being defined or called (as in C).
<li>syntactic names can be values: <code>(define progn begin) (progn (display "progn!") (+ 3 4))</code> or <code>(define function lambda)</code>, etc
<li>begin returns the value of the last form (like progn); it can contain both definitions and other statements.
</ul>

<small>
<blockquote>
<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Schemes vary in their treatment of ().  s7 considers it a constant that evaluates to itself,
so you rarely (never?) need to quote it.  <code>(eq? () '())</code> is #t.
</p>
<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Schemes also vary in handling trailing arguments:
<code>(* 0 "hi")</code> in Guile returns 0, but s7 gives an error.  
<code>(cond (1) (=&gt;))</code> is 1 in both,  and
<code>(or 1 2 . 3)</code> is an
error in Guile, and 1 in s7!
(Because it flushes trailing arguments, Guile returns 0 from <code>(* 0 +inf.0)</code>, but it should return NaN).
</p>
<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>And a harder one... How should s7 treat this:
<code>(string-set! "hiho" 1 #\z)</code>, or 
<code>(vector-set! #(1 2 3) 1 32)</code>, or
<code>(list-set! '(1 2 3) 1 32)</code>?
Originally, in s7, the first two were errors, and the third was allowed, which doesn't make much sense.
Guile (and Common Lisp) accept all three, but that leads to weird cases where we can reach
into a function's body:
</p>
<pre>
&gt; (let ((x (lambda () '(1 2 3)))) (list-set! (x) 1 32) (x))
(1 32 3) ; s7, Guile

&gt; (flet ((x () '(1 2 3))) (setf (nth 1 (x)) 32) (x))
(1 32 3) ; Clisp

&gt; (let ((x (lambda () (list 1 2 3)))) (list-set! (x) 1 32) (x))
(1 2 3)
</pre>
<p>
But it's possible to reach into a function's closure, even when the
closed-over thing is a constant:
</p>
<pre>
&gt; (flet ((x () '(1 2 3))) (setf (nth 1 (x)) 32) (x))
(1 32 3)

&gt; (let ((xx (let ((x '(1 2 3))) (lambda () x)))) (list-set! (xx) 1 32) (xx))
(1 32 3)
&gt; (let ((xx (let ((x (list 1 2 3))) (lambda () x)))) (list-set! (xx) 1 32) (xx))
(1 32 3)
</pre>
<p>And it's possible to reach into a constant list via list-set! (or set-car! of course):
</p>
<pre>
&gt; (let* ((x '(1 2)) (y (list x)) (z (car y))) (list-set! z 1 32) (list x y z))
((1 32) ((1 32)) (1 32))
</pre>
<p>
It would be a programmer's nightmare to have to keep track of which piece of a list is
constant, and an implementor's nightmare to copy every list.  set! in all its forms is
used for its side-effects, so why should we try to put a fence around them?
If we flush "immutable constant" because it is a ham-fisted, whack-it-with-a-shovel approach,
the only real problem I can see is symbol-&gt;string.  In CL, this is explicitly an error:
</p>
<pre>
&gt; (setf (elt (symbol-name 'xyz) 1) #\X)
*** - Attempt to modify a read-only string: "XYZ"
</pre>
<p>And in Guile:
</p>
<pre>
&gt; (string-set! (symbol-&gt;string 'symbol-&gt;string) 1 #\X)
ERROR: string is read-only: "symbol-&gt;string"
</pre>
<p>So both have a notion of immutable strings.  
I wonder what other Scheme programmers (not implementors!) want in this situation.
Currently, there are no immutable list, string, or vector constants, and
symbol-&gt;string
returns a copy of the string.
One simple way to ensure immutability is to use copy:
</p>
<pre>
&gt; (let ((x (lambda () (copy "hiho")))) (string-set! (x) 1 #\x) (x))
"hiho"
</pre>

</blockquote>
</small>

</dd>
<br>
<br><br>




<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="s7rundoc"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>the run macro</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>s7 is primarily aimed at computer music, CLM-based sound synthesis in particular.
A CLM "instrument" is usually a do-loop running things like oscillators and envelopes
for zillions of sound samples.  These calculations do not involve recursion, or
complex numbers, or fancy list processing, so it is not too hard to write an
optimizer for them.  In sndlib, that optimizer is called "run".  It is a macro
that can be wrapped around any piece of Scheme code that you want to speed up.
If it can't optimize the code, it passes it to the s7 interpreter.  If run is successful,
you will normally get a speed up by a factor of 10 to 30.  For CLM instruments,
the result runs close to the speed of the equivalent compiled and optimized
C code.  Here are my timings for two instruments, "bird" and "fm-violin", each running for 100 seconds.
I've included sbcl times for comparison.
</p>
<pre>
          s7 interpreted  s7+run  C (-O2)      sbcl
bird          9.6          .7       .65         .65
violin       21.6         1.44     1.28        1.28
</pre>

<p>
The sbcl and C compiler cases are the same because
CLM in sbcl uses a version of the run macro that translates the CL code to C, calls the C compiler
on that, then loads it as a foreign function, so it is essentially the
same as the straight C case.  In s7, however, we're running interpreted; there is
no separate compilation step.  Another comparison: the fft benchmark from the Gabriel
tests.  In s7 interpreted, it runs 1000 1024 point FFTs in 53 seconds; with "run",
the same takes 2 seconds.  In Guile 1.9.5 after compilation, it takes 10 seconds.
So, in general, s7 is not so slow as to be an annoyance.  
</p>

<!--
sbcl: (with-sound (:play nil :statistics t) (bird 0 100 440.0 10.0 0.5 '(0 0 1 1) '(0 0 1 1 2 1 3 0)))
      (with-sound (:play nil :statistics t) (fm-violin 0 100 440.0 .4))

C: in sndlib configure make
   gcc time-bird.c -o time-bird -O2 -I. libsndlib.a -lasound -lgsl -lgslcblas
   time time-bird

s7: use the sndlib example in s7.html
    gcc -o ex1 ex1.c s7.o -lm -I. -O2
    ex1
    (load "sndlib-ws.scm")
    (load "bird.scm")
    (load "v.scm")

(with-sound (:play #f :statistics #t) (bird 0 100 440.0 10.0 0.5 '(0 0 1 1) '(0 0 1 1 2 1 3 0)))
(with-sound (:play #f :statistics #t) (fm-violin 0 100 440.0 .4))


fft.sch interpreted: 53,  run: 2
guile 1.9.5 after compilation: 10.5
-->


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<small>
<blockquote>
<p>I can't resist giving another example.  Here's some vector arithmetic:
</p>
<pre>
(let* ((size (* 128 1024))
       (v1 (make-vector size 0.0))
       (v2 (make-vector size 0.0))
       (sum 0.0))
  (<em class=red>run</em>
   (do ((i 0 (+ i 1)))
       ((= i size))
     (vector-set! v1 i (- (random 2.0) 1.0))
     (vector-set! v2 i (- (random 2.0) 1.0)))
   (do ((i 0 (+ i 1)))
       ((= i size) sum)
     (set! sum (+ sum (* (vector-ref v1 i) (vector-ref v2 i)))))))
</pre>
<p>With run, this takes .092 seconds on my old machine; without run, it takes 1.94 seconds.
</p>
</blockquote>
</small>

</dd>
<br><br>

</dl>


<!-- -------------------------------------------------------------------------------- -->
<A NAME="FFIexamples"></a>
<table border=0 bordercolor="lightgreen" width=100% cellpadding=2 cellspacing=0><tr><td bgcolor="lightgreen">
<table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h3>FFI examples</h3></td></tr></table>
</td></tr></table>

<p>s7 exists only to serve as an extension of some other application, so
it is primarily a foreign function interface.  s7.h has lots of comments about the individual
functions.  Here I'll collect some complete examples.  s7.c depends on the following
compile-time flags:
</p>
<pre>
    HAVE_STDBOOL_H                 1 if you have stdbool.h
    HAVE_PTHREADS                  1 if you want multithreading support (requires pthreads, default is 0)
    HAVE_NESTED_FUNCTIONS          1 if your compiler supports nested functions
    WITH_GMP                       1 if you want multiprecision arithmetic (requires gmp, mpfr, and mpc, default is 0)
    WITH_COMPLEX                   1 if your compiler supports complex numbers
    HAVE_COMPLEX_TRIG              1 if your math library has complex versions of the trig functions
    WITH_MULTIDIMENSIONAL_VECTORS  1 if you want multidimensional vectors (default is 1)
    WITH_PROFILING                 1 if you want profiling support (default is 0)
    WITH_FORCE                     1 if you want force and delay (default is 0)
    WITH_MULTIPLE_VALUES           1 if you want multiple-values and its friends (default is 1)
    S7_DISABLE_DEPRECATED          1 if you want to make sure you're not using any deprecated s7 stuff (default is 0)
</pre>
<p>See the comment at the start of s7.c for more information about these switches.
s7.h defines the two main number types: s7_Int and s7_Double.
The examples that follow show:
</p>

<ul>
<li><a href="#repl">read-eval-print loop</a>
<li><a href="#defun">define a function with arguments and a returned value, and define a variable </a>
<li><a href="#defvar">call a scheme function from C, and get/set scheme variable values in C</a>
<li><a href="#juce">C++ and Juce</a>
<li><a href="#sndlib">load sndlib using the XEN functions and macros</a>
<li><a href="#pwstype">add a new scheme type and a procedure-with-setter</a>
<li><a href="#functionportexample">redirect display output to a C procedure</a>
<li><a href="#extendop">extend a built-in operator ("+" in this case)</a>
<li><a href="#definestar">C-side define* (s7_define_function_star)</a>
<li><a href="#definemacro">C-side define-macro (s7_define_macro)</a>
<li><a href="#signal">signal handling (C-C to break out of an infinite loop)</a>
<li><a href="#vector">direct multidimensional vector element access</a>
<li><a href="#notify">notification in C that a Scheme variable has been set!</a>
<li><a href="#namespace">Load C defined stuff into a separate namespace</a>
<li><a href="#Cerrors">Error handling in C</a>
</ul>

<br><br>
<p>
<A NAME="repl"></a>
First, a bare REPL:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include "s7.h"

static s7_pointer our_exit(s7_scheme *sc, s7_pointer args) 
{
  /* all added functions have this form, args is a list, 
   *    s7_car(args) is the 1st arg, etc 
   */
  exit(1);
  return(s7_nil(sc)); /* never executed, but makes the compiler happier */
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];

  s7 = <em class=red>s7_init</em>();                     /* initialize the interpreter */
  <em class=red>s7_define_function</em>(s7, "exit", our_exit, 0, 0, false, "(exit) exits the program");
                                      /* add the function "exit" to the interpreter.
                                       *   0, 0, false -&gt; no required args,
				       *                  no optional args,
				       *                  no "rest" arg
				       */
  while (1)                           /* fire up a REPL */
    {
      fprintf(stdout, "\n&gt; ");        /* prompt for input */
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  <em class=red>s7_eval_c_string</em>(s7, response); /* evaluate input and write the result */
	}
    }
}

/* make mus-config.h (it can be empty), then
 *
 *   gcc -c s7.c -I.
 *   gcc -o doc7 doc7.c s7.o -lm -I.
 *
 * run it:
 *
 *    doc7
 *    &gt; (+ 1 2)
 *    3
 *    &gt; (define (add1 x) (+ 1 x))
 *    add1
 *    &gt; (add1 2)
 *    3
 *    &gt; (exit)
 */
</pre>
</td></tr></table>



<br><br>
<A NAME="defun"></a>
<p>Define a function with arguments and a returned value, and a variable:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer our_exit(s7_scheme *sc, s7_pointer args)
{
  exit(1);
  return(s7_nil(sc));
}

static s7_pointer add1(s7_scheme *sc, s7_pointer args)
{
  if (<em class=red>s7_is_integer</em>(s7_car(args)))
    return(<em class=red>s7_make_integer</em>(sc, 1 + <em class=red>s7_integer</em>(s7_car(args))));
  return(s7_wrong_type_arg_error(sc, "add1", 1, s7_car(args), "an integer"));
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];

  s7 = s7_init();                     /* initialize the interpreter */
  
  s7_define_function(s7, "exit", our_exit, 0, 0, false, "(exit) exits the program");
  s7_define_function(s7, "add1", add1, 1, 0, false, "(add1 int) adds 1 to int");
  <em class=red>s7_define_variable</em>(s7, "my-pi", <em class=red>s7_make_real</em>(s7, 3.14159265));

  while (1)                           /* fire up a "repl" */
    {
      fprintf(stdout, "\n&gt; ");        /* prompt for input */
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response); /* evaluate input and write the result */
	}
    }
}

/*    doc7
 *    &gt; my-pi
 *    3.14159265
 *    &gt; (+ 1 (add1 1))
 *    3
 *    &gt; (exit)
 */
</pre>
</td></tr></table>



<br><br>
<A NAME="defvar"></a>
<p>Call a scheme-defined function from C, and get/set scheme variable values in C:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

int main(int argc, char **argv)
{
  s7_scheme *s7;
  s7 = s7_init();

  s7_define_variable(s7, "an-integer", s7_make_integer(s7, 1));
  s7_eval_c_string(s7, "(define (add1 a) (+ a 1))");
  
  fprintf(stderr, "an-integer: %d\n", 
	  s7_integer(<em class=red>s7_name_to_value</em>(s7, "an-integer")));

  <em class=red>s7_symbol_set_value</em>(s7, <em class=red>s7_make_symbol</em>(s7, "an-integer"), s7_make_integer(s7, 32));

  fprintf(stderr, "now an-integer: %d\n", 
	  s7_integer(<em class=red>s7_name_to_value</em>(s7, "an-integer")));

  fprintf(stderr, "(add1 2): %d\n", 
	  s7_integer(<em class=red>s7_call</em>(s7, 
			     s7_name_to_value(s7, "add1"), 
			     s7_cons(s7, s7_make_integer(s7, 2), s7_nil(s7)))));
}

/*
 *    doc7
 *    an-integer: 1
 *    now an-integer: 32
 *    (add1 2): 3
 */
</pre>
</td></tr></table>



<br><br>
<A NAME="juce"></a>
<p>C++ and Juce, from Rick Taube:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
int main(int argc, const char* argv[]) 
{ 
  initialiseJuce_NonGUI(); 

  s7_scheme *s7 = s7_init(); 
  if (!s7) 
    { 
      std::cout &lt;&lt;  "Can't start S7!\n"; 
      return -1; 
    } 

  s7_pointer val; 
  std::string str; 
  while (true) 
    { 
      std::cout &lt;&lt; "\ns7&gt; "; 
      std::getline(std::cin, str); 
      val = s7_eval_c_string(s7, str.c_str()); 
      std::cout &lt;&lt; s7_object_to_c_string(s7, val); 
    } 

  free(s7); 
  std::cout &lt;&lt; "Bye!\n"; 
  return 0; 
} 
</pre>
</td></tr></table>



<br><br>
<A NAME="sndlib"></a>
<p>Load sndlib using the XEN functions and macros into an s7 repl:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

/* assume we've configured and built sndlib, so it has created a mus-config.h file */

#include "mus-config.h"
#include "s7.h"
#include "xen.h"
#include "clm.h"
#include "clm2xen.h"

/* we need to redirect clm's mus_error calls to s7_error */

static void mus_error_to_s7(int type, char *msg)
{
  s7_error(s7,                               /* s7 is declared in xen.h */
	   s7_make_symbol(s7, "mus-error"),
	   s7_cons(s7, s7_make_string(s7, msg), s7_nil(s7)));
}

static s7_pointer our_exit(s7_scheme *sc, s7_pointer args)
{
  exit(1);
  return(s7_nil(sc));
}

/* the next functions are needed for either with-sound or many standard instruments, like fm-violin */
/*   (these are in the xen-style FFI) */

static XEN g_file_exists_p(XEN name)
{
  #define H_file_exists_p "(file-exists? filename): #t if the file exists"
  XEN_ASSERT_TYPE(XEN_STRING_P(name), name, XEN_ONLY_ARG, "file-exists?", "a string");
  return(C_TO_XEN_BOOLEAN(mus_file_probe(XEN_TO_C_STRING(name))));
}

XEN_NARGIFY_1(g_file_exists_p_w, g_file_exists_p)

static XEN g_delete_file(XEN name)
{
  #define H_delete_file "(delete-file filename): deletes the file"
  XEN_ASSERT_TYPE(XEN_STRING_P(name), name, XEN_ONLY_ARG, "delete-file", "a string");
  return(C_TO_XEN_BOOLEAN(unlink(XEN_TO_C_STRING(name))));
}

XEN_NARGIFY_1(g_delete_file_w, g_delete_file)

int main(int argc, char **argv)
{
  char buffer[512];
  char response[1024];

  s7 = s7_init();                     /* initialize the interpreter */
  xen_initialize();                   /* initialize the xen stuff (hooks and the xen s7 FFI used by sndlib) */
  Init_sndlib();                      /* initialize sndlib with all the functions linked into s7 */  

  mus_error_set_handler(mus_error_to_s7); /* catch low-level errors and pass them to s7-error */

  XEN_DEFINE_PROCEDURE("file-exists?", g_file_exists_p_w, 1, 0, 0, H_file_exists_p);
  XEN_DEFINE_PROCEDURE("delete-file",  g_delete_file_w,   1, 0, 0, H_delete_file);
  s7_define_function(s7, "exit", our_exit, 0, 0, false, "(exit) exits the program");

  while (1)                           /* fire up a "repl" */
    {
      fprintf(stdout, "\n&gt; ");        /* prompt for input */
      fgets(buffer, 512, stdin);

      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response); /* evaluate input and write the result */
	}
    }
}

/* gcc -o doc7 doc7.c -lm -I. /usr/local/lib/libsndlib.a -lasound
 *
 *   (load "sndlib-ws.scm")
 *   (with-sound () (outa 10 .1))
 *   (load "v.scm")
 *   (with-sound () (fm-violin 0 .1 440 .1))
 *
 * you might also need -lgsl -lgslcblas
 */
</pre>
</td></tr></table>



<br><br>
<A NAME="pwstype"></a>
<p>Add a new scheme type and procedure-with-setters:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer our_exit(s7_scheme *sc, s7_pointer args)
{
  exit(1);
  return(s7_nil(sc));
}

/* define *listener-prompt* in scheme, add two accessors for C get/set */

static const char *listener_prompt(s7_scheme *sc)
{
  return(s7_string(s7_name_to_value(sc, "*listener-prompt*")));
}

static void set_listener_prompt(s7_scheme *sc, const char *new_prompt)
{
  s7_symbol_set_value(sc, s7_make_symbol(sc, "*listener-prompt*"), s7_make_string(sc, new_prompt));
}

/* now add a new type, a struct named "dax" with two fields, a real "x" and a list "data" */
/*   since the data field is an s7 object, we'll need to mark it to protect it from the GC */

typedef struct {
  s7_Double x;
  s7_pointer data;
} dax;

static char *print_dax(s7_scheme *sc, void *val)
{
  char *data_str, *str;
  int data_str_len;
  dax *o = (dax *)val;
  data_str = s7_object_to_c_string(sc, o-&gt;data);
  data_str_len = strlen(data_str);
  str = (char *)calloc(data_str_len + 32, sizeof(char));
  snprintf(str, data_str_len + 32, "#&lt;dax %.3f %s&gt;", o-&gt;x, data_str);
  free(data_str);
  return(str);
}

static void free_dax(void *val)
{
  if (val) free(val);
}

static bool equal_dax(void *val1, void *val2)
{
  return(val1 == val2);
}

static void mark_dax(void *val)
{
  dax *o = (dax *)val;
  if (o) s7_mark_object(o-&gt;data);
}

static int dax_type_tag = 0;

static s7_pointer make_dax(s7_scheme *sc, s7_pointer args)
{
  dax *o;
  o = (dax *)malloc(sizeof(dax));
  o-&gt;x = s7_real(s7_car(args));
  if (s7_cdr(args) != s7_nil(sc))
    o-&gt;data = s7_car(s7_cdr(args));
  else o-&gt;data = s7_nil(sc);
  return(<em class=red>s7_make_object</em>(sc, dax_type_tag, (void *)o));
}

static s7_pointer is_dax(s7_scheme *sc, s7_pointer args)
{
  return(s7_make_boolean(sc, 
			 <em class=red>s7_is_object</em>(s7_car(args)) &amp;&amp;
			 <em class=red>s7_object_type</em>(s7_car(args)) == dax_type_tag));
}

static s7_pointer dax_x(s7_scheme *sc, s7_pointer args)
{
  dax *o;
  o = (dax *)<em class=red>s7_object_value</em>(s7_car(args));
  return(s7_make_real(sc, o-&gt;x));
}

static s7_pointer set_dax_x(s7_scheme *sc, s7_pointer args)
{
  dax *o;
  o = (dax *)s7_object_value(s7_car(args));
  o-&gt;x = s7_real(s7_car(s7_cdr(args)));
  return(s7_car(s7_cdr(args)));
}

static s7_pointer dax_data(s7_scheme *sc, s7_pointer args)
{
  dax *o;
  o = (dax *)s7_object_value(s7_car(args));
  return(o-&gt;data);
}

static s7_pointer set_dax_data(s7_scheme *sc, s7_pointer args)
{
  dax *o;
  o = (dax *)s7_object_value(s7_car(args));
  o-&gt;data = s7_car(s7_cdr(args));
  return(o-&gt;data);
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];

  s7 = s7_init();
  
  s7_define_function(s7, "exit", our_exit, 0, 0, false, "(exit) exits the program");
  s7_define_variable(s7, "*listener-prompt*", s7_make_string(s7, "&gt;"));

  dax_type_tag = <em class=red>s7_new_type</em>("dax", print_dax, free_dax, equal_dax, mark_dax, NULL, NULL);
  s7_define_function(s7, "make-dax", make_dax, 2, 0, false, "(make-dax x data) makes a new dax");
  s7_define_function(s7, "dax?", is_dax, 1, 0, false, "(dax? anything) returns #t if its argument is a dax object");

  s7_define_variable(s7, "dax-x", 
                     <em class=red>s7_make_procedure_with_setter</em>(s7, "dax-x", dax_x, 1, 0, set_dax_x, 2, 0, "dax x field"));

  s7_define_variable(s7, "dax-data", 
                     <em class=red>s7_make_procedure_with_setter</em>(s7, "dax-data", dax_data, 1, 0, set_dax_data, 2, 0, "dax data field"));

  while (1)
    {
      fprintf(stdout, "\n%s ", listener_prompt(s7));
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response); /* evaluate input and write the result */
	}
    }
}

/*
 *    &gt; *listener-prompt*
 *    "&gt;"
 *    &gt; (set! *listener-prompt* ":")
 *    ":"
 *    : (define obj (make-dax 1.0 (list 1 2 3)))
 *    obj
 *    : obj
 *    #&lt;dax 1.000 (1 2 3)&gt;
 *    : (dax-x obj)
 *    1.0
 *    : (dax-data obj)
 *    (1 2 3)
 *    : (set! (dax-x obj) 123.0)
 *    123.0
 *    : obj
 *    #&lt;dax 123.000 (1 2 3)&gt;
 *    : (dax? obj)
 *    #t
 *    : (exit)
 */
</pre>
</td></tr></table>



<br><br>
<A NAME="functionportexample"></a>
<p>Redirect output (and input) to a C procedure:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static void my_print(s7_scheme *sc, char c, s7_pointer port)
{
  fprintf(stderr, "[%c] ", c);
}

static s7_pointer my_read(s7_scheme *sc, s7_read_t peek, s7_pointer port)
{
  return(<em class=red>s7_make_character</em>(s7, fgetc(stdin)));
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];

  s7 = s7_init();  

  <em class=red>s7_set_current_output_port</em>(s7, <em class=red>s7_open_output_function</em>(s7, my_print));
  s7_define_variable(s7, "io-port", <em class=red>s7_open_input_function</em>(s7, my_read));

  while (1) 
    {
      fprintf(stdout, "\n&gt; ");
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response);
	}
    }
}

/* 
 *    &gt; (+ 1 2)
 *    [3]
 *    &gt; (display "hiho")
 *    [h] [i] [h] [o] [#] [&lt;] [u] [n] [s] [p] [e] [c] [i] [f] [i] [e] [d] [&gt;] 
 *    &gt; (define (add1 x) (+ 1 x))
 *    [a] [d] [d] [1] 
 *    &gt; (add1 123)
 *    [1] [2] [4] 
 *    &gt; (read-char io-port)
 *    a                             ; here I typed "a" in the shell
 *    [#] [\] [a] 
 */
</pre>
</td></tr></table>


<br><br>
<A NAME="extendop"></a>
<p>Extend a built-in operator ("+" in this case):
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer old_add;           /* the original "+" function for non-string cases */
static s7_pointer old_string_append; /* same, for "string-append" */

static s7_pointer our_add(s7_scheme *sc, s7_pointer args)
{
  /* this will replace the built-in "+" operator, extending it to include strings:
   *   (+ "hi" "ho") -&gt; "hiho" and  (+ 3 4) -&gt; 7
   */
  if ((s7_is_pair(args)) &amp;&amp;
      (s7_is_string(s7_car(args))))
    return(<em class=red>s7_apply_function</em>(sc, old_string_append, args));

  return(s7_apply_function(sc, old_add, args));
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];

  s7 = s7_init();

  /* get built-in + and string-append */
  old_add = s7_name_to_value(s7, "+");      
  old_string_append = s7_name_to_value(s7, "string-append");

  /* redefine "+" */
  s7_define_function(s7, "+", our_add, 0, 0, true, "(+ ...) adds or appends its arguments");

  while (1)
    {
      fprintf(stdout, "\n&gt; ");
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response);
	}
    }
}

/* 
 *    &gt; (+ 1 2)
 *    3
 *    &gt; (+ "hi" "ho")
 *    "hiho"
 */
</pre>
</td></tr></table>



<br><br>
<A NAME="definestar"></a>
<p>C-side define* (s7_define_function_star):
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer plus(s7_scheme *sc, s7_pointer args)
{
  /* (define* (plus (red 32) blue) (+ (* 2 red) blue)) */
  return(s7_make_integer(sc, 2 * s7_integer(s7_car(args)) + s7_integer(s7_car(s7_cdr(args)))));
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];

  s7 = s7_init();
  <em class=red>s7_define_function_star</em>(s7, "plus", plus, "(red 32) blue", "an example of define* from C");

  while (1)
    {
      fprintf(stdout, "\n&gt; ");
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response);
	}
    }
}

/* 
 *    &gt; (plus 2 3)
 *    7
 *    &gt; (plus :blue 3)
 *    67
 *    &gt; (plus :blue 1 :red 4)
 *    9
 *    &gt; (plus 2 :blue 3)
 *    7
 *    &gt; (plus :blue 3 :red 1)
 *    5
 */
</pre>
</td></tr></table>



<br><br>
<A NAME="definemacro"></a>
<p>C-side define-macro (s7_define_macro):
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer plus(s7_scheme *sc, s7_pointer args)
{
  /* (define-macro (plus a b) `(+ ,a ,b)) */
  s7_pointer a, b;
  a = s7_car(args);
  b = s7_car(s7_cdr(args));
  return(s7_cons(sc, s7_make_symbol(sc, "+"),  /* we are forming the list `(+ ,a ,b) */
	   s7_cons(sc, a,
	     s7_cons(sc, b, s7_nil(sc)))));
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];

  s7 = s7_init();
  <em class=red>s7_define_macro</em>(s7, "plus", plus, 2, 0, false, "plus adds its two arguments");

  while (1)
    {
      fprintf(stdout, "\n&gt; ");
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response);
	}
    }
}

/* 
 *    &gt; (plus 2 3)
 *    5
 */
</pre>
</td></tr></table>



<br><br>
<A NAME="signal"></a>
<p>Signal handling (C-C to break out of an infinite loop), and s7_make_continuation
to pick up where we were interrupted:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;signal.h&gt;

#include "s7.h"

static s7_scheme *s7;
struct sigaction new_act, old_act;  
  
static void handle_sigint(int ignored)  
{  
  fprintf(stderr, "interrupted!\n");
  s7_symbol_set_value(s7, s7_make_symbol(s7, "*interrupt*"), <em class=red>s7_make_continuation</em>(s7)); /* save where we were interrupted */
  sigaction(SIGINT, &amp;new_act, NULL);  
  s7_quit(s7);                             /* get out of the eval loop if possible */
}  

static s7_pointer our_exit(s7_scheme *sc, s7_pointer args)
{ 
  /* this function is really needed if we are trapping C-C! */
  exit(1);
  return(s7_f(sc));
}

static s7_pointer our_sleep(s7_scheme *sc, s7_pointer args)
{
  /* slow down out infinite loop for demo purposes */
  sleep(1);
  return(s7_f(sc));
}

int main(int argc, char **argv)
{
  char buffer[512];
  char response[1024];

  s7 = s7_init();
  s7_define_function(s7, "exit", our_exit, 0, 0, false, "(exit) exits");
  s7_define_function(s7, "sleep", our_sleep, 0, 0, false, "(sleep) sleeps");
  s7_define_variable(s7, "*interrupt*", s7_f(s7)); 
  /* scheme variable *interrupt* holds the continuation at the point of the interrupt */

  sigaction(SIGINT, NULL, &amp;old_act);
  if (old_act.sa_handler != SIG_IGN)
    {
      memset(&amp;new_act, 0, sizeof(new_act));  
      new_act.sa_handler = &amp;handle_sigint;  
      sigaction(SIGINT, &amp;new_act, NULL);  
    }

  while (1)
    {
      fprintf(stderr, "\n&gt; ");
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response);
	}
    }
}

/*
 *    &gt; (do ((i 0 (+ i 1))) ((= i -1)) (format #t "~D " i) (sleep))
 *      ;;; now type C-C to break out of this loop
 *    0 1 2 ^Cinterrupted!
 *      ;;; call the continuation to continue from where we were interrupted
 *    &gt; (*interrupt*)
 *    3 4 5 ^Cinterrupted!
 *    &gt; *interrupt*
 *    #&lt;continuation&gt;
 *    &gt; (+ 1 2)
 *    3
 */
</pre>
</td></tr></table>



<br><br>
<A NAME="vector"></a>
<p>Multidimensional vector element access:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdarg.h&gt;

#include "s7.h"

static s7_pointer multivector_ref(s7_scheme *sc, s7_pointer vector, int indices, ...)
{
  /* multivector_ref returns an element of a multidimensional vector */
  int ndims;
  ndims = <em class=red>s7_vector_rank</em>(vector);

  if (ndims == indices)
    {
      va_list ap;
      s7_Int index = 0;
      va_start(ap, indices);

      if (ndims == 1)
	{
	  index = va_arg(ap, s7_Int);
	  va_end(ap);
	  return(s7_vector_ref(sc, vector, index));
	}
      else
	{
	  int i;
	  s7_pointer *elements;
	  s7_Int *offsets, *dimensions;

	  elements = <em class=red>s7_vector_elements</em>(vector);
	  dimensions = <em class=red>s7_vector_dimensions</em>(vector);
	  offsets = <em class=red>s7_vector_offsets</em>(vector);

	  for (i = 0; i &lt; indices; i++)
	    {
	      int ind;
	      ind = va_arg(ap, int);
	      if ((ind &lt; 0) ||
		  (ind &gt;= dimensions[i]))
		{
		  va_end(ap);
		  return(s7_out_of_range_error(sc, 
                                               "multivector_ref", i, 
                                               s7_make_integer(sc, ind), 
                                               "index should be between 0 and the dimension size"));
		}
	      index += (ind * offsets[i]);
	    }
	  va_end(ap);
	  return(elements[index]);
	}
    }
  return(s7_wrong_number_of_args_error(sc, 
                                       "multivector_ref: wrong number of indices: ~A", 
                                       s7_make_integer(sc, indices)));
}

int main(int argc, char **argv)
{
  char buffer[512];
  char response[1024];
  s7_scheme *s7;

  s7 = s7_init(); 
  s7_eval_c_string(s7, "(define vect (make-vector '(2 3 4) 0))");
  s7_eval_c_string(s7, "(set! (vect 1 1 1) 32)");

  fprintf(stdout, "vect[0,0,0]: %s, vect[1,1,1]: %s\n",
	  s7_object_to_c_string(s7, <em class=red>multivector_ref</em>(s7, s7_name_to_value(s7, "vect"), 3, 0, 0, 0)),
	  s7_object_to_c_string(s7, <em class=red>multivector_ref</em>(s7, s7_name_to_value(s7, "vect"), 3, 1, 1, 1)));
}

/* vect[0,0,0]: 0, vect[1,1,1]: 32
 */
</pre>
</td></tr></table>



<br><br>
<A NAME="notify"></a>
<p>Notification from Scheme that a given scheme variable has been set.
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer my_exit(s7_scheme *sc, s7_pointer args) {exit(0);}

static s7_pointer scheme_set_notification(s7_scheme *sc, s7_pointer args)
{
  /* this function is called when the scheme variable is set! */
  fprintf(stderr, "%s set to %s\n",
	  s7_object_to_c_string(sc, s7_car(args)),
	  s7_object_to_c_string(sc, s7_car(s7_cdr(args))));
  return(s7_car(s7_cdr(args)));
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  s7 = s7_init();  
  s7_define_function(s7, "exit", my_exit, 0, 0, false, "(exit) exits the program");

  s7_define_function(s7, "notify-C", scheme_set_notification, 2, 0, false, "called if notified-var is set!");
  s7_define_variable(s7, "notified-var", s7_make_integer(s7, 0));
  <em class=red>s7_symbol_set_access</em>(s7,   /* set symbol-access of notified-var to (list #f notify-C #f) */
		       s7_make_symbol(s7, "notified-var"),
		       s7_cons(s7, 
			       s7_f(s7), 
			       s7_cons(s7, 
				       s7_name_to_value(s7, "notify-C"), 
				       s7_cons(s7, 
					       s7_f(s7),
					       s7_nil(s7)))));

  if (argc == 2)
    {
      fprintf(stderr, "load %s\n", argv[1]);
      s7_load(s7, argv[1]);
    }
  else
    {
      char buffer[512];
      char response[1024];
      while (1) 
	{
	  fprintf(stdout, "\n&gt; ");
	  fgets(buffer, 512, stdin);
	  
	  if ((buffer[0] != '\n') || 
	      (strlen(buffer) &gt; 1))
	    {                            
	      sprintf(response, "(write %s)", buffer);
	      s7_eval_c_string(s7, response);
	    }
	}
    }
}

/*    &gt; notified-var
 *    0
 *    &gt; (set! notified-var 32)
 *    notified-var set to 32
 *    32
 */
</pre>
</td></tr></table>


<br><br>
<A NAME="namespace"></a>
<p>Load C defined stuff into a separate namespace.
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer my_exit(s7_scheme *sc, s7_pointer args) {exit(0);}

static s7_pointer func1(s7_scheme *sc, s7_pointer args)
{
  return(s7_make_integer(sc, s7_integer(s7_car(args)) + 1));
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  s7_pointer new_env;

  s7 = s7_init();  
  s7_define_function(s7, "exit", my_exit, 0, 0, false, "(exit) exits the program");

  /* "func1" and "var1" will be placed in an anonymous environment,
   *   accessible from Scheme via the global variable "lib-exports"
   */
  
  new_env = <em class=red>s7_augment_environment</em>(s7, s7_cons(s7, s7_current_environment(s7), s7_nil(s7)), s7_nil(s7));
  /* make a private environment for func1 and var1 below (this is our "namespace") */
  s7_gc_protect(s7, new_env);

  s7_define(s7, <em class=red>new_env</em>, 
	    s7_make_symbol(s7, "func1"),
	    <em class=red>s7_make_function</em>(s7, "func1", func1, 1, 0, false, "func1 adds 1 to its argument"));
  
  s7_define(s7, <em class=red>new_env</em>, s7_make_symbol(s7, "var1"), s7_make_integer(s7, 32));
  /* those two symbols are now defined in the new environment */

  /* add "lib-exports" to the global environment */
  s7_define_variable(s7, "lib-exports", s7_car(new_env));

  if (argc == 2)
    {
      fprintf(stderr, "load %s\n", argv[1]);
      s7_load(s7, argv[1]);
    }
  else
    {
      char buffer[512];
      char response[1024];
      while (1) 
	{
	  fprintf(stdout, "\n&gt; ");
	  fgets(buffer, 512, stdin);
	  
	  if ((buffer[0] != '\n') || 
	      (strlen(buffer) &gt; 1))
	    {                            
	      sprintf(response, "(write %s)", buffer);
	      s7_eval_c_string(s7, response);
	    }
	}
    }
}

/*     &gt; func1
 *     ;func1: unbound variable, line 1
 *     &gt; lib-exports
 *     ((var1 . 32) (func1 . func1))
 *     ;; so lib-exports has the C-defined names and values
 *     ;; we can use these directly:
 *
 *     &gt; (define lib-env (apply <em class=red>augment-environment</em> (current-environment) lib-exports))
 *     lib-env
 *     &gt; (<em class=red>with-environment</em> lib-env (func1 var1))
 *     33
 *
 *     ;; or rename them to prepend "lib:"
 *     &gt; (define lib-env (apply augment-environment 
                                (current-environment) 
                                (map (lambda (binding) 
                                       (cons (string-&gt;symbol 
                                               (string-append "lib:" (symbol-&gt;string (car binding)))) 
                                             (cdr binding))) 
                                     lib-exports)))
 *     lib-env
 *     &gt; (with-environment lib-env (lib:func1 lib:var1))
 *     33
 *
 *     ;;; now for convenience, place "func1" in the global environment under the name "func2"
 *     &gt; (define func2 (cdadr lib-exports)) 
 *     func2
 *     &gt; (func2 1)  
 *     2
 */
</pre>
</td></tr></table>



<br><br>
<A NAME="Cerrors"></a>
<p>Handle scheme errors in C.
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer my_exit(s7_scheme *sc, s7_pointer args) {exit(0);}

static s7_pointer error_handler(s7_scheme *sc, s7_pointer args)
{
  /* put &lt;&lt;&gt;&gt; around the string so it's obvious who is producing what */

  fprintf(stdout, "&lt;&lt;%s&gt;&gt;", s7_string(s7_car(args)));
  return(s7_make_symbol(sc, "our-error"));
}


int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];
  bool with_error_hook = false;

  s7 = s7_init();  
  s7_define_function(s7, "exit", my_exit, 0, 0, false, "(exit) exits the program");
  s7_define_function(s7, "error-handler", error_handler, 1, 0, false, "our error handler");

  if (with_error_hook)
    s7_eval_c_string(s7, "(set! *error-hook*                               \n\
                            (lambda (tag args)                             \n\
                              (error-handler                               \n\
                                (apply format #f (car args) (cdr args)))))");

  while (1) 
    {
      fprintf(stdout, "\n&gt; ");
      fgets(buffer, 512, stdin);
	  
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  s7_pointer old_port, result;
	  int gc_loc = -1;
	  const char *errmsg = NULL;

	  /* trap error messages */
	  old_port = s7_set_current_error_port(s7, s7_open_output_string(s7));
	  if (old_port != s7_nil(s7))
	    gc_loc = s7_gc_protect(s7, old_port);

	  /* evaluate the input string */
	  result = s7_eval_c_string(s7, buffer);

	  /* print out the value wrapped in "{}" so we can tell it from other IO paths */
	  fprintf(stdout, "{%s}", s7_object_to_c_string(s7, result));

	  /* look for error messages */
	  errmsg = s7_get_output_string(s7, s7_current_error_port(s7));

	  /* if we got something, wrap it in "[]" */
	  if ((errmsg) && (*errmsg))
	    fprintf(stdout, "[%s]", errmsg); 

	  s7_close_output_port(s7, s7_current_error_port(s7));
	  s7_set_current_error_port(s7, old_port);
	  if (gc_loc != -1)
	    s7_gc_unprotect_at(s7, gc_loc);
	}
    }
}

/* 
 *   gcc -c s7.c -I. -g3
 *   gcc -o ex3 ex3.c s7.o -lm -I.
 *
 * if with_error_hook is false,
 *
 *   &gt; (+ 1 2)
 *   {3}
 *   &gt; (+ 1 #\c)
 *   {wrong-type-arg}[
 *   ;+ argument 2, #\c, is character but should be a number, line 1
 *   ]
 *
 * so s7 by default prepends ";" to the error message, and appends "\n",
 *   sending that to current-error-port, and the error type ('wrong-type-arg here)
 *   is returned.
 *
 * if with_error_hook is true,
 *
 *   &gt; (+ 1 2)
 *   {3}
 *   &gt; (+ 1 #\c)
 *   &lt;&lt;+ argument 2, #\c, is character but should be a number&gt;&gt;{our-error}
 *
 * so now the *error-hook* code handles both the error reporting and
 *   the value returned ('our-error in this case).
 */
</pre>
</td></tr></table>

<br><br>



</body>
</html>
