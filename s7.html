<html>
<!-- documentation for s7 -->

<head>
<title>s7</title>
<style type="text/css">
<!-- 
	EM.red {color:red; font-style:normal}
        EM.error {color:chocolate; font-style:normal}
        EM.typing {color:maroon; font-style: normal}
        EM.listener {color:darkblue; font-style: normal}
	EM.emdef {font-weight: bold; font-style: normal}
	H1 {text-align: center}
	UL {list-style-type: none}

	A {text-decoration:none}
	A:hover {text-decoration:underline}
	A.quiet {color:black; text-decoration:none}
	A.quiet:hover {text-decoration:underline}
	A.def {font-weight: bold; font-style: normal; text-decoration:none; text-color:black}

	EM.green {color:green; font-style:normal}
-->

</style>
</head>
<body bgcolor=white>

<!-- INDEX s7doc:s7 scheme -->


<br>

<table border=0 bordercolor="lightgreen" width=100% cellpadding=2 cellspacing=0><tr><td bgcolor="lightgreen">
<A NAME="s7doc"></a>
<table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>s7</h2></td></tr></table>
</td></tr></table>


<p>s7 is a Scheme implementation intended as an extension language
for other applications, primarily Snd and Common Music.  It exists as just two files, s7.c and
s7.h, that want only to disappear into someone else's source tree.  There are no libraries,
no run-time init files, and no configuration scripts.
It can be built as a stand-alone
interpreter (see <a href="#repl">below</a>).  s7test.scm is a regression test for s7.
A tarball is available: ftp://ccrma-ftp.stanford.edu/pub/Lisp/s7.tar.gz.  
</p>

<p>
s7 is the default extension language of Snd and sndlib (http://ccrma.stanford.edu/software/snd/),
and Rick Taube's Common Music (commonmusic at sourceforge).  There are X, Motif, Gtk, and openGL bindings
in libxm in the Snd tarball, or at ftp://ccrma-ftp.stanford.edu/pub/Lisp/libxm.tar.gz.
If you're running s7 in a context
that has getenv, file-exists?, and system (Snd for example), you can use s7-slib-init.scm
to gain easy access to slib.  This init file is named "s7.init" in the slib distribution.
</p>

<p>Although it is a descendant of tinyScheme, s7 is closest as a Scheme dialect to Guile 1.8.
I believe it is compatible with r5rs:  you can just ignore all the additions discussed in this file.
It has continuations, 
ratios, complex numbers,
macros, keywords, hash-tables, 
multiprecision arithmetic,
generalized set!, and so on.
It does not have syntax-rules or any of
its friends, and it does not think there is any such thing
as an inexact integer.  
</p>

<p>This file assumes you know about Scheme and all its problems,
and want a quick tour of where s7 is different.  (Well, it was quick once upon a time).
</p>

<ul>
  <li><a href="#multiprecision">multiprecision arithmetic</a>
  <li><a href="#math">math functions</a>
  <li><a href="#define*">define*</a>
  <li><a href="#macros">define-macro</a>
  <li><a href="#constants">define-constant, symbol-access</a>
  <li><a href="#maketype1">make-type</a>
  <li><a href="#pws">procedure-with-setter</a>
  <li><a href="#generalizedset">generalized set!</a>
  <li><a href="#multidimensionalvectors">multidimensional vectors</a>
  <li><a href="#hashtables">hash tables</a>
  <li><a href="#hooks">hooks</a>
  <li><a href="#multiplevalues">multiple-values</a>
  <li><a href="#callwithexit1">call-with-exit</a>
  <li><a href="#format1">format</a>
  <li><a href="#errors">errors, stacktrace, trace</a>
  <li><a href="#procedureinfo">procedure info</a>
  <li><a href="#environments">environments</a>
  <li><a href="#evalstring">eval</a>
  <li><a href="#IO">string IO</a>
  <li><a href="#miscellanea">miscellanea</a>
  <li><a href="#s7rundoc">the run macro</a>
  <li><a href="#FFIexamples">FFI examples</a>
  <ul>
      <li><a href="#repl">read-eval-print loop (and emacs)</a>
      <li><a href="#defun">define a function with arguments and a returned value, and define a variable </a>
      <li><a href="#defvar">call a Scheme function from C, and get/set Scheme variable values in C</a>
      <li><a href="#juce">C++ and Juce</a>
      <li><a href="#sndlib">load sndlib using the XEN functions and macros</a>
      <li><a href="#pwstype">add a new Scheme type and a procedure-with-setter</a>
      <li><a href="#functionportexample">redirect display output to a C procedure</a>
      <li><a href="#extendop">extend a built-in operator ("+" in this case)</a>
      <li><a href="#definestar1">C-side define* (s7_define_function_star)</a>
      <li><a href="#definemacro1">C-side define-macro (s7_define_macro)</a>
      <li><a href="#signal">signal handling (C-C to break out of an infinite loop)</a>
      <li><a href="#vector">direct multidimensional vector element access</a>
      <li><a href="#notify">notification in C that a Scheme variable has been set!</a>
      <li><a href="#namespace">Load C defined stuff into a separate namespace</a>
      <li><a href="#Cerrors">Error handling in C</a>
      <li><a href="#closure">Closure defined in C</a>
      <li><a href="#testhook">Hooks in C and Scheme</a>
      <li><a href="#cload">Load a C module dynamically</a>
      <li><a href="#gmpex">gmp and friends</a>
      <li><a href="#gtkrepl">Gtk-based REPL</a>
      <li><a href="#gtkschemerepl">Gtk/Scheme-based REPL</a>
      <li><a href="#s7inathread">s7 running in a separate thread</a>
      <li><a href="#replrescue">begin_hook to the rescue!</a>
  </ul>
</ul>

<br>
<dl>

<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="multiprecision"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>multiprecision arithmetic</h4></td></tr></table>
</td></tr></table>
</dt>

<dd>
<p>All numeric types, integers, ratios, reals, and complex numbers are supported.
The basic integer and real
types are defined in s7.h, defaulting to long long int and double.  
pi is predefined, as are
most-positive-fixnum and most-negative-fixnum.
s7 can be built with multiprecision support 
for all types,  using the gmp, mpfr, and mpc libraries (set WITH_GMP to 1 in s7.c).  
If multiprecision arithmetic is
enabled, the following functions are included: bignum, bignum?, and bignum-precision.
<a name="bignumprecision">bignum-precision</a>, which defaults to 128, sets the number of bits each float takes.
pi automatically reflects the current bignum-precision:
</p>

<pre>
&gt; pi
3.141592653589793238462643383279502884195E0

&gt; (bignum-precision)
128

&gt; (set! (bignum-precision) 256)
256

&gt; pi
3.141592653589793238462643383279502884197169399375105820974944592307816406286198E0
</pre>

<p>
<a name="bignump">bignum?</a> returns #t if its argument is a big number of some type; I use "bignum" 
for any big number, not just integers.  To create a big number,
either include enough digits to overflow the default types, or use the <a name="bignum">bignum</a> function.
Its argument is a string representing the desired number:
</p>

<pre>
&gt; (bignum "123456789123456789")
123456789123456789

&gt; (bignum "1.123123123123123123123123123")
1.12312312312312312312312312300000000009E0
</pre>

<small>
<blockquote>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>In the non-gmp case, if s7 is built using doubles (s7_Double in s7.h), the float "epsilon" is
around (expt 2 -53), or about 1e-16.  In the gmp case, it is around (expt 2 (- (bignum-precision))).
So in the default case (precision = 128), using gmp:
</p>

<pre>
&gt; (= 1.0 (+ 1.0 (expt 2.0 -128)))
#t
&gt; (= 1.0 (+ 1.0 (expt 2.0 -127)))
#f
</pre>

<p>and in the non-gmp case:
</p>

<pre>
&gt; (= 1.0 (+ 1.0 (expt 2 -53)))
#t
&gt; (= 1.0 (+ 1.0 (expt 2 -52)))
#f
</pre>

<p>In the gmp case, integers and ratios are limited only by the size of memory,
but reals are limited by bignum-precision.  This means, for example, that
</p>

<pre>
&gt; (floor 1e56) ; bignum-precision is 128
99999999999999999999999999999999999999927942405962072064
&gt; (set! (bignum-precision) 256)
256
&gt; (floor 1e56)
100000000000000000000000000000000000000000000000000000000
</pre>

<p>The non-gmp case is similar, but it's easy to find the edge cases:
</p>

<pre>
&gt; (floor (+ 0.9999999995 (expt 2.0 23)))
8388609
</pre>

</blockquote>
</small>


</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="math"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>math functions</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>
s7 includes:
</p>

<ul>
<li>sinh, cosh, tanh, asinh, acosh, atanh
<li>logior, logxor, logand, lognot, ash, integer-length, integer-decode-float
<li>random
<li>nan?, infinite?
</ul>

<p>
The random function can take any numeric argument, including 0.
The following constants are predefined: pi, most-positive-fixnum, most-negative-fixnum.
Other math-related differences between s7 and r5rs:
</p>

<ul>
<li>rational? and exact mean integer or ratio (i.e. not floating point), inexact means not exact.
<li>floor, ceiling, truncate, and round return (exact) integer results.
<li>"#" does not stand for an unknown digit.
<li>the "@" complex number notation is not supported.
<li>"+i" is not considered a number; include the real part.
<li>modulo, remainder, and quotient take integer, ratio, or real arguments.
<li>lcm and gcd can take integer or ratio arguments.
<li>log takes an optional second argument, the base.
<li>'.' and an exponent can occur in a number in any base.
<li>rationalize returns a ratio! 
</ul>

<pre>
&gt; (exact? 1.0)
#f
&gt; (rational? 1.5)
#f
&gt; (floor 1.4)
1
&gt; (remainder 2.4 1)
0.4
&gt; (modulo 1.4 1.0)
0.4
&gt; (lcm 3/4 1/6)
3/2
&gt; (log 8 2)
3
&gt; (number-&gt;string 0.5 2)
"0.1"
&gt; (string-&gt;number "0.1" 2)
0.5
&gt; (rationalize 1.5)
3/2
&gt; (make-rectangular 1/2 0)
1/2
</pre>

<small>
<blockquote>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>The exponent itself is always in base 10; this follows gmp usage.
Since Scheme uses "@" for its useless polar notation, s7 doesn't use it for the exponent marker, but that
means <code>(string-&gt;number "1e1" 16)</code> is ambiguous &mdash; is the "e" a digit or an exponent marker?
s7 could perhaps substitute "s" in this case, but instead it just prohibits exponents if the
radix is greater than 10.
</p>

<pre>
&gt; (string-&gt;number "1e9" 2)  ; (expt 2 9)
512.0
&gt; (string-&gt;number "1e1" 12) ; "e" is not a digit in base 12
#f
&gt; (string-&gt;number "1e1" 16) ; (+ (* 1 16 16) (* 14 16) 1)
481
&gt; (string-&gt;number "1.2e1" 3); (* 3 (+ 1 2/3))
5.0
</pre>

<p>Perhaps s7 should use "@"!
</p>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Should s7 predefine the numbers +inf.0, -inf.0, and nan.0?  It doesn't currently, but you can
get them via log:
</p>

<pre>
(define -inf.0 (real-part (log 0.0)))
(define +inf.0 (- (real-part (log 0.0))))
(define nan.0 (/ +inf.0 +inf.0))
</pre>

<p>But what is <code>(/ 1.0 0.0)</code>?  s7 gives a "division by zero" error here, and also in <code>(/ 1 0)</code>.
Guile returns +inf.0 in the first case, which seems reasonable, but a "numerical overflow" error in the second.
Slightly weirder is <code>(expt 0.0 0+i)</code>.  Currently s7 returns 0.0, Guile returns +nan.0+nan.0i,
Clisp and sbcl throw an error.  Everybody agrees that <code>(expt 0 0)</code> is 1, and Guile thinks
that <code>(expt 0.0 0.0)</code> is 1.0.  But <code>(expt 0 0.0)</code> and <code>(expt 0.0 0)</code> return different
results in Guile (1 and 1.0), both are 0.0 in s7, the first is an error in Clisp, but the second returns 1,
and so on &mdash; what a mess!  This mess was made a lot worse than it needs to be when the IEEE decreed that
0.0 equals -0.0, so we can't tell them apart, but that they produce different results in nearly every use!  
</p>

<pre>
scheme@(guile-user)&gt; (= -0.0 0.0)
#t
scheme@(guile-user)&gt; (negative? -0.0)
#f
scheme@(guile-user)&gt; (= (/ 1.0 0.0) (/ 1.0 -0.0))
#f
scheme@(guile-user)&gt;  (&lt; (/ 1.0 -0.0) -1e100 1e100 (/ 1.0 0.0))
#t
</pre>

<p>
How can they be equal? In s7, the sign
of -0.0 is ignored, and they really are equal.
</p>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>The <a name="random">random</a> function takes a range and an optional state, and returns a number 
between zero and the range, of the same type as the range.  It is perfectly reasonable
to use a range of 0, in which case random returns 0.
<a name="makerandomstate">make-random-state</a> creates a new random state from a seed.  If no state is passed,
random uses some default state initialized from the current time.
</p>

<pre>
&gt; (random 0)
0
&gt; (random 1.0)
0.86331198514245
&gt; (random 3/4)
654/1129
&gt; (random 1+i)
0.86300308872748+0.83601002730848i
&gt; (random -1.0)
-0.037691127513267
&gt; (define r0 (make-random-state 1234))
r0
&gt; (random 100 r0)
94
&gt; (random 100 r0)
19
&gt; (define r1 (make-random-state 1234))
r1
&gt; (random 100 r1)
94
&gt; (random 100 r1)
19
</pre>

<p>copy the random-state to save a spot in a random number sequence, or save the random-state as a list via
random-state-&gt;list, then to restart from that point, apply make-random-state to that list.
</p>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<pre>
(define (log-n-of n . ints)     ; return the bits on in exactly n of ints
  (let ((len (length ints)))
    (cond ((= len 0) (if (= n 0) -1 0))
	  ((= n 0)   (lognot (apply logior ints)))
	  ((= n len) (apply logand ints))
	  ((&gt; n len) 0)
	  (#t 
	   (do ((1s 0)
		(prev ints)
		(i 0 (+ i 1)))
	       ((= i len) 1s)
	     (let ((cur (ints i)))
	       (if (= i 0)
		   (set! 1s (logior 1s (logand cur (apply log-n-of (- n 1) (cdr ints)))))
		   (let* ((mid (cdr prev))
			  (nxt (if (= i (- len 1)) '() (cdr mid))))
		     (set! (cdr prev) nxt)  
		     (set! 1s (logior 1s (logand cur (apply log-n-of (- n 1) ints))))
		     (set! (cdr prev) mid)
		     (set! prev mid)))))))))
</pre>

<!-- since set-cdr! is so useful, it's too bad we can't do something similar with any sequence:
    apply a function to a truncated portion of a sequence (a vector for example).  Currently
    we'd need subvector->list; what about subvector/sublist? subsequence?
-->

</blockquote>
</small>

</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="define*"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>define*, lambda*</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p><a name="definestar">define*</a> and <a name="lambdastar">lambda*</a>
are extensions of define and lambda that make it easier to
to deal with optional, keyword, and rest arguments.  
The syntax is very simple: every argument to define* has a default value
and is automatically available as a keyword argument.  The default value
is either #f if unspecified, or given in a list whose first member is
the argument name.
The last argument
can be preceded by :rest or a dot to indicate that all other trailing arguments
should be packaged as a list under that argument's name.  A trailing or rest
argument's default value is '().
You can use
:optional and :key, but they are ignored.  
</p>

<pre>
(<em class=red>define*</em> (hi a (b 32) (c "hi")) (list a b c))
</pre>

<p>Here the argument "a" defaults to #f, "b" to 32, etc.
When the function is called, 
the argument names are bound to their default values, then the function's
current argument list is scanned.  Any name that occurs as a keyword, :arg for example where the parameter name is arg,
sets that argument's new value.  Otherwise, as values occur, they
are plugged into the actual argument list based on their position, counting a keyword/value pair as one argument.
This is called an optional-key list in CLM.  So, taking the function
above as an example:
</p>

<pre>
(hi 1) -&gt; '(1 32 "hi")
(hi :b 2 :a 3) -&gt; '(3 2 "hi")
(hi 3 2 1) -&gt; '(3 2 1)
</pre>

<p>See s7test.scm for many examples.
</p>

<pre>
(<em class=red>define*</em> (make-parameter initial-value converter)
  (let ((value (if (procedure? converter) (converter initial-value) initial-value)))
    (<em class=red>lambda*</em> ((val #&lt;unspecified&gt;))
      (if (not (eq? val #&lt;unspecified&gt;))
	  (set! value (if (procedure? converter) (converter val) val)))
      value)))

&gt; (define hiho (make-parameter 12))
hiho
&gt; (hiho)
12
&gt; (hiho 32)
32
&gt; (hiho)
32
</pre>

<small>
<blockquote>
<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>If you want a version of define* that insists
that any arguments before the keyword :optional are required:
</p>

<pre>
(define-macro (define** declarations . forms)
  (let ((name (car declarations))
	(args (cdr declarations)))
    (define (position thing lst count)
      (if (or (null? lst)
	      (not (pair? (cdr lst)))) ; for dotted arg = "rest" arg
	  #f
	  (if (eq? thing (car lst))
	      count
	      (position thing (cdr lst) (+ count 1)))))
    (let ((required-args (position :optional args 0)))
      (if required-args
	  `(define* (,name . func-args)
	     (if (&lt; (length func-args) ,required-args)
		 (error "~A requires ~D argument~A: ~A" 
			',name ,required-args 
                        (if (&gt; ,required-args 1) "s" "") 
                        func-args)
		 (apply (lambda* ,args ,@forms) func-args)))
	  `(define* ,declarations ,@forms)))))

&gt; (define** (hi a :optional (b 23)) (list a b))
hi
&gt; (hi 1)
(1 23)
&gt; (hi)
;hi requires 1 argument: ()
</pre>

<!--
  perhaps if :optional occurs in the arglist, make the preceding ones required by changing the arity?
-->

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>If a define* argument's default value is an expression, it is evaluated in the definition environment at
the time of the procedure call:
</p>

<pre>
(let ((c 1))
  (define* (a (b (+ c 1))) b)
  (set! c 2)
  (let ((c 123))
    (a))) ; (+ c 1) here is (+ 2 1) so this returns 3
</pre>

<p>Since the expression is not evaluated until the procedure is called, it is ok
to use variables that are undefined at the definition point:
</p>

<pre>
&gt; (define* (a (b c)) b)
a
&gt; c
;c: unbound variable
&gt; (define c 123)
c
&gt; (a)
123
</pre>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>To try to catch what I believe are usually mistakes, I added two
error checks.  One is triggered if you set the same parameter twice
in the same call, and the other if an unknown keyword is encountered
in the key position.  These problems arise in a case such as
</p>

<pre>
(define* (f (a 1) (b 2)) (list a b))
</pre>

<p>You could do any of the following by accident:
</p>

<pre>
(f 1 :a 2)  ; what is a?
(f :b 1 2)  ; what is b?
(f :c 3)    ; did you really want a to be :c and b to be 3?
</pre>

<p>In the last case, to pass a keyword deliberately, either include the
argument keyword: <code>(f :a :c)</code>, or make the default value a keyword:
<code>(define* (f (a :c) ...))</code>.
To turn off this error check, add :allow-other-keys at the end of the parameter list.
</p>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>s7's lambda* arglist handling is not the same as CL's lambda-list.  First,
you can have more than one :rest parameter:
</p>

<pre>
&gt; ((lambda* ((a 1) :rest b :rest c) (list a b c)) 1 2 3 4 5)
(1 (2 3 4 5) (3 4 5))
</pre>

<p>and second, the rest parameter, if any, takes up an argument slot just like any other
argument:
</p>

<pre>
&gt; ((lambda* ((b 3) :rest x (c 1)) (list b c x)) 32)
(32 1 ())

&gt; ((lambda* ((b 3) :rest x (c 1)) (list b c x)) 1 2 3 4 5)
(1 3 (2 3 4 5))
</pre>

<p>CL would agree with the first case if we used &amp;key for 'c', but would give an error in the second.
Of course, the major difference is that s7 keyword arguments don't insist that the key be present.
The :rest argument is needed in cases like these because we can't use expression
such as:
</p>

<pre>
&gt; ((lambda* ((a 3) . b c) (list a b c)) 1 2 3 4 5)
stray dot?
</pre>

<p>Yet another nit: the :rest argument is not considered a keyword argument, so
</p>

<pre>
&gt; (define* (f :rest a) a)
f
&gt; (f :a 1)
(:a 1)
</pre>

</blockquote>
</small>

</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="macros"></a>
<table border=0 bordercolor="lightgreen" width=80% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>macros</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p><a name="definemacro">define-macro</a>, <a name="definemacrostar">define-macro*</a>, 
defmacro, defmacro*, <a name="macroexpand">macroexpand</a>, <a name="gensym">gensym</a>, and <a name="macrop">macro?</a>
implement the standard (CL-style) macro definers.  
</p>

<pre>
(define-macro (add-1 arg) `(+ 1 ,arg))
(defmacro add-1 (arg) `(+ 1 ,arg))
</pre>

<p>macroexpand can help debug a macro:
</p>

<pre>
&gt; (define-macro (add-1 arg) `(+ 1 ,arg))
add-1
&gt; (macroexpand (add-1 32))
(+ 1 32)
</pre>

<p>gensym returns a symbol that is guaranteed to be unused.  It takes an optional string argument
giving the new symbol name's prefix.
</p>

<pre>
(defmacro pop! (sym)
  (let ((v (<em class=red>gensym</em>)))
    `(let ((,v (car ,sym)))
       (set! ,sym (cdr ,sym))
       ,v)))
</pre>

<p>As in define*, the starred forms give optional and keyword arguments:
</p>

<pre>
&gt; (define-macro* (add-2 a (b 2)) `(+ ,a ,b))
add-2
&gt; (add-2 1 3)
4
&gt; (add-2 1)
3
&gt; (add-2 :b 3 :a 1)
4
</pre>

<p>See s7test.scm for many examples including such perennial favorites as
when, loop, dotimes, do*, enum, pushnew, and defstruct.
</p>

<p>macro? returns #t if its argument is a macro or a symbol whose value is a macro.
We can use it, and other macro-related stuff to make a version of macroexpand-all:
</p>

<pre>
(define-macro (fully-expand form)
  (define (expand form)
    (if (pair? form)
	(if (<em class=red>macro?</em> (car form))
	    (expand ((eval (procedure-source (car form))) form))
	    (cons (expand (car form))
		  (expand (cdr form))))
	form))
  (expand form))

&gt; (define-macro (hi a) `(+ 1 ,a))
hi
&gt; (define-macro (ha c) `(hi (+ ,c 1)))
ha
&gt; (fully-expand (define (ho b) (+ 1 (ha b))))
ho
&gt; (procedure-source ho)
(lambda (b) (+ 1 (+ 1 (+ b 1))))
</pre>

<p>fully-expand expands each macro it encounters by using the
procedure-source of that macro, that is, the function that the macro definition
expanded into:
</p>

<pre>
(define-macro (hi a) `(+ ,a 1))

&gt; (procedure-source hi)
(lambda ({defmac}-18) (apply (lambda (a) ({list} '+ a 1)) (cdr {defmac}-18)))
</pre>

<small>
<blockquote>
<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>I hesitate to mention this, but macros are first-class entities in s7.  You can
pass one as a function argument, apply it to a list, return it from a function,
and assign it to a variable:
</p>

<pre>
&gt; (define-macro (hi a) `(+ ,a 1))
hi
&gt; (apply hi '(4))
5
&gt; (define (fmac mac) (apply mac '(4)))
fmac
&gt; (fmac hi)
5
&gt; (define (fmac mac) (mac 4))
fmac
&gt; (fmac hi)
5
&gt; (define (make-mac)
    (define-macro (hi a) `(+ ,a 1))
    hi)
make-mac

&gt; (let ((x (make-mac)))
    (x 2))
3
</pre>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Backquote (quasiquote) in s7 is almost trivial.  Constants are unchanged, symbols are quoted,
",arg" becomes "arg", and ",@arg" becomes "(apply values arg)" &mdash; hooray for real multiple values!
It's almost as easy to write the actual macro body as the backquoted version of it. 
</p>

<pre>
&gt; (define-macro (hi a) `(+ 1 ,a))
hi
&gt; (procedure-source hi)
(lambda ({defmac}-16) (apply (lambda (a) <em class=red>({list} '+ 1 a))</em> (cdr {defmac}-16)))

;; so (define-macro (hi a) ({list} + 1 a)) is the same

&gt; (define-macro (hi a) `(+ 1 ,@a))
hi
&gt; (procedure-source hi)
(lambda ({defmac}-17) (apply (lambda (a) <em class=red>({list} '+ 1 ({apply} {values} a)))</em> (cdr {defmac}-17)))

;; same: (define-macro (hi a) ({list} + 1 ({apply} {values} a)))

&gt; (define-macro (hi a) ``(+ 1 ,,a))
hi
&gt; (procedure-source hi)
(lambda ({defmac}-18) (apply (lambda (a) <em class=red>({list} '{list} ({list} 'quote '+) 1 a))</em> (cdr {defmac}-18)))
</pre>

<p>and so on.  "{list}" is a special version of "list" to avoid name collisions
and handle a few tricky details (similarly for "{values}" and "{apply}").  There is no unquote-splicing
macro in s7;  ",@(...)" becomes "(unquote (apply values ...))" at read-time.
</p>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>s7 macros are not hygienic.  For example,
</p>

<pre>
  (define-macro (mac b) 
    `(let ((a 12)) 
       (+ a ,b)))

  (let ((a 1) 
        (+ *))
    (mac a))
</pre>

<p>returns 144 because "+" has turned into "*", and "a" is the internal "a",
not the argument "a".  We get <code>(* 12 12)</code> where we probably expected <code>(+ 12 1)</code>.
It is possible to use gensym to clean this up, but that makes the macro 
unreadable in all but the simplest cases.  It is also possible, but not very easy, to
write a macro to do the gensymification for us, but in s7 it is much more straightforward
to use the environment functions.
The procedure-environment of a macro is the environment at its definition time, just like a function.
By wrapping the macro body in with-environment, we make sure anything in that body reflects 
the definition environment, not the calling environment.  We then augment that environment
with the macro arguments getting their values from the call-time environment:
</p>

<pre>
(define-macro (define-immaculo name-and-args . body)
  (let* ((gensyms (map (lambda (g) (gensym)) (cdr name-and-args)))
	 (args (cdr (copy name-and-args)))
	 (name (car name-and-args))
	 (set-args (map (lambda (a g) `(list ',g ,a)) args gensyms))
	 (get-args (map (lambda (a g) `(quote (cons ',a ,g))) args gensyms)))

    `(define-macro ,name-and-args
       `(let ,(list ,@set-args)                 ; get the current macro arg values
	  ,(list 'with-environment 
		 (append (list 'augment-environment) 
			 (list (list 'procedure-environment ,name)) 
			 (list ,@get-args))     ; import the current arg values into the definition environment
		 ,@body)))))
</pre>

<p>In this version of define-immaculo, don't unquote the macro arguments in the body, and
use <code>(apply values body)</code> in place of ",@body".
</p>

<pre>
&gt; (define-immaculo (mac b) `(let ((a 12)) (+ a b)))
mac
&gt; (let ((a 21) (+ *)) (mac a))
33
</pre>

<p>
If the slight difference in syntax is a problem
</p>

<pre>
(define-macro (define-immaculo name-and-args . body)
  (let* ((gensyms (map (lambda (g) (gensym)) (cdr name-and-args)))
	 (args (cdr (copy name-and-args)))
	 (name (car name-and-args))
	 (set-args (map (lambda (a g) `(list ',g ,a)) args gensyms))
	 (get-args (map (lambda (a g) `(quote (cons ',a ,g))) args gensyms))
	 (blocked-args (map (lambda (a) `(,a ',a)) args))        
	 (new-body (list (eval `(let (,@blocked-args) ,@body)))))

    `(define-macro ,name-and-args
       `(let ,(list ,@set-args)
          ,(list 'with-environment 
                 (append (list 'augment-environment) 
                         (list (list 'procedure-environment ,name)) 
                         (list ,@get-args))
                 ',@new-body)))))

&gt; (define-immaculo (mac c d) `(let ((a 12) (b 3)) (+ a b ,c ,d)))
mac
&gt; (let ((a 21) (b 10) (+ *)) (mac a b))
46
&gt; (let ((a 21) (b 10) (+ *)) (mac a (+ b 10))) ; here '+' is '*'
136

&gt; (macroexpand (define-immaculo (mac c d) `(let ((a 12) (b 3)) (+ a b ,c ,d))))
(define-macro (mac c d) 
  ({list} 'let 
    (list (list '{gensym}-23 c)        ; here we get the call-time macro argument values
          (list '{gensym}-24 d)) 
      (list 'with-environment 
            (append (list 'augment-environment) 
                                       ; now wrap the body in the augmented definition-time environment
                    (list (list 'procedure-environment mac)) 
                                       ; add the macro args to the definition-time env
                    (list '(cons 'c {gensym}-23) 
                          '(cons 'd {gensym}-24))) 
    '(let ((a 12) 
           (b 3)) 
       (+ a b c d)))))

&gt; (let ((a 21) (b 10) (+ *)) (macroexpand (mac a b)))

(let (({gensym}-22 a)    ; pick up mac args, this is arg 'c' with the value 'a'
      ({gensym}-23 b)) 
  (with-environment (augment-environment (procedure-environment #&lt;macro&gt;)
                      (cons 'c {gensym}-22) ; add them to definition-time env
		      (cons 'd {gensym}-23)) 
    (let ((a 12) 
	  (b 3)) 
      (+ a b c d)))) ; 'a' and 'b' are local, 'c' and 'd' are from the augmented env
</pre>


<p>This is not the end of the story.
Macro expansion happens
in two different environments.  Leaving aside quasiquote which operates at read-time in the global environment,
a macro first evaluates its body to form a piece
of code, a list with the macro's arguments plugged in.  Then
it evaluates that code.  So the expansion into a piece of code takes place in one
environment (the definition-time environment), and the code evaluation takes place
in another (the call-time environment).  This can be very frustrating!  Say we
decide to write a "symbol-set!" macro (borrowed in an oblique way from CL's set).
<code>(symbol-set! var val)</code> should evaluate "var", getting a symbol as its
value, then plug that symbol into <code>(set! var-value val)</code>.  For example,
after expansion we want something like:
</p>

<pre>
&gt; (let ((x 32) (y 'x)) 
    (eval (list 'set! y 123)) ; (symbol-set! y 123) ideally
    (list x y))
(123 x)
</pre>

<p>If we define our macro in the local context, then the initial expansion
into (set! x 123) takes place in a context where "y" is defined:
</p>

<pre>
&gt; (let ((x 32) (y 'x))
    (define-macro (symbol-set! var val)
      `(set! ,(symbol-&gt;value var) ,val))
    (symbol-set! y 123)
    (list x y))
(123 x)
</pre>

<p>But if we try to define that at the top level so we can use it anywhere, 
"var" may not be defined in the environment where the initial list is created:
</p>

<pre>
&gt; (define-macro (symbol-set! var val)
    `(set! ,(symbol-&gt;value var) ,val))
symbol-set!
&gt; (let ((x 32) (y 'x))
    (symbol-set! y 123)
    (list x y))
;y: unbound variable, line 3
;    ({list} 'set! (symbol-&gt;value var) val)
</pre>

<p>Exactly the same thing happens in CL:
</p>

<pre>
&gt; (defmacro symbol-set (var val) `(setf ,(eval var) ,val))
SYMBOL-SET
&gt; (let ((x 32) (y 'x)) (symbol-set y 123))
*** - EVAL: variable Y has no value
</pre>

<p>Our "unhygienic" macros are too clean!  We want both the expansion into
code and the evaluation of the code to happen in the call-time environment.
Since this is a step backward for computer science, I've called these
dirty macros, "bacros":
</p>

<pre>
&gt; (define-bacro (symbol-set! var val) 
   `(set! ,(symbol-&gt;value var) ,val))
symbol-set!
&gt; (let ((x 32) (y 'x)) 
    (symbol-set! y 123) 
    (list x y))
(123 x)
</pre>

<p>Or maybe "hacro"?  Use eval in place of symbol-&gt;value, and...
</p>

<pre>
&gt; (let ((x #(1 2 3)) 
        (y `(x 1))) 
    (symbol-set! y 123) 
    (list x y))
(#(1 123 3) (x 1))
</pre>

<p>s7 uses a bacro to implement macroexpand so that it can handle locally defined macros.
By the way, bacros solve part of our original problem:
</p>

<pre>
  (define-bacro (mac b) 
    `(let ((a 12)) 
       (+ a ,(symbol-&gt;value b))))

  (let ((a 1))
    (mac a))
</pre>

<p>returns 13! No variable capture! Perhaps we can massage this idea a bit:
</p>

<pre>
(set! *#readers*
  (cons (cons #\_ (lambda (str)
		    `(with-environment 
                       (initial-environment) 
                       ,(string-&gt;symbol (substring str 1)))))
	*#readers*))

(define-bacro* (mac b)
  `(#_let ((a 12)) 
     (#_+ a ,(eval b)))) ; eval rather than symbol-&gt;value so that 'b' can be any expression
</pre>

<p>Guaranteed hygienic!  
I'm not sure it's a big improvement over immaculos or gensyms, but it works.
</p>



<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>There is another problem with macros: accidental loops.  Take the following
example; we're trying to write a macro that defines a function
that returns its argument in a list statement.
</p>

<pre>
&gt; (define-macro (hang arg) `(define ,arg `(list (cdr ,,arg)))) ; obvious, no?
hang

&gt; (macroexpand (hang (f a)))
(define #1=(f a) ({list} 'list ({list} 'cdr #1#)))

&gt; (hang (f a))
f

&gt; (procedure-source f)
(lambda #1=(a) ({list} 'list ({list} 'cdr (f . #1#))))

&gt;(f 1)
</pre>

<p>And now we are hung.  As I think is clear from the procedure source, we've created a procedure with a
circular list in its definition!  This is surprisingly easy to do by accident.
Here's one way out:
</p>

<pre>
&gt; (define-macro (hang arg) `(define ,arg `(list ,,@(cdr arg))))
hang
&gt; (macroexpand (hang (f a)))
(define (f a) ({list} 'list a))
&gt; (hang (f a))
f
&gt; (f 1)
(list 1)
</pre>

<p>The moral of this story is: if you see a circular list in macroexpand, break
the loop! 
</p>



<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>But we should end on a happy note.  Here is Peter Seibel's once-only macro:
</p>

<pre>
  (defmacro once-only (names . body)
    (let ((gensyms (map (lambda (n) (gensym)) names)))
      `(let (,@(map (lambda (g) `(,g (gensym))) gensyms))
	 `(let (,,@(map (lambda (g n) ``(,,g ,,n)) gensyms names))
	    ,(let (,@(map (lambda (n g) `(,n ,g)) names gensyms))
	       ,@body)))))
</pre>

<p>From the land of sparkling bacros:
</p>

<pre>
(define-bacro (once-only names . body)
  `(let (,@(map (lambda (name) `(,name ,(eval name))) names))
     ,@body))
</pre>

<!--
A bacro is expanded in the call-time environment, so it can't be optimized in the same
way that CL macros sometimes are.  Since a CL macro does not evaluate its arguments, and
its expansion depends only on its definition environment, some lisps conclude that it can be expanded once and
for all the first time it is encountered, and replaced by its result (some piece of code) &mdash;
self-modifying code in effect.  This optimization is available in s7 under the name
define-expansion, with some caveats.  The thing defined by define-expansion is fully
expanded at read-time, so it must have a globally unique name, and it must depend
only on the global read-time environment.  But the CL way of doing macros is problematic.
Normally in lisp, if you redefine a function in its definition environment, then evaluate some code that calls
that function, you get the new version.  If a macro has already been expanded out of existence, 
it effectively ignores redefinition.  Similar gotchas apply to macros defined after they appear.

example:
(define (hi a) (+ 1 a))
(define (use-hi b) (hi b))
(let ((x (use-hi 1)))
  (format #t "x: ~A~%" x))
(define (hi a) (+ 2 a))
(let ((x (use-hi 1)))
  (format #t "x: ~A~%" x))

prints:
x: 2
x: 3
in s7, Guile, clisp, sbcl (using CL syntax of course),

but

(defmacro hi (a) `(+ 1 ,a))
(define (use-hi b) (hi b))
(let ((x (use-hi 1)))
  (format #t "x: ~A~%" x))
(defmacro hi (a) `(+ 2 ,a))
(let ((x (use-hi 1)))
  (format #t "x: ~A~%" x))

prints:
x: 2
x: 2

in every case but s7 which still says the 2nd x is 3.  

If we use the macro before defining it (as is perfectly legal for functions):

(define (use-hi b) (hi b))
(defmacro hi (a) `(+ 1 ,a))
(let ((x (use-hi 1)))
  (format #t "x: ~A~%" x))
(defmacro hi (a) `(+ 2 ,a))
(let ((x (use-hi 1)))
  (format #t "x: ~A~%" x))

s7 still says x is 2 then 3, Guile throws an error: "Wrong type to apply: #<syntax-transformer hi>";
clisp says 2 then 3! and sbcl gives the error: "HI is being redefined as a macro when it was previously assumed to be a function."
Incredible.


A bacro can be viewed as a function that does not
evaluate its arguments, but to avoid the extra evaluation after expansion we need
to quote the result (if the result does not already evaluate to itself):

(define-bacro (when test . body)
  (if (eval test)
      `',(eval `(let () ,@body))))

(let ((x 1)) (when (> x 0) '(list '+ x 3)))
-> '(list + x 3)


-->




</blockquote>
</small>

</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="constants"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>define-constant, constant?, symbol-access</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p><a name="defineconstant">define-constant</a> defines a constant and <a name="constantp">constant?</a> returns #t if its argument
is a constant.  A constant in s7 is really constant: it can't be set or rebound.
</p>

<pre>
&gt; (define-constant var 32)
var

&gt; (set! var 1)
;set!: can't alter immutable object: var

&gt; (let ((var 1)) var)
;can't bind or set an immutable object: var, line 1
</pre>

<p>This has the possibly surprising side effect that previous uses of the constant name
become constants:
</p>

<pre>
 (define (func a) (let ((cvar (+ a 1))) cvar))
 (define-constant cvar 23)
 (func 1)
 ;can't bind or set an immutable object: cvar
</pre>

<p>So, obviously, choose unique names for your constants, or don't use define-constant.
A function can also be a constant. 
</p>

<p>Constants are very similar to things such as keywords (no set, always return itself as its value),
variable trace (informative function upon set or keeping a history of past values), typed variables (restricting a
variable's values or doing automatic conversions upon set), and notification upon set (either in Scheme
or in C; I wanted this many years ago in Snd).  The notification function is especially useful if
you have a Scheme variable and want to reflect any change in its value immediately in C (see <a href="#notify">below</a>).
All of these cases modify
the path between a symbol and its value.  
s7 gives you a handle on that path via the procedure-with-setter <b><a name="symbolaccess">symbol-access</a></b>.
<code>(symbol-access symbol)</code> returns that symbol's accessors, and <code>(set! (symbol-access symbol) accessor-list)</code>
changes them.  The accessor-list is a list of three functions, the get, set, and bind functions.
The set and bind functions take two arguments, the symbol in question
and the value that it is about to be set or bound to.  The variable is set or bound to the value they return.
We could replace define-constant, and add
local constants with:
</p>

<pre>
(define constant-access 
  (list #f
	(lambda (symbol new-value) 
	  (format #t "can't change constant ~A's value to ~A" symbol new-value)
          'error)
	(lambda (symbol new-value) 
	  (format #t "can't bind constant ~A to a new value, ~A" symbol new-value)
          'error)))

(define-macro (define-constant symbol value)
  `(begin
     (define ,symbol ,value)
     (set! (<em class=red>symbol-access</em> ',symbol) constant-access)
     ',symbol))

(define-macro (let-constant vars . body)
  (let ((varlist (map car vars)))
    `(let ,vars
       ,@(map (lambda (var)
		`(set! (<em class=red>symbol-access</em> ',var) constant-access))
	      varlist)
       ,@body)))
</pre>


<p>In the next example, we restrict the values a variable can take to integers:
</p>

<pre>
(define-macro (define-integer var value)
  `(begin
     (define ,var ,value)
     (set! (<em class=red>symbol-access</em> ',var) 
	   (list #f
		 (lambda (symbol new-value)
		   (if (real? new-value)
		       (floor new-value) ; or min/max to restrict it to some range etc
                       (begin 
                         (format #t "~A can only take an integer value, not ~S" symbol new-value)
                         'error)))
		 #f))
     ',var))

&gt; (define-integer int 123)
int
&gt; (set! int 321.67)
321
&gt; (set! int (list 1 2))
;int can only take an integer value, not (1 2)
</pre>

<p>Here are trace and untrace.  We save the previous accessors in trace, restore them upon untrace,
and in between, call the previous set accessor, if any, after reporting the set:
</p>

<pre>
(define (trace var)
  (let* ((cur-access (<em class=red>symbol-access</em> var))
	 (cur-set (and cur-access (cadr cur-access))))
    (set! (<em class=red>symbol-access</em> var)
	  (list (and cur-access (car cur-access))
		(lambda (symbol new-value) 
		  (format #t "~A set to ~A~%" symbol new-value) 
		  (if cur-set 
		      (cur-set symbol new-value)
		      new-value))
		(and cur-access (caddr cur-access))
		cur-access)))) ; save the old version 

(define (untrace var)
  (if (and (symbol-access var)
	   (cdddr (symbol-access var)))
      (set! (symbol-access var) (cadddr (symbol-access var)))))
</pre>

<p>The "get" function is currently not implemented.
I believe symbol-access is similar to Ruby's hooked variables, or perhaps Perl's tied variables.
We could implement all kinds of things
with this mechanism, including property lists.
</p>

</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="maketype1"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>make-type</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>
<b><a name="maketype">make-type</a></b>, borrowed from Alaric Snell-Pym,
returns a type-object: a list of three functions
'?, 'make, and 'ref.  The <b>?</b> func returns #t if its argument
is of the new type, the <b>make</b> function returns a new object of the new type with the
value of the argument to the make function, and the <b>ref</b> function returns that value
when passed that object. 
</p>

<A NAME="recordexample"></a>
<pre>
(define special-value ((cadr (<em class=red>make-type</em>)) 'special))
;; now special-value's value can't be eq? to any other Scheme object

;; expand, for example, (define-record rec (a 1) (b 2))
(begin
  (define rec? #f)
  (define make-rec #f)
  (define rec-a #f)
  (define rec-b #f)

  (let* ((rec-type (<em class=red>make-type</em>))
	 (? (car rec-type))
	 (make (cadr rec-type))
	 (ref (caddr rec-type)))

    (set! make-rec (lambda* ((a 1) (b 2))
		     (make (vector a b))))

    (set! rec? ?)
  
    (set! rec-a (make-procedure-with-setter
		 (lambda (obj)
		   (and (rec? obj)
			(vector-ref (ref obj) 0)))
		 (lambda (obj val)
		   (if (rec? obj)
		       (vector-set! (ref obj) 0 val)))))

    (set! rec-b (make-procedure-with-setter
		 (lambda (obj)
		   (and (rec? obj)
			(vector-ref (ref obj) 1)))
		 (lambda (obj val)
		   (if (rec? obj)
		       (vector-set! (ref obj) 1 val)))))))

#|
(let ((hi (make-rec 32 '(1 2))))
  (set! (rec-b hi) 123)
  (format #t "rec: ~A ~A" 
	  (rec-a hi)
	  (rec-b hi)))

"rec: 32 123"
|#
</pre>

<p>Currently make-type takes some optional arguments to specify other actions.  
I might change this to be an alist of (operation function) pairs, but for now,
the optional (optkey) arguments are: print equal getter setter length name copy fill.
Except for the 'name' argument, these are functions.
When these functions are called, the argument representing the object is
the value of the object, not the object itself; see the examples below.
If no print function is specified, the 'name' argument is used when the
object is displayed.
The 'equal' function checks two objects of the new type for equality.
The 'getter' function applies the object to whatever arguments are
passed, and the 'setter' function does the same in the context of set!.
The 'length' function returns the length of the object's value.
The 'copy function returns a new object of the same type with the copy
function applied to the old object's value.
The 'fill' function takes two arguments, the object and what to
fill its value with.
So, remembering that (cadr type) is the make function:
</p>

<pre>
&gt; ((cadr (make-type)) 3.14)
#&lt;anonymous-type 3.14&gt;

&gt; ((cadr (make-type :name "hiho")) 123)
#&lt;hiho 123&gt;

&gt; ((cadr (make-type :print (lambda (a) (format #f "#&lt;typo: |~A|&gt;" a)))) 1)
#&lt;typo: |1|&gt;

&gt; (((cadr (make-type :getter (lambda (a b) (vector-ref a b)))) (vector 1 2 3)) 1)
2
</pre>

<p>The last is easier to read if we separate out the steps:
</p>

<pre>
&gt; (let* ((type (make-type 
                 :getter (lambda (a b) 
                           (vector-ref a b))))   ; make a new type with its own getter function
         (object ((cadr type) (vector 1 2 3))))  ; create an object of the new type, its value is a vector
       (object 1))                               ; apply the object to 1 =&gt; (vector-ref object 1) via the getter
2
</pre>

<p>The objects created in this way, or via s7_new_type in C, can be passed to map and for-each
if you supply the length and getter functions to make-type.
</p>

<pre>
&gt; (define-macro (enum . args)
     `(for-each define ',args ((cadr (make-type :getter (lambda (a b) b) 
                                                :length (lambda (a) ,(length args)))))))
enum
&gt; (enum zero one two three)
#&lt;unspecified&gt;
&gt; two
2
</pre>

<small>
<blockquote>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Here is define-record using make-type.  It has a few Common Lisp extensions:
</p>

<pre>
(define-macro (define-record struct-name . fields)
  (let* ((name (if (list? struct-name) (car struct-name) struct-name))
	 (sname (if (string? name) name (symbol-&gt;string name)))
		 
	 (fsname (if (list? struct-name)
		     (let ((cname (assoc :conc-name (cdr struct-name))))
		       (if cname 
			   (symbol-&gt;string (cadr cname))
			   sname))
		     sname))
		 
	 (make-name (if (list? struct-name)
			(let ((cname (assoc :constructor (cdr struct-name))))
			  (if cname 
			      (cadr cname)
			      (string-&gt;symbol (string-append "make-" sname))))
			(string-&gt;symbol (string-append "make-" sname))))

	 (is-name (string-&gt;symbol (string-append sname "?")))
		 
	 (copy-name (if (list? struct-name)
			(let ((cname (assoc :copier (cdr struct-name))))
			  (if cname 
			      (cadr cname)
			      (string-&gt;symbol (string-append "copy-" sname))))
			(string-&gt;symbol (string-append "copy-" sname))))
		 
	 (field-names (map (lambda (n)
			     (symbol-&gt;string (if (list? n) (car n) n)))
			   fields))
		 
	 (field-types (map (lambda (field)
			     (if (list? field)
				 (apply (lambda* (val type read-only) type) (cdr field))
				 #f))
			   fields))
		 
	 (field-read-onlys (map (lambda (field)
				  (if (list? field)
				      (apply (lambda* (val type read-only) read-only) (cdr field))
				      #f))
				fields)))
    `(begin

       ;; declare our globally-accessible names
       (define ,is-name #f)
       (define ,make-name #f)
       (define ,copy-name #f)

       ,@(map (lambda (n)
		`(define ,(string-&gt;symbol (string-append fsname "-" n)) #f))
	      field-names)

       (let* ((rec-type (<em class=red>make-type</em>))
	      (? (car rec-type))
	      (make (cadr rec-type))
	      (ref (caddr rec-type)))
	       
	 (set! ,is-name ?)

	 (set! ,make-name (lambda* ,(map (lambda (n)
					    (if (and (list? n)
						     (&gt;= (length n) 2))
						(list (car n) (cadr n))
						(list n #f)))
					  fields)
			    (make (vector ',(string-&gt;symbol sname) ,@(map string-&gt;symbol field-names)))))

	 (set! ,copy-name (lambda (obj) 
			    (make (copy (ref obj)))))	       

	 ,@(map (let ((ctr 1))
		  (lambda (n type read-only)
		    (let ((val (if read-only
				   `(set! ,(string-&gt;symbol (string-append fsname "-" n))
					  (lambda (arg) ((ref arg) ,ctr)))
				   `(set! ,(string-&gt;symbol (string-append fsname "-" n))
					  (make-procedure-with-setter 
					   (lambda (arg) ((ref arg) ,ctr)) 
					   (lambda (arg val) (set! ((ref arg) ,ctr) val)))))))
		      (set! ctr (+ 1 ctr))
		      val)))
		field-names field-types field-read-onlys)

	',struct-name))))

&gt; (define-record point (x 0.0) (y 0.0))
point
&gt; (let ((pt (make-point 1.0))) 
    (set! (point-y pt) 3.0)
    (list (point? pt) (point-x pt) (point-y pt)))
(#t 1.0 3.0)
</pre>	


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>In the next example, we define a float-vector type:
</p>

<pre>
(begin
  (define make-float-vector #f)
  (define float-vector? #f)
  (define float-vector #f)

  (let* ((fv-type (<em class=red>make-type</em>
		   :getter vector-ref :length length :copy copy :fill fill!
		   :setter (lambda (obj index value)
			     (if (not (real? value))
				 (error 'wrong-type-arg-error "float-vector element must be real: ~S" value))
			     (vector-set! obj index (exact-&gt;inexact value)))
		   :name "float-vector"))
	 (fv? (car fv-type))
	 (make-fv (cadr fv-type))
	 (fv-ref (caddr fv-type)))

    (set! make-float-vector 
      (lambda* (len (initial-element 0.0))
        (if (not (real? initial-element))
	    (error 'wrong-type-arg-error "make-float-vector initial element must be real: ~S" initial-element))
	(make-fv (make-vector len (exact-&gt;inexact initial-element)))))
    
    (set! float-vector? fv?)
    
    (set! float-vector
      (lambda args
	(let* ((len (length args))
	       (fv (make-float-vector len))
	       (v (fv-ref fv)))
	  (do ((lst args (cdr lst)))
	       (i 0 (+ i 1)))
	      ((null? lst) fv)
	    (let ((arg (car lst)))
	      (if (not (real? arg))
		  (error 'wrong-type-arg-error "float-vector element must be real: ~S in ~S" arg args))
	      (set! (v i) (exact-&gt;inexact arg))))))))

&gt; (let ((v (make-float-vector 3))) (set! (v 1) 32) v)
#&lt;float-vector #(0.0 32.0 0.0)&gt;

&gt; (let ((v (make-float-vector 3))) (set! (v 1) "hi") v)
;float-vector element must be real: "hi"

&gt; (map + (list 1 2 3) (float-vector 1 2 3)) ; we have a getter and length, so map and for-each will work
(2.0 4.0 6.0)
</pre>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>I seem to be using the same construct over and over; a begin to hold the names defined in the outer
environment, a let to hold internal stuff, and set!s to give the names values.  It's a clumsy, but 
simple way for multiple functions to share a closure.
Maybe it rates a macro:
</p>

<pre>
(define-macro (blet* names bindings . body)
  `(begin
     ,@(map (lambda (name)
	      `(define ,name #f))
	    names)
     (let* ,bindings
	,@body)))

(blet* (make-adjustable-vector adjustable-vector? adjust-vector)

       ((av-type (<em class=red>make-type</em> :name "adjustable-vector"
			    :getter (lambda (obj index)
				      ((car obj) index))
			    :setter (lambda (obj index value)
				      (set! ((car obj) index) value))
		            :length (lambda (obj)
			              (vector-length (car obj)))
			    :print (lambda (obj)
				     (object-&gt;string (car obj)))))
	(av? (car av-type))
	(make-av (cadr av-type))
	(av-ref (caddr av-type)))

  (set! make-adjustable-vector (lambda args 
				 (make-av (list (apply make-vector args)))))
  (set! adjustable-vector? av?)
  (set! adjust-vector (lambda* (obj new-length initial-element)
		        (let* ((new-vector (make-vector new-length initial-element))
			       (copy-len (min new-length (length obj))))
			  (do ((i 0 (+ i 1)))
			      ((= i copy-len))
			    (set! (new-vector i) (obj i)))
			  (set! (car (av-ref obj)) new-vector)))))

&gt; (define v (make-adjustable-vector 3 #f))
v

&gt; v
#(#f #f #f)

&gt; (set! (v 1) 32.0)
32.0

&gt; v
#(#f 32.0 #f)

&gt; (adjust-vector v 10 #f)
#(#f 32.0 #f #f #f #f #f #f #f #f)
</pre>

</blockquote>
</small>

</dd>
<br><br>



<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="pws"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>procedure-with-setter</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>A <a name="procedurewithsetter">procedure-with-setter</a> consists of two functions, the "getter" and the "setter".
The getter is called when the object is encountered as a function, and the setter when
it is set:
</p>

<pre>
(define xx (let ((x 32))
             (<em class=red>make-procedure-with-setter</em>
               (lambda () x) 
               (lambda (val) (set! x val) x))))
(xx) -&gt; 32
(set! (xx) 1)
(xx) -&gt; 1
</pre>

<p>The setter's last argument is the value passed to set!.  That is, 
</p>

<pre>
(define v123 
  (let ((vect (vector 1 2 3)))
    (make-procedure-with-setter
      (lambda (index) 
        (vector-ref vect index))     ; using explicit indexing -- (vect index) is the same (see "generalized set!" below)
      (lambda (index value) 
        (vector-set! vect index value)))))

&gt; (v123 2)
3
&gt; (set! (v123 2) 32)
32
&gt; (v123 2)
32
</pre>

<p>make-procedure-with-setter can add generalized set! support to any function:
</p>

<pre>
&gt; (define cadr (make-procedure-with-setter 
                 cadr 
                 (lambda (lst val) 
                   (set! (car (cdr lst) ) val))))
cadr
&gt; (cadr '(1 2 3))
2
&gt; (let ((lst (list 1 2 3))) 
    (set! (cadr lst) 4) 
    lst)
(1 4 3)
</pre>

<p>To get the setter from a procedure-with-setter (for procedure-arity for example),
use procedure-setter.
</p>


<small>
<blockquote>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Here is a pretty example of make-procedure-with-setter:
</p>

<pre>
(define-macro (c?r path)
  ;; "path" is a list and "X" marks the spot in it that we are trying to access
  ;; (a (b ((c X)))) -- anything after the X is ignored, other symbols are just placeholders
  ;; c?r returns a procedure-with-setter that gets/sets X

  (define (X-marks-the-spot accessor tree)
    (if (pair? tree)
	(or (X-marks-the-spot (cons 'car accessor) (car tree))
	    (X-marks-the-spot (cons 'cdr accessor) (cdr tree)))
	(if (eq? tree 'X) accessor #f)))

  (let ((body 'lst))
    (for-each
     (lambda (f)
       (set! body (list f body)))
     (reverse (X-marks-the-spot '() path)))

    `(<em class=red>make-procedure-with-setter</em>
      (lambda (lst) 
	,body)
      (lambda (lst val)
	(set! ,body val)))))

&gt; ((c?r (a b (X))) '(1 2 (3 4) 5))
3

&gt; (let ((lst (list 1 2 (list 3 4) 5))) 
   (set! ((c?r (a b (X))) lst) 32)
   lst)
(1 2 (32 4) 5)

&gt; (procedure-source (c?r (a b (X))))
(lambda (lst) (car (car (cdr (cdr lst)))))

&gt; ((c?r (a b . X)) '(1 2 (3 4) 5))
((3 4) 5)

&gt; (let ((lst (list 1 2 (list 3 4) 5))) 
   (set! ((c?r (a b . X)) lst) '(32))
   lst)
(1 2 32)

&gt; (procedure-source (c?r (a b . X)))
(lambda (lst) (cdr (cdr lst)))

&gt; ((c?r (((((a (b (c (d (e X)))))))))) '(((((1 (2 (3 (4 (5 6)))))))))) 
6

&gt; (let ((lst '(((((1 (2 (3 (4 (5 6))))))))))) 
    (set! ((c?r (((((a (b (c (d (e X)))))))))) lst) 32) 
    lst)
(((((1 (2 (3 (4 (5 32)))))))))

&gt; (procedure-source (c?r (((((a (b (c (d (e X)))))))))))
(lambda (lst) (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (car (car (car lst)))))))))))))))
</pre>	

<br>

<p>We can extend c?r into something incredibly useful!  A goto implementation using circular lists:
</p>

<pre>
(define-macro (define-with-goto name-and-args . body)
  ;; run through the body collecting label accessors, (label name)
  ;; run through getting goto positions, (goto name)
  ;; tie all the goto's to their respective labels (via set-cdr! essentially)
  
  (define (find-accessor type)
    (let ((labels '()))
      (define (gather-labels accessor tree)
	(if (pair? tree)
	    (if (equal? (car tree) type)
		(begin
		  (set! labels (cons (cons (cadr tree) 
					   (let ((body 'lst))
					     (for-each
					      (lambda (f)
						(set! body (list f body)))
					      (reverse (cdr accessor)))
					     (make-procedure-with-setter
					      (apply lambda '(lst) (list body))
					      (apply lambda '(lst val) `((set! ,body val))))))
				     labels))
		  (gather-labels (cons 'cdr accessor) (cdr tree)))
		(begin
		  (gather-labels (cons 'car accessor) (car tree))
		  (gather-labels (cons 'cdr accessor) (cdr tree))))))
      (gather-labels '() body)
      labels))
	
  (let ((labels (find-accessor 'label))
	(gotos (find-accessor 'goto)))
    (if (not (null? gotos))
	(for-each
	 (lambda (goto)
	   (let* ((name (car goto))
		  (goto-accessor (cdr goto))
		  (label (assoc name labels))
		  (label-accessor (and label (cdr label))))
	     (if label-accessor
		 (set! (goto-accessor body) (label-accessor body))
		 (error 'bad-goto "can't find label: ~S" name))))
	   gotos))

    `(define ,name-and-args
       (let ((label (lambda (name) #f))
	     (goto (lambda (name) #f)))
	 ,@body))))

(define-with-goto (hi)
  (display "start ")
  (<em class=red>goto</em> 'the-end)
  (display "oops")
  (<em class=red>label</em> 'the-end)
  (display "all done"))

(hi) -&gt; "start all done"
</pre>



<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>
I wonder if it would be more consistent to use the
name "procedure/setter" in place of "make-procedure-with-setter".
Its syntax is closer to
vector than make-vector, for example.  
Even better: "dilambda":
</p>

<pre>
(define-macro (dilambda getter setter)
  `(make-procedure-with-setter
     (lambda ,@getter)
     (lambda ,@setter)))

(let ((a 32)) 
  (dilambda (() a) 
            ((b) (set! a b))))
</pre>

<p>"bilambda" would mix Latin and Greek since the Romans used "el", not "lambda", according to Wikipedia.
</p>

</blockquote>
</small>
<br>

</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="generalizedset"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>applicable objects, generalized set!, generic functions</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>procedure-with-setters can be viewed as one generalization of set!.  Another
treats objects as having predefined get and set functions.  In s7
lists, strings, vectors, hash-tables, and any cooperating C or Scheme-defined objects
are both applicable and settable.  newLisp calls this implicit indexing, Gauche implements it
via object-apply, Guile via procedure-with-setter; CL's funcallable instance might be the same idea.
</p>

<p>
In <code>(vector-ref #(1 2) 0)</code>, for example, vector-ref is just a type
declaration.  But in Scheme, type declarations are unnecessary, so we get exactly
the same result from <code>(#(1 2) 0)</code>.  Similarly, <code>(lst 1)</code> is the
same as <code>(list-ref lst 1)</code>, and <code>(set! (lst 1) 2)</code> is the same
as <code>(list-set! lst 1 2)</code>.
I like this syntax:  the less noise, the better!
</p>

<pre>
;; an example taken from R Cox's website

(define dense (make-vector 128))
(define sparse (make-vector 128))
(define n 0)

(define (add-member i)
  (set! (dense n) i)
  (set! (sparse i) n)
  (set! n (+ n 1)))

(define (is-member i)
  (and (number? (sparse i))
       (&lt; (sparse i) n)
       (= (dense (sparse i)) i)))

(define (clear-all) (set! n 0))

(define (remove-member i)
  (if (is-member i)
      (begin
	(let ((j (dense (- n 1))))
	  (set! (dense (sparse i)) j)
	  (set! (sparse j) (sparse i))
	  (set! n (- n 1))))))

(add-member 32)
1
(add-member 12)
2
(is-member 14)
#f
(is-member 12)
#t
</pre>

<p>Some more examples:
</p>

<pre>
&gt; (let ((lst (list 1 2 3)))
    (set! (lst 1) 32)
    (list (lst 0) (lst 1)))
(1 32)

&gt; (let ((hash (make-hash-table)))
    (set! (hash 'hi) 32)
    (hash 'hi))
32

&gt; (let ((str "123")) 
    (set! (str 1) #\x) str)
"1x3"
</pre>

<small>
<blockquote>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Well, maybe applicable strings look weird: <code>("hi" 1)</code> is #\i, but worse,
so is <code>(cond (1 =&gt; "hi"))</code>!  Even though a string, list, or vector is "applicable", it is
not currently considered to be a procedure, so <code>(procedure? "hi")</code> is #f.  map and for-each, however,
accept anything that apply can handle, so
<code>(map #(0 1) '(1 0))</code> is '(1 0).  (On the first call to map in this case, you get the result of
<code>(#(0 1) 1)</code> and so on).
</p>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>The applicable object syntax makes it easy to write generic functions.
For example, s7test.scm has implementations of Common Lisp's sequence functions.
length, copy, reverse, fill!, map and for-each are generic in this sense (map always returns a list).
</p>

<pre>
&gt; (map (lambda (a b) (- a b)) (list 1 2) (vector 3 4))
(5 -3 9)

&gt; (length "hi")
2
</pre>

<p>
string-&gt;list and vector-&gt;list are <code>(map values object)</code>.
Their inverses are (and always have been) equally trivial.
Here's an FFT procedure that accepts lists or vectors, or any similar object:
</p>

<pre>
        (define* (cfft! data n (dir 1)) ; (complex data)
          (if (not n) (set! n (<em class=red>length</em> data)))
          (do ((i 0 (+ i 1))
               (j 0))
              ((= i n))
            (if (&gt; j i)
        	(let ((temp (data j)))
        	  (set! (data j) (data i))
        	  (set! (data i) temp)))
            (let ((m (/ n 2)))
              (do () 
        	  ((or (&lt; m 2) (&lt; j m)))
        	(set! j (- j m))
        	(set! m (/ m 2)))
              (set! j (+ j m))))
          (let ((ipow (floor (log n 2)))
        	(prev 1))
            (do ((lg 0 (+ lg 1))
        	 (mmax 2 (* mmax 2))
        	 (pow (/ n 2) (/ pow 2))
        	 (theta (make-rectangular 0.0 (* pi dir)) (* theta 0.5)))
        	((= lg ipow))
              (let ((wpc (exp theta))
        	    (wc 1.0))
        	(do ((ii 0 (+ ii 1)))
        	    ((= ii prev))
        	  (do ((jj 0 (+ jj 1))
        	       (i ii (+ i mmax))
        	       (j (+ ii prev) (+ j mmax)))
        	      ((&gt;= jj pow))
        	    (let ((tc (* wc (data j))))
        	      (set! (data j) (- (data i) tc))
        	      (set! (data i) (+ (data i) tc))))
        	  (set! wc (* wc wpc)))
        	(set! prev mmax))))
          data)
        
        &gt; (cfft! (list 0.0 1+i 0.0 0.0))
        (1+1i -1+1i -1-1i 1-1i)
        &gt; (cfft! (vector 0.0 1+i 0.0 0.0))
        #(1+1i -1+1i -1-1i 1-1i)
</pre>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>There is one place where list-set! and friends are not the same as set!: the former
evaluate their first argument, but set! does not (with a quibble; see below):
</p>

<pre>
&gt; (let ((str "hi")) (string-set! (let () str) 1 #\a) str)
"ha"

&gt; (let ((str "hi")) (set! (let () str) 1 #\a) str)
;((let () str) 1 #\a): too many arguments to set!

&gt; (let ((str "hi")) (set! ((let () str) 1) #\a) str)
"ha"

&gt; (let ((str "hi")) (set! (str 1) #\a) str)
"ha"
</pre>

<p>set! looks at its first argument to decide what to set.
If it's a symbol, no problem.  If it's a list, set! looks at its car to see if it is
some object that has a setter.  If the car is itself a list, set! evaluates the internal
expression, and tries again.  So the second case above is the only one that won't work.
And of course:
</p>

<pre>
&gt; (let ((x (list 1 2))) 
    (set! ((((lambda () (list x))) 0) 0) 3) 
    x) 
(3 2)
</pre>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>By my count, around 20 of the Scheme built-in functions are already generic in the sense
that they accept arguments of many types (leaving aside the numeric functions).  s7 extends that list with map, for-each, reverse,
and length, and adds a few others such as copy, fill!, sort!, object-&gt;string, and continuation?.
newLisp takes a more radical approach than s7: it extends operators such as '&gt;' 
to compare strings and lists, as well as numbers.  In map and for-each, however, you can mix the argument
types, so I'm not as attracted to making '&gt;' generic; you can't, for example, <code>(&gt; "hi" 32.1)</code>,
or even <code>(&gt; 1 0+i)</code>.
</p>

</blockquote>
</small>
</dd>

<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="multidimensionalvectors"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>multidimensional vectors</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>
s7 supports
vectors with any number of dimensions.  It is here, in particular, that the generalized
set! stuff shines.  make-vector's second argument can be a list of dimensions, rather than
an integer as in the one dimensional case:
</p>

<pre>
    (make-vector (list 2 3 4))
    (make-vector '(2 3) 1.0)
    (vector-dimensions (make-vector (list 2 3 4))) -&gt; (2 3 4)
</pre>

<p>The second example includes the optional initial element.
<code>(vect i ...)</code> or <code>(vector-ref vect i ...)</code> return the given
element, and <code>(set! (vect i ...) value)</code> and <code>(vector-set! vect i ... value)</code>
set it.  vector-length (or just length) returns the total number of elements.
vector-dimensions returns a list of the dimensions.
</p>

<pre>
    &gt; (define v (make-vector '(2 3) 1.0))
    #2D((1.0 1.0 1.0) (1.0 1.0 1.0))

    &gt; (set! (v 0 1) 2.0)
    #2D((1.0 2.0 1.0) (1.0 1.0 1.0))

    &gt; (v 0 1)
    2.0

    &gt; (vector-length v)
    6
</pre>

<small>
<blockquote>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>matrix multiplication:
</p>

<pre>
(define (matrix-multiply A B)
  ;; assume square matrices and so on here for simplicity
  (let* ((size (car (vector-dimensions A)))
	 (C (make-vector (list size size) 0)))
    (do ((i 0 (+ i 1)))
	((= i size) C)
      (do ((j 0 (+ j 1)))
	  ((= j size))
	(let ((sum 0))
	  (do ((k 0 (+ k 1)))
	      ((= k size))
	    (set! sum (+ sum (* (A i k) (B k j)))))
	  (set! (C i j) sum))))))
</pre>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Multidimensional vector constant syntax is modelled after CL: #nd(...) or #nD(...) 
signals that the lists specify the elements of an 'n' dimensional vector: <code>#2D((1 2 3) (4 5 6))</code>
</p>

<pre>
    &gt; (vector-ref #2D((1 2 3) (4 5 6)) 1 2)
    6

    &gt; (matrix-multiply #2d((-1 0) (0 -1)) #2d((2 0) (-2 2)))
    #2D((-2 0) (2 -2))
</pre>

<p>If any dimension has 0 length, you get an n-dimensional empty vector.  It is not
equal to a 1-dimensional empty vector.
</p>

<pre>
    &gt; (make-vector '(10 0 3))
    #3D()

    &gt; (equal? #() #3D())
    #f
</pre>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>To save on costly parentheses, and make it easier to write generic multidimensional sequence functions,
you can use this same syntax with lists.
</p>

<pre>
&gt; (let ((L '((1 2 3) (4 5 6))))
    (L 1 0))              ; same as (list-ref (list-ref L 1) 0) or ((L 1) 0)
4

&gt; (let ((L '(((1 2 3) (4 5 6)) ((7 8 9) (10 11 12))))) 
    (set! (L 1 0 2) 32)   ; same as (list-set! (list-ref (list-ref L 1) 0) 2 32) which is unreadable!
    L)
(((1 2 3) (4 5 6)) ((7 8 32) (10 11 12)))
</pre>

<p>Or with vectors of vectors, of course:
</p>

<pre>
&gt; (let ((V '#(#(1 2 3) #(4 5 6)))) 
    (V 1 2))              ; same as (vector-ref (vector-ref V 1) 2) or ((V 1) 2)
6

&gt; (let ((V #2d((1 2 3) (4 5 6))))
    (V 0))
#(1 2 3)
</pre>

<p>There's one difference between a vector-of-vectors and a multidimensional vector:
in the latter case, you can't clobber one of the inner vectors. 
</p>

<pre>
&gt; (let ((V '#(#(1 2 3) #(4 5 6)))) (set! (V 1) 32) V)
#(#(1 2 3) 32)

&gt; (let ((V #2d((1 2 3) (4 5 6)))) (set! (V 1) 32) V)
;not enough args for vector-set!: (#2D((1 2 3) (4 5 6)) 1 32)
</pre>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Using lists to display the inner vectors may not be optimal, especially when the elements are also lists:
</p>

<pre>
#2D(((0) (0) ((0))) ((0) 0 ((0))))
</pre>

<p>The "#()" notation is no better (the elements can be vectors), and I'm not a fan of "[]" parentheses.
Perhaps we could use different colors?  Or different size parentheses?
</p>

<pre>
#2D<em class=green>(</em><em class=red>(</em>(0) (0) ((0))<em class=red>)</em> <em class=red>(</em>(0) 0 ((0))<em class=red>)</em><em class=green>)</em>
#2D<big><big>(</big>(</big>(0) (0) ((0))<big>)</big> <big>(</big>(0) 0 ((0))<big>)<big>)</big></big>
</pre>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>I'm not sure how to handle vector-&gt;list and list-&gt;vector in the multidimensional case.
Currently, vector-&gt;list flattens the vector, and list-&gt;vector always returns a
one dimensional vector, so the two are not inverses.
</p>

<pre>
&gt; (vector-&gt;list #2d((1 2) (3 4)))
(1 2 3 4)             ; should this be '((1 2) (3 4)) or '(#(1 2) #(3 4))?
&gt; (list-&gt;vector '(#(1 2) #(3 4))) ; what about '((1 2) (3 4))?
#(#(1 2) #(3 4))      
</pre>

<p>Perhaps I should add an optional number-of-dimensions argument?
This also affects format and sort!:
</p>

<pre>
&gt; (format #f "~{~A~^ ~}" #2d((1 2) (3 4)))
"1 2 3 4"

&gt; (sort! #2d((1 4) (3 2)) &gt;) 
#2D((4 3) (2 1))
</pre>

<p>Another question: should we accept the multi-index syntax in a case such as:
<code>(let ((v #("abc" "def"))) (v 0 2))</code>?  Currently s7 complains because
it expects each index in a case like this to refer to the same kind of object.
It wants you to use: <code>(let ((v #("abc" "def"))) ((v 0) 2))</code>.  
</p>

</blockquote>
</small>
</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="hashtables"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>hash-tables</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><br>
<ul>
<li>(<a name="makehashtable">make-hash-table</a> (size 512))
<li>(<a name="hashtable">hash-table</a> ...)
<li>(<a name="hashtableref">hash-table-ref</a> ht key)
<li>(<a name="hashtableset">hash-table-set!</a> ht key value)
<li>(<a name="hashtablep">hash-table?</a> obj)
<li>(<a name="hashtablesize">hash-table-size</a> ht)
<li>(<a name="hashtableiteratof">make-hash-table-iterator</a> ht)
</ul>

<p>
Any s7 object can be the key or the key's value.
Each hash-table keeps track of the keys it contains, optimizing the search wherever possible.
If you pass a table size that is not a power of 2, make-hash-table rounds it up to the next power of 2.
</p>

<pre>
(let ((ht (make-hash-table)))
  (set! (ht "hi") 123)
  (ht "hi"))

-&gt; 123
</pre>

<p>hash-table (the function) parallels (the functions) vector, list, and string.  Its arguments are cons's containing key/value pairs.
The result is a new hash-table with those values preinstalled: <code>(hash-table '("hi" . 32) '("ho" . 1))</code>.
make-hash-table-iterator returns a function of no arguments (a "thunk").  Each time you call this function, it
returns the next entry in the hash table.  When it runs out of entries, it returns nil.
</p>


<small>
<blockquote>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Since hash-tables accept the same applicable-object syntax that vectors use, we can 
treat a hash-table as, for example, a sparse array:
</p>

<pre>
&gt; (define make-sparse-array make-hash-table)
make-sparse-array

&gt; (let ((arr (make-sparse-array)))
   (set! (arr 1032) "1032")
   (set! (arr -23) "-23")
   (list (arr 1032) (arr -23)))
("1032" "-23")
</pre>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>map and for-each accept hash-table arguments. On each iteration, the map or for-each function is passed
an entry, <code>'(key . value)</code>, in whatever order the entries are encountered in the table.  (Both use
make-hash-table-iterator internally).
</p>

<pre>
(define (hash-table-&gt;alist table)
  (map (lambda (x) x) table)) ; clearer perhaps than (map values table), append would also work here
</pre>

<p>reverse of a hash-table returns a new table with the keys and values reversed.
<code>(fill! table '())</code> removes all entries from the hash-table.
</p>

</blockquote>
</small>

</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="hooks"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>hooks</h4></td></tr></table>
</td></tr></table>
</dt>

<dd>

<pre>
    (<a name="makehook">make-hook</a> (arity (0 0 #f)) (documentation ""))  ; make a new hook
    (<a name="hook">hook</a> ...)                                       ; make a hook, the args are functions
    (<a name="hookp">hook?</a> obj)                                      ; return #t if obj is a hook
    (<a name="hookfunctions">hook-functions</a> hook)                            ; the hook's list of functions
    (<a name="hookarity">hook-arity</a> hook)                                ; the hook's arity list: (required optional rest)
    (<a name="hookdocumentation">hook-documentation</a> hook)                        ; the hook's documentation string
    (<a name="hookapply">hook-apply</a> hook ...) and (&lt;hook&gt; ...)           ; run the hook (it is an applicable object)
</pre>

<p>A hook holds a list of functions.  When something interesting happens,
the hook is invoked, and it applies its arguments to each function in the list.
In GUI toolkits hooks are called callback-lists, in CL conditions,
in other contexts watchpoints or signals.  s7 itself has several
hooks: *trace-hook*, *error-hook*, *unbound-variable-hook*, and *load-hook*.
A hook is created with make-hook or hook, called either as an applicable object
or via hook-apply, and recognized via hook?.  The list of functions is accessed
via hook-functions.  All the functions on the list have to be compatible with
the way the hook itself is invoked, so the hook has an arity, hook-arity.
</p>

<pre>
&gt; (let ((h (make-hook '(1 0 #f) "an example hook")))     ; 1 required arg and no others
    (set! (hook-functions h)                             ; add 1 function to the hook's list
      (list (lambda (x) (format #t "x is ~A" x))))
    (h 23))                                              ; invoke the hook's functions with argument 23
"x is 23"
</pre>

</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="multiplevalues"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>multiple-values</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>
In s7, multiple values are spliced directly into the caller's argument list.
</p>

<pre>
  &gt; (+ (values 1 2 3) 4)
  10
  &gt; (string-ref ((lambda () (values "abcd" 2))))
  #\c
  &gt; ((lambda (a b) (+ a b)) ((lambda () (values 1 2))))
  3
  &gt; (+ (call/cc (lambda (ret) (ret 1 2 3))) 4) ; call/cc has an implicit "values"
  10
  &gt; ((lambda* ((a 1) (b 2)) (list a b)) (values :a 3))
  (3 2)

  ;; call-with-values: 
  (define-macro (call-with-values producer consumer) 
    `(,consumer (,producer)))

  ;; multiple-value-bind ("receive" in srfi-8):
  (define-macro (multiple-value-bind vars expr . body)
    `((lambda ,vars ,@body) ,expr))

  ;; multiple-value-set!:
  (define-macro (multiple-value-set! vars expr . body)
    (let ((local-vars (map (lambda (n) (gensym)) vars)))
      `((lambda ,local-vars ,@(map (lambda (n ln) `(set! ,n ,ln)) vars local-vars) ,@body) ,expr)))

  ;; let*-values is defined as a macro at the end of s7.c (commented out)
</pre>


<small>
<blockquote>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>There aren't that many real uses for multiple-values in Scheme.  Nearly all can be replaced by
a normal list.  There are two cases, however, that can't be handled easily with a list.
First, you can use "values" to return any number of values, including 0,
from map's function application:
</p>

<pre>
&gt; (map (lambda (x) (if (odd? x) (values x (* x 20)) (values))) (list 1 2 3))
(1 20 3 60)

&gt; (define (filter-map func lst) (map (lambda (x) (if (func x) x (values))) lst))
</pre>

<p>
Second, you can use multiple-values to turn off the short-circuit evaluation
of 'or' and 'and'.  Normally these operators 
stop evaluating their arguments as soon as they hit #t ('or') or #f ('and').
By wrapping the arguments in 'values', you can force all of them to be evaluated:
</p>

<pre>
&gt; (let ((x 1)) 
    (and (let () #f)             ; this returns #f so
         (let () (set! x 3) #f)) ;   this is never evaluated
    x)
1

&gt; (let ((x 1)) 
    (and (<em class=red>values</em> (let () #f) 
                 (let () (set! x 3) #f)))
  x) 
3

&gt; (let ((x 1))                ; (apply and ...) has the same effect
    (apply and (list #f (set! x 3))) x)
3
</pre>

<p>At the top-level, since there's nothing to splice into, so you simply get your values back:
</p>

<pre>
&gt; (values 1 (list 1 2) (+ 3 4 5))
(values 1 (1 2) 12)
</pre>

<p>But this printout is just trying to be informative.  There is no multiple-values object
in s7.  You can't <code>(set! x (values 1 2))</code>, for example.  The values function
tells s7 that its arguments should be handled in a special way, and the multiple-value indication goes away
as soon as the arguments are spliced into some caller's arguments.  
</p>

<p>Internally, s7 uses <code>(apply values ...)</code> to implement unquote splicing (",@") in quasiquote.
</p>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>In some Schemes, values behaves like CL's prog1:
</p>

<pre>
(not s7)&gt; (let ((x 1)) (cond ((values #f (set! x 2) #t) 3) (#t x)))
2
(not s7)&gt; (if (values #f #t) 1 2)
2
</pre>

<p>But in s7 we're trying to implement real multiple values (else why have them at all?).
There are many ways we could interpret <code>(cond ((values ...))...)</code> and
<code>(cond ((values...) =&gt; func))</code>, but surely
equivalent uses of "cond" and "if" should give the same result.
Currently in s7, where a test is in progress, only <code>(values #f)</code> is the same as #f.
</p>

<pre>
&gt; (if (values #f #f) 1 2)            ; (values #f #f) is not #f
1
&gt; (cond ((values #f #f) 1) (#t 2))
1
;;; but if we interpreted this as splicing in the values, we get an inconsistency:
&gt; (cond (#f #f 1) (#t 2))
2

&gt; (if (values #f) 1 2)
2
&gt; (cond ((values #f) 1) (#t 2))
2

&gt; (if (values) 1 2)
1
&gt; (cond ((values) 1) (#t 2))
1
;;; this is consistent with (cond (1) (#t 2))
</pre>

<p>
So "if" and "cond" agree, but it requires that in one case the "values"
behavior is slightly weird.  <code>(or (values #f #f))</code> is #f, but that isn't inconsistent because
"or" is not testing anything.
We might choose to say that <code>(if (values #f #f)...)</code>
is an error, but that would be hasty &mdash;
our troubles have only begun.  First, "cond" can omit the expressions that follow the test, unlike "if":
</p>

<pre>
&gt; (cond (3))
3
</pre>

<p>and even trickier, "cond" can pass the test value to a function:
</p>

<pre>
&gt; (cond (3 =&gt; +))
3
</pre>

<p>The various standards agree that in the "=&gt;" case, the "fed to" function
receives one argument, so
</p>

<pre>
(not s7)&gt; (cond ((values 1 2) =&gt; +))
1
</pre>

<p>If we were following the "splice immediately" model, this would be <code>(cond (1 2 =&gt; +))</code>
which is an error in some Schemes.
So something has to give.  My druthers is to make "values" work as consistently as possible, and hope
that the one odd corner will not trip anyone.  From that point of view, the "one arg" standard
looks like a wasted opportunity.
s7 handles it this way:
</p>

<pre>
&gt; (+ 1 (cond ((values 2 3))) 4)   ; trailing values are not ignored
10
&gt; (cond ((values 1 2 3) =&gt; +))
6
</pre>

<p>Of course, it is unproblematic that the expression can itself involve multiple values:
</p>

<pre>
&gt; (+ (cond (#t (values 1 2))))
3
</pre>

<p>Now, what have I missed?
</p>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Since set! does not evaluate its first argument, and
there is no setter for "values", <code>(set! (values x) ...)</code> is not
the same as <code>(set! x ...)</code>.  <code>(string-set! (values string) ...)</code>
works because string-set! does evaluate its first argument.  <code>((values + 1 2) (values 3 4) 5)</code>
is 15, as anyone would expect.
</p>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>I wrote all that and said "nobody needs multiple values!".  In desperation,
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=5>

<tr>
<td>
<pre>
(define (flatten lst)
  (define (flatten-1 lst)
    (cond ((null? lst) (values))
	  ((not (pair? lst)) lst)
	  (#t (values (flatten-1 (car lst))
		      (flatten-1 (cdr lst))))))
  (map values (list (flatten-1 lst))))
</pre>
</td>
<td width=40></td>

<td bgcolor="#fbfbf0">
<pre>
(define (boring-flatten x)
  (cond ((null? x) '())
        ((not (pair? x)) (list x))
        (#t (append (boring-flatten (car x))
		    (boring-flatten (cdr x))))))
</pre>
</td>
</tr>
</table>

<p>Here's a much more entertaining version:
</p>
<pre>
(define (flatten! lst) ; in-place flatten
  (let loop ((L lst))
    (if (pair? (car L))
	(let ((end (cdr L))
	      (p (car L)))
	  (set! (car L) (car p))
	  (set! (cdr L) (cdr p))
	  (set! (cdr (list-tail L (- (length p) 1))) end)
	  (loop L))
	(if (not (null? (cdr L)))
	    (if (null? (car L))
		(begin
		  (set! (car L) (cadr L))
		  (set! (cdr L) (cddr L))
		  (loop L))
		(loop (cdr L)))))
    (if (equal? lst '(()))
	'()
	(let ((len (length lst)))
	  (if (null? (car (list-tail lst (- len 1))))
	      (set! (cdr (list-tail lst (- len 2))) '()))
	  lst))))
</pre>


</blockquote>
</small>
</dd>
<br><br>



<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="callwithexit1"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>call-with-exit and continuation?</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p><b><a name="callwithexit">call-with-exit</a></b> is call/cc without the ability to jump back into the original context,
similar to "return" in C.  This takes the place of CL's catch/throw (s7 uses "catch" for error handling).
</p>

<pre>
(define (find-first-even-number arg)
  (<em class=red>call-with-exit</em>
   (lambda (return)
     (for-each
      (lambda (a)
	(if (even? a)
	    (return a)))
      arg))))

(find-first-even-number (list 1 3 9 13 8 2 4)) -&gt; 8

(define-macro (block . body) 
  `(<em class=red>call-with-exit</em> 
     (lambda (return) 
       ,@body)))

(block (display "hi") (return 32) (display "oops")) -&gt; 32
</pre>

<p><b>continuation?</b> returns #t if its argument is a continuation,
as opposed to a normal procedure.  I don't know why Scheme hasn't had this function from
the very beginning, but it's needed if you want to write a continuable error
handler.  Here is a sketch of the situation:
</p>

<pre>
(let ()
  (catch #t
	 (lambda ()
	   (let ((res (call/cc 
                        (lambda (ok) 
			  (error 'cerror "an error" ok)))))
	     (display res) (newline)))
	 (lambda args
	   (if (and (eq? (car args) 'cerror)
		    (<em class=red>continuation?</em> (cadadr args)))
	       (begin
		 (display "continuing...")
		 ((cadadr args) 2)))
	   (display "oops"))))

  -&gt; continuing...2
</pre>

<p>In a more general case, the error handler is separate from the
catch body, and needs a way to distinguish a real continuation
from a simple procedure.  Otherwise, it blithely announces that
it is continuing from the point of the error, but then fails to do so.
</p>

<small>
<blockquote>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>The call-with-exit function's argument (the "continuation") is only valid
within the call-with-exit function.  In call/cc, you can save it, then call it later
to jump back, but if you try that with call-with-exit (from outside the call-with-exit function's body), you'll get an error.
This is similar to trying to read from a closed input port. 
</p>

</blockquote>
</small>


</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="format1"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>format, object-&gt;string</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>s7's built-in <a name="format">format</a> function is very close to that in srfi-48.
</p>

<pre>
(format #f "~A ~D ~F" 'hi 123 3.14)
-&gt; "hi 123 3.140000"
</pre>


<p>The format directives (tilde chars) are:</p>
<pre>
~%        insert newline
~&amp;        insert newline if preceding char was not newline
~~        insert tilde
~\n       (tilde followed by newline): trim white space
~{        begin iteration (take arguments from a list, string, vector, or any other applicable object)
~}        end iteration
~^        jump out of iteration
~*        ignore the current argument
~A        object-&gt;string as in display
~S        object-&gt;string as in write
~C        print as character
~P        insert 's' if current argument is not 1 or 1.0 (use ~@P for "ies" or "y")
~B        number-&gt;string in base 2
~O        number-&gt;string in base 8
~D        number-&gt;string in base 10
~X        number-&gt;string in base 16
~E        float to string, (format #f "~E" 100.1) -&gt; "1.001000e+02", (%e in C)
~F        float to string, (format #f "~F" 100.1) -&gt; "100.100000",   (%f in C)
~G        float to string, (format #f "~G" 100.1) -&gt; "100.1",        (%g in C)
~T        insert spaces (padding)
</pre>

<p>The last eight take the usual numeric arguments to specify field width and precision.
</p>
<p>
<code>(format #f ...)</code> simply returns the formatted string; <code>(format #t ...)</code>
also sends it to *stdout*.  To send the string to *stderr* instead, <code>(format *stderr* ...)</code>.
</p>

<small>
<blockquote>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Floats can occur in any base, so:
</p>

<pre>
&gt; #xf.c
15.75
</pre>

<p>This also affects format.  In most Schemes, <code>(format #f "~X" 1.25)</code> is
an error.  In CL, it is equivalent to using ~A which is perverse.  But 
</p>

<pre>
&gt; (number-&gt;string 1.25 16)
"1.4"
</pre>

<p>and there's no obvious way to get the same effect from format unless we accept
floats in the "~X" case.  So in s7, 
</p>

<pre>
&gt; (format #f "~X" 21)
"15"

&gt; (format #f "~X" 1.25)
"1.4"

&gt; (format #f "~X" 1.25+i)
"1.4+1.0i"

&gt; (format #f "~X" 21/4)
"15/4"
</pre>

<p>That is, the output choice matches the argument.  A case that came up in the Guile mailing lists is:
<code>(format #f "~F" 1/3)</code>.  s7 currently returns "1/3", but Clisp returns "0.33333334".
</p>

<p>The curly bracket directive applies to anything you can map over, not just lists:
</p>

<pre>
&gt; (format #f "~{~C~^ ~}" "hiho")
"h i h o"
</pre>


</blockquote>
</small>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>object-&gt;string returns the string representation of its argument:
</p>

<pre>
&gt; (object-&gt;string "hiho")
"\"hiho\""

&gt; (format #f "~S" "hiho")
"\"hiho\""
</pre>

<small>
<blockquote>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>I added object-&gt;string to s7 before deciding to include format.  format excites a
vague disquiet &mdash; why do we need this ancient unlispy thing?
We can almost replace it with:
</p>

<pre>
(define (objects-&gt;string . objects)
  (apply string-append (map (lambda (obj) (object-&gt;string obj #f)) objects)))
</pre>

<p>But how to handle lists (~{...~} in format), or columnized output (~T)?
I wonder whether formatted string output still matters outside a REPL.  Even in that context,
a modern GUI will leave formatting decisions to a text or table widget.
</p>

<pre>
(define-macro (string-&gt;objects str . objs)
  `(with-input-from-string ,str
     (lambda ()
       ,@(map (lambda (obj)
		`(set! ,obj (eval (read))))
	      objs))))
</pre>


<!--

:(objects->string "int: " 32 ", string: " "hi")
"int: 32, string: hi"

(define (cycle->string . objs)
  (call-with-exit
   (lambda (return)
     (for-each
      (lambda (obj)
	(if (pair? obj)
	    (return
	     (string-append 
	      (apply objects->string 
		     (map (lambda (obj)
			    (if (pair? obj)
				(car obj)
				obj))
			  objs))
	      (apply cycle->string 
		     (map (lambda (obj)
			    (if (pair? obj)
				(cdr obj)
				obj))
			  objs))))))
      objs)
     "")))

;;; (cycle->string ": " (list 1 2 3) " |")
:(objects->string "int: " 32 ", list with spaces: (" (cycle->string (list 1 2 3) " ") "), string: " "hi")
"int: 32, list with spaces: (1 2 3 ), string: hi"

:(let ((x 0) (y 0)) (string->objects "1 2" x y) (list x y))
(1 2)

-->


</blockquote>
</small>


</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="errors"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>error handling</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>s7's error handling mimics that of Guile.  An error is signalled
via the error function, and can be trapped and dealt with via <a name="catch">catch</a>.
</p>

<pre>
(<em class=red>catch</em> 'wrong-number-of-args
  (lambda ()     ; code protected by the catch
    (abs 1 2))
  (lambda args   ; the error handler
    (apply format (append (list #t) (cadr args)))))

-&gt; "abs: too many arguments: (1 2)"

(<em class=red>catch</em> 'division-by-zero
  (lambda () (/ 1.0 0.0))
  (lambda args (string-&gt;number "inf.0")))

-&gt; inf.0
</pre>

<p>
catch has 3 arguments: a tag indicating what error to catch (#t = anything),
the code, a thunk, that the catch is protecting, and the function to call
if a matching error occurs during the evaluation of the thunk.  The error handler
takes a rest argument which will hold whatever the error function chooses to pass it.
The error function itself takes at least 2 arguments, the error type, a symbol,
and the error message.  There may also be other arguments describing the error.
The default action, in the absence of any catch, is to treat the message as
a format control string, apply format to it and the other arguments, and
send that info to the current-error-port.
</p>

<p>When an error is encountered, the variable <a name="errorinfo">*error-info*</a>, a vector, contains
additional info about that error:
</p>

<ul>
<li>0: the error type or tag, e.g. 'division-by-zero
<li>1: the message or information passed by the error function
<li>2: if not #f, the code that s7 thinks triggered the error
<li>3: if not #f, the line number of that code
<li>4: if not #f, the file name of that code
<li>5: the environment at the point of the error
<li>6...: stack environment pointers, ending in #f
</ul>


<small>
<blockquote>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>To find a variable's value at the point of the error:
</p>

<pre>
(symbol-&gt;value var (vector-ref *error-info* 5))
</pre>

<p>To print the stack at the point of the error:
</p>

<pre>
(stacktrace *error-info*)
</pre>

<p>To evaluate the error handler in the environment of the error:
</p>

<pre>
(let ((x 1))
  (catch #t
	 (lambda ()
	   (let ((y 2))
	     (error 'oops)))
	 (lambda args
	   (with-environment
	    (augment-environment 
	     (*error-info* 5)      ; the error env
	     (cons 'args args))    ; add the error handler args
	    (list args x y)))))    ; we have access to 'y'
</pre>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

</blockquote>
</small>



<p>The hook <a name="errorhook">*error-hook*</a> provides a way to specialize error reporting.
Its functions take two arguments, the values passed by the error function:
the error type and whatever other info accompanies it.
</p>

<pre>
(set! (hook-functions *error-hook*) (list (lambda (tag args) (apply format #t args))))
</pre>

<p><a name="stacktrace">stacktrace</a> can be called anytime to see the chain of function calls.  Its optional argument
can be *error-info* to show the stack at the point of the last error,
or a continuation to
show the continuation stack. 
</p>

<pre>
    (let ()
      (define (a1 a) (+ a #\c))
      (define (a2 b) (+ b (a1 b)))
      (define (a3 c) (+ c (a2 c)))
      (catch #t
        (lambda () (a3 1))
        (lambda args (<em class=red>stacktrace</em> *error-info*))))

-&gt;    (a1 (a . 1))
      (a2 (b . 1))
      (a3 (c . 1))
</pre>

<p>
See also trace below.  There is a break macro defined in Snd (snd-xen.c)
which allows you to stop at some point, then evaluate arbitrary expressions in that context.
<!-- INDEX autoload:autoload -->
<A NAME="autoload"></A>
There's yet another hook, <a name="unboundvariablehook">*unbound-variable-hook*</a>, which is called
before the error is signalled
when an unbound variable
is encountered.
Its functions take one argument,
the unbound symbol.  In Snd, this is used to implement autoloading:
</p>

<pre>
(set! (hook-functions <em class=red>*unbound-variable-hook*</em>)
  (list (lambda (sym)
          ;; add your own symbol checks here
          (let ((file (autoload-file (symbol-&gt;string sym))))
            ;; autoload-file is a Snd function that knows where a lot of Snd's Scheme functions are
            (if file (load file))
            (symbol-&gt;value sym))))) ; this will return #&lt;undefined&gt; if we didn't find its source file
</pre>

<!--
<small>
<blockquote>
<p>Sly evil-doers can subvert this hook to provide something similar to Common Lisp's symbol-macros:
</p>
<pre>
&gt; (set! (hook-functions *unbound-variable-hook*)
    (list (lambda (sym)
            (if (eq? sym 'hiho)
                (sin (random 1.0))
                (symbol-&gt;value sym)))))
&lt;closure&gt;

&gt; hiho
0.46727567824396

&gt; hiho
0.64985453979392
</pre>

</blockquote>
</small>
-->

<p>The s7-built-in catch tags are 'wrong-type-arg, 'syntax-error, 'read-error, 
'out-of-memory, 'wrong-number-of-args, 'format-error, 'out-of-range, 'division-by-zero, 'io-error, and 'bignum-error.  
There's a s7 lint checker: lint.scm in the Snd tarball.
</p>

<p><a name="trace">trace</a> and untrace provide tracing:
</p>
<pre>
    (define (hiho arg) 
      (if (&gt; arg 0) 
          (+ 1 (hiho (- arg 1))) 
          0))

    (<em class=red>trace</em> hiho)

    (hiho 3)

    [hiho 3]
     [hiho 2]
      [hiho 1]
       [hiho 0]
        0
       1
      2
     3
</pre>

<p>trace adds a function to the list of functions being traced, and untrace removes it.
trace with no arguments causes everything to be traced, and untrace with no arguments
turns this off.  To trace a function that is internal to another function, put the
trace and untrace calls in the enclosing function.
</p>

<p>There is also a hook, <a name="tracehook">*trace-hook*</a>.  It takes functions
of 2 arguments, the currently traced
function and the list of current arguments.  The hook's functions are evaluated in the environment of the
traced function call (that is, global to the function, not the function's local environment).
</p>

<pre>
    (define (hiho a b c) (* a b c))
    (set! (hook-functions *trace-hook*) (list (lambda (f args) (format #t "sum of args: ~A~%" (apply + args)))))
    (trace hiho)
    (hiho 2 3 4)

    [hiho 2 3 4]
    sum of args: 9
     24
</pre>

</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="procedureinfo"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>procedure info</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p><a name="proceduresource">procedure-source</a>, procedure-arity, procedure-setter, procedure-documentation, and help provide a look into a
Scheme function.
procedure-documentation returns the documentation string associated with a procedure: the initial string in the
function's body. procedure-arity returns a list describing the argument list of a function: <code>'(required-args optional-args rest-arg?)</code>.
procedure-setter returns the set function associated with a procedure (set-car! with car, for example).
procedure-source returns the source, as a list, of a procedure. procedure-environment returns
a procedure's environment.
</p>

<pre>
&gt; (define* (add-2 a (b 32)) "add-2 adds its 2 args" (+ a b))
add-2

&gt; (procedure-documentation add-2)
"add-2 adds its 2 args"

&gt; (procedure-arity add-2)
(0 2 #f)

&gt; (procedure-source add-2)
(lambda* (a (b 32)) "add-2 adds its 2 args" (+ a b))
</pre>

<p>We can use procedure-environment and <a href="#__func__">__func__</a> to 
write a function that tells us where the source is for a function:
</p>

<pre>
(define (where-is func)
  (let ((addr (symbol-&gt;value <em class=red>'__func__</em> (<em class=red>procedure-environment</em> func))))
    (if (not (pair? addr))
	"not found"
	(format #f "~A is at line ~D of ~A" (car addr) (caddr addr) (cadr addr)))))

&gt; (where-is enveloped-mix)
"enveloped-mix is at line 68 of extensions.scm"
</pre>


<small>
<blockquote>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>procedure-source returns the actual function source &mdash;
more fun than a barrel of monkeys. Here is a self-modifying factorial function:
</p>

<pre>
(define fact         ; Reini Urban, http://autocad.xarch.at/lisp/self-mod.lsp.txt
  (let ((old '())
	(result '()))

    (define (last lst)
      (list-tail lst (- (length lst) 1)))

    (define (butlast lis)
      (let ((len (length lis)))
	(if (&lt;= len 1) '()
	    (let ((result '()))
	      (do ((i 0 (+ i 1))
		   (lst lis (cdr lst)))
		  ((= i (- len 1)) (reverse result))
		(set! result (cons (car lst) result)))))))

    (lambda (n)
      (cond ((zero? n) 1)
	    (#t 
	     (set! old (<em class=red>procedure-source</em> fact))
	     (set! fact (apply lambda '(n)
			  `((cond 
			    ,@(butlast (cdr (car (cdr (cdr old)))))
			    ((= n ,n) ,(let ()
					 (set! result (* n (fact (- n 1))))
					 result))
			    ,@(last (cdr (car (cdr (cdr old)))))))))
	     result)))))
</pre>

<p>If you modify the procedure source directly, it is safest to redefine the procedure (as above)
so that everything in s7 knows about the change.  
<a href="#augmentenv">augment-environment</a> serves a similar purpose when editing environments.
Here's a more useful example; it adds trace and local variable info for debugging:
</p>

<pre>
(define-macro (procedure-annotate proc)
  (let ((orig (<em class=red>procedure-source</em> proc)))

    (define (proc-walk source)
      (if (pair? source)
	  (if (or (eq? (car source) 'let)     ; if let or let*, show local variables
		  (eq? (car source) 'let*))
	      (if (symbol? (cadr source))
		  ;; (let name vars . body) -&gt; (let name vars print-vars . body)
		  (append 
		   (list (car source)
			 (cadr source)
			 (caddr source)
			 `(format #t "    (let ~A (~{~A~^ ~}) ...)~%" ,(cadr source) (car (environment-&gt;list (current-environment)))))
		   (cdddr source))
		  ;; (let(*) vars . body) -&gt; (let vars print-vars . body)
		  (append 
		   (list (car source)
			 (cadr source)
			 `(format #t "    (~A (~{~A~^ ~}) ...)~%" ,(car source) (car (environment-&gt;list (current-environment)))))
		   (cddr source)))
	      (cons (proc-walk (car source))
		    (proc-walk (cdr source))))
	  source))

    (let* ((new-body (proc-walk orig))
	   (result (gensym))
	   (new-source 
	    `(lambda ,(cadr orig)
	       (let ((,result #&lt;undefined&gt;))
		 (dynamic-wind
		     (lambda ()       ; upon entry, show procedure name and args
		       (format #t "(~A~{ ~A~})~%" ',proc (caddr (environment-&gt;list (current-environment)))))
		     (lambda ()
		       (set! ,result (,new-body ,@(cadr orig)))
		       ,result)
		     (lambda ()       ; at exit, show result
		       (if (eq? ,result #&lt;undefined&gt;)
			   (format #t "  ~A returns early~%")
			   (format #t "  ~A returns ~A~%" ',proc ,result))))))))

      `(set! ,proc (eval ,new-source)))))
			 
&gt; (define (hi a) (let ((b 12)) (+ b a)))
hi
&gt; (procedure-annotate hi)
#&lt;closure&gt;
&gt; (let ((x 32)) (+ 1 (hi x)))
45
;; printing: 
(hi (a . 32))
    (let ((b . 12)) ...)
  hi returns 44
</pre>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Since define* accepts multiple rest arguments, perhaps procedure-arity should return that number,
rather than a boolean.  I haven't run into a case where it matters.  Another odd case: 
<code>(procedure-arity (lambda* (:allow-other-keys) #f))</code>.  How should we indicate
this in procedure-arity?
</p>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<pre>
(define (for-each-subset func args)
  ;; form each subset of args, apply func to the subsets that fit its arity
  (let* ((arity (<em class=red>procedure-arity</em> func))
	 (min-args (car arity))                      ; required args
	 (max-args (if (caddr arity)                 ; rest arg?
		       (length args)
		       (+ min-args (cadr arity)))))  ; required+optional
    (define (subset source dest len)
      (if (null? source)
	  (if (&lt;= min-args len max-args)             ; does this subset fit?
	      (apply func dest))
	(begin
	  (subset (cdr source) (cons (car source) dest) (+ len 1))
	  (subset (cdr source) dest len))))
    (subset args '() 0)))
</pre>


</blockquote>
</small>


</dd>
<br><br>



<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="environments"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>environment info</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>An environment holds symbols and their values.  The global environment, for example,
holds all the variables that are defined at the top level.
Environments are first class objects in s7.  
</p>

<pre>
  (<a name="environmentp">environment?</a> obj)            #t if obj is an environment
  (<a name="globalenvironment">global-environment</a>)          the top-level environment
  (<a name="currentenvironment">current-environment</a>)         the currently visible variables and their values
  (<a name="procedureenvironment">procedure-environment</a> proc)  the environment at the time when proc was defined
  (<a name="initialenvironment">initial-environment</a>)         the current environment, but all built-in functions have their original values

  (<a name="withenvironment">with-environment</a> env . body) evaluate body in the environment env 

  (<a name="augmentenvironment">augment-environment</a> env . bindings)   add bindings to env
  (<a name="augmentenvironment!">augment-environment!</a> env . bindings)
  (<a name="environmenttolist">environment-&gt;list</a> env)       return the environment as a list of lists of (symbol . value) cons's
  (<a name="symboltovalue">symbol-&gt;value</a> sym (env (current-environment)))
  (<a name="definedp">defined?</a> sym (env (current-environment)))
  (<a name="symboltable">symbol-table</a>)
</pre>

<A NAME="augmentenv"></A>
<p><code>(with-environment env . body)</code> evaluates its body in the environment env.
There are several examples of its use in the <a href="#macros">macro</a> section.
defined? returns #t if the symbol is defined in the environment, and
symbol-&gt;value returns the value associated with it.
To add or change a symbol's value, use augment-environment:
</p>

<pre>
(let ((a 1)) 
  (eval '(+ a b) 
         (<em class=red>augment-environment</em>
           (current-environment) 
           (cons 'b 32)))) ; add 'b with the value 32 to this environment

-&gt; 33
</pre>

<p>augment-environment does not change the environment passed to it.  It
just prepends the new bindings, shadowing any old ones,
as if you had called "let".  To add the bindings directly to the environment,
use augment-environment!.  Both of these functions accept nil as the
'env' argument.  In this case, they return an environment containing
only the bindings you pass in.
</p>

<p>It is possible in Scheme to redefine built-in functions such as car.
To ensure that some code sees the original built-in function definitions,
wrap it in <code>(with-environment (initial-environment) ...)</code>:
</p>
<pre>
&gt; (let ((caar 123)) 
    (+ caar (with-environment (initial-environment) 
              (caar '((2) 3)))))
125
</pre>

<p>
with-environment and initial-environment are constants, so you can
use them in any context without worrying about whether they've been redefined.
I think these functions can implement the notions of libraries,
separate namespaces, or modules.  
Here's one way: first the library writer just writes his library.
The normal user simply loads it.  The abnormal user worries about everything,
so first he loads the library in a local let to make sure no bindings escape 
to pollute his code, and then he
uses initial-environment to
make sure that none of his bindings pollute the library code:
</p>

<pre>
(let ()
  (with-environment (initial-environment)
    (load "any-library.scm" (current-environment)) ; by default load puts stuff in the global environment
    ...))
</pre>

<p>Now Abnormal User can do what he wants with the library entities.
Say he wants to use "lognor" under the name "bitwise-not-or", and
all the other functions are of no interest:
</p>

<pre>
(begin
  (define bitwise-not-or #f)
  (let ()
    (with-environment (initial-environment)
      (load "any-library.scm" (current-environment))
      (set! bitwise-not-or (symbol-&gt;value 'lognor)))))
</pre>

<p>Or equivalently:
</p>

<pre>
(augment-environment! (current-environment)
  (cons 'bitwise-not-or 
    (symbol-&gt;value 'lognor
      (with-environment (initial-environment)
        (load "any-library.scm" (current-environment))
        (current-environment)))))
</pre>

<p>Say he wants to make sure the library is cleanly loaded, but all
its bindings are exported into the current environment:
</p>

<pre>
(apply augment-environment! (current-environment)
  (with-environment (initial-environment)
    (load "any-library.scm" (current-environment))
    (car (environment-&gt;list (current-environment))))) ; these are the bindings introduced by loading the library
</pre>

<p>To do the same thing, but prepend "library:" to each name:
</p>

<pre>
(apply augment-environment! (current-environment)
  (with-environment (initial-environment)
    (load "any-library.scm" (current-environment))
    (map (lambda (binding)
	   (cons (string-&gt;symbol 
		  (string-append "library:" (symbol-&gt;string (car binding))))
		 (cdr binding)))
	 (car (environment-&gt;list (current-environment))))))
</pre>

<p>That's all there is to it!
</p>

<p>
<code>(symbol-table)</code> returns the symbol table, a vector of lists of symbols.
Here we scan the symbol table looking for any function that doesn't have documentation:
</p>

<pre>
       (let ((st (<em class=red>symbol-table</em>)))
         (do ((i 0 (+ i 1))) 
             ((= i (vector-length st)))
           (let ((lst (vector-ref st i)))
             (for-each 
               (lambda (sym)
       	         (if (<em class=red>defined?</em> sym)
	             (let ((val (<em class=red>symbol-&gt;value</em> sym)))
	               (if (and (procedure? val)
			        (string=? "" (procedure-documentation val)))
		           (format #t "~A " sym)))))
               lst))))
</pre>

<p>But geez how boring can something be?  Nobody cares about procedure-documentation!
Here's a better example, an automatic software torture tester.  Even in kiddie mode
where we only feed in a few constants, I bet it segfaults!
</p>

<pre>
(let ((constants (list #f #t pi () 1 1.5 3/2 1.5+i)))

  (define (autotest func args args-left)
    (catch #t (lambda () (apply func args)) (lambda any #f))
    (if (&gt; args-left 0)
	(for-each
	 (lambda (c)
	   (autotest func (cons c args) (- args-left 1)))
	 constants)))

  (let ((st (<em class=red>symbol-table</em>)))
    (do ((i 0 (+ i 1))) 
	((= i (length st)))
      (let ((lst (st i)))
	(for-each 
	 (lambda (sym)
	   (if (<em class=red>defined?</em> sym)
	       (let ((val (<em class=red>symbol-&gt;value</em> sym)))
		 (if (procedure? val)
		     (let* ((arity (procedure-arity val))
			    (req (car arity))
			    (opt (cadr arity))
			    (rst (caddr arity)))
		       (if (or (&gt; (+ opt req) 4)
		       	       (member (symbol-&gt;string sym) '("trace" "exit" "abort")))
			   (format #t ";skip ~A for now~%" sym) ; no time! no time!
			   (begin
			     (format #t ";whack on ~A...~%" sym)
			     (autotest val '() (+ req opt 1 (if rst 1 0))))))))))
	 lst)))))
</pre>


</dd>
<br><br>



<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="evalstring"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>eval</h4></td></tr></table>
</td></tr></table>
</dt>

<dd>

<p>
<b>eval</b> evaluates its argument, a list representing a piece of code.  It takes an optional
second argument, the environment in which the evaluation should take place.  <b>eval-string</b>
is similar, but its argument is a string.
</p>

<pre>
&gt; (eval '(+ 1 2))
3

&gt; (eval-string "(+ 1 2)")
3
</pre>

<small>
<blockquote>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>The environment argument is mainly useful in debugging.  A breakpoint can be set, for
example, then any input is evaluated in the environment of the break.  Say we have the
following code in ex.scm:
</p>

<pre>
(define-macro (break)
  `(let ((break-env (<em class=red>current-environment</em>))
	 (prompt (format #f "~%~A &gt; " (if (defined? '__func__) __func__ "break"))))
     (call-with-exit
      (lambda (return)
	(do () ()                       ; our debugger's own REPL
	  (display prompt)              ; show where we stopped
	  (let ((str (read-line '())))  ; read a line of input, :go -&gt; exit the debugger
	    ;; the nil argument to read-line makes sure that we read C's stdin.  In any normal
	    ;;    program, we'd get the string from a text widget.
	    (if (&gt; (length str) 0)
		(catch #t               ; try to handle typing mistakes etc
		       (lambda ()
			 (let ((val (<em class=red>eval-string</em> str <em class=red>break-env</em>)))
			   (if (eq? val :go)
			       (return))
			   (write val)))
		       (lambda args
			 (format #t "error: ~A" args))))))))))

;; now some random code that has a breakpoint
(define (a-function b)
  (let ((x 32))
    (do ((i 0 (+ i 1)))
	((= i 10))
      (if (= i 3)
	  (<em class=red>break</em>)))
    x))

(a-function 123)
(display "done!") (newline)
</pre>

<p>
Start up a REPL, and:
</p>

<pre>
&gt; (load "ex.scm")
(a-function "ex.scm" 26) &gt; x    ; here we're in the debugger
32
(a-function "ex.scm" 26) &gt; (+ b i)
126
(a-function "ex.scm" 26) &gt; :go
done!
</pre>

</blockquote>
</small>
</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="IO"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>IO functions</h4></td></tr></table>
</td></tr></table>
</dt>

<dd>
<p>Besides files, ports can also represent strings and functions.  The string port functions
are:
</p>

<pre>
    (with-output-to-string thunk)         ; open a string port as current-output-port, call thunk, return string
    (with-input-from-string string thunk) ; open string as current-input-port, call thunk
    (call-with-output-string proc)        ; open a string port, apply proc to it, return string
    (call-with-input-string string proc)  ; open string as current-input-port, apply proc to it
    (open-output-string)                  ; open a string output port
    (get-output-string port)              ; return output accumulated in the string output port
    (open-input-string string)            ; open a string input port reading string
</pre>

<pre>
(let ((result #f) 
      (p (<em class=red>open-output-string</em>)))
  (format p "this ~A ~C test ~D" "is" #\a 3)
  (set! result (<em class=red>get-output-string</em> p))
  (close-output-port p)
  result)
-&gt; "this is a test 3"
</pre>

<p>Other functions:
</p>

<ul>
<li>read-byte and write-byte: binary IO, named "read-u8" and "write-u8" in r6rs, I think
<li>read-line: line-at-a-time reads (for write-line, use format or for-each with write-char).
</ul>

<p>The variable <a name="vectorprintlength">*vector-print-length*</a> sets
the upper limit on how many vector elements are printed by object-&gt;string and format.
</p>

<p>When running s7 behind a GUI, you often want input to come from and output to go to
arbitrary widgets. The function ports provide a way to redirect IO.  See <a href="#functionportexample">below</a>
for an example.
</p>

<p>s7 also includes current-error-port and set-current-error-port.
</p>


<small>
<blockquote>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>binary-io.scm in the Snd package has functions that read and write integers and floats in
both endian choices in a variety of sizes.  Besides read-byte and write-byte, it uses
integer-decode-float, and the various bitwise operators.
</p>

</blockquote>
</small>

</dd>
<br><br>


<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="miscellanea"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>miscellanea</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p><b><a name="loadpath">*load-path*</a></b> is a list of directories to search when loading a file.
<b><a name="loadhook">*load-hook*</a></b> is a hook whose functions are called just before a file is loaded.  
The hook function argument is the filename.
While loading, the port-filename and port-line-number of the current-input-port can tell you
where you are in the file.
</p>

<pre>
(set! (hook-functions *load-hook*) (list (lambda (name) (format #t "loading ~S...~%" name))))
</pre>

<p>Here's a *load-hook* function that adds the loaded file's directory
to the *load-path* variable so that subsequent loads don't need to specify
the directory:
</p>

<pre>
(set! (hook-functions <em class=red>*load-hook*</em>)
  (list (lambda (filename)
          (let ((pos -1)
	        (len (length filename)))
            (do ((i 0 (+ i 1)))
	        ((= i len))
	      (if (char=? (filename i) #\/)
	          (set! pos i)))
            (if (positive? pos)
	        (let ((directory-name (substring filename 0 pos)))
	          (if (not (member directory-name <em class=red>*load-path*</em>))
		      (set! <em class=red>*load-path*</em> (cons directory-name *load-path*)))))))))
</pre>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>


<p>As in Common Lisp, <b><a name="featureslist">*features*</a></b> is a list describing what is currently loaded into s7.  You can
check it with the <b>provided?</b> function, or add something to it with <b>provide</b>.  In my version of Snd,
at startup *features* is:
</p>

<pre>
&gt; *features*
(snd11 snd snd-s7 snd-motif gsl alsa xm clm4 clm sndlib gmp s7)

&gt; (provided? 'gmp)
#t
</pre>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>



<p>Multi-line and in-line comments can be enclosed in #| and |#.
<code>(+ #| add |# 1 2)</code>.
</p>

<p>Leaving aside these two cases, and the booleans, #f and #t, you can specify your own handlers for 
tokens that start with "#".  <b><a name="sharpreaders">*#readers*</a></b> is a list of pairs: <code>(char . func)</code>.
"char" refers to the first character after the sharp sign (#). "func" is a function of
one argument, the string that follows the #-sign up to the next delimiter.  "func" is called
when #&lt;char&gt; is encountered.  If it returns something other than #f, the #-expression
is replaced with that value.  Scheme has several predefined #-readers for cases such
as #b1, #\a, #i123, and so on, but you can override these if you like.  If the string
passed in is not the complete #-expression, the function can use read-char or read to get the
rest.  Say we'd like #t&lt;number&gt; to interpret the number in base 12:
</p>

<pre>
(set! *#readers* 
      (cons (cons #\t (lambda (str) 
                        (string-&gt;number (substring str 1) 12)))
            *#readers*))

&gt; #tb
11
&gt; #t11.3
13.25
</pre>

<p>I use *#readers* primarily to implement a way to get the current line number and file name, along
the lines of C's __LINE__ and __FILE__.  port-line-number works if we're reading a file (during load
for example), and *error-info* has the same information if an error happens.  But during Snd's auto-test
sequence, there are many cases that aren't errors, and the file is no longer being loaded, but
I need to know where something unexpected happened.  So:
</p>

<pre>
(set! *#readers* 
      (cons (cons #\_ (lambda (str)
			(if (string=? str "__line__")
			    (port-line-number)
			    (if (string=? str "__file__")
			        (port-filename)
			        #f))))
            *#readers*))
</pre>

<p>Here's a reader macro for read-time evaluation:
</p>

<pre>
(set! *#readers*
  (cons (cons #\. (lambda (str)
		    (if (string=? str ".") (eval (read)) #f)))
	*#readers*))

&gt; '(1 2 #.(* 3 4) 5)
(1 2 12 5)
</pre>

<p>To return no value from a reader, use <code>(values)</code>.
</p>
<pre>
    &gt; (set! *#readers* (cons (cons #\; (lambda (s) (read) (values))) *#readers*))
    ((#\; . #&lt;closure&gt;))
    &gt; (+ 1 #;(* 2 3) 4)
    5
</pre>



<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>


<p>(<b>make-list</b> length (initial-element #f)) returns a list of 'length' elements defaulting to 'initial-element'.
</p>

<p><b>reverse!</b> is an in-place version of the built-in function reverse.  That is, 
it modifies the list passed to it in the process of reversing its contents.
<b>list-set!</b> sets a member of a list.  <b>sort!</b> sorts a list or a vector using the
function passed as its second argument to choose the new ordering.
</p>

<pre>
&gt; (sort! (list 3 4 8 2 0 1 5 9 7 6) &lt;)
(0 1 2 3 4 5 6 7 8 9)

(define (mix-notelists . notelists)
  ;; assume the 2nd parameter is the begin time in seconds (the 1st is the instrument name)
  (<em class=red>sort!</em>
   (apply append notelists)
   (lambda (note1 note2)
     (&lt; (cadr note1) (cadr note2)))))

(mix-notelists '((fm-violin 0 1 440 .1)
		 (fm-violin 1 1 550 .1))
	       '((bird 0 .1 )
		 (bird .2 .1)
		 (bird 1.2 .3)
		 (bird .5 .5)))

 -&gt; ((bird 0 0.1) (fm-violin 0 1 440 0.1) (bird 0.2 0.1) (bird 0.5 0.5) (fm-violin 1 1 550 0.1) (bird 1.2 0.3))
</pre>

<p>Despite the "!" in its name, sort! actually copies any list argument passed to it,
but vectors are sorted in place.  sort! can also handle any C-defined object, or anything from make-type,
that provides getter, setter, and length functions.
</p>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>


<p>
Keywords exist mainly for define*'s benefit.  The keyword functions are:
<b>keyword?</b>, <b>make-keyword</b>, <b>symbol-&gt;keyword</b>, and <b>keyword-&gt;symbol</b>.
A keyword is a symbol that starts or ends with a colon. The colon
is considered to be a part of the symbol name.  A keyword is a constant that evaluates to itself.
</p>



<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>


<p><b>help</b> tries to find information about its argument.
</p>

<pre>
&gt; (help 'caadar)
"(caadar lst) returns (car (car (cdr (car lst)))): (caadar '((1 (2 3)))) -&gt; 2"
</pre>

<p>If the initial expression in a function body is a string constant, it is assumed to be a documentation string (accessible via help or procedure-documentation):
</p>

<pre>
(define (add1 a)
  "(add1 a) adds 1 to its argument"
  (+ a 1))

&gt; (help add1)
"(add1 a) adds 1 to its argument"
</pre>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p><b>gc</b> calls the garbage collector.  <code>(gc #f)</code> turns off the GC, and <code>(gc #t)</code> turns it on.
</p>

<!--
<p>
<b>define-expansion</b> defines read-time macros, which are just dangerous enough that
I probably shouldn't document them.  It has the same syntax as
define-macro, and the same result except that the macro is
dealt with at read time!  (This means it does not respect attempts to
bind it to something else, which is asking for confusion).
</p>
-->

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>


<p>Some other differences from r5rs:
</p>

<ul>
<li>after the initial binding, do sets its step variables, rather than rebinding them.
<li>no force or delay (use slib).
<li>no syntax-rules or any of its friends.
<li>s7-version returns the current s7 version.
<li>no scheme-report-environment (use initial-environment), null-environment, or interaction-environment (use current-environment).
<li>no transcript-on or transcript-off.
<li><A NAME="__func__">__func__</a> is the name (or name and location) of the function currently being defined or called, as in C.
<li>begin returns the value of the last form; it can contain both definitions and other statements.
<li>#&lt;unspecified&gt;, #&lt;eof&gt;, and #&lt;undefined&gt; are first-class objects.
<li>for-each and map accept different length arguments; the operation stops when any argument reaches its end.
<li>for-each and map accept any applicable object as the first argument.
<li>letrec*, but without conviction.
<li>set! and *-set! return the new value, not #&lt;unspecified&gt;.
<li>port-closed?
<li>current-input-port, current-output-port, and current-error-port have setters
<li>the default IO ports are named *stdin*, *stdout*, and *stderr*.
<li>*gc-stats* is a boolean that controls whether GC stats are printed.
<li>member and assoc accept an optional 3rd argument, the comparison function (equal? is the default).
<li>case accepts => much like cond (the function argument is the selector).
</ul>

<small>
<blockquote>

<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Schemes vary in their treatment of ().  s7 considers it a constant that evaluates to itself,
so you rarely need to quote it.  <code>(eq? () '())</code> is #t.
This is consistent with, for example,
<code>(eq? #f '#f)</code> which is also #t.
The standard says "the empty list is a special object of its own type", so surely either choice is
acceptable in that regard.  One place where the quote matters is in a case statement; the selector is
evaluated but the key is not:
</p>

<pre>
&gt; (case '() ((()) 2) (else 1))
2
&gt; (case '() (('()) 2) (else 1)) ; (eqv? '() ''()) is #f
1
;;; which parallels #f (or a number such as 2 etc):
&gt; (case '#f ((#f) 2) (else 1))
2
&gt; (case '#f (('#f) 2) (else 1)) ; (eqv? '#f ''#f) is #f
1
</pre>

<p>Similarly, vector constants do not have to be quoted.  A list constant is quoted
to keep it from being evaluated, but
#(1 2 3) is as unproblematic as "123" or 123.
</p>

<!-- there's another sense in which '() is a constant: you can't apply it to anything. ('() 0) -> error
-->



<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Schemes also vary in handling trailing arguments:
<code>(* 0 "hi")</code> in Guile returns 0, but s7 gives an error.  
<code>(cond (1) (=&gt;))</code> is 1 in both,  and
<code>(or 1 2 . 3)</code> is an
error in Guile, and 1 in s7!
Because it flushes trailing arguments, Guile returns 0 from <code>(* 0 +inf.0)</code>, but I think it should return NaN.
</p>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>And a harder one... How should s7 treat this:
<code>(string-set! "hiho" 1 #\z)</code>, or 
<code>(vector-set! #(1 2 3) 1 32)</code>, or
<code>(list-set! '(1 2 3) 1 32)</code>?
Originally, in s7, the first two were errors, and the third was allowed, which doesn't make much sense.
Guile and Common Lisp accept all three, but that leads to weird cases where we can reach
into a function's body:
</p>

<pre>
&gt; (let ((x (lambda () '(1 2 3)))) (list-set! (x) 1 32) (x))
(1 32 3) ; s7, Guile

&gt; (flet ((x () '(1 2 3))) (setf (nth 1 (x)) 32) (x))
(1 32 3) ; Clisp

&gt; (let ((x (lambda () (list 1 2 3)))) (list-set! (x) 1 32) (x))
(1 2 3)
</pre>

<p>
But it's possible to reach into a function's closure, even when the
closed-over thing is a constant:
</p>

<pre>
&gt; (flet ((x () '(1 2 3))) (setf (nth 1 (x)) 32) (x))
(1 32 3)

&gt; (let ((xx (let ((x '(1 2 3))) (lambda () x)))) (list-set! (xx) 1 32) (xx))
(1 32 3)

&gt; (let ((xx (let ((x (list 1 2 3))) (lambda () x)))) (list-set! (xx) 1 32) (xx))
(1 32 3)
</pre>

<p>And it's possible to reach into a constant list via list-set! (or set-car! of course):
</p>

<pre>
&gt; (let* ((x '(1 2)) (y (list x)) (z (car y))) (list-set! z 1 32) (list x y z))
((1 32) ((1 32)) (1 32))
</pre>

<p>
It would be a programmer's nightmare to have to keep track of which piece of a list is
constant, and an implementor's nightmare to copy every list.  set! in all its forms is
used for its side-effects, so why should we try to put a fence around them?
If we flush "immutable constant" because it is a ham-fisted, whack-it-with-a-shovel approach,
the only real problem I can see is symbol-&gt;string.  In CL, this is explicitly an error:
</p>

<pre>
&gt; (setf (elt (symbol-name 'xyz) 1) #\X)
*** - Attempt to modify a read-only string: "XYZ"
</pre>

<p>And in Guile:
</p>

<pre>
&gt; (string-set! (symbol-&gt;string 'symbol-&gt;string) 1 #\X)
ERROR: string is read-only: "symbol-&gt;string"
</pre>

<p>So both have a notion of immutable strings.  
I wonder what other Scheme programmers (not implementors!) want in this situation.
Currently, there are no immutable list, string, or vector constants, and
symbol-&gt;string
returns a copy of the string.
One simple way to ensure immutability is to use copy:
</p>

<pre>
&gt; (let ((x (lambda () (copy "hiho")))) (string-set! (x) 1 #\x) (x))
"hiho"
</pre>

<p>There is one pitfall here.  s7 normally tries to optimize garbage collection by
removing some constants from the heap.  If that constant is a list or a vector, and you later
set some member of it to something that needs GC protection, nobody in the heap points to it, so
it is GC'd.  Here is an example:
</p>

<pre>
(define (bad-idea)
  (let ((lst '(1 2 3)))              ; or #(1 2 3) and vector-ref|set
    (let ((result (list-ref lst 1)))
     (list-set! lst 1 (* 2.0 16.6))
     (gc)
     result)))
</pre>

<p>Put this is a file, load it into the interpreter, then call <code>(bad-idea)</code> a
few times.  You can turn off the optimization in question by setting the variable <b>*safety*</b>
to 1.  *safety* defaults to 0.  (Also, if *safety* is not 0, sort! is safe from infinite loops).
</p>



<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>s7 handles circular lists and vectors and dotted lists with its customary aplomb.  
You can pass them to memq, or print them, for example; you can even evaluate them.  
The print syntax is borrowed from CL:
</p>

<pre>
&gt; (let ((lst (list 1 2 3))) 
    (set! (cdr (cdr (cdr lst))) lst) 
    lst)
#1=(1 2 3 . #1#)

&gt; (let* ((x (cons 1 2)) 
         (y (cons 3 x))) 
    (list x y))
(#1=(1 . 2) (3 . #1#)) ; shared lists use the same syntax: '((1 . 2) (3 1 . 2)) spelled out
</pre>

<p>But should this syntax be readable as well?  I'm inclined to say no because
then it is part of the language, and it doesn't look like the rest of the language.
(I think it's kind of ugly).  Perhaps we could implement it via *#readers*.
</p>

<p>Length returns +inf.0 if passed a circular list, and returns a negative
number if passed a dotted list.  In the dotted case, the absolute value of the length is the list length not counting
the final cdr.  <code>(define (circular? lst) (infinite? (length lst)))</code>.
</p>

<p>Here's an amusing use of circular lists:
</p>

<pre>
(define (for-each-permutation func vals)
  ;; apply func to every permutation of vals: 
  ;;   (for-each-permutation (lambda args (format #t "~{~A~^ ~}~%" args)) '(1 2 3))
  (define (pinner cur nvals len)
    (if (= len 1)
        (apply func (cons (car nvals) cur))
        (do ((i 0 (+ i 1)))                       ; I suppose a named let would be more Schemish
            ((= i len))
          (let ((start nvals))
            (set! nvals (cdr nvals))
            (let ((cur1 (cons (car nvals) cur)))  ; add (car nvals) to our arg list
              (set! (cdr start) (cdr nvals))      ; splice out that element and 
              (pinner cur1 (cdr start) (- len 1)) ;   pass a smaller circle on down, "wheels within wheels"
              (set! (cdr start) nvals))))))       ; restore original circle
  (let ((len (length vals)))
    (set-cdr! (list-tail vals (- len 1)) vals)    ; make vals into a circle
    (pinner '() vals len)
    (set-cdr! (list-tail vals (- len 1)) '())))   ; restore its original shape
</pre>
<br>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>s7 and Snd use "*" in a variable name, *features* for example, to indicate
that the variable is predefined.  It may occur unprotected in a macro, for
example.  The "*" doesn't mean that the variable is special in the CL sense of dynamic scope,
but some clear marker is needed for a global variable so that the programmer
doesn't accidentally step on it.  
</p>

<p>Although a variable name's first character is more restricted, currently
only #\null, #\newline, #\tab, #\space, #\), #\(, #\", and #\; can't
occur within the name.  I did not originally include double-quote in this set, so wild stuff like
<code>(let ((nam""e 1)) nam""e)</code>
would work, but that means that <code>'(1 ."hi")</code> is parsed as a 1 and the
symbol <code>."hi"</code>, and <code>(string-set! x"hi")</code> is an error.
The first character should not be #\#, #\', #\`, #\,, #\:, or any of those mentioned above,
and some characters can't occur by themselves.  For example, "." is not a legal variable
name, but ".." is. 
These weird symbols have to be printed sometimes:
</p>

<pre>
&gt; (list 1 (string-&gt;symbol (string #\; #\" #\\)) 2)
(1 ;"\ 2)            <!-- " -->
&gt; (list 1 (string-&gt;symbol (string #\.)) 2)
(1 . 2)
</pre>

<p>which is a mess.  Guile prints the first as <code>(1 #{\;\"\\}# 2)</code>.
In CL and some Schemes:
</p>

<pre>
[1]&gt; (list 1 (intern (coerce (list #\; #\" #\\) 'string)) 2) ; thanks to Rob Warnock
(1 |;"\\| 2)        <!-- " -->
[2]&gt; (equalp 'A '|A|) ; in CL case matters here
T
</pre>

<p>This is clean, and has the weight of tradition behind it, but 
I think I'll use "symbol" instead:
</p>

<pre>
&gt; (list 1 (string-&gt;symbol (string #\; #\" #\\)) 2)
(1 (symbol ";\"\\") 2)       <!-- " -->
</pre>

<p>
This output is readable, and does not eat up perfectly good
characters like vertical bar, but it means we can't easily use
variable names like "| e t c |".  We could allow a name to
contain any characters if it starts and ends with "|",
but then one vertical bar is trouble.  
</p>

<p>
These symbols are not just a silly optimization of string comparison:
</p>

<pre>
(define-macro (hi a) 
  (let ((funny-name (string-&gt;symbol (string #\;))))
    `(let ((,funny-name ,a)) (+ 1 ,funny-name))))

&gt; (hi 2)
3
&gt; (macroexpand (hi 2))
(let ((; 2)) (+ 1 ;))    ; for a good time, try (string #\") 

(define-macro (hi a) 
  (let ((funny-name (string-&gt;symbol "| e t c |")))
    `(let ((,funny-name ,a)) (+ 1 ,funny-name))))
&gt; (hi 2)
3
&gt; (macroexpand (hi 2))
(let ((| e t c | 2)) (+ 1 | e t c |))

&gt; (let ((funny-name (string-&gt;symbol "| e t c |"))) ; now use it as a keyword arg to a function
    (apply define* `((func (,funny-name 32)) (+ ,funny-name 1)))
    ;; (procedure-source func) is (lambda* ((| e t c | 32)) (+ | e t c | 1))
    (apply func (list (symbol-&gt;keyword funny-name) 2)))
3
</pre>

<p>I hope that makes you as happy as it makes me!
</p>



<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>The built-in syntactic names, such as "begin", are almost first-class citizens.
</p>

<pre>
&gt; (let ((progn begin)) 
    (progn 
      (define x 1) 
      (set! x 3) 
      (+ x 4)))
7

&gt; (let ((function lambda)) 
    ((function (a b) (list a b)) 3 4))
(3 4)

&gt; (apply begin '((define x 3) (+ x 2)))
5

&gt; ((lambda (n) (apply n '(((x 1)) (+ x 2)))) let)
3

&gt; (define-macro (symbol-set! var val) ; use apply instead of define-bacro
    `(apply set! ,var (list ,val)))
</pre>

<p>We can snap together program fragments ("look Ma, no macros!"):
</p>

<pre>
(let* ((x 3) 
       (arg '(x)) 
       (body `((+ ,x x 1)))) 
  ((apply lambda arg body) 12)) ; "legolambda"?

(let ()
  (define (hi a) (+ a x))
  ((apply let '((x 32)) (list (procedure-source hi))) 12)) ; one function, many closures?
</pre>

<p>If you apply define or define-macro, the returned value is a symbol, so to apply the
new function or macro, you need to use either eval or symbol-&gt;value:
</p>

<pre>
&gt; ((symbol-&gt;value (apply define-macro '((m a) `(+ 1 ,a)))) 3)
4
&gt; ((symbol-&gt;value (apply define '((hi a) (+ a 1)))) 3)
4
</pre>

<p>This gives us a way to make anonymous macros, just as lambda returns an anonymous function:
</p>

<pre>
(define-macro (mu args . body)
  (let ((m (gensym)))
    `(symbol-&gt;value (apply define-macro '((,m ,@args) ,@body)))))

&gt; ((mu (a) `(+ 1 ,a)) 3)
4
</pre>

<p>
Currently, you can't set! a built-in syntactic object to some new value:
<code>(set! if 3)</code>.
I hope this kind of thing is not actually very useful, but let me
know if you need it.  The issue is purely one of speed.
</p>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>
In s7, there is only one kind of begin statement,
and it can contain both definitions and expressions.  These are evaluated in the order
in which they occur, and in the environment at the point of the evaluation.  I think
of it as being a little REPL.  begin does not introduce a new frame in
the current environment, so defines happen at the enclosing level.
</p>

<pre>
&gt; (let ((y 2)) 
      (let ((x 1)) 
        (begin 
          (define x y)         ; x is 2 (this x is the same as the x in the let above it)
          (set! x (* x 2))     ; now it is 4
          (define y 123))      ; this is great, but it doesn't affect x 
         x))                   ; defines in begin are in the enclosing environment so
   4                           ;   we get 4
</pre>



<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>I can't find the right tone for this section; this is the 400-th revision; I wish I were a better writer!
I think the exact/inexact distinction in Scheme is confused and useless, and leads
to verbose and buggy code.  
In some Schemes,
"rational" means "could possibly be
expressed equally well as a ratio (floats are approximations)".  In s7 it's: "is actually expressed as a ratio (or an integer of course)";
otherwise "rational?" is the same as "real?":
</p>

<pre>
(not-s7-scheme)&gt; (rational? (sqrt 2))
#t
</pre>

<p>As I understand it, "inexact" originally meant "floating point", and "exact" meant integer or ratio of integers.
But words have a life of their own.
0.0 somehow became an "inexact" integer (although it can be represented exactly in floating
point).  
+inf.0 must be an integer &mdash;
its fractional part is explicitly zero!  But +nan.0... 
And then there's:
</p>

<pre>
(not-s7-scheme)&gt; (integer? 9007199254740993.1)
#t
</pre>

<p>
When does this matter?  I often need to index into a vector, but the index is a float (a "real" in Scheme-speak: its
fractional part can be non-zero).
In one Scheme:
</p>

<pre>
(not-s7-scheme)&gt; (vector-ref #(0) (floor 0.1))
ERROR: Wrong type (expecting exact integer): 0.0   ; [why?  "it's probably a programmer mistake"!]
</pre>

<p>Not to worry, I'll use inexact-&gt;exact:
</p>

<pre>
(not-s7-scheme)&gt; (inexact-&gt;exact 0.1)
3602879701896397/36028797018963968                  ; [why? "floats are ratios"!]
</pre>

<p>So I end up using the verbose <code>(floor (inexact-&gt;exact ...))</code> everywhere, and even
then I have no guarantee that I'll get a legal vector index.
When I started work on s7, I thought perhaps
"exact" could mean "is represented exactly in the computer".  We'd have integers and ratios exact; 
reals and complex exact if they are exactly
represented in the current floating point implementation.  
0.0 and 0.5 might be exact if the printout isn't misleading, and 0.1 is inexact.
"integer?" and friends would refer instead to the programmer's point of view.
That is, if the programmer uses 1 or if the thing prints as 1, it is the integer 1, whereas 1.0
means floating point (not integer!).
And to keep exactness in view, we'd have
to monitor which operations introduce inexactness &mdash; a kind of interval arithmetic.
But then what would inexact-&gt;exact do?  
If we discard the exact/inexact distinction,
we can maintain backwards compatibility via:
</p>

<pre>
    (define exact? rational?)
    (define (inexact? x) (not (rational? x)))
    (define inexact-&gt;exact rationalize) ; or floor
    (define (exact-&gt;inexact x) (* x 1.0))
</pre>

<p>#i and #e are also useless because you can
have any number after, for example, #b:
</p>

<pre>
    &gt; #b1.1
    1.5
    &gt; #b1e2
    4.0
    &gt; #o17.5+i
    15.625+1i
</pre>

<p>Speaking of #b and friends, what should <code>(string-&gt;number "#xffff" 2)</code> return?
</p>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>r7rs:
</p>

<pre>

  (define vector-map map) (define vector-for-each for-each) (define copy-vector copy) (define (vector-&gt;string vect) (apply string (vector-&gt;list vect)))
  (define string-map map) (define string-for-each for-each) (define (string-&gt;vector str) (apply vector (string-&gt;list str)))
  (define copy-list copy)

  (define string-ni=? string=?) (define string-ni&lt;? string&lt;?) (define string-ni&gt;? string&gt;?) 
  (define string-ni&lt;=? string&lt;=?) (define string-ni&gt;=? string&gt;=?)   
  (define char-foldcase char-downcase) (define string-foldcase string-downcase)
  (define (string-downcase str) (apply string (map char-downcase str)))
  (define (string-upcase str) (apply string (map char-upcase str)))

  (define -inf.0 (real-part (log 0.0))) (define +inf.0 (- -inf.0)) (define +nan.0 (/ +inf.0 +inf.0))
  (define (finite? n) (and (number? n) (not (nan? n)) (not (infinite? n))))

  (define exact-integer? integer?)	
  (define (exact-integer-sqrt i) (let ((sq (floor (sqrt i)))) (values sq (- i (* sq sq)))))

  (define (port-open? p) (not (port-closed? p))) (define (character-port? p) #t) (define (binary-port? p) #t)
  (define (port? p) (or (input-port? p) (output-port? p)))

  (define read-u8 read-byte) (define write-u8 write-byte) (define u8-ready? char-ready?) (define peek-u8 peek-char)
  (define blob? vector?) (define make-blob make-vector) (define blob-length length) (define blob-copy copy)
  (define blob-u8-ref vector-ref) (define blob-u8-set! vector-set!)

  (define scheme-report-environment initial-environment)
  (define interaction-environment current-environment)
  (define (include file) (load file (current-environment)))

  (set! *#readers* (cons (cons #\; (lambda (s) (read) (values))) *#readers*))
<!--
  ;; and why no blob-&gt;string, blob-for-each, exact-integer-expt, euclidean-rationalize ...?
  modules: include-ci import export
  raise raise-continuable error [error msg obj] guard
  define-record-type
  parameter objects: make-parameter parameterize
  copy-partial-blob[!] copy-blob!
  case-lambda
  file-exists? delete-file command-line
  getenv? time?: get-environment-variable[s] current-jiffy|second jiffies-per-second current-posix-second
  "complete" set of int div: truncate-quotient truncate-remainder truncate/ round-* floor-* euclidean-*? ceiling-*
  with-exception-handler null-environment
-->
</pre>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Here are some additional changes I'd make to s7 if I didn't care about compatibility with other Schemes:
</p>

<pre>
   remove the exact/inexact distinction including #i and #e
   remove `#(...) support (quasiquoted vector constants)
   remove *-ci functions
   remove string&lt;-&gt;list and vector&lt;-&gt;list
   change string-&gt;symbol to symbol
   remove call-with-values and its friends
   remove char-ready?
   change eof-object? to eof? or end-of-input? or just omit it (you can use eq? #&lt;eof&gt;)
   use @ as the exponent marker if base &gt; 10
   remove the "d", "f", "s", and "l" exponent markers (leaving "e" and "E")
</pre>

<p>and perhaps:
</p>

<pre>
   remove even? and odd?
   remove the 4-way cxxxxr functions
   add file-exists?, directory?, and delete-file
   remove string-length, vector-length, and hash-table-size.
   remove list-ref|set!, string-ref|set!, vector-ref|set!, hash-table-ref|set!,
     set-car!|cdr!, and set-current-output|input|error-port.
</pre>



<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>Scheme needs a more elegant way to define functions that share a closure.  The begin+define+let+set! shuffle used
above is an embarrassment.
Here's an idle thought:
</p>

<pre>
(define f1 (let ((x 23))
	     (lambda (a)
	       (+ x a))))
(define f2
  (with-environment (procedure-environment f1) ; import f1's closure ("x") into f2
   (lambda (b)
     (+ b (* 2 x)))))

&gt; (+ (f1 1) (f2 1))
71
</pre>


<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>s7 originally had multithreading support, but I removed it in August, 2011.
It turned out to be less useful than I hoped,
mainly because s7 threads shared the heap and therefore had to coordinate
all cell allocations.  It was faster and simpler to use multiple
pthreads each running a separate s7 interpreter, rather than one s7
running multiple s7 threads.  In CLM, there was also contention for access
to the output stream.  In GUI-related situations, as discussed at length below,
threads were not useful mainly because the GUI toolkits are not thread safe,
so we use begin_hook now instead.
Last but not least, the effort to make the non-threaded
s7 faster messed up parts of the threaded version.  Rather than
waste a lot of time fixing this, I chose to flush multithreading.
</p>



<table border=0 vspace=8 width=30% cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>


<p>"Life", a poem.
</p>

<pre>
(+(*(+))(*)(+(+)(+)(*)))
(((((lambda () (lambda () (lambda () (lambda () 1))))))))
(+ (((lambda () values)) 1 2 3))
(map apply (list map) (list map) (list (list *)) '((((1 2)) ((3 4 5)))))
(do ((do do do)) (do do do))
(*(*)(*) (+)(+) 1)
</pre>

</blockquote>
</small>

</dd>
<br>
<br><br>




<!-- -------------------------------------------------------------------------------- -->
<dt>
<A NAME="s7rundoc"></a>
<table border=0 bordercolor="lightgreen" width=50% cellpadding=1 cellspacing=0><tr><td bgcolor="lightgreen">
<table width=100% border=0 cellpadding=8><tr><td bgcolor="#EEFDEE" valign="middle"><h4>the run macro</h4></td></tr></table>
</td></tr></table>
</dt>

<dd><p>s7 is primarily aimed at computer music, CLM-based sound synthesis in particular.
A CLM instrument is usually a do-loop running things like oscillators and envelopes
for zillions of sound samples.  These calculations do not involve recursion, or
complex numbers, or fancy list processing, so it is not too hard to write an
optimizer for them.  In sndlib, that optimizer is called "run".  It is a macro (in modern jargon, a JIT byte compiler)
that can be wrapped around any piece of Scheme code that you want to speed up.
If it can't optimize the code, it passes it to the s7 interpreter.  If run is successful,
you will normally get a speed up by a factor of about 10.
</p>

</dd>
<br><br>

</dl>


<!-- -------------------------------------------------------------------------------- -->
<A NAME="FFIexamples"></a>
<table border=0 bordercolor="lightgreen" width=100% cellpadding=2 cellspacing=0><tr><td bgcolor="lightgreen">
<table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h3>FFI examples</h3></td></tr></table>
</td></tr></table>

<p>s7 exists only to serve as an extension of some other application, so
it is primarily a foreign function interface.  s7.h has lots of comments about the individual
functions.  Here I'll collect some complete examples.  s7.c depends on the following
compile-time flags:
</p>

<pre>
    HAVE_STDBOOL_H                 1 if you have stdbool.h
    WITH_GMP                       1 if you want multiprecision arithmetic (requires gmp, mpfr, and mpc, default is 0)
    WITH_COMPLEX                   1 if your compiler supports complex numbers
    HAVE_COMPLEX_TRIG              1 if your math library has complex versions of the trig functions
    S7_DISABLE_DEPRECATED          1 if you want to make sure you're not using any deprecated s7 stuff (default is 0)
    HAVE_GETTIMEOFDAY              1 if you want timing info from the GC (default is 0)
    WITH_EXTRA_EXPONENT_MARKERS    1 if you want "d", "f", "l", and "s" in addition to "e" as exponent markers (default is 1)
</pre>

<p>See the comment at the start of s7.c for more information about these switches.
s7.h defines the two main number types: s7_Int and s7_Double.
The examples that follow show:
</p>

<ul>
<li><a href="#repl">read-eval-print loop (and emacs)</a>
<li><a href="#defun">define a function with arguments and a returned value, and define a variable </a>
<li><a href="#defvar">call a Scheme function from C, and get/set Scheme variable values in C</a>
<li><a href="#juce">C++ and Juce</a>
<li><a href="#sndlib">load sndlib using the XEN functions and macros</a>
<li><a href="#pwstype">add a new Scheme type and a procedure-with-setter</a>
<li><a href="#functionportexample">redirect display output to a C procedure</a>
<li><a href="#extendop">extend a built-in operator ("+" in this case)</a>
<li><a href="#definestar1">C-side define* (s7_define_function_star)</a>
<li><a href="#definemacro1">C-side define-macro (s7_define_macro)</a>
<li><a href="#signal">signal handling (C-C to break out of an infinite loop)</a>
<li><a href="#vector">direct multidimensional vector element access</a>
<li><a href="#notify">notification in C that a Scheme variable has been set!</a>
<li><a href="#namespace">Load C defined stuff into a separate namespace</a>
<li><a href="#Cerrors">Error handling in C</a>
<li><a href="#closure">Closure defined in C</a>
<li><a href="#testhook">Hooks in C and Scheme</a>
<li><a href="#cload">Load a C module dynamically</a>
<li><a href="#gmpex">gmp and friends</a>
<li><a href="#gtkrepl">Gtk-based REPL</a>
<li><a href="#gtkschemerepl">Gtk/Scheme-based REPL</a>
<li><a href="#s7inathread">s7 running in a separate thread</a>
<li><a href="#replrescue">begin_hook to the rescue!</a>
</ul>

<br><br>



<table border=0 vspace=8 width=30% hspace=100 cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<p>
<A NAME="repl"></a>
First, a bare REPL:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include "s7.h"

static s7_pointer our_exit(s7_scheme *sc, s7_pointer args) 
{
  /* all added functions have this form, args is a list, 
   *    s7_car(args) is the 1st arg, etc 
   */
  exit(1);
  return(s7_nil(sc)); /* never executed, but makes the compiler happier */
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];

  s7 = <em class=red>s7_init</em>();                     /* initialize the interpreter */
  <em class=red>s7_define_function</em>(s7, "exit", our_exit, 0, 0, false, "(exit) exits the program");
                                      /* add the function "exit" to the interpreter.
                                       *   0, 0, false -&gt; no required args,
				       *                  no optional args,
				       *                  no "rest" arg
				       */
  while (1)                           /* fire up a REPL */
    {
      fprintf(stdout, "\n&gt; ");        /* prompt for input */
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  <em class=red>s7_eval_c_string</em>(s7, response); /* evaluate input and write the result */
	}
    }
}

/* make mus-config.h (it can be empty), then
 *
 *   gcc -c s7.c -I.
 *   gcc -o doc7 doc7.c s7.o -lm -I.
 *
 * run it:
 *
 *    doc7
 *    &gt; (+ 1 2)
 *    3
 *    &gt; (define (add1 x) (+ 1 x))
 *    add1
 *    &gt; (add1 2)
 *    3
 *    &gt; (exit)
 */
</pre>
</td></tr></table>
<br>
<p>Since this reads stdin and writes stdout, it can be run as a Scheme subjob of emacs.
One (inconvenient) way to do this is to set the emacs variable scheme-program-name to
the name of the exectuable created above ("doc7"), then call the emacs function run-scheme:
M-x eval-expression in emacs, followed by (setq scheme-program-name "doc7"), then
M-x run-scheme, and you're talking to s7 in emacs.  Of course, this connection can be
customized indefinitely.  See, for example, snd-inf.el in the Snd package.
</p>

<p>To read stdin while working in a GUI-based program is trickier.  In glib/gtk, you can use
something like this:
</p>
<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
static gboolean read_stdin(GIOChannel *source, GIOCondition condition, gpointer data)
{
  /* here read from g_io_channel_unix_get_fd(source) and call s7_eval_string */
  return(true);
}

/* ... during initialization ... */

GIOChannel *channel;
channel = g_io_channel_unix_new(STDIN_FILENO);  /* watch stdin */
stdin_id = g_io_add_watch_full(channel,         /* and call read_stdin above if input is noticed */
			       G_PRIORITY_DEFAULT, 
			       (GIOCondition)(G_IO_IN | G_IO_HUP | G_IO_ERR), 
			       <em class=red>read_stdin</em>, NULL, NULL);
g_io_channel_unref(channel);
</pre>
</td></tr></table>

<p>If we accidentally get into an infinite loop in our REPL, we have to exit the program.
See <a href="#signal">signal handling</a> and <a href="#replrescue">begin_hook to the rescue!</a> below for two ways to fix this.
</p>
<br><br>



<table border=0 vspace=8 width=30% hspace=100 cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<A NAME="defun"></a>
<p>Define a function with arguments and a returned value, and a variable:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer our_exit(s7_scheme *sc, s7_pointer args)
{
  exit(1);
  return(s7_nil(sc));
}

static s7_pointer add1(s7_scheme *sc, s7_pointer args)
{
  if (<em class=red>s7_is_integer</em>(s7_car(args)))
    return(<em class=red>s7_make_integer</em>(sc, 1 + <em class=red>s7_integer</em>(s7_car(args))));
  return(s7_wrong_type_arg_error(sc, "add1", 1, s7_car(args), "an integer"));
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];

  s7 = s7_init();                     /* initialize the interpreter */
  
  s7_define_function(s7, "exit", our_exit, 0, 0, false, "(exit) exits the program");
  s7_define_function(s7, "add1", add1, 1, 0, false, "(add1 int) adds 1 to int");
  <em class=red>s7_define_variable</em>(s7, "my-pi", <em class=red>s7_make_real</em>(s7, 3.14159265));

  while (1)                           /* fire up a "repl" */
    {
      fprintf(stdout, "\n&gt; ");        /* prompt for input */
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response); /* evaluate input and write the result */
	}
    }
}

/*    doc7
 *    &gt; my-pi
 *    3.14159265
 *    &gt; (+ 1 (add1 1))
 *    3
 *    &gt; (exit)
 */
</pre>
</td></tr></table>
<br><br>



<table border=0 vspace=8 width=30% hspace=100 cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<A NAME="defvar"></a>
<p>Call a Scheme-defined function from C, and get/set Scheme variable values in C:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

int main(int argc, char **argv)
{
  s7_scheme *s7;
  s7 = s7_init();

  s7_define_variable(s7, "an-integer", s7_make_integer(s7, 1));
  s7_eval_c_string(s7, "(define (add1 a) (+ a 1))");
  
  fprintf(stderr, "an-integer: %d\n", 
	  s7_integer(<em class=red>s7_name_to_value</em>(s7, "an-integer")));

  <em class=red>s7_symbol_set_value</em>(s7, <em class=red>s7_make_symbol</em>(s7, "an-integer"), s7_make_integer(s7, 32));

  fprintf(stderr, "now an-integer: %d\n", 
	  s7_integer(<em class=red>s7_name_to_value</em>(s7, "an-integer")));

  fprintf(stderr, "(add1 2): %d\n", 
	  s7_integer(<em class=red>s7_call</em>(s7, 
			     s7_name_to_value(s7, "add1"), 
			     s7_cons(s7, s7_make_integer(s7, 2), s7_nil(s7)))));
}

/*
 *    doc7
 *    an-integer: 1
 *    now an-integer: 32
 *    (add1 2): 3
 */
</pre>
</td></tr></table>
<br><br>



<table border=0 vspace=8 width=30% hspace=100 cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<A NAME="juce"></a>
<p>C++ and Juce, from Rick Taube:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
int main(int argc, const char* argv[]) 
{ 
  initialiseJuce_NonGUI(); 

  s7_scheme *s7 = s7_init(); 
  if (!s7) 
    { 
      std::cout &lt;&lt;  "Can't start S7!\n"; 
      return -1; 
    } 

  s7_pointer val; 
  std::string str; 
  while (true) 
    { 
      std::cout &lt;&lt; "\ns7&gt; "; 
      std::getline(std::cin, str); 
      val = s7_eval_c_string(s7, str.c_str()); 
      std::cout &lt;&lt; s7_object_to_c_string(s7, val); 
    } 

  free(s7); 
  std::cout &lt;&lt; "Bye!\n"; 
  return 0; 
} 
</pre>
</td></tr></table>
<br><br>



<table border=0 vspace=8 width=30% hspace=100 cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<A NAME="sndlib"></a>
<p>Load sndlib using the XEN functions and macros into an s7 repl:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

/* assume we've configured and built sndlib, so it has created a mus-config.h file */

#include "mus-config.h"
#include "s7.h"
#include "xen.h"
#include "clm.h"
#include "clm2xen.h"

/* we need to redirect clm's mus_error calls to s7_error */

static void mus_error_to_s7(int type, char *msg)
{
  s7_error(s7,                               /* s7 is declared in xen.h */
	   s7_make_symbol(s7, "mus-error"),
	   s7_cons(s7, s7_make_string(s7, msg), s7_nil(s7)));
}

static s7_pointer our_exit(s7_scheme *sc, s7_pointer args)
{
  exit(1);
  return(s7_nil(sc));
}

/* the next functions are needed for either with-sound or many standard instruments, like fm-violin */
/*   (these are in the xen-style FFI) */

static XEN g_file_exists_p(XEN name)
{
  #define H_file_exists_p "(file-exists? filename): #t if the file exists"
  XEN_ASSERT_TYPE(XEN_STRING_P(name), name, XEN_ONLY_ARG, "file-exists?", "a string");
  return(C_TO_XEN_BOOLEAN(mus_file_probe(XEN_TO_C_STRING(name))));
}

XEN_NARGIFY_1(g_file_exists_p_w, g_file_exists_p)

static XEN g_delete_file(XEN name)
{
  #define H_delete_file "(delete-file filename): deletes the file"
  XEN_ASSERT_TYPE(XEN_STRING_P(name), name, XEN_ONLY_ARG, "delete-file", "a string");
  return(C_TO_XEN_BOOLEAN(unlink(XEN_TO_C_STRING(name))));
}

XEN_NARGIFY_1(g_delete_file_w, g_delete_file)

int main(int argc, char **argv)
{
  char buffer[512];
  char response[1024];

  s7 = s7_init();                     /* initialize the interpreter */
  xen_initialize();                   /* initialize the xen stuff (hooks and the xen s7 FFI used by sndlib) */
  Init_sndlib();                      /* initialize sndlib with all the functions linked into s7 */  

  mus_error_set_handler(mus_error_to_s7); /* catch low-level errors and pass them to s7-error */

  XEN_DEFINE_PROCEDURE("file-exists?", g_file_exists_p_w, 1, 0, 0, H_file_exists_p);
  XEN_DEFINE_PROCEDURE("delete-file",  g_delete_file_w,   1, 0, 0, H_delete_file);
  s7_define_function(s7, "exit", our_exit, 0, 0, false, "(exit) exits the program");

  while (1)                           /* fire up a "repl" */
    {
      fprintf(stdout, "\n&gt; ");        /* prompt for input */
      fgets(buffer, 512, stdin);

      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response); /* evaluate input and write the result */
	}
    }
}

/* gcc -o doc7 doc7.c -lm -I. /usr/local/lib/libsndlib.a -lasound
 *
 *   (load "sndlib-ws.scm")
 *   (with-sound () (outa 10 .1))
 *   (load "v.scm")
 *   (with-sound () (fm-violin 0 .1 440 .1))
 *
 * you might also need -lgsl -lgslcblas
 */
</pre>
</td></tr></table>
<br><br>



<table border=0 vspace=8 width=30% hspace=100 cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<A NAME="pwstype"></a>
<p>Add a new Scheme type and procedure-with-setters:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer our_exit(s7_scheme *sc, s7_pointer args)
{
  exit(1);
  return(s7_nil(sc));
}

/* define *listener-prompt* in scheme, add two accessors for C get/set */

static const char *listener_prompt(s7_scheme *sc)
{
  return(s7_string(s7_name_to_value(sc, "*listener-prompt*")));
}

static void set_listener_prompt(s7_scheme *sc, const char *new_prompt)
{
  s7_symbol_set_value(sc, s7_make_symbol(sc, "*listener-prompt*"), s7_make_string(sc, new_prompt));
}

/* now add a new type, a struct named "dax" with two fields, a real "x" and a list "data" */
/*   since the data field is an s7 object, we'll need to mark it to protect it from the GC */

typedef struct {
  s7_Double x;
  s7_pointer data;
} dax;

static char *print_dax(s7_scheme *sc, void *val)
{
  char *data_str, *str;
  int data_str_len;
  dax *o = (dax *)val;
  data_str = s7_object_to_c_string(sc, o-&gt;data);
  data_str_len = strlen(data_str);
  str = (char *)calloc(data_str_len + 32, sizeof(char));
  snprintf(str, data_str_len + 32, "#&lt;dax %.3f %s&gt;", o-&gt;x, data_str);
  free(data_str);
  return(str);
}

static void free_dax(void *val)
{
  if (val) free(val);
}

static bool equal_dax(void *val1, void *val2)
{
  return(val1 == val2);
}

static void mark_dax(void *val)
{
  dax *o = (dax *)val;
  if (o) s7_mark_object(o-&gt;data);
}

static int dax_type_tag = 0;

static s7_pointer make_dax(s7_scheme *sc, s7_pointer args)
{
  dax *o;
  o = (dax *)malloc(sizeof(dax));
  o-&gt;x = s7_real(s7_car(args));
  if (s7_cdr(args) != s7_nil(sc))
    o-&gt;data = s7_car(s7_cdr(args));
  else o-&gt;data = s7_nil(sc);
  return(<em class=red>s7_make_object</em>(sc, dax_type_tag, (void *)o));
}

static s7_pointer is_dax(s7_scheme *sc, s7_pointer args)
{
  return(s7_make_boolean(sc, 
			 <em class=red>s7_is_object</em>(s7_car(args)) &amp;&amp;
			 <em class=red>s7_object_type</em>(s7_car(args)) == dax_type_tag));
}

static s7_pointer dax_x(s7_scheme *sc, s7_pointer args)
{
  dax *o;
  o = (dax *)<em class=red>s7_object_value</em>(s7_car(args));
  return(s7_make_real(sc, o-&gt;x));
}

static s7_pointer set_dax_x(s7_scheme *sc, s7_pointer args)
{
  dax *o;
  o = (dax *)s7_object_value(s7_car(args));
  o-&gt;x = s7_real(s7_car(s7_cdr(args)));
  return(s7_car(s7_cdr(args)));
}

static s7_pointer dax_data(s7_scheme *sc, s7_pointer args)
{
  dax *o;
  o = (dax *)s7_object_value(s7_car(args));
  return(o-&gt;data);
}

static s7_pointer set_dax_data(s7_scheme *sc, s7_pointer args)
{
  dax *o;
  o = (dax *)s7_object_value(s7_car(args));
  o-&gt;data = s7_car(s7_cdr(args));
  return(o-&gt;data);
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];

  s7 = s7_init();
  
  s7_define_function(s7, "exit", our_exit, 0, 0, false, "(exit) exits the program");
  s7_define_variable(s7, "*listener-prompt*", s7_make_string(s7, "&gt;"));

  dax_type_tag = <em class=red>s7_new_type</em>("dax", print_dax, free_dax, equal_dax, mark_dax, NULL, NULL);
  s7_define_function(s7, "make-dax", make_dax, 2, 0, false, "(make-dax x data) makes a new dax");
  s7_define_function(s7, "dax?", is_dax, 1, 0, false, "(dax? anything) returns #t if its argument is a dax object");

  s7_define_variable(s7, "dax-x", 
                     <em class=red>s7_make_procedure_with_setter</em>(s7, "dax-x", dax_x, 1, 0, set_dax_x, 2, 0, "dax x field"));

  s7_define_variable(s7, "dax-data", 
                     <em class=red>s7_make_procedure_with_setter</em>(s7, "dax-data", dax_data, 1, 0, set_dax_data, 2, 0, "dax data field"));

  while (1)
    {
      fprintf(stdout, "\n%s ", listener_prompt(s7));
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response); /* evaluate input and write the result */
	}
    }
}

/*
 *    &gt; *listener-prompt*
 *    "&gt;"
 *    &gt; (set! *listener-prompt* ":")
 *    ":"
 *    : (define obj (make-dax 1.0 (list 1 2 3)))
 *    obj
 *    : obj
 *    #&lt;dax 1.000 (1 2 3)&gt;
 *    : (dax-x obj)
 *    1.0
 *    : (dax-data obj)
 *    (1 2 3)
 *    : (set! (dax-x obj) 123.0)
 *    123.0
 *    : obj
 *    #&lt;dax 123.000 (1 2 3)&gt;
 *    : (dax? obj)
 *    #t
 *    : (exit)
 */
</pre>
</td></tr></table>
<br><br>



<table border=0 vspace=8 width=30% hspace=100 cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<A NAME="functionportexample"></a>
<p>Redirect output (and input) to a C procedure:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static void my_print(s7_scheme *sc, char c, s7_pointer port)
{
  fprintf(stderr, "[%c] ", c);
}

static s7_pointer my_read(s7_scheme *sc, s7_read_t peek, s7_pointer port)
{
  return(<em class=red>s7_make_character</em>(s7, fgetc(stdin)));
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];

  s7 = s7_init();  

  <em class=red>s7_set_current_output_port</em>(s7, <em class=red>s7_open_output_function</em>(s7, my_print));
  s7_define_variable(s7, "io-port", <em class=red>s7_open_input_function</em>(s7, my_read));

  while (1) 
    {
      fprintf(stdout, "\n&gt; ");
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response);
	}
    }
}

/* 
 *    &gt; (+ 1 2)
 *    [3]
 *    &gt; (display "hiho")
 *    [h] [i] [h] [o] [#] [&lt;] [u] [n] [s] [p] [e] [c] [i] [f] [i] [e] [d] [&gt;] 
 *    &gt; (define (add1 x) (+ 1 x))
 *    [a] [d] [d] [1] 
 *    &gt; (add1 123)
 *    [1] [2] [4] 
 *    &gt; (read-char io-port)
 *    a                             ; here I typed "a" in the shell
 *    [#] [\] [a] 
 */
</pre>
</td></tr></table>
<br><br>



<table border=0 vspace=8 width=30% hspace=100 cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<A NAME="extendop"></a>
<p>Extend a built-in operator ("+" in this case):
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer old_add;           /* the original "+" function for non-string cases */
static s7_pointer old_string_append; /* same, for "string-append" */

static s7_pointer our_add(s7_scheme *sc, s7_pointer args)
{
  /* this will replace the built-in "+" operator, extending it to include strings:
   *   (+ "hi" "ho") -&gt; "hiho" and  (+ 3 4) -&gt; 7
   */
  if ((s7_is_pair(args)) &amp;&amp;
      (s7_is_string(s7_car(args))))
    return(<em class=red>s7_apply_function</em>(sc, old_string_append, args));

  return(s7_apply_function(sc, old_add, args));
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];

  s7 = s7_init();

  /* get built-in + and string-append */
  old_add = s7_name_to_value(s7, "+");      
  old_string_append = s7_name_to_value(s7, "string-append");

  /* redefine "+" */
  s7_define_function(s7, "+", our_add, 0, 0, true, "(+ ...) adds or appends its arguments");

  while (1)
    {
      fprintf(stdout, "\n&gt; ");
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response);
	}
    }
}

/* 
 *    &gt; (+ 1 2)
 *    3
 *    &gt; (+ "hi" "ho")
 *    "hiho"
 */
</pre>
</td></tr></table>
<br><br>



<table border=0 vspace=8 width=30% hspace=100 cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<A NAME="definestar1"></a>
<p>C-side define* (s7_define_function_star):
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer plus(s7_scheme *sc, s7_pointer args)
{
  /* (define* (plus (red 32) blue) (+ (* 2 red) blue)) */
  return(s7_make_integer(sc, 2 * s7_integer(s7_car(args)) + s7_integer(s7_car(s7_cdr(args)))));
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];

  s7 = s7_init();
  <em class=red>s7_define_function_star</em>(s7, "plus", plus, "(red 32) blue", "an example of define* from C");

  while (1)
    {
      fprintf(stdout, "\n&gt; ");
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response);
	}
    }
}

/* 
 *    &gt; (plus 2 3)
 *    7
 *    &gt; (plus :blue 3)
 *    67
 *    &gt; (plus :blue 1 :red 4)
 *    9
 *    &gt; (plus 2 :blue 3)
 *    7
 *    &gt; (plus :blue 3 :red 1)
 *    5
 */
</pre>
</td></tr></table>
<br><br>



<table border=0 vspace=8 width=30% hspace=100 cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<A NAME="definemacro1"></a>
<p>C-side define-macro (s7_define_macro):
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer plus(s7_scheme *sc, s7_pointer args)
{
  /* (define-macro (plus a b) `(+ ,a ,b)) */
  s7_pointer a, b;
  a = s7_car(args);
  b = s7_car(s7_cdr(args));
  return(s7_cons(sc, s7_make_symbol(sc, "+"),  /* we are forming the list `(+ ,a ,b) */
	   s7_cons(sc, a,
	     s7_cons(sc, b, s7_nil(sc)))));
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];

  s7 = s7_init();
  <em class=red>s7_define_macro</em>(s7, "plus", plus, 2, 0, false, "plus adds its two arguments");

  while (1)
    {
      fprintf(stdout, "\n&gt; ");
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response);
	}
    }
}

/* 
 *    &gt; (plus 2 3)
 *    5
 */
</pre>
</td></tr></table>
<br><br>



<table border=0 vspace=8 width=30% hspace=100 cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<A NAME="signal"></a>
<p>Signal handling (C-C to break out of an infinite loop), and s7_make_continuation
to pick up where we were interrupted:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;signal.h&gt;

#include "s7.h"

static s7_scheme *s7;
struct sigaction new_act, old_act;  
  
static void handle_sigint(int ignored)  
{  
  fprintf(stderr, "interrupted!\n");
  s7_symbol_set_value(s7, s7_make_symbol(s7, "*interrupt*"), <em class=red>s7_make_continuation</em>(s7)); /* save where we were interrupted */
  sigaction(SIGINT, &amp;new_act, NULL);  
  s7_quit(s7);                             /* get out of the eval loop if possible */
}  

static s7_pointer our_exit(s7_scheme *sc, s7_pointer args)
{ 
  /* this function is really needed if we are trapping C-C! */
  exit(1);
  return(s7_f(sc));
}

static s7_pointer our_sleep(s7_scheme *sc, s7_pointer args)
{
  /* slow down out infinite loop for demo purposes */
  sleep(1);
  return(s7_f(sc));
}

int main(int argc, char **argv)
{
  char buffer[512];
  char response[1024];

  s7 = s7_init();
  s7_define_function(s7, "exit", our_exit, 0, 0, false, "(exit) exits");
  s7_define_function(s7, "sleep", our_sleep, 0, 0, false, "(sleep) sleeps");
  s7_define_variable(s7, "*interrupt*", s7_f(s7)); 
  /* Scheme variable *interrupt* holds the continuation at the point of the interrupt */

  sigaction(SIGINT, NULL, &amp;old_act);
  if (old_act.sa_handler != SIG_IGN)
    {
      memset(&amp;new_act, 0, sizeof(new_act));  
      new_act.sa_handler = &amp;handle_sigint;  
      sigaction(SIGINT, &amp;new_act, NULL);  
    }

  while (1)
    {
      fprintf(stderr, "\n&gt; ");
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response);
	}
    }
}

/*
 *    &gt; (do ((i 0 (+ i 1))) ((= i -1)) (format #t "~D " i) (sleep))
 *      ;;; now type C-C to break out of this loop
 *    0 1 2 ^Cinterrupted!
 *      ;;; call the continuation to continue from where we were interrupted
 *    &gt; (*interrupt*)
 *    3 4 5 ^Cinterrupted!
 *    &gt; *interrupt*
 *    #&lt;continuation&gt;
 *    &gt; (+ 1 2)
 *    3
 */
</pre>
</td></tr></table>
<br><br>



<table border=0 vspace=8 width=30% hspace=100 cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<A NAME="vector"></a>
<p>Multidimensional vector element access:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdarg.h&gt;

#include "s7.h"

static s7_pointer multivector_ref(s7_scheme *sc, s7_pointer vector, int indices, ...)
{
  /* multivector_ref returns an element of a multidimensional vector */
  int ndims;
  ndims = <em class=red>s7_vector_rank</em>(vector);

  if (ndims == indices)
    {
      va_list ap;
      s7_Int index = 0;
      va_start(ap, indices);

      if (ndims == 1)
	{
	  index = va_arg(ap, s7_Int);
	  va_end(ap);
	  return(s7_vector_ref(sc, vector, index));
	}
      else
	{
	  int i;
	  s7_pointer *elements;
	  s7_Int *offsets, *dimensions;

	  elements = <em class=red>s7_vector_elements</em>(vector);
	  dimensions = <em class=red>s7_vector_dimensions</em>(vector);
	  offsets = <em class=red>s7_vector_offsets</em>(vector);

	  for (i = 0; i &lt; indices; i++)
	    {
	      int ind;
	      ind = va_arg(ap, int);
	      if ((ind &lt; 0) ||
		  (ind &gt;= dimensions[i]))
		{
		  va_end(ap);
		  return(s7_out_of_range_error(sc, 
                                               "multivector_ref", i, 
                                               s7_make_integer(sc, ind), 
                                               "index should be between 0 and the dimension size"));
		}
	      index += (ind * offsets[i]);
	    }
	  va_end(ap);
	  return(elements[index]);
	}
    }
  return(s7_wrong_number_of_args_error(sc, 
                                       "multivector_ref: wrong number of indices: ~A", 
                                       s7_make_integer(sc, indices)));
}

int main(int argc, char **argv)
{
  char buffer[512];
  char response[1024];
  s7_scheme *s7;

  s7 = s7_init(); 
  s7_eval_c_string(s7, "(define vect (make-vector '(2 3 4) 0))");
  s7_eval_c_string(s7, "(set! (vect 1 1 1) 32)");

  fprintf(stdout, "vect[0,0,0]: %s, vect[1,1,1]: %s\n",
	  s7_object_to_c_string(s7, <em class=red>multivector_ref</em>(s7, s7_name_to_value(s7, "vect"), 3, 0, 0, 0)),
	  s7_object_to_c_string(s7, <em class=red>multivector_ref</em>(s7, s7_name_to_value(s7, "vect"), 3, 1, 1, 1)));
}

/* vect[0,0,0]: 0, vect[1,1,1]: 32
 */
</pre>
</td></tr></table>
<br><br>



<table border=0 vspace=8 width=30% hspace=100 cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<A NAME="notify"></a>
<p>Notification from Scheme that a given Scheme variable has been set.
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer my_exit(s7_scheme *sc, s7_pointer args) {exit(0);}

static s7_pointer scheme_set_notification(s7_scheme *sc, s7_pointer args)
{
  /* this function is called when the Scheme variable is set! */
  fprintf(stderr, "%s set to %s\n",
	  s7_object_to_c_string(sc, s7_car(args)),
	  s7_object_to_c_string(sc, s7_car(s7_cdr(args))));
  return(s7_car(s7_cdr(args)));
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  s7 = s7_init();  
  s7_define_function(s7, "exit", my_exit, 0, 0, false, "(exit) exits the program");

  s7_define_function(s7, "notify-C", scheme_set_notification, 2, 0, false, "called if notified-var is set!");
  s7_define_variable(s7, "notified-var", s7_make_integer(s7, 0));
  <em class=red>s7_symbol_set_access</em>(s7,   /* set symbol-access of notified-var to (list #f notify-C #f) */
		       s7_make_symbol(s7, "notified-var"),
		       s7_cons(s7, 
			       s7_f(s7), 
			       s7_cons(s7, 
				       s7_name_to_value(s7, "notify-C"), 
				       s7_cons(s7, 
					       s7_f(s7),
					       s7_nil(s7)))));

  if (argc == 2)
    {
      fprintf(stderr, "load %s\n", argv[1]);
      s7_load(s7, argv[1]);
    }
  else
    {
      char buffer[512];
      char response[1024];
      while (1) 
	{
	  fprintf(stdout, "\n&gt; ");
	  fgets(buffer, 512, stdin);
	  
	  if ((buffer[0] != '\n') || 
	      (strlen(buffer) &gt; 1))
	    {                            
	      sprintf(response, "(write %s)", buffer);
	      s7_eval_c_string(s7, response);
	    }
	}
    }
}

/*    &gt; notified-var
 *    0
 *    &gt; (set! notified-var 32)
 *    notified-var set to 32
 *    32
 */
</pre>
</td></tr></table>
<br><br>



<table border=0 vspace=8 width=30% hspace=100 cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<A NAME="namespace"></a>
<p>Load C defined stuff into a separate namespace.
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer my_exit(s7_scheme *sc, s7_pointer args) {exit(0);}

static s7_pointer func1(s7_scheme *sc, s7_pointer args)
{
  return(s7_make_integer(sc, s7_integer(s7_car(args)) + 1));
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  s7_pointer new_env;

  s7 = s7_init();  
  s7_define_function(s7, "exit", my_exit, 0, 0, false, "(exit) exits the program");

  /* "func1" and "var1" will be placed in an anonymous environment,
   *   accessible from Scheme via the global variable "lib-exports"
   */
  
  new_env = <em class=red>s7_augment_environment</em>(s7, s7_cons(s7, s7_current_environment(s7), s7_nil(s7)), s7_nil(s7));
  /* make a private environment for func1 and var1 below (this is our "namespace") */
  s7_gc_protect(s7, new_env);

  s7_define(s7, <em class=red>new_env</em>, 
	    s7_make_symbol(s7, "func1"),
	    <em class=red>s7_make_function</em>(s7, "func1", func1, 1, 0, false, "func1 adds 1 to its argument"));
  
  s7_define(s7, <em class=red>new_env</em>, s7_make_symbol(s7, "var1"), s7_make_integer(s7, 32));
  /* those two symbols are now defined in the new environment */

  /* add "lib-exports" to the global environment */
  s7_define_variable(s7, "lib-exports", s7_car(<em class=red>s7_environment_to_list</em>(s7, new_env)));

  if (argc == 2)
    {
      fprintf(stderr, "load %s\n", argv[1]);
      s7_load(s7, argv[1]);
    }
  else
    {
      char buffer[512];
      char response[1024];
      while (1) 
	{
	  fprintf(stdout, "\n&gt; ");
	  fgets(buffer, 512, stdin);
	  
	  if ((buffer[0] != '\n') || 
	      (strlen(buffer) &gt; 1))
	    {                            
	      sprintf(response, "(write %s)", buffer);
	      s7_eval_c_string(s7, response);
	    }
	}
    }
}

/*     &gt; func1
 *     ;func1: unbound variable, line 1
 *     &gt; lib-exports
 *     ((var1 . 32) (func1 . func1))
 *     ;; so lib-exports has the C-defined names and values
 *     ;; we can use these directly:
 *
 *     &gt; (define lib-env (apply <em class=red>augment-environment</em> (current-environment) lib-exports))
 *     lib-env
 *     &gt; (<em class=red>with-environment</em> lib-env (func1 var1))
 *     33
 *
 *     ;; or rename them to prepend "lib:"
 *     &gt; (define lib-env (apply augment-environment 
                                (current-environment) 
                                (map (lambda (binding) 
                                       (cons (string-&gt;symbol 
                                               (string-append "lib:" (symbol-&gt;string (car binding)))) 
                                             (cdr binding))) 
                                     lib-exports)))
 *     lib-env
 *     &gt; (with-environment lib-env (lib:func1 lib:var1))
 *     33
 *
 *     ;;; now for convenience, place "func1" in the global environment under the name "func2"
 *     &gt; (define func2 (cdadr lib-exports)) 
 *     func2
 *     &gt; (func2 1)  
 *     2
 */
</pre>
</td></tr></table>
<br><br>



<table border=0 vspace=8 width=30% hspace=100 cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<A NAME="Cerrors"></a>
<p>Handle scheme errors in C.
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer my_exit(s7_scheme *sc, s7_pointer args) {exit(0);}

static s7_pointer error_handler(s7_scheme *sc, s7_pointer args)
{
  /* put &lt;&lt;&gt;&gt; around the string so it's obvious who is producing what */

  fprintf(stdout, "&lt;&lt;%s&gt;&gt;", s7_string(s7_car(args)));
  return(s7_make_symbol(sc, "our-error"));
}


int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];
  bool with_error_hook = false;

  s7 = s7_init();  
  s7_define_function(s7, "exit", my_exit, 0, 0, false, "(exit) exits the program");
  s7_define_function(s7, "error-handler", error_handler, 1, 0, false, "our error handler");

  if (with_error_hook)
    s7_eval_c_string(s7, "(set! (hook-functions *error-hook*)                    \n\
                            (list (lambda (tag args)                             \n\
                                    (error-handler                               \n\
                                      (apply format #f (car args) (cdr args))))))");

  while (1) 
    {
      fprintf(stdout, "\n&gt; ");
      fgets(buffer, 512, stdin);
	  
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  s7_pointer old_port, result;
	  int gc_loc = -1;
	  const char *errmsg = NULL;

	  /* trap error messages */
	  old_port = s7_set_current_error_port(s7, s7_open_output_string(s7));
	  if (old_port != s7_nil(s7))
	    gc_loc = s7_gc_protect(s7, old_port);

	  /* evaluate the input string */
	  result = s7_eval_c_string(s7, buffer);

	  /* print out the value wrapped in "{}" so we can tell it from other IO paths */
	  fprintf(stdout, "{%s}", s7_object_to_c_string(s7, result));

	  /* look for error messages */
	  errmsg = s7_get_output_string(s7, s7_current_error_port(s7));

	  /* if we got something, wrap it in "[]" */
	  if ((errmsg) &amp;&amp; (*errmsg))
	    fprintf(stdout, "[%s]", errmsg); 

	  s7_close_output_port(s7, s7_current_error_port(s7));
	  s7_set_current_error_port(s7, old_port);
	  if (gc_loc != -1)
	    s7_gc_unprotect_at(s7, gc_loc);
	}
    }
}

/* 
 *   gcc -c s7.c -I. -g3
 *   gcc -o ex3 ex3.c s7.o -lm -I.
 *
 * if with_error_hook is false,
 *
 *   &gt; (+ 1 2)
 *   {3}
 *   &gt; (+ 1 #\c)
 *   {wrong-type-arg}[
 *   ;+ argument 2, #\c, is character but should be a number, line 1
 *   ]
 *
 * so s7 by default prepends ";" to the error message, and appends "\n",
 *   sending that to current-error-port, and the error type ('wrong-type-arg here)
 *   is returned.
 *
 * if with_error_hook is true,
 *
 *   &gt; (+ 1 2)
 *   {3}
 *   &gt; (+ 1 #\c)
 *   &lt;&lt;+ argument 2, #\c, is character but should be a number&gt;&gt;{our-error}
 *
 * so now the *error-hook* code handles both the error reporting and
 *   the value returned ('our-error in this case).
 */
</pre>
</td></tr></table>
<br><br>



<table border=0 vspace=8 width=30% hspace=100 cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<A NAME="closure"></a>
<p>We often have hooks or callback lists in Scheme, and would like to place a C-defined
s7 function on such a list.  If the C-side function does not have
any state, we can just add its name to the list, but if it is effectively a closure, we have a problem.  C itself does not
provide closures, so the standard two-step is to include a void* pointer with the
C function in a struct, then when that is called, pass the pointer to the function
by hand.  This obviously does not work if we want that function to be a member of
a normal Scheme list of functions.  So in the next example, we define a closure
in C using s7_make_closure.  
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer closure_func(s7_scheme *sc, s7_pointer args)
{
  /* closure_func is the function portion of our closure.  It assumes its
   *   environment has an integer named "x".  The function also takes one argument,
   *   an integer we'll call it "y".
   */
  return(s7_make_integer(sc,                            /* return (+ y x) */
                         s7_integer(s7_car(args)) +     /*   this is y */
                         s7_integer(s7_name_to_value(sc, "x"))));
}

static s7_pointer define_closure(s7_scheme *sc, const char *name, s7_pointer func, s7_pointer x_value)
{
  /* make_closure creates a new closure with x_value as the local value of x,
   *   and func as the function.  It defines this in Scheme as "name".  
   *
   *   s7_make_closure's arguments are the closure code as (&lt;args&gt; &lt;code&gt;), and
   *   the closure's environment.  For the first part, we'll use '((y) (f y)),
   *   and for the second, we'll augment the current environment with
   *   ((x . x_value) (f . func)).
   */
  s7_define(sc, 
	    s7_nil(sc),
	    s7_make_symbol(sc, name),
	    <em class=red>s7_make_closure</em>(sc, 
			    s7_cons(sc, 
				    s7_cons(sc,            /* closure arg list: '(y) */
				            s7_make_symbol(sc, "y"), 
                                            s7_nil(sc)), 
				    s7_cons(sc,            /* closure code: (f y) */
					    s7_cons(sc,                              
						    s7_make_symbol(sc, "f"),
						    s7_cons(sc, 
                                                            s7_make_symbol(sc, "y"), 
                                                            s7_nil(sc))),
					    s7_nil(sc))),
			    <em class=red>s7_augment_environment</em>(sc, 
						   s7_current_environment(sc), 
						   s7_cons(sc, 
							   s7_cons(sc,  /* the local binding for "x" */
                                                                   s7_make_symbol(sc, "x"), 
                                                                   <em class=red>x_value</em>), 
							   s7_cons(sc,  /*     and "f" */
								   s7_cons(sc, 
                                                                           s7_make_symbol(sc, "f"), 
                                                                           <em class=red>func</em>), 
								   s7_nil(sc))))));
  return(s7_unspecified(sc));
}

static s7_pointer my_exit(s7_scheme *sc, s7_pointer args) {exit(0);}

int main(int argc, char **argv)
{
  char buffer[512];
  char response[1024];
  s7_pointer c_func;
  s7_scheme *s7;

  s7 = s7_init();  
  s7_define_function(s7, "exit", my_exit, 0, 0, false, "(exit) exits the program");

  c_func = s7_make_function(s7, "#&lt;closure function&gt;", closure_func, 1, 0, false, "function used by define_closure");

  define_closure(s7, "closure-1", c_func, s7_make_integer(s7, 32));  /* (let ((x 32)) (lambda (y) (+ y x))) */
  define_closure(s7, "closure-2", c_func, s7_make_integer(s7, 123)); /* (let ((x 123)) (lambda (y) (+ y x))) */

  while (1) 
    {
      fprintf(stdout, "\n&gt; ");
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response);
	}
    }
}

/*
 *   &gt; (closure-1 3)
 *   35
 *   &gt; (closure-2 3)
 *   126
 *   &gt; (procedure-source closure-1)
 *   (lambda (y) (f y))
 *   &gt; (environment-&gt;list (procedure-environment closure-1))
 *   (((f . #&lt;closure function&gt;) (x . 32)))
 */
</pre>
</td></tr></table>
<br><br>



<table border=0 vspace=8 width=30% hspace=100 cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<A NAME="testhook"></a>
<p>C and Scheme hook handling.
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer my_exit(s7_scheme *sc, s7_pointer args) {exit(0);}

static s7_pointer my_hook_function(s7_scheme *sc, s7_pointer args)
{
  fprintf(stderr, "arg is %s\n", s7_object_to_c_string(sc, s7_car(args)));
  return(s7_car(args));
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];
  s7_pointer test_hook;

  s7 = s7_init();  
  s7_define_function(s7, "exit", my_exit, 0, 0, false, "(exit) exits the program");

  /* define test_hook in C, test-hook in Scheme */
  test_hook = <em class=red>s7_make_hook</em>(s7, 2, 0, false, "test-hook's functions take 2 arguments");
  s7_define_constant(s7, "test-hook", test_hook); 

  /* add my_hook_function to the test_hook function list */
  <em class=red>s7_hook_set_functions</em>(test_hook, 
			s7_cons(s7, 
				s7_make_function(s7, "my-hook-function", my_hook_function, 2, 0, false, "my hook-function"), 
				s7_hook_functions(test_hook)));
  while (1) 
    {
      fprintf(stdout, "\n&gt; ");
      fgets(buffer, 512, stdin);
	  
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response);
	}
    }
}

/* 
 *    &gt; test-hook
 *    #&lt;hook&gt;
 *    
 *    &gt; (hook-functions test-hook)
 *    (my-hook-function)
 *    
 *    &gt; (set! (hook-functions test-hook) 
 *        (cons (lambda (a b) (format #t "a is ~S~%" a)) 
 *              (hook-functions test-hook)))
 *    (#&lt;closure&gt; my-hook-function)
 *    
 *    &gt; (test-hook 1 2)
 *    a is 1
 *    arg is 1
 *    1
 */
</pre>
</td></tr></table>
<br><br>



<table border=0 vspace=8 width=30% hspace=100 cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<A NAME="cload"></a>
<p>We can use dlopen to load a shared library, and dlsym to initialize
that library in our main program.  The tricky part is to conjure up the right
compiler and loader flags.
First we define a module that defines a new s7 function, add-1:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer add_1(s7_scheme *sc, s7_pointer args) 
{
  return(s7_make_integer(sc, s7_integer(s7_car(args)) + 1)); 
}

void init_ex(s7_scheme *sc);
void init_ex(s7_scheme *sc)  /* this needs to be globally accessible (not "static") */
{
  s7_define_function(sc, "add-1", add_1, 1, 0, false, "(add-1 x) adds 1 to x");
}

</pre>
</td></tr></table>

<p>And here is our main program:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include "s7.h"

static s7_pointer my_exit(s7_scheme *sc, s7_pointer args) {exit(0);}

#include &lt;dlfcn.h&gt;
static s7_pointer cload(s7_scheme *sc, s7_pointer args)
{
  #define CLOAD_HELP "(cload so-file-name init-func-name) loads the module and calls the init function"
  void *library;
  library = <em class=red>dlopen</em>(s7_string(s7_car(args)), RTLD_LAZY);
  if (library)
    {
      void *init_func;
      init_func = <em class=red>dlsym</em>(library, s7_string(s7_car(s7_cdr(args))));
      if (init_func)
	{
	  typedef void *(*dl_func)(s7_scheme *sc);
	  ((dl_func)<em class=red>init_func</em>)(sc);  /* call the initialization function (init_ex above) */
	  return(s7_t(sc));
	}
      else fprintf(stderr, "loader error: %s\n", <em class=red>dlerror</em>());
    }
  else fprintf(stderr, "loader error: %s\n", <em class=red>dlerror</em>());
  return(s7_f(sc));
}

int main(int argc, char **argv)
{
  char buffer[512];
  char response[1024];
  s7_scheme *s7;

  s7 = s7_init();  
  s7_define_function(s7, "exit", my_exit, 0, 0, false, "(exit) exits the program");
  s7_define_function(s7, "cload", cload, 2, 0, false, CLOAD_HELP);
  while (1) 
    {
      fprintf(stdout, "\n&gt; ");
      fgets(buffer, 512, stdin);
	  
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response);
	}
    }
}

/* Put the module in the file ex3a.c and the main program in ex3.c, then
 *
 * in Linux:
 *   gcc -c -fPIC ex3a.c
 *   gcc ex3a.o -shared -o ex3a.so
 *   gcc -c s7.c -I. -fPIC -shared
 *   gcc -o ex3 ex3.c s7.o -lm -ldl -I. -Wl,-export-dynamic
 *
 * in Mac OSX:
 *   gcc -c ex3a.c
 *   gcc ex3a.o -o ex3a.so -dynamic -bundle -undefined suppress -flat_namespace
 *   gcc -c s7.c -I. -dynamic -bundle -undefined suppress -flat_namespace
 *   gcc -o ex3 ex3.c s7.o -lm -ldl -I.
 *
 * and run it:
 *   ex3
 *   &gt; (cload "/home/bil/snd-12/ex3a.so" "init_ex")
 *   #t
 *   &gt; (add-1 2)
 *   3
 */
</pre>
</td></tr></table>
<br><br>



<table border=0 vspace=8 width=30% hspace=100 cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<A NAME="gmpex"></a>
<p>Bignum support depends on gmp, mpfr, and mpc.  In this example, we define "add-1" which adds
1 to any kind of number.  The s7_big_* functions return the underlying gmp/mpfr/mpc pointer,
so we have to copy that into a new number before adding.
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include &lt;gmp.h&gt;
#include &lt;mpfr.h&gt;
#include &lt;mpc.h&gt;

#include "s7.h"

static s7_pointer my_exit(s7_scheme *sc, s7_pointer args) {exit(0);}

static s7_pointer big_add_1(s7_scheme *sc, s7_pointer args)
{
  /* add 1 to either a normal number or a bignum */
  s7_pointer x;
  x = s7_car(args);
  if (s7_is_bignum(x))
    {
      s7_pointer n;
      if (s7_is_integer(x))
	{
	  mpz_t *big_n;
	  n = s7_make_big_integer(sc, s7_big_integer(x)); /* copy x */
	  big_n = s7_big_integer(n);                      /* get mpz_t pointer of copy */
	  mpz_add_ui(*big_n, *big_n, 1);                  /* add 1 to that */
	  return(n);                                      /* return the new bignum */
	}
      if (s7_is_ratio(x))
	{
	  mpq_t *big_q;
	  mpz_t num, den;
	  n = s7_make_big_ratio(sc, s7_big_ratio(x));
	  big_q = s7_big_ratio(n);
	  mpz_init_set(num, mpq_numref(*big_q));
	  mpz_init_set(den, mpq_denref(*big_q));
	  mpz_add(num, num, den);
	  mpq_set_num(*big_q, num);
	  mpz_clear(num);
	  mpz_clear(den);
	  return(n);
	}
      if (s7_is_real(x))
	{
	  mpfr_t *big_x;
	  n = s7_make_big_real(sc, s7_big_real(x));
	  big_x = s7_big_real(n);
	  mpfr_add_ui(*big_x, *big_x, 1, GMP_RNDN);
	  return(n);
	}
      /* x must be big complex */
      {
	mpc_t *big_z;
	n = s7_make_big_complex(sc, s7_big_complex(x));
	big_z = s7_big_complex(n);
	mpc_add_ui(*big_z, *big_z, 1, MPC_RNDNN);
	return(n);
      }
    }
  else
    {
      if (s7_is_integer(x))
	return(s7_make_integer(sc, 1 + s7_integer(x)));
      if (s7_is_rational(x))
	return(s7_make_ratio(sc, s7_numerator(x) + s7_denominator(x), s7_denominator(x)));
      if (s7_is_real(x))
	return(s7_make_real(sc, 1.0 + s7_real(x)));
      if (s7_is_complex(x))
	return(s7_make_complex(sc, 1.0 + s7_real_part(x), s7_imag_part(x)));
    }
  return(s7_wrong_type_arg_error(sc, "add-1", 0, x, "a number"));
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];

  s7 = s7_init();  
  s7_define_function(s7, "exit", my_exit, 0, 0, false, "(exit) exits the program");
  s7_define_function(s7, "add-1", big_add_1, 1, 0, false, "(add-1 num) adds 1 to num");

  while (1) 
    {
      fprintf(stdout, "\n&gt; ");
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response);
	}
    }
}

/* 
 *   gcc -DWITH_GMP=1 -c s7.c -I. -O2 -g3
 *   gcc -DWITH_GMP=1 -o ex2 ex2.c s7.o -I. -O2 -lm -lgmp -lmpfr -lmpc
 *
 *   ex2
 *   &gt; (add-1 1)   
 *   2
 *   &gt; (add-1 2/3)
 *   5/3
 *   &gt; (add-1 1.4) 
 *   2.4
 *   &gt; (add-1 1.5+i)
 *   2.5+1i
 *   &gt; (add-1 (bignum "3"))
 *   4          ; this is the bignum 4
 *   &gt; (add-1 (bignum "3/4"))
 *   7/4
 *   &gt; (add-1 (bignum "1.4"))
 *   2.399999999999999911182158029987476766109E0
 *   &gt; (add-1 (bignum "1.5+i"))
 *   2.500E0+1.000E0i
 */
</pre>
</td></tr></table>
<br><br>



<table border=0 vspace=8 width=30% hspace=100 cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<A NAME="gtkrepl"></A>
<p>In this example, we use Gtk to make a window with a scrolled text widget, running s7
in a read-eval-print loop.  I've tried to make this as short as possible; see Snd for
a much more elaborate REPL.  From s7's point of view, the only tricky part involves
catching errors.
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

/* use Gtk to post a text widget as a REPL.
 */
#include &lt;gtk/gtk.h&gt;

#if HAVE_GTK_3
  #include &lt;gdk/gdk.h&gt;
  #define Return_Key GDK_KEY_Return
#else
  #include &lt;gdk/gdkkeysyms.h&gt;
  #define Return_Key GDK_Return
#endif

#include "s7.h"
static s7_pointer my_exit(s7_scheme *sc, s7_pointer args) {exit(0);}

#define S7_PROMPT "s7&gt; "
#define S7_PROMPT_LENGTH 4

static GtkWidget* repl;                        /* the REPL text widget */
static GtkTextBuffer *repl_buf;                /* its text buffer */
static GtkTextTag *prompt_not_editable = NULL; /* a tag to make sure the prompt can't be erased */

static gint quit_repl(GtkWidget *w, GdkEvent *event, gpointer context)
{
  /* called when we click the 'x' window decoration */
  exit(0);
}

static void evaluate_expression(s7_scheme *sc, char *expression)
{
  /* evaluate expression, display result, catching and displaying any errors */
  if ((expression) &amp;&amp;
      (*expression))
    {
      if ((strlen(expression) &gt; 1) || 
	  (expression[0] != '\n'))
	{
	  const char *errmsg;
	  int gc_loc = -1;
	  s7_pointer old_port, result;
	  GtkTextIter pos;

	  /* open a port to catch error info */
	  old_port = s7_set_current_error_port(sc, s7_open_output_string(sc));
	  if (old_port != s7_nil(sc))
	    gc_loc = s7_gc_protect(sc, old_port);
	  
	  result = s7_eval_c_string(sc, expression);
	  
	  errmsg = s7_get_output_string(sc, s7_current_error_port(sc));
	  /* if error, display it, else display result of evaluation */
	  gtk_text_buffer_get_end_iter(repl_buf, &amp;pos);
	  
	  if ((errmsg) &amp;&amp; (*errmsg))
	    gtk_text_buffer_insert(repl_buf, &amp;pos, errmsg, strlen(errmsg));
	  else 
	    {
	      char *result_as_string;
	      result_as_string = s7_object_to_c_string(sc, result);
	      if (result_as_string)
		{
		  gtk_text_buffer_insert(repl_buf, &amp;pos, "\n", 1);
		  gtk_text_buffer_insert(repl_buf, &amp;pos, result_as_string, strlen(result_as_string));
		  free(result_as_string);
		}
	    }
	  
	  s7_close_output_port(sc, s7_current_error_port(sc));
	  s7_set_current_error_port(sc, old_port);
	  if (gc_loc != -1)
	    s7_gc_unprotect_at(sc, gc_loc);
	}
      g_free(expression);
    }
}

static char *get_current_expression(void)
{
  /* find the enclosing expression and return it.  This could be a lot smarter, but
   *    for the current example, I'll just look back to the previous prompt, then
   *    forward for the next prompt or the buffer end.
   */
  GtkTextIter pos, previous, next, temp;
  GtkTextMark *m;

  m = gtk_text_buffer_get_insert(repl_buf);
  gtk_text_buffer_get_iter_at_mark(repl_buf, &amp;pos, m);

  if (gtk_text_iter_backward_search(&amp;pos, S7_PROMPT, 0, &amp;temp, &amp;previous, NULL))
    {
      /* previous now marks the end of the previous prompt */
      if (!gtk_text_iter_forward_search(&amp;pos, S7_PROMPT, 0, &amp;next, &amp;temp, NULL))
	{
	  gtk_text_buffer_get_end_iter(repl_buf, &amp;next);
	  /* next now marks the end of the buffer, so there's no complication */
	  return(gtk_text_buffer_get_text(repl_buf, &amp;previous, &amp;next, true));
	}
      /* here next marks the start of the next prompt, but that probably includes
       *   the result printout from an earlier evaluation.  s7_eval_c_string evaluates
       *   all the expressions in its string, returning the value of the last one,
       *   but we want the first.  We'll backup two '\n'.
       */
      gtk_text_iter_backward_search(&amp;next, "\n", 0, &amp;pos, &amp;temp, NULL);     
      gtk_text_iter_backward_search(&amp;pos, "\n", 0, &amp;next, &amp;temp, NULL);      
      return(gtk_text_buffer_get_text(repl_buf, &amp;previous, &amp;next, true));
    }
  return(NULL);
}

static gboolean repl_key_press(GtkWidget *w, GdkEventKey *event, gpointer data)
{
  /* called when we type anything in the text widget.
   *   'data' is our s7 interpreter.
   */
  guint key;
  key = event-&gt;keyval;
  if (key == Return_Key)
    {
      GtkTextIter pos;
      /* get enclosing expression, evaluate it, display result (or error), prompt for next */
      evaluate_expression((s7_scheme *)data, get_current_expression());

      /* prompt for next expression */
      gtk_text_buffer_get_end_iter(repl_buf, &amp;pos);
      gtk_text_buffer_insert_with_tags(repl_buf, &amp;pos, 
                                       "\n" S7_PROMPT, 1 + S7_PROMPT_LENGTH, prompt_not_editable, NULL);

      /* make sure the stuff we added is visible */
      gtk_text_buffer_place_cursor(repl_buf, &amp;pos);
      gtk_text_view_scroll_mark_onscreen(GTK_TEXT_VIEW(repl), gtk_text_buffer_get_insert(repl_buf));

      /* tell Gtk that we already sent the '\n' */
      g_signal_stop_emission((gpointer)w, 
                             g_signal_lookup("key_press_event", G_OBJECT_TYPE((gpointer)w)), 0);
    }
  return(false);
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  GtkWidget *shell, *scrolled_window;
  GtkTextIter pos;

  s7 = s7_init();  
  s7_define_function(s7, "exit", my_exit, 0, 0, false, "(exit) exits the program");

  /* make a window with a scrolled text widget */
  gtk_init(&amp;argc, &amp;argv);
  shell = gtk_window_new(GTK_WINDOW_TOPLEVEL);
  g_signal_connect(G_OBJECT(shell), "delete_event", G_CALLBACK(quit_repl), NULL);

  scrolled_window = gtk_scrolled_window_new(NULL, NULL);
  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolled_window), 
                                 GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
  gtk_container_add(GTK_CONTAINER(shell), scrolled_window);

  repl = gtk_text_view_new();
  repl_buf = gtk_text_buffer_new(NULL);
  gtk_container_add(GTK_CONTAINER(scrolled_window), repl);

  gtk_text_view_set_buffer(GTK_TEXT_VIEW(repl), repl_buf);
  gtk_text_view_set_editable(GTK_TEXT_VIEW(repl), true);
  gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(repl), GTK_WRAP_NONE);
  gtk_text_view_set_cursor_visible(GTK_TEXT_VIEW(repl), true);
  gtk_text_view_set_left_margin(GTK_TEXT_VIEW(repl), 4);

  /* whenever a key is pressed, call repl_key_press */
  gtk_widget_set_events(repl, GDK_ALL_EVENTS_MASK);
  g_signal_connect(G_OBJECT(repl), "key_press_event", G_CALLBACK(repl_key_press), (void *)s7);

  gtk_widget_show(repl);
  gtk_widget_show(scrolled_window);
  gtk_widget_show(shell);

  /* start with a boldface '&gt;' prompt that can't be stepped on */
  prompt_not_editable = gtk_text_buffer_create_tag(repl_buf, "prompt_not_editable", 
						   "editable", false, 
						   "weight", PANGO_WEIGHT_BOLD,
						   NULL);
  gtk_text_buffer_get_end_iter(repl_buf, &amp;pos);
  gtk_text_buffer_insert_with_tags(repl_buf, &amp;pos, 
                                   S7_PROMPT, S7_PROMPT_LENGTH, prompt_not_editable, NULL);

  /* make the initial window size reasonable */
  gdk_window_resize(gtk_widget_get_window(shell), 400, 200);
  gtk_main();
}

/* 
 *   gcc -c s7.c -I. 
 *   gcc -o listener listener.c s7.o -lm -I. &lt;insert all the gtk flags and libraries here&gt;
 */

</pre>
</td></tr></table>
<br><br>



<table border=0 vspace=8 width=30% hspace=100 cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<A NAME="gtkschemerepl"></A>

<p>In the same vein, we can use libxm's Gtk/s7 bindings to make the REPL in Scheme.
Here is the same code, but now using libxm; first the C side, called gtkex.c:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include &lt;mus-config.h&gt;
#include "xen.h"
void Init_libxg(void);

static s7_pointer my_exit(s7_scheme *sc, s7_pointer args) {exit(0);}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  s7 = s7_init();             /* start s7 */
  s7_xen_initialize(s7);     /* start the xen connection to libxm */
  s7_define_function(s7, "exit", my_exit, 0, 0, false, "(exit) exits the program");
  Init_libxg();              /* load up all the glib/gdk/gtk/cairo/pango bindings in libxm */
  s7_load(s7, "gtkex.scm");  /* load and run our REPL (below) */ 
}

/*   libxm: configure --with-gtk, then make
 *   gcc -o gtkex gtkex.c libxg.so -lm -I.
 *   ;; you may need to include the libxm directory above
 */
</pre>
</td></tr></table>

<p>And here is gtkex.scm.  The main problem with this code is that Gtk is moving
rapidly toward gtk3, and libxm is running along behind panting and complaining.
There are several things that may change once Gtk settles down.
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
(gtk_init 0 #f)

(let ((shell (gtk_window_new GTK_WINDOW_TOPLEVEL))
      (s7-prompt "s7&gt; ")
      (return-key (if (provided? 'gtk3) GDK_KEY_Return GDK_Return)))
  
  (g_signal_connect (G_OBJECT shell) "delete_event"
		    (lambda (window event data)
		      (gtk_main_quit)
		      (exit)))
  (g_signal_connect (G_OBJECT shell) "destroy" 
		    (lambda (window data)
		      (gtk_main_quit)
		      (exit)))
  
  (let ((scrolled_window (gtk_scrolled_window_new #f #f)))
    
    (gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW scrolled_window) 
                                    GTK_POLICY_AUTOMATIC GTK_POLICY_AUTOMATIC)
    (gtk_container_add (GTK_CONTAINER shell) scrolled_window)
    
    (let* ((repl (gtk_text_view_new))
	   (repl_buf (gtk_text_buffer_new #f))
	   (prompt_not_editable #f))

      (define (evaluate-expression expr)
	(let ((pos (GtkTextIter))
	      (result (catch #t
			     (lambda ()
			       (object-&gt;string (eval-string expr)))
			     (lambda args
			       (format #f "~A: ~S" (car args) (apply format #f (cadr args)))))))
	  (gtk_text_buffer_get_end_iter repl_buf pos)
	  (gtk_text_buffer_insert repl_buf pos "\n" 1)
	  (gtk_text_buffer_insert repl_buf pos result (length result))))

      (define (get-current-expression)
	(let ((m (gtk_text_buffer_get_insert repl_buf))
	      (pos (GtkTextIter))
	      (previous (GtkTextIter))
	      (next (GtkTextIter))
	      (temp (GtkTextIter)))
	  (gtk_text_buffer_get_iter_at_mark repl_buf pos m)
	  (if (gtk_text_iter_backward_search pos s7-prompt 0 temp previous #f)
	      (if (not (gtk_text_iter_forward_search pos s7-prompt 0 next temp #f))
		  (begin
		    (gtk_text_buffer_get_end_iter repl_buf next)
		    (gtk_text_buffer_get_text repl_buf previous next #t))
		  (begin
		    (gtk_text_iter_backward_search next "\n" 0 pos temp #f)
		    (gtk_text_iter_backward_search pos "\n" 0 next temp #f)
		    (gtk_text_buffer_get_text repl_buf previous next #t)))
	      "")))

      (define (repl-key-press w event data)
	(let ((key (gtk_event_keyval event)))
	  (if (equal? key return-key)
	      (let ((pos (GtkTextIter)))

		(evaluate-expression (get-current-expression))
		
		(gtk_text_buffer_get_end_iter repl_buf pos)
		(gtk_text_buffer_insert_with_tags repl_buf pos
						  (string-append (string #\newline) s7-prompt) 
						  (+ 1  (length s7-prompt))
						  (list prompt_not_editable))
		(gtk_text_buffer_place_cursor repl_buf pos)
		(gtk_text_view_scroll_mark_onscreen (GTK_TEXT_VIEW repl) 
						    (gtk_text_buffer_get_insert repl_buf))
		(g_signal_stop_emission (GPOINTER w)
					(g_signal_lookup "key_press_event" 
							 (G_OBJECT_TYPE (G_OBJECT w))) 
					0)))))
      
      (gtk_container_add (GTK_CONTAINER scrolled_window) repl)
      (gtk_text_view_set_buffer (GTK_TEXT_VIEW repl) repl_buf)
      (gtk_text_view_set_editable (GTK_TEXT_VIEW repl) #t)
      (gtk_text_view_set_wrap_mode (GTK_TEXT_VIEW repl) GTK_WRAP_NONE)
      (gtk_text_view_set_cursor_visible (GTK_TEXT_VIEW repl) #t)
      (gtk_text_view_set_left_margin (GTK_TEXT_VIEW repl) 4)
      
      (gtk_widget_set_events repl GDK_ALL_EVENTS_MASK)
      (g_signal_connect (G_OBJECT repl) "key_press_event" repl-key-press)

      (gtk_widget_show repl)
      (gtk_widget_show scrolled_window)
      (gtk_widget_show shell)
      
      (set! prompt_not_editable 
	    (gtk_text_buffer_create_tag repl_buf "prompt_not_editable" 
					(list "editable" 0 "weight" PANGO_WEIGHT_BOLD)))
      (let ((pos (GtkTextIter)))
	(gtk_text_buffer_get_end_iter repl_buf pos)
	(gtk_text_buffer_insert_with_tags repl_buf pos 
					  s7-prompt (length s7-prompt)
					  (list prompt_not_editable))
	(gdk_window_resize (gtk_widget_get_window shell) 400 200)
	(gtk_main)))))

;; build gtkex as above, then run it and it will load/run this code
</pre>
</td></tr></table>
<br><br>



<table border=0 vspace=8 width=30% hspace=100 cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<A NAME="s7inathread"></A>

<p>There is one major flaw in the two preceding REPLs; if s7 gets caught in an infinite loop (via
<code>(do () ())</code> for example), you have to kill the main program to stop it.  We could use
Unix interrupts as in the <a href="#signal">signal</a> example earlier, but surely in a modern
GUI-based program, we'd like to avoid such brute-force stuff.  In particular, we want our interface
to keep running while we clean up the s7 problem.  So, in the next example, we use a separate
thread for the s7 evaluation:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
<em class=red>/* changes from the Gtk/C REPL above are in red */
#include &lt;pthread.h&gt;</em>
#include &lt;gtk/gtk.h&gt;

#if HAVE_GTK_3
  #include &lt;gdk/gdk.h&gt;
  #define Return_Key GDK_KEY_Return
<em class=red>  #define C_Key GDK_KEY_C
  #define c_Key GDK_KEY_c</em>
#else
  #include &lt;gdk/gdkkeysyms.h&gt;
  #define Return_Key GDK_Return
<em class=red>  #define C_Key GDK_C
  #define c_Key GDK_c</em>
#endif

#include "s7.h"
static s7_pointer my_exit(s7_scheme *sc, s7_pointer args) {exit(0);}

#define S7_PROMPT "s7&gt; "
#define S7_PROMPT_LENGTH 4

static GtkWidget* repl;                        /* the REPL text widget */
static GtkTextBuffer *repl_buf;                /* its text buffer */
static GtkTextTag *prompt_not_editable = NULL; /* a tag to make sure the prompt can't be erased */
<em class=red>static GdkCursor *arrow, *spinner;</em>

static gint quit_repl(GtkWidget *w, GdkEvent *event, gpointer context) {exit(0);}

<em class=red>static s7_scheme *s7;
static s7_pointer s7_result;
static bool just_quit = false, s7_is_running = false;
static pthread_t *s7_thread;

static void *run_s7_thread(void *obj)
{
  /* make sure we can stop this thread */
  pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
  pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);

  s7_result = s7_eval_c_string(s7, (const char *)obj);
  s7_is_running = false;
  return(NULL);
}</em>

static void evaluate_expression(s7_scheme *sc, char *expression)
{
  /* evaluate expression, display result, catching and displaying any errors */
  if ((expression) &amp;&amp;
      (*expression))
    {
      if ((strlen(expression) &gt; 1) || 
	  (expression[0] != '\n'))
	{
	  const char *errmsg = NULL;
	  int gc_loc;
	  s7_pointer old_port;
	  GtkTextIter pos;

	  /* open a port to catch error info */
	  old_port = s7_set_current_error_port(sc, s7_open_output_string(sc));
	  gc_loc = s7_gc_protect(sc, old_port);

<em class=red>	  /* evaluate the expression in a separate thread */
	  s7_thread = (pthread_t *)calloc(1, sizeof(pthread_t));
	  just_quit = false;
	  s7_is_running = true;
	  gdk_window_set_cursor(gtk_text_view_get_window(GTK_TEXT_VIEW(repl), GTK_TEXT_WINDOW_TEXT), spinner);

	  pthread_create(s7_thread, NULL, run_s7_thread, (void *)expression);

	  while (s7_is_running)
	    gtk_main_iteration();   /* make sure the GUI is responsive */

	  if (!just_quit)
	    {
	      pthread_join(*s7_thread, NULL);
	      free(s7_thread);
	      s7_thread = NULL;
	      gdk_window_set_cursor(gtk_text_view_get_window(GTK_TEXT_VIEW(repl), GTK_TEXT_WINDOW_TEXT), arrow);
	      errmsg = s7_get_output_string(sc, s7_current_error_port(sc));
	    }
	  else errmsg = "\ngot C-C!";</em>

	  /* if error, display it, else display result of evaluation */
	  gtk_text_buffer_get_end_iter(repl_buf, &amp;pos);
	  
	  if ((errmsg) &amp;&amp; (*errmsg))
	    gtk_text_buffer_insert(repl_buf, &amp;pos, errmsg, strlen(errmsg));
	  else 
	    {
	      char *result_as_string;
	      result_as_string = s7_object_to_c_string(sc, s7_result);
	      if (result_as_string)
		{
		  gtk_text_buffer_insert(repl_buf, &amp;pos, "\n", 1);
		  gtk_text_buffer_insert(repl_buf, &amp;pos, result_as_string, strlen(result_as_string));
		  free(result_as_string);
		}
	    }
	  s7_close_output_port(sc, s7_current_error_port(sc));
	  s7_set_current_error_port(sc, old_port);
	  s7_gc_unprotect_at(sc, gc_loc);
	}
      g_free(expression);
    }
}

static char *get_current_expression(void)
{
  GtkTextIter pos, previous, next, temp;
  GtkTextMark *m;

  m = gtk_text_buffer_get_insert(repl_buf);
  gtk_text_buffer_get_iter_at_mark(repl_buf, &amp;pos, m);

  if (gtk_text_iter_backward_search(&amp;pos, S7_PROMPT, 0, &amp;temp, &amp;previous, NULL))
    {
      if (!gtk_text_iter_forward_search(&amp;pos, S7_PROMPT, 0, &amp;next, &amp;temp, NULL))
	{
	  gtk_text_buffer_get_end_iter(repl_buf, &amp;next);
	  return(gtk_text_buffer_get_text(repl_buf, &amp;previous, &amp;next, true));
	}
      gtk_text_iter_backward_search(&amp;next, "\n", 0, &amp;pos, &amp;temp, NULL);     
      gtk_text_iter_backward_search(&amp;pos, "\n", 0, &amp;next, &amp;temp, NULL);      
      return(gtk_text_buffer_get_text(repl_buf, &amp;previous, &amp;next, true));
    }
  return(NULL);
}

static void prompt(GtkWidget *w)
{
  GtkTextIter pos;

  gtk_text_buffer_get_end_iter(repl_buf, &amp;pos);
  gtk_text_buffer_insert_with_tags(repl_buf, &amp;pos, "\n" S7_PROMPT, 1 + S7_PROMPT_LENGTH, prompt_not_editable, NULL);

  gtk_text_buffer_place_cursor(repl_buf, &amp;pos);
  gtk_text_view_scroll_mark_onscreen(GTK_TEXT_VIEW(repl), gtk_text_buffer_get_insert(repl_buf));

  g_signal_stop_emission((gpointer)w, g_signal_lookup("key_press_event", G_OBJECT_TYPE((gpointer)w)), 0);
}

static gboolean repl_key_press(GtkWidget *w, GdkEventKey *event, gpointer data)
{
  /* called when you type anything in the text widget.
   *   'data' is our s7 interpreter.
   */
  guint key, state;
  key = event-&gt;keyval;
<em class=red>  state = event-&gt;state;</em>

  if (key == Return_Key)
    {
      if (!s7_is_running)
	evaluate_expression((s7_scheme *)data, get_current_expression());
      prompt(w);
    }
<em class=red>
  /* if C-C typed, and s7 is running, we're trying to break out of a loop */
  if (((key == C_Key) || (key == c_Key)) &amp;&amp;
      ((state & GDK_CONTROL_MASK) != 0) &amp;&amp;
      (s7_is_running))
    {
      just_quit = true;
      pthread_cancel(*s7_thread);
      pthread_detach(*s7_thread);
      s7_is_running = false;
      s7_quit(s7);
      free(s7_thread);
      s7_thread = NULL;
      gdk_window_set_cursor(gtk_text_view_get_window(GTK_TEXT_VIEW(repl), GTK_TEXT_WINDOW_TEXT), arrow);
      prompt(w);
    }
</em>
  return(false);
}

int main(int argc, char **argv)
{
  GtkWidget *shell, *scrolled_window;
  GtkTextIter pos;

  s7 = s7_init();  
  s7_define_function(s7, "exit", my_exit, 0, 0, false, "(exit) exits the program");

  /* make a window with a scrolled text widget */
  gtk_init(&amp;argc, &amp;argv);
  <em class=red>
  spinner = gdk_cursor_new(GDK_WATCH);
  arrow = gdk_cursor_new(GDK_LEFT_PTR);
  </em>
  shell = gtk_window_new(GTK_WINDOW_TOPLEVEL);
  g_signal_connect(G_OBJECT(shell), "delete_event", G_CALLBACK(quit_repl), NULL);

  scrolled_window = gtk_scrolled_window_new(NULL, NULL);
  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolled_window), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
  gtk_container_add(GTK_CONTAINER(shell), scrolled_window);

  repl = gtk_text_view_new();
  repl_buf = gtk_text_buffer_new(NULL);
  gtk_container_add(GTK_CONTAINER(scrolled_window), repl);

  gtk_text_view_set_buffer(GTK_TEXT_VIEW(repl), repl_buf);
  gtk_text_view_set_editable(GTK_TEXT_VIEW(repl), true);
  gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(repl), GTK_WRAP_NONE);
  gtk_text_view_set_cursor_visible(GTK_TEXT_VIEW(repl), true);
  gtk_text_view_set_left_margin(GTK_TEXT_VIEW(repl), 4);

  /* whenever a key is pressed, call repl_key_press */
  gtk_widget_set_events(repl, GDK_ALL_EVENTS_MASK);
  g_signal_connect(G_OBJECT(repl), "key_press_event", G_CALLBACK(repl_key_press), (void *)s7);

  gtk_widget_show(repl);
  gtk_widget_show(scrolled_window);
  gtk_widget_show(shell);

  /* start with a boldface '&gt;' prompt that can't be stepped on */
  prompt_not_editable = gtk_text_buffer_create_tag(repl_buf, "prompt_not_editable", 
						   "editable", false, 
						   "weight", PANGO_WEIGHT_BOLD,
						   NULL);
  gtk_text_buffer_get_end_iter(repl_buf, &amp;pos);
  gtk_text_buffer_insert_with_tags(repl_buf, &amp;pos, S7_PROMPT, S7_PROMPT_LENGTH, prompt_not_editable, NULL);

  /* make the initial window size reasonable */
  gdk_window_resize(gtk_widget_get_window(shell), 400, 200);
  gtk_main();
}
</pre>
</td></tr></table>


<p>This code still has a flaw.  Any GUI callback can
call s7_call or s7_eval_c_string directly.  In the code above, if the listener
starts a long evaluation (or falls into an infinite loop), and we start idly poking around 
with the mouse, waiting for the evaluation to finish, a mouse or menu callback can trigger
a call on the same s7 interpreter that is currently running in the listener.
We are trying to evaluate two different expressions at the same time!  What you
get depends on where s7 notices the problem.  If the evaluator senses that it is lost,
it will raise some confusing error; otherwise the s7 stack will cause a segfault.
We need the GUI to stay active so that we can interrupt computation by typing C-C.
We can't sort through all the events dispatching only the C-C, because that
confuses subsequent GUI actions, and the whole idea here is to keep the interface
alive.  We can put the listener's s7_eval_c_string in a separate s7 thread
so that the multiple evaluations can be interleaved, but those evaluations
can still make calls into Gtk or Motif, and
unfortunately, neither GUI toolkit is thread-safe. If two threads invoke
a GUI function, you get a segfault or some other bizarre screwup.
In Gtk, we have to wrap gdk_threads_enter 
and gdk_threads_leave around any code that calls into Gtk.  We'd set it up by
adding
</p>

<pre>
  g_thread_init(NULL);
  gdk_threads_init();
  gdk_threads_enter();
</pre>

<p>at the very start of our program, and gdk_threads_leave() at the very end.
Then whenever an s7 call might involve Gtk, we wrap it within gdk_threads_enter() and
gdk_threads_leave().  We can't just wrap the outer s7_eval_c_string call above, because
that locks out the keyboard, and the whole point was to catch C-C
while in the s7 evaluation. But in Snd, where both normal functions and gtk callbacks can
trigger arbitrary Scheme code, it would be completely unreasonable to wrap these thread handlers
around every bit of code that might touch the user interface (consider the xg module!).
So...
</p>
<br>



<table border=0 vspace=8 width=30% hspace=100 cellpadding=0 cellspacing=0><tr><td bgcolor="lightgreen">
  <table width="100%" border=0><tr><td bgcolor="beige" align="center"></td></tr></table></td></tr></table>

<A NAME="replrescue"></A>

<p>
Common Lisp has something called "evalhook" that makes it possible
to insert your own function into eval.  In s7, we have a "begin_hook" which sits at the opening of any begin block
(implicit or explicit).  Here are two REPLs, one for Gtk, and one for a bare terminal.
</p>




<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
/* terminal-based REPL, 
 *    an expansion of the <a href="#repl">read-eval-print loop</a> program above.
 * type C-g to interrupt an evaluation.
 */
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;termios.h&gt;
#include &lt;signal.h&gt;

#include "s7.h"
static s7_pointer my_exit(s7_scheme *sc, s7_pointer args) {exit(0);}

static struct termios save_buf, buf;

static void sigcatch(int n)
{
  /* put things back the way they were */
  tcsetattr(fileno(stdin), TCSAFLUSH, &amp;save_buf);
  exit(0);
}

static char buffer[512];
static int type_ahead_point = 0;

static bool <em class=red>watch_for_c_g</em>(s7_scheme *sc)
{
  char c;
  bool all_done = false;
  /* watch for C-g without blocking, save other chars as type-ahead */
  tcsetattr(fileno(stdin), TCSAFLUSH, &amp;buf);

  if (read(fileno(stdin), &amp;c, 1) == 1)
    {
      if (c == 7) /* C-g */
	{
	  all_done = true;
	  type_ahead_point = 0;
	}
      else buffer[type_ahead_point++] = c;
    }

  tcsetattr(fileno(stdin), TCSAFLUSH, &amp;save_buf);
  return(all_done);
}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  bool use_begin_hook;

  use_begin_hook = (tcgetattr(fileno(stdin), &amp;save_buf) &gt;= 0);
  if (use_begin_hook)
    {
      buf = save_buf;
      buf.c_lflag &amp;= ~ICANON;
      buf.c_cc[VMIN] = 0;         /* if no chars waiting, just return */
      buf.c_cc[VTIME] = 0;

      signal(SIGINT, sigcatch);
      signal(SIGQUIT, sigcatch);
      signal(SIGTERM, sigcatch);
    }

  s7 = s7_init();  
  s7_define_function(s7, "exit", my_exit, 0, 0, false, "(exit) exits the program");

  if (argc == 2)
    {
      fprintf(stderr, "load %s\n", argv[1]);
      s7_load(s7, argv[1]);
    }
  else
    {
      char response[1024];
      while (1) 
	{
	  fprintf(stdout, "\n&gt; ");
	  fgets((char *)(buffer + type_ahead_point), 512 - type_ahead_point, stdin);
	  type_ahead_point = 0;

	  if ((buffer[0] != '\n') || 
	      (strlen(buffer) &gt; 1))
	    {                            
	      sprintf(response, "(write %s)", buffer);

	      if (use_begin_hook)
		<em class=red>s7_set_begin_hook</em>(s7, watch_for_c_g);
	      s7_eval_c_string(s7, response);
	      if (use_begin_hook)
		<em class=red>s7_set_begin_hook</em>(s7, NULL);
	    }
	}
    }
  if (use_begin_hook)
    tcsetattr(fileno(stdin), TCSAFLUSH, &amp;save_buf);
}
</pre>
</td></tr></table>

<br>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
/* Gtk-based REPL using s7_begin_hook 
 */
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;gtk/gtk.h&gt;

#if HAVE_GTK_3
  #include &lt;gdk/gdk.h&gt;
  #define Return_Key GDK_KEY_Return
  #define C_Key GDK_KEY_C
  #define c_Key GDK_KEY_c
#else
  #include &lt;gdk/gdkkeysyms.h&gt;
  #define Return_Key GDK_Return
  #define C_Key GDK_C
  #define c_Key GDK_c
#endif

#include "s7.h"
static s7_pointer my_exit(s7_scheme *sc, s7_pointer args) {exit(0);}

#define S7_PROMPT "s7&gt; "
#define S7_PROMPT_LENGTH 4
#define S7_INTERRUPTED_MESSAGE "\ns7 interrupted!"

static GtkWidget* repl;                        /* the REPL text widget */
static GtkTextBuffer *repl_buf;                /* its text buffer */
static GtkTextTag *prompt_not_editable = NULL; /* a tag to make sure the prompt can't be erased */
static GdkCursor *arrow, *spinner;

static gint quit_repl(GtkWidget *w, GdkEvent *event, gpointer context) {exit(0);}

<em class=red>static bool C_c_typed = false;

static bool begin_hook(s7_scheme *sc)
{
  C_c_typed = false;
  if (gtk_events_pending()) /* this is very slow -- see snd-listener.c for a work-around */
    gtk_main_iteration();
  return(C_c_typed);
}</em>

static void evaluate_expression(s7_scheme *sc, char *expression)
{
  /* evaluate expression, display result, catching and displaying any errors */
  if ((expression) &amp;&amp;
      (*expression))
    {
      if ((strlen(expression) &gt; 1) || 
	  (expression[0] != '\n'))
	{
	  const char *errmsg = NULL;
	  int gc_loc;
	  s7_pointer old_port, result;
	  GtkTextIter pos;

	  old_port = s7_set_current_error_port(sc, s7_open_output_string(sc));
	  gc_loc = s7_gc_protect(sc, old_port);
	  gdk_window_set_cursor(gtk_text_view_get_window(GTK_TEXT_VIEW(repl), GTK_TEXT_WINDOW_TEXT), spinner);
	  
	  <em class=red>s7_set_begin_hook(sc, begin_hook);
	  result = s7_eval_c_string(sc, expression);
	  s7_set_begin_hook(sc, NULL);</em>

	  gdk_window_set_cursor(gtk_text_view_get_window(GTK_TEXT_VIEW(repl), GTK_TEXT_WINDOW_TEXT), arrow);
	  gtk_text_buffer_get_end_iter(repl_buf, &amp;pos);

	  <em class=red>if (C_c_typed)
	    {
	      gtk_text_buffer_insert(repl_buf, &amp;pos, S7_INTERRUPTED_MESSAGE, strlen(S7_INTERRUPTED_MESSAGE));
	      C_c_typed = false;
	    }
	  else</em>
	    {
	      errmsg = s7_get_output_string(sc, s7_current_error_port(sc));
	      if ((errmsg) &amp;&amp; (*errmsg))
		gtk_text_buffer_insert(repl_buf, &amp;pos, errmsg, strlen(errmsg));
	      else 
		{
		  char *result_as_string;
		  result_as_string = s7_object_to_c_string(sc, result);
		  if (result_as_string)
		    {
		      gtk_text_buffer_insert(repl_buf, &amp;pos, "\n", 1);
		      gtk_text_buffer_insert(repl_buf, &amp;pos, result_as_string, strlen(result_as_string));
		      free(result_as_string);
		    }
		}
	    }

	  s7_close_output_port(sc, s7_current_error_port(sc));
	  s7_set_current_error_port(sc, old_port);
	  s7_gc_unprotect_at(sc, gc_loc);
	}

      g_free(expression);
    }
}

static char *get_current_expression(void)
{
  GtkTextIter pos, previous, next, temp;
  GtkTextMark *m;
  m = gtk_text_buffer_get_insert(repl_buf);
  gtk_text_buffer_get_iter_at_mark(repl_buf, &amp;pos, m);
  if (gtk_text_iter_backward_search(&amp;pos, S7_PROMPT, 0, &amp;temp, &amp;previous, NULL))
    {
      if (!gtk_text_iter_forward_search(&amp;pos, S7_PROMPT, 0, &amp;next, &amp;temp, NULL))
	{
	  gtk_text_buffer_get_end_iter(repl_buf, &amp;next);
	  return(gtk_text_buffer_get_text(repl_buf, &amp;previous, &amp;next, true));
	}
      gtk_text_iter_backward_search(&amp;next, "\n", 0, &amp;pos, &amp;temp, NULL);     
      gtk_text_iter_backward_search(&amp;pos, "\n", 0, &amp;next, &amp;temp, NULL);      
      return(gtk_text_buffer_get_text(repl_buf, &amp;previous, &amp;next, true));
    }
  return(NULL);
}

static void prompt(GtkWidget *w)
{
  GtkTextIter pos;
  gtk_text_buffer_get_end_iter(repl_buf, &amp;pos);
  gtk_text_buffer_insert_with_tags(repl_buf, &amp;pos, "\n" S7_PROMPT, 1 + S7_PROMPT_LENGTH, prompt_not_editable, NULL);
  gtk_text_buffer_place_cursor(repl_buf, &amp;pos);
  gtk_text_view_scroll_mark_onscreen(GTK_TEXT_VIEW(repl), gtk_text_buffer_get_insert(repl_buf));
  g_signal_stop_emission((gpointer)w, g_signal_lookup("key_press_event", G_OBJECT_TYPE((gpointer)w)), 0);
}

static gboolean repl_key_press(GtkWidget *w, GdkEventKey *event, gpointer data)
{
  /* called when you type anything in the text widget.
   *   'data' is our s7 interpreter.
   */
  guint key, state;
  s7_scheme *sc;

  sc = (s7_scheme *)data;
  key = event-&gt;keyval;
  state = event-&gt;state;

  if (key == Return_Key)
    {
      if (<em class=red>s7_begin_hook(sc) == NULL</em>)
	{
	  evaluate_expression(sc, get_current_expression());
	  prompt(w);
	}
    }

  if (((key == C_Key) || (key == c_Key)) &amp;&amp;
      ((state &amp; GDK_CONTROL_MASK) != 0))
    <em class=red>C_c_typed = true</em>;

  return(false);
}

int main(int argc, char **argv)
{
  GtkWidget *shell, *scrolled_window;
  GtkTextIter pos;
  s7_scheme *s7;

  s7 = s7_init();  
  s7_define_function(s7, "exit", my_exit, 0, 0, false, "(exit) exits the program");

  gtk_init(&amp;argc, &amp;argv);
  spinner = gdk_cursor_new(GDK_WATCH);
  arrow = gdk_cursor_new(GDK_LEFT_PTR);
  
  shell = gtk_window_new(GTK_WINDOW_TOPLEVEL);
  g_signal_connect(G_OBJECT(shell), "delete_event", G_CALLBACK(quit_repl), NULL);

  scrolled_window = gtk_scrolled_window_new(NULL, NULL);
  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolled_window), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
  gtk_container_add(GTK_CONTAINER(shell), scrolled_window);

  repl = gtk_text_view_new();
  repl_buf = gtk_text_buffer_new(NULL);
  gtk_container_add(GTK_CONTAINER(scrolled_window), repl);

  gtk_text_view_set_buffer(GTK_TEXT_VIEW(repl), repl_buf);
  gtk_text_view_set_editable(GTK_TEXT_VIEW(repl), true);
  gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(repl), GTK_WRAP_NONE);
  gtk_text_view_set_cursor_visible(GTK_TEXT_VIEW(repl), true);
  gtk_text_view_set_left_margin(GTK_TEXT_VIEW(repl), 4);
  gtk_widget_set_events(repl, GDK_ALL_EVENTS_MASK);
  g_signal_connect(G_OBJECT(repl), "key_press_event", G_CALLBACK(repl_key_press), (void *)s7);

  gtk_widget_show(repl);
  gtk_widget_show(scrolled_window);
  gtk_widget_show(shell);

  prompt_not_editable = gtk_text_buffer_create_tag(repl_buf, "prompt_not_editable", 
						   "editable", false, 
						   "weight", PANGO_WEIGHT_BOLD,
						   NULL);
  gtk_text_buffer_get_end_iter(repl_buf, &amp;pos);
  gtk_text_buffer_insert_with_tags(repl_buf, &amp;pos, S7_PROMPT, S7_PROMPT_LENGTH, prompt_not_editable, NULL);
  gdk_window_resize(gtk_widget_get_window(shell), 400, 200);
  gtk_main();
}
</pre>
</td></tr></table>

<p>In the Gtk case above, begin_hook itself checks the user-interface (via gtk_main_iteration), so a key_press event
(or any other) can still get through, even if s7_eval_c_string falls into an
infinite loop.  If a GUI event triggers a call on s7, that call happens in the current thread
at a protected point in the s7 evaluation, so the GUI toolkit is happy because there's
only the current thread, and s7 is happy because it handles the interleaved expression
at a point where it can't confuse the current evaluation.
If the begin_hook function returns true (if C-C is typed),
s7 itself calls s7_quit, interrupting the current evaluation. 
If return is typed, and s7 is running (begin_hook is not NULL),
we ignore it.  Otherwise return causes our REPL to send
the current string to s7_eval_c_string.  Upon returning from s7_eval_c_string,
we check whether we were interrupted (C_c_typed is true), and if so, send a surprised
message to the REPL.  Otherwise we handle everything as in the previous REPLs.
</p>

<p>If the s7 evaluation can't affect the GUI and the GUI can't call s7 itself,
then you don't need to use begin_hook.
</p>

<p>begin_hook provides a way to call arbitrary C or Scheme code at any time;
the mind boggles!  In the Snd listener, for example, you can ask for a stack trace
to see if your long computation is making progress.  Since the normal
begin_hook function keeps the interface alive, a callback can save the current
begin_hook function, insert its own function to do something useful, then that function can
replace itself with the original:
</p>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=16>
<tr><td bgcolor="#fbfbf0">
<pre>
static bool (*current_begin_hook)(s7_scheme *sc);       /* this will be the saved original function */

static bool stacktrace_begin_hook(s7_scheme *sc)        /* this is our one-shot replacement */
{
  s7_stacktrace(sc, s7_name_to_value(sc, "*stderr*"));  /* it prints a stacktrace */
  s7_set_begin_hook(s7, current_begin_hook);            /*   then replaces itself with the original */
  return(false);
}

static void listener_stacktrace_callback(...)           /* the usual callback boilerplate here */
{
  current_begin_hook = s7_begin_hook(s7);               /* save current begin_hook function */
  if (current_begin_hook)                               /* s7 is running, so... */
    s7_set_begin_hook(s7, stacktrace_begin_hook);       /*   insert our stacktrace function in its place */
}
</pre>
</td></tr></table>

<br><br>


</body>
</html>

