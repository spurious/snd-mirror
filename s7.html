<html>
<!-- documentation for s7 -->

<head>
<title>s7</title>
<style type="text/css">
<!-- 
	EM.red {color:red; font-style:normal}
        EM.error {color:chocolate; font-style:normal}
        EM.typing {color:maroon; font-style: normal}
        EM.listener {color:darkblue; font-style: normal}
	EM.emdef {font-weight: bold; font-style: normal}
	H1 {text-align: center}
	UL {list-style-type: none}

	A {text-decoration:none}
	A:hover {text-decoration:underline}
	A.quiet {color:black; text-decoration:none}
	A.quiet:hover {text-decoration:underline}
	A.def {font-weight: bold; font-style: normal; text-decoration:none; text-color:black}
-->

</style>
</head>
<body bgcolor=white>

<br>

<table border=0 bordercolor="lightgreen" width=100% cellpadding=2 cellspacing=0><tr><td bgcolor="lightgreen">
<A NAME="s7doc"></a>
<table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>s7</h2></td></tr></table>
</td></tr></table>

<p>s7 is a Scheme implementation, compatible with r5rs, and intended as an extension language
for other applications, primarily Snd and Common Music.  It exists as just two files, s7.c and
s7.h, that want only to disappear into someone else's source tree.  There are no libraries,
no run-time init files, and no configuration scripts.
It can be built as a stand-alone
interpreter, if you insist (see below).  There is a regression test for s7: s7test.scm in the
Snd tarball, or (the same file) r5rstest.scm at ccrma-ftp.  If you're running s7 in a context
that has getenv, file-exists?, and system (Snd for example), you can use s7-slib-init.scm
to gain easy access to slib.
</p>
<p>
s7 is the default extension language of Snd and sndlib (http://ccrma.stanford.edu/software/snd/),
and Rick Taube's Common Music (commonmusic at sourceforge).  There are X, Motif, Gtk, and openGL bindings
in libxm (in the Snd tarball, or at ftp://ccrma-ftp.stanford.edu/pub/Lisp/libxm.tar.gz).
</p>

<p>s7 has full continuations, dynamic-wind, sort!, 
error handling, ratios and complex numbers,
defmacro and define-macro, keywords, hash-tables, block comments,
threads, multiprecision arithmetic for all numeric types,
generalized set!, format, define*, and a host of other
extensions of r5rs.  It does not have syntax-rules or any of
its friends, and it does not think there is any such thing
as an "inexact integer" (what were those guys smoking?).
</p>

<p>This file assumes you know about Scheme and all its problems,
and want a quick tour of where s7 is different:
</p>
<br>

<dl>
<dt><em class=emdef>call-with-exit</em>
<dd><p>This is a continuation without the ability to return (an escape or goto).
Use call-with-current-continuation or call/cc for a full continuation.
</p>
<pre>
(define (find-first-even-number arg)
  (<em class=red>call-with-exit</em>
   (lambda (return)
     (for-each
      (lambda (a)
	(if (even? a)
	    (return a)))
      arg))))

(find-first-even-number (list 1 3 9 13 8 2 4)) -&gt; 8
</pre>
<br>


<dt><p><em class=emdef>multiprecision arithmetic</em>
<dd>All numeric types (integers, ratios, reals, complex numbers) are supported.
s7 can be built with multiprecision support
for all types,  using the gmp, mpfr, and mpc libraries.  The basic integer and real
types are defined in s7.h, defaulting to long long int and double.  To get multiprecision
numbers, build s7 with WITH_GMP set to 1 (see s7.c).  pi is predefined, as are
most-positive-fixnum and most-negative-fixnum.  If multiprecision arithmetic is
enabled, the following functions are included: bignum, bignum?, and bignum-precision.
bignum-precision, which defaults to 128, sets the number of bits each float takes.
pi automatically reflects the current bignum-precision:
</p>
<pre>
&gt; pi
3.141592653589793238462643383279502884195E0
&gt; (bignum-precision)
128
&gt; (set! (bignum-precision) 256)
256
&gt; pi
3.141592653589793238462643383279502884197169399375105820974944592307816406286198E0
</pre>
<p>
bignum? returns #t if its argument is a big number of some type.  To create a big number,
either include enough digits to overflow the default types, or use the bignum function.
Its argument is a string representing the desired number:
</p>
<pre>
&gt; (bignum "123456789123456789")
123456789123456789
&gt; (bignum "1.123123123123123123123123123")
1.12312312312312312312312312300000000009E0
</pre>
<br>

<dt><em class=emdef>defmacro, define-macro, and macroexpand</em>
<dd><p>These are the standard macro definers.  </p>
<pre>
(define-macro (add-1 arg) `(+ 1 ,arg))
(defmacro add-1 (arg) `(+ 1 ,arg))
</pre>
<p>macroexpand can help debug a macro:
</p>
<pre>
&gt; (define-macro (add-1 arg) `(+ 1 ,arg))
add-1
&gt; (macroexpand (add-1 32))
(+ 1 32)
</pre>
<br>


<dt><em class=emdef>define* and lambda*</em>
<dd><p>These are extensions of define and lambda that make it easier to
to deal with optional, keyword, and rest arguments.  
The syntax is very simple: every argument to define* has a default value
and is automatically available as a keyword argument.  The default value
is either #f (if unspecified), or given in a list whose first member is
the argument name.
The last argument
can be preceded by :rest or a dot to indicate that all other trailing arguments
should be packaged as a list under that argument's name.  You can use
:optional and :key, but they are ignored.  
</p>
<pre>
(<em class=red>define*</em> (hi a (b 32) (c "hi")) (list a b c))
</pre>
<p>Here the argument "a" defaults to #f, "b" to 32, etc.
When the function is called, 
the argument names are bound to their default values, then the function's
current argument list is scanned.  Any name that occurs as a keyword (":a")
sets that argument's new value.  Otherwise, as values occur, they
are plugged into the actual argument list based on their position.
This is called an optional-key list in CLM.  So, taking the function
above as an example:
</p>
<pre>
(hi 1) -&gt; '(1 32 "hi")
(hi :b 2 :a 3) -&gt; '(3 2 "hi")
(hi 3 2 1) -&gt; '(3 2 1)
</pre>
<br>

<dt><em class=emdef>applicable objects and generalized set!</em>
<dd><p>Lists, strings, vectors, hash-tables, and any cooperating C-defined objects
are both applicable and settable.  I think the syntax is pretty:
</p>
<pre>
(let ((lst (list 1 2 3)))
  (set! (lst 1) 32)
  (list (lst 0) (lst 1)))
-&gt; '(1 32)

(let ((hash (make-hash-table)))
  (set! (hash 'hi) 32)
  (hash 'hi))
-&gt; 32
</pre>
<p>You can use list-ref and friends, of course, but just try to read any serious vector arithmetic code
when it is buried in vector-refs and vector-set!s! 
</p>
<br>

<dt><em class=emdef>make-procedure-with-setter</em>
<dd><p>A procedure-with-setter consists of two functions, the "getter" and the "setter".
The getter is called when the object is encountered as a function, and the setter when
it is set:
</p>
<pre>
(define x 32)
(define xx (make-procedure-with-setter (lambda () x) (lambda (val) (set! x val) x)))
(xx) -&gt; 32
(set! (xx) 1)
(xx) -&gt; 1
</pre>
<br>

<dt><em class=emdef>block comments in #| ... |# and #! ... !#</em>
<dd>
<p>Multi-line comments can be enclosed in either #| and |#, or #! and !# (the latter
is for compatibility with Guile).
</p>
<br>

<dt><em class=emdef>hash tables </em>
<dd><p>
<ul>
<li>make-hash-table
<li>hash-table-ref
<li>hash-table-set!
<li>hash-table?
<li>hash-table-size
</ul>
<p>The hash key can be a symbol, string, integer, or (problematically of course) a real.
</p>
<br>

<dt><em class=emdef>threads</em>
<dd><p>If s7 is built with HAVE_PTHREADS set, you get multithreading functions.
</p>
<ul>
<li>(make-thread thunk)
<li>(join-thread thread)
<li>(thread? obj)
<li>(make-lock)
<li>(grab-lock lock)
<li>(release-lock lock)
<li>(lock? obj)
<li>(make-thread-variable)
<li>(thread-variable? obj)
</ul>
<p>
Threads in s7 share the heap and symbol table, but have their own local environment, stack,
and evaluator locals.  I use the term "lock" in place of "mutex", and "thread-variable"
in place of "pthread_key".  The thread-variable is applicable and settable, so instead
of pthread_getspecific, simply call it: (var).
</p>
<br>

<dt><em class=emdef>format</em>
<dd><p>s7's built-in format function is very close to that in srfi-48.</p>
<pre>
(format #f "~A ~D ~F" 'hi 123 3.14)
-&gt; "hi 123 3.140000"
</pre>
<br>

<dt><em class=emdef>FFI</em>
<dd><p>s7 exists only to serve as an extension of some other application, so in a sense
it is just a foreign function interface.  See s7.h for the API and many examples.
Here is a bare REPL:
</p>
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include "s7.h"

static s7_pointer our_exit(s7_scheme *sc, s7_pointer args) {exit(1);}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];
  s7 = s7_init();                     /* initialize the interpreter */
  s7_define_function(s7, "exit", our_exit, 0, 0, false, "(exit) exits the program");
  while (1)                           /* fire up a REPL */
    {
      fprintf(stdout, "\n&gt; ");        /* prompt for input */
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  s7_eval_c_string(s7, response); /* evaluate input and write the result */
	}
    }
}
</pre>
<br>

<dt><em class=emdef>error handling via error and catch</em>
<dd><p>s7's error handling mimics that of (pre-r6rs) Guile.  An error is signalled
via the error function, and can be trapped and dealt with via catch.
</p>
<pre>
(<em class=red>catch</em> 'wrong-number-of-args
  (lambda ()     ; code protected by the catch
    (abs 1 2))
  (lambda args   ; the error handler
    (apply format (append (list #t) (cadr args)))))

-&gt; "abs: too many arguments: (1 2)"
</pre>
<p>
catch has 3 arguments: a tag indicating what error to catch (#t = anything),
the code (a thunk) that the catch is protecting, and the function to call
if a matching error occurs during the evaluation of the thunk.  The error handler
takes a rest argument which will hold whatever the error function chooses to pass it.
The error function itself takes at least 2 arguments, the error type (a symbol),
and the error message.  There may also be other arguments describing the error.
The default action (in the absence of any catch) is to treat the message as
a format control string, apply format to it and the other arguments, and
send that info to the current-error-port.
</p>
<p>When an error is encountered, the variable *error-info* (a vector) contains
additional info about that error:
</p>
<ul>
<li>0: the error type or tag (e.g. 'division-by-zero)
<li>1: the message or information passed by the error function
<li>2: if not #f, the code that s7 thinks triggered the error
<li>3: if not #f, the line number of that code
<li>4: if not #f, the file name of that code
<li>5: the environment at the point of the error
<li>6...: stack enviroment pointers (giving enough info to reconstruct the current call stack), ending in #f
</ul>
<p>To find a variable's value at the point of the error:
</p>
<pre>
(symbol->value var (vector-ref *error-info* 5))
</pre>
<p>To print the stack at the point of the error:
</p>
<pre>
(stacktrace *error-info*)
</pre>

<!-- also break trace stacktrace etc -->
<br>

<dt><em class=emdef>encapsulation</em>
<dd><p>...</p>
<br>

<dt><em class=emdef>math functions</em>
<dd><p>
s7 includes:
</p>
<ul>
<li>sinh, cosh, tanh, asinh, acosh, atanh
<li>logior, logxor, logand, lognot, ash, integer-length
<li>random
</ul>
<p>
The random function can take any numeric argument, including 0 (don't get me started...).
The following constants are predefined: pi, most-positive-fixnum, most-negative-fixnum.
</p>
<br>

<dt><em class=emdef>IO functions</em>
<dd>
<p>Besides files, ports can also represent strings and functions.  The string port functions
are:
</p>
<ul>
<li>with-output-to-string
<li>with-input-from-string
<li>call-with-output-string
<li>call-with-input-string,
<li>open-output-string
<li>open-input-string
<li>get-output-string
</ul>
<pre>
(let ((result #f) 
      (p (open-output-string)))
  (format p "this ~A ~C test ~D" "is" #\a 3)
  (set! result (get-output-string p))
  (close-output-port p)
  result)
-&gt; "this is a test 3"
</pre>
<p>Other functions:</p>
<ul>
<li>read-byte and write-byte (binary IO)
<li>read-line (line-at-a-time reads)
</ul>
<p>The variable *vector-print-length* sets
the upper limit on how many vector elements are printed by object->string and format.
</p>
<br>

<dt><em class=emdef>Generic functions</em>
<dd><p>length, copy, and fill! are generic functions in the sense that their argument can be
a list, string, vector, hash-table, or C-define object.  Since vectors and lists are set-applicable, 
and length is generic, we can write a generic FFT that accepts both types or any other object that follows this syntax:
</p>
<pre>
        (define* (cfft! data n (dir 1)) ; (complex data)
          (if (not n) (set! n (length data)))
          (do ((i 0 (+ i 1))
               (j 0))
              ((= i n))
            (if (&gt; j i)
        	(let ((temp (data j)))
        	  (set! (data j) (data i))
        	  (set! (data i) temp)))
            (let ((m (/ n 2)))
              (do () 
        	  ((or (&lt; m 2) (&lt; j m)))
        	(set! j (- j m))
        	(set! m (/ m 2)))
              (set! j (+ j m))))
          (let ((ipow (floor (log n 2)))
        	(prev 1))
            (do ((lg 0 (+ lg 1))
        	 (mmax 2 (* mmax 2))
        	 (pow (/ n 2) (/ pow 2))
        	 (theta (make-rectangular 0.0 (* pi dir)) (* theta 0.5)))
        	((= lg ipow))
              (let ((wpc (exp theta))
        	    (wc 1.0))
        	(do ((ii 0 (+ ii 1)))
        	    ((= ii prev))
        	  (do ((jj 0 (+ jj 1))
        	       (i ii (+ i mmax))
        	       (j (+ ii prev) (+ j mmax)))
        	      ((&gt;= jj pow))
        	    (let ((tc (* wc (data j))))
        	      (set! (data j) (- (data i) tc))
        	      (set! (data i) (+ (data i) tc))))
        	  (set! wc (* wc wpc)))
        	(set! prev mmax))))
          data)
        
        &gt; (cfft! (list 0.0 1+i 0.0 0.0))
        (1+1i -1+1i -1-1i 1-1i)
        &gt; (cfft! (vector 0.0 1+i 0.0 0.0))
        #(1+1i -1+1i -1-1i 1-1i)
</pre>
<br>

<dt><em class=emdef>multidimensional vectors</em>
<dd><p>
If s7 is built with WITH_MULTIDIMENSIONAL_VECTORS set (the default), it supports 
vectors with any number of dimensions.  It is here, in particular, that the generalized
set! stuff shines.  make-vector's 2nd argument can be a list of dimensions, rather than
an integer (the one dimensional case):
</p>
<pre>
(make-vector (list 2 3 4))
(make-vector '(2 3) 1.0)
</pre>
<p>The second example includes the optional default vector element.  Once defined,
(vect i j k) or (to be very verbose, (vector-ref vect i j k)) returns the given
element, and (set! (vect i j k) m), (or verbose and unreadable, (vector-set! vect i j k m))
sets that element.
</p>
</br>

<dt><em class=emdef>make-promise</em>
<dd><p>This is named "delay" in most Schemes, but that name belongs to CLM.
</p>
<br>

<dt><em class=emdef>Load additions</em>
<dd><p>*load-path* is a list of directories to search when loading a file.
*load-hook* is a function called just before a file is loaded.  Its argument is the filename.
While loading, port-filename and port-line-number (of the current-input-port) can tell you
where you are in the file.
</p>
<br>

<dt><em class=emdef>GC</em>
<dd><p>The gc function either calls the GC (if passed no arguments), or turns the GC either on (pass #t)
or off (pass #f).
</p>
<br>

<dt><em class=emdef>*features*</em>
<dd><p>As in Common Lisp, *features* is a list describing what is currently loaded into s7.  You can
check it with the provided? function, or add something to it with provide.
</p>
<br>

<dt><em class=emdef>procedure info</em>
<dd><p>procedure-source, procedure-arity, procedure-documentation, and help provide a look into a
scheme function.
procedure-documentation returns the documentation string associated with a procedure (the initial string in the
function's body). procedure-arity returns a list describing the argument list of a function: '(required-args optional-args rest-arg).
procedure-source returns the source (as a list) of a procedure.
</p>
<pre>
&gt; (define* (add-2 a (b 32)) "add-2 adds its 2 args" (+ a b))
add-2
&gt; (procedure-documentation add-2)
"add-2 adds its 2 args"
&gt; (procedure-arity add-2)
(0 2 #f)
&gt; (procedure-source add-2)
(lambda* (a (b 32)) "add-2 adds its 2 args" (+ a b))
</pre>
<br>


<dt><em class=emdef>symbol table info</em>
<dd><p>(symbol-table) returns the symbol table, a vector of lists of symbols.
(symbol-&gt;value sym :optional env) returns the binding of 'sym'
in the given environment which defaults to the current environment.
(defined? obj :optional env) returns #t if 'obj' has a binding (a value) in the environment 'env'.
If profiling is enabled (set WITH_PROFILING in s7.c), (symbol-calls sym) returns
the number of times that symbol's binding has been applied.
Here we scan the symbol table for any function that doesn't have documentation:
</p>
<pre>
       (let ((st (<em class=red>symbol-table</em>)))
         (do ((i 0 (+ i 1))) 
             ((= i (vector-length st)))
           (let ((lst (vector-ref st i)))
             (for-each 
               (lambda (sym)
       	         (if (defined? sym)
	             (let ((val (<em class=red>symbol-&gt;value</em> sym)))
	               (if (and (procedure? val)
			        (string=? "" (procedure-documentation val)))
		           (format #t "~A " sym)))))
               lst))))
</pre>
<br>

<dt><em class=emdef>environments</em>
<dd><p>environments are "first class objects" in s7.  An environment is
a list of alists ending with a hash-table (the global environment).
(current-environment :optional thread)
returns the current environment (symbol bindings).  (global-environment)
returns the top-level environment.
Here is an example of "apropos" that accesses both environments:
</p>
<pre>
        (define (apropos name)
          ;; (apropos "name") prints out a list of all symbols whose name includes "name" as a substring

          (define (substring? subs s) ; from Larceny
            (let* ((start 0)
	           (ls (string-length s))
	           (lu (string-length subs))
	           (limit (- ls lu)))
              (let loop ((i start))
	        (cond ((&gt; i limit) #f)
	              ((do ((j i (+ j 1))
	        	    (k 0 (+ k 1)))
	        	   ((or (= k lu)
	        		(not (char=? (string-ref subs k) (string-ref s j))))
	        	    (= k lu))) i)
	              (else (loop (+ i 1)))))))

          (define (apropos-1 alist)
            (for-each
             (lambda (binding)
               (if (substring? name (symbol-&gt;string (car binding)))
	           (format (current-output-port) "~A: ~A~%" 
	        	   (car binding) 
	        	   (if (procedure? (cdr binding))
	        	       (procedure-documentation (cdr binding))
	        	       (cdr binding)))))
             alist))

          (for-each
           (lambda (frame)
             (if (vector? frame) ; the global environment
	         (let ((len (vector-length frame)))
	           (do ((i 0 (+ i 1)))
	               ((= i len))
	             (apropos-1 (vector-ref frame i))))
	         (apropos-1 frame)))
           (<em class=red>current-environment</em>)))
</pre>
<p>
You can change the current environment by hand:
</p>
<pre>
      (define (push-environment e binding)
        (if (vector? (car e))
            (begin
              (set-cdr! e (list (car e)))
              (set-car! e (list binding)))
            (set-car! e (cons binding (car e)))))
   
      (define (pop-environment e)
        (if (not (vector? (car e)))
            (begin
              (set-car! e (cadr e))
              (set-cdr! e (cddr e)))))
   
      (define-macro (define! e var val) ; define val=val in env e
        `(push-environment ,e (cons ',var ,val)))

      (define (make-environment . initial-bindings)
         (cons initial-bindings (global-environment)))

     (let ((x 3)) 
       (define! (current-environment) hi 21)
       (+ x hi))
     -&gt; 24
     (let ((x 32)) 
       (eval `(+ x y) (make-environment '(x . 2) '(y . 4))))
     -&gt; 6
</pre>
<br>

<hr>

<dt>
<dd>
<ul>
<li>stack
<li>object-&gt;string, eval-string, eval
<li>reverse!, list-set!, sort!
<li>quit, *error-hook*
<li>define-constant, constant?
<li>stacktrace, trace and untrace, __func__
<li>define-expansion
</ul>
</p>
<br>


<dt><em class=emdef>other differences from r5rs</em>
<dd><p>
<ul>
<li>exact means integer or ratio, inexact means not exact.
<li>floor, ceiling, truncate, and round return (exact) integer results.
<li>no syntax-rules or any of its friends.
<li>"#" does not stand for an unknown digit.
<li>the "@" complex number notation is not supported.
<li>"+i" is not considered a number; include the real part.
<li>modulo, remainder, and quotient take integer, ratio, or real arguments.
<li>lcm and gcd can take integer or ratio arguments.
<li>continuation? function to distinguish a continuation from a procedure.
<li>log takes an optional 2nd arg (the base).
<li>'.' and an exponent can occur in a number in any base.
<li>do sets its step variables, rather than rebinding them.
</ul>
</p>

</dl>


<!--
  
added profiling option (--with-profiling in configure) to s7.  profile
  function in extensions.scm.  This could be greatly elaborated, if
  it's of interest.

added trace, untrace, break and __func__ to s7. The __func__ info made it possible
  to remove the backtrace facility altogether: backtracing, backtrace, set-backtrace-length,
  clear-backtrace, and list-line-number have been removed.  These are replaced by
  the stacktrace function, callable from within a break or error handler.
  stacktrace (and error position info) still needs a lot of work.

added "encapsulators" to s7:
   open-encapsulator, close-encapsulator, (obj) to restore, encapsulator-bindings
 
   (define-macro (encapsulate . body) 
      (let ((encap (gensym)))
        `(let ((,encap (open-encapsulator)))
           (dynamic-wind
              (lambda () 
	        #f)
              (lambda () 
	        ,@body)
              (lambda () 
	        ((,encap))  ; restore saved vars
                (close-encapsulator ,encap))))))
 
    This evaluates "body", then returns any variables global to that code to their prior value:

        > (define global-x 32)
        global-x
        > (encapsulate 
            (set! global-x 123) 
            (format #f "x: ~A" global-x))
        "x: 123"
        > global-x
        32

    There are three or maybe four reasons for encapsulators (rather than, say, fluid-let).
    The main one is that it's a neat idea: a sort of data-side continuation.  open-encapsulator
    remembers the overall environment at the point it is called, returning an encapuslator
    object.  Whenever we want to return to that data state, we call that object as a thunk.
    encapsulator-bindings returns the alist of variables awaiting restoration.  Once called,
    that list is cleared, and the encapsulator starts saving values again (so repeated calls
    keep returning you to that data state).  close-encapsulator turns that encapsulator off.
    In a REPL, for example, you could save the initial state, then return to it at any time,
    without restarting the interpreter.  fluid-let is not what we want here because it has
    a body, and requires that you list in advance what variables you want to protect (and
    besides, it's not really a let (it uses "set!") and I can't see anything fluid about it).
    By tracing the encapsulator object, we can see every set! within some piece of code.
    This encapsulation is not complete: I haven't finished making Snd/CLM objects work
    with it, and some Scheme constructs aren't handled yet: (string-set! (vector-ref...))
    for example. 



   * s7 (scheme) variables:
   *
   *    *features*              a list of symbols describing what is current available (initially '(s7)).
   *                               "provide" adds a symbol to the list, 
   *                               "provided?" returns #t if its symbol arg is in the list.
   *    __func__                equivalent to C's __func__.  The symbol of the function currently being defined.
   *    *error-hook*            called upon error, a function of two args, 
   *                               the error type (a symbol), and the info about it (a list).

   *

   * s7 non-standard functions:
   *
   *    quit                    exits s7
   *    continuation?           #t if its argument is a continuation (as opposed to an ordinary procedure)
   *    help                    tries to find a help string associated with its argument
   *    trace and untrace       add or subtract functions from the trace list; (trace abs). 
   *    stacktrace              show a stack trace, the stack at the point of an error: (stacktrace *error-info*),
   *                               or the stack at a break point: (stacktrace break-continuation)
   *
   *    encapsulator           a data "continuation" -- save the current environment for later restoration.
   *       open-encapsulator        this returns an encapsulation that when called as a thunk restores the current environment
   *       close-encapsulator       this closes (retires, puts an end to) an encapsulation
   *       encapsulator-bindings    these are the currently saved bindings awaiting restoration
   *       encapsulator?            #t if its argument is an encapsulator
   * 
   */
  */

define-expansion
s7test
NaN and inf
keyword funcs
gensym

-->

