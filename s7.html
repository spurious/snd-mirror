<html>
<!-- documentation for s7 -->

<head>
<title>s7</title>
<style type="text/css">
<!-- 
	EM.red {color:red; font-style:normal}
        EM.error {color:chocolate; font-style:normal}
        EM.typing {color:maroon; font-style: normal}
        EM.listener {color:darkblue; font-style: normal}
	EM.emdef {font-weight: bold; font-style: normal}
	H1 {text-align: center}
	UL {list-style-type: none}

	A {text-decoration:none}
	A:hover {text-decoration:underline}
	A.quiet {color:black; text-decoration:none}
	A.quiet:hover {text-decoration:underline}
	A.def {font-weight: bold; font-style: normal; text-decoration:none; text-color:black}
-->

</style>
</head>
<body bgcolor=white>

<br>

<table border=0 bordercolor="lightgreen" width=100% cellpadding=2 cellspacing=0><tr><td bgcolor="lightgreen">
<A NAME="s7doc"></a>
<table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>s7</h2></td></tr></table>
</td></tr></table>

<p>s7 is a Scheme implementation, compatible with r5rs, and intended as an extension language
for other applications, primarily Snd and Common Music.  It exists as just two files, s7.c and
s7.h, that want only to disappear into someone else's source tree.  There are no libraries,
no run-time init files, and no configuration scripts.
It can be built as a stand-alone
interpreter, if you insist (see below).  s7test.scm is a regression test for s7.
If you're running s7 in a context
that has getenv, file-exists?, and system (Snd for example), you can use s7-slib-init.scm
to gain easy access to slib.
</p>
<p>
s7 is the default extension language of Snd and sndlib (http://ccrma.stanford.edu/software/snd/),
and Rick Taube's Common Music (commonmusic at sourceforge).  There are X, Motif, Gtk, and openGL bindings
in libxm (in the Snd tarball, or at ftp://ccrma-ftp.stanford.edu/pub/Lisp/libxm.tar.gz).
</p>

<p>s7 has full continuations, dynamic-wind, sort!, 
error handling, ratios and complex numbers,
defmacro and define-macro, keywords, hash-tables, block comments,
threads, multiprecision arithmetic for all numeric types,
generalized set!, format, define*, and a host of other
extensions of r5rs.  It does not have syntax-rules or any of
its friends, and it does not think there is any such thing
as an "inexact integer" (what were those guys smoking?).
</p>

<p>This file assumes you know about Scheme and all its problems,
and want a quick tour of where s7 is different:
</p>
<br>

<dl>
<dt><em class=emdef>call-with-exit and continuation?</em></dt>
<dd><p>call-with-exit is a continuation without the ability to return (an escape or goto).
Use call-with-current-continuation or call/cc for a full continuation.
</p>
<pre>
(define (find-first-even-number arg)
  (<em class=red>call-with-exit</em>
   (lambda (return)
     (for-each
      (lambda (a)
	(if (even? a)
	    (return a)))
      arg))))

(find-first-even-number (list 1 3 9 13 8 2 4)) -&gt; 8
</pre>
<p>continuation? returns #t if its argument is a continuation,
as opposed to a normal procedure.
</p>
</dd>
<br>


<dt><em class=emdef>multiprecision arithmetic</em></dt>
<dd><p>All numeric types (integers, ratios, reals, complex numbers) are supported.
The basic integer and real
types are defined in s7.h, defaulting to long long int and double.  
pi is predefined, as are
most-positive-fixnum and most-negative-fixnum.
s7 can be built with multiprecision support 
for all types,  using the gmp, mpfr, and mpc libraries (set WITH_GMP to 1 in s7.c).  
If multiprecision arithmetic is
enabled, the following functions are included: bignum, bignum?, and bignum-precision.
bignum-precision, which defaults to 128, sets the number of bits each float takes.
pi automatically reflects the current bignum-precision:
</p>
<pre>
&gt; pi
3.141592653589793238462643383279502884195E0

&gt; (bignum-precision)
128

&gt; (set! (bignum-precision) 256)
256

&gt; pi
3.141592653589793238462643383279502884197169399375105820974944592307816406286198E0
</pre>
<p>
bignum? returns #t if its argument is a big number of some type.  To create a big number,
either include enough digits to overflow the default types, or use the bignum function.
Its argument is a string representing the desired number:
</p>
<pre>
&gt; (bignum "123456789123456789")
123456789123456789

&gt; (bignum "1.123123123123123123123123123")
1.12312312312312312312312312300000000009E0
</pre>
</dd>
<br>

<dt><em class=emdef>math functions</em></dt>
<dd><p>
s7 includes:
</p>
<ul>
<li>sinh, cosh, tanh, asinh, acosh, atanh
<li>logior, logxor, logand, lognot, ash, integer-length
<li>random
</ul>
<p>
The random function can take any numeric argument, including 0 (don't get me started...).
The following constants are predefined: pi, most-positive-fixnum, most-negative-fixnum.
Other math-related differences between s7 and r5rs:
</p>
<ul>
<li>exact means integer or ratio, inexact means not exact.
<li>rational? is a synonym for exact?.
<li>floor, ceiling, truncate, and round return (exact) integer results.
<li>"#" does not stand for an unknown digit.
<li>the "@" complex number notation is not supported.
<li>"+i" is not considered a number; include the real part.
<li>modulo, remainder, and quotient take integer, ratio, or real arguments.
<li>lcm and gcd can take integer or ratio arguments.
<li>log takes an optional 2nd arg (the base).
<li>'.' and an exponent can occur in a number in any base.
<li>NaN and inf handling is left up to the underlying C or C++.
</ul>
<pre>
&gt; (exact? 1.0)
#f

&gt; (floor 1.4)
1

&gt; (rational? 1.5)
#f

&gt; (modulo 1.4 1.0)
0.4

&gt; (lcm 3/4 1/6)
3/2

&gt; (log 8 2)
3

&gt; (number->string 0.5 2)
"0.1"

&gt; (string->number "0.1" 2)
0.5
</pre>
</dd>
<br>

<dt><em class=emdef>defmacro, define-macro, macroexpand, and gensym</em></dt>
<dd><p>These are the standard macro definers.  </p>
<pre>
(define-macro (add-1 arg) `(+ 1 ,arg))
(defmacro add-1 (arg) `(+ 1 ,arg))
</pre>
<p>macroexpand can help debug a macro:
</p>
<pre>
&gt; (define-macro (add-1 arg) `(+ 1 ,arg))
add-1
&gt; (macroexpand (add-1 32))
(+ 1 32)
</pre>
<p>gensym returns a symbol that is guaranteed to be currently unused.  It takes an optional string argument
giving the new symbol name's prefix.
</p>
<pre>
(defmacro pop! (sym)
  (let ((v (<em class=red>gensym</em>)))
    `(let ((,v (car ,sym)))
       (set! ,sym (cdr ,sym))
       ,v)))
</pre>
</dd>
<br>


<dt><em class=emdef>define* and lambda*</em></dt>
<dd><p>These are extensions of define and lambda that make it easier to
to deal with optional, keyword, and rest arguments.  
The syntax is very simple: every argument to define* has a default value
and is automatically available as a keyword argument.  The default value
is either #f (if unspecified), or given in a list whose first member is
the argument name.
The last argument
can be preceded by :rest or a dot to indicate that all other trailing arguments
should be packaged as a list under that argument's name.  You can use
:optional and :key, but they are ignored.  
</p>
<pre>
(<em class=red>define*</em> (hi a (b 32) (c "hi")) (list a b c))
</pre>
<p>Here the argument "a" defaults to #f, "b" to 32, etc.
When the function is called, 
the argument names are bound to their default values, then the function's
current argument list is scanned.  Any name that occurs as a keyword (":a")
sets that argument's new value.  Otherwise, as values occur, they
are plugged into the actual argument list based on their position.
This is called an optional-key list in CLM.  So, taking the function
above as an example:
</p>
<pre>
(hi 1) -&gt; '(1 32 "hi")
(hi :b 2 :a 3) -&gt; '(3 2 "hi")
(hi 3 2 1) -&gt; '(3 2 1)
</pre>
</dd>
<br>

<dt><em class=emdef>define-constant and constant?</em></dt>
<dd><p>define-constant defines a constant and constant? returns #t if its argument
is a constant.  A constant in s7 is really constant: it can't be set or rebound.
</p>
<pre>
&gt; (define-constant var 32)
var

&gt; (set! var 1)
;set!: can't alter immutable object: var

&gt; (let ((var 1)) var)
;can't bind or set an immutable object: var, line 1
</pre>
<p>This has the possibly surprising side effect that previous uses of the constant name
become constants:
</p>
<pre>
 (define (func a) (let ((cvar (+ a 1))) cvar))
 (define-constant cvar 23)
 (func 1)
 ;can't bind or set an immutable object: cvar
</pre>
<p>So, obviously, choose unique names for your constants, or don't use define-constant.
</p>
</dd>
<br>

<dt><em class=emdef>make-procedure-with-setter</em></dt>
<dd><p>A procedure-with-setter consists of two functions, the "getter" and the "setter".
The getter is called when the object is encountered as a function, and the setter when
it is set:
</p>
<pre>
(define x 32)
(define xx (make-procedure-with-setter (lambda () x) (lambda (val) (set! x val) x)))
(xx) -&gt; 32
(set! (xx) 1)
(xx) -&gt; 1
</pre>
</dd>
<br>

<dt><em class=emdef>applicable objects and generalized set!</em></dt>
<dd><p>Lists, strings, vectors, hash-tables, and any cooperating C-defined objects
are both applicable and settable.  I think the syntax is pretty:
</p>
<pre>
(let ((lst (list 1 2 3)))
  (set! (lst 1) 32)
  (list (lst 0) (lst 1)))
-&gt; '(1 32)

(let ((hash (make-hash-table)))
  (set! (hash 'hi) 32)
  (hash 'hi))
-&gt; 32
</pre>
<p>You can use list-ref and friends, of course, but just try to read any serious vector arithmetic code
when it is buried in vector-refs and vector-set!s! 
</p>
</dd>
<br>

<dt><em class=emdef>block comments in #| ... |# and #! ... !#</em></dt>
<dd>
<p>Multi-line comments can be enclosed in either #| and |#, or #! and !# (the latter
is for compatibility with Guile).
</p>
</dd>
<br>

<dt><em class=emdef>hash tables </em></dt>
<dd>
<ul>
<li>make-hash-table
<li>hash-table-ref
<li>hash-table-set!
<li>hash-table?
<li>hash-table-size
</ul>
<p>The hash key can be a symbol, string, integer, or (problematically of course) a real.
</p>
</dd>
<br>

<dt><em class=emdef>threads</em></dt>
<dd><p>If s7 is built with HAVE_PTHREADS set, you get multithreading functions.
</p>
<ul>
<li>(make-thread thunk)
<li>(join-thread thread)
<li>(thread? obj)
<li>(make-lock)
<li>(grab-lock lock)
<li>(release-lock lock)
<li>(lock? obj)
<li>(make-thread-variable)
<li>(thread-variable? obj)
</ul>
<p>
Threads in s7 share the heap and symbol table, but have their own local environment, stack,
and evaluator locals.  I use the term "lock" in place of "mutex", and "thread-variable"
in place of "pthread_key".  The thread-variable is applicable and settable, so instead
of pthread_getspecific, simply call it: (var).
</p>
</dd>
<br>

<dt><em class=emdef>format and object-&gt;string</em></dt>
<dd><p>s7's built-in format function is very close to that in srfi-48.</p>
<pre>
(format #f "~A ~D ~F" 'hi 123 3.14)
-&gt; "hi 123 3.140000"
</pre>
<p>object-&gt;string returns the string representation of its argument, like format with ~S:
</p>
<pre>
&gt; (object-&gt;string "hiho")
"\"hiho\""

&gt; (format #f "~S" "hiho")
"\"hiho\""
</pre>
</dd>
<br>

<dt><em class=emdef>FFI</em></dt>
<dd><p>s7 exists only to serve as an extension of some other application, so in a sense
it is just a foreign function interface.  See s7.h for the API and many examples.
Here is a bare REPL:
</p>
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include "s7.h"

static s7_pointer our_exit(s7_scheme *sc, s7_pointer args) {exit(1);}

int main(int argc, char **argv)
{
  s7_scheme *s7;
  char buffer[512];
  char response[1024];
  s7 = <em class=red>s7_init</em>();                     /* initialize the interpreter */
  <em class=red>s7_define_function</em>(s7, "exit", our_exit, 0, 0, false, "(exit) exits the program");
  while (1)                           /* fire up a REPL */
    {
      fprintf(stdout, "\n&gt; ");        /* prompt for input */
      fgets(buffer, 512, stdin);
      if ((buffer[0] != '\n') || 
	  (strlen(buffer) &gt; 1))
	{                            
	  sprintf(response, "(write %s)", buffer);
	  <em class=red>s7_eval_c_string</em>(s7, response); /* evaluate input and write the result */
	}
    }
}
</pre>
</dd>
<br>

<dt><em class=emdef>error handling via error and catch</em></dt>
<dd><p>s7's error handling mimics that of (pre-r6rs) Guile.  An error is signalled
via the error function, and can be trapped and dealt with via catch.
</p>
<pre>
(<em class=red>catch</em> 'wrong-number-of-args
  (lambda ()     ; code protected by the catch
    (abs 1 2))
  (lambda args   ; the error handler
    (apply format (append (list #t) (cadr args)))))

-&gt; "abs: too many arguments: (1 2)"
</pre>
<p>
catch has 3 arguments: a tag indicating what error to catch (#t = anything),
the code (a thunk) that the catch is protecting, and the function to call
if a matching error occurs during the evaluation of the thunk.  The error handler
takes a rest argument which will hold whatever the error function chooses to pass it.
The error function itself takes at least 2 arguments, the error type (a symbol),
and the error message.  There may also be other arguments describing the error.
The default action (in the absence of any catch) is to treat the message as
a format control string, apply format to it and the other arguments, and
send that info to the current-error-port.
</p>
<p>When an error is encountered, the variable *error-info* (a vector) contains
additional info about that error:
</p>
<ul>
<li>0: the error type or tag (e.g. 'division-by-zero)
<li>1: the message or information passed by the error function
<li>2: if not #f, the code that s7 thinks triggered the error
<li>3: if not #f, the line number of that code
<li>4: if not #f, the file name of that code
<li>5: the environment at the point of the error
<li>6...: stack environment pointers (giving enough info to reconstruct the current call stack), ending in #f
</ul>
<p>To find a variable's value at the point of the error:
</p>
<pre>
(symbol-&gt;value var (vector-ref *error-info* 5))
</pre>
<p>To print the stack at the point of the error:
</p>
<pre>
(stacktrace *error-info*)
</pre>

<p>The variable *error-hook* provides a way to specialize error reporting.
It is a function of 2 arguments, the values passed by the error function
(the error type and whatever other info accompanies it).
</p>
<pre>
(set! *error-hook* (lambda (tag args) (apply format (cons #t args))))
</pre>
<p>See also stacktrace and trace below.  There is a break macro defined in Snd (see snd-xen.c)
which allows you to stop at some point, then evaluate arbitrary expressions in that context.
</p>
</dd>
<br>

<dt><em class=emdef>IO functions</em></dt>
<dd>
<p>Besides files, ports can also represent strings and functions.  The string port functions
are:
</p>
<ul>
<li>with-output-to-string
<li>with-input-from-string
<li>call-with-output-string
<li>call-with-input-string,
<li>open-output-string
<li>open-input-string
<li>get-output-string
</ul>
<pre>
(let ((result #f) 
      (p (<em class=red>open-output-string</em>)))
  (format p "this ~A ~C test ~D" "is" #\a 3)
  (set! result (<em class=red>get-output-string</em> p))
  (close-output-port p)
  result)
-&gt; "this is a test 3"
</pre>
<p>Other functions:</p>
<ul>
<li>read-byte and write-byte (binary IO)
<li>read-line (line-at-a-time reads)
</ul>
<p>The variable *vector-print-length* sets
the upper limit on how many vector elements are printed by object-&gt;string and format.
</p>
<p>When running s7 behind a GUI, you often want input to come from and output to go to
arbitrary widgets. The "function ports" provide a way to redirect IO.  See s7.h
for an example.
</p>
</dd>
<br>

<dt><em class=emdef>Generic functions</em></dt>
<dd><p>length, copy, and fill! are generic functions in the sense that their argument can be
a list, string, vector, hash-table, or C-defined object.  Since vectors and lists are set-applicable, 
and length is generic, we can write a generic FFT that accepts both types or any other object that follows this syntax:
</p>
<pre>
        (define* (cfft! data n (dir 1)) ; (complex data)
          (if (not n) (set! n (<em class=red>length</em> data)))
          (do ((i 0 (+ i 1))
               (j 0))
              ((= i n))
            (if (&gt; j i)
        	(let ((temp (data j)))
        	  (set! (data j) (data i))
        	  (set! (data i) temp)))
            (let ((m (/ n 2)))
              (do () 
        	  ((or (&lt; m 2) (&lt; j m)))
        	(set! j (- j m))
        	(set! m (/ m 2)))
              (set! j (+ j m))))
          (let ((ipow (floor (log n 2)))
        	(prev 1))
            (do ((lg 0 (+ lg 1))
        	 (mmax 2 (* mmax 2))
        	 (pow (/ n 2) (/ pow 2))
        	 (theta (make-rectangular 0.0 (* pi dir)) (* theta 0.5)))
        	((= lg ipow))
              (let ((wpc (exp theta))
        	    (wc 1.0))
        	(do ((ii 0 (+ ii 1)))
        	    ((= ii prev))
        	  (do ((jj 0 (+ jj 1))
        	       (i ii (+ i mmax))
        	       (j (+ ii prev) (+ j mmax)))
        	      ((&gt;= jj pow))
        	    (let ((tc (* wc (data j))))
        	      (set! (data j) (- (data i) tc))
        	      (set! (data i) (+ (data i) tc))))
        	  (set! wc (* wc wpc)))
        	(set! prev mmax))))
          data)
        
        &gt; (cfft! (list 0.0 1+i 0.0 0.0))
        (1+1i -1+1i -1-1i 1-1i)
        &gt; (cfft! (vector 0.0 1+i 0.0 0.0))
        #(1+1i -1+1i -1-1i 1-1i)
</pre>
</dd>
<br>

<dt><em class=emdef>multidimensional vectors</em></dt>
<dd><p>
If s7 is built with WITH_MULTIDIMENSIONAL_VECTORS (the default), it supports 
vectors with any number of dimensions.  It is here, in particular, that the generalized
set! stuff shines.  make-vector's 2nd argument can be a list of dimensions, rather than
an integer (the one dimensional case):
</p>
<pre>
(make-vector (list 2 3 4))
(make-vector '(2 3) 1.0)
(vector-dimensions (make-vector (list 2 3 4))) -&gt; (2 3 4)
</pre>
<p>The second example includes the optional default vector element.  Once defined,
(vect i j k) or (to be very verbose, (vector-ref vect i j k)) returns the given
element, and (set! (vect i j k) m), (or verbose and unreadable, (vector-set! vect i j k m))
sets that element.  vector-dimensions returns a list of the dimensions of a vector.
</p>
</dd>
<br>

<dt><em class=emdef>*load-path* and *load-hook*</em></dt>
<dd><p>*load-path* is a list of directories to search when loading a file.
*load-hook* is a function called just before a file is loaded.  Its argument is the filename.
While loading, port-filename and port-line-number (of the current-input-port) can tell you
where you are in the file.
</p>
<pre>
(set! *load-hook* (lambda (name) (format #t "loading ~S...~%" name)))
</pre>
</dd>
<br>

<dt><em class=emdef>gc</em></dt>
<dd><p>The gc function either calls the GC (if passed no arguments), or turns the GC either on: (gc #t)
or off: (gc #f).
</p>
</dd>
<br>

<dt><em class=emdef>*features*, provide, and provided?</em></dt>
<dd><p>As in Common Lisp, *features* is a list describing what is currently loaded into s7.  You can
check it with the provided? function, or add something to it with provide.  In my version of Snd,
at startup *features* is:
</p>
<pre>
&gt; *features*
(snd10 snd snd-s7 snd-motif gsl alsa xm snd-ladspa run clm4 clm sndlib gmp multidimensional-vectors s7)

&gt; (provided? 'gmp)
#t
</pre>
</dd>
<br>

<dt><em class=emdef>procedure info</em></dt>
<dd><p>procedure-source, procedure-arity, procedure-documentation, and help provide a look into a
scheme function.
procedure-documentation returns the documentation string associated with a procedure (the initial string in the
function's body). procedure-arity returns a list describing the argument list of a function: '(required-args optional-args rest-arg).
procedure-source returns the source (as a list) of a procedure.
</p>
<pre>
&gt; (define* (add-2 a (b 32)) "add-2 adds its 2 args" (+ a b))
add-2

&gt; (procedure-documentation add-2)
"add-2 adds its 2 args"

&gt; (procedure-arity add-2)
(0 2 #f)

&gt; (procedure-source add-2)
(lambda* (a (b 32)) "add-2 adds its 2 args" (+ a b))
</pre>
</dd>
<br>


<dt><em class=emdef>symbol table info</em></dt>
<dd><p>(symbol-table) returns the symbol table, a vector of lists of symbols.
(symbol-&gt;value sym :optional env) returns the binding of 'sym'
in the given environment which defaults to the current environment.
(defined? obj :optional env) returns #t if 'obj' has a binding (a value) in the environment 'env'.
If profiling is enabled (set WITH_PROFILING in s7.c), (symbol-calls sym) returns
the number of times that symbol's binding has been applied.
Here we scan the symbol table for any function that doesn't have documentation:
</p>
<pre>
       (let ((st (<em class=red>symbol-table</em>)))
         (do ((i 0 (+ i 1))) 
             ((= i (vector-length st)))
           (let ((lst (vector-ref st i)))
             (for-each 
               (lambda (sym)
       	         (if (<em class=red>defined?</em> sym)
	             (let ((val (<em class=red>symbol-&gt;value</em> sym)))
	               (if (and (procedure? val)
			        (string=? "" (procedure-documentation val)))
		           (format #t "~A " sym)))))
               lst))))
</pre>
</dd>
<br>

<dt><em class=emdef>environments</em></dt>
<dd><p>environments are "first class objects" in s7.  An environment is
a list of alists ending with a hash-table (the global environment).
(current-environment :optional thread)
returns the current environment (symbol bindings).  (global-environment)
returns the top-level environment.
Here is an example of "apropos" that accesses both environments:
</p>
<pre>
        (define (apropos name)
          ;; (apropos "name") prints out a list of all symbols whose name includes "name" as a substring

          (define (substring? subs s) ; from Larceny
            (let* ((start 0)
	           (ls (string-length s))
	           (lu (string-length subs))
	           (limit (- ls lu)))
              (let loop ((i start))
	        (cond ((&gt; i limit) #f)
	              ((do ((j i (+ j 1))
	        	    (k 0 (+ k 1)))
	        	   ((or (= k lu)
	        		(not (char=? (string-ref subs k) (string-ref s j))))
	        	    (= k lu))) i)
	              (else (loop (+ i 1)))))))

          (define (apropos-1 alist)
            (for-each
             (lambda (binding)
               (if (substring? name (symbol-&gt;string (car binding)))
	           (format (current-output-port) "~A: ~A~%" 
	        	   (car binding) 
	        	   (if (procedure? (cdr binding))
	        	       (procedure-documentation (cdr binding))
	        	       (cdr binding)))))
             alist))

          (for-each
           (lambda (frame)
             (if (vector? frame) ; the global environment
	         (let ((len (vector-length frame)))
	           (do ((i 0 (+ i 1)))
	               ((= i len))
	             (apropos-1 (vector-ref frame i))))
	         (apropos-1 frame)))
           (<em class=red>current-environment</em>)))
</pre>
<p>
You can change the current environment by hand:
</p>
<pre>
      (define (push-environment e binding)
        (if (vector? (car e))
            (begin
              (set-cdr! e (list (car e)))
              (set-car! e (list binding)))
            (set-car! e (cons binding (car e)))))
   
      (define (pop-environment e)
        (if (not (vector? (car e)))
            (begin
              (set-car! e (cadr e))
              (set-cdr! e (cddr e)))))
   
      (define-macro (define! e var val) ; define var=val in env e
        `(push-environment ,e (cons ',var ,val)))

      (define (make-environment . initial-bindings)
         (cons initial-bindings (global-environment)))

     (let ((x 3)) 
       (define! (current-environment) hi 21)
       (+ x hi))
     -&gt; 24

     (let ((x 32)) 
       (eval `(+ x y) (make-environment '(x . 2) '(y . 4))))
     -&gt; 6
</pre>
<p>(with-environment env . body) evaluates its body in the environment env.
</p>
</dd>
<br>

<dt><em class=emdef>trace and untrace</em></dt>
<dd><p>These functions provide tracing:
</p>
<pre>
    (define (hiho arg) 
      (if (&gt; arg 0) 
          (+ 1 (hiho (- arg 1))) 
          0))

    (trace hiho)

    (hiho 3)

    [hiho 3]
     [hiho 2]
      [hiho 1]
       [hiho 0]
        0
       1
      2
     3
</pre>
<p>trace adds a function to the list of functions being traced, and untrace removes it.
</p>
</dd>
<br>

<dt><em class=emdef>stacktrace and stack</em></dt>
<dd><p>stacktrace prints the stack contents.  Its optional argument
can be *error-info* to show the stack at the point of the last error,
a thread object to show that thread's stack, or a continuation to
show the continuation stack.  Similarly, the stack function returns
the stack top (an integer) and the stack itself (a vector).  
Each stack frame has 4 entries, the function, the current environment, the function arguments, and an op code used
internally by the evaluator. 
</p>
</dd>
<br>

<dt><em class=emdef>quit</em></dt>
<dd><p>quit exits s7.</p>
<br>

<dt><em class=emdef>make-promise</em></dt>
<dd><p>This is named "delay" in most Schemes, but that name belongs to CLM.
</p>
</dd>
<br>


<dt><em class=emdef>encapsulation</em></dt>
<dd><p>encapsulation saves and restores environments.</p>
<ul>
<li>open-encapsulator
<li>close-encapsulator
<li>encapsulator-bindings
<li>encapsulator?
<li>encapsulate
</ul>
<p>An encapsulator is 
a sort of data-side continuation.  open-encapsulator
remembers the overall environment at the point it is called, returning an encapuslator
object.  Whenever we want to return to that data state, we call that object as a thunk.
encapsulator-bindings returns the alist of variables awaiting restoration.  When the encapsulator is called (restoring those bindings),
the list is cleared, and the encapsulator starts saving values again (so repeated calls
keep returning you to that data state).  close-encapsulator turns that encapsulator off.
In a REPL, for example, you could save the initial state, then return to it at any time,
without restarting the interpreter.  fluid-let is not what we want here because it has
a body, and requires that you list in advance what variables you want to protect (and
besides, it's not really a let (it uses "set!") and I can't see anything fluid about it).
encapsulate is a macro that evaluates its body, then returns any variables global to that code to their prior value.
</p>
<pre>
&gt; (define global-x 32)
global-x

&gt; (encapsulate 
    (set! global-x 123) 
    (format #f "x: ~A" global-x))
  "x: 123"

&gt; global-x
32
</pre>
</dd>
<br>

<dt><em class=emdef>eval and eval-string</em></dt>
<dd><p>
eval evaluates its argument (a list representing a piece of code).  It takes an optional
second argument, the environment in which the evaluation should take place.  eval-string
is similar, but its argument is a string.
</p>
<pre>
&gt; (eval `(+ 1 2))
3

&gt; (eval-string "(+ 1 2)")
3
</pre>
</dd>
<br>

<dt><em class=emdef>reverse!, list-set!, sort!</em></dt>
<dd><p>reverse! is an in-place version of the built-in function reverse.  That is, 
it modifies the list passed to it in the process of reversing its contents.
list-set! sets a member of a list.  sort! sorts a list or a vector using the
function passed as its second argument to choose the new ordering.
</p>
<pre>
&gt; (sort! (list 3 4 8 2 0 1 5 9 7 6) &lt;)
(0 1 2 3 4 5 6 7 8 9)

&gt; (sort! (list (list 'u 1) (list 'i 0) (list 'a 2))
     (lambda (a b) (&lt; (cadr a) (cadr b))))
((i 0) (u 1) (a 2))
</pre>
<p>Despite the "!" in its name, sort! actually copies any list argument passed to it,
but vectors are sorted in place.
</p>
</dd>
<br>

<dt><em class=emdef>keywords</em></dt>
<dd><p>
Keywords exist mainly for define*'s benefit.  The keyword functions are:
keyword?, make-keyword, symbol-&gt;keyword, and keyword-&gt;symbol.
</p>
</dd>
<br>

<dt><em class=emdef>help</em></dt>
<dd><p>
(help obj) tries to find information about obj.  
</p>
</dd>
<br>

<dt><em class=emdef>define-expansion</em></dt>
<dd><p>
This defines read-time macros, which are just dangerous enough that
I probably shouldn't document them.  It has the same syntax as
define-macro, and the same result except that the macro is
dealt with at read time!  (This means it does not respect attempts to
bind it to something else, which is asking for confusion).
</p>
</dd>
<br>

<dt><em class=emdef>other differences from r5rs</em></dt>
<dd>
<ul>
<li>do sets its step variables, rather than rebinding them.
<li>no syntax-rules or any of its friends.
<li>s7-version returns the current s7 version.
<li>no scheme-report-environment, null-environment, or interaction-environment (= current-environment?).
<li>no transcript-on or transcript-off.
</ul>
</dd>
<br>

</dl>

</body>
</html>
