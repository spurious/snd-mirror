<html>
<head>
<title>An Introduction to FM</title>
</head>
<body bgcolor=white>


<center><h1>An Introduction To FM</h1></center>

<center>Bill Schottstaedt</center>

<br><br>


<!-- the latex stuff is always embedded in:

\documentclass{amsart}
\begin{document}
\thispagestyle{empty}
\Large
...
\end{document}

-->


<!-- INDEX fmintro:Frequency Modulation -->
<A NAME="fmintro"></A>

<p>In frequency modulation we modulate the frequency -- "modulation" here is just a latinate word for 
"change".  Vibrato and glissando are frequency modulation.  John Chowning tells me that he 
stumbled on FM when he sped up vibrato to the point that it was creating audible sidebands 
(perceived as a timbral change) rather than faster warbling (perceived as a frequency change).  We 
can express this (the vibrato, not the neat story) as:
</p>

<!-- LATEX \[\cos \, (\omega_{c}t+f(t))\] -->

<img src="fmeq1.png" alt="cos(wt + f)" hspace=20>

<!-- HTML
<pre>
  cos(w<sub>c</sub>t + f(t))
</pre>
-->

<table align=right border=1 width=200 vspace=10 hspace=20><tr><td bgcolor="#eefdee"><h5><center>FM and phase modulation</center></h5></td></tr></table>

<p>where the c subscript stands for "carrier" and f(t) means "some arbitrary function added to the 
carrier".  Since cos takes an angle as its argument, f(t) modulates (that is, changes) the angle 
passed to the cosine, hence the generic name "angle modulation".  We can add that change either to
the argument to cos
("phase modulation", <code>cos(angle + change)</code>), or add it to the current phase, then take cos of that 
("frequency modulation", <code>cos(angle += change)</code>), so
our fomula can viewed either way.  Since the angle is being incremented by the carrier frequency in
either case, the difference is between:
</p>
<pre>
    PM: cos((angle += incr) + change)
    FM: cos(angle += (incr + change))
</pre>
<p>
Textbooks usually mutter "strictly speaking 
we can only take the cosine of an angle", and they put an explicit integral in when they mean 
frequency modulation:
</p>


<!-- LATEX
fmeq3:
\cos \, (\omega_{c}t + \!\int_{0}^{t}\! f(t) \, \mathrm{d} t)
-->

<img src="fmeq3.png" alt="cos + integral" hspace=20>

<!-- HTML
<pre>
  cos(w<sub>c</sub>t + B<img alt="Integral" align=middle src="integ.png"><sub>0</sub><sup>t</sup> f(t) dt)
</pre>
-->

<p>
Radio engineers distinguish between PM and FM as follows: if 
f(t) is directly proportional to the modulating signal then it's PM; if f(t) is directly proportional 
to the derivative of the modulating signal, then it's FM.  Of course, you can't tell which is in use 
from the output waveform; you have to know 
what the modulating signal is.  All this verbiage is a roundabout way of saying that in computer music 
applications, where we can do what we want with the modulating signal,
there is no essential difference between frequency and phase modulation. 
</p>

<table border=1 hspace=50 cellpadding=14><tr><td>

<p>I would call this issue a dead horse, but it is still causing confusion, even 40 years
down the road. So,
here are two CLM instruments, one performing 
phase modulation, the other performing frequency modulation.  I have tried to make the innards 
explicit at each step, and match the indices so that the instruments produce the same results given 
the same parameters.  Also, to lay a different controversy to rest, it should be obvious from these two 
functions that there is no difference in run-time computational expense or accuracy between PM and FM.
</p>

</td></tr><tr><td bgcolor="#f6f8ff">

<!-- CLM CASE
<pre>
(definstrument pm (beg end freq amp mc-ratio index)
  (let ((carrier-phase 0.0) ; set to pi/2 if someone tells you PM can't generate energy at DC
        (carrier-phase-incr (hz-&gt;radians freq))
        (modulator-phase 0.0)
        (modulator-phase-incr (hz-&gt;radians (* freq mc-ratio)))
        (modulation 0.0)
        (val 0.0))
   (run
     (loop for i from beg to end do
       (setf modulation (* index (sin modulator-phase)))
       (setf val (* amp (sin (+ carrier-phase modulation)))) 
       ;; no integration in phase modulation
       (incf carrier-phase carrier-phase-incr)
       (incf modulator-phase modulator-phase-incr)
       (outa i val)))))

(definstrument fm (beg end freq amp mc-ratio index)
  (let* ((carrier-phase 0.0)
         (carrier-phase-incr (hz-&gt;radians freq))
         (modulator-phase-incr (hz-&gt;radians (* freq mc-ratio)))
         (modulator-phase (* 0.5 (+ pi modulator-phase-incr)))
	 ;; (pi+incr)/2 to get (centered) sin after integration, to match pm case above
         (fm-index (hz-&gt;radians (* freq mc-ratio index)))  
	 ;; fix up fm index (it's a frequency change)
         (val 0.0)
         (modulation 0.0))
   (run
     (loop for i from beg to end do
       (setf modulation (* fm-index (sin modulator-phase)))
       (incf carrier-phase modulation)      
       ;; here is the fm integration
       (setf val (* amp (sin carrier-phase)))
       (incf carrier-phase carrier-phase-incr)
       (incf modulator-phase modulator-phase-incr)
       (outa i val)))))

(with-sound () (pm 0 10000 1000 .5 0.25 4))
(with-sound () (fm 0 10000 1000 .5 0.25 4))
</pre>
-->

<!-- SND CASE -->
<pre>
(define (pm beg end freq amp mc-ratio index)
  (let ((carrier-phase 0.0) ; set to pi/2 if someone tells you PM can't produce energy at 0Hz
        (carrier-phase-incr (hz-&gt;radians freq))
        (modulator-phase 0.0)
        (modulator-phase-incr (hz-&gt;radians (* mc-ratio freq))))
    (do ((i beg (1+ i)))
	((= i end))
      (let* ((modulation (* index (sin modulator-phase)))
	     (pm-val (* amp (sin (+ carrier-phase modulation))))) 
	     ;; no integration in phase modulation
	(set! carrier-phase (+ carrier-phase carrier-phase-incr))
	(set! modulator-phase (+ modulator-phase modulator-phase-incr))
	(outa i pm-val *output*)))))

(define (fm beg end freq amp mc-ratio index)
  (let* ((carrier-phase 0.0)
	 (carrier-phase-incr (hz-&gt;radians freq))
	 (modulator-phase-incr (hz-&gt;radians (* mc-ratio freq)))
	 (modulator-phase (* 0.5 (+ pi modulator-phase-incr)))
	 ;; (pi+incr)/2 to get (centered) sin after integration, to match pm case above
	 (fm-index (hz-&gt;radians (* mc-ratio freq index))))
	;; fix up fm index (it's a frequency change)
    (do ((i beg (1+ i)))
	((= i end))
      (let ((modulation (* fm-index (sin modulator-phase)))
	    (fm-val (* amp (sin carrier-phase))))
	(set! carrier-phase (+ carrier-phase modulation carrier-phase-incr))
	(set! modulator-phase (+ modulator-phase modulator-phase-incr))
	(outb i fm-val *output*)))))

(with-sound (:channels 2) 
  (pm 0 10000 1000 .5 0.25 4)
  (fm 0 10000 1000 .5 0.25 4))

(with-sound (:channels 2) 
  (pm 0 10000 1000 .5 0.5 10)
  (fm 0 10000 1000 .5 0.5 10))
</pre>
<!-- -->

</td></tr></table>


<!-- a check of these instruments:

(define (channel-distance-max s1 c1 s2 c2)
  (let* ((r1 (make-sample-reader 0 s1 c1))
	 (r2 (make-sample-reader 0 s2 c2))
	 (sum 0.0)
	 (mx 0.0)
	 (mxloc 0)
	 (N (min (frames s1 c1) (frames s2 c2))))
    (do ((i 0 (1+ i)))
	((= i N))
      (let ((diff (- (r1) (r2))))
	(if (> (abs diff) mx)
	    (begin
	      (set! mx (abs diff))
	      (set! mxloc i)))
	(set! sum (+ sum (* diff diff)))))
    (list (sqrt sum) mx mxloc)))


(with-sound (:channels 2 :srate 44100)
	    (pm 0 100000 1000 .25 0.5 4)
	    (fm 0 100000 1000 .25 0.5 4))

(channel-distance-max 0 0 0 1)
(0.0295699815499316 2.01372429728508e-4 54261)


(with-sound (:channels 2 :srate 44100)
	    (pm 0 100000 1000 .25 0.5 10)
	    (fm 0 100000 1000 .25 0.5 10))

(channel-distance-max 0 0 0 1)
(0.0930102199004151 5.19216060638428e-4 97657)


(with-sound (:channels 2 :srate 44100)
	    (pm 0 100000 4000 .5 .25 10)
	    (fm 0 100000 4000 .5 .25 10))

(channel-distance-max 0 0 0 1)
(0.619834957208772 0.00419910810887814 99588)


(with-sound (:channels 2 :srate 441000)
	    (pm 0 100000 4000 .5 .25 10)
	    (fm 0 100000 4000 .5 .25 10))

(channel-distance-max 0 0 0 1)
(0.00620158844593978 4.19728457927704e-5 339)


(with-sound (:channels 2 :srate 22050)
	    (fmdoc-pm 0 100000 4000 .5 .25 10)
	    (fmdoc-fm 0 100000 4000 .5 .25 10))

(channel-distance-max 0 0 0 1)
(2.47456807755109 0.0168174412101507 99627)

;;; the difference is proportional to the inverse square of the sampling rate,
;;;   which I interpret as caused by the "centering" -- it is hard to say what
;;;   the "true" or effective FM modulator initial-phase is, so a naive comparison
;;;   with the bessel functions makes FM look "inaccurate".  We can turn the
;;;   tables by using cos, and a PM modulator initial phase of
;;;       (+ pi (* 0.5 (+ pi (hz->radians mfreq))))
;;;   (to match outputs), then complain that PM is inaccurate. Just to add to 
;;;   the confusion, in the latter case, the difference seems to be directly 
;;;   proportional to srate(?) -- enough...

-->


<table align=right border=1 width=200 vspace=10 hspace=20><tr><td bgcolor="#eefdee"><h5><center>simple FM: sin(sin)</center></h5></td></tr></table>

<p>Given our formula for FM, let's assume, for starters, that f(t) is a sinusoid:
</p>

<!-- LATEX \[  \cos \, (\omega_{c}t+B\sin \omega_{m}t)  \] -->

<img src="fmeq4.png" alt="cos(sin)" hspace=20>

<!-- HTML
<pre>
  cos(w<sub>c</sub>t + B sin w<sub>m</sub>t)
</pre>
-->

<p>where the "m" stands for "modulator" and the "B" factor is usually called the modulation index.
The corresponding CLM code is:
</p>

<pre>
  (oscil carrier (* B (oscil modulator)))
</pre>

<p>where oscil is (essentially):
</p>

<!-- CLM CASE 
<pre>
    (defun oscil (oscillator &amp;optional (fm-input 0.0) (pm-input 0.0))
      (prog1 
        (sin (+ (mus-phase oscillator) pm-input))
        (incf (mus-phase oscillator) (+ (mus-frequency oscillator) fm-input))))
</pre>
-->

<!-- SND CASE -->
<pre>
    (define* (oscil oscillator :optional (fm-input 0.0) (pm-input 0.0))
      (let ((result (sin (+ oscillator-phase pm-input))))
        (set! oscillator-phase (+ oscillator-phase (+ oscillator-phase-increment fm-input)))
        result))
</pre>
<!-- -->

<p>Since it is generally believed that the ear performs some sort of projection of the time domain 
waveform into the frequency domain (a Fourier Transform), and that timbre is at least partly a matter 
of the mix of frequencies present (the spectrum), our main interest in the FM formula is in the 
spectrum it produces.  To determine that spectrum, we have to endure some tedious mathematics.  
By the trigonometric identity:
</p>

<!-- LATEX \[  \cos (a+b)=\cos a\cos b - \sin a \sin b  \] -->

<img src="fmeq5.png" alt="cos a+b" hspace=20>

<!-- HTML
<pre>
  cos(a + b) = cos a cos b - sin a sin b
</pre>
-->


<!-- LATEX \[B\sin \omega_{m}t  \] -->

<p>we can substitute <img src="fmeq23.png" alt="wct" align=absmiddle> for "a" and
<img src="fmeq9.png" alt="bsin" align=absmiddle>
for "b" and get:
</p>


<!-- LATEX \[  \cos (\omega_{c}t+B\sin \omega_{m}t)=\cos \omega_{c}t \, \cos (B \sin \omega_{m}t) - \sin \omega_{c}t \, \sin (B\sin \omega_{m}t)  \] -->

<img src="fmeq6.png" alt="cos (sin) expanded" hspace=20>

<!-- HTML
<pre>
  cos(w<sub>c</sub>t + B sin w<sub>m</sub>t) = cos w<sub>c</sub>t cos(B sin w<sub>m</sub>t) - sin w<sub>c</sub>t sin(B sin w<sub>m</sub>t)
</pre>
-->

<p>If we can get a Fourier transform of the two inner portions: 
<img src="fmeq41.png" alt="cos sin" align=absmiddle> and
<img src="fmeq40.png" alt="sin sin" align=absmiddle>, we can use:
</p>

<!-- LATEX \[  \cos (B \sin \omega_{m}t) \textrm{ and } \sin (B\sin \omega_{m}t)  \]: fmeq7 -->
<!-- LATEX \sin (B\sin \omega_{m}t): fmeq40 -->
<!-- LATEX \cos (B \sin \omega_{m}t): fmeq41 -->

<!-- <img src="fmeq7.png" alt="cos and sin" hspace=20> -->


<!-- LATEX 
\Large
\begin{eqnarray*}
\cos a \, \cos b = \frac{1}{2}(\cos (a-b) + \cos(a+b)) \\
\sin a \, \sin b = \frac{1}{2}(\cos (a-b) - \cos(a+b)) \\
\end{eqnarray*}
-->

<img src="fmeq8.png" alt="coscos and sinsin" hspace=20>

<!-- HTML
<pre>
  cos A cos B = 1/2 (cos (A - B) + cos (A + B))
  sin A sin B = 1/2 (cos (A - B) - cos (A + B))
</pre>
-->


<!-- LATEX \omega_{c}t -->
<p>to get the final results.  "A" here is
<img src="fmeq23.png" alt="wct" align=absmiddle>
in the earlier formulas,  and "B" is either
<img src="fmeq41.png" alt="cos sin" align=absmiddle> or
<img src="fmeq40.png" alt="sin sin" align=absmiddle>.
You can slog through the Fourier series expansion by hand, or look it up in Abramowitz and Stegun, 
"Handbook of Mathematical Functions" (formulas 9.1.42 and 9.1.43), or take my word for it that:
</p>


<!-- LATEX \cos(B\sin\omega_{m}t)=J_{0}(B)+2J_{2}(B)\cos 2\omega_{m}t + \,\cdots\, + 2J_{2n}(B)\cos 2n\omega_{m}t + \,\cdots -->

<img src="fmeq10.png" alt="cos B sin t" hspace=20 vspace=3>

<!-- LATEX \sin(B\sin\omega_{m}t)=2J_{1}(B)\sin\omega_{m}t+2J_{3}(B)\sin 3\omega_{m}t + \,\cdots\, + 2J_{2n-1}(B)\sin (2n-1)\omega_{m}t + \,\cdots -->
<img src="fmeq11.png" alt="sin B sin t" hspace=20 vspace=6>

<!-- HTML
<pre>
  cos(B sin w<sub>m</sub>t) = 
      J<sub>0</sub>(B) + 2J<sub>2</sub>(B)cos 2w<sub>m</sub>t + ... 
       + 2J<sub>2n</sub>(B)cos 2nw<sub>m</sub>t + ...

  sin(B sin w<sub>m</sub>t) = 
       2J<sub>1</sub>(B)sin w<sub>m</sub>t + 2J<sub>3</sub>(B)sin 3w<sub>m</sub>t + ... 
        + 2J<sub>2n-1</sub>(B)sin(2n-1)w<sub>m</sub>t ...
</pre>
-->


<p>Here the J's refer to the Bessel functions which we will return to later. First, let's finish this 
expansion; we take these two sums and 
<img src="fmeq23.png" alt="wct" salign=absmiddle>
and plug them into our first expansion of the FM 
formula, and out pops:
</p>


<!-- LATEX
\Large
\begin{eqnarray*}
\lefteqn{ \cos(\omega_{c}t + B\sin\omega_{m}t) } \\
&& {} =J_{0}(B)\cos \omega_{c}t \\
&& {} -J_{1}(B)(\cos(\omega_{c} - \omega_{m})t - \cos(\omega_{c} + \omega_{m})t) \\
&& {} +J_{2}(B)(\cos(\omega_{c} - 2\omega_{m})t + \cos(\omega_{c} + 2\omega_{m})t) \\
&& {} -J_{3}(B)(\cos(\omega_{c} - 3\omega_{m})t - \cos(\omega_{c} + 3\omega_{m})t) + \cdots
\end{eqnarray*}
-->

<img src="fmeq12.png" alt="cos w+sin" hspace=20>

<!-- HTML
<pre>
  cos(w<sub>c</sub>t + B sin w<sub>m</sub>t) =
     J<sub>0</sub>(B) cos w<sub>c</sub>t  
        - J<sub>1</sub>(B)[cos(w<sub>c</sub> - w<sub>m</sub>)t - cos(w<sub>c</sub> + w<sub>m</sub>)t]
        + J<sub>2</sub>(B)[cos(w<sub>c</sub> - 2w<sub>m</sub>)t + cos(w<sub>c</sub> + 2w<sub>m</sub>)t]
        - J<sub>3</sub>(B)[cos(w<sub>c</sub> - 3w<sub>m</sub>)t - cos(w<sub>c</sub> + 3w<sub>m</sub>)t] + ...
</pre>
-->


<p>or in a slightly more compact form:
</p>

<!-- LATEX \sum_{n=-\infty}^{\infty} \! \! J_{n}(B)\cos(\omega_{c} + n\omega_{m})t -->

<img src="fmeq13.png" alt="sum J cos" hspace=20>

<!-- HTML
<pre>
    <img alt="inf" src="inf.png">
   <img alt="Sum" align=middle src="sum.png"> [J<sub>n</sub>(B)cos(w<sub>c</sub> + nw<sub>m</sub>)t]
  n=-<img alt="inf" src="inf.png">	
</pre>
-->

<!-- LATEX J_{-n}(x) = (-1)^{n}J_{n}(x) -->

<p>Here we are using the fact that
<img src="fmeq14.png" alt="J - J" align=absmiddle>.
We can change our point of view on the first part of the expansion given above, and ask for the 
amplitude of a given sideband:
</p>

<!-- LATEX J_{n}(B) = \frac{2}{\pi} \int_{0}^{\frac{\pi}{2}} \sin(B\sin\omega) \sin n\omega \: \mathrm{d}\omega \qquad \textrm{(n odd)} -->

<img src="fmeq15.png" alt="J sin int" hspace=20><br>

<!-- LATEX J_{n}(B) = \frac{2}{\pi} \int_{0}^{\frac{\pi}{2}} \cos(B\sin\omega) \cos n\omega \: \mathrm{d}\omega \qquad \textrm{(n even)} -->

<img src="fmeq16.png" alt="J cos int" hspace=20 vspace=6>

<!-- HTML
<pre>
  J<sub>n</sub>(B) = 2/pi<img alt="Integral" align=middle src="integ.png"><sub>0</sub><sup>pi/2</sup> sin(B sin w)sin nw dw   (n odd)
  J<sub>n</sub>(B) = 2/pi<img alt="Integral" align=middle src="integ.png"><sub>0</sub><sup>pi/2</sup> cos(B sin w)cos nw dw   (n even)
</pre>
-->

<!-- LATEX \omega_{m} : fmeq42 -->
<!-- LATEX \omega_{c} : fmeq43 -->

<p>So we end up with a spectrum made up of a "carrier" at 
<img src="fmeq43.png" alt="wc" align=absmiddle>
and symmetrically placed sidebands 
separated by
<img src="fmeq42.png" alt="wm" align=absmiddle>.  
The amplitudes  follow the Bessel functions.  I put carrier in quotes because in 
computer music we listen to the result of the modulation (this was Chowning's idea -- see "The 
Synthesis of Complex Audio Spectra by Means of Frequency Modulation").  The Bessel functions 
are nearly 0 until the index (B) equals the order (n).  Thereupon they have a bump and then tail off as
a sort of damped sinusoid:
</p>

<img src="bessel.png" alt="bessel functions" hspace=20>

<p>
So as the index sweeps 
upward, energy is swept gradually outward into higher order side bands; this is the originally 
exciting, now extremely annoying "FM sweep".
The important thing to get from these Bessel functions is that the higher the index, the 
more dispersed the spectral energy -- normally a brighter sound.
</p>

<table border=1 cellpadding=3><tr>
<td><img src="fm10.png" alt="fm 1.0"></td>
<td><img src="fm20.png" alt="fm 2.0"></td>
<td><img src="fm30.png" alt="fm 3.0"></td>
</tr>
<tr><td>
<center>carrier=1000, mod=100, index=1.0</center>
<pre>
  J0(1.0) = 0.765 -&gt; 1.0 (*)
  J1(1.0) = 0.440 -&gt; 0.575
  J2(1.0) = 0.115 -&gt; 0.150 
  J3(1.0) = 0.019 -&gt; 0.025 
  J4(1.0) = 0.002 -&gt; 0.003

(* Jn values normalized to match 
the fft peak values given above)
</pre>
</td>
<td>
<center>carrier=1000, mod=100, index=2.0</center>
<pre>
  J0(2.0) = 0.224 -&gt; 0.388 (*)
  J1(2.0) = 0.577 -&gt; 1.0
  J2(2.0) = 0.353 -&gt; 0.611
  J3(2.0) = 0.129 -&gt; 0.223
  J4(2.0) = 0.034 -&gt; 0.058
  J5(2.0) = 0.007 -&gt; 0.012
  J6(2.0) = 0.001 -&gt; 0.002
</pre>
<small>(A larger FFT reduces the mismatch)</small>
</td>
<td>
<center>carrier=1000, mod=100, index=3.0</center>
<pre>
  J0(3.0) = -0.260 -&gt; -0.534 (*)
  J1(3.0) = 0.339 -&gt;  0.697
  J2(3.0) = 0.486 -&gt;  1.0
  J3(3.0) = 0.309 -&gt;  0.635
  J4(3.0) = 0.132 -&gt;  0.271
  J5(3.0) = 0.043 -&gt;  0.088
  J6(3.0) = 0.011 -&gt;  0.023
</pre>
</td>
</tr>
</table>


<p>There is a rule of thumb, Mr Carson's rule, about the overall bandwidth of the resultant spectrum (it 
follows from our description of the Bessel functions): Roughly speaking, there are fm-index+1 
significant sidebands on each side of the carrier, so our total bandwidth is on the order of
</p>

<pre>
   2 * modulator-frequency * (fm-index + 1)
</pre>

<p>This is a good approximation -- 99% of the signal power is within its limits.
</p>

<table border=1 hspace=50 cellpadding=10><tr><td>
<small> 
<p>Then there's the perennial question "why Bessel functions?".  Consider our earlier
expansion of cos(sin) in terms of sinusoids as a sort of Fourier transform of
the simple FM equation. Looking at cos(sin) as the real part of
e<sup>(iB sin w<sub>m</sub>t)</sup>, our expansion is evaluating

<!-- LATEX 
fmeq17:
\int_{-\pi}^{\pi}e^{i(B\sin \omega_{m}t - n\omega_{m}t)} \, \mathrm{d}t
-->

<img src="fmeq17.png" alt="e to j sin" align=absmiddle>

<!-- HTML
<pre>
    c<sub>n</sub> = 1/w<sub>m</sub><img alt="Integral" align=middle src="integ.png"><sub>-pi</sub><sup>pi</sup> e<sup>j(B sin w<sub>m</sub>t - nw<sub>m</sub>t)</sup> dt
</pre>
-->

which is one way of defining the Bessel functions (see also the earlier formulas for Jn(B)).
These functions had
been studied by Daniel Bernoulli (the vibrations of a heavy chain, 1738), 
Euler (the vibrations of a membrane, 1764), Lagrange (planetary motion, 1770),
and Fourier (the motion of heat in a cylinder, 1822); Bessel studied them in the context of Kepler's equation, and wrote a monograph
about them in 1824.
There are brief historical snippits at 
<a href="http://www.aam314.vzz.net/EB/Bessel.html">Encyclopedia Britannica</a> and <a href="http://www-groups.dcs.st-and.ac.uk/~history/Biographies/Bessel.html">Bios</a>.
For an explanation of the connection between planetary motion and FM, see Benson, "Music: A Mathematical Offering".
</p></small>
</td></tr></table>

<table align=right border=1 width=200 vspace=10 hspace=20><tr><td bgcolor="#eefdee"><h5><center>simple FM examples</center></h5></td></tr></table>

<p>Here's a simple FM instrument:
</p>

<table border=0 bgcolor="#f6f8ff" hspace=20><tr><td>
<!-- CLM CASE 
<pre>
(definstrument fm (beg dur freq amp mc-ratio index &amp;optional (index-env '(0 1 100 1)))
  (let* ((start (seconds-&gt;samples beg))
         (end (+ start (seconds-&gt;samples dur)))
         (cr (make-oscil freq))
         (md (make-oscil (* freq mc-ratio)))
         (fm-index (hz-&gt;radians (* index mc-ratio freq)))
         (ampf (make-env index-env :scaler amp :duration dur)) 
         (indf (make-env index-env :scaler fm-index :duration dur))) 
    (run
      (loop for i from start to end do
        (outa i (* (env ampf) 
                   (oscil cr (* (env indf) 
                                (oscil md)))))))))
</pre>
-->

<!-- SND CASE -->
<pre>
(define* (fm beg dur freq amp mc-ratio index :optional (index-env '(0 1 100 1)))
  (let* ((start (seconds-&gt;samples beg))
         (end (+ start (seconds-&gt;samples dur)))
         (cr (make-oscil freq))
         (md (make-oscil (* freq mc-ratio)))
         (fm-index (hz-&gt;radians (* index mc-ratio freq)))
         (ampf (make-env index-env :scaler amp :duration dur)) 
         (indf (make-env index-env :scaler fm-index :duration dur)))
    (run
     (lambda ()
       (do ((i start (1+ i)))
	   ((= i end))
	 (outa i (* (env ampf)                  ; amplitude env
                    (oscil cr (* (env indf)     ; carrier + modulation env
                                 (oscil md))))  ; modulation
               *output*))))))
</pre>
<!-- -->
</td></tr></table>

<p>I put an envelope on the fm-index ("indf" above) so that we can try out dynamic spectra ("dynamic" means 
"changing" here).  For now, don't worry too much about the actual side band amplitudes.  They
will not always match Chowning's description, but we'll get around to an explanation eventually.
</p>

<pre>
    (with-sound () (fm 0 1.0 100 .5 1.0 4.0))
</pre>

<p>is Chowning's first example.  Sure enough, it's a complex spectrum (that is, it has lots of 
components; try an index of 0 to hear a sine wave, if you're suspicious).  Since our modulating 
frequency to carrier frequency ratio (mc-ratio above) is 1.0, we get sidebands at harmonics of the 
carrier. If we use an mc-ratio of .25 and a carrier of 400:
</p>

<pre>
    (with-sound () (fm 0 1.0 400 .5 0.25 4.0))
</pre>

<p>we end up with the same perceived pitch because the sidebands are still at multiples of 100 Hz.
</p>

<pre>
    (with-sound () (fm 0 1.0 400 .5 1.1414 4.0))
</pre>

<p>has inharmonic sidebands.  Most real sounds seem to change over the course of a note, and it was at one time thought that most 
of this change was spectral.  To get a changing spectrum, we need only put an envelope on the fm-index:
</p>

<pre>
    (with-sound () (fm 0 0.5 400 .5 1.0 5.0 '(0 0 20 1 40 .6 90 .5 100 0)))
</pre>

<p>making a brass-like sound.  Similarly, Chowning suggests that
</p>

<pre>
    (with-sound () (fm 0 1.0 900 .5 1/3 2.0 '(0 0 6 .5 10 1 90 1 100 0)))
</pre>

<p>is a woodwind-like tone,
</p>

<pre>
    (with-sound () (fm 0 1.0 500 .5 .2 1.5 '(0 0 6 .5 10 1 90 1 100 0)))
</pre>

<p>is bassoon-like, and finally
</p>

<pre>
    (with-sound () (fm 0 1.0 900 .5 2/3 2 '(0 0 25 1 75 1 100 0)))
</pre>

<p>is clarinet-like.  Now start at 2000 Hz, set the mc-ratio to .1, and
sweep the FM index from 0 to 10, and the spectrogram looks like this:
</p>

<img src="fmsweep.png" alt="sweep index" hspace=40>

<table align=right border=1 width=200 vspace=10 hspace=20><tr><td bgcolor="#eefdee"><h5><center>phase quibbles: cos(sin)</center></h5></td></tr></table>
<p>
There is a lot of music in simple FM.
But, to clear up one source of confusion, if you 
looked at the spectrum of our first example, and compared it to the spectrum Chowning works out, 
you may wonder what's gone awry.  We have to return to our initial set of formulas.  If we consider 
that:
</p>

<!-- LATEX \sin(a+b)=\sin a \cos b + \cos a \sin b -->

<img src="fmeq18.png" alt="sin split" hspace=20><br>

<!-- LATEX \sin(\omega_{c}t+B\sin \omega_{m}t) = \sin \omega_{c}t \cos(B \sin \omega_{m}t) + \cos \omega_{c}t \sin(B \sin \omega_{m}t) -->

<img src="fmeq19.png" alt="sin split" hspace=20 vspace=8>

<!-- HTML
<pre>
  sin(a + b) = sin a cos b + cos a sin b

  sin(w<sub>c</sub>t + B sin w<sub>m</sub>t) = sin w<sub>c</sub>t cos(B sin w<sub>m</sub>t) + cos w<sub>c</sub>t sin(B sin w<sub>m</sub>t)
</pre>
-->


<p>and using our previous formulas for the expansion of the cos(sin) and sin(sin) terms, with the 
identity:
</p>

<!-- LATEX \sin a \cos b = \frac{1}{2} (\sin (a-b) + \sin (a+b)) -->

<img src="fmeq20.png" alt="sin cos again" hspace=20 vspace=8>

<!-- HTML
<pre>
  sin a cos b = 1/2 (sin(a - b) + sin(a + b))
</pre>
-->

<p>we see that we still have a spectrum symmetric around the carrier, and the amplitude and frequencies 
are just as they were before, but the initial phases of the side bands have changed. Our result is now 
</p>

<!-- LATEX
\begin{eqnarray*}
\lefteqn{ \sin(\omega_{c}t + B\sin\omega_{m}t) } \\
&& {} =J_{0}(B)\sin \omega_{c}t \\
&& {} +J_{1}(B)(\sin(\omega_{c} + \omega_{m})t - \sin(\omega_{c} - \omega_{m})t) \\
&& {} +J_{2}(B)(\sin(\omega_{c} + 2\omega_{m})t + \sin(\omega_{c} - 2\omega_{m})t) \\
&& {} +J_{3}(B)(\sin(\omega_{c} + 3\omega_{m})t - \sin(\omega_{c} - 3\omega_{m})t) + \cdots
\end{eqnarray*}
-->

<img src="fmeq21.png" alt="sin sin case" hspace=20>

<!-- HTML
<pre>
  sin(w<sub>c</sub>t + B sin w<sub>m</sub>t) =
     J<sub>0</sub>(B)sin w<sub>c</sub>t
        + J<sub>1</sub>(B)[sin(w<sub>c</sub> + w<sub>m</sub>)t - sin(w<sub>c</sub> - w<sub>m</sub>)t]
        + J<sub>2</sub>(B)[sin(w<sub>c</sub> + 2w<sub>m</sub>)t + sin(w<sub>c</sub> - 2w<sub>m</sub>)t]
        + J<sub>3</sub>(B)[sin(w<sub>c</sub> + 3w<sub>m</sub>)t - sin(w<sub>c</sub> - 3w<sub>m</sub>)t]
        + ...
</pre>
-->

<!-- LATEX \sin(-x)=-\sin(x)\textrm{, that is }\sin(\omega_{c}t - \omega_{m}t) = -\sin(\omega_{m}t - \omega_{c}t) -->

<p>This is Chowning's version of the expansion.  Here we are also using
<img src="fmeq44.png" alt="sin-sin" align=absmiddle>.  In general:
</p>

<!-- LATEX \cos(\omega_{c}t+B\sin(\omega_{m}t + \theta_{m}) + \phi) = \sum_{k=-\infty}^{\infty}J_{k}(B)\cos((\omega_{c}+k\omega_{m})t + k\theta_{m} + \phi) -->

<img src="fmeq22.png" alt="big formula" hspace=20>

<!-- HTML
<pre>
  cos(w<sub>c</sub>t + B sin(w<sub>m</sub>t + <img alt="theta" src="theta.png"><sub>m</sub>) + <img alt="phi" src="phi.png">) =
     <img alt="inf" src="inf.png">
     <img alt="Sum" align=middle src="sum.png"> J<sub>k</sub>(B)cos((w<sub>c</sub> + kw<sub>m</sub>)t + k <img alt="theta" src="theta.png"><sub>m</sub> + <img alt="phi" src="phi.png">)
    k=-<img alt="inf" src="inf.png">	
</pre>
-->


<!-- LATEX:
\small
\begin{align*}
& \cos(B \sin x) = J_{0}(B) + 2 \sum_{k=1}^{\infty} J_{2k}(B) \cos 2kx \\
& \cos(B \cos x) = J_{0}(B) + 2 \sum_{k=1}^{\infty} (-1)^{k} J_{2k}(B) \cos 2kx \\
& \sin(B \sin x) = 2 \sum_{k=0}^{\infty} J_{2k+1}(B) \sin (2k+1)x \\
& \sin(B \cos x) = 2 \sum_{k=0}^{\infty} (-1)^{k} J_{2k+1}(B) \cos (2k+1)x \\
\end{align*}
-->

<!--
<table border=1 hspace=40 vspace=20><tr><td>
<table border=0 hspace=20>
<tr><td colspan=3>
Or perhaps more readable:
</td></tr>
<td>
<img src="fmeq49.png" alt="cos cos cases">
</td><td width=20></td>
<td>
<img src="fmeq50.png" alt="cos cos cases">
</td>
</tr></table>
</td></tr></table>
-->

<p>Our first reaction is, "so what if one's a sine and another's a cosine, or whatever -- they'll sound the 
same", but we are being hasty.  What if (for example), the modulator has the same frequency as the 
carrier, and its index (B) is high enough that some significant energy appears at
</p>

<!-- LATEX \omega_{c}-2\omega_{m} = -\omega_{c} \textrm{?} -->

<img src="fmeq24.png" alt="w-m=-w" hspace=20>

<!-- HTML
<pre>
    w<sub>c</sub> - 2w<sub>m</sub> = - w<sub>c</sub>?
</pre>
-->

<!-- LATEX \sin(-x)=-\sin(x)\textrm{, but }\cos(-x)=cos(x) -->

<p>Where does energy at a negative frequency go?  We once again fall back on elementary 
trigonometry: 
<img src="fmeq45.png" alt="sin-sin and cos" align=absmiddle>,
so the negative frequency component adds to the positive frequency component if it's a cosine, but 
subtracts if it's a sine.  The upshot of all this is that the results will be different.  We get a different 
pattern of cancellations depending on the initial phases of the carrier and modulator.  Take the CLM
instrument:
</p>

<table border=0 bgcolor="#f6f8ff" hspace=20><tr><td>
<!-- CLM CASE
<pre>
(definstrument fm (beg end freq amp mc-ratio index carrier-phase mod-phase)
  (let ((cr (make-oscil :frequency freq :initial-phase carrier-phase))
        (md (make-oscil :frequency (* freq mc-ratio) :initial-phase mod-phase))
        (fm-index (hz-&gt;radians (* index mc-ratio freq))))
    (run
      (loop for i from beg to end do
        (outa i (* amp (oscil cr (* fm-index (oscil md)))))))))

(with-sound () (fm 0 10000 100 .25 1.0 4 0 (* .5 pi)))
(with-sound () (fm 0 10000 100 .25 1.0 4.0 (* .5 pi) (* .5 pi)))
</pre>
-->

<!-- SND CASE -->
<pre>
(define (fm beg dur freq amp mc-ratio index carrier-phase mod-phase)
  (let* ((start (seconds-&gt;samples beg))
	 (end (+ start (seconds-&gt;samples dur)))
	 (cr (make-oscil freq carrier-phase))
	 (md (make-oscil (* freq mc-ratio) mod-phase))
	 (fm-index (hz-&gt;radians (* index mc-ratio freq))))
    (run
     (lambda ()
       (do ((i start (1+ i)))
	   ((= i end))
	 (outa i (* amp (oscil cr (* fm-index (oscil md)))) *output*))))))

(with-sound () (fm 0 1.0 100 .25 1.0 4 0 (* .5 pi)))
(with-sound () (fm 0 1.0 100 .25 1.0 4.0 (* .5 pi) (* .5 pi)))
</pre>
<!-- -->
</td></tr></table>

<p>There is a slight difference!  The first case is that given by Chowning in his fig 1.4a, the second 
is Bate's fig 3 ("The Effects of Modulator Phase on Timbres in FM Synthesis").  (At least I think it 
is -- Bate says he is changing the modulator's initial phase, but I can't reproduce his graph unless I 
change the carrier initial phase -- the important point is that these phases matter).  Also, remember 
that we are thinking in terms of the pre-integration phase here (hence the (* .5 pi)):
</p>

<table border=0><tr><td>
<!-- LATEX \sin(x+\frac{\pi}{2}) = cos x -->
<img src="fmeq25.png" alt="sin=cos" hspace=20>
</td><td>
and
</td><td>
<!-- LATEX \int \! \cos x \: \mathrm{d}x = \sin x -->
<img src="fmeq26.png" alt="cos int sin" hspace=20>
</td></tr></table>

<p>so by starting with a cosine in the modulator, after the integration in oscil (and ignoring the constant 
for the moment) we have
</p>

<!-- LATEX \sin(\omega_{c}t+B\sin \omega_{m}t) -->

<img src="fmeq27.png" alt="sin B sin again" hspace=20>

<!-- HTML
<pre>
    sin(w<sub>c</sub>t + B sin w<sub>m</sub>t)
</pre>
-->

<p>By varying the relative phases, we can get a changing spectrum from these cancellations.  Here is a 
CLM instrument that shows this (subtle) effect:
</p>

<table border=0 bgcolor="#f6f8ff" hspace=20><tr><td>
<!-- CLM CASE 
<pre>
(definstrument fm (beg end freq amp mc-ratio index car-phase mod-phase skew-func skew)
  (let ((cr (make-oscil freq car-phase))
        (md (make-oscil (* freq mc-ratio) mod-phase))
        (skewf (make-env skew-func :scaler (hz-&gt;radians (* skew mc-ratio freq)) :end end))
        (fm-index (hz-&gt;radians (* index mc-ratio freq))))
    (run
      (loop for i from beg to end do
        (outa i (* amp (oscil cr (* fm-index (oscil md (env skewf))))))))))

(with-sound () (fm 0 40000 100 .25 1.0 4.0 0 0 '(0 0 50 1 100 0) .02))
</pre>
-->

<!-- SND CASE -->
<pre>
(define (fm beg dur freq amp mc-ratio index)
  (let* ((start (seconds-&gt;samples beg))
	 (end (+ start (seconds-&gt;samples dur)))
	 (cr (make-oscil freq))
	 (md (make-oscil (* freq mc-ratio)))
	 (skewf (make-env (list 0.0 0.0 1.0 pi) :duration dur)))
    (run
     (lambda ()
       (do ((i start (1+ i)))
	   ((= i end))
        (outa i (* amp (oscil cr 0.0 (* index (oscil md 0.0 (env skewf))))) *output*))))))

(with-sound () (fm 0 2 100 0.5 1.0 30.0))
</pre>
<!-- -->
</td></tr></table>

<table align=right border=1 width=200 vspace=10 hspace=20><tr><td bgcolor="#eefdee"><h5><center>asymmetric spectra</center></h5></td></tr></table>

<p>The next question is "if we can get cancellations, can we fiddle with the phases and get 
asymmetric FM spectra?".  There are several approaches; an obvious one uses the
fact that:
</p>


<!-- LATEX see above -->

<img src="fmeq8.png" alt="coscos and sinsin" hspace=20>

<!-- HTML
<pre>
    cos A cos B = 1/2 (cos(A - B) + cos(A + B))
    sin A sin B = 1/2 (cos(A - B) - cos(A + B))
</pre>
-->

<p>If we have a spectrum B made up entirely of sines (or entirely cosines), we can then multiply it by 
sin A (or cos A) then add the two resulting spectra, and the (A + B) parts cancel.  Here's an 
example:
</p>

<table border=0 bgcolor="#f6f8ff" hspace=20><tr><td>
<!-- CLM CASE
<pre>
(definstrument fm (beg end freq amp mc-ratio index cr0p cr1p md0p md1p)
  (let ((cr0 (make-oscil 0 cr0p))
        (cr1 (make-oscil 0 cr1p))
        (md0 (make-oscil (* freq mc-ratio) md0p))
        (md1 (make-oscil (* freq mc-ratio) md1p))
        (am0 (make-oscil freq 0))
        (am1 (make-oscil freq (* .5 pi)))
        (fm-index (hz-&gt;radians (* index mc-ratio freq))))
    (run
      (loop for i from beg to end do
        (outa i (* amp (+ (* (oscil am0) (oscil cr0 (* fm-index (oscil md0))))
                          (* (oscil am1) (oscil cr1 (* fm-index (oscil md1)))))))))))

(with-sound () (fm 0 10000 1000 .25 .1 1.0 0 (* .5 pi) (* .5 pi) 0))
</pre>
-->

<!-- SND CASE -->
<pre>
(define (fm beg dur freq amp mc-ratio index cr0p cr1p md0p md1p)
  (let* ((start (seconds-&gt;samples beg))
	 (end (+ start (seconds-&gt;samples dur)))
	 (cr0 (make-oscil 0 cr0p))
	 (cr1 (make-oscil 0 cr1p))
	 (md0 (make-oscil (* freq mc-ratio) md0p))
	 (md1 (make-oscil (* freq mc-ratio) md1p))
	 (am0 (make-oscil freq 0))
	 (am1 (make-oscil freq (* .5 pi)))
	 (fm-index (hz-&gt;radians (* index mc-ratio freq))))
    (run
     (lambda ()
       (do ((i start (1+ i)))
	   ((= i end))
	 (outa i (* amp (+ (* (oscil am0) (oscil cr0 (* fm-index (oscil md0))))
			   (* (oscil am1) (oscil cr1 (* fm-index (oscil md1))))))
	       *output*))))))

(with-sound () (fm 0 1.0 1000 .25 .1 1.0 0 (* .5 pi) (* .5 pi) 0))
</pre>
<!-- -->
</td></tr></table>

<p>Unfortunately, there are some pesky -1's floating around, so we get asymmetric or gapped spectra,
but not anything we'd claim was single side-band.
Palamin et al in "A Method of Generating and Controlling Musical Asymmetrical Spectra" started at 
the same point (the expansion of simple FM), added a factor r^n to each sideband, and then worked 
backwards to get:
</p>

<!-- LATEX e^{(\frac{B}{2}(r-\frac{1}{r})\cos \omega_{m}t)}\sin(\omega_{c}t+\frac{B}{2}(r+\frac{1}{r})\sin \omega_{m}t)=\sum r^{n}J_{n}(B)\sin(\omega_{c}t+n\omega_{m}t) -->

<img src="fmeq29.png" alt="e sin" hspace=20>

<!-- HTML
<pre>
    e<sup>(B/2(r-1/r)cos w<sub>m</sub>t)</sup> sin(w<sub>c</sub>t + B/2(r+1/r)sin w<sub>m</sub>t)
         = <img alt="Sum" align=middle src="sum.png"> r<sup>n</sup>J<sub>n</sub>(B)sin(w<sub>c</sub>t + nw<sub>m</sub>t)
</pre>
-->

<p>But the peak amplitude of this formula is hard to predict; we'd rather have a sum of cosines:
</p>

<!--LATEX: e^{(\frac{B}{2}(r-\frac{1}{r})\cos \omega_{m}t)}\cos(\omega_{c}t+\frac{B}{2}(r+\frac{1}{r})\sin \omega_{m}t)=\sum_{n=-\infty}^{\infty} r^{n}J_{n}(B)\cos(\omega_{c}t+n\omega_{m}t) -->

<img src="fmeq47.png" alt="better asy" hspace=20>

<!-- LATEX: e^{\frac{B}{2}\big(r-\frac{1}{r}\big)}=\sum_{n=-\infty}^{\infty} r^{n}J_{n}(B) -->

<p>so we can use</p>

<img src="fmeq48.png" "sum of Js" hspace=20>

<p>to normalize the output to -1.0 to 1.0.
The spectrum produced for a given "r" is mirrored by -1/r (remembering that 
<img src="fmeq14.png" alt="J - J" align=absmiddle>).  
</p>

<!-- LATEX:
\documentclass{amsart}
\begin{document}
\thispagestyle{empty}
\begin{align*}
& 0.5^{-5}J_{-5}(2.0) = -0.225 \Rightarrow -0.160 \quad \textrm{(normalized to match fft)} \\
& 0.5^{-4}J_{-4}(2.0) = 0.544 \Rightarrow 0.385 \\
& 0.5^{-3}J_{-3}(2.0) = -1.031 \Rightarrow -0.730 \\
& 0.5^{-2}J_{-4}(2.0) = 1.411 \Rightarrow 1.0 \\
& 0.5^{-1}J_{-4}(2.0) = -1.153 \Rightarrow -0.817 \\
& 0.5^{0}J_{0}(2.0) = 0.224 \Rightarrow 0.159 \\
& 0.5^{1}J_{1}(2.0) = 0.288 \Rightarrow 0.204 \\
& 0.5^{2}J_{2}(2.0) = 0.088 \Rightarrow 0.062 \\
\end{align*}
\end{document}
-->

<table border=1 hspace=20 cellpadding=3>
<tr><td bgcolor="#f6f8ff">
<pre>
Asymmetric FM with index=2.0, r=0.5:

(using the asymmetric-fm generator in CLM)


(with-sound ()
  (let ((gen (make-asymmetric-fm 2000.0 
                       :ratio .2 :r 0.5)))
    (run 
      (lambda ()
        (do ((i 0 (1+ i)))
	    ((= i 20000))
          (outa i (asymmetric-fm gen 2.0) 
                *output*))))))
</pre>
</td>

<td>
<table border=0>
<tr><td>
<img src="asyfm1.png" alt="asy fm">
</td></tr>
<tr>
<td>
<img src="asyfm2.png" alt="peaks" hspace=10 vspace=10>
</td></tr></table>
</td></tr></table>


<p>We can put an envelope on either the index or "r"; the index
affects how broad the spectrum is, and "r" affects its placement relative to the carrier (giving the effect of
a moving formant).  Here we sweep "r" from -1.0 to -20.0, with an index of 3, m/c ratio of .2, and carrier at 1000 Hz:
</p>

<img src="asyfm.png" alt="asy spectra">


<table align=right border=1 width=200 vspace=10 hspace=20><tr><td bgcolor="#eefdee"><h5><center>complex FM: sin(sin+sin)</center></h5></td></tr></table>

<p>
So far we have been using just a sinusoid for the modulator; what if we make it a more complicated 
signal?  Here again elementary trigonometry can be used to expand
</p>

<!-- LATEX \sin(\omega_{c}t + B_{1}\sin \omega_{m1}t + B_{2}\sin \omega_{m2}t) -->

<img src="fmeq30.png" alt="multiple sins" hspace=20>

<!-- HTML
<pre>
    sin(w<sub>c</sub>t + B<sub>1</sub>sin w<sub>m1</sub>t + B<sub>2</sub>sin w<sub>m2</sub>t)
</pre>
-->

<p>The modulating signal is now made up of two sinusoids (don't despair; this is a terminating 
sequence).  Since sine is not linear, this is not the same thing as
</p>

<!-- LATEX \sin(\omega_{c}t + B_{1}\sin \omega_{m1}t) + \sin(B_{2}\sin \omega_{m2}t) -->

<img src="fmeq31.png" alt="bad sins" hspace=20>

<!-- HTML
<pre>
    sin(w<sub>c</sub>t + B<sub>1</sub>sin w<sub>m1</sub>t) + sin B<sub>2</sub>sin w<sub>m2</sub>t
</pre>
-->

<p>In the second case we just get the superposition of the two simple FM spectra, but in the first case 
we get a more complex mixture involving all the sums and differences of the modulating frequencies.  If the indices 
are small (the B's are much less than 1), then there isn't much difference between the two versions.  
Once again, the expansion is tedious, but it really involves nothing more than putting the sum of the 
sines in place of the single sine in the previous case, then turning the algebraic crank.  See Le Brun 
"A Derivation of the Spectrum of FM with a Complex Modulating Wave".  The result can be 
expressed:
</p>

<!-- LATEX \sum_{i}\sum_{k}J_{i}(B_{1})J_{k}(B_{2})\sin(\omega_{c}t + i\omega_{m1}t + k\omega_{m2}t) -->

<img src="fmeq32.png" alt="2 sums" hspace=20>

<!-- HTML
<pre>
        <img alt="Sum" align=middle src="sum.png"> <img alt="Sum" align=middle src="sum.png">  J<sub>i</sub>(B<sub>1</sub>) J<sub>k</sub>(B<sub>2</sub>) sin(w<sub>c</sub>t + iw<sub>m1</sub>t + kw<sub>m2</sub>t)
          i   k
</pre>
-->

<p>You can chew up any amount of free time calculating the resulting side band amplitudes -- see 
Schottstaedt "The Simulation of Natural Instrument Tones Using Frequency Modulation with a 
Complex Modulating Wave".  These extra modulating components flatten and spread out the 
spectrum somewhat. In general:
</p>

<!-- LATEX \cos(\omega_{c}t+\Big(\sum_{i=1}^{k}B_{i}\sin(\omega_{i}t + \theta_{i})\Big) + \phi) = \sum_{k_{k}} \cdots \sum_{k_{1}}\Big(\prod_{i=1}^{k}J_{k_{i}}(B_{i})\Big)\cos(\omega_{c}t+\Big(\sum_{i=1}^{k}k_{i}(\omega_{i}t+\theta_{i})\Big)+\phi) -->

<img src="fmeq33.png" alt="silly formula" hspace=20>

<!-- HTML
<pre>
               k
    cos(w<sub>c</sub>t + <img alt="Sum" align=middle src="sum.png"> B<sub>i</sub>sin(w<sub>i</sub>t + <img alt="theta" src="theta.png"><sub>i</sub>) + <img alt="phi" src="phi.png">) =
              i=1
                       k                      k
         <img alt="Sum" align=middle src="sum.png">...<img alt="Sum" align=middle src="sum.png"> (<img alt="Product" align=middle src="prod.png"> J<sub>k<sub>i</sub></sub>(B<sub>i</sub>)) cos(w<sub>c</sub>t + <img alt="Sum" align=middle src="sum.png"> k<sub>i</sub>(w<sub>i</sub>t + <img alt="theta" src="theta.png"><sub>i</sub>) + <img alt="phi" src="phi.png">)
           k<sub>k</sub>    k<sub>1</sub>   i=1                    i=1
</pre>
-->

<p>A CLM instrument to produce something like this might be:
</p>

<table border=0 bgcolor="#f6f8ff" hspace=20><tr><td>
<!-- CLM CASE
<pre>
(definstrument fm (beg end freq amp mc-ratios indexes carrier-phase mod-phases)
  (let* ((cr (make-oscil freq carrier-phase))
         (n (length mc-ratios))
         (md-arr (make-array n :element-type 'osc))
         (fm-index-arr (make-array n :element-type 'short-float)))
    (loop for i from 0 below n do
      (setf (aref md-arr i)
        (make-oscil (* freq (aref mc-ratios i)) 
                    (aref mod-phases i)))
      (setf (aref fm-ind-arr i) (hz-&gt;radians (* (aref indexes i) (aref mc-ratios i) freq))))
    (run
      (loop for i from beg to end do
        (let ((sum 0.0))
          (dotimes (k n) 
            (incf sum (* (aref fm-ind-arr k) (oscil (aref md-arr k)))))
          (outa i (* amp (oscil cr sum))))))))
</pre>
-->

<!-- SND CASE -->
<pre>
(define (fm beg dur freq amp mc-ratios indexes carrier-phase mod-phases)
  (let* ((start (seconds-&gt;samples beg))
	 (end (+ start (seconds-&gt;samples dur)))
	 (cr (make-oscil freq carrier-phase))
         (n (length mc-ratios))
         (modulators (make-vector n))
         (fm-indices (make-vct n)))
    (do ((i 0 (1+ i)))
	((= i n))
      (vector-set! modulators i (make-oscil (* freq (list-ref mc-ratios i)) (list-ref mod-phases i)))
      (vct-set! fm-indices i (hz-&gt;radians (* freq (list-ref indexes i) (list-ref mc-ratios i)))))
    (run
     (lambda ()
       (do ((i start (1+ i)))
	   ((= i end))
	 (let ((sum 0.0))
	   (do ((k 0 (1+ k)))
	       ((= k n))
	     (set! sum (+ sum (* (vct-ref fm-indices k) (oscil (vector-ref modulators k))))))
	   (outa i (* amp (oscil cr sum)) *output*)))))))

(with-sound () (fm 0 2.0 440 .3 '(1 3 4) '(1.0 0.5 0.1) 0.0 '(0.0 0.0 0.0)))
</pre>
<!-- -->
</td></tr></table>

<table border=1 hspace=40 vspace=20 cellpadding=5>
<tr><td>
<img src="multifm.png" alt="multi fm picture">
</td>
<td>
<pre>
  200Hz is -0.106 (i = -1, k = -1)
           -0.106 (i = -1, k = 1) 
           -0.213 -> 0.306 normalized

  2000Hz:  -0.023 (i = -2, k = 0)
            0.718 (i = 0, k = 0)
            0.695 -> 1.0 normalized

  1800Hz:  -0.013 (i = -2, k = 1)
           -0.413 (i = 0, k = -1)
           -0.426 -> 0.614 normalized
</pre>
<small>(i is the 2000 Hz part, k the 200 Hz, and this is a really simple case!)</small>
</tr>
<tr><td colspan=2 bgcolor="#f6f8ff"><center>(with-sound () (fm 0 2.0 2000 .5 '(1 .1) '(0.5 1.0) 0.0 '(1.855 1.599)))</center></td></tr>
</table>

<!--
here's the code to get that info:

(with-sound () 
  (fm 0 2.0 2000 .5 '(1 .1) '(0.5 1.0) 0.0 (list (* 0.5 (+ pi (hz->radians 2000))) (* 0.5 (+ pi (hz->radians 200))))))

(define (calcit wc wm1 wm2 b1 b2)
  (let ((sums (make-vector 400 0.0))
	(freqs (make-vector 400 0.0))
	(curfreqs 0))
    (do ((i -10 (1+ i)))
	((= i 10))
      (do ((j -10 (1+ j)))
	  ((= j 10))
	(let* ((freq (+ wc (* i wm1) (* j wm2)))
	       (curfreq (abs freq))
	       (amount (* (bes-jn i b1) (bes-jn j b2))) ; can be negative
	       (curamount (if (< freq 0.0) (- amount) amount))
	       (happy #f))
	  (if (> (abs amount) 1.0e-6)
	      (begin
		(do ((k 0 (1+ k)))
		    ((or happy 
			 (>= k curfreqs)))
		  (if (< (abs (- curfreq (vector-ref freqs k))) 0.1)
		      (begin
			(set! happy #t)

			(snd-display ";~A ~A" curfreq curamount)
			(if (< (abs (- 2000 curfreq)) 0.1)
			    (snd-display ";2000 add ~A from i:~A at ~A and j:~A at ~A" curamount i (bes-jn i b1) j (bes-jn j b2)))
			(if (< (abs (- 1800 curfreq)) 0.1)
			    (snd-display ";1800 add ~A from i:~A at ~A and j:~A at ~A" curamount i (bes-jn i b1) j (bes-jn j b2)))
			(if (< (abs (- 200 curfreq)) 0.1)
			    (snd-display ";200 add ~A from i:~A at ~A and j:~A at ~A" curamount i (bes-jn i b1) j (bes-jn j b2)))

			(vector-set! sums k (+ (vector-ref sums k) curamount)))))
		(if (not happy)
		    (begin
		      (snd-display ";start ~A: ~A" curfreq curamount)
			(if (< (abs (- 2000 curfreq)) 0.1)
			    (snd-display ";2000 add ~A from i:~A at ~A and j:~A at ~A" curamount i (bes-jn i b1) j (bes-jn j b2)))
			(if (< (abs (- 1800 curfreq)) 0.1)
			    (snd-display ";1800 add ~A from i:~A at ~A and j:~A at ~A" curamount i (bes-jn i b1) j (bes-jn j b2)))
			(if (< (abs (- 200 curfreq)) 0.1)
			    (snd-display ";200 add ~A from i:~A at ~A and j:~A at ~A" curamount i (bes-jn i b1) j (bes-jn j b2)))

		      (vector-set! freqs curfreqs curfreq)
		      (vector-set! sums curfreqs curamount)
		      (set! curfreqs (1+ curfreqs)))))))))

    (let ((base 0.0))
      (do ((i 0 (1+ i)))
	  ((= i curfreqs))
	(if (< (abs (- 2000 (vector-ref freqs i))) 0.1)
	    (set! base (vector-ref sums i))))
      (if (= base 0.0)
	  (snd-display "can't find 2000 case?")
	  (begin
	    (snd-display ";base: ~A" base)
	    (do ((i 0 (1+ i)))
		((= i curfreqs))
	      (snd-display ";~A: ~A -> ~A" (vector-ref freqs i) (vector-ref sums i) (/ (vector-ref sums i) base))))))))

(calcit 2000 2000 200 0.5 1.0)
-->

<p>
My favorite computer instrument, the FM violin, uses three sinusoidal components in the 
modulating wave; for more complex spectra these violins are then 
ganged together (see fmviolin.clm for many examples).  By using a few sines in the modulator, you 
get away from the simple FM index sweep that has become tiresome, and the broader, flatter spectrum 
is somewhat closer to that of a real violin.
</p>

<table border=1 hspace=50 cellpadding=4><tr><td>
<small>
<p>The lumpy nature of the simple FM spectrum can be seen in figures given earlier.
The main lump is 
near n=B, a most unfortunate fact if we are trying to mimic the spectra of normal musical instruments.  Long 
time FM'ers have tied themselves in elaborate knots trying to palliate this sore thumb of a bump; parallel modulators are 
merely a simple and obvious bandage.
</p>
</small>
</td></tr></table>

<p>A pared down version of the fm-violin is:
</p>

<table border=0 bgcolor="#f6f8ff" hspace=20><tr><td>
<!-- CLM CASE 
<pre>
(definstrument violin (beg end frequency amplitude fm-index)
  (let* ((frq-scl (hz-&gt;radians frequency))
         (maxdev (* frq-scl fm-index))
         (index1 (* maxdev (/ 5.0 (log frequency))))
         (index2 (* maxdev 3.0 (/ (- 8.5 (log frequency)) (+ 3.0 (/ frequency 1000)))))
         (index3 (* maxdev (/ 4.0 (sqrt frequency))))
         (carrier (make-oscil frequency))
         (fmosc1 (make-oscil frequency))
         (fmosc2 (make-oscil (* 3 frequency)))
         (fmosc3 (make-oscil (* 4 frequency)))
         (ampf  (make-env '(0 0 25 1 75 1 100 0) :scaler amplitude))
         (indf1 (make-env '(0 1 25 .4 75 .6 100 0) :scaler index1))
         (indf2 (make-env '(0 1 25 .4 75 .6 100 0) :scaler index2))
         (indf3 (make-env '(0 1 25 .4 75 .6 100 0) :scaler index3))
         (pervib (make-triangle-wave 5 :amplitude (* .0025 frq-scl)))
         (ranvib (make-rand-interp 16 :amplitude (* .005 frq-scl)))
         (vib 0.0))
    (run
     (loop for i from beg to end do
       (setf vib (+ (triangle-wave pervib) (rand-interp ranvib)))
       (outa i (* (env ampf)
                  (oscil carrier
                         (+ vib 
                            (* (env indf1) (oscil fmosc1 vib))
                            (* (env indf2) (oscil fmosc2 (* 3.0 vib)))
                            (* (env indf3) (oscil fmosc3 (* 4.0 vib)))))))))))

(with-sound () (violin 0 10000 440 .1 2.5))
</pre>
-->

<!-- SND CASE -->
<pre>
(define (violin beg dur frequency amplitude fm-index)
  (let* ((start (seconds-&gt;samples beg))
	 (end (+ start (seconds-&gt;samples dur)))
	 (frq-scl (hz-&gt;radians frequency))
         (maxdev (* frq-scl fm-index))
         (index1 (* maxdev (/ 5.0 (log frequency))))
         (index2 (* maxdev 3.0 (/ (- 8.5 (log frequency)) (+ 3.0 (/ frequency 1000)))))
         (index3 (* maxdev (/ 4.0 (sqrt frequency))))
         (carrier (make-oscil frequency))
         (fmosc1 (make-oscil frequency))
         (fmosc2 (make-oscil (* 3 frequency)))
         (fmosc3 (make-oscil (* 4 frequency)))
         (ampf  (make-env '(0 0 25 1 75 1 100 0) :scaler amplitude :duration dur))
         (indf1 (make-env '(0 1 25 .4 75 .6 100 0) :scaler index1 :duration dur))
         (indf2 (make-env '(0 1 25 .4 75 .6 100 0) :scaler index2 :duration dur))
         (indf3 (make-env '(0 1 25 .4 75 .6 100 0) :scaler index3 :duration dur))
         (pervib (make-triangle-wave 5 :amplitude (* .0025 frq-scl)))
         (ranvib (make-rand-interp 16 :amplitude (* .005 frq-scl))))
    (run
     (lambda ()
       (do ((i start (1+ i)))
	   ((= i end))
	 (let ((vib (+ (triangle-wave pervib) (rand-interp ranvib))))
	   (outa i (* (env ampf)
		      (oscil carrier
			     (+ vib 
				(* (env indf1) (oscil fmosc1 vib))
				(* (env indf2) (oscil fmosc2 (* 3.0 vib)))
				(* (env indf3) (oscil fmosc3 (* 4.0 vib))))))
		 *output*)))))))

(with-sound () (violin 0 1.0 440 .1 2.5))
</pre>
<!-- -->
</td></tr></table>

<table align=right border=1 width=200 vspace=10 hspace=20><tr><td bgcolor="#eefdee"><h5><center>cascade FM: sin(sin(sin))</center></h5></td></tr></table>

<p>We can, of course, use FM (or anything) to produce the modulating signal.  When FM is used, it is 
sometimes called "cascade FM":
</p>

<!-- LATEX \sin(\omega_{c}t + B_{1}\sin(\omega_{m1}t + B_{2}\sin(\omega_{m2}t))) -->

<img src="fmeq35.png" alt="cascade fm" hspace=20>

<!-- HTML
<pre>
    sin(w<sub>c</sub>t + B<sub>1</sub>sin(w<sub>m1</sub>t + B<sub>2</sub>sin w<sub>m2</sub>t))
</pre>
-->

<p>In CLM:
</p>

<pre>
    (* A (oscil carrier (* B (oscil modulator (* C (oscil cascade))))))
</pre>

<p>and we can get an extremely complex spectrum in no time.  Each component of the
lower pair of oscillators is surrounded by the spectrum produced by the upper pair,
sort of like a set of formant regions.
</p>

<table border=1 hspace=40><tr><td>
<img src="cascade.png" alt="cascade fm picture">
</td></tr>
<tr><td bgcolor="#f6f8ff"><center>osc A: 2000 Hz, osc B: 500 Hz, index 1.5, osc C: 50 Hz, index 1.0</center></td></tr>
</table>


<p>Unfortunately, FM can produce energy 
at 0Hz (when, for example, the carrier frequency equals the modulating frequency), and that 0Hz ("DC") component becomes a constant offset in the 
lower of the two FM pairs. So our fundamental frequency no longer has any obvious relation to
<img src="fmeq43.png" alt="wc" align=absmiddle>!
That is, we 
can expand our cascade formula into:
</p>

<!-- LATEX \sin(\omega_{c}t + \sum J_{n}(B)\cos(\omega_{c}t + n\omega_{m_{n}}t)) -->

<img src="fmeq36.png" alt="more sins" hspace=20>

<!-- HTML
<pre>
    sin(w<sub>c</sub>t + <img alt="Sum" align=middle src="sum.png"> [J<sub>n</sub>(B)cos(w<sub>c</sub> + nw<sub>m<sub>n</sub></sub>)t])
</pre>
-->

<!-- LATEX \omega_{c} = -n\omega_{m}\textrm{, we get }J_{n}(B)\cos(0) = J_{n}(B) -->

<p>but now wherever 
<img src="fmeq46.png" alt="wc" align=absmiddle>.
This could be a disaster, because 
in most cases where we care about the perceived fundamental, we are trying to create harmonic 
spectra, and that is pretty hard if we can't predict what our modulator/carrier ratios will be.  Jan 
Mattox's fm-drum can ignore such niceties.  If you are using low indices and the top pair's 
mc-ratios are below 1.0 (in vibrato, for example), you have a good chance of getting usable results.  
If you want cascade FM to work in other situations, make sure the top oscil has an initial phase of 
(pi + mod-incr)/2.  The middle FM spectrum will then have only sines (not cosines), so the DC amplitude will 
(sometimes) be 0.  Even the tiniest error in the top oscil's phase becomes a beat, inharmonicity, or a 
timbral change in the output, so cascade FM is almost impossible to keep under control.
</p>


<table border=1 hspace=50 cellpadding=4><tr><td>

<p>The irascible reader may be grumbling about angels and pins, so here's an example of cascade FM 
to show how strong this effect is:
</p>

</td></tr><tr><td bgcolor="#f6f8ff">

<!-- CLM CASE
<pre>
(definstrument cascade (beg end freq amp modrat modind casrat casind caspha)
  (let ((cr (make-oscil freq))
        (md (make-oscil (* freq modrat)))
        (ca (make-oscil (* freq casrat) caspha))
        (fm-ind0 (hz-&gt;radians (* modind modrat freq)))
        (fm-ind1 (hz-&gt;radians (* casind (/ casrat modrat) freq))))
    (run
     (loop for i from beg to end do
       (outa i (* amp (oscil cr (* fm-ind0 (oscil md (* fm-ind1 (oscil ca)))))))))))

(with-sound () (cascade 0 10000 400 .25 1.0 1.0 1.0 1.0 0))
(with-sound () (cascade 0 10000 400 .25 1.0 1.0 1.0 1.0 (* .5 pi)))
</pre>
-->

<!-- SND CASE -->
<pre>
(define (cascade beg dur freq amp modrat modind casrat casind caspha)
  (let* ((start (seconds-&gt;samples beg))
	 (end (+ start (seconds-&gt;samples dur)))
	 (cr (make-oscil freq))
	 (md (make-oscil (* freq modrat)))
	 (ca (make-oscil (* freq casrat) caspha))
	 (fm-ind0 (hz-&gt;radians (* modind modrat freq)))
	 (fm-ind1 (hz-&gt;radians (* casind (/ casrat modrat) freq))))
    (run
     (lambda ()
       (do ((i start (1+ i)))
	   ((= i end))
	 (outa i (* amp 
                    (oscil cr (* fm-ind0 
                                 (oscil md (* fm-ind1 
                                              (oscil ca)))))) 
               *output*))))))

(with-sound () 
  (cascade 0 1.0 400 .25 1.0 1.0 1.0 1.0 0)
  (cascade 1.5 1.0 400 .25 1.0 1.0 1.0 1.0 (* .5 pi)))

;;; clean it up by using the no-DC initial phase:
(with-sound () 
  (cascade 0 1.0 400 .25 1 1.0 1 1.0 (* 0.5 (+ pi (hz->radians 400)))))
</pre>
<!-- -->

</td></tr></table>

<table align=right border=1 width=200 vspace=10 hspace=20><tr><td bgcolor="#eefdee"><h5><center>feedback FM: sin(x=sin(x))</center></h5></td></tr></table>

<p>A similar trick comes up in feedback FM used in some synthesizers. Here the output of the modulator
is low-pass filtered, then fed back into its fm-input location.  Cellon, written by Stanislaw 
Krupowicz, is an example; the feedback FM occurs in the lines (edited here for clarity):
</p>

<!-- CLM CASE
<pre>
    (setf fm (one-zero low (* B (oscil fmosc fm))))
    (outa i (* amp (oscil carrier fm)))
or
    sin(y &lt;= w<sub>c</sub>t + B sin y) 
</pre>
-->

<!-- SND CASE -->
<pre>
    (set! fm (one-zero low (* B (oscil fmosc fm))))
    (outa i (* amp (oscil carrier fm)) *output*)
or
    sin(y &lt;= w + B sin y) 
</pre>
<!-- -->

<p>(ignoring the low pass filter for the moment).  This is expanded by Tomisawa as:
</p>

<!-- LATEX \sum_{n=1}^{\infty}\frac{2}{nB}J_{n}(nB)\sin n\omega_{c}t -->

<img src="fmeq37.png" alt="feedback fm" hspace=20>

<!-- HTML
<pre>
   <img alt="inf" src="inf.png">
   <img alt="Sum" align=middle src="sum.png"> (2/(nB))J<sub>n</sub>(nB) sin nw<sub>c</sub>t
    n=1
</pre>
-->

<p>As Tomisawa points out this is very close to the formulas we have been looking at already, except that 
the argument to the Bessel function depends on the order, we have only multiples of the carrier frequency 
in the expansion, and the elements of the sequence are multiplied by 2/nB.  The result is a much 
broader, flatter spectrum than one normally gets from FM.  If you just push the index up in normal 
FM, the energy is pushed outward in a lumpy sort of fashion, not evenly spread across the spectrum.  
In effect we've turned the axis of the Bessel functions so that the higher order functions start at 
nearly the same time as the lower order functions.  The new function Jn(nB) decreases (very!) gradually.  
For example if the index (B) is 1:
</p>

<!-- LATEX
\begin{eqnarray*}
J_{1}(1) = .440 \\
J_{2}(2) = .353 \\
J_{3}(3) = .309 \\
J_{200}(200) = .076 \\
J_{2000}(2000) = .035
\end{eqnarray*}
-->

<!-- J100000(100000) = .0096
     J1000000(1000000) = .0044
     J10000000(10000000) = .002
     after that they are repeating -- factor of 10 -> factor of 2 in result -- probably an artifact
-->

<img src="fmeq28.png" alt="Jn vals" hspace=20>

<!-- HTML
<pre>
    J<sub>1</sub>(1) = .440 
    J<sub>2</sub>(2) = .353 
    J<sub>3</sub>(3) = .309
    J<sub>200</sub>(200) = .076
</pre>
-->

<p>and so on. Since the other part of the equation goes down as 1/n, we get essentially a sawtooth wave 
out of this equation (its harmonics go down as 1/n).  Tomisawa suggests that B should be between 0 
and 1.5. Since we are dividing by B in the equation, we might worry that as B heads toward 0, all 
hell breaks loose, but luckily:
</p>

<!-- LATEX \lim_{B \to 0}\frac{2}{B}J_{1}(B) = 1 -->

<img src="fmeq38.png" alt="lim1 case" hspace=20>

<!-- HTML
<pre>
    lim 2/B (J<sub>1</sub>(B)) = 1
    B=&gt;0 
</pre>
-->

<p>and for all the other components
</p>

<!-- LATEX \lim_{B \to 0}\frac{2}{nB}J_{n}(nB) = 0 -->

<img src="fmeq39.png" alt="all cases" hspace=20>

<!-- HTML
<pre>
    lim 2/nB J<sub>n</sub>(nB) = 0
    B=&gt;0 
</pre>
-->

<p>so, just as in normal FM, if the index is 0, we get a pure sine wave.
</p>

<table border=1 hspace=20 cellpadding=3>
<tr><td bgcolor="#f6f8ff">
<pre>
(define (feedbk beg dur freq amp index)
  (let* ((start (seconds-&gt;samples beg))
	 (end (+ start (seconds-&gt;samples dur)))
	 (y 0.0)
	 (x-incr (hz-&gt;radians freq)))
    (run 
     (lambda ()
       (do ((i start (1+ i))
	    (x 0.0 (+ x x-incr)))
	   ((= i end))
	 (set! y (+ x (* index (sin y))))
	 (outa i (* amp (sin y)) *output*))))))

(with-sound () (feedbk 0 1 100.0 1.0 1.0))
</pre>
</td>

<td>
<table border=0>
<tr><td>
<img src="fdbk.png" alt="feedback fm">
</td></tr>
<tr>
<td>
<pre>

  2/1 J1(1) = 0.880 -&gt; 1.000 (normalized to match fft)
  2/2 J2(2) = 0.353 -&gt; 0.401
  2/3 J3(3) = 0.206 -&gt; 0.234
  2/4 J4(4) = 0.141 -&gt; 0.159
  2/5 J5(5) = 0.104 -&gt; 0.118
  2/6 J6(6) = 0.082 -&gt; 0.093
  2/7 J7(7) = 0.066 -&gt; 0.076
</pre>
</td></tr></table>
</td></tr></table>

<p>
Apparently, if B&gt;1.0, this formula becomes 
numerically unstable; the result is a burst of noise.
Tomisawa says the problem "is considered to be caused by an error in the digital computation". 
Perhaps we have wandered into the realm of chaos:
<code>(set! x (* 4 (sin (* pi x))))</code>
can behave chaotically.
</p>

<table align=right border=1 width=200 vspace=10 hspace=20><tr><td bgcolor="#eefdee"><h5><center>FM and noise: sin(sin(rand))</center></h5></td></tr></table>

<p>
One of the standard ways to make noise 
(deliberately) with FM is to increase the index until massive aliasing is taking place. 
In another, more controllable, method,
we inject noise into our FM equations and see if anything useful pops out.  The fm-noise 
instrument performs one form of modulation with noise.  The actual modulation 
portion is:
</p>

<pre>
    (oscil carrier (* fm-index (rand modulator)))
</pre>

<p>where rand is producing white noise.
When frequency modulation gets noise, the power spectral density of the output has the same form 
as the density function of the modulating wave, but now centered around the carrier. 
The bandwidth of the result is about 4 times the peak deviation (the 
random number frequency times its amplitude).  Simple FM with noise gives various whooshing sounds,
useful for Oceanic Music, but it can overstay its welcome.
Heinrich Taube had the inspired idea
of feeding the noise (as a sort of cascade FM) into the 
parallel modulators of an fm-flute, but not into the carrier.  The modulating signal becomes a sum of 
two or three narrow band noises (narrow because normally the amplitude of the noise is low), and 
these modulate the carrier.  It is my belief that you get the normal spectrum with each component 
smeared out by a copy of the noise band:
</p>

<table border=1 hspace=20>
<tr>
<td colspan=3 bgcolor="#f6f8ff"><center>(with-sound () (fm-violin 0 1 400.0 .5 :fm-index 3.0 :noise-amount 0.007))</center></td></tr>
<tr>
<td><img src="fmvnoise0.png" alt="fmv no noise"></td>
<td><img src="fmvnoise2.png" alt="fmv noise .002"></td>
<td><img src="fmvnoise7.png" alt="fmv noise .007"></td>
</tr>
<tr>
<td><center>noise-amount: 0.0</center></td>
<td><center>noise-amount: 0.002</center></td>
<td><center>noise-amount: 0.007</center></td>
</tr></table>


<p>In CLM, the basic idea is:
</p>

<pre>
    (oscil carrier (* fm-index (oscil fm (* noise-index (rand noise)))))
</pre>


<p>In the realm of "anything" as the modulating signal, consider 
</p>

<pre>
    (sin (+ sound-file (* index (sin (* 2 pi sound-file)))))
</pre>

<p>where "sound file" is any recorded sound.  I call this "contrast-enhancement" in the CLM package.  It 
makes a sound crisper; "Wait for Me!" uses it whenever a sound needs to cut through a huge 
mix.
</p>


<table align=right border=1 width=200 vspace=10 hspace=20><tr><td bgcolor="#eefdee"><h5><center>FM voice</center></h5></td></tr></table>

<p>We can use more than one sinusoidal component in our carrier, or multiple banks of carriers and 
modulators, and depend upon vibrato and "spectral fusion" to make the result sound like one voice.  
In this cross between additive synthesis (the multiple carriers) and FM (the formant centered on 
each carrier), we get around many of the limitations of the Bessel functions.  There are numerous 
examples in fmviolin.clm.  One of the raspier 
versions of the fm-violin used a sawtooth wave as the carrier.  
One of the more elaborate multi-carrier FM instruments is the voice instrument written by Marc Le Brun,
and used in "Colony" and other pieces. In a simplified form it is:
</p>

<table border=0 bgcolor="#f6f8ff" hspace=20><tr><td>
<!-- CLM CASE
<pre>
(definstrument vox (beg end freq amp 
                    &amp;optional (indexes '(.005 .01 .02)) (formant-amps '(.86 .13 .01)))
  (let* ((car-os (make-oscil 0))
         (evens (make-array 3))
         (odds (make-array 3))
         (amps (make-array 3 :element-type 'short-float :initial-contents formant-amps))
         (ampf (make-env '(0 0 25 1 75 1 100 0) :scaler amp))
         (frmfs (make-array 3))
         (indices (make-array 3 :element-type 'short-float :initial-contents indexes))
         (frq 0.0) (car 0.0) (frm 0.0) (frm-int 0) (frm0 0.0) 
         (even-amp 0.0) (odd-amp 0.0) (even-freq 0.0) 
         (odd-freq 0.0) (sum 0.0)
         (per-vib (make-triangle-wave 6 :amplitude (* freq .03)))
         (ran-vib (make-rand-interp 20 :amplitude (* freq .5 .02))))
    (dotimes (i 3)
      (setf (aref evens i) (make-oscil 0))
      (setf (aref odds i) (make-oscil 0)))
    (setf (aref frmfs 0) (make-env '(0 520 100 490))) 
    (setf (aref frmfs 1) (make-env '(0 1190 100 1350))) 
    (setf (aref frmfs 2) (make-env '(0 2390 100 1690))) 
    (run
     (loop for i from beg to end do
       (setf frq (+ freq (triangle-wave per-vib) (rand-interp ran-vib)))
       (setf car (oscil car-os (hz-&gt;radians frq)))
       (setf sum 0.0)
       (dotimes (k 3)
         (setf frm (env (aref frmfs k)))
         (setf frm0 (/ frm frq))
         (setf frm-int (floor frm0))
         (if (evenp frm-int)
             (progn
               (setf even-freq (hz-&gt;radians (* frm-int frq)))
               (setf odd-freq (hz-&gt;radians (* (+ frm-int 1) frq)))
               (setf odd-amp (- frm0 frm-int))
               (setf even-amp (- 1.0 odd-amp)))
           (progn
             (setf odd-freq (hz-&gt;radians (* frm-int frq)))
             (setf even-freq (hz-&gt;radians (* (+ frm-int 1) frq)))
             (setf even-amp (- frm0 frm-int))
             (setf odd-amp (- 1.0 even-amp))))
         (incf sum (+ (* (aref amps k) 
                      (+ (* even-amp 
                            (oscil (aref evens k) 
                              (+ even-freq (* (aref indices k) car))))
                         (* odd-amp 
                             (oscil (aref odds k) 
                               (+ odd-freq (* (aref indices k) car)))))))))
      (outa i (* (env ampf) sum))))))

(with-sound () (vox 0 10000 110 .5 '(0.02 0.01 0.02) '(.9 .09 .01)))
</pre>
-->

<!-- SND CASE -->
<pre>
(define* (vox beg dur freq amp :optional (indexes '(.005 .01 .02)) (formant-amps '(.86 .13 .01)))
  (let* ((start (seconds-&gt;samples beg))
	 (end (+ start (seconds-&gt;samples dur)))
	 (car-os (make-oscil 0))
         (evens (make-vector 3))
         (odds (make-vector 3))
         (amps (apply vct formant-amps))
         (ampf (make-env '(0 0 25 1 75 1 100 0) :scaler amp :duration dur))
         (frmfs (make-vector 3))
         (indices (apply vct indexes))
         (per-vib (make-triangle-wave 6 :amplitude (* freq .03)))
         (ran-vib (make-rand-interp 20 :amplitude (* freq .5 .02))))
    (do ((i 0 (1+ i)))
	((= i 3))
      (vector-set! evens i (make-oscil 0))
      (vector-set! odds i (make-oscil 0)))

    (vector-set! frmfs 0 (make-env '(0 520 100 490) :duration dur)) 
    (vector-set! frmfs 1 (make-env '(0 1190 100 1350) :duration dur)) 
    (vector-set! frmfs 2 (make-env '(0 2390 100 1690) :duration dur))

    (run
     (lambda ()
       (do ((i start (1+ i)))
	   ((= i end))
	 (let* ((frq (+ freq (triangle-wave per-vib) (rand-interp ran-vib)))
		(car (oscil car-os (hz-&gt;radians frq)))
		(sum 0.0))
	   (do ((k 0 (1+ k)))
	       ((= k 3))
	     (let* ((frm (env (vector-ref frmfs k)))
		    (frm0 (/ frm frq))
		    (frm-int (inexact-&gt;exact (floor frm0)))
		    (even-amp 0.0) (odd-amp 0.0) 
		    (even-freq 0.0) (odd-freq 0.0))
	       (if (even? frm-int)
		   (begin
		     (set! even-freq (hz-&gt;radians (* frm-int frq)))
		     (set! odd-freq (hz-&gt;radians (* (+ frm-int 1) frq)))
		     (set! odd-amp (- frm0 frm-int))
		     (set! even-amp (- 1.0 odd-amp)))
		   (begin
		     (set! odd-freq (hz-&gt;radians (* frm-int frq)))
		     (set! even-freq (hz-&gt;radians (* (+ frm-int 1) frq)))
		     (set! even-amp (- frm0 frm-int))
		     (set! odd-amp (- 1.0 even-amp))))
	       (set! sum (+ sum (+ (* (vct-ref amps k) 
				      (+ (* even-amp 
					    (oscil (vector-ref evens k) 
						   (+ even-freq (* (vct-ref indices k) car))))
					 (* odd-amp 
					    (oscil (vector-ref odds k) 
						   (+ odd-freq (* (vct-ref indices k) car)))))))))))
	   (outa i (* (env ampf) sum) *output*)))))))

(with-sound () 
  (vox 0 1.0 220.0 0.5)
  (vox 1.5 1.0 110 .5 '(0.02 0.01 0.02) '(.9 .09 .01)))
</pre>
<!-- -->
</td></tr></table>

<p>which produces this spectrogram:
</p>

<img src="voxspectrum.png" alt="voice spectrum" hspace=20>


<hr>
<h2>References</h2>
<pre>
Abramowitz and Stegun, "Handbook of Mathematical Functions", Dover 1965.

Bate, "The Effect of Modulator Phase on Timbres in FM Synthesis", CMJ vol 14, no3 1990, p38-45.

Benson, "Music: A Mathematical Offering", Cambridge University Press, Nov 2006. Also available
     on-line: http://www.maths.abdn.ac.uk/~bensondj/html/music.pdf.  If the math side of my
     article is of any interest, you might like Benson's discussion of FM.

Chowning, "The Synthesis of Complex Audio Spectra by Means of Frequency Modulation", JAES 21:526-534, 1973

De Poli, "A Tutorial on Digital Sound Synthesis Techniques", CMJ vol7 no 4, 1983.

Gagliardi, "Introduction to Communications Engineering", Wiley Interscience, 1978.

Klapper, "Selected Papers on Frequency Modulation", Dover 1970. (Out of print, but available
     via used book markets such as abebooks or amazon -- usually about $25).
     The Bessel function graph is from Corrington, "Variation of Bandwidth with Modulation Index in FM",
     The picture below of an early radio is from Armstrong, "A Method of Reducing Disturbances in Radio
     Signaling by a System of FM".

Le Brun, "A Derivation of the Spectrum of FM with a Complex Modulating Wave", CMJ vol1, no 4 1977 p51-52

Moorer, "Signal Processing Aspects of Computer Music: A Survey" Proc IEEE  vol 65 1977.

Palamin, Palamin, Ronveaux "A Method of Generating and Controlling Asymmetrical Spectra", JAES vol 36, 
     no 9, Sept 88, p671-685.

Schottstaedt, "The Simulation of Natural Instrument Tones Using Frequency Modulation with a Complex Modulating Wave", 
     CMJ vol 1 no 4 1977 p46-50

Taub and Schilling, "Principles of Communications Systems", McGraw-Hill, 1986.

Tomisawa, "Tone Production Method for an Electronic Musical Instrument" US Patent 4,249,447, 1981.

Watson, "A Treatise on the Theory of Bessel Functions", Cambridge, 1922.
</pre>

<table border=1 hspace=40><tr><td>
<img src="fmradio.png" alt="early FM radio">
</td></tr><tr><td>
<center>FM (and AM) radio ca 1933</center>
</td></tr></table>

</body>
</html>
