<html>
<head>
<title>Common Lisp Music</title>
<style type="text/css">
<!-- 
	EM.red {color: red; font-style: normal}
	EM.def {font-weight: bold; font-style: normal}
	EM.gen {font-weight: bold; font-style: normal}
	H1 {text-align: center}
	UL {list-style-type: none}
	SPAN.box {background: beige; width: 100%; font-style: normal; text-align: center; border-width: thin; border-style: ridge}
	SPAN.bbox {background: lightsteelblue; width: 100%; font-style: normal; border-width: thin; border-style: ridge}
	SPAN.cbox {background: lightgreen; width: 100%; font-style: normal; border-width: thin; border-style: ridge}
	SPAN.htmlbox {background: tan; font-style: normal; font-size: small; border-width: thin; border-style: ridge}
-->
</style>
</head>

<!-- 
     The index at the end is generated automatically by index.cl which notices all names, and
     special comments labelled INDEX.  Similarly, the TOPIC comments are for the clm-help facility.
-->

<body bgcolor=white>
<h1>COMMON LISP MUSIC</h1>
<center><small><small><cite>"The most apparent difference between animals and vegetables is that animals have the powers of sound" -- William Bartram, "Travels", 1791.</cite></small></small></center><br>

<p>Common Lisp Music (CLM, for lack of a catchier name) is a music synthesis and
signal processing package in the Music V family.  The new version, named CLM-2, 
represents a large-scale revision of the version that existed from 1990 to 1999.
This document describes CLM-2.  See translate.cl for information on moving from
the previous version to this one.  CLM exists in three forms: a Common Lisp implementation
with optional C foreign functions, a C version, and a Scheme version built on the C version
through the Guile library.  There are a variety of unavoidable differences between these
versions, but in general, the differences are obvious and consistent (Lisp "-" becomes
C "_", "?" becomes "_p", "-&gt;" becomes "2", etc).  
The Common Lisp and Scheme versions try to be completely compatible, and this document
concentrates on former.  (To compare the three versions, see v.ins, the fm-violin in
examp.scm, and the same code in sndlib.html).
</p>

<p>CLM has several sections: the <a href="#generators">"generators"</a>, instruments
(<a href="#definstrument">definstrument</a> and *.ins), examples of note lists
(<a href="#with-sound">with-sound</a>, *.clm), a "make" facility for sound files (<a href="#with-mix">with-mix</a>), 
various functions that are useful in sound file work (<a href="#sound-let">sound-let</a>,
<a href="#mix">mix</a>), and a connection to
the <a href="#sndcommunication">Snd</a> sound editor.
CLM runs on the Macintosh (MacOS or LinuxPPC), SGI, Sun, Alpha, Windoze, and any machine
running Linux.
It is available free, via anonymous ftp (<a href="ftp://ccrma-ftp.stanford.edu/pub/Lisp/clm-2.tar.gz">pub/Lisp/clm-2.tar.gz</a> at
ccrma-ftp.stanford.edu; the Snd editor is <a href="ftp://ccrma-ftp.stanford.edu/pub/Lisp/snd-4.tar.gz">snd-4.tar.gz</a>).</p>

<center>Bill Schottstaedt (bil@ccrma.stanford.edu)</center>
<br>
<center>
<span class=htmlbox>related documentation</span><span class=htmlbox><a href="snd.html#overview">snd.html</a><spacer type=horizontal size=25><a href="extsnd.html#extsndcontents">extsnd.html</a><spacer type=horizontal size=25><a href="grfsnd.html#grfsndcontents">grfsnd.html</a><spacer type=horizontal size=25><a href="sndlib.html#introduction">sndlib.html</a></span>
</center>

<br>

<span class=box><h2>Contents</h2></span>
<ul>
<li><a href="#introduction">Introduction</a>
<li><a href="#instruments">Instruments</a>
<ul>
<li><small><a href="#generators">Generators</a></small>
<li><small><a href="#generic-functions">Generic Functions</a></small>
<li><small><a href="#sound IO">Frames, Mixers, Sound IO</a></small>
<li><small><a href="#functions">Useful functions</a></small>
<li><small><a href="#def-clm-struct">def-clm-struct</a></small>
<li><small><a href="#definstrument">Definstrument</a></small>
</ul>
<li><a href="#note-lists">Note Lists</a>
<ul>
<li><small><a href="#with-sound">With-sound</a></small>
<li><small><a href="#howtowsm">How to use many machines at once</a></small>
<li><small><a href="#with-psound">Direct to DAC and Realtime Controls</a></small>
<li><small><a href="#mix-and-with-mix">With-mix</a></small>
<li><small><a href="#instrument-let">Instrument-let and Sound-let</a></small>
</ul>
<li><a href="#debugging-aids">Debugging</a>
<ul>
<li><small><a href="#sndcommunication">CLM and Snd</a></small>
</ul>
<li><a href="#appendices">Appendices</a>
<ul>
<li><small><a href="#header-types">Header and data types supported in CLM</a></small>
<li><small><a href="#unwanted-noise">Sources of unwanted noise</a></small>
<li><small><a href="#clm-init.lisp">Example of clm-init.lisp</a></small>
<li><small><a href="#user-defined-ugs">User-defined generators</a></small>
<li><small><a href="#savedimages">About CLM in saved images</a></small>
<li><small><a href="#how-to-use-clm">How to use CLM outside with-sound</a></small>
<li><small><a href="#bugs">Misfeaures and Unfinished Business</a></small>
</ul>
<li><a href="#index">Index</a>
</ul>
<br>

<span class=box><h2><a name="introduction">Introduction</a></h2></span>

<p>CLM provides functions to experiment with sounds.
The easiest way to make a new sound is 
<a href="#with-sound">with-sound</a>.  Say we want to hear one second of the fm violin (in <a href="v.ins">v.ins</a>,
named fm-violin) at 440 Hz, and a somewhat soft amplitude.  Compile and load v.ins, then call with-sound:</p>
<pre>
    (compile-file "v.ins")
    (load "v")
    (with-sound () (fm-violin 0 1 440 .1)) 
</pre>
<p>and the note should emerge from the speakers.  The compile and load sequence can be abbreviated
in most lisps.  In ACL, for example, <code>:cl v.ins</code> or perhaps even <code>:cl v</code> will call compile-file
if needed, then load.
Once loaded, we don't
need to reload v unless we change it in some way.  To get an arpeggio:</p>
<pre>
    (with-sound ()
      (loop for i from 0 to 7 do
        (fm-violin (* i .25) .5 (* 100 (1+ i)) .1))) 
</pre>
<p><a href="clm-example.lisp">clm-example.lisp</a> shows how to create such a note list algorithmically.</p>

<p>Although you can use CLM simply as a bunch of canned functions, it's a lot more
fun to make your own.  In CLM, these are called "generators" and "instruments", and a sequence of
instrumental calls is a "note list".  
To create your own generators and instruments, you need to write the Lisp function that expresses
in CLM's terms the sound processing actions you want.
In the simplest case, you can just calculate your new
value, and add it into the current output:</p>
<pre>
(defun simp (start-time duration frequency amplitude)
  (let* ((beg (floor (* start-time *srate*)))
	 (end (+ beg (floor (* duration *srate*)))))
    (loop for i from beg below end and j from 0 by 1 do
      (outa i (* amplitude (sin (* j 2.0 pi (/ frequency *srate*))))))))
</pre>
<p>Now to hear our sine wave:</p>
<pre>
(with-sound () (simp 0 0.25 440.0 0.2))
</pre>
<p>This creates a sine-wave at 440.0 Hz, 0.2 amplitude, between times 0 and
0.25 seconds.  The line:</p>
<pre>
(defun simp (start-time duration frequency amplitude)
</pre>
<p>declares that our instrument is a lisp function (defun) named simp which
takes the four parameters start-time, duration, frequency, and amplitude.
The next two lines:</p>
<pre>
  (let* ((beg (floor (* start-time *srate*)))
	 (end (+ beg (floor (* duration *srate*)))))
</pre>
<p>turn the start-time and duration values, passed by the caller in
terms of seconds, into samples.  The variable <i>*srate*</i>
holds the current sampling rate. The next
line:</p>
<pre>
    (loop for i from beg below end and j from 0 by 1 do
</pre>
<p>uses the Lisp <i>loop</i> construct to loop through the samples
between start-time (beg) and start-time+duration (end) calculating
simp's output on each sample.  We are also using the variable <i>j</i>
to increment the current phase in the last line:</p>
<pre>
      (outa i (* amplitude (sin (* j 2.0 pi (/ frequency *srate*))))))))
</pre>
<p>This is the "meat" of our instrument.  The call (<a href="#outa">outa</a> <i>i</i> <i>whatever</i>)
adds its third argument (in this case a complicated expression) into channel 0 of the
current output stream at location <i>i</i>.  The expression itself:</p>
<pre>
(* amplitude (sin (* j 2.0 pi (/ frequency *srate*))))))))
</pre>
<p>is creating a sinusoid (via the "sin" function) at the specified
volume ("amplitude" is passed as an argument to simp), and the
desired frequency ("frequency" is also an argument to simp).  The
caller passes simp a frequency in cycles per second (440.0 for
example), but we need to turn that into the corresponding phase
value for the "sin" function.  We do that by translating from
cycles per second to radians per sample by multiplying by two pi
(this multiply gives us radians
per second), then dividing by the sampling rate (samples per
second) to give us radians per sample (i.e. radians/second
divided by samples/second gives radians/sample); we then multiply
by "j" to step forward on each sample.  All this is far more
detailed and explicit than would be the case in a normal clm
instrument.  For example, we would normally use the clm macro
<i>hz-&gt;radians</i> to replace the multiply by (/ (* 2.0 pi) sampling-rate);
and we would use <i>oscil</i> to deal with the phase increments.
Finally, the line:</p>
<pre>
(with-sound () (simp 0 0.25 440.0 0.2))
</pre>
<p>opens an output sound file, calls simp, closes the file, and
plays the result. 
Lisp compilers generate less-than-ideal numerical code, so we always
wrap up the "run-time" portion of our instrument in the macro <a href="#run">run</a>.  If
it can, <i>run</i> expands into C code to speed up the work.
To take care of various system bookkeeping functions during this
process, we use <a href="#definstrument">definstrument</a>, rather than defun to define the 
instrument function. Its syntax can be considered to be identical to defun:</p>
<pre>
(definstrument simp (start-time duration frequency amplitude)
  (multiple-value-bind (beg end) (times-&gt;samples start-time duration)
    (let ((s (make-oscil frequency)))
      (run
       (loop for i from beg below end do 
	 (outa i (* amplitude (oscil s))))))))
</pre>
<p>This version of simp performs the same task as the earlier one, but a lot faster.
We use <i>run</i> and <i>definstrument</i> which work together to speed up the computation,
and replace the explicit phase calculation with <i>oscil</i>.
<a href="#oscil">Oscil</a> returns a sine wave at the frequency specified
in the <a href="#make-oscil">make-oscil</a> call.  Each "generator"
in clm has a corresponding "make" function to create and initialize an instance
of that generator.  One such generator, <a href="#env">env</a>, handles envelopes -- 
let's put an amplitude envelope on simp's output:</p>
<pre>
(definstrument simp (start-time duration frequency amplitude 
		      &amp;optional (amp-env '(0 0 50 1 100 0)))
  (multiple-value-bind (beg end) (times-&gt;samples start-time duration)
    (let ((s (make-oscil :frequency frequency))
	  (amp (make-env :envelope amp-env :scaler amplitude :duration duration)))
      (run 
       (loop for i from beg below end do
	 (outa i (* (env amp) (oscil s))))))))
</pre>
<p>Our envelope is a list of (x y) break-point pairs.  The
x-axis bounds are arbitrary, but it is conventional (here at ccrma) to
go from 0 to 1.0.  The y-axis values are normally between -1.0 and
1.0, to make it easier to figure out how to apply the envelope in
various different situations.  In this case, our envelope is a ramp up
to the middle of the note, then a ramp down to 0.  <a href="#make-env">Make-env</a>
packages up the envelope information, pre-computing increments and so
on.  The envelope is then actually applied by calling <a href="#env">env</a>.</p>
<br>


<span class=box><h2><a name="instruments">CLM instruments</a></h2></span>

<p>The normal structure of an instrument is:</p>
<pre>
(<i>definstrument</i> name (args) (setup code (<i>run</i> run-time code)))
</pre>
<p>The setup code creates any needed generator structures for the
run-time code which actually generates the samples.
The run-time code can contain any of the lisp functions, generators, or other
special functions described in the next several sections.  Since life is short,
not every feature of lisp is supported by the run macro; if you want to use
the Lisp-to-C translation feature, only the following 
<a name="lisp-functions"></a>
<!-- TOPIC lisp-functions -->
<!-- INDEX lisp-functions:Run support for Lisp -->
Lisp functions can occur within the body of the run macro:</p>
<pre>
    +  /  *  -  1+  1-  incf decf setf setq psetf psetq shiftf rotatef
     =  /=  &lt;  &gt;  &lt;=  &gt;=  zerop plusp  
    minusp oddp evenp max min abs mod rem identity
    floor ceiling round truncate signum sqrt random float
    ash log expt exp sin cos tan asin acos atan cosh sinh tanh asinh acosh atanh 
    or and not null if unless when cond progn prog1 prog2 case tagbody go 
    error warn print princ terpri print-object probe-file
    block return return-from let let* loop do do* dotimes declare
    lambda apply loop-finish
    aref elt svref array-total-size array-in-bounds-p array-rank array-dimension
    integerp numberp floatp realp eq eql
</pre>
<p>The function <a name="clm-print"><em class=def>clm-print</em></a> stands in for Lisp's
<i>format</i> -- we don't support all of format's
options, but enough to be useful, I hope.  clm-print's syntax is (<i>clm-print</i>
<i>format-string</i> &amp;rest <i>args</i>). If the first argument is an
integer, rather than the format string, it is assumed to be a file
identifier, and the text output is written to that file.</p>

<p><small>
<i>Loop</i> is expanded as a macro and anything in
the loop syntax is ok if it expands into something else mentioned above (i.e. a
lambda form with go's and so forth).  The same holds for <i>psetf</i>,
<i>rotatef</i>, and <i>shiftf</i>.  (I think only MCL has problems in
this regard).
</small></p>

<p><small>
<i>Declare</i> can be used to set the safety and debugging options, as
well as set variable types (this can result in tighter code in many cases).
The recognized types are integer and float;
in the resultant C code these become either integers or doubles.
</small></p>
<br>

<!-- INDEX generators:Generators -->
<span class=bbox><h3><a name="generators">Generators</a></h3></span>
<br><center>
<table border=8 bordercolor="lightsteelblue">
  <tr><td><small><a href="#all-pass">all-pass</a></small><td><small>all-pass filter</small><td><td><small><a href="#out-any">out-any</a></small><td><small>sound output</small><td>
  <tr><td><small><a href="#asymmetric-fm">asymmetric-fm</a></small><td><small>asymmetric fm</small><td><td><small><a href="#phase-vocoder">phase-vocoder</a></small><td><small>vocoder analysis and resynthesis</small><td>
  <tr><td><small><a href="#make-buffer">buffer</a></small><td><small>block oriented processing</small><td><td><small><a href="#pulse-train">pulse-train</a></small><td><small>pulse train</small>
  <tr><td><small><a href="#comb">comb</a></small><td><small>comb filter</small><td><td><small><a href="#rand">rand,rand-interp</a></small><td><small>random numbers, noise</small>
  <tr><td><small><a href="#convolve">convolve</a></small><td><small>convolution</small><td><td><small><a href="#readin">readin</a></small><td><small>sound input</small>
  <tr><td><small><a href="#delay">delay</a></small><td><small>delay line</small><td><td><small><a href="#sawtooth-wave">sawtooth-wave</a></small><td><small>sawtooth</small>
  <tr><td><small><a href="#env">env</a></small><td><small>line segment envelope</small><td><td><small><a href="#sine-summation">sine-summation</a></small><td><small>sine summation synthesis</small>
  <tr><td><small><a href="#filter">filter</a></small><td><small>direct form FIR/IIR filter</small><td><td><small><a href="#square-wave">square-wave</a></small><td><small>square wave</small>
  <tr><td><small><a href="#fir-filter">FIR-filter</a></small><td><small>FIR filter</small><td><td><small><a href="#src">src</a></small><td><small>sampling rate conversion</small>
  <tr><td><small><a href="#formant">formant</a></small><td><small>resonance</small><td><td><small><a href="#sum-of-cosines">sum-of-cosines</a></small><td><small>band-limited pulse train</small>
  <tr><td><small><a href="#granulate">granulate</a></small><td><small>granular synthesis</small><td><td><small><a href="#table-lookup">table-lookup</a></small><td><small>interpolated table lookup</small>
  <tr><td><small><a href="#iir-filter">IIR-filter</a></small><td><small>IIR filter</small><td><td><small><a href="#tap">tap</a></small><td><small>delay line tap</small>
  <tr><td><small><a href="#in-any">in-any</a></small><td><small>sound file input</small><td><td><small><a href="#triangle-wave">triangle-wave</a></small><td><small>triangle wave</small>
  <tr><td><small><a href="#locsig">locsig</a></small><td><small>static sound placement</small><td><td><small><a href="#two-pole">two-pole</a></small><td><small>two pole filter</small>
  <tr><td><small><a href="#notch">notch</a></small><td><small>notch filter</small><td><td><small><a href="#two-zero">two-zero</a></small><td><small>two zero filter</small>
  <tr><td><small><a href="#one-pole">one-pole</a></small><td><small>one pole filter</small><td><td><small><a href="#wave-train">wave-train</a></small><td><small>wave train</small>
  <tr><td><small><a href="#one-zero">one-zero</a></small><td><small>one zero filter</small><td><td><small><a href="#waveshape">waveshape</a></small><td><small>waveshaping</small>
  <tr><td><small><a href="#oscil">oscil</a></small><td><small>sine wave and FM</small><td>
</table>
</center>
<br><br>

<p>A generator is a function that returns the next sample in an infinite stream of samples
each time it is called.  An oscillator, for example, returns an endless sine wave a sample
at a time.  
Each generator consists of a set of functions:  Make-&lt;gen&gt; sets up the
data structure associated with the generator at initialization time;
&lt;gen&gt; produces a new sample;
&lt;gen&gt;? checks whether a variable is that kind of generator.
Internal fields are accessible via various "generic" functions such as mus-frequency.
For example,</p>
<pre>
    (setf oscillator (make-oscil :frequency 330))
</pre>
<p>prepares <i>oscillator</i> to produce a sine wave
when set in motion via</p>
<pre>
    (oscil oscillator)
</pre>
<p>(oscil? oscillator) returns t, and (mus-frequency oscillator) returns 330.
The initialization function
normally takes a number of optional arguments, setting whatever state the given
generator needs to operate on.  The run-time function's first argument is
always its associated structure.  Its second argument is nearly always
something like an FM input, whatever run-time modulation might be
desired.  Amplitude envelopes are handled with a separate <a href="#env">env</a> generator.
Frequency sweeps of all kinds (vibrato, glissando, breath
noise, FM proper) are all forms of run-time frequency modulation.  So, in
normal usage, our oscillator looks something like:</p>
<pre>
    (oscil oscillator (+ vibrato glissando frequency-modulation))
</pre>
<p>
Frequencies are always in cycles per
second (also known as Hz), internal table size is two pi.  The
fm (or frequency change) argument is assumed to be a phase change in radians,
applied on each sample.  Normally composers would rather think in terms of
Hz, so the function <a href="#hz-&gt;radians">hz-&gt;radians</a> can be used to convert from units of cycles
per second to radians per sample.  Since all the generators agree that their internal period length is
two-pi, you can always use hz-&gt;radians to convert the frequency change (or fm)
argument from a more easily interpreted value.</p>

<p>Finally, one special aspect of the make-&lt;gen&gt; functions is the way they
read their arguments.  I use the word <a name="optional-key"><em class=def>optional-key</em></a>
in the function definitions in this document to indicate that the arguments are
keywords, but the keywords themselves are optional.
Take, for example, the make-oscil call, defined as:</p>
<pre>
  make-oscil &amp;optional-key (<i>frequency</i> 440.0) (<i>initial-phase</i> 0.0)
</pre>
<p>When make-oscil is called, it scans its arguments; if a keyword is seen, that
argument and all following arguments are passed unchanged, but if a value is
seen, the corresponding keyword is prepended in the argument list.  So, for
example,</p>
<pre>
  (make-oscil :frequency 440.0)
  (make-oscil :frequency 440.0 :initial-phase 0.0)
  (make-oscil 440.0)
  (make-oscil)
  (make-oscil 440.0 :initial-phase 0.0)
  (make-oscil 440.0 0.0)
</pre>
<p>are all equivalent, but</p>
<pre>
  (make-oscil :frequency 440.0 0.0)
  (make-oscil :initial-phase 0.0 440.0)
</pre>
<p>are in error, because once we see any keyword, all the rest of the arguments have
to use keywords too (we can't reliably make any assumptions after that point about argument
ordering).  If this is confusing, just use the keywords all the time.  I implemented this somewhat
unusual argument interpretation because
in many cases it is silly to insist on the keyword; for example, in make-env,
the envelope argument is obvious and can't be confused with any other argument, so
it's an annoyance to have to say ":envelope" over and over.</p>

<br>


<!-- TOPIC oscil -->
<span class=cbox><h4>OSCIL</h4></span>

<pre>
  <a name="make-oscil"><em class=def>make-oscil</em></a> <a href="#optional-key">&amp;optional-key</a> (<i>frequency</i> 440.0) (<i>initial-phase</i> 0.0)
  <a name="oscil"><em class=def>oscil</em></a> <i>os</i> &amp;optional (<i>fm-input</i> 0.0) (<i>pm-input</i> 0.0)
  <a name="oscil?"><em class=def>oscil?</em></a> <i>os</i>
  <a name="oscilbank"><em class=def>oscil-bank</em></a> <i>amps oscils fms len</i> 
</pre>

<p><b>Oscil</b> produces a sine wave with optional frequency change (i.e. fm).
Its first argument is an oscil created by <b>make-oscil</b>.
Oscil's second (optional) argument is the current (sample-wise)
frequency change (defaults to 0).  Its third argument is the (sample-wise)
phase change (in addition to the carrier increment and so on).  See <a href="fm.html">fm.html</a> for a
discussion of fm.</p>

<table border align=left hspace=40>
<tr><td colspan=2><center>oscil methods</center></tr>
<tr><td><em class=gen>mus-frequency</em><td>frequency in Hz</tr>
<tr><td><em class=gen>mus-phase</em><td>phase in radians</tr>
<tr><td><em class=gen>mus-cosines</em><td>1 (no setf)</tr>
</table>
<pre><small>
  (prog1
    (sin (+ phase pm-input))
    (incf phase (+ (hz-&gt;radians frequency) fm-input)))
</small></pre>
<br clear=left>

<pre><small>
(definstrument simple-fm (beg end freq amp mc-ratio index
             &amp;optional (amp-env '(0 0 50 1 100 1)) (index-env '(0 1 100 1)))
  (let* ((cr (<em class=red>make-oscil</em> freq))
         (md (<em class=red>make-oscil</em> (* freq mc-ratio)))
         (fm-index (hz-&gt;radians (* index mc-ratio freq)))
         (ampf (make-env amp-env amp :start beg :end end))
         (indf (make-env index-env fm-index :start beg :end end)))
    (run
      (loop for i from beg below end do
        (outa i (* (env ampf) (<em class=red>oscil</em> cr (* (env indf) (<em class=red>oscil</em> md)))))))))
</small></pre>
<br>

<!-- TOPIC envelope -->
<!-- INDEX envelopes:Envelopes --><a name="envelopes"></a>
<span class=cbox><h4>ENV</h4></span>

<pre>
  <a name="make-env"><em class=def>make-env</em></a> <a href="#optional-key">&amp;optional-key</a> 
      <i>envelope</i>      ; list of x,y break-point pairs
      (<i>scaler</i> 1.0)  ; scaler on every y value (before offset is added)
      <i>duration</i>      ; seconds
      (<i>offset</i> 0.0)  ; value added to every y value
      <i>base</i>          ; type of connecting line between break-points
      <i>end</i>           ; (- end start) =&gt; duration in samples (can be used instead of <i>duration</i>
      (<i>start</i> 0)     ; can be used in conjunction with <i>end</i>
  <a name="env"><em class=def>env</em></a> <i>e</i>
  <a name="env?"><em class=def>env?</em></a> <i>e</i>
  <a name="restart-env"><em class=def>restart-env</em></a> <i>e</i>     ; return to start of envelope
  <a name="env-interp"><em class=def>env-interp</em></a> <i>x env</i> &amp;optional (<i>base</i> 1.0)
  <a name="envelope-interp"><em class=def>envelope-interp</em></a> <i>x envelope</i> &amp;optional (<i>base</i> 1.0)
</pre>

<table border>
<tr><td colspan=2><center>env methods</center></tr>
<tr><td><em class=gen>mus-location</em><td>call counter value (number of calls so far on <i>env</i>)</tr>
</table>

<p>An envelope is a list of break point pairs:  '(0 0 100 1)  is
a ramp from 0 to 1 over an x-axis excursion from 0 to 100.  This list is passed
to <b>make-env</b> along with the scaler
applied to the y axis, the offset added to every y value,
and optionally the desired start and end times.  The resulting
object, when accessed with the <b>env</b> generator, creates an envelope of the
same shape as the original, but stretched along the x-axis to fit
the duration, and transformed along the y-axis by <i>offset</i>
+ <i>scaler</i> * y-value.
The kind of interpolation used to get y-values between the break
points is determined by the envelope's <i>base</i>.  
</p>

<p>Make-env produces a structure that env can handle at run-time.
Each call on env gets the next value of the envelope.
With the arguments to make-env, you can apply a given shape to any
situtation.  Say we want  a ramp moving from .3 to .5 over 1 second.
The corresponding make-env call would be</p>
<pre>
  (make-env :envelope '(0 0 100 1) :scaler .2 :offset .3 :duration 1.0)
</pre>
<p><i>Base</i> determines how the break-points are connected.  If it is 1.0 (the
default), you get straight line segments.  <i>Base</i> = 0.0 gives a step
function (the envelope changes its value suddenly to the new one without any
interpolation).  Any other positive value becomes the exponent of the exponential curve
connecting the points (for an explicit example see env.lisp).  <i>Base</i> &lt; 1.0 gives convex curves (i.e. bowed
out), and <i>Base</i> &gt; 1.0 gives concave curves (i.e. sagging).
To get arbitrary connecting curves between the break points, treat
the output of env as input to the connecting function.  Here's an
example that maps the line segments into sin x^3:
</p>
<pre><small>
(definstrument mapenv (beg dur frq amp en)
  (let* ((bg (floor (* beg *srate*)))
	 (nd (+ bg (floor (* dur *srate*))))
	 (o (make-oscil frq))
         (half-pi (* pi 0.5))
	 (zv (<em class=red>make-env</em> en 1.0 dur)))
    (run
     (loop for i from bg below nd do
       (let ((zval (<em class=red>env</em> zv))) ;zval^3 is [0.0..1.0], as is sin between 0 and half-pi.
	 (outa i (* amp (sin (* half-pi zval zval zval)) (oscil o))))))))

(with-sound () (mapenv 0 1 440 .4 '(0 0 50 1 75 0 86 .5 100 0)))
</small></pre>
<p>Or create your own generator that traces out the curve you want.  For
example, J.C.Risset's bell curve could be:</p>
<pre><small>
(defmacro bell-curve (x)
  ;; x from 0.0 to 1.0 creates bell curve between .64e-4 and nearly 1.0
  ;; if x goes on from there, you get more bell curves; x can be
  ;; an envelope (a ramp from 0 to 1 if you want just a bell curve)
  `(+ .64e-4 (* .1565 (- (exp (- 1.0 (cos (* two-pi ,x)))) 1.0))))
</small></pre>
<p><b>Restart-env</b> causes an
envelope to start all over again from the beginning. To jump to any position in
an envelope, use <a href="#mus-location">mus-location</a> (there's an example
of this in ug.ins).</p>
<pre><small>
(definstrument restartable-simp (beg dur env-dur)
  (let* ((os (make-oscil))
	 (en (make-env '(0 0 50 1 100 0) :end env-dur :scaler .1))
	 (j beg)
	 (env-stop (+ beg env-dur)))
    (run
     (loop for i from beg below (+ beg dur) do 
       (let ((val (* (env en) (oscil os))))
	 (incf j)
	 (when (&gt; j env-stop)
	   (incf env-stop env-dur)
	   (<em class=red>restart-env</em> en))
	 (outa i val))))))
</small></pre><br>

<p>env-interp and envelope-interp return the value of the envelope at some point
on the x axis; env-interp operates on an 'env' (the output of make-env), whereas
envelope-interp operates on an 'envelope' (a list of breakpoints).
For example, to get weighted random numbers, use the output of
random(100.0) as the lookup index into an envelope whose x axis goes
from 0 to 100.  Then the envelope y values are the numbers returned,
and the amount of the x-axis taken by a given value is its weight.
Say we want 40% .5, and 60% 1.0,
</p><pre>
(loop for i from 0 to 10 collect 
  (envelope-interp (list 0 .5 40 .5 40.01 1.0 100 1.0) (random 100.0))
=&gt; '(1.0 1.0 0.5 1.0 1.0 0.5 0.5 1.0 0.5 1.0 1.0) 
</pre>

<p>Other related functions are:</p>
<pre>
  <a name="envelope-reverse"><em class=def>envelope-reverse</em></a> <i>e</i>                         reverse an envelope
  <a name="envelope-repeat"><em class=def>envelope-repeat</em></a> <i>e num</i> &amp;optional <i>refl xnorm</i> repeat an envelope
  <a name="envelope-concatenate"><em class=def>envelope-concatenate</em></a> &amp;rest <i>es</i>              concatenate any number of envelopes
  <a name="envelope+"><em class=def>envelope+</em></a> <i>es</i>                               add together any number of envelopes
  <a name="envelope*"><em class=def>envelope*</em></a> <i>es</i>                               same but multiply
  <a name="envelope-simplify"><em class=def>envelope-simplify</em></a> <i>e</i> &amp;optional <i>yg xg</i>        simplify an evelope
  <a name="meld-envelopes"><em class=def>meld-envelopes</em></a> <i>e0 e1</i>                       meld two envelopes together
  <a name="map-across-envelopes"><em class=def>map-across-envelopes</em></a> <i>func es</i>               map a function across any number of envelopes
  <a name="envelope-exp"><em class=def>envelope-exp</em></a>  <i>e</i> &amp;optional <i>pow xg</i>           create exponential segments of envelopes
  <a name="window-envelope"><em class=def>window-envelope</em></a> <i>beg end e</i>                  return portion of e between two x values
  <a name="stretch-envelope"><em class=def>stretch-envelope</em></a> <i>e a0 a1</i> &amp;optional <i>d0 d1</i>   attack and decay portions
  <a name="scale-envelope"><em class=def>scale-envelope</em></a> <i>e scale</i> &amp;optional <i>offset</i>    scale e
  <a name="normalize-envelope"><em class=def>normalize-envelope</em></a> <i>e</i> &amp;optional <i>norm</i>        normalize e
</pre>
<p>See env.lisp for more such functions.</p>
<br>


<!-- TOPIC table-lookup -->
<span class=cbox><h4>TABLE-LOOKUP</h4></span>

<pre>
  <a name="make-table-lookup"><em class=def>make-table-lookup</em></a> <a href="#optional-key">&amp;optional-key</a> 
        (<i>frequency</i> 440.0)   ; in Hz
        (<i>initial-phase</i> 0.0) ; in radians 
        <i>wave</i>                ; double-float array
  <a name="table-lookup"><em class=def>table-lookup</em></a> <i>tl</i> &amp;optional (<i>fm-input</i> 0.0)
  <a name="table-lookup?"><em class=def>table-lookup?</em></a> <i>tl</i>
</pre>

<p><b>Table-lookup</b> performs interpolating table lookup.  Indices are first
made to fit in the current table (fm input can produce negative indices), then
linear interpolation returns the table value.  Table-lookup scales its
frequency change argument (<i>fm-input</i>) to fit whatever its table size is
(that is, it assumes the caller is thinking in terms of a table size of two pi,
and fixes it up).  The wave table should be an array of double-floats (the function
make-double-float-array can be used to create it).</p>
<br>

<table border align=left hspace=40>
<tr><td colspan=2><center>table-lookup methods</center></tr>
<tr><td><em class=gen>mus-frequency</em><td>frequency in Hz</tr>
<tr><td><em class=gen>mus-phase</em><td>phase in radians (wave-size/(2*pi))</tr>
<tr><td><em class=gen>mus-data</em><td>wave array</tr>
<tr><td><em class=gen>mus-length</em><td>wave size (no setf)</tr>
</table>
<pre><small>
(prog1
  (array-interp wave phase)
  (incf phase (+ (hz-&gt;radians frequency) 
                 (* fm-input 
                    (/ (length wave) 
                       (* 2 pi))))))
</small></pre><br clear=left>
<br>
<p>There are two functions that make it easier to load up
various wave forms:</p>
<pre>
 <a name="partials-&gt;wave"><em class=def>partials-&gt;wave</em></a> <i>synth-data</i> <i>table</i> &amp;optional (<i>norm</i> t)
 <a name="phase-partials-&gt;wave"><em class=def>phase-partials-&gt;wave</em></a> <i>synth-data</i> <i>table</i> &amp;optional (<i>norm</i> t)
</pre>
<p>The <i>synth-data</i> argument is a list of (partial amp) pairs: '(1 .5 2 .25)
gives a combination of a sine wave at the carrier (1) at amplitude .5, and
another at the first harmonic (2) at amplitude .25.  The partial amplitudes are
normalized to sum to a total amplitude of 1.0 unless the argument <i>norm</i>
is nil.  If the initial phases matter (they almost never do), you can use
phase-partials-&gt;wave; in this case the <i>synth-data</i> is a list of (partial amp phase) triples with phases in radians.</p>
<pre><small>
(definstrument simp (dur)
  (let ((hi (<em class=red>make-table-lookup</em> :wave (<em class=red>partials-&gt;wave</em> '(1 .5 2 .5)))))
    (run
     (loop for i from 0 to dur do
       (outa i (* .3 (<em class=red>table-lookup</em> hi)))))))
</small></pre>
<p><a href="spectr.clm">spectr.clm</a> has a steady state spectra of
several standard orchestral instruments, courtesy of James A. Moorer.
<a href="bird.clm">bird.clm</a> (using bird.ins and bigbird.ins) has about 50 North American bird songs. </p>
<br>

<!-- TOPIC waveshape -->
<span class=cbox><h4>WAVESHAPE</h4></span>
<pre>
  <a name="make-waveshape"><em class=def>make-waveshape</em></a> <a href="#optional-key">&amp;optional-key</a> (<i>frequency</i> 440.0) (<i>partials</i> '(1 1)) <i>wave</i>
  <a name="waveshape"><em class=def>waveshape</em></a> <i>w</i> &amp;optional (<i>index</i> 1.0) (<i>fm</i> 0.0)
  <a name="waveshape?"><em class=def>waveshape?</em></a> <i>w</i>

  <a name="partials-&gt;waveshape"><em class=def>partials-&gt;waveshape</em></a> <a href="#optional-key">&amp;optional-key</a> <i>partials</i> (<i>norm</i> t) (<i>size</i> *clm-table-size*)
  <a name="partials-&gt;polynomial"><em class=def>partials-&gt;polynomial</em></a> <i>partials</i> &amp;optional (<i>kind</i> 1)
</pre>

<p><b>Waveshape</b> performs waveshaping; see
"Digital Waveshaping Synthesis" by Marc Le Brun in JAES 1979 April, vol 27, no
4, p250. </p>

<table border align=left hspace=40>
<tr><td colspan=2><center>waveshape methods</center></tr>
<tr><td><em class=gen>mus-frequency</em><td>frequency in Hz</tr>
<tr><td><em class=gen>mus-phase</em><td>phase in radians</tr>
<tr><td><em class=gen>mus-data</em><td>wave array (no setf)</tr>
<tr><td><em class=gen>mus-length</em><td>wave size (no setf)</tr>
</table>
<pre><small>
(prog1
  (array-interp wave (* (length wave) 
                        (+ 0.5 (* index 0.5 (sin phase)))))
  (incf phase (+ (hz-&gt;radians frequency) fm)))
</small></pre>
<br clear=left>
<br>
<pre><small>
(definstrument simp ()
  (let ((wav (<em class=red>make-waveshape</em> :frequency 440 :partials '(1 .5 2 .3 3 .2))))
    (run (loop for i from 0 to 1000 do (outa i (<em class=red>waveshape</em> wav))))))
</small></pre>
<p>See <a href="#bigbird">bigbird</a> below for an example of partials-&gt;polynomial, and
<a href="pqw.ins">pqw.ins</a> for an example of phase quadrature waveshaping.
Partials-&gt;polynomial takes a list of harmonic amplitudes and
returns a list of Chebychev polynomial coefficients.  The argument <i>kind</i>
determines which kind of Chebychev polynomial we are interested in.</p>
<br>


<!-- TOPIC sawtooth-wave -->
<span class=cbox><h4>SAWTOOTH-WAVE, TRIANGLE-WAVE, PULSE-TRAIN, SQUARE-WAVE</h4></span>

<pre>
  <a name="make-triangle-wave"><em class=def>make-triangle-wave</em></a> <a href="#optional-key">&amp;optional-key</a> (<i>frequency</i> 440.0) (<i>amplitude</i> 1.0) (<i>initial-phase</i> pi)
  <a name="triangle-wave"><em class=def>triangle-wave</em></a> <i>s</i> &amp;optional (<i>fm</i> 0.0)
  <a name="triangle-wave?"><em class=def>triangle-wave?</em></a> <i>s</i>

  <a name="make-square-wave"><em class=def>make-square-wave</em></a> <a href="#optional-key">&amp;optional-key</a> (<i>frequency</i> 440.0) (<i>amplitude</i> 1.0) (<i>initial-phase</i> 0)
  <a name="square-wave"><em class=def>square-wave</em></a> <i>s</i> &amp;optional (<i>fm</i>  0.0)
  <a name="square-wave?"><em class=def>square-wave?</em></a> <i>s</i>

  <a name="make-sawtooth-wave"><em class=def>make-sawtooth-wave</em></a> <a href="#optional-key">&amp;optional-key</a> (<i>frequency</i> 440.0) (<i>amplitude</i> 1.0) (<i>initial-phase</i> pi)
  <a name="sawtooth-wave"><em class=def>sawtooth-wave</em></a> <i>s</i> &amp;optional (<i>fm</i> 0.0)
  <a name="sawtooth-wave?"><em class=def>sawtooth-wave?</em></a> <i>s</i>

  <a name="make-pulse-train"><em class=def>make-pulse-train</em></a> <a href="#optional-key">&amp;optional-key</a> (<i>frequency</i> 440.0) (<i>amplitude</i> 1.0) (<i>initial-phase</i> two-pi)
  <a name="pulse-train"><em class=def>pulse-train</em></a> <i>s</i> &amp;optional (<i>fm</i> 0.0)
  <a name="pulse-train?"><em class=def>pulse-train?</em></a> <i>s</i>
</pre>

<p>These generators produce some occasionally useful wave forms.
<b>Sawtooth-wave</b> ramps from -1 to 1, then goes immediately back to -1.
<b>Triangle-wave</b> ramps from -1 to 1, then ramps from 1 to -1.
<b>Pulse-train</b> produces a single sample of 1.0, then zeros.
<b>Square-wave</b> produces 1 for half a period, then 0.  All have a "period"
of two-pi, so the <i>fm</i> argument should have an effect comparable to the
same fm applied to the same waveform in <a href="#table-lookup">table-lookup</a>.</p>

<table border align=left hspace=40>
<tr><td colspan=2><center>saw-tooth and friends' methods</center></tr>
<tr><td><em class=gen>mus-frequency</em><td>frequency in Hz</tr>
<tr><td><em class=gen>mus-phase</em><td>phase in radians</tr>
<tr><td><em class=gen>mus-scaler</em><td>amplitude arg used in make-&lt;gen&gt;</tr>
</table>
<pre><small>
One popular kind of vibrato is:
  (+ (triangle-wave pervib) 
     (rand-interp ranvib))
</small></pre><br clear=left>
<br>

<!-- TOPIC sum-of-cosines -->
<span class=cbox><h4>SUM-OF-COSINES</h4></span>
<pre>
  <a name="make-sum-of-cosines"><em class=def>make-sum-of-cosines</em></a> <a href="#optional-key">&amp;optional-key</a> 
        (<i>cosines</i> 1) (<i>frequency</i> 440.0) (<i>initial-phase</i> 0.0)
  <a name="sum-of-cosines"><em class=def>sum-of-cosines</em></a> <i>cs</i> &amp;optional (<i>fm</i> 0.0)
  <a name="sum-of-cosines?"><em class=def>sum-of-cosines?</em></a> <i>cs</i>
</pre>
<p><b>Sum-of-cosines</b> produces a band-limited pulse train containing
<i>cosines</i> cosines.</p>
<table border align=left hspace=40>
<tr><td colspan=2><center>sum-of-cosines methods</center></tr>
<tr><td><em class=gen>mus-frequency</em><td>frequency in Hz</tr>
<tr><td><em class=gen>mus-phase</em><td>phase in radians</tr>
<tr><td><em class=gen>mus-scaler</em><td>(/ 1.0 (+ 1 (* 2 cosines)))</tr>
<tr><td><em class=gen>mus-cosines</em><td>cosines arg  used in make-&lt;gen&gt; (no setf)</tr>
<tr><td><em class=gen>mus-length</em><td>same as mus-cosines</tr>
</table>
<pre><small>
based on:
  1 + 2(cos(x) + cos(2x) + ... cos(nx)) = 
    sin((n+.5)x) / sin(x/2)
</small></pre><br clear=left>
<br>

<!-- TOPIC wave-train -->
<span class=cbox><h4>WAVE-TRAIN</h4></span>
<pre>
  <a name="make-wave-train"><em class=def>make-wave-train</em></a> <a href="#optional-key">&amp;optional-key</a> (<i>frequency</i> 440.0) (<i>initial-phase</i> 0.0) <i>wave</i>
  <a name="wave-train"><em class=def>wave-train</em></a> <i>w</i> &amp;optional (<i>fm</i> 0.0)
  <a name="wave-train?"><em class=def>wave-train?</em></a> <i>w</i>
</pre>

<p><b>Wave-train</b> produces a wave train (an extension of pulse-train).
<i>Frequency</i> is the repetition rate of the wave found in <i>wave</i>.
Successive waves can overlap.  With some simple envelopes, or filters, you can
use this for VOSIM and other related techniques.</p>

<table border>
<tr><td colspan=2><center>wave-train methods</center></tr>
<tr><td><em class=gen>mus-frequency</em><td>frequency in Hz</tr>
<tr><td><em class=gen>mus-phase</em><td>phase in radians</tr>
<tr><td><em class=gen>mus-data</em><td>wave array (no setf)</tr>
<tr><td><em class=gen>mus-length</em><td>length of wave array (no setf)</tr>
</table>

<pre><small>
;;; FOF instrument based loosely on fof.c of Perry Cook and the article
;;;   "Synthesis of the Singing Voice" by Bennett and Rodet in 
;;;   "Current Directions in Computer Music Research"

(definstrument fofins (beg dur frq amp vib f0 a0 f1 a1 f2 a2 &amp;optional ve ae)
  (let* ((start (floor (* beg *srate*)))
         (end (+ start (floor (* dur *srate*))))
         (ampf (make-env :envelope (or ae (list 0 0 25 1 75 1 100 0)) amp dur))
         (frq0 (hz-&gt;radians f0))
         (frq1 (hz-&gt;radians f1))
         (frq2 (hz-&gt;radians f2))
         (foflen (if (= *srate* 22050) 100 200))
         (vibr (make-oscil :frequency 6))
	 (vibenv (make-env :envelope (or ve (list 0 1 100 1)) vib dur))
         (win-freq (/ two-pi foflen))
         (foftab (make-double-float-array foflen))
         (wt0 (<em class=red>make-wave-train</em> :wave foftab :frequency frq)))
    (loop for i from 0 below foflen do
      (setf (aref foftab i) (double-float      
        ;; this is not the pulse shape used by B&amp;R
            (* (+ (* a0 (sin (* i frq0))) 
                  (* a1 (sin (* i frq1))) 
                  (* a2 (sin (* i frq2)))) 
               .5 (- 1.0 (cos (* i win-freq)))))))
    (run
     (loop for i from start below end do
       (outa i (* (env ampf) (<em class=red>wave-train</em> wt0 (* (env vibenv) (oscil vibr)))))))))

(with-sound () (fofins 0 1 270 .2 .001 730 .6 1090 .3 2440 .1)) ;"Ahh"

(with-sound () 
  (fofins 0 4 270 .2 0.005 730 .6 1090 .3 2440 .1 '(0 0 40 0 75 .2 100 1) 
          '(0 0 .5 1 3 .5 10 .2 20 .1 50 .1 60 .2 85 1 100 0))
  (fofins 0 4 (* 6/5 540) .2 0.005 730 .6 1090 .3 2440 .1 '(0 0 40 0 75 .2 100 1) 
          '(0 0 .5 .5 3 .25 6 .1 10 .1 50 .1 60 .2 85 1 100 0))
  (fofins 0 4 135 .2 0.005 730 .6 1090 .3 2440 .1 '(0 0 40 0 75 .2 100 1) 
          '(0 0 1 3 3 1 6 .2 10 .1 50 .1 60 .2 85 1 100 0)))
</small></pre>

<br>

<!-- TOPIC rand -->
<!-- INDEX random-numbers:Random numbers --><a name="random-numbers"></a>
<span class=cbox><h4>RAND, RAND-INTERP</h4></span>

<pre>
  <a name="make-rand"><em class=def>make-rand</em></a> <a href="#optional-key">&amp;optional-key</a> 
        (<i>frequency</i> 440.0) ;freq at which new random numbers occur
        (<i>amplitude</i> 1.0)   ;numbers are between -amplitude and amplitude
  <a name="rand"><em class=def>rand</em></a> <i>r</i> &amp;optional (<i>sweep</i> 0.0)
  <a name="rand?"><em class=def>rand?</em></a> <i>r</i>
  <a name="make-rand-interp"><em class=def>make-rand-interp</em></a> <a href="#optional-key">&amp;optional-key</a> (<i>frequency</i> 440.0) (<i>amplitude</i> 1.0)
  <a name="rand-interp"><em class=def>rand-interp</em></a> <i>r</i> &amp;optional (<i>sweep</i> 0.0)
  <a name="rand-interp?"><em class=def>rand-interp?</em></a> <i>r</i>
  <a name="centered-random"><em class=def>centered-random</em></a> <i>amp</i> 
  <a name="clm-random"><em class=def>clm-random</em></a> <i>amp</i>
  <a name="mus-random"><em class=def>mus-random</em></a> <i>amp</i> ;same as centered-random (for C-side compatibility)
  <a name="mus-set-rand-seed"><em class=def>mus-set-rand-seed</em></a> <i>seed</i>
</pre>
<p><b>Rand</b> returns a sequence of random numbers between -amplitude and
amplitude (it produces a sort of step function.
<b>Rand-Interp</b> interpolates between successive
random numbers. Lisp's function <i>random</i> returns a number between 0.0 and its argument.
<b>Centered-random</b> returns a number between -<i>amp</i> and <i>amp</i>.
<b>Clm-random</b> returns a random number between 0 and <i>amp</i>. In the latter two cases,
<i>mus-set-rand-seed</i> sets the seed for the random number generator.  This provides a
way around Lisp's clumsy mechanism for repeating a random number sequence.
</p>

<table border align=left hspace=40>
<tr><td colspan=2><center>rand and rand-interp methods</center></tr>
<tr><td><em class=gen>mus-frequency</em><td>frequency in Hz</tr>
<tr><td><em class=gen>mus-phase</em><td>phase in radians</tr>
<tr><td><em class=gen>mus-scaler</em><td>amplitude arg used in make-&lt;gen&gt;</tr>
</table>
<pre><small>
rand:
  (if (>= phase (* 2 pi))
      (setf output (centered-random amplitude))
  (incf phase (+ (hz-&gt;radians frequency) sweep))
</small></pre>
<br clear=left>
<br>

<p>The "central-limit theorem" says that you can get closer and closer to gaussian
noise simply by adding rand's together.  Orfanidis in 
"Introduction to Signal Processing" says 12 calls on rand will
do perfectly well.  We could define our own generator:
</p><pre><small>
(defmacro gaussian-noise (r)
  ;; r=a rand generator allocated via make-rand
  `(let ((val 0.0))
     (dotimes (i 12) (incf val (rand ,r)))
     val))
</small></pre>
<p>For a discussion of the central limit theorem, see
Korner "Fourier Analysis".
Orfanidis also mentions a clever way to get reasonably good 1/f noise:
sum together n rand's, where each rand is running an octave slower
than the preceding:
</p>
<pre><small>
(defun make-1f-noise (n)
  ;; returns an array of rand's ready for the 1f-noise generator
  (let ((rans (make-array n)))
    (dotimes (i n) (setf (aref rans i) (make-rand :frequency (/ *srate* (expt 2 i)))))
    rans))

(defmacro 1f-noise (rans)
  `(let ((val 0.0)
         (len (length ,rans)))
     (dotimes (i len) (incf val (rand (aref ,rans i))))
     (/ val len)))
</small></pre>
<p>See also <a href="green.cl">green.cl</a> (bounded brownian noise that can mimic 1/f noise in some cases).
And we can't talk about noise without an example of fractals:</p>
<pre><small>
(definstrument fractal (start duration m x amp)
  ;; use formula of M J Feigenbaum
  (let* ((beg (floor (* *srate* start)))
	 (end (+ beg (floor (* *srate* duration)))))
    (run
     (loop for i from beg below end do
       (outa i (* amp x))
       (setf x (- 1.0 (* m x x)))))))

;;; quickly reaches a stable point for any m in[0,.75], so:
(with-sound () (fractal 0 1 .5 0 .5)) 
;;; is just a short "ftt"
(with-sound () (fractal 0 1 1.5 .20 .2))
</small></pre>
<p>With this instrument you can easily hear
the change over from the stable equilibria, to the period doublings,
and finally into the combination of noise and periodicity that
has made these curves famous. See appendix 2 to Ekeland's "Mathematics and the Unexpected" for more details.
Another instrument based on similar ideas is:</p>
<pre><small>
(definstrument attract (beg dur amp c) ;c from 1 to 10 or so
  ;; by James McCartney, from CMJ vol 21 no 3 p 6
  (let* ((st (floor (* beg *srate*)))
	 (nd (+ st (floor (* dur *srate*))))
	 (a .2) (b .2) (dt .04)
	 (scale (/ (* .5 amp) c))
	 (x1 0.0) (x -1.0) (y 0.0) (z 0.0))
    (run
     (loop for i from st below nd do
       (setf x1 (- x (* dt (+ y z))))
       (incf y (* dt (+ x (* a y))))
       (incf z (* dt (- (+ b (* x z)) (* c z))))
       (setf x x1)
       (outa i (* scale x))))))
</small></pre>
<p>which gives brass-like sounds!
</p>
<br>

<!-- TOPIC one-pole -->
<!-- INDEX filters:Filters --><a name="filters"></a>
<span class=cbox><h4>ONE-POLE, ONE-ZERO, TWO-POLE, TWO-ZERO</h4></span>

<pre>
   <a name="make-one-pole"><em class=def>make-one-pole</em></a> <a href="#optional-key">&amp;optional-key</a> <i>a0</i> <i>b1</i>    ; <i>b1</i> &lt; 0.0 gives lowpass, <i>b1</i> &gt; 0.0 gives highpass
   <a name="one-pole"><em class=def>one-pole</em></a> <i>f</i> <i>input</i> 
   <a name="one-pole?"><em class=def>one-pole?</em></a> <i>f</i>

   <a name="make-one-zero"><em class=def>make-one-zero</em></a> <a href="#optional-key">&amp;optional-key</a> <i>a0</i> <i>a1</i>    ; <i>a1</i> &gt; 0.0 gives weak lowpass, <i>a1</i> &lt; 0.0 highpass
   <a name="one-zero"><em class=def>one-zero</em></a> <i>f</i> <i>input</i> 
   <a name="one-zero?"><em class=def>one-zero?</em></a> <i>f</i>

   <a name="make-two-pole"><em class=def>make-two-pole</em></a> <a href="#optional-key">&amp;optional-key</a> <i>a0</i> <i>b1</i> <i>b2</i>
   <a name="two-pole"><em class=def>two-pole</em></a> <i>f</i> <i>input</i> 
   <a name="two-pole?"><em class=def>two-pole?</em></a> <i>f</i>

   <a name="make-two-zero"><em class=def>make-two-zero</em></a> <a href="#optional-key">&amp;optional-key</a> <i>a0</i> <i>a1</i> <i>a2</i>
   <a name="two-zero"><em class=def>two-zero</em></a> <i>f</i> <i>input</i> 
   <a name="two-zero?"><em class=def>two-zero?</em></a> <i>f</i>

   <a name="make-zpolar"><em class=def>make-zpolar</em></a> <i>radius frequency</i>
   <a name="make-ppolar"><em class=def>make-ppolar</em></a> <i>radius frequency</i>
</pre>

<table border align=left hspace=20>
<tr><td colspan=2><center>simple filter methods</center></tr>
<tr><td><em class=gen>mus-a0</em><td>a0 in equations</tr>
<tr><td><em class=gen>mus-a1</em><td>a1 in equations</tr>
<tr><td><em class=gen>mus-a2</em><td>a2 in equations</tr>
<tr><td><em class=gen>mus-b1</em><td>b1 in equations</tr>
<tr><td><em class=gen>mus-b2</em><td>b2 in equations</tr>
<tr><td><em class=gen>mus-x1</em><td>x(n-1) in equations</tr>
<tr><td><em class=gen>mus-x2</em><td>x(n-2) in equations</tr>
<tr><td><em class=gen>mus-y1</em><td>y(n-1) in equations</tr>
<tr><td><em class=gen>mus-y2</em><td>y(n-2) in equations</tr>
<tr><td><em class=gen>mus-order</em><td>1 or 2 (no setf)</tr>
</table>
<pre>
one-zero  y(n) = a0 x(n) + a1 x(n-1)
one-pole  y(n) = a0 x(n) - b1 y(n-1)
two-pole  y(n) = a0 x(n) - b1 y(n-1) - b2 y(n-2)
two-zero  y(n) = a0 x(n) + a1 x(n-1) + a2 x(n-2)
</pre>
<p>
This nomenclature is taken from Julius Smith's "An Introduction to Digital
Filter Theory" in Strawn "Digital Audio Signal Processing", and is different
from that used in the more general filters such as <a href="#fir-filter">FIR-filter</a>.
</p><br clear=left>
<br>
<p>In <b>make-ppolar</b> ("poles polar") you can specify the radius and angle of a
pole while <a href="#make-two-pole">make-two-pole</a> requires actual filter coefficients.  The filter
provided by make-ppolar has two poles, one at (<i>radius,frequency</i>), the other at
(<i>radius</i>,-<i>frequency</i>).  <i>Radius</i> is between 0 and 1 (but less than 1), and
<i>frequency</i> is between 0 and srate/2.  This is the standard resonator form with
poles specified by the polar coordinates of one pole.  Similar remarks apply to
<a href="#make-two-zero">make-two-zero</a> and <b>make-zpolar</b>.  Use two-pole
in conjunction with make-ppolar.</p>
<br>


<!-- TOPIC formant -->
<span class=cbox><h4>FORMANT</h4></span>

<pre>
  <a name="make-formant"><em class=def>make-formant</em></a> <a href="#optional-key">&amp;optional-key</a> <i>radius</i> <i>frequency</i> (<i>gain</i> 1.0)
  <a name="formant"><em class=def>formant</em></a> <i>f</i> <i>input</i>       ; resonator centered at <i>frequency</i>, bandwidth set by <i>r</i>
  <a name="formant?"><em class=def>formant?</em></a> <i>f</i>
</pre>

<table border align=left hspace=20>
<tr><td colspan=2><center>simple filter methods</center></tr>
<tr><td><em class=gen>mus-a0</em><td>a0 in equations</tr>
<tr><td><em class=gen>mus-a1</em><td>0.0 (no setf)</tr>
<tr><td><em class=gen>mus-a2</em><td>a2 in equations</tr>
<tr><td><em class=gen>mus-b1</em><td>b1 in equations</tr>
<tr><td><em class=gen>mus-b2</em><td>b2 in equations</tr>
<tr><td><em class=gen>mus-x1</em><td>x(n-1) in equations</tr>
<tr><td><em class=gen>mus-x2</em><td>x(n-2) in equations</tr>
<tr><td><em class=gen>mus-y1</em><td>y(n-1) in equations</tr>
<tr><td><em class=gen>mus-y2</em><td>y(n-2) in equations</tr>
<tr><td><em class=gen>mus-formant-radius</em><td>formant radius</tr>
<tr><td><em class=gen>mus-frequency</em><td>formant center frequency</tr>
<tr><td><em class=gen>mus-order</em><td>2 (no setf)</tr>
</table>

<pre><small>
y(n) = x(n) - 
       r*x(n-2) + 
       2*r*cos(2*pi*frequency/srate)*y(n-1) - 
       r*r*y(n-2)
</small></pre>
<br clear=left><br>

<p>
<p><b>Formant</b> is recommended for resonators (simple bandpass filters), vocal
tract or instrument cavity simulations, etc.  It provides bandpass
filtering (a simple resonance) using a two-pole and a two-zero filter, as
described above. 
Only one
coefficient need be changed in order to move the filter center frequency.  The
filter coefficients are set as a function of desired pole-radius <i>radius</i> (set
by desired bandwidth from radius=1-bw/2), center frequency <i>frequency</i>, and peak gain <i>gain</i>. 
To change the frequency in the run loop use (setf (mus-frequency f) freq).  The radius
is the field (mus-formant-radius) which can be set at run time using (setf (mus-formant-radius f) val).
For details see "A Constant-gain Digital Resonator Tuned By a Single Coefficient" by Julius
O. Smith and James B. Angell in Computer Music Journal Vol. 6 No. 4 (winter
1982). There radius ~= e^(-pi*Bw*T) where Bw is the bandwidth in Hz and T is
the sampling period (1/sampling-rate); also "A note on
Constant-Gain Digital Resonators" by Ken Steiglitz, CMJ vol 18 No. 4 pp.8-10
(winter 1994).  The bandwidth can be specified in the run loop in Hz
by using a macro such as:</p>
<pre>
  (defmacro compute-radius (bw) ; bw in Hz
    `(exp (/ (* (- pi) ,bw) *srate*)))
</pre>
<p>The <i>gain</i> argument to make-formant is not used directly; it becomes
<i>gain</i> * (1 - radius) or some variation thereof (see make-formant in mus.lisp).
When you set the mus-formant-radius in the run-loop, the gain is also adjusted.
We can use a bank of formant generators to implement a graphic equalizer,
but consider doing cross-synthesis with an equalizer of 128 channels driven
at the sampling rate by a spectral analyzer:</p>
<!-- INDEX cross-synthesis:cross synthesis -->
<pre><small>
(definstrument <a name="cross-synthesis">cross-synthesis</a> (beg dur file1 file2 amp &amp;optional (fftsize 128) (r two-pi) (lo 2) (hi nil))
  ;; file1: input sound, file2: gives spectral shape
  ;; r: controls width of formants (1.0 is another good value here)
  ;; lo and hi: which of the formants are active (a sort of filter on top of the filter)
  ;; we use the on-going spectrum of file2 to scale the outputs of the formant array
  (let* ((fil1 (open-input* file1))
	 (fil2 (and fil1 (open-input* file2))))
    (when fil1
      (if (not fil2)
          (close-input fil1)
        (unwind-protect
	  (let* ((start (floor (* beg *srate*)))
	         (end (+ start (floor (* dur *srate*))))
	         (freq-inc (floor fftsize 2))
	         (fdr (make-double-float-array fftsize))
	         (fdi (make-double-float-array fftsize))
	         (diffs (make-double-float-array freq-inc))
	         (spectrum (make-double-float-array freq-inc))
	         (filptr 0)
	         (ctr freq-inc)
	         (radius (- 1.0 (/ r fftsize)))
	         (bin (float (/ *srate* fftsize)))
	         (fs (make-array freq-inc)))
	    (if (null hi) (setf hi freq-inc))
	    (loop for k from lo below hi do 
              (setf (aref fs k) (<em class=red>make-formant</em> radius (* k bin))))
	    (run
	     (loop for i from start below end do
	       (when (= ctr freq-inc)
	         (dotimes (k fftsize)
		   (setf (aref fdr k) (ina filptr fil2))
		   (incf filptr))
	         (clear-array fdi)
	         (decf filptr freq-inc)
	         (fft fdr fdi fftsize 1)
	         (rectangular-&gt;polar fdr fdi)
	         (dotimes (k freq-inc) 
                   (setf (aref diffs k) 
                     (/ (- (aref fdr k) (aref spectrum k)) freq-inc)))
	         (setf ctr 0))
	       (incf ctr)
	       (dotimes (k freq-inc) 
                 (incf (aref spectrum k) (aref diffs k)))
	       (let ((outval 0.0)
		     (inval (ina i fil1)))
	         (loop for k from lo below hi do 
                   (incf outval (* (aref spectrum k) (<em class=red>formant</em> (aref fs k) inval))))
	         (outa i (* amp outval))))))
        (progn
	  (close-input fil1)
	  (close-input fil2)))))))

(with-sound () (cross-synthesis 0 1 "oboe" "fyow" .5 256 1.0 3 100))
</small></pre>
<p>This same idea (an enveloped bank of resonators) can be used for a variety of
cross-fade effects, analogs in the sound world to the common graphical
sweeps, dissolves, and whatnot.  <a href="fade.ins">fade.ins</a> has several
examples.
See also the noi-attempt, filter-white-noise, and testR instruments in <a href="ugex.ins">ugex.ins</a>.
</p>
<br>

<!-- TOPIC filter -->
<span class=cbox><h4>FILTER, IIR-FILTER, FIR-FILTER</h4></span>

<pre>
   <a name="make-filter"><em class=def>make-filter</em></a> <a href="#optional-key">&amp;optional-key</a> <i>order</i> <i>xcoeffs</i> <i>ycoeffs</i>
   <a name="filter"><em class=def>filter</em></a> <i>fl</i> <i>inp</i> 
   <a name="filter?"><em class=def>filter?</em></a> <i>fl</i>

   <a name="make-fir-filter"><em class=def>make-fir-filter</em></a> <a href="#optional-key">&amp;optional-key</a> <i>order xcoeffs</i>
   <a name="fir-filter"><em class=def>FIR-filter</em></a> <i>fl</i> <i>inp</i> 
   <a name="fir-filter?"><em class=def>FIR-filter?</em></a> <i>fl</i>

   <a name="make-iir-filter"><em class=def>make-iir-filter</em></a> <a href="#optional-key">&amp;optional-key</a> <i>order ycoeffs</i>
   <a name="iir-filter"><em class=def>IIR-filter</em></a> <i>fl</i> <i>inp</i> 
   <a name="iir-filter?"><em class=def>IIR-filter?</em></a> <i>fl</i>

   <a name="envelope-&gt;coeffs"><em class=def>envelope-&gt;coeffs</em></a> &amp;key <i>order envelope dc</i>
</pre>
<p>These are the general FIR/IIR filters of arbitrary order.
See <a href="fltdes.lisp">fltdes.lisp</a> for functions compatible with these filters that provide the
coefficients for various FIR and IIR filters.<p>

<table border align=left hspace=20>
<tr><td colspan=2><center>general filter methods</center></tr>
<tr><td><em class=gen>mus-order</em><td>filter order</tr>
<tr><td><em class=gen>mus-xcoeffs</em><td>x (input) coeffs</tr>
<tr><td><em class=gen>mus-ycoeffs</em><td>y (output) coeffs</tr>
<tr><td><em class=gen>mus-data</em><td>current state (input values)</tr>
<tr><td><em class=gen>mus-length</em><td>same as mus-order</tr>
</table>
<pre><small>
  (let ((xout 0.0))
    (setf (aref state 0) input)
    (loop for j from order downto 1 do
      (incf xout (* (aref state j) (aref xcoeffs j)))
      (decf (aref state 0) (* (aref ycoeffs j) (aref state j)))
      (setf (aref state j) (aref state (1- j))))
    (+ xout (* (aref state 0) (aref xcoeffs 0))))
</small></pre><br clear=left><br>

<p>
Say we want to put a spectral envelope on a noise source.</p>
<pre><small>
(definstrument filter-noise (beg dur amp &amp;key xcoeffs)
  (let* ((st (floor (* beg *srate*)))
         (noi (make-rand :frequency (* .5 *srate*) :amplitude amp))
         (flA (<em class=red>make-filter</em> :xcoeffs xcoeffs))
         (nd (+ st (floor (* *srate* dur)))))
    (run
      (loop for i from st below nd do
        (outa i (<em class=red>filter</em> flA (rand noi)))))))

(with-sound () 
  (filter-noise 0 1 .2 
    :xcoeffs (envelope-&gt;coeffs :order 12 :envelope '(0 0.0 .125 0.5 .2 0.0 .3 1.0 .5 0.0 1.0 0.0))))
</small></pre>

<p><i>envelope-&gt;coeffs</i> translates a frequency response envelope into the corresponding FIR filter coefficients.
The <i>order</i> of the filter determines how close you
get to the envelope.</p>

<p>The <a name="hilbert">Hilbert transform</a> can be implemented with FIR-filter:</p>
<pre><small>
(defun make-hilbert (&amp;optional (len 30))
  ;; create the coefficients of the Hilbert transformer of length <i>len</i>
  (let* ((arrlen (1+ (* 2 len)))
	 (arr (make-array arrlen))
	 (j -2))
    (setf (aref arr len) 0.0)
    (loop for i from 1 to len do
      (let* ((hamm (+ 0.54 (* 0.46 (cos (/ (* pi i) len)))))
	     (val (/ (* hamm j) (* pi i))))
	(setf (aref arr (+ len i)) val)
	(setf (aref arr (- len i)) (- val))
	(if (= j -2) (setf j 0) (setf j -2))))
    (<em class=red>make-fir-filter</em> arrlen (loop for i from 0 below arrlen collect (aref arr i)))))

(defmacro hilbert (f in) `(<em class=red>FIR-filter</em> ,f ,in))
</small></pre>
<br>

<!-- TOPIC delay -->
<span class=cbox><h4>DELAY, TAP</h4></span>
<pre>
  <a name="make-delay"><em class=def>make-delay</em></a> <a href="#optional-key">&amp;optional-key</a> <i>size</i> <i>initial-contents initial-element max-size</i>
  <a name="delay"><em class=def>delay</em></a> <i>d</i> <i>input</i> &amp;optional (<i>pm</i> 0.0)
  <a name="delay?"><em class=def>delay?</em></a> <i>d</i>
  <a name="tap"><em class=def>tap</em></a> <i>d</i> &amp;optional (<i>offset</i> 0) (<i>pm</i> 0.0)
</pre>
<p><b>Delay</b> is a delay line.  <i>Size</i> is in samples.
Input fed into a delay line reappears at the output <i>size</i> samples
later.  <i>Initial-element</i> defaults to 0.0.  If specified,
<i>initial-contents</i> need not be the same length as the delay line.
<b>Tap</b> returns the
current value of the delay generator.  <i>Offset</i> is the distance of the tap
from the current delay line sample.  If <i>max-size</i> is specified,
and larger than <i>size</i>, the delay line can provide fractional delays
via linear interpolation.
The argument <i>pm</i> determines how far from the normal index we are.
<i>max-size</i> should be large enough to accommodate the largest actual
delay requested at run-time.
The <i>pm</i> argument is difference between the nominal
delay length (<i>size</i>) and the current actual delay length (<i>size</i>
+ <i>pm</i>) -- a positive <i>pm</i> corresponds to a longer
delay line. </p>

<table border align=left hspace=20>
<tr><td colspan=2><center>delay methods</center></tr>
<tr><td><em class=gen>mus-length</em><td>length of delay (no setf)</tr>
<tr><td><em class=gen>mus-order</em><td>same as mus-length</tr>
<tr><td><em class=gen>mus-data</em><td>delay line itself (no setf)</tr>
</table>

<pre><small>
(prog1
  (array-interp line (- loc pm))
  (setf (aref line loc) input)
  (incf loc)
  (if (&lt;= size loc) (setf loc 0)))
</small></pre><br clear=left>

<pre><small>
(definstrument echo (beg dur scaler secs file)
  (let ((del (<em class=red>make-delay</em> (round (* secs *srate*))))
	(inf (open-input file))
	(j 0))
    (run
     (loop for i from beg below (+ beg dur) do
       (let ((inval (ina j inf)))
	 (outa i (+ inval (<em class=red>delay</em> del (* scaler (+ (<em class=red>tap</em> del) inval)))))
	 (incf j))))
    (close-input inf)))

;;; (with-sound () (echo 0 60000 .5 1.0 "pistol.snd"))
</small></pre>
<br>


<!-- TOPIC comb -->
<span class=cbox><h4>COMB, NOTCH</h4></span>

<pre>
  <a name="make-comb"><em class=def>make-comb</em></a> <a href="#optional-key">&amp;optional-key</a> <i>scaler size initial-contents initial-element max-size</i>
  <a name="comb"><em class=def>comb</em></a> <i>cflt input</i> &amp;optional (<i>pm</i> 0.0)
  <a name="comb?"><em class=def>comb?</em></a> <i>cflt</i>

  <a name="make-notch"><em class=def>make-notch</em></a> <a href="#optional-key">&amp;optional-key</a> <i>scaler size initial-contents initial-element max-size</i>
  <a name="notch"><em class=def>notch</em></a> <i>cflt input</i> &amp;optional (<i>pm</i> 0.0)
  <a name="notch?"><em class=def>notch?</em></a> <i>cflt</i>
</pre>
<p><b>Comb</b> is a delay line with a scaler on the feedback term.  <b>Notch</b>
is a delay line with a scaler on the feedforward term.
<i>Size</i> is the length
in samples of the delay line. </p>

<table border align=left hspace=20>
<tr><td colspan=2><center>comb and notch methods</center></tr>
<tr><td><em class=gen>mus-length</em><td>length of delay (no setf)</tr>
<tr><td><em class=gen>mus-order</em><td>same as mus-length</tr>
<tr><td><em class=gen>mus-data</em><td>delay line itself (no setf)</tr>
<tr><td><em class=gen>mus-feedback</em><td>scaler (comb only)</tr>
<tr><td><em class=gen>mus-feedforward</em><td>scaler (notch only)</tr>
</table>

<pre><small>
 comb:  y(n) = x(n-size-1) + scaler * y(n-size)
 notch: y(n) = x(n-1) * scaler  + x(n-size-1)
</small></pre>
<br clear=left><br>

<p>As a rule of thumb, the decay time of the feedback part is
7*<i>size</i>/(1-<i>scaler</i>) samples, so to get a decay of Dur seconds,
<i>scaler</i> &lt;= 1-7*<i>size</i>/(Dur*Srate).  The peak gain is 1/(1-(abs
<i>scaler</i>)).  The peaks (or valleys in notch's case) are evenly spaced
at srate/size. The height (or depth) thereof is determined by <i>scaler</i> --
the closer to 1.0, the more pronounced.
See Julius Smith's "An Introduction to Digital Filter Theory" in
Strawn "Digital Audio Signal Processing", or Smith's "Music Applications of
Digital Waveguides".</p>
<br>

<!-- TOPIC all-pass -->
<span class=cbox><h4>ALL-PASS</h4></span>
<pre>
  <a name="make-all-pass"><em class=def>make-all-pass</em></a> <a href="#optional-key">&amp;optional-key</a> <i>feedback feedforward size initial-contents initial-element max-size</i>
  <a name="all-pass"><em class=def>all-pass</em></a> <i>f input</i> &amp;optional (<i>pm</i> 0.0)
  <a name="all-pass?"><em class=def>all-pass?</em></a> <i>f</i>
</pre>
<p><b>All-pass</b> or "moving average comb" is just like <a href="#comb">comb</a> but with
an added feedforward term.  If <i>feedback</i> = 0, we get a moving
average comb filter.  If both scale terms = 0, we get a pure delay line. </p>

<table border align=left hspace=20>
<tr><td colspan=2><center>all-pass methods</center></tr>
<tr><td><em class=gen>mus-length</em><td>length of delay (no setf)</tr>
<tr><td><em class=gen>mus-order</em><td>same as mus-length</tr>
<tr><td><em class=gen>mus-data</em><td>delay line itself (no setf)</tr>
<tr><td><em class=gen>mus-feedback</em><td>feedback scaler</tr>
<tr><td><em class=gen>mus-feedforward</em><td>feedforward scaler</tr>
</table>

<pre><small>
 y(n) = feedforward*x(n-1) + x(n-size-1) + feedback*y(n-size)
</small></pre><br clear=left>
<br>

<!-- TOPIC src -->
<!-- INDEX make-src:sampling-rate conversion -->
<span class=cbox><h4>SRC</h4></span>
<pre>
  <a name="make-src"><em class=def>make-src</em></a> <a href="#optional-key">&amp;optional-key</a> <i>input</i> (<i>srate</i> 1.0) (<i>width</i> 5)
  <a name="src"><em class=def>src</em></a> <i>s</i> &amp;optional (<i>sr-change</i> 0.0) <i>input-function</i>
  <a name="src?"><em class=def>src?</em></a> <i>s</i>
</pre>

<table border>
<tr><td colspan=2><center>src methods</center></tr>
<tr><td><em class=gen>mus-increment</em><td>srate arg to make-src</tr>
<tr><td><em class=gen>mus-location</em><td>if file input, current location in file</tr>
<tr><td><em class=gen>mus-channel</em><td>if file input, channel of file (no setf)</tr>
</table>

<p><b>Src</b> performs sampling rate conversion
by convolving its input with a sinc
function.
<i>srate</i> is the
ratio between the new sampling rate and the old.
<i>width</i> is how many neighboring samples to convolve with sinc.
If you hear high-frequency artifacts in the conversion, try increasing this number;
Perry Cook's default value is 40, and I've seen cases where it needs to be 100.
The greater the width, the slower the src generator runs.
The <i>sr-change</i>
argument is the amount to add to the current <i>srate</i> on a sample by sample
basis (if it's 0.0, you get a constant output because the generator is not moving at all).  Here's
an instrument that provides time-varying sampling rate conversion (see also the
<a href="#srctst">srctst</a> instrument below):</p>
<pre><small>
(definstrument simp (start-time duration amp srt srt-env filename)
  (let* ((senv (make-env :envelope srt-env :duration duration))
         (beg (floor (* start-time *srate*)))
         (end (+ beg (floor (* duration *srate*))))
         (f (open-input filename))	
         (src-gen (<em class=red>make-src</em> :input f :srate srt)))
    (run
      (loop for i from beg below end do
        (outa i (* amp (<em class=red>src</em> src-gen (env senv))))))
    (close-input f)))
</small></pre>
<p>src can provide an all-purpose "Forbidden Planet" sound effect; for example,</p>
<pre><small>
(definstrument simp (start-time duration amp srt fmamp fmfreq filename)
  (let* ((os (make-oscil :frequency fmfreq))
         (beg (floor (* start-time *srate*)))
         (end (+ beg (floor (* duration *srate*))))
         (f (open-input filename))
         (src-gen (<em class=red>make-src</em> :input f :srate srt)))
    (run
      (loop for i from beg below end do
        (outa i (* amp (<em class=red>src</em> src-gen (* fmamp (oscil os)))))))
    (close-input f)))

(with-sound () (simp 0 2 1.0   1 .3 20 "fyow.snd"))   
(with-sound () (simp 0 25 10.0   .01 1 10 "fyow.snd"))
(with-sound () (simp 0 2 1.0   .9 .05 60 "oboe.snd")) 
(with-sound () (simp 0 2 1.0   1.0 .5 124 "oboe.snd"))
(with-sound () (simp 0 10 10.0   .01 .2 8 "oboe.snd"))
(with-sound () (simp 0 2 1.0   1 3 20 "oboe.snd"))    

(definstrument hello-dentist (beg dur file frq amp)
  (let ((fil (open-input* file)))
    (when fil
      (unwind-protect
        (let ((rd (make-src :input fil))
              (rn (make-rand-interp :frequency frq :amplitude amp))
              (end (+ beg dur)))
	(run
          (loop for i from beg below end do
                 (outa i (src rd (rand-interp rn)))))
        (close-input fil))))))
</small></pre>
<p>The <i>input</i> argument to make-src and the <i>input-function</i> argument
to src provide the generator with input as it is needed. 
The input function
is a function of one argument (the desired read direction, if the reader can support it), that is funcall'd each time src needs another
sample of input.  The input argument to src can also be an input file structure, as returned by
open-input.
If you're using the run macro (the normal case), only
file input is supported at the make-src level; otherwise, you should pass
in the function in the src call inside the body of run (this is a temporary
situation, hopefully; see expsrc.ins for an example).</p>
<br>

<!-- TOPIC convolve -->
<span class=cbox><h4>CONVOLVE</h4></span>
<pre>
  <a name="make-convolve"><em class=def>make-convolve</em></a> <a href="#optional-key">&amp;optional-key</a> <i>input filter fft-size filter-size</i>
   <a name="convolve"><em class=def>convolve</em></a> <i>ff</i> &amp;optional <i>input-function</i>
   <a name="convolve?"><em class=def>convolve?</em></a> <i>ff</i>
   <a name="convolvefiles"><em class=def>convolve-files</em></a> <i>file1 file2</i> &amp;optional (<i>maxamp</i> 1.0) (<i>output-file</i> "tmp.snd")
</pre>

<table border>
<tr><td colspan=2><center>convolve methods</center></tr>
<tr><td><em class=gen>mus-length</em><td>fft size used in the convolution</tr>
</table>

<p>
<b>Convolve</b> convolves its input with the impulse response <i>filter</i>.
The <i>filter</i> argument 
can be
an array, the result of open-input, or a filename as a string.
When not file based,
<i>input</i> and <i>input-function</i> are functions of one argument (currently ignored) that are
funcall'd whenever convolve needs input (see <a href="#src">src</a>).
</p>
<pre><small>
(definstrument convins (beg dur filter file &amp;optional (size 128))
  (let* ((start (floor (* beg *srate*)))
         (end (+ start (floor (* dur *srate*))))
         (fil (open-input file))
         (ff (<em class=red>make-convolve</em> :input fil :fft-size size :filter filter)))
    (run
      (loop for i from start below end do (outa i (<em class=red>convolve</em> ff))))
    (close-input fil))) 
</small></pre>
<p><b>convolve-files</b> handles a very common special case: you often want to convolve
two files, normalizing the result to some maxamp.  The convolve generator does not
know in advance what its maxamp will be, and when the two files are more or less
the same size, there's no real computational savings to using overlap-add (i.e.
the generator), so a one-time giant FFT saved as a temporary sound file is much
handier.</p>
<br>

<!-- TOPIC granulate -->
<!-- INDEX grains:Granular synthesis --><a name="grains"></a>
<span class=cbox><h4>GRANULATE</h4></span>
<pre>
  <a name="make-granulate"><em class=def>make-granulate</em></a> <a href="#optional-key">&amp;optional-key</a>   
        <i>input</i>
        (<i>expansion</i> 1.0)   ;how much to lengthen or compress the file
        (<i>length</i> .15)      ;length of file slices that are overlapped
        (<i>scaler</i> .6)       ;amplitude scaler on slices (to avoid overflows)
        (<i>hop</i> .05)         ;speed at which slices are repeated in output
        (<i>ramp</i> .4)         ;amount of slice-time spent ramping up/down
        (<i>jitter</i> 1.0)      ;affects spacing of successive grains
        <i>max-size</i>          ;internal buffer size
  <a name="granulate"><em class=def>granulate</em></a> <i>e</i> &amp;optional <i>input-function</i>
  <a name="granulate?"><em class=def>granulate?</em></a> <i>e</i>
</pre>

<table border>
<tr><td colspan=2><center>granulate methods</center></tr>
<tr><td><em class=gen>mus-frequency</em><td>time (seconds) between output grains (<i>hop</i>)</tr>
<tr><td><em class=gen>mus-ramp</em><td>length (samples) of grain envelope ramp segment</tr>
<tr><td><em class=gen>mus-hop</em><td>time (samples)  between output grains (<i>hop</i>)</tr>
<tr><td><em class=gen>mus-scaler</em><td>grain amp (<i>scaler</i>)</tr>
<tr><td><em class=gen>mus-increment</em><td><i>expansion</i></tr>
<tr><td><em class=gen>mus-length</em><td>grain length (samples)</tr>
</table>

<p><b>Granulate</b> "granulates" the sound file <i>file</i>.  It is the poor man's way
to change the speed at which things happen in a recorded sound without
changing the pitches.  It works by slicing the input file into short
pieces, then overlapping these slices to lengthen (or shorten) the
result; this process is sometimes known as granular synthesis, and is
similar to the "freeze" function.  The duration of each slice is
<i>length</i> -- the longer, the more like reverb the effect.  The
portion of the length (on a scale from 0 to 1.0) spent on each
ramp (up or down) is <i>ramp</i>.  This can control the smoothness of
the result of the overlaps.  The more-or-less average time between
successive segments is <i>hop</i>.  The accuracy at which we handle
this hopping is set by the float <i>jitter</i> -- if <i>jitter</i> is very small, you may get an
annoying tremolo.  The overall amplitude scaler on each segment is
<i>scaler</i> -- this is used to try to to avoid overflows as we add
all these zillions of segments together.  <i>expansion</i>
determines the input hop in relation to the output hop; an
expansion-amount of 2.0 should more or less double the length of the
original, whereas an expansion-amount of 1.0 should return something
close to the original speed.
<i>input</i> and <i>input-function</i> are the same as in src and convolve.
</p>
<pre><small>
(definstrument granulate-sound (file beg &amp;optional dur (orig-beg 0.0) (exp-amt 1.0))
  (let* ((f-srate (sound-srate file))
	 (f-start (round (* f-srate orig-beg)))
         (f (open-input file :start f-start))
	 (st (floor (* beg *srate*)))
	 (new-dur (or dur (- (sound-duration file) orig-beg)))
	 (exA (<em class=red>make-granulate</em> :input f :expansion exp-amt))
	 (nd (+ st (floor (* *srate* new-dur)))))
    (run
     (loop for i from st below nd do
       (outa i (<em class=red>granulate</em> exA))))
    (close-input f)))
</small></pre>
<p>See expsrc.ins for examples.</p>
<br>

<!-- TOPIC phase-vocoder -->
<span class=cbox><h4>PHASE-VOCODER</h4></span>
<pre>
  <a name="make-phase-vocoder"><em class=def>make-phase-vocoder</em></a> <a href="#optional-key">&amp;optional-key</a> <i>input</i> (<i>fftsize</i> 512) (<i>overlap</i> 4) <i>interp</i> (<i>pitch</i> 1.0) <i>analyze edit synthesize</i>
  <a name="phase-vocoder"><em class=def>phase-vocoder</em></a> <i>pv input</i>
  <a name="phase-vocoder?"><em class=def>phase-vocoder?</em></a> <i>pv</i>
</pre>

<table border>
<tr><td colspan=2><center>phase-vocoder methods</center></tr>
<tr><td><em class=gen>mus-frequency</em><td>pitch shift</tr>
<tr><td><em class=gen>mus-length</em><td>fft-size ("N")</tr>
<tr><td><em class=gen>mus-increment</em><td>interp</tr>
<tr><td><em class=gen>mus-hop</em><td>fft-size / overlap ("D")</tr>
</table>

<p>phase-vocoder provides a generator to perform phase-vocoder analysis and resynthesis.  The process is
split into three pieces, the analysis stage, editing of the amplitudes and phases, then the resynthesis.
Each stage has a default that is invoked if the <i>analyze</i>, <i>edit</i>, or <i>synthesize</i>
arguments are omitted from make-phase-vocoder.  The edit and synthesize arguments are functions of one argument, the
phase-vocoder generator.  The analyze argument is a function of two arguments, the generator and
the input function passed to phase-vocoder at run-time (if any). The default is to read input (from the input function, an "as-needed"
input source as in src or granulate), take the fft, get the new amplitudes and phases (as the edit
function default), then resynthesize using sum-of-sines (the synthesize function default); so, the
default case simply returns a resynthesis of the original input.  <i>interp</i> sets the time between
ffts (for time stretching etc).  Here's an example that changes the edit function to provide
control over the resynthesis pitch:
</p>
<pre>
<small>
(defun test-pv (freq)
  (with-sound ()
    (let ((pv (make-phase-vocoder
	        nil
                512 4 (/ 512 4) 1.0
                nil ;no change to analysis
                (lambda (v)
                  ; new editing func changes pitch (we could simply pass :pitch freq instead)
                  (let* ((N (mus-length v))
                         (D (mus-hop v)))
                    (do ((k 0 (1+ k))
                         (pscl (/ 1.0 D))
                         (kscl (/ (* 2.0 pi) N)))
                        ((= k (floor N 2)))
                     (let ((phasediff (- (clm::pv-freqs v k) (clm::pv-lastphase v k))))
                       (clm::set-pv-lastphase v k (clm::pv-freqs v k))
                       (if (&gt; phasediff pi) (do () ((&lt;= phasediff pi)) (setf phasediff (- phasediff (* 2 pi)))))
                       (if (&lt; phasediff (- pi)) (do () ((&gt;= phasediff (- pi))) (setf phasediff (+ phasediff (* 2 pi)))))
                       (clm::set-pv-freqs v k (* freq (+ (* pscl phasediff) (* k kscl))))))
                     nil))
                nil)) ; no change to synthesis
          (fil (open-input "oboe.snd")))
      (let ((ctr 0))
        (dotimes (i (* 22050 2.3))
          (outa i (phase-vocoder pv (lambda (dir) (let ((val (ina ctr fil))) (incf ctr) val)))))))))

(test-pv 0.5)
</small>
</pre>
<br>

<!-- TOPIC buffer -->
<span class=cbox><h4>BUFFER-&gt;SAMPLE</h4></span>
<pre>
  <a name="make-buffer"><em class=def>make-buffer</em></a> <a href="#optional-key">&amp;optional-key</a> <i>size (fill-time 0.0)</i>
  <a name="buffer-&gt;sample"><em class=def>buffer-&gt;sample</em></a> <i>b</i> 
  <a name="sample-&gt;buffer"><em class=def>sample-&gt;buffer</em></a> <i>b val</i> 
  <a name="buffer-&gt;frame"><em class=def>buffer-&gt;frame</em></a> <i>b f</i> 
  <a name="frame-&gt;buffer"><em class=def>frame-&gt;buffer</em></a> <i>b f</i> 
  <a name="buffer-empty?"><em class=def>buffer-empty?</em></a> <i>b</i> 
  <a name="buffer-full?"><em class=def>buffer-full?</em></a> <i>b</i> 
  <a name="buffer?"><em class=def>buffer?</em></a> <i>b</i> 
</pre>

<table border>
<tr><td colspan=2><center>buffer methods</center></tr>
<tr><td><em class=gen>mus-data</em><td>buffer data (no setf)</tr>
<tr><td><em class=gen>mus-increment</em><td>buffer fill time</tr>
<tr><td><em class=gen>mus-length</em><td>buffer length (no setf)</tr>
</table>

<p>This generator is an extension of a delay line, providing a way to overlap-add
stuff into the line, and a way to get notification when the next block of input is needed.
<b>Buffer-&gt;sample</b> provides sample-at-a-time access to block-oriented data.  On
each call, buffer-&gt;sample returns the next sample in the buffer. 
Similarly, sample-&gt;buffer appends a sample to the buffer.  <b>buffer-empty?</b> returns
t when a new block of data is needed; mus-increment sets the next block-trigger time.
</p>
<pre><small>
(definstrument simp (dur)
  (let* ((gen (<em class=red>make-buffer</em> 128 128.0)))
    (loop for i from 0 below 128 do (setf (aref (mus-data gen) i) (double-float (* i .001))))
    (run
     (loop for i from 0 below dur do
       (when (<em class=red>buffer-empty?</em> gen)
	 (loop for k from 0 below 128 do (setf (aref (mus-data gen) k) (double-float (* k .001))))
	 (incf (mus-increment gen) 128))
       (outa i (<em class=red>buffer-&gt;sample</em> gen))))))
</small></pre>
<br>

<!-- TOPIC sine-summation -->
<span class=cbox><h4>SINE-SUMMATION</h4></span>
<pre>
  <a name="make-sine-summation"><em class=def>make-sine-summation</em></a> <a href="#optional-key">&amp;optional-key</a> 
        (<i>frequency</i> 440.0) (<i>initial-phase</i> 0.0) (<i>n</i> 1) (<i>a</i> .5) (<i>ratio</i> 1.0)
  <a name="sine-summation"><em class=def>sine-summation</em></a> <i>s</i> &amp;optional (<i>fm</i> 0.0)
  <a name="sine-summation?"><em class=def>sine-summation?</em></a> <i>s</i>
</pre>

<table border>
<tr><td colspan=2><center>sine-summation methods</center></tr>
<tr><td><em class=gen>mus-frequency</em><td>frequency in Hz</tr>
<tr><td><em class=gen>mus-phase</em><td>phase in radians</tr>
</table>

<p><b>sine-summation</b> provides a kind of additive synthesis.
See J.A.Moorer, "Signal Processing Aspects of Computer Music" and "The
Synthesis of Complex Audio Spectra by means of Discrete Summation Formulae"
(Stan-M-5).  The basic idea is very similar to that used in the
<a href="#sum-of-cosines">sum-of-cosines</a> generator.</p>
<pre><small>
  (definstrument ss (beg dur freq amp &amp;optional (N 1) (a .5) (B-ratio 1.0))
    (let* ((st (floor (* *srate* beg)))
           (nd (+ st (floor (* *srate* dur))))
           (sgen (<em class=red>make-sine-summation</em> :n N :a a :ratio B-ratio :frequency freq)))
      (run
       (loop for i from st below nd do
         (outa i (* amp (<em class=red>sine-summation</em> sgen)))))))

</small></pre>
<br>

<!-- TOPIC asymmetric-fm -->
<span class=cbox><h4>ASYMMETRIC-FM</h4></span>

<pre>
  <a name="make-asymmetric-fm"><em class=def>make-asymmetric-fm</em></a> <a href="#optional-key">&amp;optional-key</a> 
        (<i>frequency</i> 440.0) (<i>initial-phase</i> 0.0) (<i>r</i> 1.0) (<i>ratio</i> 1.0)
  <a name="asymmetric-fm"><em class=def>asymmetric-fm</em></a> <i>af index</i> &amp;optional (<i>fm</i> 0.0)
  <a name="asymmetric-fm?"><em class=def>asymmetric-fm?</em></a> <i>af</i>
</pre>

<table border>
<tr><td colspan=2><center>asymmetric-fm methods</center></tr>
<tr><td><em class=gen>mus-frequency</em><td>frequency in Hz</tr>
<tr><td><em class=gen>mus-phase</em><td>phase in radians</tr>
</table>

<p><b>asymmetric-fm</b> provides a way around the symmetric spectra normally produced by FM.
See  Palamin and Palamin, "A Method of Generating and Controlling Asymmetrical
Spectra" JAES vol 36, no 9, Sept 88, p671-685:  this is another extension of
the <a href="#sine-summation">sine-summation</a> and <a href="#sum-of-cosines">sum-of-cosines</a> approach.</p>
<pre><small>
  (definstrument asy (beg dur freq amp index &amp;optional (r 1.0) (ratio 1.0))
    (let* ((st (floor (* beg *srate*)))
           (nd (+ st (floor (* dur *srate*))))
           (asyf (<em class=red>make-asymmetric-fm</em> :r r :ratio ratio :frequency freq)))
      (run
       (loop for i from st below nd do
         (outa i (* amp (<em class=red>asymmetric-fm</em> asyf index 0.0)))))))
</small></pre>
<br>

<span class=cbox><h4>Other Generators</h4></span>
<p>There are a number of other generators in the CLM distribution that aren't
loaded by default.  Among these are:</p>
<pre>
  <a href="balance.html#rms">rms</a>         ;trace the rms of signal
  <a href="balance.html#gain">gain</a>        ;modify signal to match rms power
  <a href="balance.html#balance">balance</a>     ;combination of rms and gain
</pre>
<p>prc-toolkit95.lisp and piano.ins define different versions of some of the
filter, noise and delay generators. Various special functions and
their relatives are defined in bessel.lisp.
green.cl defines several special purpose noise generators.
butterworth.cl has several Butterworth filters.  </p>
<br>


<!-- TOPIC generic functions -->
<span class=cbox><h4><a name="generic-functions">Generic Functions</a></h4></span>

<p>The generators have internal fields that are sometimes of interest at run-time.  To get or
set these fields, use these functions (they are described in conjunction with the associated generators):</p>
<pre>
  <a name="mus-frequency"><em class=def>mus-frequency</em></a>  <a name="mus-cosines"><em class=def>mus-cosines</em></a>         <a name="mus-phase"><em class=def>mus-phase</em></a>     <a name="mus-location"><em class=def>mus-location</em></a>
  <a name="mus-length"><em class=def>mus-length</em></a>     <a name="mus-increment"><em class=def>mus-increment</em></a>       <a name="mus-data"><em class=def>mus-data</em></a>      <a name="mus-order"><em class=def>mus-order</em></a>
  <a name="mus-channel"><em class=def>mus-channel</em></a>    <a name="mus-formant-radius"><em class=def>mus-formant-radius</em></a>  <a name="mus-channels"><em class=def>mus-channels</em></a>  <a name="mus-xcoeffs"><em class=def>mus-xcoeffs</em></a>
  <a name="mus-scaler"><em class=def>mus-scaler</em></a>     <a name="mus-ycoeffs"><em class=def>mus-ycoeffs</em></a>         <a name="mus-ramp"><em class=def>mus-ramp</em></a>      <a name="mus-feedback"><em class=def>mus-feedback</em></a>
  <a name="mus-a0"><em class=def>mus-a0</em></a>         <a name="mus-feedforward"><em class=def>mus-feedforward</em></a>     <a name="mus-a1"><em class=def>mus-a1</em></a>        <a name="mus-hop"><em class=def>mus-hop</em></a>
  <a name="mus-a2"><em class=def>mus-a2</em></a>         <a name="mus-b1"><em class=def>mus-b1</em></a>              <a name="mus-b2"><em class=def>mus-b2</em></a>        <a name="mus-run"><em class=def>mus-run</em></a>
</pre>
<p>
For example (setf (mus-frequency osc1) 440.0)
sets osc1's current frequency to (hz-&gt;radians 440.0). 

</p>
<pre><small>
(definstrument <a name="backandforth">backandforth</a> (onset duration file src-ratio)
  ;; read file forwards and backwards until dur is used up
  ;; a slightly improved version is 'scratch' in ug1.ins
  (let* ((f (open-input file))
         (last-sample (sound-frames file))
         (beg (floor (* *srate* onset)))
         (end (+ beg (floor (* *srate* duration))))
         (s (make-src :file f :start 0 :srate src-ratio))
         (cs 0))
    (run
     (loop for i from beg below end do
       (setf cs (<em class=red>mus-location</em> s))
       (if (&gt;= cs last-sample) (setf (<em class=red>mus-increment</em> s) (- src-ratio)))
       (if (&lt;= cs 0) (setf (<em class=red>mus-increment</em> s) src-ratio)
       (outa i (src s)))))
    (close-input f)))
</small></pre>
<p>mus-location is useful in cases where you're doing some complicated
processing on a file, and want to use envelopes, but for whatever reason can't
easily say how long the output will be.  The envelopes can be defined in terms
of the input file's length, then applied by watching mus-location:</p>
<pre><small>
(definstrument <a name="srctst">srctst</a> (file beg srcenv in-file-start)
  (let ((f (open-input file :start (floor (* in-file-start (sound-srate file))))))
    (unwind-protect
        (let* ((st (floor (* beg *srate*)))
               (dur (sound-duration file))
               (samples (1- (sound-frames file)))
               (srcA (make-src :input f :srate 0.0))
               (env-val 0.0)
               (pass 0)
               (senv (make-env :envelope srcenv :duration dur)))
	  (setf env-val (env senv))           ;get initial src value
          (run
           (loop for i from st do
             (let ((pos (<em class=red>mus-location</em> srcA)))
               (when (/= pass pos)            ;position in input has changed
                 (let ((passes (- pos pass))) ;move env forward by same amount
                   (setf pass pos)
                   (dotimes (k passes) (setf env-val (env senv)))))
               (outa i (src srcA env-val))
               ;; perhaps this should protect against an env-val of 0.0
               (if (&gt;= pass samples) (loop-finish))))))
      (close-input f))))

</small></pre>
<p>This instrument puts an envelope on the sampling rate, and defines
the envelope to apply over the entire input file:</p>
<pre>
  (with-sound () (srctst  "oboe.snd" 0 '(0 1 1 .5 2 1)))
</pre>

<p>If you write your own generators, and want them to respond to any of the
generic functions, you need to use <a name="add-clm-method">add-clm-method</a>.
It takes 4 arguments, the name of the generic function to which you're adding
a method, the type identifier for the generator this method applies to,
and two functions that produce the code to access the data or set it to
some new value.  The type can be any integer greater than 50 or so --
currently CLM's built-in types stop at +mixer+ which is 42.  There
are numerous examples of add-clm-method in cmus.lisp.  When a generic
function reference occurs in the run body, a function is built up
at compile time that collects all the known methods for that generic
function.</p>
<br>


<span class=bbox><h3><a name="sound IO">Frames, Mixers, Sound IO</a></h3></span>
<!-- TOPIC frames -->
<span class=cbox><h4>Frames and Mixers</h4></span>

<p>There are two special data types in CLM: frames and mixers.
A frame is an array that represents
a multi-channel sample (that is, in a stereo file, at time 0.0, there
are two samples, one for each channel).  A mixer is a array of arrays
that represents a set of input to output scalers, as if it were the
current state of a mixing console's volume controls.  A frame (a multi-channel
input) can be "mixed" into a new frame (a multi-channel output) by passing
it through a "mixer" (a matrix, the operation being a matrix multiply).
These are combined with the notion of a "sample" (one datum of sampled music), and
input/output ports (files, audio ports, etc) to handle all the underlying
data.
</p>
<pre>
  <a name="make-empty-frame"><em class=def>make-empty-frame</em></a> <i>chans</i>         ;create frame of 0's
  <a name="make-frame"><em class=def>make-frame</em></a> <i>chans</i> &amp;rest <i>args</i>    ;create frame and load it with args
  <a name="frame?"><em class=def>frame?</em></a> <i>obj</i>                     ;is <i>obj</i> a frame
  <a name="frame+"><em class=def>frame+</em></a> <i>f1 f2</i> &amp;optional <i>outf</i>    ;add <i>f1</i> and <i>f2</i> element-wise, return new frame (or <i>outf</i>)
  <a name="frame*"><em class=def>frame*</em></a> <i>f1 f2</i> &amp;optional <i>outf</i>    ;multiply <i>f1</i> and <i>f2</i> element-size, return new frame (or <i>outf</i>)
  <a name="frame-ref"><em class=def>frame-ref</em></a> <i>f1 chan</i>              ;return <i>f1</i>[<i>chan</i>]
  <a name="frame-set!"><em class=def>frame-set!</em></a> <i>f1 chan val</i>         ;<i>f1</i>[<i>chan</i>] = <i>val</i> (also setf with frame-ref)

  <a name="make-empty-mixer"><em class=def>make-empty-mixer</em></a> <i>chans</i>         ;create a mixer of 0's
  <a name="make-identity-mixer"><em class=def>make-identity-mixer</em></a> <i>chans</i>      ;create a mixer of 1's on the diagonals
  <a name="make-mixer"><em class=def>make-mixer</em></a> <i>chans</i> &amp;rest <i>args</i>    ;create a mixer and load it with args
  <a name="mixer?"><em class=def>mixer?</em></a> <i>obj</i>                     ;is <i>obj a mixer</i>
  <a name="mixer*"><em class=def>mixer*</em></a> <i>m1 m2</i> &amp;optional <i>outm</i>    ;matrix multiply of <i>m1</i> and <i>m2</i>, return new mixer (or <i>outm</i>)
  <a name="mixer-ref"><em class=def>mixer-ref</em></a> <i>m1 in out</i>            ;<i>m1</i>[<i>in</i>,<i>out</i>] (use setf to change)
  <a name="mixer-set!"><em class=def>mixer-set!</em></a> <i>m1 in out val</i>       ;<i>m1</i>[<i>in,out</i>] = <i>val</i> (also setf with mixer-ref)

  <a name="frame-&gt;frame"><em class=def>frame-&gt;frame</em></a> <i>mixer frame</i> &amp;optional <i>outf</i>
                        ;pass <i>frame</i> through <i>mixer</i>, return new frame (or outf)
  <a name="frame-&gt;list"><em class=def>frame-&gt;list</em></a> frame              ;return list of <i>frame's</i> contents
  <a name="sample-&gt;frame"><em class=def>sample-&gt;frame</em></a> <i>frame-or-mixer sample</i> &amp;optional <i>outf</i>
                        ;pass <i>sample</i> through <i>frame-or-mixer</i>, return new frame (or <i>outf</i>)
  <a name="frame-&gt;sample"><em class=def>frame-&gt;sample</em></a> <i>frame-or-mixer frame</i>  
                        ;pass <i>frame</i> through <i>frame-or-mixer</i>, return sample
</pre>

<table border>
<tr><td colspan=2><center>frame and mixer methods</center></tr>
<tr><td><em class=gen>mus-channels</em><td>number of channels accommodated</tr>
<tr><td><em class=gen>mus-length</em><td>same as mus-channels</tr>
</table>

<p>fullmix.ins uses these functions to provide a mixer able to handle any number
of channels of data in and out with optional scalers and envelopes on any in-&gt;out path.
The heart of the instrument is:</p>
<pre>
       (<em class=red>frame-&gt;file</em> *output* i 
         (<em class=red>frame-&gt;frame</em> mx 
           (<em class=red>file-&gt;frame</em> file inloc inframe) outframe))
</pre>
<p>Here the input file is read by <b>file-&gt;frame</b> producing a frame of data.  That
is then passed through the mixer <b>frame-&gt;frame</b>, and the resultant frame is written to
the with-sound output file <b>*output*</b> by <b>frame-&gt;file</b>.  Within <b>run</b>, the
output frames of the various frame producing functions must be provided (I'm trying to avoid
run-time memory management).
</p>

<p>Sound file IO is supported by a variety of low-level functions:</p>
<pre>
  <a name="mus-input?"><em class=def>mus-input?</em></a> <i>obj</i>                ;t if <i>obj</i> performs sound input
  <a name="mus-output?"><em class=def>mus-output?</em></a> <i>obj</i>               ;t if <i>obj</i> performs sound output
  <a name="file-&gt;sample?"><em class=def>file-&gt;sample?</em></a> <i>obj</i>             ;t if <i>obj</i> reads a sound file returning a sample
  <a name="sample-&gt;file?"><em class=def>sample-&gt;file?</em></a> <i>obj</i>             ;t if <i>obj</i> writes a sample to a sound file
  <a name="frame-&gt;file?"><em class=def>frame-&gt;file?</em></a> <i>obj</i>              ;t if <i>obj</i> writes a frame to a sound file
  <a name="file-&gt;frame?"><em class=def>file-&gt;frame?</em></a> <i>obj</i>              ;t if <i>obj</i> reads a sound file returning a frame
   
  <a name="make-file-&gt;sample"><em class=def>make-file-&gt;sample</em></a> <i>name</i>        ;return gen that reads samples from sound file <i>name</i>
  <a name="make-sample-&gt;file"><em class=def>make-sample-&gt;file</em></a> <i>name chans</i> &amp;optional <i>format type</i>
                                ;return gen that writes samples to sound file <i>name</i>
  <a name="make-file-&gt;frame"><em class=def>make-file-&gt;frame</em></a> <i>name</i>         ;return gen that reads frames from sound file <i>name</i>
  <a name="make-frame-&gt;file"><em class=def>make-frame-&gt;file</em></a> <i>name chans</i> &amp;optional <i>format type</i>
                                ;return gen that writes frames to sound file <i>name</i>

  <a name="file-&gt;sample"><em class=def>file-&gt;sample</em></a> <i>obj samp</i> &amp;optional <i>chan</i>    ;return sample at <i>samp</i> in channel <i>chan</i>
  <a name="sample-&gt;file"><em class=def>sample-&gt;file</em></a> <i>obj samp chan val</i>;write (add) sample <i>val</i> at <i>samp</i> in channel <i>chan</i>
  <a name="file-&gt;frame"><em class=def>file-&gt;frame</em></a> <i>obj samp</i>          ;return frame at <i>samp</i>
  <a name="frame-&gt;file"><em class=def>frame-&gt;file</em></a> <i>obj samp val</i>      ;write (add) frame <i>val</i> at <i>samp</i>

  <a name="file-&gt;array"><em class=def>file-&gt;array</em></a> <i>filename channel start-sample samples array</i>
  <a name="array-&gt;file"><em class=def>array-&gt;file</em></a> <i>file data srate channels</i>
  ;; these two read and write entire files to or from float arrays

  <a name="mus-open-write"><em class=def>mus-open-write</em></a> <i>filename</i>       ;low-level open/create call (O_RDRW), returning (new empty) file id
  <a name="mus-reopen-write"><em class=def>mus-reopen-write</em></a> <i>filename</i>     ;low-level open call (O_RDRW), returning file id
  <a name="mus-open-read"><em class=def>mus-open-read</em></a> <i>filename</i>        ;low-level open call (O_RDONLY), returning file id
  <a name="mus-create"><em class=def>mus-create</em></a> <i>filename</i>           ;low-level creat call (make new file), returning file id
  <a name="mus-close"><em class=def>mus-close</em></a> <i>fd</i>                  ;low-level close call (fd can be int or IO struct)
</pre>

<p>These functions underly the more commonly used IO functions, outa and friends:</p>

<!-- TOPIC outa -->
<!-- INDEX ina-outa:Input and output --><a name="ina-outa"></a>
<span class=cbox><h4>OUTA, OUTB, OUTC, OUTD, OUT-ANY</h4></span>
<pre>
  <a name="outa"><em class=def>outa</em></a> <i>loc</i> <i>data</i> &amp;optional (<i>o-stream</i> *output*)
  <a name="outb"><em class=def>outb</em></a> <i>loc</i> <i>data</i> &amp;optional (<i>o-stream</i> *output*)
  <a name="outc"><em class=def>outc</em></a> <i>loc</i> <i>data</i> &amp;optional (<i>o-stream</i> *output*)
  <a name="outd"><em class=def>outd</em></a> <i>loc</i> <i>data</i> &amp;optional (<i>o-stream</i> *output*)
  <a name="out-any"><em class=def>out-any</em></a> <i>loc</i> <i>data</i> &amp;optional (<i>channel</i> 0) (<i>o-stream</i> *output*)
</pre>
<p><b>Outa</b> and friends add <i>data</i> into <i>o-stream</i> at sample
position <i>loc</i>.  <i>O-stream</i> defaults to the current output
file (it is an IO instance, not a file name).  The reverb stream, if any,
is named *reverb*; the direct output is *output*.  See the <a href="#envsound">env-sound</a>
instrument for an example of *reverb*.
You can output anywhere at any time, but because of the way data is buffered internally, your
instrument will run much faster if it does sequential output.
<a href="#locsig">Locsig</a> is the other output function.</p>
<br>

<!-- TOPIC ina -->
<span class=cbox><h4>INA, INB, IN-ANY</h4></span>
<pre>
  <a name="ina"><em class=def>ina</em></a> <i>loc</i> &amp;optional (<i>i-stream</i> *input*)
  <a name="inb"><em class=def>inb</em></a> <i>loc</i> &amp;optional (<i>i-stream</i> *input*)
  <a name="in-any"><em class=def>in-any</em></a> <i>loc</i> &amp;optional (<i>channel</i> 0) (<i>i-stream</i> *input*)
</pre>
<p><b>Ina</b> and friends get the sample at position <i>loc</i> in
<i>i-stream</i> as a float.  The data is normally between -1.0 and 1.0.
<i>I-stream</i> defaults to the current input file (it is an IO struct, not a file name).
See the "digital zipper" instrument <a href="zipper.ins">zipper.ins</a> for an example.
</p>
<br>

<!-- TOPIC rec-any -->
<span class=cbox><h4>REC-ANY</h4></span>
<pre>
  <a name="rec-any"><em class=def>rec-any</em></a> <i>chan</i>
</pre>
<p>Within <a href="#defpinstrument">defpinstrument</a> and <a href="#with-psound">with-psound</a>, access to the current
real-time input is through <b>rec-any</b>.  The <i>chan</i> argument refers to
the recording input channel.  Which input is accessed depends on the rec-line argument to with-psound
or with-dac (0=microphone, 1=analog line in, 2=digital line in).
</p> 
<hr>

<!-- TOPIC readin -->
<span class=cbox><h4>READIN</h4></span>
<pre>
 <a name="make-readin"><em class=def>make-readin</em></a> <a href="#optional-key">&amp;optional-key</a> <i>file</i> (<i>channel</i> 0) <i>start</i> <i>(direction 1)</i>
 <a name="readin"><em class=def>readin</em></a> <i>rd</i>
 <a name="readin?"><em class=def>readin?</em></a> <i>rd</i>
</pre>

<table border>
<tr><td colspan=2><center>readin methods</center></tr>
<tr><td><em class=gen>mus-channel</em><td><i>channel</i> arg to make-readin (no setf)</tr>
<tr><td><em class=gen>mus-location</em><td>current location in file</tr>
<tr><td><em class=gen>mus-increment</em><td>sample increment (<i>direction</i> arg to make-readin)</tr>
</table>

<p><b>Readin</b> returns successive samples (as floats) from <i>file</i>.
<i>File</i> should be an IO instance, as returned by <a href="#open-input">open-input</a>.
<i>Start</i> is the frame at which to start reading <i>file</i>. 
Here is an instrument that applies an envelope to a sound file using
readin and <a href="#env">env</a> (see also the fullmix instrument in fullmix.ins):</p>
<pre><small>
(definstrument <a name="envsound">env-sound</a> (file beg &amp;optional (amp 1.0) (amp-env '(0 1 100 1)))
  (let ((f (open-input* file)))
    (when f
      (unwind-protect
        (let* ((st (floor (* beg *srate*)))
               (dur (sound-duration file))
               (rev-amount .01)
               (rdA (<em class=red>make-readin</em> f))
               (ampf (make-env amp-env amp dur))
               (nd (+ st (floor (* *srate* dur)))))
          (run
            (loop for i from st below nd do
	      (let ((outval (* (env ampf) (<em class=red>readin</em> rdA))))
		(outa i outval)
		(if *reverb* (outa i (* outval rev-amount) *reverb*)))))
          (close-input f))))))
</small></pre>
<br>

<!-- TOPIC locsig -->
<!-- INDEX make-locsig:Sound placement -->
<span class=cbox><h4>LOCSIG</h4></span>
<pre>
 <a name="make-locsig"><em class=def>make-locsig</em></a> <a href="#optional-key">&amp;optional-key</a> (<i>degree</i> 0.0) (<i>distance</i> 1.0) <i>reverb channels</i>
 <a name="locsig"><em class=def>locsig</em></a> <i>loc i in-sig</i>
 <a name="locsig?"><em class=def>locsig?</em></a> <i>loc</i>
 <a name="locsig-ref"><em class=def>locsig-ref</em></a> <i>loc chan</i>
 <a name="locsig-set!"><em class=def>locsig-set!</em></a> <i>loc chan val</i>
 <a name="locsig-reverb-ref"><em class=def>locsig-reverb-ref</em></a> <i>loc chan</i>
 <a name="locsig-reverb-set!"><em class=def>locsig-reverb-set!</em></a> <i>loc chan val</i>
</pre>
<p><b>Locsig</b> normally takes the place of <a href="#outa">outa</a> and <a href="#outb">outb</a> in an
instrument.  It tries to place a signal between outa and outb in
an extremely dumb manner, it just scales the respective amplitudes
("that old trick <i>never</i> works").  <i>Reverb</i> determines how much of
the direct signal gets sent to the reverberator.  <i>Distance</i> tries to
imitate a distance cue by fooling with the relative amounts of direct and
reverberated signal (independent of <i>reverb</i>).  <i>Distance</i> should
be greater than or equal to 1.0. Locsig is a
kludge, but then so is any pretence of placement when you're piping the signal
out a loudspeaker.  It is my current belief that locsig does the "right"
thing for all the wrong reasons; a good concert hall provides "auditory
spaciousness" by interfering with the ear's attempt to localize a sound --
that is, a diffuse sound source is the ideal!  By sending an arbitrary mix of
signal and reverberation to various speakers, locsig gives you a very
diffuse "source"; it does the opposite of what it claims to do, and by
some perversity of Mother Nature, that is what you want.  (See "Binaural
Phenomena" by J Blauert).</p>

<p>Locsig can send output to any number of channels. The <i>degree</i> and
<i>distance</i> arguments are ignored if the output file has more than 4 channels.
In the quad case, the speakers are assumed to be in
a circle with channel 0 at 0 degrees, channel 1 at 90, and so on.  In other
cases, you can set the mix you want via the <b>locsig-ref</b> and <b>locsig-reverb-ref</b>
functions.
For example, to have full output to both channels,</p>
<pre>
(setf (locsig-ref loc 0) 1.0) ;or (locsig-set! loc 0 1.0)
(setf (locsig-ref loc 1) 1.0)
</pre>
<p>These locations can be set via envelopes and so on within the run
loop to pan between speakers:</p>
<pre><small>
(definstrument space (file onset duration 
	              &amp;key (distance-env '(0 1 100 10)) (amplitude-env '(0 1 100 1))
			   (degree-env '(0 45 50 0 100 90)) (reverb-amount .05))
  (let ((f (open-input file)))
    (when f
      (unwind-protect
	(let* ((beg (floor (* onset *srate*)))
	       (end (+ beg (floor (* *srate* duration))))
	       (loc (<em class=red>make-locsig</em> :degree 0 :distance 1 :reverb reverb-amount))
	       (rdA (make-readin :file f))
	       (dist-env (make-env distance-env :duration duration))
	       (amp-env (make-env amplitude-env :duration duration))
	       (deg-env (make-env (loop for x in degree-env by #'cddr and
					    y in (cdr degree-env) by #'cddr 
				    collect x collect (/ y 90)))
				:duration duration)
	       (dist-scaler 0.0))
	  (run
	   (loop for i from beg below end do
	     (let ((rdval (* (readin rdA) (env amp-env)))
		   (degval (env deg-env))
		   (distval (env dist-env)))
	       (setf dist-scaler (/ 1.0 distval))
	       (setf (<em class=red>locsig-ref</em> loc 0) (* (- 1.0 degval) dist-scaler))
	       (setf (<em class=red>locsig-ref</em> loc 1) (* degval dist-scaler))
	       (when *reverb* 
                 (setf (<em class=red>locsig-reverb-ref</em> loc 0) (* reverb-amount (sqrt dist-scaler))))
	       (<em class=red>locsig</em> loc i rdval)))))
        (close-input f)))))
</small></pre>
<p>See also
<a name="make-roomsig"><em class=def>make-roomsig</em></a> in <a href="roomsig.cl">roomsig.cl</a>.
For a moving sound
source, see Fernando Lopez Lezcano's <a name="dlocsig"><em class=def>dlocsig</em></a>, documented in
<a href="dlocsig/index.html">dlocsig/index.html</a>.
</p>
<br>


<span class=bbox><h3><a name="functions">Useful functions</a></h3></span>

<p>There are several commonly-used functions that can occur in the run macro. These include
a few that look for all the world like generators.</p>
<pre>
  <a name="hz-&gt;radians"><em class=def>hz-&gt;radians</em></a> <i>freq</i>               convert <i>freq</i> to radians per sample
  <a name="radians-&gt;hz"><em class=def>radians-&gt;hz</em></a> <i>rads</i>               convert <i>rads</i> to Hz
  <a name="db-&gt;linear"><em class=def>db-&gt;linear</em></a> <i>dB</i>               convert <i>dB</i> to linear value
  <a name="linear-&gt;db"><em class=def>linear-&gt;db</em></a> <i>val</i>               convert <i>val</i> to dB
  <a name="times-&gt;samples"><em class=def>times-&gt;samples</em></a> <i>start</i> <i>duration</i>  convert <i>start</i> and <i>duration</i> from seconds to samples
  <a name="seconds-&gt;samples"><em class=def>seconds-&gt;samples</em></a> <i>secs</i>          convert <i>secs</i> to samples
  <a name="degrees-&gt;radians"><em class=def>degrees-&gt;radians</em></a> <i>degs</i>          convert <i>degs</i> to radians
  <a name="radians-&gt;degrees"><em class=def>radians-&gt;degrees</em></a> <i>rads</i>          convert <i>rads</i> to degrees
  <a name="clear-array"><em class=def>clear-array</em></a> <i>arr</i>                set all values in <i>arr</i> to 0.0
  <a name="sound-samples"><em class=def>sound-samples</em></a> filename         samples of sound according to header (can be incorrect)
  <a name="sound-frames"><em class=def>sound-frames</em></a> filename          samples per channel
  <a name="sound-datum-size"><em class=def>sound-datum-size</em></a> filename      bytes per sample
  <a name="sound-data-location"><em class=def>sound-data-location</em></a> filename   location of first sample (bytes)
  <a name="sound-chans"><em class=def>sound-chans</em></a> filename           number of channels (samples are interleaved)
  <a name="sound-srate"><em class=def>sound-srate</em></a> filename           sampling rate
  <a name="sound-header-type"><em class=def>sound-header-type</em></a> filename     header type (aiff etc)
  <a name="sound-data-format"><em class=def>sound-data-format</em></a> filename     data format (alaw etc)
  <a name="sound-length"><em class=def>sound-length</em></a> filename          true file length (for error checks)
  <a name="sound-duration"><em class=def>sound-duration</em></a> filename        file length in seconds
  <a name="mus-set-raw-header-defaults"><em class=def>mus-set-raw-header-defaults</em></a> srate chans data-format
  <a name="sound-max-amp"><em class=def>sound-max-amp</em></a> name vals        get max amp vals and times of file name in vals
  <a name="sound-loop-info"><em class=def>sound-loop-info</em></a> name vals      get loop info of file name in vals (make-integer-array 6)
  <a name="sound-set-loop-info"><em class=def>sound-set-loop-info</em></a> name vals  set loop info of file name to vals
  <a name="sound-format-name"><em class=def>sound-format-name</em></a> format       format name as string
  <a name="sound-type-name"><em class=def>sound-type-name</em></a> type           type name as string
</pre>

<p>Also add-mark, marks, mark-channel, and mark-sample.</p>

<b>hz-&gt;radians</b>
converts its argument to radians/sample (for any situation where a
frequency is used as an amplitude, glissando or FM, for example).  It
can be used within run. hz-&gt;radians is equivalent to 
<pre>
  Freq-in-hz * 2 * pi / *srate*.  
</pre>
<blockquote>
<p><small>
<i>Freq-in-hz</i> * 2 * pi gives us the number of radians traversed per
second; we then divide by the number of samples per second to get the
radians per sample; in dimensional terms: (radians/sec) /
(sample/sec) = radians/sample.  We need this conversion whenever a
frequency-related value is actually being accessed on every sample, as
an increment of a phase variable, for example.  (We are also assuming
our wave table size is 2 * pi). This conversion value was named "mag"
in Mus10 and "in-hz" in CLM-1.  The inverse is radians-&gt;hz.
</small></p></blockquote>


<!-- TOPIC polynomial -->
<span class=cbox><h4>POLYNOMIAL</h4></span>
<pre>
   <a name="polynomial"><em class=def>polynomial</em></a> <i>coeffs x</i>
</pre>
<p><i>Coeffs</i> is an array of coefficients, <i>x</i> is the value to be plugged
into the polynomial.  <i>Coeffs</i>[0] is the constant term, and so on.  For
waveshaping, use the function <a href="#partials-&gt;polynomial">partials-&gt;polynomial</a>.
Abramowitz and Stegun, "A Handbook of Mathematical Functions" is a
treasure-trove of interesting polynomials.</p>
<pre><small>
(definstrument <a name="bigbird">BigBird</a> (start duration frequency freqskew amplitude
                          freq-env amp-env partials)
  (multiple-value-bind (beg end) (times-&gt;samples start duration)
    (let* ((gls-env (make-env freq-env (hz-&gt;radians freqskew) duration))
           (os (make-oscil frequency))
           (fil (make-one-pole .1 .9))
           (coeffs (<em class=red>partials-&gt;polynomial</em> (normalize-partials partials)))
           (amp-env (make-env amp-env amplitude duration)))
      (run
        (loop for i from beg below end do
          (outa i 
            (one-pole fil 
              (* (env amp-env) 
                 (<em class=red>polynomial</em> coeffs (oscil os (env gls-env)))))))))))
</small></pre>
<p>See also the <a href="#brighten">brighten</a> instrument.</p>
<br>

<!-- TOPIC array-interp -->
<span class=cbox><h4>ARRAY-INTERP, DOT-PRODUCT, SUM-OF-SINES</h4></span>
<pre>
  <a name="array-interp"><em class=def>array-interp</em></a> <i>fn x</i> &amp;optional <i>size</i>
  <a name="dot-product"><em class=def>dot-product</em></a> <i>in1 in2</i> &amp;optional (<i>start</i> 0)
  <a name="sum-of-sines"><em class-def>sum-of-sines</em></a> <i>amps phases</i>
</pre>
<p>These simple functions underlie some of the generators, and can be
called within run, if you want to roll your own.  See <a href="mus.lisp">mus.lisp</a> for
details. Array-interp can be used for companding and similar functions --
load the array (call it "compander" below) with the positive half 
of the companding function, then:
</p>
<pre>
  (let ((in-val (readin rd))            ; in-coming signal
        (func-len (length compander)))  ; size of array
    (* (signum in-val) 
       (array-interp compander (abs (* in-val (1- func-len))) func-len)))
</pre>
<p>sum-of-sines simply loops through its arrays of amps and phases, summing
(* amp (sin phase)) -- it is mostly a convenience function for additive synthesis.
<br>

<br>
<!-- TOPIC contrast-enhancement -->
<span class=cbox><h4>CONTRAST-ENHANCEMENT</h4></span>
<pre>
   <a name="contrast-enhancement"><em class=def>contrast-enhancement</em></a> <i>in-samp</i> &amp;optional (<i>fm-index</i> 1.0)
</pre>
<p><b>Contrast-enhancement</b> phase-modulates a sound file.  It's like audio MSG.
The actual algorithm is sin(<i>in-samp</i>*pi/2 +
(<i>fm-index</i>*sin(<i>in-samp</i>*2*pi))).  The result is to brighten the
sound, helping it cut through a huge mix.</p>

<p><small>
Waveshaping can provide a similar effect:</p>
<pre>
(definstrument <a name="brighten">brighten</a> (start duration file file-maxamp partials)
  (multiple-value-bind (beg end) (times-&gt;samples start duration)
    (let ((fil (open-input* file)))
      (when fil
        (unwind-protect
	  (let ((coeffs (partials-&gt;polynomial (normalize-partials partials)))
		(rd (make-readin fil)))
	    (run (loop for i from beg below end do
		   (outa i (* file-maxamp (polynomial coeffs (/ (readin rd) file-maxamp)))))))
	  (close-input fil))))))

(with-sound () (brighten 0 3 "oboe" .15 '(1 1 3 .5 7 .1)))
</pre>
<blockquote>
<p>In this case, it is important to scale the file input to the waveshaper to go from
-1.0 to 1.0 to get the full effect of the Chebychev polynomials.  Unfortunately,
if you don't add an overall amplitude envelope to bring the output to 0, you'll
get clicks if you include even numbered partials.  These partials create a non-zero
constant term in the polynomial, so when the sound decays to 0, the polynomial
output decays to some (possibly large) non-zero value.  In the example above,
I've used only odd partials for this reason.</small></p>
</blockquote>
<br>

<!-- TOPIC amplitude-modulate -->
<span class=cbox><h4>RING-MODULATE, AMPLITUDE-MODULATE</h4></span>

<pre>
  <a name="ring-modulate"><em class=def>ring-modulate</em></a> <i>in1 in2</i>
  <a name="amplitude-modulate"><em class=def>amplitude-modulate</em></a> <i>am-carrier input1 input2</i>
</pre>
<b>Ring-modulate</b> returns (* <i>in1</i> <i>in2</i>).
<b>Amplitude-modulate</b> returns (* <i>input1</i> (+ <i>am-carrier</i> <i>input2</i>))

<p>Since neither needs any state information, there are no associated "make"
functions.</p>

<p>Both of these take advantage of the "Modulation Theorem"; since
multiplying a signal by a phasor (e ^ (j w t)) translates its spectrum by w /
two-pi Hz, multiplying by a sinusoid splits its spectrum into two equal parts
translated up and down by w/two-pi Hz.  The simplest case is: </p>
<pre>
   cos f1 * cos f2 = (cos (f1 + f2) + cos (f1 - f2)) / 2.
</pre>
<br>


<!-- TOPIC fft -->
<!-- INDEX fft:Fourier transforms  -->
<span class=bbox><h3>FFT</h3></span>
<pre>
  <a name="fft"><em class=def>fft</em></a> <i>rdat idat fftsize</i> &amp;optional <i>sign</i>
  <a name="make-fft-window"><em class=def>make-fft-window</em></a> <a href="#optional-key">&amp;optional-key</a> <i>type size</i> (<i>beta</i> 2.5)
  <a name="multiply-arrays"><em class=def>multiply-arrays</em></a> <i>rdat</i> <i>window</i>
  <a name="rectangular-&gt;polar"><em class=def>rectangular-&gt;polar</em></a> <i>rdat</i> <i>idat</i>
  <a name="spectrum"><em class=def>spectrum</em></a> <i>rdat</i> <i>idat</i> <i>window</i> <i>norm-type</i>
  <a name="convolution"><em class=def>convolution</em></a> <i>rdat</i> <i>idat</i> <i>size</i>
</pre>
<p>These provide run-time access to the standard fft routines and their habitual companions.
<b>make-fft-window</b> can return many of the standard windows including:</p>
<pre>
  <i>rectangular-window</i>   ;no change in data
  <i>bartlett-window</i>      ;triangle
  <i>parzen-window</i>        ;raised triangle
  <i>welch-window</i>         ;parzen squared
  <i>hanning-window</i>       ;cosine
  <i>hamming-window</i>       ;raised cosine
  <i>blackman2-window</i>     ;Blackman-Harris windows of various orders
  <i>blackman3-window</i>
  <i>blackman4-window</i>
  <i>exponential-window</i>
  <i>kaiser-window</i>        ;<i>beta</i> argument used here
</pre>
<p>The
magnitude of the spectrum is returned by <b>rectangular-&gt;polar</b>.  The data can be windowed
with <b>multiply-arrays</b>.  <b>Spectrum</b> calls the fft, translates to polar coordinates,
then returns results in dB (<i>norm-type</i> = 0), or linear normalized to 1.0 (<i>norm-type</i> = 1),
or linear unnormalized (<i>norm-type</i> not 0 or 1). 
</p>
<p>The following instrument implements fft overlap-add, but instead
of scaling the various spectral components to filter a sound, it reverses a portion
of the spectrum, a distortion that can be effective with speech sounds.</p>
<pre>
<small>
(definstrument <a name="inside-out">inside-out</a> (beg dur file amp lo hi &amp;optional (fftsize 1024))
  ;; fft overlap-add (and buffer), but the fft bins between lo and hi are reversed
  (let ((fil (open-input* file)))
    (when fil
      (unwind-protect
        (let* ((start (floor (* beg *srate*)))
               (end (+ start (floor (* dur *srate*))))
               (fdr (make-double-float-array fftsize))
               (fdi (make-double-float-array fftsize))
               (wtb (make-double-float-array fftsize))
               (filptr 0)
               (fft2 (floor fftsize 2))
               (fft4 (floor fftsize 4))
               (ctr fft2)
               (fftn (/ 1.0 fftsize))
               (first-time 1)
               (mid (* .5 (+ hi lo))))
	  (when (zerop lo) (setf lo 1))
          (run
           (loop for i from start below end do
             (when (= ctr fft2)
               (<em class=red>clear-array</em> fdr)
               (<em class=red>clear-array</em> fdi)
               (dotimes (k fft2)
                 (setf (aref fdr (+ k fft4)) (* (ina filptr fil) fftn))
                 (incf filptr))
               (<em class=red>fft</em> fdr fdi fftsize 1)
               (let ((j1 hi) ;now reverse bins between lo and hi
                     (k0 (- fftsize lo))
                     (k1 (- fftsize hi)))
                 (loop for j0 from lo to mid do
                   (let ((tmprj (aref fdr j0))
                         (tmprk (aref fdr k0))
                         (tmpij (aref fdi j0))
                         (tmpik (aref fdi k0)))
                     (setf (aref fdr j0) (aref fdr j1))
                     (setf (aref fdr j1) tmprj)
                     (setf (aref fdr k0) (aref fdr k1))
                     (setf (aref fdr k1) tmprk)
                     (setf (aref fdi j0) (aref fdi j1))
                     (setf (aref fdi j1) tmpij)
                     (setf (aref fdi k0) (aref fdi k1))
                     (setf (aref fdi k1) tmpik)
                     (incf k1)
                     (decf k0)
                     (decf j1))))
               (<em class=red>fft</em> fdr fdi fftsize -1)
               (dotimes (k fft2)
                 (setf (aref wtb k) (aref wtb (+ k fft2)))
                 (setf (aref wtb (+ k fft2)) 0.0))
               (if (= first-time 1)
                   (progn
                     (dotimes (k fftsize) (setf (aref wtb k) (aref fdr k)))
                     (setf first-time 0)
		     (setf ctr fft4))
                 (progn
                   (dotimes (k fft2) (incf (aref wtb k) (aref fdr k)))
                   (dotimes (k fft2) (setf (aref wtb (+ k fft2)) (aref fdr (+ k fft2))))
		   (setf ctr 0))))
             (outa i (* amp (aref wtb ctr)))
             (incf ctr))))
        (close-input fil)))))

(with-sound () (inside-out 0 1.0 "fyow" 1.0 3 8))
</small>
</pre>
<p>See the <a href="#cross-synthesis">cross-synthesis</a> instrument above, 
<a href="ugex.ins">ugex.ins</a>, <a href="san.ins">san.ins</a>,
and <a href="anoi.ins">anoi.ins</a>
for more examples.</p>
<pre><small>
(definstrument spectr (infile outfile &amp;optional (fftsize 128))
  (let* ((fdi (make-double-float-array fftsize))
	 (fdr (make-double-float-array fftsize))
	 (win (<em class=red>make-fft-window</em> blackman2-window fftsize))
	 (in-file (open-input* infile))
	 (out-file (mus-open-write outfile))
	 (k 0)
	 (freqsize (floor fftsize 2))
	 (end (sound-frames infile)))
    (run 
     (loop for i from 0 below end do
       (let ((inval (ina i in-file)))
	 (setf (aref fdr k) inval)
	 (incf k)
	 (when (>= k fftsize)
	   (setf k 0)
	   (<em class=red>spectrum</em> fdr fdi win 1)
	   (clm-print out-file "~%sample: ~D~%" i)
	   (dotimes (ctr freqsize)
	     (clm-print out-file "  (~,3F ~,3F)"
			(/ (* ctr *srate*) fftsize)
			(aref fdr ctr)))))))
    (close-input in-file)
    (mus-close out-file)))
</small></pre>
<br>

<!-- TOPIC def-clm-struct -->
<span class=cbox><h4><a name="def-clm-struct">def-clm-struct</a></h4></span>

<p><b>Def-clm-struct</b> is syntactically like def-struct, but sets up
the struct field names for the run macro.</p>
<pre><small>
  (<em class=red>def-clm-struct</em> hi ho silver away)
  (definstrument simp ()
    (let ((ha (make-hi :ho (make-array 1 :element-type 'envelope 
                             :initial-element (make-env :envelope '(0 0 100 1) 
                                                        :scaler .1 :end 10)))))
      (run
        (loop for i from 0 to 10 do
          (outa i (env (aref (hi-ho ha) 0)))))))
</small></pre>
<p>See prc-toolkit95.lisp for many examples.</p>
<br>


<!-- TOPIC definstrument -->
<span class=bbox><h3><a name="definstrument">Definstrument</a></h3></span>

<p><b>Definstrument</b> is the most common way to define an instrument in CLM.
Its syntax is almost the same as defun, but in addition it has a
few options.  These fulfill two roles:  specifying instrument output language
details, and requesting minor optimizations.  The options are in a state of
flux; currently they are:</p>
<pre>
  language  :c or :lisp ; specify output language (C is the default where possible)
  c-file  nil           ; specify the instrument intermediate C file name
  c-include-file  nil   ; C code to be #include'd in the intermediate file
  c-options  "-c -O"    ; C compiler switches
  parallel nil          ; a "sample-synchronous" instrument -- defpinstrument
  type                  ; can be :parallel or nil -- will replace the "parallel" argument
  print-function
</pre>
<p>The output language is chosen based on the kind of CLM you load.  In most cases,
it defaults to :c.
The :lisp option is useful during debugging.  The syntax for these options is somewhat similar to that of <a href="#with-sound">with-sound</a>.
For example, to specify that the instrument simp should use C with the "-c -O3"
flags, </p>
<pre>
   (definstrument (simp :language :c :c-options "-c -O3") (beg dur)
   ...)
</pre>

<p><a name="defpinstrument"><em class=def>Defpinstrument</em></a> produces
an instrument that is handled by a special scheduler that runs
it one sample at a time, in parallel with all other p-instruments that want to
run on that sample.
P-instruments can be mixed
freely with "normal" instruments.  The latter run to completion when they are
called, while the currently running p-instruments wait in the background.
Obviously, calls on these
instruments must be ordered by begin-time.</p>

<!-- TOPIC instruments -->
<!-- INDEX ins-files:Instruments --><a name="ins-files"></a>
<p>The following instruments are included as separate .ins files in the clm
directory (see also <a href="ins">ins</a>):</p>

<table border=8 bordercolor="lightgreen">
<tr><td width=170>complete-add</td><td width=180><a href="add.ins">add.ins</a></td><td>additive synthesis</td></tr>
<tr><td>addflts</td><td><a href="addflt.ins">addflt.ins</a></td><td>filters</td></tr>
<tr><td>add-sound</td><td><a href="addsnd.ins">addsnd.ins</a></td><td>mix in a sound file</td></tr>
<tr><td>anoi</td><td><a href="anoi.ins">anoi.ins</a></td><td>noise reduction</td></tr>
<tr><td>badd</td><td><a href="badd.ins">badd.ins</a></td><td>fancier additive synthesis</td></tr>
<tr><td>fm-bell</td><td><a href="bell.ins">bell.ins</a></td><td>fm bell sounds</td></tr>
<tr><td>bessel stuff</td><td><a href="bessel.lisp">bessel.lisp</a></td><td>special functions and related instruments</td></tr>
<tr><td>bigbird</td><td><a href="bigbird.ins">bigbird.ins</a></td><td>waveshaping (<a href="bird.clm">bird.clm</a> and <a href="bird.ins">bird.ins</a>)</td></tr>
<tr><td>canter</td><td><a href="canter.ins">canter.ins</a></td><td>fm (<a href="bag.clm">bag.clm</a> -- bagpipes)</td></tr>
<tr><td>cellon</td><td><a href="cellon.ins">cellon.ins</a></td><td>feedback fm</td></tr>
<tr><td>cnvrev</td><td><a href="cnv.ins">cnv.ins</a></td><td>convolution (aimed at reverb)</td></tr>
<tr><td>moving sounds</td><td><a href="dlocsig/dlocsig.lisp">dlocsig/dlocsig.lisp</a></td><td>quad sound movement</td></tr>
<tr><td>drone</td><td><a href="drone.ins">drone.ins</a></td><td>additive synthesis (<a href="bag.clm">bag.clm</a>)</td></tr>
<tr><td>granulate-sound</td><td><a href="expsrc.ins">expsrc.ins</a></td><td>examples of the granulate generator (granular synthesis)</td></tr>
<tr><td>cross-fade</td><td><a href="fade.ins">fade.ins</a></td><td>cross-fades and dissolves in the frequency domain</td></tr>
<tr><td>filter-noise</td><td><a href="fltnoi.ins">fltnoi.ins</a></td><td>filter with envelopes on coefficients</td></tr>
<tr><td>filter-sound</td><td><a href="fltsnd.ins">fltsnd.ins</a></td><td>filter a sound file</td></tr>
<tr><td>stereo-flute</td><td><a href="flute.ins">flute.ins</a></td><td>physical model of a flute (Nicky Hind)</td></tr>
<tr><td>fm examples</td><td><a href="fmex.ins">fmex.ins</a></td><td>fm bell, gong, drum</td></tr>
<tr><td>fm-insect</td><td><a href="insect.ins">insect.ins</a></td><td>fm</td></tr>
<tr><td>fullmix</td><td><a href="fullmix.ins">fullmix.ins</a></td><td>a mixer</td></tr>
<tr><td>grani</td><td><a href="grani.ins">grani.ins</a></td><td>granular synthesis (Fernando Lopez-Lezcano)</td></tr>
<tr><td>grapheq</td><td><a href="grapheq.ins">grapheq.ins</a></td><td>graphic equalizer</td></tr>
<tr><td>jc-reverb</td><td><a href="jcrev.ins">jcrev.ins</a></td><td>an old reverberator (jlrev is a cavernous version)</td></tr>
<tr><td>fm-voice</td><td><a href="jcvoi.ins">jcvoi.ins</a></td><td>jc's fm voice</td></tr>
<tr><td>kiprev</td><td><a href="kiprev.ins">kiprev.ins</a></td><td>a fancier (temperamental) reverberator</td></tr>
<tr><td>lbj-piano</td><td><a href="lbjPiano.ins">lbjPiano.ins</a></td><td>additive synthesis piano</td></tr>
<tr><td>mlb-voice</td><td><a href="mlbvoi.ins">mlbvoi.ins</a></td><td>mlb's fm (originally waveshaping) voice</td></tr>
<tr><td>moog filters</td><td><a href="moog.lisp">moog.lisp</a></td><td>Moog filters (also <a href="filter-noise.ins">filter-noise.ins</a>) (Fernando Lopez-Lezcano)</td></tr>
<tr><td>fm-noise</td><td><a href="noise.ins">noise.ins</a></td><td>noise maker</td></tr>
<tr><td>nrev</td><td><a href="nrev.ins">nrev.ins</a></td><td>a popular reverberator</td></tr>
<tr><td>p</td><td><a href="piano.ins">piano.ins</a></td><td>Scott van Duyne's piano physical model</td></tr>
<tr><td>pluck</td><td><a href="pluck.ins">pluck.ins</a></td><td>Karplus-Strong synthesis</td></tr>
<tr><td>pqw</td><td><a href="pqw.ins">pqw.ins</a></td><td>waveshaping</td></tr>
<tr><td>pqw-vox</td><td><a href="pqwvox.ins">pqwvox.ins</a></td><td>waveshaping voice</td></tr>
<tr><td>physical models</td><td><a href="prc-toolkit95.lisp">prc-toolkit95.lisp</a></td><td>several physical modelling instruments</td></tr>
<tr><td>pvoc</td><td><a href="pvoc.ins">pvoc.ins</a></td><td>phase vocoder (Michael Klingbeil)</td></tr>
<tr><td>various ins</td><td><a href="prc96.ins">prc96.ins</a></td><td>fm and aditive synthesis from Perry Cook's Synthesis Toolkit</td></tr>
<tr><td>preverb</td><td><a href="preverb.ins">preverb.ins</a></td><td>realtime version of jc-reverb (jcrev.ins)</td></tr>
<tr><td>resflt</td><td><a href="resflt.ins">resflt.ins</a></td><td>filters (3 resonators)</td></tr>
<tr><td>reson</td><td><a href="reson.ins">reson.ins</a></td><td>fm (formants)</td></tr>
<tr><td>ring-modulate</td><td><a href="ring-modulate.ins">ring-modulate.ins</a></td><td>ring-modulation of sounds (Craig Sapp)</td></tr>
<tr><td>track-rms</td><td><a href="rms.ins">rms.ins</a></td><td>rms envelope of sound file (Michael Edwards)</td></tr>
<tr><td>pins</td><td><a href="san.ins">san.ins</a></td><td>spectral modelling</td></tr>
<tr><td>singer</td><td><a href="singer.ins">singer.ins</a></td><td>Perry Cook's vocal tract physical model</td></tr>
<tr><td>tc</td><td><a href="tc.ins">tc.ins</a></td><td>fft-based instruments</td></tr>
<tr><td>fm-trumpet</td><td><a href="trp.ins">trp.ins</a></td><td>fm trumpet (Dexter Morrill)</td></tr>
<tr><td>fm-violin</td><td><a href="v.ins">v.ins</a></td><td>fm violin (<a href="fmviolin.clm">fmviolin.clm</a>, <a href="popi.clm">popi.clm</a>)</td></tr>
<tr><td>various ins</td><td><a href="ugex.ins">ugex.ins</a></td><td>granular synthesis, formants, etc</td></tr>
<tr><td>test ins</td><td><a href="ug.ins">ug.ins</a>,<a href="ug1.ins">ug1.ins</a></td><td></td></tr>
<tr><td>vox</td><td><a href="vox.ins">vox.ins</a></td><td>fm voice (<a href="cream.clm">cream.clm</a>)</td></tr>
<tr><td>zc, zn</td><td><a href="zd.ins">zd.ins</a></td><td>examples of interpolating delays</td></tr>
<tr><td>zipper</td><td><a href="zipper.ins">zipper.ins</a></td><td>The 'digital zipper' effect.</td></tr>
</table>

<p>The file <a href="clm-test.lisp">clm-test.lisp</a> exercises most of these instruments. 
If you develop
an interesting instrument that you're willing to share, please send it to me
(bil@ccrma.stanford.edu). </p>

<p>Although all the examples in this document use run followed by a loop,
you can use other constructs instead:</p>
<pre><small>
(definstrument no-loop-1 (beg dur)
  (let ((o (make-oscil 660)))
    (run 
     (let ((j beg)) 
       (loop for i from 0 below dur do
	 (outa (+ i j) (* .1 (oscil o))))))))

(definstrument no-loop-2 (beg dur)
  (let ((o (make-oscil 440)))
    (run
     (dotimes (k dur)
       (outa (+ k beg) (* .1 (oscil o)))))))
</small></pre>
<p>And, of course, outa and locsig can be called any number of times
(including zero) per "sample" and at any output location.  Except in
extreme cases (spraying samples to random locations several seconds
apart), there is almost no speed penalty associated with such output,
so don't feel constrained to write an instrument as a sample-at-a-time loop.
That form was necessary in the old days, so nearly all current instruments
still use it (they are translations of older instruments), but there's no
good reason not to write an instrument such as:</p>
<pre><small>
(definstrument noisey (beg dur)
  (run
   (dotimes (i dur)
     (dotimes (k (random 10))
       (outa (+ beg (floor (random dur))) (centered-random .01))))))
</small></pre>
<p>See also the stick and stick1 instruments in ug.ins.
"Parallel" instruments must use loop (all such instruments are assumed to be running
in parallel, generating the "current sample" for the DACs).  It is also possible (albeit slow) to call
any of the run-oriented functions in with-sound:</p>
<pre>
(with-sound (:statistics t) 
  (let ((os (make-oscil 440)))
    (dotimes (i 5000) (outa i (* .1 (oscil os))))))
</pre>
<br>

<span class=box><h2><a name="note-lists">Note Lists</a></h2></span>
<!-- INDEX note-lists:Note lists  -->

<p>A note list in CLM is any lisp expression that opens an output sound file and calls an instrument.  The simplest way to
do this is with with-sound or clm-load.
</p>
<br>
<!-- TOPIC with-sound -->
<span class=bbox><h3>With-sound and clm-load</h3></span>
<pre>
 <a name="with-sound"><em class=def>with-sound</em></a> &amp;key 
   ;; <small>"With-sound: check it out!" -- Duane Kuiper, Giants broadcaster after Strawberry homer</small>
   (<i>output</i> <a href="#*clm-file-name*">*clm-file-name*</a>)  ; name of output sound file ("test.snd" normally)
   (<i>channels</i> <a href="#*clm-channels*">*clm-channels*</a>) ; can be any number (defaults to 1, see defaults.lisp)
   (<i>srate</i> <a href="#*clm-srate*">*clm-srate*</a>)       ; also 'sampling-rate' for backwards compatibility
   <i>continue-old-file</i>         ; open and continue old output file
   <i>reverb</i>                    ; name of the reverberator, if any.  The reverb
                             ;   is a normal clm instrument (see <a href="nrev.ins">nrev.ins</a>)
   <i>reverb-data</i>               ; arguments passed to the reverberator; an unquoted list
   (<i>reverb-channels</i> 1)       ; chans in temp reverb stream (input to reverb)
   <i>revfile</i>                   ; reverb file name
   (<i>play</i> *clm-play*)         ; play new sound automatically?
   (<i>notehook</i> *clm-notehook*) ; function evaluated on each instrument call
   <i>statistics</i>                ; print out various fascinating numbers
   (<i>decay-time</i> 1.0)          ; ring time of reverb after end of piece
   <i>comment</i>                   ; comment placed in header
   <i>info</i>                      ; non-comment header string
   (<i>header-type</i> <a href="#*clm-header-type*">*clm-header-type*</a>)  ; output file type (see also <a href="#header-types">header types</a>)
   (<i>data-format</i> <a href="#*clm-data-format*">*clm-data-format*</a>)  ; output data format (see <a href="#header-types">header types</a>)
   <i>save-body</i>                 ; if t, copy the body (as a string) into the header
   <i>scaled-to</i>                 ; if a number, scale results to have that max amp
   <i>scaled-by</i>                 ; scale output by some number
   (<i>clipped</i> *clm-clipped*)   ; if t, clip output rather than allowing data to wrap-around (has no effect in no-ffi versions)
   (<i>verbose</i> <a name="*clm-verbose*">*clm-verbose*</a>)
   (<i>force-recomputation</i> nil) ; if t, force with-mix calls to recompute
   (<i>explode</i> *clm-explode*)   ; if t, produce "exploded" output -- each instrument call becomes a separately mixed file in Snd
</pre>
<p><b>With-sound</b> is a macro that performs all the various services needed to
produce and play a sound file; it also wraps an "unwind-protect" around its body to
make sure that everything is cleaned up properly if you happen to interrupt
computation, then returns the output file name.  Here are some examples showing how to use the various options:</p>
<pre>
  (with-sound (:output "new.snd") (simp 0 1 440 .1))
  (with-sound (:srate 44100 :channels 2) ...)
  (with-sound (:comment (format nil 
     "This version is louder: ~A" (make-header))))
  (with-sound (:reverb jc-reverb) ...)
  (with-sound (:reverb nrev :reverb-data (:reverb-factor 1.2 :lp-coeff .95))...)
</pre>
<p>With-sound can be called within itself, so, for example, you can make an output sound file
for each section of a piece as well as the whole thing, all in one run.  Since it is the basis of <a href="#mix-and-with-mix">with-mix</a> and
<a href="#sound-let">sound-let</a>, all of these can be nested indefinitely:</p>
<pre>
<small>
(with-sound () 
  (mix (with-sound (:output "hiho.snd") 
            (fm-violin 0 1 440 .1))
          :amplitude .5))

(with-sound ()
  (with-mix () "s1" 0
    (sound-let ((tmp ()
                  (fm-violin 0 1 440 .1)))
      (mix tmp))))

(with-sound (:verbose t)
  (with-mix () "s6" 0
    (sound-let ((tmp ()
                  (fm-violin 0 1 440 .1))
                (tmp1 (:reverb nrev)
                  (mix "oboe.snd")))
      (mix tmp1)
      (mix tmp :amplitude .2 :output-frame *srate*))
    (fm-violin .5 .1 330 .1)))

(with-sound (:verbose t)
  (sound-let ((tmp ()
                (with-mix () "s7" 0
                  (sound-let ((tmp ()
                                (fm-violin 0 1 440 .1))
                              (tmp1 ()
                                (mix "oboe.snd")))
                   (mix tmp1)
                   (mix tmp :output-frame *srate*))
                 (fm-violin .5 .1 330 .1))))
    (mix tmp :amplitude .5)))
</small>
</pre>
<p>You can call with-sound within an instrument:</p>
<pre>
<small>
(definstrument msnd (beg dur freq amp)
  (let ((os (make-oscil freq)))
    (run
     (loop for i from beg below (+ beg dur) do
       (outa i (* amp (oscil os)))))))

(definstrument call-msnd (beg dur sr amp)
  (let* ((temp-file (<em class=red>with-sound</em> (:output "temp.snd") (msnd 0 dur 440.0 .1)))
	 (tfile (open-input temp-file))
	 (reader (make-src :file tfile :srate sr))
	 (new-dur (/ dur sr)))
    (run
     (loop for i from beg below (+ beg new-dur) do
       (outa i (* amp (src reader)))))
    (close-input tfile)
    (delete-file temp-file)))
</small>
</pre>
<p>But enough fun...
Besides the obvious options like :reverb and :srate, the most useful ones are :scaled-to and
:statistics.
<i>Statistics</i>, if t (the default is nil), causes clm
to keep track of a variety of interesting things and print them out at the end
of the computation.  <i>Scaled-to</i> tells clm to make sure the final output
file has a max-amp of whatever the argument is to :scaled-to -- that is,</p>
<pre>
(with-sound (<em class=red>:scaled-to</em> .5) 
  (dotimes (i 32) (mix "oboe.snd" :output-frame (* i *srate*))))
</pre>
<p>will produce test.snd with a max-amp of .5, no matter how loud the intermediate
mix actually is (within reason -- the current true intermediate max-amp is
128.0 (if using the default sndlib settings)).  Similarly, the <i>scaled-by</i> argument causes all the output to
be scaled (in amplitude) by its value.</p>
<pre>
(with-sound (<em class=red>:scaled-by</em> 2.0) (fm-violin 0 1 440 .1)) 
</pre>
<p>produces a note that is .2 in amplitude.
<a name="scaled-by"><em class=def>scaled-by</em></a> scales its body by
its first argument (much like <a href="#with-offset">with-offset</a>):</p>
<pre>
  (with-sound () 
    (fm-violin 0 1 440 .1)
    (<em class=red>scaled-by</em> 2.0
      (fm-violin 0 .25 660 .1)) ;actual amp is .2
    (fm-violin .5 440 .1))
</pre>
<p>There is also the parallel macro <a name="scaled-to"><em class=def>scaled-to</em></a>.
These are built on the macro <a name="with-current-sound"><em class=def>with-current-sound</em></a>
which sets up an embedded with-sound call with all the current with-sound arguments in place
except output, comment, scaled-to, and scaled-by.</p>

<p>Other options that might need explanation are :notehook and :continue-old-file.</p>

<p><a name="notehook">Notehook</a> declares a function that is evaluated each time any instrument is called.
The arguments passed to the notehook function are the current instrument name (a string) and all its
arguments.  For example, the following prints out the instrument arguments for any
calls on simp that are encountered:</p>
<pre>
(with-sound (<em class=red>:notehook</em>
              #'(lambda (name &amp;rest args) 
		  (when (string-equal name "simp")
	            (print (format nil "(simp ~{~A ~})" args))
                    (force-output))))
  (simp 0 1 440 .1)
  (toot .5 .5 660 .2))
</pre>
<p>If the notehook function returns :done, the instrument exits immediately.
</p>


<p><i>Continue-old-file</i>, if t (the default is nil), re-opens a previously existing file
for further processing.  The default clobbers any existing file
of the same name as the output file (see <i>output</i> above).  By using
<i>continue-old-file</i>, you can both add new stuff to an existing file, or
(by subtracting) delete old stuff to any degree of selectivity.  When you erase
a previous note, remember that the subtraction has to be exact; you have
to create exactly the same note again, then subtract it.  By the same token,
you can make a selected portion louder or softer by adding or subtracting a
scaled version of the original.  
The option <i>data-format</i> underlies :scaled-to.
CLM can read and write sound data in all the currently popular formats,
leaving aside propietary compression schemes.  The names used in
:data-format can be found in <a href="initmus.lisp">initmus.lisp</a>,
along with the headers CLM knows about.</p>
 
<p><a name="clm-load"><em class=def>Clm-load</em></a> is the same as with-sound, but its first argument is the name
of a file containing clm instrument calls (i.e. the body of
with-sound), the reverb argument is the name of the reverb function,
and the reverb-data argument is the list; that is, clm-load's arguments
look like "normal" lisp, whereas with-sound's are unquoted in these two cases.</p>
<pre>
  (with-sound (:reverb jc-reverb :reverb-data (:volume .3)) ...)
  (clm-load "test.clm" :reverb 'jc-reverb :reverb-data '(volume .3))
</pre>
<p>All the run-time generators and functions discussed above can be called
directly (that is, outside any instrument) in with-sound: (with-sound () (outa 3 .1)). 
Global amplitude envelopes can be handled with eref, and so on.</p>

<p>The with-sound output is normally sent to the speakers via the <b>dac</b> function.
There are several associated functions:</p>
<pre>
  <a name="dac"><em class=def>dac</em></a> &amp;optional <i>file</i>
  <a name="stop-dac"><em class=def>stop-dac</em></a>
  <a name="volume"><em class=def>volume</em></a> &amp;optional (<i>device</i> +default-device+) <i>channel</i>
</pre>
<p><b>dac</b> starts playing <i>file</i> (or the last file played, if no
argument is given); in some cases (MCL and ACL) it then returns to the lisp listener;
to interrupt the dac in those cases, use <b>stop-dac</b>.  To set the dac volume
(setf (<em class=red>volume</em>) 1.0).  Similarly (<em class=red>volume</em>)
returns the current volume settings.</p>

<span class=cbox><h4><a name="howtowsm">How to use many machines at once</a></h4></span>
<!-- INDEX howtowsm:Multi-host with-sound -->

<p><small>[under construction]</small></p>

<pre>
  <a name="wsm"><em class=def>wsm</em></a> (<i>helpers</i> ...)       ; multi-host with-sound
  <a name="be-helpful "><em class=def>be-helpful </em></a> ()          ; start helper process
  <a name="stop-helpers"><em class=def>stop-helpers</em></a> ()         ; stop all helper process
  <a name="stop-helper"><em class=def>stop-helper</em></a> (<i>host</i>)      ; stop one helper
  <a name="fixup-helpers"><em class=def>fixup-helpers</em></a> ()        ; try to recover from communication errors
  <a name="tell-helpers"><em class=def>tell-helpers</em></a> ()         ; send form to be evaluated by all helpers
  <a name="remote-read"><em class=def>remote-read</em></a> (<i>socket</i>)    ; read form from helper
  <a name="remote-write"><em class=def>remote-write</em></a> (<i>socket</i> <i>form-as-text</i>) ; write form to helper
</pre>

<p>If you have several machines connected by a reasonably fast net,
and you're running ACL or MCL, you can use a variant of with-sound
that parcels out the note calls to all the machines in parallel.
<b>wsm</b> is the with-sound replacement's name; many of with-sound's
special features aren't implemented yet.  wsm takes one additional
argument: <i>helpers</i> which is a list of host names; these are
the machines you want to use to compute the wsm body.  The names can
be either the machine name or its dotted decimal IP address. On each
such machine, start CLM, load all instruments and other files that
you will need during the with-sound computation, then call <b>be-helpful</b>.
be-helpful simply sits watching the net for a CLM out there that wants
help, and tries to provide it.  On the main machine, replace
your with-sound call with wsm, and cross your fingers.
A sample wsm call is:</p>
<pre>
(<em class=red>wsm</em> (:<em class=red>helpers</em> '("gogtab")) (fm-violin 0 1 440 .1))
</pre>
<p>where "gogtab" is the name of a machine on the net.
If someone logs in on a machine you're using as
a helper, a message will be sent to the main machine.
To stop using
all helpers, call <b>stop-helpers</b>.  In ACL CLM will try to call this
itself when you exit the main lisp.  To stop one helper, call (<b>stop-helper</b> <i>hostname</i>).
"Stopping" a helper only closes the helper's net connection and exits the
be-helpful function.  Similarly, if something goes wrong, it may be possible
to get back to a clean slate by calling <b>fixup-helpers</b>.
If you forgot to load something
on a helper before calling be-helpful, you can call <b>tell-helpers</b>
or <b>remote-write</b>.  These pass a form to a helper which the helper
then evaluates in its own context.  For example, say we have a
helper connected to socket 5 (you can see the socket numbers in the clm::all-helpers list),
and want it to load "forgetful.cl":</p>
<pre>
  (remote-write 5 "(load \"forgetful.cl\")")
</pre>
<p>The backslashes are lisp's way of including double quotes in a string.
The main machine can double as a helper if you run a second clm image
and write the wsm output to someplace other than the default output.
The various lisps in communication have to agree about case mode;
if you're using case-insensitive-upper mode on the main machine and
case-sensitive-lower mode on a helper, the helper is very likely to
complain about undefined functions and whatnot.  CLM is currently
hard-wired to use tcp port number 1756.
</p>

<span class=cbox><h4>Direct to DAC and Realtime Controls</h4></span>
<!-- INDEX with-psound:Direct to DAC  -->
<pre>
  <a name="with-psound"><em class=def>with-psound</em></a> (&amp;key
    (<i>srate</i> *clm-srate*) 
    (<i>channels</i> *clm-channels*) 
    (<i>rec-chans</i> 0) (<i>rec-line</i> 0)
    <i>reverb</i> <i>reverb-duration</i>
    <i>bufsize</i> *clm-rt-bufsize*)
    (<i>data-format</i> mus-bshort)) &amp;body <i>body</i>
</pre>
<p><b>With-psound</b> runs its body in
real-time in the sense that the sound is sent directly to the DAC
as it is being computed.  The dac buffer size is <i>bufsize</i>,
which defaults to 1024.  This default avoids clicks and interruptions,
but can be sluggish if, for example, you're using with-psound to
run a real-time spectrum analyzer.
Obviously this only works if the body can be computed faster than
real-time. Ordinary C instruments can be handled if there's only
one note in the body; for more complex cases, use parallel
instruments (defpinstrument).  
Record (microphone) input is enabled when
<b>rec-chans</b> is greater than 0 (see <a href="#rec-any">rec-any</a>).
Reverb in this mode is handled currently by the
generator <b>previn</b> -- see rt.lisp and preverb.ins
for examples.  With-psound assumes it is dealing with
a precomputed notelist, and runs until all instruments
have stopped.  That is, in with-psound, time is always
moving forward and instruments that arrive behind the
current time will screw up.  The time moves forward only
as instruments come and go, however, and if you don't
send it notes, it simply waits for them, sending nothing
to the DAC and holding the current time suspended.
The current time in seconds from with-psound's
point of view is returned by the function current-real-time.
This kind of time management is not always (i.e. almost never) what you want in realtime
situations.  The alternative is:</p>

<pre>
  <a name="with-dac"><em class=def>with-dac</em></a> &amp;key
    (<i>srate</i> *clm-srate*) 
    (<i>channels</i> *clm-channels*) 
    (<i>rec-chans</i> 0)
    (<i>rec-line</i> 0) ;0=mic,1=analog in, 2=digital in
    <i>init-func</i>
    <i>run-func</i>
    (<i>data-format</i> mus-bshort)
</pre>
<p><b>With-dac</b> opens the dac and starts sending it buffers
of data.  It runs until told explicitly to stop, processing
whatever instruments are currently active.  <i>Init-func</i>
is a function of two arguments, the srate and number of
channels; any realtime control settings that need to be
done before you start should be handled here.  <i>Run-func</i>
is a function of one argument, the current time in seconds,
that is called constantly as long as with-dac is active.
It can return :quit which exits with-dac, :continue which
simply sends out the next buffer of data, or a number
which is the number of samples to wait until the next
call on the run-func.  With-dac currently is limited
to ACL on the SGI or Linux.</p>

<!-- INDEX realtimecontrols:Realtime Controls -->
<p><a name="realtimecontrols"></a>
Realtime control and value readback is handled in CLM through shared memory.
In the run loop
(or anywhere else for that matter), the function <b>control</b>
gets the current (float) value of some portion of this
memory; (setf (control n) val) sets it to val.  While lisp is running (most usefully while
with-psound or with-dac is running), any instrument or program can read or write these
values (via sliders or whatever) by accessing the same
memory.  Besides serving as real-time IO locations, these can also be used
for inter-instrument communication in "parallel" instruments; for example,
for example, spectral fusion effects involving shared frequency modulation
across instruments can be implemented with control.
Several complete examples can be found in the bess*.cl files.
The available control-related functions are:</p>
<pre>
  <a name="control"><em class=def>control</em></a> <i>n</i>
  <a name="open-controls"><em class=def>open-controls</em></a> <i>size</i>
  <a name="close-controls"><em class=def>close-controls</em></a>
  <a name="control-allocate"><em class=def>control-allocate</em></a> (&amp;optional (<i>size</i> 1))
  <a name="control-free"><em class=def>control-free</em></a> (<i>var</i>)
  <a name="make-controller"><em class=def>make-controller</em></a> <i>program</i> &amp;rest <i>args</i>
  <a name="fcontrol"><em class=def>fcontrol</em></a> <i>fc</i>
  <a name="make-fcontrol"><em class=def>make-fcontrol</em></a> <i>n</i> &amp;optional (<i>mult</i> 0.005)
  <a name="graph"><em class=def>graph</em></a> <i>sc val</i>
  <a name="make-graph"><em class=def>make-graph</em></a> <i>arr</i> <i>len</i> &amp;optional (<i>trigger</i> 0)
  <a name="fft-graph"><em class=def>fft-graph</em></a> <i>sc val win rl im</i>
  <a name="make-fft-graph"><em class=def>make-fft-graph</em></a> <i>arr len</i> &amp;optional (<i>trigger</i> 0) (<i>type</i> 0)
</pre>
<p>The functions <b>control-allocate</b> and <b>control-free</b> allocate
and release portions of shared memory.  If you don't call open-controls
yourself, the first control-allocate call will get a block of 4096 words (*clm-shared-memory-size*).
The <b>control</b> function accesses shared memory from Lisp or within the run
loop.  The external programatic access is through shmget and friends --
see the code generated by <b>make-controller</b>.  <b>fcontrol</b> is a
filtered version of control to smooth out the staircase functions you
get from slider widgets.  <b>make-graph</b> and <b>make-fft-graph</b>
display waveforms and ffts in realtime.  <b>make-controller</b>
provides a simple way to get a graphical interface up and running,
connected to its associated lisp code.  It takes the desired program
name (this program will have the widgets), an argument that is currently ignored,
and a list of widget descriptions.  It then sets up the
widgets on the screen in the order listed in the arguments, where
currently the descriptions are of the form, (index name &amp;rest description).
<i>Index</i> is the control location associated with this widget; <i>name</i> is the
label to place on or beside the widget; <i>description</i> describes the
widget and can be one of:</p>
<pre>
 :slider lo hi &amp;opt color
 :push (down = 1, caller should clear)
 :separator &amp;opt (height 4) (type :normal)
 :toggle default &amp;opt color (up = 0, down = 1)
 :label &amp;opt bgcolor fgcolor (shows current value)
 :graph xlabel ylabel -&gt; ready x0 x1 y0 y1 length [data]
 :midi channel status data-byte
</pre>
<p>If you want to watch a particular variable as an instrument
runs, set a control location to its value, and request a
label widget in the user-interface.  The files bess.cl
through bess6.cl give examples of these functions.
This portion of CLM currently works only on the SGI or
under Linux (though there's no reason it couldn't also
work on the Sun).</p>

<p>The :<a name="midi input">midi</a> input sets the associated control location 
to the value of the <i>data-byte</i> indicated (byte 1 or 2) if
something comes along that matches
the specified <i>channel</i> and <i>status</i>.  The raw data byte
is turned into a float (without scaling) and written
to the control location and some sort of indication is
posted in the controller.
I actually expect midi users to use make-controller to get the
basic interface up and running quickly, then edit the
midi handler themselves.  I'm not too interested in trying
to unravel all of midi's wierd cases.
Currently the midi support is limited to the SGI Irix 6.2
or later.
The examples are:
</p>
<pre>
  bess.cl   simple realtime controls on FM
  bess1.cl  complex FM with waveform and fft graphs, variable readback
  bess2.cl  fft of microphone/line input
  bess3.cl  trigger fm-violin calls via pushbuttons
  bess4.cl  realtime control of global and instrument-local variables
  bess5.cl  lisp composition algorithm with controls
  bess6.cl  midi control of clm instruments
</pre>
<br>

<!-- TOPIC with-mix -->
<!-- INDEX mix-and-with-mix:Checkpoints -->
<span class=bbox><h3><a name="mix-and-with-mix">With-mix</a></h3></span>
<pre>
  <a name="with-mix"><em class=def>with-mix</em></a> <i>options</i> <i>file</i> <i>begin</i> &amp;body <i>body</i>
</pre>
<p><i>With-mix</i> is a macro, callable within <a href="#with-sound">with-sound</a> or <a href="#clm-load">clm-load</a>,
which saves the computation in its body in a separate file named <i>file</i>
(without the .snd extension), and can tell when that file's data is up to date
and need not be recomputed.   This is equivalent to <a href="#open-input">open-input</a>.
</p>
<pre>
  (with-sound () 
    (fm-violin 0 .1 440 .1)
    (<em class=red>with-mix</em> () "sec1" .5 
      (fm-violin 0 .1 550 .1)
      (fm-violin .1 .1 660 .1))
    (<em class=red>with-mix</em> (:reverb jc-reverb) "sec2" 1.0
      (fm-violin 0 .1 880 .1 :reverb-amount .2)
      (fm-violin .1 .1 1320 .1 :reverb-amount .2))
    (fm-violin 2 .1 220 .1)
    (<em class=red>mix</em> "/zap/slow.snd"))
</pre>
<p>Now, if we change just the first note in the with-mix call, the
second with-mix section will not be recomputed, but will be mixed in from the
saved file "sec2.snd".  By surrounding stable sections of a piece with calls on
mix or with-mix, you can save a huge amount of time that would
otherwise be spent waiting for these notes to be recomputed.  This check-point
or makefile capability is built on <a href="#open-input">open-input</a>.</p>

<blockquote>
<small>
<p>
With-mix performs a string comparison of its body to decide whether
it needs to recompute its note calls.  It then loads that body from
a separate saved file.  This can be confusing if global variables
are present.</p>
<pre>
  &gt; USER(2): (let ((rstr .1)) (with-sound () (with-mix () "sec" 0 (fm-violin 0 1 440 rstr))))
  &gt; ; Loading /zap/sec.clm
  &gt; Error: Attempt to take the value of the unbound variable `RSTR'.
</pre>
<p>Here the code evaluated is basically
<code>
(let ((rstr .1)) (load "/zap/sec.clm"))
</code>
where rstr has lexical scope.  To make rstr visible within the load,</p>
<pre>
  (let ((rstr1 .1)) 
    (declare (special rstr1))
    (with-sound () (with-mix () "sec" 0 (fm-violin 0 1 440 rstr1))))
</pre>
<p>but if you then evaluate the same form again, changing rstr1 to (say) .5,
with-mix does not notice that rstr1's value has changed, so
it does not recompute its body, leaving the resultant amplitude at .1.
</p>
</small>
</blockquote>
<br>

<p>The fastest way to mix sound files is with <b>mix</b>:</p>
<pre>
  <a name="mix"><em class=def>mix</em></a> &amp;optional-key <i>filename</i> (<i>input-frame</i> 0) (<i>output-frame</i> 0) <i>frames</i> 
                       (<i>amplitude</i> 1.0) output (<i>prescaler</i> 1.0)
</pre>
<hr>

<!-- TOPIC sound-file-io -->
<!-- INDEX open-input:Sound file IO -->
<pre>
  <a name="open-input"><em class=def>open-input</em></a> &amp;optional <i>name</i> &amp;key <i>verbose if-does-not-exist element-type mix-at  
             mix-duration force-recomputation start channel end channel bufsize prescaler</i>
  <a name="open-output"><em class=def>open-output</em></a> &amp;optional (<i>name</i> *clm-file-name*)
  <a name="close-input"><em class=def>close-input</em></a> &amp;optional (<i>i-stream</i> *input*)
  <a name="close-output"><em class=def>close-output</em></a> &amp;optional (<i>o-stream</i> *output*)
  <a name="reopen-output"><em class=def>reopen-output</em></a> &amp;optional (<i>o-stream</i> *clm-file-name*)
  <a name="open-input*"><em class=def>open-input*</em></a> <i>name</i> &amp;key <i>start channel restartable</i>
</pre>
<p>These functions open and close input and output sound files.  <b>Open-input</b>
and <b>open-output</b> take either strings or pathnames and return an IO object
(see <a href="io.lisp">io.lisp</a> for a description of the innards of this structure).  Various clm
functions use that object as a handle on the file.  The variable
<b>*clm-file-name*</b>, used as the default name in most such calls, is "/zap/test.snd" at CCRMA.</p>

<p>Open-input normally opens the sound file <i>name</i> and returns an IO
structure that other clm functions can use to access the file.  If you don't
give a complete file name (<i>name</i> without the .snd extension),
open-input checks to see if there's either no .snd file or a later .cm
or .clm file, and in that case, suspends the current computation, makes the
sound file from the sources, then resumes the old computation, opening the
(newly computed) sound file.  If you are working in sections, and keep the
sections in separate files, the various layers of mixing can automatically
notice when some section has changed, and update everything for you.
Similarly, if all your sound files get deleted, the whole piece can still
regenerate itself in one operation. 
If you want the convenience of the directory
search (see <a href="#*clm-search-list*">*clm-search-list*</a>) <b>open-input*</b>.
Normally if open-input* can't find a file, it prints a warning and returns
nil.  If you would rather that it drop into the debugger with an option
to specify a new file name at that time, set the <i>restartable</i> argument to t.
</p>

<p>Open-input's &amp;key parameters are patterned after Lisp's load
function:
<i>verbose</i> (the default is nil) turns on some informational printout;
<i>element-type</i> can be nil (the default), or :sound.  In the latter case, the file passed to
open-input is assumed to contain sound data, no matter what extension it has, providing
a way to override the check for out of date sound files and so on;
<i>if-does-not-exist</i> can be nil or :error (the default).  In the latter case, if no sound file
associated with name can be found or created, you get an error message.
<i>start</i> is the sample to start at when reading the first data buffer.
<i>end</i> is the sample to stop at when reading the initial buffer (it defaults to buffer-size).
If you are reading only a small portion of a file many times, you can save some
time by setting explicitly the bounds of the initial read via <i>start</i> and <i>end</i>.
The implicit load triggered by open-input with a non-specific file name
sets 
<a name="*open-input-pathname*"><em class=def>*open-input-pathname*</em></a> and 
<a name="*open-input-truename*"><em class=def>*open-input-truename*</em></a> and notices
<a name="*open-input-verbose*"><em class=def>*open-input-verbose*</em></a> (if t, print out informational
messages).</p>

<br>

<!-- TOPIC instrument-let -->
<span class=bbox><h3><a name="instrument-let">Instrument-let</a></h3></span>

<p><b>Instrument-let</b> is like Lisp's <i>flet</i> -- it can be used to
define local instruments.  For example,</p>
<pre><small>
(defun ins ()
  (<em class=red>instrument-let</em> ((simp (beg dur freq)
                     (let* ((start (floor (* beg *srate*)))
                            (end (+ start (floor (* dur *srate*))))
                            (osc (make-oscil :frequency freq)))
                       (run
                         (loop for i from start below end do
                           (outa i (* .25 (oscil osc)))))))
                   (toot (beg dur) 
                     (let* ((start (floor (* beg *srate*)))
                            (end (+ start (floor (* dur *srate*))))
                            (osc (make-oscil :frequency 220)))
                       (run
                         (loop for i from start below end do
                           (outa i (* .25 (oscil osc))))))))
    (simp 0 1 660)
    (toot 3 1)))
</small></pre>
<p>Now, when the function Ins is called within <a href="#with-sound">with-sound</a> or
<a href="#clm-load">clm-load</a>, it will add a note from Simp and Toot.  For a more useful
example, see <a href="expsrc.ins">expsrc.ins</a>. 
Don't use instrument-let within
<a href="#definstrument">definstrument</a>.</p>
<br>

<!-- TOPIC sound-let -->
<span class=bbox><h3><a name="sound-let">Sound-let</a></h3></span>

<p><b>Sound-let</b> is a form of <i>let*</i> that creates temporary sound streams
within with-sound.  Its syntax is like that of <i>let</i> and
with-sound:</p>
<pre>
  (<em class=red>sound-let</em> ((temp-1 () (fm-violin 0 1 440 .1))
              (temp-2 () (fm-violin 0 2 660 .1)
                         (fm-violin .125 .5 880 .1)))
    (granulate-sound temp-1 0 2 0 2);temp-1's value is the name of the temp file
    (granulate-sound temp-2 1 1 0 2))
</pre>
<p>This creates two temporary files and passes them along to the subsequent calls
on granulate-sound.  The first list after the sound file identifier (i.e. after
"temp-1" in the example) is the list of <a href="#with-sound">with-sound</a> options to be passed
along when creating this temporary file.  These default to :output
with a unique name generated internally, and all other variables are taken from
the overall (enclosing) output file.  The rest of the list is the body of the
associated <a href="#with-sound">with-sound</a>, which can contain embedded sound-lets.
The difference between sound-let and a simple embedded with-sound is primarily that
sound-let names and later deletes the temporary files it creates, whereas with-sound leaves
its explicitly named output intact.
</p>
<br>

<!-- TOPIC defaults -->
<span class=cbox><h4>CLM Defaults</h4></span>
<p>These are set in defaults.lisp. Generally, the default value is *clm-&lt;var&gt;, and the
current dynamic value of that variable is *&lt;var&gt;*.
</p>

<pre>
  <a name="*clm-file-name*"><em class=def>*clm-file-name*</em></a>          default sound file name
  <a name="*clm-header-type*"><em class=def>*clm-header-type*</em></a>        default output sound file header type
  <a name="*clm-data-format*"><em class=def>*clm-data-format*</em></a>        default output sound file data format
  <a name="*clm-table-size*"><em class=def>*clm-table-size*</em></a>         default table-lookup table size
  <a name="*clm-srate*"><em class=def>*clm-srate*</em></a>              default sampling rate (22050)
  <a name="*clm-channels*"><em class=def>*clm-channels*</em></a>           default output channels (1)
  <a name="*clm-play*"><em class=def>*clm-play*</em></a>               default for play arg in with-sound
  <a name="*clm-clipped*"><em class=def>*clm-clipped*</em></a>            default for clipped arg in with-sound
  <a name="*clm-notehook*"><em class=def>*clm-notehook*</em></a>           default for notehook arg in with-sound
  <a name="*clm-init*"><em class=def>*clm-init*</em></a>               name of site-specific initializations (see <a href="#clm-init.lisp">clm-init.lisp</a>)
  <a name="*clm-array-print-length*"><em class=def>*clm-array-print-length*</em></a> number of IO data buffer elements printed
  <a name="*clm-player*"><em class=def>*clm-player*</em></a>             user-supplied DAC funtion
  <a name="*clm-file-buffer-size*"><em class=def>*clm-file-buffer-size*</em></a>   IO buffer sizes 
  <a name="*clm-search-list*"><em class=def>*clm-search-list*</em></a>        pathname list for file searches (open-input*)
  <a name="*clm-instruments*"><em class=def>*clm-instruments*</em></a>        list of the currently loaded clm instruments
  <a name="*clm-news*"><em class=def>*clm-news*</em></a>               brief list of recent changes (HISTORY.clm)
  <a name="*clm-version*"><em class=def>*clm-version*</em></a>            version identifier (a number -- also *clm-revision*)
  <a name="*clm-date*"><em class=def>*clm-date*</em></a>               creation date of the current version
  <a name="*clm-safety*"><em class=def>*clm-safety*</em></a>             default safety setting (run loop debugging choices)
  <a name="*output*"><em class=def>*output*</em></a>                 current output stream (for outa and friends)
  <a name="*input*"><em class=def>*input*</em></a>                  current input stream (for ina and friends)
  <a name="*reverb*"><em class=def>*reverb*</em></a>                 current reverb stream
  <a name="two-pi"><em class=def>two-pi</em></a>                   2*pi
</pre>

<p>On machines with plenty of memory and slow disks, you can speed up CLM
computations by setting <b>*clm-file-buffer-size*</b> to some number larger
than its default (65536).  For example, on ccrma's PC's running Linux
with IDE drives and 64MBytes of RAM, CLM runs as much as 50% faster
if you use:</p>
<pre>
  (let ((*clm-file-buffer-size* (* 1024 1024))) (with-sound ...)
</pre>

<p>The macro <a name="with-offset"><em class=def>with-offset</em></a> can be used to set local
begin time offsets.  Its argument is in seconds:</p>
<pre>
  (with-sound () 
    (fm-violin 0 1 440 .1)
    (<em class=red>with-offset</em> 1.0
      (fm-violin 0 .25 660 .1)) ;actually starts at 1.0
    (fm-violin .5 440 .1))
</pre>

<span class=cbox><h4>CLM examples and whatnot</h4></span>
<p>The file <a href="files">files</a> describes briefly each of the files in the clm
directory;  <a href="clm-example.lisp">clm-example.lisp</a> shows one way to write notelists;  
<a href="cm-clm.lisp">cm-clm.lisp</a> is
a brief example of using Rick Taube's Common Music to drive CLM.  There are several
*.clm files included in the clm distribution.  clm-test.lisp runs my standard
set of "regression" tests, exercising many of the instruments. <a href="pitches.cl">pitches.cl</a>
provides the standard pitch names as lisp variables (a4 = 440.0 and so on).
</p>
<br>

<!-- TOPIC run-star -->
<span class=bbox><h3><a name="run*">Run*</a></h3></span>

<p><b>Run*</b> takes two arguments, a list of variables, and the usual
run macro body.  The run body is executed (in C normally) and then
the variables are set to the values they had when the run loop
exited. 
This extension of <a href="#run">run</a> is
needed because in C
instruments, everything that happens within the run loop is normally hidden
from the lisp interpreter; if you set a global variable's value, for example,
only the run-specific version of that variable is affected.  You need <b>run*</b>
to return such values back to Lisp.
Here's an example:</p>
<pre><small>
(definstrument p (beg dur frq amp)
  (let* ((s (make-oscil frq))
	 (start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (hi 0.0))
    (<em class=red>run*</em> (amp hi)
      (loop for i from start below end do
	(incf hi .001)
	(outa i (* amp (oscil s)))))
    (print (format nil "~A ~A" hi amp))))
</small></pre>
<p>A more useful example is Michael Edwards' <a href="rmsp.ins">rmsp.ins</a>; see also
the sr3 instrument in ug.ins.
Run* doesn't work in no-ffi versions of
CLM, but you can get the same effect (on the SGI or in Linux) by using the <a href="#control">control</a> function instead.
Here's another example that implements legato between notes by using the previous note's phases:
</p>
<pre><small>
(defstruct fmins carrier modulator)
(definstrument fmsimp (beg dur frq amp ind &amp;optional previous-oscils)
  (let* ((start (floor (* *srate* beg)))
	 (end (+ start (floor (* *srate* dur))))
	 (carrier (if previous-oscils
		      (fmins-carrier previous-oscils)
		    (make-oscil)))
	 (modulator (if previous-oscils
			(fmins-modulator previous-oscils)
		      (make-oscil))))
    (setf (mus-frequency carrier) frq)
    (setf (mus-frequency modulator) frq)
    (run* (carrier modulator)
     (loop for i from start below end do
       (outa i (* amp (oscil carrier (* ind (oscil modulator)))))))
    (if previous-oscils
	(progn
	  (setf (fmins-carrier previous-oscils) carrier)
	  (setf (fmins-modulator previous-oscils) modulator)))))

;;; (defvar oscs (make-fmins :carrier (make-oscil) :modulator (make-oscil)))
;;; (with-sound () (fmsimp 0 1.01 440 .1 0.0 oscs) (fmsimp 1.01 1 660 .1 0.0 oscs))
;;; (with-sound () (fmsimp 0 1.01 440 .1 0.0) (fmsimp 1.01 1 660 .1 0.0))
;;;     the 1.01 (as opposed to 1.0) is needed because the phases line up just by chance in the 1.0 case
;;;     for portamento, the instrument could notice an in-coming osc set and
;;;     change the frequency envelope accordingly
</small></pre>
<br>


<!-- TOPIC debugging -->
<span class=box><h2><a name="debugging-aids">Debugging</a></h2></span>
<!-- INDEX debugging-aids:Debugging  -->

<p>CLM provides several built-in data display and instrument debugging aids, 
loosely divided into three groups; lisp itself, 
realtime readback and analysis, and a "memo" mechanism to communicate with Snd.
The realtime support is described above under
<a href="#realtimecontrols">realtime controls</a>.  The lisp support
is mostly oriented around the lisp debugger, but includes some additional
functions provided by CLM.
The most useful first step in debugging
is to run the instrument in Lisp; CLM will run very slowly, but you can
use all of Lisp's debugging features to see what is going wrong.  To run in Lisp,
(definstrument (simp :language :lisp) (args) ...), and then recompile and reload
the instrument.  </p>

<p>The optimize <a name="safety">safety</a> option can be used to check for array index and null
generator problems (these will be reported as bus errors and segmentation
faults).</p>

<span class=cbox><h4>The Error Handler</h4></span>
<p>When you hit an error within with-sound, depending on the context of the error and
the lisp you're running, you'll see a variety of restart options:</p>
<pre>
  Restart actions (select using :continue):
   0: return from break.
   1: try to exit current note cleanly and go on.
   2: abort current note.
   3: close files and return to top-level.
   4: jump past remaining notes.
</pre>
<p>The last four are provided by CLM.  The first tries to jump to the end of the
current instrument, allowing open input files to be closed and so forth.
The second jumps out of the current note, but tries to continue processing
the body of with-sound.  The third closes all files and jumps out of with-sound.
The fourth jumps to the end of the body of with-sound and tries to handle 
all the usual with-sound closing options such as reverb, statistics, and
scaling.
</p>

<p>If you hit a C error (segfault, for example), start gdb with lisp ('gdb /usr/local/lisp/acl', for example),
'run', load clm, run your instrument, then when the error drops you into the gdb debugger, 'where'.  This
should give you some idea where the problem is.  In the worst case, trace clm::run-in-shell and compile/load
the instrument to find out what the C compilation sequence is on your machine; next, make whatever changes
you like to the instrument C code (produced by the run macro, named clm_xxxyyy_INSNAME.c); to add a print
statement that will send its output to the lisp listener, use the function mus_error with a first argument
of 0; next run the C compiler and loader, making a new instrument object file, start gdb with lisp, run
lisp loading clm, load your instrument, and run it.  This is incredibly tedious!
</p>
<p>Once in gdb, you can use clm_print_object to display the fields of a generator:</p>
<pre><small>
Program received signal SIGSEGV, Segmentation fault.
0x804af4d in clm_lnxacl_fm_violin3 (clm_beg=0, clm_end=22050,clm_double=0x8079b08, clm_int=0x8079ea8)
    at /space/home/bil/cl/clm_lnxacl_FM-VIOLIN.c:507
507              ((int *)(clm_int[rIO[CLM_IO_DATS + 1]+i]))[data_end] += (int)(revn[i] * CLM_12263);
</small></pre>
<p>Now we look at clm_lnxacl_FM-VIOLIN.c (the C code produced by the run macro),
and find the generator locations (toward the start of the violin function):</p>
<pre><small>
int clm_lnxacl_fm_violin3 (int clm_beg, int clm_end, double *clm_double, int *clm_int)
... 
  #define c_l_m__REVERB_ 34
  #define c_l_m__REVERB__r 17
  #define CARRIER 38
  #define CARRIER_r 19
 ...
</small></pre>
<p>For example, to see the "carrier" fields, we call clm_print_object with the
two locations:</p>
<pre><small>
(gdb) p <em class=red>clm_print_object</em>(38,19,0,clm_int,clm_double)
#&lt;oscil: freq: 440.000 Hz, phase: 8.554 deg&gt;
</small></pre>
<p>
But we're more interested in the segfault, which obviously has something to do with
the reverb output file, or the locsig generator:</p>
<pre><small>
(gdb) p <em class=red>clm_print_object</em>(34,17,0,clm_int,clm_double)
#&lt;IO: "test.reverb", write, [chan: 0, loc: 0], chans: 1, fil: 8, beg: 0, end: 65535, 
  frames: 0, bufsize: 65536, hdr-end: 28, data-start: 0, data-end: 0, 
  dats: #&lt;integer-array[1]: [0]&gt;&gt;
</small></pre>
<p>In this case the output buffer looks suspicious...</p>


<span class=cbox><h4>Help</h4></span>
<!-- INDEX clm-help:Help  -->
<p>To get help for some topic,
call <a name="clm-help"><em class=def>clm-help</em></a>. Its argument can be
either a (quoted) symbol or a string. 
In most cases, Netscape will be used to display
the documentation; on the Mac, the variable
<a name="*clm-help-browser*"><em class=def>*clm-help-browser*</em></a>
can be set to :cyberdog to choose that browser instead of Netscape.
Another possibility is <a name="linux-help">linux-help</a> with
the same arguments -- it is smarter about which browser is used.
</p>

<p>To find out the current state of an instrument, use
<pre>
  <a name="describe-instrument"><em class=def>describe-instrument</em></a>               show the state of current instrument locals
  <a name="ins-var"><em class=def>ins-var</em></a> (var &amp;optional ins-name)  return value of var in instrument ins-name
</pre>

<p>Except when running in just-lisp mode, each instrument has a variety of properties
the may occasionally be useful.</p>
<pre>
  :c-version-number     lisp/C version to check for libclm conflicts
  :version              CLM version
  :ins-vars             hash table that maps from lisp to C variables
  :run-vars             run* variables
  :ins-args             complete arglist of the instrument (including initial values)
  :c-proc               name of c function called from lisp
  :language             :c (or :lisp if just-lisp)
  :c-file-name          file containing C source code for instrument
  :print-function       function used by describe-instrument
</pre>
<br>

<span class=bbox><h3><a name="sndcommunication">CLM and Snd</a></h3></span>

<p>If the Snd sound editor is available (currently this is the case on the SGI and
some Linux systems, and should work on the Sun, but I haven't been able to try it), there are a variety of hooks in clm-snd.lisp that enable
CLM and Snd to talk to each other.  This portion of CLM has changed drastically three times now, so
it is only for good sports.  Currently,
the most useful of the functions are:</p>
<pre>
  <a name="start-snd"><em class=def>start-snd</em></a>
  <a name="send-snd"><em class=def>send-snd</em></a> <i>code</i>
  <a name="receive-snd"><em class=def>receive-snd</em></a> 
  <a name="send-and-receive-snd"><em class=def>send-and-receive-snd</em></a> <i>code</i> &amp;optional <i>with-eval</i>

  <a name="snd-memo"><em class=def>snd-memo</em></a> <i>file format-string</i> &amp;rest <i>args</i>
  <a name="add-mark"><em class=def>add-mark</em></a> <i>sample channel</i>
  <a name="add-region"><em class=def>add-region</em></a> <i>beg end</i>
  <a name="save-signal"><em class=def>save-signal</em></a> <i>value format-string</i> &amp;rest <i>args</i>

  <a name="snd-sound"><em class=def>snd-sound</em></a> &amp;optional <i>file-name</i>
  <a name="snd-region"><em class=def>snd-region</em></a> &amp;optional (<i>reg</i> 0)
  <a name="snd-cleanup"><em class=def>snd-cleanup</em></a> &amp;body <i>body</i>

  <a name="to-snd"><em class=def>to-snd</em></a> (&amp;rest <i>args</i>) &amp;body <i>body</i>
  <a name="snd-edit-sound"><em class=def>snd-edit-sound</em></a> <i>new-name</i> &amp;optional <i>old-name</i>
  <a name="snd-edit"><em class=def>snd-edit</em></a> (&amp;optional <i>file</i>) &amp;body <i>body</i>

  <a name="sndenv"><em class=def>snd-envelope</em></a> <i>env</i>
  <a name="clmenv"><em class=def>clm-envelope</em></a> <i>env</i>
</pre>
<p><b>snd-memo</b> provides access to the ".scm" file that can be associated with any sound
in Snd; the memo file can contain any Snd-related Scheme code you want; it will be loaded
just after the sound it itself is loaded.  The variable <b>memo-sound</b> is set during
this process to the index of the current sound.  You can save any arbitrary information
you like at any time through this function; the predefined macro <b>add-mark</b> is
just one simple example:</p>
<pre>
  (defmacro add-mark (samp &amp;optional (chan 0))
    `(<em class=red>snd-memo</em> *output* "(<em class=red>add-mark</em> ~D memo-sound ~D)~%" ,samp ,chan))
</pre>
<p>It appends the <code>(add-mark samp memo-sound chan)</code> call to the current output's
memo (.scm) file.  Similarly, <b>add-region</b> defines a new region in Snd; it can be used
to mark a note's begin and end points with a sound.  <b>save-signal</b> saves its first
argument as an on-going output file, opening it in Snd when the current output file is
opened.  This provides a simple way to probe an instrument to see what the local signals
are.  The rest of its arguments are used to create the signal's file name, and it returns
its first argument.  This facility was handled through the display argument to with-sound
in CLM-1.
</p>
<pre><small>
(definstrument simp (dur)
  (let ((fd (open-input "oboe.snd")))
    (run
     (loop for i from 0 to dur do
       (outa i (<em class=red>save-signal</em> (ina i fd) "ina.snd"))))
  (close-input fd)))
</small></pre>
<p>Currently, the save-signal output file is not deleted, nor is the memo file, so
before each with-sound evaluation, delete any such files if you want to re-use
the same names.  Also, save-signal saves each value when it is called, so it is
not fast, but you will get data even if the instrument dies in mid-note.</p>

<p><b>snd-sound</b> returns the current edited state of the desired file in the
Snd editor (or the currently active file if no file-name is given).  This can
be used anywhere a file name occurs in CLM, for example:</p>
<pre>
  (with-sound () (mix (snd-sound)))
</pre>
<p>Similarly, <b>snd-region</b> returns the contents of region <i>reg</i>.
<b>snd-edit-sound</b> passes sound data back to sound, causing it to appear in
the editor as an edit of either the file passed as old-name, or the currently
active file if no old-name is given.</p>
<pre>
  (snd-edit-sound 
    (with-sound () 
      (mix (<em class=red>snd-sound</em>)) 
      (fm-violin .1 .1 660 .1)))
</pre>
<p>takes the current state of the current active file in Snd (snd-sound), adds
a short fm-violin note to it, then returns that to Snd as a kind of editing
operation. </p>

<p>Nearly everything that Snd can do is accessible to CLM by sending the
appropriate Snd code through the function <b>send-snd</b> and friends.
</p>
<pre>
  (send-snd "(open-sound \"oboe.snd\")")
  (snd-edit () (with-sound () (mix (snd-sound)) (fm-violin .1 .1 660 .1)))
  (send-and-receive-snd "(save-sound 0)")
</pre>
<p>fires up Snd, opens "oboe.snd", edits it by adding a fm-violin note, and
saves the result under the same name, exiting Snd.  All of this is
compatible with the debugging and display uses of Snd.  For example,
'display' starts Snd itself if one isn't started yet,
and that same Snd process can handle the editing operations described above.
Similarly, <b>to-snd</b> fires up Snd unless it is already running, then
calls with-sound on its arguments, passing the result to Snd.
</p>
<p>The Snd envelope editor can be used in conjunction with clm; <b>clm-envelope</b>
passes its argument (assumed to be a list) to Snd, and <b>snd-envelope</b> returns
Snd's notion of that envelope (presumably after it has been edited):</p>
<pre>
  (defvar hi '(0 0 1 1))
  (clm-envelope hi)
  (setf hi (snd-envelope hi))
</pre>
<p><b>send-snd</b> can also be called within the run loop, sending Snd any
arbitrary command; for example, the following instrument prints out the
seconds as they go by in Snd's minibuffer:</p>
<pre>
(definstrument call-snd (beg dur frq)
  (let* ((bg (floor (* beg *srate*)))
         (nd (+ bg (floor (* dur *srate*))))
         (o (make-oscil frq))
	 (ctr 0)
	 (secs 0))
    (run
     (loop for i from bg below nd do
       (incf ctr)
       (when (>= ctr *srate*)
	 (incf secs)
	 (setf ctr 0)
	 (send-snd "(report-in-minibuffer (number->string ~D))" secs))
       (outa i (oscil o))))))
</pre>
<p>In this case, if send-snd has extra arguments, they are treated like
format or clm-print arguments.<p>

<p>snd-sound creates a temporary file to pass the current state to CLM, and expects
CLM to delete that file when it is done with it.  The macros <b>snd-cleanup</b> and
<b>snd-edit</b> provide this cleanup action for you.  If you don't clean these
files up as they are created, they are finally deleted when snd-stop is called,
or when CLM is exited.  If something goes wrong, just delete any file on
the temp directory (/tmp or /var/tmp normally) whose name begins with "snd_".</p>
<br>

<span class=box><h2><a name="appendices">Appendices</a></h2></span>

<!-- TOPIC headers -->
<br>
<span class=bbox><h3><a name="header-types">Header and data types</a></h3></span>
<!-- INDEX header-types:Sound file formats  -->
<!-- INDEX header-types:Data formats  -->
<!-- INDEX header-types:Headers  -->

<p>CLM can write NeXT/Sun, AIFF/AIFC, RIFF ("wave"), raw (no header), NIST-sphere, and "old-style" IRCAM headers.
The default choice is set by <a href="#*clm-header-type*">*clm-header-type*</a>
set in <a href="defaults.lisp">defaults.lisp</a>. The output data format is normally
16-bit signed (2's complement) integer; the default is set by 
<a href="#*clm-data-format*">*clm-data-format*</a>.
CLM can read most standard headers, and can read and write most uncompressed
data formats.</p>
<ul>
<li>read/write (many data formats):  
<ul>     
<li>NeXT/Sun/DEC/AFsp
<li>AIFF/AIFC
<li>RIFF (Microsoft wave)
<li>IRCAM (old style)
<li>NIST-sphere
<li>no header
</ul>
<li>read-only (in selected data formats):
<ul>
<li>8SVX (IFF), EBICSF, INRS, ESPS, 
<li>SPPACK, ADC (OGI), AVR, VOC,
<li>Sound Tools, Turtle Beach SMP, SoundFont 2.0, 
<li>Sound Designer I and II, PSION, MAUD, Kurzweil 2000,
<li>Tandy DeskMate, Gravis Ultrasound, ASF, PAF, CSL,
<li>Comdisco SPW, Goldwave sample, omf, quicktime
<li>Sonic Foundry, SBStudio II, Delusion digital, 
<li>Digiplayer ST3, Farandole Composer WaveSample,
<li>Ultratracker WaveSample, Sample Dump exchange, 
<li>Yamaha SY85, SY99, and TX16, Covox v8, SPL, AVI, 
</ul>
<li>use Snd to translate these:
<ul>
<li>IEEE text, Mus10 SAM 16-bit (modes 1 and 4), IBM CVSD, AVI
<li>NIST shortpack, HCOM, Intel and Oki (Dialogic) ADPCM, MIDI sample dump
<li>G721, G723_24, G723_40, IFF Fibonacci and Exponential
</ul>
</ul>
<p>I am willing to add almost anything to this list.
See <a href="headers.c">headers.c</a> for all the gory details.  In
<a href="#with-sound">with-sound</a>, you can set the output header type with
the keyword :header-type, and the data type with the :data-format keyword.</p>

<p>The CLM names for the output header types, as used with the :header-type argument to with-sound, are
<a name="mus-aiff">mus-aiff</a>, <a name="mus-aifc">mus-aifc</a>, <a name="mus-sun">mus-sun</a>, 
<a name="mus-riff">mus-riff</a>, and <a name="mus-ircam">mus-ircam</a>.
(The type mus-next is a synonym for mus-sun).
The data-formats
that are exported from the clm package are <a name="mus-bshort">mus-bshort</a>, mus-lshort, mus-bint, mus-lint,
mus-bfloat, mus-lfloat, mus-mulaw, mus-alaw, mus-byte, mus-ubyte, mus-b24int, mus-l24int, mus-bdouble,
and mus-ldouble.  The "b" stands for big-endian, "l" for little-endian, "u" for unsigned.
The other header and data format possibilites are listed in initmus.lisp.</p>

<a name="raw-data"></a>
<!-- INDEX raw-data:raw data  -->
<p>If you are trying to read raw (no header) sound files, CLM's default settings for
the sampling rate, channels, and data format are 44100, 2, and mus-bshort
respectively.  To change these, call (mus-set-raw-header-defaults srate chans format).
For example</p>
<small><pre>
(mus-set-raw-header-defaults 8012 1 mus-mulaw)
(open-input "raw.snd")
</pre></small>
<p>treats "raw.snd" as mono mulaw data at 8012 Hz.</p>

<br>

<span class=bbox><h3><a name="unwanted-noise">Sources of unwanted noise</a></h3></span>

<p>The major source of unwanted noise in computer music is amplitude
quantization.  This means soft notes are buzzy.  If these are later used as
input to a reverberator, for example, the buzziness can easily be magnified.
If the soft notes are split between channels (via locsig for example), you may
end up increasing the overall noisiness.  My experience has been that anything
under .003 in amplitude is asking for trouble unless it is covered up in some
way.  Since reverb amounts are often less than .01, even a loud note can
produce noisy input to the reverberator.  The simplest way around this in CLM
is to make one run and get the reverb stream max amp (reported if :statistics
is t in with-sound).  Then scale all the reverb signals up by the inverse of
this (leaving some room for slop, of course).  For example, if the reverb max
amp is .01, you're throwing away about 7 bits of amplitude resolution in the
reverb input.  So, in this case, multiply all the locsig reverb by (say) 50,
then in the reverberator, divide the reverb output by 50 before sending it out.
See <a href="jcrev.ins">jcrev.ins</a> for an example (the
volume argument).  Similarly, if your notes are soft, send them directly out
channel 0 or 1; the spatial effects are going to add less to your piece
than the noise will detract in this case.  And if you're making repeated
iterative passes over sound files, try to keep them scaled close to 1.0 in
maxamp through all the passes.  The exact maxamp is not important; the
difference between 1.0 and .5 is one bit of resolution.
If you want to hear this buzz, either run a slowly
decaying envelope on a sine wave, or listen to the tail end of the
standard reverbs as they decay into "silence"; you'll be horrified.
The latter effect is so noticeable that many of the reverbs have an
amplitude envelope argument that can be used to cut them off quickly
at the end of the piece; it is against my religion to add noise
(i.e. the "dithering" used currently by commercial CD's; the theory
is that this dithering makes the buzz (a periodic toggling of the low
order bits) uncorrelated, and therefore we're happier because we've
come to expect tape noise anyway; but turn up the soft portions of
your favorite CD, if it has any, and decide whether the cure is
perhaps worse than the disease).
</p>

<p>Next in importance, in my unhappy experience with headphones, speakers, and
amplifiers has been that slow amplitude envelopes can cause annoying artifacts
in less than perfect audio equipment.  You may hear glissandos or chirps if a
soft note is slowly ramping up or down.  The function
reduce-amplitude-quantization-noise in <a href="env.lisp">env.lisp</a> makes the envelope jump through
the initial or final section where there are too few bits, hopefully reducing
the chirps (these are apparently caused by non-linearities in the audio
equipment; I don't hear them in very good equipment).  A similar trick
is to use exponential envelopes that are bowed out (a base less than 1.0 in
CLM); this is the default in the MusicKit for example.   There may be
some combination of problems here; see Robert Maher, "On the Nature of
Granulation Noise in Uniform Quantization Systems", JAES vol 40 no 1/2, 1992,
p12; he says "The common assumption that the quantization noise is
additive, white, and uncorrelated with the input signal is simply incorrect for
the case of sinusoidal input".  Since the ramping portions are often
sinusoidal, or nearly so, these chirps might be analyzable as FM caused by
quantization.</p>

<p>Another source of "noise" is foldover.  This is mostly a problem with FM when
the sampling rate is low; you'll hear inharmonic artifacts caused by
components that are beyond half the sampling rate.  Then there are the obvious
problems like discontinuities in the wave becoming clicks at the speaker, and
clipping. Finally, avoid reverberating notes with
sharp attacks.</p>

<p>The major sources of noise in audio equipment are bad connections and "ground
loops".  In the latter case, various pieces of equipment are at slightly
different ground voltages due to tiny resistances in ground wires; this
sets up a sort of screen upon which all kinds of interference can be projected,
so to speak.  These loops are hard to avoid.  In my house, for example, the
grounds are real; that is, the third plug on the power cords is actually
connected to a solid ground, but I still had to connect all the drives, audio
equipment, and NeXT itself to the same outlet (representing altogether about
1000 watts of worst case power consumption). The problem was that the ground
and "neutral" wires  meander through the conduits alongside the power wires, so it becomes a
serial connection of grounds along a given path; it's a low gauge wire,
but even so, there is a slight resistance along that path, causing equipment
connected to different outlets to be at a slightly different ground voltage.
Even after putting everything on the same outlet, the external drive was the
source of a slight hum; after unplugging it, I could turn all the volume
knobs up all the way and hear only a small hiss which I attribute to the
unavoidable randomness in any analog equipment (Johnson noise, for example).</p>

<p>On the NeXT, the DACs are mounted near the monitor, so you can hear
interference from that all the time. Similarly speaker cables can sometimes act
as antennas; I think the theory here is that radio frequency
interference (which can be picked up by a short wire like a speaker connection)
can occur in pulses that become clicks or hiss in the speakers, and hum can
apparently be caused by stray inductance from transformers.  The simplest
answer is to buy properly shielded computer equipment, route the wires away
from that equipment, and use the shortest wires possible.  If that's not an
option, I'm told that it helps to use shielded cables.  If there's still
interference, you might be able to go to "balanced" connections, but this
normally means investing in pro-audio equipment.</p>
<br>

<!-- TOPIC initialization -->
<span class=bbox><h3><a name="clm-init.lisp">clm-init.lisp</a></h3></span>
<!-- INDEX clm-init.lisp:CLM Initialization  -->

<p>If the file clm-init.lisp exists in the same directory as <a href="all.lisp">all.lisp,</a> or
if you set the clm variable *clm-init* to point to some file, then CLM
loads that file upon initialization.  As an example of the sorts of
customizations that can be included, here is my clm-init.lisp:</p>
<pre><small>
(compile-and-load "v")
(compile-and-load "jcrev")
;;; my two favorite instruments

(setf (volume) 1.0)
;;; dac output volume

(setf *print-array* nil)
;;; keep lisp from printing out endless arrays in trace/zoom, etc

(setf *clm-search-list* 
  (append *clm-search-list* 
	  (list "/me/cl/oboe.snd" 
		"/me/mus/hdr/aiff-8.snd" 
		"/me/snd/now.snd" 
		"/snd1/zap/test.snd" 
		"/snd1/snds/test.snd")))
;;; these are my standard sound file directories -- by including 
;;; these in the search list I don't need to remember where each 
;;; file happens to be.  The file names are just fillers --
;;; the important part of the path is the directory.
</small></pre>
<br>
<!-- TOPIC user-defined-gens -->
<span class=bbox><h3><a name="user-defined-ugs">User-defined generators</a></h3></span>
<!-- INDEX user-defined-ugs:User-defined generators  -->

<p>Most special-case generators can be expressed as macros and defined
in lisp; see <a href="zd.ins">zd.ins</a> or <a href="prc-toolkit95.lisp">prc-toolkit95.lisp</a> for extensive examples.
There's rarely a real need to drop into C!
If you want to call your own C code within the run loop, you have to
tell the run macro how to make the call.  The run macro looks up identifiers
in a table built by def-clm-fun; as an example, we'll make a "generator"
that averages its arguments:
</p>
<pre><small>
(in-package :clm)
(export '(average))
(def-clm-fun 'average #'(lambda (var x) (package-op 'c-average var x :clm-real)))
(defmacro c-average (result a b)
  (format *c-file* "  ~A = (~A + ~A)/2.0;~%" 
    (lc (second result)) (lc-num-ref a) (lc-num-ref b))
  nil)
</small></pre>
<p><a name="def-clm-fun"><em class=def>def-clm-fun</em></a> tells the run macro how to handle the function <i>average</i> -- actual
C output needs to be deferred until the entire tree has been examined, so in this case, when "average" is encountered
in an instrument's run section, the macro "c-average" is queued up with its arguments in an internal form;
The macro <i>c-average</i>
sends out the associated c code (to the global file identifier *c-file*) when that point is reached in the translation.
See <a href="cmus.lisp">cmus.lisp</a> for more examples.
Once this code is loaded into CLM,</p>
<pre><small>
(definstrument average-stuff (beg dur freq amp)
  (let ((os1 (make-oscil freq))
	(os2 (make-oscil (* freq 3/2)))
	(bg (floor (* *srate* beg)))
	(nd (+ beg (floor (* *srate* dur)))))
    (run
     (loop for i from bg below nd do
       (outa i (* amp (<em class=red>average</em> (oscil os1) (oscil os2))))))))
</small></pre>
<br>

<span class=bbox><h3><a name="savedimages">About CLM in saved images</a></h3></span>
<!-- INDEX savedimages:saved images -->

<p>Many lisps have some mechanism to dump the current lisp image as an
executable file.  In ACL or MCL, some of CLM's state at run-time is handled in C-based
foreign-function modules that are opaque to Lisp, so there are cases where the naive use
of dumplisp (acl), or save-application (mcl)
can fail with a segmentation fault or some other equally
un-informative error message.  This should only be a problem when the saved image
has called clm-initialize-links (within with-sound or dac or some such function);
if you build a clm image and immediately save it, as in make-clm.cl, everything
should work without problem.  Once clm-initialize-links has been called,
the C modules assume they have been initialized; if the saved version of
modules is then executed, the arrays associated with these modules will
not exist, but the modules won't know that.  In this case, you need to call the
function <a name="restart-clm"><em class=def>restart-clm</em></a> before doing anything in the newly executed image.
For example, in Linux, I use the Scheme window manager (scwm), and have the
following as a top-level menu item:</p>
<pre>
(menuitem "CLM" 
  #:action (lambda () 
             (execute "rxvt -e /space/home/bil/cl/CLM")))
</pre>
<p>
The "CLM" script is:</p>
<pre>
#!/bin/csh -f
exec /space/home/bil/acl5/lisp -I /space/home/bil/cl/clm.dxl -e '(restart-clm)'
</pre>
<p>where the file clm.dxl was created by ACL's dumplisp command:</p>
<pre>
(excl:dumplisp :name "clm.dxl")
</pre>
<p>
In Linux, you also need to avoid using any function that tickles the
Linux audio drivers (OSS or Alsa) since they are not compatible with
saved images.  
</p>
<br>

<span class=bbox><h3><a name="how-to-use-clm">How to use CLM outside with-sound or clm-load</a></h3></span>

<p><a href="#with-sound">With-sound</a> and <a href="#clm-load">clm-load</a> are macros that expand into code similar to the
following:</p>
<pre>
  (clm-initialize-links)
  (setf *srate* 44100)
  (setf *output* (open-output "/zap/test.snd" :chans 2 :srate 44100))

&lt; insert instrument calls here &gt;

  (close-output *output*)
</pre>
<p>An instrument can be called outside with-sound and friends, or
notice that it is being called in that way:</p>
<pre><small>
  (definstrument auto (dur)
    (let ((os (make-oscil))
          (need-close (not *output*))
          (end (floor (* dur *srate*))))
      (if (not *output*) 
        (setf *output* (open-output "/zap/test.snd")))
      (run
        (loop for i from 0 to end do (outa i (* .1 (oscil os)))))
    (when need-close
      (close-output *output*)
      (dac "/zap/test.snd"))))
</small></pre>
<p>Now (auto) is the same as (with-sound () (auto))</p>

<p>An instrument need not perform sound output.
See <a href="rmsp.ins">rmsp.ins</a> for an example.</p>
<br>


<span class=bbox><h3><a name="bugs">Misfeatures and Unfinished Business</a></h3></span>

<h4>Doubly nested with-mix triggers paranoia</h4>
<p>With-mix called within with-mix called within with-sound causes the
outer with-mix to be such a worrier that it always recomputes
its note list.</p>

<h4>:no-ffi limitations</h4> 

<p>Currently the :no-ffi versions of CLM
(affecting Clisp and CMU-CL) do not implement 
convolve with huge files, notehook, run*, 
instrument-let, error within run, nor the multi-host support.
In this version of CLM, instruments are written
out as C modules and loaded into the rc (or saved-rc) program whenever
CLM notices that rc and CLM are not in sync.  With-sound arguments and
instrument parameters are then passed from CLM to rc through a binary
data file, normally called test.cdt. The instrument cannot be loaded
dynamically (on the SGI -- this might be do-able on other systems, but
I haven't had time to check it out), so currently rc is rebuilt from scratch
each time the instrument list changes.  To accomplish this, CLM needs
continuous access to various header files, the libmus.a library built
at CLM build time, and the instrument code.  The variables
clm::<a name="*clm-source-directory*">*clm-source-directory*</a> and 
clm::<a name="*clm-binary-directory*">*clm-binary-directory*</a> tell CLM
where to look for the library files; <a name="*rc-directory*">*rc-directory*</a> tells CLM where
to write the <a name="rc">rc</a> program and its various header files and modules. 
See <a href="rc.lisp">rc.lisp</a> for more details.</p>

<h4>Instruments as generators</h4>

<p>Instruments as generators are not implemented yet in common lisp (not difficult)
or in the run macro (difficult).
They are working in the Scheme/Snd versions however -- see fmv.scm for an example
of treating the fm-violin (v.ins) as a generator; pvoc.scm for a phase-vocoder
generator; and zip.scm for the zipper.  There are two main
differences between an instrument and a generator: first, the generator
does not know its duration, so envelopes have to be packaged as functions
(closures), and second, sound input (as from a sound file) should be handled as
an "as-needed" function, rather than calling in-any or whatever.  The other
difference is one of approach; you need to separate the note-list-oriented
portion of an instrument from its signal-processing or synthesis section.
Once split apart, the same code can be used in "real-time"
situations (the "control" function and the closures-as-envelopes are
interchangeable).
</p>

<p>I may rewrite CLM's instruments to use this format even if it doesn't
work in the run macro; it irks me that progress is seriously impeded
by a desperate attempt to speed up Lisp.  The first step toward run-macro
revision is to make cmus.c use clm.c -- that is, imbed the current
C clm implementation into lisp. </p>

<br>

<span class=box><h2><a name="index">Index</a></h2></span>
<!-- created 15-June-00 -->
<pre>
<small>
<a href="clm.html#add-clm-method">add-clm-method</a>            <a href="clm.html#file-&gt;frame?">file-&gt;frame?</a>              <a href="clm.html#make-waveshape">make-waveshape</a>            <a href="clm.html#rec-any">rec-any</a>
<a href="clm.html#add-mark">add-mark</a>                  <a href="clm.html#file-&gt;sample">file-&gt;sample</a>              <a href="clm.html#make-zpolar">make-zpolar</a>               <a href="clm.html#receive-snd">receive-snd</a>
<a href="clm.html#add-region">add-region</a>                <a href="clm.html#file-&gt;sample?">file-&gt;sample?</a>             <a href="clm.html#map-across-envelopes">map-across-envelopes</a>      <a href="clm.html#rectangular-&gt;polar">rectangular-&gt;polar</a>
<a href="clm.html#all-pass">all-pass</a>                  <a href="clm.html#filter">filter</a>                    <a href="clm.html#meld-envelopes">meld-envelopes</a>            <a href="clm.html#remote-read">remote-read</a>
<a href="clm.html#all-pass?">all-pass?</a>                 <a href="clm.html#filter?">filter?</a>                   <a href="clm.html#midi input">midi</a>                      <a href="clm.html#remote-write">remote-write</a>
<a href="clm.html#amplitude-modulate">amplitude-modulate</a>        <a href="clm.html#filters"><b>Filters</b></a>                   <a href="clm.html#mix">mix</a>                       <a href="clm.html#reopen-output">reopen-output</a>
<a href="clm.html#array-&gt;file">array-&gt;file</a>               <a href="clm.html#fir-filter">FIR-filter</a>                <a href="clm.html#mixer*">mixer*</a>                    <a href="clm.html#restart-clm">restart-clm</a>
<a href="clm.html#array-interp">array-interp</a>              <a href="clm.html#fir-filter?">FIR-filter?</a>               <a href="clm.html#mixer-ref">mixer-ref</a>                 <a href="clm.html#restart-env">restart-env</a>
<a href="clm.html#asymmetric-fm">asymmetric-fm</a>             <a href="clm.html#fixup-helpers">fixup-helpers</a>             <a href="clm.html#mixer-set!">mixer-set!</a>                <a href="clm.html#*reverb*">*reverb*</a>
<a href="clm.html#asymmetric-fm?">asymmetric-fm?</a>            <a href="clm.html#formant">formant</a>                   <a href="clm.html#mixer?">mixer?</a>                    <a href="clm.html#ring-modulate">ring-modulate</a>
<a href="clm.html#be-helpful ">be-helpful </a>               <a href="clm.html#formant?">formant?</a>                  <a href="clm.html#howtowsm"><b>Multi-host with-sound</b></a>     <a href="clm.html#run*">run*</a>
<a href="clm.html#buffer-&gt;frame">buffer-&gt;frame</a>             <a href="clm.html#fft"><b>Fourier transforms </b></a>       <a href="clm.html#multiply-arrays">multiply-arrays</a>           <a href="clm.html#lisp-functions"><b>Run support for Lisp</b></a>
<a href="clm.html#buffer-&gt;sample">buffer-&gt;sample</a>            <a href="clm.html#frame*">frame*</a>                    <a href="clm.html#mus-a0">mus-a0</a>                    <a href="clm.html#sample-&gt;buffer">sample-&gt;buffer</a>
<a href="clm.html#buffer-empty?">buffer-empty?</a>             <a href="clm.html#frame+">frame+</a>                    <a href="clm.html#mus-a1">mus-a1</a>                    <a href="clm.html#sample-&gt;file">sample-&gt;file</a>
<a href="clm.html#buffer-full?">buffer-full?</a>              <a href="clm.html#frame-&gt;buffer">frame-&gt;buffer</a>             <a href="clm.html#mus-a2">mus-a2</a>                    <a href="clm.html#sample-&gt;file?">sample-&gt;file?</a>
<a href="clm.html#buffer?">buffer?</a>                   <a href="clm.html#frame-&gt;file">frame-&gt;file</a>               <a href="clm.html#mus-aifc">mus-aifc</a>                  <a href="clm.html#sample-&gt;frame">sample-&gt;frame</a>
<a href="clm.html#centered-random">centered-random</a>           <a href="clm.html#frame-&gt;file?">frame-&gt;file?</a>              <a href="clm.html#mus-aiff">mus-aiff</a>                  <a href="clm.html#make-src"><b>sampling-rate conversion</b></a>
<a href="clm.html#mix-and-with-mix"><b>Checkpoints</b></a>               <a href="clm.html#frame-&gt;frame">frame-&gt;frame</a>              <a href="clm.html#mus-b1">mus-b1</a>                    <a href="clm.html#save-signal">save-signal</a>
<a href="clm.html#clear-array">clear-array</a>               <a href="clm.html#frame-&gt;list">frame-&gt;list</a>               <a href="clm.html#mus-b2">mus-b2</a>                    <a href="clm.html#savedimages"><b>saved images</b></a>
<a href="clm.html#clm-init.lisp"><b>CLM Initialization </b></a>       <a href="clm.html#frame-&gt;sample">frame-&gt;sample</a>             <a href="clm.html#mus-bshort">mus-bshort</a>                <a href="clm.html#sawtooth-wave">sawtooth-wave</a>
<a href="clm.html#*clm-array-print-length*">*clm-array-print-length*</a>  <a href="clm.html#frame-ref">frame-ref</a>                 <a href="clm.html#mus-channel">mus-channel</a>               <a href="clm.html#sawtooth-wave?">sawtooth-wave?</a>
<a href="clm.html#*clm-binary-directory*">*clm-binary-directory*</a>    <a href="clm.html#frame-set!">frame-set!</a>                <a href="clm.html#mus-channels">mus-channels</a>              <a href="clm.html#scale-envelope">scale-envelope</a>
<a href="clm.html#*clm-channels*">*clm-channels*</a>            <a href="clm.html#frame?">frame?</a>                    <a href="clm.html#mus-close">mus-close</a>                 <a href="clm.html#scaled-by">scaled-by</a>
<a href="clm.html#*clm-clipped*">*clm-clipped*</a>             <a href="clm.html#generators"><b>Generators</b></a>                <a href="clm.html#mus-cosines">mus-cosines</a>               <a href="clm.html#scaled-to">scaled-to</a>
<a href="clm.html#*clm-data-format*">*clm-data-format*</a>         <a href="clm.html#grains"><b>Granular synthesis</b></a>        <a href="clm.html#mus-create">mus-create</a>                <a href="clm.html#seconds-&gt;samples">seconds-&gt;samples</a>
<a href="clm.html#*clm-date*">*clm-date*</a>                <a href="clm.html#granulate">granulate</a>                 <a href="clm.html#mus-data">mus-data</a>                  <a href="clm.html#send-and-receive-snd">send-and-receive-snd</a>
<a href="clm.html#clmenv">clm-envelope</a>              <a href="clm.html#granulate?">granulate?</a>                <a href="clm.html#mus-feedback">mus-feedback</a>              <a href="clm.html#send-snd">send-snd</a>
<a href="clm.html#*clm-file-buffer-size*">*clm-file-buffer-size*</a>    <a href="clm.html#graph">graph</a>                     <a href="clm.html#mus-feedforward">mus-feedforward</a>           <a href="clm.html#sine-summation">sine-summation</a>
<a href="clm.html#*clm-file-name*">*clm-file-name*</a>           <a href="clm.html#header-types"><b>Headers </b></a>                  <a href="clm.html#mus-formant-radius">mus-formant-radius</a>        <a href="clm.html#sine-summation?">sine-summation?</a>
<a href="clm.html#*clm-header-type*">*clm-header-type*</a>         <a href="clm.html#clm-help"><b>Help </b></a>                     <a href="clm.html#mus-frequency">mus-frequency</a>             <a href="clm.html#snd-cleanup">snd-cleanup</a>
<a href="clm.html#clm-help">clm-help</a>                  <a href="clm.html#hilbert">Hilbert transform</a>         <a href="clm.html#mus-hop">mus-hop</a>                   <a href="clm.html#snd-edit">snd-edit</a>
<a href="clm.html#*clm-help-browser*">*clm-help-browser*</a>        <a href="clm.html#hz-&gt;radians">hz-&gt;radians</a>               <a href="clm.html#mus-increment">mus-increment</a>             <a href="clm.html#snd-edit-sound">snd-edit-sound</a>
<a href="clm.html#*clm-init*">*clm-init*</a>                <a href="clm.html#iir-filter">IIR-filter</a>                <a href="clm.html#mus-input?">mus-input?</a>                <a href="clm.html#sndenv">snd-envelope</a>
<a href="clm.html#clm-init.lisp">clm-init.lisp</a>             <a href="clm.html#iir-filter?">IIR-filter?</a>               <a href="clm.html#mus-ircam">mus-ircam</a>                 <a href="clm.html#snd-memo">snd-memo</a>
<a href="clm.html#*clm-instruments*">*clm-instruments*</a>         <a href="clm.html#in-any">in-any</a>                    <a href="clm.html#mus-length">mus-length</a>                <a href="clm.html#snd-region">snd-region</a>
<a href="clm.html#clm-load">clm-load</a>                  <a href="clm.html#ina">ina</a>                       <a href="clm.html#mus-location">mus-location</a>              <a href="clm.html#snd-sound">snd-sound</a>
<a href="clm.html#*clm-news*">*clm-news*</a>                <a href="clm.html#inb">inb</a>                       <a href="clm.html#mus-open-read">mus-open-read</a>             <a href="clm.html#header-types"><b>Sound file formats </b></a>
<a href="clm.html#*clm-notehook*">*clm-notehook*</a>            <a href="clm.html#*input*">*input*</a>                   <a href="clm.html#mus-open-write">mus-open-write</a>            <a href="clm.html#open-input"><b>Sound file IO</b></a>
<a href="clm.html#*clm-play*">*clm-play*</a>                <a href="clm.html#ina-outa"><b>Input and output</b></a>          <a href="clm.html#mus-order">mus-order</a>                 <a href="clm.html#make-locsig"><b>Sound placement</b></a>
<a href="clm.html#*clm-player*">*clm-player*</a>              <a href="clm.html#ins-var">ins-var</a>                   <a href="clm.html#mus-output?">mus-output?</a>               <a href="clm.html#sound-chans">sound-chans</a>
<a href="clm.html#clm-print">clm-print</a>                 <a href="clm.html#instrument-let">instrument-let</a>            <a href="clm.html#mus-phase">mus-phase</a>                 <a href="clm.html#sound-data-format">sound-data-format</a>
<a href="clm.html#clm-random">clm-random</a>                <a href="clm.html#ins-files"><b>Instruments</b></a>               <a href="clm.html#mus-ramp">mus-ramp</a>                  <a href="clm.html#sound-data-location">sound-data-location</a>
<a href="clm.html#*clm-safety*">*clm-safety*</a>              <a href="clm.html#linux-help">linux-help</a>                <a href="clm.html#mus-reopen-write">mus-reopen-write</a>          <a href="clm.html#sound-datum-size">sound-datum-size</a>
<a href="clm.html#*clm-search-list*">*clm-search-list*</a>         <a href="clm.html#locsig">locsig</a>                    <a href="clm.html#mus-riff">mus-riff</a>                  <a href="clm.html#sound-duration">sound-duration</a>
<a href="clm.html#*clm-source-directory*">*clm-source-directory*</a>    <a href="clm.html#locsig-ref">locsig-ref</a>                <a href="clm.html#mus-scaler">mus-scaler</a>                <a href="clm.html#sound-format-name">sound-format-name</a>
<a href="clm.html#*clm-srate*">*clm-srate*</a>               <a href="clm.html#locsig-reverb-ref">locsig-reverb-ref</a>         <a href="clm.html#mus-set-rand-seed">mus-set-rand-seed</a>         <a href="clm.html#sound-frames">sound-frames</a>
<a href="clm.html#*clm-table-size*">*clm-table-size*</a>          <a href="clm.html#locsig-reverb-set!">locsig-reverb-set!</a>        <a href="clm.html#mus-set-raw-header-defaults">mus-set-raw-header-defaults</a> <a href="clm.html#sound-header-type">sound-header-type</a>
<a href="clm.html#*clm-verbose*">*clm-verbose*</a>             <a href="clm.html#locsig-set!">locsig-set!</a>               <a href="clm.html#mus-sun">mus-sun</a>                   <a href="clm.html#sound-length">sound-length</a>
<a href="clm.html#*clm-version*">*clm-version*</a>             <a href="clm.html#locsig?">locsig?</a>                   <a href="clm.html#mus-xcoeffs">mus-xcoeffs</a>               <a href="clm.html#sound-let">sound-let</a>
<a href="clm.html#close-controls">close-controls</a>            <a href="clm.html#make-all-pass">make-all-pass</a>             <a href="clm.html#mus-ycoeffs">mus-ycoeffs</a>               <a href="clm.html#sound-loop-info">sound-loop-info</a>
<a href="clm.html#close-input">close-input</a>               <a href="clm.html#make-asymmetric-fm">make-asymmetric-fm</a>        <a href="clm.html#normalize-envelope">normalize-envelope</a>        <a href="clm.html#sound-max-amp">sound-max-amp</a>
<a href="clm.html#close-output">close-output</a>              <a href="clm.html#make-buffer">make-buffer</a>               <a href="clm.html#notch">notch</a>                     <a href="clm.html#sound-samples">sound-samples</a>
<a href="clm.html#comb">comb</a>                      <a href="clm.html#make-comb">make-comb</a>                 <a href="clm.html#notch?">notch?</a>                    <a href="clm.html#sound-set-loop-info">sound-set-loop-info</a>
<a href="clm.html#comb?">comb?</a>                     <a href="clm.html#make-controller">make-controller</a>           <a href="clm.html#note-lists"><b>Note lists </b></a>               <a href="clm.html#sound-srate">sound-srate</a>
<a href="clm.html#contrast-enhancement">contrast-enhancement</a>      <a href="clm.html#make-convolve">make-convolve</a>             <a href="clm.html#notehook">notehook</a>                  <a href="clm.html#sound-type-name">sound-type-name</a>
<a href="clm.html#control">control</a>                   <a href="clm.html#make-delay">make-delay</a>                <a href="clm.html#one-pole">one-pole</a>                  <a href="clm.html#spectrum">spectrum</a>
<a href="clm.html#control-allocate">control-allocate</a>          <a href="clm.html#make-empty-frame">make-empty-frame</a>          <a href="clm.html#one-pole?">one-pole?</a>                 <a href="clm.html#square-wave">square-wave</a>
<a href="clm.html#control-free">control-free</a>              <a href="clm.html#make-empty-mixer">make-empty-mixer</a>          <a href="clm.html#one-zero">one-zero</a>                  <a href="clm.html#square-wave?">square-wave?</a>
<a href="clm.html#convolution">convolution</a>               <a href="clm.html#make-env">make-env</a>                  <a href="clm.html#one-zero?">one-zero?</a>                 <a href="clm.html#src">src</a>
<a href="clm.html#convolve">convolve</a>                  <a href="clm.html#make-fcontrol">make-fcontrol</a>             <a href="clm.html#open-controls">open-controls</a>             <a href="clm.html#src?">src?</a>
<a href="clm.html#convolvefiles">convolve-files</a>            <a href="clm.html#make-fft-graph">make-fft-graph</a>            <a href="clm.html#open-input">open-input</a>                <a href="clm.html#start-snd">start-snd</a>
<a href="clm.html#convolve?">convolve?</a>                 <a href="clm.html#make-fft-window">make-fft-window</a>           <a href="clm.html#open-input*">open-input*</a>               <a href="clm.html#stop-dac">stop-dac</a>
<a href="clm.html#cross-synthesis"><b>cross synthesis</b></a>           <a href="clm.html#make-file-&gt;frame">make-file-&gt;frame</a>          <a href="clm.html#*open-input-pathname*">*open-input-pathname*</a>     <a href="clm.html#stop-helper">stop-helper</a>
<a href="clm.html#dac">dac</a>                       <a href="clm.html#make-file-&gt;sample">make-file-&gt;sample</a>         <a href="clm.html#*open-input-truename*">*open-input-truename*</a>     <a href="clm.html#stop-helpers">stop-helpers</a>
<a href="clm.html#header-types"><b>Data formats </b></a>             <a href="clm.html#make-filter">make-filter</a>               <a href="clm.html#*open-input-verbose*">*open-input-verbose*</a>      <a href="clm.html#stretch-envelope">stretch-envelope</a>
<a href="clm.html#debugging-aids"><b>Debugging </b></a>                <a href="clm.html#make-fir-filter">make-fir-filter</a>           <a href="clm.html#open-output">open-output</a>               <a href="clm.html#sum-of-cosines">sum-of-cosines</a>
<a href="clm.html#def-clm-fun">def-clm-fun</a>               <a href="clm.html#make-formant">make-formant</a>              <a href="clm.html#optional-key">optional-key</a>              <a href="clm.html#sum-of-cosines?">sum-of-cosines?</a>
<a href="clm.html#def-clm-struct">def-clm-struct</a>            <a href="clm.html#make-frame">make-frame</a>                <a href="clm.html#oscil">oscil</a>                     <a href="clm.html#table-lookup">table-lookup</a>
<a href="clm.html#definstrument">definstrument</a>             <a href="clm.html#make-frame-&gt;file">make-frame-&gt;file</a>          <a href="clm.html#oscilbank">oscil-bank</a>                <a href="clm.html#table-lookup?">table-lookup?</a>
<a href="clm.html#defpinstrument">defpinstrument</a>            <a href="clm.html#make-granulate">make-granulate</a>            <a href="clm.html#oscil?">oscil?</a>                    <a href="clm.html#tap">tap</a>
<a href="clm.html#degrees-&gt;radians">degrees-&gt;radians</a>          <a href="clm.html#make-graph">make-graph</a>                <a href="clm.html#out-any">out-any</a>                   <a href="clm.html#tell-helpers">tell-helpers</a>
<a href="clm.html#delay">delay</a>                     <a href="clm.html#make-identity-mixer">make-identity-mixer</a>       <a href="clm.html#outa">outa</a>                      <a href="clm.html#times-&gt;samples">times-&gt;samples</a>
<a href="clm.html#delay?">delay?</a>                    <a href="clm.html#make-iir-filter">make-iir-filter</a>           <a href="clm.html#outb">outb</a>                      <a href="clm.html#to-snd">to-snd</a>
<a href="clm.html#describe-instrument">describe-instrument</a>       <a href="clm.html#make-locsig">make-locsig</a>               <a href="clm.html#outc">outc</a>                      <a href="clm.html#triangle-wave">triangle-wave</a>
<a href="clm.html#with-psound"><b>Direct to DAC </b></a>            <a href="clm.html#make-mixer">make-mixer</a>                <a href="clm.html#outd">outd</a>                      <a href="clm.html#triangle-wave?">triangle-wave?</a>
<a href="clm.html#dlocsig">dlocsig</a>                   <a href="clm.html#make-notch">make-notch</a>                <a href="clm.html#*output*">*output*</a>                  <a href="clm.html#two-pi">two-pi</a>
<a href="clm.html#dot-product">dot-product</a>               <a href="clm.html#make-one-pole">make-one-pole</a>             <a href="clm.html#partials-&gt;polynomial">partials-&gt;polynomial</a>      <a href="clm.html#two-pole">two-pole</a>
<a href="clm.html#env">env</a>                       <a href="clm.html#make-one-zero">make-one-zero</a>             <a href="clm.html#partials-&gt;wave">partials-&gt;wave</a>            <a href="clm.html#two-pole?">two-pole?</a>
<a href="clm.html#env-interp">env-interp</a>                <a href="clm.html#make-oscil">make-oscil</a>                <a href="clm.html#partials-&gt;waveshape">partials-&gt;waveshape</a>       <a href="clm.html#two-zero">two-zero</a>
<a href="clm.html#envsound">env-sound</a>                 <a href="clm.html#make-ppolar">make-ppolar</a>               <a href="clm.html#phase-partials-&gt;wave">phase-partials-&gt;wave</a>      <a href="clm.html#two-zero?">two-zero?</a>
<a href="clm.html#env?">env?</a>                      <a href="clm.html#make-pulse-train">make-pulse-train</a>          <a href="clm.html#polynomial">polynomial</a>                <a href="clm.html#user-defined-ugs"><b>User-defined generators </b></a>
<a href="clm.html#envelope*">envelope*</a>                 <a href="clm.html#make-rand">make-rand</a>                 <a href="clm.html#pulse-train">pulse-train</a>               <a href="clm.html#volume">volume</a>
<a href="clm.html#envelope+">envelope+</a>                 <a href="clm.html#make-rand-interp">make-rand-interp</a>          <a href="clm.html#pulse-train?">pulse-train?</a>              <a href="clm.html#wave-train">wave-train</a>
<a href="clm.html#envelope-&gt;coeffs">envelope-&gt;coeffs</a>          <a href="clm.html#make-readin">make-readin</a>               <a href="clm.html#radians-&gt;degrees">radians-&gt;degrees</a>          <a href="clm.html#wave-train?">wave-train?</a>
<a href="clm.html#envelope-concatenate">envelope-concatenate</a>      <a href="clm.html#make-roomsig">make-roomsig</a>              <a href="clm.html#radians-&gt;hz">radians-&gt;hz</a>               <a href="clm.html#waveshape">waveshape</a>
<a href="clm.html#envelope-exp">envelope-exp</a>              <a href="clm.html#make-sample-&gt;file">make-sample-&gt;file</a>         <a href="clm.html#rand">rand</a>                      <a href="clm.html#waveshape?">waveshape?</a>
<a href="clm.html#envelope-interp">envelope-interp</a>           <a href="clm.html#make-sawtooth-wave">make-sawtooth-wave</a>        <a href="clm.html#rand-interp">rand-interp</a>               <a href="clm.html#window-envelope">window-envelope</a>
<a href="clm.html#envelope-repeat">envelope-repeat</a>           <a href="clm.html#make-sine-summation">make-sine-summation</a>       <a href="clm.html#rand-interp?">rand-interp?</a>              <a href="clm.html#with-current-sound">with-current-sound</a>
<a href="clm.html#envelope-reverse">envelope-reverse</a>          <a href="clm.html#make-square-wave">make-square-wave</a>          <a href="clm.html#rand?">rand?</a>                     <a href="clm.html#with-dac">with-dac</a>
<a href="clm.html#envelope-simplify">envelope-simplify</a>         <a href="clm.html#make-src">make-src</a>                  <a href="clm.html#random-numbers"><b>Random numbers</b></a>            <a href="clm.html#with-mix">with-mix</a>
<a href="clm.html#envelopes"><b>Envelopes</b></a>                 <a href="clm.html#make-sum-of-cosines">make-sum-of-cosines</a>       <a href="clm.html#raw-data"><b>raw data </b></a>                 <a href="clm.html#with-offset">with-offset</a>
<a href="clm.html#fcontrol">fcontrol</a>                  <a href="clm.html#make-table-lookup">make-table-lookup</a>         <a href="clm.html#rc">rc</a>                        <a href="clm.html#with-psound">with-psound</a>
<a href="clm.html#fft">fft</a>                       <a href="clm.html#make-triangle-wave">make-triangle-wave</a>        <a href="clm.html#*rc-directory*">*rc-directory*</a>            <a href="clm.html#with-sound">with-sound</a>
<a href="clm.html#fft-graph">fft-graph</a>                 <a href="clm.html#make-two-pole">make-two-pole</a>             <a href="clm.html#readin">readin</a>                    <a href="clm.html#wsm">wsm</a>
<a href="clm.html#file-&gt;array">file-&gt;array</a>               <a href="clm.html#make-two-zero">make-two-zero</a>             <a href="clm.html#readin?">readin?</a>                   
<a href="clm.html#file-&gt;frame">file-&gt;frame</a>               <a href="clm.html#make-wave-train">make-wave-train</a>           
</small>
</pre>
<center>
<span class=htmlbox>related documentation</span><span class=htmlbox><a href="snd.html#overview">snd.html</a><spacer type=horizontal size=25><a href="extsnd.html#extsndcontents">extsnd.html</a><spacer type=horizontal size=25><a href="grfsnd.html#grfsndcontents">grfsnd.html</a><spacer type=horizontal size=25><a href="sndlib.html#introduction">sndlib.html</a></span>
</center>
