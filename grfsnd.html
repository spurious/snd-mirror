<html>
<head>
<title>Snd Customization and Extension</title>
<style type="text/css">
<!-- 
	EM.red {color:red; font-style:normal}
        EM.typing {color:maroon; font-style: normal}
        EM.listener {color:darkblue; font-style: normal}
        EM.tab {font-style: normal; font-size: small; font-family: fixed}
	EM.def {font-weight: bold; font-style: normal}
	H1 {text-align: center}
	UL {list-style-type: none}
	SPAN.box {background: beige; width: 100%; font-style: normal; text-align: center; border-width: thin; border-style: ridge}
	SPAN.bbox {background: lightsteelblue; width: 100%; font-style: normal; border-width: thin; border-style: ridge}
	SPAN.cbox {background: lightgreen; width: 100%; font-style: normal; border-width: thin; border-style: ridge}
	SPAN.htmlbox {background: tan; font-style: normal; font-size: small; border-width: thin; border-style: ridge}
-->
</style>
</head>
<body bgcolor=white>

<!-- I'm using A NAME (i.e caps) where the entity should be ignored by the indexer (index.cl) -->

<A NAME="grfsndcontents"></a>
<span class=box><h1>Snd Customization and Extension Part 2</h1></span>
<br>

<center>
<span class=htmlbox>related documentation</span><span class=htmlbox><a href="snd.html">snd.html</a><spacer type=horizontal size=25><a href="extsnd.html">extsnd.html</a><spacer type=horizontal size=25><a href="clm.html">clm.html</a><spacer type=horizontal size=25><a href="sndlib.html">sndlib.html</a><spacer type=horizontal size=25><a href="sndscm.html">sndscm.html</a><spacer type=horizontal size=25><a href="index.html">index.html</a></span>
</center>

<ul>
<li><a href="#startup">Snd Startup</a>
  <ul>
  <li><a href="#sndresources">Snd resources</a>
  <li><a href="#sndswitches">Snd invocation flags</a>
  <li><a href="#sndinitfile">The initialization file</a>
  </ul>
<li><a href="#snddynamic">Runtime modules and external programs</a>
  <ul>
  <li><a href="#emacssnd">Snd as an Emacs subjob</a>
  <li><a href="#dynamic">Dynamically loaded modules</a>
  <ul>
     <li><a href="#sndgsl">GSL</a>
     <li><a href="#sndsndlib">Sndlib</a>
     </ul>
  <li><a href="#programs">External Programs</a>
  <ul>
    <li><a href="#stk">STK</a>
    <li><a href="#sox">Sox</a>
    <li><a href="#clm">CLM</a>
    </ul>
  <li><a href="#sndaswidget">Snd as a Widget</a>
  <li><a href="#sndwithclm">Snd and the CLM module</a>
    <ul>
    <li><a href="#clmfuncs">CLM functions</a>
    </ul>
  <li><a href="#sndwithmotif">Snd and Motif</a>
  <li><a href="#sndwithgtk">Snd and Gtk</a>
  <li><a href="#sndwithnogui">Snd with no GUI and as script engine</a>
  <li><a href="#sndandruby">Snd with Ruby</a>
  <li><a href="#sndwithgmeteor">Snd and gmeteor</a>
  <li><a href="#sndandladspa">Snd and LADSPA</a>
  <li><a href="#sndandx">Driving Snd remotely</a>
  <li><a href="#sndandgl">Snd and OpenGL</a>
  <li><a href="#sndandgdb">Snd and gdb</a>
  <li><a href="#sndclmcmn">Snd, CLM, CMN</a>
  </ul>
<li><a href="index.html">Index</a>
</ul>

<br>

<span class=box><h2><A NAME="startup">Snd Startup</a></h2></span>
<br>
<span class=bbox><h3><A NAME="sndresources">Snd resources</a></h3></span>

<p>In the Motif version, there are a few X-style resources that Snd looks for (see Snd.ad):</p>

<table cellspacing=0 cellpadding=0>
<tr><td width=200>initFile</td>               <td>"~/.snd"</td></tr>
<tr><td><A NAME="epsresource">epsFile</a></td><td>"snd.eps"</td></tr>
<tr><td>overwriteCheck</td>                   <td>0</td></tr>
<tr><td>autoResize</td>                       <td>1</td></tr>
<tr><td>horizontalPanes</td>                  <td>0</td></tr>
<tr><td><br></td><td><br></td></tr>
<tr><td>buttonFont</td>                       <td>-*-times-medium-r-*-*-14-*-*-*-*-*-iso8859-1</td></tr>
<tr><td>boldbuttonFont</td>                   <td>-*-times-bold-r-*-*-14-*-*-*-*-*-iso8859-1</td></tr>
<tr><td>axisLabelFont</td>                    <td>-*-times-medium-r-normal-*-20-*-*-*-*-*-iso8859-1</td></tr>
<tr><td>axisNumbersFont</td>                  <td>-*-courier-medium-r-normal-*-14-*-*-*-*-*-iso8859-1</td></tr>
<tr><td>helpTextFont</td>                     <td>9x15</td></tr>
<tr><td>listenerFont</td>                     <td>default</td></tr>
<tr><td><br></td><td><br></td></tr>
<tr><td>useSchemes</td>                       <td>none</td></tr>
<tr><td>highlightcolor</td>                   <td>ivory1</td></tr>
<tr><td>basiccolor</td>                       <td>ivory2</td></tr>
<tr><td>positioncolor</td>                    <td>ivory3</td></tr>
<tr><td>zoomcolor</td>                        <td>ivory4</td></tr>
<tr><td>cursorcolor</td>                      <td>red</td></tr>
<tr><td>selectioncolor</td>                   <td>lightsteelblue1</td></tr>
<tr><td>mixcolor</td>                         <td>lightgreen</td></tr>
<tr><td>mixfocuscolor</td>                    <td>yellow2</td></tr>
<tr><td>listenercolor</td>                    <td>aliceblue</td></tr>
<tr><td>envedwaveformcolor</td>               <td>blue</td></tr>
<tr><td>filterwaveformcolor</td>              <td>blue</td></tr>
<tr><td>mixwaveformcolor</td>                 <td>darkgray</td></tr>
<tr><td>graphcolor</td>                       <td>white</td></tr>
<tr><td>selectedgraphcolor</td>               <td>white</td></tr>
<tr><td>datacolor</td>                        <td>black</td></tr>
<tr><td>selecteddatacolor</td>                <td>black</td></tr>
<tr><td>markcolor</td>                        <td>red</td></tr>
<tr><td>pushedbuttoncolor</td>                <td>lightsteelblue1</td></tr>
<tr><td>sashcolor</td>                        <td>lightgreen</td></tr>
</table>
<p>If you have the HTML widget loaded, the following
resources are also available:</p>

<table cellspacing=0 cellpadding=0>
<tr><td width=200>htmlDir</td>                <td>"."</td></tr>
<tr><td>htmlWidth</td>                        <td>600</td></tr>
<tr><td>htmlHeight</td>                       <td>400</td></tr>
<tr><td>htmlFontSizeList</td>                 <td>"14,10,24,24,18,14,12"</td></tr>
<tr><td>htmlFixedFontSizeList</td>            <td>"14,10"</td></tr>
</table>

<p>You can experiment with other choices by
using the -xrm command line argument:</p>

<pre>
  snd -xrm '*Highlightcolor: Red' oboe.snd
  snd -xrm '*AxisNumbersFont: 6x10' oboe.snd
  snd -xrm '*overwriteCheck: 1' oboe.snd
  snd -xrm '*useSchemes: all' -xrm '*scheme: Pacific'
  snd -xrm '*fontList: 9x15' oboe.snd
  snd -xrm '*listenerFont: 6x10' oboe.snd
  snd -xrm '*mixwaveformcolor: red' oboe.snd -notebook
  snd oboe.snd pistol.snd -xrm '*selectedgraphcolor: black' -xrm '*selecteddatacolor: white'
  snd oboe.snd -title hiho -display hummer.hiho:0.0 -xrm '*chn-graph*backgroundPixmap: text.xpm'
</pre>

<p>The color names can be found in <a href="sndscm.html#rgbdoc">rgb.scm</a>. 
If you use SGI color schemes (the useSchemes resource), most of the color resources mentioned above are ignored 
(the cursor and selection colors are never ignored). If color schemes are available
they're listed in /usr/lib/X11/schemes, probably -- it's unfortunate that
there is the language Scheme used by Guile, and the notion of an SGI color scheme -- there is
no connection between the two.  The last example sets the window title to "hiho", rather than
"snd", displays the window on the machine hummer.hiho (presumably accessible over the net),
and tiles the graph backgrounds with the contents of text.xpm.  To get the -geometry argument
to work, set the autoResize resource to 0:</p>
<pre>
  snd oboe.snd -geometry 800x200 -xrm '*autoResize: 0'
</pre>

<p>These resources can be set in your .Xdefaults file:</p>
<pre>
snd*buttonFont:         -adobe-times-medium-r-*-*-14-*-*-*-*-*-*-*
snd*boldbuttonFont:     -adobe-times-bold-r-*-*-14-*-*-*-*-*-*-*
snd*axisLabelFont:      -adobe-times-medium-r-normal-*-18-*-*-*-*-*-*-*
snd*axisNumbersFont:    9x15
snd*fontList:           9x15
snd*helpTextFont:       9x15
</pre>

<p>
The <A NAME="xautoresize">autoResize resource</a> determines how Snd acts when files
are added or removed from its overall display.  The default (1)
causes Snd to expand or contract the main window's size to accommodate
the sounds (many people find this distracting); if <i>autoResize</i> is 0, the outer window size remains the
same, and the sounds try to fit as best they can.  See also
the variable <a href="extsnd.html#autoresize">auto-resize</a>.
If <i>overwriteCheck</i> is 1, Snd asks before overwriting existing files.
The <A NAME="horizontalpanes">horizontalPanes resource</a>
is equivalent to the -h flag; if 1, sounds are layed out
horizontally rather than vertically;  if 2, you get a notebook
widget holding the sounds.
</p>

<p><A NAME="aboutcolors"></a>The various color resources are:</p>

<table cellspacing=0 cellpadding=0>
<tr><td width=200>basiccolor</td><td width=350>default background color everywhere</td><td><code>basic-color</code></td></tr>
<tr><td>cursorcolor</td>         <td>color of the cursor</td>                   <td><code>cursor-color</code></td></tr>
<tr><td>datacolor</td>           <td>unselected data color</td>                 <td><code>data-color</code></td></tr>
<tr><td>envedwaveformcolor</td>  <td>color of envelope editor waveform</td>     <td><code>enved-waveform-color</code></td></tr>
<tr><td>filterwaveformcolor</td> <td>color of control panel filter waveform</td><td><code>filter-waveform-color</code></td></tr>
<tr><td>graphcolor</td>          <td>unselected channels' graph background</td> <td><code>graph-color</code></td></tr>
<tr><td>highlightcolor</td>      <td>highlighting here and there</td>           <td><code>highlight-color</code></td></tr>
<tr><td>listenercolor</td>       <td>background color of the listener</td>      <td><code>listener-color</code></td></tr>
<tr><td>listenertextcolor</td>   <td>text color in the listener</td>            <td><code>listener-text-color</code></td></tr>
<tr><td>markcolor</td>           <td>color of the mark indicator</td>           <td><code>mark-color</code></td></tr>
<tr><td>mixcolor</td>            <td>used for mix waveforms</td>                <td><code>mix-color</code></td></tr>
<tr><td>selectedmixcolor</td>    <td>selected mix waveforms</td>                <td><code>selected-mix-color</code></td></tr>
<tr><td>positioncolor</td>       <td>color of position sliders</td>             <td><code>position-color</code></td></tr>
<tr><td>pushedbuttoncolor</td>   <td>color of pushed button</td>                <td><code>pushed-button-color</code></td></tr>
<tr><td>sashcolor</td>           <td>color of paned window sash handles</td>    <td><code>sash-color</code></td></tr>
<tr><td>selecteddatacolor</td>   <td>color of the data in selected channel</td> <td><code>selected-data-color</code></td></tr>
<tr><td>selectedgraphcolor</td>  <td>background of selected channel's graph</td><td><code>selected-graph-color</code></td></tr>
<tr><td>selectioncolor</td>      <td>color of an active selection</td>          <td><code>selection-color</code></td></tr>
<tr><td>textfocuscolor</td>      <td>color of text field with focus</td>        <td><code>text-focus-color</code></td></tr>
<tr><td>zoomcolor</td>           <td>color of zoom sliders</td>                 <td><code>zoom-color</code></td></tr>
</table>
<p>
Each of these colors can be set in Guile using the second name given above ("basic-color").
Colors are defined by calling <a href="extsnd.html#makecolor">make-color</a> with the three red/green/blue values,
each a float between 0.0 and 1.0. <code>(set! (basic-color) (make-color 1.0 0.0 0.0))</code> sets
the overall background color of Snd to red.  <a href="sndscm.html#rgbdoc">rgb.scm</a> defines all the standard X11 color names
(you probably don't want to load the whole thing; just use the names as needed). 
</p>

<p>There are several other resources that set various widget sizes: zoomSliderWidth,
positionSliderWidth, toggleSize, sashSize, sashIndent, channelSashSize, channelSashIndent, and
envedPointSize.  And several more color resources: whitecolor (list background),
blackcolor (recorder VU meter text), redcolor (buttons, VU clipping, etc), 
greencolor (a few buttons),
yellowcolor (a few envelope editor buttons), lightbluecolor (the recorder), and lighterbluecolor (the fft option panel).
</p>

<p>In the GTK version, you can load a gtkrc file, overriding all Snd defaults, with the
function <b>parse-rc-file</b>:
</p>
<pre>
  (parse-rc-file "/home/bil/test/gtk+-1.2.9/gtk/testgtkrc")
</pre>

        <!-- I(print file):O(epsFile resource)(epsresource) -->

<br>
<span class=bbox><h3><A NAME="sndswitches">Snd invocation flags</a></h3></span>

<p>The following flags are recognized by Snd (leaving aside all
the usual Xt/X-related flags like -xrm).</p>

<table cellspacing=0 cellpadding=0>
<tr><td width=200><code>-h -horizontal</code></td><td>layout sounds as horizontal panes</td></tr>
<tr><td><code>-v -vertical</code></td>            <td>layout sounds vertically (the default)</td></tr>
<tr><td><code>-notebook</code></td>               <td>layout sounds in a notebook widget (Motif 2.0 or later)</td></tr>
<tr><td><code>-separate</code></td>               <td>layout sounds each in a separate window (lisp listener in main window)</td></tr>
<tr><td><code>--help</code></td>                  <td>print some help, version info, and exit</td></tr>
<tr><td><code>--version</code></td>               <td>print version info</td></tr>
<tr><td><code>-noglob</code></td>                 <td>don't read /etc/snd.conf</td></tr>
<tr><td><code>-noinit</code></td>                 <td>don't read ~/.snd, if any</td></tr>
<tr><td><code>-p -preload &lt;dir&gt;</code></td> <td>preload sound files in directory &lt;dir&gt; (for example, snd -p .)</td></tr>
<tr><td><code>-l -load &lt;file&gt;</code></td>   <td>load guile (scheme) code in &lt;file&gt; (for example, snd -l test.scm)</td></tr>
<tr><td><code>-e -eval expr</code></td>           <td>evaluate expr</td></tr>
<tr><td><code>-b -batch &lt;file&gt;</code></td>  <td>load guile (scheme) code in &lt;file&gt; as a batch (no GUI) job</td></tr>
</table>

<p>
The -e switch evaluates its argument as though it had been passed to M-X.  The
initialization file, if any, is loaded first, then the arguments are processed
in order.  For example</p>
<pre>
snd -e "(set! (data-color) (make-color 1 0 0))" oboe.snd
</pre>
<p>reads ~/.snd, if any, then sets the (unselected) data color to red, then opens oboe.snd.</p>
<pre>
./snd -eval '(begin (display (+ 1 2)) (exit))'
</pre>
<p>prints "3" and exits.  The "-title" argument works in both versions of Snd.
The following adds "WAV" to the sound file extension table before preloading the directory:
</p>
<pre>
snd -e '(add-sound-file-extension "WAV")' -p /home/bil/sounds
</pre>
<br>
<img src="note.png" alt="notebook"><spacer type=horizontal size=10><img src="bgd.png" alt="colors" vspace=30>
<br>
<br>

<span class=bbox><h3><A NAME="sndinitfile">The initialization file</a></h3></span>
<p>
When Snd starts up, it looks for an "initialization file", normally named "~/.snd" (its name can be set
via the X resource mechanism, or through the environment variable SND_INIT_FILE).  This optional file is
supposed to be just like emacs' .emacs file, containing any customizations or
extensions that you want loaded whenever Snd starts up.  For example, say we
want the Snd window to start out 800x500, want to predefine an envelope named
"env1", and want the file selection box to
default to showing just sound files.  We make ~/.snd and put in it:</p>
<pre>
(set! (window-width) 800)
(set! (window-height) 500)
(defvar env1 '(0 0 1 1 2 0))
(set! (just-sounds) #t)
</pre>
<p>
In addition, we could add our own analysis functions or whatever.  In more
complex situations, you may want an initialization file particular to a given
machine, and global across users; the 
name of this optional global initialization file is "/etc/snd.conf". It
is read before the user's local file; both can, of course, be
absent.  To override reading the global init file when Snd is invoked, include the switch -noglob.
To override the local init file, use -noinit.  
Here's a more extended example:
</p>

<pre>
(use-modules (ice-9 popen) (ice-9 debug) (ice-9 format))

(set! (window-width) 800)
(set! (window-height) 500)
(set! (button-font) "-adobe-times-medium-r-*-*-14-*-*-*-*-*-*-*")
(set! (bold-button-font) "-adobe-times-bold-r-*-*-14-*-*-*-*-*-*-*")
(set! (axis-label-font) "-adobe-times-medium-r-normal-*-18-*-*-*-*-*-*-*")
(set! (axis-numbers-font) "9x15")

(set! (show-mix-waveforms) #t)
(set! (listener-prompt) ":")
(show-listener)
(set! (show-indices) #t)

(define beige (make-color 0.96 0.96 0.86))
(define blue (make-color 0 0 1))
(set! (selected-graph-color) beige)
(set! (selected-data-color) blue)

(add-hook! mouse-enter-graph-hook 
  (lambda (snd chn) 
    (focus-widget (car (channel-widgets snd chn)))))
(add-hook! mouse-enter-listener-hook 
  (lambda (widget) 
    (focus-widget widget)))
(add-hook! mouse-enter-text-hook
  (lambda (w)
    (focus-widget w)))
</pre>
<p>
If you loaded Snd with GSL, and have set the GSL_IEEE_MODE environment variable,
it will override Snd's default arithmetic mode settings.  GSL recommends the setting:
</p>
<pre>
GSL_IEEE_MODE=double-precision,mask-underflow,mask-denormalized
</pre>

<br>
<span class=box><h2><A NAME="snddynamic">Runtime modules and external programs</a></h2></span>

<p>It is possible to load your own C code into Snd at run-time or
use any external program from within Snd as an editing function.
And, perhaps most useful, you can run Snd as an Emacs subjob.
</p>
<br>
<span class=bbox><h3><A NAME="emacssnd">Snd as an Emacs subjob</a></h3></span>

<p>Snd watches stdin; any input received
is evaluated as if typed in Snd's lisp listener; any subsequent output
is sent to stdout; presumably any process could communicate with
Snd in this manner.  But the intention here was to connect to Emacs 
via ILISP (available at
http://sourceforge.net/projects/ilisp,
and possibly built into Xemacs).
Once you have ILISP, put this code in your .emacs file:</p>
<pre>
(require 'ilisp)
(defdialect snd "Snd" ilisp
  (setq ilisp-block-command "(begin \n%s)")
  (setq ilisp-load-command "(load \"%s\")")
  (setq ilisp-init-hook '((lambda () (ilisp-init nil nil nil))))
  (setq comint-prompt-regexp "^&gt;+")
  (setq ilisp-directory-command "(getcwd)")
  (setq	ilisp-set-directory-command "(chdir \"%s\")")
  (setq	ilisp-complete-command
	"(map (lambda (sym) 
                (list (symbol-&gt;string sym))) 
              (apropos-internal \"^%s\"))")
  (local-set-key "\C-x\C-h" '(lambda (s)
			       (interactive "sSnd help: ")
			       (insert "(snd-help " s ")")
			       (comint-send-input))))

  (setq snd-program "snd")
</pre>
<p>You can bind this to some key via:</p>
<pre>
  (global-set-key "\C-x\C-l" 'snd)
</pre>
<p>Now C-x C-l in Emacs starts Snd as a subjob; anything you type in the Emacs
<b>*snd*</b> buffer is sent to Snd (very much as if you were running CLM as
an Emacs subjob), and Snd's output is appended to the <b>*snd*</b> buffer.
Also, C-x C-h prompts for some Snd entity and appends the help text for that
entity in the snd buffer.  The following code tries to implement Snd's
name completion upon C-x C-i in the <b>*snd*</b> buffer:</p>
<pre>
(defun handle-snd-completion (process string)
  (let ((buffer (process-buffer process)))
    (save-excursion
      (set-buffer buffer)
      (goto-char (point-max))
      (insert (substring string 1 (- (length string) 3))))
    (goto-char (point-max))
    (display-buffer buffer)))
      
(defun snd-complete-symbol ()
  (interactive)
  (let* ((end (point))
	 (start (save-excursion (skip-syntax-backward "w_") (point)))
	 (pattern (buffer-substring-no-properties start end))
	 (proc (get-buffer-process (current-buffer)))
	 (old-filter (process-filter proc)))
    (delete-region start end)
    (set-process-filter proc 'handle-snd-completion)
    (process-send-string proc (format "(snd-completion \"%s\")\n" pattern))
    (accept-process-output proc)
    (set-process-filter proc old-filter)))
</pre>
<p>and add this to the defdialect block:</p>
<pre>
  (local-set-key "\C-x\C-i" 'snd-complete-symbol)
</pre>
<p>But for some reason it needs an open-paren?
<i>snd-program</i> is the name of the snd image; you can include whatever
startup switches you like:
</p>
<pre>
(setq snd-program "snd -horizontal ~/cl/oboe.snd")
</pre>
<br>
<span class=bbox><h3><A NAME="dynamic">Dynamically loaded modules</a></h3></span>

<p>You can import shared object files into Snd at any time.
You need to build Snd
with -lguile (that is, load it with the guile shared library, not libguile.a);
if the loader can't find libguile.so.2 (or whatever), add its directory to
your LD_LIBRARY_PATH; for example, if
it's on /usr/local/lib, <code>setenv LD_LIBRARY_PATH /usr/local/lib</code>.  
Next add Guile wrappers to your C code:</p>
<pre>
  /* cscm.c */
  #include &lt;math.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;
  #include &lt;guile/gh.h&gt;

  int hiho (int a) 
  { /* this is the function we want to call from Snd */
    return(1 + a);
  }

  SCM hiho_wrapper(SCM a) 
  { /* this tells Guile how to interpret the arguments and return value of hiho */
    return(scm_long2num(hiho(scm_num2int(a, 0, "hiho"))));
  }

  void init_hiho() 
  { /* this declares hiho within Guile calling the wrapper which calls the C function hiho */
    scm_c_define_gsubr("hiho", 1, 0, 0, hiho_wrapper);
  }
</pre>
<p>
Next compile
your code into a shared object (this example is for Linux):
</p>
<pre>
  cc -c cscm.c 
  ld -shared -o cscm.so cscm.o -lguile
</pre>
<p>Now go to Snd's lisp listener and,</p>
<pre>
  (define lib (<em class=red>dynamic-link</em> "/home/bil/cl/cscm.so"))
  (<em class=red>dynamic-call</em> "init_hiho" lib)
  (hiho 3)
</pre>
<p>The function we actually want loaded into Guile here is "hiho".
We define a wrapper for it to handle the translation between
Guile (Scheme) variable types and C ("hiho_wrapper"), and
a procedure to define hiho in Guile ("init_hiho").  Once loaded
("dynamic-link"), we can call the initialization function
("dynamic-call"), and thereafter treat "hiho" as though
it had been defined in Guile/Snd to begin with.  After both the
dynamic-link and dynamic-lib calls, the listener will
print "#&lt;unspecified&gt;" or something equally obscure to indicate
in its own peculiar way that all went well.  M-x (hiho 4) will
print 5 in the minibuffer.
</p>

<p><A NAME="sndgsl"></a>
As a slightly more useful example, let's import the bessel J0 function
from GSL (Gnu Scientific Library); in this case, we need to build Snd
with GSL (the easiest way is to include the --with-gsl option to configure).
Then make a file (say "gsl-ex.c"):</p>
<pre>
#include &lt;guile/gh.h&gt;
#include &lt;gsl/gsl_sf_bessel.h&gt;

static SCM scm_j0(SCM x)
{ /* calls GSL function gsl_sf_bessel_J0_e */
  gsl_sf_result res;
  gsl_sf_bessel_J0_e(scm_num2dbl(x, "j0"), &amp;res);
  return(scm_make_real(res.val));
}

void init_gsl_j0(void)
{ /* links scm_j0 into Snd under the name j0 */
  scm_c_define_gsubr("j0", 1, 0, 0, scm_j0);
}
</pre>
<p>Now the usual compile, load, link into Snd sequence:</p>
<pre>
/home/bil/snd-4/ cc gsl-ex.c -c -Wall
/home/bil/snd-4/ ld -shared gsl-ex.o -o gsl-ex.so -lguile
/home/bil/snd-4/ ./snd

&gt;<em class=typing>(define lib (dynamic-link "/home/bil/snd-4/gsl-ex.so"))</em>
<em class=listener>#&lt;unspecified&gt;</em>
&gt;<em class=typing>(dynamic-call "init_gsl_j0" lib)</em>
<em class=listener>#&lt;unspecified&gt;</em>
&gt;<em class=typing>(</em><em class=red>j0</em><em class=typing> 0.0)</em>
<em class=listener>1.0</em>
&gt;<em class=typing>(</em><em class=red>j0</em><em class=typing> 2.0)</em>
<em class=listener>0.223890779141236</em>
&gt;<em class=typing>(define (bes-fm dur freq amp ratio index)
 ;; bessel-FM from CLM
   (let* ((car-ph 0.0)
	  (mod-ph 0.0)
 	  (car-incr (hz-&gt;radians freq))
	  (mod-incr (* ratio car-incr))
	  (ampenv (make-env :envelope '(0 0 25 1 75 1 100 0) :scaler amp :end dur))
	  (output (make-vct dur)))
     (vct-map! output
       (lambda ()
         (let ((val (* (env ampenv) (</em><em class=red>j0</em><em class=typing> car-ph))))
           (set! car-ph (+ car-ph car-incr (* index (</em><em class=red>j0</em><em class=typing> mod-ph))))
           (set! mod-ph (+ mod-ph mod-incr))
	   val)))
     (vct-&gt;samples 0 dur output)))</em>
<em class=listener>#&lt;unspecified&gt;</em>
&gt;<em class=typing>(bes-fm 22050 440 10.0 1.0 8.0)</em>
</pre>

<p>To acess and edit sound data from such a module, use the
Snd functions make-sample-reader and loop-samples.  loop-samples
takes a sample reader, a pointer to a (C) float function that takes
one float argument (the current sample), the number of times
to call that function, and a name for the editing operation for
the edit history list.  For example, the following module
defines a function that scales the data by 2:</p>
<pre>
#include &lt;guile/gh.h&gt;

static float a2(float b) {return(b * 2.0);}

static SCM get_a2(void) {return(scm_ulong2num((unsigned long)a2));}

void init_hiho() {scm_c_define_gsubr("get-a2", 0, 0, 0, get_a2);}
</pre>
<p>The "a2" function will be called from Snd as follows; first make
the shared object module and load it as above, then</p>
<pre>
(loop-samples (make-sample-reader 0) (get-a2) 50828 "a2")
</pre>
<p>There's a way to make a module like this loadable via the
(use-modules ...) syntax in Guile, but I haven't delved into
it yet.</p>

<p>To call internal Snd functions, you can do something like
the following: declare an SCM variable to hold the procedure
variable, in the init function set the variable to the
value of scm_symbol_value0("function-name"), and in the
rest of the code call it via scm_apply. The following
is a sketch using the Snd internal "srate" function:</p>
<pre>
  #include &lt;guile/gh.h&gt;
  static SCM g_srate;
  static SCM srate_wrapper(SCM a) {return(scm_call_1(g_srate, a));}
  void init_srate(void) 
  { 
    scm_c_define_gsubr("my-srate", 1, 0, 0, srate_wrapper);
    g_srate = scm_symbol_value0("srate");
  }
</pre>
<p>Alternatively, you can simply use scm_eval_str0:</p>
<pre>
  scm_eval_str0("(recorder-dialog)");
  scm_eval_str0("(open-sound \"oboe.snd\")");
  srate = scm_num2int(scm_eval_str0("(srate)"), 0, "");
</pre>


<p><A NAME="sndsndlib"></a>
To use sndlib (clm) functions from a shared object file can be a bit
tricky; first you need to build sndlib as a shared library (named
"libsndlib.so" for loader convenience).  If it's not in a directory
the loader normally searches, you need to use -rpath in the loader
arguments to force the loader to look in the right place. 
Here's an example that
implements <a href="sndscm.html#effectsdoc">new-effects.scm</a>'s flanger in a file named eff.c:
</p>
<pre>
#include &lt;guile/gh.h&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include "sndlib.h"
#include "clm.h"

typedef struct {
  mus_any *del, *ri;
} flg;

static flg *make_flange(float flg_speed, float flg_amount, float flg_time)
{
  flg *gens;
  int len;
  len = (int)(flg_time * 22050) + 1;
  gens = (flg *)calloc(1, sizeof(flg));
  gens-&gt;del = mus_make_delay(len, NULL, (int)(len + 1 + flg_amount));
  gens-&gt;ri = mus_make_rand_interp(flg_speed, flg_amount);
  return(gens);
}

static float run_flange(float inval, void *ugens)
{
  flg *gens = (flg *)ugens;
  return(0.75 * (inval + mus_delay(gens-&gt;del, inval, mus_rand_interp(gens-&gt;ri, 0.0))));
}

static void free_flange(flg *gens)
{
  mus_free(gens-&gt;del);
  mus_free(gens-&gt;ri);
  free(gens);
}

static SCM g_make_flange(SCM speed, SCM amount, SCM time)
{
  flg *gens;
  gens = make_flange(scm_num2dbl(speed, "make-flange"), scm_num2dbl(amount, "make-flange"), scm_num2dbl(time, "make-flange"));
  return(scm_ulong2num((unsigned long)(gens)));
}

static SCM g_get_flange(void)
{
  return(scm_ulong2num((unsigned long)run_flange));
}

static SCM g_free_flange(SCM g_gens)
{
  free_flange((flg *)scm_num2ulong(g_gens, 0, "free-flange"));
  return(XEN_FALSE);
}

void init_eff(void)
{
  mus_sound_initialize();
  init_mus_module();
  scm_c_define_gsubr("free-flange", 1, 0, 0, g_free_flange);
  scm_c_define_gsubr("get-flange", 0, 0, 0, g_get_flange);
  scm_c_define_gsubr("make-flange", 3, 0, 0, g_make_flange);
}
</pre>
<p>Now compile eff.c and turn it into eff.so, then</p>
<pre>
(define lib (dynamic-link "/home/bil/cl/eff.so"))
(dynamic-call "init_eff" lib)
</pre>
<p>If this gets the catch-all error "file not found: eff.so",
it's actually complaining about the libraries, not eff.so itself.
In a case where I had both guile and sndlib on unusual directories, I used:
</p>
<pre>
ld -shared -o eff.so eff.o -rpath /home/bil/test/lib -L/home/bil/test/lib -lguile -rpath /home/bil/cl -L/home/bil/cl -lsndlib -ldl -lm
</pre>
<p>and changed the Snd makefile LIBS statement to:</p>
<pre>
LIBS = -Xlinker -rpath -Xlinker /home/bil/test/lib -L/home/bil/test/lib -lguile -Xlinker -rpath -Xlinker /home/bil/cl -L/home/bil/cl -lsndlib -lmcheck -L/usr/X11R6/lib -lXm -lXp -lXpm -lXt -lXext -lX11 -ldl -lm
</pre>
<p>
If all else fails (as it usually does when using libtool's dynamic linking),
I've included a simple dlopen call in Snd as a fallback -- (dlopen filename) will return
a "handle" (like dynamic-link), or give you a truthful error message.  The function corresponding to "dynamic-call"
is dlinit: (dlinit handle func-name) where the function in question takes no arguments.
If the sndlib.so business won't work for you, build your .so file with the sndlib object files
included explicitly:
</p>
<pre>
  ld -shared eff.o -o eff.so io.o headers.o audio.o sound.o clm.o vct.o sndlib2xen.o clm2xen.o
</pre>
<p>Then in Snd (assume we're on /home/bil/cl),</p>
<pre>
(define handle (dlopen "/home/bil/cl/eff.so"))
(dlinit handle "init_eff")
</pre>
<p>
Once the dynamic linker is happy, the flanger can be 
invoked:</p>
<pre>
(loop-samples (make-sample-reader 0) (get-flange) (frames) "flange" (make-flange 2.0 5.0 0.001))
</pre>
<p>There is (yet another)
gotcha in this business: if Snd is built in the normal way incorporating the sndlib code directly,
the call (mus-srate) in the listener does not refer to the same thing that mus_srate refers to
in eff.c; the latter is using the shared library's variable whereas Snd is using the variable
incorporated at compile time.  In addition, the initialization used in sndlib doesn't carry
over to the shared library (this is probably a bug...).  So, you can (set! (mus-srate) 22050),
and then find that mus_srate is returning 0!  It's probably best to set the shared library's
mus_srate explicitly when you initialize your module, or build Snd with sndlib.so (I've actually
never done this...).  I hope in the future to provide various modules (for the effects menu, for
example).</p>

<br>
<span class=bbox><h3><A NAME="programs">External Programs</a></h3></span>

<p>Any external program that knows about sound files can be used to perform editing operations
from Snd.  You thereby get Snd's display, analysis, header and format conversion, and edit-tree support,
and can concentrate on the actual sound effect you're developing.
The original impetus for Snd came from CLM, a large lisp-listener based program
which normally runs without a graphical
user interface, and without any simple way to move around
in what Snd calls the edit history.  Since interprocess
communication proved problematic in this case,
the communication path was simplified to
consist of little more than shared files, with CLM treated
as a batch program. A nice side-effect of this is that any other program can fit
the same mold.</p>

<p>
For example, say we have a sound processing CLM instrument we like; it takes
two sound file names as its arguments, reading the first and writing the second.
In Snd we write the current edited state to a temporary file, start CLM, call the instrument 
passing it the input and output filenames, then pass its output back
to Snd.  Snd then replaces the current data with the data our instrument wrote, as if it had incorporated that
instrument as an editing operation from the beginning.
</p>
<p>To write out the current data, we use either save-sound-as or save-selection.  Our
program then writes its changes, and Snd reads these back in as edits using
set! samples.  We can delete the Snd output at that point, though the
input (changed) files should be left for Snd to handle.  Here are some examples,
based on the Snd-4 sound-to-temp functions and its friends; these are implemented
in snd4.scm.  The basic idea is that you can write out any portion of the current
data, and (independent of any prior write) use any external sound file as an edit of any portion.
</p>
<br>

<span class=cbox><h4><A NAME="stk">STK</a></h4></span>

<p><b><a href="www-ccrma.stanford.edu/CCRMA/Software/STK/">STK</a></b>
is a synthesis toolkit developed by Perry Cook and Gary Scavone.
Like many such programs, it reads a score file and produces an output file.  We'll use it here
to replace the current sound with a clarinet tone:</p>

<table border=1 cellpadding=5><tr><td bgcolor="beige"><pre>
(define stk
  (lambda ()
    (let* ((str "")
           (data (<em class=red>sound-to-temp</em>))
           (fil (<em class=red>open-pipe</em> "syntmono Clarinet -s /tmp/test &lt; scores/hiho.ski" "r")))
      (do ((val (read-char fil) (read-char fil)))
          ((eof-object? val))
        (set! str (string-append str (string val))))
      (<em class=red>close-pipe</em> fil)
      (<em class=red>temp-to-sound</em> data "/tmp/test.snd" "(STK clarinet)")
      str)))
</pre></td></tr></table>

<p>hiho.ski is:</p>
<pre>
NoteOn          0.000000 1 60 127.000000
NoteOff         0.126032 1 60 63.500000
</pre>
<p>The basic sequence is: <b>sound-to-temp</b> writes out the current (possibly edited)
state of the selected sound(s) in Snd as a temp file.  <b>sound-to-temp</b> returns
an opaque object which we will later pass to <b>temp-to-sound</b> to complete the
edit.  But first, we open a pipe, call STK as a batch job, and read in whatever
it prints out (so we can see how the call went).  Then we call <b>temp-to-sound</b>
passing it the object mentioned earlier, the new filename (the data written by STK
that will replace the current data in Snd), and the associated edit-history reference
to the operation.  In brief:</p>
<pre>
  [sound | selection]-to-[temp | temps]
  call external program on the data and write new data
  [temp | temps]-to-[sound | selection]
</pre>

<p>But this function can't safely be called twice because it always writes
"test.snd", and it isn't very useful as an editing operation because it
completely ignores the current Snd data.  The next steps are to write
our data using safe temporary filenames, and read the current data
using <b>temp-filenames</b>.  We'll also apply this to the current
selection, rather than the full file.  Since I don't know enough
about STK to get it to read an input file, I'll use Sox for the
next examples.</p>
<br>
<span class=cbox><h4><A NAME="sox">Sox</a></h4></span>

<p>Sox is a widely available and well-known program for sound format conversions
and various sound effects.  In this case, we'll read and write NeXT files, and
use Sox's copy "effect".</p>

<table border=1 cellpadding=5><tr><td bgcolor="beige"><pre>
(define sox
  (lambda ()
    (let ((data (<em class=red>selection-to-temp</em>)))
      (if data
	  (let* ((str "")
                 (input-names (<em class=red>temp-filenames</em> data))
                 (output-name (string-append (<em class=red>tmpnam</em>) ".snd"))
		 (cmd (string-append
		        "sox -t .au \""
                        (<em class=red>vector-ref</em> input-names 0)
			"\" -t .au \""
			output-name
			"\" copy"))
		 (fil (open-pipe cmd "r")))
	    (do ((val (read-char fil) (read-char fil))) 
		((eof-object? val))
	      (set! str (string-append str (string val))))
	    (close-pipe fil)
	    (<em class=red>temp-to-selection</em> data output-name "(sox copy)")
	    str)
	  (report-in-minibuffer "no current selection")))))
</pre></td></tr></table>

<p>We use the Guile built-in function <i>tmpnam</i> to get an output
file name that doesn't collide with any existing file; 
We then read the incoming filename that Snd wrote (<i>temp-filenames</i>),
and pass that to Sox.  This is a very complicated no-op,
since Sox in this case merely copies its input to its output.
We're assuming NeXT/Sun files (the
"-t .au" business), and
we're blithely ignored the possibility that we might be
editing any number of sounds, each with any number of channels.  To deal with
the latter, we need to notice how many mono files have been passed to us (in the
case of <i>sound-to-temps</i>), or our external program needs to be able
to handle a file with arbitrarily many channels (<i>sound-to-temp</i>).
In the next example, we'll loop through the mono files, processing each
in turn.  We'll also start packaging up the boilerplate a bit.</p>

<table border=1 cellpadding=5><tr><td bgcolor="beige"><pre>
(define execute-and-wait
  (lambda (cmd)
    (let ((str "")
	  (fil (open-pipe cmd "r")))
      (do ((val (read-char fil) (read-char fil))) 
	  ((eof-object? val))
	(set! str (string-append str (string val))))
      (close-pipe fil)
      str)))

(define loop-through-files
  (lambda (description make-cmd)
    (let* ((data (<em class=red>sound-to-temps</em>))
	   (input-names (temp-filenames data))
	   (files (vector-length input-names))
	   (output-names (make-vector files "")))
      (do ((i 0 (1+ i)))
	  ((= i files))
	(vector-set! output-names i (string-append (tmpnam) ".snd"))
	(execute-and-wait (make-cmd (vector-ref input-names i) (vector-ref output-names i))))
      (<em class=red>temps-to-sound</em> data output-names description))))

(define sox-1
  (lambda ()
    (loop-through-files
     "(sox copy)"
     (lambda (in out)
       (string-append "sox -t .au \""	in "\" -t .au \"" out "\" copy")))))
</pre></td></tr></table>

<p>Now our <i>sox</i> function can handle any number of files or
channels that might be sync'd together in Snd.  In case it's not
obvious, the function <i>loop-through-files</i> takes as its second argument
a function of two arguments, and calls it on each file as we march
through the input file list, passing it the input and output file
names as arguments.  It (<i>make-cmd</i>) puts together the actual
call on sox that we were making earlier.  An equivalent using cp is:</p>

<table border=1 cellpadding=5><tr><td bgcolor="beige"><pre>
(define copyfile
  (lambda ()
    (loop-through-files
      "(cp)"
      (lambda (in out)
        (string-append "cp " in " " out)))))
</pre></td></tr></table>

<p>But we're still assuming NeXT/Sun format files, and we're throwing away the string
we so laboriously created.  A more friendly function would display its progress.
</p>
<br>
<span class=cbox><h4><A NAME="clm">CLM</a></h4></span>

<p>Reading, mixing, and writing sound files are no problem in CLM, but
it's unusual to run it as a batch program.
Assume for the moment we have loaded the CLM instruments we want (v.ins and jcrev.ins),
and have saved the image using ACL 5.0 in Linux.  The CLM image is
invoked in this case with <code>lisp -I clm.dxl</code>.  ACL provides
a way (<i>-e</i>) to evaluate lisp code from the command line, so
we'll use that along with the <i>exit</i> function to turn CLM
into a batch program.  For example, we can reverberate the current data:</p>

<table border=1 cellpadding=5><tr><td bgcolor="beige"><pre>
(define reverb
  (lambda (reverb-amount)
    (loop-through-files
     (string-append "(reverb " (number-&gt;string reverb-amount) ")")
     (lambda (in out)
       (string-append
	"lisp -I clm.dxl "
	"-e '(progn (restart-clm) "
	"      (with-sound (:play nil :output \"" out "\" :reverb jc-reverb) "
	"        (mix \"" in "\") "
	"        (mix \"" in "\" :output *reverb* :amplitude " (number-&gt;string reverb-amount) "))"
	"      (exit))'")))))
</pre></td></tr></table>

<p>This is a call on CLM's <i>with-sound</i> with a reverberator
and two calls on <i>mix</i>, one for the direct signal, the
other for the reverb input.  The with-sound form is wrapped up
in a progn that calls <i>restart-clm</i> (to make sure all dynamically
allocated entities are setup properly), the with-sound itself,
then <i>exit</i> to leave lisp (the latter is needed since we're
waiting for EOF in the <i>execute-and-wait</i> function).
The <i>reverb</i> function's argument sets the amount of
reverb, and we save that value in the edit-history descriptor.
Now, in Snd, <code>M-x (reverb .1)</code> reverbs the current
data and extends the edit-history list with the string "(reverb .1)".
This example also shows how to mix something into the current 
data.  For example, to add an fm-violin note starting at the
current cursor:
</p>

<table border=1 cellpadding=5><tr><td bgcolor="beige"><pre>
(define fm-violin
  (lambda (dur frq amp)
    (let* ((beg (/ (<em class=red>cursor</em>) (srate)))
	   (fmv-call (string-append "(fm-violin "
				    (number-&gt;string beg) " "
				    (number-&gt;string dur) " "
				    (number-&gt;string frq) " "
				    (number-&gt;string amp) ")")))
      (loop-through-files
       fmv-call
       (lambda (in out)
       (string-append
	"lisp -I clm.dxl "
	"-e '(progn (restart-clm) "
	"      (with-sound (:play nil :output \"" out "\") "
	"        (mix \"" in "\") "
	         fmv-call
	"        ) (exit))'"))))))
</pre></td></tr></table>

<p>But if anything goes wrong, the whole process gets hung, since Lisp
drops into its error handler, and Snd is waiting for the Lisp job to
exit -- we have to go to a shell and kill the Lisp subjob!
So let's check for C-g in Snd, and send the subjob output to
Guile's "current-output-port" (whatever that is):</p>

<table border=1 cellpadding=5><tr><td bgcolor="beige"><pre>
(define read-or-run
  (lambda (fil)
    (let ((val (<em class=red>peek-char</em> fil)))
      (or (and val (read-char fil))
	  (<em class=red>c-g?</em>)
	  (read-or-run fil)))))

(define execute-and-wait
  (lambda (cmd)
    (let ((fil (open-pipe cmd "r")))
      (do ((val (read-or-run fil) (read-or-run fil))) 
	  ((or (eq? val #t) (eof-object? val))
	   (eq? val #t))
        (<em class=red>write-char</em> val (<em class=red>current-output-port</em>)))
      (close-pipe fil))))
      
(define loop-through-files
  (lambda (description make-cmd)
    (let* ((data (sound-to-temps))
	   (input-names (temp-filenames data))
	   (files (vector-length input-names))
	   (output-names (make-vector files ""))
	   (stopped #f))
      (do ((i 0 (1+ i)))
	  ((or stopped (= i files)))
	(vector-set! output-names i (string-append (tmpnam) ".snd"))
	(set! stopped (execute-and-wait (make-cmd (vector-ref input-names i) (vector-ref output-names i)))))
      (temps-to-sound data output-names description))))

</pre></td></tr></table>

<p>If this is too ugly, we could probably use append-to-minibuffer instead
of write-char.  In Clisp, use the -x switch without the exit function call.
Also, place the expression to be evaluated in double quotes, rather than 
ACL's single quotes.
</p>

<br>
<span class=bbox><h3><A NAME="sndaswidget">Snd as a Widget</a></h3></span>

<p>To include the entire Snd editor as a widget in some other program,
first compile it with -DSND_AS_WIDGET. Then load it into your program,
using the procedure <b>snd_as_widget</b> to fire it up.  The program
saw.c included with Snd is a very brief example.</p>

<pre>
  void snd_as_widget(int argc, char **argv, XtAppContext app, Widget parent, Arg *caller_args, int caller_argn)
</pre>

<p>starts up the Snd editor in the widget <i>parent</i>, passing the outer Snd
form widget the arguments <i>caller_args</i> and <i>caller_argn</i>.  The
enclosing application context is <i>app</i>.  <i>parent</i> needs to
be realized at the time of the call, since Snd uses it to set up graphics
contexts and so on.  <i>argc</i> and <i>argv</i> can be passed to
simulate a shell invocation of Snd.  Remember that in this case, the
first string argument is expected to be the application name, and is
ignored by Snd.</p>

<p>In Gtk, the arguments are different, but the basic idea is the same.
saw.c has an example.</p>

<br>
<span class=bbox><h3><A NAME="sndwithclm">Snd and the CLM module</a></h3></span>

<p>The files clm.c, clm.h, and clm2xen.c implement CLM (a Common Lisp Music V implementation
described in clm.html, available in clm-2.tar.gz at ccrma-ftp) as a Guile-loadable module.
They are normally loaded into Snd when it is built.
You can see what a generator does, or a group of generators, by running them in the
lisp listener, and using the graph and spectrum functions.  For example, say we have
these declarations in ~/.snd:
</p>

<table border=1 cellpadding=5><tr><td bgcolor="beige"><pre>
(define data-size 1024)
(define data (make-vct data-size))

(define run 
  (lambda (fun)
    (do ((i 0 (1+ i))) 
        ((= i data-size))
      (vct-set! data i (fun)))
    (graph data)))

(define runf
  (lambda (fun)
    (do ((i 0 (1+ i))) 
        ((= i data-size))
      (vct-set! data i (fun)))
    (graph (snd-spectrum data blackman2-window data-size #t))))
</pre></td></tr></table>

<p>Now we can open the listener, and type:</p>
<pre>
(define hi (make-oscil))
(run (lambda () (oscil hi)))
(define ho (make-oscil))
(runf (lambda () (oscil hi (* .5 (oscil ho)))))
</pre>
<p>Obviously, any CLM instrument or function can be used in this way 
to edit sounds, and so on.  Say we want an echo effect:</p>

<table border=1 cellpadding=5><tr><td bgcolor="beige"><pre>
(define echo 
  (lambda (scaler secs)
    (let ((del (make-delay (round (* secs (srate))))))
      (lambda (inval)
        (+ inval (delay del (* scaler (+ (tap del) inval))))))))
</pre></td></tr></table>

<p>For readers who are new to Scheme, <i>echo</i> is a function
of two arguments, <i>scaler</i> and <i>secs</i>.  Scaler sets
how loud subsequent echos are, and secs sets how far apart they
are in seconds.  <i>echo</i> uses the <i>secs</i> argument to create
a delay line (<i>make-delay</i>) using the current sound's
sampling rate to turn the <i>secs</i> parameter into samples.
<i>echo</i> then returns a "closure", that is, a function with
associated variables (in this case <i>del</i> and <i>scaler</i>);
the returned function (the second <i>lambda</i>) takes
one argument (<i>inval</i>) and returns the result of passing
that value to the delay with scaling.  The upshot of all this is that
we can use:</p>
<pre>
(map-chan (echo .5 .75) 0 44100)
</pre>
<p>to take the current active channel and 
return 44100 samples of echos, each echo half the amplitude
of the previous, and spaced by .75 seconds.  <i>map-chan</i>'s
first argument is a function of one argument, the current sample;
when we pass it <i>(echo ...)</i>, it evaluates the echo call,
which returns the function that actually runs the delay line,
producing the echo.  
The CLM (common lisp) version might be something like:</p>

<table border=1 cellpadding=5><tr><td bgcolor="beige"><pre>
(definstrument echo (beg dur scaler secs file)
  (let ((del (make-delay (round (* secs *srate*))))
	(inf (open-input file))
	(j 0))
    (run
     (loop for i from beg below (+ beg dur) do
       (let ((inval (ina j inf)))
	 (outa i (+ inval (delay del (* scaler (+ (tap del) inval)))))
	 (incf j))))
    (close-input inf)))

;;; (with-sound () (echo 0 60000 .5 1.0 "pistol.snd"))
</pre></td></tr></table>

<br>
<span class=cbox><h4><A NAME="clmfuncs">CLM functions</a></h4></span>

<p>See <a href="clm.html">clm.html</a> for full details. Optional args are in italics.</p>
<br>

<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href="clm.html#all-pass">all-pass</a></td><td>(gen input <i>pm</i>)</td><td>all-pass filter</td></tr>
<tr><td><a href="clm.html#all-pass?">all-pass?</a></td><td>(gen)</td><td>#t if gen is all-pass filter</td></tr>
<tr><td><a href="clm.html#amplitude-modulate">amplitude-modulate</a></td><td>(carrier in1 in2)</td><td>amplitude modulation</td></tr>
<tr><td><a href="clm.html#array-interp">array-interp</a></td><td>(arr x)</td><td>interpolated array lookup</td></tr>
<tr><td><a href="clm.html#array-&gt;file">array-&gt;file</a></td><td colspan=2>(filename vct len srate channels)</td></tr>
<tr><td></td><td colspan=2>
write the contents of <i>vct</i> to the newly created sound file <i>filename</i>, giving 
the new file <i>channels</i> channels (data assumed to be interleaved in <i>vct</i>),
sampling rate <i>srate</i>, and <i>len</i> samples (not frames).
</td></tr>
<tr><td><a href="clm.html#asymmetric-fm">asymmetric-fm</a></td><td>(gen index <i>fm</i>)</td><td>asymmetric-fm generator</td></tr>
<tr><td><a href="clm.html#asymmetric-fm?">asymmetric-fm?</a></td><td>(gen)</td><td>#t if gen is asymmetric-fm generator</td></tr>
<tr><td><a href="clm.html#buffer-&gt;frame">buffer-&gt;frame</a></td><td>(gen frame)</td><td>buffer generator returning frame</td></tr>
<tr><td><a href="clm.html#buffer-&gt;sample">buffer-&gt;sample</a></td><td>(gen)</td><td>buffer generator returning sample</td></tr>
<tr><td><a href="clm.html#buffer-empty?">buffer-empty?</a></td><td>(gen)</td><td>#t if buffer has no data</td></tr>
<tr><td><a href="clm.html#buffer-full?">buffer-full?</a></td><td>(gen)</td><td>#t if buffer has no room for more data</td></tr>
<tr><td><a href="clm.html#buffer?">buffer?</a></td><td>(gen)</td><td>#t if gen is buffer generator</td></tr>
<tr><td><a href="clm.html#clear-array">clear-array</a></td><td>(arr)</td><td>set all elements of arr to 0.0</td></tr>
<tr><td><a href="clm.html#comb">comb</a></td><td>(gen input <i>pm</i>)</td><td>comb filter</td></tr>
<tr><td><a href="clm.html#comb?">comb?</a></td><td>(gen)</td><td>#t if gen is comb filter</td></tr>
<tr><td><a href="clm.html#contrast-enhancement">contrast-enhancement</a></td><td>(input (<i>index</i> 1.0))</td><td>a kind of phase modulation or companding</td></tr>
<tr><td><a href="clm.html#convolution">convolution</a></td><td>(sig1 sig2 n)</td><td>convolve sig1 with sig2 (size n), returning new sig1</td></tr>
<tr><td><a href="clm.html#convolve">convolve</a></td><td>(gen <i>input-function</i>)</td><td>convolve generator</td></tr>
<tr><td><a href="clm.html#convolve?">convolve?</a></td><td>(gen)</td><td>#t if gen is convolve generator</td></tr>
<tr><td><a href="clm.html#convolvefiles">convolve-files</a></td><td>(f1 f2 maxamp outf)</td><td>convolve f1 with f2, normalize to maxamp, write outf</td></tr>
<tr><td><a href="clm.html#db-&gt;linear">db-&gt;linear</a></td><td>(db)</td><td>translate dB value to linear</td></tr>
<tr><td><a href="clm.html#degrees-&gt;radians">degrees-&gt;radians</a></td><td>(deg)</td><td>translate degrees to radians</td></tr>
<tr><td><a href="clm.html#delay">delay</a></td><td>(gen input <i>pm</i>)</td><td>delay line</td></tr>
<tr><td></td><td colspan=2><br>
<b>delay</b> is a built-in syntactic form. The name <b>%delay</b> is bound
to the original meaning of <b>delay</b> in case you need to use it.
</td></tr>
<tr><td colspan=3><br></td></tr>
<tr><td><a href="clm.html#delay?">delay?</a></td><td>(gen)</td><td>#t if gen is delay line</td></tr>
<tr><td><a href="clm.html#dot-product">dot-product</a></td><td>(sig1 sig2)</td><td>return dot-product of sig1 with sig2</td></tr>
<tr><td><a href="clm.html#env">env</a></td><td>(gen)</td><td>envelope generator</td></tr>
<tr><td><a href="clm.html#env-interp">env-interp</a></td><td>(x env (<i>base</i> 1.0))</td><td>return value of env at x</td></tr>
<tr><td><a href="clm.html#env?">env?</a></td><td>(gen)</td><td>#t if gen is env (from make-env)</td></tr>
<tr><td><a href="clm.html#fft">mus-fft</a></td><td>(rl im <i>n sign</i>)</td><td>fft of rl and im (sign = -1 for ifft), result in rl</td></tr>
<tr><td valign=top><a href="clm.html#file-&gt;array">file-&gt;array</a></td><td valign=top>(filename chan start len vct)</td><td>
load <i>len</i> samples of <i>filename</i> into <i>vct</i> starting at frame <i>start</i> in channel <i>chan</i>.
</td></tr>
<tr><td><a href="clm.html#file-&gt;frame">file-&gt;frame</a></td><td>(gen loc <i>frame</i>)</td><td>return frame from file at loc</td></tr>
<tr><td><a href="clm.html#file-&gt;frame?">file-&gt;frame?</a></td><td>(gen)</td><td>#t if gen is file-&gt;frame generator</td></tr>
<tr><td><a href="clm.html#file-&gt;sample">file-&gt;sample</a></td><td>(gen loc <i>(chan 0)</i>)</td><td>return sample from file at loc</td></tr>
<tr><td><a href="clm.html#file-&gt;sample?">file-&gt;sample?</a></td><td>(gen)</td><td>#t if gen is file-&gt;sample generator</td></tr>
<tr><td><a href="clm.html#filter">filter</a></td><td>(gen input)</td><td>filter</td></tr>
<tr><td><a href="clm.html#filter?">filter?</a></td><td>(gen)</td><td>#t if gen is filter</td></tr>
<tr><td><a href="clm.html#fir-filter">fir-filter</a></td><td>(gen input)</td><td>FIR filter</td></tr>
<tr><td><a href="clm.html#fir-filter?">fir-filter?</a></td><td>(gen)</td><td>#t if gen is fir filter</td></tr>
<tr><td><a href="clm.html#formant">formant</a></td><td>(gen input)</td><td>formant generator</td></tr>
<tr><td>formant-bank</td><td>(scls gens inval)</td><td></td></tr>
<tr><td><a href="clm.html#formant?">formant?</a></td><td>(gen)</td><td>#t if gen is formant generator</td></tr>
<tr><td><a href="clm.html#frame*">frame*</a></td><td>(fr1 fr2 <i>outfr</i>)</td><td>element-wise multiply</td></tr>
<tr><td><a href="clm.html#frame+">frame+</a></td><td>(fr1 fr2 <i>outfr</i>)</td><td>element-wise add</td></tr>
<tr><td><a href="clm.html#frame-&gt;buffer">frame-&gt;buffer</a></td><td>(buf frame)</td><td>add frame to buffer</td></tr>
<tr><td><a href="clm.html#frame-&gt;file">frame-&gt;file</a></td><td>(gen loc frame)</td><td>write (add) frame to file at loc</td></tr>
<tr><td><a href="clm.html#frame-&gt;file?">frame-&gt;file?</a></td><td>(gen)</td><td>#t if gen is frame-&gt;file generator</td></tr>
<tr><td><a href="clm.html#frame-&gt;frame">frame-&gt;frame</a></td><td>(mixer frame <i>outfr</i>)</td><td>pass frame through mixer</td></tr>
<tr><td><a href="clm.html#frame-&gt;list">frame-&gt;list</a></td><td>(frame)</td><td>return list of frame contents</td></tr>
<tr><td><a href="clm.html#frame-ref">frame-ref</a></td><td>(frame chan)</td><td>return frame[chan]</td></tr>
<tr><td><a href="clm.html#frame-&gt;sample">frame-&gt;sample</a></td><td>(frmix frame)</td><td>pass frame through frame or mixer to produce sample</td></tr>
<tr><td><a href="clm.html#frame-set!">frame-set!</a></td><td>(frame chan val)</td><td>frame[chan]=val</td></tr>
<tr><td><a href="clm.html#frame?">frame?</a></td><td>(gen)</td><td>#t if gen is frame object</td></tr>
<tr><td><a href="clm.html#granulate">granulate</a></td><td>(gen <i>input-function</i>)</td><td>granular synthesis generator</td></tr>
<tr><td><a href="clm.html#granulate?">granulate?</a></td><td>(gen)</td><td>#t if gen is granulate generator</td></tr>
<tr><td><a href="clm.html#hz-&gt;radians">hz-&gt;radians</a></td><td>(freq)</td><td>translate freq to radians/sample</td></tr>
<tr><td><a href="clm.html#iir-filter">iir-filter</a></td><td>(gen input)</td><td>IIR filter</td></tr>
<tr><td><a href="clm.html#iir-filter?">iir-filter?</a></td><td>(gen)</td><td>#t if gen is iir-filter</td></tr>
<tr><td><a href="clm.html#in-any">in-any</a></td><td>(loc <i>chan stream</i>)</td><td>return sample in stream at loc and chan</td></tr>
<tr><td>in-hz</td><td>(freq)</td><td>translate freq to radians/sample</td></tr>
<tr><td><a href="clm.html#ina">ina</a></td><td>(loc <i>stream</i>)</td><td>return sample in stream at loc, chan 0</td></tr>
<tr><td><a href="clm.html#inb">inb</a></td><td>(loc <i>stream</i>)</td><td>return sample in stream at loc, chan 1</td></tr>
<tr><td><a href="clm.html#linear-&gt;db">linear-&gt;db</a></td><td>(val)</td><td>translate linear val to dB</td></tr>
<tr><td><a href="clm.html#locsig">locsig</a></td><td>(gen loc input)</td><td>place input in output channels at loc</td></tr>
<tr><td><a href="clm.html#locsig-ref">locsig-ref</a></td><td>(gen chan)</td><td>locsig-scaler[chan]</td></tr>
<tr><td><a href="clm.html#locsig-reverb-ref">locsig-reverb-ref</a></td><td>(gen chan)</td><td>locsig-reverb-scaler[chan]</td></tr>
<tr><td><a href="clm.html#locsig-set!">locsig-set!</a></td><td>(gen chan val)</td><td>locsig-scaler[chan] = val</td></tr>
<tr><td><a href="clm.html#locsig-reverb-set!">locsig-reverb-set!</a></td><td>(gen chan val)</td><td>locsig-reverb-scaler[chan] = val</td></tr>
<tr><td><a href="clm.html#locsig?">locsig?</a></td><td>(gen)</td><td>#t if gen is locsig generator</td></tr>
<tr><td colspan=3><br>
;; all the make function arguments are <a href="clm.html#optional-key">optional-key</a> args
</td></tr>
<tr><td><a href="clm.html#make-all-pass">make-all-pass</a></td><td colspan=2>(feedback feedforward size initial-contents initial-element max-size)</td></tr>
<tr><td><a href="clm.html#make-asymmetric-fm">make-asymmetric-fm</a></td><td colspan=2>(frequency initial-phase r ratio)</td></tr>
<tr><td><a href="clm.html#make-buffer">make-buffer</a></td><td colspan=2>(size fill-time)</td></tr>
<tr><td><a href="clm.html#make-comb">make-comb</a></td><td colspan=2>(scaler size initial-contents initial-element max-size)</td></tr>
<tr><td><a href="clm.html#make-convolve">make-convolve</a></td><td colspan=2>(input filter fft-size filter-size)</td></tr>
<tr><td><a href="clm.html#make-delay">make-delay</a></td><td colspan=2>(size initial-contents initial-element max-size)</td></tr>
<tr><td><a href="clm.html#make-env">make-env</a></td><td colspan=2>(envelope scaler duration offset base end start)</td></tr>
<tr><td><a href="clm.html#make-fft-window">make-fft-window</a></td colspan=2><td>(type size beta)</td></tr>
<tr><td><a href="clm.html#make-file-&gt;frame">make-file-&gt;frame</a></td><td colspan=2>(name)</td></tr>
<tr><td><a href="clm.html#make-file-&gt;sample">make-file-&gt;sample</a></td><td colspan=2>(name)</td></tr>
<tr><td><a href="clm.html#make-filter">make-filter</a></td><td colspan=2>(order xcoeffs ycoeffs)</td></tr>
<tr><td><a href="clm.html#make-fir-filter">make-fir-filter</a></td><td colspan=2>(order xcoeffs)</td></tr>
<tr><td><a href="clm.html#make-formant">make-formant</a></td><td colspan=2>(radius frequency gain)</td></tr>
<tr><td><a href="clm.html#make-frame">make-frame</a></td><td colspan=2>(chans &amp;rest vals)</td></tr>
<tr><td><a href="clm.html#make-frame-&gt;file">make-frame-&gt;file</a></td><td colspan=2>(name chans format type)</td></tr>
<tr><td><a href="clm.html#make-granulate">make-granulate</a></td><td colspan=2>(input expansion length scaler hop ramp jitter max-size)</td></tr>
<tr><td><a href="clm.html#make-iir-filter">make-iir-filter</a></td><td colspan=2>(order ycoeffs)</td></tr>
<tr><td><a href="clm.html#make-locsig">make-locsig</a></td><td colspan=2>(degree distance reverb output revout channels type)</td></tr>
<tr><td><a href="clm.html#make-mixer">make-mixer</a></td><td colspan=2>(chans &amp;rest vals)</td></tr>
<tr><td><a href="clm.html#make-notch">make-notch</a></td><td colspan=2>(scaler size initial-contents initial-element max-size)</td></tr>
<tr><td><a href="clm.html#make-one-pole">make-one-pole</a></td><td colspan=2>(a0 b1)</td></tr>
<tr><td><a href="clm.html#make-one-zero">make-one-zero</a></td><td colspan=2>(a0 a1)</td></tr>
<tr><td><a href="clm.html#make-oscil">make-oscil</a></td><td colspan=2>(frequency initial-phase)</td></tr>
<tr><td><a href="clm.html#make-phase-vocoder">make-phase-vocoder</a></td><td colspan=2>(fftsize overlap interp pitch analyze edit synthesize)</td></tr>
<tr><td><a href="clm.html#make-ppolar">make-ppolar</a></td><td colspan=2>(radius frequency)</td></tr>
<tr><td><a href="clm.html#make-pulse-train">make-pulse-train</a></td><td colspan=2>(frequency amplitude initial-phase)</td></tr>
<tr><td><a href="clm.html#make-rand">make-rand</a></td><td colspan=2>(frequency amplitude)</td></tr>
<tr><td><a href="clm.html#make-rand-interp">make-rand-interp</a></td><td colspan=2>(frequency amplitude)</td></tr>
<tr><td><a href="clm.html#make-readin">make-readin</a></td><td colspan=2>(file channel start)</td></tr>
<tr><td><a href="clm.html#make-sample-&gt;file">make-sample-&gt;file</a></td><td colspan=2>(name chans format type <i>comment</i>)</td></tr>
<tr><td><a href="clm.html#make-sawtooth-wave">make-sawtooth-wave</a></td><td colspan=2>(frequency amplitude initial-phase)</td></tr>
<tr><td><a href="clm.html#make-sine-summation">make-sine-summation</a></td><td colspan=2>(frequency initial-phase n a ratio)</td></tr>
<tr><td><a href="clm.html#make-square-wave">make-square-wave</a></td><td colspan=2>(frequency amplitude initial-phase)</td></tr>
<tr><td><a href="clm.html#make-src">make-src</a></td><td colspan=2>(input srate width)</td></tr>
<tr><td><a href="clm.html#make-sum-of-cosines">make-sum-of-cosines</a></td><td colspan=2>(frequency initial-phase cosines)</td></tr>
<tr><td><a href="clm.html#make-table-lookup">make-table-lookup</a></td><td colspan=2>(frequency initial-phase wave)</td></tr>
<tr><td><a href="clm.html#make-triangle-wave">make-triangle-wave</a></td><td colspan=2>(frequency amplitude initial-phase)</td></tr>
<tr><td><a href="clm.html#make-two-pole">make-two-pole</a></td><td colspan=2>(a0 b1 b2)</td></tr>
<tr><td><a href="clm.html#make-two-zero">make-two-zero</a></td><td colspan=2>(a0 a1 a2)</td></tr>
<tr><td><a href="clm.html#make-wave-train">make-wave-train</a></td><td colspan=2>(frequency initial-phase wave)</td></tr>
<tr><td><a href="clm.html#make-waveshape">make-waveshape</a></td><td colspan=2>(frequency partials)</td></tr>
<tr><td><a href="clm.html#make-zpolar">make-zpolar</a></td><td colspan=2>(radius frequency)</td></tr>
<tr><td><a href="clm.html#mixer*">mixer*</a></td><td>(mix1 mix2 <i>outmx</i>)</td><td>matrix multiply of mix1 and mix2</td></tr>
<tr><td><a href="clm.html#mixer-ref">mixer-ref</a></td><td>(mix in out)</td><td>mix-scaler[in,out]</td></tr>
<tr><td><a href="clm.html#mixer-set!">mixer-set!</a></td><td>(mix in out val)</td><td>mix-scaler[in,out] = val</td></tr>
<tr><td><a href="clm.html#mixer?">mixer?</a></td><td>(gen)</td><td>#t if gen is mixer object</td></tr>
<tr><td><a href="clm.html#move-locsig">move-locsig</a></td><td colspan=2>(gen degree distance)</td></tr>
<tr><td><a href="clm.html#multiply-arrays">multiply-arrays</a></td><td>(arr1 arr2)</td><td>arr1[i] *= arr2[i]</td></tr>
<tr><td><a href="clm.html#mus-a0">mus-a0</a></td><td>(gen)</td><td>a0 field (simple filters)</td></tr>
<tr><td><a href="clm.html#mus-a1">mus-a1</a></td><td>(gen)</td><td>a1 field (simple filters)</td></tr>
<tr><td><a href="clm.html#mus-a2">mus-a2</a></td><td>(gen)</td><td>a2 field (simple filters)</td></tr>
<tr><td>mus-array-print-length</td><td>()</td><td>how many array elements to print in mus_describe</td></tr>
<tr><td><a href="clm.html#mus-b1">mus-b1</a></td><td>(gen)</td><td>b1 field (simple filters)</td></tr>
<tr><td><a href="clm.html#mus-b2">mus-b2</a></td><td>(gen)</td><td>b2 field (simple filters)</td></tr>
<tr><td><a href="clm.html#musbank">mus-bank</a></td><td>(gens amps <i>args1 args2</i>)</td><td></td></tr>
<tr><td><a href="clm.html#mus-channel">mus-channel</a></td><td>(gen)</td><td>channel of gen</td></tr>
<tr><td><a href="clm.html#mus-channels">mus-channels</a></td><td>(gen)</td><td>channels of gen</td></tr>
<tr><td><a href="clm.html#mus-cosines">mus-cosines</a></td><td>(gen)</td><td>cosines of sum-of-cosines gen</td></tr>
<tr><td><a href="clm.html#mus-data">mus-data</a></td><td>(gen)</td><td>data array of gen</td></tr>
<tr><td><a href="clm.html#mus-feedback">mus-feedback</a></td><td>(gen)</td><td>feedback term of gen (simple filters)</td></tr>
<tr><td><a href="clm.html#mus-feedforward">mus-feedforward</a></td><td>(gen)</td><td>feedforward term of gen (all-pass)</td></tr>
<tr><td>mus-file-buffer-size</td><td>()</td><td>size of input/ouput buffers (default 8192)</td></tr>
<tr><td><a href="clm.html#mus-formant-radius">mus-formant-radius</a></td><td>(gen)</td><td>formant radius</td></tr>
<tr><td><a href="clm.html#mus-frequency">mus-frequency</a></td><td>(gen)</td><td>frequency of gen (Hz)</td></tr>
<tr><td><a href="clm.html#mus-hop">mus-hop</a></td><td>(gen)</td><td>hop amount of gen (granulate)</td></tr>
<tr><td><a href="clm.html#mus-increment">mus-increment</a></td><td>(gen)</td><td>increment of gen (src, readin, granulate)</td></tr>
<tr><td><a href="clm.html#mus-input?">mus-input?</a></td><td>(gen)</td><td>#t if gen is input source</td></tr>
<tr><td><a href="clm.html#mus-length">mus-length</a></td><td>(gen)</td><td>length of gen</td></tr>
<tr><td><a href="clm.html#mus-location">mus-location</a></td><td>(gen)</td><td>location (read point) of gen</td></tr>
<tr><td>mus-mix</td><td colspan=2>(outfile infile <i>(outloc 0) frames (inloc 0) mixer envs</i>)</td></tr>
<tr><td></td><td colspan=2><br>
mix <i>infile</i> into <i>outfile</i> starting at <i>outloc</i> in <i>outfile</i> and <i>inloc</i> in <i>infile</i>
mixing <i>frames</i> frames of <i>infile</i>.  <i>frames</i> defaults to the length of <i>infile</i>. If <i>mixer</i>,
use it to scale the various channels; if <i>envs</i> (an array of envelope generators), use
it in conjunction with <i>mixer</i>to scale/envelope all the various ins and outs.
</td></tr>
<tr><td colspan=3><br></td></tr>
<tr><td><a href="clm.html#mus-order">mus-order</a></td><td>(gen)</td><td>order of gen (filters)</td></tr>
<tr><td><a href="clm.html#mus-output?">mus-output?</a></td><td>(gen)</td><td>#t if gen is output generator</td></tr>
<tr><td><a href="clm.html#mus-phase">mus-phase</a></td><td>(gen)</td><td>phase of gen (radians)</td></tr>
<tr><td><a href="clm.html#mus-ramp">mus-ramp</a></td><td>(gen)</td><td>ramp time of gen (granulate)</td></tr>
<tr><td><a href="clm.html#mus-random">mus-random</a></td><td>(val)</td><td>random numbers bewteen -val and val</td></tr>
<tr><td><a href="clm.html#mus-run">mus-run</a></td><td>(gen <i>arg1 arg2</i>)</td><td>apply gen to args</td></tr>
<tr><td><a href="clm.html#mus-scaler">mus-scaler</a></td><td>(gen)</td><td>scaler of gen</td></tr>
<tr><td><a href="clm.html#mus-set-rand-seed">mus-rand-seed</a></td><td>(val)</td><td>random number generator seed (settable via set!)</td></tr>
<tr><td>mus-set-srate</td><td>(val)</td><td>set sampling rate to val -- (set! (mus-srate) val) is the same.</td></tr>
<tr><td>mus-srate</td><td>()</td><td>current sampling rate</td></tr>
<tr><td><a href="clm.html#mus-xcoeffs">mus-xcoeffs</a></td><td>(gen)</td><td>feedforward (FIR) coeffs of filter</td></tr>
<tr><td><a href="clm.html#mus-ycoeffs">mus-ycoeffs</a></td><td>(gen)</td><td>feedback (IIR) coeefs of filter</td></tr>
<tr><td><a href="clm.html#notch">notch</a></td><td>(gen input <i>pm</i>)</td><td>notch filter</td></tr>
<tr><td><a href="clm.html#notch?">notch?</a></td><td>(gen)</td><td>#t if gen is notch filter</td></tr>
<tr><td><a href="clm.html#one-pole">one-pole</a></td><td>(gen input)</td><td>one-pole filter</td></tr>
<tr><td><a href="clm.html#one-pole?">one-pole?</a></td><td>(gen)</td><td>#t if gen is one-pole filter</td></tr>
<tr><td><a href="clm.html#one-zero">one-zero</a></td><td>(gen input)</td><td>one-zero filter</td></tr>
<tr><td><a href="clm.html#one-zero?">one-zero?</a></td><td>(gen)</td><td>#t if gen is one-zero filter</td></tr>
<tr><td><a href="clm.html#oscil">oscil</a></td><td>(gen <i>fm pm</i>)</td><td>sine wave generator</td></tr>
<tr><td><a href="clm.html#oscilbank">oscil-bank</a></td><td>(scls gens invals)</td><td>bank of oscils</td></tr>
<tr><td><a href="clm.html#oscil?">oscil?</a></td><td>(gen)</td><td>#t if gen is oscil generator</td></tr>
<tr><td><a href="clm.html#out-any">out-any</a></td><td>(loc samp chan <i>stream</i>)</td><td>write (add) samp to stream at loc in channel chan</td></tr>
<tr><td><a href="clm.html#outa">outa</a></td><td>(loc samp <i>stream</i>)</td><td>write (add) samp to stream at loc in chan 0</td></tr>
<tr><td><a href="clm.html#outb">outb</a></td><td>(loc samp <i>stream</i>)</td><td>write (add) samp to stream at loc in chan 1</td></tr>
<tr><td><a href="clm.html#outc">outc</a></td><td>(loc samp <i>stream</i>)</td><td>write (add) samp to stream at loc in chan 2</td></tr>
<tr><td><a href="clm.html#outd">outd</a></td><td>(loc samp <i>stream</i>)</td><td>write (add) samp to stream at loc in chan 3</td></tr>
<tr><td><a href="clm.html#partials-&gt;polynomial">partials-&gt;polynomial</a></td><td>(partials <i>kind</i>)</td><td>create waveshaping polynomial from partials</td></tr>
<tr><td><a href="clm.html#partials-&gt;wave">partials-&gt;wave</a></td><td>(synth-data table <i>norm</i>)</td><td>load table from synth-data</td></tr>
<tr><td><a href="clm.html#partials-&gt;waveshape">partials-&gt;waveshape</a></td><td>(partials <i>norm size</i>)</td><td>create waveshaping table from partials</td></tr>
<tr><td><a href="clm.html#phase-partials-&gt;wave">phase-partials-&gt;wave</a></td><td>(synth-data table <i>norm</i>)</td><td>load table from synth-data</td></tr>
<tr><td><a href="clm.html#phase-vocoder">phase-vocoder</a></td><td>(pv input)</td><td>phase vocoder generator</td></tr>
<tr><td><a href="clm.html#phase-vocoder?">phase-vocoder?</a></td><td>(pv)</td><td>#t if pv is phase vocoder generator</td></tr>
<tr><td><a href="clm.html#polar-&gt;rectangular">polar-&gt;rectangular</a></td><td>(rl im)</td><td>translate from polar to rectangular coordinates</td></tr>
<tr><td><a href="clm.html#polynomial">polynomial</a></td><td>(coeffs x)</td><td>evaluate polynomial at x</td></tr>
<tr><td><a href="clm.html#pulse-train">pulse-train</a></td><td>(gen <i>fm</i>)</td><td>pulse-train generator</td></tr>
<tr><td><a href="clm.html#pulse-train?">pulse-train?</a></td><td>(gen)</td><td>#t if gen is pulse-train generator</td></tr>
<tr><td><a href="clm.html#radians-&gt;degrees">radians-&gt;degrees</a></td><td>(rads)</td><td>convert radians to degrees</td></tr>
<tr><td><a href="clm.html#radians-&gt;hz">radians-&gt;hz</a></td><td>(rads)</td><td>convert radians/sample to Hz</td></tr>
<tr><td><a href="clm.html#rand">rand</a></td><td>(gen <i>fm</i>)</td><td>random number generator</td></tr>
<tr><td><a href="clm.html#rand-interp">rand-interp</a></td><td>(gen <i>fm</i>)</td><td>interpolating random number generator</td></tr>
<tr><td><a href="clm.html#rand-interp?">rand-interp?</a></td><td>(gen)</td><td>#t if gen is interpolating random number generator</td></tr>
<tr><td><a href="clm.html#rand?">rand?</a></td><td>(gen)</td><td>#t if gen is random number generator</td></tr>
<tr><td><a href="clm.html#readin">readin</a></td><td>(gen)</td><td>read one value from associated input stream</td></tr>
<tr><td><a href="clm.html#readin?">readin?</a></td><td>(gen)</td><td>#t if gen is readin generator</td></tr>
<tr><td><a href="clm.html#rectangular-&gt;polar">rectangular-&gt;polar</a></td><td>(rl im)</td><td>translate from rectangular to polar coordinates</td></tr>
<tr><td><a href="clm.html#restart-env">restart-env</a></td><td>(env)</td><td>return to start of env</td></tr>
<tr><td><a href="clm.html#ring-modulate">ring-modulate</a></td><td>(sig1 sig2)</td><td>sig1 * sig2 (element-wise)</td></tr>
<tr><td><a href="clm.html#sample-&gt;buffer">sample-&gt;buffer</a></td><td>(buf samp)</td><td>store samp in buffer</td></tr>
<tr><td><a href="clm.html#sample-&gt;file">sample-&gt;file</a></td><td>(gen loc chan val)</td><td>store val in file at loc in channel chan</td></tr>
<tr><td><a href="clm.html#sample-&gt;file?">sample-&gt;file?</a></td><td>(gen)</td><td>#t if gen is sample-&gt;file generator</td></tr>
<tr><td><a href="clm.html#sample-&gt;frame">sample-&gt;frame</a></td><td>(frmix samp <i>outfr</i>)</td><td>convert samp to frame</td></tr>
<tr><td><a href="clm.html#sawtooth-wave">sawtooth-wave</a></td><td>(gen <i>fm</i>)</td><td>sawtooth-wave generator</td></tr>
<tr><td><a href="clm.html#sawtooth-wave?">sawtooth-wave?</a></td><td>(gen)</td><td>#t if gen is sawtooth-wave generator</td></tr>
<tr><td><a href="clm.html#sine-summation">sine-summation</a></td><td>(gen <i>fm</i>)</td><td>sine-summation generator</td></tr>
<tr><td><a href="clm.html#sine-summation?">sine-summation?</a></td><td>(gen)</td><td>#t if gen is sine-summation generator</td></tr>
<tr><td><a href="clm.html#spectrum">spectrum</a></td><td>(rl im win type)</td><td>produce spectrum of data in rl (return rl)</td></tr>
<tr><td><a href="clm.html#square-wave">square-wave</a></td><td>(gen <i>fm</i>)</td><td>square-wave generator</td></tr>
<tr><td><a href="clm.html#square-wave?">square-wave?</a></td><td>(gen)</td><td>#t if gen is square-wave generator</td></tr>
<tr><td><a href="clm.html#src">src</a></td><td>(gen <i>fm input-function</i>)</td><td>sample rate converter</td></tr>
<tr><td><a href="clm.html#src?">src?</a></td><td>(gen)</td><td>#t if gen is sample-rate converter</td></tr>
<tr><td><a href="clm.html#sum-of-cosines">sum-of-cosines</a></td><td>(gen <i>fm</i>)</td><td>sum-of-cosines (pulse-train) generator</td></tr>
<tr><td><a href="clm.html#sum-of-cosines?">sum-of-cosines?</a></td><td>(gen)</td><td>#t if gen is sum-of-cosines generator</td></tr>
<tr><td><a href="clm.html#sum-of-sines">sum-of-sines</a></td><td>(amps phases)</td><td>additive synthesis</td></tr>
<tr><td><a href="clm.html#table-lookup">table-lookup</a></td><td>(gen <i>fm</i>)</td><td>table-lookup generator</td></tr>
<tr><td><a href="clm.html#table-lookup?">table-lookup?</a></td><td>(gen)</td><td>#t if gen is table-lookup generator</td></tr>
<tr><td><a href="clm.html#tap">tap</a></td><td>(gen <i>pm</i>)</td><td>delay line tap</td></tr>
<tr><td><a href="clm.html#triangle-wave">triangle-wave</a></td><td>(gen <i>fm</i>)</td><td>triangle-wave generator</td></tr>
<tr><td><a href="clm.html#triangle-wave?">triangle-wave?</a></td><td>(gen)</td><td>#t if gen is triangle-wave generator</td></tr>
<tr><td><a href="clm.html#two-pole">two-pole</a></td><td>(gen input)</td><td>two-pole filter</td></tr>
<tr><td><a href="clm.html#two-pole?">two-pole?</a></td><td>(gen)</td><td>#t if gen is two-pole filter</td></tr>
<tr><td><a href="clm.html#two-zero">two-zero</a></td><td>(gen input)</td><td>two-zero filter</td></tr>
<tr><td><a href="clm.html#two-zero?">two-zero?</a></td><td>(gen)</td><td>#t if gen is two-zero filter</td></tr>
<tr><td><a href="clm.html#wave-train">wave-train</a></td><td>(gen <i>fm</i>)</td><td>wave-train generator</td></tr>
<tr><td><a href="clm.html#wave-train?">wave-train?</a></td><td>(gen)</td><td>#t if gen is wave-train generator</td></tr>
<tr><td><a href="clm.html#waveshape">waveshape</a></td><td>(gen <i>index fm</i>)</td><td>waveshaping generator</td></tr>
<tr><td><a href="clm.html#waveshape?">waveshape?</a></td><td>(gen)</td><td>#t if gen is waveshape generator</td></tr>
</table>
<br>

<p>In Snd, the default locsig interpolation type is handled via locsig-type, rather than CLM's global
variable *clm-locsig-type*.
</p>

<p><b>formant-bank</b> and <b>oscil-bank</b> are optimizations for situations like the phase
vocoder or cross synthesis (see <a href="sndscm.html#exampdoc">examp.scm</a>).  It is assumed that you have a vector of generators,
all summing their outputs into a single float.  The amplitude scalers (the first argument to
the bank function) can be a float, a vector of floats, a vct of floats, or a function that
returns a float each time it is called; similarly for the inputs (the third argument); the
bank of generators (the second argument) is assumed to be a vector full of generators. </p>
<pre>
  (formant-bank amps gens inval)
</pre>
<p>is essentially the same as (but 30 times faster than)</p>
<pre>
  (do ((sum 0.0)
       (i 0 (1+ i))) 
      ((= i (vct-length gens)) sum)
    (set! sum (+ sum (* (vector-ref amps i)
                        (formant (vector-ref gens i) inval)))))
</pre>
<p>in the all-vector case.  <a href="clm.html#musbank">mus-bank</a> is the general case.
Here are a few more examples, taken from <a href="sndscm.html#exampdoc">examp.scm</a>.
</p>
<pre>


(define comb-filter 
  (lambda (scaler size)
    (let ((cmb (make-comb scaler size)))
      (lambda (x) (comb cmb x)))))

; (map-chan (comb-filter .8 32))

;;; by using filters at harmonically related sizes, we can get chords:

(define comb-chord
  (lambda (scaler size amp)
    (let ((c1 (make-comb scaler size))
	  (c2 (make-comb scaler (* size .75)))
	  (c3 (make-comb scaler (* size 1.2))))
      (lambda (x)
        (* amp (+ (comb c1 x) (comb c2 x) (comb c3 x)))))))

; (map-chan (comb-chord .95 60 .3))

;;; or change the comb length via an envelope:

(define max-envelope
  (lambda (e mx)
    (if (null? e)
	mx
      (max-envelope (cddr e) (max mx (abs (cadr e)))))))

(define zcomb
  (lambda (scaler size pm)
    (let ((cmb (make-comb scaler size :max-size (+ size 1 (max-envelope pm 0))))
	  (penv (make-env :envelope pm :end (frames))))
      (lambda (x) (comb cmb x (env penv))))))

; (map-chan (zcomb .8 32 '(0 0 1 10)))

;;; to impose several formants, just add them in parallel:

(define formants
  (lambda (r1 f1 r2 f2 r3 f3)
    (let ((fr1 (make-formant r1 f1))
	  (fr2 (make-formant r2 f2))
	  (fr3 (make-formant r3 f3)))
      (lambda (x)
	(+ (formant fr1 x)
	   (formant fr2 x)
	   (formant fr3 x))))))

; (map-chan (formants .01 900 .02 1800 .01 2700))

;;; to get a moving formant:

(define moving-formant
  (lambda (radius move)
    (let ((frm (make-formant radius (cadr move)))
	  (menv (make-env :envelope move :end (frames))))
      (lambda (x)
        (let ((val (formant frm x)))
	  (set! (mus-frequency frm) (env menv))
	  val)))))

; (map-chan (moving-formant .01 '(0 1200 1 2400)))

;;; various "Forbidden Planet" sound effects:

(define sp
  (lambda (sr osamp osfrq)
    (let* ((os (make-oscil osfrq))
	   (sr (make-src :srate sr))
	   (len (frames))
	   (sf (make-sample-reader))
	   (out-data (make-vct len)))
      (vct-map! out-data
		  (lambda () 
		    (src sr (* osamp (oscil os))
			 (lambda (dir)
			   (if (&gt; dir 0)
			       (next-sample sf)
			       (previous-sample sf))))))
      (free-sample-reader sf)
      (vct-&gt;samples 0 len out-data))))

; (fp 1.0 .3 20)


;;; -------- shift pitch keeping duration constant
;;;
;;; both src and granulate take a function argument to get input whenever it is needed.
;;; in this case, src calls granulate which reads the currently selected file.

(define <A NAME="expsrc">expsrc</a>
  (lambda (rate)
    (let* ((gr (make-granulate :expansion rate))
	   (sr (make-src :srate rate))
	   (vsize 1024)
	   (vbeg 0)
	   (v (samples-&gt;vct 0 vsize))
	   (inctr 0))
      (lambda (inval)
        (src sr 0.0
	  (lambda (dir)
	    (granulate gr
	      (lambda (dir)
		(let ((val (vct-ref v inctr)))
		  (set! inctr (+ inctr dir))
		  (if (&gt;= inctr vsize)
		      (begin
			(set! vbeg (+ vbeg inctr))
			(set! inctr 0)
			(samples-&gt;vct vbeg vsize 0 0 v)))
		  val)))))))))

</pre>
<p>Geez, I haven't had this much fun in a long time!  Check out <a href="sndscm.html#exampdoc">examp.scm</a> and <a href="sndscm.html#sndtestdoc">snd-test.scm</a> for more.  
CLM-in-CL users will be disappointed with the CLM-in-Scheme performance; my tests indicate that
interpreted Scheme (as in Snd currently) is about 30 to 100 times slower than CLM instruments using
the "run" macro.  I am translating that macro for use in Snd; see the <a href="extsnd.html#optimization">optimization</a>
variable for a brief discussion.  Currently, I can speed up most CLM-related Scheme code
by factors between 8 and 20.  This is still slightly slower than CLM, but it's certainly
an improvement!
</p>
<br>

<span class=bbox><h3><A NAME="sndwithmotif">Snd and Motif</a></h3></span>

<p>It is possible to add your own user-interface elements using the xm module
included with Snd.  'make xm' should create
a shared library named xm.so; you can load this at any time into Snd:
</p>
<pre>
&gt; <em class=typing>(define hxm (dlopen "/home/bil/snd-5/xm.so"))</em>
<em class=listener>#&lt;unspecified&gt;</em>
&gt; <em class=typing>(dlinit hxm "init_xm")</em>
<em class=listener>#t</em>
</pre>
<p>and now we have access to all of X and Motif.
As a very simple example, here's dialog window with a slider:</p>
<pre>
(define scale-dialog #f)
(define current-scaler 1.0)

(define (create-scale-dialog parent)
  (if (not (|Widget? scale-dialog))
      (let ((xdismiss (|XmStringCreate "Dismiss" |XmFONTLIST_DEFAULT_TAG))
	    (xhelp (|XmStringCreate "Help" |XmFONTLIST_DEFAULT_TAG))
	    (titlestr (|XmStringCreate "Scaling" |XmFONTLIST_DEFAULT_TAG)))
	(set! scale-dialog 
	      (|XmCreateTemplateDialog parent "Scaling"
                (list |XmNcancelLabelString   xdismiss
		      |XmNhelpLabelString     xhelp
		      |XmNautoUnmanage        #f
		      |XmNdialogTitle         titlestr
		      |XmNresizePolicy        |XmRESIZE_GROW
	              |XmNnoResize            #f
		      |XmNtransient           #f) ))
	(|XtAddCallback scale-dialog 
			|XmNcancelCallback (lambda (w context info)
					     (|XtUnmanageChild scale-dialog)))
	(|XtAddCallback scale-dialog 
			|XmNhelpCallback (lambda (w context info)
					   (snd-print "move the slider to affect the volume")))
	(|XmStringFree xhelp)
	(|XmStringFree xdismiss)
	(|XmStringFree titlestr)

	(let* ((mainform 
		(|XtCreateManagedWidget "formd" |xmFormWidgetClass scale-dialog
                  (list |XmNleftAttachment      |XmATTACH_FORM
		        |XmNrightAttachment     |XmATTACH_FORM
		        |XmNtopAttachment       |XmATTACH_FORM
		        |XmNbottomAttachment    |XmATTACH_WIDGET
		        |XmNbottomWidget        (|XmMessageBoxGetChild scale-dialog |XmDIALOG_SEPARATOR))))
	       (scale
		(|XtCreateManagedWidget "" |xmScaleWidgetClass mainform
		  (list |XmNorientation |XmHORIZONTAL
			|XmNshowValue   #t
			|XmNvalue       100
			|XmNmaximum     500
			|XmNdecimalPoints 2))))

      (|XtAddCallback scale 
		      |XmNvalueChangedCallback (lambda (w context info)
						 (set! current-scaler (/ (|value info) 100.0))))
      (|XtAddCallback scale |XmNdragCallback (lambda (w context info)
						 (set! current-scaler (/ (|value info) 100.0)))))))
  (|XtManageChild scale-dialog))

(create-scale-dialog (cadr (main-widgets)))
</pre>
<p>In Ruby, this would be:</p>
<pre>
$scale_dialog = false
$current_scaler = 1.0

def create_scale_dialog(parent)
  if !RWidget?($scale_dialog) 
    then
      xdismiss = RXmStringCreate("Dismiss", RXmFONTLIST_DEFAULT_TAG)
      xhelp = RXmStringCreate("Help", RXmFONTLIST_DEFAULT_TAG)
      titlestr = RXmStringCreate("Scaling", RXmFONTLIST_DEFAULT_TAG)
      $scale_dialog = RXmCreateTemplateDialog(parent, "Scaling",
                   	[RXmNcancelLabelString,  xdismiss,
                      	 RXmNhelpLabelString,    xhelp,
                      	 RXmNautoUnmanage,       false,
                      	 RXmNdialogTitle,        titlestr,
                      	 RXmNresizePolicy,       RXmRESIZE_GROW,
                      	 RXmNnoResize,           false,
                       	 RXmNtransient,          false])
      RXtAddCallback($scale_dialog, RXmNcancelCallback, 
                     Proc.new { |w, context, info| RXtUnmanageChild($scale_dialog)})
      RXtAddCallback($scale_dialog, RXmNhelpCallback, 
                     Proc.new { |w, context, info| snd_print "move the slider to affect the volume"})
      RXmStringFree xhelp
      RXmStringFree xdismiss
      RXmStringFree titlestr
      mainform = RXtCreateManagedWidget("formd", RxmFormWidgetClass, $scale_dialog,
                  	[RXmNleftAttachment,      RXmATTACH_FORM,
                         RXmNrightAttachment,     RXmATTACH_FORM,
                         RXmNtopAttachment,       RXmATTACH_FORM,
                         RXmNbottomAttachment,    RXmATTACH_WIDGET,
                         RXmNbottomWidget,        RXmMessageBoxGetChild($scale_dialog, RXmDIALOG_SEPARATOR)])
      scale = RXtCreateManagedWidget("", RxmScaleWidgetClass, mainform,
                  	[RXmNorientation, RXmHORIZONTAL,
                         RXmNshowValue,   true,
                         RXmNvalue,       100,
                         RXmNmaximum,     500,
                         RXmNdecimalPoints, 2])
      RXtAddCallback(scale, RXmNvalueChangedCallback, 
                     Proc.new { |w, context, info| $current_scaler = Rvalue(info) / 100.0})
      RXtAddCallback(scale, RXmNdragCallback, 
                     Proc.new { |w, context, info | $current_scaler = Rvalue(info) / 100.0})
      RXtManageChild $scale_dialog
    end
end

$Snd_widgets = main_widgets()
create_scale_dialog $Snd_widgets[1]
</pre>
<p>All of Snd is at your disposal once this module is loaded.  As a more interesting example,
the next function installs our own file filtering procedure into the File:Open dialog (it uses
match-sound-files from extensions.scm):
</p>
<pre>
(define (install-searcher proc)
  (define (XmString-&gt;string str)
    (cadr (|XmStringGetLtoR str |XmFONTLIST_DEFAULT_TAG)))
  (define (XmStringTable-&gt;list st len)
    (|XmStringTableUnparse st len #f |XmCHARSET_TEXT |XmCHARSET_TEXT #f 0 |XmOUTPUT_ALL))
  (define (list-&gt;XmStringTable strs)
    (|XmStringTableParseStringArray strs (length strs) #f |XmCHARSET_TEXT #f 0 #f))
  (|XtSetValues (let ((m (open-file-dialog #f)))
                         ; make sure the dialog exists
		  (list-ref (dialog-widgets) 6))
		(list |XmNfileSearchProc                             ; set dialog file search procedure
		       (lambda (widget info)
			 (let* ((dir (XmString-&gt;string (|dir info))) ; directory string
				(files (match-sound-files proc dir)) ; list of matching files
				(fileTable (list-&gt;XmStringTable      ; XmStringTable for XmNfileListItems
                                             (map (lambda (n)        ; every file needs prepended dir
                                                    (string-append dir n)) 
                                                  files))))
			   (|XtSetValues widget                      ; change the list of files
					 (list |XmNfileListItems fileTable
					       |XmNfileListItemCount (length files)
					       |XmNlistUpdated #t)))))))

;(install-searcher (lambda (file) (= (mus-sound-srate file) 44100)))
;(install-searcher (lambda (file) (= (mus-sound-chans file) 4)))
</pre>
<p>Now click the 'Filter' button to see only those files that fit the procedure in
the dialog's files list.  See snd-motif.scm and popup.scm for more examples.
There are a few special Snd functions to support this module:
</p>
<pre>
  snd-pixel color -- returns pixel of that color
  snd-gcs -- returns list of Snd graphics contexts
  all the widget-list functions
</pre>
<br>

<span class=bbox><h3><A NAME="sndwithgtk">Snd and Gtk+</a></h3></span>

<p>This part of Snd is in progress.
Eventually I'll provide gtk equivalents of the
stuff in snd-motif.scm and popup.scm.  Once that gets squared away, most of the
graphics routines currently built-into Snd (focus-widget, recolor-widget, etc)
will be moved into Scheme.  In the meantime, here's the scale-dialog in xg/gtk:
</p>
<pre>
(define scale-dialog #f)
(define current-scaler 1.0)

(define (create-scale-dialog parent)
  (if (not scale-dialog)
      (begin
	(set! scale-dialog (|gtk_dialog_new))
	(|gtk_signal_connect (|GTK_OBJECT scale-dialog) "delete-event"
			     (lambda (w ev info)
			       (|gtk_widget_hide w)))
	(|gtk_window_set_title (|GTK_WINDOW scale-dialog) "Scale")
	(|gtk_widget_realize scale-dialog)
	(let ((dismiss (|gtk_button_new_with_label "Dismiss"))
	      (help (|gtk_button_new_with_label "Help")))
	  (|gtk_box_pack_start (|GTK_BOX (|action_area (|GTK_DIALOG scale-dialog))) dismiss #t #t 4)
	  (|gtk_box_pack_end (|GTK_BOX (|action_area (|GTK_DIALOG scale-dialog))) help #t #t 4)	
	  (|gtk_signal_connect (|GTK_OBJECT dismiss) "clicked"
			       (lambda (w info)
				 (|gtk_widget_hide scale-dialog)))
	  (|gtk_signal_connect (|GTK_OBJECT help) "clicked"
			       (lambda (w info)
				 (help-dialog "Scaler Dialog" "move the slider to affect the volume")))
	  (|gtk_widget_show dismiss)
	  (|gtk_widget_show help)
	  (let* ((adj (|gtk_adjustment_new 0.0 0.0 1.01 0.01 0.01 .01))
		 (scale (|gtk_hscale_new (|GTK_ADJUSTMENT adj))))
	    (|gtk_range_set_update_policy (|GTK_RANGE (|GTK_SCALE scale)) |GTK_UPDATE_CONTINUOUS)
	    (|gtk_scale_set_draw_value (|GTK_SCALE scale) #t)
	    (|gtk_scale_set_digits (|GTK_SCALE scale) 2)
	    (|gtk_signal_connect (|GTK_OBJECT adj) "value_changed"
				 (lambda (wadj info)
				   (set! current-scaler (|value (|GTK_ADJUSTMENT wadj)))))
	    (|gtk_box_pack_start (|GTK_BOX (|vbox (|GTK_DIALOG scale-dialog))) scale #f #f 6)
	    (|gtk_widget_show scale)))))
  (|gtk_widget_show scale-dialog))

(create-scale-dialog (cadr (main-widgets)))
</pre>
<p>The only change from the C code was the addition of GTK_ADJUSTMENT in the scale value_changed
callback -- currently the xg module assumes the first argument to the two-argument callback is
a GtkWidget, so we have to cast a GtkAdjustment back to its original type.  Once I figure out
how the "marshaller" works in Gtk, I may be able to fix this.
</p>

<br>

<span class=bbox><h3><A NAME="sndwithnogui">Snd with no GUI and scripting</a></h3></span>

<p>If Snd is built without a graphical user interface (either by specifying
--with-no-gui to configure, or by setting the USE_NO_GUI compile-time flag),
it runs Guile's "repl" (read-eval-print loop) (or Ruby's equivalent) with input from stdin.  All
the non-interface related functions are available, so you can do things
like:
</p>
<pre>
<em class=listener>snd&gt;</em><em class=typing> (new-sound "new.snd")</em>
<em class=listener>0</em>
<em class=listener>snd&gt;</em><em class=typing> (load "v.scm")</em>
<em class=listener>snd&gt;</em><em class=typing> (fm-violin 0 1 440 .1)</em>
<em class=listener>-1</em>
<em class=listener>snd&gt;</em><em class=typing> (frames 0)</em>
<em class=listener>22050</em>
<em class=listener>snd&gt;</em><em class=typing> (play)</em>
<em class=listener>#t</em>
<em class=listener>snd&gt;</em><em class=typing> (exit)</em>
</pre>
<p>Guile's repl has its own error handlers, different from the
normal Snd handlers; name completion, if it exists at all,
won't complete Snd names; there are undoubtedly other
differences that I haven't noticed.  
</p>
<p>
Since this version of
Snd is the same as the guile program with Snd loaded, you
can treat it as a scripting engine.  For example,
if you have an executable file with:
</p>
<pre>
#!/home/bil/test/snd-5/snd -l
!#
(define a-test 32)
(display "hiho")
(newline)
</pre>
<p>it can be executed just like any such script.
</p>
<pre>
/home/bil/test/snd-5/ script
hiho
:a-test
32
:(exit)
/home/bil/test/snd-5/ 
</pre>
<p>The difference between this use of Snd, and using guile itself
for scripts is that Snd uses the -l switch where guile would use -s.
As noted above, you can use the -e switch to use Snd as a pure
command-line program, and, of course, (exit) to drop back to the shell.
Here's an example script that doubles every sample in "oboe.snd" and
writes the result as "test.snd":
</p>
<pre>
#!/home/bil/test/snd-5/snd -l
!#
(open-sound "oboe.snd")
(scale-by 2.0)
(save-sound-as "test.snd")
(exit)
</pre>
<p>The functions <b>script-args</b> and <b>script-arg</b> can be used
to access the script's arguments, and if necessary (if not exiting)
tell Snd to ignore arguments.  script-args returns a list of strings
giving the arguments.  The first two are always "-l" and the script
file name. The current argument is (script-arg).  If you set this to
a higher value, Snd will subsequently ignore the intevening arguments
as it scans the startup arguments (see snd-test.scm for an example).
</p>
<pre>
#!/home/bil/test/snd-5/snd -l
!#
(if (= (length (script-args)) 2) ;i.e. ("-l" "script")
  (display "usage: script file-name...\n")
  (begin
    (open-sound (list-ref (script-args) (+ (script-arg) 1)))
    (scale-by 2.0)
    (save-sound-as "test.snd")))
(exit)
</pre>
<p>This either grumbles if no argument is given,
or scales its argument sound by 2.0:
</p>
<pre>
script pistol.snd
</pre>
<p>And obviously we can run through the entire argument list,
doubling all the sounds or whatever by using a do loop --
the following example displays all the comments it finds:
</p>
<pre>
#!/home/bil/cl/snd -l
!#
(use-modules (ice-9 format))
(if (= (length (script-args)) 2) ;i.e. ("-l" "script")
  (display "usage: script file-name...\n")
  (do ((arg (+ (script-arg) 1) (1+ arg)))
      ((= arg (length (script-args))))
    (let ((name (list-ref (script-args) arg)))
      (display (format #f "~A: ~A~%" name (mus-sound-comment name))))))
(exit)
</pre>
<p>
Say we save this as the file "comments".</p>
<pre>
/home/bil/cl/comments *.snd
</pre>
<p>If you like, you can use env:</p>
<pre>
#!/usr/bin/env snd
!#
</pre>
<p>But if that works, so will:</p>
<pre>
#!snd -l
!#
</pre>
<p>
This scripting mechanism actually will work in any version of Snd;
to keep the Snd window from popping up, use the -b (-batch) switch in
place of -l.
</p>
<p>Here's another script example; it looks for any sounds that are longer
than 40 seconds in duration, and truncates them to 40 seconds:
</p>
<pre>
#!/usr/local/bin/snd -l
!#
(if (= (length (script-args)) 2)
  (display "usage: trunc.scm file-name...\n")
  (do ((arg (+ (script-arg) 1) (1+ arg)))
      ((= arg (length (script-args))))
    (let* ((name (list-ref (script-args) arg)))
      (if (&gt; (mus-sound-duration name) 40.0)
	  (let* ((ind (open-sound name)))
	    (set! (frames ind) (* 40 (srate ind)))
	    (save-sound ind)
	    (close-sound ind))))))
(exit)
</pre>
<br>

<span class=bbox><h3><A NAME="sndandruby">Snd with Ruby</a></h3></span>

<p>Ruby is an extension language described as an "object-oriented Perl".
It provides a different syntax from that of Guile/Scheme.  In Ruby, all
the "-" are "_", "-&gt;" is "2", hooks and memo_sound have "$" prepended
(since they are global variables from Ruby's point of view), and all the constants are capitalized
(e.g. Autocorrelation).  The generalized set! functions are replaced
by "set_" plus the base name (e.g. set_window_width), with arguments
reordered in some cases to place the optional values after the new value.  That is,
<code>(set! (sync snd) 1)</code> becomes <code>set_sync(1, snd)</code>.
Hooks in Ruby (which have little or nothing to do with Ruby's "hookable variables")
are just procedures or nil, not lists of procedures as in Guile.
Here's the Ruby version of the init file given
above:
</p>
<pre>
set_window_width 800
set_window_height 500

set_listener_font "9x15"
set_help_text_font "9x15"
set_axis_numbers_font "9x15"

set_show_mix_waveforms true
set_trap_segfault false
set_show_backtrace true
set_show_indices true

set_listener_prompt ":"
show_listener

beige = make_color 0.96, 0.96, 0.86
blue = make_color 0, 0, 1
set_selected_graph_color beige
set_selected_data_color blue
</pre>
<p>Procedures are created via Proc.new, so to set the open-hook to print the
file name,
</p>
<pre>
&gt;<em class=typing>$open_hook = Proc.new { |name| snd_print name }</em>
<em class=listener>#&lt;Proc:0x40221b84&gt;</em>
&gt;<em class=typing>open_sound "oboe.snd"</em>
<em class=listener>/home/bil/cl/oboe.snd
0</em>
</pre>
<p>(The trailing "0" is the result of open_sound).
The Guile hook list support procedures aren't included in Ruby --
simply set the variable to the procedure you want, or false to clear it.
</p>
<p>Vcts and sound-data objects mixin "Comparable" and "Enumerable", and respond to various array-like methods:
</p>
<pre>
&gt;<em class=typing>v1 = make_vct 4</em>
<em class=listener>#&lt;vct[len=4]: 0.000 0.000 0.000 0.000&gt;</em>
&gt;<em class=typing>v1[3] = 1.0</em>
<em class=listener>1.0</em>
&gt;<em class=typing>v1.sort</em>
<em class=listener>0.00.00.01.0</em> # I don't know why it prints this way but ...
&gt;<em class=typing>v1</em>
<em class=listener>#&lt;vct[len=4]: 0.000 0.000 0.000 1.000&gt;</em>
&gt;<em class=typing>v1.max</em>
<em class=listener>1.0</em>
</pre>
<p>I'm thinking about making classes for things like sounds; you could then
have <code>sound + sound</code> to mix, or <code>sound * 2</code> to scale it,
a given channel could be treated as an array, accessed via <code>sound[0, 12345]</code> and so on,
These are extremely easy to add, but I'd like to coordinate this with Guile's
object system.  Keywords, CLM generic functions, and optional arguments work as in Scheme:
</p>
<pre>
&gt;<em class=typing>osc = make_oscil(:frequency, 440)</em>
<em class=listener>oscil freq: 440.000Hz, phase: 0.000</em>
&gt;<em class=typing>(oscil osc)</em>
<em class=listener>0.0</em>
&gt;<em class=typing>(oscil osc)</em>
<em class=listener>0.1250506192</em>
&gt;<em class=typing>osc.frequency</em>
<em class=listener>440.0</em>
</pre>
<p>Lists (from the Scheme point of view) are arrays (vectors) in Ruby, and various
built-in Scheme functions such as car aren't predefined, so to set up the focusing
hooks as described in <a href="extsnd.html#mouseentergraphhook">mouse-enter-graph-hook</a>
we need to do something along these lines:
</p>
<pre>
def car(v)
  v[0]
end

$mouse_enter_graph_hook = Proc.new {|snd, chn| 
			            if sound? snd then
			               focus_widget car channel_widgets snd, chn
                                    end 
                                   }

$mouse_enter_listener_hook = Proc.new { |widget| 
                                        focus_widget widget 
                                      }
</pre>
<p>Here's one more example, a translation of display-energy in draw.scm:
</p>
<pre>
def display_energy(snd, chn)
  ls = left_sample
  rs = right_sample
  data1 = make_graph_data(snd, chn)
  data = data1
  if not vct? data
    data = data1[1]
  end
  len = vct_length data
  sr = srate snd
  y_max = y_zoom_slider(snd, chn)
  vct_multiply!(data, data)
  graph(data, "energy", ls / sr, rs / sr, 0.0, y_max * y_max, snd, chn, false)
  end

# $lisp_graph_hook = Proc.new {|snd,chn| display_energy(snd,chn)}
</pre>
<p>In the listener, everything is line-oriented (that is, I'm not trying to
catch incomplete expressions).  And it appears that in Ruby, variables defined
within a file are considered local to that file(?).
The save state mechanism is incomplete, but the basic stuff works.
Unimplemented (or untested) are:
backtrace upon error, 
env lookup from the env name,
and
many cute methods.
I'm slowly translating snd-test.scm to Ruby: see snd.rb.  bird.rb is the
Ruby version of bird.scm. (My very informal timing tests indicate that
Guile and Ruby run at essentially the same speed: Guile might be about
10 to 20% faster).
</p>
<br>

<span class=bbox><h3><A NAME="sndwithgmeteor">Snd and gmeteor</a></h3></span>

<p><A NAME="gmeteor">gmeteor</A> is a Guile-based filter design package
written by Matteo Frigo, based on the Meteor system of Steiglitz, Parks,
and Kaiser.  It is freely available <a href="ftp://ftp.prosa.it/pub/gmeteor/gmeteor-0.9.tar.gz">here</a>.
Once installed, it can be loaded into Snd and used to define filters very easily:
(here I'm typing in Snd's listener and editing the numbers for legibility; the file
gm.scm is taken nearly verbatim from the gmeteor script):</p>
<pre>
&gt;<em class=typing>(load "gm.scm")</em>
<em class=listener>#&lt;unspecified&gt;</em>
&gt;<em class=typing>(load "../test/gmeteor-0.9/examples/example-1.scm")</em>
<em class=listener>#&lt;unspecified&gt;</em>
&gt;<em class=typing>*coefficients*</em>
<em class=listener>#(0.0197 -0.0406 -0.0739 0.1340 0.4479 0.4479 0.13403 -0.0739 -0.0406 0.0197)</em>
&gt;<em class=typing>(filter-sound (vector-&gt;vct *coefficients*) (vector-length *coefficients*))</em>
</pre>

<!--
<p>Since every Snd text widget is actually a little lisp listener in disguise,
we can use gmeteor directly in the Control Panel
filter text field (where the list of breakpoints is specified).
I don't currently have a version of gmeteor compatible with my
version of Snd, but the basic idea would be to have a function
that sets the filter-control-order based on the length of the *coefficients*
vector, then returns that vector as a list.
</p>
-->

<p>There is one small problem: both Snd (CLM) and gmeteor define a function
named make-filter.  Someday I'll learn enough about the Guile module system to
know how to keep gmeteor's make-filter from clobbering CLM's.  (There may
be others as well -- this is the one I happened to notice).
</p>
<br>

<span class=bbox><h3><A NAME="sndandladspa">Snd and LADSPA</a></h3></span>

<pre>
  <em class=def><a name="initladspa">init-ladspa</a></em>
  <em class=def><a name="listladspa">list-ladspa</a></em>
  <em class=def><a name="analyseladspa">analyse-ladspa</a></em> library type
  <em class=def><a name="applyladspa">apply-ladspa</a></em> reader data duration origin
</pre>

<p>Richard Furse has provided a module to support LADSPA plugins in Snd. To get it
loaded, either use the configure switch --with-ladspa, or include the compile
flag HAVE_LADSPA. Here is documentation from Richard Furse:</p>
<pre>
Supporting functions are:

	(init-ladspa)

	Performs a search of LADSPA_PATH for plugins, doesn't need to be called 
as LADSPA automatically initialises on first use however can be used to 
reinitialise if new plugins have arrived.

	(list-ladspa)

	Returns a list of lists where each inner list contains a string to 
identify the plugin library and a string to identify the plugin type within 
the library.

	(analyse-ladspa plugin-library plugin-type)

	Returns a list of assorted data about a particular plugin including a 
list of port descriptions. plugin-library and plugin-type are as provided 
by list-ladspa.

The main function is:

	(apply-ladspa reader (plugin-library plugin-type [param1 [param2 ...]]) samples origin)

	Applies a LADSPA plugin in a way very similar to loop-samples - 
essentially a plugin identifier and parameter set takes the place of func. 
An example call to apply the low-pass-filter in the CMT plugin library is 
(apply-ladspa (make-sample-reader 0) (list "cmt" "lpf" 1000) 10000 "origin").
</pre>
<p>Dave Phillips in <a href="http://www.oreillynet.com/pub/a/linux/2001/02/02/ladspa.html">Linux Audio Plug-Ins: A Look Into LADSPA"</a> adds this
example:
</p>
<pre>
  (apply-ladspa (make-sample-reader 57264) (list "cmt" "delay_5s" .3 .5) 32556 "ibm.wav")
</pre>
<p>
"This sequence tells Snd to read a block of 32556 samples from the ibm.wav file, starting at sample number 57264,
 and apply the delay_5s LADSPA plug-in (Richard Furse's delay plug-in, also found in cmt.so) with a delay time of
.3 seconds and a 50/50 dry/wet balance."
</p>
<p>To help Snd find the plugin library, set either the Snd variable <a href="extsnd.html#ladspadir">ladspa-dir</a> or the environment variable LADSPA_PATH
to the directory.
If, for example,
cmt.so is in /usr/local/lib/ladspa, (and you're using tcsh), then
</p>
<pre>
  setenv LADSPA_PATH /usr/local/lib/ladspa
</pre>
<p>or</p>
<pre>
  (set! (ladspa-dir) "/usr/local/lib/ladspa")
</pre>
<p>Snd plugins may have any number of inputs and outputs; if more
than one input is required, the first argument to apply-ladspa should be a list of readers:
</p>
<pre>
  (apply-ladspa (list (make-sample-reader 0 0 0)  ;chan 0
                      (make-sample-reader 0 0 1)) ;chan 1
                (list "cmt" "freeverb3" 0 .5 .5 .5 .5 .5) 
                100000 "freeverb")
</pre>
<p><a name="ladspachannel"></a>The "regularized" version of apply-ladspa could be defined:
</p>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(define* (ladspa-channel ladspa-data #:optional nbeg ndur nsnd nchn nedpos)
  (let* ((beg (or nbeg 0)) 
	 (snd (or nsnd (selected-sound)))
	 (chn (or nchn (selected-channel)))
	 (dur (or ndur (- (frames snd chn) beg)))
	 (edpos (or nedpos current-edit-position))
	 (reader (make-sample-reader beg snd chn 1 edpos)))
    (<em class=red>apply-ladspa</em> reader ladspa-data dur "apply-ladspa")
    (free-sample-reader reader)))
<!-- --></pre></td></tr></table>
<br>

<span class=bbox><h3><A NAME="sndandx">Driving Snd remotely</a></h3></span>

<p>It is possible to send Snd arbitrary scheme code from any other program;
the program sndctrl.c is a simple example.  Snd has two X window properties:
"SND_VERSION" and "SND_COMMAND"; the former is the Snd version (a date),
and the latter is the communication path for other programs.  Any time
such a program changes the SND_COMMAND property, Snd notices and evaluates
the new value (as a string, as if typed in the Snd lisp listener).  To get
a response from Snd, use the function change-property(consat,name,command) where
consat is the property name Snd should search for, name is the property to change, and command is the string
that replaces the current property value.  For example, CLM's communication
with Snd function sends Snd this string:</p>
<pre>
"(change-property \"CLM_VERSION\" \"CLM_COMMAND\" " str ")"
</pre>
<p>where <i>str</i> is the form to be evaluated within Snd.  It then waits
for a change to the CLM_COMMAND property, returning its value to the
user. The send-snd function itself, similarly, looks for SND_VERSION and
sets SND_COMMAND to <i>str</i>, which Snd subsequently notices.
</p>
<br>

<span class=bbox><h3><A NAME="sndandgl">Snd and OpenGL</a></h3></span>

<p>Snd can be used in conjunction with OpenGL.  If it is compiled with
the switch -DHAVE_GL, and loaded with -lGLU -lGL (normally this can be
handled via the configure switch --with-gl), the top level Snd shell
is setup to handle OpenGL graphics; the GLXContext is (snd-glx-context).
The GL-to-Scheme bindings are in gl.c, and follow the same name and type
conventions of the Motif bindings in xm.c.
Any of the Snd drawing area widgets (or your own) can receive GL graphics
commands.  For example, here is a translation of the SGI/xjournal glxmotif
program:
</p>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(define (draw-it)
  (|glXMakeCurrent (|XtDisplay (cadr (main-widgets))) 
		   (|XtWindow (car (channel-widgets)))
		   (snd-glx-context))
  (|glEnable |GL_DEPTH_TEST)
  (|glDepthFunc |GL_LEQUAL)
  (|glClearDepth 1.0)
  (|glClearColor 0.0 0.0 0.0 0.0)
  (|glLoadIdentity)
  (|gluPerspective 40.0 1.0 10.0 200.0)
  (|glTranslatef 0.0 0.0 -50.0)
  (|glRotatef -58.0 0.0 1.0 0.0)
  (let ((vals (|XtVaGetValues (car (channel-widgets)) (list |XmNwidth 0 |XmNheight 0))))
    (|glViewport 0 0 (list-ref vals 1) (list-ref vals 3)))
  (|glClear (logior |GL_COLOR_BUFFER_BIT |GL_DEPTH_BUFFER_BIT))
  (|glBegin |GL_POLYGON)
  (|glColor3f 0.0 0.0 0.0)   (|glVertex3f -10.0 -10.0 0.0)
  (|glColor3f 0.7 0.7 0.7)   (|glVertex3f 10.0 -10.0 0.0)
  (|glColor3f 1.0 1.0 1.0)   (|glVertex3f -10.0 10.0 0.0)
  (|glEnd)
  (|glBegin |GL_POLYGON)
  (|glColor3f 1.0 1.0 0.0)   (|glVertex3f 0.0 -10.0 -10.0)
  (|glColor3f 0.0 1.0 0.7)   (|glVertex3f 0.0 -10.0 10.0)
  (|glColor3f 0.0 0.0 1.0)   (|glVertex3f 0.0 5.0 -10.0)
  (|glEnd)
  (|glBegin |GL_POLYGON)
  (|glColor3f 1.0 1.0 0.0)   (|glVertex3f -10.0 6.0 4.0)
  (|glColor3f 1.0 0.0 1.0)   (|glVertex3f -10.0 3.0 4.0)
  (|glColor3f 0.0 0.0 1.0)   (|glVertex3f 4.0 -9.0 -10.0)
  (|glColor3f 1.0 0.0 1.0)   (|glVertex3f 4.0 -6.0 -10.0)
  (|glEnd)
  (|glXSwapBuffers (|XtDisplay (cadr (main-widgets))) 
		   (|XtWindow (car (channel-widgets))))
  (|glFlush))
<!-- --></pre></td></tr></table>
<br>
<p>For more examples, see snd-gl.scm.
</p>
<br>
<table border>
<tr><td colspan=2><center>GL spectrogram</center></td></tr>
<tr><td colspan=2>
<img src="gl1.png" alt="now.snd GL spectrogram">
</td></tr></table>
<br>

<span class=bbox><h3><A NAME="sndandgdb">Snd and gdb</a></h3></span>

<p>Here are some gdb functions (for your ~/.gbdinit file) that might
come in handy:
</p>
<pre>
define gp
set gdb_print($arg0)
print gdb_output
end
document gp
Executes (object-&gt;string arg): gp memo_sound =&gt; #f
end

define ge
call gdb_read($arg0)
call gdb_eval(gdb_result)
set gdb_print(gdb_result)
print gdb_output
end
document ge
Executes (print (eval (read arg))): ge "(+ 1 2)" =&gt; 3
end

define gh
call g_help(scm_str2symbol($arg0), 20)
set gdb_print($1)
print gdb_output
end
document gh
Prints help string for arg: gh "enved-target"
end
</pre>
<p>SCM values are displayed as integers in gdb, so, for example, say
Snd halts and you notice it's loading some unknown file:
</p>
<pre>
#32 0x081ae8f4 in scm_primitive_load (filename=1112137128) at load.c:129
</pre>
<p>You can get the file name with gp:
</p>
<pre>
(gdb) gp 1112137128
$1 = 0
$2 = 0x40853fac "\"/home/bil/test/share/guile/1.5.0/ice-9/session.scm\""
</pre>
<p>
If you have a pointer to a CLM generator, you can use:
</p>
<pre>
p mus_describe(arg)  --  show the user-view of arg
p mus_inspect(arg)  --  show every internal field of arg
</pre>
<p>The ge function can show current Snd state:</p>
<pre>
(gdb) ge "(eps-file)"
$5 = 0
$6 = 0
$7 = 0
$8 = 0x8296cf0 "\"snd.eps\""
</pre>

<br>
<span class=bbox><h3><A NAME="sndclmcmn">Snd, CLM, CMN</a></h3></span>

<p>Each of these programs sets up two X atoms for interprogram communication,
*_VERSION which is guaranteed to have some value, and *_COMMAND which is
evaluated as a string (i.e. (eval (read-from-string ...))) whenever
it changes.  In Snd, this happens via XEvents, but in the other two
you have to poll for the change.  In Snd, change-property can be used
to talk to the others; in CLM clm-send-snd and clm-receive-snd, in
CMN cmn-send-snd and cmn-receive-snd.  
</p>
<p>[this section under development...]
</p>
<br>

<center>
<span class=htmlbox>related documentation</span><span class=htmlbox><a href="snd.html">snd.html</a><spacer type=horizontal size=25><a href="extsnd.html">extsnd.html</a><spacer type=horizontal size=25><a href="clm.html">clm.html</a><spacer type=horizontal size=25><a href="sndlib.html">sndlib.html</a><spacer type=horizontal size=25><a href="sndscm.html">sndscm.html</a><spacer type=horizontal size=25><a href="index.html">index.html</a></span>
</center>
</body></html>
