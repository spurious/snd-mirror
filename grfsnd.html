<html>
<head>
<title>Snd Customization and Extension</title>
<style type="text/css">
<!-- 
	EM.red {color:red; font-style:normal}
        EM.typing {color:maroon; font-style: normal}
        EM.listener {color:darkblue; font-style: normal}
        EM.tab {font-style: normal; font-size: small; font-family: fixed}
	EM.emdef {font-weight: bold; font-style: normal}
	H1 {text-align: center}
	UL {list-style-type: none}

	A {text-decoration:none}
	A:hover {text-decoration:underline}
	A.quiet {color:black; text-decoration:none}
	A.quiet:hover {text-decoration:underline}
	A.def {font-weight: bold; font-style: normal; text-decoration:none; text-color:black}
-->
</style>
</head>
<body bgcolor=white>

<!-- I'm using A NAME (i.e caps) where the entity should be ignored by the indexer (index.cl) -->

<A NAME="grfsndcontents"></a>
<table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h1>Snd Customization and Extension Part 2</h1></td></tr></table>
<br>

<center>
<table border=1><tr><td>
<table bgcolor="aliceblue" border=0 cellspacing=8><tr><td><small>related documentation:</small></td><td><small><a href="snd.html">snd.html</a></small></td><td><small><a href="extsnd.html">extsnd.html</a></small></td><td><small><a href="clm.html">clm.html</a></small></td><td><small><a href="sndlib.html">sndlib.html</a></small></td><td><small><a href="sndscm.html">sndscm.html</a></small></td><td><small><a href="libxm.html">libxm.html</a></small></td><td><small><a href="index.html">index.html</a></small></td></tr></table>
</td></tr></table>
</center>

<table border=0><tr><td>
<ul>
<li><a href="#startup">Snd Startup</a>
  <ul>
  <li><a href="#sndswitches">Snd invocation flags</a>
  <li><a href="#sndinitfile">The initialization file</a>
  <li><a href="#sndresources">Snd resources</a>
  </ul>
<li><a href="#snddynamic">Runtime modules and external programs</a>
  <ul>
  <li><a href="#emacssnd">Snd as an Emacs subjob</a>
  <li><a href="#dynamic">Dynamically loaded modules</a>
  <li><a href="#programs">External Programs</a>
  <li><a href="#sndaswidget">Snd as a Widget</a>
  <li><a href="#sndwithclm">Snd and the CLM module</a>
    <ul>
    <li><a href="#clmfuncs">CLM functions</a>
    <li><a href="#sndinstruments">Instruments</a>
    </ul>
  <li><a href="#sndwithcm">Snd and Common Music</a>
  <li><a href="#sndwithmotif">Snd and Motif</a>
  <li><a href="#sndwithgtk">Snd and Gtk</a>
  <li><a href="#sndwithnogui">Snd with no GUI and as script engine</a>
  <li><a href="#sndandruby">Snd with Ruby</a>
  <li><a href="#sndandladspa">Snd and LADSPA plugins</a>
  <li><a href="#sndandx">Driving Snd remotely</a>
  <li><a href="#sndandgl">Snd and OpenGL</a>
  <li><a href="#sndandgdb">Snd and gdb</a>
  </ul>
</ul>
</td><td>
<img src="note.png" alt="notebook" hspace=40>
</td></tr></table>
<br>

<table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2><A NAME="startup">Snd Startup</a></h2></td></tr></table>
<br>
<!-- INDEX sndswitches:Invocation flags -->
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="sndswitches">Snd invocation flags</a></h3></td></tr></table>

<p>Snd recognizes the following switches in its command line (leaving aside all
the usual Xt/X-related flags like -xrm).</p>

<table cellspacing=0 cellpadding=0>
<tr><td width=200><code>-h -horizontal</code></td><td>layout sounds as horizontal panes</td></tr>
<tr><td><code>-v -vertical</code></td>            <td>layout sounds vertically (the default)</td></tr>
<tr><td><code>-notebook</code></td>               <td>layout sounds in a notebook widget (Motif 2.0 or later)</td></tr>
<tr><td><code>-separate</code></td>               <td>layout sounds each in a separate window (lisp listener in main window)</td></tr>
<tr><td><code>--help</code></td>                  <td>print some help, version info, and exit</td></tr>
<tr><td><code>--version</code></td>               <td>print version info</td></tr>
<tr><td><code>-noglob</code></td>                 <td>don't read /etc/snd.conf</td></tr>
<tr><td><code>-noinit</code></td>                 <td>don't read ~/.snd</td></tr>
<tr><td><code>-nostdin</code></td>                <td>don't watch for possible input from stdin</td></tr>
<tr><td><code>-p -preload &lt;dir&gt;</code></td> <td>preload sound files in directory &lt;dir&gt; (snd -p .)</td></tr>
<tr><td><code>-l -load &lt;file&gt;</code></td>   <td>load Scheme or Ruby code in &lt;file&gt; (snd -l test.scm)</td></tr>
<tr><td><code>-e -eval expr</code></td>           <td>evaluate expr</td></tr>
<tr><td><code>-b -batch &lt;file&gt;</code></td>  <td>load Scheme or Ruby code in &lt;file&gt; as a batch (no GUI) job</td></tr>
<tr><td><code>-I &lt;dir&gt;</code></td>          <td>add &lt;dir&gt; to the load search list</td></tr>
</table>

<p>
The -e switch evaluates its argument as though it had been passed to M-X.  The
initialization file, if any, is loaded first, then the arguments are processed
in order:</p>
<pre>
snd -e "(set! (<a class=quiet href="extsnd.html#datacolor">data-color</a>) (<a class=quiet href="extsnd.html#makecolor">make-color</a> 1 0 0))" oboe.snd
</pre>
<p>reads ~/.snd, if any, then sets the (unselected) data color to red, then opens oboe.snd.</p>
<pre>
./snd -eval '(begin (display (+ 1 2)) (<a class=quiet href="extsnd.html#exit">exit</a>))'
</pre>
<p>prints "3" and exits.  The "-title" argument works in both versions of Snd.
The following adds "WAV" to the sound file extension table before preloading the directory:
</p>
<pre>
snd -e '(<a class=quiet href="extsnd.html#addsoundfileextension">add-sound-file-extension</a> "WAV")' -p /home/bil/sounds
</pre>
<br>

<img src="bgd.png" alt="colors" vspace=10 hspace=10>
<br>
<br>

<!-- INDEX sndinitfile:Initialization file -->
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="sndinitfile">The initialization file</a></h3></td></tr></table>
<p>
When Snd starts, it looks for an initialization file, normally named "~/.snd" (its name can be set
via the X resource mechanism, or through the environment variable SND_INIT_FILE).  This optional file is
supposed to be just like Emacs' .emacs file, containing any customizations or
extensions that you want loaded whenever Snd starts.  Say we
want the Snd window to start out 800x500, want to predefine an envelope named
"env1", and want the file selection box to
show just sound files.  We make ~/.snd and put in it:</p>
<pre>
(set! (<a class=quiet href="extsnd.html#windowwidth">window-width</a>) 800)
(set! (<a class=quiet href="extsnd.html#windowheight">window-height</a>) 500)
(<a class=quiet href="extsnd.html#ldefvar">defvar</a> env1 '(0 0 1 1 2 0))
(set! (<a class=quiet href="extsnd.html#justsounds">just-sounds</a>) #t)
</pre>
<p>
In more
complex situations, you may want an initialization file particular to a given
machine, and global across users; the 
name of this optional global initialization file is "/etc/snd.conf". It
is read before your local file; both can, of course, be
absent.  To override reading the global init file when Snd is invoked, include the switch -noglob.
To override the local init file, use -noinit.  
Here's a more elaborate initialization file:
</p>

<table border=1 cellpadding=5><tr><td bgcolor="GhostWhite"><pre>
(use-modules (ice-9 debug) (ice-9 format) (ice-9 optargs))
(debug-set! stack 0)                ;turn off Guile's stack-size check
(set! snd-remember-paths #t)        ;remember paths making "load" smarter

(set! (<a class=quiet href="extsnd.html#windowwidth">window-width</a>) 800)           ;these set the initial window size
(set! (<a class=quiet href="extsnd.html#windowheight">window-height</a>) 500)

(if (provided? 'snd-motif)          ;Motif and Gtk use different font naming conventions
    (begin
      (set! (<a class=quiet href="extsnd.html#listenerfont">listener-font</a>) "9x15")
      (set! (<a class=quiet href="extsnd.html#axislabelfont">axis-label-font</a>) "-*-times-medium-r-normal-*-18-*-*-*-*-*-*-*")
      (set! (<a class=quiet href="extsnd.html#axisnumbersfont">axis-numbers-font</a>) "9x15"))
    (begin
      (set! (<a class=quiet href="extsnd.html#listenerfont">listener-font</a>) "Monospace 10")
      (set! (<a class=quiet href="extsnd.html#axislabelfont">axis-label-font</a>) "Serif 14")
      (set! (<a class=quiet href="extsnd.html#axisnumbersfont">axis-numbers-font</a>) "Monospace 10")))

(set! (<a class=quiet href="extsnd.html#listenerprompt">listener-prompt</a>) ":")        ;change listener prompt from the default "&gt;" to ":"
(set! (<a class=quiet href="extsnd.html#showlistener">show-listener</a>) #t)           ;include the listener window initially
(set! (<a class=quiet href="extsnd.html#showindices">show-indices</a>) #t)            ;include sound index values with the sound name

(define beige (<a class=quiet href="extsnd.html#makecolor">make-color</a> 0.96 0.96 0.86))
(define blue (<a class=quiet href="extsnd.html#makecolor">make-color</a> 0 0 1))
(set! (<a class=quiet href="extsnd.html#selectedgraphcolor">selected-graph-color</a>) beige) ;selected graph background is beige
(set! (<a class=quiet href="extsnd.html#selecteddatacolor">selected-data-color</a>) blue)   ;selected graph data is blue

(add-hook! <a class=quiet href="extsnd.html#mouseentergraphhook">mouse-enter-graph-hook</a>  ;automatically focus on (activate) the widget under the mouse
  (lambda (snd chn) 
    (<a class=quiet href="extsnd.html#focuswidget">focus-widget</a> (car (<a class=quiet href="extsnd.html#channelwidgets">channel-widgets</a> snd chn)))))
(add-hook! <a class=quiet href="extsnd.html#mouseenterlistenerhook">mouse-enter-listener-hook</a>
  (lambda (widget) 
    (<a class=quiet href="extsnd.html#focuswidget">focus-widget</a> widget)))
(add-hook! <a class=quiet href="extsnd.html#mouseentertexthook">mouse-enter-text-hook</a> 
  (lambda (w)
    (<a class=quiet href="extsnd.html#focuswidget">focus-widget</a> w)))

(set! (<a class=quiet href="extsnd.html#savedir">save-dir</a>) "/zap/snd")        ;save-state files are placed in /zap/snd
(set! (<a class=quiet href="extsnd.html#tempdir">temp-dir</a>) "/zap/tmp")        ;temp files are placed in /zap/tmp
(load "peak-env.scm")               ;large file peak env data is saved for faster 
				    ;  subsequent reads -- this makes the first
				    ;  view of a large file much snappier --
				    ;  its default directory for the data is ~/peaks.

(load "draw.scm")                   ;load some useful extensions
(load "hooks.scm")
(load "extensions.scm")

(make-current-window-display)       ;display an overview of the current window in the upper right
(if (provided? 'snd-motif)          
    (load "popup.scm")              ;context-sensitive popup menus
    (if (provided? 'snd-gtk)
        (load "/home/bil/cl/gtk-popup.scm")))

(add-hook! <a class=quiet href="extsnd.html#afteropenhook">after-open-hook</a>          ;if sound has many chans, use just one pane for all
  (lambda (snd)
    (if (&gt; (<a class=quiet href="extsnd.html#chans">chans</a> snd) 4)
        (set! (<a class=quiet href="extsnd.html#channelstyle">channel-style</a> snd) <a class=quiet href="extsnd.html#channelstyle">channels-combined</a>))))

(set! (<a class=quiet href="extsnd.html#optimization">optimization</a>) 6)              ;turn on full optimization (live dangerously...)
(set! (<a class=quiet href="extsnd.html#selectioncreatesregion">selection-creates-region</a>) #f) ;turn off automatic region creation
</pre></td></tr></table>

<p>
If you loaded Snd with GSL, and have set the GSL_IEEE_MODE environment variable,
it will override Snd's default arithmetic mode settings.  GSL recommends the setting:
</p>
<pre>
GSL_IEEE_MODE=double-precision,mask-underflow,mask-denormalized
</pre>
<p>For more complex initialization files, see snd_conffile.scm and edit123.scm.
</p>
<br>
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="sndresources">Snd resources</a></h3></td></tr></table>

<p>In the Motif version, there are a few X-style resources that Snd looks for (see Snd.ad); each has
a built-in default value, so you can ignore any that are already acceptable:</p>

<table cellspacing=0 cellpadding=0>
<tr><td width=200>initFile</td>               <td>"~/.snd"</td></tr>
<tr><td>autoResize</td>                       <td>1</td></tr>
<tr><td>horizontalPanes</td>                  <td>0</td></tr>
<tr><td><br></td><td><br></td></tr>
<tr><td>peaksFont</td>                        <td>-*-times-medium-r-*-*-14-*-*-*-*-*-*-*</td></tr>
<tr><td>boldpeaksFont</td>                    <td>-*-times-bold-r-*-*-14-*-*-*-*-*-*-*</td></tr>
<tr><td>axisLabelFont</td>                    <td>-*-times-medium-r-normal-*-20-*-*-*-*-*-*-*</td></tr>
<tr><td>axisNumbersFont</td>                  <td>-*-courier-medium-r-normal-*-14-*-*-*-*-*-*-*</td></tr>
<tr><td>listenerFont</td>                     <td>default font (fixed 7x13, I think)</td></tr>
<tr><td><br></td><td><br></td></tr>
<tr><td>useSchemes</td>                       <td>none</td></tr>
<tr><td>highlightcolor</td>                   <td>ivory1</td></tr>
<tr><td>basiccolor</td>                       <td>ivory2</td></tr>
<tr><td>positioncolor</td>                    <td>ivory3</td></tr>
<tr><td>zoomcolor</td>                        <td>ivory4</td></tr>
<tr><td>cursorcolor</td>                      <td>red</td></tr>
<tr><td>selectioncolor</td>                   <td>lightsteelblue1</td></tr>
<tr><td>mixcolor</td>                         <td>lightgreen</td></tr>
<tr><td>mixfocuscolor</td>                    <td>yellow2</td></tr>
<tr><td>listenercolor</td>                    <td>aliceblue</td></tr>
<tr><td>envedwaveformcolor</td>               <td>blue</td></tr>
<tr><td>filterwaveformcolor</td>              <td>blue</td></tr>
<tr><td>mixwaveformcolor</td>                 <td>darkgray</td></tr>
<tr><td>graphcolor</td>                       <td>white</td></tr>
<tr><td>selectedgraphcolor</td>               <td>white</td></tr>
<tr><td>datacolor</td>                        <td>black</td></tr>
<tr><td>selecteddatacolor</td>                <td>black</td></tr>
<tr><td>markcolor</td>                        <td>red</td></tr>
<tr><td>pushedbuttoncolor</td>                <td>lightsteelblue1</td></tr>
<tr><td>sashcolor</td>                        <td>lightgreen</td></tr>
<tr><td>helpbuttoncolor</td>                  <td>lightsteelblue2</td></tr>
<tr><td>quitbuttoncolor</td>                  <td>indianred</td></tr>
<tr><td>resetbuttoncolor</td>                 <td>goldenrod1</td></tr>
<tr><td>doitbuttoncolor</td>                  <td>palegreen2</td></tr>
<tr><td>doitagainbuttoncolor</td>             <td>darkolivegreen1</td></tr>
</table>

<p>You can experiment with other choices by
using the -xrm switch:</p>

<pre>
  snd -xrm '*Highlightcolor: Red' oboe.snd
  snd -xrm '*AxisNumbersFont: 6x10' oboe.snd
  snd -xrm '*useSchemes: all' -xrm '*scheme: Pacific'
  snd -xrm '*fontList: 9x15' oboe.snd
  snd -xrm '*listenerFont: 6x10' oboe.snd
  snd -xrm '*mixwaveformcolor: red' oboe.snd -notebook
  snd oboe.snd pistol.snd -xrm '*selectedgraphcolor: black' -xrm '*selecteddatacolor: white'
  snd oboe.snd -title hiho -display hummer.hiho:0.0 -xrm '*chn-graph*backgroundPixmap: text.xpm'
  snd -xrm '*fontList: -*-times-medium-r-*-*-14-*-*-*-*-*-*-*'
  snd -xrm '*fontList: -*-symbol-*-*-*-*-18-*-*-*-*-*-*-*'
</pre>
<p>Perhaps this is most useful when your window manager assumes white text for labels (menus);
since Snd defaults to an off-white background, this makes everything unreadable. You can get
the black text back with:
</p>
<pre>
./snd -xrm '*foreground: Black'
</pre>
<p>or put the equivalent line in your .Xdefaults file.  The listener text color can be set
via <code>(set! (<a href="extsnd.html#listenertextcolor">listener-text-color</a>) (<a href="extsnd.html#makecolor">make-color</a> 0 0 0))</code> in ~/.snd.
</p>

<p>The colors are defined in <a href="sndscm.html#rgbdoc">rgb.scm</a>. 
"useSchemes" refers to SGI color schemes.
It's unfortunate that
there is the language Scheme implemented by Guile, and the notion of an SGI color scheme -- there is
no connection between the two. Other systems (Linux, Solaris) use the term "theme" instead.
You can get Snd to honor your current window manager theme by setting useSchemes to all.  
The last example above sets the window title to "hiho", rather than
"snd", displays the window on the machine hummer.hiho (presumably accessible over the net),
and tiles the graph backgrounds with the contents of text.xpm.  To get the -geometry argument
to work, set the autoResize resource to 0:</p>
<pre>
  snd oboe.snd -geometry 800x200 -xrm '*autoResize: 0'
</pre>

<p>These resources can be set in Snd.ad or in your .Xdefaults file:</p>
<pre>
snd*axisLabelFont:      -*-times-medium-r-normal-*-18-*-*-*-*-*-*-*
snd*axisNumbersFont:    9x15
snd*fontList:           -*-times-bold-r-*-*-14-*-*-*-*-*-*-*
</pre>

<p>To find what fonts are available, and what they look like, I use xfontsel.
I think other toolkits use helvetica where Motif defaults to a small fixed font --
it looks like 7x13 on my machine.
</p>

<p>
The <A class=def NAME="xautoresize">autoResize</a> resource determines how Snd acts when files
are added to or removed from its overall display.  The default (1)
causes Snd to expand or contract the main window's size to accommodate
the sounds; many people find this distracting.  If <i>autoResize</i> is 0, the outer window size remains the
same, and the sounds try to fit as best they can (to some extent the window manager controls this stuff).  See also
the variable <a href="extsnd.html#autoresize">auto-resize</a>.
The <A class=def NAME="horizontalpanes">horizontalPanes</a> resource
is equivalent to the -h flag; if 1, sounds are layed out
horizontally rather than vertically;  if 2, you get a notebook
widget holding the sounds.
</p>
<p>In Gtk, the various default colors and fonts are set via the "gtkrc"
file.  If you are using some global "theme", you probably have ~/.gtkrc-2.0.
Snd looks for this file first.  If it isn't found, Snd looks on the
current directory for Snd.gtkrc.  If that isn't found, it looks for
~/Snd.gtkrc. If that isn't found, it uses a built-in default equivalent
to the Snd.gtkrc file in the Snd tarball.
If you want to change the overall appearance of Snd, you can edit any of these rc files.
Currently, the simplest way to change the menu label fonts
is to change the "default" or "default_menu" styles in Snd.gtkrc:
</p>
<pre>
style "default"
{
  font_name = "Sans Serif 11"
  ....
}
</pre>
<p>Frank Barknecht made a more elaborate example using the Xfce-b5 theme:</p>
<img src="snd-gtkrc.png" alt="Snd with Xfce-b5 theme">

<hr>
<p><A NAME="aboutcolors"></a>The Snd-specific X (Motif) color resources are:</p>

<table cellspacing=0 cellpadding=0>
<tr><td width=200>basiccolor</td><td width=350>default background color everywhere</td><td><code><a href="extsnd.html#basiccolor">basic-color</a></code></td></tr>
<tr><td>cursorcolor</td>         <td>color of the cursor</td>                   <td><code><a href="extsnd.html#cursorcolor">cursor-color</a></code></td></tr>
<tr><td>datacolor</td>           <td>unselected data color</td>                 <td><code><a href="extsnd.html#datacolor">data-color</a></code></td></tr>
<tr><td>doitbuttoncolor</td>     <td>color of Apply or Ok buttons</td>          <td><code><a href="extsnd.html#doitbuttoncolor">doit-button-color</a></code></td></tr>
<tr><td>doitagainbuttoncolor</td><td>color of Undo&amp;Apply buttons</td>       <td><code><a href="extsnd.html#doitagainbuttoncolor">doit-again-button-color</a></code></td></tr>
<tr><td>envedwaveformcolor</td>  <td>color of envelope editor waveform</td>     <td><code><a href="extsnd.html#envedwaveformcolor">enved-waveform-color</a></code></td></tr>
<tr><td>filterwaveformcolor</td> <td>color of control panel filter waveform</td><td><code><a href="extsnd.html#filterwaveformcolor">filter-control-waveform-color</a></code></td></tr>
<tr><td>graphcolor</td>          <td>unselected channels' graph background</td> <td><code><a href="extsnd.html#graphcolor">graph-color</a></code></td></tr>
<tr><td>helpbuttoncolor</td>     <td>color of Help buttons</td>                 <td><code><a href="extsnd.html#helpbuttoncolor">help-button-color</a></code></td></tr>
<tr><td>highlightcolor</td>      <td>highlighting here and there</td>           <td><code><a href="extsnd.html#highlightcolor">highlight-color</a></code></td></tr>
<tr><td>listenercolor</td>       <td>background color of the listener</td>      <td><code><a href="extsnd.html#listenercolor">listener-color</a></code></td></tr>
<tr><td>listenertextcolor</td>   <td>text color in the listener</td>            <td><code><a href="extsnd.html#listenertextcolor">listener-text-color</a></code></td></tr>
<tr><td>markcolor</td>           <td>color of the mark indicator</td>           <td><code><a href="extsnd.html#markcolor">mark-color</a></code></td></tr>
<tr><td>mixcolor</td>            <td>used for mix waveforms</td>                <td><code><a href="extsnd.html#mixcolor">mix-color</a></code></td></tr>
<tr><td>positioncolor</td>       <td>color of position sliders</td>             <td><code><a href="extsnd.html#positioncolor">position-color</a></code></td></tr>
<tr><td>pushedbuttoncolor</td>   <td>color of pushed button</td>                <td><code><a href="extsnd.html#pushedbuttoncolor">pushed-button-color</a></code></td></tr>
<tr><td>quitbuttoncolor</td>     <td>color of Cancel or Dismiss buttons</td>    <td><code><a href="extsnd.html#quitbuttoncolor">quit-button-color</a></code></td></tr>
<tr><td>resetbuttoncolor</td>    <td>color of Reset buttons</td>                <td><code><a href="extsnd.html#resetbuttoncolor">reset-button-color</a></code></td></tr>
<tr><td>sashcolor</td>           <td>color of paned window sash handles</td>    <td><code><a href="extsnd.html#sashcolor">sash-color</a></code></td></tr>
<tr><td>selecteddatacolor</td>   <td>color of the data in selected channel</td> <td><code><a href="extsnd.html#selecteddatacolor">selected-data-color</a></code></td></tr>
<tr><td>selectedgraphcolor</td>  <td>background of selected channel's graph</td><td><code><a href="extsnd.html#selectedgraphcolor">selected-graph-color</a></code></td></tr>
<tr><td>selectioncolor</td>      <td>color of an active selection</td>          <td><code><a href="extsnd.html#selectioncolor">selection-color</a></code></td></tr>
<tr><td>textfocuscolor</td>      <td>color of text field with focus</td>        <td><code><a href="extsnd.html#textfocuscolor">text-focus-color</a></code></td></tr>
<tr><td>zoomcolor</td>           <td>color of zoom sliders</td>                 <td><code><a href="extsnd.html#zoomcolor">zoom-color</a></code></td></tr>
</table>
<p>
Each of these colors can be set in Guile using the second name given above ("basic-color").
Colors are defined by <a href="extsnd.html#makecolor">make-color</a> with the three red/green/blue values,
each a float between 0.0 and 1.0. <code>(set! (<a class=quiet href="extsnd.html#basiccolor">basic-color</a>) (<a class=quiet href="extsnd.html#makecolor">make-color</a> 1.0 0.0 0.0))</code> sets
the overall background color of Snd to red.  <a href="sndscm.html#rgbdoc">rgb.scm</a> defines all the standard X11 color names
(you probably don't want to load the whole thing; just use the names as needed). 
</p>

<p>There are several other resources that set widget sizes: zoomSliderWidth,
positionSliderWidth, toggleSize, sashSize, sashIndent, channelSashSize, and channelSashIndent.
And several more color resources: whitecolor (list background),
blackcolor (recorder VU meter text), redcolor (buttons, VU clipping, etc), 
greencolor (a few buttons),
yellowcolor (a few envelope editor buttons), lightbluecolor (the recorder), and lighterbluecolor (the fft option panel).
</p>

<br>

<table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2><A NAME="snddynamic">Runtime modules and external programs</a></h2></td></tr></table>

<p>It is possible to load your own C code into Snd at run-time or
use any external program from within Snd as an editing function.
And, perhaps most useful, you can run Snd as an Emacs subjob.
</p>
<br>

<!-- INDEX emacssnd:Emacs and Snd -->
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="emacssnd">Snd as an Emacs subjob</a></h3></td></tr></table>

<p>Snd watches stdin; any input received
is evaluated as if typed in Snd's lisp listener; any subsequent output
is sent to stdout; presumably any process could communicate with
Snd in this manner.  But the intention here is to make it possible to run Snd as a subjob of Emacs.
The simplest way to enable that is to use inf-snd.el by Michael
Scholz.  It starts with a long and detailed commentary.
A simpler alternative is Fernando Lopez-Lezcano's DotEmacs,
which also has comments on its use.
</p>
<br>
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="dynamic">Dynamically loaded modules</a></h3></td></tr></table>

<p>You can import shared object files into Snd at any time.
You need to build Snd
with -lguile (that is, load it with the guile shared library, not libguile.a);
if the loader can't find libguile.so.2 (or whatever), add its directory to
your LD_LIBRARY_PATH; for example, if
it's on /usr/local/lib, <code>setenv LD_LIBRARY_PATH /usr/local/lib</code>.  
Next add Guile wrappers to your C code:</p>
<pre>
  /* cscm.c */
  #include &lt;math.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;
  #include &lt;libguile.h&gt;

  int hiho (int a) 
  { /* this is the function we want to call from Snd */
    return(1 + a);
  }

  SCM hiho_wrapper(SCM a) 
  { /* this tells Guile how to interpret the arguments and return value of hiho */
    return(scm_long2num(hiho(scm_num2int(a, 0, "hiho"))));
  }

  void init_hiho() 
  { /* this declares hiho within Guile calling the wrapper which calls the C function hiho */
    scm_c_define_gsubr("hiho", 1, 0, 0, hiho_wrapper);
  }
</pre>
<p>
Next compile
your code into a shared object (this is aimed at Linux):
</p>
<pre>
  cc -c cscm.c 
  ld -shared -o cscm.so cscm.o -lguile
</pre>
<p>Now go to Snd's lisp listener and,</p>
<pre>
  (define lib (<em class=red>dynamic-link</em> "/home/bil/cl/cscm.so"))
  (<em class=red>dynamic-call</em> "init_hiho" lib)
  (hiho 3)
</pre>
<p>The function we actually want loaded into Guile here is "hiho".
We define a wrapper for it to handle the translation between
Guile (Scheme) variable types and C ("hiho_wrapper"), and
a procedure to define hiho in Guile ("init_hiho").  Once loaded
("dynamic-link"), we can call the initialization function
("dynamic-call"), and thereafter treat "hiho" as though
it had been defined in Guile/Snd to begin with.  After both the
dynamic-link and dynamic-lib calls, the listener will
print "#&lt;unspecified&gt;" or something equally obscure to indicate
in its own peculiar way that all went well.  M-x (hiho 4) will
print 5 in the minibuffer.
</p>

<p>
As a slightly more useful example, let's import the Bessel J0 function
from GSL (Gnu Scientific Library); in this case, we need to build Snd
with GSL (the easiest way is to include the --with-gsl option to configure).
Then make a file (say "gsl-ex.c"):</p>
<pre>
#include &lt;libguile.h&gt;
#include &lt;gsl/gsl_sf_bessel.h&gt;

static SCM scm_j0(SCM x)
{ /* calls GSL function gsl_sf_bessel_J0_e */
  gsl_sf_result res;
  gsl_sf_bessel_J0_e(scm_num2dbl(x, "j0"), &amp;res);
  return(scm_make_real(res.val));
}

void init_gsl_j0(void)
{ /* links scm_j0 into Snd under the name j0 */
  scm_c_define_gsubr("j0", 1, 0, 0, scm_j0);
}
</pre>
<p>Now the usual compile, load, link into Snd sequence:</p>
<pre>
/home/bil/snd-4/ cc gsl-ex.c -c -Wall
/home/bil/snd-4/ ld -shared gsl-ex.o -o gsl-ex.so -lguile
/home/bil/snd-4/ ./snd

&gt;<em class=typing>(define lib (dynamic-link "/home/bil/snd-4/gsl-ex.so"))</em>
<em class=listener>#&lt;unspecified&gt;</em>
&gt;<em class=typing>(dynamic-call "init_gsl_j0" lib)</em>
<em class=listener>#&lt;unspecified&gt;</em>
&gt;<em class=typing>(</em><em class=red>j0</em><em class=typing> 0.0)</em>
<em class=listener>1.0</em>
&gt;<em class=typing>(</em><em class=red>j0</em><em class=typing> 2.0)</em>
<em class=listener>0.223890779141236</em>
&gt;<em class=typing>(define (bes-fm dur freq amp ratio index)
 ;; bessel-FM from CLM
   (let* ((car-ph 0.0)
	  (mod-ph 0.0)
 	  (car-incr (hz-&gt;radians freq))
	  (mod-incr (* ratio car-incr))
	  (ampenv (make-env :envelope '(0 0 25 1 75 1 100 0) :scaler amp :end dur))
	  (output (make-vct dur)))
     (vct-map! output
       (lambda ()
         (let ((val (* (env ampenv) (</em><em class=red>j0</em><em class=typing> car-ph))))
           (set! car-ph (+ car-ph car-incr (* index (</em><em class=red>j0</em><em class=typing> mod-ph))))
           (set! mod-ph (+ mod-ph mod-incr))
	   val)))
     (vct-&gt;samples 0 dur output)))</em>
<em class=listener>#&lt;unspecified&gt;</em>
&gt;<em class=typing>(bes-fm 22050 440 10.0 1.0 8.0)</em>
</pre>

<p>To call internal Snd functions, you can do something like
the following: declare an SCM variable to hold the procedure
variable, in the init function set the variable to the
value of scm_symbol_value0("function-name"), and in the
rest of the code call it via scm_apply. The following
is a sketch using the Snd internal "srate" function:</p>
<pre>
  #include &lt;libguile.h&gt;
  static SCM g_srate;
  static SCM srate_wrapper(SCM a) {return(scm_call_1(g_srate, a));}
  void init_srate(void) 
  { 
    scm_c_define_gsubr("my-srate", 1, 0, 0, srate_wrapper);
    g_srate = scm_symbol_value0("srate");
  }
</pre>
<p>Alternatively, you can simply use scm_eval_str0:</p>
<pre>
  scm_eval_str0("(<a class=quiet href="extsnd.html#recorderdialog">recorder-dialog</a>)");
  scm_eval_str0("(<a class=quiet href="extsnd.html#opensound">open-sound</a> \"oboe.snd\")");
  srate = scm_num2int(scm_eval_str0("(<a class=quiet href="extsnd.html#srate">srate</a>)"), 0, "");
</pre>

<br>
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="programs">External Programs</a></h3></td></tr></table>

<p>Any external program that knows about sound files can be used to perform editing operations
in Snd.  You get Snd's display, analysis, header and format conversion, and edit-tree support,
and can concentrate on the actual sound effect you're developing.
The original impetus for Snd came from CLM, a large lisp-listener based program
which normally runs without a graphical
user interface, and without any simple way to move around
in what Snd calls the edit history.  Since interprocess
communication proved problematic in this case,
the communication path was simplified to
consist of little more than shared files, with CLM treated
as a batch program.
</p>

<p>
Say we have a sound processing CLM instrument we like; it takes
two sound file names as its arguments, reading the first and writing the second.
In Snd we write the current edited state to a temporary file (<a href="extsnd.html#savesoundas">save-sound-as</a>),
start CLM, call the instrument 
passing it the input filename (just written by Snd), then pass CLM's output back
to Snd.  Snd replaces (via set-samples) the current data with the data our instrument wrote, as if it had incorporated that
instrument as an editing operation from the beginning.
We then delete the Snd output (the input to CLM).
</p>

<br>
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="sndaswidget">Snd as a Widget</a></h3></td></tr></table>

<p>To include the entire Snd editor as a widget in some other program,
first compile it with -DSND_AS_WIDGET. Then load it into your program,
using the procedure <b>snd_as_widget</b> to fire it up.  See
saw.c included with Snd.
</p>

<pre>
  void snd_as_widget(int argc, char **argv, XtAppContext app, Widget parent, Arg *caller_args, int caller_argn)
</pre>

<p>starts up the Snd editor in the widget <i>parent</i>, passing the outer Snd
form widget the arguments <i>caller_args</i> and <i>caller_argn</i>.  The
enclosing application context is <i>app</i>.  <i>parent</i> needs to
be realized at the time of the call, since Snd uses it to set up graphics
contexts and so on.  <i>argc</i> and <i>argv</i> can be passed to
simulate a shell invocation of Snd.  Remember that in this case, the
first string argument is expected to be the application name, and is
ignored by Snd.
In Gtk, the arguments are different, but the basic idea is the same.
</p>

<br>
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="sndwithclm">Snd and the CLM module</a></h3></td></tr></table>

<p>The files clm.c, clm.h, and clm2xen.c implement CLM (a Common Lisp Music V implementation
described in clm.html, available in clm-2.tar.gz at ccrma-ftp) as a Guile-loadable module.
They are loaded into Snd when it is built.
You can see what a generator does, or a group of generators, by running them in the
lisp listener, and using the graph and spectrum functions.  Say we have
these declarations in ~/.snd:
</p>

<table border=1 cellpadding=5><tr><td bgcolor="GhostWhite"><pre>
(define data-size 1024)
(define data (<a class=quiet href="extsnd.html#makevct">make-vct</a> data-size))

(define run 
  (lambda (fun)
    (do ((i 0 (1+ i))) 
        ((= i data-size))
      (<a class=quiet href="extsnd.html#vctset">vct-set!</a> data i (fun)))
    (<a class=quiet href="extsnd.html#graph">graph</a> data)))

(define runf
  (lambda (fun)
    (do ((i 0 (1+ i))) 
        ((= i data-size))
      (<a class=quiet href="extsnd.html#vctset">vct-set!</a> data i (fun)))
    (<a class=quiet href="extsnd.html#graph">graph</a> (<a class=quiet href="extsnd.html#sndspectrum">snd-spectrum</a> data blackman2-window data-size #t))))
</pre></td></tr></table>

<p>Now we can open the listener, and type:</p>
<pre>
(define hi (<a class=quiet href="clm.html#make-oscil">make-oscil</a>))
(<a class=quiet href="extsnd.html#run">run</a> (lambda () (<a class=quiet href="clm.html#oscil">oscil</a> hi)))
(define ho (<a class=quiet href="clm.html#make-oscil">make-oscil</a>))
(runf (lambda () (<a class=quiet href="clm.html#oscil">oscil</a> hi (* .5 (<a class=quiet href="clm.html#oscil">oscil</a> ho)))))
</pre>
<p>Obviously, any CLM instrument or function can be used in this way 
to edit sounds.  Say we want an echo effect:</p>

<table border=1 cellpadding=5><tr><td bgcolor="GhostWhite"><pre>
(define echo 
  (lambda (scaler secs)
    (let ((del (<a class=quiet href="clm.html#make-delay">make-delay</a> (round (* secs (<a class=quiet href="extsnd.html#srate">srate</a>))))))
      (lambda (inval)
        (+ inval (<a class=quiet href="clm.html#delay">delay</a> del (* scaler (+ (<a class=quiet href="clm.html#tap">tap</a> del) inval))))))))
</pre></td></tr></table>

<p>
Here <i>scaler</i> sets
how loud subsequent echos are, and <i>secs</i> sets how far apart they
are in seconds.  <i>echo</i> uses the <i>secs</i> argument to create
a delay line (<i>make-delay</i>) using the current sound's
sampling rate to turn the <i>secs</i> parameter into samples.
<i>echo</i> then returns a closure, that is, a function with
associated variables (in this case <i>del</i> and <i>scaler</i>);
the returned function (the second <i>lambda</i>) takes
one argument (<i>inval</i>) and returns the result of passing
that value to the delay with scaling.  The upshot of all this is that
we can use:</p>
<pre>
(<a class=quiet href="extsnd.html#mapchan">map-chan</a> (echo .5 .75) 0 44100)
</pre>
<p>to take the current active channel and 
return 44100 samples of echos, each echo half the amplitude
of the previous, and spaced by .75 seconds.  <i>map-chan</i>'s
first argument is a function of one argument, the current sample;
when we pass it <i>(echo ...)</i>, it evaluates the echo call,
which returns the function that actually runs the delay line,
producing the echo.  
The CLM (common lisp) version might be something like:</p>

<table border=1 cellpadding=5><tr><td bgcolor="GhostWhite"><pre>
(<a class=quiet href="clm.html#definstrument">definstrument</a> echo (beg dur scaler secs file)
  (let ((del (<a class=quiet href="clm.html#make-delay">make-delay</a> (round (* secs *srate*))))
	(inf (<a class=quiet href="clm.html#open-input">open-input</a> file))
	(j 0))
    (run
     (loop for i from beg below (+ beg dur) do
       (let ((inval (<a class=quiet href="clm.html#ina">ina</a> j inf)))
	 (<a class=quiet href="clm.html#outa">outa</a> i (+ inval (<a class=quiet href="clm.html#delay">delay</a> del (* scaler (+ (<a class=quiet href="clm.html#tap">tap</a> del) inval)))))
	 (incf j))))
    (<a class=quiet href="clm.html#close-input">close-input</a> inf)))

;;; (<a class=quiet href="clm.html#with-sound">with-sound</a> () (echo 0 60000 .5 1.0 "pistol.snd"))
</pre></td></tr></table>

<br>

<!-- INDEX clmfuncs:CLM generators -->
<table width="100%" border=1><tr><td bgcolor="lightgreen" valign="middle"><h4><A NAME="clmfuncs">CLM functions</a></h4></td></tr></table>

<p>See <a href="clm.html">clm.html</a> for full details. Optional args are in italics.</p>
<br>

<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href="clm.html#all-pass">all-pass</a></td><td>(gen input <i>pm</i>)</td><td>all-pass filter</td></tr>
<tr><td><a href="clm.html#all-pass?">all-pass?</a></td><td>(gen)</td><td>#t if gen is all-pass filter</td></tr>
<tr><td><a href="clm.html#amplitude-modulate">amplitude-modulate</a></td><td>(carrier in1 in2)</td><td>amplitude modulation</td></tr>
<tr><td><a href="clm.html#array-interp">array-interp</a></td><td>(arr x)</td><td>interpolated array lookup</td></tr>
<tr><td><a href="clm.html#array-&gt;file">array-&gt;file</a></td><td colspan=2>(filename vct len srate channels)</td></tr>
<tr><td></td><td colspan=2>
write the contents of <i>vct</i> to the newly created sound file <i>filename</i>, giving 
the new file <i>channels</i> channels (data assumed to be interleaved in <i>vct</i>),
sampling rate <i>srate</i>, and <i>len</i> samples (not frames).
</td></tr>
<tr><td><a href="clm.html#asymmetric-fm">asymmetric-fm</a></td><td>(gen index <i>fm</i>)</td><td>asymmetric-fm generator</td></tr>
<tr><td><a href="clm.html#asymmetric-fm?">asymmetric-fm?</a></td><td>(gen)</td><td>#t if gen is asymmetric-fm generator</td></tr>
<tr><td><a href="clm.html#average">average</a></td><td>(gen input)</td><td>moving window average</td></tr>
<tr><td><a href="clm.html#average?">average?</a></td><td>(gen)</td><td>#t if gen is an average generator</td></tr>
<tr><td><a href="clm.html#buffer-&gt;frame">buffer-&gt;frame</a></td><td>(gen frame)</td><td>buffer generator returning frame</td></tr>
<tr><td><a href="clm.html#buffer-&gt;sample">buffer-&gt;sample</a></td><td>(gen)</td><td>buffer generator returning sample</td></tr>
<tr><td><a href="clm.html#buffer-empty?">buffer-empty?</a></td><td>(gen)</td><td>#t if buffer has no data</td></tr>
<tr><td><a href="clm.html#buffer-full?">buffer-full?</a></td><td>(gen)</td><td>#t if buffer has no room for more data</td></tr>
<tr><td><a href="clm.html#buffer?">buffer?</a></td><td>(gen)</td><td>#t if gen is buffer generator</td></tr>
<tr><td><a href="clm.html#clear-array">clear-array</a></td><td>(arr)</td><td>set all elements of arr to 0.0</td></tr>
<tr><td><a href="clm.html#comb">comb</a></td><td>(gen input <i>pm</i>)</td><td>comb filter</td></tr>
<tr><td><a href="clm.html#comb?">comb?</a></td><td>(gen)</td><td>#t if gen is comb filter</td></tr>
<tr><td><a href="clm.html#continue-sample-&gt;file">continue-sample-&gt;file</a></td><td>(file)</td><td>reopen file for more output</td></tr>
<tr><td><a href="clm.html#contrast-enhancement">contrast-enhancement</a></td><td>(input (<i>index</i> 1.0))</td><td>a kind of phase modulation or companding</td></tr>
<tr><td><a href="clm.html#convolution">convolution</a></td><td>(sig1 sig2 n)</td><td>convolve sig1 with sig2 (size n), returning new sig1</td></tr>
<tr><td><a href="clm.html#convolve">convolve</a></td><td>(gen <i>input-function</i>)</td><td>convolve generator</td></tr>
<tr><td><a href="clm.html#convolve?">convolve?</a></td><td>(gen)</td><td>#t if gen is convolve generator</td></tr>
<tr><td><a href="clm.html#convolvefiles">convolve-files</a></td><td>(f1 f2 maxamp outf)</td><td>convolve f1 with f2, normalize to maxamp, write outf</td></tr>
<tr><td><a href="clm.html#db-&gt;linear">db-&gt;linear</a></td><td>(db)</td><td>translate dB value to linear</td></tr>
<tr><td><a href="clm.html#degrees-&gt;radians">degrees-&gt;radians</a></td><td>(deg)</td><td>translate degrees to radians</td></tr>
<tr><td><a href="clm.html#delay">delay</a></td><td>(gen input <i>pm</i>)</td><td>delay line</td></tr>
<tr><td></td><td colspan=2><br>
In Scheme <b>delay</b> is a built-in syntactic form; it is renamed <b>%delay</b> here.
</td></tr>
<tr><td colspan=3><br></td></tr>
<tr><td><a href="clm.html#delay?">delay?</a></td><td>(gen)</td><td>#t if gen is delay line</td></tr>
<tr><td><a href="clm.html#dot-product">dot-product</a></td><td>(sig1 sig2)</td><td>return dot-product of sig1 with sig2</td></tr>
<tr><td><a href="clm.html#env">env</a></td><td>(gen)</td><td>envelope generator</td></tr>
<tr><td><a href="clm.html#env-interp">env-interp</a></td><td>(x env (<i>base</i> 1.0))</td><td>return value of env at x</td></tr>
<tr><td><a href="clm.html#env?">env?</a></td><td>(gen)</td><td>#t if gen is env (from make-env)</td></tr>
<tr><td><a href="clm.html#fft">mus-fft</a></td><td>(rl im <i>n sign</i>)</td><td>fft of rl and im (sign = -1 for ifft), result in rl</td></tr>
<tr><td valign=top><a href="clm.html#file-&gt;array">file-&gt;array</a></td><td valign=top>(filename chan start len vct)</td><td>
load <i>len</i> samples of <i>filename</i> into <i>vct</i> starting at frame <i>start</i> in channel <i>chan</i>.
</td></tr>
<tr><td><a href="clm.html#file-&gt;frame">file-&gt;frame</a></td><td>(gen loc <i>frame</i>)</td><td>return frame from file at loc</td></tr>
<tr><td><a href="clm.html#file-&gt;frame?">file-&gt;frame?</a></td><td>(gen)</td><td>#t if gen is file-&gt;frame generator</td></tr>
<tr><td><a href="clm.html#file-&gt;sample">file-&gt;sample</a></td><td>(gen loc <i>(chan 0)</i>)</td><td>return sample from file at loc</td></tr>
<tr><td><a href="clm.html#file-&gt;sample?">file-&gt;sample?</a></td><td>(gen)</td><td>#t if gen is file-&gt;sample generator</td></tr>
<tr><td><a href="clm.html#filter">filter</a></td><td>(gen input)</td><td>filter</td></tr>
<tr><td><a href="clm.html#filter?">filter?</a></td><td>(gen)</td><td>#t if gen is filter</td></tr>
<tr><td><a href="clm.html#fir-filter">fir-filter</a></td><td>(gen input)</td><td>FIR filter</td></tr>
<tr><td><a href="clm.html#fir-filter?">fir-filter?</a></td><td>(gen)</td><td>#t if gen is fir filter</td></tr>
<tr><td><a href="clm.html#formant">formant</a></td><td>(gen input)</td><td>formant generator</td></tr>
<tr><td><a class=def name="formantbank">formant-bank</a></td><td>(scls gens inval)</td><td></td></tr>
<tr><td><a href="clm.html#formant?">formant?</a></td><td>(gen)</td><td>#t if gen is formant generator</td></tr>
<tr><td><a href="clm.html#frame*">frame*</a></td><td>(fr1 fr2 <i>outfr</i>)</td><td>element-wise multiply</td></tr>
<tr><td><a href="clm.html#frame+">frame+</a></td><td>(fr1 fr2 <i>outfr</i>)</td><td>element-wise add</td></tr>
<tr><td><a href="clm.html#frame-&gt;buffer">frame-&gt;buffer</a></td><td>(buf frame)</td><td>add frame to buffer</td></tr>
<tr><td><a href="clm.html#frame-&gt;file">frame-&gt;file</a></td><td>(gen loc frame)</td><td>write (add) frame to file at loc</td></tr>
<tr><td><a href="clm.html#frame-&gt;file?">frame-&gt;file?</a></td><td>(gen)</td><td>#t if gen is frame-&gt;file generator</td></tr>
<tr><td><a href="clm.html#frame-&gt;frame">frame-&gt;frame</a></td><td>(mixer frame <i>outfr</i>)</td><td>pass frame through mixer</td></tr>
<tr><td><a href="clm.html#frame-&gt;list">frame-&gt;list</a></td><td>(frame)</td><td>return list of frame contents</td></tr>
<tr><td><a href="clm.html#frame-ref">frame-ref</a></td><td>(frame chan)</td><td>return frame[chan]</td></tr>
<tr><td><a href="clm.html#frame-&gt;sample">frame-&gt;sample</a></td><td>(frmix frame)</td><td>pass frame through frame or mixer to produce sample</td></tr>
<tr><td><a href="clm.html#frame-set!">frame-set!</a></td><td>(frame chan val)</td><td>frame[chan]=val</td></tr>
<tr><td><a href="clm.html#frame?">frame?</a></td><td>(gen)</td><td>#t if gen is frame object</td></tr>
<tr><td></td><td colspan=2><br>
In Guile <b>frame?</b> is part of the debugger; it is renamed <b>%frame?</b> here.
</td></tr>
<tr><td colspan=3><br></td></tr>
<tr><td><a href="clm.html#granulate">granulate</a></td><td>(gen <i>input-function</i>)</td><td>granular synthesis generator</td></tr>
<tr><td><a href="clm.html#granulate?">granulate?</a></td><td>(gen)</td><td>#t if gen is granulate generator</td></tr>
<tr><td><a href="clm.html#hz-&gt;radians">hz-&gt;radians</a></td><td>(freq)</td><td>translate freq to radians/sample</td></tr>
<tr><td><a href="clm.html#iir-filter">iir-filter</a></td><td>(gen input)</td><td>IIR filter</td></tr>
<tr><td><a href="clm.html#iir-filter?">iir-filter?</a></td><td>(gen)</td><td>#t if gen is iir-filter</td></tr>
<tr><td><a href="clm.html#in-any">in-any</a></td><td>(loc <i>chan stream</i>)</td><td>return sample in stream at loc and chan</td></tr>
<tr><td><a class=def name="inhz">in-hz</a></td><td>(freq)</td><td>translate freq to radians/sample</td></tr>
<tr><td><a href="clm.html#ina">ina</a></td><td>(loc <i>stream</i>)</td><td>return sample in stream at loc, chan 0</td></tr>
<tr><td><a href="clm.html#inb">inb</a></td><td>(loc <i>stream</i>)</td><td>return sample in stream at loc, chan 1</td></tr>
<tr><td><a href="clm.html#linear-&gt;db">linear-&gt;db</a></td><td>(val)</td><td>translate linear val to dB</td></tr>
<tr><td><a href="clm.html#locsig">locsig</a></td><td>(gen loc input)</td><td>place input in output channels at loc</td></tr>
<tr><td><a href="clm.html#locsig-ref">locsig-ref</a></td><td>(gen chan)</td><td>locsig-scaler[chan]</td></tr>
<tr><td><a href="clm.html#locsig-reverb-ref">locsig-reverb-ref</a></td><td>(gen chan)</td><td>locsig-reverb-scaler[chan]</td></tr>
<tr><td><a href="clm.html#locsig-set!">locsig-set!</a></td><td>(gen chan val)</td><td>locsig-scaler[chan] = val</td></tr>
<tr><td><a href="clm.html#locsig-reverb-set!">locsig-reverb-set!</a></td><td>(gen chan val)</td><td>locsig-reverb-scaler[chan] = val</td></tr>
<tr><td><a href="clm.html#locsig?">locsig?</a></td><td>(gen)</td><td>#t if gen is locsig generator</td></tr>
<tr><td colspan=3><br>
;; all the make function arguments are <a href="clm.html#optional-key">optional-key</a> args
</td></tr>
<tr><td><a href="clm.html#make-all-pass">make-all-pass</a></td><td colspan=2>(feedback feedforward size initial-contents initial-element max-size)</td></tr>
<tr><td><a href="clm.html#make-average">make-average</a></td><td colspan=2>(size initial-contents initial-element)</td></tr>
<tr><td><a href="clm.html#make-asymmetric-fm">make-asymmetric-fm</a></td><td colspan=2>(frequency initial-phase r ratio)</td></tr>
<tr><td><a href="clm.html#make-buffer">make-buffer</a></td><td colspan=2>(size fill-time)</td></tr>
<tr><td><a href="clm.html#make-comb">make-comb</a></td><td colspan=2>(scaler size initial-contents initial-element max-size)</td></tr>
<tr><td><a href="clm.html#make-convolve">make-convolve</a></td><td colspan=2>(input filter fft-size filter-size)</td></tr>
<tr><td><a href="clm.html#make-delay">make-delay</a></td><td colspan=2>(size initial-contents initial-element max-size)</td></tr>
<tr><td><a href="clm.html#make-env">make-env</a></td><td colspan=2>(envelope scaler duration offset base end start)</td></tr>
<tr><td><a href="clm.html#make-fft-window">make-fft-window</a></td colspan=2><td>(type size beta)</td></tr>
<tr><td><a href="clm.html#make-file-&gt;frame">make-file-&gt;frame</a></td><td colspan=2>(name)</td></tr>
<tr><td><a href="clm.html#make-file-&gt;sample">make-file-&gt;sample</a></td><td colspan=2>(name)</td></tr>
<tr><td><a href="clm.html#make-filter">make-filter</a></td><td colspan=2>(order xcoeffs ycoeffs)</td></tr>
<tr><td><a class=def name="makefircoeffs">make-fir-coeffs</a></td><td colspan=2>(order spectr)</td></tr>
<tr><td><a href="clm.html#make-fir-filter">make-fir-filter</a></td><td colspan=2>(order xcoeffs)</td></tr>
<tr><td><a href="clm.html#make-formant">make-formant</a></td><td colspan=2>(radius frequency gain)</td></tr>
<tr><td><a href="clm.html#make-frame">make-frame</a></td><td colspan=2>(chans &amp;rest vals)</td></tr>
<tr><td><a href="clm.html#make-frame-&gt;file">make-frame-&gt;file</a></td><td colspan=2>(name chans format type)</td></tr>
<tr><td><a href="clm.html#make-granulate">make-granulate</a></td><td colspan=2>(input expansion length scaler hop ramp jitter max-size edit)</td></tr>
<tr><td><a href="clm.html#make-iir-filter">make-iir-filter</a></td><td colspan=2>(order ycoeffs)</td></tr>
<tr><td><a href="clm.html#make-locsig">make-locsig</a></td><td colspan=2>(degree distance reverb output revout channels type)</td></tr>
<tr><td><a href="clm.html#make-mixer">make-mixer</a></td><td colspan=2>(chans &amp;rest vals)</td></tr>
<tr><td><a href="clm.html#make-notch">make-notch</a></td><td colspan=2>(scaler size initial-contents initial-element max-size)</td></tr>
<tr><td><a href="clm.html#make-one-pole">make-one-pole</a></td><td colspan=2>(a0 b1)</td></tr>
<tr><td><a href="clm.html#make-one-zero">make-one-zero</a></td><td colspan=2>(a0 a1)</td></tr>
<tr><td><a href="clm.html#make-oscil">make-oscil</a></td><td colspan=2>(frequency initial-phase)</td></tr>
<tr><td><a href="clm.html#make-phase-vocoder">make-phase-vocoder</a></td><td colspan=2>(fftsize overlap interp pitch analyze edit synthesize)</td></tr>
<tr><td><a href="clm.html#make-ppolar">make-ppolar</a></td><td colspan=2>(radius frequency)</td></tr>
<tr><td><a href="clm.html#make-pulse-train">make-pulse-train</a></td><td colspan=2>(frequency amplitude initial-phase)</td></tr>
<tr><td><a href="clm.html#make-rand">make-rand</a></td><td colspan=2>(frequency amplitude)</td></tr>
<tr><td><a href="clm.html#make-rand-interp">make-rand-interp</a></td><td colspan=2>(frequency amplitude)</td></tr>
<tr><td><a href="clm.html#make-readin">make-readin</a></td><td colspan=2>(file channel start)</td></tr>
<tr><td><a href="clm.html#make-sample-&gt;file">make-sample-&gt;file</a></td><td colspan=2>(name chans format type <i>comment</i>)</td></tr>
<tr><td><a href="clm.html#make-sawtooth-wave">make-sawtooth-wave</a></td><td colspan=2>(frequency amplitude initial-phase)</td></tr>
<tr><td><a href="clm.html#make-sine-summation">make-sine-summation</a></td><td colspan=2>(frequency initial-phase n a ratio)</td></tr>
<tr><td><a href="extsnd.html#makesnd_to_sample">make-snd-&gt;sample</a></td><td colspan=2>((index #f))</td></tr>
<tr><td><a href="clm.html#make-square-wave">make-square-wave</a></td><td colspan=2>(frequency amplitude initial-phase)</td></tr>
<tr><td><a href="clm.html#make-src">make-src</a></td><td colspan=2>(input srate width)</td></tr>
<tr><td><a href="clm.html#make-sum-of-cosines">make-sum-of-cosines</a></td><td colspan=2>(cosines frequency initial-phase)</td></tr>
<tr><td><a href="clm.html#make-sum-of-sines">make-sum-of-sines</a></td><td colspan=2>(sines frequency initial-phase)</td></tr>
<tr><td><a href="clm.html#make-table-lookup">make-table-lookup</a></td><td colspan=2>(frequency initial-phase wave size)</td></tr>
<tr><td><a href="clm.html#make-triangle-wave">make-triangle-wave</a></td><td colspan=2>(frequency amplitude initial-phase)</td></tr>
<tr><td><a href="clm.html#make-two-pole">make-two-pole</a></td><td colspan=2>(a0 b1 b2)</td></tr>
<tr><td><a href="clm.html#make-two-zero">make-two-zero</a></td><td colspan=2>(a0 a1 a2)</td></tr>
<tr><td><a href="clm.html#make-wave-train">make-wave-train</a></td><td colspan=2>(frequency initial-phase wave size)</td></tr>
<tr><td><a href="clm.html#make-waveshape">make-waveshape</a></td><td colspan=2>(frequency partials wave size)</td></tr>
<tr><td><a href="extsnd.html#makexen_to_sample">make-xen-&gt;sample</a></td><td colspan=2>(reader)</td></tr>
<tr><td><a href="clm.html#make-zpolar">make-zpolar</a></td><td colspan=2>(radius frequency)</td></tr>
<tr><td><a href="clm.html#mixer*">mixer*</a></td><td>(mix1 mix2 <i>outmx</i>)</td><td>matrix multiply of mix1 and mix2</td></tr>
<tr><td><a href="clm.html#mixer-ref">mixer-ref</a></td><td>(mixer in out)</td><td>mix-scaler[in,out]</td></tr>
<tr><td><a href="clm.html#mixer-set!">mixer-set!</a></td><td>(mixer in out val)</td><td>mix-scaler[in,out] = val</td></tr>
<tr><td><a href="clm.html#mixer?">mixer?</a></td><td>(gen)</td><td>#t if gen is mixer object</td></tr>
<tr><td><a href="clm.html#move-locsig">move-locsig</a></td><td colspan=2>(gen degree distance)</td></tr>
<tr><td><a href="clm.html#multiply-arrays">multiply-arrays</a></td><td>(arr1 arr2)</td><td>arr1[i] *= arr2[i]</td></tr>
<tr><td><a href="clm.html#mus-a0">mus-a0</a></td><td>(gen)</td><td>a0 field (simple filters)</td></tr>
<tr><td><a href="clm.html#mus-a1">mus-a1</a></td><td>(gen)</td><td>a1 field (simple filters)</td></tr>
<tr><td><a href="clm.html#mus-a2">mus-a2</a></td><td>(gen)</td><td>a2 field (simple filters)</td></tr>
<tr><td><a class=def name="musarrayprintlength">mus-array-print-length</a></td><td>()</td><td>how many array (vct) elements to print in mus_describe</td></tr>
<tr><td><a href="clm.html#mus-b1">mus-b1</a></td><td>(gen)</td><td>b1 field (simple filters)</td></tr>
<tr><td><a href="clm.html#mus-b2">mus-b2</a></td><td>(gen)</td><td>b2 field (simple filters)</td></tr>
<tr><td><a href="clm.html#musbank">mus-bank</a></td><td>(gens amps <i>args1 args2</i>)</td><td></td></tr>
<tr><td><a href="clm.html#mus-channel">mus-channel</a></td><td>(gen)</td><td>channel of gen</td></tr>
<tr><td><a href="clm.html#mus-channels">mus-channels</a></td><td>(gen)</td><td>channels of gen</td></tr>
<tr><td><a href="clm.html#mus-cosines">mus-cosines</a></td><td>(gen)</td><td>cosines of sum-of-cosines gen</td></tr>
<tr><td><a href="clm.html#mus-data">mus-data</a></td><td>(gen)</td><td>data array of gen</td></tr>
<tr><td><a href="clm.html#mus-feedback">mus-feedback</a></td><td>(gen)</td><td>feedback term of gen (simple filters)</td></tr>
<tr><td><a href="clm.html#mus-feedforward">mus-feedforward</a></td><td>(gen)</td><td>feedforward term of gen (<a class=quiet href="clm.html#all-pass">all-pass</a>)</td></tr>
<tr><td><a class=def name="musfilebuffersize">mus-file-buffer-size</a></td><td>()</td><td>size of input/ouput buffers (default 8192)</td></tr>
<tr><td><a href="clm.html#mus-file-name">mus-file-name</a></td><td>(gen)</td><td>name of file assoicated with gen</td></tr>
<tr><td><a href="clm.html#mus-formant-radius">mus-formant-radius</a></td><td>(gen)</td><td>formant radius</td></tr>
<tr><td><a href="clm.html#mus-frequency">mus-frequency</a></td><td>(gen)</td><td>frequency of gen (Hz)</td></tr>
<tr><td><a href="clm.html#mus-hop">mus-hop</a></td><td>(gen)</td><td>hop amount of gen (<a class=quiet href="clm.html#granulate">granulate</a>)</td></tr>
<tr><td><a href="clm.html#mus-increment">mus-increment</a></td><td>(gen)</td><td>increment of gen (src, readin, granulate)</td></tr>
<tr><td><a href="clm.html#mus-input?">mus-input?</a></td><td>(gen)</td><td>#t if gen is input source</td></tr>
<tr><td><a href="clm.html#mus-length">mus-length</a></td><td>(gen)</td><td>length of gen</td></tr>
<tr><td><a href="clm.html#mus-location">mus-location</a></td><td>(gen)</td><td>location (read point) of gen</td></tr>
<tr><td><a class=def name="musmix">mus-mix</a></td><td colspan=2>(outfile infile <i>(outloc 0) frames (inloc 0) mixer envs</i>)</td></tr>
<tr><td></td><td colspan=2><br>
mix <i>infile</i> into <i>outfile</i> starting at <i>outloc</i> in <i>outfile</i> and <i>inloc</i> in <i>infile</i>
mixing <i>frames</i> frames of <i>infile</i>.  <i>frames</i> defaults to the length of <i>infile</i>. If <i>mixer</i>,
use it to scale the various channels; if <i>envs</i> (an array of envelope generators), use
it in conjunction with <i>mixer</i>to scale/envelope all the various ins and outs.
<i>outfile</i> can be a frame-&gt;file generator, and <i>infile</i> can be a file-&gt;frame generator.
</td></tr>
<tr><td colspan=3><br></td></tr>
<tr><td><a href="clm.html#mus-order">mus-order</a></td><td>(gen)</td><td>order of gen (filters)</td></tr>
<tr><td><a href="clm.html#mus-output?">mus-output?</a></td><td>(gen)</td><td>#t if gen is output generator</td></tr>
<tr><td><a href="clm.html#mus-phase">mus-phase</a></td><td>(gen)</td><td>phase of gen (radians)</td></tr>
<tr><td><a href="clm.html#mus-ramp">mus-ramp</a></td><td>(gen)</td><td>ramp time of gen (<a class=quiet href="clm.html#granulate">granulate</a>)</td></tr>
<tr><td><a href="clm.html#mus-random">mus-random</a></td><td>(val)</td><td>random numbers bewteen -val and val</td></tr>
<tr><td><a href="clm.html#mus-run">mus-run</a></td><td>(gen <i>arg1 arg2</i>)</td><td>apply gen to args</td></tr>
<tr><td><a href="clm.html#mus-scaler">mus-scaler</a></td><td>(gen)</td><td>scaler of gen</td></tr>
<tr><td><a href="clm.html#mus-set-rand-seed">mus-rand-seed</a></td><td>(val)</td><td>random number generator seed (settable via set!)</td></tr>
<tr><td><a class=def name="mussrate">mus-srate</a></td><td>()</td><td>current sampling rate</td></tr>
<tr><td><a href="clm.html#mus-xcoeffs">mus-xcoeffs</a></td><td>(gen)</td><td>feedforward (FIR) coeffs of filter</td></tr>
<tr><td><a href="clm.html#mus-ycoeffs">mus-ycoeffs</a></td><td>(gen)</td><td>feedback (IIR) coeefs of filter</td></tr>
<tr><td><a href="clm.html#notch">notch</a></td><td>(gen input <i>pm</i>)</td><td>notch filter</td></tr>
<tr><td><a href="clm.html#notch?">notch?</a></td><td>(gen)</td><td>#t if gen is notch filter</td></tr>
<tr><td><a href="clm.html#one-pole">one-pole</a></td><td>(gen input)</td><td>one-pole filter</td></tr>
<tr><td><a href="clm.html#one-pole?">one-pole?</a></td><td>(gen)</td><td>#t if gen is one-pole filter</td></tr>
<tr><td><a href="clm.html#one-zero">one-zero</a></td><td>(gen input)</td><td>one-zero filter</td></tr>
<tr><td><a href="clm.html#one-zero?">one-zero?</a></td><td>(gen)</td><td>#t if gen is one-zero filter</td></tr>
<tr><td><a href="clm.html#oscil">oscil</a></td><td>(gen <i>fm pm</i>)</td><td>sine wave generator</td></tr>
<tr><td><a href="clm.html#oscilbank">oscil-bank</a></td><td>(scls gens invals)</td><td>bank of oscils</td></tr>
<tr><td><a href="clm.html#oscil?">oscil?</a></td><td>(gen)</td><td>#t if gen is oscil generator</td></tr>
<tr><td><a href="clm.html#out-any">out-any</a></td><td>(loc samp chan <i>stream</i>)</td><td>write (add) samp to stream at loc in channel chan</td></tr>
<tr><td><a href="clm.html#outa">outa</a></td><td>(loc samp <i>stream</i>)</td><td>write (add) samp to stream at loc in chan 0</td></tr>
<tr><td><a href="clm.html#outb">outb</a></td><td>(loc samp <i>stream</i>)</td><td>write (add) samp to stream at loc in chan 1</td></tr>
<tr><td><a href="clm.html#outc">outc</a></td><td>(loc samp <i>stream</i>)</td><td>write (add) samp to stream at loc in chan 2</td></tr>
<tr><td><a href="clm.html#outd">outd</a></td><td>(loc samp <i>stream</i>)</td><td>write (add) samp to stream at loc in chan 3</td></tr>
<tr><td><a href="clm.html#partials-&gt;polynomial">partials-&gt;polynomial</a></td><td>(partials <i>kind</i>)</td><td>create waveshaping polynomial from partials</td></tr>
<tr><td><a href="clm.html#partials-&gt;wave">partials-&gt;wave</a></td><td>(synth-data table <i>norm</i>)</td><td>load table from synth-data</td></tr>
<tr><td><a href="clm.html#partials-&gt;waveshape">partials-&gt;waveshape</a></td><td>(partials <i>norm size</i>)</td><td>create waveshaping table from partials</td></tr>
<tr><td><a href="clm.html#phase-partials-&gt;wave">phase-partials-&gt;wave</a></td><td>(synth-data table <i>norm</i>)</td><td>load table from synth-data</td></tr>
<tr><td><a href="clm.html#phase-vocoder">phase-vocoder</a></td><td>(pv input)</td><td>phase vocoder generator</td></tr>
<tr><td><a href="clm.html#phase-vocoder?">phase-vocoder?</a></td><td>(pv)</td><td>#t if pv is phase vocoder generator</td></tr>
<tr><td><a href="clm.html#polar-&gt;rectangular">polar-&gt;rectangular</a></td><td>(rl im)</td><td>translate from polar to rectangular coordinates</td></tr>
<tr><td><a href="clm.html#polynomial">polynomial</a></td><td>(coeffs x)</td><td>evaluate polynomial at x</td></tr>
<tr><td><a href="clm.html#pulse-train">pulse-train</a></td><td>(gen <i>fm</i>)</td><td>pulse-train generator</td></tr>
<tr><td><a href="clm.html#pulse-train?">pulse-train?</a></td><td>(gen)</td><td>#t if gen is pulse-train generator</td></tr>
<tr><td><a href="clm.html#radians-&gt;degrees">radians-&gt;degrees</a></td><td>(rads)</td><td>convert radians to degrees</td></tr>
<tr><td><a href="clm.html#radians-&gt;hz">radians-&gt;hz</a></td><td>(rads)</td><td>convert radians/sample to Hz</td></tr>
<tr><td><a href="clm.html#rand">rand</a></td><td>(gen <i>fm</i>)</td><td>random number generator</td></tr>
<tr><td></td><td colspan=2><br>
In Ruby <b>rand</b> is a built-in method; it is aliased to <b>kernel_rand</b> here.
</td></tr>
<tr><td colspan=3><br></td></tr>
<tr><td><a href="clm.html#rand-interp">rand-interp</a></td><td>(gen <i>fm</i>)</td><td>interpolating random number generator</td></tr>
<tr><td><a href="clm.html#rand-interp?">rand-interp?</a></td><td>(gen)</td><td>#t if gen is interpolating random number generator</td></tr>
<tr><td><a href="clm.html#rand?">rand?</a></td><td>(gen)</td><td>#t if gen is random number generator</td></tr>
<tr><td><a href="clm.html#readin">readin</a></td><td>(gen)</td><td>read one value from associated input stream</td></tr>
<tr><td><a href="clm.html#readin?">readin?</a></td><td>(gen)</td><td>#t if gen is readin generator</td></tr>
<tr><td><a href="clm.html#rectangular-&gt;polar">rectangular-&gt;polar</a></td><td>(rl im)</td><td>translate from rectangular to polar coordinates</td></tr>
<tr><td><a href="clm.html#restart-env">restart-env</a></td><td>(env)</td><td>return to start of env</td></tr>
<tr><td><a href="clm.html#ring-modulate">ring-modulate</a></td><td>(sig1 sig2)</td><td>sig1 * sig2 (element-wise)</td></tr>
<tr><td><a href="clm.html#sample-&gt;buffer">sample-&gt;buffer</a></td><td>(buf samp)</td><td>store samp in buffer</td></tr>
<tr><td><a href="clm.html#sample-&gt;file">sample-&gt;file</a></td><td>(gen loc chan val)</td><td>store val in file at loc in channel chan</td></tr>
<tr><td><a href="clm.html#sample-&gt;file?">sample-&gt;file?</a></td><td>(gen)</td><td>#t if gen is sample-&gt;file generator</td></tr>
<tr><td><a href="clm.html#sample-&gt;frame">sample-&gt;frame</a></td><td>(frmix samp <i>outfr</i>)</td><td>convert samp to frame</td></tr>
<tr><td><a href="clm.html#samples-&gt;seconds">samples-&gt;seconds</a></td><td>(val)</td><td>use mus-srate to convert samples into seconds</td></tr>
<tr><td><a href="clm.html#sawtooth-wave">sawtooth-wave</a></td><td>(gen <i>fm</i>)</td><td>sawtooth-wave generator</td></tr>
<tr><td><a href="clm.html#sawtooth-wave?">sawtooth-wave?</a></td><td>(gen)</td><td>#t if gen is sawtooth-wave generator</td></tr>
<tr><td><a href="clm.html#seconds-&gt;samples">seconds-&gt;samples</a></td><td>(val)</td><td>use mus-srate to convert seconds into samples</td></tr>
<tr><td><a href="clm.html#sine-bank">sine-bank</a></td><td>(amps phases)</td><td>additive synthesis</td></tr>
<tr><td><a href="clm.html#sine-summation">sine-summation</a></td><td>(gen <i>fm</i>)</td><td>sine-summation generator</td></tr>
<tr><td><a href="clm.html#sine-summation?">sine-summation?</a></td><td>(gen)</td><td>#t if gen is sine-summation generator</td></tr>
<tr><td><a href="extsnd.html#snd_to_sample">snd-&gt;sample</a></td><td>(loc (chan 0))</td><td>return sample from sound (index=snd) at loc</td></tr>
<tr><td><a href="extsnd.html#snd_to_samplep">snd-&gt;sample?</a></td><td>(gen)</td><td>#t if gen is snd-&gt;sample generator</td></tr>
<tr><td><a href="clm.html#spectrum">spectrum</a></td><td>(rl im win type)</td><td>produce spectrum of data in rl (return rl)</td></tr>
<tr><td><a href="clm.html#square-wave">square-wave</a></td><td>(gen <i>fm</i>)</td><td>square-wave generator</td></tr>
<tr><td><a href="clm.html#square-wave?">square-wave?</a></td><td>(gen)</td><td>#t if gen is square-wave generator</td></tr>
<tr><td><a href="clm.html#src">src</a></td><td>(gen <i>fm input-function</i>)</td><td>sample rate converter</td></tr>
<tr><td><a href="clm.html#src?">src?</a></td><td>(gen)</td><td>#t if gen is sample-rate converter</td></tr>
<tr><td><a href="clm.html#sum-of-cosines">sum-of-cosines</a></td><td>(gen <i>fm</i>)</td><td>sum-of-cosines (<a class=quiet href="clm.html#pulse-train">pulse-train</a>) generator</td></tr>
<tr><td><a href="clm.html#sum-of-cosines?">sum-of-cosines?</a></td><td>(gen)</td><td>#t if gen is sum-of-cosines generator</td></tr>
<tr><td><a href="clm.html#sum-of-sines">sum-of-sines</a></td><td>(gen <i>fm</i>)</td><td>sum-of-sines</td></tr>
<tr><td><a href="clm.html#sum-of-sines?">sum-of-sines?</a></td><td>(gen)</td><td>#t if gen is sum-of-sines generator</td></tr>
<tr><td><a href="clm.html#table-lookup">table-lookup</a></td><td>(gen <i>fm</i>)</td><td>table-lookup generator</td></tr>
<tr><td><a href="clm.html#table-lookup?">table-lookup?</a></td><td>(gen)</td><td>#t if gen is table-lookup generator</td></tr>
<tr><td><a href="clm.html#tap">tap</a></td><td>(gen <i>pm</i>)</td><td>delay line tap</td></tr>
<tr><td><a href="clm.html#triangle-wave">triangle-wave</a></td><td>(gen <i>fm</i>)</td><td>triangle-wave generator</td></tr>
<tr><td><a href="clm.html#triangle-wave?">triangle-wave?</a></td><td>(gen)</td><td>#t if gen is triangle-wave generator</td></tr>
<tr><td><a href="clm.html#two-pole">two-pole</a></td><td>(gen input)</td><td>two-pole filter</td></tr>
<tr><td><a href="clm.html#two-pole?">two-pole?</a></td><td>(gen)</td><td>#t if gen is two-pole filter</td></tr>
<tr><td><a href="clm.html#two-zero">two-zero</a></td><td>(gen input)</td><td>two-zero filter</td></tr>
<tr><td><a href="clm.html#two-zero?">two-zero?</a></td><td>(gen)</td><td>#t if gen is two-zero filter</td></tr>
<tr><td><a href="clm.html#wave-train">wave-train</a></td><td>(gen <i>fm</i>)</td><td>wave-train generator</td></tr>
<tr><td><a href="clm.html#wave-train?">wave-train?</a></td><td>(gen)</td><td>#t if gen is wave-train generator</td></tr>
<tr><td><a href="clm.html#waveshape">waveshape</a></td><td>(gen <i>index fm</i>)</td><td>waveshaping generator</td></tr>
<tr><td><a href="clm.html#waveshape?">waveshape?</a></td><td>(gen)</td><td>#t if gen is waveshape generator</td></tr>
<tr><td><a href="extsnd.html#xen_to_sample">xen-&gt;sample</a></td><td>(loc (chan 0))</td><td>return sample from xen func at loc in chan</td></tr>
<tr><td><a href="extsnd.html#xen_to_samplep">xen-&gt;sample?</a></td><td>(gen)</td><td>#t if gen is xen-&gt;sample generator</td></tr>
</table>
<br>

<p>In Snd, the default locsig interpolation type is handled via locsig-type, rather than CLM's global
variable *clm-locsig-type*.
</p>

<p><b>formant-bank</b> and <b>oscil-bank</b> are optimizations for situations like the phase
vocoder or cross synthesis (see <a href="sndscm.html#exampdoc">examp.scm</a>).  It is assumed that you have a vector of generators,
all summing their outputs into a single float.  The amplitude scalers (the first argument to
the bank function) can be a float, a vector of floats, a vct of floats, or a function that
returns a float each time it is called; similarly for the inputs (the third argument); the
bank of generators (the second argument) is assumed to be a vector full of generators. </p>
<pre>
  (formant-bank amps gens inval)
</pre>
<p>is the same as (but 30 times faster than)</p>
<pre>
  (do ((sum 0.0)
       (i 0 (1+ i))) 
      ((= i (<a class=quiet href="extsnd.html#vctlength">vct-length</a> gens)) sum)
    (set! sum (+ sum (* (vector-ref amps i)
                        (<a class=quiet href="clm.html#formant">formant</a> (vector-ref gens i) inval)))))
</pre>
<p>in the all-vector case.  <a href="clm.html#musbank">mus-bank</a> is the general case.
Here are a few more examples, taken from <a href="sndscm.html#exampdoc">examp.scm</a>.
</p>
<pre>


(define comb-filter 
  (lambda (scaler size)
    (let ((cmb (<a class=quiet href="clm.html#make-comb">make-comb</a> scaler size)))
      (lambda (x) (<a class=quiet href="clm.html#comb">comb</a> cmb x)))))

; (<a class=quiet href="extsnd.html#mapchan">map-chan</a> (comb-filter .8 32))

;;; by using filters at harmonically related sizes, we can get chords:

(define comb-chord
  (lambda (scaler size amp)
    (let ((c1 (<a class=quiet href="clm.html#make-comb">make-comb</a> scaler size))
	  (c2 (<a class=quiet href="clm.html#make-comb">make-comb</a> scaler (* size .75)))
	  (c3 (<a class=quiet href="clm.html#make-comb">make-comb</a> scaler (* size 1.2))))
      (lambda (x)
        (* amp (+ (<a class=quiet href="clm.html#comb">comb</a> c1 x) (<a class=quiet href="clm.html#comb">comb</a> c2 x) (<a class=quiet href="clm.html#comb">comb</a> c3 x)))))))

; (<a class=quiet href="extsnd.html#mapchan">map-chan</a> (comb-chord .95 60 .3))

;;; or change the comb length via an envelope:

(define max-envelope
  (lambda (e mx)
    (if (null? e)
	mx
      (<a class=quiet href="sndscm.html#maxenvelope">max-envelope</a> (cddr e) (max mx (abs (cadr e)))))))

(define zcomb
  (lambda (scaler size pm)
    (let ((cmb (<a class=quiet href="clm.html#make-comb">make-comb</a> scaler size :max-size (+ size 1 (<a class=quiet href="sndscm.html#maxenvelope">max-envelope</a> pm 0))))
	  (penv (<a class=quiet href="clm.html#make-env">make-env</a> :envelope pm :end (<a class=quiet href="extsnd.html#frames">frames</a>))))
      (lambda (x) (<a class=quiet href="clm.html#comb">comb</a> cmb x (env penv))))))

; (<a class=quiet href="extsnd.html#mapchan">map-chan</a> (zcomb .8 32 '(0 0 1 10)))

;;; to impose several formants, just add them in parallel:

(define formants
  (lambda (r1 f1 r2 f2 r3 f3)
    (let ((fr1 (<a class=quiet href="clm.html#make-formant">make-formant</a> r1 f1))
	  (fr2 (<a class=quiet href="clm.html#make-formant">make-formant</a> r2 f2))
	  (fr3 (<a class=quiet href="clm.html#make-formant">make-formant</a> r3 f3)))
      (lambda (x)
	(+ (<a class=quiet href="clm.html#formant">formant</a> fr1 x)
	   (<a class=quiet href="clm.html#formant">formant</a> fr2 x)
	   (<a class=quiet href="clm.html#formant">formant</a> fr3 x))))))

; (<a class=quiet href="extsnd.html#mapchan">map-chan</a> (formants .01 900 .02 1800 .01 2700))

;;; to get a moving formant:

(define moving-formant
  (lambda (radius move)
    (let ((frm (<a class=quiet href="clm.html#make-formant">make-formant</a> radius (cadr move)))
	  (menv (<a class=quiet href="clm.html#make-env">make-env</a> :envelope move :end (<a class=quiet href="extsnd.html#frames">frames</a>))))
      (lambda (x)
        (let ((val (<a class=quiet href="clm.html#formant">formant</a> frm x)))
	  (set! (<a class=quiet href="clm.html#mus-frequency">mus-frequency</a> frm) (env menv))
	  val)))))

; (<a class=quiet href="extsnd.html#mapchan">map-chan</a> (moving-formant .01 '(0 1200 1 2400)))

;;; various "Forbidden Planet" sound effects:

(define fp
  (lambda (sr osamp osfrq)
    (let* ((os (<a class=quiet href="clm.html#make-oscil">make-oscil</a> osfrq))
	   (sr (<a class=quiet href="clm.html#make-src">make-src</a> :srate sr))
	   (len (<a class=quiet href="extsnd.html#frames">frames</a>))
	   (sf (<a class=quiet href="extsnd.html#makesamplereader">make-sample-reader</a>))
	   (out-data (<a class=quiet href="extsnd.html#makevct">make-vct</a> len)))
      (<a class=quiet href="extsnd.html#vctmap">vct-map!</a> out-data
		  (lambda () 
		    (<a class=quiet href="clm.html#src">src</a> sr (* osamp (<a class=quiet href="clm.html#oscil">oscil</a> os))
			 (lambda (dir)
			   (if (&gt; dir 0)
			       (<a class=quiet href="extsnd.html#nextsample">next-sample</a> sf)
			       (<a class=quiet href="extsnd.html#previoussample">previous-sample</a> sf))))))
      (<a class=quiet href="extsnd.html#freesamplereader">free-sample-reader</a> sf)
      (<a class=quiet href="extsnd.html#vct_to_samples">vct-&gt;samples</a> 0 len out-data))))

; (fp 1.0 .3 20)


;;; -------- shift pitch keeping duration constant
;;;
;;; both src and granulate take a function argument to get input whenever it is needed.
;;; in this case, src calls granulate which reads the currently selected file.

(define <A class=def NAME="expsrc">expsrc</a>
  (lambda (rate)
    (let* ((gr (<a class=quiet href="clm.html#make-granulate">make-granulate</a> :expansion rate))
	   (sr (<a class=quiet href="clm.html#make-src">make-src</a> :srate rate))
	   (vsize 1024)
	   (vbeg 0)
	   (v (<a class=quiet href="extsnd.html#samples_to_vct">samples-&gt;vct</a> 0 vsize))
	   (inctr 0))
      (lambda (inval)
        (<a class=quiet href="clm.html#src">src</a> sr 0.0
	  (lambda (dir)
	    (<a class=quiet href="clm.html#granulate">granulate</a> gr
	      (lambda (dir)
		(let ((val (<a class=quiet href="extsnd.html#vctref">vct-ref</a> v inctr)))
		  (set! inctr (+ inctr dir))
		  (if (&gt;= inctr vsize)
		      (begin
			(set! vbeg (+ vbeg inctr))
			(set! inctr 0)
			(<a class=quiet href="extsnd.html#samples_to_vct">samples-&gt;vct</a> vbeg vsize 0 0 v)))
		  val)))))))))

</pre>
<p>Geez, I haven't had this much fun in a long time!  Check out <a href="sndscm.html#exampdoc">examp.scm</a> and <a href="sndscm.html#sndtestdoc">snd-test.scm</a> for more.  
CLM-in-CL users will be disappointed with the CLM-in-Scheme performance; my tests indicate that
interpreted Scheme (as in Snd currently) is about 30 to 100 times slower than CLM instruments using
the run macro.  That macro now exists in Snd; see the <a href="extsnd.html#optimization">optimization</a>
variable for a brief discussion.  Currently, I can speed up most CLM-related Scheme code
by factors between 8 and 20.  This is still slightly slower than CLM, but it's certainly
an improvement!
</p>
<p>
You can load Rick Taube's CM into Snd as Scheme code:
</p>
<pre>snd -l /home/bil/test/cm-2.4.0/src/cm.scm
</pre>
<p>and all of CM is at your disposal! See also <a href="#sndwithcm">Snd and Common Music</a>.
</p>
<p>In most CLM instruments, including all those in clm-ins.scm, the assumption is that 
you're reading and writing a temp file, calling the instruments within with-sound.
The special generators snd-&gt;sample and xen-&gt;sample provide a way to redirect
the CLM input handlers (<a class=quiet href="clm.html#in-any">in-any</a> in particular) to either a Snd sound (via its index),
or an arbitrary function.
</p>
<br>

<!-- INDEX sndinstruments:Instruments -->
<table width="100%" border=1><tr><td bgcolor="lightgreen" valign="middle"><h4><A NAME="sndinstruments">Instruments</a></h4></td></tr></table>

<p>It's hard to decide what's an "instrument" in this context, but I think I'll treat
it as something that can be called as a note in a notelist (say in with-sound) and
generate its own sound.
Test 23 in snd-test.scm has a with-sound that includes most of these instruments.
</p>
<TABLE border=1 cellpadding=3>
<tr><th>Instrument</th><th>Sources</th><th>Description</th></tr>
<tr><td>anoi</td><td>clm-ins.scm</td><td>noise reduction based on P Cook's Scrubber.m</td></tr>
<tr><td>attract</td><td>clm-ins.scm</td><td>James McCarthy's choatic brass</td></tr>
<tr><td>bes-fm</td><td>clm-ins.scm</td><td>FM analog using Bessel j0 rather than sin</td></tr>
<tr><td>bigbird</td><td>bird.scm, bird.rb</td><td>more bird songs</td></tr>
<tr><td>bird</td><td>bird.scm, bird.rb</td><td>bird songs</td></tr>
<tr><td>bow</td><td>strad.scm, strad.rb</td><td>bowed string physical model (Juan Reyes, Michael Scholz)</td></tr>
<tr><td>bowstr</td><td>prc95.scm</td><td>bowed string pysical model</td></tr>
<tr><td>brass</td><td>prc95.scm</td><td>brass pysical model</td></tr>
<tr><td>cellon</td><td>clm-ins.scm</td><td>S Krupowicz's feedback FM</td></tr>
<tr><td>chain-dsps</td><td>examp.scm</td><td>instrument gets gen patch from its args</td></tr>
<tr><td>clarinet</td><td>prc95.scm</td><td>clarinet pysical model</td></tr>
<tr><td>drone, canter</td><td>clm-ins.scm</td><td>Peter Common's bagpipe</td></tr>
<tr><td>exp-snd</td><td>clm-ins.scm</td><td>granulate to the max</td></tr>
<tr><td>expfil</td><td>clm-ins.scm</td><td>granular synthesis interleaving two files</td></tr>
<tr><td>flute</td><td>prc95.scm</td><td>flute pysical model</td></tr>
<tr><td>fm-bell</td><td>clm-ins.scm, examp.rb</td><td>Mike McNabb's FM bell</td></tr>
<tr><td>fm-drum</td><td>clm-ins.scm</td><td>Jan Mattox's FM dum</td></tr>
<tr><td>fm-insect</td><td>clm-ins.scm</td><td>FM insect (katydid)</td></tr>
<tr><td>fm-noise</td><td>noise.scm, noise.rb</td><td>noise maker</td></tr>
<tr><td>fm-trumpet</td><td>clm-ins.scm</td><td>Dexter Morrill's FM trumpet</td></tr>
<tr><td>fm-violin</td><td>v.scm, v.rb, fmv.scm, sndscm.html</td><td>violin-like sounds via FM</td></tr>
<tr><td>fofins</td><td>clm-ins.scm</td><td>FOF synthesis</td></tr>
<tr><td>fullmix</td><td>clm-ins.scm</td><td>complicated mixer</td></tr>
<tr><td>freeverb</td><td>freeverb.scm</td><td>a reverberator</td></tr>
<tr><td>gong</td><td>clm-ins.scm</td><td>Paul Weineke's FM gong</td></tr>
<tr><td>gran-synth</td><td>clm-ins.scm</td><td>simple granular synthesis</td></tr>
<tr><td>graphEq</td><td>clm-ins.scm</td><td>Marco Trevisani's semi-graphical equalizer</td></tr>
<tr><td>jc-reverb</td><td>jcrev.scm, examp.rb</td><td>Chowning's old reverb</td></tr>
<tr><td>jl-reverb</td><td>clm-ins.scm</td><td>cavernous version of jc-reverb</td></tr>
<tr><td>lbj-piano</td><td>clm-ins.scm</td><td>additive synthesis piano (Doug Fulton)</td></tr>
<tr><td>maraca, big-maraca</td><td>maraca.scm</td><td>Perry Cook's maraca physical model</td></tr>
<tr><td>metal</td><td>clm-ins.scm</td><td>more FM by Perry</td></tr>
<tr><td>nrev</td><td>clm-ins.scm</td><td>Mike McNabb's reverb</td></tr>
<tr><td>p</td><td>piano.scm, piano.rb</td><td>Scott van Duyne's piano physical model</td></tr>
<tr><td>pins</td><td>clm-ins.scm</td><td>Xavier Serra SMS-style spectral modeling</td></tr>
<tr><td>pluck</td><td>clm-ins.scm</td><td>David Jaffe's Karplus-Strong (physical model) plucked string</td></tr>
<tr><td>plucky</td><td>prc95.scm</td><td>plucked string pysical model</td></tr>
<tr><td>pqw-vox</td><td>clm-ins.scm</td><td>vocal sounds from phase-quadrature waveshaping</td></tr>
<tr><td>pqw</td><td>clm-ins.scm</td><td>phase-quadrature waveshaping</td></tr>
<tr><td>resflt</td><td>clm-ins.scm</td><td>two-poles for resonances (Xavier Serra)</td></tr>
<tr><td>reson</td><td>clm-ins.scm</td><td>parallel FM creating resonances</td></tr>
<tr><td>rhodey, wurley, hammondoid</td><td>clm-ins.scm</td><td>FM stuff from Perry Cook</td></tr>
<tr><td>scm-simp</td><td>clm.html</td><td>simple sine wave instrument</td></tr>
<tr><td>scratch</td><td>clm-ins.scm</td><td>move around in sound via list of turn points and src</td></tr>
<tr><td>singer</td><td>singer.scm</td><td>Perry Cook's vocal tract physical model</td></tr>
<tr><td>spectra</td><td>clm-ins.scm</td><td>simple additive synthesis</td></tr>
<tr><td>stereo-flute</td><td>clm-ins.scm</td><td>Nicky Hind's flute physical model</td></tr>
<tr><td>touch-tone</td><td>clm-ins.scm</td><td>touch-tone telephone</td></tr>
<tr><td>tubebell</td><td>clm-ins.scm</td><td>Perry Cook's FM tubular bell</td></tr>
<tr><td>two-tab</td><td>clm-ins.scm</td><td>interpolate between two spectra</td></tr>
<tr><td>vox</td><td>clm-ins.scm</td><td>voice using "leapfrog" FM-generated formants</td></tr>
<tr><td>zc, zn, za</td><td>clm-ins.scm</td><td>interpolating delay effects</td></tr>
</TABLE>
<br><br>

<br><br>
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="sndwithcm">Snd and Common Music</a></h3></td></tr></table>

<p>You can load Common Music into Snd, but the connection to
Snd's definstrument macro is not yet as tight as it is in the Common Lisp
CLM:
</p>
<pre>
&gt; <em class=typing>(load "/home/bil/test/cm-2.4.0/src/cm.scm")</em>
<em class=listener>#&lt;unspecified&gt;</em>
&gt; <em class=typing>(load "ws.scm")</em>
<em class=listener>#&lt;unspecified&gt;</em>
&gt; <em class=typing>(definstrument (simp beg dur freq amp)
   (let* ((o (make-oscil freq))
          (st (inexact-&gt;exact (* beg (mus-srate))))
          (nd (+ st (inexact-&gt;exact (* dur (mus-srate))))))
     (run
       (lambda ()
         (do ((i st (1+ i)))
             ((= i nd))
           (outa i (* amp (oscil o)) *output*))))))</em>
<em class=listener>#&lt;unspecified&gt;</em>
&gt; <em class=typing>(formals-&gt;defobject '(simp beg dur freq amp))</em>
<em class=listener>(defobject simp () ((beg #:accessor object-time) dur freq amp) (#:parameters beg dur freq amp))</em>
&gt; <em class=typing>(defobject simp () ((beg #:accessor object-time) dur freq amp) (#:parameters beg dur freq amp))</em>
<em class=listener>#&lt;values ()&gt;</em>
&gt; <em class=typing>(define (random-fn n) (process repeat n output (new simp :beg (now) :dur .1 :freq (between 220 880) :amp .1) wait .25))</em>
<em class=listener>#&lt;unspecified&gt;</em>
&gt; <em class=typing>(events (random-fn 10) "test.clm" 0 :output "test.snd")</em>
<em class=listener>"test.clm"</em>
&gt; <em class=typing>(define hi (init-with-sound :output "test.snd"))</em>
<em class=listener>#&lt;unspecified&gt;</em>
&gt; <em class=typing>(load "test.clm")</em>
<em class=listener>#&lt;unspecified&gt;</em>
&gt; <em class=typing>(finish-with-sound hi)</em>
<em class=listener>"test.snd"</em>
</pre>


<br><br>
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="sndwithmotif">Snd and Motif</a></h3></td></tr></table>

<p>It is possible to add your own user-interface elements using the xm module
included with Snd.  'make xm' should create
a shared library named xm.so; you can load this at any time into Snd:
</p>
<pre>
&gt; <em class=typing>(define hxm (dlopen "/home/bil/snd-7/xm.so"))</em>
<em class=listener>#&lt;unspecified&gt;</em>
&gt; <em class=typing>(dlinit hxm "init_xm")</em>
<em class=listener>#t</em>
</pre>
<p>and now we have access to all of X and Motif.  Alternatively, use the
configure switch --with-static-xm, and the xm module will be included
in the base Snd image.
Here's a dialog window with a slider:</p>
<pre>
(define scale-dialog #f)
(define current-scaler 1.0)

(define (create-scale-dialog parent)
  (if (not (Widget? scale-dialog))
      (let ((xdismiss (XmStringCreate "Dismiss" XmFONTLIST_DEFAULT_TAG))
	    (xhelp (XmStringCreate "Help" XmFONTLIST_DEFAULT_TAG))
	    (titlestr (XmStringCreate "Scaling" XmFONTLIST_DEFAULT_TAG)))
	(set! scale-dialog 
	      (XmCreateTemplateDialog parent "Scaling"
                (list XmNcancelLabelString   xdismiss
		      XmNhelpLabelString     xhelp
		      XmNautoUnmanage        #f
		      XmNdialogTitle         titlestr
		      XmNresizePolicy        XmRESIZE_GROW
	              XmNnoResize            #f
		      XmNtransient           #f)))
	(XtAddCallback scale-dialog 
		       XmNcancelCallback (lambda (w context info)
					   (XtUnmanageChild scale-dialog)))
	(XtAddCallback scale-dialog 
		       XmNhelpCallback (lambda (w context info)
					 (<a class=quiet href="extsnd.html#sndprint">snd-print</a> "move the slider to affect the volume")))
	(XmStringFree xhelp)
	(XmStringFree xdismiss)
	(XmStringFree titlestr)

	(let* ((mainform 
		(XtCreateManagedWidget "formd" xmFormWidgetClass scale-dialog
                  (list XmNleftAttachment    XmATTACH_FORM
		        XmNrightAttachment   XmATTACH_FORM
		        XmNtopAttachment     XmATTACH_FORM
		        XmNbottomAttachment  XmATTACH_WIDGET
		        XmNbottomWidget      (XmMessageBoxGetChild scale-dialog XmDIALOG_SEPARATOR))))
	       (scale
		(XtCreateManagedWidget "" xmScaleWidgetClass mainform
		  (list XmNorientation XmHORIZONTAL
			XmNshowValue   #t
			XmNvalue       100
			XmNmaximum     500
			XmNdecimalPoints 2))))

      (XtAddCallback scale XmNvalueChangedCallback (lambda (w context info)
					     (set! current-scaler (/ (.value info) 100.0))))
      (XtAddCallback scale XmNdragCallback (lambda (w context info)
					     (set! current-scaler (/ (.value info) 100.0)))))))
  (XtManageChild scale-dialog))

(create-scale-dialog (cadr (<a class=quiet href="extsnd.html#mainwidgets">main-widgets</a>)))
</pre>
<p>In Ruby, this is:</p>
<pre>
$scale_dialog = false
$current_scaler = 1.0

def create_scale_dialog(parent)
  if !RWidget?($scale_dialog) 
    then
      xdismiss = RXmStringCreate("Dismiss", RXmFONTLIST_DEFAULT_TAG)
      xhelp = RXmStringCreate("Help", RXmFONTLIST_DEFAULT_TAG)
      titlestr = RXmStringCreate("Scaling", RXmFONTLIST_DEFAULT_TAG)
      $scale_dialog = RXmCreateTemplateDialog(parent, "Scaling",
                   	[RXmNcancelLabelString,  xdismiss,
                      	 RXmNhelpLabelString,    xhelp,
                      	 RXmNautoUnmanage,       false,
                      	 RXmNdialogTitle,        titlestr,
                      	 RXmNresizePolicy,       RXmRESIZE_GROW,
                      	 RXmNnoResize,           false,
                       	 RXmNtransient,          false])
      RXtAddCallback($scale_dialog, RXmNcancelCallback, 
                     Proc.new { |w, context, info| RXtUnmanageChild($scale_dialog)})
      RXtAddCallback($scale_dialog, RXmNhelpCallback, 
                     Proc.new { |w, context, info| snd_print "move the slider to affect the volume"})
      RXmStringFree xhelp
      RXmStringFree xdismiss
      RXmStringFree titlestr
      mainform = RXtCreateManagedWidget("formd", RxmFormWidgetClass, $scale_dialog,
                  	[RXmNleftAttachment,      RXmATTACH_FORM,
                         RXmNrightAttachment,     RXmATTACH_FORM,
                         RXmNtopAttachment,       RXmATTACH_FORM,
                         RXmNbottomAttachment,    RXmATTACH_WIDGET,
                         RXmNbottomWidget,        RXmMessageBoxGetChild($scale_dialog, RXmDIALOG_SEPARATOR)])
      scale = RXtCreateManagedWidget("", RxmScaleWidgetClass, mainform,
                  	[RXmNorientation, RXmHORIZONTAL,
                         RXmNshowValue,   true,
                         RXmNvalue,       100,
                         RXmNmaximum,     500,
                         RXmNdecimalPoints, 2])
      RXtAddCallback(scale, RXmNvalueChangedCallback, 
                     Proc.new { |w, context, info| $current_scaler = Rvalue(info) / 100.0})
      RXtAddCallback(scale, RXmNdragCallback, 
                     Proc.new { |w, context, info| $current_scaler = Rvalue(info) / 100.0})
      RXtManageChild $scale_dialog
    end
end

$Snd_widgets = main_widgets()
create_scale_dialog $Snd_widgets[1]
</pre>
<p>All of Snd is at your disposal once this module is loaded.
The next function installs our own file filtering procedure into the File:Open dialog (it uses
match-sound-files from extensions.scm):
</p>
<pre>
(define (install-searcher proc)
  (define (XmString-&gt;string str)
    (cadr (XmStringGetLtoR str XmFONTLIST_DEFAULT_TAG)))
  (define (XmStringTable-&gt;list st len)
    (XmStringTableUnparse st len #f XmCHARSET_TEXT XmCHARSET_TEXT #f 0 XmOUTPUT_ALL))
  (define (list-&gt;XmStringTable strs)
    (XmStringTableParseStringArray strs (length strs) #f XmCHARSET_TEXT #f 0 #f))
  (XtSetValues (let ((m (<a class=quiet href="extsnd.html#openfiledialog">open-file-dialog</a> #f)))
                         ; make sure the dialog exists
		  (list-ref (<a class=quiet href="extsnd.html#dialogwidgets">dialog-widgets</a>) 6))
		(list XmNfileSearchProc                             ; set dialog file search procedure
		       (lambda (widget info)
			 (let* ((dir (XmString-&gt;string (dir info))) ; directory string
				(files (<a class=quiet href="sndscm.html#exmatchsoundfiles">match-sound-files</a> proc dir)) ; list of matching files
				(fileTable (list-&gt;XmStringTable      ; XmStringTable for XmNfileListItems
                                             (map (lambda (n)        ; every file needs prepended dir
                                                    (string-append dir n)) 
                                                  files))))
			   (XtSetValues widget                      ; change the list of files
					 (list XmNfileListItems fileTable
					       XmNfileListItemCount (length files)
					       XmNlistUpdated #t)))))))

;(install-searcher (lambda (file) (= (<a class=quiet href="extsnd.html#soundsrate">mus-sound-srate</a> file) 44100)))
;(install-searcher (lambda (file) (= (<a class=quiet href="extsnd.html#soundchans">mus-sound-chans</a> file) 4)))
</pre>
<p>Now click the 'Filter' button to see only those files that fit the procedure in
the dialog's files list.  See snd-motif.scm and popup.scm.
</p>
<br>

<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="sndwithgtk">Snd and Gtk+</a></h3></td></tr></table>

<p>
Here's the scale-dialog in xg/gtk:
</p>
<pre>
(define scale-dialog #f)
(define current-scaler 1.0)

(define* (g_signal_connect obj name func #:optional data)
  ;; slightly obsolete ...
  (g_signal_connect_closure_by_id 
   (list 'gpointer (cadr obj))
   (g_signal_lookup name (G_OBJECT_TYPE (GTK_OBJECT obj)))
   0
   (g_cclosure_new func data (list 'GClosureNotify 0))
   #f))

(define (create-scale-dialog parent)
  (if (not scale-dialog)
      (begin
	(set! scale-dialog (gtk_dialog_new))
	(g_signal_connect scale-dialog "delete-event"
			     (lambda (w ev info)
			       (gtk_widget_hide w)))
	(gtk_window_set_title (GTK_WINDOW scale-dialog) "Scale")
	(gtk_widget_realize scale-dialog)
	(let ((dismiss (gtk_button_new_with_label "Dismiss"))
	      (help (gtk_button_new_with_label "Help")))
	  (gtk_box_pack_start (GTK_BOX (.action_area (GTK_DIALOG scale-dialog))) dismiss #t #t 4)
	  (gtk_box_pack_end (GTK_BOX (.action_area (GTK_DIALOG scale-dialog))) help #t #t 4)	
	  (g_signal_connect dismiss "clicked"
			       (lambda (w info)
				 (gtk_widget_hide scale-dialog)))
	  (g_signal_connect help "clicked"
			       (lambda (w info)
				 (<a class=quiet href="extsnd.html#helpdialog">help-dialog</a> "Scaler Dialog" "move the slider to affect the volume")))
	  (gtk_widget_show dismiss)
	  (gtk_widget_show help)
	  (let* ((adj (gtk_adjustment_new 0.0 0.0 1.01 0.01 0.01 .01))
		 (scale (gtk_hscale_new (GTK_ADJUSTMENT adj))))
	    (gtk_range_set_update_policy (GTK_RANGE (GTK_SCALE scale)) GTK_UPDATE_CONTINUOUS)
	    (gtk_scale_set_draw_value (GTK_SCALE scale) #t)
	    (gtk_scale_set_digits (GTK_SCALE scale) 2)
	    (g_signal_connect adj "value_changed"
				 (lambda (wadj info)
				   (set! current-scaler (.value (GTK_ADJUSTMENT wadj)))))
	    (gtk_box_pack_start (GTK_BOX (.vbox (GTK_DIALOG scale-dialog))) scale #f #f 6)
	    (gtk_widget_show scale)))))
  (gtk_widget_show scale-dialog))

(create-scale-dialog (cadr (<a class=quiet href="extsnd.html#mainwidgets">main-widgets</a>)))
</pre>
<p>The only change from the C code is the addition of GTK_ADJUSTMENT in the scale value_changed
callback -- currently the xg module assumes the first argument to the two-argument callback is
a GtkWidget, so we have to cast a GtkAdjustment back to its original type.
</p>

<br>

<!-- INDEX sndwithnogui:Scripting -->
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="sndwithnogui">Snd with no GUI and scripting</a></h3></td></tr></table>

<p>If Snd is built without a graphical user interface (by specifying
--with-no-gui to configure),
it runs Guile's "repl" (read-eval-print loop), or Ruby's equivalent, with input from stdin.  All
the non-interface related functions are available, so you can do things
like:
</p>
<pre>
<em class=listener>snd&gt;</em><em class=typing> (new-sound "new.snd")</em>
<em class=listener>0</em>
<em class=listener>snd&gt;</em><em class=typing> (load "v.scm")</em>
<em class=listener>snd&gt;</em><em class=typing> (fm-violin 0 1 440 .1)</em>
<em class=listener>-1</em>
<em class=listener>snd&gt;</em><em class=typing> (frames 0)</em>
<em class=listener>22050</em>
<em class=listener>snd&gt;</em><em class=typing> (play)</em>
<em class=listener>#t</em>
<em class=listener>snd&gt;</em><em class=typing> (exit)</em>
</pre>
<p>Guile's repl has its own error handlers, different from the
normal Snd handlers; name completion, if it exists at all,
won't complete Snd names; there are undoubtedly other
differences that I haven't noticed.  
</p>
<p>
Since this version of
Snd is the same as the guile program with Snd loaded, you
can treat it as a scripting engine.  For example,
if you have an executable file with:
</p>
<pre>
#!/home/bil/test/snd-7/snd -l
!#
(define a-test 32)
(display "hiho")
(newline)
</pre>
<p>it can be executed just like any such script.
</p>
<pre>
/home/bil/test/snd-7/ script
hiho
:a-test
32
:(<a class=quiet href="extsnd.html#exit">exit</a>)
/home/bil/test/snd-7/ 
</pre>
<p>The difference between this use of Snd, and using guile itself
for scripts is that Snd uses the -l switch where guile would use -s.
As noted above, you can use the -e switch to use Snd as a pure
command-line program, and, of course, (<a class=quiet href="extsnd.html#exit">exit</a>) to drop back to the shell.
Here's a script that doubles every sample in "oboe.snd" and
writes the result as "test.snd":
</p>
<pre>
#!/home/bil/test/snd-7/snd -l
!#
(<a class=quiet href="extsnd.html#opensound">open-sound</a> "oboe.snd")
(<a class=quiet href="extsnd.html#scaleby">scale-by</a> 2.0)
(<a class=quiet href="extsnd.html#savesoundas">save-sound-as</a> "test.snd")
(<a class=quiet href="extsnd.html#exit">exit</a>)
</pre>
<p>The functions <b>script-args</b> and <b>script-arg</b> can be used
to access the script's arguments, and if necessary (if not exiting)
tell Snd to ignore arguments.  script-args returns a list of strings
giving the arguments.  The first two are always "-l" and the script
file name. The current argument is (<a class=quiet href="extsnd.html#scriptarg">script-arg</a>).  If you set this to
a higher value, Snd will subsequently ignore the intevening arguments
as it scans the startup arguments (see snd-test.scm).
</p>
<pre>
#!/home/bil/test/snd-7/snd -l
!#
(if (= (length (<a class=quiet href="extsnd.html#scriptargs">script-args</a>)) 2) ;i.e. ("-l" "script")
  (display "usage: script file-name...\n")
  (begin
    (<a class=quiet href="extsnd.html#opensound">open-sound</a> (list-ref (<a class=quiet href="extsnd.html#scriptargs">script-args</a>) (+ (<a class=quiet href="extsnd.html#scriptarg">script-arg</a>) 1)))
    (<a class=quiet href="extsnd.html#scaleby">scale-by</a> 2.0)
    (<a class=quiet href="extsnd.html#savesoundas">save-sound-as</a> "test.snd")))
(<a class=quiet href="extsnd.html#exit">exit</a>)
</pre>
<p>This either grumbles if no argument is given,
or scales its argument sound by 2.0:
</p>
<pre>
script pistol.snd
</pre>
<p>And obviously we can run through the entire argument list,
doubling all the sounds or whatever by using a do loop --
the following displays all the comments it finds:
</p>
<pre>
#!/home/bil/cl/snd -l
!#
(use-modules (ice-9 format))
(if (= (length (<a class=quiet href="extsnd.html#scriptargs">script-args</a>)) 2) ;i.e. ("-l" "script")
  (display "usage: script file-name...\n")
  (do ((arg (+ (<a class=quiet href="extsnd.html#scriptarg">script-arg</a>) 1) (1+ arg)))
      ((= arg (length (<a class=quiet href="extsnd.html#scriptargs">script-args</a>))))
    (let ((name (list-ref (<a class=quiet href="extsnd.html#scriptargs">script-args</a>) arg)))
      (display (format #f "~A: ~A~%" name (<a class=quiet href="extsnd.html#soundcomment">mus-sound-comment</a> name))))))
(<a class=quiet href="extsnd.html#exit">exit</a>)
</pre>
<p>
Say we save this as the file "comments".</p>
<pre>
/home/bil/cl/comments *.snd
</pre>
<p>If you like, you can use env:</p>
<pre>
#!/usr/bin/env snd
!#
</pre>
<p>But if that works, so will:</p>
<pre>
#!snd -l
!#
</pre>
<p>
This scripting mechanism actually will work in any version of Snd;
to keep the Snd window from popping up, use the -b (-batch) switch in
place of -l.
Here's another script; it looks for any sounds that are longer
than 40 seconds in duration, and truncates them to 40 seconds:
</p>
<pre>
#!/usr/local/bin/snd -l
!#
(if (= (length (<a class=quiet href="extsnd.html#scriptargs">script-args</a>)) 2)
  (display "usage: trunc.scm file-name...\n")
  (do ((arg (+ (<a class=quiet href="extsnd.html#scriptarg">script-arg</a>) 1) (1+ arg)))
      ((= arg (length (<a class=quiet href="extsnd.html#scriptargs">script-args</a>))))
    (let* ((name (list-ref (<a class=quiet href="extsnd.html#scriptargs">script-args</a>) arg)))
      (if (&gt; (<a class=quiet href="extsnd.html#soundduration">mus-sound-duration</a> name) 40.0)
	  (let* ((ind (<a class=quiet href="extsnd.html#opensound">open-sound</a> name)))
	    (set! (<a class=quiet href="extsnd.html#frames">frames</a> ind) (* 40 (<a class=quiet href="extsnd.html#srate">srate</a> ind)))
	    (<a class=quiet href="extsnd.html#savesound">save-sound</a> ind)
	    (<a class=quiet href="extsnd.html#closesound">close-sound</a> ind))))))
(<a class=quiet href="extsnd.html#exit">exit</a>)
</pre>
<p>Here's a sndplay replacement script:</p>
<pre>
#!snd -b
!#
(<a class=quiet href="extsnd.html#playandwait">play-and-wait</a> (list-ref (<a class=quiet href="extsnd.html#scriptargs">script-args</a>) (+ (<a class=quiet href="extsnd.html#scriptarg">script-arg</a>) 1)))
(<a class=quiet href="extsnd.html#exit">exit</a>)
</pre>
<p>And here's a script that splits a multi-channel file
into a bunch of mono files:
</p>
<pre>
#!snd -b
!#
(if (= (length (<a class=quiet href="extsnd.html#scriptargs">script-args</a>)) 2)
  (display "usage: split.scm filename\n")
  (let* ((name (list-ref (<a class=quiet href="extsnd.html#scriptargs">script-args</a>) (1+ (<a class=quiet href="extsnd.html#scriptarg">script-arg</a>))))
	 (chns (<a class=quiet href="extsnd.html#soundchans">mus-sound-chans</a> name)))
    (if (&gt; chns 1)
	(let ((ind (<a class=quiet href="extsnd.html#opensound">open-sound</a> name)))
	  (do ((i 0 (1+ i)))
	      ((= i chns))
	    (display (format #f "~A.~D " name i))
	    (<a class=quiet href="extsnd.html#savesoundas">save-sound-as</a> (format #f "~A.~D" name i)
			   ind
			   (<a class=quiet href="extsnd.html#headertype">header-type</a> ind)
			   (<a class=quiet href="extsnd.html#dataformat">data-format</a> ind)
			   (<a class=quiet href="extsnd.html#srate">srate</a> ind)
			   i))
	  (<a class=quiet href="extsnd.html#closesound">close-sound</a> ind)))))
(<a class=quiet href="extsnd.html#exit">exit</a>)
</pre>
<br>

<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="sndandruby">Snd with Ruby</a></h3></td></tr></table>

<p>Ruby is an extension language described as an "object-oriented Perl".
It provides a different syntax from that of Guile/Scheme.  In Ruby, all
the "-" are "_", "-&gt;" is "2", hooks and memo_sound have "$" prepended
(since they are global variables from Ruby's point of view), and all the constants are capitalized
(e.g. Autocorrelation).  The generalized set! functions are replaced
by "set_" plus the base name (e.g. set_window_width), with arguments
reordered in some cases to place the optional values after the new value.  That is,
<code>(set! (<a class=quiet href="extsnd.html#sync">sync</a> snd) 1)</code> becomes <code>set_sync(1, snd)</code>.
Hooks in Ruby (which have little or nothing to do with Ruby's "hookable variables")
are just procedures or nil, not lists of procedures as in Guile.
Here's the Ruby version of the init file given
above:
</p>
<pre>
set_window_width 800
set_window_height 500

set_listener_font "9x15"
set_axis_numbers_font "9x15"

set_show_mix_waveforms true
set_trap_segfault false
set_show_backtrace true
set_show_indices true

set_listener_prompt ":"
show_listener

beige = make_color 0.96, 0.96, 0.86
blue = make_color 0, 0, 1
set_selected_graph_color beige
set_selected_data_color blue
</pre>
<p>Procedures are created via Proc.new, so to set the open-hook to print the
file name,
</p>
<pre>
&gt;<em class=typing>$open_hook = Proc.new { |name| snd_print name }</em>
<em class=listener>#&lt;Proc:0x40221b84&gt;</em>
&gt;<em class=typing>open_sound "oboe.snd"</em>
<em class=listener>/home/bil/cl/oboe.snd
0</em>
</pre>
<p>(The trailing "0" is the result of open_sound).
The Guile hook list support procedures aren't included in Ruby --
simply set the variable to the procedure you want, or false to clear it.
</p>
<p>Vcts and sound-data objects mixin "Comparable" and "Enumerable", and respond to various array-like methods:
</p>
<pre>
&gt;<em class=typing>v1 = make_vct 4</em>
<em class=listener>#&lt;vct[len=4]: 0.000 0.000 0.000 0.000&gt;</em>
&gt;<em class=typing>v1[3] = 1.0</em>
<em class=listener>1.0</em>
&gt;<em class=typing>v1.sort</em>
<em class=listener>0.00.00.01.0</em> # I don't know why it prints this way but ...
&gt;<em class=typing>v1</em>
<em class=listener>#&lt;vct[len=4]: 0.000 0.000 0.000 1.000&gt;</em>
&gt;<em class=typing>v1.max</em>
<em class=listener>1.0</em>
</pre>
<p>I'm thinking about making classes for things like sounds; you could then
have <code>sound + sound</code> to mix, or <code>sound * 2</code> to scale it,
a given channel could be treated as an array, accessed via <code>sound[0, 12345]</code> and so on,
These are extremely easy to add, but I'd like to coordinate this with Guile's
object system.  Keywords, CLM generic functions, and optional arguments work as in Scheme:
</p>
<pre>
&gt;<em class=typing>osc = make_oscil(:frequency, 440)</em>
<em class=listener>oscil freq: 440.000Hz, phase: 0.000</em>
&gt;<em class=typing>oscil osc</em>
<em class=listener>0.0</em>
&gt;<em class=typing>oscil osc</em>
<em class=listener>0.1250506192</em>
&gt;<em class=typing>osc.frequency</em>
<em class=listener>440.0</em>
</pre>
<p>Lists (from the Scheme point of view) are arrays (vectors) in Ruby, and various
built-in Scheme functions such as car aren't predefined, so to set up the focusing
hooks as described in <a href="extsnd.html#mouseentergraphhook">mouse-enter-graph-hook</a>
we need to do something along these lines:
</p>
<pre>
def car(v)
  v[0]
end

$mouse_enter_graph_hook = Proc.new {|snd, chn| 
			            if sound? snd then
			               focus_widget car channel_widgets snd, chn
                                    end 
                                   }

$mouse_enter_listener_hook = Proc.new { |widget| 
                                        focus_widget widget 
                                      }
</pre>
<p>Here's one more example, a translation of display-energy in draw.scm:
</p>
<pre>
def display_energy(snd, chn)
  ls = left_sample
  rs = right_sample
  data1 = make_graph_data(snd, chn)
  data = data1
  if not vct? data
    data = data1[1]
  end
  len = vct_length data
  sr = srate snd
  y_max = y_zoom_slider(snd, chn)
  vct_multiply!(data, data)
  graph(data, "energy", ls / sr, rs / sr, 0.0, y_max * y_max, snd, chn, false)
  end

# $lisp_graph_hook = Proc.new {|snd, chn| display_energy(snd, chn)}
</pre>
<p>
In Ruby you make a symbol by prepending ":", so Guile's
</p>
<pre>
(list 'KeySym (char-&gt;integer #\F))
</pre> 
<p>becomes</p>
<pre>
[:KeySym, ?F]
</pre>

<p>In the listener, everything is line-oriented (that is, I'm not trying to
catch incomplete expressions).  And it appears that in Ruby, variables defined
within a file are considered local to that file(?).
The save state mechanism is incomplete, but the basic stuff works.
The RubyInline module might serve as a run-macro replacement.
My very informal timing tests indicate that
Guile and Ruby run at the same speed.
Michael Scholz has translated many of the Scheme files to Ruby -- see
any of the .rb files.
</p>
<br>

<!-- INDEX sndandladspa:Plugins -->
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="sndandladspa">Snd and LADSPA Plugins</a></h3></td></tr></table>

<pre>
  <a class=def name="initladspa">init-ladspa</a>
  <a class=def name="listladspa">list-ladspa</a>
  <a class=def name="analyseladspa">analyse-ladspa</a> library plugin
  <a class=def name="ladspadescriptor">ladspa-descriptor</a> library plugin
  <a class=def name="applyladspa">apply-ladspa</a> reader data duration origin

  <em class=emdef>ladspa-instantiate</em> descriptor srate
  <em class=emdef>ladspa-activate</em> descriptor handle
  <em class=emdef>ladspa-deactivate</em> descriptor handle
  <em class=emdef>ladspa-cleanup</em> descriptor handle
  <em class=emdef>ladspa-connect-port</em> descriptor handle port vct
  <em class=emdef>ladspa-run</em> descriptor handle count
  <em class=emdef>ladspa-run-adding</em> descriptor handle count
  <em class=emdef>ladspa-set-run-adding-gain</em> descriptor handle gain
</pre>

<p>Richard Furse has provided a module to support LADSPA plugins in Snd.
Here is his documentation:</p>
<pre>
Supporting functions are:

	(init-ladspa)

	Performs a search of LADSPA_PATH for plugins, doesn't need to be called 
as LADSPA automatically initialises on first use however can be used to 
reinitialise if new plugins have arrived.

	(list-ladspa)

	Returns a list of lists where each inner list contains a string to 
identify the plugin library and a string to identify the plugin type within 
the library.

	(analyse-ladspa plugin-library plugin-type)

	Returns a list of assorted data about a particular plugin including a 
list of port descriptions. plugin-library and plugin-type are as provided 
by list-ladspa.

The main function is:

	(apply-ladspa reader (plugin-library plugin-type [param1 [param2 ...]]) samples origin)

	Applies a LADSPA plugin to a block of samples. 
An example call to apply the low-pass-filter in the CMT plugin library is 
(apply-ladspa (<a class=quiet href="extsnd.html#makesamplereader">make-sample-reader</a> 0) (list "cmt" "lpf" 1000) 10000 "origin").
</pre>
<p>Dave Phillips in <a href="http://www.oreillynet.com/pub/a/linux/2001/02/02/ladspa.html">Linux Audio Plug-Ins: A Look Into LADSPA</a> adds this:
</p>
<pre>
  (apply-ladspa (<a class=quiet href="extsnd.html#makesamplereader">make-sample-reader</a> 57264) (list "cmt" "delay_5s" .3 .5) 32556 "ibm.wav")
</pre>
<p>
"This sequence tells Snd to read a block of 32556 samples from the ibm.wav file, starting at sample number 57264,
 and apply the delay_5s LADSPA plug-in (Richard Furse's delay plug-in, also found in cmt.so) with a delay time of
.3 seconds and a 50/50 dry/wet balance."
</p>
<p>To help Snd find the plugin library, set either the Snd variable <a href="extsnd.html#ladspadir">ladspa-dir</a> or the environment variable LADSPA_PATH
to the directory.
If, for example,
cmt.so is in /usr/local/lib/ladspa, (and you're using tcsh), then
</p>
<pre>
  setenv LADSPA_PATH /usr/local/lib/ladspa
</pre>
<p>or</p>
<pre>
  (set! (ladspa-dir) "/usr/local/lib/ladspa")
</pre>
<p>Snd plugins may have any number of inputs and outputs; if more
than one input is required, the first argument to apply-ladspa should be a list of readers:
</p>
<pre>
  (apply-ladspa (list (<a class=quiet href="extsnd.html#makesamplereader">make-sample-reader</a> 0 0 0)  ;chan 0
                      (<a class=quiet href="extsnd.html#makesamplereader">make-sample-reader</a> 0 0 1)) ;chan 1
                (list "cmt" "freeverb3" 0 .5 .5 .5 .5 .5) 
                100000 "freeverb")
</pre>
<p><a name="ladspachannel"></a>The "regularized" version of apply-ladspa could be defined:
</p>
<table border=1 cellpadding=5><tr><td bgcolor="GhostWhite"><pre>
(define* (ladspa-channel ladspa-data #:optional nbeg ndur nsnd nchn nedpos)
  (let* ((beg (or nbeg 0)) 
	 (snd (or nsnd (<a class=quiet href="extsnd.html#selectedsound">selected-sound</a>) (car (<a class=quiet href="extsnd.html#sounds">sounds</a>))))
	 (chn (or nchn (<a class=quiet href="extsnd.html#selectedchannel">selected-channel</a>)))
	 (dur (or ndur (- (<a class=quiet href="extsnd.html#frames">frames</a> snd chn) beg)))
	 (edpos (or nedpos current-edit-position))
	 (reader (<a class=quiet href="extsnd.html#makesamplereader">make-sample-reader</a> beg snd chn 1 edpos)))
    (<em class=red>apply-ladspa</em> reader ladspa-data dur "apply-ladspa")
    (<a class=quiet href="extsnd.html#freesamplereader">free-sample-reader</a> reader)))
</pre></td></tr></table>
<p>There are also functions to access the LADSPA descriptor directly:
</p>
<pre>
(define ptr (ladspa-descriptor "amp" "amp_mono"))
(.Label ptr)
    "amp_mono"
(.Name ptr)
    "Mono Amplifier"
(.Copyright ptr)
    "None"
(.Maker ptr)
    "Richard Furse (LADSPA example plugins)"
(.Properties ptr)
    4
(.UniqueID ptr)
    1048
(.PortNames ptr)
    ("Gain" "Input" "Output")
(.PortRangeHints ptr)
    ((593 0.0 0.0) (0 0.0 0.0) (0 0.0 0.0))
(.PortCount ptr)
    3
(.PortDescriptors ptr)
    (5 9 10)
(logand (cadr (.PortDescriptors ptr)) LADSPA_PORT_INPUT)
    1
</pre>
<p>See ladspa.h for full details. We could replace analyse-ladspa using these functions:
</p>
<table border=1 cellpadding=5><tr><td bgcolor="GhostWhite"><pre>
(define (analyze-ladspa library label)
  (let* ((descriptor (<em class=red>ladspa-descriptor</em> library label))
	 (data '())
	 (names (.PortNames descriptor))
	 (hints (.PortRangeHints descriptor))
	 (descriptors (.PortDescriptors descriptor))
	 (name (.Name descriptor))
	 (maker (.Maker descriptor))
	 (copy (.Copyright descriptor)))
    (for-each
     (lambda (port ranges port-name)
       (if (and (not (= (logand port LADSPA_PORT_CONTROL) 0))
		(not (= (logand port LADSPA_PORT_INPUT) 0)))
	   (let ((ldata '())
		 (hint (car ranges))
		 (lo (cadr ranges))
		 (hi (caddr ranges)))
	     (if (not (= (logand hint LADSPA_HINT_TOGGLED) 0)) (set! ldata (cons "toggle" ldata)))
	     (if (not (= (logand hint LADSPA_HINT_LOGARITHMIC) 0)) (set! ldata (cons "logarithmic" ldata)))
	     (if (not (= (logand hint LADSPA_HINT_INTEGER) 0)) (set! ldata (cons "integer" ldata)))
	     (if (not (= (logand hint LADSPA_HINT_SAMPLE_RATE) 0)) (set! ldata (cons "sample_rate" ldata)))
	     (if (not (= (logand hint LADSPA_HINT_BOUNDED_ABOVE) 0)) 
		 (begin
		   (set! ldata (cons hi ldata))
		   (set! ldata (cons "maximum" ldata))))
	     (if (not (= (logand hint LADSPA_HINT_BOUNDED_BELOW) 0) )
		 (begin
		   (set! ldata (cons lo ldata))
		   (set! ldata (cons "minimum" ldata))))
	     (set! ldata (cons port-name ldata))
	     (set! data (cons ldata data)))))
     descriptors hints names)
    (append (list name maker copy) data)))
</pre></td></tr></table>
<p>Here's a function that processes a channel of data through a plugin, sending the 
data directly to the DAC:
</p>
<table border=1 cellpadding=5><tr><td bgcolor="GhostWhite"><pre>
(define* (ladspa-it library label #:rest plugin-parameters)
  ;; (ladspa-it "cmt" "delay_5s" .3 .5)
  (init-ladspa)
  (let* ((descriptor (ladspa-descriptor library label))
	 (handle (ladspa-instantiate descriptor (<a class=quiet href="extsnd.html#srate">srate</a>)))
	 (block-size 256)
	 (in-block (<a class=quiet href="extsnd.html#makevct">make-vct</a> block-size))
	 (out-block (<a class=quiet href="extsnd.html#makevct">make-vct</a> block-size))
	 (len (<a class=quiet href="extsnd.html#frames">frames</a>))
	 (data (<a class=quiet href="extsnd.html#makesounddata">make-sound-data</a> 1 block-size))
	 (audio-port (<a class=quiet href="extsnd.html#musaudioopenoutput">mus-audio-open-output</a> mus-audio-default (<a class=quiet href="extsnd.html#srate">srate</a>) 1 mus-lshort (* block-size 2))))
  (dynamic-wind
   (lambda ()
     (let ((count 0))
       (for-each 
	(lambda (port)
	  (if (not (= (logand port LADSPA_PORT_CONTROL) 0))
	      (let ((parameter (<a class=quiet href="extsnd.html#makevct">make-vct</a> 1 (car plugin-parameters))))
		(set! plugin-parameters (cdr plugin-parameters))
		(ladspa-connect-port descriptor handle count parameter))
	      (if (not (= (logand port LADSPA_PORT_INPUT) 0))
		  (ladspa-connect-port descriptor handle count in-block)
		  (ladspa-connect-port descriptor handle count out-block)))
	  (set! count (1+ count)))
	(.PortDescriptors descriptor))))
   (lambda ()
     (ladspa-activate descriptor handle)
     (do ((i 0 (+ i block-size)))
	 ((&gt;= i len))
       (<a class=quiet href="extsnd.html#samples_to_vct">samples-&gt;vct</a> i block-size #f #f in-block)
       (ladspa-run descriptor handle block-size)
       (<a class=quiet href="extsnd.html#vct2sounddata">vct-&gt;sound-data</a> out-block data 0)
       (<a class=quiet href="extsnd.html#musaudiowrite">mus-audio-write</a> audio-port data block-size)))
   (lambda ()
     (ladspa-deactivate descriptor handle)
     (<a class=quiet href="extsnd.html#musaudioclose">mus-audio-close</a> audio-port)
     (ladspa-cleanup descriptor handle)))))
</pre></td></tr></table>
<p>For a Ladspa GUI builder, see <a href="sndscm.html#ladspadoc">ladspa.scm</a>.
One slight "gotcha"
in this area: the Snd configuration switch --with-doubles causes "vcts" to
be arrays of doubles, but Ladspa plugins expect to see arrays of floats.
This is a problem only if you're calling ladpsa-connect-port yourself.
</p>
<br>

<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="sndandx">Driving Snd remotely</a></h3></td></tr></table>

<p>It is possible to send Snd arbitrary Scheme or Ruby code from any other program;
see the program sndctrl.c.  Snd has two X window properties:
"SND_VERSION" and "SND_COMMAND"; the former is the Snd version (a date),
and the latter is the communication path for other programs.  Any time
such a program changes the SND_COMMAND property, Snd notices and evaluates
the new value (as a string, as if typed in the Snd listener).  To get
a response from Snd, use <code>(set! (window-property consat name) command)</code> where
<i>consat</i> is the property name Snd should search for (to find the sending window), 
<i>name</i> is the property to change (the X window property that Snd will change), and 
<i>command</i> is the string
that replaces the current property value (which Snd will evaluate).
CLM's communication
with Snd function sends Snd this string:</p>
<pre>
"(set! (<a class=quiet href="extsnd.html#windowproperty">window-property</a> \"CLM_VERSION\" \"CLM_COMMAND\") " str ")"
</pre>
<p>where <i>str</i> is the form to be evaluated within Snd.  It then waits
for a change to the CLM_COMMAND property, returning its value to the
user. The send-snd function itself, similarly, looks for SND_VERSION and
sets SND_COMMAND to <i>str</i>, which Snd subsequently notices.
</p>
<br>

<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="sndandgl">Snd and OpenGL</a></h3></td></tr></table>

<p>Snd can be used in conjunction with OpenGL.  If it is configured
with the switch --with-gl or --with-just-gl, the top level Snd shell
is setup to handle OpenGL graphics; the GLXContext is (snd-glx-context).
The GL-to-Scheme bindings are in gl.c, and follow the same name and type
conventions of the Motif bindings in xm.c.
Any of the Snd drawing area widgets (or your own) can receive GL graphics
commands.  Here is a translation of the SGI/xjournal glxmotif
program:
</p>
<table border=1 cellpadding=5><tr><td bgcolor="GhostWhite"><pre>
(define (draw-it)
  (glXMakeCurrent (XtDisplay (cadr (<a class=quiet href="extsnd.html#mainwidgets">main-widgets</a>))) 
		  (XtWindow (car (<a class=quiet href="extsnd.html#channelwidgets">channel-widgets</a>)))
		  (snd-glx-context))
  (glEnable GL_DEPTH_TEST)
  (glDepthFunc GL_LEQUAL)
  (glClearDepth 1.0)
  (glClearColor 0.0 0.0 0.0 0.0)
  (glLoadIdentity)
  (gluPerspective 40.0 1.0 10.0 200.0)
  (glTranslatef 0.0 0.0 -50.0)
  (glRotatef -58.0 0.0 1.0 0.0)
  (let ((vals (XtVaGetValues (car (<a class=quiet href="extsnd.html#channelwidgets">channel-widgets</a>)) (list XmNwidth 0 XmNheight 0))))
    (glViewport 0 0 (list-ref vals 1) (list-ref vals 3)))
  (glClear (logior GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))
  (glBegin GL_POLYGON)
  (glColor3f 0.0 0.0 0.0)   (glVertex3f -10.0 -10.0 0.0)
  (glColor3f 0.7 0.7 0.7)   (glVertex3f 10.0 -10.0 0.0)
  (glColor3f 1.0 1.0 1.0)   (glVertex3f -10.0 10.0 0.0)
  (glEnd)
  (glBegin GL_POLYGON)
  (glColor3f 1.0 1.0 0.0)   (glVertex3f 0.0 -10.0 -10.0)
  (glColor3f 0.0 1.0 0.7)   (glVertex3f 0.0 -10.0 10.0)
  (glColor3f 0.0 0.0 1.0)   (glVertex3f 0.0 5.0 -10.0)
  (glEnd)
  (glBegin GL_POLYGON)
  (glColor3f 1.0 1.0 0.0)   (glVertex3f -10.0 6.0 4.0)
  (glColor3f 1.0 0.0 1.0)   (glVertex3f -10.0 3.0 4.0)
  (glColor3f 0.0 0.0 1.0)   (glVertex3f 4.0 -9.0 -10.0)
  (glColor3f 1.0 0.0 1.0)   (glVertex3f 4.0 -6.0 -10.0)
  (glEnd)
  (glXSwapBuffers (XtDisplay (cadr (<a class=quiet href="extsnd.html#mainwidgets">main-widgets</a>))) 
		  (XtWindow (car (<a class=quiet href="extsnd.html#channelwidgets">channel-widgets</a>))))
  (glFlush))
</pre></td></tr></table>
<br>
<p>See snd-gl.scm.
</p>
<br>
<table border>
<tr><td colspan=2><center>GL spectrogram</center></td></tr>
<tr><td colspan=2>
<img src="gl1.png" alt="now.snd GL spectrogram">
</td></tr></table>
<br>

<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="sndandgdb">Snd and gdb</a></h3></td></tr></table>

<p>Here are some gdb functions (for your ~/.gbdinit file) that might
come in handy:
</p>
<pre>
define gp
set gdb_print($arg0)
print gdb_output
end
document gp
Executes (object-&gt;string arg): gp memo_sound =&gt; #f
end

define ge
call gdb_read($arg0)
call gdb_eval(gdb_result)
set gdb_print(gdb_result)
print gdb_output
end
document ge
Executes (print (eval (read arg))): ge "(+ 1 2)" =&gt; 3
end

define gh
call g_help(scm_str2symbol($arg0), 20)
set gdb_print($1)
print gdb_output
end
document gh
Prints help string for arg: gh "enved-target"
end
</pre>
<p>SCM values are displayed as integers in gdb, so say
Snd halts and you notice it's loading some unknown file:
</p>
<pre>
#32 0x081ae8f4 in scm_primitive_load (filename=1112137128) at load.c:129
</pre>
<p>You can get the file name with gp:
</p>
<pre>
(gdb) gp 1112137128
$1 = 0
$2 = 0x40853fac "\"/home/bil/test/share/guile/1.5.0/ice-9/session.scm\""
</pre>
<p>
If you have a pointer to a CLM generator, you can use:
</p>
<pre>
p mus_describe(arg)  --  show the outsider's view of arg
p mus_inspect(arg)  --  show every internal field of arg
</pre>
<p>The ge function can show current Snd state:</p>
<pre>
(gdb) ge "(<a class=quiet href="extsnd.html#epsfile">eps-file</a>)"
$5 = 0
$6 = 0
$7 = 0
$8 = 0x8296cf0 "\"snd.eps\""
</pre>

<br>

<center>
<table border=1><tr><td>
<table bgcolor="aliceblue" border=0 cellspacing=8><tr><td><small>related documentation:</small></td><td><small><a href="snd.html">snd.html</a></small></td><td><small><a href="extsnd.html">extsnd.html</a></small></td><td><small><a href="clm.html">clm.html</a></small></td><td><small><a href="sndlib.html">sndlib.html</a></small></td><td><small><a href="sndscm.html">sndscm.html</a></small></td><td><small><a href="libxm.html">libxm.html</a></small></td><td><small><a href="index.html">index.html</a></small></td></tr></table>
</td></tr></table>
</center>
</body></html>
