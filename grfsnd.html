<html>
<head>
<title>Snd Customization and Extension</title>
<style type="text/css">
<!-- 
	EM.red {color:red; font-style:normal}
        EM.typing {color:maroon; font-style: normal}
        EM.listener {color:darkblue; font-style: normal}
        EM.tab {font-style: normal; font-size: small; font-family: fixed}
	EM.def {font-weight: bold; font-style: normal}
	H1 {text-align: center}
	UL {list-style-type: none}
	SPAN.box {background: beige; width: 100%; font-style: normal; text-align: center; border-width: thin; border-style: ridge}
	SPAN.bbox {background: lightsteelblue; width: 100%; font-style: normal; border-width: thin; border-style: ridge}
	SPAN.cbox {background: lightgreen; width: 100%; font-style: normal; border-width: thin; border-style: ridge}
	SPAN.htmlbox {background: tan; font-style: normal; font-size: small; border-width: thin; border-style: ridge}
-->
</style>
</head>
<body bgcolor=white>

<!-- I'm using A NAME (i.e caps) where the entity should be ignored by the indexer (index.cl) -->

<A NAME="grfsndcontents"></a>
<span class=box><h1>Snd Customization and Extension Part 2</h1></span>
<br>

<center>
<span class=htmlbox>related documentation</span><span class=htmlbox><a href="snd.html">snd.html</a><spacer type=horizontal size=25><a href="extsnd.html">extsnd.html</a><spacer type=horizontal size=25><a href="clm.html">clm.html</a><spacer type=horizontal size=25><a href="sndlib.html">sndlib.html</a><spacer type=horizontal size=25><a href="sndscm.html">sndscm.html</a><spacer type=horizontal size=25><a href="index.html">index.html</a></span>
</center>

<ul>
<li><a href="#startup">Snd Startup</a>
  <ul>
  <li><a href="#sndresources">Snd resources</a>
  <li><a href="#sndswitches">Snd invocation flags</a>
  <li><a href="#sndinitfile">The initialization file</a>
  </ul>
<li><a href="#snddynamic">Runtime modules and external programs</a>
  <ul>
  <li><a href="#emacssnd">Snd as an Emacs subjob</a>
  <li><a href="#dynamic">Dynamically loaded modules</a>
  <ul>
     <li><a href="#sndgsl">GSL</a>
     <li><a href="#sndsndlib">Sndlib</a>
     </ul>
  <li><a href="#programs">External Programs</a>
  <ul>
    <li><a href="#stk">STK</a>
    <li><a href="#sox">Sox</a>
    <li><a href="#clm">CLM</a>
    </ul>
  <li><a href="#sndaswidget">Snd as a Widget</a>
  <li><a href="#sndwithclm">Snd and the CLM module</a>
    <ul>
    <li><a href="#clmfuncs">CLM functions</a>
    </ul>
  <li><a href="#sndwithmotif">Snd and Motif</a>
  <li><a href="#sndwithgtk">Snd and Gtk</a>
  <li><a href="#sndwithnogui">Snd with no GUI</a>
  <li><a href="#sndwithgmeteor">Snd and gmeteor</a>
  <li><a href="#sndandladspa">Snd and LADSPA</a>
  <li><a href="#sndandx">Driving Snd remotely</a>
  <li><a href="#sndandgl">Snd and OpenGL</a>
  <li><a href="#sndandgdb">Snd and gdb</a>
  </ul>
<li><a href="index.html#extsndindex">Index</a>
</ul>

<br>

<span class=box><h2><A NAME="startup">Snd Startup</a></h2></span>
<br>
<span class=bbox><h3><A NAME="sndresources">Snd resources</a></h3></span>

<p>In the Motif version, there are a few X-style resources that Snd looks for (see Snd.ad):</p>

<table cellspacing=0 cellpadding=0>
<tr><td width=200>initFile</td><td>"~/.snd"</td></tr>
<tr><td><A NAME="epsresource">epsFile</a></td><td>"snd.eps"</td></tr>
<tr><td>overwriteCheck</td><td>0</td></tr>
<tr><td>autoResize</td><td>1</td></tr>
<tr><td>horizontalPanes</td><td>0</td></tr>
<tr><td><br></td><td><br></td></tr>
<tr><td>buttonFont</td><td>-*-times-medium-r-*-*-14-*-*-*-*-*-iso8859-1</td></tr>
<tr><td>boldbuttonFont</td><td>-*-times-bold-r-*-*-14-*-*-*-*-*-iso8859-1</td></tr>
<tr><td>axisLabelFont</td><td>-*-times-medium-r-normal-*-20-*-*-*-*-*-iso8859-1</td></tr>
<tr><td>axisNumbersFont</td><td>-*-courier-medium-r-normal-*-14-*-*-*-*-*-iso8859-1</td></tr>
<tr><td>helpTextFont</td><td>9x15</td></tr>
<tr><td>listenerFont</td><td>default</td></tr>
<tr><td><br></td><td><br></td></tr>
<tr><td>useSchemes</td><td>none</td></tr>
<tr><td>highlightcolor</td><td>ivory1</td></tr>
<tr><td>basiccolor</td><td>ivory2</td></tr>
<tr><td>positioncolor</td><td>ivory3</td></tr>
<tr><td>zoomcolor</td><td>ivory4</td></tr>
<tr><td>cursorcolor</td><td>red</td></tr>
<tr><td>selectioncolor</td><td>lightsteelblue1</td></tr>
<tr><td>mixcolor</td><td>lightgreen</td></tr>
<tr><td>mixfocuscolor</td><td>yellow2</td></tr>
<tr><td>listenercolor</td><td>aliceblue</td></tr>
<tr><td>envedwaveformcolor</td><td>blue</td></tr>
<tr><td>filterwaveformcolor</td><td>blue</td></tr>
<tr><td>mixwaveformcolor</td><td>darkgray</td></tr>
<tr><td>graphcolor</td><td>white</td></tr>
<tr><td>selectedgraphcolor</td><td>white</td></tr>
<tr><td>datacolor</td><td>black</td></tr>
<tr><td>selecteddatacolor</td><td>black</td></tr>
<tr><td>markcolor</td><td>red</td></tr>
<tr><td>pushedbuttoncolor</td><td>lightsteelblue1</td></tr>
<tr><td>sashcolor</td><td>lightgreen</td></tr>
</table>
<p>If you have the HTML widget loaded, the following
resources are also available:</p>

<table cellspacing=0 cellpadding=0>
<tr><td width=200>htmlDir</td><td>"."</td></tr>
<tr><td>htmlWidth</td><td>600</td></tr>
<tr><td>htmlHeight</td><td>400</td></tr>
<tr><td>htmlFontSizeList</td><td>"14,10,24,24,18,14,12"</td></tr>
<tr><td>htmlFixedFontSizeList</td><td>"14,10"</td></tr>
</table>

<p>You can experiment with other choices by
using the -xrm command line argument:</p>

<pre>
  snd -xrm '*Highlightcolor: Red' oboe.snd
  snd -xrm '*AxisNumbersFont: 6x10' oboe.snd
  snd -xrm '*overwriteCheck: 1' oboe.snd
  snd -xrm '*useSchemes: all' -xrm '*scheme: Pacific'
  snd -xrm '*fontList: 9x15' oboe.snd
  snd -xrm '*listenerFont: 6x10' oboe.snd
  snd -xrm '*mixwaveformcolor: red' oboe.snd -notebook
  snd oboe.snd pistol.snd -xrm '*selectedgraphcolor: black' -xrm '*selecteddatacolor: white'
  snd oboe.snd -title hiho -display hummer.hiho:0.0 -xrm '*chn-graph*backgroundPixmap: text.xpm'
</pre>

<p>The color names can be found in <a href="sndscm.html#rgbdoc">rgb.scm</a>. 
If you use SGI color schemes (the useSchemes resource), most of the color resources mentioned above are ignored 
(the cursor and selection colors are never ignored). If color schemes are available
they're listed in /usr/lib/X11/schemes, probably -- it's unfortunate that
there is the language Scheme used by Guile, and the notion of an SGI color scheme -- there is
no connection between the two.  The last example sets the window title to "hiho", rather than
"snd", displays the window on the machine hummer.hiho (presumably accessible over the net),
and tiles the graph backgrounds with the contents of text.xpm.  To get the -geometry argument
to work, set the autoResize resource to 0:</p>
<pre>
  snd oboe.snd -geometry 800x200 -xrm '*autoResize: 0'
</pre>

<p>These resources can be set in your .Xdefaults file:</p>
<pre>
snd*buttonFont:         -adobe-times-medium-r-*-*-14-*-*-*-*-*-*-*
snd*boldbuttonFont:     -adobe-times-bold-r-*-*-14-*-*-*-*-*-*-*
snd*axisLabelFont:      -adobe-times-medium-r-normal-*-18-*-*-*-*-*-*-*
snd*axisNumbersFont:    9x15
snd*fontList:           9x15
snd*helpTextFont:       9x15
</pre>

<p>
The <A NAME="xautoresize">autoResize resource</a> determines how Snd acts when files
are added or removed from its overall display.  The default (1)
causes Snd to expand or contract the main window's size to accommodate
the sounds (many people find this distracting); if <i>autoResize</i> is 0, the outer window size remains the
same, and the sounds try to fit as best they can.  See also
the variable <a href="extsnd.html#autoresize">auto-resize</a>.
If <i>overwriteCheck</i> is 1, Snd asks before overwriting existing files.
The <A NAME="horizontalpanes">horizontalPanes resource</a>
is equivalent to the -h flag; if 1, sounds are layed out
horizontally rather than vertically;  if 2, you get a notebook
widget holding the sounds.
</p>

<p><A NAME="aboutcolors"></a>The various color resources are:</p>

<table cellspacing=0 cellpadding=0>
<tr><td width=200>basiccolor</td><td width=350>default background color everywhere</td><td><code>basic-color</code></td></tr>
<tr><td>cursorcolor</td><td>color of the cursor</td><td><code>cursor-color</code></td></tr>
<tr><td>datacolor</td><td>unselected data color</td><td><code>data-color</code></td></tr>
<tr><td>envedwaveformcolor</td><td>color of envelope editor waveform</td><td><code>enved-waveform-color</code></td></tr>
<tr><td>filterwaveformcolor</td><td>color of control panel filter waveform</td><td><code>filter-waveform-color</code></td></tr>
<tr><td>graphcolor</td><td>unselected channels' graph background</td><td><code>graph-color</code></td></tr>
<tr><td>highlightcolor</td><td>highlighting here and there</td><td><code>highlight-color</code></td></tr>
<tr><td>listenercolor</td><td>background color of the listener</td><td><code>listener-color</code></td></tr>
<tr><td>listenertextcolor</td><td>text color in the listener</td><td><code>listener-text-color</code></td></tr>
<tr><td>markcolor</td><td>color of the mark indicator</td><td><code>mark-color</code></td></tr>
<tr><td>mixcolor</td><td>used for mix waveforms</td><td><code>mix-color</code></td></tr>
<tr><td>selectedmixcolor</td><td>selected mix waveforms</td><td><code>selected-mix-color</code></td></tr>
<tr><td>positioncolor</td><td>color of position sliders</td><td><code>position-color</code></td></tr>
<tr><td>pushedbuttoncolor</td><td>color of pushed button</td><td><code>pushed-button-color</code></td></tr>
<tr><td>sashcolor</td><td>color of paned window sash handles</td><td><code>sash-color</code></td></tr>
<tr><td>selecteddatacolor</td><td>color of the data in selected channel</td><td><code>selected-data-color</code></td></tr>
<tr><td>selectedgraphcolor</td><td>background of selected channel's graph</td><td><code>selected-graph-color</code></td></tr>
<tr><td>selectioncolor</td><td>color of an active selection</td><td><code>selection-color</code></td></tr>
<tr><td>textfocuscolor</td><td>color of text field with focus</td><td><code>text-focus-color</code></td></tr>
<tr><td>zoomcolor</td><td>color of zoom sliders</td><td><code>zoom-color</code></td></tr>
</table>
<p>
Each of these colors can be set in Guile using the second name given above ("basic-color").
Colors are defined by calling <a href="extsnd.html#makecolor">make-color</a> with the three red/green/blue values,
each a float between 0.0 and 1.0. <code>(set! (basic-color) (make-color 1.0 0.0 0.0))</code> sets
the overall background color of Snd to red.  <a href="sndscm.html#rgbdoc">rgb.scm</a> defines all the standard X11 color names
(you probably don't want to load the whole thing; just use the names as needed). 
</p>

<p>There are several other resources that set various widget sizes: zoomSliderWidth,
positionSliderWidth, toggleSize, sashSize, sashIndent, channelSashSize, channelSashIndent, and
envedPointSize.  And several more color resources: whitecolor (list background),
blackcolor (recorder VU meter text), redcolor (buttons, VU clipping, etc), 
greencolor (a few buttons),
yellowcolor (a few envelope editor buttons), lightbluecolor (the recorder), and lighterbluecolor (the fft option panel).
</p>

<p>In the GTK version, you can load a gtkrc file, overriding all Snd defaults, with the
function <b>parse-rc-file</b>:
</p>
<pre>
  (parse-rc-file "/home/bil/test/gtk+-1.2.9/gtk/testgtkrc")
</pre>

        <!-- I(print file):O(epsFile resource)(epsresource) -->

<br>
<span class=bbox><h3><A NAME="sndswitches">Snd invocation flags</a></h3></span>

<p>The following flags are recognized by Snd (leaving aside all
the usual Xt/X-related flags like -xrm).</p>

<table cellspacing=0 cellpadding=0>
<tr><td width=200><code>-h -horizontal</code></td><td>layout sounds as horizontal panes</td></tr>
<tr><td><code>-v -vertical</code></td><td>layout sounds vertically (the default)</td></tr>
<tr><td><code>-notebook</code></td><td>layout sounds in a notebook widget (Motif 2.0 or later)</td></tr>
<tr><td><code>-separate</code></td><td>layout sounds each in a separate window (lisp listener in main window)</td></tr>
<tr><td><code>--help</code></td><td>print some help, version info, and exit</td></tr>
<tr><td><code>--version</code></td><td>print version info</td></tr>
<tr><td><code>-noglob</code></td><td>don't read SND_CONF, if any</td></tr>
<tr><td><code>-noinit</code></td><td>don't read ~/.snd, if any</td></tr>
<tr><td><code>-p -preload &lt;dir&gt;</code></td><td>preload sound files in directory &lt;dir&gt; (for example, snd -p .)</td></tr>
<tr><td><code>-l -load &lt;file&gt;</code></td><td>load guile (scheme) code in &lt;file&gt; (for example, snd -l test.scm)</td></tr>
<tr><td><code>-e -eval expr</code></td><td>evaluate expr</td></tr>
</table>

<p>
The -e switch evaluates its argument as though it had been passed to M-X.  The
initialization file, if any, is loaded first, then the arguments are processed
in order.  For example</p>
<pre>
snd -e "(set! (data-color) (make-color 1 0 0))" oboe.snd
</pre>
<p>reads ~/.snd, if any, then sets the (unselected) data color to red, then opens oboe.snd.<p>
<pre>
./snd -eval '(begin (display (+ 1 2)) (exit))'
</pre>
<p>prints "3" and exits.  The "-title" argument works in both versions of Snd.
</p>
<img src="note.png" alt="notebook"><spacer type=horizontal size=10><img src="bgd.png" alt="colors" vspace=30>
<br>
<br>
<span class=bbox><h3><A NAME="sndinitfile">The initialization file</a></h3></span>
<p>
When Snd starts up, it looks for an "initialization file", normally named "~/.snd" (its name can be set
via the X resource mechanism, or through the environment variable SND_INIT_FILE).  This optional file is
supposed to be just like emacs' .emacs file, containing any customizations or
extensions that you want loaded whenever Snd starts up.  For example, say we
want the Snd window to start out 800x500, want to predefine an envelope named
"env1", and want the file selection box to
default to showing just sound files.  We make ~/.snd and put in it:</p>
<pre>
(set! (window-width) 800)
(set! (window-height) 500)
(defvar env1 '(0 0 1 1 2 0))
(set! (just-sounds) #t)
</pre>
<p>
In addition, we could add our own analysis functions or whatever.  In more
complex situations, you may want an initialization file particular to a given
machine, and global across users; in that case, the macro SND_CONF gives the
name of this global initialization file.  At ccrma, it's "/etc/snd.conf". The
global file is read before the user's local file; both can, of course, be
absent.  To override reading the global init file when Snd is invoked, include the switch -noglob.
To override the local init file, use -noinit.  To set the global file name in
a makefile include (for example) -DSND_CONF='"/home/bil/cl/sndconf"' in CFLAGS.
Here's a more extended example:
</p>

<pre>
(use-modules (ice-9 popen) (ice-9 debug) (ice-9 format))

(set! (window-width) 800)
(set! (window-height) 500)
(set! (button-font) "-adobe-times-medium-r-*-*-14-*-*-*-*-*-*-*")
(set! (bold-button-font) "-adobe-times-bold-r-*-*-14-*-*-*-*-*-*-*")
(set! (axis-label-font) "-adobe-times-medium-r-normal-*-18-*-*-*-*-*-*-*")
(set! (axis-numbers-font) "9x15")

(set! (show-mix-waveforms) #t)
(set! (listener-prompt) ":")
(show-listener)
(set! (show-indices) #t)

(define beige (make-color 0.96 0.96 0.86))
(define blue (make-color 0 0 1))
(set! (selected-graph-color) beige)
(set! (selected-data-color) blue)

(add-hook! mouse-enter-graph-hook 
  (lambda (snd chn) 
    (focus-widget (car (channel-widgets snd chn)))))
(add-hook! mouse-enter-listener-hook 
  (lambda (widget) 
    (focus-widget widget)))
(add-hook! mouse-enter-text-hook
  (lambda (w)
    (focus-widget w)))
</pre>
<p>
If you loaded Snd with GSL, and have set the GSL_IEEE_MODE environment variable,
it will override Snd's default arithmetic mode settings.  GSL recommends the setting:
</p>
<pre>
GSL_IEEE_MODE=double-precision,mask-underflow,mask-denormalized
</pre>

<br>
<span class=box><h2><A NAME="snddynamic">Runtime modules and external programs</a></h2></span>

<p>It is possible to load your own C code into Snd at run-time or
use any external program from within Snd as an editing function.
And, perhaps most useful, you can run Snd as an Emacs subjob.
</p>
<br>
<span class=bbox><h3><A NAME="emacssnd">Snd as an Emacs subjob</a></h3></span>

<p>Snd watches stdin; any input received
is evaluated as if typed in Snd's lisp listener; any subsequent output
is sent to stdout; presumably any process could communicate with
Snd in this manner.  But the intention here was to connect to Emacs 
via ILISP (available at
http://sourceforge.net/projects/ilisp,
and possibly built into Xemacs).
Once you have ILISP, put this code in your .emacs file:</p>
<pre>
(require 'ilisp)
(defdialect snd "Snd" ilisp
  (setq ilisp-block-command "(begin \n%s)")
  (setq ilisp-load-command "(load \"%s\")")
  (setq ilisp-init-hook '((lambda () (ilisp-init nil nil nil))))
  (setq comint-prompt-regexp "^>+")
  (setq ilisp-directory-command "(getcwd)")
  (setq	ilisp-set-directory-command "(chdir \"%s\")")
  (setq	ilisp-complete-command
	"(map (lambda (sym) 
                (list (symbol-&gt;string sym))) 
              (apropos-internal \"^%s\"))")
  (local-set-key "\C-x\C-h" '(lambda (s)
			       (interactive "sSnd help: ")
			       (insert "(snd-help " s ")")
			       (comint-send-input))))

  (setq snd-program "snd")
</pre>
<p>You can bind this to some key via:</p>
<pre>
  (global-set-key "\C-x\C-l" 'snd)
</pre>
<p>Now C-x C-l in Emacs starts Snd as a subjob; anything you type in the Emacs
<b>*snd*</b> buffer is sent to Snd (very much as if you were running CLM as
an Emacs subjob), and Snd's output is appended to the <b>*snd*</b> buffer.
Also, C-x C-h prompts for some Snd entity and appends the help text for that
entity in the snd buffer.  The following code tries to implement Snd's
name completion upon C-x C-i in the <b>*snd*</b> buffer:</p>
<pre>
(defun handle-snd-completion (process string)
  (let ((buffer (process-buffer process)))
    (save-excursion
      (set-buffer buffer)
      (goto-char (point-max))
      (insert (substring string 1 (- (length string) 3))))
    (goto-char (point-max))
    (display-buffer buffer)))
      
(defun snd-complete-symbol ()
  (interactive)
  (let* ((end (point))
	 (start (save-excursion (skip-syntax-backward "w_") (point)))
	 (pattern (buffer-substring-no-properties start end))
	 (proc (get-buffer-process (current-buffer)))
	 (old-filter (process-filter proc)))
    (delete-region start end)
    (set-process-filter proc 'handle-snd-completion)
    (process-send-string proc (format "(snd-completion \"%s\")\n" pattern))
    (accept-process-output proc)
    (set-process-filter proc old-filter)))
</pre>
<p>and add this to the defdialect block:</p>
<pre>
  (local-set-key "\C-x\C-i" 'snd-complete-symbol)
</pre>
<p>But for some reason it needs an open-paren?
<i>snd-program</i> is the name of the snd image; you can include whatever
startup switches you like:
</p>
<pre>
(setq snd-program "snd -horizontal ~/cl/oboe.snd")
</pre>
<br>
<span class=bbox><h3><A NAME="dynamic">Dynamically loaded modules</a></h3></span>

<p>You can import shared object files into Snd at any time.
You need to build Snd
with -lguile (that is, load it with the guile shared library, not libguile.a);
if the loader can't find libguile.so.2 (or whatever), add its directory to
your LD_LIBRARY_PATH; for example, if
it's on /usr/local/lib, <code>setenv LD_LIBRARY_PATH /usr/local/lib</code>.  
Next add Guile wrappers to your C code:</p>
<pre>
  /* cscm.c */
  #include &lt;math.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;
  #include &lt;guile/gh.h&gt;

  int hiho (int a) 
  { /* this is the function we want to call from Snd */
    return(1 + a);
  }

  SCM hiho_wrapper(SCM a) 
  { /* this tells Guile how to interpret the arguments and return value of hiho */
    return(gh_int2scm(hiho(gh_scm2int(a))));
  }

  void init_hiho() 
  { /* this declares hiho within Guile calling the wrapper which calls the C function hiho */
    gh_new_procedure1_0("hiho", hiho_wrapper);
  }
</pre>
<p>
Next compile
your code into a shared object (this example is for Linux):
<pre>
  cc -c cscm.c 
  ld -shared -o cscm.so cscm.o -lguile
</pre>
<p>Now go to Snd's lisp listener and,</p>
<pre>
  (define lib (<em class=red>dynamic-link</em> "/home/bil/cl/cscm.so"))
  (<em class=red>dynamic-call</em> "init_hiho" lib)
  (hiho 3)
</pre>
<p>The function we actually want loaded into Guile here is "hiho".
We define a wrapper for it to handle the translation between
Guile (Scheme) variable types and C ("hiho_wrapper"), and
a procedure to define hiho in Guile ("init_hiho").  Once loaded
("dynamic-link"), we can call the initialization function
("dynamic-call"), and thereafter treat "hiho" as though
it had been defined in Guile/Snd to begin with.  After both the
dynamic-link and dynamic-lib calls, the listener will
print "#&lt;unspecified&gt;" or something equally obscure to indicate
in its own peculiar way that all went well.  M-x (hiho 4) will
print 5 in the minibuffer.
</p>

<p><A NAME="sndgsl"></a>
As a slightly more useful example, let's import the bessel J0 function
from GSL (Gnu Scientific Library); in this case, we need to build Snd
with GSL (the easiest way is to include the --with-gsl option to configure).
Then make a file (say "gsl-ex.c"):</p>
<pre>
#include &lt;guile/gh.h&gt;
#include &lt;gsl/gsl_sf_bessel.h&gt;

static SCM scm_j0(SCM x)
{ /* calls GSL function gsl_sf_bessel_J0_e */
  gsl_sf_result res;
  gsl_sf_bessel_J0_e(gh_scm2double(x), &amp;res);
  return(gh_double2scm(res.val));
}

void init_gsl_j0(void)
{ /* links scm_j0 into Snd under the name j0 */
  gh_new_procedure("j0", scm_j0, 1, 0, 0);
}
</pre>
<p>Now the usual compile, load, link into Snd sequence:</p>
<pre>
/home/bil/snd-4/ cc gsl-ex.c -c -Wall
/home/bil/snd-4/ ld -shared gsl-ex.o -o gsl-ex.so -lguile
/home/bil/snd-4/ ./snd

&gt;<em class=typing>(define lib (dynamic-link "/home/bil/snd-4/gsl-ex.so"))</em>
<em class=listener>#&lt;unspecified&gt;</em>
&gt;<em class=typing>(dynamic-call "init_gsl_j0" lib)</em>
<em class=listener>#&lt;unspecified&gt;</em>
&gt;<em class=typing>(<em class=red>j0</em> 0.0)</em>
<em class=listener>1.0</em>
&gt;<em class=typing>(<em class=red>j0</em> 2.0)</em>
<em class=listener>0.223890779141236</em>
&gt;<em class=typing>(define (bes-fm dur freq amp ratio index)
 ;; bessel-FM from CLM
   (let* ((car-ph 0.0)
	  (mod-ph 0.0)
 	  (car-incr (hz-&gt;radians freq))
	  (mod-incr (* ratio car-incr))
	  (ampenv (make-env :envelope '(0 0 25 1 75 1 100 0) :scaler amp :end dur))
	  (output (make-vct dur)))
     (do ((i 0 (1+ i)))
	 ((= i dur))
       (vct-set! output i (* (env ampenv) (<em class=red>j0</em> car-ph)))
       (set! car-ph (+ car-ph car-incr (* index (<em class=red>j0</em> mod-ph))))
       (set! mod-ph (+ mod-ph mod-incr)))
     (vct-&gt;samples 0 dur output)))</em>
<em class=listener>#&lt;unspecified&gt;</em>
&gt;<em class=typing>(bes-fm 22050 440 10.0 1.0 8.0)</em>
</pre>
<p>It is possible to have the gsl-ex.so library loaded automatically,
including the dynamic-link.  (This part of Guile's module system
may change, but they've been saying that for years).  First, include
this in gsl-ex.c:
</p>
<pre>
void scm_init_gsl_bessel_module ()
{
  scm_register_module_xxx ("gsl bessel", init_gsl_j0);
}
</pre>
<p>This tells Guile to call init_gsl_j0 when the module is loaded (thereby
defining j0 for us).  Now we'll call this module (gsl bessel) just for
laughs; this means when we type</p>
<pre>
&gt;(use-modules (gsl bessel))
</pre>
<p>in Snd's listener, the loader will look for gsl/libbessel.so,
calling scm_init_gsl_bessel_module if possible. So we create
a subdirectory named gsl, and put gsl-ex.so in it under the name
libbessel.so.  Then whenever we want to use j0, we simply
use the <code>use-modules</code> line given above.
</p>

<p>To acess and edit sound data from such a module, use the
Snd functions make-sample-reader and loop-samples.  loop-samples
takes a sample reader, a pointer to a (C) float function that takes
one float argument (the current sample), the number of times
to call that function, and a name for the editing operation for
the edit history list.  For example, the following module
defines a function that scales the data by 2:</p>
<pre>
#include &lt;guile/gh.h&gt;

static float a2(float b) {return(b * 2.0);}

static SCM get_a2(void) {return(gh_ulong2scm((unsigned long)a2));}

void init_hiho() {gh_new_procedure0_0("get-a2", get_a2);}
</pre>
<p>The "a2" function will be called from Snd as follows; first make
the shared object module and load it as above, then</p>
<pre>
(loop-samples (make-sample-reader 0) (get-a2) 50828 "a2")
</pre>
<p>There's a way to make a module like this loadable via the
(use-modules ...) syntax in Guile, but I haven't delved into
it yet.</p>

<p>To call internal Snd functions, you can do something like
the following: declare an SCM variable to hold the procedure
variable, in the init function set the variable to the
value of scm_symbol_value0("function-name"), and in the
rest of the code call it via scm_apply. The following
is a sketch using the Snd internal "srate" function:</p>
<pre>
  #include &lt;guile/gh.h&gt;
  static SCM g_srate;
  static SCM srate_wrapper(SCM a) {return(gh_call1(g_srate, a));}
  void init_srate(void) 
  { 
    gh_new_procedure1_0("my-srate", srate_wrapper);
    g_srate = scm_symbol_value0("srate");
  }
</pre>
<p>Alternatively, you can simply use gh_eval_str:</p>
<pre>
  gh_eval_str("(recorder-dialog)");
  gh_eval_str("(open-sound \"oboe.snd\")");
  srate = gh_scm2int(gh_eval_str("(srate)"));
</pre>
<p>There is a Scheme to C compiler named <a name="hobbit">Hobbit</a>, but it's not
very useful in our context.  If you have pure Scheme functions,
it may be able to speed them up, but if you want to call Snd/CLM/Sndlib
functions, special support is needed, and even with that support
my timing tests did not get more than a 50% improvement in speed.
Recently, however, Keisuke Nishida started work on a Guile compiler
that promises to speed up Snd-Scheme code by at least an order of
magnitude.  When it becomes available, I'll probably move the
vct support stuff back into Scheme, and reduce some of the
clutter of functions aimed at fast data access.  I think all
that's really needed from Snd are the sample-reader functions.
</p>

<p><A NAME="sndsndlib"></a>
To use sndlib (clm) functions from a shared object file can be a bit
tricky; first you need to build sndlib as a shared library (named
"libsndlib.so" for loader convenience).  If it's not in a directory
the loader normally searches, you need to use -rpath in the loader
arguments to force the loader to look in the right place. 
Here's an example that
implements <a href="sndscm.html#effectsdoc">effects.scm</a>'s flanger in a file named eff.c:
</p>
<pre>
#include &lt;guile/gh.h&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include "sndlib.h"
#include "clm.h"

typedef struct {
  mus_any *del,*ri;
} flg;

static flg *make_flange(float flg_speed, float flg_amount, float flg_time)
{
  flg *gens;
  int len;
  len = (int)(flg_time * 22050) + 1;
  gens = (flg *)calloc(1, sizeof(flg));
  gens-&gt;del = mus_make_delay(len, NULL, (int)(len + 1 + flg_amount));
  gens-&gt;ri = mus_make_rand_interp(flg_speed, flg_amount);
  return(gens);
}

static float run_flange(float inval, void *ugens)
{
  flg *gens = (flg *)ugens;
  return(0.75 * (inval + mus_delay(gens-&gt;del, inval, mus_rand_interp(gens-&gt;ri, 0.0))));
}

static void free_flange(flg *gens)
{
  mus_free(gens-&gt;del);
  mus_free(gens-&gt;ri);
  free(gens);
}

static SCM g_make_flange(SCM speed, SCM amount, SCM time)
{
  SCM result;
  flg *gens;
  gens = make_flange(gh_scm2double(speed), gh_scm2double(amount), gh_scm2double(time));
  return(gh_ulong2scm((unsigned long)(gens)));
}

static SCM g_get_flange(void)
{
  return(gh_ulong2scm((unsigned long)run_flange));
}

static SCM g_free_flange(SCM g_gens)
{
  free_flange((flg *)gh_scm2ulong(g_gens));
}

void init_eff(void)
{
  mus_sound_initialize();
  init_mus_module();
  gh_new_procedure("free-flange", g_free_flange, 1, 0, 0);
  gh_new_procedure("get-flange", g_get_flange, 0, 0, 0);
  gh_new_procedure("make-flange", g_make_flange, 3, 0, 0);
}
</pre>
<p>Now compile eff.c and turn it into eff.so, then</p>
<pre>
(define lib (dynamic-link "/home/bil/cl/eff.so"))
(dynamic-call "init_eff" lib)
</pre>
<p>If this gets the catch-all error "file not found: eff.so",
it's actually complaining about the libraries, not eff.so itself.
In a case where I had both guile and sndlib on unusual directories, I used:
</p>
<pre>
ld -shared -o eff.so eff.o -rpath /home/bil/test/lib -L/home/bil/test/lib -lguile -rpath /home/bil/cl -L/home/bil/cl -lsndlib -ldl -lm
</pre>
<p>and changed the Snd makefile LIBS statement to:</p>
<pre>
LIBS = -Xlinker -rpath -Xlinker /home/bil/test/lib -L/home/bil/test/lib -lguile -Xlinker -rpath -Xlinker /home/bil/cl -L/home/bil/cl -lsndlib -lmcheck -L/usr/X11R6/lib -lXm -lXp -lXpm -lXt -lXext -lX11 -ldl -lm
</pre>
<p>
If all else fails (as it usually does when using libtool's dynamic linking),
I've included a simple dlopen call in Snd as a fallback -- (dlopen filename) will return
a "handle" (like dynamic-link), or give you a truthful error message.  The function corresponding to "dynamic-call"
is dlinit: (dlinit handle func-name) where the function in question takes no arguments.
If the sndlib.so business won't work for you, build your .so file with the sndlib object files
included explicitly:
</p>
<pre>
  ld -shared eff.o -o eff.so io.o headers.o audio.o sound.o clm.o vct.o sndlib2scm.o clm2scm.o
</pre>
<p>Then in Snd (assume we're on /home/bil/cl),</p>
<pre>
(define handle (dlopen "/home/bil/cl/eff.so"))
(dlinit handle "init_eff")
</pre>
<p>
Once the dynamic linker is happy, the flanger can be 
invoked:</p>
<pre>
(loop-samples (make-sample-reader 0) (get-flange) (frames) "flange" (make-flange 2.0 5.0 0.001))
</pre>
<p>which is about 30 times faster than the interpreted version in <a href="sndscm.html#effectsdoc">effects.scm</a>.  There is (yet another)
gotcha in this business: if Snd is built in the normal way incorporating the sndlib code directly,
the call (mus-srate) in the listener does not refer to the same thing that mus_srate refers to
in eff.c; the latter is using the shared library's variable whereas Snd is using the variable
incorporated at compile time.  In addition, the initialization used in sndlib doesn't carry
over to the shared library (this is probably a bug...).  So, you can (set! (mus-srate) 22050),
and then find that mus_srate is returning 0!  It's probably best to set the shared library's
mus_srate explicitly when you initialize your module, or build Snd with sndlib.so (I've actually
never done this...).  I hope in the future to provide various modules (for the effects menu, for
example).</p>

<br>
<span class=bbox><h3><A NAME="programs">External Programs</a></h3></span>

<p>Any external program that knows about sound files can be used to perform editing operations
from Snd.  You thereby get Snd's display, analysis, header and format conversion, and edit-tree support,
and can concentrate on the actual sound effect you're developing.
The original impetus for Snd came from CLM, a large lisp-listener based program
which normally runs without a graphical
user interface, and without any simple way to move around
in what Snd calls the edit history.  Since interprocess
communication proved problematic in this case,
the communication path was simplified to
consist of little more than shared files, with CLM treated
as a batch program. A nice side-effect of this is that any other program can fit
the same mold.</p>

<p>
For example, say we have a sound processing CLM instrument we like; it takes
two sound file names as its arguments, reading the first and writing the second.
In Snd we write the current edited state to a temporary file, start CLM, call the instrument 
passing it the input and output filenames, then pass its output back
to Snd.  Snd then replaces the current data with the data our instrument wrote, as if it had incorporated that
instrument as an editing operation from the beginning.
<p>To write out the current data, we use either save-sound-as or save-selection.  Our
program then writes its changes, and Snd reads these back in as edits using
set! samples.  We can delete the Snd output at that point, though the
input (changed) files should be left for Snd to handle.  Here are some examples,
based on the Snd-4 sound-to-temp functions and its friends; these are implemented
in examp.scm.  The basic idea is that you can write out any portion of the current
data, and (independent of any prior write) use any external sound file as an edit of any portion.
<br>

<span class=cbox><h4><A NAME="stk">STK</a></h4></span>

<p><b><a href="www-ccrma.stanford.edu/CCRMA/Software/STK/">STK</a></b>
is a synthesis toolkit developed by Perry Cook and Gary Scavone.
Like many such programs, it reads a score file and produces an output file.  We'll use it here
to replace the current sound with a clarinet tone:</p>

<table border=1 cellpadding=5><tr><td bgcolor="beige"><pre>
(define stk
  (lambda ()
    (let* ((str "")
           (data (<em class=red>sound-to-temp</em>))
           (fil (<em class=red>open-pipe</em> "syntmono Clarinet -s /tmp/test &lt; scores/hiho.ski" "r")))
      (do ((val (read-char fil) (read-char fil)))
          ((eof-object? val))
        (set! str (string-append str (string val))))
      (<em class=red>close-pipe</em> fil)
      (<em class=red>temp-to-sound</em> data "/tmp/test.snd" "(STK clarinet)")
      str)))
</pre></td></tr></table>

<p>hiho.ski is:</p>
<pre>
NoteOn          0.000000 1 60 127.000000
NoteOff         0.126032 1 60 63.500000
</pre>
<p>The basic sequence is: <b>sound-to-temp</b> writes out the current (possibly edited)
state of the selected sound(s) in Snd as a temp file.  <b>sound-to-temp</b> returns
an opaque object which we will later pass to <b>temp-to-sound</b> to complete the
edit.  But first, we open a pipe, call STK as a batch job, and read in whatever
it prints out (so we can see how the call went).  Then we call <b>temp-to-sound</b>
passing it the object mentioned earlier, the new filename (the data written by STK
that will replace the current data in Snd), and the associated edit-history reference
to the operation.  In brief:</p>
<pre>
  [sound | selection]-to-[temp | temps]
  call external program on the data and write new data
  [temp | temps]-to-[sound | selection]
</pre>

<p>But this function can't safely be called twice because it always writes
"test.snd", and it isn't very useful as an editing operation because it
completely ignores the current Snd data.  The next steps are to write
our data using safe temporary filenames, and read the current data
using <b>temp-filenames</b>.  We'll also apply this to the current
selection, rather than the full file.  Since I don't know enough
about STK to get it to read an input file, I'll use Sox for the
next examples.</p>
<br>
<span class=cbox><h4><A NAME="sox">Sox</a></h4></span>

<p>Sox is a widely available and well-known program for sound format conversions
and various sound effects.  In this case, we'll read and write NeXT files, and
use Sox's copy "effect".</p>

<table border=1 cellpadding=5><tr><td bgcolor="beige"><pre>
(define sox
  (lambda ()
    (let ((data (<em class=red>selection-to-temp</em>)))
      (if data
	  (let* ((str "")
                 (input-names (<em class=red>temp-filenames</em> data))
                 (output-name (string-append (<em class=red>tmpnam</em>) ".snd"))
		 (cmd (string-append
		        "sox -t .au \""
                        (<em class=red>vector-ref</em> input-names 0)
			"\" -t .au \""
			output-name
			"\" copy"))
		 (fil (open-pipe cmd "r")))
	    (do ((val (read-char fil) (read-char fil))) 
		((eof-object? val))
	      (set! str (string-append str (string val))))
	    (close-pipe fil)
	    (<em class=red>temp-to-selection</em> data output-name "(sox copy)")
	    str)
	  (report-in-minibuffer "no current selection")))))
</pre></td></tr></table>

<p>We use the Guile built-in function <i>tmpnam</i> to get an output
file name that doesn't collide with any existing file; 
We then read the incoming filename that Snd wrote (<i>temp-filenames</i>),
and pass that to Sox.  This is a very complicated no-op,
since Sox in this case merely copies its input to its output.
We're assuming NeXT/Sun files (the
"-t .au" business), and
we're blithely ignored the possibility that we might be
editing any number of sounds, each with any number of channels.  To deal with
the latter, we need to notice how many mono files have been passed to us (in the
case of <i>sound-to-temps</i>), or our external program needs to be able
to handle a file with arbitrarily many channels (<i>sound-to-temp</i>).
In the next example, we'll loop through the mono files, processing each
in turn.  We'll also start packaging up the boilerplate a bit.</p>

<table border=1 cellpadding=5><tr><td bgcolor="beige"><pre>
(define execute-and-wait
  (lambda (cmd)
    (let ((str "")
	  (fil (open-pipe cmd "r")))
      (do ((val (read-char fil) (read-char fil))) 
	  ((eof-object? val))
	(set! str (string-append str (string val))))
      (close-pipe fil)
      str)))

(define loop-through-files
  (lambda (description make-cmd)
    (let* ((data (<em class=red>sound-to-temps</em>))
	   (input-names (temp-filenames data))
	   (files (vector-length input-names))
	   (output-names (make-vector files "")))
      (do ((i 0 (1+ i)))
	  ((= i files))
	(vector-set! output-names i (string-append (tmpnam) ".snd"))
	(execute-and-wait (make-cmd (vector-ref input-names i) (vector-ref output-names i))))
      (<em class=red>temps-to-sound</em> data output-names description))))

(define sox-1
  (lambda ()
    (loop-through-files
     "(sox copy)"
     (lambda (in out)
       (string-append "sox -t .au \""	in "\" -t .au \"" out "\" copy")))))
</pre></td></tr></table>

<p>Now our <i>sox</i> function can handle any number of files or
channels that might be sync'd together in Snd.  In case it's not
obvious, the function <i>loop-through-files</i> takes as its second argument
a function of two arguments, and calls it on each file as we march
through the input file list, passing it the input and output file
names as arguments.  It (<i>make-cmd</i>) puts together the actual
call on sox that we were making earlier.  An equivalent using cp is:</p>

<table border=1 cellpadding=5><tr><td bgcolor="beige"><pre>
(define copyfile
  (lambda ()
    (loop-through-files
      "(cp)"
      (lambda (in out)
        (string-append "cp " in " " out)))))
</pre></td></tr></table>

<p>But we're still assuming NeXT/Sun format files, and we're throwing away the string
we so laboriously created.  A more friendly function would display its progress.
</p>
<br>
<span class=cbox><h4><A NAME="clm">CLM</a></h4></span>

<p>Reading, mixing, and writing sound files are no problem in CLM, but
it's unusual to run it as a batch program.
Assume for the moment we have loaded the CLM instruments we want (v.ins and jcrev.ins),
and have saved the image using ACL 5.0 in Linux.  The CLM image is
invoked in this case with <code>lisp -I clm.dxl</code>.  ACL provides
a way (<i>-e</i>) to evaluate lisp code from the command line, so
we'll use that along with the <i>exit</i> function to turn CLM
into a batch program.  For example, we can reverberate the current data:</p>

<table border=1 cellpadding=5><tr><td bgcolor="beige"><pre>
(define reverb
  (lambda (reverb-amount)
    (loop-through-files
     (string-append "(reverb " (number-&gt;string reverb-amount) ")")
     (lambda (in out)
       (string-append
	"lisp -I clm.dxl "
	"-e '(progn (restart-clm) "
	"      (with-sound (:play nil :output \"" out "\" :reverb jc-reverb) "
	"        (mix \"" in "\") "
	"        (mix \"" in "\" :output *reverb* :amplitude " (number-&gt;string reverb-amount) "))"
	"      (exit))'")))))
</pre></td></tr></table>

<p>This is a call on CLM's <i>with-sound</i> with a reverberator
and two calls on <i>mix</i>, one for the direct signal, the
other for the reverb input.  The with-sound form is wrapped up
in a progn that calls <i>restart-clm</i> (to make sure all dynamically
allocated entities are setup properly), the with-sound itself,
then <i>exit</i> to leave lisp (the latter is needed since we're
waiting for EOF in the <i>execute-and-wait</i> function).
The <i>reverb</i> function's argument sets the amount of
reverb, and we save that value in the edit-history descriptor.
Now, in Snd, <code>M-x (reverb .1)</code> reverbs the current
data and extends the edit-history list with the string "(reverb .1)".
This example also shows how to mix something into the current 
data.  For example, to add an fm-violin note starting at the
current cursor:
</p>

<table border=1 cellpadding=5><tr><td bgcolor="beige"><pre>
(define fm-violin
  (lambda (dur frq amp)
    (let* ((beg (/ (<em class=red>cursor</em>) (srate)))
	   (fmv-call (string-append "(fm-violin "
				    (number-&gt;string beg) " "
				    (number-&gt;string dur) " "
				    (number-&gt;string frq) " "
				    (number-&gt;string amp) ")")))
      (loop-through-files
       fmv-call
       (lambda (in out)
       (string-append
	"lisp -I clm.dxl "
	"-e '(progn (restart-clm) "
	"      (with-sound (:play nil :output \"" out "\") "
	"        (mix \"" in "\") "
	         fmv-call
	"        ) (exit))'"))))))
</pre></td></tr></table>

<p>But if anything goes wrong, the whole process gets hung, since Lisp
drops into its error handler, and Snd is waiting for the Lisp job to
exit -- we have to go to a shell and kill the Lisp subjob!
So let's check for C-g in Snd, and send the subjob output to
Guile's "current-output-port" (whatever that is):</p>

<table border=1 cellpadding=5><tr><td bgcolor="beige"><pre>
(define read-or-run
  (lambda (fil)
    (let ((val (<em class=red>peek-char</em> fil)))
      (or (and val (read-char fil))
	  (<em class=red>c-g?</em>)
	  (read-or-run fil)))))

(define execute-and-wait
  (lambda (cmd)
    (let ((fil (open-pipe cmd "r")))
      (do ((val (read-or-run fil) (read-or-run fil))) 
	  ((or (eq? val #t) (eof-object? val))
	   (eq? val #t))
        (<em class=red>write-char</em> val (<em class=red>current-output-port</em>)))
      (close-pipe fil))))
      
(define loop-through-files
  (lambda (description make-cmd)
    (let* ((data (sound-to-temps))
	   (input-names (temp-filenames data))
	   (files (vector-length input-names))
	   (output-names (make-vector files ""))
	   (stopped #f))
      (do ((i 0 (1+ i)))
	  ((or stopped (= i files)))
	(vector-set! output-names i (string-append (tmpnam) ".snd"))
	(set! stopped (execute-and-wait (make-cmd (vector-ref input-names i) (vector-ref output-names i)))))
      (temps-to-sound data output-names description))))

</pre></td></tr></table>

<p>If this is too ugly, we could probably use append-to-minibuffer instead
of write-char.  In Clisp, use the -x switch without the exit function call.
Also, place the expression to be evaluated in double quotes, rather than 
ACL's single quotes.
</p>

<br>
<span class=bbox><h3><A NAME="sndaswidget">Snd as a Widget</a></h3></span>

<p>To include the entire Snd editor as a widget in some other program,
first compile it with -DSND_AS_WIDGET. Then load it into your program,
using the procedure <b>snd_as_widget</b> to fire it up.  The program
saw.c included with Snd is a very brief example.</p>

<pre>
  void snd_as_widget(int argc, char **argv, XtAppContext app, Widget parent, Arg *caller_args, int caller_argn)
</pre>

<p>starts up the Snd editor in the widget <i>parent</i>, passing the outer Snd
form widget the arguments <i>caller_args</i> and <i>caller_argn</i>.  The
enclosing application context is <i>app</i>.  <i>parent</i> needs to
be realized at the time of the call, since Snd uses it to set up graphics
contexts and so on.  <i>argc</i> and <i>argv</i> can be passed to
simulate a shell invocation of Snd.  Remember that in this case, the
first string argument is expected to be the application name, and is
ignored by Snd.</p>

<p>In Gtk, the arguments are different, but the basic idea is the same.
saw.c has an example.</p>

<br>
<span class=bbox><h3><A NAME="sndwithclm">Snd and the CLM module</a></h3></span>

<p>The files clm.c, clm.h, and clm2scm.c implement CLM (a Common Lisp Music V implementation
described in clm.html, available in clm-2.tar.gz at ccrma-ftp) as a Guile-loadable module.
They are normally loaded into Snd when it is built.
You can see what a generator does, or a group of generators, by running them in the
lisp listener, and using the graph and spectrum functions.  For example, say we have
these declarations in ~/.snd:
</p>

<table border=1 cellpadding=5><tr><td bgcolor="beige"><pre>
(define data-size 1024)
(define data (make-vct data-size))

(define run 
  (lambda (fun)
    (do ((i 0 (1+ i))) 
        ((= i data-size))
      (vct-set! data i (fun)))
    (graph data)))

(define runf
  (lambda (fun)
    (do ((i 0 (1+ i))) 
        ((= i data-size))
      (vct-set! data i (fun)))
    (graph (snd-spectrum data blackman2-window data-size #t))))
</pre></td></tr></table>

<p>Now we can open the listener, and type:<p>
<pre>
(define hi (make-oscil))
(run (lambda () (oscil hi)))
(define ho (make-oscil))
(runf (lambda () (oscil hi (* .5 (oscil ho)))))
</pre>
<p>Obviously, any CLM instrument or function can be used in this way 
to edit sounds, and so on.  Say we want an echo effect:</p>

<table border=1 cellpadding=5><tr><td bgcolor="beige"><pre>
(define echo 
  (lambda (scaler secs)
    (let ((del (make-delay (round (* secs (srate))))))
      (lambda (inval)
        (+ inval (delay del (* scaler (+ (tap del) inval))))))))
</pre></td></tr></table>

<p>For readers who are new to Scheme, <i>echo</i> is a function
of two arguments, <i>scaler</i> and <i>secs</i>.  Scaler sets
how loud subsequent echos are, and secs sets how far apart they
are in seconds.  <i>echo</i> uses the <i>secs</i> argument to create
a delay line (<i>make-delay</i>) using the current sound's
sampling rate to turn the <i>secs</i> parameter into samples.
<i>echo</i> then returns a "closure", that is, a function with
associated variables (in this case <i>del</i> and <i>scaler</i>);
the returned function (the second <i>lambda</i>) takes
one argument (<i>inval</i>) and returns the result of passing
that value to the delay with scaling.  The upshot of all this is that
we can use:</p>
<pre>
(map-chan (echo .5 .75) 0 44100)
</pre>
<p>to take the current active channel and 
return 44100 samples of echos, each echo half the amplitude
of the previous, and spaced by .75 seconds.  <i>map-chan</i>'s
first argument is a function of one argument, the current sample;
when we pass it <i>(echo ...)</i>, it evaluates the echo call,
which returns the function that actually runs the delay line,
producing the echo.  
The CLM (common lisp) version might be something like:</p>

<table border=1 cellpadding=5><tr><td bgcolor="beige"><pre>
(definstrument echo (beg dur scaler secs file)
  (let ((del (make-delay (round (* secs *srate*))))
	(inf (open-input file))
	(j 0))
    (run
     (loop for i from beg below (+ beg dur) do
       (let ((inval (ina j inf)))
	 (outa i (+ inval (delay del (* scaler (+ (tap del) inval)))))
	 (incf j))))
    (close-input inf)))

;;; (with-sound () (echo 0 60000 .5 1.0 "pistol.snd"))
</pre></td></tr></table>

<br>
<span class=cbox><h4><A NAME="clmfuncs">CLM functions</a></h4></span>

<p>See <a href="clm.html">clm.html</a> for full details. Optional args are in italics.</p>
<br>

<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href="clm.html#all-pass">all-pass</a></td><td>(gen input <i>pm</i>)</td><td>all-pass filter</td></tr>
<tr><td><a href="clm.html#all-pass?">all-pass?</a></td><td>(gen)</td><td>#t if gen is all-pass filter</td></tr>
<tr><td><a href="clm.html#amplitude-modulate">amplitude-modulate</a></td><td>(carrier in1 in2)</td><td>amplitude modulation</td></tr>
<tr><td><a href="clm.html#array-interp">array-interp</a></td><td>(arr x)</td><td>interpolated array lookup</td></tr>
<tr><td><a href="clm.html#array-&gt;file">array-&gt;file</a></td><td colspan=2>(filename vct len srate channels)</td></tr>
<tr><td></td><td colspan=2>
write the contents of <i>vct</i> to the newly created sound file <i>filename</i>, giving 
the new file <i>channels</i> channels (data assumed to be interleaved in <i>vct</i>),
sampling rate <i>srate</i>, and <i>len</i> samples (not frames).
</td></tr>
<tr><td><a href="clm.html#asymmetric-fm">asymmetric-fm</a></td><td>(gen index <i>fm</i>)</td><td>asymmetric-fm generator</td></tr>
<tr><td><a href="clm.html#asymmetric-fm?">asymmetric-fm?</a></td><td>(gen)</td><td>#t if gen is asymmetric-fm generator</td></tr>
<tr><td><a href="clm.html#buffer-&gt;frame">buffer-&gt;frame</a></td><td>(gen frame)</td><td>buffer generator returning frame</td></tr>
<tr><td><a href="clm.html#buffer-&gt;sample">buffer-&gt;sample</a></td><td>(gen)</td><td>buffer generator returning sample</td></tr>
<tr><td><a href="clm.html#buffer-empty?">buffer-empty?</a></td><td>(gen)</td><td>#t if buffer has no data</td></tr>
<tr><td><a href="clm.html#buffer-full?">buffer-full?</a></td><td>(gen)</td><td>#t if buffer has no room for more data</td></tr>
<tr><td><a href="clm.html#buffer?">buffer?</a></td><td>(gen)</td><td>#t if gen is buffer generator</td></tr>
<tr><td><a href="clm.html#clear-array">clear-array</a></td><td>(arr)</td><td>set all elements of arr to 0.0</td></tr>
<tr><td><a href="clm.html#comb">comb</a></td><td>(gen input <i>pm</i>)</td><td>comb filter</td></tr>
<tr><td><a href="clm.html#comb?">comb?</a></td><td>(gen)</td><td>#t if gen is comb filter</td></tr>
<tr><td><a href="clm.html#contrast-enhancement">contrast-enhancement</a></td><td>(input (<i>index</i> 1.0))</td><td>a kind of phase modulation or companding</td></tr>
<tr><td><a href="clm.html#convolution">convolution</a></td><td>(sig1 sig2 n)</td><td>convolve sig1 with sig2 (size n), returning new sig1</td></tr>
<tr><td><a href="clm.html#convolve">convolve</a></td><td>(gen <i>input-function</i>)</td><td>convolve generator</td></tr>
<tr><td><a href="clm.html#convolve?">convolve?</a></td><td>(gen)</td><td>#t if gen is convolve generator</td></tr>
<tr><td><a href="clm.html#convolvefiles">convolve-files</a></td><td>(f1 f2 maxamp outf)</td><td>convolve f1 with f2, normalize to maxamp, write outf</td></tr>
<tr><td><a href="clm.html#db-&gt;linear">db-&gt;linear</a></td><td>(db)</td><td>translate dB value to linear</td></tr>
<tr><td><a href="clm.html#degrees-&gt;radians">degrees-&gt;radians</a></td><td>(deg)</td><td>translate degrees to radians</td></tr>
<tr><td><a href="clm.html#delay">delay</a></td><td>(gen input <i>pm</i>)</td><td>delay line</td></tr>
<tr><td></td><td colspan=2><br>
<b>delay</b> is a built-in syntactic form. The name <b>%delay</b> is bound
to the original meaning of <b>delay</b> in case you need to use it.
</td></tr>
<tr><td colspan=3><br></td></tr>
<tr><td><a href="clm.html#delay?">delay?</a></td><td>(gen)</td><td>#t if gen is delay line</td></tr>
<tr><td><a href="clm.html#dot-product">dot-product</a></td><td>(sig1 sig2)</td><td>return dot-product of sig1 with sig2</td></tr>
<tr><td><a href="clm.html#env">env</a></td><td>(gen)</td><td>envelope generator</td></tr>
<tr><td><a href="clm.html#env-interp">env-interp</a></td><td>(x env (<i>base</i> 1.0))</td><td>return value of env at x</td></tr>
<tr><td><a href="clm.html#env?">env?</a></td><td>(gen)</td><td>#t if gen is env (from make-env)</td></tr>
<tr><td><a href="clm.html#fft">mus-fft</a></td><td>(rl im n sign)</td><td>fft of rl and im (sign = -1 for ifft), result in rl</td></tr>
<tr><td valign=top><a href="clm.html#file-&gt;array">file-&gt;array</a></td><td valign=top>(filename chan start len vct)</td><td>
load <i>len</i> samples of <i>filename</i> into <i>vct</i> starting at frame <i>start</i> in channel <i>chan</i>.
</td></tr>
<tr><td><a href="clm.html#file-&gt;frame">file-&gt;frame</a></td><td>(gen loc <i>frame</i>)</td><td>return frame from file at loc</td></tr>
<tr><td><a href="clm.html#file-&gt;frame?">file-&gt;frame?</a></td><td>(gen)</td><td>#t if gen is file-&gt;frame generator</td></tr>
<tr><td><a href="clm.html#file-&gt;sample">file-&gt;sample</a></td><td>(gen loc <i>(chan 0)</i>)</td><td>return sample from file at loc</td></tr>
<tr><td><a href="clm.html#file-&gt;sample?">file-&gt;sample?</a></td><td>(gen)</td><td>#t if gen is file-&gt;sample generator</td></tr>
<tr><td><a href="clm.html#filter">filter</a></td><td>(gen input)</td><td>filter</td></tr>
<tr><td><a href="clm.html#filter?">filter?</a></td><td>(gen)</td><td>#t if gen is filter</td></tr>
<tr><td><a href="clm.html#fir-filter">fir-filter</a></td><td>(gen input)</td><td>FIR filter</td></tr>
<tr><td><a href="clm.html#fir-filter?">fir-filter?</a></td><td>(gen)</td><td>#t if gen is fir filter</td></tr>
<tr><td><a href="clm.html#formant">formant</a></td><td>(gen input)</td><td>formant generator</td></tr>
<tr><td>formant-bank</td><td>(scls gens inval)</td><td></td></tr>
<tr><td><a href="clm.html#formant?">formant?</a></td><td>(gen)</td><td>#t if gen is formant generator</td></tr>
<tr><td><a href="clm.html#frame*">frame*</a></td><td>(fr1 fr2 <i>outfr</i>)</td><td>element-wise multiply</td></tr>
<tr><td><a href="clm.html#frame+">frame+</a></td><td>(fr1 fr2 <i>outfr</i>)</td><td>element-wise add</td></tr>
<tr><td><a href="clm.html#frame-&gt;buffer">frame-&gt;buffer</a></td><td>(buf frame)</td><td>add frame to buffer</td></tr>
<tr><td><a href="clm.html#frame-&gt;file">frame-&gt;file</a></td><td>(gen loc frame)</td><td>write (add) frame to file at loc</td></tr>
<tr><td><a href="clm.html#frame-&gt;file?">frame-&gt;file?</a></td><td>(gen)</td><td>#t if gen is frame-&gt;file generator</td></tr>
<tr><td><a href="clm.html#frame-&gt;frame">frame-&gt;frame</a></td><td>(mixer frame <i>outfr</i>)</td><td>pass frame through mixer</td></tr>
<tr><td><a href="clm.html#frame-&gt;list">frame-&gt;list</a></td><td>(frame)</td><td>return list of frame contents</td></tr>
<tr><td><a href="clm.html#frame-ref">frame-ref</a></td><td>(frame chan)</td><td>return frame[chan]</td></tr>
<tr><td><a href="clm.html#frame-&gt;sample">frame-&gt;sample</a></td><td>(frmix frame)</td><td>pass frame through frame or mixer to produce sample</td></tr>
<tr><td><a href="clm.html#frame-set!">frame-set!</a></td><td>(frame chan val)</td><td>frame[chan]=val</td></tr>
<tr><td><a href="clm.html#frame?">frame?</a></td><td>(gen)</td><td>#t if gen is frame object</td></tr>
<tr><td><a href="clm.html#granulate">granulate</a></td><td>(gen <i>input-function</i>)</td><td>granular synthesis generator</td></tr>
<tr><td><a href="clm.html#granulate?">granulate?</a></td><td>(gen)</td><td>#t if gen is granulate generator</td></tr>
<tr><td><a href="clm.html#hz-&gt;radians">hz-&gt;radians</a></td><td>(freq)</td><td>translate freq to radians/sample</td></tr>
<tr><td><a href="clm.html#iir-filter">iir-filter</a></td><td>(gen input)</td><td>IIR filter</td></tr>
<tr><td><a href="clm.html#iir-filter?">iir-filter?</a></td><td>(gen)</td><td>#t if gen is iir-filter</td></tr>
<tr><td><a href="clm.html#in-any">in-any</a></td><td>(loc <i>chan stream</i>)</td><td>return sample in stream at loc and chan</td></tr>
<tr><td>in-hz</td><td>(freq)</td><td>translate freq to radians/sample</td></tr>
<tr><td><a href="clm.html#ina">ina</a></td><td>(loc <i>stream</i>)</td><td>return sample in stream at loc, chan 0</td></tr>
<tr><td><a href="clm.html#inb">inb</a></td><td>(loc <i>stream</i>)</td><td>return sample in stream at loc, chan 1</td></tr>
<tr><td><a href="clm.html#linear-&gt;db">linear-&gt;db</a></td><td>(val)</td><td>translate linear val to dB</td></tr>
<tr><td><a href="clm.html#locsig">locsig</a></td><td>(gen loc input)</td><td>place input in output channels at loc</td></tr>
<tr><td><a href="clm.html#locsig-ref">locsig-ref</a></td><td>(gen chan)</td><td>locsig-scaler[chan]</td></tr>
<tr><td><a href="clm.html#locsig-reverb-ref">locsig-reverb-ref</a></td><td>(gen chan)</td><td>locsig-reverb-scaler[chan]</td></tr>
<tr><td><a href="clm.html#locsig-set!">locsig-set!</a></td><td>(gen chan val)</td><td>locsig-scaler[chan] = val</td></tr>
<tr><td><a href="clm.html#locsig-reverb-set!">locsig-reverb-set!</a></td><td>(gen chan val)</td><td>locsig-reverb-scaler[chan] = val</td></tr>
<tr><td><a href="clm.html#locsig?">locsig?</a></td><td>(gen)</td><td>#t if gen is locsig generator</td></tr>
<tr><td colspan=3><br>
;; all the make function arguments are <a href="clm.html#optional-key">optional-key</a> args
</td></tr>
<tr><td><a href="clm.html#make-all-pass">make-all-pass</a></td><td colspan=2>(feedback feedforward size initial-contents initial-element max-size)</td></tr>
<tr><td><a href="clm.html#make-asymmetric-fm">make-asymmetric-fm</a></td><td colspan=2>(frequency initial-phase r ratio)</td></tr>
<tr><td><a href="clm.html#make-buffer">make-buffer</a></td><td colspan=2>(size fill-time)</td></tr>
<tr><td><a href="clm.html#make-comb">make-comb</a></td><td colspan=2>(scaler size initial-contents initial-element max-size)</td></tr>
<tr><td><a href="clm.html#make-convolve">make-convolve</a></td><td colspan=2>(input filter fft-size filter-size)</td></tr>
<tr><td><a href="clm.html#make-delay">make-delay</a></td><td colspan=2>(size initial-contents initial-element max-size)</td></tr>
<tr><td><a href="clm.html#make-env">make-env</a></td><td colspan=2>(envelope scaler duration offset base end start)</td></tr>
<tr><td><a href="clm.html#make-fft-window">make-fft-window</a></td colspan=2><td>(type size beta)</td></tr>
<tr><td><a href="clm.html#make-file-&gt;frame">make-file-&gt;frame</a></td><td colspan=2>(name)</td></tr>
<tr><td><a href="clm.html#make-file-&gt;sample">make-file-&gt;sample</a></td><td colspan=2>(name)</td></tr>
<tr><td><a href="clm.html#make-filter">make-filter</a></td><td colspan=2>(order xcoeffs ycoeffs)</td></tr>
<tr><td><a href="clm.html#make-fir-filter">make-fir-filter</a></td><td colspan=2>(order xcoeffs)</td></tr>
<tr><td><a href="clm.html#make-formant">make-formant</a></td><td colspan=2>(radius frequency gain)</td></tr>
<tr><td><a href="clm.html#make-frame">make-frame</a></td><td colspan=2>(chans &amp;rest vals)</td></tr>
<tr><td><a href="clm.html#make-frame-&gt;file">make-frame-&gt;file</a></td><td colspan=2>(name chans format type)</td></tr>
<tr><td><a href="clm.html#make-granulate">make-granulate</a></td><td colspan=2>(input expansion length scaler hop ramp jitter max-size)</td></tr>
<tr><td><a href="clm.html#make-iir-filter">make-iir-filter</a></td><td colspan=2>(order ycoeffs)</td></tr>
<tr><td><a href="clm.html#make-locsig">make-locsig</a></td><td colspan=2>(degree distance reverb output revout channels)</td></tr>
<tr><td><a href="clm.html#make-mixer">make-mixer</a></td><td colspan=2>(chans &amp;rest vals)</td></tr>
<tr><td><a href="clm.html#make-notch">make-notch</a></td><td colspan=2>(scaler size initial-contents initial-element max-size)</td></tr>
<tr><td><a href="clm.html#make-one-pole">make-one-pole</a></td><td colspan=2>(a0 b1)</td></tr>
<tr><td><a href="clm.html#make-one-zero">make-one-zero</a></td><td colspan=2>(a0 a1)</td></tr>
<tr><td><a href="clm.html#make-oscil">make-oscil</a></td><td colspan=2>(frequency initial-phase)</td></tr>
<tr><td><a href="clm.html#make-phase-vocoder">make-phase-vocoder</a></td><td colspan=2>(fftsize overlap interp pitch analyze edit synthesize)</td></tr>
<tr><td><a href="clm.html#make-ppolar">make-ppolar</a></td><td colspan=2>(radius frequency)</td></tr>
<tr><td><a href="clm.html#make-pulse-train">make-pulse-train</a></td><td colspan=2>(frequency amplitude initial-phase)</td></tr>
<tr><td><a href="clm.html#make-rand">make-rand</a></td><td colspan=2>(frequency amplitude)</td></tr>
<tr><td><a href="clm.html#make-rand-interp">make-rand-interp</a></td><td colspan=2>(frequency amplitude)</td></tr>
<tr><td><a href="clm.html#make-readin">make-readin</a></td><td colspan=2>(file channel start)</td></tr>
<tr><td><a href="clm.html#make-sample-&gt;file">make-sample-&gt;file</a></td><td colspan=2>(name chans format type <i>comment</i>)</td></tr>
<tr><td><a href="clm.html#make-sawtooth-wave">make-sawtooth-wave</a></td><td colspan=2>(frequency amplitude initial-phase)</td></tr>
<tr><td><a href="clm.html#make-sine-summation">make-sine-summation</a></td><td colspan=2>(frequency initial-phase n a ratio)</td></tr>
<tr><td><a href="clm.html#make-square-wave">make-square-wave</a></td><td colspan=2>(frequency amplitude initial-phase)</td></tr>
<tr><td><a href="clm.html#make-src">make-src</a></td><td colspan=2>(input srate width)</td></tr>
<tr><td><a href="clm.html#make-sum-of-cosines">make-sum-of-cosines</a></td><td colspan=2>(frequency initial-phase cosines)</td></tr>
<tr><td><a href="clm.html#make-table-lookup">make-table-lookup</a></td><td colspan=2>(frequency initial-phase wave)</td></tr>
<tr><td><a href="clm.html#make-triangle-wave">make-triangle-wave</a></td><td colspan=2>(frequency amplitude initial-phase)</td></tr>
<tr><td><a href="clm.html#make-two-pole">make-two-pole</a></td><td colspan=2>(a0 b1 b2)</td></tr>
<tr><td><a href="clm.html#make-two-zero">make-two-zero</a></td><td colspan=2>(a0 a1 a2)</td></tr>
<tr><td><a href="clm.html#make-wave-train">make-wave-train</a></td><td colspan=2>(frequency initial-phase wave)</td></tr>
<tr><td><a href="clm.html#make-waveshape">make-waveshape</a></td><td colspan=2>(frequency partials)</td></tr>
<tr><td><a href="clm.html#make-zpolar">make-zpolar</a></td><td colspan=2>(radius frequency)</td></tr>
<tr><td><a href="clm.html#mixer*">mixer*</a></td><td>(mix1 mix2 <i>outmx</i>)</td><td>matrix multiply of mix1 and mix2</td></tr>
<tr><td><a href="clm.html#mixer-ref">mixer-ref</a></td><td>(mix in out)</td><td>mix-scaler[in,out]</td></tr>
<tr><td><a href="clm.html#mixer-set!">mixer-set!</a></td><td>(mix in out val)</td><td>mix-scaler[in,out] = val</td></tr>
<tr><td><a href="clm.html#mixer?">mixer?</a></td><td>(gen)</td><td>#t if gen is mixer object</td></tr>
<tr><td><a href="clm.html#multiply-arrays">multiply-arrays</a></td><td>(arr1 arr2)</td><td>arr1[i] *= arr2[i]</td></tr>
<tr><td><a href="clm.html#mus-a0">mus-a0</a></td><td>(gen)</td><td>a0 field (simple filters)</td></tr>
<tr><td><a href="clm.html#mus-a1">mus-a1</a></td><td>(gen)</td><td>a1 field (simple filters)</td></tr>
<tr><td><a href="clm.html#mus-a2">mus-a2</a></td><td>(gen)</td><td>a2 field (simple filters)</td></tr>
<tr><td>mus-array-print-length</td><td>()</td><td>how many array elements to print in mus_describe</td></tr>
<tr><td><a href="clm.html#mus-b1">mus-b1</a></td><td>(gen)</td><td>b1 field (simple filters)</td></tr>
<tr><td><a href="clm.html#mus-b2">mus-b2</a></td><td>(gen)</td><td>b2 field (simple filters)</td></tr>
<tr><td><a href="clm.html#musbank">mus-bank</a></td><td>(gens amps <i>args1 args2</i>)</td><td></td></tr>
<tr><td><a href="clm.html#mus-channel">mus-channel</a></td><td>(gen)</td><td>channel of gen</td></tr>
<tr><td><a href="clm.html#mus-channels">mus-channels</a></td><td>(gen)</td><td>channels of gen</td></tr>
<tr><td><a href="clm.html#mus-cosines">mus-cosines</a></td><td>(gen)</td><td>cosines of sum-of-cosines gen</td></tr>
<tr><td><a href="clm.html#mus-data">mus-data</a></td><td>(gen)</td><td>data array of gen</td></tr>
<tr><td><a href="clm.html#mus-feedback">mus-feedback</a></td><td>(gen)</td><td>feedback term of gen (simple filters)</td></tr>
<tr><td><a href="clm.html#mus-feedforward">mus-feedforward</a></td><td>(gen)</td><td>feedforward term of gen (all-pass)</td></tr>
<tr><td>mus-file-buffer-size</td><td>()</td><td>size of input/ouput buffers (default 8192)</td></tr>
<tr><td><a href="clm.html#mus-formant-radius">mus-formant-radius</a></td><td>(gen)</td><td>formant radius</td></tr>
<tr><td><a href="clm.html#mus-frequency">mus-frequency</a></td><td>(gen)</td><td>frequency of gen (Hz)</td></tr>
<tr><td><a href="clm.html#mus-hop">mus-hop</a></td><td>(gen)</td><td>hop amount of gen (granulate)</td></tr>
<tr><td><a href="clm.html#mus-increment">mus-increment</a></td><td>(gen)</td><td>increment of gen (src, readin, granulate)</td></tr>
<tr><td><a href="clm.html#mus-input?">mus-input?</a></td><td>(gen)</td><td>#t if gen is input source</td></tr>
<tr><td><a href="clm.html#mus-length">mus-length</a></td><td>(gen)</td><td>length of gen</td></tr>
<tr><td><a href="clm.html#mus-location">mus-location</a></td><td>(gen)</td><td>location (read point) of gen</td></tr>
<tr><td>mus-mix</td><td colspan=2>(outfile infile <i>(outloc 0) frames (inloc 0) mixer envs</i>)</td></tr>
<tr><td></td><td colspan=2><br>
mix <i>infile</i> into <i>outfile</i> starting at <i>outloc</i> in <i>outfile</i> and <i>inloc</i> in <i>infile</i>
mixing <i>frames</i> frames of <i>infile</i>.  <i>frames</i> defaults to the length of <i>infile</i>. If <i>mixer</i>,
use it to scale the various channels; if <i>envs</i> (an array of envelope generators), use
it in conjunction with <i>mixer</i>to scale/envelope all the various ins and outs.
</td></tr>
<tr><td colspan=3><br></td></tr>
<tr><td><a href="clm.html#mus-order">mus-order</a></td><td>(gen)</td><td>order of gen (filters)</td></tr>
<tr><td><a href="clm.html#mus-output?">mus-output?</a></td><td>(gen)</td><td>#t if gen is output generator</td></tr>
<tr><td><a href="clm.html#mus-phase">mus-phase</a></td><td>(gen)</td><td>phase of gen (radians)</td></tr>
<tr><td><a href="clm.html#mus-ramp">mus-ramp</a></td><td>(gen)</td><td>ramp time of gen (granulate)</td></tr>
<tr><td><a href="clm.html#mus-random">mus-random</a></td><td>(val)</td><td>random numbers bewteen -val and val</td></tr>
<tr><td><a href="clm.html#mus-run">mus-run</a></td><td>(gen <i>arg1 arg2</i>)</td><td>apply gen to args</td></tr>
<tr><td><a href="clm.html#mus-scaler">mus-scaler</a></td><td>(gen)</td><td>scaler of gen</td></tr>
<tr><td><a href="clm.html#mus-rand-seed">mus-rand-seed</a></td><td>(val)</td><td>random number generator seed (settable via set!)</td></tr>
<tr><td>mus-set-srate</td><td>(val)</td><td>set sampling rate to val -- (set! (mus-srate) val) is the same.</td></tr>
<tr><td>mus-srate</td><td>()</td><td>current sampling rate</td></tr>
<tr><td><a href="clm.html#mus-xcoeffs">mus-xcoeffs</a></td><td>(gen)</td><td>feedforward (FIR) coeffs of filter</td></tr>
<tr><td><a href="clm.html#mus-ycoeffs">mus-ycoeffs</a></td><td>(gen)</td><td>feedback (IIR) coeefs of filter</td></tr>
<tr><td><a href="clm.html#notch">notch</a></td><td>(gen input <i>pm</i>)</td><td>notch filter</td></tr>
<tr><td><a href="clm.html#notch?">notch?</a></td><td>(gen)</td><td>#t if gen is notch filter</td></tr>
<tr><td><a href="clm.html#one-pole">one-pole</a></td><td>(gen input)</td><td>one-pole filter</td></tr>
<tr><td><a href="clm.html#one-pole?">one-pole?</a></td><td>(gen)</td><td>#t if gen is one-pole filter</td></tr>
<tr><td><a href="clm.html#one-zero">one-zero</a></td><td>(gen input)</td><td>one-zero filter</td></tr>
<tr><td><a href="clm.html#one-zero?">one-zero?</a></td><td>(gen)</td><td>#t if gen is one-zero filter</td></tr>
<tr><td><a href="clm.html#oscil">oscil</a></td><td>(gen <i>fm pm</i>)</td><td>sine wave generator</td></tr>
<tr><td><a href="clm.html#oscilbank">oscil-bank</a></td><td>(scls gens invals)</td><td>bank of oscils</td></tr>
<tr><td><a href="clm.html#oscil?">oscil?</a></td><td>(gen)</td><td>#t if gen is oscil generator</td></tr>
<tr><td><a href="clm.html#out-any">out-any</a></td><td>(loc samp chan <i>stream</i>)</td><td>write (add) samp to stream at loc in channel chan</td></tr>
<tr><td><a href="clm.html#outa">outa</a></td><td>(loc samp <i>stream</i>)</td><td>write (add) samp to stream at loc in chan 0</td></tr>
<tr><td><a href="clm.html#outb">outb</a></td><td>(loc samp <i>stream</i>)</td><td>write (add) samp to stream at loc in chan 1</td></tr>
<tr><td><a href="clm.html#outc">outc</a></td><td>(loc samp <i>stream</i>)</td><td>write (add) samp to stream at loc in chan 2</td></tr>
<tr><td><a href="clm.html#outd">outd</a></td><td>(loc samp <i>stream</i>)</td><td>write (add) samp to stream at loc in chan 3</td></tr>
<tr><td><a href="clm.html#partials-&gt;polynomial">partials-&gt;polynomial</a></td><td>(partials <i>kind</i>)</td><td>create waveshaping polynomial from partials</td></tr>
<tr><td><a href="clm.html#partials-&gt;wave">partials-&gt;wave</a></td><td>(synth-data table <i>norm</i>)</td><td>load table from synth-data</td></tr>
<tr><td><a href="clm.html#partials-&gt;waveshape">partials-&gt;waveshape</a></td><td>(partials <i>norm size</i>)</td><td>create waveshaping table from partials</td></tr>
<tr><td><a href="clm.html#phase-partials-&gt;wave">phase-partials-&gt;wave</a></td><td>(synth-data table <i>norm</i>)</td><td>load table from synth-data</td></tr>
<tr><td><a href="clm.html#phase-vocoder">phase-vocoder</a></td><td>(pv input)</td><td>phase vocoder generator</td></tr>
<tr><td><a href="clm.html#phase-vocoder?">phase-vocoder?</a></td><td>(pv)</td><td>#t if pv is phase vocoder generator</td></tr>
<tr><td><a href="clm.html#polynomial">polynomial</a></td><td>(coeffs x)</td><td>evaluate polynomial at x</td></tr>
<tr><td><a href="clm.html#pulse-train">pulse-train</a></td><td>(gen <i>fm</i>)</td><td>pulse-train generator</td></tr>
<tr><td><a href="clm.html#pulse-train?">pulse-train?</a></td><td>(gen)</td><td>#t if gen is pulse-train generator</td></tr>
<tr><td><a href="clm.html#radians-&gt;degrees">radians-&gt;degrees</a></td><td>(rads)</td><td>convert radians to degrees</td></tr>
<tr><td><a href="clm.html#radians-&gt;hz">radians-&gt;hz</a></td><td>(rads)</td><td>convert radians/sample to Hz</td></tr>
<tr><td><a href="clm.html#rand">rand</a></td><td>(gen <i>fm</i>)</td><td>random number generator</td></tr>
<tr><td><a href="clm.html#rand-interp">rand-interp</a></td><td>(gen <i>fm</i>)</td><td>interpolating random number generator</td></tr>
<tr><td><a href="clm.html#rand-interp?">rand-interp?</a></td><td>(gen)</td><td>#t if gen is interpolating random number generator</td></tr>
<tr><td><a href="clm.html#rand?">rand?</a></td><td>(gen)</td><td>#t if gen is random number generator</td></tr>
<tr><td><a href="clm.html#readin">readin</a></td><td>(gen)</td><td>read one value from associated input stream</td></tr>
<tr><td><a href="clm.html#readin?">readin?</a></td><td>(gen)</td><td>#t if gen is readin generator</td></tr>
<tr><td><a href="clm.html#rectangular-&gt;polar">rectangular-&gt;polar</a></td><td>(rl im)</td><td>translate from rectangular to polar coordinates</td></tr>
<tr><td><a href="clm.html#restart-env">restart-env</a></td><td>(env)</td><td>return to start of env</td></tr>
<tr><td><a href="clm.html#ring-modulate">ring-modulate</a></td><td>(sig1 sig2)</td><td>sig1 * sig2 (element-wise)</td></tr>
<tr><td><a href="clm.html#sample-&gt;buffer">sample-&gt;buffer</a></td><td>(buf samp)</td><td>store samp in buffer</td></tr>
<tr><td><a href="clm.html#sample-&gt;file">sample-&gt;file</a></td><td>(gen loc chan val)</td><td>store val in file at loc in channel chan</td></tr>
<tr><td><a href="clm.html#sample-&gt;file?">sample-&gt;file?</a></td><td>(gen)</td><td>#t if gen is sample-&gt;file generator</td></tr>
<tr><td><a href="clm.html#sample-&gt;frame">sample-&gt;frame</a></td><td>(frmix samp <i>outfr</i>)</td><td>convert samp to frame</td></tr>
<tr><td><a href="clm.html#sawtooth-wave">sawtooth-wave</a></td><td>(gen <i>fm</i>)</td><td>sawtooth-wave generator</td></tr>
<tr><td><a href="clm.html#sawtooth-wave?">sawtooth-wave?</a></td><td>(gen)</td><td>#t if gen is sawtooth-wave generator</td></tr>
<tr><td><a href="clm.html#sine-summation">sine-summation</a></td><td>(gen <i>fm</i>)</td><td>sine-summation generator</td></tr>
<tr><td><a href="clm.html#sine-summation?">sine-summation?</a></td><td>(gen)</td><td>#t if gen is sine-summation generator</td></tr>
<tr><td><a href="clm.html#spectrum">spectrum</a></td><td>(rl im win type)</td><td>produce spectrum of data in rl (return rl)</td></tr>
<tr><td><a href="clm.html#square-wave">square-wave</a></td><td>(gen <i>fm</i>)</td><td>square-wave generator</td></tr>
<tr><td><a href="clm.html#square-wave?">square-wave?</a></td><td>(gen)</td><td>#t if gen is square-wave generator</td></tr>
<tr><td><a href="clm.html#src">src</a></td><td>(gen <i>fm input-function</i>)</td><td>sample rate converter</td></tr>
<tr><td><a href="clm.html#src?">src?</a></td><td>(gen)</td><td>#t if gen is sample-rate converter</td></tr>
<tr><td><a href="clm.html#sum-of-cosines">sum-of-cosines</a></td><td>(gen <i>fm</i>)</td><td>sum-of-cosines (pulse-train) generator</td></tr>
<tr><td><a href="clm.html#sum-of-cosines?">sum-of-cosines?</a></td><td>(gen)</td><td>#t if gen is sum-of-cosines generator</td></tr>
<tr><td><a href="clm.html#sum-of-sines">sum-of-sines</a></td><td>(amps phases)</td><td>additive synthesis</td></tr>
<tr><td><a href="clm.html#table-lookup">table-lookup</a></td><td>(gen <i>fm</i>)</td><td>table-lookup generator</td></tr>
<tr><td><a href="clm.html#table-lookup?">table-lookup?</a></td><td>(gen)</td><td>#t if gen is table-lookup generator</td></tr>
<tr><td><a href="clm.html#tap">tap</a></td><td>(gen <i>pm</i>)</td><td>delay line tap</td></tr>
<tr><td><a href="clm.html#triangle-wave">triangle-wave</a></td><td>(gen <i>fm</i>)</td><td>triangle-wave generator</td></tr>
<tr><td><a href="clm.html#triangle-wave?">triangle-wave?</a></td><td>(gen)</td><td>#t if gen is triangle-wave generator</td></tr>
<tr><td><a href="clm.html#two-pole">two-pole</a></td><td>(gen input)</td><td>two-pole filter</td></tr>
<tr><td><a href="clm.html#two-pole?">two-pole?</a></td><td>(gen)</td><td>#t if gen is two-pole filter</td></tr>
<tr><td><a href="clm.html#two-zero">two-zero</a></td><td>(gen input)</td><td>two-zero filter</td></tr>
<tr><td><a href="clm.html#two-zero?">two-zero?</a></td><td>(gen)</td><td>#t if gen is two-zero filter</td></tr>
<tr><td><a href="clm.html#wave-train">wave-train</a></td><td>(gen <i>fm</i>)</td><td>wave-train generator</td></tr>
<tr><td><a href="clm.html#wave-train?">wave-train?</a></td><td>(gen)</td><td>#t if gen is wave-train generator</td></tr>
<tr><td><a href="clm.html#waveshape">waveshape</a></td><td>(gen <i>index fm</i>)</td><td>waveshaping generator</td></tr>
<tr><td><a href="clm.html#waveshape?">waveshape?</a></td><td>(gen)</td><td>#t if gen is waveshape generator</td></tr>
</table>
<br>

<p><b>formant-bank</b> and <b>oscil-bank</b> are optimizations for situations like the phase
vocoder or cross synthesis (see <a href="sndscm.html#exampdoc">examp.scm</a>).  It is assumed that you have a vector of generators,
all summing their outputs into a single float.  The amplitude scalers (the first argument to
the bank function) can be a float, a vector of floats, a vct of floats, or a function that
returns a float each time it is called; similarly for the inputs (the third argument); the
bank of generators (the second argument) is assumed to be a vector full of generators. </p>
<pre>
  (formant-bank amps gens inval)
</pre>
<p>is essentially the same as (but 30 times faster than)</p>
<pre>
  (do ((sum 0.0)
       (i 0 (1+ i))) 
      ((= i (vct-length gens)) sum)
    (set! sum (+ sum (* (vector-ref amps i)
                        (formant (vector-ref gens i) inval)))))
</pre>
<p>in the all-vector case.  <a href="clm.html#musbank">mus-bank</a> is the general case.
Here are a few more examples, taken from <a href="sndscm.html#exampdoc">examp.scm</a>.
</p>
<pre>


(define comb-filter 
  (lambda (scaler size)
    (let ((cmb (make-comb scaler size)))
      (lambda (x) (comb cmb x)))))

; (map-chan (comb-filter .8 32))

;;; by using filters at harmonically related sizes, we can get chords:

(define comb-chord
  (lambda (scaler size amp)
    (let ((c1 (make-comb scaler size))
	  (c2 (make-comb scaler (* size .75)))
	  (c3 (make-comb scaler (* size 1.2))))
      (lambda (x)
        (* amp (+ (comb c1 x) (comb c2 x) (comb c3 x)))))))

; (map-chan (comb-chord .95 60 .3))

;;; or change the comb length via an envelope:

(define max-envelope
  (lambda (e mx)
    (if (null? e)
	mx
      (max-envelope (cddr e) (max mx (abs (cadr e)))))))

(define zcomb
  (lambda (scaler size pm)
    (let ((cmb (make-comb scaler size :max-size (+ size 1 (max-envelope pm 0))))
	  (penv (make-env :envelope pm :end (frames))))
      (lambda (x) (comb cmb x (env penv))))))

; (map-chan (zcomb .8 32 '(0 0 1 10)))

;;; to impose several formants, just add them in parallel:

(define formants
  (lambda (r1 f1 r2 f2 r3 f3)
    (let ((fr1 (make-formant r1 f1))
	  (fr2 (make-formant r2 f2))
	  (fr3 (make-formant r3 f3)))
      (lambda (x)
	(+ (formant fr1 x)
	   (formant fr2 x)
	   (formant fr3 x))))))

; (map-chan (formants .01 900 .02 1800 .01 2700))

;;; to get a moving formant:

(define moving-formant
  (lambda (radius move)
    (let ((frm (make-formant radius (cadr move)))
	  (menv (make-env :envelope move :end (frames))))
      (lambda (x)
        (let ((val (formant frm x)))
	  (set! (mus-frequency frm) (env menv))
	  val)))))

; (map-chan (moving-formant .01 '(0 1200 1 2400)))

;;; various "Forbidden Planet" sound effects:

(define sp
  (lambda (sr osamp osfrq)
    (let* ((os (make-oscil osfrq))
	   (sr (make-src :srate sr))
	   (len (frames))
	   (sf (make-sample-reader))
	   (out-data (make-vct len)))
      (vct-map! out-data
		  (lambda () 
		    (src sr (* osamp (oscil os))
			 (lambda (dir)
			   (if (&gt; dir 0)
			       (next-sample sf)
			       (previous-sample sf))))))
      (free-sample-reader sf)
      (vct-&gt;samples 0 len out-data))))

; (fp 1.0 .3 20)


;;; -------- shift pitch keeping duration constant
;;;
;;; both src and granulate take a function argument to get input whenever it is needed.
;;; in this case, src calls granulate which reads the currently selected file.

(define <A NAME="expsrc">expsrc</a>
  (lambda (rate)
    (let* ((gr (make-granulate :expansion rate))
	   (sr (make-src :srate rate))
	   (vsize 1024)
	   (vbeg 0)
	   (v (samples-&gt;vct 0 vsize))
	   (inctr 0))
      (lambda (inval)
        (src sr 0.0
	  (lambda (dir)
	    (granulate gr
	      (lambda (dir)
		(let ((val (vct-ref v inctr)))
		  (set! inctr (+ inctr dir))
		  (if (&gt;= inctr vsize)
		      (begin
			(set! vbeg (+ vbeg inctr))
			(set! inctr 0)
			(samples-&gt;vct vbeg vsize 0 0 v)))
		  val)))))))))

</pre>
<p>Geez, I haven't had this much fun in a long time!  Check out <a href="sndscm.html#exampdoc">examp.scm</a> and <a href="sndscm.html#sndtestdoc">snd-test.scm</a> for more.  CLM-in-CL users will be disappointed with the CLM-in-Scheme performance; my tests indicate that
interpreted Scheme (as in Snd currently) is about 30 to 100 times slower than CLM instruments using
the "run" macro.  I may translate that macro to Scheme, but I'm waiting to see if there's
any demand -- there is CLM-in-CL after all, and it's about 8000 lines of Lisp...
</p>
<br>

<span class=bbox><h3><A NAME="sndwithmotif">Snd and Motif</a></h3></span>

<p>It is possible to add your own user-interface elements.
As a very simple example, let's make a dialog window with a slider:</p>
<pre>

#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;guile/gh.h&gt;
#include &lt;Xm/XmAll.h&gt;

static Widget scale_dialog = NULL; /* this will hold our slider */
static float current_scaler = 1.0;

static void Help_Scale_Callback(Widget w, XtPointer context, XtPointer info)
{
  fprintf(stderr, "move the slider to affect the volume");
}

static void Dismiss_Scale_Callback(Widget w, XtPointer context, XtPointer info)
{
  XtUnmanageChild(scale_dialog);
}

static void Scale_Callback(Widget w, XtPointer context, XtPointer info)
{
  XmScaleCallbackStruct *cb = (XmScaleCallbackStruct *)info;
  current_scaler = (float)(cb-&gt;value / 100.0);
}

static void create_scale_dialog(Widget parent)
{
  Arg args[32];
  int n, i;
  XmString xhelp, xdismiss, titlestr;
  Widget mainform, scale;
  if (!scale_dialog)
    {
      xdismiss = XmStringCreate("Dismiss", XmFONTLIST_DEFAULT_TAG);
      xhelp = XmStringCreate("Help", XmFONTLIST_DEFAULT_TAG);
      titlestr = XmStringCreate("Scaling", XmFONTLIST_DEFAULT_TAG);

      n = 0;
      XtSetArg(args[n], XmNcancelLabelString, xdismiss); n++;
      XtSetArg(args[n], XmNhelpLabelString, xhelp); n++;
      XtSetArg(args[n], XmNautoUnmanage, FALSE); n++;
      XtSetArg(args[n], XmNdialogTitle, titlestr); n++;
      XtSetArg(args[n], XmNresizePolicy, XmRESIZE_GROW); n++;
      XtSetArg(args[n], XmNnoResize, FALSE); n++;
      XtSetArg(args[n], XmNtransient, FALSE); n++;
      scale_dialog = XmCreateTemplateDialog(parent, "Scaling", args, n);

      XtAddCallback(scale_dialog, XmNcancelCallback, Dismiss_Scale_Callback, NULL);
      XtAddCallback(scale_dialog, XmNhelpCallback, Help_Scale_Callback, NULL);
      XmStringFree(xhelp);
      XmStringFree(xdismiss);
      XmStringFree(titlestr);

      n = 0;
      XtSetArg(args[n], XmNleftAttachment, XmATTACH_FORM); n++;
      XtSetArg(args[n], XmNrightAttachment, XmATTACH_FORM); n++;
      XtSetArg(args[n], XmNtopAttachment, XmATTACH_FORM); n++;
      XtSetArg(args[n], XmNbottomAttachment, XmATTACH_WIDGET); n++;
      XtSetArg(args[n], XmNbottomWidget, XmMessageBoxGetChild(scale_dialog, XmDIALOG_SEPARATOR)); n++;
      mainform = XtCreateManagedWidget("formd", xmFormWidgetClass, scale_dialog, args, n);

      n = 0;
      XtSetArg(args[n], XmNorientation, XmHORIZONTAL); n++;
      XtSetArg(args[n], XmNshowValue, TRUE); n++;
      XtSetArg(args[n], XmNvalue, 100); n++;
      XtSetArg(args[n], XmNmaximum, 500); n++;
      XtSetArg(args[n], XmNdecimalPoints, 2); n++;
      scale = XtCreateManagedWidget("", xmScaleWidgetClass, mainform, args, n);
      XtAddCallback(scale, XmNvalueChangedCallback, Scale_Callback, NULL);
      XtAddCallback(scale, XmNdragCallback, Scale_Callback, NULL);
    }
  XtManageChild(scale_dialog);
}

static SCM hiho_scaler(void) 
{
  return(gh_double2scm(current_scaler));
}

static SCM g_create_scale_dialog(SCM parent)
{
  /* assumes we're called in listener as (create-scale-dialog (snd-main-shell)) */
  /* snd-main-shell returns Snd's topmost widget */
  create_scale_dialog((Widget)gh_scm2ulong(parent));
  return(SCM_BOOL_F);
}

void init_hiho()
{
  gh_new_procedure1_0("create-scale-dialog", g_create_scale_dialog);
  gh_new_procedure0_0("hiho-scaler", hiho_scaler);
}

/* call this hiho.c:
 *   gcc -c hiho.c -o hiho.o
 *   ld -shared hiho.o -o hiho.so -L/usr/X11R6/lib -lXm -lXt -lXext -lX11 -L/usr/local/lib -lguile -ldl
 * in Snd:
 *   (define hiho (dynamic-link "/home/bil/cl/hiho.so"))
 *   (dynamic-call "init_hiho" hiho)
 *   (create-scale-dialog (cadr (main-widgets)))
 *
 * if the dynamic-link says "file not found", this normally means it can't find one of the needed
 * libraries; this in turn normally means your /etc/ld.so.conf file needs to be updated to include
 * whatever directory is missing, then run (as root) /sbin/ldconfig.
 */

</pre>
<p>I've heard rumors of a guile-motif package similar (I presume) 
to the guile-gtk package (see below).  If it surfaces, I'll add
some immortal prose here.</p>
<br>

<span class=bbox><h3><A NAME="sndwithgtk">Snd and Gtk+</a></h3></span>

<p>In the Gtk+ version of Snd, 
the easiest way to add your own user interface widgets
to Snd is through guile-gtk.  This package ties gtk into guile which is already tied
into Snd.  It's available from http://www.ping.de/sites/zagadka/guile-gtk/ or possibly
from the various guile sites.  As a quick example, take the file simple.scm included
in the guile-gtk examples directory; in its original form, it assumes it is the top-level
program, but it is very easy to modify it to be a dialog in Snd (my changes are in red):
</p>

<table border=1 cellpadding=5><tr><td bgcolor="beige"><pre>
(use-modules (gtk gtk))
(<em class=red>define hiho 
  (lambda ()</em>
    (let* ((window (gtk-widget-new 'GtkWindow
				   :type         <em class=red>'dialog</em>
				   :title        "hello world"
				   :allow_grow   #f
				   :allow_shrink #f
				   :GtkContainer::border_width 10))
	   (label  (gtk-widget-new 'GtkLabel
				   :label        "hello world"
				   :visible      #t))
	   (button (gtk-widget-new 'GtkButton
				   :child        label
				   :parent       window
				   :visible      #t)))
      (gtk-signal-connect button "clicked" 
			  (lambda ()
			    (display (gtk-object-get label :label))
			    (newline)
			    (gtk-widget-set label :label "yo!")))
      (gtk-widget-show window))))
      <em class=red>;deleted the line (gtk-standalone-main window)</em>
</pre></td></tr></table>

<p>Now rather than making a top-level window, this little example creates
a dialog in Snd; say we have saved it as simple.scm.  We can load it into
Snd at any time using the "load" function, or in the Snd invocation using
the "-l" switch: <code>snd oboe.snd -l simple.scm</code>.
Now call the function <code>(hiho)</code> and the dialog appears! A more
useful dialog might play the current sound with a scaler to change the
output amplitude (we're placing a "play" menu option in the options menu;
when that is activated, the dialog fires up):</p>

<table border=1 cellpadding=5><tr><td bgcolor="beige"><pre>
(use-modules (gtk gtk) (gtk gdk))
(define amp 1.0)

(define play-dialog-menu (gtk-menu-item-new-with-label "play"))
(gtk-menu-append (sg-options-menu-widget) play-dialog-menu)
(gtk-widget-show play-dialog-menu)

(gtk-signal-connect play-dialog-menu "activate" 
 (lambda ()
   (let* ((window (gtk-dialog-new))
	  (adj (gtk-adjustment-new 1.0 0.0 1.01 .01 .01 .01))
	  (scale (gtk-hscale-new adj))
	  (button (gtk-button-new-with-label "play")))
     (gtk-box-pack-start (gtk-dialog-action-area window) scale #t #t 2)
     (gtk-range-set-update-policy scale 'continuous)
     (gtk-scale-set-digits scale 2)
     (gtk-scale-set-draw-value scale #t)
     (gtk-widget-show scale)
     (gtk-signal-connect adj "value_changed" 
       (lambda () 
         (set! amp (gtk-adjustment-value adj))))
     (gtk-box-pack-start (gtk-dialog-action-area window) button #f #f 2)
     (gtk-signal-connect button "clicked" 
      (lambda () 
	(let* ((size 256)
	       (data (make-sound-data 1 size))
	       (bytes (* size 2))
	       (len (frames))
	       (beg 0)
	       (audio-fd (mus-audio-open-output mus-audio-default 22050 1 mus-lshort bytes)))
	  (if (not (= audio-fd -1))
	      (do ()
		  ((or (c-g?) (&gt;= beg len))
		   (mus-audio-close audio-fd))
		(vct-&gt;sound-data 
                  (vct-scale! 
                    (samples-&gt;vct beg size) 
                    amp) 
                  data 0)
		(mus-audio-write audio-fd data size)
		(set! beg (+ beg size)))))))
     (gtk-widget-show button)
     (gtk-widget-show window))))
</pre></td></tr></table>

<p>See <a href="sndscm.html#sndgtkdoc">snd-gtk.scm</a> for more examples.</p>
<br>

<span class=bbox><h3><A NAME="sndwithnogui">Snd with no GUI</a></h3></span>

<p>If Snd is built without a graphical user interface (either by specifying
--with-no-gui to configure, or by setting the USE_NO_GUI compile-time flag),
it runs Guile's "repl" (read-eval-print loop) with input from stdin.  All
the non-interface related functions are available, so you can do things
like:
</p>
<pre>
<em class=listener>snd&gt;</em><em class=typing> (new-sound "new.snd")</em>
<em class=listener>0</em>
<em class=listener>snd&gt;</em><em class=typing> (load "v.scm")</em>
<em class=listener>snd&gt;</em><em class=typing> (fm-violin 0 1 440 .1)</em>
<em class=listener>-1</em>
<em class=listener>snd&gt;</em><em class=typing> (frames 0)</em>
<em class=listener>22050</em>
<em class=listener>snd&gt;</em><em class=typing> (play)</em>
<em class=listener>#t</em>
<em class=listener>snd&gt;</em><em class=typing> (exit)</em>
</pre>
<p>Guile's repl has its own error handlers, different from the
normal Snd handlers; name completion, if it exists at all,
won't complete Snd names; there are undoubtedly other
differences that I haven't noticed.
</p>


<span class=bbox><h3><A NAME="sndwithgmeteor">Snd and gmeteor</a></h3></span>

<p><a name="gmeteor">gmeteor</a> is a Guile-based filter design package
written by Matteo Frigo, based on the Meteor system of Steiglitz, Parks,
and Kaiser.  It is freely available <a href="ftp://ftp.prosa.it/pub/gmeteor/gmeteor-0.9.tar.gz">here</a>.
Once installed, it can be loaded into Snd and used to define filters very easily:
(here I'm typing in Snd's listener and editing the numbers for legibility; the file
gm.scm is taken nearly verbatim from the gmeteor script):</p>
<pre>
&gt;<em class=typing>(load "gm.scm")</em>
<em class=listener>#&lt;unspecified&gt;</em>
&gt;<em class=typing>(load "../test/gmeteor-0.9/examples/example-1.scm")</em>
<em class=listener>#&lt;unspecified&gt;</em>
&gt;<em class=typing>*coefficients*</em>
<em class=listener>#(0.0197 -0.0406 -0.0739 0.1340 0.4479 0.4479 0.13403 -0.0739 -0.0406 0.0197)</em>
&gt;<em class=typing>(filter-sound (vector-&gt;vct *coefficients*) (vector-length *coefficients*))</em>
</pre>

<!--
<p>Since every Snd text widget is actually a little lisp listener in disguise,
we can use gmeteor directly in the Control Panel
filter text field (where the list of breakpoints is specified).
I don't currently have a version of gmeteor compatible with my
version of Snd, but the basic idea would be to have a function
that sets the filter-control-order based on the length of the *coefficients*
vector, then returns that vector as a list.
</p>
-->

<p>There is one small problem: both Snd (CLM) and gmeteor define a function
named make-filter.  Someday I'll learn enough about the Guile module system to
know how to keep gmeteor's make-filter from clobbering CLM's.  (There may
be others as well -- this is the one I happened to notice).
</p>
<br>

<span class=bbox><h3><A NAME="sndandladspa">Snd and LADSPA</a></h3></span>

<p>Richard Furse has provided a module to support LADSPA plugins in Snd. To get it
loaded, either use the configure switch --with-ladspa, or include the compile
flag HAVE_LADSPA. Here is documentation from Richard Furse:</p>
<pre>
Supporting functions are:

	(init-ladspa)

	Performs a search of LADSPA_PATH for plugins, doesn't need to be called 
as LADSPA automatically initialises on first use however can be used to 
reinitialise if new plugins have arrived.

	(list-ladspa)

	Returns a list of lists where each inner list contains a string to 
identify the plugin library and a string to identify the plugin type within 
the library.

	(analyse-ladspa plugin-library plugin-type)

	Returns a list of assorted data about a particular plugin including a 
list of port descriptions. plugin-library and plugin-type are as provided 
by list-ladspa.

The main function is:

	(apply-ladspa reader (plugin-library plugin-type [param1 [param2 ...]]) samples origin)

	Applies a LADSPA plugin in a way very similar to loop-samples - 
essentially a plugin identifier and parameter set takes the place of func. 
An example call to apply the low-pass-filter in the CMT plugin library is 
(apply-ladspa (make-sample-reader 0) (list "cmt" "lpf" 1000) 10000 "origin").
</pre>
<p>Dave Phillips in <a href="http://www.oreillynet.com/pub/a/linux/2001/02/02/ladspa.html">Linux Audio Plug-Ins: A Look Into LADSPA"</a> adds this
example:
</p>
<pre>
  (apply-ladspa (make-sample-reader 57264) (list "cmt" "delay_5s" .3 .5) 32556 "ibm.wav")
</pre>
<p>
"This sequence tells Snd to read a block of 32556 samples from the ibm.wav file, starting at sample number 57264,
 and apply the delay_5s LADSPA plug-in (Richard Furse's delay plug-in, also found in cmt.so) with a delay time of
.3 seconds and a 50/50 dry/wet balance."
</p>

<br>

<span class=bbox><h3><A NAME="sndandx">Driving Snd remotely</a></h3></span>

<p>It is possible to send Snd arbitrary scheme code from any other program;
the program sndctrl.c is a simple example.  Snd has two X window properties:
"SND_VERSION" and "SND_COMMAND"; the former is the Snd version (a date),
and the latter is the communication path for other programs.  Any time
such a program changes the SND_COMMAND property, Snd notices and evaluates
the new value (as a string, as if typed in the Snd lisp listener).  To get
a response from Snd, use the function change-property(consat,name,command) where
consat is the property name Snd should search for, name is the property to change, and command is the string
that replaces the current property value.  For example, CLM's communication
with Snd function sends Snd this string:</p>
<pre>
"(change-property \"CLM_VERSION\" \"CLM_COMMAND\" " str ")"
</pre>
<p>where <i>str</i> is the form to be evaluated within Snd.  It then waits
for a change to the CLM_COMMAND property, returning its value to the
user. The send-snd function itself, similarly, looks for SND_VERSION and
sets SND_COMMAND to <i>str</i>, which Snd subsequently notices.
</p>
<br>

<span class=bbox><h3><A NAME="sndandgl">Snd and OpenGL</a></h3></span>

<p>Snd can be used in conjunction with OpenGL, but due to the way GL uses X, it's
not built into the Snd image.  The files glfft.c and <a href="sndscm.html#glfftdoc">glfft.scm</a> show one way
to get GL graphics of Snd data.  glfft.c is a program that sets up a Motif/Mesa
GL drawing area widget, then sits in a loop watching for Snd-generated spectrogram
data.  Whenever any appears, it displays it using (exceedingly primitive) GL
commands.  <a href="sndscm.html#glfftdoc">glfft.scm</a> is the Snd side of the process; it puts a function on
the after-fft hook to write the spectrogram data to the shared file.  To use
this stuff, build glfft, start Snd, display spectrograms, load <a href="sndscm.html#glfftdoc">glfft.scm</a>,
and (start-gl).
</p>
<br>

<span class=bbox><h3><A NAME="sndandgdb">Snd and gdb</a></h3></span>

<p>Here are some gdb functions (for your ~/.gbdinit file) that might
come in handy:
</p>
<pre>
define gp
call gdb_print($arg0)
print gdb_output
end
document gp
Executes (object-&gt;string arg): gp memo_sound =&gt; #f
end

define ge
call gdb_read($arg0)
call gdb_eval(gdb_result)
call gdb_print(gdb_result)
print gdb_output
end
document ge
Executes (print (eval (read arg))): ge "(+ 1 2)" =&gt; 3
end

define gh
call g_help(scm_str2symbol($arg0), 20)
call gdb_print($1)
print gdb_output
end
document gh
Prints help string for arg: gh "enved-target"
end
</pre>
<p>SCM values are displayed as integers in gdb, so, for example, say
Snd halts and you notice it's loading some unknown file:
</p>
<pre>
#32 0x081ae8f4 in scm_primitive_load (filename=1112137128) at load.c:129
</pre>
<p>You can get the file name with gp:
</p>
<pre>
(gdb) gp 1112137128
$1 = 0
$2 = 0x40853fac "\"/home/bil/test/share/guile/1.5.0/ice-9/session.scm\""
</pre>
<p>
If you have a pointer to a CLM generator, you can use:
</p>
<pre>
p mus_describe(arg)  --  show the user-view of arg
p mus_inspect(arg)  --  show every internal field of arg
</pre>
<p>The ge function can show current Snd state:</p>
<pre>
(gdb) ge "(eps-file)"
$5 = 0
$6 = 0
$7 = 0
$8 = 0x8296cf0 "\"snd.eps\""
</pre>

<br>

<center>
<span class=htmlbox>related documentation</span><span class=htmlbox><a href="snd.html">snd.html</a><spacer type=horizontal size=25><a href="extsnd.html">extsnd.html</a><spacer type=horizontal size=25><a href="clm.html">clm.html</a><spacer type=horizontal size=25><a href="sndlib.html">sndlib.html</a><spacer type=horizontal size=25><a href="sndscm.html">sndscm.html</a><spacer type=horizontal size=25><a href="index.html">index.html</a></span>
</center>
</body></html>
