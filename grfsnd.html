<html>
<head>
<title>Snd Customization and Extension</title>
<style type="text/css">
<!-- 
	EM.red {color:red; font-style:normal}
        EM.typing {color:maroon; font-style: normal}
        EM.listener {color:darkblue; font-style: normal}
        EM.tab {font-style: normal; font-size: small; font-family: fixed}
	EM.def {font-weight: bold; font-style: normal}
	H1 {text-align: center}
	UL {list-style-type: none}
	SPAN.box {background: beige; width: 100%; font-style: normal; text-align: center; border-width: thin; border-style: ridge}
	SPAN.bbox {background: lightsteelblue; width: 100%; font-style: normal; border-width: thin; border-style: ridge}
	SPAN.cbox {background: lightgreen; width: 100%; font-style: normal; border-width: thin; border-style: ridge}
	SPAN.htmlbox {background: tan; font-style: normal; font-size: small; border-width: thin; border-style: ridge}
-->
</style>
</head>
<body bgcolor=white>

<!-- I'm using A NAME (i.e caps) where the entity should be ignored by the indexer (index.cl) -->

<A NAME="grfsndcontents"></a>
<span class=box><h1>Snd Customization and Extension Part 2</h1></span>
<br>

<center>
<span class=htmlbox>related documentation</span><span class=htmlbox><a href="snd.html">snd.html</a><spacer type=horizontal size=25> <a href="extsnd.html">extsnd.html</a><spacer type=horizontal size=25> <a href="clm.html">clm.html</a><spacer type=horizontal size=25> <a href="sndlib.html">sndlib.html</a><spacer type=horizontal size=25> <a href="sndscm.html">sndscm.html</a><spacer type=horizontal size=25> <a href="libxm.html">libxm.html</a><spacer type=horizontal size=25> <a href="index.html">index.html</a></span>
</center>

<ul>
<li><a href="#startup">Snd Startup</a>
  <ul>
  <li><a href="#sndresources">Snd resources</a>
  <li><a href="#sndswitches">Snd invocation flags</a>
  <li><a href="#sndinitfile">The initialization file</a>
  </ul>
<li><a href="#snddynamic">Runtime modules and external programs</a>
  <ul>
  <li><a href="#emacssnd">Snd as an Emacs subjob</a>
  <li><a href="#dynamic">Dynamically loaded modules</a>
  <li><a href="#programs">External Programs</a>
  <li><a href="#sndaswidget">Snd as a Widget</a>
  <li><a href="#sndwithclm">Snd and the CLM module</a>
    <ul>
    <li><a href="#clmfuncs">CLM functions</a>
    <li><a href="#sndinstruments">Instruments</a>
    <li><a href="#sndeffects">Effects</a>
    </ul>
  <li><a href="#sndwithmotif">Snd and Motif</a>
  <li><a href="#sndwithgtk">Snd and Gtk</a>
  <li><a href="#sndwithnogui">Snd with no GUI and as script engine</a>
  <li><a href="#sndandruby">Snd with Ruby</a>
  <li><a href="#sndandladspa">Snd and LADSPA</a>
  <li><a href="#sndandx">Driving Snd remotely</a>
  <li><a href="#sndandgl">Snd and OpenGL</a>
  <li><a href="#sndandgdb">Snd and gdb</a>
  </ul>
</ul>

<br>

<span class=box><h2><A NAME="startup">Snd Startup</a></h2></span>
<br>
<span class=bbox><h3><A NAME="sndresources">Snd resources</a></h3></span>

<p>In the Motif version, there are a few X-style resources that Snd looks for (see Snd.ad); each has
a built-in default value, so you can ignore any that are already acceptable:</p>

<table cellspacing=0 cellpadding=0>
<tr><td width=200>initFile</td>               <td>"~/.snd"</td></tr>
<tr><td><A NAME="epsresource">epsFile</a></td><td>"snd.eps"</td></tr>
<tr><td>overwriteCheck</td>                   <td>0</td></tr>
<tr><td>autoResize</td>                       <td>1</td></tr>
<tr><td>horizontalPanes</td>                  <td>0</td></tr>
<tr><td><br></td><td><br></td></tr>
<tr><td>buttonFont</td>                       <td>-*-times-medium-r-*-*-14-*-*-*-*-*-iso8859-1</td></tr>
<tr><td>boldbuttonFont</td>                   <td>-*-times-bold-r-*-*-14-*-*-*-*-*-iso8859-1</td></tr>
<tr><td>peaksFont</td>                        <td>-*-times-medium-r-*-*-14-*-*-*-*-*-iso8859-1</td></tr>
<tr><td>boldpeaksFont</td>                    <td>-*-times-bold-r-*-*-14-*-*-*-*-*-iso8859-1</td></tr>
<tr><td>axisLabelFont</td>                    <td>-*-times-medium-r-normal-*-20-*-*-*-*-*-iso8859-1</td></tr>
<tr><td>axisNumbersFont</td>                  <td>-*-courier-medium-r-normal-*-14-*-*-*-*-*-iso8859-1</td></tr>
<tr><td>helpTextFont</td>                     <td>9x15</td></tr>
<tr><td>listenerFont</td>                     <td>default</td></tr>
<tr><td><br></td><td><br></td></tr>
<tr><td>useSchemes</td>                       <td>none</td></tr>
<tr><td>highlightcolor</td>                   <td>ivory1</td></tr>
<tr><td>basiccolor</td>                       <td>ivory2</td></tr>
<tr><td>positioncolor</td>                    <td>ivory3</td></tr>
<tr><td>zoomcolor</td>                        <td>ivory4</td></tr>
<tr><td>cursorcolor</td>                      <td>red</td></tr>
<tr><td>selectioncolor</td>                   <td>lightsteelblue1</td></tr>
<tr><td>mixcolor</td>                         <td>lightgreen</td></tr>
<tr><td>mixfocuscolor</td>                    <td>yellow2</td></tr>
<tr><td>listenercolor</td>                    <td>aliceblue</td></tr>
<tr><td>envedwaveformcolor</td>               <td>blue</td></tr>
<tr><td>filterwaveformcolor</td>              <td>blue</td></tr>
<tr><td>mixwaveformcolor</td>                 <td>darkgray</td></tr>
<tr><td>graphcolor</td>                       <td>white</td></tr>
<tr><td>selectedgraphcolor</td>               <td>white</td></tr>
<tr><td>datacolor</td>                        <td>black</td></tr>
<tr><td>selecteddatacolor</td>                <td>black</td></tr>
<tr><td>markcolor</td>                        <td>red</td></tr>
<tr><td>pushedbuttoncolor</td>                <td>lightsteelblue1</td></tr>
<tr><td>sashcolor</td>                        <td>lightgreen</td></tr>
</table>

<p>You can experiment with other choices by
using the -xrm switch:</p>

<pre>
  snd -xrm '*Highlightcolor: Red' oboe.snd
  snd -xrm '*AxisNumbersFont: 6x10' oboe.snd
  snd -xrm '*overwriteCheck: 1' oboe.snd
  snd -xrm '*useSchemes: all' -xrm '*scheme: Pacific'
  snd -xrm '*fontList: 9x15' oboe.snd
  snd -xrm '*listenerFont: 6x10' oboe.snd
  snd -xrm '*mixwaveformcolor: red' oboe.snd -notebook
  snd oboe.snd pistol.snd -xrm '*selectedgraphcolor: black' -xrm '*selecteddatacolor: white'
  snd oboe.snd -title hiho -display hummer.hiho:0.0 -xrm '*chn-graph*backgroundPixmap: text.xpm'
</pre>
<p>Perhaps this is most useful when your window manager assumes white text for labels (menus);
since Snd defaults to an off-white background, this makes everything unreadable. You can get
the black text back with:
</p>
<pre>
./snd -xrm '*foreground: Black'
</pre>
<p>or put the equivalent line in your .Xdefaults file.  The listener text color can be set
via <code>(set! (<a href="extsnd.html#listenertextcolor">listener-text-color</a>) (<a href="extsnd.html#makecolor">make-color</a> 0 0 0))</code> in ~/.snd.
</p>

<p>The colors are defined in <a href="sndscm.html#rgbdoc">rgb.scm</a>. 
"useSchemes" refers to SGI color schemes.
It's unfortunate that
there is the language Scheme implemented by Guile, and the notion of an SGI color scheme -- there is
no connection between the two. Other systems (Linux, Solaris) use the term "theme" instead.
You can get Snd to honor your current window manager theme by setting useSchemes to all.  
The last example above sets the window title to "hiho", rather than
"snd", displays the window on the machine hummer.hiho (presumably accessible over the net),
and tiles the graph backgrounds with the contents of text.xpm.  To get the -geometry argument
to work, set the autoResize resource to 0:</p>
<pre>
  snd oboe.snd -geometry 800x200 -xrm '*autoResize: 0'
</pre>

<p>These resources can be set in Snd.ad or in your .Xdefaults file:</p>
<pre>
snd*buttonFont:         -adobe-times-medium-r-*-*-14-*-*-*-*-*-*-*
snd*boldbuttonFont:     -adobe-times-bold-r-*-*-14-*-*-*-*-*-*-*
snd*axisLabelFont:      -adobe-times-medium-r-normal-*-18-*-*-*-*-*-*-*
snd*axisNumbersFont:    9x15
snd*fontList:           9x15
snd*helpTextFont:       9x15
</pre>

<p>
The <A NAME="xautoresize">autoResize resource</a> determines how Snd acts when files
are added to or removed from its overall display.  The default (1)
causes Snd to expand or contract the main window's size to accommodate
the sounds; many people find this distracting.  If <i>autoResize</i> is 0, the outer window size remains the
same, and the sounds try to fit as best they can (to some extent the window manager controls this stuff).  See also
the variable <a href="extsnd.html#autoresize">auto-resize</a>.
If <i>overwriteCheck</i> is 1, Snd asks before overwriting existing files.
The <A NAME="horizontalpanes">horizontalPanes resource</a>
is equivalent to the -h flag; if 1, sounds are layed out
horizontally rather than vertically;  if 2, you get a notebook
widget holding the sounds.
</p>
<p>In Gtk2, the (pango) font defaults are:</p>
<pre>
tiny-font         "Monospace 8"
button-font       "Serif 14"
bold-button-font  "Serif Bold 14"
axis-numbers-font "Monospace 10"
axis-label-font   "Serif 14"
help-text-font    "Monospace 14"
</pre>

<p><A NAME="aboutcolors"></a>The various color resources are:</p>

<table cellspacing=0 cellpadding=0>
<tr><td width=200>basiccolor</td><td width=350>default background color everywhere</td><td><code><a href="extsnd.html#basiccolor">basic-color</a></code></td></tr>
<tr><td>cursorcolor</td>         <td>color of the cursor</td>                   <td><code><a href="extsnd.html#cursorcolor">cursor-color</a></code></td></tr>
<tr><td>datacolor</td>           <td>unselected data color</td>                 <td><code><a href="extsnd.html#datacolor">data-color</a></code></td></tr>
<tr><td>envedwaveformcolor</td>  <td>color of envelope editor waveform</td>     <td><code><a href="extsnd.html#envedwaveformcolor">enved-waveform-color</a></code></td></tr>
<tr><td>filterwaveformcolor</td> <td>color of control panel filter waveform</td><td><code><a href="extsnd.html#filterwaveformcolor">filter-waveform-color</a></code></td></tr>
<tr><td>graphcolor</td>          <td>unselected channels' graph background</td> <td><code><a href="extsnd.html#graphcolor">graph-color</a></code></td></tr>
<tr><td>highlightcolor</td>      <td>highlighting here and there</td>           <td><code><a href="extsnd.html#highlightcolor">highlight-color</a></code></td></tr>
<tr><td>listenercolor</td>       <td>background color of the listener</td>      <td><code><a href="extsnd.html#listenercolor">listener-color</a></code></td></tr>
<tr><td>listenertextcolor</td>   <td>text color in the listener</td>            <td><code><a href="extsnd.html#listenertextcolor">listener-text-color</a></code></td></tr>
<tr><td>markcolor</td>           <td>color of the mark indicator</td>           <td><code><a href="extsnd.html#markcolor">mark-color</a></code></td></tr>
<tr><td>mixcolor</td>            <td>used for mix waveforms</td>                <td><code><a href="extsnd.html#mixcolor">mix-color</a></code></td></tr>
<tr><td>selectedmixcolor</td>    <td>selected mix waveforms</td>                <td><code><a href="extsnd.html#selectedmixcolor">selected-mix-color</a></code></td></tr>
<tr><td>positioncolor</td>       <td>color of position sliders</td>             <td><code><a href="extsnd.html#positioncolor">position-color</a></code></td></tr>
<tr><td>pushedbuttoncolor</td>   <td>color of pushed button</td>                <td><code><a href="extsnd.html#pushedbuttoncolor">pushed-button-color</a></code></td></tr>
<tr><td>sashcolor</td>           <td>color of paned window sash handles</td>    <td><code><a href="extsnd.html#sashcolor">sash-color</a></code></td></tr>
<tr><td>selecteddatacolor</td>   <td>color of the data in selected channel</td> <td><code><a href="extsnd.html#selecteddatacolor">selected-data-color</a></code></td></tr>
<tr><td>selectedgraphcolor</td>  <td>background of selected channel's graph</td><td><code><a href="extsnd.html#selectedgraphcolor">selected-graph-color</a></code></td></tr>
<tr><td>selectioncolor</td>      <td>color of an active selection</td>          <td><code><a href="extsnd.html#selectioncolor">selection-color</a></code></td></tr>
<tr><td>textfocuscolor</td>      <td>color of text field with focus</td>        <td><code><a href="extsnd.html#textfocuscolor">text-focus-color</a></code></td></tr>
<tr><td>zoomcolor</td>           <td>color of zoom sliders</td>                 <td><code><a href="extsnd.html#zoomcolor">zoom-color</a></code></td></tr>
</table>
<p>
Each of these colors can be set in Guile using the second name given above ("basic-color").
Colors are defined by <a href="extsnd.html#makecolor">make-color</a> with the three red/green/blue values,
each a float between 0.0 and 1.0. <code>(set! (basic-color) (make-color 1.0 0.0 0.0))</code> sets
the overall background color of Snd to red.  <a href="sndscm.html#rgbdoc">rgb.scm</a> defines all the standard X11 color names
(you probably don't want to load the whole thing; just use the names as needed). 
</p>

<p>There are several other resources that set widget sizes: zoomSliderWidth,
positionSliderWidth, toggleSize, sashSize, sashIndent, channelSashSize, channelSashIndent, and
envedPointSize.  And several more color resources: whitecolor (list background),
blackcolor (recorder VU meter text), redcolor (buttons, VU clipping, etc), 
greencolor (a few buttons),
yellowcolor (a few envelope editor buttons), lightbluecolor (the recorder), and lighterbluecolor (the fft option panel).
</p>

<p>In the GTK version, you can load a gtkrc file, overriding all Snd defaults, with
<b>parse-rc-file</b>:
</p>
<pre>
  (parse-rc-file "/home/bil/test/gtk+-1.2.9/gtk/testgtkrc")
</pre>
<p>I've never used this.  If it's broken, please let me know!
</p>

        <!-- I(print file):O(epsFile resource)(epsresource) -->

<br>
<!-- INDEX sndswitches:Invocation flags -->
<span class=bbox><h3><A NAME="sndswitches">Snd invocation flags</a></h3></span>

<p>Snd recognizes the following switches in its command line (leaving aside all
the usual Xt/X-related flags like -xrm).</p>

<table cellspacing=0 cellpadding=0>
<tr><td width=200><code>-h -horizontal</code></td><td>layout sounds as horizontal panes</td></tr>
<tr><td><code>-v -vertical</code></td>            <td>layout sounds vertically (the default)</td></tr>
<tr><td><code>-notebook</code></td>               <td>layout sounds in a notebook widget (Motif 2.0 or later)</td></tr>
<tr><td><code>-separate</code></td>               <td>layout sounds each in a separate window (lisp listener in main window)</td></tr>
<tr><td><code>--help</code></td>                  <td>print some help, version info, and exit</td></tr>
<tr><td><code>--version</code></td>               <td>print version info</td></tr>
<tr><td><code>-noglob</code></td>                 <td>don't read /etc/snd.conf</td></tr>
<tr><td><code>-noinit</code></td>                 <td>don't read ~/.snd</td></tr>
<tr><td><code>-nostdin</code></td>                <td>don't watch for possible input from stdin</td></tr>
<tr><td><code>-p -preload &lt;dir&gt;</code></td> <td>preload sound files in directory &lt;dir&gt; (snd -p .)</td></tr>
<tr><td><code>-l -load &lt;file&gt;</code></td>   <td>load Scheme or Ruby code in &lt;file&gt; (snd -l test.scm)</td></tr>
<tr><td><code>-e -eval expr</code></td>           <td>evaluate expr</td></tr>
<tr><td><code>-b -batch &lt;file&gt;</code></td>  <td>load Scheme or Ruby code in &lt;file&gt; as a batch (no GUI) job</td></tr>
<tr><td><code>-I &lt;dir&gt;</code></td>          <td>add &lt;dir&gt; to the load search list</td></tr>
</table>

<p>
The -e switch evaluates its argument as though it had been passed to M-X.  The
initialization file, if any, is loaded first, then the arguments are processed
in order:</p>
<pre>
snd -e "(set! (data-color) (make-color 1 0 0))" oboe.snd
</pre>
<p>reads ~/.snd, if any, then sets the (unselected) data color to red, then opens oboe.snd.</p>
<pre>
./snd -eval '(begin (display (+ 1 2)) (exit))'
</pre>
<p>prints "3" and exits.  The "-title" argument works in both versions of Snd.
The following adds "WAV" to the sound file extension table before preloading the directory:
</p>
<pre>
snd -e '(add-sound-file-extension "WAV")' -p /home/bil/sounds
</pre>
<br>
<img src="note.png" alt="notebook"><spacer type=horizontal size=10><img src="bgd.png" alt="colors" vspace=0>
<br>
<br>

<!-- INDEX: sndinitfile:Initialization file -->
<span class=bbox><h3><A NAME="sndinitfile">The initialization file</a></h3></span>
<p>
When Snd starts, it looks for an initialization file, normally named "~/.snd" (its name can be set
via the X resource mechanism, or through the environment variable SND_INIT_FILE).  This optional file is
supposed to be just like Emacs' .emacs file, containing any customizations or
extensions that you want loaded whenever Snd starts.  Say we
want the Snd window to start out 800x500, want to predefine an envelope named
"env1", and want the file selection box to
show just sound files.  We make ~/.snd and put in it:</p>
<pre>
(set! (window-width) 800)
(set! (window-height) 500)
(defvar env1 '(0 0 1 1 2 0))
(set! (just-sounds) #t)
</pre>
<p>
In more
complex situations, you may want an initialization file particular to a given
machine, and global across users; the 
name of this optional global initialization file is "/etc/snd.conf". It
is read before your local file; both can, of course, be
absent.  To override reading the global init file when Snd is invoked, include the switch -noglob.
To override the local init file, use -noinit.  
Here's a more extended example:
</p>

<pre>
(use-modules (ice-9 debug) (ice-9 format))
(debug-set! stack 0)                ;turn off Guile's stack-size check
(set! snd-remember-paths #t)        ;remember paths making "load" smarter

(set! (window-width) 800)           ;these set the initial window size
(set! (window-height) 500)

(if (provided? 'snd-motif)          ;if using Motif, set some fonts
    (begin
      (set! (button-font) "-adobe-times-medium-r-*-*-14-*-*-*-*-*-*-*")
      (set! (bold-button-font) "-adobe-times-bold-r-*-*-14-*-*-*-*-*-*-*")
      (set! (axis-label-font) "-adobe-times-medium-r-normal-*-18-*-*-*-*-*-*-*")
      (set! (axis-numbers-font) "9x15")))

(set! (listener-prompt) ":")        ;change listener prompt from the default "&gt;" to ":"
(show-listener)                     ;include the listener window initially
(set! (show-indices) #t)            ;include sound index values with the sound name

(define beige (make-color 0.96 0.96 0.86))
(define blue (make-color 0 0 1))
(set! (selected-graph-color) beige) ;selected graph background is beige
(set! (selected-data-color) blue)   ;selected graph data is blue

(add-hook! mouse-enter-graph-hook   ;automatically focus on (activate) the widget under the mouse
  (lambda (snd chn) 
    (focus-widget (car (channel-widgets snd chn)))))
(add-hook! mouse-enter-listener-hook 
  (lambda (widget) 
    (focus-widget widget)))
(add-hook! mouse-enter-text-hook
  (lambda (w)
    (focus-widget w)))

(set! (save-dir) "/zap/snd")        ;save-state files are placed in /zap/snd
(set! (temp-dir) "/zap/tmp")        ;temp files are placed in /zap/tmp
(load "peak-env.scm")               ;large file peak env data is saved for faster 
				    ;  subsequent reads -- this makes the first
				    ;  view of a large file much snappier --
				    ;  its default directory for the data is ~/peaks.

(load "draw.scm")                   ;load some useful extensions
(load "hooks.scm")
(load "extensions.scm")

(make-current-window-display)       ;display an overview of the current window in the upper right
(if (provided? 'snd-motif)          
    (load "popup.scm")              ;context-sensitive popup menus
    (if (provided? 'snd-gtk)
        (load "/home/bil/cl/gtk-popup.scm")))

(add-hook! after-open-hook          ;if sound has many chans, use just one pane for all
  (lambda (snd)
    (if (&gt; (chans snd) 4)
        (set! (channel-style snd) channels-combined))))

(set! (optimization) 6)             ;turn on full optimization
(set! (selection-creates-region) #f) ;turn off automatic region creation
</pre>
<p>
If you loaded Snd with GSL, and have set the GSL_IEEE_MODE environment variable,
it will override Snd's default arithmetic mode settings.  GSL recommends the setting:
</p>
<pre>
GSL_IEEE_MODE=double-precision,mask-underflow,mask-denormalized
</pre>

<br>
<span class=box><h2><A NAME="snddynamic">Runtime modules and external programs</a></h2></span>

<p>It is possible to load your own C code into Snd at run-time or
use any external program from within Snd as an editing function.
And, perhaps most useful, you can run Snd as an Emacs subjob.
</p>
<br>

<!-- INDEX emacssnd:Emacs and Snd -->
<span class=bbox><h3><A NAME="emacssnd">Snd as an Emacs subjob</a></h3></span>

<p>Snd watches stdin; any input received
is evaluated as if typed in Snd's lisp listener; any subsequent output
is sent to stdout; presumably any process could communicate with
Snd in this manner.  But the intention here is to connect to Emacs 
via ILISP (available at
http://sourceforge.net/projects/ilisp,
and possibly built into Xemacs).
Once you have ILISP, put this code in your .emacs file:</p>
<pre>
(require 'ilisp)
(defdialect snd "Snd" ilisp
  (setq ilisp-block-command "(begin \n%s)")
  (setq ilisp-load-command "(load \"%s\")")
  (setq ilisp-init-hook '((lambda () (ilisp-init nil nil nil))))
  (setq comint-prompt-regexp "^&gt;+")
  (setq ilisp-directory-command "(getcwd)")
  (setq	ilisp-set-directory-command "(chdir \"%s\")")
  (setq	ilisp-complete-command
	"(map (lambda (sym) 
                (list (symbol-&gt;string sym))) 
              (apropos-internal \"^%s\"))")
  (local-set-key "\C-x\C-h" '(lambda (s)
			       (interactive "sSnd help: ")
			       (insert "(snd-help " s ")")
			       (comint-send-input))))

  (setq snd-program "snd")
</pre>
<p>You can bind this to some key via:</p>
<pre>
  (global-set-key "\C-x\C-l" 'snd)
</pre>
<p>Now C-x C-l in Emacs starts Snd as a subjob; anything you type in the Emacs
<b>*snd*</b> buffer is sent to Snd (very much as if you were running CLM as
an Emacs subjob), and Snd's output is appended to the <b>*snd*</b> buffer.
Also, C-x C-h prompts for some Snd entity and appends the help text for that
entity in the snd buffer.  The following code tries to implement Snd's
name completion upon C-x C-i in the <b>*snd*</b> buffer:</p>
<pre>
(defun handle-snd-completion (process string)
  (let ((buffer (process-buffer process)))
    (save-excursion
      (set-buffer buffer)
      (goto-char (point-max))
      (insert (substring string 1 (- (length string) 3))))
    (goto-char (point-max))
    (display-buffer buffer)))
      
(defun snd-complete-symbol ()
  (interactive)
  (let* ((end (point))
	 (start (save-excursion (skip-syntax-backward "w_") (point)))
	 (pattern (buffer-substring-no-properties start end))
	 (proc (get-buffer-process (current-buffer)))
	 (old-filter (process-filter proc)))
    (delete-region start end)
    (set-process-filter proc 'handle-snd-completion)
    (process-send-string proc (format "(snd-completion \"%s\")\n" pattern))
    (accept-process-output proc)
    (set-process-filter proc old-filter)))
</pre>
<p>and add this to the defdialect block:</p>
<pre>
  (local-set-key "\C-x\C-i" 'snd-complete-symbol)
</pre>
<p>But for some reason it needs an open-paren?
<i>snd-program</i> is the name of the snd image; you can include whatever
startup switches you like:
</p>
<pre>
(setq snd-program "snd -horizontal ~/cl/oboe.snd")
</pre>
<p>Fernando Lopez-Lezcano's DotEmacs file
shows another way to set up the emacs-snd connection:
</p>
<pre>
       (defdialect snd "Snd" guile
         (setq comint-prompt-regexp "^&gt;+")
         (setq ilisp-complete-command nil)
         ;; try to autodetect the binary
         (unless snd-program
           (cond
            ((file-executable-p "/usr/bin/snd")
             (setq snd-program "/usr/bin/snd"))
            (t (setq snd-program "snd")))))

       (add-hook 'snd-hook
                 (lambda ()

                   ))
       ;; if you have the binary somewhere else:
       ;; (setq snd-program "snd")
</pre>
<p>Another, much fancier possibility is Michael Scholz's inf-snd.el.
</p>

<br>
<span class=bbox><h3><A NAME="dynamic">Dynamically loaded modules</a></h3></span>

<p>You can import shared object files into Snd at any time.
You need to build Snd
with -lguile (that is, load it with the guile shared library, not libguile.a);
if the loader can't find libguile.so.2 (or whatever), add its directory to
your LD_LIBRARY_PATH; for example, if
it's on /usr/local/lib, <code>setenv LD_LIBRARY_PATH /usr/local/lib</code>.  
Next add Guile wrappers to your C code:</p>
<pre>
  /* cscm.c */
  #include &lt;math.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;
  #include &lt;guile/gh.h&gt;

  int hiho (int a) 
  { /* this is the function we want to call from Snd */
    return(1 + a);
  }

  SCM hiho_wrapper(SCM a) 
  { /* this tells Guile how to interpret the arguments and return value of hiho */
    return(scm_long2num(hiho(scm_num2int(a, 0, "hiho"))));
  }

  void init_hiho() 
  { /* this declares hiho within Guile calling the wrapper which calls the C function hiho */
    scm_c_define_gsubr("hiho", 1, 0, 0, hiho_wrapper);
  }
</pre>
<p>
Next compile
your code into a shared object (this example is for Linux):
</p>
<pre>
  cc -c cscm.c 
  ld -shared -o cscm.so cscm.o -lguile
</pre>
<p>Now go to Snd's lisp listener and,</p>
<pre>
  (define lib (<em class=red>dynamic-link</em> "/home/bil/cl/cscm.so"))
  (<em class=red>dynamic-call</em> "init_hiho" lib)
  (hiho 3)
</pre>
<p>The function we actually want loaded into Guile here is "hiho".
We define a wrapper for it to handle the translation between
Guile (Scheme) variable types and C ("hiho_wrapper"), and
a procedure to define hiho in Guile ("init_hiho").  Once loaded
("dynamic-link"), we can call the initialization function
("dynamic-call"), and thereafter treat "hiho" as though
it had been defined in Guile/Snd to begin with.  After both the
dynamic-link and dynamic-lib calls, the listener will
print "#&lt;unspecified&gt;" or something equally obscure to indicate
in its own peculiar way that all went well.  M-x (hiho 4) will
print 5 in the minibuffer.
</p>

<p>
As a slightly more useful example, let's import the Bessel J0 function
from GSL (Gnu Scientific Library); in this case, we need to build Snd
with GSL (the easiest way is to include the --with-gsl option to configure).
Then make a file (say "gsl-ex.c"):</p>
<pre>
#include &lt;guile/gh.h&gt;
#include &lt;gsl/gsl_sf_bessel.h&gt;

static SCM scm_j0(SCM x)
{ /* calls GSL function gsl_sf_bessel_J0_e */
  gsl_sf_result res;
  gsl_sf_bessel_J0_e(scm_num2dbl(x, "j0"), &amp;res);
  return(scm_make_real(res.val));
}

void init_gsl_j0(void)
{ /* links scm_j0 into Snd under the name j0 */
  scm_c_define_gsubr("j0", 1, 0, 0, scm_j0);
}
</pre>
<p>Now the usual compile, load, link into Snd sequence:</p>
<pre>
/home/bil/snd-4/ cc gsl-ex.c -c -Wall
/home/bil/snd-4/ ld -shared gsl-ex.o -o gsl-ex.so -lguile
/home/bil/snd-4/ ./snd

&gt;<em class=typing>(define lib (dynamic-link "/home/bil/snd-4/gsl-ex.so"))</em>
<em class=listener>#&lt;unspecified&gt;</em>
&gt;<em class=typing>(dynamic-call "init_gsl_j0" lib)</em>
<em class=listener>#&lt;unspecified&gt;</em>
&gt;<em class=typing>(</em><em class=red>j0</em><em class=typing> 0.0)</em>
<em class=listener>1.0</em>
&gt;<em class=typing>(</em><em class=red>j0</em><em class=typing> 2.0)</em>
<em class=listener>0.223890779141236</em>
&gt;<em class=typing>(define (bes-fm dur freq amp ratio index)
 ;; bessel-FM from CLM
   (let* ((car-ph 0.0)
	  (mod-ph 0.0)
 	  (car-incr (hz-&gt;radians freq))
	  (mod-incr (* ratio car-incr))
	  (ampenv (make-env :envelope '(0 0 25 1 75 1 100 0) :scaler amp :end dur))
	  (output (make-vct dur)))
     (vct-map! output
       (lambda ()
         (let ((val (* (env ampenv) (</em><em class=red>j0</em><em class=typing> car-ph))))
           (set! car-ph (+ car-ph car-incr (* index (</em><em class=red>j0</em><em class=typing> mod-ph))))
           (set! mod-ph (+ mod-ph mod-incr))
	   val)))
     (vct-&gt;samples 0 dur output)))</em>
<em class=listener>#&lt;unspecified&gt;</em>
&gt;<em class=typing>(bes-fm 22050 440 10.0 1.0 8.0)</em>
</pre>

<p>To call internal Snd functions, you can do something like
the following: declare an SCM variable to hold the procedure
variable, in the init function set the variable to the
value of scm_symbol_value0("function-name"), and in the
rest of the code call it via scm_apply. The following
is a sketch using the Snd internal "srate" function:</p>
<pre>
  #include &lt;guile/gh.h&gt;
  static SCM g_srate;
  static SCM srate_wrapper(SCM a) {return(scm_call_1(g_srate, a));}
  void init_srate(void) 
  { 
    scm_c_define_gsubr("my-srate", 1, 0, 0, srate_wrapper);
    g_srate = scm_symbol_value0("srate");
  }
</pre>
<p>Alternatively, you can simply use scm_eval_str0:</p>
<pre>
  scm_eval_str0("(recorder-dialog)");
  scm_eval_str0("(open-sound \"oboe.snd\")");
  srate = scm_num2int(scm_eval_str0("(srate)"), 0, "");
</pre>

<br>
<span class=bbox><h3><A NAME="programs">External Programs</a></h3></span>

<p>Any external program that knows about sound files can be used to perform editing operations
in Snd.  You get Snd's display, analysis, header and format conversion, and edit-tree support,
and can concentrate on the actual sound effect you're developing.
The original impetus for Snd came from CLM, a large lisp-listener based program
which normally runs without a graphical
user interface, and without any simple way to move around
in what Snd calls the edit history.  Since interprocess
communication proved problematic in this case,
the communication path was simplified to
consist of little more than shared files, with CLM treated
as a batch program.
</p>

<p>
To give a specific example of this way of using Snd,
say we have a sound processing CLM instrument we like; it takes
two sound file names as its arguments, reading the first and writing the second.
In Snd we write the current edited state to a temporary file (<a href="extsnd.html#sndsaveas">save-sound-as</a>),
start CLM, call the instrument 
passing it the input filename (just written by Snd), then pass CLM's output back
to Snd.  Snd replaces (via set-samples) the current data with the data our instrument wrote, as if it had incorporated that
instrument as an editing operation from the beginning.
We then delete the Snd output (the input to CLM).
</p>

<br>
<span class=bbox><h3><A NAME="sndaswidget">Snd as a Widget</a></h3></span>

<p>To include the entire Snd editor as a widget in some other program,
first compile it with -DSND_AS_WIDGET. Then load it into your program,
using the procedure <b>snd_as_widget</b> to fire it up.  The program
saw.c included with Snd is a very brief example.</p>

<pre>
  void snd_as_widget(int argc, char **argv, XtAppContext app, Widget parent, Arg *caller_args, int caller_argn)
</pre>

<p>starts up the Snd editor in the widget <i>parent</i>, passing the outer Snd
form widget the arguments <i>caller_args</i> and <i>caller_argn</i>.  The
enclosing application context is <i>app</i>.  <i>parent</i> needs to
be realized at the time of the call, since Snd uses it to set up graphics
contexts and so on.  <i>argc</i> and <i>argv</i> can be passed to
simulate a shell invocation of Snd.  Remember that in this case, the
first string argument is expected to be the application name, and is
ignored by Snd.</p>

<p>In Gtk, the arguments are different, but the basic idea is the same.
saw.c has an example.</p>

<br>
<span class=bbox><h3><A NAME="sndwithclm">Snd and the CLM module</a></h3></span>

<p>The files clm.c, clm.h, and clm2xen.c implement CLM (a Common Lisp Music V implementation
described in clm.html, available in clm-2.tar.gz at ccrma-ftp) as a Guile-loadable module.
They are loaded into Snd when it is built.
You can see what a generator does, or a group of generators, by running them in the
lisp listener, and using the graph and spectrum functions.  Say we have
these declarations in ~/.snd:
</p>

<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define data-size 1024)
(define data (make-vct data-size))

(define run 
  (lambda (fun)
    (do ((i 0 (1+ i))) 
        ((= i data-size))
      (vct-set! data i (fun)))
    (graph data)))

(define runf
  (lambda (fun)
    (do ((i 0 (1+ i))) 
        ((= i data-size))
      (vct-set! data i (fun)))
    (graph (snd-spectrum data blackman2-window data-size #t))))
</pre></td></tr></table>

<p>Now we can open the listener, and type:</p>
<pre>
(define hi (make-oscil))
(run (lambda () (oscil hi)))
(define ho (make-oscil))
(runf (lambda () (oscil hi (* .5 (oscil ho)))))
</pre>
<p>Obviously, any CLM instrument or function can be used in this way 
to edit sounds.  Say we want an echo effect:</p>

<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define echo 
  (lambda (scaler secs)
    (let ((del (make-delay (round (* secs (srate))))))
      (lambda (inval)
        (+ inval (delay del (* scaler (+ (tap del) inval))))))))
</pre></td></tr></table>

<p>
Here <i>scaler</i> sets
how loud subsequent echos are, and <i>secs</i> sets how far apart they
are in seconds.  <i>echo</i> uses the <i>secs</i> argument to create
a delay line (<i>make-delay</i>) using the current sound's
sampling rate to turn the <i>secs</i> parameter into samples.
<i>echo</i> then returns a closure, that is, a function with
associated variables (in this case <i>del</i> and <i>scaler</i>);
the returned function (the second <i>lambda</i>) takes
one argument (<i>inval</i>) and returns the result of passing
that value to the delay with scaling.  The upshot of all this is that
we can use:</p>
<pre>
(map-chan (echo .5 .75) 0 44100)
</pre>
<p>to take the current active channel and 
return 44100 samples of echos, each echo half the amplitude
of the previous, and spaced by .75 seconds.  <i>map-chan</i>'s
first argument is a function of one argument, the current sample;
when we pass it <i>(echo ...)</i>, it evaluates the echo call,
which returns the function that actually runs the delay line,
producing the echo.  
The CLM (common lisp) version might be something like:</p>

<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(definstrument echo (beg dur scaler secs file)
  (let ((del (make-delay (round (* secs *srate*))))
	(inf (open-input file))
	(j 0))
    (run
     (loop for i from beg below (+ beg dur) do
       (let ((inval (ina j inf)))
	 (outa i (+ inval (delay del (* scaler (+ (tap del) inval)))))
	 (incf j))))
    (close-input inf)))

;;; (with-sound () (echo 0 60000 .5 1.0 "pistol.snd"))
</pre></td></tr></table>

<br>

<!-- INDEX clmfuncs:CLM generators -->
<span class=cbox><h4><A NAME="clmfuncs">CLM functions</a></h4></span>

<p>See <a href="clm.html">clm.html</a> for full details. Optional args are in italics.</p>
<br>

<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href="clm.html#all-pass">all-pass</a></td><td>(gen input <i>pm</i>)</td><td>all-pass filter</td></tr>
<tr><td><a href="clm.html#all-pass?">all-pass?</a></td><td>(gen)</td><td>#t if gen is all-pass filter</td></tr>
<tr><td><a href="clm.html#amplitude-modulate">amplitude-modulate</a></td><td>(carrier in1 in2)</td><td>amplitude modulation</td></tr>
<tr><td><a href="clm.html#array-interp">array-interp</a></td><td>(arr x)</td><td>interpolated array lookup</td></tr>
<tr><td><a href="clm.html#array-&gt;file">array-&gt;file</a></td><td colspan=2>(filename vct len srate channels)</td></tr>
<tr><td></td><td colspan=2>
write the contents of <i>vct</i> to the newly created sound file <i>filename</i>, giving 
the new file <i>channels</i> channels (data assumed to be interleaved in <i>vct</i>),
sampling rate <i>srate</i>, and <i>len</i> samples (not frames).
</td></tr>
<tr><td><a href="clm.html#asymmetric-fm">asymmetric-fm</a></td><td>(gen index <i>fm</i>)</td><td>asymmetric-fm generator</td></tr>
<tr><td><a href="clm.html#asymmetric-fm?">asymmetric-fm?</a></td><td>(gen)</td><td>#t if gen is asymmetric-fm generator</td></tr>
<tr><td><a href="clm.html#buffer-&gt;frame">buffer-&gt;frame</a></td><td>(gen frame)</td><td>buffer generator returning frame</td></tr>
<tr><td><a href="clm.html#buffer-&gt;sample">buffer-&gt;sample</a></td><td>(gen)</td><td>buffer generator returning sample</td></tr>
<tr><td><a href="clm.html#buffer-empty?">buffer-empty?</a></td><td>(gen)</td><td>#t if buffer has no data</td></tr>
<tr><td><a href="clm.html#buffer-full?">buffer-full?</a></td><td>(gen)</td><td>#t if buffer has no room for more data</td></tr>
<tr><td><a href="clm.html#buffer?">buffer?</a></td><td>(gen)</td><td>#t if gen is buffer generator</td></tr>
<tr><td><a href="clm.html#clear-array">clear-array</a></td><td>(arr)</td><td>set all elements of arr to 0.0</td></tr>
<tr><td><a href="clm.html#comb">comb</a></td><td>(gen input <i>pm</i>)</td><td>comb filter</td></tr>
<tr><td><a href="clm.html#comb?">comb?</a></td><td>(gen)</td><td>#t if gen is comb filter</td></tr>
<tr><td><a href="clm.html#continue-sample-&gt;file">continue-sample-&gt;file</a></td><td>(file)</td><td>reopen file for more output</td></tr>
<tr><td><a href="clm.html#contrast-enhancement">contrast-enhancement</a></td><td>(input (<i>index</i> 1.0))</td><td>a kind of phase modulation or companding</td></tr>
<tr><td><a href="clm.html#convolution">convolution</a></td><td>(sig1 sig2 n)</td><td>convolve sig1 with sig2 (size n), returning new sig1</td></tr>
<tr><td><a href="clm.html#convolve">convolve</a></td><td>(gen <i>input-function</i>)</td><td>convolve generator</td></tr>
<tr><td><a href="clm.html#convolve?">convolve?</a></td><td>(gen)</td><td>#t if gen is convolve generator</td></tr>
<tr><td><a href="clm.html#convolvefiles">convolve-files</a></td><td>(f1 f2 maxamp outf)</td><td>convolve f1 with f2, normalize to maxamp, write outf</td></tr>
<tr><td><a href="clm.html#db-&gt;linear">db-&gt;linear</a></td><td>(db)</td><td>translate dB value to linear</td></tr>
<tr><td><a href="clm.html#degrees-&gt;radians">degrees-&gt;radians</a></td><td>(deg)</td><td>translate degrees to radians</td></tr>
<tr><td><a href="clm.html#delay">delay</a></td><td>(gen input <i>pm</i>)</td><td>delay line</td></tr>
<tr><td></td><td colspan=2><br>
In Scheme <b>delay</b> is a built-in syntactic form; it is renamed <b>%delay</b> here.
</td></tr>
<tr><td colspan=3><br></td></tr>
<tr><td><a href="clm.html#delay?">delay?</a></td><td>(gen)</td><td>#t if gen is delay line</td></tr>
<tr><td><a href="clm.html#dot-product">dot-product</a></td><td>(sig1 sig2)</td><td>return dot-product of sig1 with sig2</td></tr>
<tr><td><a href="clm.html#env">env</a></td><td>(gen)</td><td>envelope generator</td></tr>
<tr><td><a href="clm.html#env-interp">env-interp</a></td><td>(x env (<i>base</i> 1.0))</td><td>return value of env at x</td></tr>
<tr><td><a href="clm.html#env?">env?</a></td><td>(gen)</td><td>#t if gen is env (from make-env)</td></tr>
<tr><td><a href="clm.html#fft">mus-fft</a></td><td>(rl im <i>n sign</i>)</td><td>fft of rl and im (sign = -1 for ifft), result in rl</td></tr>
<tr><td valign=top><a href="clm.html#file-&gt;array">file-&gt;array</a></td><td valign=top>(filename chan start len vct)</td><td>
load <i>len</i> samples of <i>filename</i> into <i>vct</i> starting at frame <i>start</i> in channel <i>chan</i>.
</td></tr>
<tr><td><a href="clm.html#file-&gt;frame">file-&gt;frame</a></td><td>(gen loc <i>frame</i>)</td><td>return frame from file at loc</td></tr>
<tr><td><a href="clm.html#file-&gt;frame?">file-&gt;frame?</a></td><td>(gen)</td><td>#t if gen is file-&gt;frame generator</td></tr>
<tr><td><a href="clm.html#file-&gt;sample">file-&gt;sample</a></td><td>(gen loc <i>(chan 0)</i>)</td><td>return sample from file at loc</td></tr>
<tr><td><a href="clm.html#file-&gt;sample?">file-&gt;sample?</a></td><td>(gen)</td><td>#t if gen is file-&gt;sample generator</td></tr>
<tr><td><a href="clm.html#filter">filter</a></td><td>(gen input)</td><td>filter</td></tr>
<tr><td><a href="clm.html#filter?">filter?</a></td><td>(gen)</td><td>#t if gen is filter</td></tr>
<tr><td><a href="clm.html#fir-filter">fir-filter</a></td><td>(gen input)</td><td>FIR filter</td></tr>
<tr><td><a href="clm.html#fir-filter?">fir-filter?</a></td><td>(gen)</td><td>#t if gen is fir filter</td></tr>
<tr><td><a href="clm.html#formant">formant</a></td><td>(gen input)</td><td>formant generator</td></tr>
<tr><td>formant-bank</td><td>(scls gens inval)</td><td></td></tr>
<tr><td><a href="clm.html#formant?">formant?</a></td><td>(gen)</td><td>#t if gen is formant generator</td></tr>
<tr><td><a href="clm.html#frame*">frame*</a></td><td>(fr1 fr2 <i>outfr</i>)</td><td>element-wise multiply</td></tr>
<tr><td><a href="clm.html#frame+">frame+</a></td><td>(fr1 fr2 <i>outfr</i>)</td><td>element-wise add</td></tr>
<tr><td><a href="clm.html#frame-&gt;buffer">frame-&gt;buffer</a></td><td>(buf frame)</td><td>add frame to buffer</td></tr>
<tr><td><a href="clm.html#frame-&gt;file">frame-&gt;file</a></td><td>(gen loc frame)</td><td>write (add) frame to file at loc</td></tr>
<tr><td><a href="clm.html#frame-&gt;file?">frame-&gt;file?</a></td><td>(gen)</td><td>#t if gen is frame-&gt;file generator</td></tr>
<tr><td><a href="clm.html#frame-&gt;frame">frame-&gt;frame</a></td><td>(mixer frame <i>outfr</i>)</td><td>pass frame through mixer</td></tr>
<tr><td><a href="clm.html#frame-&gt;list">frame-&gt;list</a></td><td>(frame)</td><td>return list of frame contents</td></tr>
<tr><td><a href="clm.html#frame-ref">frame-ref</a></td><td>(frame chan)</td><td>return frame[chan]</td></tr>
<tr><td><a href="clm.html#frame-&gt;sample">frame-&gt;sample</a></td><td>(frmix frame)</td><td>pass frame through frame or mixer to produce sample</td></tr>
<tr><td><a href="clm.html#frame-set!">frame-set!</a></td><td>(frame chan val)</td><td>frame[chan]=val</td></tr>
<tr><td><a href="clm.html#frame?">frame?</a></td><td>(gen)</td><td>#t if gen is frame object</td></tr>
<tr><td></td><td colspan=2><br>
In Guile <b>frame?</b> is part of the debugger; it is renamed <b>%frame?</b> here.
</td></tr>
<tr><td colspan=3><br></td></tr>
<tr><td><a href="clm.html#granulate">granulate</a></td><td>(gen <i>input-function</i>)</td><td>granular synthesis generator</td></tr>
<tr><td><a href="clm.html#granulate?">granulate?</a></td><td>(gen)</td><td>#t if gen is granulate generator</td></tr>
<tr><td><a href="clm.html#hz-&gt;radians">hz-&gt;radians</a></td><td>(freq)</td><td>translate freq to radians/sample</td></tr>
<tr><td><a href="clm.html#iir-filter">iir-filter</a></td><td>(gen input)</td><td>IIR filter</td></tr>
<tr><td><a href="clm.html#iir-filter?">iir-filter?</a></td><td>(gen)</td><td>#t if gen is iir-filter</td></tr>
<tr><td><a href="clm.html#in-any">in-any</a></td><td>(loc <i>chan stream</i>)</td><td>return sample in stream at loc and chan</td></tr>
<tr><td>in-hz</td><td>(freq)</td><td>translate freq to radians/sample</td></tr>
<tr><td><a href="clm.html#ina">ina</a></td><td>(loc <i>stream</i>)</td><td>return sample in stream at loc, chan 0</td></tr>
<tr><td><a href="clm.html#inb">inb</a></td><td>(loc <i>stream</i>)</td><td>return sample in stream at loc, chan 1</td></tr>
<tr><td><a href="clm.html#linear-&gt;db">linear-&gt;db</a></td><td>(val)</td><td>translate linear val to dB</td></tr>
<tr><td><a href="clm.html#locsig">locsig</a></td><td>(gen loc input)</td><td>place input in output channels at loc</td></tr>
<tr><td><a href="clm.html#locsig-ref">locsig-ref</a></td><td>(gen chan)</td><td>locsig-scaler[chan]</td></tr>
<tr><td><a href="clm.html#locsig-reverb-ref">locsig-reverb-ref</a></td><td>(gen chan)</td><td>locsig-reverb-scaler[chan]</td></tr>
<tr><td><a href="clm.html#locsig-set!">locsig-set!</a></td><td>(gen chan val)</td><td>locsig-scaler[chan] = val</td></tr>
<tr><td><a href="clm.html#locsig-reverb-set!">locsig-reverb-set!</a></td><td>(gen chan val)</td><td>locsig-reverb-scaler[chan] = val</td></tr>
<tr><td><a href="clm.html#locsig?">locsig?</a></td><td>(gen)</td><td>#t if gen is locsig generator</td></tr>
<tr><td colspan=3><br>
;; all the make function arguments are <a href="clm.html#optional-key">optional-key</a> args
</td></tr>
<tr><td><a href="clm.html#make-all-pass">make-all-pass</a></td><td colspan=2>(feedback feedforward size initial-contents initial-element max-size)</td></tr>
<tr><td><a href="clm.html#make-asymmetric-fm">make-asymmetric-fm</a></td><td colspan=2>(frequency initial-phase r ratio)</td></tr>
<tr><td><a href="clm.html#make-buffer">make-buffer</a></td><td colspan=2>(size fill-time)</td></tr>
<tr><td><a href="clm.html#make-comb">make-comb</a></td><td colspan=2>(scaler size initial-contents initial-element max-size)</td></tr>
<tr><td><a href="clm.html#make-convolve">make-convolve</a></td><td colspan=2>(input filter fft-size filter-size)</td></tr>
<tr><td><a href="clm.html#make-delay">make-delay</a></td><td colspan=2>(size initial-contents initial-element max-size)</td></tr>
<tr><td><a href="clm.html#make-env">make-env</a></td><td colspan=2>(envelope scaler duration offset base end start)</td></tr>
<tr><td><a href="clm.html#make-fft-window">make-fft-window</a></td colspan=2><td>(type size beta)</td></tr>
<tr><td><a href="clm.html#make-file-&gt;frame">make-file-&gt;frame</a></td><td colspan=2>(name)</td></tr>
<tr><td><a href="clm.html#make-file-&gt;sample">make-file-&gt;sample</a></td><td colspan=2>(name)</td></tr>
<tr><td><a href="clm.html#make-filter">make-filter</a></td><td colspan=2>(order xcoeffs ycoeffs)</td></tr>
<tr><td><a href="clm.html#make-fir-filter">make-fir-filter</a></td><td colspan=2>(order xcoeffs)</td></tr>
<tr><td><a href="clm.html#make-formant">make-formant</a></td><td colspan=2>(radius frequency gain)</td></tr>
<tr><td><a href="clm.html#make-frame">make-frame</a></td><td colspan=2>(chans &amp;rest vals)</td></tr>
<tr><td><a href="clm.html#make-frame-&gt;file">make-frame-&gt;file</a></td><td colspan=2>(name chans format type)</td></tr>
<tr><td><a href="clm.html#make-granulate">make-granulate</a></td><td colspan=2>(input expansion length scaler hop ramp jitter max-size)</td></tr>
<tr><td><a href="clm.html#make-iir-filter">make-iir-filter</a></td><td colspan=2>(order ycoeffs)</td></tr>
<tr><td><a href="clm.html#make-locsig">make-locsig</a></td><td colspan=2>(degree distance reverb output revout channels type)</td></tr>
<tr><td><a href="clm.html#make-mixer">make-mixer</a></td><td colspan=2>(chans &amp;rest vals)</td></tr>
<tr><td><a href="clm.html#make-notch">make-notch</a></td><td colspan=2>(scaler size initial-contents initial-element max-size)</td></tr>
<tr><td><a href="clm.html#make-one-pole">make-one-pole</a></td><td colspan=2>(a0 b1)</td></tr>
<tr><td><a href="clm.html#make-one-zero">make-one-zero</a></td><td colspan=2>(a0 a1)</td></tr>
<tr><td><a href="clm.html#make-oscil">make-oscil</a></td><td colspan=2>(frequency initial-phase)</td></tr>
<tr><td><a href="clm.html#make-phase-vocoder">make-phase-vocoder</a></td><td colspan=2>(fftsize overlap interp pitch analyze edit synthesize)</td></tr>
<tr><td><a href="clm.html#make-ppolar">make-ppolar</a></td><td colspan=2>(radius frequency)</td></tr>
<tr><td><a href="clm.html#make-pulse-train">make-pulse-train</a></td><td colspan=2>(frequency amplitude initial-phase)</td></tr>
<tr><td><a href="clm.html#make-rand">make-rand</a></td><td colspan=2>(frequency amplitude)</td></tr>
<tr><td><a href="clm.html#make-rand-interp">make-rand-interp</a></td><td colspan=2>(frequency amplitude)</td></tr>
<tr><td><a href="clm.html#make-readin">make-readin</a></td><td colspan=2>(file channel start)</td></tr>
<tr><td><a href="clm.html#make-sample-&gt;file">make-sample-&gt;file</a></td><td colspan=2>(name chans format type <i>comment</i>)</td></tr>
<tr><td><a href="clm.html#make-sawtooth-wave">make-sawtooth-wave</a></td><td colspan=2>(frequency amplitude initial-phase)</td></tr>
<tr><td><a href="clm.html#make-sine-summation">make-sine-summation</a></td><td colspan=2>(frequency initial-phase n a ratio)</td></tr>
<tr><td><a href="clm.html#make-square-wave">make-square-wave</a></td><td colspan=2>(frequency amplitude initial-phase)</td></tr>
<tr><td><a href="clm.html#make-src">make-src</a></td><td colspan=2>(input srate width)</td></tr>
<tr><td><a href="clm.html#make-sum-of-cosines">make-sum-of-cosines</a></td><td colspan=2>(frequency initial-phase cosines)</td></tr>
<tr><td><a href="clm.html#make-table-lookup">make-table-lookup</a></td><td colspan=2>(frequency initial-phase wave size)</td></tr>
<tr><td><a href="clm.html#make-triangle-wave">make-triangle-wave</a></td><td colspan=2>(frequency amplitude initial-phase)</td></tr>
<tr><td><a href="clm.html#make-two-pole">make-two-pole</a></td><td colspan=2>(a0 b1 b2)</td></tr>
<tr><td><a href="clm.html#make-two-zero">make-two-zero</a></td><td colspan=2>(a0 a1 a2)</td></tr>
<tr><td><a href="clm.html#make-wave-train">make-wave-train</a></td><td colspan=2>(frequency initial-phase wave size)</td></tr>
<tr><td><a href="clm.html#make-waveshape">make-waveshape</a></td><td colspan=2>(frequency partials wave size)</td></tr>
<tr><td><a href="clm.html#make-zpolar">make-zpolar</a></td><td colspan=2>(radius frequency)</td></tr>
<tr><td><a href="clm.html#mixer*">mixer*</a></td><td>(mix1 mix2 <i>outmx</i>)</td><td>matrix multiply of mix1 and mix2</td></tr>
<tr><td><a href="clm.html#mixer-ref">mixer-ref</a></td><td>(mix in out)</td><td>mix-scaler[in,out]</td></tr>
<tr><td><a href="clm.html#mixer-set!">mixer-set!</a></td><td>(mix in out val)</td><td>mix-scaler[in,out] = val</td></tr>
<tr><td><a href="clm.html#mixer?">mixer?</a></td><td>(gen)</td><td>#t if gen is mixer object</td></tr>
<tr><td><a href="clm.html#move-locsig">move-locsig</a></td><td colspan=2>(gen degree distance)</td></tr>
<tr><td><a href="clm.html#multiply-arrays">multiply-arrays</a></td><td>(arr1 arr2)</td><td>arr1[i] *= arr2[i]</td></tr>
<tr><td><a href="clm.html#mus-a0">mus-a0</a></td><td>(gen)</td><td>a0 field (simple filters)</td></tr>
<tr><td><a href="clm.html#mus-a1">mus-a1</a></td><td>(gen)</td><td>a1 field (simple filters)</td></tr>
<tr><td><a href="clm.html#mus-a2">mus-a2</a></td><td>(gen)</td><td>a2 field (simple filters)</td></tr>
<tr><td>mus-array-print-length</td><td>()</td><td>how many array elements to print in mus_describe</td></tr>
<tr><td><a href="clm.html#mus-b1">mus-b1</a></td><td>(gen)</td><td>b1 field (simple filters)</td></tr>
<tr><td><a href="clm.html#mus-b2">mus-b2</a></td><td>(gen)</td><td>b2 field (simple filters)</td></tr>
<tr><td><a href="clm.html#musbank">mus-bank</a></td><td>(gens amps <i>args1 args2</i>)</td><td></td></tr>
<tr><td><a href="clm.html#mus-channel">mus-channel</a></td><td>(gen)</td><td>channel of gen</td></tr>
<tr><td><a href="clm.html#mus-channels">mus-channels</a></td><td>(gen)</td><td>channels of gen</td></tr>
<tr><td><a href="clm.html#mus-cosines">mus-cosines</a></td><td>(gen)</td><td>cosines of sum-of-cosines gen</td></tr>
<tr><td><a href="clm.html#mus-data">mus-data</a></td><td>(gen)</td><td>data array of gen</td></tr>
<tr><td><a href="clm.html#mus-feedback">mus-feedback</a></td><td>(gen)</td><td>feedback term of gen (simple filters)</td></tr>
<tr><td><a href="clm.html#mus-feedforward">mus-feedforward</a></td><td>(gen)</td><td>feedforward term of gen (all-pass)</td></tr>
<tr><td>mus-file-buffer-size</td><td>()</td><td>size of input/ouput buffers (default 8192)</td></tr>
<tr><td><a href="clm.html#mus-file-name">mus-file-name</a></td><td>(gen)</td><td>name of file assoicated with gen</td></tr>
<tr><td><a href="clm.html#mus-formant-radius">mus-formant-radius</a></td><td>(gen)</td><td>formant radius</td></tr>
<tr><td><a href="clm.html#mus-frequency">mus-frequency</a></td><td>(gen)</td><td>frequency of gen (Hz)</td></tr>
<tr><td><a href="clm.html#mus-hop">mus-hop</a></td><td>(gen)</td><td>hop amount of gen (granulate)</td></tr>
<tr><td><a href="clm.html#mus-increment">mus-increment</a></td><td>(gen)</td><td>increment of gen (src, readin, granulate)</td></tr>
<tr><td><a href="clm.html#mus-input?">mus-input?</a></td><td>(gen)</td><td>#t if gen is input source</td></tr>
<tr><td><a href="clm.html#mus-length">mus-length</a></td><td>(gen)</td><td>length of gen</td></tr>
<tr><td><a href="clm.html#mus-location">mus-location</a></td><td>(gen)</td><td>location (read point) of gen</td></tr>
<tr><td>mus-mix</td><td colspan=2>(outfile infile <i>(outloc 0) frames (inloc 0) mixer envs</i>)</td></tr>
<tr><td></td><td colspan=2><br>
mix <i>infile</i> into <i>outfile</i> starting at <i>outloc</i> in <i>outfile</i> and <i>inloc</i> in <i>infile</i>
mixing <i>frames</i> frames of <i>infile</i>.  <i>frames</i> defaults to the length of <i>infile</i>. If <i>mixer</i>,
use it to scale the various channels; if <i>envs</i> (an array of envelope generators), use
it in conjunction with <i>mixer</i>to scale/envelope all the various ins and outs.
</td></tr>
<tr><td colspan=3><br></td></tr>
<tr><td><a href="clm.html#mus-order">mus-order</a></td><td>(gen)</td><td>order of gen (filters)</td></tr>
<tr><td><a href="clm.html#mus-output?">mus-output?</a></td><td>(gen)</td><td>#t if gen is output generator</td></tr>
<tr><td><a href="clm.html#mus-phase">mus-phase</a></td><td>(gen)</td><td>phase of gen (radians)</td></tr>
<tr><td><a href="clm.html#mus-ramp">mus-ramp</a></td><td>(gen)</td><td>ramp time of gen (granulate)</td></tr>
<tr><td><a href="clm.html#mus-random">mus-random</a></td><td>(val)</td><td>random numbers bewteen -val and val</td></tr>
<tr><td><a href="clm.html#mus-run">mus-run</a></td><td>(gen <i>arg1 arg2</i>)</td><td>apply gen to args</td></tr>
<tr><td><a href="clm.html#mus-scaler">mus-scaler</a></td><td>(gen)</td><td>scaler of gen</td></tr>
<tr><td><a href="clm.html#mus-set-rand-seed">mus-rand-seed</a></td><td>(val)</td><td>random number generator seed (settable via set!)</td></tr>
<tr><td>mus-srate</td><td>()</td><td>current sampling rate</td></tr>
<tr><td><a href="clm.html#mus-xcoeffs">mus-xcoeffs</a></td><td>(gen)</td><td>feedforward (FIR) coeffs of filter</td></tr>
<tr><td><a href="clm.html#mus-ycoeffs">mus-ycoeffs</a></td><td>(gen)</td><td>feedback (IIR) coeefs of filter</td></tr>
<tr><td><a href="clm.html#notch">notch</a></td><td>(gen input <i>pm</i>)</td><td>notch filter</td></tr>
<tr><td><a href="clm.html#notch?">notch?</a></td><td>(gen)</td><td>#t if gen is notch filter</td></tr>
<tr><td><a href="clm.html#one-pole">one-pole</a></td><td>(gen input)</td><td>one-pole filter</td></tr>
<tr><td><a href="clm.html#one-pole?">one-pole?</a></td><td>(gen)</td><td>#t if gen is one-pole filter</td></tr>
<tr><td><a href="clm.html#one-zero">one-zero</a></td><td>(gen input)</td><td>one-zero filter</td></tr>
<tr><td><a href="clm.html#one-zero?">one-zero?</a></td><td>(gen)</td><td>#t if gen is one-zero filter</td></tr>
<tr><td><a href="clm.html#oscil">oscil</a></td><td>(gen <i>fm pm</i>)</td><td>sine wave generator</td></tr>
<tr><td><a href="clm.html#oscilbank">oscil-bank</a></td><td>(scls gens invals)</td><td>bank of oscils</td></tr>
<tr><td><a href="clm.html#oscil?">oscil?</a></td><td>(gen)</td><td>#t if gen is oscil generator</td></tr>
<tr><td><a href="clm.html#out-any">out-any</a></td><td>(loc samp chan <i>stream</i>)</td><td>write (add) samp to stream at loc in channel chan</td></tr>
<tr><td><a href="clm.html#outa">outa</a></td><td>(loc samp <i>stream</i>)</td><td>write (add) samp to stream at loc in chan 0</td></tr>
<tr><td><a href="clm.html#outb">outb</a></td><td>(loc samp <i>stream</i>)</td><td>write (add) samp to stream at loc in chan 1</td></tr>
<tr><td><a href="clm.html#outc">outc</a></td><td>(loc samp <i>stream</i>)</td><td>write (add) samp to stream at loc in chan 2</td></tr>
<tr><td><a href="clm.html#outd">outd</a></td><td>(loc samp <i>stream</i>)</td><td>write (add) samp to stream at loc in chan 3</td></tr>
<tr><td><a href="clm.html#partials-&gt;polynomial">partials-&gt;polynomial</a></td><td>(partials <i>kind</i>)</td><td>create waveshaping polynomial from partials</td></tr>
<tr><td><a href="clm.html#partials-&gt;wave">partials-&gt;wave</a></td><td>(synth-data table <i>norm</i>)</td><td>load table from synth-data</td></tr>
<tr><td><a href="clm.html#partials-&gt;waveshape">partials-&gt;waveshape</a></td><td>(partials <i>norm size</i>)</td><td>create waveshaping table from partials</td></tr>
<tr><td><a href="clm.html#phase-partials-&gt;wave">phase-partials-&gt;wave</a></td><td>(synth-data table <i>norm</i>)</td><td>load table from synth-data</td></tr>
<tr><td><a href="clm.html#phase-vocoder">phase-vocoder</a></td><td>(pv input)</td><td>phase vocoder generator</td></tr>
<tr><td><a href="clm.html#phase-vocoder?">phase-vocoder?</a></td><td>(pv)</td><td>#t if pv is phase vocoder generator</td></tr>
<tr><td><a href="clm.html#polar-&gt;rectangular">polar-&gt;rectangular</a></td><td>(rl im)</td><td>translate from polar to rectangular coordinates</td></tr>
<tr><td><a href="clm.html#polynomial">polynomial</a></td><td>(coeffs x)</td><td>evaluate polynomial at x</td></tr>
<tr><td><a href="clm.html#pulse-train">pulse-train</a></td><td>(gen <i>fm</i>)</td><td>pulse-train generator</td></tr>
<tr><td><a href="clm.html#pulse-train?">pulse-train?</a></td><td>(gen)</td><td>#t if gen is pulse-train generator</td></tr>
<tr><td><a href="clm.html#radians-&gt;degrees">radians-&gt;degrees</a></td><td>(rads)</td><td>convert radians to degrees</td></tr>
<tr><td><a href="clm.html#radians-&gt;hz">radians-&gt;hz</a></td><td>(rads)</td><td>convert radians/sample to Hz</td></tr>
<tr><td><a href="clm.html#rand">rand</a></td><td>(gen <i>fm</i>)</td><td>random number generator</td></tr>
<tr><td></td><td colspan=2><br>
In Ruby <b>rand</b> is a built-in method; it is aliased to <b>kernel_rand</b> here.
</td></tr>
<tr><td colspan=3><br></td></tr>
<tr><td><a href="clm.html#rand-interp">rand-interp</a></td><td>(gen <i>fm</i>)</td><td>interpolating random number generator</td></tr>
<tr><td><a href="clm.html#rand-interp?">rand-interp?</a></td><td>(gen)</td><td>#t if gen is interpolating random number generator</td></tr>
<tr><td><a href="clm.html#rand?">rand?</a></td><td>(gen)</td><td>#t if gen is random number generator</td></tr>
<tr><td><a href="clm.html#readin">readin</a></td><td>(gen)</td><td>read one value from associated input stream</td></tr>
<tr><td><a href="clm.html#readin?">readin?</a></td><td>(gen)</td><td>#t if gen is readin generator</td></tr>
<tr><td><a href="clm.html#rectangular-&gt;polar">rectangular-&gt;polar</a></td><td>(rl im)</td><td>translate from rectangular to polar coordinates</td></tr>
<tr><td><a href="clm.html#restart-env">restart-env</a></td><td>(env)</td><td>return to start of env</td></tr>
<tr><td><a href="clm.html#ring-modulate">ring-modulate</a></td><td>(sig1 sig2)</td><td>sig1 * sig2 (element-wise)</td></tr>
<tr><td><a href="clm.html#sample-&gt;buffer">sample-&gt;buffer</a></td><td>(buf samp)</td><td>store samp in buffer</td></tr>
<tr><td><a href="clm.html#sample-&gt;file">sample-&gt;file</a></td><td>(gen loc chan val)</td><td>store val in file at loc in channel chan</td></tr>
<tr><td><a href="clm.html#sample-&gt;file?">sample-&gt;file?</a></td><td>(gen)</td><td>#t if gen is sample-&gt;file generator</td></tr>
<tr><td><a href="clm.html#sample-&gt;frame">sample-&gt;frame</a></td><td>(frmix samp <i>outfr</i>)</td><td>convert samp to frame</td></tr>
<tr><td><a href="clm.html#sawtooth-wave">sawtooth-wave</a></td><td>(gen <i>fm</i>)</td><td>sawtooth-wave generator</td></tr>
<tr><td><a href="clm.html#sawtooth-wave?">sawtooth-wave?</a></td><td>(gen)</td><td>#t if gen is sawtooth-wave generator</td></tr>
<tr><td><a href="clm.html#sine-summation">sine-summation</a></td><td>(gen <i>fm</i>)</td><td>sine-summation generator</td></tr>
<tr><td><a href="clm.html#sine-summation?">sine-summation?</a></td><td>(gen)</td><td>#t if gen is sine-summation generator</td></tr>
<tr><td><a href="clm.html#spectrum">spectrum</a></td><td>(rl im win type)</td><td>produce spectrum of data in rl (return rl)</td></tr>
<tr><td><a href="clm.html#square-wave">square-wave</a></td><td>(gen <i>fm</i>)</td><td>square-wave generator</td></tr>
<tr><td><a href="clm.html#square-wave?">square-wave?</a></td><td>(gen)</td><td>#t if gen is square-wave generator</td></tr>
<tr><td><a href="clm.html#src">src</a></td><td>(gen <i>fm input-function</i>)</td><td>sample rate converter</td></tr>
<tr><td><a href="clm.html#src?">src?</a></td><td>(gen)</td><td>#t if gen is sample-rate converter</td></tr>
<tr><td><a href="clm.html#sum-of-cosines">sum-of-cosines</a></td><td>(gen <i>fm</i>)</td><td>sum-of-cosines (pulse-train) generator</td></tr>
<tr><td><a href="clm.html#sum-of-cosines?">sum-of-cosines?</a></td><td>(gen)</td><td>#t if gen is sum-of-cosines generator</td></tr>
<tr><td><a href="clm.html#sum-of-sines">sum-of-sines</a></td><td>(amps phases)</td><td>additive synthesis</td></tr>
<tr><td><a href="clm.html#table-lookup">table-lookup</a></td><td>(gen <i>fm</i>)</td><td>table-lookup generator</td></tr>
<tr><td><a href="clm.html#table-lookup?">table-lookup?</a></td><td>(gen)</td><td>#t if gen is table-lookup generator</td></tr>
<tr><td><a href="clm.html#tap">tap</a></td><td>(gen <i>pm</i>)</td><td>delay line tap</td></tr>
<tr><td><a href="clm.html#triangle-wave">triangle-wave</a></td><td>(gen <i>fm</i>)</td><td>triangle-wave generator</td></tr>
<tr><td><a href="clm.html#triangle-wave?">triangle-wave?</a></td><td>(gen)</td><td>#t if gen is triangle-wave generator</td></tr>
<tr><td><a href="clm.html#two-pole">two-pole</a></td><td>(gen input)</td><td>two-pole filter</td></tr>
<tr><td><a href="clm.html#two-pole?">two-pole?</a></td><td>(gen)</td><td>#t if gen is two-pole filter</td></tr>
<tr><td><a href="clm.html#two-zero">two-zero</a></td><td>(gen input)</td><td>two-zero filter</td></tr>
<tr><td><a href="clm.html#two-zero?">two-zero?</a></td><td>(gen)</td><td>#t if gen is two-zero filter</td></tr>
<tr><td><a href="clm.html#wave-train">wave-train</a></td><td>(gen <i>fm</i>)</td><td>wave-train generator</td></tr>
<tr><td><a href="clm.html#wave-train?">wave-train?</a></td><td>(gen)</td><td>#t if gen is wave-train generator</td></tr>
<tr><td><a href="clm.html#waveshape">waveshape</a></td><td>(gen <i>index fm</i>)</td><td>waveshaping generator</td></tr>
<tr><td><a href="clm.html#waveshape?">waveshape?</a></td><td>(gen)</td><td>#t if gen is waveshape generator</td></tr>
</table>
<br>

<p>In Snd, the default locsig interpolation type is handled via locsig-type, rather than CLM's global
variable *clm-locsig-type*.
</p>

<p><b>formant-bank</b> and <b>oscil-bank</b> are optimizations for situations like the phase
vocoder or cross synthesis (see <a href="sndscm.html#exampdoc">examp.scm</a>).  It is assumed that you have a vector of generators,
all summing their outputs into a single float.  The amplitude scalers (the first argument to
the bank function) can be a float, a vector of floats, a vct of floats, or a function that
returns a float each time it is called; similarly for the inputs (the third argument); the
bank of generators (the second argument) is assumed to be a vector full of generators. </p>
<pre>
  (formant-bank amps gens inval)
</pre>
<p>is the same as (but 30 times faster than)</p>
<pre>
  (do ((sum 0.0)
       (i 0 (1+ i))) 
      ((= i (vct-length gens)) sum)
    (set! sum (+ sum (* (vector-ref amps i)
                        (formant (vector-ref gens i) inval)))))
</pre>
<p>in the all-vector case.  <a href="clm.html#musbank">mus-bank</a> is the general case.
Here are a few more examples, taken from <a href="sndscm.html#exampdoc">examp.scm</a>.
</p>
<pre>


(define comb-filter 
  (lambda (scaler size)
    (let ((cmb (make-comb scaler size)))
      (lambda (x) (comb cmb x)))))

; (map-chan (comb-filter .8 32))

;;; by using filters at harmonically related sizes, we can get chords:

(define comb-chord
  (lambda (scaler size amp)
    (let ((c1 (make-comb scaler size))
	  (c2 (make-comb scaler (* size .75)))
	  (c3 (make-comb scaler (* size 1.2))))
      (lambda (x)
        (* amp (+ (comb c1 x) (comb c2 x) (comb c3 x)))))))

; (map-chan (comb-chord .95 60 .3))

;;; or change the comb length via an envelope:

(define max-envelope
  (lambda (e mx)
    (if (null? e)
	mx
      (max-envelope (cddr e) (max mx (abs (cadr e)))))))

(define zcomb
  (lambda (scaler size pm)
    (let ((cmb (make-comb scaler size :max-size (+ size 1 (max-envelope pm 0))))
	  (penv (make-env :envelope pm :end (frames))))
      (lambda (x) (comb cmb x (env penv))))))

; (map-chan (zcomb .8 32 '(0 0 1 10)))

;;; to impose several formants, just add them in parallel:

(define formants
  (lambda (r1 f1 r2 f2 r3 f3)
    (let ((fr1 (make-formant r1 f1))
	  (fr2 (make-formant r2 f2))
	  (fr3 (make-formant r3 f3)))
      (lambda (x)
	(+ (formant fr1 x)
	   (formant fr2 x)
	   (formant fr3 x))))))

; (map-chan (formants .01 900 .02 1800 .01 2700))

;;; to get a moving formant:

(define moving-formant
  (lambda (radius move)
    (let ((frm (make-formant radius (cadr move)))
	  (menv (make-env :envelope move :end (frames))))
      (lambda (x)
        (let ((val (formant frm x)))
	  (set! (mus-frequency frm) (env menv))
	  val)))))

; (map-chan (moving-formant .01 '(0 1200 1 2400)))

;;; various "Forbidden Planet" sound effects:

(define fp
  (lambda (sr osamp osfrq)
    (let* ((os (make-oscil osfrq))
	   (sr (make-src :srate sr))
	   (len (frames))
	   (sf (make-sample-reader))
	   (out-data (make-vct len)))
      (vct-map! out-data
		  (lambda () 
		    (src sr (* osamp (oscil os))
			 (lambda (dir)
			   (if (&gt; dir 0)
			       (next-sample sf)
			       (previous-sample sf))))))
      (free-sample-reader sf)
      (vct-&gt;samples 0 len out-data))))

; (fp 1.0 .3 20)


;;; -------- shift pitch keeping duration constant
;;;
;;; both src and granulate take a function argument to get input whenever it is needed.
;;; in this case, src calls granulate which reads the currently selected file.

(define <A NAME="expsrc">expsrc</a>
  (lambda (rate)
    (let* ((gr (make-granulate :expansion rate))
	   (sr (make-src :srate rate))
	   (vsize 1024)
	   (vbeg 0)
	   (v (samples-&gt;vct 0 vsize))
	   (inctr 0))
      (lambda (inval)
        (src sr 0.0
	  (lambda (dir)
	    (granulate gr
	      (lambda (dir)
		(let ((val (vct-ref v inctr)))
		  (set! inctr (+ inctr dir))
		  (if (&gt;= inctr vsize)
		      (begin
			(set! vbeg (+ vbeg inctr))
			(set! inctr 0)
			(samples-&gt;vct vbeg vsize 0 0 v)))
		  val)))))))))

</pre>
<p>Geez, I haven't had this much fun in a long time!  Check out <a href="sndscm.html#exampdoc">examp.scm</a> and <a href="sndscm.html#sndtestdoc">snd-test.scm</a> for more.  
CLM-in-CL users will be disappointed with the CLM-in-Scheme performance; my tests indicate that
interpreted Scheme (as in Snd currently) is about 30 to 100 times slower than CLM instruments using
the run macro.  That macro now exists in Snd; see the <a href="extsnd.html#optimization">optimization</a>
variable for a brief discussion.  Currently, I can speed up most CLM-related Scheme code
by factors between 8 and 20.  This is still slightly slower than CLM, but it's certainly
an improvement!
</p>
<p>
You can load Rick Taube's CM into Snd as Scheme code:
</p>
<pre>snd -l /home/bil/test/cm-2.4.0/src/cm.scm
</pre>
<p>and all of CM is at your disposal! 
</p>
<br>

<!-- INDEX sndinstruments:Instruments -->
<span class=cbox><h4><A NAME="sndinstruments">Instruments</a></h4></span>

<p>It's hard to decide what's an "instrument" in this context, but I think I'll treat
it as something that can be called as a note in a notelist (say in with-sound) and
generate its own sound, or a reverberator.
See test 23 in snd-test.scm for example calls.
</p>
<table border=1 cellpadding=5>
<tr><th>Instrument</th><th>Sources</th><th>Description</th></tr>
<tr><td>attract</td><td>clm-ins.scm</td><td>James McCarthy's choatic brass</td></tr>
<tr><td>bes-fm</td><td>clm-ins.scm</td><td>FM analog using Bessel j0 rather than sin</td></tr>
<tr><td>bigbird</td><td>bird.scm, bird.rb</td><td>more bird songs</td></tr>
<tr><td>bird</td><td>bird.scm, bird.rb</td><td>bird songs</td></tr>
<tr><td>bow</td><td>strad.scm, strad.rb</td><td>bowed string physical model (Juan Reyes, Michael Scholz)</td></tr>
<tr><td>bowstr</td><td>prc95.scm</td><td>bowed string pysical model</td></tr>
<tr><td>brass</td><td>prc95.scm</td><td>brass pysical model</td></tr>
<tr><td>cellon</td><td>clm-ins.scm</td><td>S Krupowicz's feedback FM</td></tr>
<tr><td>chain-dsps</td><td>examp.scm</td><td>instrument gets gen patch from its args</td></tr>
<tr><td>clarinet</td><td>prc95.scm</td><td>clarinet pysical model</td></tr>
<tr><td>drone, canter</td><td>clm-ins.scm</td><td>Peter Common's bagpipe</td></tr>
<tr><td>flute</td><td>prc95.scm</td><td>flute pysical model</td></tr>
<tr><td>fm-bell</td><td>clm-ins.scm, examp.rb</td><td>Mike McNabb's FM bell</td></tr>
<tr><td>fm-drum</td><td>clm-ins.scm</td><td>Jan Mattox's FM dum</td></tr>
<tr><td>fm-insect</td><td>clm-ins.scm</td><td>FM insect (katydid)</td></tr>
<tr><td>fm-noise</td><td>noise.scm, noise.rb</td><td>noise maker</td></tr>
<tr><td>fm-trumpet</td><td>clm-ins.scm</td><td>Dexter Morrill's FM trumpet</td></tr>
<tr><td>fm-violin</td><td>v.scm, v.rb, fmv.scm, sndscm.html</td><td>violin-like sounds via FM</td></tr>
<tr><td>fofins</td><td>clm-ins.scm</td><td>FOF synthesis</td></tr>
<tr><td>freeverb</td><td>freeverb.scm</td><td>a reverberator</td></tr>
<tr><td>gong</td><td>clm-ins.scm</td><td>Paul Weineke's FM gong</td></tr>
<tr><td>gran-synth</td><td>clm-ins.scm</td><td>simple granular synthesis example</td></tr>
<tr><td>jc-reverb</td><td>jcrev.scm, examp.rb</td><td>Chowning's old reverb</td></tr>
<tr><td>jl-reverb</td><td>clm-ins.scm</td><td>cavernous version of jc-reverb</td></tr>
<tr><td>lbj-piano</td><td>clm-ins.scm</td><td>additive synthesis piano (Doug Fulton)</td></tr>
<tr><td>maraca, big-maraca</td><td>maraca.scm</td><td>Perry Cook's maraca physical model</td></tr>
<tr><td>metal</td><td>clm-ins.scm</td><td>more FM by Perry</td></tr>
<tr><td>nrev</td><td>clm-ins.scm</td><td>Mike McNabb's reverb</td></tr>
<tr><td>p</td><td>piano.scm, piano.rb</td><td>Scott van Duyne's piano physical model</td></tr>
<tr><td>pluck</td><td>clm-ins.scm</td><td>David Jaffe's Karplus-Strong (physical model) plucked string</td></tr>
<tr><td>plucky</td><td>prc95.scm</td><td>plucked string pysical model</td></tr>
<tr><td>pqw-vox</td><td>clm-ins.scm</td><td>vocal sounds from phase-quadrature waveshaping</td></tr>
<tr><td>pqw</td><td>clm-ins.scm</td><td>phase-quadrature waveshaping</td></tr>
<tr><td>resflt</td><td>clm-ins.scm</td><td>two-poles for resonances (Xavier Serra)</td></tr>
<tr><td>reson</td><td>clm-ins.scm</td><td>parallel FM creating resonances</td></tr>
<tr><td>rhodey, wurley, hammondoid</td><td>clm-ins.scm</td><td>FM stuff from Perry Cook</td></tr>
<tr><td>scm-simp</td><td>clm.html</td><td>simple sine wave example instrument</td></tr>
<tr><td>singer</td><td>singer.scm</td><td>Perry Cook's vocal tract physical model</td></tr>
<tr><td>spectra</td><td>clm-ins.scm</td><td>simple additive synthesis</td></tr>
<tr><td>stereo-flute</td><td>clm-ins.scm</td><td>Nicky Hind's flute physical model</td></tr>
<tr><td>touch-tone</td><td>clm-ins.scm</td><td>touch-tone telephone</td></tr>
<tr><td>tubebell</td><td>clm-ins.scm</td><td>Perry Cook's FM tubular bell</td></tr>
<tr><td>two-tab</td><td>clm-ins.scm</td><td>interpolate between two spectra</td></tr>
<tr><td>vox</td><td>clm-ins.scm</td><td>voice using "leapfrog" FM-generated formants</td></tr>
</table>
<br><br>

<!-- INDEX sndeffects:Effects -->
<span class=cbox><h4><A NAME="sndeffects">Effects</a></h4></span>

<p>As with instruments, it's hard to say what isn't an "effect"; even "Invert"
(that is, scale by -1) seems to count as an effect in some circles.  This list
is limited to functions that aren't already built into Snd/CLM.
</p>

<table border=1>
<tr><th>Effect</th><th>Sources</th><th>Description</th></tr>
<tr><td></td><td></td><td></td></tr>
<!-- TODO: fill this table -->
<!-- fade.scm cross-syn hello-dentist vocoder filters expsnd/src compand voiced->un various mixes echos osc-formants(etc) place-sound
     brighten-slightly chorus flanger chordalize zero-phase(etc) vibro/ringmod fp sum-of-cos exs

add:
backandforth.ins:definstrument backandforth 
clm.html:definstrument inside-out
zdelay.ins:definstrument zdelay 
zd.ins:definstrument zc 
zd.ins:definstrument zn 
zipper.ins:definstrument zipper
comb.ins:definstrument comb-test
cross.ins:definstrument cross-synthesis
envsnd.ins:definstrument env-sound 
expfil.ins:definstrument expfil 
expins.ins:definstrument expins 
expsnd.ins:definstrument expsnd 
expsrc.ins:definstrument expsrc 
expsrc.ins:definstrument expsrc1
expsrc.ins:definstrument expsnd 
expsrc.ins:definstrument expfil 
expsrc.ins:definstrument interleave-files 
fade.ins:definstrument cross-fade 
fade.ins:definstrument dissolve-fade 
dissolve.ins:definstrument dissolve 
-->
</table>


<br><br>
<span class=bbox><h3><A NAME="sndwithmotif">Snd and Motif</a></h3></span>

<p>It is possible to add your own user-interface elements using the xm module
included with Snd.  'make xm' should create
a shared library named xm.so; you can load this at any time into Snd:
</p>
<pre>
&gt; <em class=typing>(define hxm (dlopen "/home/bil/snd-6/xm.so"))</em>
<em class=listener>#&lt;unspecified&gt;</em>
&gt; <em class=typing>(dlinit hxm "init_xm")</em>
<em class=listener>#t</em>
</pre>
<p>and now we have access to all of X and Motif.  Alternatively, use the
configure switch --with-static-xm, and the xm module will be included
in the base Snd image.
As a very simple example, here's dialog window with a slider:</p>
<pre>
(define scale-dialog #f)
(define current-scaler 1.0)

(define (create-scale-dialog parent)
  (if (not (Widget? scale-dialog))
      (let ((xdismiss (XmStringCreate "Dismiss" XmFONTLIST_DEFAULT_TAG))
	    (xhelp (XmStringCreate "Help" XmFONTLIST_DEFAULT_TAG))
	    (titlestr (XmStringCreate "Scaling" XmFONTLIST_DEFAULT_TAG)))
	(set! scale-dialog 
	      (XmCreateTemplateDialog parent "Scaling"
                (list XmNcancelLabelString   xdismiss
		      XmNhelpLabelString     xhelp
		      XmNautoUnmanage        #f
		      XmNdialogTitle         titlestr
		      XmNresizePolicy        XmRESIZE_GROW
	              XmNnoResize            #f
		      XmNtransient           #f)))
	(XtAddCallback scale-dialog 
		       XmNcancelCallback (lambda (w context info)
					   (XtUnmanageChild scale-dialog)))
	(XtAddCallback scale-dialog 
		       XmNhelpCallback (lambda (w context info)
					 (snd-print "move the slider to affect the volume")))
	(XmStringFree xhelp)
	(XmStringFree xdismiss)
	(XmStringFree titlestr)

	(let* ((mainform 
		(XtCreateManagedWidget "formd" xmFormWidgetClass scale-dialog
                  (list XmNleftAttachment    XmATTACH_FORM
		        XmNrightAttachment   XmATTACH_FORM
		        XmNtopAttachment     XmATTACH_FORM
		        XmNbottomAttachment  XmATTACH_WIDGET
		        XmNbottomWidget      (XmMessageBoxGetChild scale-dialog XmDIALOG_SEPARATOR))))
	       (scale
		(XtCreateManagedWidget "" xmScaleWidgetClass mainform
		  (list XmNorientation XmHORIZONTAL
			XmNshowValue   #t
			XmNvalue       100
			XmNmaximum     500
			XmNdecimalPoints 2))))

      (XtAddCallback scale XmNvalueChangedCallback (lambda (w context info)
					     (set! current-scaler (/ (.value info) 100.0))))
      (XtAddCallback scale XmNdragCallback (lambda (w context info)
					     (set! current-scaler (/ (.value info) 100.0)))))))
  (XtManageChild scale-dialog))

(create-scale-dialog (cadr (main-widgets)))
</pre>
<p>In Ruby, this is:</p>
<pre>
$scale_dialog = false
$current_scaler = 1.0

def create_scale_dialog(parent)
  if !RWidget?($scale_dialog) 
    then
      xdismiss = RXmStringCreate("Dismiss", RXmFONTLIST_DEFAULT_TAG)
      xhelp = RXmStringCreate("Help", RXmFONTLIST_DEFAULT_TAG)
      titlestr = RXmStringCreate("Scaling", RXmFONTLIST_DEFAULT_TAG)
      $scale_dialog = RXmCreateTemplateDialog(parent, "Scaling",
                   	[RXmNcancelLabelString,  xdismiss,
                      	 RXmNhelpLabelString,    xhelp,
                      	 RXmNautoUnmanage,       false,
                      	 RXmNdialogTitle,        titlestr,
                      	 RXmNresizePolicy,       RXmRESIZE_GROW,
                      	 RXmNnoResize,           false,
                       	 RXmNtransient,          false])
      RXtAddCallback($scale_dialog, RXmNcancelCallback, 
                     Proc.new { |w, context, info| RXtUnmanageChild($scale_dialog)})
      RXtAddCallback($scale_dialog, RXmNhelpCallback, 
                     Proc.new { |w, context, info| snd_print "move the slider to affect the volume"})
      RXmStringFree xhelp
      RXmStringFree xdismiss
      RXmStringFree titlestr
      mainform = RXtCreateManagedWidget("formd", RxmFormWidgetClass, $scale_dialog,
                  	[RXmNleftAttachment,      RXmATTACH_FORM,
                         RXmNrightAttachment,     RXmATTACH_FORM,
                         RXmNtopAttachment,       RXmATTACH_FORM,
                         RXmNbottomAttachment,    RXmATTACH_WIDGET,
                         RXmNbottomWidget,        RXmMessageBoxGetChild($scale_dialog, RXmDIALOG_SEPARATOR)])
      scale = RXtCreateManagedWidget("", RxmScaleWidgetClass, mainform,
                  	[RXmNorientation, RXmHORIZONTAL,
                         RXmNshowValue,   true,
                         RXmNvalue,       100,
                         RXmNmaximum,     500,
                         RXmNdecimalPoints, 2])
      RXtAddCallback(scale, RXmNvalueChangedCallback, 
                     Proc.new { |w, context, info| $current_scaler = Rvalue(info) / 100.0})
      RXtAddCallback(scale, RXmNdragCallback, 
                     Proc.new { |w, context, info| $current_scaler = Rvalue(info) / 100.0})
      RXtManageChild $scale_dialog
    end
end

$Snd_widgets = main_widgets()
create_scale_dialog $Snd_widgets[1]
</pre>
<p>All of Snd is at your disposal once this module is loaded.  As a more interesting example,
the next function installs our own file filtering procedure into the File:Open dialog (it uses
match-sound-files from extensions.scm):
</p>
<pre>
(define (install-searcher proc)
  (define (XmString-&gt;string str)
    (cadr (XmStringGetLtoR str XmFONTLIST_DEFAULT_TAG)))
  (define (XmStringTable-&gt;list st len)
    (XmStringTableUnparse st len #f XmCHARSET_TEXT XmCHARSET_TEXT #f 0 XmOUTPUT_ALL))
  (define (list-&gt;XmStringTable strs)
    (XmStringTableParseStringArray strs (length strs) #f XmCHARSET_TEXT #f 0 #f))
  (XtSetValues (let ((m (open-file-dialog #f)))
                         ; make sure the dialog exists
		  (list-ref (dialog-widgets) 6))
		(list XmNfileSearchProc                             ; set dialog file search procedure
		       (lambda (widget info)
			 (let* ((dir (XmString-&gt;string (dir info))) ; directory string
				(files (match-sound-files proc dir)) ; list of matching files
				(fileTable (list-&gt;XmStringTable      ; XmStringTable for XmNfileListItems
                                             (map (lambda (n)        ; every file needs prepended dir
                                                    (string-append dir n)) 
                                                  files))))
			   (XtSetValues widget                      ; change the list of files
					 (list XmNfileListItems fileTable
					       XmNfileListItemCount (length files)
					       XmNlistUpdated #t)))))))

;(install-searcher (lambda (file) (= (mus-sound-srate file) 44100)))
;(install-searcher (lambda (file) (= (mus-sound-chans file) 4)))
</pre>
<p>Now click the 'Filter' button to see only those files that fit the procedure in
the dialog's files list.  See snd-motif.scm and popup.scm for more examples.
</p>
<br>

<span class=bbox><h3><A NAME="sndwithgtk">Snd and Gtk+</a></h3></span>

<p>
Here's the scale-dialog in xg/gtk:
</p>
<pre>
(define scale-dialog #f)
(define current-scaler 1.0)

(define* (g_signal_connect obj name func #:optional data)
  ;; slightly obsolete example...
  (g_signal_connect_closure_by_id 
   (list 'gpointer (cadr obj))
   (g_signal_lookup name (G_OBJECT_TYPE (GTK_OBJECT obj)))
   0
   (g_cclosure_new func data (list 'GClosureNotify 0))
   #f))

(define (create-scale-dialog parent)
  (if (not scale-dialog)
      (begin
	(set! scale-dialog (gtk_dialog_new))
	(g_signal_connect scale-dialog "delete-event"
			     (lambda (w ev info)
			       (gtk_widget_hide w)))
	(gtk_window_set_title (GTK_WINDOW scale-dialog) "Scale")
	(gtk_widget_realize scale-dialog)
	(let ((dismiss (gtk_button_new_with_label "Dismiss"))
	      (help (gtk_button_new_with_label "Help")))
	  (gtk_box_pack_start (GTK_BOX (.action_area (GTK_DIALOG scale-dialog))) dismiss #t #t 4)
	  (gtk_box_pack_end (GTK_BOX (.action_area (GTK_DIALOG scale-dialog))) help #t #t 4)	
	  (g_signal_connect dismiss "clicked"
			       (lambda (w info)
				 (gtk_widget_hide scale-dialog)))
	  (g_signal_connect help "clicked"
			       (lambda (w info)
				 (help-dialog "Scaler Dialog" "move the slider to affect the volume")))
	  (gtk_widget_show dismiss)
	  (gtk_widget_show help)
	  (let* ((adj (gtk_adjustment_new 0.0 0.0 1.01 0.01 0.01 .01))
		 (scale (gtk_hscale_new (GTK_ADJUSTMENT adj))))
	    (gtk_range_set_update_policy (GTK_RANGE (GTK_SCALE scale)) GTK_UPDATE_CONTINUOUS)
	    (gtk_scale_set_draw_value (GTK_SCALE scale) #t)
	    (gtk_scale_set_digits (GTK_SCALE scale) 2)
	    (g_signal_connect adj "value_changed"
				 (lambda (wadj info)
				   (set! current-scaler (.value (GTK_ADJUSTMENT wadj)))))
	    (gtk_box_pack_start (GTK_BOX (.vbox (GTK_DIALOG scale-dialog))) scale #f #f 6)
	    (gtk_widget_show scale)))))
  (gtk_widget_show scale-dialog))

(create-scale-dialog (cadr (main-widgets)))
</pre>
<p>The only change from the C code was the addition of GTK_ADJUSTMENT in the scale value_changed
callback -- currently the xg module assumes the first argument to the two-argument callback is
a GtkWidget, so we have to cast a GtkAdjustment back to its original type.  Once I figure out
how the "marshaller" works in Gtk, I may be able to fix this.
</p>

<br>

<!-- INDEX sndwithnogui:Scripting -->
<span class=bbox><h3><A NAME="sndwithnogui">Snd with no GUI and scripting</a></h3></span>

<p>If Snd is built without a graphical user interface (either by specifying
--with-no-gui to configure, or by setting the USE_NO_GUI compile-time flag),
it runs Guile's "repl" (read-eval-print loop), or Ruby's equivalent, with input from stdin.  All
the non-interface related functions are available, so you can do things
like:
</p>
<pre>
<em class=listener>snd&gt;</em><em class=typing> (new-sound "new.snd")</em>
<em class=listener>0</em>
<em class=listener>snd&gt;</em><em class=typing> (load "v.scm")</em>
<em class=listener>snd&gt;</em><em class=typing> (fm-violin 0 1 440 .1)</em>
<em class=listener>-1</em>
<em class=listener>snd&gt;</em><em class=typing> (frames 0)</em>
<em class=listener>22050</em>
<em class=listener>snd&gt;</em><em class=typing> (play)</em>
<em class=listener>#t</em>
<em class=listener>snd&gt;</em><em class=typing> (exit)</em>
</pre>
<p>Guile's repl has its own error handlers, different from the
normal Snd handlers; name completion, if it exists at all,
won't complete Snd names; there are undoubtedly other
differences that I haven't noticed.  
</p>
<p>
Since this version of
Snd is the same as the guile program with Snd loaded, you
can treat it as a scripting engine.  For example,
if you have an executable file with:
</p>
<pre>
#!/home/bil/test/snd-6/snd -l
!#
(define a-test 32)
(display "hiho")
(newline)
</pre>
<p>it can be executed just like any such script.
</p>
<pre>
/home/bil/test/snd-6/ script
hiho
:a-test
32
:(exit)
/home/bil/test/snd-6/ 
</pre>
<p>The difference between this use of Snd, and using guile itself
for scripts is that Snd uses the -l switch where guile would use -s.
As noted above, you can use the -e switch to use Snd as a pure
command-line program, and, of course, (exit) to drop back to the shell.
Here's an example script that doubles every sample in "oboe.snd" and
writes the result as "test.snd":
</p>
<pre>
#!/home/bil/test/snd-6/snd -l
!#
(open-sound "oboe.snd")
(scale-by 2.0)
(save-sound-as "test.snd")
(exit)
</pre>
<p>The functions <b>script-args</b> and <b>script-arg</b> can be used
to access the script's arguments, and if necessary (if not exiting)
tell Snd to ignore arguments.  script-args returns a list of strings
giving the arguments.  The first two are always "-l" and the script
file name. The current argument is (script-arg).  If you set this to
a higher value, Snd will subsequently ignore the intevening arguments
as it scans the startup arguments (see snd-test.scm for an example).
</p>
<pre>
#!/home/bil/test/snd-6/snd -l
!#
(if (= (length (script-args)) 2) ;i.e. ("-l" "script")
  (display "usage: script file-name...\n")
  (begin
    (open-sound (list-ref (script-args) (+ (script-arg) 1)))
    (scale-by 2.0)
    (save-sound-as "test.snd")))
(exit)
</pre>
<p>This either grumbles if no argument is given,
or scales its argument sound by 2.0:
</p>
<pre>
script pistol.snd
</pre>
<p>And obviously we can run through the entire argument list,
doubling all the sounds or whatever by using a do loop --
the following example displays all the comments it finds:
</p>
<pre>
#!/home/bil/cl/snd -l
!#
(use-modules (ice-9 format))
(if (= (length (script-args)) 2) ;i.e. ("-l" "script")
  (display "usage: script file-name...\n")
  (do ((arg (+ (script-arg) 1) (1+ arg)))
      ((= arg (length (script-args))))
    (let ((name (list-ref (script-args) arg)))
      (display (format #f "~A: ~A~%" name (mus-sound-comment name))))))
(exit)
</pre>
<p>
Say we save this as the file "comments".</p>
<pre>
/home/bil/cl/comments *.snd
</pre>
<p>If you like, you can use env:</p>
<pre>
#!/usr/bin/env snd
!#
</pre>
<p>But if that works, so will:</p>
<pre>
#!snd -l
!#
</pre>
<p>
This scripting mechanism actually will work in any version of Snd;
to keep the Snd window from popping up, use the -b (-batch) switch in
place of -l.
Here's another script example; it looks for any sounds that are longer
than 40 seconds in duration, and truncates them to 40 seconds:
</p>
<pre>
#!/usr/local/bin/snd -l
!#
(if (= (length (script-args)) 2)
  (display "usage: trunc.scm file-name...\n")
  (do ((arg (+ (script-arg) 1) (1+ arg)))
      ((= arg (length (script-args))))
    (let* ((name (list-ref (script-args) arg)))
      (if (&gt; (mus-sound-duration name) 40.0)
	  (let* ((ind (open-sound name)))
	    (set! (frames ind) (* 40 (srate ind)))
	    (save-sound ind)
	    (close-sound ind))))))
(exit)
</pre>
<p>Here's a sndplay replacement script:</p>
<pre>
#!snd -b
!#
(play-and-wait (list-ref (script-args) (+ (script-arg) 1)))
(exit)
</pre>
<p>And here's a script that splits a multi-channel file
into a bunch of mono files:
</p>
<pre>
#!snd -b
!#
(if (= (length (script-args)) 2)
  (display "usage: split.scm filename\n")
  (let* ((name (list-ref (script-args) (1+ (script-arg))))
	 (chns (mus-sound-chans name)))
    (if (&gt; chns 1)
	(let ((ind (open-sound name)))
	  (do ((i 0 (1+ i)))
	      ((= i chns))
	    (display (format #f "~A.~D " name i))
	    (save-sound-as (format #f "~A.~D" name i)
			   ind
			   (header-type ind)
			   (data-format ind)
			   (srate ind)
			   i))
	  (close-sound ind)))))
(exit)
</pre>
<br>

<span class=bbox><h3><A NAME="sndandruby">Snd with Ruby</a></h3></span>

<p>Ruby is an extension language described as an "object-oriented Perl".
It provides a different syntax from that of Guile/Scheme.  In Ruby, all
the "-" are "_", "-&gt;" is "2", hooks and memo_sound have "$" prepended
(since they are global variables from Ruby's point of view), and all the constants are capitalized
(e.g. Autocorrelation).  The generalized set! functions are replaced
by "set_" plus the base name (e.g. set_window_width), with arguments
reordered in some cases to place the optional values after the new value.  That is,
<code>(set! (sync snd) 1)</code> becomes <code>set_sync(1, snd)</code>.
Hooks in Ruby (which have little or nothing to do with Ruby's "hookable variables")
are just procedures or nil, not lists of procedures as in Guile.
Here's the Ruby version of the init file given
above:
</p>
<pre>
set_window_width 800
set_window_height 500

set_listener_font "9x15"
set_help_text_font "9x15"
set_axis_numbers_font "9x15"

set_show_mix_waveforms true
set_trap_segfault false
set_show_backtrace true
set_show_indices true

set_listener_prompt ":"
show_listener

beige = make_color 0.96, 0.96, 0.86
blue = make_color 0, 0, 1
set_selected_graph_color beige
set_selected_data_color blue
</pre>
<p>Procedures are created via Proc.new, so to set the open-hook to print the
file name,
</p>
<pre>
&gt;<em class=typing>$open_hook = Proc.new { |name| snd_print name }</em>
<em class=listener>#&lt;Proc:0x40221b84&gt;</em>
&gt;<em class=typing>open_sound "oboe.snd"</em>
<em class=listener>/home/bil/cl/oboe.snd
0</em>
</pre>
<p>(The trailing "0" is the result of open_sound).
The Guile hook list support procedures aren't included in Ruby --
simply set the variable to the procedure you want, or false to clear it.
</p>
<p>Vcts and sound-data objects mixin "Comparable" and "Enumerable", and respond to various array-like methods:
</p>
<pre>
&gt;<em class=typing>v1 = make_vct 4</em>
<em class=listener>#&lt;vct[len=4]: 0.000 0.000 0.000 0.000&gt;</em>
&gt;<em class=typing>v1[3] = 1.0</em>
<em class=listener>1.0</em>
&gt;<em class=typing>v1.sort</em>
<em class=listener>0.00.00.01.0</em> # I don't know why it prints this way but ...
&gt;<em class=typing>v1</em>
<em class=listener>#&lt;vct[len=4]: 0.000 0.000 0.000 1.000&gt;</em>
&gt;<em class=typing>v1.max</em>
<em class=listener>1.0</em>
</pre>
<p>I'm thinking about making classes for things like sounds; you could then
have <code>sound + sound</code> to mix, or <code>sound * 2</code> to scale it,
a given channel could be treated as an array, accessed via <code>sound[0, 12345]</code> and so on,
These are extremely easy to add, but I'd like to coordinate this with Guile's
object system.  Keywords, CLM generic functions, and optional arguments work as in Scheme:
</p>
<pre>
&gt;<em class=typing>osc = make_oscil(:frequency, 440)</em>
<em class=listener>oscil freq: 440.000Hz, phase: 0.000</em>
&gt;<em class=typing>oscil osc</em>
<em class=listener>0.0</em>
&gt;<em class=typing>oscil osc</em>
<em class=listener>0.1250506192</em>
&gt;<em class=typing>osc.frequency</em>
<em class=listener>440.0</em>
</pre>
<p>Lists (from the Scheme point of view) are arrays (vectors) in Ruby, and various
built-in Scheme functions such as car aren't predefined, so to set up the focusing
hooks as described in <a href="extsnd.html#mouseentergraphhook">mouse-enter-graph-hook</a>
we need to do something along these lines:
</p>
<pre>
def car(v)
  v[0]
end

$mouse_enter_graph_hook = Proc.new {|snd, chn| 
			            if sound? snd then
			               focus_widget car channel_widgets snd, chn
                                    end 
                                   }

$mouse_enter_listener_hook = Proc.new { |widget| 
                                        focus_widget widget 
                                      }
</pre>
<p>Here's one more example, a translation of display-energy in draw.scm:
</p>
<pre>
def display_energy(snd, chn)
  ls = left_sample
  rs = right_sample
  data1 = make_graph_data(snd, chn)
  data = data1
  if not vct? data
    data = data1[1]
  end
  len = vct_length data
  sr = srate snd
  y_max = y_zoom_slider(snd, chn)
  vct_multiply!(data, data)
  graph(data, "energy", ls / sr, rs / sr, 0.0, y_max * y_max, snd, chn, false)
  end

# $lisp_graph_hook = Proc.new {|snd, chn| display_energy(snd, chn)}
</pre>
<p>
In Ruby you make a symbol by prepending ":", so Guile's
</p>
<pre>
(list 'KeySym (char-&gt;integer #\F))
</pre> 
<p>becomes</p>
<pre>
[:KeySym, ?F]
</pre>

<p>In the listener, everything is line-oriented (that is, I'm not trying to
catch incomplete expressions).  And it appears that in Ruby, variables defined
within a file are considered local to that file(?).
The save state mechanism is incomplete, but the basic stuff works.
Unimplemented (or untested) are:
backtrace upon error, 
env lookup from the env name,
and
many cute methods.  The RubyInline module might serve as a run-macro replacement.
I'm slowly translating snd-test.scm to Ruby: see snd_test.rb.  bird.rb is the
Ruby version of bird.scm. My very informal timing tests indicate that
Guile and Ruby run at the same speed.
Michael Scholz has translated bess.scm to Ruby: bess.rb,
and much of examp.scm: examp.rb.
</p>
<br>

<!-- INDEX sndandladspa:Plugins -->
<span class=bbox><h3><A NAME="sndandladspa">Snd and LADSPA</a></h3></span>

<pre>
  <em class=def><a name="initladspa">init-ladspa</a></em>
  <em class=def><a name="listladspa">list-ladspa</a></em>
  <em class=def><a name="analyseladspa">analyse-ladspa</a></em> library type
  <em class=def><a name="applyladspa">apply-ladspa</a></em> reader data duration origin
</pre>

<p>Richard Furse has provided a module to support LADSPA plugins in Snd.
Here is documentation from Richard Furse:</p>
<pre>
Supporting functions are:

	(init-ladspa)

	Performs a search of LADSPA_PATH for plugins, doesn't need to be called 
as LADSPA automatically initialises on first use however can be used to 
reinitialise if new plugins have arrived.

	(list-ladspa)

	Returns a list of lists where each inner list contains a string to 
identify the plugin library and a string to identify the plugin type within 
the library.

	(analyse-ladspa plugin-library plugin-type)

	Returns a list of assorted data about a particular plugin including a 
list of port descriptions. plugin-library and plugin-type are as provided 
by list-ladspa.

The main function is:

	(apply-ladspa reader (plugin-library plugin-type [param1 [param2 ...]]) samples origin)

	Applies a LADSPA plugin to a block of samples. 
An example call to apply the low-pass-filter in the CMT plugin library is 
(apply-ladspa (make-sample-reader 0) (list "cmt" "lpf" 1000) 10000 "origin").
</pre>
<p>Dave Phillips in <a href="http://www.oreillynet.com/pub/a/linux/2001/02/02/ladspa.html">Linux Audio Plug-Ins: A Look Into LADSPA</a> adds this
example:
</p>
<pre>
  (apply-ladspa (make-sample-reader 57264) (list "cmt" "delay_5s" .3 .5) 32556 "ibm.wav")
</pre>
<p>
"This sequence tells Snd to read a block of 32556 samples from the ibm.wav file, starting at sample number 57264,
 and apply the delay_5s LADSPA plug-in (Richard Furse's delay plug-in, also found in cmt.so) with a delay time of
.3 seconds and a 50/50 dry/wet balance."
</p>
<p>To help Snd find the plugin library, set either the Snd variable <a href="extsnd.html#ladspadir">ladspa-dir</a> or the environment variable LADSPA_PATH
to the directory.
If, for example,
cmt.so is in /usr/local/lib/ladspa, (and you're using tcsh), then
</p>
<pre>
  setenv LADSPA_PATH /usr/local/lib/ladspa
</pre>
<p>or</p>
<pre>
  (set! (ladspa-dir) "/usr/local/lib/ladspa")
</pre>
<p>Snd plugins may have any number of inputs and outputs; if more
than one input is required, the first argument to apply-ladspa should be a list of readers:
</p>
<pre>
  (apply-ladspa (list (make-sample-reader 0 0 0)  ;chan 0
                      (make-sample-reader 0 0 1)) ;chan 1
                (list "cmt" "freeverb3" 0 .5 .5 .5 .5 .5) 
                100000 "freeverb")
</pre>
<p><a name="ladspachannel"></a>The "regularized" version of apply-ladspa could be defined:
</p>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define* (ladspa-channel ladspa-data #:optional nbeg ndur nsnd nchn nedpos)
  (let* ((beg (or nbeg 0)) 
	 (snd (or nsnd (selected-sound) (car (sounds))))
	 (chn (or nchn (selected-channel)))
	 (dur (or ndur (- (frames snd chn) beg)))
	 (edpos (or nedpos current-edit-position))
	 (reader (make-sample-reader beg snd chn 1 edpos)))
    (<em class=red>apply-ladspa</em> reader ladspa-data dur "apply-ladspa")
    (free-sample-reader reader)))
</pre></td></tr></table>
<br>

<span class=bbox><h3><A NAME="sndandx">Driving Snd remotely</a></h3></span>

<p>It is possible to send Snd arbitrary Scheme or Ruby code from any other program;
the program sndctrl.c is a simple example.  Snd has two X window properties:
"SND_VERSION" and "SND_COMMAND"; the former is the Snd version (a date),
and the latter is the communication path for other programs.  Any time
such a program changes the SND_COMMAND property, Snd notices and evaluates
the new value (as a string, as if typed in the Snd listener).  To get
a response from Snd, use the function change-window-property(consat,name,command) where
consat is the property name Snd should search for, name is the property to change, and command is the string
that replaces the current property value.  CLM's communication
with Snd function sends Snd this string:</p>
<pre>
"(change-window-property \"CLM_VERSION\" \"CLM_COMMAND\" " str ")"
</pre>
<p>where <i>str</i> is the form to be evaluated within Snd.  It then waits
for a change to the CLM_COMMAND property, returning its value to the
user. The send-snd function itself, similarly, looks for SND_VERSION and
sets SND_COMMAND to <i>str</i>, which Snd subsequently notices.
</p>
<br>

<span class=bbox><h3><A NAME="sndandgl">Snd and OpenGL</a></h3></span>

<p>Snd can be used in conjunction with OpenGL.  If it is compiled with
the switch -DHAVE_GL, and loaded with -lGLU -lGL (normally this can be
handled via the configure switch --with-gl), the top level Snd shell
is setup to handle OpenGL graphics; the GLXContext is (snd-glx-context).
The GL-to-Scheme bindings are in gl.c, and follow the same name and type
conventions of the Motif bindings in xm.c.
Any of the Snd drawing area widgets (or your own) can receive GL graphics
commands.  Here is a translation of the SGI/xjournal glxmotif
program:
</p>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (draw-it)
  (glXMakeCurrent (XtDisplay (cadr (main-widgets))) 
		  (XtWindow (car (channel-widgets)))
		  (snd-glx-context))
  (glEnable GL_DEPTH_TEST)
  (glDepthFunc GL_LEQUAL)
  (glClearDepth 1.0)
  (glClearColor 0.0 0.0 0.0 0.0)
  (glLoadIdentity)
  (gluPerspective 40.0 1.0 10.0 200.0)
  (glTranslatef 0.0 0.0 -50.0)
  (glRotatef -58.0 0.0 1.0 0.0)
  (let ((vals (XtVaGetValues (car (channel-widgets)) (list XmNwidth 0 XmNheight 0))))
    (glViewport 0 0 (list-ref vals 1) (list-ref vals 3)))
  (glClear (logior GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))
  (glBegin GL_POLYGON)
  (glColor3f 0.0 0.0 0.0)   (glVertex3f -10.0 -10.0 0.0)
  (glColor3f 0.7 0.7 0.7)   (glVertex3f 10.0 -10.0 0.0)
  (glColor3f 1.0 1.0 1.0)   (glVertex3f -10.0 10.0 0.0)
  (glEnd)
  (glBegin GL_POLYGON)
  (glColor3f 1.0 1.0 0.0)   (glVertex3f 0.0 -10.0 -10.0)
  (glColor3f 0.0 1.0 0.7)   (glVertex3f 0.0 -10.0 10.0)
  (glColor3f 0.0 0.0 1.0)   (glVertex3f 0.0 5.0 -10.0)
  (glEnd)
  (glBegin GL_POLYGON)
  (glColor3f 1.0 1.0 0.0)   (glVertex3f -10.0 6.0 4.0)
  (glColor3f 1.0 0.0 1.0)   (glVertex3f -10.0 3.0 4.0)
  (glColor3f 0.0 0.0 1.0)   (glVertex3f 4.0 -9.0 -10.0)
  (glColor3f 1.0 0.0 1.0)   (glVertex3f 4.0 -6.0 -10.0)
  (glEnd)
  (glXSwapBuffers (XtDisplay (cadr (main-widgets))) 
		  (XtWindow (car (channel-widgets))))
  (glFlush))
</pre></td></tr></table>
<br>
<p>For more examples, see snd-gl.scm.
</p>
<br>
<table border>
<tr><td colspan=2><center>GL spectrogram</center></td></tr>
<tr><td colspan=2>
<img src="gl1.png" alt="now.snd GL spectrogram">
</td></tr></table>
<br>

<span class=bbox><h3><A NAME="sndandgdb">Snd and gdb</a></h3></span>

<p>Here are some gdb functions (for your ~/.gbdinit file) that might
come in handy:
</p>
<pre>
define gp
set gdb_print($arg0)
print gdb_output
end
document gp
Executes (object-&gt;string arg): gp memo_sound =&gt; #f
end

define ge
call gdb_read($arg0)
call gdb_eval(gdb_result)
set gdb_print(gdb_result)
print gdb_output
end
document ge
Executes (print (eval (read arg))): ge "(+ 1 2)" =&gt; 3
end

define gh
call g_help(scm_str2symbol($arg0), 20)
set gdb_print($1)
print gdb_output
end
document gh
Prints help string for arg: gh "enved-target"
end
</pre>
<p>SCM values are displayed as integers in gdb, so say
Snd halts and you notice it's loading some unknown file:
</p>
<pre>
#32 0x081ae8f4 in scm_primitive_load (filename=1112137128) at load.c:129
</pre>
<p>You can get the file name with gp:
</p>
<pre>
(gdb) gp 1112137128
$1 = 0
$2 = 0x40853fac "\"/home/bil/test/share/guile/1.5.0/ice-9/session.scm\""
</pre>
<p>
If you have a pointer to a CLM generator, you can use:
</p>
<pre>
p mus_describe(arg)  --  show the outsider's view of arg
p mus_inspect(arg)  --  show every internal field of arg
</pre>
<p>The ge function can show current Snd state:</p>
<pre>
(gdb) ge "(eps-file)"
$5 = 0
$6 = 0
$7 = 0
$8 = 0x8296cf0 "\"snd.eps\""
</pre>

<br>

<center>
<span class=htmlbox>related documentation</span><span class=htmlbox><a href="snd.html">snd.html</a><spacer type=horizontal size=25> <a href="extsnd.html">extsnd.html</a><spacer type=horizontal size=25> <a href="clm.html">clm.html</a><spacer type=horizontal size=25> <a href="sndlib.html">sndlib.html</a><spacer type=horizontal size=25> <a href="sndscm.html">sndscm.html</a><spacer type=horizontal size=25> <a href="libxm.html">libxm.html</a><spacer type=horizontal size=25> <a href="index.html">index.html</a></span>
</center>
</body></html>
