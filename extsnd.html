<html>
<head>
<title>Snd Customization and Extension</title>
<style type="text/css">
<!-- 
	EM.red {color:red; font-style: normal}
        EM.error {color:chocolate; font-style: normal}
        EM.narg {color:chocolate; font-style: normal}
        EM.targ {color:darkgreen; font-style: normal}
        EM.typing {color:maroon; font-style: normal}
        EM.listener {color:darkblue; font-style: normal}
	EM.def {font-weight: bold; font-style: normal}
	H1 {text-align: center}
	UL {list-style-type: none}
	SPAN.box {background: beige; width: 100%; font-style: normal; text-align: center; border-width: thin; border-style: ridge}
	SPAN.bbox {background: lightsteelblue; width: 100%; font-style: normal; border-width: thin; border-style: ridge}
	SPAN.cbox {background: lightgreen; width: 100%; font-style: normal; border-width: thin; border-style: ridge}
	SPAN.htmlbox {background: tan; font-style: normal; font-size: small; border-width: thin; border-style: ridge}
	SPAN.defbox {border-width: thin; border-color: lightsteelblue}
-->
</style>
</head>

<body bgcolor=white>

<!-- I'm using A NAME (i.e caps) where the entity should be ignored by the indexer (index.cl) -->

<A NAME="extsndcontents"></a>
<table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h1>Snd Customization and Extension</h1></td></tr></table>
<br>
<center>
<table border=1><tr><td>
<table bgcolor="aliceblue" border=0 cellspacing=8><tr><td><small>related documentation:</small></td><td><small><a href="snd.html">snd.html</a></small></td><td><small><a href="grfsnd.html">grfsnd.html</a></small></td><td><small><a href="clm.html">clm.html</a></small></td><td><small><a href="sndlib.html">sndlib.html</a></small></td><td><small><a href="sndscm.html">sndscm.html</a></small></td><td><small><a href="libxm.html">libxm.html</a></small></td><td><small><a href="index.html">index.html</a></small></td></tr></table>
</td></tr></table>
</center>

<ul>
<li><a href="#lisplistener">Introduction</a>
<li><a href="#etc">Snd Programming</a>
  <ul>
  <li><a href="#behavior">Customizing Snd's behavior</a>
    <ul>
    <li><a href="#sndglobalvars">Global variables</a>
    <li><a href="#sndhooks">Hooks</a>
    </ul>
  <li><a href="#sndobjects">Snd's objects</a>
    <ul>
    <li><a href="#Vcts">Vcts</a>
    <li><a href="#sndsounddata">Sound-data and Sndlib</a>
    <li><a href="#samplereaders">Sample-readers</a>
    <li><a href="#sndmarks">Marks</a>
    <li><a href="#sndmixes">Mixes</a>
    <li><a href="#sndregions">Regions and Selections</a>
    <li><a href="#sndsounds">Sounds and channels</a>
      <ul><li><a href="#customcontrols">the control panel</a></ul>
    <li><a href="#editlists">Edit Lists</a>
    <li><a href="#sndtransforms">Transforms</a>
    <li><a href="#snddialogs">Dialogs and Menus</a>
    <li><a href="#sndmisc">Miscellaneous functions</a>
    <li><a href="#sndconstants">Constants</a>
    <li><a href="#snderrors">Errors and Debugging</a>
    </ul>
  <li><a href="#appearance">Customizing Snd's appearance</a>
    <ul>
    <li><a href="#colors">Colors</a>
    <li><a href="#fonts">Fonts</a>
    <li><a href="#sndgraphics">Graphics</a>
    <li><a href="#sndwidgets">Widgets</a>
    </ul>
  <li><a href="grfsnd.html#grfsndcontents">Customization Part 2</a>
  </ul>
<li><a href="index.html">Index</a>
</ul>
<br>
<table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2>Introduction</h2></td></tr></table>
<A NAME="lisplistener"></a>

<p>Snd is a highly customizable, extensible program.
The syntax used throughout this documentation is Scheme (a form of lisp) as implemented by the Gnu Guile library.
You can also use Ruby, but need to make the obvious <a href="grfsnd.html#sndandruby">changes</a>.
I've tried to bring out to lisp nearly every portion
of Snd, both the signal-processing functions, and
much of the user interface.  You can, for example,
add your own menu choices, editing operations, 
or graphing alternatives.
Nearly everything in Snd can be set in an initialization
file, loaded at any time from a file of scheme code or a <a href="snd.html#savedstate">saved state</a> file,
specified via inter-process communication or from stdin
from any other program (CLM and Emacs in particular),
imbedded in a keyboard macro, or accessed in the
lisp listener.  The easiest way to get acquainted
with this aspect of Snd is to open the listener
(via the View:Open listener menu option), and type
experiments in its window.  Its prompt is "&gt;". So,
say we've opened the listener (my typing is 
in <em class=typing>this font</em> and Snd's responses
are in <em class=listener>this font</em>):
</p>
<pre>
&gt;<em class=typing>(+ 1 2)</em>
<em class=listener>3</em>
</pre>
<p><small>If the listener is active, and some sound
is selected, any characters typed while in the sound
graph which it can't handle are passed to the
listener; to exit the listener without using the
mouse, type C-g.  This is also the way to get back to
the listener prompt if it appears to be hung; normally
in this situation,
it's actually waiting for a close paren; if you put the
cursor just past the close paren you're interested in
and type return,
Snd will flash the unbalanced open paren (if any) briefly.
In any case, whenever the cursor is just past a close paren,
the matching open paren is underlined.
</small></p>
<br>
<table width="100%" border=1><tr><td bgcolor="beige" align="center" valign="middle"><h2><A NAME="etc">Snd Programming</a></h2></td></tr></table>

<p>Snd is organized as a list of sounds, each with a list of channels,
each channel containing lists of edits, marks, mixes, etc.
There are other objects such as colors, vcts (an optimization
of vectors), and regions; the currently active region is
called the selection.  I originally presented all the
functions and variables in an enormous alphabetical
list, but that finally became unmanageable.  In the following
sections, each of the basic entities is treated in a separate
section with cross-references where needed.  The <a href="index.html">index</a>
provides alphabetical entry.</p>

<p>There are many examples in <a href="sndscm.html#exampdoc">examp.scm</a>, examp.rb, and <a href="sndscm.html#sndtestdoc">snd-test.scm</a>. 
Extensions to Snd can be found in:
</p>

<table border=8 bordercolor="lightsteelblue">
<tr><td width=140><a href="sndscm.html#autosavedoc">autosave.scm</a></td><td>auto-save (edit backup) support</td></tr>
<tr><td><a href="sndscm.html#bessdoc">bess.scm, bess.rb</a></td>     <td>FM demo (from bess.cl in CLM)</td></tr>
<tr><td><a href="sndscm.html#bess1doc">bess1.scm, bess1.rb</a></td>  <td>FM violin demo (from bess5.cl in CLM)</td></tr>
<tr><td><a href="sndscm.html#birddoc">bird.scm, bird.rb</a></td>     <td>various North-American birds (from bird.clm)</td></tr>
<tr><td><a href="sndscm.html#clminsdoc">clm-ins.scm</a></td>         <td>various CLM instruments translated to Snd</td></tr>
<tr><td><a href="sndscm.html#debugdoc">debug.scm</a></td>            <td>debugging aids</td></tr>
<tr><td><a href="sndscm.html#dlocsigdoc">dlocsig.rb</a></td>         <td>CLM's dlocsig in Ruby (Michael Scholz)</td></tr>
<tr><td><a href="sndscm.html#dlpdoc">dlp directory entries</a></td>  <td>various contributions from Dave Phillips</td></tr>
<tr><td><a href="sndscm.html#drawdoc">draw.scm</a></td>              <td>graphics additions</td></tr>
<tr><td><a href="sndscm.html#dspdoc">dsp.scm</a></td>                <td>various DSP-related procedures</td></tr>
<tr><td><a href="sndscm.html#editmenudoc">edit-menu.scm</a></td>     <td>Edit menu additions</td></tr>
<tr><td><a href="sndscm.html#effectsdoc">new-effects.scm, gtk-effects.scm, effects.rb</a></td><td>an Effects menu</td></tr>
<tr><td><a href="sndscm.html#envdoc">env.scm</a></td>                <td>various envelope functions from CLM</td></tr>
<tr><td><a href="sndscm.html#enveddoc">enved.scm</a></td>            <td>envelope editor in lisp graph section</td></tr>
<tr><td><a href="sndscm.html#eventdoc">event.scm</a></td>            <td>xm module stuff for automatic user-interface tests</td></tr>
<tr><td><a href="sndscm.html#extensionsdoc">extensions.scm</a></td>  <td>extensions of Snd</td></tr>
<tr><td><a href="sndscm.html#fadedoc">fade.scm</a></td>              <td>frequency-domain cross-fades</td></tr>
<tr><td><a href="sndscm.html#fmvdoc">fmv.scm</a></td>                <td>the fm-violin tied to real-time stuff</td></tr>
<tr><td><a href="sndscm.html#freeverbdoc">freverb.scm, freeverb.rb</a></td><td>a reverb</td></tr>
<tr><td><a href="sndscm.html#goopsnddoc">goopsnd.scm</a></td>        <td>first look at Goops (Guile Object System) for Snd</td></tr>
<tr><td><a href="sndscm.html#hooksdoc">hooks.scm</a></td>            <td>functions related to hooks</td></tr>
<tr><td><a href="sndscm.html#indexdoc">index.scm, index.rb</a></td>  <td>snd-help locators</td></tr>
<tr><td><a href="sndscm.html#jcrevdoc">jcrev.scm</a></td>            <td>John Chowning's reverb</td></tr>
<tr><td><a href="sndscm.html#ladspadoc">ladspa.scm</a></td>          <td>Kjetil S. Matheussen's LADSPA GUI-builder and previewer.</td></tr>
<tr><td><a href="sndscm.html#maracadoc">maraca.scm</a></td>          <td>Perry Cook's maraca physical model</td></tr>
<tr><td><a href="sndscm.html#marksdoc">marks.scm</a></td>            <td>functions related to marks</td></tr>
<tr><td><a href="sndscm.html#maxfdoc">maxf.scm, maxf.rb</a></td>     <td>Max Mathews resonator</td></tr>
<tr><td><a href="sndscm.html#mixdoc">mix.scm</a></td>                <td>functions related to mixes and tracks</td></tr>
<tr><td><a href="sndscm.html#moogdoc">moog.scm</a></td>              <td>Moog filter (from CLM)</td></tr>
<tr><td><a href="sndscm.html#musglyphs">musglyphs.scm</a></td>       <td>Music notation symbols (from CMN)</td></tr>
<tr><td><a href="sndscm.html#nbdoc">nb.scm, nb.rb</a></td>           <td>Popup File info etc</td></tr>
<tr><td><a href="sndscm.html#noisedoc">noise.scm, noise.rb</a></td>  <td>CLM's noise.ins</td></tr>
<tr><td><a href="sndscm.html#peakenvdoc">peak-env.scm</a></td>       <td>peak envelope support</td></tr>
<tr><td><a href="sndscm.html#pianodoc">piano.scm, piano.rb</a></td>  <td>piano physical model</td></tr>
<tr><td><a href="sndscm.html#playdoc">play.scm</a></td>              <td>play-related functions</td></tr>
<tr><td><a href="sndscm.html#popupdoc">popup.scm, gtk-popup.scm, popup.rb</a></td><td>Popup menu specializations</td></tr>
<tr><td><a href="sndscm.html#prc95doc">prc95.scm</a></td>            <td>Perry Cook's physical model examples (from CLM)</td></tr>
<tr><td><a href="sndscm.html#pvocdoc">pvoc.scm</a></td>              <td>phase-vocoder examples</td></tr>
<tr><td><a href="sndscm.html#rgbdoc">rgb.scm, rgb.rb</a></td>        <td>color definitions</td></tr>
<tr><td><a href="sndscm.html#rtiodoc">rtio.scm</a></td>              <td>real-time stuff</td></tr>
<tr><td><a href="sndscm.html#rubberdoc">rubber.scm, rubber.rb</a></td><td>rubber-sound</td></tr>
<tr><td><a href="sndscm.html#singerdoc">singer.scm</a></td>          <td>Perry Cook's vocal-tract physical model</td></tr>
<tr><td><a href="sndscm.html#sndmotifdoc">snd-motif.scm, snd-gtk.scm</a></td><td>Motif/Gtk modules (xm.c, xg.c)</td></tr>
<tr><td><a href="sndscm.html#sndgldoc">snd-gl.scm</a></td>           <td>OpenGL examples (gl.c)</td></tr>
<tr><td><a href="sndscm.html#snd4doc">snd4.scm</a></td>              <td>backwards compatibility for version 4</td></tr>
<tr><td><a href="sndscm.html#snd5doc">snd5.scm</a></td>              <td>backwards compatibility for version 5</td></tr>
<tr><td><a href="sndscm.html#snd6doc">snd6.scm</a></td>              <td>backwards compatibility for version 6</td></tr>
<tr><td><a href="sndscm.html#straddoc">strad.scm, strad.rb</a></td>  <td>string physical model (from CLM)</td></tr>
<tr><td><a href="sndscm.html#vdoc">v.scm, v.rb</a></td>              <td>fm-violin (from CLM)</td></tr>
<tr><td><a href="sndscm.html#wsdoc">ws.scm, ws.rb</a></td>           <td>with-sound implementation</td></tr>
<tr><td><a href="sndscm.html#xmenveddoc">xm-enved.scm, xm-enved.rb</a></td><td>xm-based envelope editor</td></tr>
<tr><td><a href="sndscm.html#zipdoc">zip.scm</a></td>                <td>the zipper (a cross-fader, sort of) (from CLM)</td></tr>
</table>

<br>
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="behavior">Customizing Snd's behavior</a></h3></td></tr></table>

<p>Most of Snd's behavior can be customized.  For example,
when a sound is saved, some people want to be warned if
a pre-existing sound is about to be destroyed; others (Snd's
author included) grumble "just do it".  There are two ways
this kind of situation is handled in Snd; variables and hooks.
A hook is a list of callbacks invoked whenever the associated
event happens.  When Snd exits, for example, any functions found
on the <a href="#exithook">exit-hook</a> list are evaluated; if any of them returns #t,
Snd does not exit.</p>

<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define <A NAME="unsavededitsp">unsaved-edits?</A>
  (lambda (lst)
    (if (not (null? lst))
	(if (&gt; (car (edits (car lst))) 0)
	    (begin
	      (report-in-minibuffer "there are unsaved edits")
	      #t)
	    (unsaved-edits? (cdr lst)))
	#f)))

(add-hook! <em class=red>exit-hook</em> (lambda () (unsaved-edits? (sounds))))
</pre></td></tr></table>

<p>Now when Snd is told to exit, it checks exit-hook, runs
unsaved-edits?, and if the latter returns #t, if prints
a worried message in the minibuffer, and refuses to
exit.  Similar hooks customize actions such as closing
a sound (<a href="#closehook">close-hook</a>), clicking a mark (<a href="#markclickhook">mark-click-hook</a>),
pressing a key (<a href="#keypresshook">key-press-hook</a>), and so on.</p>

<p>The global variables handle various customizations that aren't callback-oriented.
For example, 
<A NAME="autoexpl"></a>as panes (sounds) come and go, Snd's overall size may change (this is
partly determined by the window manager, but is also
up to Snd); many people find this distracting -- they would rather that the
overall window stick to one size.  The Snd variable associated
with this is "auto-resize"; it can be accessed as follows (we're typing
to the listener here, as described above):</p>

<pre>
&gt;<em class=typing>(auto-resize)</em>
<em class=listener>#t</em>
&gt;<em class=typing>(set! (auto-resize) #f)</em>
<em class=listener>#f</em>
</pre>

<p>As this illustrates, 
variables in Snd are accessed as though each were a function, and set using set!.  auto-resize's current
value is accessed via <code>(auto-resize)</code>, and set to a
new value via <code>(set! (auto-resize) #f)</code>. #t is Scheme for true
(often 1 in C, t in Lisp, true in Ruby), #f is false (0 in C, nil in Lisp, false in Ruby).
The statement <code>(set! (auto-resize) #f)</code> can be placed in your ~/.snd initialization file
to make it the default setting for your version of Snd, or placed
in a separate file of Scheme code and loaded at any time via the load
function. </p>

<br>
<table width="100%" border=1><tr><td bgcolor="lightgreen" valign="middle"><h4><A NAME="sndglobalvars">Global variables</a></h4></td></tr></table>

<p>The variables affecting Snd's overall behavior are:</p>

<!-- -------------------------------- GLOBAL VARIABLE TABLE -------------------------------- -->

<table border=0 cellspacing=4>

<!-- ask-before-overwrite -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="askbeforeoverwrite">ask-before-overwrite</a></em></code></span></td>
<td width><code>#f</code></td></tr>
<tr><td></td><td colspan=2>should Snd ask before <a href="snd.html#overwrite">overwriting</a> an existing file.</td></tr>
<tr><td colspan=3></td></tr>

<!-- audio-input-device -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="audioinputdevice">audio-input-device</a></em></code></span></td>
<td><code>mus-audio-default</code></td></tr>
<tr><td></td><td colspan=2>Audio input device (for the recorder).
</td></tr>
<tr><td colspan=3></td></tr>

<!-- audio-output-device -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="audiooutputdevice">audio-output-device</a></em></code></span></td>
<td><code>mus_audio-default</code></td></tr>
<tr><td></td><td colspan=2>Audio output device (for the play button).
</td></tr>
<tr><td colspan=3></td></tr>

<!-- auto-resize -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="autoresize">auto-resize</a></em></code></span></td>
<td><code>#t</code></td></tr>
<tr><td></td><td colspan=2>should Snd window resize upon open/close (see <a href="grfsnd.html#xautoresize">AutoResize</a> and <a href="#autoexpl">blathering</a> above).
</td></tr>
<tr><td colspan=3></td></tr>

<!-- auto-update -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="autoupdate">auto-update</a></em></code></span></td>
<td><code>#f</code></td></tr>
<tr><td></td><td colspan=2>should Snd <a href="snd.html#updatefile">update</a> a file automatically if it changes on disk due to some other process.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- auto-update-interval -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="corruptiontime">auto-update-interval</a></em></code></span></td>
<td><code>60</code></td></tr>
<tr><td></td><td colspan=2>Time (seconds) between background checks for changed file on 
disk (see <a href="#autoupdate">auto-update</a>). If less than 0.0, the auto-update background process 
is turned off.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- dac-combines-channels -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="dacfolding">dac-combines-channels</a></em></code></span></td>
<td><code>#t</code></td></tr>
<tr><td></td><td colspan=2>are channels mixed into available channels upon dac output.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- dac-size -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="dacsize">dac-size</a></em></code></span></td>
<td><code>256</code></td></tr>
<tr><td></td><td colspan=2>Audio output buffer size (not always meaningful).  See <i>play-with-envs</i> in enved.scm or
<i>play-sound</i> in play.scm.  When the various control panel controls are changed, the snappiness of the
response is set, to some extent, by the dac-size.  The default of 256 gives a stair-case effect in many
cases, whereas 2048 is smoother.  This also affects the resampling smoothness of playback while dragging the
mark play triangle.  (Some audio choices, ALSA in particular, may ignore dac-size).
</td></tr>
<tr><td colspan=3></td></tr>

<!-- data-clipped -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="dataclipped">data-clipped</a></em></code></span></td>
<td><code>#f</code></td></tr>
<tr><td></td><td colspan=2>If #t, output values are clipped to fit the current sndlib sample
representation's notion of -1.0 to just less than 1.0.  The default
causes wrap-around which makes the out-of-range values very obvious.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- default-output-chans -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="defaultoutputchans">default-output-chans</a></em></code></span></td>
<td><code>1</code></td></tr>
<tr><td></td><td colspan=2>The default number of channels when a new or temporary file is created, 
or a save dialog is opened.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- default-output-format -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="defaultoutputformat">default-output-format</a></em></code></span></td>
<td><code>mus-bshort</code></td></tr>
<tr><td></td><td colspan=2>The default data format when a new or temporary file is created, 
or a save dialog is opened. (mus-bshort is from sndlib, standing for 16-bit big-endian data).  Use mus-out-format for fastest IO.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- default-output-srate -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="defaultoutputsrate">default-output-srate</a></em></code></span></td>
<td><code>22050</code></td></tr>
<tr><td></td><td colspan=2>The default srate when a new or temporary file is created, 
or a save dialog is opened.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- default-output-type -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="defaultoutputtype">default-output-type</a></em></code></span></td>
<td><code>mus-next</code></td></tr>
<tr><td></td><td colspan=2>The default header type when a new file is created, 
or a save dialog is opened. (mus-next is from sndlib, standing for the NeXT/Sun sound file header).
</td></tr>
<tr><td colspan=3></td></tr>

<!-- emacs-style-save-as -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="emacssytlesaveas">emacs-style-save-as</a></em></code></span></td>
<td><code>#f</code></td></tr>
<tr><td></td><td colspan=2>After File:Save-as dialog option, should Snd remain with the current file (#f) or go to the new file (#t).
</td></tr>
<tr><td colspan=3></td></tr>

<!-- eps-bottom-margin -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="epsbottommargin">eps-bottom-margin</a></em></code></span></td>
<td><code>0.0</code></td></tr>
<tr><td></td><td colspan=2>bottom margin used in snd.eps, created by the Print command.
PostScript units are 1/72 of an inch (a "point" in printer jargon); 
an inch is 2.54 cm:
</td></tr>

<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (inches-to-ps inches) 
  (* inches 72))

(define (cm-to-ps cm) 
  (* cm (/ 72.0 2.54)))
</pre></td></tr></table></td></tr>

<tr><td></td><td colspan=2>
In the resulting .eps file, you'll find a concat statement near the 
top of the file; the first and fourth numbers are scale factors on 
the entire graph, the fifth is the left margin, and the sixth is the 
bottom margin.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- eps-file -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="epsfile">eps-file</a></em></code></span></td>
<td><code>"snd.eps"</code></td></tr>
<tr><td></td><td colspan=2>Name of the Postscript file produced by the <a href="snd.html#printfile">File Print</a> option.
See also the <a href="grfsnd.html#epsresource">epsFile</a> resource.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- eps-left-margin -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="epsleftmargin">eps-left-margin</a></em></code></span></td>
<td><code>0.0</code></td></tr>
<tr><td></td><td colspan=2>left margin used in snd.eps, created by the Print command.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- eps-size -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="epssize">eps-size</a></em></code></span></td>
<td><code>1.0</code></td></tr>
<tr><td></td><td colspan=2>scaler used in snd.eps (Print command) for overall picture size.  
</td></tr>
<tr><td colspan=3></td></tr>

<!-- filter-env-in-hz -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="filterenvinhz">filter-env-in-hz</a></em></code></span></td>
<td><code>#f</code></td></tr>
<tr><td></td><td colspan=2>If #t, filter env (sound control panel) x axis is in Hz, otherwise 0 to 1.0 (where 1.0 corresponds to srate/2).
</td></tr>
<tr><td colspan=3></td></tr>

<!-- graph-cursor -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="graphcursor">graph-cursor</a></em></code></span></td>
<td><code>XC_crosshair (34)</code></td></tr>
<tr><td></td><td colspan=2>The kind of cursor displayed following the mouse in the data graph.
The X cursors are declared in /usr/X11R6/include/X11/cursorfont.h or some such file.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- ladspa-dir -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="ladspadir">ladspa-dir</a></em></code></span></td>
<td><code>#f</code></td></tr>
<tr><td></td><td colspan=2>Name of directory for LADSPA plugin libraries (can override or replace LADSPA_PATH).
See <a href="grfsnd.html#sndandladspa">Snd and LADSPA</a>.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- max-regions -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="maxregions">max-regions</a></em></code></span></td>
<td><code>16</code></td></tr>
<tr><td></td><td colspan=2>Maximum size of the region list; the number of regions that are accessible.</td></tr>
<tr><td colspan=3></td></tr>

<!-- minibuffer-history-length -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="minibufferhistorylength">minibuffer-history-length</a></em></code></span></td>
<td><code>8</code></td></tr>
<tr><td></td><td colspan=2>Maximum length of minibuffer and listener M-p/M-n history lists.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- optimization -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="optimization">optimization</a></em></code></span></td>
<td><code>0</code></td></tr>
<tr><td></td><td colspan=2>If non-zero, try to optimize simple lambda forms passed to the searches and so forth.
This depends partly on the optargs module (not available in the correct form before Guile 1.5),
only applies to Guile (not Ruby), and is highly experimental.
The actual values of the optimization switch are:
</td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5>
<tr><td width=50>0:  </td><td> no use of parse trees at all (use the standard Guile parser/evaluator)</td></tr>
<tr><td>1:  </td><td> allow simple ops (if complex result possible, give up)</td></tr>
<tr><td>2:  </td><td>assume nothing will return a complex number</td></tr>
<tr><td>3:  </td><td>if undefined global variable encountered, try to determine eventual type from context</td></tr>
<tr><td>4:  </td><td>make dangerous assumptions about variable types</td></tr>
<tr><td>5:  </td><td>make dangerous assumptions about variable locations (for set!)</td></tr>
<tr><td>6:  </td><td>try to splice in user-defined functions (buggy!)</td></tr>
</table><br></td></tr>
<tr><td></td><td colspan=2><small>Currently, the optimizer is able to speed up Scheme code by factors between
8 and 20; see snd-run.c for what is implemented, what the major limitations are, and so on.
If you set the optimization-hook to print out whatever it's argument is, you can
find out what the optimizer found confusing.  
One dangerous assumption involved in local variables (optimization = 5) is that
such a variable might be a continuation set within the run-optimized code, but then
called from outside that block.  This (obviously!) won't work, but it's too much trouble to
try to trap it in the context of run.
Here are some representative results;
the first number is the unoptimized time, the second is the optimized time, the third is
the speed-up ratio:<br><br></td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5>
<tr><td>singer</td><td>1225</td><td>55</td><td>22</td>
<td bgcolor="black"><br></td><td>abs sin</td><td>447</td><td>36</td><td>12</td>
<td bgcolor="black"><br></td><td>jcrev  </td><td>505</td><td>44</td><td>11</td></tr>
<tr><td>vct-ref</td><td>413</td><td>31</td><td>13</td>
<td bgcolor="black"><br></td><td>-1     </td><td>269</td><td>21</td><td>13</td>
<td bgcolor="black"><br></td><td>expsnd </td><td>158</td><td>16</td><td>10</td></tr>
<tr><td>let if </td><td>372</td><td>36</td><td>10</td>
<td bgcolor="black"><br></td><td>*2     </td><td>274</td><td>20</td><td>14</td>
<td bgcolor="black"><br></td><td>fm vln </td><td>206</td><td>16</td><td>13</td></tr>
</table>
<br><br></small></td></tr>

<!-- save-dir -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="savedir">save-dir</a></em></code></span></td>
<td><code>#f</code></td></tr>
<tr><td></td><td colspan=2>Name of directory for saved-state files.  
<br><br>
If #f, all saved-state is placed (as text) in the saved-snd.scm
file.  If you've edited a sound file, this can be unwieldy because each
changed sample is saved as text!  By setting
save-dir, Snd instead places the necessary intermediate files in
save-dir, with the file names in the saved-state file.  The assumption
here is that you won't mess with the save-dir files until you no
longer want to restart that version of Snd.  
<code>(set! (save-dir) "/tmp")</code>.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- save-state-file -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="lsavestatefile">save-state-file</a></em></code></span></td>
<td><code>"saved-snd.scm"</code></td></tr>
<tr><td></td><td colspan=2>The default <a href="snd.html#savedstate">saved state</a> file name.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- selection-creates-region -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="selectioncreatesregion">selection-creates-region</a></em></code></span></td>
<td><code>#t</code></td></tr>
<tr><td></td><td colspan=2>If #t, a region is created whenever a selection is made.  If you're editing very large sounds
and using selections, the region temp files can use up a lot of disk space (and the time to write
them); if you're not using regions anyway, this switch can turn them off.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- show-backtrace -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="showbacktrace">show-backtrace</a></em></code></span></td>
<td><code>#f</code></td></tr>
<tr><td></td><td colspan=2>If #t, show backtrace automatically upon error.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- show-indices -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="showindices">show-indices</a></em></code></span></td>
<td><code>#f</code></td></tr>
<tr><td></td><td colspan=2>If #t, each sound's name is preceded by its index (in the sound pane).
</td></tr>
<tr><td colspan=3></td></tr>

<!-- show-selection-transform -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="lshowselectiontransform">show-selection-transform</a></em></code></span></td>
<td><code>#f</code></td></tr>
<tr><td></td><td colspan=2>If #t, display the transform of the current active selection, if any.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- sinc-width -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sincwidth">sinc-width</a></em></code></span></td>
<td><code>10</code></td></tr>
<tr><td></td><td colspan=2>Width (in samples) of the sampling rate conversion sinc interpolation.
<br><br>
The higher this number, the better the src low-pass filter, but the slower
src runs.  If you use too low a setting, you can sometimes hear high 
frequency whistles leaking through. To hear these on purpose, make 
a sine wave at (say) 55 Hz, then <code>(src-sound '(0 3 1 1))</code> with sinc-width at 4.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- temp-dir -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="tempdir">temp-dir</a></em></code></span></td>
<td><code>#f</code></td></tr>
<tr><td></td><td colspan=2>Name of directory for temporary files.  #f usually means "/tmp" or "/var/tmp".  
See <a href="#sndtempnam">snd-tempnam</a>, and autosave.scm.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- trap-segfault -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="trapsegfault">trap-segfault</a></em></code></span></td>
<td><code>#t</code></td></tr>
<tr><td></td><td colspan=2>If #t, try to catch segfaults and continue anyway.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- window-height -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="windowheight">window-height</a></em></code></span></td>
<td><code>0</code></td></tr>
<tr><td></td><td colspan=2>The current Snd window height in pixels.
This is the same as <br>
<code>(cadr (<a href="widgetsize">widget-size</a> (cadr (<a href="mainwidgets">main-widgets</a>))))</code><br>
except at startup when the window-height function and friends defer the set until after the main widgets
have been created.  If Snd becomes confused about screen size, it can make its main window so large that
you can't get at any of the decorations for resizing the window; in this emergency you can
<code>(set! (window-height) 300)</code> or some such number.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- window-width -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="windowwidth">window-width</a></em></code></span></td>
<td><code>0</code></td></tr>
<tr><td></td><td colspan=2>The current Snd window width in pixels.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- window-x -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="windowx">window-x</a></em></code></span></td>
<td><code>-1</code></td></tr>
<tr><td></td><td colspan=2>The current Snd window left side in pixels.
This is (usually) the same as <br>
<code>(car (<a href="widgetposition">widget-position</a> (cadr (<a href="mainwidgets">main-widgets</a>))))</code><br>
</td></tr>
<tr><td colspan=3></td></tr>

<!-- window-y -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="windowy">window-y</a></em></code></span></td>
<td><code>-1</code></td></tr>
<tr><td></td><td colspan=2>The current Snd window upper side in pixels (X numbering starts at 0 at the top).
</td></tr>
<tr><td colspan=3></td></tr>

<!-- with-background-processes -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="withbackgroundprocesses">with-background-processes</a></em></code></span></td>
<td><code>#t</code></td></tr>
<tr><td></td><td colspan=2>Determines whether Snd should use background (idle time) processes for ffts and so forth. (Intended primarily for auto-testing).
</td></tr>
<tr><td colspan=3></td></tr>

<!-- with-relative-panes -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="withrelativepanes">with-relative-panes</a></em></code></span></td>
<td><code>#t</code></td></tr>
<tr><td></td><td colspan=2>
If this flag is set in the Motif
version of Snd, a multichannel sound tries to retain the relative channel graph sizes
when the outer sash (the overall sound size sash) changes.
Mono sounds and the listener are not affected (perhaps they should be?).
</td></tr>
<tr><td colspan=3></td></tr>

<!-- zoom-focus-style -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="zoomfocusstyle">zoom-focus-style</a></em></code></span></td>
<td><code>zoom-focus-active</code></td></tr>
<tr><td></td><td colspan=2>This determines what a zoom action focuses (centers) on. The choices are 
<i>zoom-focus-left</i>, <i>zoom-focus-right</i>, <i>zoom-focus-active</i>, and <i>zoom-focus-middle</i>.
See <a href="snd.html#zoomoption">Zoom options</a>.</td></tr>
</table>
<br>

<!-- INDEX sndhooks:Hooks -->
<table width="100%" border=1><tr><td bgcolor="lightgreen" valign="middle"><h4><A NAME="sndhooks">Hooks</a></h4></td></tr></table>

<p>When some user-interface action takes place, code is called that responds to that action;
these functions are sometimes called callbacks; in Guile the variable that holds a list of such
callbacks is known as a hook.  
A hook provides
a way to customize user-interface
actions.  
The hook itself is list of functions.  The Guile function add-hook! adds a function to a hook's
list, remove-hook! removes a function, and reset-hook! clears out the list.
For example, the hook that is checked when you click the sound's name in the minibuffer is
name-click-hook.  We can cause that action to print "hi" in the listener by:</p>
<pre>
&gt;<em class=typing>(add-hook! name-click-hook (lambda (snd) (snd-print "hi") #t))</em>
</pre>
<p>
If there is more than one function attached to a hook, some of the hooks
"or" the functions together (marked <b>or</b> below); that is they
run through the list of functions, and if any function returns something other than #f, the
hook invocation eventually returns the last such non-#f value.  A few hooks are "cascade"
hooks; that is, each function gets the result of the previous function, and
the final function's value is returned.
In the other
cases (named "progn" from Common Lisp), the result returned by the hook is the result of the last function in the list.
Whatever the hook combination choice, all the functions on the hook list are run
on each invocatiion.
In the list below the arguments after the hook name refer to the arguments to the functions invoked by
the hook.  That is, <code>after-apply-hook (snd)</code> means that the functions on the
after-apply-hook list each take one argument, a sound index.
</p>
<p>In Ruby, the hook is a global variable that holds either a procedure or is false.
</p>

<!-- -------------------------------- HOOK TABLE -------------------------------- -->

<table border=0 cellspacing=10>

<!-- after-apply-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="afterapplyhook">after-apply-hook</a></em> (snd)</code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called when 'Apply' finishes.  <i>add-amp-controls</i> in snd-motif.scm uses this hook to
reset any added amplitude sliders to 1.0 when Apply finishes.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- after-graph-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="aftergraphhook">after-graph-hook</a></em> (snd chn)</code></span></td><td>
</td></tr>
<tr><td width=150></td><td colspan=2>
called after a graph is updated or redisplayed; see <a href="#displaysampsinred">display-samps-in-red</a>,
<i>draw-smpte-label</i> in snd-motif.scm, or <a href="#addcomment">add-comment</a>.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- after-open-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="afteropenhook">after-open-hook</a></em> (snd)</code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called just before a newly opened sound's window is displayed.
This provides a way to set various sound-specific defaults.  
For example, the following causes Snd to default to locally 
sync'd channels (that is, each sound's channels are sync'd 
together but are independent of any other sound), united channels, 
and filled graphs:
</td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! <em class=red>after-open-hook</em>
  (lambda (snd)
    (if (&gt; (channels snd) 1)
        (begin
          (set! (sync snd) (1+ snd)) ; 0 = #f
          (set! (channel-style snd) channels-combined)
          (set! (graph-style snd) graph-filled)))))
</pre></td></tr></table>
<br>
See also <i>C-x b support</i> in examp.scm, <i>remember-sound-state</i> in extensions.scm, enved.scm, and various
examples in snd-motif.scm.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- after-save-state-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="aftersavestatehook">after-save-state-hook</a></em> (filename)</code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called after Snd has saved its state (<a href="#sndsavestate">save-state</a>).  'filename' is the (otherwise complete) saved state
program.  See ws-save-state in ws.scm or remember-sound-state in extensions.scm.  Both use this sequence:
<br>
<pre>
(lambda (filename)
  (let ((fd (open filename (logior O_RDWR O_APPEND)))) ; open to write at the end
    (format fd "~%~%;;; save-state stuff here ~%")
    ...
    (close fd)))
</pre>
</td></tr>
<tr><td colspan=3></td></tr>

<!-- bad-header-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="badheaderhook">bad-header-hook</a></em> (filename)</code></span></td><td align=right><b>or</b></td>
</tr>
<tr><td></td><td colspan=2>
called if a file has a bogus-looking header. Return #t to give up on that file. <br><br><code>(add-hook! bad-header-hook (lambda (n) #t))</code>
</td></tr>
<tr><td colspan=3></td></tr>

<!-- before-apply-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="beforeapplyhook">before-apply-hook</a></em> (snd)</code></span></td><td align=right><b>or</b></td>
</tr>
<tr><td></td><td colspan=2>
called when 'Apply' is clicked or apply-controls is called.
If it returns #t, the apply is aborted.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- before-transform-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="beforeffthook">before-transform-hook</a></em> (snd chn)</code></span></td><td align=right><b>progn</b></td>
</tr>

<tr><td></td><td colspan=2>
called just before an FFT (or spectrum) is calculated.  If it returns 
an integer, it is used as the starting point of the fft.  The following 
somewhat brute-force code shows a way to have the fft reflect the position 
of a moving mark:
</td></tr>

<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define fft-position #f)
(add-hook! <em class=red>before-transform-hook</em> (lambda (snd chn) fft-position))
(add-hook! mark-drag-hook (lambda (id)
                            (set! fft-position (mark-sample id))
                            (update-transform-graph)))
</pre></td></tr></table></td></tr>
<tr><td colspan=3></td></tr>

<!-- close-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="closehook">close-hook</a></em> (snd) </code></span></td><td align=right><b>or</b></td>
</tr>

<tr><td></td><td colspan=2>
called each time a file is closed (before the close).
If it returns #t, the file is not closed. 
</td></tr>

<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! <em class=red>close-hook</em>
  (lambda (snd) 
    (system \"sndplay wood16.wav\")
    #f))
</pre></td></tr></table>
<br><i>close-hook</i> is used in autosave.scm, examp.scm, extensions.scm, and peak-env.scm; see, for example,
<i>check-for-unsaved-edits</i> or <i>remember-sound-state</i> in extensions.scm.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- color-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="colorhook">color-hook</a></em> () </code></span></td><td align=right><b>progn</b></td>
</tr>

<tr><td></td><td colspan=2>
called whenever one of the variables associated with the color dialog changes.  See <i>start-waterfall</i> in snd-gl.scm.
</td></tr><tr><td colspan=3></td></tr>

<!-- dac-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="dachook">dac-hook</a></em> (data) </code></span></td><td align=right><b>progn</b></td>
</tr>

<tr><td></td><td colspan=2>
called just before data is sent to DAC passing data as sound-data object. See <i>with-level-meters</i> in snd-motif.scm.
</td></tr><tr><td colspan=3></td></tr>

<!-- draw-mark-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="drawmarkhook">draw-mark-hook</a></em> (id)</code></span></td><td align=right><b>progn</b></td>
</tr>
<tr><td></td><td colspan=2>
called before a mark is drawn (in XOR mode). If the hook returns #t, the mark is not drawn.  <i>mark-sync-color</i>
in snd-motif.scm uses this hook to draw sync'd marks in some other color than the current mark-color.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- drop-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="drophook">drop-hook</a></em> (filename) </code></span></td><td align=right><b>or</b></td>
</tr>

<tr><td></td><td colspan=2>
called each time Snd receives a drag-and-drop event, passing the hook the filename.
If it returns #t, the file is not opened.  If you drag the file icon to the menubar, 
Snd opens it as if you had called open-sound.  If you drag it to a particular channel,
Snd mixes it at the mouse location in that channel.  To get Snd to
mix the dragged file even from the menubar:
<br><br><code>(add-hook! drop-hook (lambda (filename) (mix filename) #t))</code><br><br>
snd-motif.scm has examples that add a drop callback to an arbitrary widget, or
change an existing callback (to pass the sound index and channel number to the drop callback function, bypassing drop-hook).
</td></tr><tr><td colspan=3></td></tr>

<!-- during-open-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="duringopenhook">during-open-hook</a></em> (fd name reason)</code></span></td><td>
</td></tr>

<tr><td></td><td colspan=2>
called after file is opened, but before data has been read.
This provides an opportunity to set sndlib prescaling values:
</td></tr>

<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! <em class=red>during-open-hook</em>
  (lambda (fd name reason)
    (if (= (mus-sound-header-type name) mus-raw)
        (<a href="#musfileprescaler">(set! (mus-file-prescaler</a> fd) 500.0)))))
</pre></td></tr></table></td></tr>

<tr><td></td><td colspan=2>
The prescaling affects only sound data made up of floats or doubles.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- enved-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="envedhook">enved-hook</a></em> (env pt new-x new-y reason)</code></span></td><td align=right><b>cascade</b>
</td></tr>

<tr><td></td><td colspan=2>
Each time a breakpoint is changed in the envelope editor, this hook 
is called; if it returns a list, that list defines the new envelope, 
otherwise the breakpoint is moved (but not beyond the neighboring 
breakpoint), leaving other points untouched.  The kind of change
is <i>reason</i> which can be <b>enved-move-point</b>, <b>enved-delete-point</b>,
or <b>enved-add-point</b>.  This hook makes it possible to define attack 
and decay portions in the envelope editor, or use functions such as 
stretch-envelope from env.scm:
</td></tr>

<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! <em class=red>enved-hook</em>
  (lambda (env pt x y reason)
    (if (= reason enved-move-point)
        (if (and (&gt; x 0.0) (&lt; x (envelope-last-x env))) ; from env.scm
            (let* ((old-x (list-ref env (* pt 2)))
                   (new-env (<em class=red>stretch-envelope</em> env old-x x)))
              (list-set! new-env (+ (* pt 2) 1) y)
              new-env)
            env)
        #f)))
</pre></td></tr></table></td></tr>

<tr><td></td><td colspan=2>
If there are several functions on the hook, each gets the (envelope)
result of the preceding function (if a function returns #f, the envelope
is not changed).  A math-type would call this a "function composition"
method combination; a filter-type would say "cascade"; 
I like the latter.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- exit-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="exithook">exit-hook</a></em> ()</code></span></td><td align=right><b>or</b>
</td></tr>

<tr><td></td><td colspan=2>
called upon exit.
If it returns #t, Snd does not exit.  This can be used to check 
for unsaved edits, or to perform cleanup activities (see autosave.scm, extensions.scm, or <a href="#unsavededitsp">unsaved-edits?</a>).
</td></tr>
<tr><td colspan=3></td></tr>

<!-- graph-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="graphhook">graph-hook</a></em> (snd chn y0 y1) </code></span></td><td align=right><b>or</b>
</td></tr>

<tr><td></td><td colspan=2>
called each time a graph is updated or redisplayed.
If it returns #t, the display is not updated.
See examp.scm for many examples.
</td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! <em class=red>graph-hook</em>
  (lambda (snd chn y0 y1)
    "set the dot size depending on the number of samples being displayed"
    (let ((dots (- (right-sample snd chn) (left-sample snd chn))))
      (if (&gt; dots 100) 
	  (set! (dot-size snd chn) 1)
	(if (&gt; dots 50)
	    (set! (dot-size snd chn) 2)
	  (if (&gt; dots 25)
	      (set! (dot-size snd chn) 3)
	    (set! (dot-size snd chn) 5))))
      #f)))
</pre></td></tr></table></td></tr>
<tr><td colspan=3></td></tr>

<!-- help-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="helphook">help-hook</a></em> (subject help-string)</code></span></td><td align=right><b>cascade</b>
</td></tr>
<tr><td width=150></td><td colspan=2>
called from snd-help with the current help subject and default help-string.  Say we want the index.scm
procedure 'html' called any time snd-help is called (from C-? for example):<br><br>
<code>(add-hook! help-hook (lambda (subject help) (html subject) #f))</code><br><br>
If there is more than one hook function, each function's result is passed as input to the next function.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- initial-graph-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="initialgraphhook">initial-graph-hook</a></em> (snd chn dur) </code></span></td><td align=right><b>or</b>
</td></tr>

<tr><td></td><td colspan=2>
called the first time a given channel is displayed.
If it returns a list, the list's contents are interpreted as: <br>
<code>'(x0 x1 y0 y1 label ymin ymax)</code><br> (all values optional), where these numbers set the
initial axis limits and settings. 
The default (empty hook) is equivalent to:
<pre>(add-hook! initial-graph-hook (lambda (snd chn dur) (list 0.0 0.1 -1.0 1.0 "time" -1.0 1.0)))</pre>
The <i>dur</i> argument is the total length in seconds of the channel, so to cause the
entire sound to be displayed initially:
<pre>(add-hook! initial-graph-hook (lambda (snd chn dur) (list 0.0 dur)))</pre>
To get the data limits (rather than the default -1.0 to 1.0 as above), you can use <a href="mussoundmaxamp">mus-sound-maxamp</a>,
but if that sound's maxamp isn't already known, it can require a long process of reading the file. The following hook procedure
uses the maxamp data only if it is already available:
</td></tr><tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! <em class=red>initial-graph-hook</em>
  (lambda (snd chn dur)
    (if (mus-sound-maxamp-exists? (file-name snd))
	(let* ((amp-vals (mus-sound-maxamp (file-name snd)))
	       (max-val (list-ref amp-vals (+ (* chn 2) 1))))
	  (list 0.0 dur (- max-val) max-val))
	(list 0.0 dur -1.0 1.0))))
</pre></td></tr></table>
</td></tr><tr><td colspan=3></td></tr>
<tr><td></td><td colspan=2>A similar problem affects the <i>dur</i> argument.  If the file is very long, Snd starts
a background process reading its data to get an overall amplitude envelope of the file,
and this envelope is what it actually displays when you zoom out to look at the entire
sound. If you set <i>x1</i> to <i>dur</i>, you effectively get two such processes
contending for access to the data.  One way around this is to save the envelope
(a "peak envelope" in Snd's nomenclature); 
load peak-env.scm to make this process automatic.
</td></tr><tr><td colspan=3></td></tr>

<!-- just-sounds-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="justsoundshook">just-sounds-hook</a></em> (filename)</code></span></td><td align=right><b>or</b>
</td></tr>
<tr><td></td><td colspan=2>
called on each file (after the sound file extension check) if the
just-sounds button is set. Return #f to filter out <i>filename</i>.
</td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! <em class=red>just-sounds-hook</em>
  (lambda (name) ;display only stereo files in file selection dialog
    (and (not (= (mus-sound-header-type name) mus-raw))
         ;;any unrecognized file is considered "raw"
         (= (mus-sound-chans name) 2))))
</pre></td></tr></table></td></tr>
<tr><td></td><td colspan=2>
This currently only works in Motif; the Gtk file selection dialogs 
don't provide a way to specialize the directory read.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- key-press-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="keypresshook">key-press-hook</a></em> (snd chn key state)</code></span></td><td align=right><b>or</b>
</td></tr>
<tr><td></td><td colspan=2>
called upon key press while the mouse is in the lisp graph.
If it returns #t, the key press is not passed to the main handler.
<i>state</i> refers to the control, meta, and shift keys.
<b>start-enveloping</b> in enved.scm uses this hook to add C-g and C-. support to the
channel-specific envelope editors.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- lisp-graph-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="lispgraphhook">lisp-graph-hook</a></em> (snd chn)</code></span></td><td align=right><b>progn</b>
</td></tr>
<tr><td></td><td colspan=2>
called just before the lisp graph is updated or redisplayed (see <a href="#displaydb">display-db</a>).
If it returns a list of pixels (xm style), these are used in order by the list of graphs (if any), rather than Snd's default set
(this makes it possible to use different colors for the various graphs).
If it returns a function (of no arguments), that function is called rather than the standard graph routine:

</td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! <em class=red>lisp-graph-hook</em>
	   (lambda (snd chn)
	     (lambda ()
	       (draw-string "hi" 
			    (x-&gt;position 0.5 snd chn lisp-graph) 
			    (y-&gt;position 0.0 snd chn lisp-graph)
			    snd chn))))
</pre></td></tr></table></td></tr>
<tr><td colspan=3></td></tr>

<!-- listener-click-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="listenerclickhook">listener-click-hook</a></em> (textpos)</code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called when a click occurs in the listener; the argument is the position in the text where the click occurred.
See click-for-listener-help in draw.scm.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- mark-click-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="markclickhook">mark-click-hook</a></em> (id)</code></span></td><td align=right><b>progn</b>
</td></tr>
<tr><td></td><td colspan=2>
called when a mark is clicked; return #t to squelch default minibuffer mark identification.  The following 
hook function is used in with-marked-sound in ws.scm to display arbitrary info about a note.
</td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! <em class=red>mark-click-hook</em>
  (lambda (n) 
    (if (not (defined? 'mark-properties)) (load "marks.scm"))
    (help-dialog "Mark Help"
      (format #f "Mark ~D~A:~%  sample: ~D = ~,3F secs~A~A"
	      n 
	      (let ((name (mark-name n)))
   	        (if (&gt; (string-length name) 0)
		    (format #f " (~S)" name)
		    ""))
	      (mark-sample n)
	      (/ (mark-sample n) (srate (car (mark-home n))))
	      (if (not (= (mark-sync n) 0))
	        (format #f "~%  sync: ~A" (mark-sync n))
	        "")
	      (let ((props (mark-properties n)))
	        (if (and (list? props)
		         (not (null? props)))
	          (format #f "~%  properties: '~A" props)
	          ""))))
    #t))
</pre></td></tr></table></td></tr>
<tr><td colspan=3></td></tr>

<!-- mark-drag-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="markdraghook">mark-drag-hook</a></em> (id)</code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called when a mark is dragged.
</td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (report-mark-location id)
  ;; print current mark location in minibuffer
  (let ((samp (mark-sample id))
        (sndchn (mark-home id)))
    (report-in-minibuffer 
      (format #f "mark ~D: sample: ~D (~,3F) ~A[~D]: ~,3F"
              id samp 
              (/ samp (srate (car sndchn))) 
              (short-file-name (car sndchn))
              (cadr sndchn)
	      (sample samp (car sndchn) (cadr sndchn))))))
(add-hook! <em class=red>mark-drag-hook</em> report-mark-location)
</pre></td></tr></table></td></tr>
<tr><td colspan=3></td></tr>


<!-- mark-drag-triangle-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="markdragtrianglehook">mark-drag-triangle-hook</a></em> (id x time dragged-before)</code></span></td><td align=right><b>progn</b>
</td></tr>
<tr><td></td><td colspan=2>
called when a mark play triangle is dragged.  The smoothness of the response to the drag motion is
largely determined by <a href="#dacsize">dac-size</a>.
<i>dragged-before</i> is #f when the drag starts and #t thereafter.  <i>x</i> is the mouse x location in the current
graph. <i>time</i> is the uninterpreted time at which the drag event was reported. <i>id</i> is the mark id. If the hook returns #t,
Snd takes no further action.  To set up to play, then interpret the motion yourself, return #f on the first call,
and #t thereafter:
</td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(let ((first-x 0))
  (add-hook! <em class=red>mark-drag-triangle-hook</em>
    (lambda (id x time dragged-before)
      (if (not dragged-before)
	  (set! first-x x)
	  (set! (speed-control) (/ (- x first-x) 16.0)))
      dragged-before)))
</pre></td></tr></table></td></tr>
<tr><td colspan=3></td></tr>


<!-- mark-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="markhook">mark-hook</a></em> (id snd chn reason)</code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called when a mark is added, deleted, or moved (but not while moving). 'id' can be -1 (i.e. no specific mark).
'Reason' can be 0: add, 1: delete, 2: move (via set! mark-sample), 3: delete all marks, 4: release (after drag). 
In the "release" case, the hook is called upon button release before any edits (control-drag of mark) or sorting (simple drag),
and if the mark-sync is active, the hook is called on each syncd mark.
</td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (<A NAME="snpmark">snap-mark-to-beat</a>)
  ;; when a mark is dragged, its end position is always on a beat
  (let ((mark-release 4))
    (add-hook! <em class=red>mark-hook</em>
      (lambda (mrk snd chn reason)
        (if (= reason mark-release)
            (let* ((samp (mark-sample mrk))
	           (bps (/ (beats-per-minute snd chn) 60.0))
		   (sr (srate snd))
		   (beat (floor (/ (* samp bps) sr)))
		   (lower (inexact-&gt;exact (/ (* beat sr) bps)))
		   (higher (inexact-&gt;exact (/ (* (1+ beat) sr) bps))))
	      (set! (mark-sample mrk)
	      (if (&lt; (- samp lower) (- higher samp))
		  lower
 		  higher))))))))
</pre></td></tr></table></td></tr>
<tr><td colspan=3></td></tr>

<!-- mix-amp-changed-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="mixampchangedhook">mix-amp-changed-hook</a></em> (id chan)</code></span></td><td align=right><b>progn</b>
</td></tr>
<tr><td></td><td colspan=2>
called when a mix's amp changes via the mouse (id = mix id, chan = which channel's slider moved in the Mix Panel).
If it returns #t, the actual remix is the hook's responsibility.
With this hook and the parallel <a href="#mixdraggedhook">mix-dragged-hook</a>, 
<a href="#mixampenvchangedhook">mix-amp-env-changed-hook</a>, and 
<a href="#mixspeedchangedhook">mix-speed-changed-hook</a>,
the intent is that user-interface changes will go through the hooks, but programmatic changes
(setting mix-amp from code, for example) will handle the sync's effects and what not explicitly.
The <a href="sndscm.html#panmix">pan-mix</a> function in mix.scm uses all four to make sure
that all the mixes and their channels related to a given panning event can be handled
as a unit through the user interface.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- mix-amp-env-changed-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="mixampenvchangedhook">mix-amp-env-changed-hook</a></em> (id chan)</code></span></td><td align=right><b>progn</b>
</td></tr>
<tr><td></td><td colspan=2>
called when a mix's amp env changes via the mouse (id = mix id, chan = which channel's amp env in the Mix Panel); this can happen either through
the Mix Panel amp envs, or through the Envelope Editor if it is applied to a mix's amp env.
If it returns #t, the actual remix is the hook's responsibility.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- mix-click-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="mixclickhook">mix-click-hook</a></em> (id)</code></span></td><td align=right><b>progn</b>
</td></tr>
<tr><td></td><td colspan=2>
called when a mix tag is clicked; return #t to omit the default action which is to print the mix id in
the minibuffer.  Here's an example that sets the mix amps to 0 if you click it (see <a href="sndscm.html#mixclicksetsamp">mix-click-sets-amp</a>
in mix.scm for a fancier version):
</td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! <em class=red>mix-click-hook</em>
  (lambda (n)
    (do ((i 0 (1+ i)))
	((= i (mix-chans n)))
      (set! (mix-amp n i) 0.0))
    #t))
</pre></td></tr></table></td></tr>

<tr><td colspan=3></td></tr>

<!-- mix-drag-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="mixdraghook">mix-drag-hook</a></em> (id)</code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called when a mix is dragged.
</td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! <em class=red>mix-drag-hook</em>
  (lambda (n) 
    (report-in-minibuffer 
      (format #f "mix ~A at ~D: ~,3F" n (mix-position n) (/ (mix-position n) (srate))))))
</pre></td></tr></table></td></tr>
<tr><td colspan=3></td></tr>

<!-- mix-dragged-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="mixdraggedhook">mix-dragged-hook</a></em> (id samps)</code></span></td><td align=right><b>progn</b>
</td></tr>
<tr><td></td><td colspan=2>
called after a mix has been dragged by the mouse to a new position (id = mix id, 
samps = total samples moved during the drag).  If it returns #t, the actual remix is the 
hook's responsibility.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- mix-speed-changed-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="mixspeedchangedhook">mix-speed-changed-hook</a></em> (id)</code></span></td><td align=right><b>progn</b>
</td></tr>
<tr><td></td><td colspan=2>
called when a mix's speed changes via the mouse (id = mix id).
If it returns #t, the actual remix is the hook's responsibility (see <i>respeed-track</i> in mix.scm).
</td></tr>
<tr><td colspan=3></td></tr>

<!-- mouse-click-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="mouseclickhook">mouse-click-hook</a></em> (snd chn button state x y axis) </code></span></td><td align=right><b>or</b>
</td></tr>
<tr><td></td><td colspan=2>
called upon a mouse button click (press and release without drag).  If it returns #t, the click is ignored by Snd.
See the <i>current-window-location</i> procedures in draw.scm.  Here's a simpler example:</td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (click-to-center snd chn button state x y axis)
  ;; if mouse click in time domain graph, set cursor as normally, but also center the window
  (if (= axis time-graph)
      (let ((samp (inexact-&gt;exact (* (srate snd) (position-&gt;x x snd chn)))))
	(set! (cursor snd chn) samp)
	(set! (right-sample snd chn) 
          (- samp (inexact-&gt;exact (* .5 (- (left-sample snd chn) (right-sample snd chn))))))
	(update-time-graph)
	#t)
      #f))

(add-hook! <em class=red>mouse-click-hook</em> click-to-center)
</pre></td></tr></table></td></tr>
<tr><td colspan=3></td></tr>

<!-- mouse-drag-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="mousedraghook">mouse-drag-hook</a></em> (snd chn button state x y) </code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called when the mouse is dragged within the lisp graph (see enved.scm or rtio.scm).
</td></tr>
<tr><td colspan=3></td></tr>

<!-- mouse-enter-graph-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="mouseentergraphhook">mouse-enter-graph-hook</a></em> (snd chn) </code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called when the mouse enters a channel's drawing area (graph pane).
</td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! <em class=red>mouse-enter-graph-hook</em>
  (lambda (snd chn) 
    (snd-print (format #f "~A[~A]" (short-file-name snd) chn))))
</pre></td></tr></table></td></tr>
<tr><td colspan=3></td></tr>

<!-- mouse-enter-label-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="mouseenterlabelhook">mouse-enter-label-hook</a></em> (type position name) </code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called when a file viewer or region label 
is entered by the mouse. The 'type' is 0 for the current files list, 1 for previous files, and 2 for regions. 
The 'position' is the scrolled list position of the label. 
The label itself is 'label'. We could use the <i>finfo</i> procedure in examp.scm
to popup file info as follows:
</td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! <em class=red>mouse-enter-label-hook</em>
  (lambda (type position name)
    (if (not (= type 2))
        (help-dialog name (finfo name)))))
</pre></td></tr></table></td></tr>
<tr><td></td><td>See also <i>files-popup-buffer</i> in examp.scm</td></tr>
<tr><td colspan=3></td></tr>

<!-- mouse-enter-listener-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="mouseenterlistenerhook">mouse-enter-listener-hook</a></em> (widget) </code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called when the mouse enters the lisp listener pane. This hook, along with the parallel graph hook
makes it possible to set up Snd to behave internally like a window manager with pointer-focus.  That is, to
ensure that the pane under the mouse is the one that receives keyboard input, we could define the following
hook procedures:
</td></tr>
<tr><td colspan=3></td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! <em class=red>mouse-enter-graph-hook</em>
  (lambda (snd chn)
    (if (sound? snd) (focus-widget (car (channel-widgets snd chn))))))

(add-hook! <em class=red>mouse-enter-listener-hook</em>
  (lambda (widget)
    (focus-widget widget)))
</pre></td></tr></table></td></tr>
<tr><td></td><td colspan=2>
I much prefer this style of operation.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- mouse-enter-text-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="mouseentertexthook">mouse-enter-text-hook</a></em> (widget) </code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called when the mouse enters a text widget (this is the third of the pointer-focus hooks).
</td></tr><tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! <em class=red>mouse-enter-text-hook</em>
  (lambda (w)
    (focus-widget w)))
</pre></td></tr></table></td></tr>
<tr><td colspan=3></td></tr>

<!-- mouse-leave-graph-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="mouseleavegraphhook">mouse-leave-graph-hook</a></em> (snd chn) </code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called when the mouse leaves a channel's drawing area (graph pane). 
</td></tr>
<tr><td colspan=3></td></tr>

<!-- mouse-leave-label-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="mouseleavelabelhook">mouse-leave-label-hook</a></em> (type position name) </code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called when the mouse exits one of the labels covered by mouse-enter-label-hook. (See nb.scm)
</td></tr>
<tr><td colspan=3></td></tr>

<!-- mouse-leave-listener-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="mousleavelistenerhook">mouse-leave-listener-hook</a></em> (widget) </code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called when the mouse leaves the lisp listener pane.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- mouse-leave-text-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="mousleavetexthook">mouse-leave-text-hook</a></em> (widget) </code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called when the mouse leaves a text widget.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- mouse-press-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="mousepresshook">mouse-press-hook</a></em> (snd chn button state x y) </code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called upon a mouse button press within the lisp graph (see enved.scm).  The x and y values are 
relative to the lisp graph axis (as if the raw mouse pixel position was passed through
<a href="#position2x">position-&gt;x</a> and <a href="#position2y">position-&gt;y</a>).
</td></tr>
<tr><td colspan=3></td></tr>

<!-- mouse-release-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="mousereleasehook">mouse-release-hook</a></em> (snd chn button state x y) </code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called upon a mouse button release within the lisp graph (see enved.scm).
</td></tr>
<tr><td colspan=3></td></tr>

<!-- multichannel-mix-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="multichannelmixhook">multichannel-mix-hook</a></em> (ids)</code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called when a multichannel sound is mixed into a sync'd sound.
<i>ids</i> is a list of mix id numbers.  <a href="sndscm.html#syncmultichannelmixes">sync-multichannel-mixes</a> in mix.scm uses
this hook to sync together the members of a multichannel mix. 
</td></tr>
<tr><td colspan=3></td></tr>

<!-- mus-error-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="muserrorhook">mus-error-hook</a></em> (error-type error-message)</code></span></td><td align=right><b>or</b></td>
</tr>
<tr><td></td><td colspan=2>
called upon mus_error.
If it returns #t, Snd ignores the error (it assumes you've handled it via the hook).
This hook is used in <i>play-sound</i> in play.scm to flush an error message that the Snd ALSA support code generates (or used to generate).
</td></tr>
<tr><td colspan=3></td></tr>

<!-- name-click-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="nameclickhook">name-click-hook</a></em> (snd)</code></span></td><td align=right><b>or</b>
</td></tr>
<tr><td></td><td colspan=2>
called when the sound name is clicked.
If it returns #t, the usual informative minibuffer babbling is squelched.
</td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! <em class=red>name-click-hook</em>
  (lambda (snd) ; toggle read-only
    (set! (read-only snd) (not (read-only snd)))
    #t))
</pre></td></tr></table></td></tr>
<tr><td colspan=3></td></tr>

<!-- new-sound-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="newsoundhook">new-sound-hook</a></em> (filename)</code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called whenever a new sound file is being created.  <a href="clm.html#sound-let">sound-let</a> in ws.scm uses
this hook to keep track of newly created temporary sounds so that it can delete them once they are no longer needed.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- new-widget-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="newwidgethook">new-widget-hook</a></em> (widget)</code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called each time a dialog or a new set of channel or sound widgets is created.  This is used in snd-motif.scm (<i>paint-all</i>) to
make sure all newly created widgets have the same background pixmaps.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- open-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="openhook">open-hook</a></em> (filename)</code></span></td><td align=right><b>or</b>
</td></tr>
<tr><td></td><td colspan=2>
called each time a file is opened (before the actual open).
If it returns #t, the file is not opened.
If it returns a string (a filename), that file is opened instead of the original one.
</td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! <em class=red>open-hook</em>
  (lambda (filename)
    (if (= (mus-sound-header-type filename) mus-raw)
        ;; check for "OggS" first word, if found, translate to something Snd can read
	(if (call-with-input-file filename 
	      (lambda (fd)
		(and (char=? (read-char fd) #\O)
		     (char=? (read-char fd) #\g)
		     (char=? (read-char fd) #\g)
		     (char=? (read-char fd) #\S))))
	    (let ((aufile (string-append filename ".au")))
	      (if (file-exists? aufile) (delete-file aufile))
	      (system (format #f "ogg123 -d au -f ~A ~A" aufile filename))
	      aufile)
	    #f)
	#f)))
</pre></td></tr></table>
<br>
See also <a href="sndscm.html#exopenbuffer">open-buffer</a> in examp.scm.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- open-raw-sound-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="openrawsoundhook">open-raw-sound-hook</a></em> (filename current-choices)</code></span></td><td align=right><b>progn</b>
</td></tr>
<tr><td></td><td colspan=2>
called each time <a href="#sndopen">open-sound</a> encounters a headerless file.
Its result can be a list describing the raw file's attributes (thereby bypassing the Raw File Dialog and so on):
<code>(list chans srate data-format data-location data-length)</code> where trailing elements can 
be omitted (location defaults to 0, and length defaults to the file length in bytes).
If there is more than one function on the hook list, functions after the first get the
on-going list result (if any) as the <i>current-choices</i> argument (the empty list is the default).
<br><br><code>(add-hook! open-raw-sound-hook (lambda (file choices) (list 1 44100 mus-lshort)))</code><br><br>
Return '() to accept all the current raw header defaults; return #f to fallback on the Raw File Dialog.
The raw header defaults are stereo, 44100 Hz, big endian short data; these values can be changed in the
Raw File Dialog, or by calling open-raw-sound with explicit arguments.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- optimization-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="optimizationhook">optimization-hook</a></em> (message)</code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called each time the optimizer hits something it can't handle; <i>message</i> tries to give some information about the situation.
<br><br><code>(add-hook! optimization-hook (lambda (n) (display (format #f "~A~%" n))))</code>
<br><br>
Normally, if the optimizer fails for some reason, it falls back silently on the Guile evaluator, so
the code simply runs slower.  This hook gives you a way to find out why the optimizer gave up.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- orientation-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="orientationhook">orientation-hook</a></em> () </code></span></td><td align=right><b>progn</b>
</td></tr>

<tr><td></td><td colspan=2>
called whenever one of the variables associated with the orientation dialog changes.  See <i>start-waterfall</i> in snd-gl.scm.
</td></tr><tr><td colspan=3></td></tr>

<!-- output-comment-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="outputcommenthook">output-comment-hook</a></em> (str)</code></span></td><td align=right><b>cascade</b>
</td></tr>
<tr><td></td><td colspan=2>
called in the Save-As dialog. <i>str</i> is the current sound's comment.
If there is more than one hook function, each function's result is passed as input to the next function in the list.
</td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! <em class=red>output-comment-hook</em>
  (lambda (str) 
    (string-append str ": written " 
      (strftime "%a %d-%b-%Y %H:%M %Z" 
        (localtime (current-time)))))) 
</pre></td></tr></table></td></tr>
<tr><td colspan=3></td></tr>

<!-- output-name-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="outputnamehook">output-name-hook</a></em> ()</code></span></td><td align=right><b>progn</b>
</td></tr>
<tr><td></td><td colspan=2>
called in the New File dialog, setting the file name in the associated text widget.
</td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(let ((file-ctr -1))
  (add-hook! <em class=red>output-name-hook</em>
    (lambda ()
      (set! file-ctr (+ file-ctr 1))
      (format #f "~A-~D.snd" 
	(strftime "%b-%d" (localtime (current-time)))
        file-ctr))))
</pre></td></tr></table></td></tr>
<tr><td colspan=3></td></tr>

<!-- play-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="playhook">play-hook</a></em> (samps)</code></span></td><td align=right><b>progn</b>
</td></tr>
<tr><td></td><td colspan=2>
called each time a buffer (size: <i>samps</i>) is about to be 
filled for the DAC (see <a href="sndscm.html#enveddoc">enved.scm</a> and <a href="sndscm.html#marksdoc">marks.scm</a>).
</td></tr>
<tr><td colspan=3></td></tr>

<!-- previous-files-select-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="previousfilesselecthook">previous-files-select-hook</a></em> (filename)</code></span></td><td align=right><b>or</b>
</td></tr>
<tr><td></td><td colspan=2>
called each time a file is selected in the View Files dialog's previous files list.
If it returns #t, the file is not opened in Snd (the default action).  We can use this
hook to use the previous files list for whatever purpose seems handy. 
Say we want to click a file to have it mixed into the currently selected sound at
the cursor:
</td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! <em class=red>previous-files-select-hook</em>
  (lambda (file)
    (mix file (cursor))
    #t))
</pre></td></tr></table></td></tr>
<tr><td colspan=3></td></tr>

<!-- print-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="printhook">print-hook</a></em> (text)</code></span></td><td align=right><b>progn</b>
</td></tr>
<tr><td></td><td colspan=2>
called each time some Snd-generated response (<i>text</i>) is about to be appended to the listener.
If it returns some non-#f result, Snd assumes you've sent the text out yourself, as well as any needed prompt.
The prompt is important!  Snd uses it to find the current form to evaluate, so if your print hook
forgets to include it, you can end up with a comatose listener.  To get out of this state, include
the prompt by hand (i.e. type "&gt;(reset-hook! print-hook)").
This is intended to make it possible to
distinguish Snd responses from user-typing, or add arbitrarily fancy prompts, etc.  Here are two
examples, the first adds a timestamp, the second (in Gtk) displays Snd's responses in red:
</td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! <em class=red>print-hook</em>
  (lambda (msg) 
    (if (char=? (string-ref msg 0) #\newline)
	(snd-print msg)
	(snd-print (format #f "~A~%[~A]~%~A" ;need newline just before listener-prompt
			   msg 
			   (strftime "%d-%b %H:%M %Z" (localtime (current-time)))
			   (listener-prompt))))))

(add-hook! <em class=red>print-hook</em>
  (lambda (msg) 
    (let ((old-color (listener-text-color)))
    (set! (listener-text-color) (make-color 1 0 0))
    (snd-print msg)
    (set! (listener-text-color) old-color))
    (snd-print (listener-prompt))))
</pre></td></tr></table></td></tr>
<tr><td colspan=3></td></tr>

<!-- read-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="readhook">read-hook</a></em> (text)</code></span></td><td align=right><b>or</b>
</td></tr>
<tr><td></td><td colspan=2>
called each time a line is typed into the listener (it is triggered by the carriage return).
If it returns #t, Snd assumes you've dealt the text yourself, and does not try to evaluate it.
This is intended to make it possible to read user-typing in the listener.
</td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (read-listener-line prompt)
  "(read-listener-line prompt) prompts for input and returns it in Snd's listener"
  (let ((res #f))
    (add-hook! <em class=red>read-hook</em> (lambda (str) (set! res str) #t))
    (reset-listener-cursor)
    (snd-print "\n")
    (snd-print prompt)
    (do () ((or (c-g?) res)))
    (reset-hook! <em class=red>read-hook</em>)
    res))
</pre></td></tr></table></td></tr>
<tr><td></td><td colspan=2>
</td></tr>

<!-- save-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="savehook">save-hook</a></em> (snd name)</code></span></td><td align=right><b>or</b>
</td></tr>
<tr><td></td><td colspan=2>
called each time a file is about to be saved.
If it returns #t, the file is not saved.  <i>name</i> is #f unless 
the file is being saved under a new name (as in <a href="#sndsaveas">save-sound-as</a>).  (See the auto-save code in autosave.scm).
</td></tr>
<tr><td colspan=3></td></tr>

<!-- save-state-hook -->
<tr><td colspan=3>
<span class=defbox><code><em class=def><a name="savestatehook">save-state-hook</a></em> (temp-filename)</code></span>
</td></tr>
<tr><td></td><td colspan=2>
called each time the <a href="#sndsavestate">save-state</a>
mechanism is about to create a new temporary file to save some edit history sample values.
<i>temp-filename</i> is the current temporary file name.
If the hook returns a string, it is treated as the new temp filename.  This hook provides a way to
keep track of which files are in a given saved state batch, and a way to rename or redirect those files.
The default naming scheme simply increments a counter and places everything in the <a href="#savedir">save-dir</a>;
without the save-state-hook, if you are saving several states, it can be a pain sometimes to decide which files are no longer needed.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- select-channel-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="selectchannelhook">select-channel-hook</a></em> (snd chn)</code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called when a channel is selected (after the sound has been selected). The arguments are the sound's index and the channel number.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- select-mix-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="selectmixhook">select-mix-hook</a></em> (id)</code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called when a mix is selected. The argument is the newly selected mix's id.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- select-sound-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="selectsoundhook">select-sound-hook</a></em> (snd)</code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called when a sound is selected. The argument is the about-to-be-selected sound's index.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- snd-error-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="snderrorhook">snd-error-hook</a></em> (error-message)</code></span></td><td align=right><b>or</b>
</td></tr>
<tr><td></td><td colspan=2>
called upon snd_error.
If it returns #t, Snd flushes the error (it assumes you've 
reported it via the hook).
</td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! <em class=red>snd-error-hook</em>
  (lambda (msg) 
    (play "bong.snd") ; or if xm is loaded, (XBell (XtDisplay (cadr (main-widgets))) 10)
    #f))
</pre></td></tr></table></td></tr>
<tr><td colspan=3></td></tr>

<!-- snd-warning-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndwarninghook">snd-warning-hook</a></em> (warning-message)</code></span></td><td align=right><b>or</b>
</td></tr>
<tr><td></td><td colspan=2>
called upon snd_warning.
If it returns #t, Snd flushes the warning (it assumes you've 
reported it via the hook).
</td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define without-warnings
  (lambda (thunk)
    (define no-warning (lambda (msg) #t))
    (add-hook! <em class=red>snd-warning-hook</em> no-warning)
    (thunk)
    (remove-hook! <em class=red>snd-warning-hook</em> no-warning)))
</pre></td></tr></table></td></tr>
<tr><td colspan=3></td></tr>

<!-- start-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="starthook">start-hook</a></em> (filename)</code></span></td><td align=right><b>or</b>
</td></tr>
<tr><td></td><td colspan=2>
called when Snd starts.
If it returns #t, Snd exits immediately.
Say we are so annoyed with the X/Motif file browser that we want
Snd to exit back to the shell if its file argument is not
found (this code obviously has to be in the ~/.snd init file):
</td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! <em class=red>start-hook</em>
  (lambda (file)
    (if (not (file-exists? file))
	(begin
	  (display file) (display " does not exist")
	  #t))))
</pre></td></tr></table>
</td></tr><tr><td colspan=3></td></tr>

<!-- start-playing-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="startplayinghook">start-playing-hook</a></em> (snd)</code></span></td><td align=right><b>or</b>
</td></tr>
<tr><td></td><td colspan=2>
called when a sound is about to be played.
If it returns #t, Snd does not play (see <i>report-mark-names</i> in marks.scm).
</td></tr>
<tr><td colspan=3></td></tr>

<!-- start-playing-selection-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="startplayingselectionhook">start-playing-selection-hook</a></em> ()</code></span></td><td align=right><b>or</b>
</td></tr>
<tr><td></td><td colspan=2>
called when the selection is about to be played.
If it returns #t, Snd does not play the selection.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- stop-dac-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="stopdachook">stop-dac-hook</a></em> ()</code></span></td><td>
</td></tr>

<tr><td></td><td colspan=2>
called when Snd stops playing and turns off the DAC, normally upon mus_audio_close.  See snd-motif.scm.
</td></tr><tr><td colspan=3></td></tr>

<!-- stop-playing-channel-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="stopplayingchannelhook">stop-playing-channel-hook</a></em> (snd chn)</code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called when a sound finishes playing.
</td></tr>
<tr><td colspan=3></td></tr>

<!-- stop-playing-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="stopplayinghook">stop-playing-hook</a></em> (snd)</code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called when a sound finishes playing.
The following code plays a sound over and over until you type C-g:
</td></tr>
<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (play-until-c-g)
  (define (play-once snd)
    (if (c-g?)
        (remove-hook! <em class=red>stop-playing-hook</em> play-once)
        (play 0 snd)))
  (add-hook! <em class=red>stop-playing-hook</em> play-once)
  (play))
</pre></td></tr></table></td></tr>
<tr><td></td><td colspan=2>
Here's somewhat brute-force code to play a sound a given number of times.
</td></tr><tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (play-often n) 
  (let ((plays (- n 1)))
    (define (play-once snd)
      (if (or (= plays 0)
	      (c-g?))
	  (remove-hook! <em class=red>stop-playing-hook</em> play-once)
	  (begin
	    (set! plays (- plays 1))
	    (play 0 snd))))
    (add-hook! <em class=red>stop-playing-hook</em> play-once)
    (play)))

(bind-key (char-&gt;integer #\p) 0 (lambda (num) (play-often (max 1 num))))
</pre></td></tr></table></td></tr>
<tr><td colspan=3></td></tr>

<!-- stop-playing-region-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="stopplayingregionhook">stop-playing-region-hook</a></em> (n)</code></span></td><td>
</td></tr>
<tr><td></td><td colspan=2>
called when a region finishes playing.  See play.scm.
</td></tr>

<!-- stop-playing-selection-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="stopplayingselectionhook">stop-playing-selection-hook</a></em> ()</code></span></td><td align=right><b>progn</b>
</td></tr>
<tr><td></td><td colspan=2>
called when the selection finishes playing.  See popup.scm.
</td></tr>

<!-- transform-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="ffthook">transform-hook</a></em> (snd chn scaler)</code></span></td><td>
</td></tr>

<tr><td></td><td colspan=2>
called just after an FFT (or spectrum) is calculated.
</td></tr>

<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (fft-peak snd chn scale)
  (if (and (transform-graph?) 
           (= (transform-graph-type) graph-once))
      (report-in-minibuffer 
        (number-&gt;string (/ (* 2 (vct-peak (transform-samples-&gt;vct snd chn))) 
                           (transform-size snd chn))))))
(add-hook! <em class=red>transform-hook</em> fft-peak)
</pre></td></tr></table>
</td></tr><tr><td colspan=3></td></tr>

<!-- update-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="updatehook">update-hook</a></em> (snd)</code></span></td><td align=right><b>or</b>
</td></tr>

<tr><td></td><td colspan=2>
update-hook is called just before a sound is updated (re-read from the disk, flushing the current version; this
is useful if you overwrite a sound file while viewing it in Snd). 
The update process can be triggered by a variety of situations, not just by <a href="#sndupdate">update-sound</a>. 
The hook is passed the sound's index.  If it returns #t, the update is cancelled (this is not 
recommended!); if it returns a procedure of one argument, that procedure is called upon 
completion of the update operation; its argument is the (possibly different) sound index. 
Snd tries to maintain the index across the update, but if you change the number of channels 
the newly updated sound may have a different index.  <i>add-mark-pane</i> in snd-motif.scm uses
the returned procedure to make sure the mark pane is reactivated right away when a sound is updated. The basic idea is:
</td></tr>

<tr><td></td><td colspan=2>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! <em class=red>update-hook</em>
  (lambda (snd-about-to-be-udpated)
    ;; this function called just before update
    (lambda (updated-snd)
      ;; this code executed when update is complete
      (snd-print "ok!"))))
</pre></td></tr></table>
</td></tr><tr><td colspan=3></td></tr>

<!-- window-property-changed-hook -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="windowpropertychangedhook">window-property-changed-hook</a></em> (command)</code></span></td><td align=right><b>or</b>
</td></tr>
<tr><td></td><td colspan=2>
called when Snd sees a SND_COMMAND window property change.
If it returns #t, the command is not evaluated.  (This is mostly an internal debugging hook).
</td></tr>
<tr><td colspan=3></td></tr>

</table>

<pre>
  <h4>Channel-specific hooks:</h4>

  <em class=def><a name="edithook">edit-hook</a></em> (<i>snd chn</i>)
  <em class=def><a name="undohook">undo-hook</a></em> (<i>snd chn</i>)
  <em class=def><a name="afteredithook">after-edit-hook</a></em> (<i>snd chn</i>)
</pre>

<table border=0><tr><td width=150><br></td><td>
These are functions that return the hooks in question associated with the specified channel.
The functions on these hooks are thunks -- they should take no arguments.
edit-hook is called just before any attempt to edit the channel's data; if it returns #t,
the edit is cancelled. So,
</td></tr></table>
<center><pre>
  (add-hook! (<em class=red>edit-hook</em>) (lambda () #t))
</pre></center>
<table border=0><tr><td width=150><br></td><td>
halts any attempt to edit the data; this is even more restrictive than setting the read-only
flag because the latter only refuses to overwrite the current data.  undo-hook is called
just after any undo, redo, or revert that affects the channel.  after-edit-hook is called
after an edit, but before after-graph-hook (<a href="sndscm.html#addmarkpane">add-mark-pane</a> in snd-motif.scm 
uses this hook to update a mark list after each edit
so that the displayed mark positions are correct).
You can use edit-hook to set
up protected portions of the edit history:
</td></tr></table>
<br>
<center><table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define protect
  "(protect #:optional snd chn) disallows any edits before the current one"
  (lambda args
    (let* ((edit-pos (apply edit-position args))
           (hook (apply <em class=red>edit-hook</em> args)))
      (reset-hook! hook)
      (add-hook! hook 
        (lambda ()
          (let ((val (&lt; (apply edit-position args) edit-pos)))
            (if val (report-in-minibuffer "protected"))
            val))))))

(define unprotect 
  "(unprotect #:optional snd chn) allows edits at any edit history position"
  (lambda args 
    (reset-hook! (apply <em class=red>edit-hook</em> args))))
</pre></td></tr></table></center>

<p><a href="sndscm.html#enveddoc">enved.scm</a> uses several of these hooks to implement an envelope editor in lisp.
<i>add-mark-pane</i> in snd-motif.scm uses them to make sure the mark list reflects the current edit history location.
See also <a href="#menuhook">menu-hook</a> and autosave.scm.
</p>
<p>
You can find out what's on a given hook with the following (which is mostly adding carriage returns to the
printout from hook-&gt;list):
</p>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (describe-hook hook)
  (for-each 
    (lambda (n) 
      (snd-print (format #f "~A~%" n)))
    (reverse (<em class=red>hook-&gt;list</em> hook))))
</pre></td></tr></table>

<p>Say we pile up some random stuff on name-click-hook:
</p>
<pre>
(add-hook! name-click-hook snd-print)
(add-hook! name-click-hook (lambda (n) (snd-print n)))
(add-hook! name-click-hook (let ((ha 32)) (lambda (n) ha)))
</pre>
<p>Then we go skiing for a week, get home, and can't remember where
we were.  Do we panic and dial 911? No!  We simply type:
</p>
<pre>
<em class=listener>:</em><em class=typing>(describe-hook name-click-hook)</em>
<em class=listener>#&lt;primitive-procedure snd-print&gt;
#&lt;procedure (n) (snd-print n)&gt;
#&lt;procedure (n) ha&gt;
#&lt;unspecified&gt;
:</em>
</pre>
<p>These hooks are extremely easy to add; if there's some user-interface action
you'd like to specialize in some way, send me a note.  I'm slowly replacing
many of the global variables with hooks, since the latter are much more
flexible.  hooks.scm has snd-hooks and reset-all-hooks, as well as other
useful hook-related functions.
</p>

<br>
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="sndobjects">Snd's objects</a></h3></td></tr></table>

<p>Snd presents its various data structures as a list
of sounds, each with a list of channels, each with lists of edits,
marks, and mixes.  The sound data itself is accessed through
a variety of structures and functions, each aimed at a particular
kind of use.  One of the most commonly used is the <i>vct</i>.
But before launching into vcts, I need to explain a few things
about the following documentation.
</p>

<p>In the following lists, optional arguments are in italics (although
netscape sometimes displays them in bold face for some reason).
Each sound has an
associated index used to refer to it in all the
functions.  This arbitrary number is more
or less related to the sound's position in the
display of sounds (if the variable <a href="#showindices">show-indices</a> is #t,
the index is displayed in front of the sound's name).
In the argument lists
below, <i>snd</i> as an argument refers to the sound's index, and defaults to the currently
selected sound.  Similarly, <i>chn</i> is the channel number, starting from 0, and defaults
to the currently selected channel.  So if there's only one sound active (say it's index is 0), and it has only
one channel, (cursor) (cursor 0), and (cursor 0 0) all refer to the same
thing.  If you want to refer to the currently selected sound, either use #f
as the sound index or <a href="#sndselectedsound">selected-sound</a>.
</p>
<p>
If the <i>snd</i> argument is a list, the first element of the list is
taken to be a mix id number, and the reference is to the underlying mix input
sound data.  That is, (frames 1) returns the number of frames (samples per channel)
in the sound whose current index is 1; (frames (list 1)) returns the frames in
the sound that underlies the mix whose id is 1.  Similarly (scale-by .5) scales
the currently selected sound by .5; (scale-by .5 (list 0) 2) scales the 3rd channel
of mix 0's input sound by .5.  I keep saying "underlying" because normally a
mix is viewed after it has gone through its panel of controls (the set of widgets displayed
in the Mix Panel dialog -- these can affect the
amplitude, amplitude envelope, and sampling rate).  next-mix-sample, for
example, refers to the processed form of the mix data, whereas next-sample
would refer to the original form.  I may extend this to accept a list of mixes (i.e. a "track" 
in the terminology of mix.scm).
</p>

<p>In many cases, the <i>snd</i>, <i>chn</i>, and <i>reg</i> arguments
can be #t (for backwards compatibility, a few of them default to #t).
#t means "all" in this case; if <i>snd</i> is #t, all sounds are included,
so, for example, <code>(expand-control #t)</code> returns a list of the current
control panel expansion settings of all sounds, and
<code>(set! (transform-graph? #t #t) #t)</code>
turns on the fft display in all channels of all sounds.
</p>

<p>When an error occurs, in most cases the function throws a tag such as 'no-such-sound,
'no-active-selection, etc.
All the functions that take sound and channel args (<i>snd chn</i> below) can return the errors
'no-such-sound and 'no-such-channel; all the mix-related functions can return 'no-such-mix;
all the region-related functions can return 'no-such-region; all selection-oriented functions
can return 'no-active-selection. To reduce clutter, I'll omit mention
of these below.  
</p>

<br>
<!-- INDEX Vcts:Vcts -->
<table width="100%" border=1><tr><td bgcolor="lightgreen" valign="middle"><h3><A NAME="Vcts">Vcts</a></h3></td></tr></table>
<p>
Many of the Snd and CLM functions handle vectors (arrays) of data.
By defining a new vector type, named vct, and providing a package
of old-style array-processing calls upon that type, we can speed up many
operations by a factor of 30.  This is enough of a difference to warrant
the added complexity, I think.  A vct can be viewed as a vector;
to make one, call <i>make-vct</i>.  It is freed by the
garbage collector when it can't be referenced any further.  To get 
an element of a vct, use <i>vct-ref</i>; similarly <i>vct-set!</i>
sets an element (the "!" appended to the setter functions is standard in Scheme;
another is the use of "?" where Common Lisp is more likely to use "-p").
Once created, a vct can be passed to a variety of built-in
functions:</p>
<pre>
  (define hi (make-vct 100))
  (vct-fill! hi 3.14)
  (vct-scale! hi -1.0)
</pre>
<p>Now our vct <i>hi</i> has 100 -3.14's. </p>

<!-- -------------------------------- VCT TABLE -------------------------------- -->

<table border=0 cellspacing=5>

<!-- list->vct -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndlist2vct">list-&gt;vct</a></em> (lst)</code></span></td></tr>
<tr><td width=100></td><td>return vct with elements of list <i>lst</i></td></tr>

<!-- make-vct -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="makevct">make-vct</a></em> (len (initial-element 0.0))</code></span></td></tr>
<tr><td></td><td>create vct of size <i>len</i>.</td></tr>

<!-- sound-date->vct -->
<tr><td colspan=2><span class=defbox><code><em class=def>sound-data-&gt;vct</em> (sdobj (chan 0) (v #f))</code></span></td></tr>
<tr><td></td><td>place sound-data channel data in vct, returning <i>v</i> or the new vct.</td></tr>

<!-- vct -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndvct">vct</a></em> args...</code></span></td></tr>
<tr><td></td><td>list-&gt;vct with args as the list: <code>(vct 1 2 3)</code> = <code>(list-&gt;vct '(1 2 3))</code></td></tr>

<!-- vct? -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="vctp">vct?</a></em> (v)</code></span></td></tr>
<tr><td></td><td>#t if <i>v</i> is a vct.</td></tr>

<!-- vct-add! -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="vctadd">vct-add!</a></em> (v1 v2 (off 0))</code></span></td></tr>
<tr><td></td><td>element-wise add: <code>v1[i + off] += v2[i]</code>, returns <i>v1</i>.</td></tr>

<!-- vct-copy -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="vctcopy">vct-copy</a></em> (v)</code></span></td></tr>
<tr><td></td><td>return a copy of <i>v</i>.</td></tr>

<!-- vct-fill! -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="vctfill">vct-fill!</a></em> (v val)</code></span></td></tr>
<tr><td></td><td>set each element of <i>v</i> to <i>val</i>, <code>v[i] = val</code>, returns <i>v</i>.</td></tr>

<!-- vct-length -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="vctlength">vct-length</a></em> (v)</code></span></td></tr>
<tr><td></td><td>return length of <i>v</i>.</td></tr>

<!-- vct-map -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="vctmap1">vct-map</a></em> (thunk v0 vcts...)</code></span></td></tr>
<tr><td></td><td>map 'thunk' (which should return a frame) into the vcts passed as trailing args.</td></tr>

<!-- vct-map! -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="vctmap">vct-map!</a></em> (v proc)</code></span></td></tr>
<tr><td></td><td>set each element of <i>v</i> to the value returned by (<i>proc</i>); <code>(vct-map! v (lambda () 3.0))</code>
is the same as <code>(vct-fill! v 3.0)</code>.
</td></tr>

<!-- vct-move! -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="vctmove">vct-move!</a></em> (v new old (backwards #f))</code></span></td></tr>
<tr><td></td></tr><tr><td></td><td><code>v[new++] = v[old++]</code>, returns v (if <i>backwards</i> is #t, <code>v[new--] = v[old--]</code>)</td></tr>

<!-- vct-multiply! -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="vctmultiply">vct-multiply!</a></em> (v1 v2)</code></span></td></tr>
<tr><td></td><td>element-wise multiply: <code>v1[i] *= v2[i]</code>, returns v1.</td></tr>

<!-- vct-offset! -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="vctoffset">vct-offset!</a></em> (v val)</code></span></td></tr>
<tr><td></td><td>add <i>val</i> to each element of <i>v</i>:  <code>v[i] += val</code>, returns v.</td></tr>

<!-- vct-peak -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="vctpeak">vct-peak</a></em> (v)</code></span></td></tr>
<tr><td></td><td>maximum of absolute value of all elements of <i>v</i></td></tr>

<!-- vct-ref -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="vctref">vct-ref</a></em> (v pos)</code></span></td></tr>
<tr><td></td><td>element <i>pos</i> in <i>v</i>: <code>v[pos]</code>.</td></tr>

<!-- vct-scale! -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="vctscale">vct-scale!</a></em> (v scl)</code></span></td></tr>
<tr><td></td><td>multiply each element of <i>v</i> by <i>scl</i>: <code>v[i] *= scl</code>, returns v.</td></tr>

<!-- vct-set! -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="vctset">vct-set!</a></em> (v pos val)</code></span></td></tr>
<tr><td></td><td>set element <i>pos</i> of <i>v</i> to <i>val</i>: <code>v[pos] = val</code>. same as <code>(set! (vct-ref v pos) val)</code>.</td></tr>

<!-- vct-subtract! -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="vctsubtract">vct-subtract!</a></em> (v1 v2)</code></span></td></tr>
<tr><td></td><td>element-wise subtract: <code>v1[i] -= v2[i]</code>, returns v1.</td></tr>

<!-- vct-subseq -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="vctsubseq">vct-subseq</a></em> (v start (end len) (nv #f))</code></span></td></tr>
<tr><td></td><td>return a new vct (or <i>nv</i> if given) with the elements of <i>v</i> between <i>start</i> and <i>end</i> inclusive.  <i>end</i> defaults
to the end of <i>v</i>.</td></tr>

<!-- vct->channel -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="vct2channel">vct-&gt;channel</a></em> (v (beg 0) (dur len) (snd #f) (chn #f) (edpos #f))</code></span></td></tr>
<tr><td></td><td>
set the samples from <i>beg</i> to <i>beg+dur</i> from the values in <i>v</i>.
This is the <a href="#regularizedargs">regularized</a> version of <a href="#vct2samples">vct-&gt;samples</a>.
</td></tr>

<!-- vct->list -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="vct2list">vct-&gt;list</a></em> (v)</code></span></td></tr>
<tr><td></td><td>return list with elements of <i>v</i></td></tr>

<!-- vct->samples -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="vct2samples">vct-&gt;samples</a></em> (samp samps data (snd #f) (chn #f))</code></span></td></tr>
<tr><td></td><td>A synonym for <a href="#sndsetsamples">set-samples</a>, but you can also pass just a vct as the first argument, or a start
sample and a vct as the second argument.  This is too confusing!  Use <a href="#vct2channel">vct-&gt;channel</a> instead.
<pre>(define v (samples-&gt;vct))
(vct-scale! v 2.0)
(vct-&gt;samples v)</pre></td></tr>

<!-- vct->sound-data -->
<tr><td colspan=2><span class=defbox><code><em class=def>vct-&gt;sound-data</em> (v sd (chan 0))</code></span></td></tr>
<tr><td></td><td>place vct <i>v</i> data in sound-data <i>sd</i>, returning sd</td></tr>

<!-- vct->sound-file -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="vct2soundfile">vct-&gt;sound-file</a></em> (fd v vals)</code></span></td></tr>
<tr><td></td>
<td>write <i>vals</i> floats from <i>v</i> to <i>fd</i>.  This is intended for use with <a href="#sndopensoundfile">open-sound-file</a></td></tr>

<!-- vct-&gt;vector -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndvct2vector">vct-&gt;vector</a></em> (v)</code></span></td></tr>
<tr><td></td><td>return vector with elements of <i>v</i></td></tr>

<!-- vector-&gt;vct -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndvector2vct">vector-&gt;vct</a></em> (vect)</code></span></td></tr>
<tr><td></td><td>return vct with elements of vector <i>vect</i></td></tr>

</table>

<p>Many of the functions described below can take a vct as an argument; 
there are also several functions that create and fill vcts with data:</p>
<pre>
  <a href="#sndregionsamples2vct">region-samples-&gt;vct</a>
  <a href="#samples2vct">samples-&gt;vct</a>
  <a href="#transformsamples2vct">transform-samples-&gt;vct</a>
  <a href="#channel2vct">channel-&gt;vct</a>
  <a href="sndscm.html#mix2vct">mix-&gt;vct</a>
  <a href="#sounddata2vct">sound-data-&gt;vct</a>
  <a href="sndscm.html#track2vct">track-&gt;vct</a>
  <a href="#sndvector2vct">vector-&gt;vct</a>
</pre>
<p>There is one slightly
unusual function in this family: <i>vct-map!</i>.
This is a do-loop (or for-each) over a vct, calling some 
function to get the values to assign into the vct.  For example</p>
<pre>
  (vct-map! out-data (lambda () 
                       (convolve cnv (lambda (dir) 
                                       (read-sample sf)))))
</pre>
<p>in the cnvtest function in <a href="sndscm.html#exampdoc">examp.scm</a> is calling the convolve generator and
assigning the result to each successive member of the out-data vct.
We can use vcts to write new sound files:</p>
<pre>
  <em class=def>open-sound-file</em> (name chans srate comment)   ; returns fd
  <em class=def>vct-&gt;sound-file</em> (fd vct vals)                ; writes vals floats to fd
  <em class=def>close-sound-file</em> (fd vals)
</pre>
<p>After opening the file, loop through the data calling samples-&gt;vct, deal with the
vct data as desired, write the samples to the file via vct-&gt;sound-file, then
when finished, close-sound-file.  If the new data is to replace the old,
call (set! (samples...) data) with the new sound file's name; otherwise call insert-samples.
</p>
<p>If you have Guile 1.4.1 or later, it's possible to access a vct's
elements with the syntax (v index), equivalent to (vct-ref v index),
but without some of the type checks.
This is using a feature called "applicable smobs" in Guile.
The clm generators also use this syntax:
</p>
<pre>
  &gt;<em class=typing>(define hi (make-oscil 440.0))</em>
  <em class=listener>#&lt;unspecified&gt;</em>
  &gt;<em class=typing>(hi)</em>
  <em class=listener>0.0</em>
  &gt;<em class=typing>(oscil hi)</em>
  <em class=listener>0.125050634145737</em>
</pre>
<p>It's no accident that the generator's type (i.e. oscil or whatever)
is hidden here.  We can make a generator that is either
an oscil or a sawtooth-wave:
</p>
<pre>
  &gt;<em class=typing>(define sine-or-sawtooth
     (lambda (sine)
        (let ((gen ((if sine make-oscil make-sawtooth-wave) 440.0)))
           (lambda (fm)
              (gen fm)))))</em>
  <em class=listener>#&lt;unspecified&gt;</em>
  &gt;<em class=typing>(define osc (sine-or-sawtooth #t))</em>
  <em class=listener>#&lt;unspecified&gt;</em>
  &gt;<em class=typing>(osc 0.0)</em>
  <em class=listener>0.0</em>
  &gt;<em class=typing>(osc 0.0)</em>
  <em class=listener>0.125050634145737</em>
</pre>

<br>
<table width="100%" border=1><tr><td bgcolor="lightgreen" valign="middle"><h3><A NAME="sndsounddata">Sound-data and Sndlib</a></h3></td></tr></table>

<p>Another sound data object is the sound-data array used in Sndlib.</p>

<!-- -------------------------------- SOUND-DATA TABLE -------------------------------- -->

<table border=0 cellspacing=10>

<tr><td colspan=2><span class=defbox><code><em class=def><a name="makesounddata">make-sound-data</a></em> (chans frames)</code></span></td></tr>
<tr><td><spacer type=horizontal size=40><br>
</td><td>return a sound-data object with <i>chans</i> arrays, each of length <i>frames</i></td></tr>

<tr><td colspan=2><span class=defbox><code><em class=def><a name="sounddataref">sound-data-ref</a></em> (obj chan frame)</code></span></td></tr>
<tr><td></td><td>return (as a float) the sample in channel <i>chan</i> at location <i>frame</i></td></tr>

<tr><td colspan=2><span class=defbox><code><em class=def><a name="sounddataset">sound-data-set!</a></em> (obj chan frame val)</code></span></td></tr>
<tr><td></td><td>set <i>obj</i>'s sample at <i>frame</i> in <i>chan</i> to (the float) <i>val</i></td></tr>

<tr><td colspan=2><span class=defbox><code><em class=def><a name="sounddata?">sound-data?</a></em> (obj)</code></span></td></tr>
<tr><td></td><td>#t if <i>obj</i> is of type sound-data</td></tr>

<tr><td colspan=2><span class=defbox><code><em class=def><a name="sounddatalength">sound-data-length</a></em> (obj)</code></span></td></tr>
<tr><td></td><td>length (in samples) of each channel of data in <i>obj</i></td></tr>

<tr><td colspan=2><span class=defbox><code><em class=def><a name="sounddatamaxamp">sound-data-maxamp</a></em> (obj)</code></span></td></tr>
<tr><td></td><td>list of maxamps (one for each channel) of data in <i>obj</i></td></tr>

<tr><td colspan=2><span class=defbox><code><em class=def><a name="sounddatachans">sound-data-chans</a></em> (obj)</code></span></td></tr>
<tr><td></td><td>number of channels of data in <i>obj</i></td></tr>

<tr><td colspan=2><span class=defbox><code><em class=def><a name="sounddata2vct">sound-data-&gt;vct</a></em> (sdobj chan vobj)</code></span></td></tr>
<tr><td></td><td>copy sound-data channel data into vct </td></tr>

<tr><td colspan=2><span class=defbox><code><em class=def><a name="vct2sounddata">vct-&gt;sound-data</a></em> (vobj sdobj chan)</code></span></td></tr>
<tr><td></td><td>copy vct data into sound-data</td></tr>
</table>

<p>All of the underlying sound library (<a href="sndlib.html">Sndlib</a>)
functions are available, as well as most of (<a href="grfsnd.html#clmfuncs">CLM</a>).
See play.scm and rtio.scm. The most important Sndlib functions for Snd are:</p>

<!-- -------------------------------- SNDLIB TABLE -------------------------------- -->

<table border=0 cellspacing=10>

<!-- mus-audio-close -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="musaudioclose">mus-audio-close</a></em> (line)</code></span></td></tr>
<tr><td><spacer type=horizontal size=40><br>
</td><td>close audio port <i>line</i></td></tr>

<!-- mus-audio-describe -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="describeaudiostate">mus-audio-describe</a></em> ()</code></span></td></tr>
<tr><td></td><td>describe audio hardware state (in help window)</td></tr>

<!-- mus-audio-error -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="audioerror">mus-audio-error</a></em> ()</code></span></td></tr>
<tr><td></td><td>return error code raised by preceding audio call (much like "errno" in C)</td></tr>

<!-- mus-audio-error-name -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="audioerror-name">mus-audio-error-name</a></em> (er)r</code></span></td></tr>
<tr><td></td><td>string description of error <i>code</i></td></tr>

<!-- mus-audio-mixer-read -->
<tr><td colspan=2><span class=defbox><code><em class=def>
<a name="musaudiomixerread">mus-audio-mixer-read</a></em> (device field channel vals)</code></span></td></tr>
<tr><td></td>
<td>read current state of <i>device</i>'s <i>field</i>:
</td></tr>
<tr><td></td><td>
<pre>
  mus-audio-amp         mus-audio-srate    mus-audio-channel mus-audio-format
  mus-audio-imix        mus-audio-igain    mus-audio-reclev  mus-audio-pcm 
  mus-audio-ogain       mus-audio-line     mus-audio-synth   mus-audio-bass
  mus-audio-direction   mus-audio-port     mus-audio-pcm2    mus-audio-treble
  mus-audio-samples-per-channel
</pre>
</td></tr>

<!-- mus-audio-mixer-write -->
<tr><td colspan=2><span class=defbox><code><em class=def>
<a name="musaudiomixerwrite">mus-audio-mixer-write</a></em> (device field channel vals)</code></span></td></tr>
<tr><td></td>
<td>set state of <i>device</i>'s <i>field</i>.
</td></tr>
<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
;;; here we get the microphone volume, then set it to .5
(define vals (make-vector 32))
(<em class=red>mus-audio-mixer-read</em> mus-audio-microphone mus-audio-amp 0 vals)
(vector-ref vals 0)
(vector-set! vals 0 .5)
(<em class=red>mus-audio-mixer-write</em> mus-audio-microphone mus-audio-amp 0 vals)
;;; now set the 2 "igain" fields to 1
(vector-set! vals 0 1.0)
(vector-set! vals 1 1.0)
(<em class=red>mus-audio-mixer-write</em> mus-audio-mixer mus-audio-igain 2 vals)
</pre></td></tr></table></td></tr>
<br>

<!-- mus-audio-open-input -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="musaudioopeninput">mus-audio-open-input</a></em> (device srate chans format bufsize)</code></span></td></tr>
<tr><td></td>
<td>open audio port <i>device</i> ready for input. Return -1 if the open failed.  <i>device</i> is one of:
</td></tr>
<tr><td></td><td>
<pre>
  mus-audio-default      mus-audio-duplex-default   mus-audio-line-out
  mus-audio-microphone   mus-audio-speakers         mus-audio-dac-out    
  mus-audio-aes-in       mus-audio-digital-in       mus-audio-digital-out
  mus-audio-aes-out      mus-audio-dac-filter       mus-audio-mixer
  mus-audio-line2        mus-audio-line3            mus-audio-aux-input 
  mus-audio-line-in      mus-audio-aux-output       mus-audio-adat-in
  mus-audio-adat-out     mus-audio-line1            mus-audio-cd 
  mus-audio-spdif-in     mus-audio-spdif-out
</pre>
</td></tr>

<!-- mus-audio-open-output -->
<tr><td colspan=2><span class=defbox><code><em class=def>
<a name="musaudioopenoutput">mus-audio-open-output</a></em> (device srate chans format bufsize)</code></span></td></tr>
<tr><td></td>
<td>open audio port <i>device</i> ready for output.  Return -1 if the open failed. </td></tr>

<!-- mus-audio-read -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="musaudioread">mus-audio-read</a></em> (line sdata frames)</code></span></td></tr>
<tr><td></td><td>read <i>frames</i> of data into sound-data object <i>sdata</i> from port <i>line</i>.  The in-coming data format
is set by the corresponding mus-audio-open-input call and is translated to the sound-data format (internally known as
mus_sample_t) by mus-audio-read.</td></tr>

<!-- mus-audio-restore -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="musaudiorestore">mus-audio-restore</a></em> ()</code></span></td></tr>
<tr><td></td><td>restore a previously saved audio hardware state (unimplemented in many cases)</td></tr>

<!-- mus-audio-save -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="musaudiosave">mus-audio-save</a></em> ()</code></span></td></tr>
<tr><td></td><td>save the current audio hardware state (unimplemented in many cases)</td></tr>

<!-- mus-audio-sun-outputs -->
<tr><td colspan=2><span class=defbox><code><em class=def>mus-audio-sun-outputs</em> (speakers headphones line-out)</code></span></td></tr>
<tr><td></td>
<td>(Sun only)
set the current Sun audio outputs.
Each entry should be either 0 (turn off device) or 1 (turn it on).
</td></tr>

<!-- mus-audio-write -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="musaudiowrite">mus-audio-write</a></em> (line sdata frames)</code></span></td></tr>
<tr><td></td><td>write <i>frames</i> of data from sound-data <i>sdata</i> to audio port <i>line</i>.  As with mus-audio-read,
the out-going data format is set by mus-audio-open-output, and the sound-data's data is translated to that
format by mus-audio-write.</td></tr>

<!-- mus-data-format-name -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="soundformatname">mus-data-format-name</a></em> (format)</code></span></td></tr>
<tr><td></td><td>convert <i>format</i> from an integer to a string, e.g. "16-bit big endian linear".  The sndlib data formats are:</td></tr>
<tr><td></td><td>
<pre>
  mus-bshort   mus-lshort   mus-mulaw   mus-alaw   mus-byte  
  mus-lfloat   mus-bint     mus-lint    mus-b24int mus-l24int
  mus-ubshort  mus-ulshort  mus-ubyte   mus-bfloat mus-bdouble 
  mus-ldouble
</pre></td></tr>

<!-- mus-expand-filename -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="musexpandfilename">mus-expand-filename</a></em> (name)</code></span></td></tr>
<tr><td></td><td>expand <i>name</i> into its 'absolute' pathname; that is, replace '~' with the current home directory,
and whatever else seems appropriate.</td></tr>

<!-- mus-file-prescaler -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="musfileprescaler">mus-file-prescaler</a></em> (fd)</code></span></td></tr>
<tr><td></td><td>The prescaling value for reading data from the sndlib file descriptor <i>fd</i>.
If you're reading float data that is extremely soft (i.e. max amp
below .001), the transfer to integer form in sndlib can cause bits
to be lost, resulting in hiss.  In this case set the prescaler for
the file to 1000.0 or so to get the data into a more normal
range.  Since the set of mus-file-prescaler should come just after opening
the sound file, but before trying to read any data, you need to use it in the context of <a href="#duringopenhook">during-open-hook</a>.
A similar low-level sndlib function is <em class=def>mus-file-data-clipped</em>.
</td></tr>

<!-- mus-header-type-name -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="soundtypename">mus-header-type-name</a></em> (type)</code></span></td></tr>
<tr><td></td><td>convert <i>type</i>, an integer, to a string, e.g. "AIFF".  Some of the sndlib header types are:</td></tr>
<tr><td colspan=2><pre>
  mus-next  mus-aifc  mus-riff  mus-nist  mus-raw  mus-ircam  mus-aiff mus-bicsf mus-soundfont mus-voc mus-svx
</pre></td></tr>

<!-- mus-sound-chans -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="soundchans">mus-sound-chans</a></em> (filename)</code></span></td></tr>
<tr><td></td><td>number of channels in <i>filename</i> (settable)</td></tr>

<!-- mus-sound-close-input -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="mussoundcloseinput">mus-sound-close-input</a></em> (fd)</code></span></td></tr>
<tr><td></td><td>close sound file</td></tr>

<!-- mus-sound-close-output -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="mussoundcloseoutput">mus-sound-close-output</a></em> (fd bytes)</code></span></td></tr>
<tr><td></td><td>close sound file and update its length indication, if any</td></tr>

<!-- mus-sound-comment -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="soundcomment">mus-sound-comment</a></em> (filename)</code></span></td></tr>
<tr><td></td><td>header comment, if any</td></tr>

<!-- mus-sound-data-format -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sounddataformat">mus-sound-data-format</a></em> (filename)</code></span></td></tr>
<tr><td></td><td>data format (e.g. <i>mus-bshort</i>) (settable)</td></tr>

<!-- mus-sound-data-location -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sounddatalocation">mus-sound-data-location</a></em> (filename)</code></span></td></tr>
<tr><td></td><td>location of first sample (bytes) (settable)</td></tr>

<!-- mus-sound-duration -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="soundduration">mus-sound-duration</a></em> (filename)</code></span></td></tr>
<tr><td></td><td>duration of sound in seconds</td></tr>

<!-- mus-sound-forget -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="soundforget">mus-sound-forget</a></em> (filename)</code></span></td></tr>
<tr><td></td><td>remove <i>filename</i> from the sound cache (presumably the file has been deleted or something).</td></tr>

<!-- mus-sound-frames -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="soundframes">mus-sound-frames</a></em> (filename)</code></span></td></tr>
<tr><td></td><td>frames of sound according to header (can be incorrect)</td></tr>

<!-- mus-sound-header-type -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="soundheadertype">mus-sound-header-type</a></em> (filename)</code></span></td></tr>
<tr><td></td><td>header type (e.g. <i>mus-aifc</i>) (settable)</td></tr>

<!-- mus-sound-length -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="soundlength">mus-sound-length</a></em> (filename)</code></span></td></tr>
<tr><td></td><td>true file length (bytes)</td></tr>

<!-- mus-sound-loop-info -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="soundloopinfo">mus-sound-loop-info</a></em> (filename)</code></span></td></tr>
<tr><td></td><td>loop info.  <a href="sndscm.html#exmarkloops">mark-loops</a> in examp.scm uses this to place a mark at each loop point.
</td></tr>

<!-- mus-sound-maxamp -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="mussoundmaxamp">mus-sound-maxamp</a></em> (filename)</code></span></td></tr>
<tr><td></td><td>a list of max amps and locations thereof.  The corresponding set! 
affects only the sndlib table of sound file info, not the sound file itself.</td></tr>

<!-- mus-sound-maxamp-exists? -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="mussoundmaxampexists">mus-sound-maxamp-exists?</a></em> (filename)</code></span></td></tr>
<tr><td></td><td>#t if the sound's maxamp data is available
in the sound cache; if it isn't, a call on mus-sound-maxamp has to open and read the data to get the maxamp.
</td></tr>

<!-- mus-sound-open-input -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="mussoundopeninput">mus-sound-open-input</a></em> (filename)</code></span></td></tr>
<tr><td></td><td>open filename (a sound file) returning an integer ("fd" below)</td></tr>

<!-- mus-sound-open-output -->
<tr><td colspan=2><span class=defbox><code><em class=def>
<a name="mussoundopenoutput">mus-sound-open-output</a></em> (filename srate chans data-format header-type comment)</code></span></td></tr>
<tr><td></td>
<td>create a new sound file with the indicated attributes, return "fd"</td></tr>

<!-- mus-sound-prune -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="soundprune">mus-sound-prune</a></em> ()</code></span></td></tr>
<tr><td></td><td>remove all defunct (non-existent) files from the sound cache.</td></tr>

<!-- mus-sound-read -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="mussoundread">mus-sound-read</a></em> (fd beg end chans sdata)</code></span></td></tr>
<tr><td></td>
<td>read data from sound file <i>fd</i> loading the data array from beg
to end. <i>sdata</i> is a sound-data object that should be able to
accommodate the read</td></tr>

<!-- mus-sound-reopen-output -->
<tr><td colspan=2><span class=defbox><code><em class=def>
<a name="mussoundreopenoutput">mus-sound-reopen-output</a></em> (filename chans data-format header-type data-location)</code></span></td></tr>
<tr><td></td>
<td>reopen filename, ready to continue output.</td></tr>

<!-- mus-sound-report-cache -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="mussoundreportcache">mus-sound-report-cache</a></em> (file)</code></span></td></tr>
<tr><td></td><td>print the current sound header data table to the file given or stdout if none is specified.</td></tr>

<!-- mus-sound-samples -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="soundsamples">mus-sound-samples</a></em> (filename)</code></span></td></tr>
<tr><td></td><td>number of samples in sound according to header (can be incorrect) (settable)</td></tr>

<!-- mus-sound-seek-frame -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="mussoundseekframe">mus-sound-seek-frame</a></em> (fd frame)</code></span></td></tr>
<tr><td></td><td>move to <i>frame</i> in sound file <i>fd</i></td></tr>

<!-- mus-sound-srate -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="soundsrate">mus-sound-srate</a></em> (filename)</code></span></td></tr>
<tr><td></td><td>sampling rate (settable)</td></tr>

<!-- mus-sound-write -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="mussoundwrite">mus-sound-write</a></em> (fd beg end chans sdata)</code></span></td></tr>
<tr><td></td>
<td>write data to sound file <i>fd</i></td></tr>

<!-- mus-sound-write-date -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="soundwritedate">mus-sound-write-date</a></em> (filename)</code></span></td></tr>
<tr><td></td><td>sound's write date:
</td></tr><tr><td></td><td>
<pre>
    :<em class=typing>(strftime "%d-%b %H:%M %Z" (localtime (mus-sound-write-date "oboe.snd")))</em>
    <em class=listener>"18-Oct 06:56 PDT"</em>
</pre></td></tr>

<!-- mus-audio-set-oss-buffers -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="setossbuffers">mus-audio-set-oss-buffers</a></em> (num size)</code></span></td></tr>
<tr><td></td><td>in Linux (OSS), this sets the number and size of the OSS fragments.
The default (as of 21-May-01) is to accept whatever OSS chooses: I believe this is normally
equivalent to <code>(mus-audio-set-oss-buffers 16 12)</code>.  This default makes the control panel controls very sluggish.  
Snd used to call <code>(mus-audio-set-oss-buffers 4 12)</code> as its default, 
but this seems to cause trouble for a variety of new sound cards.
My initialization file includes <code>(mus-audio-set-oss-buffers 2 12)</code>.</td></tr>

</table>

<p>See <a href="sndlib.html">Sndlib</a> for more information on these functions. When called from Snd, these
throw 'mus-error upon encountering an error, rather than returning -1 like the underlying sndlib functions.
</p>
<p>The following function uses the sndlib functions to mimic the 'info' popup menu option (see <a href="sndscm.html#exampdoc">examp.scm</a> for a version that uses format):</p>

<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
<A NAME="sndinfo"></a>
(define info 
  (lambda (file)
    (string-append 
     file
     ": chans: " (number-&gt;string (<a href="#soundchans">mus-sound-chans</a> file))
     ", srate: " (number-&gt;string (<a href="#soundsrate">mus-sound-srate</a> file))
     ", " (<a href="#soundtypename">mus-header-type-name</a> (<a href="#soundheadertype">mus-sound-header-type</a> file))
     ", " (<a href="#soundformatname">mus-data-format-name</a> (<a href="#sounddataformat">mus-sound-data-format</a> file))
     ", len: " (number-&gt;string 
                (/ (<a href="#soundsamples">mus-sound-samples</a> file) 
                   (* (<a href="#soundchans">mus-sound-chans</a> file) (<a href="#soundsrate">mus-sound-srate</a> file)))))))
</pre></td></tr></table>
<br>

<br>
<table width="100%" border=1><tr><td bgcolor="lightgreen" valign="middle"><h3><A NAME="samplereaders">Sample-readers</a></h3></td></tr></table>
<p>
The simplest data access function is <a href="#sndsample">sample</a> which returns the sample at
a given position in a sound's channel.  This simplicity, however, comes at
a price in computation:  if the desired sample is not in Snd's
in-core (already loaded) view of the data, it has to go get the sample,
which can sometimes require that it open, read, and close a sound file.
The result is that <i>sample</i> will bring your code
to a grinding halt.  There are two alternatives, leaving aside the scanning
and mapping functions mentioned below.  One involves keeping the buffer of
data around explicitly (<i>samples-&gt;vct</i>), and the other involves the
use of a special object known as a <i>sample-reader</i>.  The sample-reader
returns the next sample in its sound each time it is called; this kind
of access is sometimes called an "enumerator".
The buffer approach (<i>samples-&gt;vct</i> in <a href="grfsnd.html#expsrc">expsrc</a>)
is better if you're jumping around in the data, the sample-by-sample approach (examp.scm has examples) if you're treating
the data as a sequence of samples.
To get a sample reader,
you create a reader (via <i>make-sample-reader</i>) giving it the start position, the sound and channel
to read, and the initial read direction, then get data via <i>read-sample</i> (which remembers the
read direction passed to make-sample-reader), or <i>next-sample</i> (read forward) and
<i>previous-sample</i> (read backward); when done, you can close the reader with <i>free-sample-reader</i>, 
but it's not necessary; the
garbage collector will take care of it if you forget to.
</p>
<p>
A standard way to add something to the current
data is:</p>
<pre>
   ...
   (sf (make-sample-reader start))
   ...
   (vct-map! out-data (lambda () (+ (read-sample sf) &lt;new stuff&gt;)))
   (free-sample-reader sf)
   (vct-&gt;samples start len out-data)
</pre>
<p>This is equivalent to the clm call</p>
<pre>
  (outa (+ start i) &lt;new-stuff&gt;)
</pre>
<p>but is applied as an edit to the current state in Snd. 
</p>

<p>There is a similar set of functions giving access to the mix data.
<i>make-mix-sample-reader</i> returns a mix reader for the desired mix,
<i>mix-sample-reader?</i> returns #t if its argument in a mix sample reader,
<i>next-mix-sample</i> returns the next sample (before it is mixed into
the output), and <i>free-mix-sample-reader</i> releases a reader.
Mixes can be collected into tracks, so there are also <i>make-track-sample-reader</i>, <i>track-sample-reader?</i>,
<i>next-track-sample</i>, and <i>free-track-sample-reader</i>.
As mentioned above, the mix-sample-reader refers to the mix data after
it has been processed through its control panel.  The original (possibly
edited) sound can be accessed by a normal sample-reader.
</p>

<!-- -------------------------------- SAMPLE-READER TABLE -------------------------------- -->

<table border=0 cellspacing=10>

<!-- free-mix-sample-reader -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="freemixsamplereader">free-mix-sample-reader</a></em> (obj)</code></span></td></tr>
<tr><td><spacer type=horizontal size=40><br></td>
<td>release mix-sample-reader <i>obj</i>.</td></tr>

<!-- free-sample-reader -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="freesamplereader">free-sample-reader</a></em> (obj)</code></span></td></tr>
<tr><td></td><td>release sample-reader <i>obj</i>.</td></tr>

<!-- free-track-sample-reader -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="freetracksamplereader">free-track-sample-reader</a></em> (obj)</code></span></td></tr>
<tr><td></td>
<td>release track-sample-reader <i>obj</i>.</td></tr>

<!-- inspect-sample-reader -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="inspectsamplereader">inspect-sample-reader</a></em> (obj)</code></span></td></tr>
<tr><td></td><td>This is mainly a debugging aid; it returns a string with much internal info about the sample-reader <i>obj</i>.</td></tr>

<!-- make-mix-sample-reader -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="makemixsamplereader">make-mix-sample-reader</a></em> (mix <i>beg</i>)</code></span></td></tr>
<tr><td></td>
<td>create a mix-sample-reader reading <i>mix</i> starting (in the mix input) at <i>beg</i> which defaults to 0.
See <i>mix-&gt;vct</i> in mix.scm.
</td></tr>

<!-- make-region-sample-reader -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="makeregionsamplereader">make-region-sample-reader</a></em> (<i>start reg chn dir</i>)</code></span></td></tr>
<tr><td></td>
<td>create a sample-reader reading region <i>reg</i>'s channel <i>chn</i>.
It is not safe to assume this reader will return zeros beyond the region boundaries.
</td></tr>

<!-- make-sample-reader -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="makesamplereader">make-sample-reader</a></em> (<i>start snd chn dir pos</i>)</code></span></td></tr>
<tr><td></td>
<td>
create a sample-reader reading <i>snd</i>'s channel <i>chn</i>
starting at sample <i>start</i> with initial read direction <i>dir</i> 
(1=forward, -1=backward).  <i>pos</i> is the edit history position to read 
(defaults to current position). One use of <i>pos</i> is to get the difference 
between two edits:
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define snd-diff
  (lambda () ;assume mono, get diff between current state and previous
    (let* ((index (selected-sound))
           (edit-pos (edit-position index))
           (previous-edit (<em class=red>make-sample-reader</em> 0 0 index 1 (1- edit-pos))))
      (lambda (x)
        (- x (read-sample previous-edit)) #f))))

(map-chan (snd-diff))
</pre></td></tr></table></td></tr>

<tr><td></td><td>
<i>snd</i> can also be a filename (a string); in this way a sample-reader
can read external sounds without going to the trouble of loading them into Snd.
<br><br>
<code>(define reader (make-sample-reader 100 "oboe.snd"))</code>.
</td></tr>
<tr><td colspan=2></td></tr>

<!-- make-track-sample-reader -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="maketracksamplereader">make-track-sample-reader</a></em> (track snd chn beg)</code></span></td></tr>
<tr><td></td>
<td>create a track-sample-reader reading <i>track</i>.  <i>beg</i> is the starting point of the reader within the track.
</td></tr> 

<!-- mix-sample-reader? -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="mixsamplereaderQ">mix-sample-reader?</a></em> (obj)</code></span></td></tr>
<tr><td></td><td>#t if <i>obj</i> is a mix-sample-reader.</td></tr>

<!-- next-mix-sample -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="nextmixsample">next-mix-sample</a></em>   (obj)</code></span></td></tr>
<tr><td></td><td>return next sample read by mix-sample-reader <i>obj</i>.</td></tr>

<!-- next-sample -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="nextsample">next-sample</a></em>       (obj)</code></span></td></tr>
<tr><td></td><td>return next sample (reading forward) read by sample-reader <i>obj</i>.</td></tr>

<!-- next-track-sample -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="nexttracksample">next-track-sample</a></em> (obj)</code></span></td></tr>
<tr><td></td><td>return next sample read by track-sample-reader <i>obj</i>.</td></tr>

<!-- previous-sample -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="previoussample">previous-sample</a></em>   (obj)</code></span></td></tr>
<tr><td></td><td>return previous sample in stream read by sample-reader <i>obj</i>.</td></tr>

<!-- read-sample -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="readsample">read-sample</a></em>       (obj)</code></span></td></tr>
<tr><td></td><td>return next sample (reading in the direction set by make-sample-reader) from sample-reader <i>obj</i>.</td></tr>

<!-- read-mix-sample -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="readmixsample">read-mix-sample</a></em>   (obj)</code></span></td></tr>
<tr><td></td><td>return next sample read by mix-sample-reader <i>obj</i>.</td></tr>

<!-- read-track-sample -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="readtracksample">read-track-sample</a></em> (obj)</code></span></td></tr>
<tr><td></td><td>return next sample read by track-sample-reader <i>obj</i>.</td></tr>

<!-- sample-reader-at-end? -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="samplereaderatendQ">sample-reader-at-end?</a></em> (obj)</code></span></td></tr>
<tr><td></td><td>#t if sample-reader <i>obj</i> is at the end of the sound (and hence returning 0.0 each time it is called).
See <a href="#scanagain">scan-again</a> and <a href="newcp">find-zero</a>.
</td></tr>

<!-- sample-reader-home -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="samplereaderhome">sample-reader-home</a></em> (obj)</code></span></td></tr>
<tr><td></td><td>return a list with the sound index and channel number associated with <i>obj</i>.</td></tr>

<!-- sample-reader-position -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="samplereaderposition">sample-reader-position</a></em> (obj)</code></span></td></tr>
<tr><td></td><td>current (sample-wise) location of sample-reader <i>obj</i>.  See <a href="#scanagain">scan-again</a>.
</td></tr>

<!-- sample-reader? -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="samplereaderQ">sample-reader?</a></em>    (obj)</code></span></td></tr>
<tr><td></td><td>#t if <i>obj</i> is a sample-reader.</td></tr>

<!-- track-sample-reader? -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="tracksamplereaderQ">track-sample-reader?</a></em> (obj)</code></span></td></tr>
<tr><td></td><td>#t if <i>obj</i> is a track-sample-reader.</td></tr>

</table>

<p>The <i>read-sample</i> functions can be omitted: <code>(reader)</code> is the same as <code>(read-sample reader)</code>.
</p>

<br>
<table width="100%" border=1><tr><td bgcolor="lightgreen" valign="middle"><h3><A NAME="sndmarks">Marks</a></h3></td></tr></table>

<p>A mark is an object that refers to a particular sample.
Each mark has an associated sample number (<b>mark-sample</b>), name (<b>mark-name</b>), sync value (<b>mark-sync</b>), and
a globally unique id number (returned by <b>find-mark</b> or <b>add-mark</b>).  See <a href="snd.html#marks">Marks</a>
for an overview and key bindings associated with marks.
</p>

<!-- -------------------------------- MARKS TABLE -------------------------------- -->

<table border=0 cellspacing=10>

<!-- add-mark -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndaddmark">add-mark</a></em> (sample <i>snd chn</i>)</code></span></td></tr>
<tr><td><spacer type=horizontal size=40><br></td><td>
add mark at <i>sample</i>, returning mark id.  If <i>sample</i> is out-of-range, <i>add-mark</i> throws 'no-such-sample.
</td></tr>

<!-- backward-mark -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndbackwardmark">backward-mark</a></em> (<i>count snd chn</i>)</code></span></td></tr>
<tr><td></td><td>move the cursor back <i>count</i> marks (C-j), returning mark id, or #f if none.
</td></tr>

<!-- delete-mark -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="snddeletemark">delete-mark</a></em> (<i>id</i>)</code></span></td></tr>
<tr><td></td><td>delete mark <i>id</i> (- C-m).
</td></tr>

<!-- delete-marks -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="snddeletemarks">delete-marks</a></em> (<i>snd chn</i>)</code></span></td></tr>
<tr><td></td><td>delete all marks in <i>snd</i>'s channel <i>chn</i>.
</td></tr>

<tr><td colspan=2><span class=defbox><code><em class=def><a href="#drawmarkhook">draw-mark-hook</a></em> (id)</code></span></td></tr>
<tr><td></td><td>called before a mark is drawn (discussed in the Hooks section).
</td></tr>

<!-- find-mark -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndfindmark">find-mark</a></em> (samp <i>snd chn edpos</i>)</code></span></td></tr>
<tr><td></td><td>return identifier of the mark at sample <i>samp</i> or #f if none.
This identifier is used in calls such as <a href="#sndmarksample">mark-sample</a>.  Since marks
can move around during editing, a unique 'tag' is needed to refer to a 
particular mark. <i>samp</i> can also be a string; in this case <i>find-mark</i> 
looks for a mark of that name.  <i>mark-name-&gt;id</i> in marks.scm finds a named mark in any channel (a global version of find-mark).
</td></tr>

<!-- forward-mark -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndforwardmark">forward-mark</a></em> (<i>count snd chn</i>)</code></span></td></tr>
<tr><td></td><td>move the cursor forward <i>count</i> marks (C-j), returning mark id, or #f if none.
</td></tr>

<tr><td colspan=2><span class=defbox><code><em class=def><a href="#markclickhook">mark-click-hook</a></em> (id)</code></span></td></tr>
<tr><td></td><td>called when a mark is clicked (discussed in the Hooks section).
</td></tr>

<tr><td colspan=2><span class=defbox><code><em class=def><a href="#markcolor">mark-color</a></em></code></span></td></tr>
<tr><td></td><td>color of mark indicator (default: red).
</td></tr>

<tr><td colspan=2><span class=defbox><code><em class=def><a href="#markcontext">mark-context</a></em></code></span></td></tr>
<tr><td></td><td>graphics context to use to draw a mark (XOR mode).
</td></tr>

<!-- mark-home -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="markhome">mark-home</a></em> (<i>id</i>)</code></span></td></tr>
<tr><td></td><td>a list with the sound index and channel that hold mark <i>id</i>.
mark-home provides a way to go from a mark to its sound and
channel; the inverse function is <b>marks</b>.  
</td></tr>

<tr><td colspan=2><span class=defbox><code><em class=def><a href="#markhook">mark-hook</a></em> (id snd chn reason)</code></span></td></tr>
<tr><td></td><td>called when a mark is added, deleted, moved (discussed in the Hooks section).
</td></tr>

<!-- mark-name -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmarkname">mark-name</a></em> (<i>id</i>)</code></span></td></tr>
<tr><td></td><td>name of mark <i>id</i>.
</td></tr>
<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define* (add-named-mark samp name #:optional snd chn)
  (let ((m (add-mark samp snd chn)))
    (set! (<em class=red>mark-name</em> m) name)
    m))
</pre></td></tr></table>
</td></tr>

<!-- mark-sample -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmarksample">mark-sample</a></em> (<i>id pos</i>)</code></span></td></tr>
<tr><td></td><td>sample (number) marked by mark <i>id</i> at edit history position <i>pos</i>; also <code>(set! (mark-sample id) samp)</code>.
It might be more consistent with other Snd names to call this mark-position, but I wanted to emphasize
that a mark follows its sample around as a sound is edited; that is, it marks a sample, not a position in the sound.
</td></tr>

<!-- mark-sync -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmarksync">mark-sync</a></em> (<i>id</i>)</code></span></td></tr>
<tr><td></td><td>mark <i>id</i>'s sync value (default is 0).
The sync value is very similar to
the mix track number or the sound sync field; it provides a way to group marks for simultaneous
changes.  Marks that share the same sync value (if not 0), move together when any one of them is
dragged, play together if clicked, etc.  To find which marks share a given
sync value, use <b>syncd-marks</b>; to find an unused sync value use <b>mark-sync-max</b>.
<br><br>
Marks that are syncd together can be used for insertions, and deletions, and can
set arbitrary groups of play points.  But it's a bit tedious to type (set! (mark-sync ...)...)
for each of the marks you want in the group.  The following uses the mark-clicked-hook
instead; you type (start-sync), then click the set of marks to sync, then (stop-sync).
</td></tr>
<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define mark-sync-number 0)
(define (start-sync) (set! mark-sync-number (+ (mark-sync-max) 1)))
(define (stop-sync) (set! mark-sync-number 0))
(define (click-to-sync id) (set! (<em class=red>mark-sync</em> id) mark-sync-number) #f)
(add-hook! mark-click-hook click-to-sync)
</pre></td></tr></table>
</td></tr>
<tr><td></td><td>
Now control-click and drag one of them, and all move together deleting data, or
inserting zeros; or click the "play" triangle, and all play together starting from
the respective marks (which need not be in separate channels). 
</td></tr>

<!-- mark-sync-max -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmarksyncmax">mark-sync-max</a></em> ()</code></span></td></tr>
<tr><td></td><td>max mark sync value seen so far (intended as a way to get a unique sync value).
</td></tr>

<!-- marks -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="emarks">marks</a></em> (<i>snd chn pos</i>)</code></span></td></tr>
<tr><td></td><td>list of mark ids in <i>snd</i>'s channel <i>chn</i> at edit history position <i>pos</i>.
If <i>chn</i> and <i>pos</i> are omitted, a list of lists is returned, 
each inner list representing a channel of <i>snd</i>.  If <i>snd</i> is 
also omitted, a list of lists of lists is returned, representing
each sound and its channels.
</td></tr>
<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (how-many-marks-in-channel snd chn)
  (length (<em class=red>marks</em> snd chn)))

(define (how-many-marks-in-sound snd)
  (apply + (map length (<em class=red>marks</em> snd))))

(define (how-many-marks)
  (apply + (map how-many-marks-in-sound (sounds))))
</pre></td></tr></table>
</td></tr>
<tr><td></td><td>
<b>marks</b>
without any argument, or with just a sound index returns a list of lists; each inner list is the list
of current marks (ids) active in that channel, ordered by sample number.  If the channel argument is
specified, <b>marks</b> returns just the list of mark ids.  If the edit history position is given,
the list of ids reflects the mark list at that time in the edit history.  See describe-marks in marks.scm.
</td></tr>

<!-- mark? -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmarkok">mark?</a></em> (<i>id</i>)</code></span></td></tr>
<tr><td></td><td>#t if mark <i>id</i> is active (that is, present in an active channel).
</td></tr>

<!-- save-marks -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndsavemarks">save-marks</a></em> (<i>snd</i>)</code></span></td></tr>
<tr><td></td><td>save <i>snd</i>'s marks, writing a file &lt;name&gt;.marks (return file name or #f if no marks).
</td></tr>

<tr><td colspan=2><span class=defbox><code><em class=def><a href="#showmarks">show-marks</a></em></code></span></td></tr>
<tr><td></td><td>#t if marks are being (or to be) displayed.
</td></tr>

<!-- syncd-marks -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="syncdmarks">syncd-marks</a></em> (sync)</code></span></td></tr>
<tr><td></td><td>a list of marks (the mark id's) that share the mark-sync value <i>sync</i>.
</td></tr>
<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (move-syncd-marks sync diff)
  (for-each 
    (lambda (m) 
      (set! (mark-sample m) (+ (mark-sample m) diff))) 
    (<em class=red>syncd-marks</em> sync)))
</pre></td></tr></table>
</td></tr>

</table>

<!-- INDEX markexamples:Marking -->
<A NAME="markexamples"></a>
<p>
See <a href="sndscm.html#marksdoc">marks.scm</a> for
more examples including:
</p>
<table border=3 bordercolor="tan" hspace=40><tr><td>
<blockquote><small>
<br>
global find-mark: <a href="sndscm.html#markname2id">mark-name-&gt;id</a><br>
mark history: <a href="sndscm.html#describemark">describe-mark</a><br>
synchronize marks by inserting silences: <a href="sndscm.html#syncup">syncup</a><br>
squeeze selection between marks: <a href="sndscm.html#fitselectionbetweenmarks">fit-selection-between-marks</a><br>
insert silence before marks: <a href="sndscm.html#padmarks">pad-marks</a><br>
move syncd marks: <a href="sndscm.html#movesyncdmarks">move-syncd-marks</a><br>
play starting from syncd marks: <a href="sndscm.html#playsyncdmarks">play-syncd-marks</a><br>
evaluate function between marks: <a href="sndscm.html#exevalbetweenmarks">eval-between-marks</a><br>
place marks at selection start and end: <a href="sndscm.html#exsnapmarks">snap-marks</a><br>
define selection via marks: <a href="sndscm.html#exdefineselectionviamarks">define-selection-via-marks</a><br>
force dragged mark to land on a beat: <a href="sndscm.html#exsnapmarktobeat">snap-mark-to-beat</a><br>
loop continuously between the two specified marks: <a href="sndscm.html#exloopbetweenmarks">loop-between-marks</a><br>
split sound into separate files based on mark placement: <a href="sndscm.html#exmarkexplode">mark-explode</a><br>
mark property lists: <a href="sndscm.html#markproperty">mark-property</a><br>
save mark properties in saved state file: <a href="sndscm.html#savemarkproperties">save-mark-properties</a><br>
show mark properties upon click: <a href="sndscm.html#markclickinfo">mark-click-info</a><br>
</small></blockquote>
<br>
</td></tr></table>

<p>Other examples can be found in Dave Phillips' dlp/marks-menu.scm, snd-motif.scm (<i>add-mark-pane</i>),<br>
edit-menu.scm (trim from mark, etc), examp.scm (move window to correspond to mark, looping).
</p>
<br>
<br>
<table width="100%" border=1><tr><td bgcolor="lightgreen" valign="middle"><h3><A NAME="sndmixes">Mixes</a></h3></td></tr></table>

<p>A mix is an object that represents a channel of a sound mix.
Each mix object has a unique identifier called its id that identifies it in the following functions.
Say we have a mix whose id is 123:</p>
<pre>
&gt;<em class=typing>(mix-chans 123)</em>
<em class=listener>1</em>
&gt;<em class=listener>(set! (mix-amp 123 0) .5)</em>
<em class=typing>.5</em>
</pre>
<p>This 
sets mix 123's channel 0 amplitude scaler to .5.
</p>
<p>
All of the signal-processing functions can be applied to its data.
In the functions that refer to a given sound, the form <code>(list mix-id)</code> refers to the
underlying mix's sound.  So, <code>(src-sound 2.0 1.0 (list 0) 0)</code> performs
sampling-rate conversion on mix 0's sound's channel 0; <code>(display-edits (list 0) 0)</code>
shows the edit list of that sound.  To undo or redo an edit that actually applied to the underlying
mix sound, call undo or redo on the outer (resultant, mixed-into) sound.
</p>

<!-- -------------------------------- MIX FUNCTION TABLE -------------------------------- -->

<table border=0 cellspacing=10>

<!-- backward-mix -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndbackwardmix">backward-mix</a></em> (<i>count snd chn</i>)</code></span></td></tr>
<tr><td><spacer type=horizontal size=40><br></td><td>move the cursor back <i>count</i> mix tags (C-x C-j), returning the mix id.
</td></tr>

<!-- find-mix -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndfindmix">find-mix</a></em> (<i>samp snd chn</i>)</code></span></td></tr>
<tr><td></td><td>return identifier of mix at sample <i>samp</i> (or anywhere in the given channel if <i>samp</i> is not specified) or #f if no mix is found.
</td></tr>

<!-- forward-mix -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndforwardmix">forward-mix</a></em> (<i>count snd chn</i>)</code></span></td></tr>
<tr><td></td><td>move the cursor forward <i>count</i> mix tags (C-x C-j), returning the mix id.
</td></tr>

<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmix">mix</a></em> (file <i>samp in-chan snd chn with-mix-tags auto-delet</i>)</code></span></td></tr>
<tr><td></td><td>
mix <i>file</i>'s channel <i>in-chan</i> starting at <i>samp</i> in <i>snd</i>'s channel <i>chn</i>.
if only the <i>file</i> argument is given, this is equivalent to the File menu's 
Mix option; the mix start sample in this case depends on the cursor location.
mix returns the id of the first channel's mix (subsequent channels simply 
increment this number). If sync is off, only the first channel is mixed.
If <i>with-mix-tags</i> is #f (default is #t), the data is simply
mixed without creating any mix tags.
</td></tr>

<!-- mixes -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="mixes">mixes</a></em> (<i>snd chn pos</i>)</code></span></td></tr>
<tr><td></td><td>a list of currently active mixes in <i>snd</i>'s channel <i>chn</i> at history <i>pos</i>.
</td></tr>

<!-- mix-amp -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmixamp">mix-amp</a></em> (<i>mix chan</i>)</code></span></td></tr>
<tr><td></td><td>amplitude of <i>mix</i>'s channel <i>chan</i>.
</td></tr>

<!-- mix-amp-env -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmixampenv">mix-amp-env</a></em> (<i>mix chan</i>)</code></span></td></tr>
<tr><td></td><td>amplitude envelope of <i>mix</i>'s channel <i>chan</i>.
</td></tr>

<!-- mix-anchor -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmixanchor">mix-anchor</a></em> (<i>mix</i>)</code></span></td></tr>
<tr><td></td><td>anchor (tag) position (within the mix) of <i>mix</i>; a sample number.
</td></tr>

<!-- mix-chans -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmixchans">mix-chans</a></em> (<i>mix</i>)</code></span></td></tr>
<tr><td></td><td>chans in <i>mix</i>.
</td></tr>

<!-- mix-color -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="mixcolor">mix-color</a></em>()</code></span></td></tr>
<tr><td></td><td>color of mix waveforms (defaults to dark-gray).
The set form, <code>(set! (mix-color) ...)</code>, has an optional second argument; if you
want to set just a particular mix's color, give the id of the mix
as that argument: <code>(set! (mix-color) red)</code> sets all unselected mixes to
red; but <code>(set! (mix-color 3) red)</code> sets only mix #3 to be red.
</td></tr>

<!-- mix-frames -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmixframes">mix-frames</a></em> (<i>mix</i>)</code></span></td></tr>
<tr><td></td><td>mix's length in samples.
</td></tr>

<!-- mix-home-->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmixhome">mix-home</a></em> (<i>mix</i>)</code></span></td></tr>
<tr><td></td><td>a list of the sound index and channel number affected by <i>mix</i>.
</td></tr>

<!-- mix-locked -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmixlocked">mix-locked</a></em> (<i>mix</i>)</code></span></td></tr>
<tr><td></td><td>#t if <i>mix</i> is locked.  A mix is automatically locked (i.e. made immovable) if an edit operation
affects some portion of the data that the mix also affects.  For example, if you delete a portion of a sound
that has actively mixed data, the associated mix tag goes away until you undo that deletion.  This can
be used deliberately to remove a mix:
</td></tr>
<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (delete-mix id)
  (if (mix? id)
      (as-one-edit
       (lambda ()
	 (do ((i 0 (1+ i)))
	     ((= i (mix-chans id)))
	   (set! (mix-amp id i) 0.0))
	 (set! (<em class=red>mix-locked</em> id) #t)))))
</pre></td></tr></table>
</td></tr>

<!-- mix-position -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmixposition">mix-position</a></em> (<i>mix</i>)</code></span></td></tr>
<tr><td></td><td>position (a sample number) of <i>mix</i>.
</td></tr>

<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmixregion">mix-region</a></em> (<i>samp reg snd chn</i>)</code></span></td></tr>
<tr><td></td><td>
Mix in region <i>reg</i> at sample <i>samp</i> (defaulting to the cursor sample), 
in <i>snd</i>'s channel <i>chn</i>.  mix-region returns the id of the first channel's 
mix (subsequent channels simply increment this number).
</td></tr>

<!-- mix-selection -->
<tr><td colspan=2><span class=defbox><code><em class=def>mix-selection</em> (<i>beg snd chn</i>)</code></span></td></tr>
<tr><td></td><td>
mix (add) selection starting at beg in snd's channel chn.  Return new mix id.
</td></tr>

<!-- mix-speed -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmixspeed">mix-speed</a></em> (<i>mix</i>)</code></span></td></tr>
<tr><td></td><td>speed (resampling ratio) of <i>mix</i>; 1.0 (default) means no resampling; 2.0 reads the mix data twice as fast.
</td></tr>

<!-- mix-tag-height -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmixtagheighth">mix-tag-height</a></em> (<i>mix</i>)</code></span></td></tr>
<tr><td></td><td>tag height in graph of <i>mix</i> (default 14)
</td></tr>

<!-- mix-tag-width -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmixtagwidth">mix-tag-width</a></em> (<i>mix</i>)</code></span></td></tr>
<tr><td></td><td>tag width in graph of <i>mix</i> (default 6)
</td></tr>

<!-- mix-tag-y -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmixtagy">mix-tag-y</a></em> (<i>mix</i>)</code></span></td></tr>
<tr><td></td><td>tag y offset in graph of <i>mix</i> (default 0).  The x offset of the tag is determined by <a href="sndmixanchor">mix-anchor</a>.
</td></tr>

<!-- mix-track -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmixtrack">mix-track</a></em> (<i>mix</i>)</code></span></td></tr>
<tr><td></td><td>mix track (0 = none).  (mix-sync is a synonym for this).
A "track" is a list of associated mixes (see mix.scm).
</td></tr>

<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmixvct">mix-vct</a></em> (vct <i>beg snd chn with-mix-tags</i> origin)</code></span></td></tr>
<tr><td></td><td>
mix the contents of <i>vct</i> into <i>snd</i>'s channel <i>chn</i> starting at frame <i>beg</i>.
Return the id of the new mix, or -1 if some error occurred.
If <i>with-mix-tags</i> is #f (default is #t), the data is simply
mixed without creating any mix tags, and without returning a mix id.
</td></tr>

<!-- mix-waveform-height -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="mixwaveformheight">mix-waveform-height</a></em>()</code></span></td></tr>
<tr><td></td><td>Max height (pixels) of mix waveforms; default is 20 (see <a href="#showmixwaveforms">show-mix-waveforms</a>).
</td></tr>

<!-- mix? -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmixok">mix?</a></em> (<i>mix</i>)</code></span></td></tr>
<tr><td></td><td>#t if <i>mix</i> is active.
</td></tr>

<!-- play-mix -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndplaymix">play-mix</a></em> (<i>mix beg</i>)</code></span></td></tr>
<tr><td></td><td>play mix <i>mix</i>.  'beg' is where to start playing within the mix.
</td></tr>

<!-- play-track -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndplaytrack">play-track</a></em> (<i>track snd chn beg</i>)</code></span></td></tr>
<tr><td></td><td>play track <i>track</i>. If snd is #t, play all associated mixes, even if in different sounds.
'beg' is where to start playing within the track.
</td></tr>

<!-- selected-mix -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndselectedmix">selected-mix</a></em> ()</code></span></td></tr>
<tr><td></td><td>selected mix (#f if none) -- set to select mix.
</td></tr>

<!-- selected-mix-color -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="selectedmixcolor">selected-mix-color</a></em>()</code></span></td></tr>
<tr><td></td><td>color of selected mix waveform (default is light green).
</td></tr>

<!-- with-mix-tags -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="withmixtags">with-mix-tags</a></em>()</code></span></td></tr>
<tr><td></td><td>If #f (default #t), automatically lock each new mix; the default is to place a tag above each
mix so that it can be easily moved around.
</td></tr>

</table>
<br>
<p>
See mix.scm for more mix-related (and track-related) functions including:
</p>
<table border=0>
<tr><td><em class=def><a href="sndscm.html#mix2vct">mix-&gt;vct</a></em></td><td>place samples of mix in vct</td></tr>
<tr><td><em class=def><a href="sndscm.html#panmix">pan-mix</a></em></td><td>pan mix samples via envelope</td></tr>
<tr><td><em class=def><a href="sndscm.html#snapmixtobeat">snap-mix-to-beat</a></em></td><td>force dragged mix to land on a beat</td></tr>
<tr><td><em class=def><a href="sndscm.html#deletemix">delete-mix</a></em></td><td>delete mix (set amps to 0 and lock)</td></tr>
<tr><td><em class=def><a href="sndscm.html#deleteallmixes">delete-all-mixes</a></em></td><td>delete all mixes</td></tr>
</table>

<!-- INDEX mixingexamples:Mixing -->
<A NAME="mixingexamples"></a>
<br>
<table border=3 bordercolor="tan" hspace=40><tr><td>

<blockquote><small>
<br>
mix sound file: <a href="#sndmix">mix</a> or drag-and-drop it where you want it mixed.<br>
mix channel: see <i>mix-channel</i> in extensions.scm<br>
mix region: <a href="#sndmixregion">mix-region</a><br>
mix selection: <a href="#sndmixselection">mix-selection</a><br>
mix vct: <a href="#sndmixvct">mix-vct</a><br>
enveloped mix: see <i>enveloped-mix</i> in extensions.scm<br>
pan mono into stereo: see <i>place-sound</i> in examp.scm<br>
the mix dialog: <a href="snd.html#mixpanel">Mix Panel</a><br>
mix menu: see dlp/mix-menu.scm<br>
filter mix (or any other such operation): use list with mix id as 'snd' arg.<br>
read pre-mix samples: <a href="#makemixsamplereader">make-mix-sample-reader</a><br>
mix property list: <a href="sndscm.html#mixproperty">mix-property</a> in mix.scm<br>
cross-fade in frequency: <i>cross-fade</i> and <i>dissolve-fade</i> in <a href="sndscm.html#fadedoc">fade.scm</a><br>
zipper cross-fade: <a href="sndscm.html#zipdoc">zipper.scm</a><br>
<br>
</small></blockquote>

</td></tr></table>
<br>
<table width="100%" border=1><tr><td bgcolor="lightgreen" valign="middle"><h3><A NAME="sndregions">Regions and Selections</a></h3></td></tr></table>

<p>A region is a saved portion of sound data.  There is a dialog, the View:Region browser, to inspect regions.
As regions are defined, the new ones are pushed on a stack, and if enough regions already
exist, old ones are pushed off (and deleted) to make room.
Each region has a unique id returned by make-region and shown beside the region name in the Region Browser.
Most of the region arguments default to the current region (the top of the regions stack).
</p>

<!-- -------------------------------- REGION TABLE -------------------------------- -->

<table border=0 cellspacing=10>

<!-- forget-region -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="forgetregion">forget-region</a></em> (<i>reg</i>)</code></span></td></tr>
<tr><td><spacer type=horizontal size=40><br></td><td>
"forget" (delete) region <i>reg</i>, removing it from the region stack. To delete all regions, <code>(for-each forget-region (regions))</code>.
<small>I called this forget-region because delete-region seemed ambiguous, especially given delete-selection.</small>
</td></tr>

<!-- insert-region -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndinsertregion">insert-region</a></em> (<i>beg reg snd chn</i>)</code></span></td></tr>
<tr><td></td><td>
insert region <i>reg</i> at sample <i>beg</i> in <i>snd</i>'s channel <i>chn</i>.
</td></tr>

<!-- make-region -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmakeregion">make-region</a></em> (<i>beg end snd chn</i>)</code></span></td></tr>
<tr><td></td><td>
create a new region spanning samples <i>beg</i> to <i>end</i> in <i>snd</i>'s channel <i>chn</i>.
return region's id.  If no arguments are given, the 
selection is used. If <i>chn</i> is #t, all chans are included, taking the <i>snd</i> sync field into account if it's not 0.
</td></tr>

<!-- make-region-sample-reader -->
<tr><td colspan=2><span class=defbox><code><a href="#makeregionsamplereader">make-region-sample-reader</a> (<i>start reg chn dir</i>)</code></span></td></tr>
<tr><td></td><td>
create a <a href="#samplereaders">sample-reader</a> reading region <i>reg</i>'s channel <i>chn</i>.
</td></tr>

<!-- mix-region -->
<tr><td colspan=2><span class=defbox><code><em class=def>mix-region</em> (<i>samp reg snd chn</i>)</code></span></td></tr>
<tr><td></td><td>
Mix in region <i>reg</i> at sample <i>samp</i> (defaulting to the cursor sample), 
in <i>snd</i>'s channel <i>chn</i>.  mix-region returns the id of the first channel's 
mix (subsequent channels simply increment this number).
</td></tr>

<!-- play-region -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndplayregion">play-region</a></em> (<i>reg wait</i>)</code></span></td></tr>
<tr><td></td><td>
play region <i>reg</i>; if wait is #t, play to the end before returning. (See play.scm).
</td></tr>

<!-- region-chans -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndregionchans">region-chans</a></em> (<i>reg</i>)</code></span></td></tr>
<tr><td></td><td>
number of channels in region <i>reg</i>.
</td></tr>

<!-- region-frames -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndregionframes">region-frames</a></em> (<i>reg</i>)</code></span></td></tr>
<tr><td></td><td>
number of samples (per channel) in region <i>reg</i>.
</td></tr>

<!-- region-graph-style -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndregiongraphstyle">region-graph-style</a></em> (style)</code></span></td></tr>
<tr><td></td><td>
graph drawing choice for the region dialog's graph.
</td></tr>

<!-- region-maxamp -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndregionmaxamp">region-maxamp</a></em> (<i>reg</i>)</code></span></td></tr>
<tr><td></td><td>
maximum amplitude of region <i>reg</i>.
</td></tr>

<!-- region-sample -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndregionsample">region-sample</a></em> (<i>samp reg chn</i>)</code></span></td></tr>
<tr><td></td><td>
value of sample <i>samp</i> in region <i>reg</i> in channel <i>chn</i>.
</td></tr>

<!-- region-samples->vct -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndregionsamples2vct">region-samples-&gt;vct</a></em> (<i>samp samps reg chn v</i>)</code></span></td></tr>
<tr><td></td><td>
return a vct containing <i>samps</i> samples starting at <i>samp</i> in region <i>reg</i>'s 
channel <i>chn</i>. If v (a vct) is provided, it is filled, 
rather than creating a new vct.
</td></tr>
<tr><td colspan=2>
<center><table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (region-rms n)
  (let* ((data (<em class=red>region-samples-&gt;vct</em> 0 0 n)) ; len=0 =&gt; entire region
	 (len (vct-length data)))
    (sqrt (/ (dot-product data data len) len))))
</pre></td></tr></table></center>
</td></tr>

<!-- region-srate -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndregionsrate">region-srate</a></em> (<i>reg</i>)</code></span></td></tr>
<tr><td></td><td>
original (nominal) sampling rate of region <i>reg</i>.
</td></tr>

<!-- regions -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="eregions">regions</a></em> ()</code></span></td></tr>
<tr><td></td><td>
list of ids of regions currently active.  The most recently created region is <code>(car (regions))</code>.
<code>(map region-frames (regions))</code> returns a list of region lengths.
</td></tr>

<!-- region? -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="regionok">region?</a></em> (<i>reg</i>)</code></span></td></tr>
<tr><td></td><td>
#t if region <i>reg</i> exists.  There is a limit to how many regions Snd tries to
keep track of (<a href="#maxregions">max-regions</a>); when necessary, the least-recently created region is
deleted.
</td></tr>

<!-- save-region -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndsaveregion">save-region</a></em> (reg filename <i>type format comment</i>) </code></span></td></tr>
<tr><td></td><td>
save region <i>reg</i> in <i>filename</i> in data format <i>format</i> (default is mus-bshort), header type <i>type</i> (default
is mus-next), with header comment <i>comment</i>.
</td></tr>

</table>
<!-- INDEX regionexamples:Regions -->
<A NAME="regionexamples"></a>
<table border=3 bordercolor="tan" hspace=40><tr><td>
<small><blockquote>
See also:<br>
Max length of region list: <a href="#maxregions">max-regions</a><br>
Whether selection creates a region: <a href="selectioncreatesregion">selection-creates-region</a><br>
Play hook: <a href="#stopplayingregionhook">stop-playing-region-hook</a><br>
To play region repeatedly: <a href="sndscm.html#explayregionforever">play-region-forever</a><br>
Start region browser from Scheme: <a href="#sndregiondialog">region-dialog</a><br>
All about regions: <a href="snd.html#regions">regions</a><br>
The region dialog: <a href="snd.html#regionbrowser">region browser</a><br>
Region rms amp: <a href="sndscm.html#exregionrms">region-rms</a><br>
region-play-list and region-play-sequence in examp.scm<br>
</blockquote></small>
</td></tr></table>
<br>
<hr>


<!-- -------------------------------- SELECTION TABLE -------------------------------- -->

<table border=0 cellspacing=10>

<!-- convolve-selection-with -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndconvolveselectionwith">convolve-selection-with</a></em> (file <i>amp</i>)</code></span></td></tr>
<tr><td><spacer type=horizontal size=40><br></td><td>
convolve the selection with <i>file</i>.
</td></tr>

<!-- delete-selection -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="snddeleteselection">delete-selection</a></em> ()</code></span></td></tr>
<tr><td></td><td>
delete the selection.
</td></tr>

<!-- env-selection -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndenvselection">env-selection</a></em> (envelope <i>env-base</i>)</code></span></td></tr>
<tr><td></td><td>
apply <i>envelope</i> to the selection.
<i>envelope</i> can also be a CLM env generator (in this case, <i>env-base</i> 
is ignored).
</td></tr>

<!-- filter-selection -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndfilterselection">filter-selection</a></em> (env <i>order</i>)</code></span></td></tr>
<tr><td></td><td>
apply an FIR filter of order <i>order</i> and frequency response <i>env</i>
to the selection.  <i>env</i> can be the filter coefficients
themselves in a vct with at least order elements, or 
a CLM filtering generator (see <a href="filtersound">filter-sound</a>).
</td></tr>

<!-- insert-selection -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndinsertselection">insert-selection</a></em> (<i>beg snd chn</i>)</code></span></td></tr>
<tr><td></td><td>
insert selection starting at beg in snd's channel chn.
</td></tr>

<!-- mix-selection -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmixselection">mix-selection</a></em> (<i>beg snd chn</i>)</code></span></td></tr>
<tr><td></td><td>
mix (add) selection starting at beg in snd's channel chn.  Return new mix id.
</td></tr>

<!-- play-selection -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndplayselection">play-selection</a></em> (<i>wait pos</i>)</code></span></td></tr>
<tr><td></td><td>
play the selection.  <i>pos</i> sets the edit position.  If <i>wait</i> is #t, the function does not return until the play has completed.
</td></tr>

<!-- reverse-selection -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndreverseselection">reverse-selection</a></em> ()</code></span></td></tr>
<tr><td></td><td>
reverse the selection.
</td></tr>

<!-- save-selection -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndsaveselection">save-selection</a></em> (file <i>header-type data-format srate comment chan</i>)</code></span></td></tr>
<tr><td></td><td>
save the selection in <i>file</i>.  If <i>chan</i> is given, save only that channel.
See popup.scm for an example.
</td></tr>
<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (brksnd dur base)
  "(brksnd dur base) divides the current sound into dur-sized pieces, saving them as base.n"
  (let ((hop (inexact-&gt;exact (* (srate) dur)))
	(len (frames))
        (old-sync (sync)))
    (set! (sync) 1) ; save all chans
    (do ((i 0 (+ i hop))
	 (j 0 (1+ j)))
	((&gt;= i len))
      (make-selection i (+ i hop)) ; in extensions.scm
      (<em class=red>save-selection</em> (string-append base "." (number-&gt;string j))))
    (set! (sync) old-sync)))
</pre></td></tr></table>
</td></tr>

<!-- scale-selection-by -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndscaleselectionby">scale-selection-by</a></em> (scalers)</code></span></td></tr>
<tr><td></td><td>
<a href="snd.html#scaling">scale</a> the selection by <i>scalers</i> which can be either a float, 
a list of floats, or a vector of floats.  In a multi-channel selection, each member of the vector or list
is applied to the next channel in the selection.  <code>(scale-selection-by '(0.0 2.0))</code> scales
the first channel by 0.0, the second (if any) by 2.0.  <code>(scale-selection-by 2.0)</code> scales
all channels by 2.0.  Normally the order of channels follows the order of the sound indices.
</td></tr>

<!-- scale-selection-to -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndscaleselectionto">scale-selection-to</a></em> (<i>norms</i>)</code></span></td></tr>
<tr><td></td><td>
<a href="snd.html#scaling">normalize</a> the selection to <i>norms</i> which can be either a float, 
a list of floats, or a vector of floats.
</td></tr>

<!-- select-all -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndselectall">select-all</a></em> (<i>snd chn</i>)</code></span></td></tr>
<tr><td></td><td>
select all samples in <i>snd</i>'s channel <i>chn</i>.
If a region is created, return the region's id.
</td></tr>

<!-- selection-chans -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="selectionchans">selection-chans</a></em> ()</code></span></td></tr>
<tr><td></td><td>
selection channels.
</td></tr>

<!-- selection-frames -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="selectionframes">selection-frames</a></em> (<i>snd chn</i>)</code></span></td></tr>
<tr><td></td><td>
selection length in samples.  You can set this to move the selection end point. 
</td></tr>

<!-- selection-maxamp -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndselectionmaxamp">selection-maxamp</a></em> (<i>snd chn</i>)</code></span></td></tr>
<tr><td></td><td>
maximum amplitude of selection in the given channel.
</td></tr>

<!-- selection-member? -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="selectionmember">selection-member?</a></em> (<i>snd chn</i>)</code></span></td></tr>
<tr><td></td><td>
#t if snd's chn is member of active selection. (This is settable).  See make-selection in extensions.scm.
If <i>snd</i> is #t and the new value is #f, the entire selection is deactivated.
</td></tr>

<!-- selection-position -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="selectionposition">selection-position</a></em> (<i>snd chn</i>)</code></span></td></tr>
<tr><td></td><td>
sample where selection begins. You can set this to move the selection's starting point to some arbitrary sample.
If changed, the selection end point stays the same, while the length (selection-frames) changes to reflect the
moved origin. 
See make-selection in extensions.scm.
</td></tr>

<!-- selection-srate -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="selectionsrate">selection-srate</a></em> ()</code></span></td></tr>
<tr><td></td><td>
selection srate.  There's some arbitrariness in this if the sounds that make up the selection have different sampling rates.
</td></tr>

<!-- selection? -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="selectionok">selection?</a></em> ()</code></span></td></tr>
<tr><td></td><td>
#t if there is a selection.
</td></tr>

<!-- smooth-selection -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndsmoothselection">smooth-selection</a></em> ()</code></span></td></tr>
<tr><td></td><td>
apply a smoothing function to the selection.  This produces a sinusoid between
the end points.</td></tr>

<!-- src-selection -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndsrcselection">src-selection</a></em> (num-or-env <i>base</i>) </code></span></td></tr>
<tr><td></td><td>
apply sampling rate conversion to the selection;
this is the same as <i>src-sound</i> but applied to selection.
</td></tr>
</table>

<!-- INDEX selectionexamples:Selections -->
<A NAME="selectionexamples"></a>
<table border=3 bordercolor="tan" hspace=40><tr><td>
<small><blockquote>
See also:<br>
<a href="#selectioncolor">selection-color</a>: color of selected portion<br>
<a href="#selectioncreatesregion">selection-creates-region</a>: if #f, creating a selection does not create a region<br>
<a href="#lshowselectiontransform">show-selection-transform</a>: if #t, fft graph refers to the selection<br>
<a href="#stopplayingselectionhook">stop-playing-selection-hook</a>: hook called when selection stops playing<br>
<a href="sndscm.html#exswapselectionchannels">swap-selection-channels</a>: swap chans in selected portion<br>
<a href="sndscm.html#exreplacewithselection">replace-with-selection</a>: replace portion with selection<br>
<a href="sndscm.html#exmakeselection">make-selection</a>: select portion via function<br>
<a href="sndscm.html#exevaloverselection">eval-over-selection</a>: evaluate thunk on each sample of selection<br>
<a href="sndscm.html#exselectionmembers">selection-members</a>: list of lists of sound index and channel if selection is active there<br>
<a href="sndscm.html#exselectionrms">selection-rms</a>: rms of selection data<br>
<a href="sndscm.html#exdeleteselectionandsmooth">delete-selection-and-smooth</a>: delete selection and smooth the splice<br>
<a href="sndscm.html#exdefineselectionviamarks">define-selection-via-marks</a>: select portion between two marks<br>
<a href="sndscm.html#exsnapmarks">snap-marks</a>: place marks at selection start and end<br>
<a href="sndscm.html#fitselectionbetweenmarks">fit-selection-between-marks</a>: squeeze selection between marks<br>
<a href="sndscm.html#addselectionpopup">add-selection-popup</a>: add context-sensitive popup menu specific to selection<br>
<a href="sndscm.html#editmenudoc">cut-selection-&gt;new</a>: delete selection and write it to a file<br>
<a href="sndscm.html#editmenudoc">append-selection</a>: append selection<br>
<a href="sndscm.html#editmenudoc">selection-&gt;new</a>: write selection to a file<br>
<a href="sndscm.html#dlpdoc">deselect-all</a>: undo select-all.<br>
<br>
</blockquote></small>
</td></tr></table>

<p>The selected portion can be chosen, independent of any region, by setting selection-position and selection-frames.
It's easy to extend the notion of a selection to an arbitrary list of sound portions:
</p>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (make-section . members)
  ;; each member is '(beg dur snd chn)
  (append (list 'Section) members))

(define (section-for-each func section)
  ;; call func on each member of the section
  (as-one-edit (lambda () (for-each func (cdr section)))))

;; an example that scales each member of the section by .5
(section-for-each 
 (lambda (sect)
   (apply scale-channel (append (list .5) sect)))
 (make-section (list 0 10000 0 0) (list 30000 10000 0 0)))
</pre></td></tr></table>


<br>
<table width="100%" border=1><tr><td bgcolor="lightgreen" valign="middle"><h3><A NAME="sndsounds">Sounds and channels</a></h3></td></tr></table>

<p>This is the heart of Snd; we've waded through all the ancillary junk, and we've
finally reached the functions that actually edit sounds!  Most of these functions
take both a sound index and a channel number.  To make global operations simpler to achieve,
some of the <i>snd</i> and <i>chan</i> arguments can be #t, referring to all current sounds or all channels of a sound; 
of these, some default to the currently selected sound if no argument is given, whereas others
(mainly for historical reasons) default to all sounds and channels;
the former are indicated as <em class=targ>snd</em> or <em class=targ>snd chn</em> below,
and the latter as <em class=narg>snd</em> or <em class=narg>snd chn</em>.
Also, in most of the signal-processing functions, the <i>snd</i> argument can also be
a list; in this case it refers to a mix.  For example, the <b>cursor</b> function,
which refers to the current cursor location, is listed here as:
</p>
<pre>
  cursor           (<em class=targ>snd chn</em>)     cursor location
</pre>
<p>which indicates that <code>(cursor 0 0)</code> returns the cursor location in sound 0, channel 0,
<code>(cursor)</code> returns the location in the currently selected sound, <code>(cursor #t #t)</code>
returns a list of lists of all the cursor locations, and <code>(set! (cursor) 0)</code> sets (just) the
cursor in the currently selected channel;
on the other hand, the <b>transform-size</b> function
is listed as:</p>
<pre>
  transform-size         (<em class=narg>snd chn</em>)     FFT size.
</pre>
<p>which means that <code>(transform-size 0 0)</code> returns the fft size used in sound 0, channel 0,
<code>(transform-size)</code> returns the globally effective fft size, <code>(transform-size #t #t)</code>
returns a list of lists of all the fft sizes, and <code>(set! (transform-size) 512)</code> sets all
fft sizes to 512.</p>

<p>The variables are local to each sound or each channel.
That is, <code>(amp-control snd)</code> returns the control-panel amp setting, and <code>(set! (amp-control snd) val)</code>
sets its value to val.  
</p>

<p>Many of the procedures also have an <i>edpos</i> argument (standing for "edit position").
It always defaults to the current edit history position.  If specified, it can be either an edit history position (to which
the operation is applied), the constant <a name="currenteditposition">current-edit-position</a> (the default), or a function
of two arguments, the sound index and the channel number.  The function should return the
desired edit history position. In most cases, you should only refer to edits in the past
(that is, <i>edpos</i> should be less than or equal to the current edit-position); in a few
situations, you can make use of data in the "redo" section of the edit-history list, but
nothing is guaranteed.  
</p>

<blockquote>
<hr>
<p>
<small><A NAME="regularizedargs"></a>
For not-very-good historical reasons (it took me awhile to decide how to organize things), some of the procedures here are unnecessarily inconsistent in
what arguments they accept, whether a channel of #f signals application to all channels or just the
selected one, whether the sync field is followed, and so on.  Rather than make a bunch of backwards
incompatible changes, I decided to add a bunch of more-or-less synonymous functions that regularize
these calls. The replacements always take arguments in the order begin time, duration (not end sample),
sound index, channel number, and edit position, possibly preceded by one argument, and sometimes followed by 
an edit history name or 'ring time' (overlap).  The sync field is ignored, an unspecified sound argument applies only to the
current sound, and an unspecified channel argument applies only to the current channel. 
The following substitutions can be made:
</small>
</p>
<small>
<pre>
<a href="#sndenv">env-sound</a> env beg dur base s c e                <a href="#envchannel">env-channel</a> clm-env-gen beg dur s c e
<a href="#sndfilter">filter-sound</a> env order s c e                    <a href="#clmchannel">clm-channel</a> clm-filter-gen beg dur s c e overlap
<a href="#mapchan">map-chan</a> func beg end origin s c e              <a href="#mapchannel">map-channel</a> func beg dur s c e origin (or <a href="#ptreechannel">ptree-channel</a>)
<a href="#scanchan">scan-chan</a> func beg end s c e                    <a href="#scanchannel">scan-channel</a> func beg dur s c e
<a href="#sndplay">play</a> beg s c sync end e                         <a href="#playchannel">play-channel</a> beg dur s c e
<a href="#sndreverse">reverse-sound</a> s c e                             <a href="#reversechannel">reverse-channel</a> beg dur s c e
<a href="#sndscalesoundby">scale-sound-by</a> scl beg dur s c e                <a href="#scalechannel">scale-channel</a> scl beg dur s c e
<a href="#sndsetsamples">set-samples</a> beg dur data s c trunc origin fchan <a href="#vct2channel">vct-&gt;channel</a> vct beg dur s c e
<a href="#sndsmooth">smooth-sound</a> beg dur s c                        <a href="#smoothchannel">smooth-channel</a> beg dur s c e
<a href="#samples2vct">samples-&gt;vct</a> beg dur snd chn v e                <a href="#channel2vct">channel-&gt;vct</a> beg dur s c e
<a href="#vct2samples">vct-&gt;samples</a> beg dur vct s c trunc origin fchan <a href="#vct2channel">vct-&gt;channel</a> vct beg dur s c e
<a href="#sndinsertsilence">insert-silence</a> beg dur s c                      <a href="#padchannel">pad-channel</a> beg dur s c e
<a href="#sndsrc">src-sound</a> num base s c e                        <a href="#srcchannel">src-channel</a> ratio-or-env-gen beg dur s c e
<a href="#sndconvolvewith">convolve-with</a> file amp s c e                    <a href="#clmchannel">clm-channel</a> convolve-gen beg dur s c e
<a href="grfsnd.html#applyladspa">apply-ladspa</a> reader dat dur origin              <a href="grfsnd.html#ladspachannel">ladspa-channel</a> dat beg dur s c e
<a href="#sndmix">mix</a> file beg filechn s c with-tags              <a href="sndscm.html#mixchannel">mix-channel</a> filedat beg dur s c e
<a href="#sndinsertfile">insert-sound</a> file beg filechn s c e             <a href="sndscm.html#insertchannel">insert-channel</a> filedat beg dur s c e
<a href="#sndredo">redo</a> edits s c                                  <a href="#redochannel">redo-channel</a> edits s c
<a href="#sndundo">undo</a> edits s c                                  <a href="#undochannel">undo-channel</a> edits s c
</pre>
</small>
<p><small>An equivalent to map-channel might be:</small></p>
<pre>
<small>
 (define* (map-channel func #:optional (beg 0) dur snd chn edpos (edname "map-channel"))
   (let* ((end (if dur (+ beg dur) (1- (frames snd chn edpos)))))
     (map-chan func beg end edname snd chn edpos)))
</small>
</pre>
<p><small>Another case that might deserve "regularization" is make-sample-reader which confusingly interpolates
the direction argument between the channel and edit-position:
</small></p>
<pre>
<small>
 (define* (read-channel #:optional (beg 0) snd chn edpos (direction 1))
   (make-sample-reader beg snd chn direction edpos))
</small>
</pre>
<hr>
</blockquote>


<!-- -------------------------------- SOUND AND CHANNEL TABLE -------------------------------- -->

<table border=0 cellspacing=10>


<!-- add-player -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="addplayer">add-player</a></em> (player <i>start end pos</i>)</code></span>
</td></tr>
<tr><td><spacer type=horizontal size=40><br></td><td>
add <i>player</i> to the play-list (see <a href="#makeplayer">make-player</a>). 
If <i>pos</i> is given, play at that edit position. See <i>play-with-envs</i> in enved.scm, <i>play-syncd-marks</i>
in marks.scm, or <i>start-dac</i> in play.scm.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- backward-graph -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndbackwardgraph">backward-graph</a></em> (<i>count snd chn</i>)</code></span>
</td></tr>
<tr><td></td><td>
move the selected channel back (up or left) <i>count</i> graphs (C-x C-o), returning a list of the new sound index and channel number.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- beats-per-minute -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="beatsperminute">beats-per-minute</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
The x axis labelling of the time domain waveform can be in beats
(x-axis-style = x-axis-in-beats); this variable sets the number of beats per minute.
The default is 60.0, making it the same as x-axis-in-seconds.  
See <a href="#snpmark">snap-mark-to-beat</a>, or <a href="sndscm.html#snapmixtobeat">snap-mix-to-beat</a>.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- bomb -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="bomb">bomb</a></em> (<i>snd on</i>)</code></span>
</td></tr>
<tr><td></td><td>
display bomb icon in <i>snd's</i> minibuffer.  Set <i>on</i> to #f to erase bomb.  Each time <i>bomb</i>
is called, the bomb icon moves to the next image in its sequence (showing the bomb's fuse burning down),
restarting the sequence whenever it reaches the end.
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define show-bomb 
  (lambda (n speed) 
    (if (&gt; n 0) 
	(begin 
	  (<em class=red>bomb</em>) 
	  (in speed (lambda () (show-bomb (- n 1) speed))))
	(<em class=red>bomb</em> 0 #f))))

(show-bomb 20 200)
</pre></td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- channel-amp-envs -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="channelampenvs">channel-amp-envs</a></em> (file chan size <i>peak-file-func work-proc-func</i>)</code></span>
</td></tr>
<tr><td></td><td>
This procedure returns two vcts of length 'size' containing y vals (min and max) of file's channel chan's amp envs.
'peak-file-func' if any is used to get the name of the associated peak_env_info file if the file is very large.
'work-proc-func' is called when the amp envs are ready if the amp envs are gathered in the background.
If 'file' is a sound index (an integer), pts is an edit-position, and the current amp envs (if any) are returned.
peak-file-func's args are the file and the channel.  If it returns a string, that is treated as the filename
to read to get the peak info.  work-proc-func's args are the filename, the channel and the current peak.
<b>make-sound-icon</b> in <a href="sndscm.html#makesoundbox">make-sound-box</a> in snd-motif.scm uses
this function to draw the little thumbnail graph for each sound icon.
</td></tr>
<tr><td colspan=2></td></tr>

<!-- channel-data -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="channeldata">channel-data</a></em> (<i>snd chn</i>)</code></span>
</td></tr>
<tr><td></td><td>
channel-data provides very low-level access to the data currently in the given channel's sample buffers.
It is used by the <a href="sndscm.html#variabledisplay">variable-display</a> mechanism to show graphs
of variable values (normally in an instrument).  channel-data only works with sound indices returned
by make-variable-display.  See <b>make-variable-display</b> in snd-motif.scm.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- channel-properties -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndchannelproperties">channel-properties</a></em> (<em class=targ>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
A property list associated with the given channel.  It is set to '() at the time a sound is opened.  The accessor
<a href="sndscm.html#exchannelproperty">channel-property</a> is provided in extensions.scm.  See enved.scm (which uses
the property 'enved-envelope), or draw.scm (the properties 'colored-samples and 'insert-envelope).
<br><br>Traditionally in Lisp, a property list has been treated as an association list. This is a list
of pairs (made by cons), each inner pair having a key as its first element, and the associated value as the second element.
The function <b>assoc</b> can be used to search the list for a given key's value; a new key-value pair can be
added with:<br><br>
  <code>(cons (cons key value) a-list)</code>
<br><br>In Common Lisp, property lists have other properties, so to speak, but <b>channel-properties</b> (and
<a href="#sndsoundproperties">sound-properties</a>) can be handled in any way you like.

</td></tr>
<tr><td colspan=2></td></tr>


<!-- channel-style -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="channelstyle">channel-style</a></em> (<i>snd</i>)</code></span>
</td></tr>
<tr><td></td><td>
The state of the '<a href="snd.html#unitebutton">unite</a>' button in multi-channel files.  
Values are <i>channels-separate</i>, <i>channels-combined</i>, and <i>channels-superimposed</i>. 
The following code sets the 'unite' button if the current sound has more than 4 channels: 
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! after-open-hook 
  (lambda (snd)
    (if (&gt; (chans snd) 4)
        (set! (<em class=red>channel-style</em> snd) channels-combined))))
</pre></td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- channel->vct -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="channel2vct">channel-&gt;vct</a></em> (<i>beg dur snd chn edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
<b>channel-&gt;vct</b> is the <a href="#regularizedargs">regularized</a> version of <a href="#samples2vct">samples-&gt;vct</a>.
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define* (selection-&gt;vct #:optional snd chn)
  (if (selection-member? snd chn)
      (<em class=red>channel-&gt;vct</em> (selection-position snd chn)
		    (selection-frames snd chn)
		    snd chn)
      (if (selection?)
          (throw 'no-such-channel 
                 (list "selection-&gt;vct"
     	               (format #f "snd ~D channel ~D is not a member of the selection" snd chn)))
	  (throw 'no-active-selection (list "selection-&gt;vct")))))
</pre></td></tr></table>
<br>
See also <i>mark-explode</i> in marks.scm.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- channels -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="channels">channels</a></em> (<em class=targ>snd</em>)</code> 
<spacer type=horizontal size=40><code><em class=def><a name="chans">chans</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
number of channels in <i>snd</i>.  <i>chans</i> is another name for this procedure.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- clm-channel -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="clmchannel">clm-channel</a></em> (clm-gen <i>beg dur snd chn edpos overlap</i>)</code></span>
</td></tr>
<tr><td></td><td>
apply <i>clm-gen</i> to <i>snd</i>'s channel <i>chn</i> starting
at sample <i>beg</i> for <i>dur</i> samples, and <i>overlap</i> samples of 'ring time'.
This is used by some of the <a href="#regularizedargs">regularized</a> functions, but it can also be used directly:
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define* (convolve-channel kernel #:optional nbeg ndur nsnd nchn nedpos)
  (let* ((beg (or nbeg 0)) 
	 (snd (or nsnd (selected-sound) (car (sounds))))
	 (chn (or nchn (selected-channel)))
	 (dur (or ndur (- (frames snd chn) beg)))
	 (edpos (or nedpos current-edit-position))
	 (reader (make-sample-reader beg snd chn 1 edpos))
	 (cgen (make-convolve :filter kernel 
                              :input (lambda (dir)
				       (read-sample reader)))))
    (<em class=red>clm-channel</em> cgen beg dur snd chn edpos)
    (free-sample-reader reader)))

(define (difference) (<em class=red>clm-channel</em> (make-two-zero 1 -1)))
(define (wobble) (<em class=red>clm-channel</em> (make-sum-of-cosines 3 50)))
(define (hold-nose) (<em class=red>clm-channel</em> (make-sum-of-cosines 3 1)))
(define (bad-reception) (<em class=red>clm-channel</em> (make-sum-of-cosines 5 10)))
</pre></td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- close-sound -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndclose">close-sound</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
close <i>snd</i> (same as File menu Close). To close all: <code>(for-each close-sound (sounds))</code>.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- comment -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndcomment">comment</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
<i>snd</i>'s comment, if any (this refers initially to the file's header which can often contain a comment, identical
to <a href="#soundcomment">mus-sound-comment</a>).  If you set it, the header is not updated until the sound is saved.
If the new comment is the only change you want to make, you can save the new header via the Edit:Edit Header menu option.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- convolve-with -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndconvolvewith">convolve-with</a></em> (file <i>amp snd chn edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
convolve <i>snd</i>'s channel <i>chn</i> (or the currently sync'd data)
with the data in the sound file <i>file</i>. <i>amp</i> is the resultant 
peak amplitude (leave <i>amp</i> unset, or set it to #f to get the 
unnormalized result).
Convolve-with in conjunction with mix can provide high-quality reverb:
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define conrev
  (lambda (impulse amp)
    (<em class=red>convolve-with</em> impulse amp)
    (save-sound-as "reverb.snd") ;let mix scalers set reverb amount
    (revert-sound)
    (<em class=red>mix</em> "reverb.snd")))
</pre></td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- count-matches -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="lcountmatches">count-matches</a></em> (proc <i>sample snd chn edpos</i>) </code></span></td></tr>
<tr><td></td><td>
return how many samples satisfy the function <i>proc</i>; <i>proc</i> should
take one argument (the current sample value), and return #t for a hit. <i>sample</i> 
determines where to start the search.<br><br>
<code>(count-matches (lambda (y) (&gt; y .1)))</code>
</td></tr>
<tr><td></td><td>
This function is obviously modelled on Emacs. It could be defined along these lines:
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (count-matches proc)
  (let ((count 0))
    (scan-channel 
      (lambda (y)
        (if (proc y) (set! count (+ count 1)))
        #f))
    count))
</pre></td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- cursor -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndcursor">cursor</a></em> (<em class=targ>snd chn edpos</em>)</code></span>
</td></tr>
<tr><td></td><td>
cursor location (as a sample number, first sample is numbered 0) in channel <i>chn</i> of <i>snd</i>.
<code>(set! (cursor) 100)</code> moves the cursor to sample 100.  The cursor is somewhat similar to a
mark in that it moves if you delete or insert samples in front of it.  Many functions apply from the
cursor in the currently selected channel if you don't specify otherwise.

<!-- INDEX cursorexamples:Cursors -->
<A NAME="cursorexamples"></a>
<br><br>
<table border=3 bordercolor="tan" hspace=40><tr><td>
<blockquote><small>
<br>
Tracking cursor: <a href="#sndcursorfollowsplay">cursor-follows-play</a><br>
Change cursor shape or size: <a href="#cursorstyle">cursor-style</a>, <a href="#cursorsize">cursor-size</a><br>
Cursor moving keys: <a href="snd.html#movecursor">Moving the Cursor</a><br>
Display data about sample under cursor: <a href="#verbosecursor">verbose cursor</a><br>
<br>
</small></blockquote>
</td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- cursor-follows-play -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndcursorfollowsplay">cursor-follows-play</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
#t if cursor is following along in the sound as it plays.  To make this the default:<br><br>
<code>(add-hook! after-open-hook (lambda (sp) (set! (cursor-follows-play sp) #t)))</code>.<br><br>
A better name for this might be <i>with-tracking-cursor</i>, but the word "track" already has too many meanings in this context;
I wonder whether "track" or "frame" has the most uses.

<!-- INDEX trackingcursors:Tracking cursors -->
<A NAME="trackingcursors"></a>
<br><br>
<table border=3 bordercolor="tan" hspace=40><tr><td>
<blockquote><small>
<br>
To play from the current cursor position with a tracking cursor:  <a href="#pfc">pfc</a>.<br>
To display tracking cursor as a full height vertical line: <a href="#cursorstyle">cursor-style</a>.<br>
To track play once: control-click 'play'. (You can add a mark at the current tracking cursor location during the play with C-m).<br>
To leave the cursor at the final position after tracking play: if-cursor-follows-play-it-stays-where-play-stopped in examp.scm.<br>
<br>
</small></blockquote>
</td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- cursor-position -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="cursorposition">cursor-position</a></em> (<em class=targ>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
current cursor position as a list (x y).
These graph-relative values can be turned into axis-relative values with
<a href="#position2x">position-&gt;x</a> and <a href="#position2y">position-&gt;y</a>:
<br><br>
<code>(position-&gt;x (car (cursor-position)))</code> equals <code>(/ (cursor) (srate))</code>
<br>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- cursor-size -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="cursorsize">cursor-size</a></em> (<em class=targ>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
cursor size (pixels); defaults to 15.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- cursor-style -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="cursorstyle">cursor-style</a></em> (<em class=targ>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
cursor style (<i>cursor-cross</i> or <i>cursor-line</i>)
The normal shape is a "+" sign; the cursor-line is a vertical line.
The following hooks set the cursor-style to cursor-line while playing if
cursor-follows-play is #t:
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define set-sound-cursor
  (lambda (snd shape)
    (do ((j 0 (1+ j)))
        ((= j (channels snd)) #f)
      (set! (<em class=red>cursor-style</em> snd j) shape))))

(add-hook! start-playing-hook 
  (lambda (snd) 
    (if (cursor-follows-play snd) 
        (set-sound-cursor snd <em class=red>cursor-line</em>))))

(add-hook! stop-playing-hook 
  (lambda (snd) 
    (set-sound-cursor snd <em class=red>cursor-cross</em>)))
</pre></td></tr></table>
</td></tr>
<tr><td></td><td>
The <i>cursor-style</i> can also be a procedure of three arguments, the
sound index, channel number, and graph (always time-graph).  The procedure
should draw the cursor at the current cursor position using the
cursor-context whenever it is called.  The following 
replaces the normal "+" cursor with an "x":
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (<A NAME="xcursor">x-cursor</a> snd chn ax)
  (let* ((point (<em class=red>cursor-position</em>))
         (x (car point))
         (y (cadr point))
         (size (inexact-&gt;exact (/ (<em class=red>cursor-size</em>) 2))))
    (<em class=red>draw-line</em> (- x size) (- y size) (+ x size) (+ y size) snd chn <em class=red>cursor-context</em>)    
    (<em class=red>draw-line</em> (- x size) (+ y size) (+ x size) (- y size) snd chn <em class=red>cursor-context</em>)))
</pre></td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- data-format -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="snddataformat">data-format</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
<i>snd</i>'s data format (e.g. mus-bshort).  <br><br>If you encounter a file
with an unknown format, or a header that has the wrong format, 
you can set this field forcing Snd to interpret the data in any 
way you like.  Similar remarks apply to the srate, data-location,
header-type, and channels fields.  There are ambiguities in some header
specifications, usually involving big/little endian or signed/unsigned data confusion.
If you encounter a sound that is clipping crazily, try changing these settings.
Some NeXT/Sun (au) header files using the data format for byte-wide data
assume the byte is unsigned, whereas most others assume it is signed.  Sndlib
treats it as signed by default, so to make one of the unsigned-byte files playable,
<br><br><code>(set! (data-format) mus-ubyte)</code>.<br><br>
Float data is another source of confusion;
there is apparently no agreement on whether the data is between -1.0 and 1.0, or -32768.0 and 32767.0 or anything else.
In this case, Snd assumes -1.0 to 1.0 (except in one special case involving IRCAM headers), and you may have to set y-bounds to see the actual data.
Yet another: files with 32-bit integers.  Some programs (Glame, apparently, and perhaps Ardour) assume the fraction is
31 bits wide, others (Snd) use whatever its sample-width is configured to be; there is no correct or standard
placement of the fixed point, but not to worry!  Your data is ok:
<code>(set! (y-bounds) (list -256.0 256.0))</code>. There are several ways you can handle
these files automatically in Snd.  Perhaps the simplest is to use one of the open hooks:
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! after-open-hook 
  (lambda (snd) 
    ;; this could also (alternatively) set the y-bounds as above
    (if (= (<em class=red>data-format</em> snd) mus-lint)
        (set! (<em class=red>data-format</em> snd) mus-lintn))))
</pre></td></tr></table>
</td></tr>
<tr><td></td><td>
or (an alternative that sets the underlying database entry, rather than the current in-Snd choice):
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! open-hook 
  (lambda (name)
    (if (= (mus-sound-data-format name) mus-lint)
        (set! (mus-sound-data-format name) mus-lintn))
    #f))
</pre></td></tr></table>
</td></tr>
<tr><td></td><td>
If you set any of these fields, the sound's index may change (there can be an embedded update-sound).
To deal with MPEG or OGG files, see examp.scm (mpg) or dlp/misc.scm (mpg123 and ogg123).
<br><br>
To turn a data-format number into a string, use <a href="#soundformatname">mus-data-format-name</a>. To get
the data format of some sound file, use <a href="#sounddataformat">mus-sound-data-format</a>.
The default output (new-sound, save-sound-as) data-format is <a href="#defaultoutputformat">default-output-format</a>.
</td></tr>

<tr><td colspan=2></td></tr>


<!-- data-location -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="snddatalocation">data-location</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The location of the sound samples (an offset in bytes) in the file represented by <i>snd</i>.  In a raw (headerless) file,
this is 0, but normally the data comes after some portion of the header.  
To get the data-location of some sound file, use <a href="#sounddatalocation">mus-sound-data-location</a>.
If you set this field (you don't want to do this!), the underlying file is immediately rewritten.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- data-size -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="snddatasize">data-size</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The size of the sound data in bytes in the file represented by <i>snd</i>.
If you set this field, the underlying file is immediately rewritten.
Next/Sun files treat the size field as purely "advisory", so an incorrect data size is often
ignored in that case.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- delete-sample -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="snddeletesample">delete-sample</a></em> (samp <i>snd chn edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
delete sample <i>samp</i> in <i>snd</i>'s channel <i>chn</i>.

<!-- INDEX deletionexamples:Deletions -->
<A NAME="deletionexamples"></a>
<br><br>
<table border=3 bordercolor="tan" hspace=40><tr><td>
<small><blockquote>
To delete a file: use the Guile function delete-file or Ruby's File.delete.<br>
To delete a region: <a href="#forgetregion">forget-region</a><br>
To delete the currently selected samples: <a href="#snddeleteselection">delete-selection</a><br>
To delete the selection and smooth the splice: <a href="sndscm.html#exdeleteselectionandsmooth">delete-selection-and-smooth</a><br>
To delete a mix or all mixes: <a href="sndscm.html#deletemix">delete-mix</a><br>
To delete a track or all tracks: <a href="sndscm.html#deletetrack">delete-track</a><br>
To delete a mark or all marks: <a href="#snddeletemark">delete-mark</a><br>
To remove a file from the sound cache: <a href="#soundforget">mus-sound-forget</a><br>
To remove a menu item: <a href="#sndremovefrommenu">remove-from-menu</a><br>
To add a 'delete' option to the file selection dialog: <a href="sndscm.html#adddeleteoption">add-delete-option</a><br>
</blockquote></small>
</td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- delete-samples -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="snddeletesamples">delete-samples</a></em> (samp samps <i>snd chn edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
delete a block of samples.  The deleted portion starts at sample <i>samp</i> and runs for <i>samps</i> samples.
See <a href="#deletetozero">delete-to-zero</a> or <i>delete-selection-and-smooth</i> in extensions.scm.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- dot-size -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="dotsize">dot-size</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
size in pixels of dots when graphing with dots (default: 1); this affects <a href="#graphstyle">graph-styles</a> such as <code>graph-lollipops</code>.  See <a href="#graphhook">graph-hook</a> or auto-dot in examp.scm.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- env-channel -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="envchannel">env-channel</a></em> (clm-env-gen <i>beg dur snd chn edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
<b>env-channel</b> is the <a href="#regularizedargs">regularized</a> version of <a href="#sndenv">env-sound</a>.  <i>clm-env-gen</i>
can be either a CLM envelope generator or an envelope (a list of breakpoints). <code>(env-channel '(0 0 1 1 2 0))</code><br>

<!-- INDEX envexamples:Envelopes -->
<A NAME="envexamples"></a>
<br><br>
<table border=3 bordercolor="tan" hspace=40><tr><td>
<blockquote><small>
<br>
envelopes in Snd:<br>
Other enveloping functions: <a href="#rampchannel">ramp-channel</a>, <a href="#xrampchannel">xramp-channel</a>, <a href="#smoothchannel">smooth-channel</a><br>
The CLM env generator: <a href="clm.html#make-env">env</a>, many examples in examp.scm, new-effects.scm, etc<br>
Various operations on envelopes: <a href="sndscm.html#envdoc">env.scm</a><br>
Peak env files: <a href="sndscm.html#peakenvdoc">peak-env.scm</a><br>
The envelope editor: <a href="snd.html#editenvelope">Edit or View and Envelope</a><br>
Panning: place-sound in examp.scm, <a href="snd.html#mixpanel">Mix Dialog</a>, play-panned in enved.scm, <a href="sndscm.html#panmix">pan-mix</a><br>
Envelope over mix: <a href="sndscm.html#exenvelopedmix">enveloped-mix</a><br>
Envelope over track (a set of mixes): <a href="sndscm.html#envtrack">env-track</a><br>
Local envelope editor: <a href="sndscm.html#enveddoc">enved.scm</a>, xm-enved.scm<br>
Read sound indexed through envelope: <a href="sndscm.html#exenvsoundinterp">env-sound-interp</a><br>
Cosine as envelope: <a href="#cosinechannel">cosine-channel</a>, <a href="#cosinechannelviaptree">cosine-channel-via-ptree</a>, <a href="clm.html#bellcurve">bell-curve</a><br>
Customizing the envelope editor: <a href="#envedhook">enved-hook</a><br>
<br>
</small></blockquote>
</td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- env-sound -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndenv">env-sound</a></em> (envelope <i>samp samps env-base snd chn edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
apply (in amplitude) <i>envelope</i> to <i>snd</i>'s channel <i>chn</i> starting
at sample <i>samp</i> for <i>samps</i> samples with connecting segments
based on <i>env-base</i>.  <i>env-base</i> defaults to 1.0 (line segments).
<i>samp</i> defaults to 0.  <i>samps</i> defaults to the full duration.
<i>envelope</i> is a list containing the breakpoint values 
(as in CLM) or an env generator.<br><br>
<code>(env-sound '(0 0 1 1 2 0))</code>
<br><br>
As mentioned in <a href="clm.html#make-env">clm.html</a>, 
<i>env-base</i> determines how the break-points are connected.  If it is 1.0 (the
default), you get straight line segments.  <i>env-base</i> = 0.0 gives a step
function (the envelope changes its value suddenly to the new one without any
interpolation).  Any other positive value becomes the exponent of the exponential curve
connecting the points.  <i>env-base</i> &lt; 1.0 gives convex curves (i.e. bowed
out), and <i>env-base</i> &gt; 1.0 gives concave curves (i.e. sagging).
If you'd rather think in terms of e^-kt, set <i>env-base</i> to (exp k).
See env.lisp for a CLM instrument that shows the relation between the connecting
curve's exponent and <i>env-base</i>.  Here's a brief restatement:
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (compare-exp k)
   (let ((e (make-env (list 0 1 1 (exp (- k))) :base (exp k) :end 10)))
      (do ((i 0 (1+ i )))
         ((= i 10))
         (snd-print (format #f "~A ~A~%" (env e) (exp (* (- k) (/ i 10.0))))))))
</pre></td></tr></table>
</td></tr>
<tr><td></td><td>
If <i>envelope</i> is a CLM env generator, <i>env-base</i> 
is ignored.
</td></tr><tr><td colspan=2></td></tr>


<!-- fft-log-frequency -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="fftlogfrequency">fft-log-frequency</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
spectrum frequency axis is logarithmic (#t) or linear (#f, the default).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- fft-log-magnitude -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="fftlogmagnitude">fft-log-magnitude</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
spectrum magnitude axis is in decibels (#t) or linear (#f, the default).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- fft-window -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="lfftwindow">fft-window</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
fft data window (default: <i>blackman2-window</i>)
<pre>
rectangular-window   hann(ing)-window     welch-window        parzen-window
bartlett-window      hamming-window       blackman2-window    blackman3-window
blackman4-window     exponential-window   riemann-window      kaiser-window
cauchy-window        poisson-window       gaussian-window     tukey-window
dolph-chebyshev-window (this only if GSL is loaded)
</pre>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- fft-window-beta -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="fftbeta">fft-window-beta</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
Some fft windows have a parameter, often named alpha or beta, that chooses one from a family of possible windows.
The actual (underlying) beta values are dependent on the window choice, but
in Snd, <i>fft-window-beta</i> is scaled to fit the current window's range of values, so
its value here should fall between 0.0 and 1.0.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- file-name -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndfilename">file-name</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
<i>snd</i>'s complete (or "absolute") file name (that is, the directory is included; see <a href="#shortfilename">short-file-name</a>
if you don't want all the directory junk).  See examp.scm for many examples.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- filter-sound -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndfilter">filter-sound</a></em> (env <i>order snd chn edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
apply an FIR filter of order <i>order</i> (actually one more than the nominal order)
and frequency response <i>env</i>
to <i>snd</i>'s channel <i>chn</i>.  <i>env</i> can be the filter coefficients
themselves, in a vct with at least order elements.
It can also be any CLM filtering generator 
(e.g. comb, formant, one-pole, iir-filter, etc). The generator 
is called in C, not Scheme, so this is the fastest way to apply 
CLM filtering to a sound. (The regularized version of this is <a href="#clmchannel">clm-channel</a>).
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(<em class=red>filter-sound</em> '(0 1 1 0) 1024)                       ;FIR filter given frequency response
(<em class=red>filter-sound</em> (list-&gt;vct '(.1 .2 .3 .3 .2 .1)) 6)    ;FIR filter given actual coefficients
(<em class=red>filter-sound</em> (make-fir-filter 6 (list-&gt;vct '(.1 .2 .3 .3 .2 .1)))) ;CLM FIR filter
(<em class=red>filter-sound</em> (make-delay 120))                      ;CLM delay (same as insert-silence)
(<em class=red>filter-sound</em> (make-formant .99 1200))               ;CLM formant
</pre></td></tr></table>
<p>
If you want to use the cascade filter structure, rather than the canonical
form of CLM's filter generator:
</p>
<pre>
(define (make-biquad a0 a1 a2 b1 b2)
  (make-filter 3 (vct a0 a1 a2) (vct 0.0 b1 b2)))
</pre>
<p>If you have coefficients for the cascade form, but have no scruples about using 
some other form, see <b>cascade-&gt;canonical</b> in dsp.scm, and the examples that follow.
</p>
<!-- INDEX filtersinsnd:Filters -->
<table border=3 bordercolor="tan" hspace=40><tr><td>
<blockquote><small>
<br>
<A NAME="filtersinsnd">Filters</a> in Snd:<br>
CLM filter generators: <a href="clm.html#filters">filter, one-pole, formant, comb, notch, all-pass, etc</a>, many examples in examp.scm, new-effects.scm<br>
lowpass filter: make-lowpass in dsp.scm<br>
highpass filter: make-highpass in dsp.scm<br>
bandpass filter: make-bandpass in dsp.scm<br>
bandstop filter: make-bandstop in dsp.scm<br>
Butterworth filters: make-butter-high-pass, make-butter-low etc in dsp.scm, used in new-effects.scm<br>
IIR filters of various orders/kinds: dsp.scm<br>
Hilbert transform: make-hilbert-transform in dsp.scm<br>
differentiator: make-differentiator in dsp.scm<br>
block DC: see dc-block in prc95.scm, also stereo-flute in clm-ins.scm.<br>
hum elimination: see eliminate-hum in dsp.scm<br>
arbitrary spectrum via FIR filter: spectrum-&gt;coeffs in dsp.scm<br>
filtered echo sound effect: flecho in examp.scm<br>
time varying filter: fltit in examp.scm<br>
draw frequency response: use <a href="snd.html#editenvelope">envelope editor</a> or <a href="snd.html#filtercontrol">filter control</a> in control panel<br>
Moog filter: <a href="sndscm.html#moogdoc">moog.scm</a><br>
Click reduction: <a href="sndscm.html#exremoveclick">remove-click</a><br>
Filter a track: <a href="sndscm.html#filtertrack">filter-track</a><br>
LADSPA-based filter effects: see dlp/plugins-menu.scm<br>
Max Mathews resonator: <a href="sndscm.html#maxfdoc">maxf.scm, maxf.rb</a><br>
Spectral edit dialog: <a href="snd.html#editenvelope">Envelope Editor</a><br>
graphical equalizer filter bank: <a href="sndscm.html#clminsdoc">graphEq</a><br>
see also convolution, physical modeling, reverb, and <a href="sndscm.html#ssffts">fft-based filtering</a><br>
<br>
</small></blockquote>
</td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- find -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="lfind">find</a></em> (proc <i>sample snd chn edpos</i>) </code></span></td></tr>
<tr><td></td><td>
find the sample that satisfies the function <i>proc</i>. <i>sample</i>
determines where to start the search. 
If 'proc' returns some non-#f value, find itself returns a list with that value and the sample number.
In the find dialog and in C-s or C-r searches, if the value returned is an integer, the cursor is offset by that number of samples.
<br><br><code>(find (lambda (y) (&gt; y .1)))</code><br><code>(find (lambda (y) (and (&gt; y .1) -2)))</code><br>

<!-- INDEX searchexamples:Searching -->
<A NAME="searchexamples"></a>
<br><br>
<table border=3 bordercolor="tan" hspace=40><tr><td>
<blockquote><small>
<br>
Example find procedures: <a href="sndscm.html#exsearchforclick">search-for-click, zero+, next-peak, find-pitch</a><br>
Search via continuation: <a href="#scanagain">scan-again</a><br>
Explicit access to search procedures: <a href="#searchprocedure">search-procedure</a><br>
The Find dialog: <a href="snd.html#editoperations">Find</a><br>
find silence: <a href="#mapsilence">map-silence</a><br>
find zero crossing: <a href="#newcp">find-zero</a><br>
find a mark etc: <a href="#sndfindmark">find-mark</a>, <a href="#sndfindmix">find-mix</a>, <a href="#sndfindsound">find-sound</a><br>
see also <a href="#lcountmatches">count-matches</a> and <a href="#scanchannel">scan-channel</a>.<br>
<br>
</small></blockquote>
</td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- find-sound -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndfindsound">find-sound</a></em> (filename <i>nth</i>)</code></span>
</td></tr>
<tr><td></td><td>
return the index of <i>filename</i> or
#f if no sound is found that matches <i>filename</i>.  If there is (or might be) more than one file
open with the given filename, the 'nth' parameter (which defaults to 0) chooses which to return.
Leaving aside the 'nth' parameter, find-sound could be defined as:
</td></tr>
<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (find-sound name)
  (call-with-current-continuation
   (lambda (return)
     (for-each 
      (lambda (snd)
	(if (or (string=? (short-file-name snd) name)
		(string=? (file-name snd) name))
	    (return snd)))
      (sounds))
     #f)))
</pre></td></tr></table><br>
See popup.scm, and <i>files-popup-buffer</i>, <i>open-next-file-in-directory</i> and the "Buffer Menu" code in examp.scm.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- finish-progress-report -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="finishprogressreport">finish-progress-report</a></em> (<i>snd</i>)</code></span>
</td></tr>
<tr><td></td><td>
End an on-going progress report (a visual indication of how far along some time-consuming process is). 
See <a href="#progressreport">progress-report</a>.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- forward-graph -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndforwardgraph">forward-graph</a></em> (<i>count snd chn</i>)</code></span>
</td></tr>
<tr><td></td><td>
move the selected channel forward (down or right) <i>count</i> graphs (C-x C-o), returning a list of the new sound index and channel number.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- frames -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndframes">frames</a></em> (<em class=targ>snd chn</em> <i>edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
<i>chn</i>'s current length in samples.  Used with set!, this either truncates 
the sound or pads it with zeros at the end.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- graph -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndgraph">graph</a></em> (data <i>xlabel x0 x1 y0 y1 snd chn force-display</i>)</code></span>
</td></tr>
<tr><td></td><td>
Display a graph of <i>data</i> in a separate display per channel.  The x axis
is labelled <i>xlabel</i>, the x axis units go from x0 to x1 (default 0 to 1.0),
the y axis goes from y0 to y1 (default fits the data), and the display is 
associated with channel <i>chn</i> in <i>snd</i>.
<code>(graph '#(0 .1 .2 .3 .4 .3 .2 .1 0) "roof")</code>
The current slider values can be read from <a href="#xpositionslider">x-position-slider</a>, 
<a href="#xzoomslider">x-zoom-slider</a>, etc.  The <i>data</i> argument can be a list of vectors or
vcts; each is graphed at the same time, following the sequence of
colors used when channels are superimposed.  See <a href="sndscm.html#exampdoc">examp.scm</a>.  If <i>data</i>
is a list of numbers, it is assumed to be an envelope (a list of breakpoints).
If <i>force-display</i> is #f (default is #t), the graph is not
explicitly drawn; this is useful when you're calling graph from
the lisp-graph-hook, where the redisplay is automatic.
</td></tr>
<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define display-energy
  ;; y-zoom-slider controls the graph amp
  (lambda (snd chn)
    "display time domain data as energy"
    (let* ((ls (left-sample))
           (rs (right-sample))
	   (datal (make-graph-data snd chn))
	   (data (if (vct? datal) datal (cadr datal)))
           (len (vct-length data))
           (sr (srate snd))
	   (y-max (y-zoom-slider snd chn)))
      (vct-multiply! data data)
      (<em class=red>graph</em> data "energy" (/ ls sr) (/ rs sr) 0.0 (* y-max y-max) snd chn #f))))

(add-hook! <a href="#lispgraphhook">lisp-graph-hook</a> display-energy)
</pre></td></tr></table><br>
<img src="energy.png" alt="picture of examp.scm in action">
</td></tr>
<tr><td colspan=2></td></tr>


<!-- graph-style -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="graphstyle">graph-style</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
how sound data is displayed by default (default: <i>graph-lines</i>)
The choices are:<pre>
graph-lines  graph-dots  graph-filled  graph-lollipops  graph-dots-and-lines 
</pre>
In the set! case, if no <i>snd</i> is specified, all graph-styles are set to the
new value.  If <i>snd</i> is given, the three graph styles for that sound's channels (or channel <i>chn</i>) are
set. See <a href="#timegraphstyle">time-graph-style</a>, <a href="#lispgraphstyle">lisp-graph-style</a>, and
<a href="#transformgraphstyle">transform-graph-style</a> to override the default for a specific graph.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- graphs-horizontal -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="graphshorizontal">graphs-horizontal</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
determines whether channel graphs (time domain, spectrum, lisp graph) 
are arranged vertically or horizontally.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- header-type -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndheadertype">header-type</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The header type (e.g. mus-aiff) of the file that underlies <i>snd</i>.  Snd can read about 60 header types, and write 7 or so.
Each header type has its own peculiarities; if in doubt, use mus-next because it is simple,
and can handle any data format that Snd can write (whereas each of the others is restricted in this regard).
The writable header types are mus-next (also named mus-sun), mus-nist (NIST Sphere), mus-aiff (obsolete, rarely needed), mus-aifc, mus-riff (MS wave),
mus-ircam, and mus-raw (no header -- it's up to you to remember what's in the file).  For descriptions of the headers,
see headers.c; for actual sound files, see sf.tar.gz at ccrma-ftp.
To turn a type number into a string, use <a href="#soundtypename">mus-header-type-name</a>. To get
the header type of some sound file, use <a href="#soundheadertype">mus-sound-header-type</a>.
If you set the header-type, the sound file is rewritten with the new header.  The default output
(new-sound, save-sound-as) header type is <a href="#defaultoutputtype">default-output-type</a>.
<br><br>
To read or write your own headers (or some header that isn't built-in),
I recommend using either <a href="#openhook">open-hook</a> or <a href="#openrawsoundhook">open-raw-sound-hook</a>:
in the latter case, when you open the file with the unsupported header,
Snd will throw up its hands and say "maybe it's a raw (headerless)
sound"; it will then look at open-raw-sound-hook before trying
other fallbacks (such as the Raw File Dialog).
See examp.scm or dlp/misc.scm (MPEG and OGG).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- insert-sample -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndinsertsample">insert-sample</a></em> (samp value <i>snd chn edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
insert sample <i>value</i> at sample <i>samp</i> in <i>snd</i>'s channel <i>chn</i> 

<!-- INDEX insertionexamples:Insertions -->
<A NAME="insertionexamples"></a>
<br><br>
<table border=3 bordercolor="tan" hspace=40><tr><td>
<small><blockquote>
To insert some portion of a channel: <a href="sndscm.html#insertchannel">insert-channel</a><br>
To insert a silence: <a href="#padchannel">pad-channel</a>, <a href="#sndinsertsilence">insert-silence</a><br>
To insert a region: <a href="#sndinsertregion">insert-region</a><br>
To insert the selection: <a href="#sndinsertselection">insert-selection</a><br>
To insert a vct of samples: <a href="#sndinsertsamples">insert-samples</a><br>
To insert a sound: <a href="#sndinsertfile">insert-sound</a><br>
</blockquote></small>
</td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- insert-samples -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndinsertsamples">insert-samples</a></em> (samp samps data <i>snd chn edpos auto-delete</i>)</code></span>
</td></tr>
<tr><td></td><td>
insert <i>samps</i> samples of <i>data</i> (normally a vct) starting at sample <i>samp</i> in <i>snd</i>'s channel <i>chn</i>.
<i>data</i> can be a filename.
The regularized version of this might be:<br>
<pre>
(define* (insert-channel data #:optional beg dur snd chn edpos)
  (insert-samples beg dur data snd chn edpos))
</pre>To insert a block of samples of a given value: <code>(insert-samples beg dur (make-vct dur val))</code>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- insert-silence -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndinsertsilence">insert-silence</a></em> (beg num <i>snd chn</i>)</code></span>
</td></tr>
<tr><td></td><td>
insert num zeros at beg in <i>snd</i>'s channel <i>chn</i>. <a href="#padchannel">pad-channel</a> is the regularized version,
with one small change: insert-silence forces <i>beg</i> to be within the current sound, but pad-channel pads out to <i>beg</i> if
<i>beg</i> is past the end of the sound.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- insert-sound -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndinsertfile">insert-sound</a></em> (file <i>beg in-chan snd chn edpos auto-delete</i>)</code></span>
</td></tr>
<tr><td></td><td>
insert channel <i>in-chan</i> of <i>file</i> at sample <i>beg</i> in <i>snd</i>'s channel <i>chn</i>.
beg defaults to the cursor position; if <i>in-chan</i> is not given, all 
channels are inserted. 
</td></tr>
<tr><td colspan=2></td></tr>


<!-- left-sample -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndleftsample">left-sample</a></em> (<em class=targ>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
return the position in samples of the left edge of the time domain
waveform for <i>snd</i>'s channel <i>chn</i>.
To get the data currently displayed in the time domain window:
</td></tr>
<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (window-samples)
  (let ((wl (<em class=red>left-sample</em>))
	(wr (<a href="#sndrightsample">right-sample</a>)))
   (<a href="#sndsamples">samples</a> wl (+ 1 (- wr wl)))))
</pre></td></tr></table>
</td></tr><tr><td colspan=2></td></tr>


<!-- lisp-graph? -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndgraphing">lisp-graph?</a></em> (<i>snd chn</i>)</code></span>
</td></tr>
<tr><td></td><td>
#t if lisp-generated graph is currently displayed.  This graph section is also active if there's an active function
on the <a href="#lispgraphhook">lisp-graph-hook</a>.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- lisp-graph-style -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="lispgraphstyle">lisp-graph-style</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
how lisp-generated data is displayed.
The choices are:<pre>
graph-lines  graph-dots  graph-filled  graph-lollipops  graph-dots-and-lines 
</pre>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- make-player -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="makeplayer">make-player</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
make a new player associated with <i>snd</i>'s channel <i>chn</i>.
A <i>player</i> is a sort of wrapper for a channel of a sound that supports
all the control-panel functions.  Once created, you can set these
fields, then call <a href="#addplayer">add-player</a> to add this channel to the list of
channels either being played (if a play is in progress) or about
to be played.  Once some player is in the play-list, you can start 
the play with <a href="#startplaying">start-playing</a>, and stop it prematurely with either 
<a href="#stopplayer">stop-player</a> or <a href="#sndstop">stop-playing</a>.  These functions make it possible 
to build custom control panels.  Here's a simple example that plays a 
sound with individual amplitudes for the channels:
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define play-with-amps
  (lambda (sound . amps)
    (let ((chans (chans sound)))
      (do ((chan 0 (1+ chan)))
          ((= chan chans))
        (let ((player (<em class=red>make-player</em> sound chan)))
          (set! (amp-control player) (list-ref amps chan))
          (<em class=red>add-player</em> player)))
      (<em class=red>start-playing</em> chans (srate sound)))))

(play-with-amps 0 1.0 0.5) ;plays channel 2 of stereo sound at half amplitude
</pre></td></tr></table>
</td></tr>

<tr><td></td><td>
See <i>play-with-envs</i> in enved.scm, 
<i>play-syncd-marks</i> in marks.scm, <i>start-dac</i> in play.scm,
and <i>add-amp-controls</i> in <a href="sndscm.html#sndmotifdoc">snd-motif.scm</a>.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- make-variable-graph -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="makevariablegraph">make-variable-graph</a></em> (container <i>name length srate</i>)</code></span>
</td></tr>
<tr><td></td><td>
make-variable-graph is a part of the <b>variable-display</b> mechanism in snd-motif.scm.  It creates the
sound/channel pair that displays a graph of spectrum of the arbitrary data accessed via <a href="#channeldata">channel-data</a>.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- map-chan -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="mapchan">map-chan</a></em> (func <i>start end edname snd chn edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
<b>map-chan</b> applies <i>func</i> to samples in the specified channel.
As opposed to scan-chan, map-chan can change the data.
An optional subsequence of the data can be requested via
'start' and 'end' points.  If beg is #f, it defaults to 0; if end is #f,
it defaults to the end of the channel.
The fourth argument <i>edname</i> is the
name of the editing operation that will be reported by the
edit history mechanism. 
<i>func</i>, a procedure of one argument (the current sample),
can return #f, which means that the data passed in is
deleted (replaced by nothing), or a number which replaces the
current sample,
or #t which halts the mapping operation, leaving trailing samples
unaffected, or a list, vct, or vector of numbers;
the numbers are spliced into the edited version, effectively
replacing the current sample with any number of samples. This sounds
more complicated than it is!  Basically, a map-chan function receives
each sample and returns either #f (no corresponding output), a number
(the new output), or a bunch of numbers.
If every value returned for a given channel is #f, the data is not edited.
<br>
<pre>
&gt;<em class=typing>(map-chan (lambda (y) (+ y .2)))</em>
<em class=listener>#f</em>

&gt;<em class=typing>(map-chan (lambda (y) (cos y)) #f #f "(cos y)")</em>
<em class=listener>#f</em>

&gt;<em class=typing>(map-chan (lambda (y) (if (&gt; y .1) (list .1 .2 .3) y))) </em>
<em class=listener>#f</em>
</pre>
Here's a slightly more involved example;
we define a function that finds silences and replaces them with
something:<br><br>

<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define <A NAME="mapsilence">map-silence</a>
  ;; see squelch in <a href="sndscm.html#effectsdoc">new-effects.scm</a> for a better version
  (lambda (silence replacement)
    (let ((sum-of-squares 0.0)
	  (buffer (make-vector 128 0.0))
	  (position 0)
	  (current-sample 0)
	  (chan-samples (frames)))
      (lambda (y)
        (let ((old-y (vector-ref buffer position)))
	  (set! sum-of-squares (- (+ sum-of-squares (* y y)) (* old-y old-y)))
	  (vector-set! buffer position y)
	  (set! position (1+ position))
	  (if (= position 128) (set! position 0))
	  (set! current-sample (1+ current-sample))
	  (if (&gt; sum-of-squares silence)
	      (if (= current-sample chan-samples)
		  ;; at end return trailing samples as long as it looks like sound
		  (let ((temp-buffer (make-vector 128 0.0)))
		    (do ((i 0 (1+ i)))
			((= i 128) temp-buffer)
		      (let ((final-y (vector-ref buffer position)))
			(vector-set! temp-buffer i (if (&gt; sum-of-squares silence) final-y 0.0))
			(set! sum-of-squares (- sum-of-squares (* final-y final-y)))
			(set! position (1+ position))
			(if (= position 128) (set! position 0)))))
		  old-y)
	    replacement))))))

(<em class=red>map-chan</em> (map-silence .01 0.0))  ; squelch background noise
(<em class=red>map-chan</em> (map-silence .001 #f))   ; remove silences altogether
</pre></td></tr></table>
<br>
In case it isn't obvious, we're using <i>buffer</i> to hold a running
portion of the sound, and <i>sum-of-squares</i> to hold the sum of the squares
of all the samples in that portion.  When the portion's sum falls below
the argument <i>silence</i>, we replace the current sample with <i>replacement</i>.
At the end, we flush out all the remaining samples awaiting output in <i>buffer</i>.
<br><br>
It is possible to break out of a map, flushing any edits, via call-with-current-continuation:
<br><br>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define ctr 0)
(call-with-current-continuation 
  (lambda (return)
    (<em class=red>map-chan</em> (lambda (val)
                (set! ctr (1+ ctr)) 
                (if (&gt; ctr 100) 
                  (return "quitting!") 
                  val)))))
</pre></td></tr></table>
<br>
It is also possible to stop, then continue map-chan:<br><br>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define go-on #f)
(<em class=red>map-chan</em> (lambda (y) 
            (call-with-current-continuation 
              (lambda (stop) 
                (if (&gt; y 1.0)
                    (begin 
                      (set! go-on stop) 
                      (throw 'oops))))) 
            .2))
</pre></td></tr></table>
<br>
If this hits a sample &gt; 1.0, it will print 'oops and put the continuation in the variable <i>go-on</i>.
<code>(go-on)</code> will continue where you left off.  (I'm not sure how far this can be pushed, or
whether it's a good idea -- you may end up with unclosed files and so on).
<br><br>
If the editing action is not mapping something over the current sound, it is
safest to write a temp file with the new data, then pass that to set-samples
with the trunc argument set to #t.  This way you don't assume the new sound
will fit in memory (as in using vct-&gt;samples for example).
Use <a href="#sndtempnam">snd-tempnam</a> to get a temporary filename that reflects the current
temp-dir setting (if any).  The env-sound-interp function in <a href="sndscm.html#exenvsoundinterp">examp.scm</a>
is an example of this.  snd4.scm has Snd-4 style mapping functions such as
map-sound-chans, map-all-chans, etc. 
<br><br>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define* (map-sound-chans proc #:optional (beg 0) end edname snd edpos)
  (do ((i 0 (1+ i)))
      ((= i (chans snd)))
    (<em class=red>map-chan</em> proc beg end edname snd i edpos)))

(define* (map-all-chans proc #:optional (beg 0) end edname edpos)
  (apply for-each 
	 (lambda (snd chn)
	   (<em class=red>map-chan</em> proc beg end edname snd chn edpos))
	 (all-chans)))
</pre></td></tr></table><br>
An esoteric aside: map-chan sets up the sample reader before calling the procedure, so if that procedure edits
the sound itself (independent of map-chan), the result will be all such edits after the current edit, then the map-chan result
applied to the original (not the newly edited) data.  That is,<br><br><pre>
(let ((first #t)) 
  (<em class=red>map-chan</em> (lambda (y) 
              (if first (set! (sample 0) 1.0)) 
              (set! first #f) 
              (* y 2))))
</pre>
will return with two edits registered in the edit history list; the map-chan result will be the original data doubled;
the preceding edit in the list will be the <code>(set! (sample 0) 1.0)</code> which the map-chan ignores.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- map-channel -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="mapchannel">map-channel</a></em> (func <i>beg dur snd chn edpos edname</i>)</code></span>
</td></tr>
<tr><td></td><td>
<b>map-channel</b> is the <a href="#regularizedargs">regularized</a> version of <a href="#mapchan">map-chan</a>.
<br><br>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define* (<A NAME="cosinechannel">cosine-channel</a> #:optional (beg 0) (dur #f) (snd #f) (chn #f) (edpos #f))
  (<em class=red>map-channel</em>
   (let* ((samps (or dur (frames snd chn)))
	  (incr (/ pi samps))
	  (angle (* -0.5 pi)))
     (lambda (y)
       (let ((val (* y (cos angle))))
	 (set! angle (+ angle incr))
	 val)))
   beg dur snd chn edpos))
</pre></td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- maxamp -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndmaxamp">maxamp</a></em> (<em class=targ>snd chn</em> <i>edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
max amp of <i>snd</i>'s channel <i>chn</i>.  Used with set!, this is equivalent to scale-to.
<br><br>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (maxamp-all)
  "(maxamp-all) returns the current maxamp of all currently open sounds"
  (apply max (map (lambda (snd) (apply max (<em class=red>maxamp</em> snd #t))) (sounds))))
</pre></td></tr></table>

<!-- INDEX maxampexamples:Maxamps -->
<A NAME="maxampexamples"></a>
<br><br>
<table border=3 bordercolor="tan" hspace=40><tr><td>
<blockquote><small>
<br>
Sound file maxamp: <a href="#mussoundmaxamp">mus-sound-maxamp</a><br>
Region maxamp: <a href="#sndregionmaxamp">region-maxamp</a><br>
Selection maxamp: <a href="#sndselectionmaxamp">selection-maxamp</a><br>
Sound data object maxamp: <a href="#sounddatamaxamp">sound-data-maxamp</a><br>
Vct maxamp: <a href="#vctpeak">vct-peak</a><br>
CLM's sound maxamp: <a href="clm.html#sound-maxamp">sound-maxamp</a> (same as mus-sound-maxamp)<br>
To set the y axis bounds to reflect the channel's maxamp: <a href="#sndybounds">y-bounds</a><br>
<br>
</small></blockquote>
</td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- max-transform-peaks -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="maxfftpeaks">max-transform-peaks</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
max number of transform peaks reported (default: 100).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- min-dB -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="mindb">min-dB</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
Sets the minimum dB value displayed in various graphs (default: -60.0).
Due to problems with arithmetic underflows in sqrt, the spectrum functions set the lowest
actual dB value calculated to -140.0 or -180.0 (depending on which function is called and so on).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- new-sound -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndnew">new-sound</a></em> (<i>name header-type data-format srate chans comment initial-length</i>)</code></span>
</td></tr>
<tr><td></td><td>
create a new (empty) sound named <i>name</i>.  The following function opens a new (blank) sound,
extends it to 'dur' samples, and initializes all samples to 'val':
<br><br><pre>
(define (init-sound val dur)
  (let ((ind (<em class=red>new-sound</em> "test.snd")))
    (insert-silence 0 dur)
    (map-chan (lambda (y) val))
    ind))
</pre>
If the <i>type</i> and other 
arguments are not specified, they
default to the current <a href="#defaultoutputtype">default-output-type</a> and 
related settings. Data formats are (b=big-endian, l=little, u=unsigned):
<pre>
mus-bshort  mus-lshort mus-mulaw  mus-alaw   mus-byte   mus-ubyte   mus-bfloat
mus-lfloat  mus-bint   mus-lint   mus-b24int mus-l24int mus-bdouble mus-ldouble
mus-ubshort mus-ulshort
</pre>
Header-types are:
<pre>
mus-next mus-aifc mus-riff mus-nist mus-raw mus-ircam mus-aiff mus-soundfont mus-bicsf mus-voc mus-svx
</pre>
To be informed whenever a new sound is created, use <a href="#newsoundhook">new-sound-hook</a> (see ws.scm).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- open-raw-sound -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndrawopen">open-raw-sound</a></em> (name chans srate format)</code></span>
</td></tr>
<tr><td></td><td>
open <i>name</i> as a raw (no header) sound in the layout specified.
If the file has a header, it is not ignored (use (set! (data-format ...))
and friends if you want to ignore the header).
<br><br>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define mpg
  (lambda (mpgfile rawfile chans)
    "(mpg file tmpname chans) converts file from MPEG-3 to raw 16-bit samples using mpg123"
    (system (format #f "mpg123 -s ~A &gt; ~A" mpgfile rawfile))
    (<em class=red>open-raw-sound</em> rawfile 1 44100 (if (little-endian?) mus-lshort mus-bshort))))
</pre></td></tr></table>
<br>There's a more elaborate version of this function in examp.scm.  See also <a href="#openrawsoundhook">open-raw-sound-hook</a>.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- open-sound -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndopen">open-sound</a></em> (name)</code></span>
</td></tr>
<tr><td></td><td>
open <i>name</i> and return its index; this is equivalent to the File:Open option. <a href="#sndview">view-sound</a>
opens a sound read-only, or you can set <a href="#sndreadonly">read-only</a> by hand. <a href="#sndclose">close-sound</a>
closes a file opened by open-sound.  There are a variety of hooks that are invoked during the sound opening process:
<a href="#duringopenhook">during-open-hook</a>, <a href="#openhook">open-hook</a>, <a href="#afteropenhook">after-open-hook</a>,
<a href="#initialgraphhook">initial-graph-hook</a>, <a href="#openrawsoundhook">open-raw-sound-hook</a>.  There are
other ways to get at sound file data: <a href="#makesamplereader">make-sample-reader</a> can be given a filename,
rather than a sound index; <i>file-&gt;vct</i> in examp.scm; 
<a href="#mussoundopeninput">mus-sound-open-input</a> and
<a href="#sndopensoundfile">open-sound-file</a> are low-level sndlib functions;
and there are a variety of CLM-based functions such as
<a href="clm.html#file-&gt;sample">file-&gt;sample</a> and
<a href="clm.html#file-&gt;array">file-&gt;array</a>.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- pad-channel -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="padchannel">pad-channel</a></em> (beg dur <i>snd chn edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
insert <i>dur</i> zeros at <i>beg</i> in <i>snd</i>'s channel <i>chn</i>. This is the <a href="#regularizedargs">regularized</a> 
version of <a href="#sndinsertsilence">insert-silence</a>.  To set a block of samples to zero, use 
<a href="#scalechannel">scale-channel</a> with a scaler of 0.0.
To insert a block of arbitrary-valued samples:
<br><br>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define* (<A NAME="blockchannel">block-channel</a> value #:optional beg dur snd chn edpos)
  (let ((val value)) ; this for the run macro's benefit
    (<em class=red>pad-channel</em> beg dur snd chn edpos)
    (<a href="#ptreechannel">ptree-channel</a> (lambda (y) val) beg dur snd chn)))
</pre></td></tr></table>
<br>
We could also use map-channel here (rather than ptree-channel), but this version
uses only virtual edits, so no matter how big the block of samples we insert,
no disk space or memory is needed.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- peak-env-info -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="peakenvinfo">peak-env-info</a></em> (<i>snd chn pos</i>)</code></span>
</td></tr>
<tr><td></td><td>
return some of the overall amplitude envelope data for the given channel
at the given edit list position.  The data currently returned are whether
the envelopes are complete (they are the result of a background process), and the min and max data values.
See <a href="#initialgraphhook">initial-graph-hook</a> and peak-env.scm.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- peaks -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndpeaks">peaks</a></em> (<i>file snd chn</i>)</code></span>
</td></tr>
<tr><td></td><td>
display fft peak information.  If <i>file</i> is not null, write 
the information to that file, else post it in a help window 
(where it can be selected and pasted elsewhere).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- play -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndplay">play</a></em> (<i>samp snd chn sync end pos</i>)</code></span>
</td></tr>
<tr><td></td><td>
play <i>snd</i>'s channel <i>chn</i> starting from sample <i>samp</i>. 
If 'sync' is #t, play all sounds syncd to snd.  If 'end' is not given or #f, 
play until end of sound. If 'end' is given (as a sample number), the 
actual end point may be off by a few samples; Snd only checks on 
dac-buffer boundaries (normally around 256 samples).  <i>samp</i> can
also be a filename (a string).  In this case, <i>snd</i> can be the start 
sample (default 0), and <i>chn</i> can be the end sample (default end-of-file).
If 'chn' is not given, or is a boolean, play all channels together.
If <i>pos</i> is given, play at that edit position.
<br><br>
The <i>pos</i> argument makes it easier to try "A:B" comparisons.<br>
<br><code>(play 0 #f #f #f #f (1- (edit-position)))</code><br><br> plays the version before the latest edit.
<br><br>
This code binds the "p" key to play all channels of the current sound from the cursor:<br><br>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(bind-key (char-&gt;integer #\p) 0 
  (lambda () 
    (<em class=red>play</em> (cursor))
    keyboard-no-action))
</pre></td></tr></table><br>
The following code plays from the cursor with a moving ("tracking") cursor:<br><br>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (<A NAME="pfc">pfc</a>)
  (let ((old-tracking (cursor-follows-play)))
    (set! (cursor-follows-play) #t)
    (add-hook! stop-playing-hook 
	       (lambda (snd)
		 (set! (cursor-follows-play) old-tracking)))
    (<em class=red>play</em> (cursor))))
</pre></td></tr></table>

<!-- INDEX playexamples:Playing -->
<A NAME="playexamples"></a>
<br><br>
<table border=3 bordercolor="tan" hspace=40><tr><td>
<small><blockquote>
To play one channel: <a href="#playchannel">play-channel</a>, play button in control panel or files dialog<br>
To play from cursor: C-q and example above<br>
To play from cursor with tracking cursor: <a href="#pfc">pfc</a> above<br>
To play the selection: <a href="#sndplayselection">play-selection</a>, <a href="snd.html#cxp">C-x p</a><br>
To play a region: <a href="#sndplayregion">play-region</a>, <a href="snd.html#cxp">C-x p</a>, play button in Region dialog<br>
To play a mix: <a href="#sndplaymix">play-mix</a>, play button in Mix dialog<br>
To play a track: <a href="#sndplaytrack">play-track</a><br>
To play from mark: click or drag triangle (control-click for all chans)<br>
To play continuously between two marks: <a href="sndscm.html#exloopbetweenmarks">loop-it</a><br>
To stop playing: C-g, C-t, <a href="#sndstop">stop-playing</a><br>
To pause or resume playback: space<br>
To play repeatedly: <a href="sndscm.html#explayoften">play-often</a><br>
To play repeatedly until C-g: <a href="sndscm.html#explayuntilcg">play-until-c-g</a><br>
To play region repeatedly: <a href="sndscm.html#explayregionforever">play-region-forever</a><br>
To play a file upon a keystroke: <a href="#extendedpiano">bind-key</a><br>
To play using an external program: (shell "sndplay wood16.wav")<br>
To play arbitrary mixtures of things: <a href="#makeplayer">make-player</a> and related functions, <a href="sndscm.html#playsyncdmarks">play-syncd-marks</a><br>
To send arbitrary data to the DAC: <a href="#musaudiowrite">mus-audio-write</a>, <a href="sndscm.html#exstartdac">start-dac</a><br>
To play after sending the data through some function: <a href="sndscm.html#explaysound">play-sound</a><br>
To play with applied amplitude envelope: <a href="sndscm.html#explaywithenvs">play-with-envs</a>, <a href="sndscm.html#explaypanned">play-panned</a><br>
To play an external file: (play "file")<br>
</blockquote></small>
</td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- play-and-wait -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndplayandwait">play-and-wait</a></em> (<i>samp snd chn sync end pos</i>)</code></span>
</td></tr>
<tr><td></td><td>
play <i>snd</i>'s channel <i>chn</i> starting from sample <i>samp</i> and wait 
for it to finish. (<a href="#sndplay">play</a> on the other hand returns immediately so subsequent calls on play 
mix multiple sample streams together, rather than playing them one after the other).
If <i>pos</i> is given, play at that edit position.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- play-channel -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="playchannel">play-channel</a></em> (<i>beg dur snd chn edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
<b>play-channel</b> is the <a href="#regularizedargs">regularized</a> version of <a href="#sndplay">play</a>.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- player-home -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="playerhome">player-home</a></em> (player)</code></span>
</td></tr>
<tr><td></td><td>
return a list of the sound index and channel number associated with <a href="#makeplayer">player</a>.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- player? -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="playerQ">player?</a></em> (obj)</code></span>
</td></tr>
<tr><td></td><td>
#t is <i>obj</i> is an active <a href="#makeplayer">player</a>.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- position->x -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="position2x">position-&gt;x</a></em> (xpos snd chn axis)</code></span>
</td></tr>
<tr><td></td><td>
return the X axis value that corresponds to the graph position <i>xpos</i>.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- position->y -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="position2y">position-&gt;y</a></em> (ypos snd chn axis)</code></span>
</td></tr>
<tr><td></td><td>
return the Y axis value that corresponds to the graph position <i>ypos</i>.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- progress-report -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="progressreport">progress-report</a></em> (pct <i>name current-channel channels snd</i>)</code></span>
</td></tr>
<tr><td></td><td>
The functions <i>start-progress-report</i>, <i>progress-report</i>, and 
<i>finish-progress-report</i> handle the animated hour-glass icon used 
to amuse the idle user while some long computation is in progress.  
The <i>pct</i> argument is a float between 0.0 and 1.0 which indicates how 
far along we are in the computation (there are only 20 separate 
icons, so there's no point in calling this more often than that).  
start-progress-report posts the initial icon, and finish-progress-report 
removes it.  If the icons are not available, a message is posted in 
<i>snd's</i> minibuffer using <i>name</i> and so on to identify itself.
See new-effects.scm.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- prompt-in-minibuffer -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndpromptinminibuffer">prompt-in-minibuffer</a></em> (msg <i>callback snd (raw #f)</i>)</code></span>
</td></tr>
<tr><td></td><td>
Post <i>msg</i> in <i>snd</i>'s minibuffer, and when you respond,
call <i>callback</i> with the response as the callback's argument.
If <i>callback</i> is specified it should be either #f or a function of 
one argument.  If 'raw' is #t, the response is returned as a string; otherwise it is evaluated first.
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(<em class=red>prompt-in-minibuffer</em> "sample 0 via func:"
  (lambda (func) 
    (set! (sample 0) (func (sample 0)))))
    ;; here we're assuming you will type a function in response to the prompt
    ;;   the value returned by the function will be the new sample 0 value
    ;;   the function should take one argument, the current sample 0 value
    ;; now if you respond: (lambda (y) (+ y .5))
    ;; sample 0 will be set to itself + .5
</pre></td></tr></table></td></tr>

<tr><td></td><td>
See eval-over-selection in <a href="sndscm.html#extensionsdoc">extensions.scm</a> for a more useful example.
We could also use a continuation here:
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (prompt msg default)
  (call-with-current-continuation
   (lambda (rsvp)
     (<em class=red>prompt-in-minibuffer</em> msg rsvp)
     default)))
</pre></td></tr></table></td></tr>

<tr><td></td><td>
The 'raw' argument is useful when we want to prompt for yes or no, without forcing the
user to put the answer in double quotes.  In the next example, we replace Snd's
built-in C-x k action (which immediately closes the sound) with one that is
more like Emacs (which prompts for confirmation first):
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(bind-key (char-&gt;integer #\k) 0 
  (lambda ()
    (<em class=red>prompt-in-minibuffer</em>
     (format #f "close ~S (cr=yes)?" (short-file-name))
     (lambda (response)
       (if (and (not (c-g?)) ; C-g =&gt; no
		(or (not (string? response))
		    (= (string-length response) 0)
		    (char=? (string-ref response 0) #\y)))
	   (close-sound)))
     #f   ; selected sound
     #t)) ; treat as string (i.e. don't require double quotes)
  #t)     ; C-x ...
</pre></td></tr></table></td></tr>
<tr><td colspan=2></td></tr>


<!-- INDEX ptreechannel:Virtual Edits -->
<!-- ptree-channel -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="ptreechannel">ptree-channel</a></em> (proc <i>beg dur snd chn edpos env-too init-func (map-fallback #t)</i>)</code></span>
</td></tr>
<tr><td></td><td>
<b>ptree-channel</b> (only in Guile currently, unless <i>map-fallback</i> is #f)
applies 'proc' as a 'virtual edit'; that is, the effect of 'proc' (a function of one argument, the
current sample), comes about as an implicit change in the way the data is read. 
<br><br>
To be less Orphic:
all the data accesses in Snd go through the edit-history list.  The currently
active member of that list
chooses an accessor based on the type of edit. A  multiply by 2, for
example, does not multiply anything by 2 internally; it just sets up
the data accessor to multiply by 2 on any read.  From any other
point of view, the data has been multiplied.  These accessors make it
unnecessary to save any data in temp files (so that undo will still
work) or internal arrays, and editing the edit-history list is very
fast (we just tack a new accessor choice onto the edit-history list), so the edit operation
appears to be instantaneous and memory-less.  Lots of other operations
are already being done this way in Snd (deletions, scaling, most
envelopes, some channel swaps, etc).  <b>ptree-channel</b> extends the idea to (nearly) arbitrary
functions.  When you call <br><br><code>(ptree-channel (lambda (y) (* y 2)))</code><br><br>
which has the same effect as <br><br><code>(map-channel (lambda (y) (* y 2)))</code><br><br> the
optimizer makes the parse-tree that represents <code>(lambda (y) (* y 2))</code>, then the
edit-history accessor function uses that tree every time the data is
read.<br><br>
If the argument 'env-too' is #t,
the same function is applied to the peak env values to get the new version of the peak env data.  
The default is #f, and should be #t only if the old max and min values as processed through 'proc'
will be the new max and min values. 
Snd uses the peak env values when the graph of the sound covers very large amounts of data.
If 'env-too' is #f, a background process is launched reading all the sound data through
'proc'; this can be time-consuming, so if you're viewing a half-hour of sound data,
it can take awhile for the ptree-channel results to be displayed if 'env-too' is #f.
<br><br>If the underlying data
has too many previous ptree operations, map-channel is called instead and the new
data is saved in the normal manner (that is, I don't currently try to chain any number of these operations
together).  Envelopes have a similar limitation (currently 2 ptrees and 3 envs).
<br><br>
If no 'init-func' is specified, the editing procedure ('proc') should not assume anything about
the context in which it is called;  in this case, there's no way for 'proc' to know where it starts, or when it is being restarted,
or which direction it is running, so,
the following call:
<br><br><pre>
   (let ((ctr 0)) 
     (<em class=red>ptree-channel</em> (lambda (y) 
                      (set! ctr (1+ ctr)) 
                      (* ctr .0001))))
</pre>
will never reset ctr to 0!  Every time a portion of the data is read by Snd, the samples will be
higher.  But, the notion of an accessor that returns a different thing each time a sample
is accessed is not foolish:
<br><br><pre>
  (<em class=red>ptree-channel</em> (lambda (y) (+ y (random .01))))
</pre>
This gives a slightly different take on the sound on each change
of view or redisplay.  But if the details of the noise don't
matter, this change is also ok -- you're editing a sort
of mobile in sound (analogous to mobile sculpture).
<br><br>
However, not everyone wants his samples floating around randomly beneath his gaze.
'init-func' provides a way to include state with the 'proc', as in
this version of cosine-channel given under
<a href="#mapchannel">map-channel</a>:
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define* (<A NAME="cosinechannelviaptree">cosine-channel-via-ptree</a> #:optional (beg 0) (dur #f) (snd #f) (chn #f) (edpos #f))
  ;; vct: angle increment
  (<em class=red>ptree-channel</em>
   (lambda (y data forward)
     (declare (y real) (data vct) (forward boolean))
     (let* ((angle (vct-ref data 0))
	    (incr (vct-ref data 1))
	    (val (* y (cos angle))))
       (if forward
	   (vct-set! data 0 (+ angle incr))
	   (vct-set! data 0 (- angle incr)))
       val))
   beg dur snd chn edpos #t
   (lambda (frag-beg frag-dur)
     (let ((incr (/ pi frag-dur)))
       (vct (+ (* -0.5 pi) (* frag-beg incr))
	    incr)))))
</pre></td></tr></table></td></tr>

<tr><td></td><td>
Since the ptree-channel function (the first argument, 'proc') is optimized
via the run macro, all normal closure references are packaged up into the parse tree and never
seen again (in this context anyway), so we need a way to pass in the initial value of 'angle'
each time ptree-channel is run over the segment that owns this operation.  So, the 'init-func'
returns a vct that is then passed to 'proc' on each call. Since a read operation can start
anywhere in a given fragment, and change read direction unpredictably, the 'init-func' is
passed the fragment-relative begin time, and the main 'proc' takes the current (sample-wise)
read direction as well as the vct returned by 'init-func'.  The sequence of operations is:
a read is requested, 'init-func' is called with the read start point (relative to the
original segment start),
it returns in a vct any state that 'proc' may need
to refer to, then each time a sample is needed from the current sample
reader, 'proc' is called passing it the current underlying sample, the vct of 'init-func',
and the read direction.
<br><br>The second argument to the init-func only comes into play when 'env-too' is #t.
In this case, 'proc' is being evaluated over the peak env data, rather than the
original data, so the duration is the envelope size. 
<br><br>
One major limitation of ptree-channel with an 'init-func' is that <a href="#sndsavestate">save-state</a>
currently doesn't know how to save the enclosing environment along with the init-func. So,
<br><br><pre>
  (let ((outer 0.5))
    (<em class=red>ptree-channel</em> (lambda (y data forward)
		     (declare (y real) (data vct) (forward boolean))
		     (* y (vct-ref data 0)))
		   0 #f ind 0 #f #f
		   (lambda (pos dur)
		     (vct outer))))
</pre>
will not save the "outer" declaration in the saved state file. 
This is a general problem with save-state; there's no obvious way in Guile to
save the current closure as text.
You can fix the saved state file by hand (it is just Scheme or Ruby code, of course),
but that's not a very elegant solution.

<br><br>Another limitation is that Guile may garbage collect the enclosing environment.
Only the vct returned by 'init-func' and 'init-func' itself are protected from the GC (this may change -- it seems
counterintuitive and unnecessary). 
In compand-channel (examp.scm), the table of companding data is declared globally
to protect against this.  We could also, in this case, place the companding table in the vct.
<br><br>
The real limitation in using ptree-channel, however, is that the read direction
can not only be backwards, but it can also change at any time.  This makes it
hard to use CLM generators, or anything that depends on previous samples.
Since the run macro (on which ptree-channel depends) is currently limited in
the kinds of vector or list elements it can decipher, you're pretty tightly
constricted in this context.
The read direction argument can be ignored if you know you're not going to read backwards.
The only hidden reverse read is in the src generator where a negative increment can be
generated in a variety of ways (for example, src driven by oscil).  A one-zero filter
could in this case be:
<br><br><pre>
  (<em class=red>ptree-channel</em> (lambda (y data forward)
		   (declare (y real) (data vct) (forward boolean))
		   (let ((val (* 0.5 (+ y (vct-ref data 0)))))
		     (vct-set! data 0 y)
		     val))
		 0 (frames) ind 0 #f #f ; "ind" is the sound index 
		 (let ((edpos (edit-position ind 0)))
		   (lambda (pos dur)
		     (vct (if (= pos 0) 0.0
			      (sample (1- pos) ind 0 edpos))))))
</pre>
The last (highly experimental) argument to ptree-channel, 'map-fallback', can be set
to #f if you want to try out a more general virtual operator: 'proc' and 'init-func' can
be anything legal in Snd, and the actual forms will be evaluated as virtual ops
at run-time. This should also work in Ruby, whereas the optimized cases (those that
depend on the run macro) will work only in Guile.  We could define xen-channel:
<br><br><pre>
  (define* (<a name="xenchannel">xen-channel</a> proc #:optional (beg 0) (dur #f) (snd #f) (chn #f) (edpos #f) (env-too #f) (init-func #f))
    (<em class=red>ptree-channel</em> proc beg dur snd chn edpos env-too init-func #f))
</pre>Then reverse-channel as a virtual op could be:
<br><br><pre>
(<A NAME="virtualreverse">xen-channel</a> (lambda (y data forward)
	       (if forward
		   (previous-sample data)
		   (next-sample data)))
	     0 (frames) ind 0 #f #f
	     (let ((edpos (edit-position ind 0))
		   (orig-last (1- (frames))))
	       (lambda (pos dur)
		 (make-sample-reader (- orig-last pos) ind 0 -1 edpos))))
</pre><br><br>Here are a couple more examples:
</td></tr>
<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define* (ptree-scale scl #:optional (beg 0) (dur #f) (snd #f) (chn #f) (edpos #f))
  "ptree-channel version of scale-channel"
  (let ((local-scl scl)) ; needed by the run macro -- it can't find define* args
    (<em class=red>ptree-channel</em>
      (lambda (y) 
        (* local-scl y)) 
      beg dur snd chn edpos #t)))

(define* (ptree-xramp r0 r1 ubase #:optional (beg 0) (dur #f) (snd #f) (chn #f) (edpos #f))
  "exponential version of ramp-channel"
  ;; this is essentially what CLM's exponential envelope generator is doing
  ;;   to accommodate C, it uses (exp (* power (log base))) prescaling power by (log base)
  (let* ((base (if (&gt; r0 r1) (/ 1.0 ubase) ubase)))
    (<em class=red>ptree-channel</em>
     (lambda (y data forward)
       (declare (y real) (data vct) (forward boolean))
       (let* ((lr0 (vct-ref data 0))
	      (lbase (vct-ref data 1))
	      (incr (vct-ref data 2))
	      (scl (vct-ref data 3))
	      (power (vct-ref data 4))
	      (val (* y (+ lr0 (* scl (- (expt lbase power) 1.0))))))
	 (if forward
	     (vct-set! data 4 (+ power incr))
	     (vct-set! data 4 (- power incr)))
	 val))
     beg dur snd chn edpos #t
     (lambda (frag-beg frag-dur)
       ;; r0, base, incr, (/ (- r1 r0) (- base 1.0)), current power
       (vct r0
	    base
	    (/ 1.0 frag-dur)
	    (/ (- r1 r0) (- base 1.0))
	    (/ frag-beg frag-dur))))))
</pre></td></tr></table><br>
See also <i>smooth-channel-via-ptree</i> and <i>compand-channel</i> in examp.scm, and
<a href="#blockchannel">block-channel</a> above.
</td></tr><tr><td colspan=2></td></tr>


<!-- ramp-channel -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="rampchannel">ramp-channel</a></em> (rmp0 rmp1 <i>beg dur snd chn edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
<b>ramp-channel</b> is a slight extension of scale-channel. It scales samples in the given sound/channel
between beg and beg + dur by a ramp going from rmp0 to rmp1. (<b>ramp-channel</b> underlies the virtual envelope operations).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- read-only -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndreadonly">read-only</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
#t if <i>snd</i> is read-only, #f otherwise.  <a href="#sndview">view-sound</a> sets this field to #t.
This can be set at any time.  If it is #t, a lock icon is displayed beside the file name.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- read-peak-env-info-file -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="readpeakenvinfofile">read-peak-env-info-file</a></em> (snd chn filename)</code></span>
</td></tr>
<tr><td></td><td>
opens <i>filename</i>, assumed to be the peak-env amp info written by <a href="#writepeakenvinfofile">write-peak-env-info-file</a>
for the given channel.  This should be called only within <a href="#initialgraphhook">initial-graph-hook</a>.  See peak-env.scm.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- redo -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndredo">redo</a></em> (<i>edits snd chn</i>)</code></span>
</td></tr>
<tr><td></td><td>
redo <i>edits</i> edits (default is 1) in <i>snd</i>'s channel <i>chn</i>. Redo follows the sync field if it
is not 0, which sometimes means that the channel arg is simply ignored.  The following might be a more reasonable redo function:
<br><br><pre>
(define* (<a name="redochannel">redo-channel</a> #:optional (edits 1) snd chn)
  (if (and snd (not (= (sync snd) 0)) chn)
      (set! (edit-position snd chn) (+ (edit-position snd chn) edits))
      (redo edits snd)))
</pre>  
<br>
<i>redo</i> simply moves forward in the edit history list, whereas 
<a href="#sndundo">undo</a> backs up, and <a href="#sndrevert">revert-sound</a> resets the current
edit position to the start of the list.
For more about the edit history list, see <a href="#editlists">Edit Lists</a>.
<br><br>
In Ruby, <b>redo</b> is a part of the loop handling, so Snd's redo is renamed redo_edit.
<a name="redoedit">redo-edit</a> also exists in Scheme, for consistency.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- report-in-minibuffer -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndreportinminibuffer">report-in-minibuffer</a></em> (msg <i>snd</i>)</code></span>
</td></tr>
<tr><td></td><td>
post <i>msg</i> in <i>snd</i>'s minibuffer.  This is the text widget between the sound's filename and the buttons
on the right, beneath the graph.  It is intended to mimic Emacs' minibuffer, being useful mainly for short,
temporary messages.  C-g clears it.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- reverse-channel -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="reversechannel">reverse-channel</a></em> (<i>beg dur snd chn edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
<b>reverse-channel</b> is the <a href="#regularizedargs">regularized</a> version of <a href="#sndreverse">reverse-sound</a>.
<!-- INDEX reverseexamples:Reversing -->
<br><br>
<A NAME="reverseexamples"></a>
<table border=3 bordercolor="tan" hspace=40><tr><td>
<blockquote><small>
<br>
To reverse selected portion: <a href="#sndreverseselection">reverse-selection</a><br>
To read samples in reverse: use <a href="#makesamplereader">make-sample-reader</a> with direction -1.<br>
To reverse at new sampling rate: use <a href="#srcchannel">src-channel</a> with a negative ratio.<br>
Reverse in control panel: <a href="snd.html#speed">control panel</a> and <a href="#sndspeed">speed-control</a> variable.<br>
To reverse a track: <a href="sndscm.html#reversetrack">reverse-track</a><br>
To reverse an envelope: <a href="sndscm.html#reverseenvelope">reverse-envelope</a><br>
Virtual reverse-channel: <a href="#virtualreverse">xen-channel</a><br>
<br>
</small></blockquote>
</td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- reverse-sound -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndreverse">reverse-sound</a></em> (<i>snd chn edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
reverse data.  There are some interesting non-causal effects you can get with this:
take a voice sound, reverse it, reverberate it, reverse it again, and you get the original with
reversed reverb.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- revert-sound -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndrevert">revert-sound</a></em> (<i>snd</i>)</code></span>
</td></tr>
<tr><td></td><td>
revert <i>snd</i> to saved state (undo all edits).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- right-sample -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndrightsample">right-sample</a></em> (<em class=targ>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
position (samples) of right edge of time domain waveform.  See <a href="sndleftsample">left-sample</a> and many examples in examp.scm.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- run -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndrun">run</a></em> (thunk)</code></span>
</td></tr>
<tr><td></td><td>
<b>run</b> is the Snd equivalent of the CL/CLM run macro.  You can wrap it around any numerically-intensive
block of code, and the result will usually run 10 to 20 times faster.  In the context of with-sound, run is used
to speed up instrument bodies.  My timing tests indicate that Snd+Run instruments are within a factor of two to four
of the speed of CL+run+C in CLM.
<br><br><pre>
(define (ws-sine freq)
  (let ((o (make-oscil freq)))
    (run
     (lambda ()
       (do ((i 0 (1+ i)))
	   ((= i 100))
	 (outa i (oscil o) *output*))))))
</pre></td></tr>

<tr><td></td><td>
This optimization is also hidden in many contexts (map-channel, find, etc).  Internally the Snd run macro
uses 64-bit ints and doubles, so large sounds should not present any numerical problems.
See <a href="#optimization">optimization</a>
for some timings.  In Ruby, it's possible to use the <a href="http://www.zenspider.com/Languages/Ruby/">RubyInline</a> module instead.
</td></tr><tr><td colspan=2></td></tr>


<!-- sample -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndsample">sample</a></em> (<i>samp snd chn edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
value of sample <i>samp</i> in <i>snd</i>'s channel <i>chn</i>.
If the desired sample happens to fall outside the current buffer 
for the indicated channel, this function grinds to a halt -- if you're 
running a loop through a bunch of samples, use the <a href="#samplereaders">sample-readers</a> 
or <a href="#samples2vct">samples-&gt;vct</a> instead.  <i>samp</i> defaults to the current cursor location.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- samples -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndsamples">samples</a></em> (<i>samp samps snd chn edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
return vct of <i>samps</i> samples starting at <i>samp</i> in <i>snd</i>'s channel <i>chn</i>.
<i>samp</i> defaults to 0.  <i>samps</i> defaults to frames - samp.
<i>pos</i> is the edit history position to read (defaults to current position).
This is settable (as is <b>sample</b>) -- see <a href="#sndsetsamples">set-samples</a>.
(<i>samples</i> is basically another name for channel-&gt;vct and samples-&gt;vct).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- samples->sound-data -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="samples2sounddata">samples-&gt;sound-data</a></em> (<i>samp samps snd chn sdobj edpos sdchan</i>)</code></span>
</td></tr>
<tr><td></td><td>
similar to samples-&gt;vct, but fill a <a href="#sndsounddata">sound-data</a> object.  This is an optimization
for real-time audio applications; see play.scm.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- samples->vct -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="samples2vct">samples-&gt;vct</a></em> (<i>samp samps snd chn v edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
return vct struct with same data as in <i>samples</i> call above.  
If v (a vct) is provided, it is filled, rather than creating 
a new vct. <i>pos</i> is the edit history position to read.
The regularized version of this function is <a href="#channel2vct">channel-&gt;vct</a>.
There are many examples in examp.scm and dsp.scm.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- save-sound -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndsave">save-sound</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
save <i>snd</i>; same as File menu's Save option. <a href="#savehook">save-hook</a> is invoked upon save-sound.

<!-- INDEX saveexamples:Saving -->
<br><br>
<A NAME="saveexamples"></a>
<table border=3 bordercolor="tan" hspace=40><tr><td>
<small><blockquote>
To save all sounds: <code>(for-each save-sound (sounds))</code>.<br>
To save a sound under a different name: <a href="#sndsaveas">save-sound-as</a><br>
To extract one channel of a sound: <a href="#sndsaveas">save-sound-as</a><br>
To save a sound in a different format or header: <a href="#sndsaveas">save-sound-as</a><br>
To backup edits automatically: <a href="sndscm.html#exautosave">autosave</a><br>
To check first for unsaved edits: <a href="sndscm.html#exunsavededits">check-for-unsaved-edits</a><br>
To save Snd's complete state (unsaved edits and all): <a href="#sndsavestate">save-state</a>, <a href="#savedir">save-dir</a>, <a href="#savestatehook">save-state-hook</a>, <a href="#lsavestatefile">save-state-file</a><br>
To save just the current options: <a href="#sndsaveoptions">save-options</a><br>
To save the selection: <a href="#sndsaveselection">save-selection</a><br>
To save a region: <a href="#sndsaveregion">save-region</a><br>
To save a track: <a href="sndscm.html#savetrack">save-track</a><br>
To save the control panel state: <a href="#sndcontrolsave">save-controls</a><br>
To save currently defined envelopes (envelope editor): <a href="#sndsaveenvelopes">save-envelopes</a><br>
To start the file save dialog: <a href="#sndfilesaveasdialog">file-save-as-dialog</a><br>
To start the selection save dialog: <a href="#sndeditsaveasdialog">edit-save-as-dialog</a><br>
To use Emacs-style save-as behavior: <a href="#emacssytlesaveas">emacs-style-save-as</a><br>
To save the current listener text: <a href="#sndsavelistener">save-listener</a><br>
To save keyboard macros: <a href="#sndsavemacros">save-macros</a><br>
To save marks: <a href="#sndsavemarks">save-marks</a><br>
To save the audio hardware settings: <a href="#musaudiosave">mus-audio-save</a><br>
To save just the edit history: <a href="#sndsaveedithistory">save-edit-history</a><br>
To save the peak-env data: <a href="sndscm.html#peakenvdoc">save-peak-env-info</a><br>
To take some action upon a window manager save-yourself signal: <a href="sndscm.html#uponsaveyourself">upon-save-yourself</a><br>
To save the current sound setup for a later reopen: <a href="sndscm.html#exremembersoundstate">remember-sound-state</a><br>
To save the current fft peak info: <a href="#sndpeaks">peaks</a><br>
</blockquote></small>
</td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- save-sound-as -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndsaveas">save-sound-as</a></em> (filename <i>snd header-type data-format srate channel edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
save <i>snd</i> as <i>filename</i> (same as File Save as option).  If channel is specified,
only that channel is saved (extracted).  <i>edpos</i>, if given, specifies which edit history position to save.
Any argument can be #f (the default for an optional argument)
which causes its value to be taken from the sound being saved. 
To start a parallel editing branch on a given file, you could <code>(save-sound-as "test.snd") (open-sound "test.snd")</code>.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- scale-by -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndscaleby">scale-by</a></em> (scalers <i>snd chn</i>)</code></span>
</td></tr>
<tr><td></td><td>
<a href="snd.html#scaling">scale</a> amplitude of <i>snd</i> by <i>scalers</i>.  Unlike most of these functions,
scale-by follows the 'sync' buttons and affects all currently sync'd 
channels. <i>scalers</i> can be either a float or a vector of floats.  
In the latter case, the values are used one by one, applying each as 
scale-by moves through the channels. If 'sync' is off, channel <i>chn</i> 
is scaled (defaults to the currently selected channel).  <code>(scale-by 2.0)</code> doubles all samples.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- scale-channel -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="scalechannel">scale-channel</a></em> (scl <i>beg dur snd chn edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
<b>scale-channel</b> is the <a href="#regularizedargs">regularized</a> version of <a href="#sndscalesoundby">scale-sound-by</a>.
There are approximately a bazillion ways to scale samples in Snd; here's a potpourri of increasingly silly choices:<br><br>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(scale-by 2.0)
(scale-channel 2.0)
(map-chan (lambda (val) (* val 2.0)))
(set! (maxamp) (* 2 (maxamp)))
(env-sound '(0 2 1 2))
(env-channel (make-env '(0 1 1 1) :scaler 2.0) :end (1- (frames)))
(clm-channel (make-one-zero :a0 2.0 :a1 0.0))
(vct-&gt;samples 0 (frames) (vct-scale! (samples-&gt;vct) 2.0))
(begin (select-all) (mix-selection 0))
(begin (select-all) (scale-selection-by 2.0))
(begin (save-sound-as "temp.snd") (mix "temp.snd" 0) (delete-file "temp.snd"))

(ptree-channel (lambda (y data forward) (data y)) 0 (frames) 0 0 #f #t
	       (lambda (pos dur) (lambda (y) (* 2.0 y))) #f)

(let ((sd (samples-&gt;sound-data)))
  (do ((i 0 (1+ i))) 
      ((= i (frames)))
    (sound-data-set! sd 0 i (* 2.0 (sound-data-ref sd 0 i))))
  (set! (samples 0 (frames)) (sound-data-&gt;vct sd)))

(let ((flt (make-vct 8)))
  (vct-set! flt 0 2.0)
  (let ((cnv (make-convolve :filter flt))
	(sf (make-sample-reader 0)))
    (map-channel
     (lambda (val)
       (convolve cnv (lambda (dir) 
                       (read-sample sf)))))))

(do ((i 0 (1+ i)))
    ((= i (frames)))
  ;; don't actually do this! -- it involves a separate edit on each sample
  (set! (sample i) (* 2 (sample i))))

(let ((make-scaler 
       (lambda (start end)
	 (letrec ((ctr start)
		  (us (lambda (them)
			(set! (sample ctr) (* 2.0 (sample ctr)))
			(set! ctr (+ ctr 2))
			(if (&lt;= ctr end)
			    (them us)))))
	   us))))
  ((make-scaler 0 (frames)) 
     (make-scaler 1 (frames))))
</pre></td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- scale-sound-by -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndscalesoundby">scale-sound-by</a></em> (scaler <i>beg num snd chn edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
scales the samples in the given channel between beg and beg + num by scaler.  If the channel argument is omitted,
<b>scale-sound-by</b> scales the entire sound.  <i>beg</i> defaults to 0; <i>num</i> defaults to the length of the channel.
<i>snd</i> defaults to the selected sound, and <i>chn</i> to the selected channel.  Unlike scale-by, this ignores the sync setting.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- scale-sound-to -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndscalesoundto">scale-sound-to</a></em> (norm <i>beg num snd chn</i>)</code></span>
</td></tr>
<tr><td></td><td>
normalizes the samples in the given channel between beg and beg + num to norm.  If the channel argument is omitted,
<b>scale-sound-to</b> normalizes the entire sound.  <i>beg</i> defaults to 0; <i>num</i> defaults to the length of the channel.
<i>snd</i> defaults to the selected sound, and <i>chn</i> to the selected channel.  Unlike scale-to, this ignores the sync setting.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- scale-to -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndscaleto">scale-to</a></em> (<i>scalers snd chn</i>)</code></span>
</td></tr>
<tr><td></td><td>
(see scale-by) -- <a href="snd.html#scaling">normalize</a> <i>snd</i> to <i>scalers</i> (following sync as in scale-by).
<code>(scale-to 0.5)</code> scales the current channel so that it's maxamp is 0.5.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- scan-chan -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="scanchan">scan-chan</a></em> (func <i>start end snd chn edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
<b>scan-chan</b> applies <i>func</i> to samples in the specified channel.
A subsequence of the data can be requested via
'start' and 'end' points.  'start' defaults to 0; 'end'
defaults to the end of the channel.
The function is passed the current sample as its argument.
If it returns something other than #f, the scan is stopped and a list is returned
containing that value and the current sample position of the
scan. The following call scans the
current channel from sample 0 to the end looking for any sample greater than
.1:<br>
<pre>
&gt;<em class=typing>(scan-chan (lambda (y) (&gt; y .1)))</em>
<em class=listener>(#t 4423)</em>
</pre>
In this case, we found such a sample at position 4423.<br>
<pre>
(define every-sample?
  (lambda (proc)
    (let ((baddy (scan-chan (lambda (y) 
			      (not (proc y))))))
      (if baddy (set! (cursor) (cadr baddy)))
      (not baddy))))

&gt;<em class=typing>(every-sample? (lambda (y) (&lt; y .5)))</em>
<em class=listener>#t</em>
</pre>
<i>scan-chan</i> could be defined in terms of make-sample-reader:<br><br>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (scan-chan . args)
  (let* ((func (car args))
	 (len (length args))
	 (start (if (&gt; len 1) (cadr args) 0))
	 (snd (if (&gt; len 3) (cadddr args) (or (selected-sound) (car sounds))))
	 (chn (if (&gt; len 4) (caddddr args) (selected-channel snd)))
	 (end (if (&gt; len 2) (caddr args) (frames snd chn)))
	 (reader (make-sample-reader start snd chn))
	 (result #f))
    (do ((i start (1+ i)))
	((or result (= i end))
	 (let ((val (if result 
			(list result (- i 1))
			#f)))
	   (free-sample-reader reader)
	   val))
      (set! result (func (read-sample reader))))))
</pre></td></tr></table>
<br>snd4.scm has Snd-4 style scanning functions:<br><br>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define* (scan-all-chans proc #:optional (beg 0) end edpos)
  (catch 'done
	 (lambda ()
	   (apply for-each 
		  (lambda (snd chn)
		    (let ((result (<em class=red>scan-chan</em> proc beg end snd chn edpos)))
		      (if result (throw 'done (append result (list snd chn))))))
		  (all-chans)))
	 (lambda args (cadr args))))
</pre></td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- scan-channel -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="scanchannel">scan-channel</a></em> (func <i>beg dur snd chn edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
<b>scan-channel</b> is the <a href="#regularizedargs">regularized</a> version of <a href="#scanchan">scan-chan</a>.
In scan-chan, scan-channel, find, and count-matches (all the same underlying procedure), an attempt to jump back
into a previous call will not work.  That is,<br><br>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(let ((not-a-good-idea #f))
  (<em class=red>scan-channel</em> (lambda (y)
                  (call-with-current-continuation
	            (lambda (call)
		      (set! not-a-good-idea call)))
		  (&gt; y .001)))
  (not-a-good-idea))
</pre></td></tr></table>
<br>will die with a segfault (this is fixable, with much effort and grumbling).  If you want a continuable search, use a sample-reader:
<br><br>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define reader #f)
(define last-proc #f)
(define (<A NAME="scanagain">scan-again</a>)
  (if (sample-reader-at-end? reader)
      #f
      (let ((val (last-proc (reader))))
	(if val 
	    (list val (1- (sample-reader-position reader)))
	    (scan-again)))))
(define (my-scan-chan proc)
  (set! last-proc proc)
  (set! reader (make-sample-reader 0))
  (scan-again))
</pre></td></tr></table>
<br>Now <code>(my-scan-chan (lambda (y) (&gt; y .1)))</code> finds the first such sample, and
subsequent <code>(scan-again)</code> calls continue the search where the last call left off.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- search-procedure -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="searchprocedure">search-procedure</a></em> (<i>snd</i>)</code></span>
</td></tr>
<tr><td></td><td>
the current global or sound-local (if <i>snd</i> is specified) search procedure.
<code>(set! (search-procedure) (lambda (y) (&gt; y .1)))</code>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- selected-channel -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndselectedchannel">selected-channel</a></em> (<i>snd</i>)</code></span>
</td></tr>
<tr><td></td><td>
selected channel in <i>snd</i> (set it to select a channel).  Return #f is no channel is selected in snd. 
</td></tr>
<tr><td colspan=2></td></tr>


<!-- selected-sound -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndselectedsound">selected-sound</a></em> ()</code></span>
</td></tr>
<tr><td></td><td>
selected sound (index) (set it to select a sound). Return #f is there is no selected sound. 
</td></tr>
<tr><td colspan=2></td></tr>


<!-- select-channel -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndselectchannel">select-channel</a></em> (<i>chn</i>)</code></span>
</td></tr>
<tr><td></td><td>
select channel <i>chn</i>. This is the same as <code>(set! (selected-channel) chn)</code>. 
See also <a href="#selectchannelhook">select-channel-hook</a>.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- select-sound -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndselectsound">select-sound</a></em> (<i>snd</i>)</code></span>
</td></tr>
<tr><td></td><td>
select sound <i>snd</i> (an index). This is the same as <code>(set! (selected-sound) snd)</code>.
See also <a href="#selectsoundhook">select-sound-hook</a>.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- set-samples -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndsetsamples">set-samples</a></em> (samp samps data <i>snd chn trunc edname infile-chan edpos auto-delete</i>)</code></span>
</td></tr>
<tr><td></td><td>
set <i>snd</i>'s channel <i>chn</i>'s samples starting from
sample <i>samp</i> for <i>samps</i> samples to the values in <i>data</i>.
<small>(If <i>samp</i> is beyond the end of the file, the file is first zero-padded to reach it).</small>
<i>data</i> can be a filename.  If <i>data</i> is a vct, this is identical to vct-&gt;channel.
If <i>trunc</i> is #t and <i>samp</i> is 0, the
sound is truncated (if necessary) to reflect the end of <i>data</i>.
The form (set! (samples samp samps <i>snd chn trunc edname infile-chan</i>) data) can also be used.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- short-file-name -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="shortfilename">short-file-name</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
return the brief (no directory) form of <i>snd</i>'s filename.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- show-axes -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="showaxes">show-axes</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
(default: <code>show-all-axes</code>)
If <b>show-axes</b> is <code>show-all-axes</code>, display x and y axes; if <code>show-x-axis</code>, 
just one (bottom) x axis is displayed, reducing screen clutter. 
The other choice is <code>show-no-axes</code>.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- show-marks -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="showmarks">show-marks</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
If #t, marks are displayed.  This is the '<a href="snd.html#marks">Show marks</a>' View menu option.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- show-mix-waveforms -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="showmixwaveforms">show-mix-waveforms</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
If #t (default is #t), a mixed sound is displayed as a separate waveform above the main data.  The rectangular tag
at the start of the waveform can be dragged to move the mix, or clicked to select it for the mix panel.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- show-transform-peaks -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="showfftpeaks">show-transform-peaks</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
If #t, transform peak information is included in the transform display (default: #f).
This is the 'peaks' button in the <a href="snd.html#viewfft">Transform</a> options dialog.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- show-y-zero -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="showyzero">show-y-zero</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
If #t, the y=0 axis is displayed.  This is the '<a href="snd.html#viewy0">Show Y=0</a>' View menu option.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- smooth-channel -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="smoothchannel">smooth-channel</a></em> (<i>beg dur snd chn edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
<b>smooth-channel</b> is the <a href="#regularizedargs">regularized</a> version of <a href="#sndsmooth">smooth-sound</a>.
<i>smooth-channel-via-ptree</i> in examp.scm is the virtual form.

<!-- INDEX smoothexamples:Smoothing -->
<br><br>
<A NAME="smoothexamples"></a>
<table border=3 bordercolor="tan" hspace=40><tr><td>
<small><blockquote>
To smooth all channels: <a href="#sndsmooth">smooth-sound</a><br>
To smooth selection: <a href="#sndsmoothselection">smooth-selection</a><br>
To delete the selection and smooth the splice: <a href="sndscm.html#exdeleteselectionandsmooth">delete-selection-and-smooth</a><br>
Smoothing as virtual op: smooth-channel-via-ptree in examp.scm<br>
Smoothing via fft: <a href="sndscm.html#exfftsmoother">fft-smoother</a><br>
Smooth via low-pass <a href="#filtersinsnd">filter</a><br>
Smooth over click: Remove-click in examp.scm<br>
</blockquote></small>
</td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- smooth-sound -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndsmooth">smooth-sound</a></em> (beg num <i>snd chn</i>)</code></span>
</td></tr>
<tr><td></td><td>
apply a smoothing function to the indicated data.  This produces a sinusoid between
the end points:</td></tr>
<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (smoother y0 y1 num)
   "go sinusoidally from y0 to y1 over num samps"
   (let ((v (make-vct (1+ num))) 
	 (angle (if (&gt; y1 y0) pi 0.0)) 
	 (off (* .5 (+ y0 y1))) 
	 (scale (* 0.5 (abs (- y1 y0)))))
     (do ((i 0 (1+ i)))
         ((= i num) v)
       (vct-set! v i (+ off (* scale (cos (+ angle (* i (/ pi num))))))))))
</pre></td></tr></table>
</td></tr>
<tr><td></td><td>For a fancier version, see fft-smoother in examp.scm.  See also remove-clicks in examp.scm.</td></tr>

<!-- sound? -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndok">sound?</a></em> (<i>snd</i>)</code></span>
</td></tr>
<tr><td></td><td>
#t if <i>snd</i> (an index) points to an open sound. (After <a href="#sndupdate">update-sound</a>, it is possible, though unlikely
for the updated sound's index to change; a better way to deal with this problem is via <a href="#updatehook">update-hook</a>).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- soundfont-info -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="soundfontinfo">soundfont-info</a></em> (<i>snd</i>)</code></span>
</td></tr>
<tr><td></td><td>
return a list of lists describing <i>snd</i> as a soundfont.  Each inner list
consists of the sound name, start point, loop start, and loop end.
To set a named mark at the start of each sound with un-named marks 
at the loop points:
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (mark-sf2)
  (letrec ((sf2it (lambda (lst)
                    (if (not (null? lst))
                        (let ((vals (car lst)))
                          (let ((m1 (add-mark (cadr vals))))
                            (set! (mark-name m1) (car vals)))
                          (add-mark (caddr vals))
                          (add-mark (cadddr vals))
                          (sf2it (cdr lst)))))))
   (sf2it (<em class=red>soundfont-info</em>))))
</pre></td></tr></table></td></tr>
<tr><td></td><td>See also explode-sf2 in examp.scm.</td></tr>


<!-- sound-loop-info -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndsoundloopinfo">sound-loop-info</a></em> (<i>snd</i>)</code></span></td>
</tr><tr><td></td>
<td>return or set loop points in header.  In each case, the loop info is a list of
up to 4 points, the first two (start, end) refer to the sustain loop,
the second two to the release.  The 5th and 6th list entries are the base note and detune values.
For historical reasons, the 7th and 8th entries are the sustain and release modes.
This is similar to <a href="#soundloopinfo">mus-sound-loop-info</a> (but it's settable).  See <i>explode-sf2</i> in examp.scm.
</td></tr>

<!-- sound-properties -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndsoundproperties">sound-properties</a></em> (<i>snd</i>)</code></span>
</td></tr>
<tr><td></td><td>
A property list associated with the given sound.  It is set to '() at the time a sound is opened.  The accessor
<a href="sndscm.html#exsoundproperty">sound-property</a> is provided in extensions.scm.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- sounds -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sounds">sounds</a></em> ()</code></span>
</td></tr>
<tr><td></td><td>
list of currently active sounds (id numbers).
A common Snd trope is (map func (sounds)): <code>(map maxamp (<em class=red>sounds</em>))</code>.  Or, if
the return value is not needed: <code>(for-each (lambda (snd) (display (short-file-name snd))) (<em class=red>sounds</em>))</code>.
This can be
extended to provide a complete list of sounds and channels (since many Snd functions
take the "snd chn" arguments):
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (all-chans)
  (let ((sndlist '())
        (chnlist '()))
    (for-each (lambda (snd)
                (do ((i (1- (channels snd)) (1- i)))
                    ((&lt; i 0))
                  (set! sndlist (cons snd sndlist))
                  (set! chnlist (cons i chnlist))))
              (<em class=red>sounds</em>))
    (list sndlist chnlist)))

(apply map maxamp (all-chans))
</pre></td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- spectro-cutoff -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="spectrocutoff">spectro-cutoff</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
The amount of the frequency domain to include in the spectrum 
display (default: 1.0). This number changes as you drag the frequency
axis. This is the slider labelled '% of spectrum' in the View 
Orientation dialog. See <i>zoom-fft</i> in examp.scm.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- spectro-hop -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="spectrohop">spectro-hop</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
The distance (pixels) moved between successive spectrogram traces 
(default = 4).  This is the 'hop' slider in the Orientation dialog.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- spectro-start -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="spectrostart">spectro-start</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
The start point of the frequency domain to include in the spectrum
display (default 0.0).  See <i>zoom-fft</i> in examp.scm.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- spectro-x-angle -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="spectroxangle">spectro-x-angle</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
Default spectrogram x-axis viewing angle (default 90.0, in GL: 300.0).  See snd-gl.scm.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- spectro-x-scale -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="spectroxscale">spectro-x-scale</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
Default scaler (stretch) along the spectrogram x axis (default 1.0, in GL: 1.5).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- spectro-y-angle -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="spectroyangle">spectro-y-angle</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
Same for y-axis (default 0.0, in GL: 320.0).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- spectro-y-scale -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="spectroyscale">spectro-y-scale</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
Same for y-axis (default 1.0).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- spectro-z-angle -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="spectrozangle">spectro-z-angle</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
Same for z-axis (default 358.0, in GL: 0.0).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- spectro-z-scale -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="spectrozscale">spectro-z-scale</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
Same for z-axis (default 0.1, in GL: 1.0).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- squelch-update -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="squelchupdate">squelch-update</a></em> (<em class=targ>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
#t if graphic updates squelched (turned off).  If you're doing a sequence of edits where intermediate
states aren't of great interest, you can save time by turning off redisplays.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- srate -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndsrate">srate</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
<i>snd</i>'s sampling rate.  There are several srates floating around in Snd.  <code>(srate snd)</code> returns the
sampling rate of a particular (currently open) sound. <code>(mus-sound-srate filename)</code> returns a sound file's sampling
rate.  <code>mus-srate</code> is associated with the CLM package (setting the implicit srate for oscil etc).  
<code>default-output-srate</code> is the default sampling rate used when opening new files.  <code>enved-srate</code>
is a constant that can be assigned to the envelope editor's <code>enved-target</code> (to apply an envelope to 
the sampling rate).  <code>region-srate</code> is the sampling rate associated with a region.  <code>recorder-srate</code>
is the sampling rate of the ADC.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- src-channel -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="srcchannel">src-channel</a></em> (num-or-env-gen <i>beg dur snd chn edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
sampling rate conversion using 'warped sinc interpolation'.  The
argument <i>num-or-env-gen</i> can be either a number or an envelope generator.
This is the <a href="#regularizedargs">regularized</a> version of <a href="#sndsrc">src-sound</a>.

<!-- INDEX resampleexamples:Resampling -->
<br><br>
<A NAME="resampleexamples"></a>
<table border=3 bordercolor="tan" hspace=40><tr><td>
<small><blockquote>
resample all chans: <a href="#sndsrc">src-sound</a><br>
resample selection: <a href="#sndsrcselection">src-selection</a><br>
resample mix: speed control in <a href="snd.html#mixpanel">Mix dialog</a> (also <a href="#applycontrols">apply-controls</a>) or src-channel with mix id in list<br>
resample via drawn envelope: srate in <a href="snd.html#editenvelope">Envelope editor</a><br>
resample via CLM gen: <a href="clm.html#src">src</a><br>
resample with independent time control: expand in <a href="#customcontrols">control panel</a>, <a href="sndscm.html#exexpsrc">expsrc</a> and <a href="sndscm.html#exexpsnd">expsnd</a><br>
resampling-based sound effects: <a href="sndscm.html#exhellodentist">hello-dentist</a>, <a href="sndscm.html#exfp">fp</a> ("Forbidden Planet"), flange and chorus in dsp.scm and new-effects.scm<br>
the digital zipper: <a href="sndscm.html#zipdoc">zipper</a><br>
resample via FFT: <a href="sndscm.html#exdownoct">down-oct</a><br>
resample through env: <a href="sndscm.html#exsoundinterp">sound-interp</a> and <a href="sndscm.html#exenvsoundinterp">env-sound-interp</a><br>
resample through list: <a href="sndscm.html#scratch">scratch</a><br>
<br>
</blockquote></small>
</td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- src-sound -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndsrc">src-sound</a></em> (num-or-env <i>base snd chn edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
sampling rate conversion using 'warped sinc interpolation'.  The
argument <i>num-or-env</i> can be either a number or an envelope.  In 
the latter case, <i>base</i> sets the segment base (default is 1.0 = linear).
A value greater than 1.0 causes the sound to be transposed up.
A value less than 0.0 causes the sound to be reversed. 
<br>
<i>num-or-env</i> can also be a CLM env generator (its duration should
be the same as the original sound).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- start-playing -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="startplaying">start-playing</a></em> (<i>chans srate background</i>)</code></span>
</td></tr>
<tr><td></td><td>
if a <a href="#makeplayer">play-list</a> is waiting, start it.  <i>chans</i> defaults to 1, 
<i>srate</i> defaults to 44100, <i>background</i> defaults to #t. See play.scm or marks.scm.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- start-progress-report -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="startprogressreport">start-progress-report</a></em> (<i>snd</i>)</code></span>
</td></tr>
<tr><td></td><td>
Start a progress report; see <a href="#progressreport">progress-report</a>.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- stop-player -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="stopplayer">stop-player</a></em> (player)</code></span>
</td></tr>
<tr><td></td><td>
remove <i>player</i> from play-list(see <a href="#makeplayer">make-player</a>).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- stop-playing -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndstop">stop-playing</a></em> (<i>snd</i>)</code></span>
</td></tr>
<tr><td></td><td>
if <i>snd</i> is playing, stop it.
If no argument is given, stop all sounds (channels) in progress.  See play.scm or popup.scm; also
<a href="#stopplayinghook">stop-playing-hook</a>, <a href="#stopplayingchannelhook">stop-playing-channel-hook</a>,
<a href="#stopplayingregionhook">stop-playing-region-hook</a>, and
<a href="#stopplayingselectionhook">stop-playing-selection-hook</a>.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- swap-channels -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="swapchannels">swap-channels</a></em> (<i>snd1 chn1 snd2 chn2 beg dur edpos0 edpos1</i>)</code></span>
</td></tr>
<tr><td></td><td>
Swap the indicated channels, between beg and beg+dur.  See <i>swap-selection-channels</i> in examp.scm.
In simple cases, this is a virtual operation.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- sync -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndsyncing">sync</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
<i>snd</i>'s 'sync' value (an integer, 0=none). Several functions (scale-by, for example), apply to the
currently selected sound and also to any other sounds that share its sync value.  (I later decided that
this was a bad idea, hence the regularized replacements).  Sounds that share a given sync value 
move together when you drag an x-axis slider and so on.
<br><br>The built-in Guile/Posix function named sync ("flush OS disk buffers") is available (are you sure you want this?) as %sync.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- time-graph? -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndwaving">time-graph?</a></em> (<em class=targ>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
#t if the time domain graph is being displayed (the 'w' button).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- time-graph-style -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="timegraphstyle">time-graph-style</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
how time-domain data is displayed.
The choices are:<pre>
graph-lines  graph-dots  graph-filled  graph-lollipops  graph-dots-and-lines 
</pre>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- time-graph-type -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="wavo">time-graph-type</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
If <b>time-graph-type</b> is <code>graph-as-wavogram</code>, the time domain waveform is displayed as a '<a href="snd.html#wavogram">wavogram</a>'.
The default is <code>graph-once</code>.  See also <a href="#wavohop">wavo-hop</a> and <a href="#wavotrace">wavo-trace</a>.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- transform-graph? -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndffting">transform-graph?</a></em> (<em class=targ>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
#t if <i>snd</i>'s channel <i>chn</i> is displaying a spectrum (the 'f' button).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- transform-graph-style -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="transformgraphstyle">transform-graph-style</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
how frequency-domain data is displayed.
The choices are:<pre>
graph-lines  graph-dots  graph-filled  graph-lollipops  graph-dots-and-lines 
</pre>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- transform-graph-type -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="lfftstyle">transform-graph-type</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
choice of spectral display.  The choices are (default) <i>graph-once</i>, 
<i>graph-as-sonogram</i>, and <i>graph-as-spectrogram</i>.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- transform-normalization -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="normalizefft">transform-normalization</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
Transform normalization choice (default: <i>normalize-by-channel</i>)
If <i>normalize-by-channel</i> or <i>normalize-by-sound</i>, spectral data is 
normalized to 1.0 before display. If <i>dont-normalize</i>, you get the 
raw data values, which can reflect amplitude changes -- Snd tries to 
choose a y axis limit that makes successive displays move smoothly. The other choice is <i>normalize-globally</i> (i.e. across all sounds).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- transform-sample -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndtransformsample">transform-sample</a></em> (<i>bin slice snd chn</i>)</code></span>
</td></tr>
<tr><td></td><td>
return the current value of the transform (if any) in <i>bin</i> and (if a 
sonogram or spectrogram) <i>slice</i> in <i>snd</i>'s channel <i>chn</i>.  
</td></tr>
<tr><td colspan=2></td></tr>


<!-- transform-samples->vct -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="transformsamples2vct">transform-samples-&gt;vct</a></em> (<i>snd chn v</i>)</code></span>
</td></tr>
<tr><td></td><td>
return vct struct with the transform data currently in <i>snd</i>'s channel <i>chn</i>.
If v (a vct) is provided, it is filled, rather than creating a new vct.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- transform-samples-size -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="transformgraphsize">transform-samples-size</a></em> (<i>snd chn</i>)</code></span>
</td></tr>
<tr><td></td><td>
return either 0 if no transform, transform-size if graph-once,
or (list full-size bins slices) if sonogram or spectrogram.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- transform-size -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="lfftsize">transform-size</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
FFT size (default = 256).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- transform-type -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="ltransformtype">transform-type</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
The spectrum transform type (default: <i>fourier-transform</i>).
<pre>
fourier-transform  wavelet-transform   haar-transform
autocorrelation    walsh-transform     hadamard-transform  cepstrum     
</pre>
</td></tr>

<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndundo">undo</a></em> (<i>edits snd chn</i>)</code></span>
</td></tr>
<tr><td></td><td>
undo <i>edits</i> edits (default 1) in <i>snd</i>'s channel <i>chn</i>.
Undo follows the sync field if it
is not 0, which sometimes means that the channel arg is simply ignored.  The following might be a more reasonable undo function:
<br><br><pre>
(define* (<a name="undochannel">undo-channel</a> #:optional (edits 1) snd chn)
  (if (and snd (not (= (sync snd) 0)) chn)
      (set! (edit-position snd chn) (max 0 (- (edit-position snd chn) edits)))
      (undo edits snd)))
</pre>
See also <a href="#undohook">undo-hook</a>.
Since <b>redo</b> collides with Ruby, forcing me to change its name to redo_edit,
undo can also be accessed under the name undo_edit (in Scheme, <a name="undoedit">undo-edit</a>).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- update-lisp-graph -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndupdatelispgraph">update-lisp-graph</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
redisplay <i>chn's</i> lisp graph.  See <a href="sndscm.html#enveddoc">enved.scm</a> which uses the lisp graph as a local envelope editor.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- update-sound -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndupdate">update-sound</a></em> (snd)</code></span>
</td></tr>
<tr><td></td><td>
update <i>snd</i> (re-reads data from disk, flushing any pending edits).  In some cases (primarily involving
a change in the number of channels), update-sound can change the index of the sound referred to by 'snd'.
See <a href="#updatehook">update-hook</a> for a way to deal with the index confusion.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- update-time-graph -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndupdategraph">update-time-graph</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
redisplay <i>chn's</i> time domain graph.  See <i>color-samples</i> in draw.scm.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- update-transform-graph -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndupdatefft">update-transform-graph</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
redisplay <i>chn's</i> fft graph; for historical reasons, it also forces the current transform to completion.  
See <a href="#zeropad">zero-pad</a> and <a href="#beforeffthook">before-transform-hook</a>.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- view-sound -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndview">view-sound</a></em> (filename)</code></span>
</td></tr>
<tr><td></td><td>
open <i>filename</i> read-only (you can edit the sound within Snd, but you can't overwrite the original sound).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- verbose-cursor -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="verbosecursor">verbose-cursor</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
If #t, the cursor's position and other information is constantly 
displayed in the minibuffer.  This is the View:Verbose cursor option 
(default: #f).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- wavelet-type -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="wavelettype">wavelet-type</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
If <i><a href="#ltransformtype">transform-type</a></i> is <i>wavelet-transform</i>, <i>wavelet-type</i> selects which 
wavelet is used.  The list of available wavelets is in the Transform 
Dialog. There are currently 20 choices, so this variable goes from 
0 to 19 (default: 0).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- wavo-hop -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="wavohop">wavo-hop</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
This sets the distance upward between wavogram traces; that is,
the smaller this number, the more traces can be displayed (default: 3).  See <a href="#wavo">time-graph-type</a>.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- wavo-trace -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="wavotrace">wavo-trace</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
This sets the length (samples) of each wavogram trace (default: 64).  See <a href="#wavo">time-graph-type</a>.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- write-peak-env-info-file -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="writepeakenvinfofile">write-peak-env-info-file</a></em> (snd chn filename)</code></span>
</td></tr>
<tr><td></td><td>
writes the current peak-env amp info of the given channel to <i>filename</i>.
</td></tr>
<tr><td colspan=2></td></tr>

<!-- x-axis-style -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="xaxisstyle">x-axis-style</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
The x axis labelling of the time domain waveform can be in seconds
(<i>x-axis-in-seconds</i>), in samples (<i>x-axis-in-samples</i>), expressed
as a percentage of the overall duration (<i>x-axis-as-percentage</i>, useful in envelope definitions), or as a beat number (<i>x-axis-in-beats</i>).
This is the View menu 'X-axis units' option.
(default: <i>x-axis-in-seconds</i>). 
</td></tr>
<tr><td colspan=2></td></tr>


<!-- x-bounds -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndxbounds">x-bounds</a></em> (<i>snd chn</i>)</code></span>
</td></tr>
<tr><td></td><td>
return (list x0 x1) -- current x axis time domain bounds in seconds.
<code>(set! (x-bounds) (list 0.0 (/ (frames) (srate))))</code> shows the full sound.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- x->position -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="x2position">x-&gt;position</a></em> (x snd chn axis)</code></span>
</td></tr>
<tr><td></td><td>
return the graph position that corresponds to the X axis value <i>x</i>. <i>axis</i> is one of time-graph, lisp-graph, or transform-graph.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- x-position-slider -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="xpositionslider">x-position-slider</a></em> (<em class=targ>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
value of x axis position slider.  See <i>zoom-fft</i> in examp.scm.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- x-zoom-slider -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="xzoomslider">x-zoom-slider</a></em> (<em class=targ>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
value of x axis zoom slider.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- xramp-channel -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="xrampchannel">xramp-channel</a></em> (rmp0 rmp1 base <i>beg dur snd chn edpos</i>)</code></span>
</td></tr>
<tr><td></td><td>
<b>xramp-channel</b> is a slight extension of scale-channel. It scales samples in the given sound/channel
between beg and beg + dur by an exponential ramp going from rmp0 to rmp1 with the connecting segment curvature
set by base. (<b>xramp-channel</b> underlies the virtual exponential envelope operations).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- y-bounds -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndybounds">y-bounds</a></em> (<i>snd chn</i>)</code></span>
</td></tr>
<tr><td></td><td>
return (list y0 y1) -- current y axis bounds.
To set the bounds to reflect the channel's maxamp, use (set! (y-bounds) '()).
To set all channels at once using the selected sound's maxamp:
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(let ((maxval (apply max (maxamp #f #t)))) 
  (do ((i 0 (1+ i))) 
      ((= i (chans))) 
    (set! (<em class=red>y-bounds</em> #f i) (list (- maxval) maxval))))
</pre></td></tr></table></td></tr>

<tr><td></td><td>
Or to set each channel to its own maxamp:
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(do ((i 0 (1+ i))) 
    ((= i (chans)))
  (let ((maxval (maxamp #f i))) 
    (set! (<em class=red>y-bounds</em> #f i) (list (- maxval) maxval))))
</pre></td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>


<!-- y->position -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="y2position">y-&gt;position</a></em> (y snd chn axis)</code></span>
</td></tr>
<tr><td></td><td>
return the graph position that corresponds to the Y axis value <i>y</i>. <i>axis</i> is one of time-graph, lisp-graph, or transform-graph.
This is used in <i>samples-via-colormap</i> in draw.scm to draw the time domain samples in many colors.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- y-position-slider -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="ypositionslider">y-position-slider</a></em> (<em class=targ>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
value of y axis position slider.  See <i>zync</i> in snd-motif.scm.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- y-zoom-slider -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="yzoomslider">y-zoom-slider</a></em> (<em class=targ>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
value of y axis zoom slider.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- zero-pad -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="zeropad">zero-pad</a></em> (<em class=narg>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
fft zero pad size as a multiple of the fft size; <code>(set! (zero-pad) 1)</code>
gives you half data, half zeros (default: 0) (the data length is 
determined by the nominal transform-size).  Zero padding causes sinc-interpolation 
of the fft points, making the display smoother.
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(bind-key (char-&gt;integer #\p) 0 
  (lambda () 
    (set! (zero-pad) (+ (<em class=red>zero-pad</em>) 1)) 
    (update-transform-graph)))

(bind-key (char-&gt;integer #\m) 0 
  (lambda () 
    (set! (zero-pad) (- (<em class=red>zero-pad</em>) 1)) 
    (update-transform-graph)))
</pre></td></tr></table></td></tr>
<tr><td colspan=2></td></tr>

</table>


<table width="100%" border=1><tr><td bgcolor="lightgreen" valign="middle"><h4><A NAME="customcontrols">the control panel</a></h4></td></tr></table>

<p>
The control panel normally processes samples as follows: if the sampling
rate conversion is on (the 'Speed' control is not 1.0), it applies srate
conversion to the incoming sample; the next stage is the expansion function,
if the 'Expand' toggle button is set; this value is passed
next to the Contrast function, if it is running, and then the result
is scaled by the Amp slider's value.  The filter is run next, if
it's on, and finally the sample is scaled by the reverb slider and
passed to the reverb, if any, which adds its result to the sample;
the final result is sent to the speakers.
The control panel procedures are:
</p>
<!-- -------------------------------- CONTROL PANEL -------------------------------- -->
<table border=0 cellspacing=10>

<!-- amp-control -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndamp">amp-control</a></em> (<em class=targ>snd chn</em>)</code></span>
</td></tr>
<tr><td><spacer type=horizontal size=40><br></td><td>
The current amp value.
It is possible to use these controls (in "real-time") in your own functions.
See amprt in <a href="sndscm.html#exampdoc">examp.scm</a> for a simple example,
or <i>add-amp-control</i> in snd-motif.scm.
As an experiment, I added the optional <i>chn</i> argument; if it is specified, the
channel's local amp-control value is set instead of the sound's.  This affects the
apply button (apply-controls) and playback.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- apply-controls -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="applycontrols">apply-controls</a></em> (<i>snd target beg dur</i>)</code></span>
</td></tr>
<tr><td></td><td>
The  'apply' button.
<i>target</i> can be 0=sound, 1=channel, 2=selection.
<i>beg</i> sets where in samples the apply starts: <code>(apply-controls 0 0 (mark-sample m))</code> starts from the given mark.
<i>dur</i>, if given, sets how many samples to run through the apply process.
apply-controls can be used in conjunction with the various control panel variables:
</td></tr>
<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define expnd 
  (lambda (amt) 
    (set! (expand-control?) #t) 
    (set! (expand-control) amt) 
    (<em class=red>apply-controls</em>)))
</pre></td></tr></table><br>
For many examples see new-effects.scm.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- contrast-control -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndcontrast">contrast-control</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The <a href="snd.html#contrast">contrast</a> amount.
The contrast-enhancement algorithm treats this variable as a kind of modulation index (the higher, the brighter),
whereas <i>contrast-control-amp</i> below prescales the in-coming signal to be closer to -1.0 to 1.0
(the brightening effect works best if it has a full amplitude signal to work with).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- contrast-control-amp -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndcontrastamp">contrast-control-amp</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The <a href="snd.html#contrast">contrast-control-amp</a> (a prescaler on the contrast-enhancement to get the
full effect of the compander).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- contrast-control? -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndcontrasting">contrast-control?</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The <a href="snd.html#contrast">contrast</a> button.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- expand-control -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndexpand">expand-control</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The <a href="snd.html#expand">expansion</a> amount.  This sets the ratio between the
output and input grain spacing.  If it is greater than 1.0, the result is longer.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- expand-control-hop -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndexpandhop">expand-control-hop</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The <a href="snd.html#expand">expansion</a> hop amount in seconds.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- expand-control-length -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndexpandlength">expand-control-length</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The <a href="snd.html#expand">expansion</a> segment (grain) length in seconds.  The longer the grain,
the more reverberated or slurred the effect.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- expand-control-ramp -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndexpandramp">expand-control-ramp</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The <a href="snd.html#expand">expansion</a> ramp amount (between 0 and .5).
This affects the smoothness of the grain overlaps -- .001 gives a 
rattling effect.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- expand-control? -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndexpanding">expand-control?</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The expand button.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- filter-control-coeffs -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndfiltercoeffs">filter-control-coeffs</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The <a href="snd.html#filtercontrol">filter</a> coefficients (read-only currently).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- filter-control-in-dB -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndfilterdbing">filter-control-in-dB</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The <a href="snd.html#filtercontrol">filter</a> dB button.  If #t, the filter (frequency) envelope
graph is displayed in dB.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- filter-control-env -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndfilterenv">filter-control-env</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The <a href="snd.html#filtercontrol">filter</a> envelope (a list of breakpoints).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- filter-control-order -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndfilterorder">filter-control-order</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The <a href="snd.html#filtercontrol">filter</a> order.  This affects how much computing
is needed to run the filter, and how close the filter can get to the desired frequency envelope.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- filter-control? -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndfiltering">filter-control?</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The control panel filter button.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- reset-controls -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndcontrolreset">reset-controls</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The 'reset' button.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- restore-controls -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndcontrolrestore">restore-controls</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The '<a href="snd.html#savcontrols">restore</a>' button (see new-effects.scm).
</td></tr>
<tr><td colspan=2></td></tr>

<!-- reverb-control-decay -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="reverbdecay">reverb-control-decay</a></em> (<em class=narg>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The length (seconds) of the reverberation after the sound has 
finished (default: 1.0).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- reverb-control-feedback -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndreverbfeedback">reverb-control-feedback</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The reverb feedback coefficient.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- reverb-control-length -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndreverblength">reverb-control-length</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The <a href="snd.html#reverb">reverb</a> delay line length scaler. 
</td></tr>
<tr><td colspan=2></td></tr>


<!-- reverb-control-lowpass -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndreverblowpass">reverb-control-lowpass</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The reverb low pass filter coefficient.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- reverb-control-scale -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndreverbscale">reverb-control-scale</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The <a href="snd.html#reverb">reverb</a> amount (the amount of the direct signal sent to the reverb).
</td></tr>
<tr><td colspan=2></td></tr>


<!-- reverb-control? -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndreverbing">reverb-control?</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The control panel's reverb button.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- save-controls -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndcontrolsave">save-controls</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The control panel '<a href="snd.html#savcontrols">s</a>' button.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- show-controls -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndshowcontrols">show-controls</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>#t if <i>snd</i>'s control panel is currently open.
If set to #t, <i>snd</i>'s control panel is opened, else it is closed. 
</td></tr>
<tr><td colspan=2></td></tr>


<!-- speed-control -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndspeed">speed-control</a></em> (<em class=targ>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
current <a href="snd.html#speed">speed</a>.
</td></tr>
<tr><td colspan=2></td></tr>


<!-- speed-control-style -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="lspeedstyle">speed-control-style</a></em> (<em class=narg>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The speed control can be interpreted as a 
float, (<i>speed-control-as-float</i>, the default), as a just-intonation ratio 
of relatively small integers (<i>speed-control-as-ratio</i>), or as a step in a 
microtonal scale (<i>speed-control-as-semitone</i>).  
</td></tr>
<tr><td colspan=2></td></tr>


<!-- speed-control-tones -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="speedtones">speed-control-tones</a></em> (<em class=narg>snd</em>)</code></span>
</td></tr>
<tr><td></td><td>
The number of tones per octave in the <i>speed-control-as-semitone</i> speed 
style (default: 12).
</td></tr>
<tr><td colspan=2></td></tr>


</table>

<!-- INDEX editlists:Edit lists -->
<!-- Edit Lists -->
<br>
<table width="100%" border=1><tr><td bgcolor="lightgreen" valign="middle"><h3><A NAME="editlists">Edit Lists</a></h3></td></tr></table>

<p>An edit list (in other editors this is called an "edit decision list", I guess because it sounds decisive)
describes the edit history of a channel. When, for example, you type C-d, nothing actually
happens to any data, despite the fact that the graph no longer shows that sample, it's omitted when you play the
channel, and so on.  Instead, a descriptor is appended to the edit history of that
channel saying "sample n was deleted".  Undo and redo move around in this list (they simply move the
pointer to the current edit history position); all the positions are accessible just like the current
one, and are exposed in many functions described above via the <i>pos</i> or <i>edpos</i> arguments.
The edit list functions are:</p>

<!-- -------------------------------- EDIT-LIST TABLE -------------------------------- -->

<table border=0 cellspacing=10>

<!-- as-one-edit -->

<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="asoneedit">as-one-edit</a></em> (func <i>origin</i>)</code></span>
</td></tr>
<tr><td width=150></td><td>
apply <i>func</i>, a function of no arguments, treating it as
one edit (in all channels) in the edit history mechanism.  Graphics redisplays are squelched during as-one-edit.
Returns result of 'func'.
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(<em class=red>as-one-edit</em> 
  (lambda () 
    (set! (sample 100) .1) 
    (set! (sample 200) .2)))
</pre></td></tr></table>
<br>
See mix.scm for many examples. If you want to save Snd's state after using as-one-edit, you need to
set 'origin' to some string that can restore the effect of the as-one-edit 'func'; the default is
to copy the last edit history string and use its associated bounds -- unlikely to be what you want.
</td></tr>
<tr><td></td><td></td></tr>

<!-- display-edits -->

<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="snddisplayedits">display-edits</a></em> (<i>snd chn edpos with-source</i>)</code></span>
</td></tr>
<tr><td></td><td>
return the current edit list contents as a string.  If <i>edpos</i> is specified, only that position is described.
<i>with-source</i> (default #t) determines whether ptree source code is included in the output.
</td></tr>
<tr><td></td><td></td></tr>

<!-- edit-fragment -->

<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndeditfragment">edit-fragment</a></em> (<i>num</i> <em class=targ>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
return a list similar to that displayed in the edit history window giving 
the origin of the specified edit, its type (delete, insert, etc), its 
begin sample, and the number of samples 
affected.  If num is omitted, edit-fragment returns the currently active
edit.
</td></tr>
<tr><td></td><td></td></tr>

<!-- edit-position -->

<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndeditposition">edit-position</a></em> (<em class=targ>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
current position in the edit history list; can be set.  <code>(set! (edit-position) 0)</code> is equivalent
to <code>(revert-sound)</code>.
See <a href="#makesamplereader">make-sample-reader</a>.
</td></tr>
<tr><td></td><td></td></tr>

<!-- edits -->

<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndedits">edits</a></em> (<em class=targ>snd chn</em>)</code></span>
</td></tr>
<tr><td></td><td>
return a list with the number of undo-able edits and redo-able edits.  That is, if we have 2 undo-able edits and
no redo-able edits, (edits) returns (list 2 0).
</td></tr>
<tr><td></td><td></td></tr>

<!-- edit-tree -->

<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndedittree">edit-tree</a></em> (<i>snd chn pos</i>)</code></span>
</td></tr>
<tr><td></td><td>
return a list of lists completely describing current edit list.
Each inner list has the form 
<br>
'(global-position data-number local-position local-end scaler).
<br>
If <i>data-number</i> is -2, it marks the end of the list.  The following function uses
this information to highlight the changed portions of a given sound.
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (<A NAME="showoriginal">show-original</a> snd chn)
  ;; draw a bar above unchanged portions of a sound
  (define (check-fragment tree ls rs)
    (let* ((fragment (car tree))       ; current edit list fragment
           (pos (car fragment))        ; its position in sound
           (dat (cadr fragment))
           (scl (list-ref fragment 4)))
      (if (and (= dat 0)               ; original sound
               (= scl 1.0))            ; unscaled
          (let ((nxtpos (car (cadr tree))))
            (if (and (&lt;= pos rs)
                     (&gt;= nxtpos ls))   ; fragment is at least partially visible
                (let ((x0pos (x-&gt;position (/ (max ls pos) (srate))))
                      (x1pos (x-&gt;position (/ (min rs nxtpos) (srate)))))
                  (fill-rectangle x0pos 2 (- x1pos x0pos) 5)))))
      (if (and (cdr tree)              ; go to next fragment
               (not (= (cadr (car tree)) -2)))
          (check-fragment (cdr tree) ls rs))))
   (check-fragment (<em class=red>edit-tree</em> snd chn)
                   (left-sample snd chn)
                   (right-sample snd chn)))
(add-hook! after-graph-hook show-original)
</pre></td></tr></table></td></tr>
<tr><td></td><td></td></tr>


<!-- save-edit-history -->

<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndsaveedithistory">save-edit-history</a></em> (filename <i>snd chn</i>)</code></span>
</td></tr>
<tr><td></td><td>
save current edit list(s) in <i>filename</i>.
If <i>chn</i> is omitted, all <i>snd</i>'s channels are saved; if <i>snd</i> is omitted,
all edit lists are saved.  If the underlying files are not subsequently 
changed, you can load this file to restore the current edit list state.
save-edit-history returns #t if all went well.
The following function makes an
exact copy of the state (edit lists and all) of the given sound,
providing a way to fork an edit path (geez, what jargon!).  The idea here
is to copy the complete edit state into a new sound so that two or more
edit sequences can be compared.
</td></tr>
<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define sfile 0)

(define* (<a name="clonesoundas">clone-sound-as</a> new-name #:optional snd)
  (let* ((tmpf (snd-tempnam))
	 (scm (string-append (substring tmpf 0 (- (string-length tmpf) 3)) "scm"))
	 (oldsnd (or snd (selected-sound))))
    (if (not (string? (save-dir))) (set! (save-dir) "/tmp"))
    (<em class=red>save-edit-history</em> scm oldsnd)
    (copy-file (file-name oldsnd) new-name)
    (set! sfile (open-sound new-name))
    (load scm)
    (delete-file scm)
    sfile))
</pre></td></tr></table></td></tr>
<tr><td></td><td></td></tr>

</table>

<p>It is sometimes more convenient to edit the edit history lists
directly, than to run Snd and invoke the <a href="snd.html#savedstate">"Save State"</a> menu option.
To save a particular sound's or channel's edit list(s), use the
function <a href="#sndsaveedithistory">save-edit-history</a>.
These lists are simply Scheme or Ruby programs, just like anything else
discussed in this document.  You could even write them from
scratch.  Say we want to make a stereo file that consists
of four mono files mixed at various points; we know where they
should go, and we have religious objections to using a
graphical user interface.  So we create myfile.scm, and
put in it something like:</p>

<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(let ((myfile (<a href="#sndnew">new-sound</a> "mysound.snd" mus-aifc-sound-file mus-bshort 44100 2 "this is my sound")))
	;; this is equivalent to the New file menu option
  (<a href="#sndmix">mix</a> "oboe.snd" 0 0 myfile 0)
  ;; this mixes in the mono file oboe.snd at sample 0 in channel 0
  ;; use (mix "oboe.snd" 0 0 myfile 0 #f) to forego the editable mix
  (mix "pistol.snd" 0 0 myfile 1)
  ;; now pistol.snd is at sample 0 in channel 1
  (mix "fyow.snd" 10000 0 myfile 0)
  ;; add in fyow.snd at sample 10000 in the first channel
  (mix "cardinal.snd" 20000 0 myfile 1)
  ;; etc
  )
</pre></td></tr></table>

<p>Now start Snd: <code>snd -l myfile.scm</code> and voila!
Files like this can contain any arbitrary code, calling
anything in Snd or anywhere else for that matter; you
have a CLM-like notelist reader to describe sound file edits.
Similarly, when you save Snd's state (via the Save State menu
option or by calling the function <a href="#sndsavestate">save-state</a>),
the result is a program that can be edited just like any
other such text.
</p>
<p>
Many editing operations within Snd actually only affect the current
edit lists.  For example, if you delete a portion of a sound, the
only thing that happens is that the edit list of that sound is
updated to reflect the jump over the deleted portion.  Similarly,
all scaling operations, silences,
envelopes, and simple cases of channel swaps only affect
the edit list.  This means that ideally such operations are instantaneous
and take no disk space no matter how large the sound being edited
(in other cases we have to save at least the changed portion of the
sound).  <a href="#ptreechannel">ptree-channel</a> (still in the experimental stages) extends this part of Snd to 
(almost) arbitrary functions. 
</p>



<!-- Transforms -->
<br>
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="sndtransforms">Transforms</a></h3></td></tr></table>

<p>Except for add-transform, the transform functions and variables have been treated above, so this is just
a list of them with cross-references.</p>

<!-- -------------------------------- TRANSFORM TABLE -------------------------------- -->

<table border=0 cellspacing=10>

<!-- add-transform -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="addtransform">add-transform</a></em> (name xlabel lo hi transform)</code></span>
</td></tr>
<tr><td width=150></td><td>
add-transform adds a transform to the transform tables.  <i>name</i> is the name
to use in the transform dialog. <i>xlabel</i> is the x axis label
of the resultant graph.  <i>lo</i> and <i>hi</i> set which portion of the returned data
to graph (normally 0.0 to 1.0).  <i>proc</i> is a function of two 
arguments, the length of the desired transform, and a sample-reader that 
can be used to get the current data.  Do not free the sample-reader!  
The function should return a vct containing the transform data.  
add-transform returns the new transform's transform-type.
Here's an example that displays a histogram of the current values in 16 bins:
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(<em class=red>add-transform</em> "histogram" "bins" 0.0 1.0 
  (lambda (len fd)
    (let ((v (make-vct len))
          (steps (/ len 16))
          (step (/ 1.0 len)))
      (do ((i 0 (1+ i))) 
          ((= i len) v)
        (let* ((val (read-sample fd))
               (bin (inexact-&gt;exact (* (abs val) 16.0))))
          (do ((j 0 (1+ j))) 
              ((= j steps))
            (vct-set! v 
                      (+ j bin) 
                      (+ step (vct-ref v (+ j bin))))))))))
</pre></td></tr></table></td></tr>

<tr><td></td><td>
And an example that ties the Hilbert transform in dsp.scm into the user-interface:
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(<em class=red>add-transform</em> "Hilbert" "Hilbert" 0.0 1.0
  (lambda (len fd)
    (let ((flt (make-hilbert-transform 40)))
      (do ((i 0 (1+ i))) ; preload first samples
	  ((= i 40))
	(fir-filter flt (read-sample fd)))
      (vct-map! 
       (make-vct len) 
       (lambda () 
	 (fir-filter flt (read-sample fd)))))))
</pre></td></tr></table></td></tr>

<!-- autocorrelate -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndautocorrelate">autocorrelate</a></em> (data)</code></span></td></tr>
<tr><td></td><td>
return the (in place) autocorrelation of <i>data</i> (a vct).  See <a href="sndscm.html#spotfreq">spot-freq</a> in dsp.scm, 
or <a href="sndscm.html#rubberdoc">rubber.scm</a>.
</td></tr>
<tr><td colspan=2></td></tr>

<!-- fft -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndfft">fft</a></em> (rl im <i>sgn</i>)</code></span></td></tr>
<tr><td></td><td>
perform an FFT on vcts <i>rl</i> and <i>im</i> (the real and imaginary parts of the
input data). <i>sgn</i> is 1 for an FFT, -1 for an inverse FFT; (default 1).
</td></tr>
<tr><td colspan=2></td></tr>

<!-- vct-convolve! -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="vctconvolve">vct-convolve!</a></em> (rl1 rl2)</code></span></td></tr>
<tr><td></td><td>
convolve vct <i>rl1</i> with <i>rl2</i>.  Result in rl1.
rl1 should be large enough to hold the full convolution result.
This function is the same as <a href="clm.html#convolution">convolution</a>.
</td></tr>
<tr><td colspan=2></td></tr>
</table>

<p>Other related variables and functions:</p>
<table cellpadding=0 celspacing=10 border=0>
<tr><td width=200><a href="#sndffting"><small>transform-graph?</small></a></td><td width=200><a href="#showfftpeaks"><small>show-transform-peaks</small></a></td><td><a href="#sndtransformsample"><small>transform-sample</small></a></td></tr>
<tr><td><a href="#fftbeta"><small>fft-window-beta</small></a></td><td><a href="#lshowselectiontransform"><small>show-selection-transform</small></a></td><td><a href="#transformsamples2vct"><small>transform-samples-&gt;vct</small></a></td></tr>
<tr><td><a href="#ffthook"><small>transform-hook</small></a></td><td><a href="#spectrocutoff"><small>spectro-cutoff</small></a></td><td><a href="#transformgraphsize"><small>transform-samples-size</small></a></td></tr>
<tr><td><a href="#fftlogfrequency"><small>fft-log-frequency</small></a></td><td><a href="#spectrohop"><small>spectro-hop</small></a></td><td><a href="#ltransformtype"><small>transform-type</small></a></td></tr>
<tr><td><a href="#fftlogmagnitude"><small>fft-log-magnitude</small></a></td><td><a href="#spectrostart"><small>spectro-start</small></a></td><td><a href="#sndupdatefft"><small>update-transform-graph</small></a></td></tr>
<tr><td><a href="#lfftsize"><small>transform-size</small></a></td><td><a href="#spectroxangle"><small>spectro-x-angle</small></a></td><td><a href="#normalizefft"><small>transform-normalization</small></a></td></tr>
<tr><td><a href="#lfftstyle"><small>transform-graph-type</small></a></td><td><a href="#spectroxscale"><small>spectro-x-scale</small></a></td><td><a href="#zeropad"><small>zero-pad</small></a></td></tr>
<tr><td><a href="#lfftwindow"><small>fft-window</small></a></td><td><a href="#spectroyangle"><small>spectro-y-angle</small></a></td><td><a href="#wavelettype"><small>wavelet-type</small></a></td></tr>
<tr><td><a href="#maxfftpeaks"><small>max-transform-peaks</small></a></td><td><a href="#spectroyscale"><small>spectro-y-scale</small></a></td><td><a href="#spectrozscale"><small>spectro-z-scale</small></a></td></tr>
<tr><td><a href="#mindb"><small>min-dB</small></a></td><td><a href="#spectrozangle"><small>spectro-z-angle</small></a></td><td></td></tr>
</table>

<p>And some of the fft-based effects/editing functions:
</p>
<!-- INDEX fftexamples:FFTs -->
<A NAME="fftexamples"></a>
<table border=3 bordercolor="tan" hspace=40><tr><td>
<small><blockquote>
CLM fft function: <a href="clm.html#fft">mus-fft</a><br>
CLM spectrum: <a href="clm.html#spectrum">spectrum</a><br>
Snd spectrum: <a href="#sndspectrum">snd-spectrum</a><br>
Cross Correlation: <a href="sndscm.html#excorrelate">correlate</a><br>
FFT window: <a href="clm.html#make-fft-window">make-fft-window</a><br>
Dolph-Chebyshev window in Scheme: <a href="sndscm.html#exdolph">dolph</a><br>
Hartley transform in Scheme: <a href="sndscm.html#exdht">dht</a><br>
Spectral edit dialog: <a href="snd.html#editenvelope">Envelope Editor</a><br>
<br>
fft-based filter: <a href="sndscm.html#exfftedit">fft-edit</a>, <a href="sndscm.html#exfftenvedit">fft-env-edit</a>, <a href="sndscm.html#exfftenvinterp">fft-env-interp</a>, <a href="sndscm.html#exfftsquelch">fft-squelch</a>, <a href="sndscm.html#exfftcancel">fft-cancel</a><br>
phase-vocoder: <a href="clm.html#phase-vocoder">phase-vocoder</a>. <a href="sndscm.html#pvocdoc">pvoc</a><br>
transposition via fft: <a href="sndscm.html#exdownoct">down-oct</a><br>
phase rotation via fft: <a href="sndscm.html#zerophase">zero-phase, rotate-phase</a><br>
duration change via autocorrelation: <a href="sndscm.html#rubberdoc">rubber-sound</a><br>
smoothing via fft: <a href="sndscm.html#exfftsmoother">fft-smoother</a><br>
cross-synthesis: <a href="sndscm.html#excrosssynthesis">cross-synthesis</a><br>
voiced-&gt;unvoiced effect: <a href="sndscm.html#exvoiced2unvoiced">voiced-&gt;unvoiced</a><br>
noise reduction: <a href="sndscm.html#clminsdoc">anoi</a><br>
spectral modeling: <a href="sndscm.html#clminsdoc">pins</a><br>
<br>
Superimpose ffts: <a href="sndscm.html#exsuperimposeffts">superimpose-ffts</a><br>
Waterfall real-time spectrograph: <a href="sndscm.html#startwaterfall">start-waterfall</a><br>
Simple rt spectrum: <a href="sndscm.html#exshowinputfft">show-input-fft</a>, <a href="sndscm.html#exshowdraggableinputfft">show-draggable-input-fft</a><br>
</blockquote></small>
</td></tr></table>

<!-- Dialogs -->
<br>
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="snddialogs">Dialogs</a></h3></td></tr></table>
<p>Many aspects of the various dialogs can be customized.  The following is organized by dialog, or was meant to be originally.</p>

<!-- -------------------------------- DIALOG TABLE -------------------------------- -->
<table border=0 cellspacing=10>

<!-- just-sounds -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="justsounds">just-sounds</a></em> ()</code></span></td></tr>
<tr><td width=150></td><td>reflects the just-sounds button (if any). See also <a href="#justsoundshook">just-sounds-hook</a>.</td></tr>

<!-- file-dialog -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndfiledialog">file-dialog</a></em> ()</code></span></td></tr>
<tr><td></td><td>create the <a href="snd.html#prevfiles">list</a> of current and previous files (not the file browser), if necessary, activate it, and return the dialog widget.</td></tr>

<!-- mix-file-dialog -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmixfiledialog">mix-file-dialog</a></em> (managed)</code></span></td></tr>
<tr><td></td><td>create the File:Mix file selection dialog, if necessary, and make it visible if <i>managed</i>.</td></tr>

<!-- open-file-dialog -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndopenfiledialog">open-file-dialog</a></em> (managed)</code></span></td></tr>
<tr><td></td><td>create the File:Open file selection dialog, if necessary, and make it visible if <i>managed</i> (see snd-motif.scm).</td></tr>

<!-- previous-files-sort -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="previousfilessort">previous-files-sort</a></em> ()</code></span></td></tr>
<tr><td></td><td>Sort choice in files dialog (0=unsorted, 1=name, 2=date, 3=size, 4=entry, 5=user procedure).</td></tr>

<!-- previous-files-sort-procedure -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="filessortproc">previous-files-sort-procedure</a></em> ()</code></span></td></tr>
<tr><td></td><td>Procedure used to sort files in the files dialog.  It takes one argument, the list of files, and
should return that list, sorted as it pleases.  The following sorts the list by decreasing max amp:
</td></tr>

<tr><td></td><td><table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(set! (<em class=red>previous-files-sort-procedure</em>)
  (lambda (lst)
    (sort lst 
	  (lambda (a b)
	    (define (mxall mxcur mxlst)
	      (if (null? mxlst)
		  mxcur
		  (mxall (max mxcur (cadr mxlst)) (cddr mxlst))))
	    (let ((mxa (<em class=red>mus-sound-maxamp</em> a))
		  (mxb (<em class=red>mus-sound-maxamp</em> b)))
	      (or (null? mxb)
		  (and (not (null? mxa))
		       (&gt; (mxall 0.0 mxa)
			  (mxall 0.0 mxb)))))))))
</pre></td></tr></table></td></tr>

<!-- edit-header-dialog -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndeditheaderdialog">edit-header-dialog</a></em> (snd) </code></span></td></tr>
<tr><td></td><td>start the Edit Header dialog on <i>snd</i>.</td></tr>

<!-- edit-save-as-dialog -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndeditsaveasdialog">edit-save-as-dialog</a></em> () </code></span></td></tr>
<tr><td></td><td>start the Edit Save-as dialog (to save the selection).</td></tr>

<!-- enved-active-env -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="envedactiveenv">enved-active-env</a></em> ()</code></span></td></tr>
<tr><td></td><td>current envelope in the envelope editor's graph window (list).</td></tr>

<!-- enved-base -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="envedbase">enved-base</a></em> () </code></span></td></tr>
<tr><td></td><td>envelope editor exponential base value (1.0)</td></tr>

<!-- enved-clip? -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="envedclipping">enved-clip?</a></em> ()</code></span></td></tr>
<tr><td></td><td>envelope editor 'clip' button (restricts mouse motion) (#f)</td></tr>

<!-- enved-in-dB -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="envedin-dB">enved-in-dB</a></em> ()</code></span></td></tr>
<tr><td></td><td>envelope editor 'dB' button (#f)</td></tr>

<!-- enved-dialog -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndenveddialog">enved-dialog</a></em> ()</code></span></td></tr>
<tr><td></td><td>start the Envelope editor dialog, return the dialog widget.</td></tr>

<!-- enved-exp? -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="envedexping">enved-exp?</a></em> ()</code></span></td></tr>
<tr><td></td><td>envelope editor 'exp' and 'lin' buttons (type of connecting segments) (#f)</td></tr>

<!-- enved-filter -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="filterenv">enved-filter</a></em> ()</code></span></td></tr>
<tr><td></td><td>The type of the Envelope editor's filter. (default #t: FIR, #f is FFT).  To get the fft display in the envelope editor
as the default:
</td></tr>

<tr><td></td><td><table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (enved-fft)
  (set! (<em class=red>enved-filter)</em> #f)
  (set! (enved-wave?) #t)
  (set! (enved-target) enved-spectrum)
  (add-hook! after-open-hook (lambda (snd)
			       (set! (transform-size snd) 
				     (expt 2 (ceiling (/ (log (frames snd)) 
							 (log 2.0))))))))
</pre></td></tr></table></td></tr>

<!-- enved-filter-order -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="filterenvorder">enved-filter-order</a></em> ()</code></span></td></tr>
<tr><td></td><td>The order of the envelope editor's FIR filter. (default is 40)</td></tr>

<!-- enved-power -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="envedpower">enved-power</a></em> ()</code></span></td></tr>
<tr><td></td><td>envelope editor base scale range (9.0^power). (3.0)</td></tr>

<!-- enved-selected-env -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="envedselectedenv">enved-selected-env</a></em> ()</code></span></td></tr>
<tr><td></td><td>envelope editor selected envelope (list) -- this is the unedited form; the
version in the editor's graph window is called <a href="#envedactiveenv">enved-active-env</a>.</td></tr>

<!-- enved-target -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="envedtarget">enved-target</a></em> ()</code></span></td></tr>
<tr><td></td><td>
Determines how the envelope editor's current envelope is applied to the currently selected data.
The choices are <i>enved-amplitude</i>, <i>enved-srate</i> and <i>enved-spectrum</i>.
</td></tr>

<!-- enved-waveform-color -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="envedwaveformcolor">enved-waveform-color</a></em> ()</code></span></td></tr>
<tr><td></td><td>color of waveform displayed in envelope editor. (default is blue).</td></tr>

<!-- enved-wave? -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="envedwaving">enved-wave?</a></em> ()</code></span></td></tr>
<tr><td></td><td>envelope editor 'wave' button.
The wave shown is the time domain display, even when filtering.
</td></tr>

<!-- file-save-as-dialog -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndfilesaveasdialog">file-save-as-dialog</a></em> () </code></span></td></tr>
<tr><td></td><td>start the File Save-as dialog (to save the currently selected sound).</td></tr>

<!-- help-dialog -->
<tr><td colspan=2 valign=top><span class=defbox><code><em class=def><a name="sndhelpdialog">help-dialog</a></em> (subject help-string) </code></span></td></tr>
<tr><td></td><td>start the help dialog with title <i>subject</i> and body <i>help</i>, returning the dialog widget.<br>
<br><code>(help-dialog "xyzzy" "are we having fUn?")</code>
<br><br>There are many examples in new-effects.scm.
</td></tr>

<!-- html-dir -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="htmldir">html-dir</a></em> ()</code></span></td></tr>
<tr><td></td><td>The directory to search for documentation if an HTML reader is in use.
See <i>html</i> in index.scm.
</td></tr>

<!-- html-program -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="htmlprogram">html-program</a></em> ()</code></span></td></tr>
<tr><td></td><td>The program to use to read HTML files (defaults to "netscape", but can also be "mozilla").
See <i>html</i> in index.scm.
</td></tr>

<!-- listener-color -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="listenercolor">listener-color</a></em> ()</code></span></td></tr>
<tr><td></td><td>background color of lisp listener. <code>(set! (listener-color) (make-color 0 0 0))</code> is good too.</td></tr>

<!-- listener-font -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="listenerfont">listener-font</a></em> ()</code></span></td></tr>
<tr><td></td><td>listener font.</td></tr>

<!-- listener-prompt -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="listenerprompt">listener-prompt</a></em> ()</code></span></td></tr>
<tr><td></td><td>lisp listener prompt (defaults to "&gt;").</td></tr>

<!-- listener-text-color -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="listenertextcolor">listener-text-color</a></em> ()</code></span></td></tr>
<tr><td></td><td>text color in lisp listener.</td></tr>

<tr><td></td><td><table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (red-alert msg)
  ;; this only works in the gtk version (in Motif all existing text changes color)
  (let ((old-color (<em class=red>listener-text-color</em>)))
    (set! (listener-text-color) (make-color 1 0 0))
    (snd-print msg)
    (set! (listener-text-color) old-color)))
</pre></td></tr></table></td></tr>

<!-- mix-panel -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmixpanel">mix-panel</a></em> ()</code></span></td></tr>
<tr><td></td><td>create the Mix Panel Dialog, if necessary, activate it, and return the dialog widget.</td></tr>

<!-- orientation-dialog -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndorientationdialog">orientation-dialog</a></em> ()</code></span></td></tr>
<tr><td></td><td>Create the <a href="snd.html#orientationbrowser">Orientation</a> dialog, if necessary, activate it, and return the dialog widget.</td></tr>

<tr><td colspan=2><span class=defbox><code><a href="#spectrocutoff">spectro-cutoff</a> ()</code></span></td></tr>
<tr><td></td><td>The amount of the frequency domain to include in the spectrum display.
This number changes as you drag the frequency axis.  
This is the slider labelled '% of spectrum' in the View Orientation dialog.
Its default value is 1.0.
</td></tr>

<tr><td colspan=2><span class=defbox><code><a href="#spectrohop">spectro-hop</a> ()</code></span></td></tr>
<tr><td></td><td>The distance (pixels) moved between successive spectrogram traces.
This is the slider labelled 'hop' in the Orientation dialog.
default: 4.
</td></tr>

<tr><td colspan=2><span class=defbox><code><a href="#spectrostart">spectro-start</a> ()</code></span></td></tr>
<tr><td></td><td>The starting point of the frequency domain in the spectrum display. default: 0.0</td></tr>

<tr><td colspan=2><span class=defbox><code><a href="#spectroxangle">spectro-x-angle</a> ()</code></span></td></tr>
<tr><td></td><td>Default spectrogram x-axis viewing angle. default: 90.0</td></tr>

<tr><td colspan=2><span class=defbox><code><a href="#spectroxscale">spectro-x-scale</a> ()</code></span></td></tr>
<tr><td></td><td>Default scaler (stretch) along the spectrogram x axis. default: 1.0</td></tr>

<tr><td colspan=2><span class=defbox><code><a href="#spectroyangle">spectro-y-angle</a> ()</code></span></td></tr>
<tr><td></td><td>Same for y-axis. default: 0.0</td></tr>

<tr><td colspan=2><span class=defbox><code><a href="#spectroyscale">spectro-y-scale</a> ()</code></span></td></tr>
<tr><td></td><td>Same for y-axis. default: 1.0</td></tr>

<tr><td colspan=2><span class=defbox><code><a href="#spectrozangle">spectro-z-angle</a> ()</code></span></td></tr>
<tr><td></td><td>Same for z-axis. default: -2.0</td></tr>

<tr><td colspan=2><span class=defbox><code><a href="#spectrozscale">spectro-z-scale</a> ()</code></span></td></tr>
<tr><td></td><td>Same for z-axis. default: 0.1</td></tr>

<!-- print-length -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="printlength">print-length</a></em> ()</code></span></td></tr>
<tr><td></td><td>number of elements of lists and vectors that are printed. default: 12.</td></tr>

<!-- recorder-autoload -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="recorderautoload">recorder-autoload</a></em> ()</code></span></td></tr>
<tr><td></td><td>The '<a href="snd.html#Xautoload">autoload</a>' button in the recorder dialog. default: #f.</td></tr>

<!-- recorder-buffer-size -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="recorderbuffersize">recorder-buffer-size</a></em> ()</code></span></td></tr>
<tr><td></td><td>The size of the recorder input buffer (there's a trade-off between responsiveness and clicks in some cases).
</td></tr>

<!-- recorder-dialog -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndrecorderdialog">recorder-dialog</a></em> ()</code></span></td></tr>
<tr><td></td><td>start the <a href="snd.html#recordfile">recorder</a> window.</td></tr>

<!-- recorder-file -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="recorderfile">recorder-file</a></em> ()</code></span></td></tr>
<tr><td></td><td>Default recorder output file name.</td></tr>

<!-- recorder-gain -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndrecordergain">recorder-gain</a></em> (gain)</code></span></td></tr>
<tr><td></td><td>  recorder input (soundcard-audio) gain <i>gain</i>.</td></tr>

<!-- recorder-in-amp -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndrecorderinamp">recorder-in-amp</a></em> (in out)</code></span></td></tr>
<tr><td></td><td> recorder input channel <i>in</i> to output channel <i>out</i> amplitude.</td></tr>

<!-- recorder-in-device -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="recorderindevice">recorder-in-device</a></em> ()</code></span></td></tr>
<tr><td></td><td>Input device for recorder.<br><br><code>(set! (recorder-in-device) mus-audio-line-in)</code></td></tr>

<!-- recorder-in-format -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="recorderinformat">recorder-in-format</a></em> ()</code></span></td></tr>
<tr><td></td><td>Incoming data format for the recorder. default 16-bit linear.</td></tr>

<!-- recorder-max-duration -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="recordermaxduration">recorder-max-duration</a></em> ()</code></span></td></tr>
<tr><td></td><td>Recorder max output file length.</td></tr>

<!-- recorder-out-amp -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndrecorderoutamp">recorder-out-amp</a></em> (out)</code></span></td></tr>
<tr><td></td><td>recorder file output channel <i>out</i> amplitude.</td></tr>

<!-- recorder-out-chans -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="recorderoutchans">recorder-out-chans</a></em> ()</code></span></td></tr>
<tr><td></td><td>Recorder output file channels. (default: 2)</td></tr>

<!-- recorder-out-format -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="recorderoutformat">recorder-out-format</a></em> ()</code></span></td></tr>
<tr><td></td><td>same as <a href="#recorderinformat">recorder-in-format</a></td></tr>

<!-- recorder-srate -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="recordersrate">recorder-srate</a></em> ()</code></span></td></tr>
<tr><td></td><td>Recorder sampling rate.</td></tr>

<!-- recorder-trigger -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="recordertrigger">recorder-trigger</a></em> ()</code></span></td></tr>
<tr><td></td><td>Recorder auto-trigger value.</td></tr>

<!-- show-listener -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndshowlistener">show-listener</a></em> ()</code></span></td></tr>
<tr><td></td><td>if set to #t open the lisp listener pane, else close it.  For backwards compatibility, if called outside set!, it opens the pane.</td></tr>

<tr><td colspan=2><span class=defbox><code><em class=def><a href="sndsavelistener">save-listener</a></em> (filename) </code></span></td></tr>
<tr><td></td><td>save listener text in filename.</td></tr>

<!-- vu-font -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="vufont">vu-font</a></em> ()</code></span></td></tr>
<tr><td></td><td>The "vu-" variables refer to the VU meters in the recorder.
<i>vu-font</i> is the font used to label the meters.  It is normally "courier".
</td></tr>

<!-- vu-font-size -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="vufontsize">vu-font-size</a></em> ()</code></span></td></tr>
<tr><td></td><td>recorder VU meter label font size. (1.0)</td></tr>

<!-- vu-size -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="vusize">vu-size</a></em> ()</code></span></td></tr>
<tr><td></td><td>overall size of the recorder VU meters. (1.0)</td></tr>

<!-- region-dialog -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndregiondialog">region-dialog</a></em> ()</code></span></td></tr>
<tr><td></td><td>start the <a href="snd.html#regionbrowser">region browser</a> (a no-op if no regions).</td></tr>

<!-- transform-dialog -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndtransformdialog">transform-dialog</a></em> (<i>managed</i>)</code></span></td></tr>
<tr><td></td><td>create the Transform Dialog, if necessary, activate it (if <i>managed</i> is #t, the default), 
and return the dialog widget.  This is Option menu's Transform Options choice.</td></tr>

<!-- yes-or-no? -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndyesornop">yes-or-no?</a></em> (ques)</code></span></td></tr>
<tr><td></td><td>modal error dialog, #t if user clicks "yes", otherwise #f. 
</td></tr>
<tr><td></td><td>
In normal use, this is a very annoying thing to call because
it forces everything to stop until the poor user clicks a button; in Snd, it's used for questions like "destroy disk?".
While developing code, however, yes-or-no? can be a very handy way to stop and restart a computation.
Say we're trying to get remove-clicks in examp.scm to work, and can't see why a click is being missed.  We can use
yes-or-no? to step through the samples one at a time, breaking out of the computation at any time (the ellipses here
mark code omissions -- see the original for details):
</td></tr>

<tr><td></td><td><table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
    (call-with-current-continuation
     (lambda (return)
       (do ((ctr loc (1+ ctr)))
	   ((= ctr len) #f)
	...
	 (let ((local-max (max .1 (vct-peak samps))))
	   (snd-print (format #f "~A " local-max))
	   (if (<em class=red>yes-or-no?</em> "continue?")
	       (if (and (&gt; (abs (- samp0 samp1)) local-max)
                        ...
		   (return (1- ctr)))
	       (return #f)
               ...
	       <!-- )))))) -->
</pre></td></tr></table></td></tr>
<tr><td></td><td>
But this is kinda dumb; we really should use a continuation here:
</td></tr>

<tr><td></td><td><table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
    (call-with-current-continuation
     (lambda (return)
       (do ((ctr loc (1+ ctr)))
	   ((= ctr len) #f)
         ...
	 (let ((local-max (max .1 (vct-peak samps))))
	   (call-with-current-continuation
	    (lambda (go-on)
	      (snd-print (format #f "~A: ~A (~A) " ctr local-max samp2))
	      (return go-on)
	      (if (and (&gt; (abs (- samp0 samp1)) local-max)
                  ...
		  (return (1- ctr))
		  <!-- )))))))) -->
</pre></td></tr></table></td></tr>
<tr><td></td><td>
Now save the continuation after the first call, and whenever you want to
pick up where you last left off, call it as a function of no arguments.
This method leaves all the rest of Snd operational (in particular the
listener), whereas yes-or-no? tries to freeze everything until you
click its button.
</td></tr>
</table>

<hr>
<p>The main menus can be extended, and new menus added with the following functions:</p>

<!-- -------------------------------- MENU TABLE -------------------------------- -->
<table border=0 cellspacing=10>

<!-- add-to-main-menu -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndaddtomainmenu">add-to-main-menu</a></em> (menu-label <i>update-callback</i>)</code></span></td></tr>
<tr><td width=150></td><td>
add a new top-level menu named <i>menu-label</i> and return its menu index.  This index
identifies the menu for add-to-menu and others.
<i>update-callback</i> is a procedure of no arguments that is
called each time the menu is displayed. <a href="sndscm.html#effectsdoc">new-effects.scm</a> calls this function
to add a new "Effects" menu to the top level menubar.
<br><br><pre>
  &gt;<em class=typing>(add-to-main-menu "Tools")</em>
  <em class=listener>5</em>
</pre></td></tr>

<!-- add-to-menu -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndaddtomenu">add-to-menu</a></em> (top-menu menu-label callback <i>position</i>)</code></span></td></tr>
<tr><td></td><td>
add menu <i>menu-label</i> to top-level menu whose index is 
<i>top-menu</i> with the callback function <i>callback</i>.  The built-in
Snd menus are numbered from 0 ('File') to 5 ('Popup'); 'Help' is menu 4.  If the label and callback are #f, a separator is added to the menu.
<i>position</i> sets the position of the new menu option; it defaults to the end of the menu.  See new-effects.scm for many examples.
<br><br><pre>
  (<em class=red>add-to-menu</em> 1 "Stop Playing" 
    (lambda () (stop-playing)))
<br>
  (<em class=red>add-to-menu</em> 5 "Reduce height" 
    (lambda () (set! (window-height) (/ (window-height) 2))))
</pre></td></tr>
<tr><td></td><td>
As a slightly more elaborate example, the following adds a Delete option to the File menu:
</td></tr>

<tr><td></td><td><table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(<em class=red>add-to-menu</em> 0 "Delete" ; add Delete option to File menu
	     (lambda ()
	       ;; close current sound and delete it (after requesting confirmation)
	       (if (selected-sound)
		   (let ((filename (file-name)))
		     (close-sound)
		     (if (yes-or-no? (format #f "delete ~S?" filename))
			 (delete-file filename)))))
	     8) ; place after File:New
</pre></td></tr></table></td></tr>

<!-- change-menu-label -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndchangemenulabel">change-menu-label</a></em> (top-menu old-label new-label)</code></span></td></tr>
<tr><td></td><td>
change the label of the given menu from <i>old-label</i> to <i>new-label</i>.
</td></tr>

<!-- remove-from-menu -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="sndremovefrommenu">remove-from-menu</a></em> (top-menu menu-label)</code></span></td></tr>
<tr><td></td><td>
remove menu <i>menu-label</i> from the top top-level menu whose index is <i>top-menu</i>.  See examp.scm or snd-motif.scm.
</td></tr>

<!-- menu-sensitive -->
<tr><td colspan=2><span class=defbox><code><em class=def><a name="menusensitive">menu-sensitive</a></em> (top-menu label)</code></span></td></tr>
<tr><td></td><td>
#t if the given menu is currently sensitive (clickable).  This can be set.
</td></tr>
</table>


<p>The hook <em class=def><a name="menuhook">menu-hook</a></em> is checked each time a menu item is selected;
its entries should be functions of two arguments, the parent menu name and the option
selected (both as strings), and should return #f if it wants to override (cancel) the default
menu action.</p>

<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
  (add-hook! <em class=red>menu-hook</em>
    (lambda (name option)
      (if (and (string=? name "File")
               (string=? option "Exit"))
        (begin
          (snd-print "no exit!")
	  #f)
        #t))) ; #t to make sure other menu items remain active
</pre></td></tr></table>
<p>I may change these menu handlers to use the menu-widgets list
and more general functions; let me know what you'd like to be able
to do!
</p>

<br>
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="sndmisc">Miscellaneous functions</a></h3></td></tr></table>

<p>These functions don't seem to fit anywhere else:</p>

<!-- -------------------------------- MISCELLANEOUS TABLE -------------------------------- -->

<table border=0 cellspacing=10>

<!-- abort -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="abort">abort</a></em> ()</code></span></td></tr>
<tr><td><spacer type=horizontal size=40><br>
</td><td>
exit Snd via "abort", presumably to fall into the C debugger (gdb).  To stop some on-going Snd operation,
use <a href="#sndabort">C-g</a>.
</td></tr>

<!-- add-sound-file-extension -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="addsoundfileextension">add-sound-file-extension</a></em> (ext)</code></span></td></tr>
<tr><td></td><td>
add <i>ext</i> to the list of (case sensitive) sound file extensions used by <a href="#soundfilesindirectory">sound-files-in-directory</a>.
The initial list is ("snd" "aiff" "aif" "wav" "au" "aifc" "voc" "wve" "WAV" "sf2").
To add "ogg" as a recognized extension: <code>(add-sound-file-extension "ogg")</code><br>
A Scheme implementation: <a href="sndscm.html#addsoundextension1">add-sound-file-extension-1</a>.
</td></tr>

<!-- bind-key -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndbindkey">bind-key</a></em> (key state func extended origin) </code></span></td></tr>
<tr><td></td><td>
Cause <i>key</i> (an integer) with modifiers <i>state</i> (and preceding C-x if <i>extended</i>) to evaluate <i>func</i>
when the graph widget has keyboard "focus".  If bind-key seems to be a no-op, try clicking in the graph to
force it to take the focus.
If <i>origin</i> is included, it is the name reported if an error occurs.  The ugly default is "user key func".

</td></tr><tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(<em class=red>bind-key</em> (char-&gt;integer #\a) 4 
          (lambda () 
            "C-a prints hi in listener"
            (snd-print \"hi\") 
            cursor-in-view))

(<em class=red>bind-key</em> (char-&gt;integer #\p) 0 
          (lambda () 
            "p moves cursor to left edge of window"
            cursor-on-left)
          #f "#\\p-&gt;cursor-on-left")

(<em class=red>bind-key</em> (char-&gt;integer #\v) 4
	  (lambda ()
            "C-v redefined to behave as in Emacs (move ahead window)"
	    (if (&lt; (right-sample) (frames))
		(set! (left-sample) (right-sample)))
	    keyboard-no-action))
</pre></td></tr></table></td></tr>
<tr><td></td><td>

The modifier state is a combination of shift: 1, control: 4, meta: 8, 
so the first bind-key above causes C-a to print "hi" in the lisp listener.  The 
value returned should be one of the cursor choices telling Snd what 
action (if any) to take after evaluating <i>code</i>.  
Possible return values are:
<br><pre>
  cursor-in-view  cursor-on-left  cursor-on-right  cursor-in-middle  keyboard-no-action
</pre>
</td></tr>
<tr><td></td><td>
The function bound to a key can take either no arguments (as above), or one
argument.  In the latter case, the argument is the count (the C-u number prefixed to the keyboard command)
defaulting to 1 if no prefix is typed.  For example, there used to be a "line-size" variable
setting how how many samples to jump for the C-p and C-n keys.  We can implement the same idea:
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define line-size 128)
(<em class=red>bind-key</em> (char-&gt;integer #\n) 4 (lambda (arg) (set! (cursor) (+ (cursor) (* line-size arg)))))
(<em class=red>bind-key</em> (char-&gt;integer #\p) 4 (lambda (arg) (set! (cursor) (- (cursor) (* line-size arg)))))
</pre></td></tr></table></td></tr>

<tr><td></td><td>
<A NAME="extendedpiano"></A>We can use bind-key to turn the keyboard into a sort of extended piano:
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(<em class=red>bind-key</em> (char-&gt;integer #\o) 0 
  (lambda () 
    (play "oboe.snd") 
    keyboard-no-action))

(<em class=red>bind-key</em> (char-&gt;integer #\p) 0 
  (lambda () 
    (play "pistol.snd") 
    keyboard-no-action))
</pre></td></tr></table></td></tr>

<tr><td></td><td>
Now each time we hit "o", "oboe.snd" plays,  etc.  Or say we want to move
forward two samples in the graph each time we type "l":
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(<em class=red>bind-key</em> (char-&gt;integer #\l) 0 
  (lambda () 
    (set! (left-sample 0 0) (+ 2 (left-sample 0 0))) 
    keyboard-no-action))
</pre></td></tr></table></td></tr>

<tr><td></td><td>
Or, more useful perhaps, have C-c set the cursor at a particular sample:
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(<em class=red>bind-key</em> (char-&gt;integer #\c) 4
  (lambda (arg)
    (set! (cursor) arg) 
    cursor-in-middle))
</pre></td></tr></table></td></tr>

<tr><td></td><td>
The key codes can usually be found in the X header file X11R6/include/X11/keysymdef.h
The "Page Up" key is given as 0xFF55, which in Scheme would be #xff55 (65365).
<pre>
  (bind-key #xff55 0 (lambda () (snd-print "Page up") keyboard-no-action))
</pre>
Similarly, the End key if #xFF57, so we could bind it to cause the full sound to be displayed:
<pre>
  (bind-key #xFF57 0 (lambda () (set! (x-bounds) (list 0.0 (/ (frames) (srate))))))
</pre>
</td></tr>

<tr><td></td><td>
The emacs-style line-oriented commands C-p, C-n, and C-k aren't very useful in Snd,
since there's no reason for 128 samples to consititute the audio analog of a line of text.
In the next example, we rebind them to treat same-sense zero-crossings as line markers:
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (<A NAME="newcp">find-zero</a> forwards)
  (let* ((loc (cursor))
	 (twice #f)
	 (dir (if forwards 1 -1))
	 (reader (make-sample-reader loc #f #f dir))
	 (val (read-sample)))
    (while (not (or (c-g?)
		    (and forwards (sample-reader-at-end? reader))
		    (and (not forwards) (= loc 0))))
      (let ((newval (read-sample reader)))
	(set! loc (+ loc dir))
	(if (or (and (&gt;= val 0.0) (&lt; newval 0.0))
		(and (&lt; val 0.0) (&gt;= newval 0.0)))
	    (if twice
		(break loc)
		(begin
		  (set! val newval)
		  (set! twice #t))))))
    loc))

(define (<A NAME="deletetozero">delete-to-zero</a> forwards)
  (let ((loc (cursor))
	(zero-loc (find-zero forwards)))
    (if (not (= loc zero-loc))
	(if forwards
	    (delete-samples (cursor) (- zero-loc loc))
	    (begin
	      (delete-samples zero-loc (- loc zero-loc))
	      (set! (cursor) zero-loc))))))

(define (go-to-zero forwards)
  (set! (cursor) (find-zero forwards)))

(<em class=red>bind-key</em> (char-&gt;integer #\k) 4 (lambda (arg) 
				  (do ((i 0 (1+ i))) 
				      ((= i (abs arg)))
				    (delete-to-zero (&gt; arg 0)))))
(<em class=red>bind-key</em> (char-&gt;integer #\n) 4 (lambda (arg) 
				  (do ((i 0 (1+ i))) 
				      ((= i (abs arg)))
				    (go-to-zero (&gt; arg 0)))))
(<em class=red>bind-key</em> (char-&gt;integer #\p) 4 (lambda (arg) 
				  (do ((i 0 (1+ i))) 
				      ((= i (abs arg)))
				    (go-to-zero (&lt; arg 0)))))
</pre></td></tr></table></td></tr>
<tr><td></td><td>Most of the predefined key definitions are given in <a href="snd.html#builtinkeys">Keyboard Commands</a>.
The key bindings set by bind-key are active only when the active widget is a graph; when the listener is receiving
key strokes, the underlying text widget interprets them itself.  You can change the listener's interpretation
in the following manner (this assumes you're using Motif and have the xm module loaded):
</td></tr><tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(XtAppAddActions (car (main-widgets)) (list (list "hiho" (lambda args (snd-print "hiho")))))
(XtOverrideTranslations (list-ref (main-widgets) 4) (XtParseTranslationTable "Ctrl &lt;Key&gt;i: hiho()\n"))
</pre></td></tr></table><br></td></tr>

<!-- change-window-property -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="changeproperty">change-window-property</a></em> (known-atom property value)</code></span></td></tr>
<tr><td width=150></td><td>
<i>change-window-property</i> changes an X-window's property; <a href="sndscm.html#titlewithdate">title-with-date</a> in examp.scm uses this function
to put the date and time in the Snd title bar.
</td></tr>

<!-- clear-listener -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndclearlistener">clear-listener</a></em> ()</code></span></td></tr>
<tr><td width=150></td><td>
delete listener text from the beginning to the cursor position (C-M-g is bound to this function).
</td></tr>

<!-- close-sound-file -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndclosesoundfile">close-sound-file</a></em> (fd bytes)</code></span></td></tr>
<tr><td></td><td>
close file (opened by open-sound-file) updating header to report <i>bytes</i> bytes of data.  This refers to data files
handled directly, not sounds displayed in Snd (the latter are handled by <a href="#sndopen">open-sound</a> and <a href="#sndclose">close-sound</a>).
See <i>save-track</i> in mix.scm.
</td></tr>

<!-- c-g? -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndabort">c-g?</a></em> ()</code></span></td></tr>
<tr><td></td><td>
check for C-g to interrupt an on-going computation, and let other UI 
events through.  <i>c-g?</i> is especially useful in loops; we could define our own safe 'while' loop as follows
(this is a slight revision of Guile's while macro from ice-9/boot-9.scm):
</td></tr>
<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(defmacro safe-while (cond . body)
  `(letrec ((break (lambda val (apply throw 'break val)))
	    (continue (lambda () (if (<em class=red>c-g?</em>) 
				     (break 'interrupted)
				     (or (not ,cond) 
					 (begin (begin ,@ body) 
						(continue)))))))
     (catch 'break
	    (lambda () (continue))
	    (lambda v (cadr v)))))
</pre></td></tr></table>
<br>
See examp.scm and play.scm for other examples.
</td></tr>

<!-- c-g! -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndoops">c-g!</a></em> ()</code></span></td></tr>
<tr><td></td><td>
simulate typing C-g (intended for use with bind-key to remap C-g).
</td></tr>

<!-- dac-is-running -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="dacisrunning">dac-is-running</a></em> ()</code></span></td></tr>
<tr><td></td><td>
#t if sound output is currently in progress.  dac-is-running only notices Snd-instigated "play" processes;
if you open the DAC via <a href="#musaudioopenoutput">mus-audio-open-output</a> and
send it output via <a href="#musaudiowrite">mus-audio-write</a>, dac-is-running will not notice.
</td></tr>

<!-- defvar -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="ldefvar">defvar</a></em> (var val)</code></span></td></tr>
<tr><td></td><td>
same as <code>(define var val)</code> except that the envelope editor keeps track
of <i>var</i> thereafter and treats lists as envelopes. (<i>defvar</i> is a macro).
I'm using <i>defvar</i> here rather than some more perspicuous name like def-envelope
so that Snd and CLM can share envelope files.
</td></tr>

<!-- equalize-panes -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndequalizepanes">equalize-panes</a></em> (<i>snd</i>)</code></span></td></tr>
<tr><td></td><td>
equalize Snd panes as in the View menu <a href="snd.html#equalizepanes">Equalize Panes</a> option.
If the <i>snd</i> argument is given, only that sound's panes are affected.
</td></tr>
<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(add-hook! after-open-hook 
  (lambda (n) (if (&gt; (channels n) 3) (<em class=red>equalize-panes</em>))))
</pre></td></tr></table></td></tr>

<!-- exit -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndexit">exit</a></em> (<i>exit-value</i>)</code></span></td></tr>
<tr><td></td><td>
exit Snd. 
</td></tr>

<!-- graph->ps -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndgraph2ps">graph-&gt;ps</a></em> (<i>file</i>)</code></span></td></tr>
<tr><td></td><td>
create Postscript picture of current display.
<i>file</i> defaults to <a href="#epsfile">eps-file</a>.
</td></tr>

<!-- in -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="gin">in</a></em> (ms thunk)</code></span></td></tr>
<tr><td></td><td>
<i>ms</i> milliseconds from now, evaluate <i>thunk</i>, a function of no arguments.  In Ruby, this
is named "<a name="callin">call_in</a>".
<pre><code>(in 5000 (lambda () (snd-print "boo!")))</code></pre>
</td></tr>
<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (at hour minute func)
  (let* ((cur-time (localtime (current-time)))
	 (cur-minute (vector-ref cur-time 1))
	 (cur-hour (vector-ref cur-time 2))
	 (now (+ (* cur-hour 60) cur-minute))
	 (then (+ (* hour 60) minute)))
    (<em class=red>in</em> (* 1000 60 (- then now)) func)))

(at 15 11 (lambda () (snd-print "it's 3:11 pm!")))
</pre></td></tr></table></td></tr>

<!-- key -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndkey">key</a></em> (key state <i>snd chn</i>) </code></span></td></tr>
<tr><td></td><td>
execute the keyboard command <i>key</i> with modifier keys <i>state</i>.
<i>state</i> is the bitwise OR of shift: 1, control: 4, meta: 8
</td></tr>

<!-- key-binding -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="keybinding">key-binding</a></em> (key state extended)</code></span></td></tr>
<tr><td></td><td>
the user-defined (not built-in) procedure, if any, currently bound to key+state+extended.
<i>state</i> is the bitwise OR of shift: 1, control: 4, meta: 8.  <i>extended</i> is #t if the command
is preceded by C-x.
</td></tr>

<!-- listener-selection -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="listenerselection">listener-selection</a></em> ()</code></span></td></tr>
<tr><td></td><td>

<i>listener-selection</i> returns the currently selected text in the listener, or #f if there isn't any.  The following code 
starts the help dialog with help related to the selection if "h" is typed in the graph:
<pre>
  (bind-key (char-&gt;integer #\h) 0 
    (lambda ()
      (let ((subject (<em class=red>listener-selection</em>)))
	(if subject
            (help-dialog subject (snd-help subject))))))
</pre>
<p>But it's probably more convenient to use the <a href="#listenerclickhook">listener-click-hook</a>
and click-for-listener-help (draw.scm).
</p>
</td></tr>

<!-- memo-sound -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="memosound">memo-sound</a></em></code></span></td></tr>
<tr><td></td><td>
When a sound file is opened, Snd looks for a file with the same 
name but with an appended ".scm" extension.  If such a file is found, 
it is loaded automatically.  The variable <i>memo-sound</i> is set to 
the newly opened sound's index.  This supports the snd-memo feature 
in CLM, but can be used independently of CLM to store marks, selections,
or whatever that you want associated with a particular sound. Confusingly
enough, this is a variable, unlike all the others -- that is, you
refer to it directly, not as a procedure call.
</td></tr>

<!-- open-sound-file -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndopensoundfile">open-sound-file</a></em> (<i>name chans srate comment</i>)</code></span></td></tr>
<tr><td></td><td>
Open (create) a sound file <i>name</i> (defaults to "test.snd" or "test.wav").  
It is assumed that the data will be floats in the native format (written by 
the caller interleaving channels), and that the file will be closed by 
close-sound-file. One simple way to write the data is to call 
<a href="#vct2soundfile">vct-&gt;sound-file</a>.  <i>open-sound-file</i> opens a file external to Snd, whereas <i>open-sound</i>
loads a file into Snd for editing.
</td></tr>

<!-- preload-directory -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndpreloaddirectory">preload-directory</a></em> (dir)</code></span></td></tr>
<tr><td></td><td>
preload sound files from directory <i>dir</i> (see -<a href="snd.html#minusp">p</a>).  Preloading a file means
placing it in the list of previous files in the View menu's <a href="snd.html#prevfiles">View Files</a> dialog.
By preloading all the files you might want to use, you can use that dialog as a convenient access method, and so on.
See <a href="sndscm.html#nbdoc">nb.scm</a>.
</td></tr>

<!-- preload-file -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndpreloadfile">preload-file</a></em> (file)</code></span></td></tr>
<tr><td></td><td>
preload <i>file</i>, placing it in the View menu's <a href="snd.html#prevfiles">View Files</a> dialog as
a previous file (as if you had opened and closed it).
</td></tr>

<!-- reset-listener-cursor -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="resetlistenercursor">reset-listener-cursor</a></em></code></span></td></tr>
<tr><td></td><td>
reset the listener cursor to the default pointer shape
</td></tr>

<!-- save-envelopes -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndsaveenvelopes">save-envelopes</a></em> (filename)</code></span></td></tr>
<tr><td></td><td>
save envelope editor contents in <i>filename</i>.
</td></tr>

<!-- save-listener -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndsavelistener">save-listener</a></em> (filename)</code></span></td></tr>
<tr><td></td><td>
save listener contents in <i>filename</i>.
</td></tr>

<!-- save-macros -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndsavemacros">save-macros</a></em> (filename)</code></span></td></tr>
<tr><td></td><td>
save <a href="snd.html#kbdmacros">keyboard macros</a> in <i>filename</i> or in Snd's init file (~/.snd) if <i>filename</i> is omitted.
</td></tr>

<!-- save-options -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndsaveoptions">save-options</a></em> (filename)</code></span></td></tr>
<tr><td></td><td>
save options (Snd global variable settings) in <i>filename</i>.
</td></tr>

<!-- save-state -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndsavestate">save-state</a></em> (filename)</code></span></td></tr>
<tr><td></td><td>
save current state of Snd in <i>filename</i>.  The saved-state file is a Scheme or Ruby program that when loaded
into Snd, recreates the state of Snd (as far as possible) at the point of the save.  There are a variety of
limitations to this process; the worst is that save-state does not try to save hook values or global variable values --
see also <a href="#ptreechannel">ptree-channel</a> in this regard.
If you call save-state with active regions, and have the region browser running all the time, and subsequently
want to back up the the saved state, it's safer to delete all the regions first (via <a href="forgetregion">forget-region</a>), 
then load the saved-state file (see snd-test.scm).
<a href="#savestatehook">save-state-hook</a> is called during the saving process (once on each temp file), and
and <a href="#aftersavestatehook">after-save-state-hook</a> is called afterwards.
</td></tr>

<!-- script-arg -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndscriptarg">script-arg</a></em> ()</code></span></td></tr>
<tr><td></td><td>
current startup argument number (normally 1). See <a href="grfsnd.html#sndwithnogui">Snd as a script engine</a> and snd-test.scm.
</td></tr>

<!-- script-args -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndscriptargs">script-args</a></em> ()</code></span></td></tr>
<tr><td></td><td>
startup arguments as a list of strings. See <a href="grfsnd.html#sndwithnogui">Snd as a script engine</a> and snd-test.scm.
</td></tr>

<!-- snd-apropos -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndapropos">snd-apropos</a></em> (name) </code></span></td></tr>
<tr><td></td><td>
return possible completions of <i>name</i>, a string or a symbol.
<pre>
:<em class=typing>(snd-apropos "mouse-enter")</em>
<em class=listener>(guile): mouse-enter-graph-hook
(guile): mouse-enter-label-hook
(guile): mouse-enter-listener-hook
</em></pre>
</td></tr>

<!-- snd-error -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="snderror">snd-error</a></em> (str)</code></span></td></tr>
<tr><td></td><td>
reports the error message <i>str</i> in the Error dialog, saves <i>str</i> in the error history list 
(see <a href="snd.html#errorhistory">View:Error History</a>), 
and returns <i>str</i>.  See also <a href="#muserrorhook">mus-error-hook</a> and <a href="#snderrorhook">snd-error-hook</a>.
</td></tr>

<!-- snd-help -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndhelp">snd-help</a></em> (obj (formatted #t))</code></span></td></tr>
<tr><td></td><td>
return (as a string) the help text associated with <i>obj</i>:
<br><br>
<pre>
:<em class=typing>(snd-help 'open-sound)</em>
<em class=listener>"(open-sound filename) opens filename (as if opened from File:Open menu option), 
and returns the new file's index"</em>
</pre>
To go to the
HTML documentation for a given object, load <a href="sndscm.html#indexdoc">index.scm</a> and use the html function.
To get a more global help function (i.e. one that knows about Scheme built-ins and so forth), 
<code>(use-modules (ice-9 session))</code>.  This loads Guile's
help (and apropos) support which uses 'regexps' and so forth.
<br><br>
Normally snd-help adds carriage-returns to fit the current size of the listener; to
get the raw string instead, set the argument <i>formatted</i> to #f.  <i>click-for-listener-help</i>
in draw.scm uses this to put off formatting the help string until the help dialog (rather than
the listener) gets it.
</td></tr>

<!-- snd-print -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndprint">snd-print</a></em> (str)</code></span></td></tr>
<tr><td></td><td>
displays <i>str</i> in lisp the listener, then returns <i>str</i>.  (This is intended as a
debugging aid -- there's still nothing like a lowly print statement).
</td></tr>

<!-- snd-remember-paths -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndrememberpaths">snd-remember-paths</a></em></code></span></td></tr>
<tr><td></td><td>
A variable (not a function); if #t (its default is #f), Snd adds code to the Guile %load-hook that makes sure the
current file's path is included in %load-path when load or load-from-file is called.  This makes it possible to
use load-from-path inside a Scheme file when you don't know in advance where that file will reside at load time.
</td></tr>

<!-- snd-spectrum -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndspectrum">snd-spectrum</a></em> (data window length <i>linear beta in-place normalized</i>)</code></span></td></tr>
<tr><td></td><td>
return the spectrum (as a vct) of <i>data</i> (also a vct) using fft-window <i>win</i>.
<i>length</i> is the number of samples 
of data. <code>(let ((spectr (snd-spectrum data rectangular-window (transform-size)))) ...)</code>
If <i>linear</i> is #f (its default is #t), the spectrum is in dB.
<i>beta</i> is the fft data window family parameter; it is scaled internally so here it should be between 0.0 and 1.0.
If <i>in-place</i> is #t, the spectrum is in <i>data</i>, otherwise snd-spectrum returns a new vct.
</td></tr>

<!-- snd-tempnam -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndtempnam">snd-tempnam</a></em> ()</code></span></td></tr>
<tr><td></td><td>
return a new temp file name using Snd's <a href="#tempdir">temp-dir</a>.
</td></tr>

<!-- snd-version -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndversion">snd-version</a></em> ()</code></span></td></tr>
<tr><td></td><td>
Snd version: a string, normally a date. <b>version</b> is a Guile function.
</td></tr>

<!-- snd-warning -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndwarning">snd-warning</a></em> (str)</code></span></td></tr>
<tr><td></td><td>
post a warning message, <i>str</i>, in the minibuffer, and return <i>str</i>.
See also <a href="#sndwarninghook">snd-warning-hook</a>.
</td></tr>

<!-- sound-files-in-directory -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="soundfilesindirectory">sound-files-in-directory</a></em> (<i>dir</i>)</code></span></td></tr>
<tr><td></td><td>
return a list of sound file names.  A file is considered a sound if it has data and
its extension is on the sound file extension list (see <a href="#addsoundfileextension">add-sound-file-extension</a>).
The directory name defaults to the current directory.
This is useful for batch processing of sounds.  The following
prints the names of all the stereo AIFC files it finds:
</td></tr>

<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(for-each
  (lambda (filename)
    (if (and (= (mus-sound-header-type filename) mus-aifc)
             (= (mus-sound-chans filename) 2))
        (snd-print (format #f "~%~A" filename))))
  (<em class=red>sound-files-in-directory</em>))
</pre></td></tr></table></td></tr>

<tr><td></td><td>
See also map-sound-files in <a href="sndscm.html#snd4doc">snd4.scm</a>, and 
<a href="sndscm.html#exmapsoundfiles">map-sound-files</a> in extensions.scm.
</td></tr>

<!-- unbind-key -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndunbindkey">unbind-key</a></em> (key state extended)</code></span></td></tr>
<tr><td></td><td>
cause <i>key</i> with modifiers <i>state</i> to be a no-op.
</td></tr>

<!-- widget-position -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="widgetposition">widget-position</a></em> (widget)</code></span></td></tr>
<tr><td></td><td>
return a list giving the widget x and y coordinates (pixels).  Can be set.  See <a href="#sndwidgets">Snd widgets</a> below,
and nb.scm where it uses the current window position to try to find a convenient place for the help dialog.
</td></tr>

<!-- widget-size -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="widgetsize">widget-size</a></em> (widget) </code></span></td></tr>
<tr><td></td><td>
return a list giving the widget width and height (pixels).  Can be set. See nb.scm and examp.scm.
</td></tr>

</table>
<br>

<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="sndconstants">Constants</a></h3></td></tr></table>

<p><b>Sndlib</b> (see <a href="sndlib.html#sndlibguile">sndlib.html</a> for a complete list):</p>
<pre>
  <a name="nextsoundfile">mus-next</a> mus-aifc mus-riff mus-nist mus-raw mus-ircam mus-aiff
  mus-bicsf mus-soundfont mus-voc mus-svx

  mus-bshort  mus-lshort mus-mulaw  mus-alaw   mus-byte   mus-ubyte   mus-bfloat
  mus-lfloat  mus-bint   mus-lint   mus-b24int mus-l24int mus-bdouble mus-ldouble
  mus-ubshort mus-ulshort

  <a name="musoutformat">mus-out-format</a>
</pre>
<br>
<p><b>Time domain graph type</b> (<a href="#wavo">time-graph-type</a>):</p>
<pre>
  graph-once  graph-as-wavogram
</pre>
<br>
<p><b>Transform graph type</b> (the Transform Options Display choice, <a href="#lfftstyle">transform-graph-type</a>):</p>
<pre>
  graph-once  graph-as-sonogram  graph-as-spectrogram
</pre>
<br>
<p><b>Transform type</b> (<a href="#ltransformtype">transform-type</a>):</p>
<pre>
  <a name="fouriertransform">fourier-transform</a>  wavelet-transform   cepstrum   haar-transform
  autocorrelation    walsh-transform     hadamard-transform  
</pre><br>

<p><b>Transform normalization</b> (<a href="#normalizefft">transform-normalization</a>):</p>
<pre>
  dont-normalize     normalize-by-channel    normalize-by-sound    normalize-globally
</pre><br>

<p><b>FFT Window</b> type (<a href="#lfftwindow">fft-window</a>):</p>
<pre>
  rectangular-window    hann(ing)-window      welch-window         parzen-window
  bartlett-window       hamming-window        blackman2-window     blackman3-window
  blackman4-window      exponential-window    riemann-window       kaiser-window
  cauchy-window         poisson-window        gaussian-window      tukey-window
  dolph-chebyshev-window (if GSL is loaded)
</pre><br>

<p><b>Zoom Focus</b> style (<a href="#zoomfocusstyle">zoom-focus-style</a>):</p>
<pre>
  zoom-focus-left    zoom-focus-right   zoom-focus-active zoom-focus-middle
</pre><br>

<p><b>X-axis Label</b> (<a href="#xaxisstyle">x-axis-style</a>):</p>
<pre>
  x-axis-in-seconds  x-axis-in-samples  x-axis-as-percentage  x-axis-in-beats
</pre><br>

<p><b>Speed Control</b> style (<a href="#lspeedstyle">speed-control-style</a>):</p>
<pre>
  speed-control-as-float     speed-control-as-ratio     speed-control-as-semitone
</pre><br>

<p><b>Channel Combination</b> style (<a href="#channelstyle">channel-style</a>):</p>
<pre>
  <a name="channelstyleconstants">channels-separate</a>  channels-combined  channels-superimposed
</pre><br>

<p><b>Envelope Editor</b> target (<a href="#envedtarget">enved-target</a>):</p>
<pre>
  enved-amplitude      enved-spectrum       enved-srate
</pre><br>

<p><b>Graph Line</b> style (<a href="#graphstyle">graph-style</a>):</p>
<pre>
  <a name="graphlines">graph-lines</a>        graph-dots         graph-filled      graph-lollipops
  graph-dots-and-lines 
</pre><br>

<p><b>Key binding</b> cursor action (<a href="#sndbindkey">bind-key</a>):</p>
<pre>
  <a name="cursorchoices">cursor-in-view</a>     cursor-on-left     cursor-on-right   cursor-in-middle  keyboard-no-action
</pre><br>

<p><b>Cursor</b> style (<a href="#cursorstyle">cursor-style</a>):</p>
<pre>
  cursor-cross   cursor-line
</pre><br>

<p><b>Axis placement</b> choice (<a href="#showaxes">show-axes</a>):</p>
<pre>
  show-all-axes  show-no-axes  show-x-axis
</pre><br>

<p><b>Graph</b> id (for <a href="#y2position">y-&gt;position</a> etc):</p>
<pre>
  time-graph     transform-graph     lisp-graph
</pre>


<br>
<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="snderrors">Errors and Debugging</a></h3></td></tr></table>
<!-- INDEX snderrors:Debugging (Scheme) -->
<p> When something goes awry, the various functions can throw an error (a symbol)
which is normally caught by the default error handler (this is a kind of goto 
but without the embarrassment).  It prints out some message,
and sometimes appends a stack trace.  So, as a simple example, selection-position
throws 'no-active-selection if there isn't a selection:
</p>
<pre>
&gt;<em class=typing>(selection-position)</em>
<em class=listener>selection-position: no-active-selection</em>
&gt;<em class=typing>asdf</em>
<em class=listener>Unbound variable: asdf</em>
</pre>
<p>But there are cases where you'd rather handle an error (or all errors) specially.
In the case of 'no-active-selection, we set up our own handler for that as follows:</p>
<pre>
&gt;<em class=typing>(catch 'no-active-selection 
       (lambda () 
         (+ 1 (selection-position))) 
       (lambda (tag val) 0))</em>
<em class=listener>0</em>
</pre>
<p>Here we've caught 'no-active-selection (if it occurs within the
first thunk's body), and return 0 if it occurs; otherwise we return
<code>(+ 1 (selection-position))</code>.  Scheme (Guile) has a number
of errors such as 'out-of-range, 'wrong-type-arg, 'numerical-overflow,
etc.  The Snd-specific errors are:</p>
<pre>
'no-such-channel 'no-such-sound  'no-such-mark       'no-such-mix
'no-such-menu    'no-such-file   'no-such-region     'no-such-sample
'no-such-edit    'cannot-save    'no-such-envelope   'no-active-selection
'no-such-widget  'mus-error      'no-such-track      'bad-arity
'cannot-print    'no-such-axis   'no-such-player     'no-such-graphics-context
'no-such-color   'no-such-widget 'no-such-plugin     'no-data
'gsl-error       'no-such-key    'no-such-direction  'cannot-parse
</pre>
<p><i>bad-arity</i> is jargon indicating that a procedure has been passed the
wrong number of arguments.  <i>gsl-error</i> indicates that the GSL
library is the source of the error.
The symbol #t stands for all errors in this case, so we can 
run rough-shod over any error with:</p>
<pre>
(defmacro without-errors (func)
  `(catch #t 
	  (lambda ()
	    ,func)
	  (lambda args (car args))))
</pre>
<p>You can use these errors in your code, if you like, or add your own.  The following
throws the error 'no-such-file:</p>
<pre>
(define look-for-file
  (lambda (file)
    (or (file-exists? file)
	(throw 'no-such-file (list "look-for-file" file)))))
</pre>
<p>The mix.scm track functions can return 'no-such-track if a
given track has no mixes.
</p>
<p>There is one special catch: 'snd-top-level.  This is used by the
debuggers to exit the current context, returning up a level in the
stack of listeners.  Normally that means you jump out of a breakpoint
or whatever and find yourself back at the top level.  <code>(throw 'snd-top-level)</code>.
</p>

<hr>
<p>There are a variety of debugging aids supplied by Guile, including
a backtrace facility.  To be sure all Guile's debugging support
code is loaded,
</p>
<pre>
  (use-modules (ice-9 debug))
</pre>
<p>
Now when an error occurs, you can call (snd-debug) 
and fall into the debugger.  The debugger in Snd is just the normal
listener, but you also have some stacks and continuations lying
around.  These can be examined via <b>bt</b> (backtrace) and
<b>lv</b> (local variables).
</p>
<p>If you're getting a stack overflow, and you're sure it's not a case
of infinite recursion,
</p>
<pre>
(debug-set! stack 0)
</pre>
<p>turns off the (very conservative) stack overflow check.
</p>
<hr>
<A NAME="cdebugging"></a>
<!-- INDEX cdebugging:Debugging (C) -->
<p>If you hit a bug in Snd's C code, you'll need to use gdb (or dbx on the SGI)
to track it down, or mail me the gory details;
if the error is a segfault, there is probably a file named "core" or "core.nnnn"
on the current directory:
</p>
<pre>
gdb snd core
where
</pre>
<p>The "where" command displays the stack at the point of the error.
"up", and "down" move around in the stack, and "info locals" prints out
the current frame's variables.  If it's not a segfault, you can
</p>
<pre>
gdb snd
run
</pre>
<p>Then get the error to happen, at which point you should fall into gdb
where you can type "where" and so on.  If the problem involves X, you
may need to run -sync.  If Gtk, run --g-fatal-errors.  If Snd gets hung
and you need to type C-C to get out, 
</p>
<pre>
gdb snd
break exit
run
</pre>

<br>


<table width="100%" border=1><tr><td bgcolor="lightsteelblue" valign="middle"><h3><A NAME="appearance">Customizing Snd's appearance</a></h3></td></tr></table>

<p>Snd's overall appearance is controlled first by the startup <a href="grfsnd.html#sndswitches">switches</a> that
choose the outermost widget; normally this is a paned window with a sound
in each pane; -separate puts each
sound in a separate window, and -notebook
puts each sound on a separate page of a notebook widget.  Similarly -horizontal
and -vertical determine which way the outer panes are laid out. 
There are a variety of functions and variables related to widget colors and so forth.
</p>

<table width="100%" border=1><tr><td bgcolor="lightgreen" valign="middle"><h4><A NAME="colors">Colors</a></h4></td></tr></table>

<p>A color in Snd is an object with three fields representing the
rgb (red green blue) settings as numbers between 0.0 and 1.0.  A color
object is created via make-color:</p>
<pre>
&gt;<em class=typing>(define blue (make-color 0 0 1))</em>
</pre>
<p>This declares the Scheme variable "blue" and gives it the value
of the color whose rgb components include only blue in full force.
The X11 color names are defined in <a href="sndscm.html#rgbdoc">rgb.scm</a>. The overall
widget background color is <i>basic-color</i>.
</p>
<pre>
&gt;<em class=typing>(set! (basic-color) blue)</em>
</pre>

<p>The color variables
are:</p>

<table border=0 cellpadding=0 cellspacing=0>
<tr><td width=220><code><em class=def><a name="basiccolor">basic-color</a></em></code></td>
    <td width=180><code>ivory2</code></td>
    <td>main Snd color.</td></tr>
<tr><td><code><em class=def><a name="cursorcolor">cursor-color</a></em></code></td>
    <td><code>red</code></td>
    <td>cursor color.</td></tr>
<tr><td><code><em class=def><a name="datacolor">data-color</a></em></code></td>
    <td><code>black</code></td>
    <td>color of data in unselected graph.</td></tr>
<tr><td><code><em class=def>enved-waveform-color</em></code></td>
    <td><code>blue</code></td>
    <td>color of waveform displayed in envelope editor.</td></tr>
<tr><td><code><em class=def><a name="filterwaveformcolor">filter-waveform-color</a></em></code></td>
    <td><code>blue</code></td>
    <td>color of control panel filter waveform.</td></tr>
<tr><td><code><em class=def><a name="graphcolor">graph-color</a></em></code></td>
    <td><code>white</code></td>
    <td>background color of unselected graph.</td></tr>
<tr><td><code><em class=def><a name="highlightcolor">highlight-color</a></em></code></td>
    <td><code>ivory1</code></td>
    <td>highlighting color.</td></tr>
<tr><td><code><em class=def>listener-color</em></code></td>
    <td><code>aliceblue</code></td>
    <td>background color of lisp listener.</td></tr>
<tr><td><code><em class=def>listener-text-color</em></code></td>
    <td><code>black</code></td>
    <td>text color in lisp listener.</td></tr>
<tr><td><code><em class=def><a name="markcolor">mark-color</a></em></code></td>
    <td><code>red</code></td>
    <td>color of mark indicator.</td></tr>
<tr><td><code><em class=def>mix-color</em></code></td>
    <td><code>darkgray</code></td>
    <td>color of mix waveforms.</td></tr>
<tr><td><code><em class=def>selected-mix-color</em></code></td>
    <td><code>lightgreen</code></td>
    <td>color of selected mix waveform.</td></tr>
<tr><td><code><em class=def><a name="positioncolor">position-color</a></em></code></td>
    <td><code>ivory3</code></td>
    <td>position slider color</td></tr>
<tr><td><code><em class=def><a name="pushedbuttoncolor">pushed-button-color</a></em></code></td>
    <td><code>lightsteelblue1</code></td>
    <td>color of pushed button.</td></tr>
<tr><td><code><em class=def><a name="sashcolor">sash-color</a></em></code></td>
    <td><code>lightgreen</code></td>
    <td>color of paned window sashes.</td></tr>
<tr><td><code><em class=def><a name="selecteddatacolor">selected-data-color</a></em></code></td>
    <td><code>black</code></td>
    <td>color of data in currently selected graph.</td></tr>
<tr><td><code><em class=def><a name="selectedgraphcolor">selected-graph-color</a></em></code></td>
    <td><code>white</code></td>
    <td>background color of currently selected graph.</td></tr>
<tr><td><code><em class=def><a name="selectioncolor">selection-color</a></em></code></td>
    <td><code>lightsteelblue1</code></td>
    <td>color of selected portion of graph.</td></tr>
<tr><td><code><em class=def><a name="textfocuscolor">text-focus-color</a></em></code></td>
    <td><code>white</code></td>
    <td>color of text field when it has focus.</td></tr>
<tr><td><code><em class=def><a name="zoomcolor">zoom-color</a></em></code></td>
    <td><code>ivory4</code></td>
    <td>zoom slider color.</td></tr>
</table>

<br>
<p>I have these lines in my ~/.snd file:
</p>
<pre>
    (define beige (make-color 0.96 0.96 0.86))
    (define blue (make-color 0 0 1))
    (set! (selected-graph-color) beige)
    (set! (selected-data-color) blue)
</pre>
<br>

<p>In addition, the various transforms can be displayed using colormaps.  The following
variables and functions control this:</p>

<table border=0 cellspacing=4>

<tr><td width=180><code><em class=def><a name="colorcutoff">color-cutoff</a></em></code></td><td width=100>0.003</td>
<td>In spectra, sets the lowest data value that will be colored.</td></tr>
<tr><td><code><em class=def><a name="sndcolordialog">color-dialog</a></em></code></td><td>()</td>
<td>Create the Color dialog (to choose a colormap etc), if necessary, activate it and return the dialog widget.</td></tr>
<tr><td><code><em class=def><a name="colorinverted">color-inverted</a></em></code></td><td>#t</td>
<td>The 'invert' button in the <a href="snd.html#colorbrowser">color</a> dialog, negated (hunh?!).</td></tr>
<tr><td><code><em class=def><a name="colorscale">color-scale</a></em></code></td><td>0.5</td>
<td>The darkness setting in the <a href="snd.html#colorbrowser">color</a> dialog, divided by 100.</td></tr>
<tr><td valign=top><code><em class=def><a name="colormap">colormap</a></em></code></td><td valign=top>0</td>
<td>Colormap choice for various displays (see the Color dialog, or <i>samples-via-colormap</i> in draw.scm).
<br>
This should be an integer between -1 and 15.  The maps (from 0 to 15) are: 
gray, hsv, hot, cool, bone, copper, pink, jet, prism, autumn, winter, 
spring, summer, colorcube, flag, and lines.  -1 means black and white.
These names are defined (with color-map prepended) in rgb.scm.
</td></tr>
</table>

<p>The color object handlers are:</p>

<table border=0 cellspacing=4>
<tr>
<td width="20%"><code><em class=def><a name="colorp">color?</a></em> (obj)</code></td>
<td>#t if <i>obj</i> is a color (this is the same as Pixel? in xm), (see <a href="#makecolor">make-color</a>).</td></tr>

<tr>
<td><code><em class=def><a name="color3list">color-&gt;list</a></em> (obj)</code></td>
<td>return list (r g b) of color components.</td></tr>

<tr>
<td valign=top><code><em class=def><a name="makecolor">make-color</a></em> (r g b)</code></td>
<td>return a color object using the red/green/blue values.  If the object is called
as a function, it returns the list of rgb values.
If, for example, blue is a defined color, <code>(blue)</code> is the same as <code>(color-&gt;list blue)</code>.
Two colors are equal (i.e. equal? returns #t) if their rgb values are the same.
</td>
</tr>
</table>

<br>
<table width="100%" border=1><tr><td bgcolor="lightgreen" valign="middle"><h4><A NAME="fonts">Fonts</a></h4></td></tr></table>

<p>Fonts in Snd are strings containing a description of the
desired font.  These can be the abbreviated forms such as
"8x14" or a full X font name such as "-misc-fixed-bold-r-normal--*-140-*-*-c-*-*-*".
The font variables are:
</p>
<table cellpadding=0 cellspacing=0>
<tr><td width=200><code><em class=def><a name="axislabelfont">axis-label-font</a></em></code></td><td>used in axis labels</td></tr>
<tr><td><code><em class=def><a name="axisnumbersfont">axis-numbers-font</a></em></code></td><td>used in axis tick numbers</td></tr>
<tr><td><code><em class=def><a name="boldbuttonfont">bold-button-font</a></em></code></td><td>used by various buttons and labels</td></tr>
<tr><td><code><em class=def><a name="boldpeaksfont">bold-peaks-font</a></em></code></td><td>used by fft peaks display</td></tr>
<tr><td><code><em class=def><a name="peaksfont">peaks-font</a></em></code></td><td>used by ffy peaks display</td></tr>
<tr><td><code><em class=def>listener-font</em></code></td><td>listener font</td></tr>
<tr><td><code><em class=def><a name="tinyfont">tiny-font</a></em></code></td><td>smallest font used</td></tr>
</table>
<br>
<center><table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(set! (listener-font) "9x15")
(set! (bold-button-font) "-*-times-bold-r-*-*-14-*-*-*-*-*-*-*")
(set! (axis-label-font) "-*-times-medium-r-normal-*-18-*-*-*-*-*-*-*")
(set! (axis-numbers-font) "9x15")
</pre></td></tr></table></center>

<p>See also <a href="#loadfont">load-font</a> and <a href="#currentfont">current-font</a> below.
In Gtk2, Pango-style names are used for the fonts: "Monospace 8" for example.
If the requested font can't be loaded, the set! statement returns the old (unchanged) font name.
</p>
<pre>
&gt;<em class=typing>(set! (axis-label-font) "8x14")</em>
<em class=listener>"-*-times-medium-r-normal-*-18-*-*-*-*-*-*-*"</em>
</pre>
<br>
<br>
<table width="100%" border=1><tr><td bgcolor="lightgreen" valign="middle"><h4><A NAME="sndwidgets">Widgets</a></h4></td></tr></table>

<p>Snd can be built with Motif, Gtk, or no GUI; other toolkits might be supported in the future.
Unfortunately, each toolkit has its own way of handling widgets.  I originally started implementing
a Snd-specific layer of calls that would work in any supported toolkit, but then changed direction
and decided to implement the libxm connection.  This left the earlier graphics functions dangling;
they are still useful, but they probably should not be built-in.  I'm currently planning to move
them to Scheme/Ruby.  But, for now, here are some of them:
</p>
<table cellspacing=0>
<tr><td><code><em class=def>widget-position</em> (widget)</code></td>
<td>return a list giving the widget x and y positions</td></tr>
<tr><td valign=top><code><em class=def>widget-size</em> (widget)</code></td>
<td>return a list giving the widget width and height.  The corresponding set! forms also take a list:<br>
<code>(set! (widget-position (cadr (main-widgets))) (list 300 100))</code></td></tr>
<tr><td><code><em class=def>widget-text</em> (widget)</code></td><td>return or set the contents of text widget</td></tr>
<tr><td><code><em class=def><a name="recolorwidget">recolor-widget</a></em> (widget color)</code></td></tr>
<tr><td><code><em class=def><a name="showwidget">show-widget</a></em> (widget)</code></td></tr>
<tr><td><code><em class=def><a name="hidewidget">hide-widget</a></em> (widget)</code></td></tr>
<tr><td><code><em class=def><a name="focuswidget">focus-widget</a></em> (widget)</code></td></tr>
<tr><td colspan=2><br></td></tr>
<tr><td><code><em class=def><a name="mainmenu">main-menu</a></em> (menu)</code></td><td></td></tr>
<tr><td><code><em class=def><a name="mainwidgets">main-widgets</a></em> ()</code></td><td></td></tr>
<tr><td><code><em class=def><a name="menuwidgets">menu-widgets</a></em> ()</code></td><td></td></tr>
<tr><td><code><em class=def><a name="soundwidgets">sound-widgets</a></em> (snd)</code></td><td></td></tr>
<tr><td><code><em class=def><a name="channelwidgets">channel-widgets</a></em> (snd chn)</code></td><td></td></tr>
<tr><td><code><em class=def><a name="dialogwidgets">dialog-widgets</a></em> ()</code></td><td></td></tr>
</table>

<p>
The four "-widgets" procedures return lists of possibly useful widgets:
</p>
<pre>
  main-widgets:    '(0:top-level-application 1:top-level-shell 2:main-pane 3:main-sound-pane 4:listener-pane 5:notebook-outer-pane)
  menu-widgets:    '(0:top-level-menu-bar 1:file-menu 2:edit-menu 3:view-menu 4:options-menu 5:help-menu)
  sound-widgets:   '(0:main-pane 1:name-label 2:control-panel 3:minibuffer 4:play 5:filter-graph 6:unite 7:minibuffer-label 8:name-icon 9:sync)
  channel-widgets: '(0:graph 1:w 2:f 3:sx 4:sy 5:zx 6:zy 7:edhist 8:gsy 9:gzy) + others in gtk
  dialog-widgets:  '(0:color_dialog 1:orientation_dialog 2:enved_dialog 3:error_dialog 
                     4:yes_or_no_dialog 5:transform_dialog 6:file_open_dialog 
                     7:file_save_as_dialog 8:view_files_dialog 9:raw_data_dialog 
                     10:new_file_dialog 11:file_mix_dialog 12:edit_header_dialog 
                     13:find_dialog 14:help_dialog 15:completion_dialog 16:mix_panel_dialog
                     17:print_dialog 18:recorder_dialog 19:region_dialog)
</pre>
<p>
<i>dialog-widgets</i> entries are #f for any dialog that has not
yet been created.  In gtk, the first element of the main-widgets list is the top level shell's window.
</p>
<pre>
  (recolor-widget (cadr (sound-widgets)) (make-color 1 0 0))
</pre>
<p>makes the sound name label red. To remove the y-position slider (which is only there
for looks):
</p>
<pre>
  (hide-widget (list-ref (channel-widgets) 4))
</pre>
<p>See also snd-motif.scm, new-effects.scm, and examp.scm.</p>

<br>
<table width="100%" border=1><tr><td bgcolor="lightgreen" valign="middle"><h4><A NAME="sndgraphics">Graphics</a></h4></td></tr></table>

<p>It is possible to draw directly on any of the channel graphs.  Simple examples include the
<a href="extsnd.html#showoriginal">show-original</a> after-graph-hook function, and the
<a href="extsnd.html#xcursor">x-cursor</a> function that draws an "x" shaped cursor.
The lowest level procedures are:
</p>

<!-- -------------------------------- GRAPHICS TABLE -------------------------------- -->
<table border=0 cellspacing=4>

<!-- axis-info -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="axisinfo">axis-info</a></em> (snd chn <i>grf</i>)</code></span></td></tr>
<tr><td><spacer type=horizontal size=40><br></td><td>
return a list describing the specified axis:
<code>'(left-sample right-sample x0 y0 x1 y1 x-min y-min x-max y-max 
x0-position y0-position x1-position y1-position y-offset xlabel)</code>.  This might be
useful if you're drawing arbitrary figures in a graph.  <i>grf</i> defaults to
time-graph; the other choices are transform-graph and lisp-graph.  The procedure <a href="#x2position">x-&gt;position</a>
could be defined as:
</td></tr>
<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (x-&gt;position-1 x snd chn)
  (let* ((axinfo (<em class=red>axis-info</em> snd chn time-graph))
	 (x0 (list-ref axinfo 2))
	 (x1 (list-ref axinfo 4))
	 (axis-left (list-ref axinfo 10))
	 (axis-right (list-ref axinfo 12)))
    (inexact-&gt;exact 
     (+ axis-left
	(* (- x x0) 
	   (/ (- axis-right axis-left)
	      (- x1 x0)))))))
</pre></td></tr></table>
<br>
See <i>draw-smpte-label</i> in snd-motif.scm, or <i>make-current-window-display</i> in draw.scm.
</td></tr>
<tr><td colspan=2></td></tr>

<!-- colormap-ref -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="colormapref">colormap-ref</a></em> (map pos)</code></span></td></tr>
<tr><td></td><td>
<i>colormap-ref</i> returns the rgb values of the colormap <i>map</i> at position <i>pos</i>,
suitable for use with make-color.  'map' can be a number
between 0.0 and 1.0 with 'pos' omitted; in this case the colormap choice comes from the color dialog.
See <i>samples-via-colormap</i> in draw.scm.
</td></tr><tr><td colspan=2></td></tr>

<!-- copy-context -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="copycontext">copy-context</a></em></code></span></td></tr>
<tr><td></td><td>
the graphics mode to use to draw over whatever is currently in a graph.
The "contexts" refer to graphics contexts used throughout Snd; the <i>copy-context</i>
copies into the current graph, whereas the <i>cursor-context</i> uses XOR.
The error thrown for an unimplemented 'context' is 'no-such-graphics-context.
See draw.scm or <a href="#displaysampsinred">display-samps-in-red</a>.
</td></tr>
<tr><td colspan=2></td></tr>

<!-- current-font -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="currentfont">current-font</a></em> (snd chn context)</code></span></td></tr>
<tr><td></td><td>
return the current font (also settable).</td></tr>
<tr><td colspan=2></td></tr>

<!-- cursor-context -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="cursorcontext">cursor-context</a></em></code></span></td></tr>
<tr><td></td><td>
the graphics mode for XOR drawing in the cursor color (for cursors, normally).
See <a href="#xcursor">x-cursor</a> or
<a href="#foregroundcolor">foreground-color</a>.
</td></tr>
<tr><td colspan=2></td></tr>

<!-- draw-axes -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="drawaxes">draw-axes</a></em> (wid gc <i>label x0 x1 y0 y1 style axes</i>)</code></span></td></tr>
<tr><td width=50></td><td>
draw axes in the widget <i>wid</i>, using the graphics context <i>gc</i>, with the x-axis label <i>label</i>
going from <i>x0</i> to <i>x1</i> (floats) along the x axis, <i>y0</i> to <i>y1</i> along the y axis, with x-axis-style
<i>style</i> (x-axis-in-seconds etc); whether the axes are actually displayed or just implied
depends on <i>axes</i>. Return a list of the actual (pixel) axis bounds.  See the scanned-synthesis display code in snd-motif.scm,
or the local envelope editor code in xm-enved.scm.
</td></tr><tr><td colspan=2></td></tr>

<!-- draw-dot -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="drawdot">draw-dot</a></em> (x0 y0 dot-size snd chn context)</code></span></td></tr>
<tr><td width=50></td><td>
draw a dot at (x0 y0) of <i>dot-size</i> pixels diameter in the given graph.  See musglyphs.scm.</td></tr>
<tr><td colspan=2></td></tr>

<!-- draw-dots -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="drawdots">draw-dots</a></em> (positions dot-size snd chn context)</code></span></td></tr>
<tr><td></td><td>
draw dots of size <i>dot-size</i> from the (x y) pairs in the vector <i>positions</i> in the given context.
draw-dots, draw-lines, and fill-polygon take vectors, rather than vcts (which would be more consistent
with the rest of Snd) because the values passed are supposed to be short ints.  The xm and xg modules
have made these functions obsolete.
</td></tr>
<tr><td colspan=2></td></tr>

<!-- draw-line -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="drawline">draw-line</a></em> (x0 y0 x1 y1 snd chn context)</code></span></td></tr>
<tr><td></td><td>
draw a line from (x0 y0) to (x1 y1) in the given context.
See <i>show-hiho</i> below.
</td></tr>
<tr><td colspan=2></td></tr>

<!-- draw-lines -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="drawlines">draw-lines</a></em> (lines size snd chn context)</code></span></td></tr>
<tr><td></td><td>
draw lines following the (x y) pairs in the vector <i>lines</i> in the given graphics context (copy-context is the default).
See <i>make-current-window-display</i> in draw.scm.
<i>make-bezier-1</i> in <a href="sndscm.html#musglyphs">musglyphs.scm</a> can be used to draw Bezier curves.
</td></tr>
<tr><td colspan=2></td></tr>

<!-- draw-string -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="drawstring">draw-string</a></em> (text x0 y0 snd chn context)</code></span></td></tr>
<tr><td></td><td>
draw a string (<i>text</i>) in the current font and foreground color starting at (x0 y0) in the given graphics context.
The next procedures use the channel-property list (extensions.scm) to maintain a list
of sample-oriented comments, displaying a given comment if its associated sample is
currently in the time-domain graph:
</td></tr>
<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define* (<a name="addcomment">add-comment</a> sample comment #:optional snd1 chn1)
  (let* ((snd (or snd1 (selected-sound)))
	 (chn (or chn1 (selected-channel)))
	 (old-comments (or (channel-property 'comments snd chn) '())))
    (set! (channel-property 'comments snd chn)
	  (cons (list sample comment)
		old-comments))))
	  
(define (show-comments snd chn)
  (let ((comments (or (channel-property 'comments snd chn) '())))
    (for-each
     (lambda (comment)
       (let* ((samp (car comment))
	      (text (cadr comment))
	      (text-width (* 6 (string-length text)))
	      (ls (left-sample snd chn))
	      (rs (right-sample snd chn)))
	 (if (and (&lt; ls samp)
		  (&gt; rs samp))
	     (let ((xpos (x-&gt;position (/ samp (srate))))
		   (ypos (y-&gt;position (sample samp))))
	       (draw-line xpos 20 xpos (- ypos 4))
	       (<em class=red>draw-string</em> text (- xpos (/ text-width 2)) 18)))))
     comments)))

(add-hook! after-graph-hook show-comments)
</pre></td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>
<tr><td colspan=2></td></tr>

<!-- fill-rectangle -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="fillrectangle">fill-rectangle</a></em> (x0 y0 width height snd chn context)</code></span></td></tr>
<tr><td></td><td>
draws a filled rectangle in the current foreground color from (x0 y0) of size (width height).
See draw.scm, snd-motif.scm, or <a href="#showoriginal">show-original</a>.
</td></tr>
<tr><td colspan=2></td></tr>

<!-- fill-polygon -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="fillpolygon">fill-polygon</a></em> (points snd chn context)</code></span></td></tr>
<tr><td></td><td>
draws a filled polygon whose vertices are in the vector <i>points</i>.</td></tr>
<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (-&gt; x0 y0 size snd chn)
  "draw an arrow pointing (from the left) at the point (x0 y0)"
  (let ((points (make-vector 8)))
    (define (point i x y)
      (vector-set! points (* i 2) x)
      (vector-set! points (+ (* i 2) 1) y))
    (define (arrow-head x y)
      (point 0 x y)
      (point 1 (- x (* 2 size)) (- y size))
      (point 2 (- x (* 2 size)) (+ y size))
      (point 3 x y)
      (<em class=red>fill-polygon</em> points snd chn))
    (arrow-head x0 y0)
    (fill-rectangle (- x0 (* 4 size)) 
		    (inexact-&gt;exact (- y0 (* .4 size)))
		    (* 2 size)
		    (inexact-&gt;exact (* .8 size))
                    snd chn)))	
</pre></td></tr></table></td></tr>
<tr><td colspan=2></td></tr>
<tr><td></td><td>
musglyphs.scm has some elaborate examples that use fill-polygon to draw music notation symbols.
</td></tr>
<tr><td colspan=2></td></tr>

<!-- foreground-color -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="foregroundcolor">foreground-color</a></em> (snd chn context)</code></span></td></tr>
<tr><td></td><td>
return the current foreground color (also settable).
The following gives us a green cursor:
<pre>
  (set! (<em class=red>foreground-color</em> 0 0 cursor-context) (make-color 1 0 1))
</pre>
We can goof around with colors and fonts:
</td></tr>
<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define new-font (load-font "-*-helvetica-bold-r-*-*-14-*-*-*-*-*-*-*"))

(define show-hiho
  ;; show a red "hiho" in the helvetica bold font on a gray background
  (lambda (snd chn)
    (let ((ls (left-sample snd chn))
          (rs (right-sample snd chn)))
      (if (and (&lt; ls 1000)
               (&gt; rs 1000))
	  (let ((pos (x-&gt;position (/ 1000.0 (srate))))
		(old-color (foreground-color)))
	    (set! (<em class=red>foreground-color</em>) (make-color .75 .75 .75))
            (fill-rectangle pos 10 50 20)
	    (set! (<em class=red>foreground-color</em>) (make-color 1 0 0))
	    (if new-font (set! (<em class=red>current-font</em>) new-font))
            (draw-string "hiho" (+ pos 5) 24)
	    (set! (<em class=red>foreground-color</em>) old-color))))))
</pre></td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>

<!-- glSpectrogram -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="glspectrogram">glSpectrogram</a></em> (data gl-list cutoff use-dB min-dB scale br bg bb)</code></span></td></tr>
<tr><td></td><td>
<i>glSpectrogram</i> takes spectrogram data and passes it to openGL.  
The <a href="sndscm.html#startwaterfall">waterfall</a> function in snd-gl.scm uses this function.</td></tr>
<tr><td colspan=2></td></tr>

<!-- graph-data -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="graphdata">graph-data</a></em> (data snd chn context low high graphics-style)</code></span></td></tr>
<tr><td></td><td>
<i>graph-data</i> displays <i>data</i> in the time domain graph of <i>snd</i>'s channel
<i>chn</i> using the graphics context <i>context</i> (normally copy-context), placing the
data in the recipient's graph between points <i>low</i> and <i>high</i>
in the drawing mode (<i>graphics-style</i>).
With this function and <i>make-graph-data</i> we can overlay sounds,
overlay different versions of the same sound, place a portion of a
sound over another at an arbitrary point, and so on (see draw.scm):
</td></tr>
<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (<A NAME="displaysampsinred">display-samps-in-red</A> snd chn)
  "display samples 1000 to 2000 in red whenever they're in the current view"
  (let ((left (left-sample snd chn))
	(right (right-sample snd chn))
	(old-color (foreground-color snd chn))
	(red (make-color 1 0 0)))
    (if (and (&lt; left 2000)
	     (&gt; right 1000))
	(let* ((data (<em class=red>make-graph-data</em> snd chn)))
	  (if (vct? data)                      ;the simple, one-sided graph case
	      (let* ((samps (- (min right 2000)
			       (max left 1000)))
		     (offset (max 0 (- 1000 left)))
		     (new-data (vct-subseq data offset (+ offset samps))))
		(set! (foreground-color snd chn) red)
		(<em class=red>graph-data</em> new-data snd chn copy-context (max 1000 left) (min 2000 right))
		(set! (foreground-color snd chn) old-color))
	      (let* ((low-data (car data))     ;the two-sided envelope graph case
		     (high-data (cadr data))
                     ;; we need to place the red portion correctly in the current graph
                     ;; so the following is getting the "bin" numbers associated with 
                     ;; samples 1000 and 2000
		     (size (vct-length low-data))
		     (samps (- right left))
		     (left-offset (max 0 (- 1000 left)))
		     (left-bin (inexact-&gt;exact (/ (* size left-offset) samps)))
		     (right-offset (- (min 2000 right) left))
		     (right-bin (inexact-&gt;exact (/ (* size right-offset) samps)))
		     (new-low-data (vct-subseq low-data left-bin right-bin))
		     (new-high-data (vct-subseq high-data left-bin right-bin)))
		(set! (foreground-color snd chn) red)
		(<em class=red>graph-data</em> 
                  (list new-low-data new-high-data) snd chn copy-context left-bin right-bin)
		(set! (foreground-color snd chn) old-color)))))))

(add-hook! after-graph-hook display-samps-in-red)
</pre></td></tr></table></td></tr>
<tr><td></td><td align=center>
<img src="redsamps.png" alt="red samples">
</td></tr>
<tr><td colspan=2></td></tr>

<!-- load-font -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="loadfont">load-font</a></em> (font-name)</code></span></td></tr>
<tr><td></td><td>
load the font <i>font-name</i> (an X-style font spec), and return a handle for it (for <a href="#currentfont">current-font</a>).
<pre>
  (define new-font (<em class=red>load-font</em> "-*-helvetica-bold-r-*-*-14-*-*-*-*-*-*-*"))
</pre>
load-font could be (should have been!) defined using the xm module as:
</td></tr>
<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define (load-font name)
  (let ((fs (XLoadQueryFont (XtDisplay (cadr (main-widgets))) name)))
    (and (XFontStruct? fs) (.fid fs))))
</pre></td></tr></table>
</td></tr>
<tr><td colspan=2></td></tr>
<tr><td colspan=2></td></tr>

<!-- make-graph-data -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="makegraphdata">make-graph-data</a></em> (snd chn edit-position low-sample high-sample)</code></span></td></tr>
<tr><td></td><td>
Use <i>make-graph-data</i> to get the currently displayed data (i.e. the waveform displayed
in the graph, which can be based on an overall peak envelope rather than the
individual samples).
It returns either a vct (if the graph has one trace), or a
list of two vcts (the two sides of the peak envelope graph).
<i>edit-position</i> defaults to the current edit history position,
<i>low-sample</i> defaults to the current window left sample, and
<i>high-sample</i> defaults to the current rightmost sample.
The result can be used in the lisp graph:
</td></tr>
<tr><td></td><td>
<table border=1 cellpadding=5><tr><td bgcolor="#FEFEF6"><pre>
(define <A NAME="displaydb">display-db</A>
  (lambda (snd chn)
    "(display-db snd chn) is a lisp-graph-hook function to display the time domain data in dB"
    (let* ((datal (<em class=red>make-graph-data</em> snd chn))
	   (data (if (vct? datal) datal (cadr datal)))
           (sr (srate snd)))
      (define (dB val)
	(if (&lt; val .001)
	    -60.0
	    (* 20.0 (log10 val))))
      (vct-map! data (lambda ()
		       (+ 60.0 (dB (abs (vct-ref data i))))))
      (graph data "dB" 
	     (/ (left-sample snd chn) sr) (/ (right-sample snd chn) sr)  
	     0.0 60.0
	     snd chn))))

(add-hook! lisp-graph-hook display-db)
</pre></td></tr></table>
</td></tr>
<tr><td></td><td>
Here we are taking whatever is displayed in the time domain, and
presenting the same thing in dB in the lisp graph.  <i>display-energy</i>
in examp.scm is another example.  But the real power of this function
comes from its use with <i>graph-data</i>.  
The latter takes its argument (either a vct or a list of two
vcts), and displays it in any channel's time domain graph using its current graph-style.
</td></tr>
<tr><td colspan=2></td></tr>

<!-- mark-context -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="markcontext">mark-context</a></em></code></span></td></tr>
<tr><td></td><td>
the graphics context to use to draw a mark (XOR mode).
</td></tr>
<tr><td colspan=2></td></tr>

<!-- selection-context -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="selectioncontext">selection-context</a></em></code></span></td></tr>
<tr><td></td><td>
the graphics context for XOR drawing in the selection color.</td></tr>
<tr><td colspan=2></td></tr>

<!-- send-netscape -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sendnetscape">send-netscape</a></em> (url)</code></span></td></tr>
<tr><td></td><td>
Start netscape, if necessary, and tell it to go to the location 'url'.
</td></tr><tr><td colspan=2></td></tr>

<!-- snd-gcs -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="sndgcs">snd-gcs</a></em></code></span></td></tr>
<tr><td></td><td>
<i>snd-gcs</i> returns a list of Snd's graphics contexts (intended for use with the xm module in snd-motif.scm):
(0)basic (1)selected_basic (2)combined (3)cursor (4)selected_cursor (5)selection (6)selected_selection 
(7)erase (8)selected_erase (9)mark (10)selected_mark (11)mix (12)selected_mix (13)fltenv_basic (14)fltenv_data.
</td>
</tr><tr><td colspan=2></td></tr>

<!-- with-gl -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="withgl">with-gl</a></em></code></span></td></tr>
<tr><td></td><td>
If #t and GL is loaded, use GL where possible (default is #t if HAVE_GL).</td></tr>
<tr><td colspan=2></td></tr>

<!-- x-axis-label -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="xaxislabel">x-axis-label</a></em> (snd chn context)</code></span></td></tr>
<tr><td></td><td>
return the current x axis label (also settable).
</td></tr>
<tr><td colspan=2></td></tr>

</table>

        <!-- I(open file):L(open-sound)(sndopen) -->
	<!-- I(close file):L(close-sound)(sndclose) -->
	<!-- I(save file):L(save-sound)(sndsave) -->
        <!-- I(save file as):L(save-sound-as)(sndsaveas) -->
        <!-- I(change format):L(save-sound-as)(sndsaveas) -->
	<!-- I(revert file):L(revert-sound)(sndrevert) -->
        <!-- I(open file read-only):L(view-sound)(sndview) -->
        <!-- I(create new file):L(new-sound)(sndnew) -->
	<!-- I(print file):L(graph-&gt;ps)(sndgraph2ps) -->
	<!-- I(exit Snd):L(exit)(sndexit) -->
        <!-- I(undo edit):L(undo)(sndundo) -->
	<!-- I(redo edit):L(redo)(sndredo) -->
        <!-- I(cut selection):L(delete-selection)(snddeleteselection) -->
	<!-- I(insert selection):O(insert-region)(sndinsertregion) -->
	<!-- I(insert selection):L(insert-selection)(sndinsertselection) -->
	<!-- I(play file):L(play, stop)(sndplay) -->
        <!-- I(show marks):L(show-marks)(showmarks) --><!-- I(show marks):A(showmarks) -->
	<!-- I(y=0 line):L(show-y-zero)(showyzero) -->
	<!-- I(dots or lines):L(graph-style)(graphstyle) -->
        <!-- I(combine channels):L(channel-style)(channelstyle) -->
        <!-- I(normalize display):L(equalize-panes)(sndequalizepanes) -->
        <!-- I(control panel):L(show-controls)(sndshowcontrols) -->
	<!-- I(fft peaks):L(show-transform-peaks)(showfftpeaks) -->
        <!-- I(fft peaks):O(peaks)(sndpeaks) -->
	<!-- I(fft/sono/spectrogram):L(transform-graph-type)(lfftstyle) -->
        <!-- I(zoom focus):L(zoom-focus-style)(zoomfocusstyle) -->
	<!-- I(fft in dB):L(fft-log-magnitude)(fftlogmagnitude) -->
	<!-- I(fft log freq):L(fft-log-frequency)(fftlogfrequency) -->
	<!-- I(select sound):L(selected-sound)(sndselectedsound) -->
	<!-- I(multichannel ops):L(sync)(sndsyncing) -->
        <!-- I(save control panel):L(save-controls)(sndcontrolsave) -->
	<!-- I(amp env):L(env-sound)(sndenv) -->
        <!-- I(filter):L(filter-env)(sndfilterenv) -->
	<!-- I(filter):M(Edit: Edit Env)(editenvelope) -->
        <!-- I(axis bounds):L([xy]-bounds)(sndxbounds) -->
	<!-- I(max amp):L(maxamp)(sndmaxamp) -->
	<!-- I(max amp):A(sndmaxamp) -->
        <!-- I(define mark):L(add-mark)(sndaddmark) -->
	<!-- I(preload directory):L(preload-directory)(sndpreloaddirectory) -->
        <!-- I(color):L(color-dialog)(sndcolordialog) -->
	<!-- I(color):O(color-scale,color-cutoff)(colorscale) -->
        <!-- I(orientation):L(orientation-dialog)(sndorientationdialog) -->
        <!-- I(orientation):O(spectro-x-angle etc)(spectroxangle) -->
	<!-- I(file lists):L(file-dialog)(sndfiledialog) -->
        <!-- I(define selection):L(make-region)(sndmakeregion) -->
	<!-- I(delete samples):L(delete-samples)(snddeletesamples) -->
        <!-- I(temp directory):L(temp-dir)(tempdir) -->
        <!-- I(continue session):L(load) -->
        <!-- I(fft window):L(fft-window)(lfftwindow) -->
	<!-- I(fft size):L(transform-size)(lfftsize) -->
        <!-- I(fft window parameter):L(fft-window-beta)(fftbeta) -->
	<!-- I(move cursor ahead):L(set cursor)(sndcursor) -->
        <!-- I(move cursor back):L(set cursor)(sndcursor) -->
        <!-- I(insert zeros):L(insert-silence)(sndinsertsilence) -->
        <!-- I(insert zeros):O(pad-channel)(padchannel) -->
	<!-- I(change samples):L(set-samples)(sndsetsamples) -->
	<!-- I(srate conversion):L(src-sound)(sndsrc) --><!-- I(srate conversion):M(Edit: Edit Env)(editenvelope) -->
        <!-- I(srate conversion):O(src-selection)(sndsrcselection) --><!-- I(srate conversion):A(sndsrc) -->
	<!-- I(resample):L(src-sound)(sndsrc) --><!-- I(resample):M(Edit: Edit Env)(editenvelope) --><!-- I(resample):A(sndsrc) -->
	<!-- I(resample):O(src-selection)(sndsrcselection) --><!-- I(reverse samples):A(sndreverse) -->
	<!-- I(reverse samples):L(reverse-sound)(sndreverse) --><!-- I(reverse samples):O(reverse-selection)(sndreverseselection) -->
	<!-- I(filter samples):L(filter-sound)(sndfilter) --><!-- I(filter samples):M(Edit: Edit Env)(editenvelope) -->
	<!-- I(filter samples):O(filter-selection)(sndfilterselection) --><!-- I(filter samples):A(sndfilter) -->
	<!-- I(save marks):L(save-marks)(sndsavemarks) -->
        <!-- I(show freq domain):L(transform-graph?)(sndffting) -->
	<!-- I(show time domain):L(time-graph?)(sndwaving) -->
        <!-- I(keyboard macros):L(key)(sndkey) -->
        <!-- I(delete mark):L(delete-mark)(snddeletemark) --> <!-- I(delete mark):O(delete-marks)(snddeletemarks) -->
	<!-- I(sonogram):L(transform-graph-type)(lfftstyle) -->
	<!-- I(spectrogram):L(transform-graph-type)(lfftstyle) -->
        <!-- I(X axis units):L(x-axis-style)(xaxisstyle) -->
	<!-- I(speed units):L(speed-control-style)(lspeedstyle) -->
	<!-- I(speed units):O(speed-control-tones)(speedtones) -->
	<!-- I(change srate):L(src-sound)(sndsrc) -->	
	<!-- I(edit env):L(enved-dialog)(sndenveddialog) -->
	<!-- I(edit header):L(edit-header-dialog)(sndeditheaderdialog) -->
	<!-- I(insert file):L(insert-sound)(sndinsertfile) -->
	<!-- I(mix file):L(mix)(sndmix) -->
	<!-- I(move mixed file):L(mix-position)(sndmixposition) -->
	<!-- I(move to mark):L(forward-mark)(sndforwardmark) -->
	<!-- I(move to mix):L(forward-mix)(sndforwardmix) -->
	<!-- I(play selection):L(play-selection)(sndplayselection) -->
	<!-- I(play selection):O(play-region)(sndplayregion) -->
	<!-- I(update file):L(update)(sndupdate) -->
	<!-- I(view envs):L(enved-dialog)(sndenveddialog) -->
	<!-- I(play channel):L(play-channel)(playchannel) -->
	<!-- I(play channel):O(play)(sndplay) -->
	<!-- I(mix selection):O(mix-region)(sndmixregion) -->
	<!-- I(mix selection):L(mix-selection)(sndmixselection) -->
	<!-- I(interrupt Snd):L(stop-playing)(sndstop) -->
	<!-- I(interrupt Snd):O(c-g!)(sndoops) -->
	<!-- I(move window back):L(left-sample)(sndleftsample) -->
	<!-- I(move window ahead):L(right-sample)(sndrightsample) -->
	<!-- I(change tempo):L(expand)(sndexpand) -->
	<!-- I(wavelets):L(wavelet-type)(wavelettype) -->
	<!-- I(save macros):L(save-macros)(sndsavemacros) -->
        <!-- I(save selection):L(save-region)(sndsaveregion) --><!-- I(save selection):O(save-selection)(sndsaveselection) -->
	<!-- I(examine regions):L(region-dialog)(sndregiondialog) -->
	<!-- I(zoom window):L(x-bounds)(sndxbounds) -->
	<!-- I(save options):L(save-options)(sndsaveoptions) -->
	<!-- I(describe audio):A(describeaudiostate) --><!-- I(describe audio):L(mus-audio-describe)(describeaudiostate) -->
	<!-- I(abort command):L(c-g?)(sndabort) -->
	<!-- I(count matches):L(count-matches)(lcountmatches) --><!-- I(count matches):A(lcountmatches) -->
	<!-- I(convolution):L(vct-convolve!)(vctconvolve) --><!-- I(convolution):A(vctconvolve) --><!-- I(convolution):O(convolve-with)(sndconvolvewith) -->
	<!-- I(auto save):O(autosave.scm) -->
        <!-- I(reverberate file):L(convolve-with)(sndconvolvewith) -->
        <!-- I(record sound):L(recorder-dialog)(sndrecorderdialog) -->
        <!-- I(describe file):L(info)(sndinfo) -->
        <!-- I(change pitch):L(src-sound)(sndsrc) -->
	<!-- I(change colors):L(make-color)(aboutcolors) --><!-- I(change colors):A(aboutcolors) --><!-- I(change colors):O(resources)(sndresources) -->
	<!-- I(create new file):O(default-output-srate)(defaultoutputsrate) -->
	<!-- I(autocorrelation):L(autocorrelate)(sndautocorrelate) -->
	<!-- I(axis bounds):O(axis-info)(axisinfo) -->
	<!-- I(horizontal panes):L(graphs-horizontal)(graphshorizontal) -->
	<!-- I(extract channel):L(save-sound-as)(sndsaveas) -->
	<!-- I(save channel):L(save-sound-as)(sndsaveas) -->
	<!-- I(swap channels):L(swap-channels)(swapchannels) -->
	<!-- I(overlay sounds):L(graph-data)(graphdata) -->
	<!-- I(overlay sounds):A(graphdata) -->
	<!-- I(edit env):O(enved-hook)(envedhook) -->
	<!-- I(close file):O(close-hook)(closehook) -->
	<!-- I(change samples):O(edit-hook)(edithook) -->
	<!-- I(file lists):O(mouse-enter-label-hook)(mouseenterlabelhook) -->
	<!-- I(swap channels):A(swapchannels) -->
	<!-- I(extend file):L(pad-channel)(padchannel) -->
	<!-- I(extract channel):O(channel-&gt;vct)(channel2vct) -->
	<!-- I(fft normalization):L(transform-normalization)(normalizefft) -->
	<!-- I(fft normalization):A(normalizefft) -->
	<!-- I(file formats):L(data-format)(snddataformat) -->

<br><br>

<center>
<table border=1><tr><td>
<table bgcolor="aliceblue" border=0 cellspacing=8><tr><td><small>related documentation:</small></td><td><small><a href="snd.html">snd.html</a></small></td><td><small><a href="grfsnd.html">grfsnd.html</a></small></td><td><small><a href="clm.html">clm.html</a></small></td><td><small><a href="sndlib.html">sndlib.html</a></small></td><td><small><a href="sndscm.html">sndscm.html</a></small></td><td><small><a href="libxm.html">libxm.html</a></small></td><td><small><a href="index.html">index.html</a></small></td></tr></table>
</td></tr></table>
</center>
</body></html>
