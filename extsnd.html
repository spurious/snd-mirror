<html>
<head>
<title>Snd Customization and Extension</title>
<style type="text/css">
<!-- 
	EM.red {color:red; font-style: normal}
        EM.error {color:chocolate; font-style: normal}
        EM.narg {color:chocolate; font-style: normal}
        EM.targ {color:darkgreen; font-style: normal}
        EM.typing {color:maroon; font-style: normal}
        EM.listener {color:darkblue; font-style: normal}
	EM.def {font-weight: bold; font-style: normal}
	H1 {text-align: center}
	UL {list-style-type: none}
	SPAN.box {background: beige; width: 100%; font-style: normal; text-align: center; border-width: thin; border-style: ridge}
	SPAN.bbox {background: lightsteelblue; width: 100%; font-style: normal; border-width: thin; border-style: ridge}
	SPAN.cbox {background: lightgreen; width: 100%; font-style: normal; border-width: thin; border-style: ridge}
	SPAN.htmlbox {background: tan; font-style: normal; font-size: small; border-width: thin; border-style: ridge}
	SPAN.defbox {border-width: thin; border-color: lightsteelblue}
-->
</style>
</head>
<!-- TODO: change remaining <i> and <b> into <em class=mumble> -->
<!-- TODO: more of the js extended discussions -->


<!-- -------------------------------------------------------------------------------- -->
<!-- an experiment: click button to post an example -- I'd like the buttons on the right to take less space somehow -->
<!--    also, need some automatic way to update the location references etc -->
<!-- func args: title example-code definition-loc related-stuff comments... -->
<SCRIPT>
var win = null;
function example()
{
  if ((win == null) || (win.closed))
    {
      win = window.open("","example","width=500,height=300,resizable");
      win.document.open();
     }
  win.document.write('<body bgcolor=white><p><b>', arguments[0], '</b></p>');
  if (arguments.length > 1)
    {
      win.document.write('<pre>', arguments[1], '</pre>');
      if (arguments.length > 2)
        {
          win.document.write('<p>defined: ', arguments[2], '</p>');
          if (arguments.length > 3)
            {
              win.document.write('<p>see also: ', arguments[3], '</p>');
              if (arguments.length > 4)
                {
                  win.document.write('<hr>');
                  for (var i = 4; i < arguments.length; i++)
                    win.document.write('<p>', arguments[i], '</p>');
		}
            }
	}
    }
  win.document.write('</body>');
  win.document.close();
  return true;
}
</SCRIPT>
<!-- -------------------------------------------------------------------------------- -->

<body bgcolor=white>

<!-- I'm using A NAME (i.e caps) where the entity should be ignored by the indexer (index.cl) -->

<A NAME="extsndcontents"></a>
<span class=box><h1>Snd Customization and Extension</h1></span>
<br>
<center>
<span class=htmlbox>related documentation</span><span class=htmlbox><a href="snd.html">snd.html</a><spacer type=horizontal size=25><a href="grfsnd.html">grfsnd.html</a><spacer type=horizontal size=25><a href="clm.html">clm.html</a><spacer type=horizontal size=25><a href="sndlib.html">sndlib.html</a><spacer type=horizontal size=25><a href="sndscm.html">sndscm.html</a><spacer type=horizontal size=25><a href="index.html">index.html</a></span>
</center>

<ul>
<li><a href="#lisplistener">Introduction</a>
<li><a href="#etc">Snd Programming</a>
  <ul>
  <li><a href="#appearance">Customizing Snd's appearance</a>
    <ul>
    <li><a href="#colors">Colors</a>
    <li><a href="#fonts">Fonts</a>
    <li><a href="#sndgraphics">Graphics</a>
    <li><a href="#sndwidgets">Widgets</a>
    </ul>
  <li><a href="#behavior">Customizing Snd's behavior</a>
    <ul>
    <li><a href="#sndglobalvars">Global variables</a>
    <li><a href="#sndhooks">Hooks</a>
    </ul>
  <li><a href="#sndobjects">Snd's objects</a>
    <ul>
    <li><a href="#Vcts">Vcts</a>
    <li><a href="#samplereaders">Sample-readers</a>
    <li><a href="#sndsounddata">Sound-data and Sndlib</a>
    <li><a href="#sndmarks">Marks</a>
    <li><a href="#sndmixes">Mixes</a>
    <li><a href="#sndregions">Regions</a>
    <li><a href="#sndsounds">Sounds and channels</a>
      <ul><li><a href="#customcontrols">the control panel</a></li></ul>
    <li><a href="#editlists">Edit Lists</a>
    <li><a href="#scanning">Scanning Data</a>
    <li><a href="#sndtransforms">Transforms</a>
    <li><a href="#snddialogs">Dialogs and Menus</a>
    <li><a href="#snderrors">Errors</a>
    <li><a href="#sndconstants">Constants</a>
    <li><a href="#sndmisc">Miscellaneous functions</a>
    </ul>
  <li><a href="#sndexamples">Examples</a>
  <li><a href="grfsnd.html#grfsndcontents">Customization Part 2</a>
  </ul>
<li><a href="index.html#extsndindex">Index</a>
</ul>
<br>
<span class=box><h2>Introduction</h2></span>
<A NAME="lisplistener"></a>

<p>Snd is a highly customizable, extensible program.
The syntax used is Scheme (a form of lisp) as implemented by the Gnu Guile library.
I've tried to bring out to lisp nearly every portion
of Snd, both the signal-processing functions, and
much of the user interface.  You can, for example,
add your own menu choices, editing operations, 
or graphing alternatives.
Nearly everything in Snd can be set in an initialization
file, loaded at any time from a file of scheme code or a <a href="snd.html#savedstate">saved state</a> file,
specified via inter-process communication or from stdin
from any other program (CLM and Emacs in particular),
imbedded in a keyboard macro, or accessed in the
lisp listener.  The easiest way to get acquainted
with this aspect of Snd is to open the listener
(via the View:Open listener menu option), and type
experiments in its window.  Its prompt is "&gt;". So,
say we've opened the listener, and (my typing is 
in <em class=typing>this font</em> and Snd's responses
are in <em class=listener>this font</em>):
</p>
<pre>
&gt;<em class=typing>(+ 1 2)</em>
<em class=listener>3</em>
</pre>
<p><small>If the listener is active, and some sound
is selected, any characters typed while in the sound
graph which it can't handle are passed to the
listener; to exit the listener without using the
mouse, type C-g.  This is also the way to get back to
the listener prompt if it appears to be hung; normally
in this situation,
it's actually waiting for a close paren.
</small></p>
<br>
<span class=box><h2><A NAME="etc">Snd Programming</a></h2></span>

<p>Snd is organized as a list of sounds, each with a list of channels,
each channel containing lists of edits, marks, mixes, etc.
There are other objects such as colors, vcts (an optimization
of vectors), and regions; the currently active region is
called the selection.  I originally presented all the
various functions and variables in an enormous alphabetical
list, but that finally became unmanageable.  In the following
sections, each of the basic entities is treated in a separate
section with cross-references where needed.  The <a href="index.html#extsndindex">index</a>
provides alphabetical entry.</p>

<p>There are many examples in <a href="sndscm.html#exampdoc">examp.scm</a> and <a href="sndscm.html#sndtestdoc">snd-test.scm</a>.  In addition,
various examples of and extensions to Snd can be found in:
</p>

<table border=8 bordercolor="lightsteelblue">
<tr><td width=140><a href="sndscm.html#belldoc">bell.scm</a></td><td>the fm-bell from CLM</td></tr>
<tr><td><a href="sndscm.html#birddoc">bird.scm</a></td><td>various North-American birds (from bird.clm)</td></tr>
<tr><td><a href="sndscm.html#effectsdoc">effects.scm</a></td><td>an Effects menu based on examp.scm</td></tr>
<tr><td><a href="sndscm.html#envdoc">env.scm</a></td><td>various envelope functions from CLM</td></tr>
<tr><td><a href="sndscm.html#enveddoc">enved.scm</a></td><td>envelope editor in lisp graph section</td></tr>
<tr><td><a href="sndscm.html#fmvdoc">fmv.scm</a></td><td>the fm-violin tied to real-time gtk graphics</td></tr>
<tr><td><a href="sndscm.html#glfftdoc">glfft.scm</a></td><td>OpenGL for spectra (needs work)</td></tr>
<tr><td><a href="sndscm.html#goopsnddoc">goopsnd.scm</a></td><td>first look at Goops (Guile Object System) for Snd</td></tr>
<tr><td><a href="sndscm.html#indexdoc">index.scm</a></td><td>snd-help locators</td></tr>
<tr><td><a href="sndscm.html#loopdoc">loop.scm</a></td><td>some Common Lisp syntax in Scheme</td></tr>
<tr><td><a href="sndscm.html#marksdoc">marks.scm</a></td><td>functions related to marks</td></tr>
<tr><td><a href="sndscm.html#mixdoc">mix.scm</a></td><td>functions related to mixes and tracks</td></tr>
<tr><td><a href="sndscm.html#moogdoc">moog.scm</a></td><td>Moog filter (from CLM)</td></tr>
<tr><td><a href="sndscm.html#musglyphs">musglyphs.scm</a></td><td>Music notation symbols (from CMN)</td></tr>
<tr><td><a href="sndscm.html#nbdoc">nb.scm</a></td><td>Popup File info etc</td></tr>
<tr><td><a href="sndscm.html#pqwvoxdoc">pqwvox.scm</a></td><td>phase-quadrature waveshaping (from CLM)</td></tr>
<tr><td><a href="sndscm.html#prc95doc">prc95.scm</a></td><td>Perry Cook's physical model examples (from CLM)</td></tr>
<tr><td><a href="sndscm.html#pvocdoc">pvoc.scm</a></td><td>phase-vocoder examples</td></tr>
<tr><td><a href="sndscm.html#rgbdoc">rgb.scm</a></td><td>color definitions</td></tr>
<tr><td><a href="sndscm.html#rtiodoc">rtio.scm</a></td><td>real-time stuff</td></tr>
<tr><td><a href="sndscm.html#rubberdoc">rubber.scm</a></td><td>rubber-sound</td></tr>
<tr><td><a href="sndscm.html#sndgtkdoc">snd-gtk.scm</a></td><td>various Guile-Gtk examples</td></tr>
<tr><td><a href="sndscm.html#vdoc">v.scm</a></td><td>fm-violin (from CLM)</td></tr>
<tr><td><a href="sndscm.html#wsdoc">ws.scm</a></td><td>with-sound implementation</td></tr>
<tr><td><a href="sndscm.html#zipdoc">zip.scm</a></td><td>the zipper (a cross-fader, sort of) (from CLM)</td></tr>
</table>

<br>
<span class=bbox><h3><A NAME="appearance">Customizing Snd's appearance</a></h3></span>

<p>Snd's overall appearance is controlled first by the startup <a href="grfsnd.html#sndswitches">switches</a> that
choose the outermost widget; normally this is a paned window with a sound
in each pane; -separate puts each
sound in a separate window, and -notebook
puts each sound on a separate page of a notebook widget.  Similarly -horizontal
and -vertical determine which way the outer panes are layed out. 
As panes (sounds) come and go, Snd's overall size may change (this is
partly determined by the window manager, but is to some extent also
up to Snd); many people find this distracting -- they would rather the
overall window size try to stay the same.  The Snd variable associated
with this is "auto-resize"; it can be accessed as follows (we're typing
to the listener here, as described above):</p>

<pre>
&gt;<em class=typing>(auto-resize)</em>
<em class=listener>#t</em>
&gt;<em class=typing>(set! (auto-resize) #f)</em>
<em class=listener>#f</em>
</pre>

<p>As this illustrates, 
variables in Snd are accessed as though each were a function, and set using set!.  auto-resize's current
value is accessed above via <code>(auto-resize)</code>, and set to a
new value via <code>(set! (auto-resize) #f)</code>. #t is Scheme for "true"
(often 1 in C, t in Lisp), #f is "false" (0 in C, nil in Lisp).
A statement like <code>(set! (auto-resize) #f)</code> can be placed in your ~/.snd initialization file
to make it the default setting for your version of Snd, or placed
in a separate file of Scheme code and loaded at any time via the load
function.  </p>

<p>In the sections below, the variable or function name is followed by
either its default value or the function arguments, then some brief
description of what it does.  So,
</p>
<pre>
  <em class=def>basic-color</em>           ivory2          main Snd color.
</pre>
<p>means there's a thing called basic-color (and a way to set it via  "(set! (basic-color) ...)"),
that its default value is ivory2 (see <a href="sndscm.html#rgbdoc">rgb.scm</a> for a definition of this color), and that
it is the main Snd color.</p>
<br>
<span class=cbox><h4><A NAME="colors">Colors</a></h4></span>

<p>A color in Snd is an object with three fields representing the
rgb (red green blue) settings as numbers between 0.0 and 1.0.  A color
object is created via make-color:</p>
<pre>
&gt;<em class=typing>(define blue (make-color 0 0 1))</em>
</pre>
<p>This declares the Scheme variable "blue" and gives it the value
of the color whose rgb components include only blue in full force.
The X11 color names are defined in <a href="sndscm.html#rgbdoc">rgb.scm</a>. Now, in Snd, the basic
color is known as "basic-color" (another Scheme variable); we can
set it:</p>
<pre>
&gt;<em class=typing>(set! (basic-color) blue)</em>
</pre>

<p>The color variables
are:</p>

<table border=0 cellpadding=0 cellspacing=0>
<tr><td width=220><code><em class=def><a name="basiccolor">basic-color</a></em></code></td><td width=180><code>ivory2</code></td>
<td>main Snd color.</td></tr>
<tr><td><code><em class=def><a name="cursorcolor">cursor-color</a></em></code></td><td><code>red</code></td>
<td>cursor color.</td></tr>
<tr><td><code><em class=def><a name="datacolor">data-color</a></em></code></td><td><code>black</code></td>
<td>color of data in unselected graph.	</td></tr>
<tr><td><code><em class=def>enved-waveform-color</em></code></td><td><code>blue</code></td>
<td>color of waveform displayed in envelope editor.</td></tr>
<tr><td><code><em class=def><a name="filterwaveformcolor">filter-waveform-color</a></em></code></td><td><code>blue</code></td>
<td>color of control panel filter waveform.</td></tr>
<tr><td><code><em class=def><a name="graphcolor">graph-color</a></em></code></td><td><code>white</code></td>
<td>background color of unselected graph.</td></tr>
<tr><td><code><em class=def><a name="highlightcolor">highlight-color</a></em></code></td><td><code>ivory1</code></td>
<td>highlighting color.</td></tr>
<tr><td><code><em class=def>listener-color</em></code></td><td><code>aliceblue</code></td>
<td>background color of lisp listener.</td></tr>
<tr><td><code><em class=def>listener-text-color</em></code></td><td><code>black</code></td>
<td>text color in lisp listener.</td></tr>
<tr><td><code><em class=def><a name="markcolor">mark-color</a></em></code></td><td><code>red</code></td>
<td>color of mark indicator.</td></tr>
<tr><td><code><em class=def>mix-color</em></code></td><td><code>darkgray</code></td>
<td>color of mix waveforms.</td></tr>
<tr><td><code><em class=def>selected-mix-color</em></code></td><td><code>lightgreen</code></td>
<td>color of selected mix waveform.</td></tr>
<tr><td><code><em class=def><a name="positioncolor">position-color</a></em></code></td><td><code>ivory3</code></td>
<td>position slider color</td></tr>
<tr><td><code><em class=def><a name="pushedbuttoncolor">pushed-button-color</a></em></code></td><td><code>lightsteelblue1</code></td>
<td>color of pushed button.</td></tr>
<tr><td><code><em class=def>sash-color</em></code></td><td><code>lightgreen</code></td>
<td>color of paned window sashes.</td></tr>
<tr><td><code><em class=def><a name="selecteddatacolor">selected-data-color</a></em></code></td>
<td><code>black</code></td><td>           color of data in currently selected graph.</td></tr>
<tr><td><code><em class=def><a name="selectedgraphcolor">selected-graph-color</a></em></code></td><td><code>white</code></td>
<td>background color of currently selected graph.</td></tr>
<tr><td><code><em class=def><a name="selectioncolor">selection-color</a></em></code></td><td><code>lightsteelblue1</code></td>
<td>color of selected portion of graph.</td></tr>
<tr><td><code><em class=def><a name="textfocuscolor">text-focus-color</a></em></code></td><td><code>white</code></td>
<td>color of text field when it has focus.</td></tr>
<tr><td><code><em class=def><a name="zoomcolor">zoom-color</a></em></code></td><td><code>ivory4</code></td>
<td>zoom slider color.</td></tr>
</table>

<p>In addition, the various transforms can be displayed using colormaps.  The following
variables and functions control this:</p>

<table border=0 cellspacing=4>

<tr><td width=180><code><em class=def><a name="colorcutoff">color-cutoff</a></em></code></td><td width=100>0.003</td>
<td>In spectra, sets the lowest data value that will be colored.</td></tr>
<tr><td><code><em class=def><a name="sndcolordialog">color-dialog</a></em></code></td><td>()</td>
<td>Create the Color dialog (to choose a colormap etc), if necessary, activate it and return the dialog widget.</td></tr>
<tr><td><code><em class=def><a name="colorinverted">color-inverted</a></em></code></td><td>#t</td>
<td>The 'invert' button in the <a href="snd.html#colorbrowser">color</a> dialog, negated (hunh?!).</td></tr>
<tr><td><code><em class=def><a name="colorscale">color-scale</a></em></code></td><td>0.5</td>
<td>The darkness setting in the <a href="snd.html#colorbrowser">color</a> dialog, divided by 100.</td></tr>
<tr><td valign=top><code><em class=def><a name="colormap">colormap</a></em></code></td><td valign=top>0</td>
<td>Colormap choice for various displays (see the Color Editor).
<br>
This should be an integer between -1 and 15.  The maps (from 0 to 15) are: 
gray, hsv, hot, cool, bone, copper, pink, jet, prism, autumn, winter, 
spring, summer, colorcube, flag, and lines.  -1 means black and white.
</td></tr>
<tr><td colspan=2 valign=top><code><em class=def><a name="loadcolormap">load-colormap</a></em> (colors)</code></td>
<td>use colors in <i>colors</i> (a vector) as current colormap.
This is still kludgey, but the following shows how to use it:
</td></tr>
<tr><td colspan=3 align=center><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(load "rgb.scm")
(define hi (make-vector 512)) ;use 64 if not using big colormaps
  (do ((i 0 (+ i 4))) 
      ((&gt;= i 512)) 
    (vector-set! hi i red) (vector-set! hi (+ i 1) blue) 
    (vector-set! hi (+ i 2) green) (vector-set! hi (+ i 3) black))

(<em class=red>load-colormap</em> hi)
</pre></td></tr></table></td></tr>
</table>

<p>The color object handlers are:</p>

<form>
<table border=0 cellspacing=0 cellpadding=0 width="100%">
<tr>
<td width="20%"><code><em class=def><a name="colorp">color?</a></em> (obj)</code></td>
<td>#t if <i>obj</i> is a color object (see <a href="#makecolor">make-color</a>).</td>
<td align right><input type="button" value="->" onClick="example(
  'color?', 
  '(define blue (make-color 0 0 1))\n(color? blue)\n  => #t',
  '<code>snd-x|gscm.c g_color_p</code>',
  'rgb.scm'
);">
</input></td>
</tr>

<tr>
<td><code><em class=def><a name="color3list">color-&gt;list</a></em> (obj)</code></td>
<td>return list (r g b) of color components.</td>
<td><input type="button" value="->" onClick="example(
  'color->list', 
  '(define red (make-color 1 0 0))\n(color->list red)\n => \'(1.0 0.0 0.0)',
  '<code>snd-x|gscm.c g_color2list</code>'
);">
</input></td>
</tr>

<tr>
<td valign=top><code><em class=def><a name="makecolor">make-color</a></em> (r g b)</code></td>
<td>return a color object using the red/green/blue values.  If the object is called
as a function, it returns the list of rgb values.
If, for example, blue is a defined color, <code>(blue)</code> is the same as <code>(color->list blue)</code>.
Two colors are equal (i.e. equal? returns #t) if their rgb values are the same.
</td>
<td valign=top><input type="button" value="->" onClick="example(
  'make-color', 
  '(define red (make-color 1 0 0))\
(define beige (make-color 0.96 0.96 0.86))\
(red)\
  => (1.0 0.0 0.0)\
(eq? red (make-color 1 0 0))\
  => #f\
(equal? red (make-color 1 0 0))\
  => #t',
  '<code>snd-x|gscm.c g_make_snd_color</code>',
  'rbg.scm',
  'The arguments are floats between 0.0 and 1.0 (as in Postscript).'
);">
</input></td>
</tr>
</table>
</form>

<p><small>(British spelling enthusiasts can use "colour" throughout Snd by building it with the CFLAG
 -DSTR_OR=\"our\").</small>
</p>

<br>
<span class=cbox><h4><A NAME="fonts">Fonts</a></h4></span>

<p>Fonts in Snd are strings containing a description of the
desired font.  These can be the abbreviated forms such as
"8x14" or a full X font name such as "-misc-fixed-bold-r-normal--*-140-*-*-c-*-iso8859-1".
The font variables are:
</p>
<table cellpadding=0 cellspacing=0>
<tr><td width=200><code><em class=def><a name="axislabelfont">axis-label-font</a></em></code></td><td>used in axis labels</td></tr>
<tr><td><code><em class=def><a name="axisnumbersfont">axis-numbers-font</a></em></code></td><td>used in axis tick numbers</td></tr>
<tr><td><code><em class=def><a name="boldbuttonfont">bold-button-font</a></em></code></td><td>used by various buttons and labels</td></tr>
<tr><td><code><em class=def><a name="buttonfont">button-font</a></em></code></td><td>used by various buttons and labels</td></tr>
<tr><td><code><em class=def>help-text-font</em></code></td><td>help dialog text font</td></tr>
<tr><td><code><em class=def>listener-font</em></code></td><td>listener font</td></tr>
<tr><td><code><em class=def><a name="tinyfont">tiny-font</a></em></code></td><td>smallest font used</td></tr>
</table>

<p>See also <a href="#loadfont">load-font</a> and <a href="#currentfont">current-font</a> below.
</p>

<br>
<span class=cbox><h4><A NAME="sndwidgets">Widgets</a></h4></span>

<p>This section is new, and in flux, but here's what's currently implemented:
</p>

<table cellspacing=0>
<tr><td><code><em class=def>widget-position</em> (widget)</code></td>
<td>return a list giving the widget x and y positions</td></tr>
<tr><td valign=top><code><em class=def>widget-size</em> (widget)</code></td>
<td>return a list giving the widget width and height.  The corresponding set! forms also take a list:<br>
<code>(set! (widget-position (cadr (main-widgets))) (list 300 100))</code></td></tr>
<tr><td><code><em class=def><a name="recolorwidget">recolor-widget</a></em> (widget color)</code></td></tr>
<tr><td><code><em class=def><a name="showwidget">show-widget</a></em> (widget)</code></td></tr>
<tr><td><code><em class=def><a name="hidewidget">hide-widget</a></em> (widget)</code></td></tr>
<tr><td colspan=2><br></td></tr>
<tr><td><code><em class=def><a name="mainwidgets">main-widgets</a></em> ()</code></td><td></td></tr>
<tr><td><code><em class=def><a name="menuwidgets">menu-widgets</a></em> ()</code></td><td></td></tr>
<tr><td><code><em class=def><a name="soundwidgets">sound-widgets</a></em> (snd)</code></td><td></td></tr>
<tr><td><code><em class=def><a name="channelwidgets">channel-widgets</a></em> (snd chn)</code></td><td></td></tr>
<tr><td><code><em class=def><a name="dialogwidgets">dialog-widgets</a></em> ()</code></td><td></td></tr>
</table>

<p>
The four "-widgets" procedure return lists of possibly useful widgets:
</p>
<pre>
  main-widgets:    '(top-level-application top-level-shell main-pane main-sound-pane)
  menu-widgets:    '(top-level-menu-bar file-menu edit-menu view-menu options-menu 
                     help-menu)
  sound-widgets:   '(main-pane name-label control-panel)
  channel-widgets: '(graph)
  dialog-widgets:  '(color_dialog orientation_dialog enved_dialog error_dialog 
                     yes_or_no_dialog transform_dialog file_open_dialog 
                     file_save_as_dialog view_files_dialog raw_data_dialog 
                     new_file_dialog file_mix_dialog edit_header_dialog 
                     find_dialog help_dialog completion_dialog mix_panel_dialog
                     print_dialog recorder_dialog region_dialog stats_dialog 
                     listener-text)
</pre>
<p>I've only included the ones I needed immediately, but all Snd widgets are potentially (and easily)
accessible; if you need access to one that
isn't included, let me know.  <i>dialog-widgets</i> entries will be #f for any dialogs that have not
yet been created.
</p>
<pre>
  (recolor-widget (cadr (sound-widgets)) (make-color 1 0 0))
</pre>
<p>makes the sound name label red.
</p>

<br>
<span class=cbox><h4><A NAME="sndgraphics">Graphics</a></h4></span>

<p>It is possible to draw directly on any of the channel graphs.  Simple examples include the
<a href="extsnd.html#showoriginal">show-original</a> after-graph-hook function, and the
<a href="extsnd.html#xcursor">x-cursor</a> function that draws an "x" shaped cursor.
The lowest level procedures are:
</p>

<!-- -------------------------------- GRAPHICS TABLE -------------------------------- -->
<!-- --><table border=0 cellspacing=4>
<!-- -->
<!-- draw-dot -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="drawdot">draw-dot</a></em> (x0 y0 dot-size snd chn context)</code></span></td></tr>
<!-- -->
<!-- --><tr><td width=50></td><td>
<!-- -->draws a dot at (x0 y0) of <i>dot-size</i> pixels diameter in the given graph</td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- draw-dots -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="drawdots">draw-dots</a></em> (positions dot-size snd chn context)</code></span></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->draws dots of size <i>dot-size</i> from the (x y) pairs in the vector <i>positions</i> in the given context.</td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- draw-line -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="drawline">draw-line</a></em> (x0 y0 x1 y1 snd chn context)</code></span></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->draws a line from (x0 y0) to (x1 y1) in the given context.</td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- draw-lines -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="drawlines">draw-lines</a></em> (lines size snd chn context)</code></span></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->draws lines following the (x y) pairs in the vector <i>lines</i> in the given context.
<!-- --><i>make-bezier-1</i> in musglyphs.scm can be used to draw Bezier curves.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- draw-string -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="drawstring">draw-string</a></em> (text x0 y0 snd chn context)</code></span></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->draws a string (<i>text</i>) in the current font and foreground color starting at (x0 y0) in the given context.
<!-- -->The next procedure draws a box over sample 1000 (if it is visible)
<!-- -->with the text "hiho":
<!-- --></td></tr>
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(define show-hiho
<!-- -->  ;; show "hiho" in a box over sample 1000
<!-- -->  (lambda (snd chn)
<!-- -->    (define (draw-rectangle x0 y0 width height)
<!-- -->      (<em class=red>draw-line</em> x0 y0 (+ x0 width) y0)
<!-- -->      (<em class=red>draw-line</em> (+ x0 width) y0 (+ x0 width) (+ y0 height))
<!-- -->      (<em class=red>draw-line</em> (+ x0 width) (+ y0 height) x0 (+ y0 height))
<!-- -->      (<em class=red>draw-line</em> x0 (+ y0 height) x0 y0))
<!-- -->    (let ((ls (left-sample snd chn))
<!-- -->          (rs (right-sample snd chn)))
<!-- -->      (if (and (&lt; ls 1000)
<!-- -->               (&gt; rs 1000))
<!-- -->	  (let ((pos (<em class=red>x-&gt;position</em> (/ 1000.0 (srate)))))
<!-- -->            (draw-rectangle pos 10 50 20)
<!-- -->            (<em class=red>draw-string</em> "hiho" (+ pos 5) 24))))))
<!-- -->
<!-- -->(add-hook! after-graph-hook show-hiho)
<!-- --></pre></td></tr></table>
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- fill-rectangle -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="fillrectangle">fill-rectangle</a></em> (x0 y0 width height snd chn context)</code></span></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->draws a filled rectangle (in the current foreground color) from (x0 y0) of size (width height).</td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- erase-rectangle -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="eraserectangle">erase-rectangle</a></em> (x0 y0 width height snd chn context)</code></span></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->erases the specified rectangle (not sure this is actually useful -- I had the code lying around handy).</td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- fill-polygon -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="fillpolygon">fill-polygon</a></em> (points snd chn context)</code></span></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->draws a filled polygon whose vertices are in <i>points</i>.</td></tr>
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(define (-> x0 y0 size snd chn)
<!-- -->  "draw an arrow pointing (from the left) at the point (x0 y0)"
<!-- -->  (let ((points (make-vector 8)))
<!-- -->    (define (point i x y)
<!-- -->      (vector-set! points (* i 2) x)
<!-- -->      (vector-set! points (+ (* i 2) 1) y))
<!-- -->    (define (arrow-head x y)
<!-- -->      (point 0 x y)
<!-- -->      (point 1 (- x (* 2 size)) (- y size))
<!-- -->      (point 2 (- x (* 2 size)) (+ y size))
<!-- -->      (point 3 x y)
<!-- -->      (<em class=red>fill-polygon</em> points snd chn))
<!-- -->    (arrow-head x0 y0)
<!-- -->    (fill-rectangle (- x0 (* 4 size)) 
<!-- -->		    (inexact->exact (- y0 (* .4 size)))
<!-- -->		    (* 2 size)
<!-- -->		    (inexact->exact (* .8 size))
<!-- -->                    snd chn)))	
<!-- --></pre></td></tr></table></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- --><tr><td></td><td>
<!-- -->musglyphs.scm has some elaborate examples that use fill-polygon to draw various music symbols.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- load-font -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="loadfont">load-font</a></em> (font-name)</code></span></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->loads the font <i>font-name</i> (an X-style font spec), and returns a handle for it (for <i>current-font</i> below).
<!-- --><pre>
<!-- -->  (define new-font (<em class=red>load-font</em> "-adobe-helvetica-bold-r-*-*-14-*-*-*-*-*-*-*"))
<!-- --></pre>
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- current-font -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="currentfont">current-font</a></em> (snd chn context)</code></span></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->returns the current font (also settable).</td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- foreground-color -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="foregroundcolor">foreground-color</a></em> (snd chn context)</code></span></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->returns the current foreground color (also settable).
<!-- -->The following gives us a green cursor:
<!-- --><pre>
<!-- -->  (set! (<em class=red>foreground-color</em> 0 0 cursor-context) (make-color 1 0 1))
<!-- --></pre>
<!-- -->We can goof around with colors and fonts:
<!-- --></td></tr>
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(define new-font (load-font "-adobe-helvetica-bold-r-*-*-14-*-*-*-*-*-*-*"))
<!-- -->
<!-- -->(define show-hiho
<!-- -->  ;; show a red "hiho" in the helvetica bold font on a gray background
<!-- -->  (lambda (snd chn)
<!-- -->    (let ((ls (left-sample snd chn))
<!-- -->          (rs (right-sample snd chn)))
<!-- -->      (if (and (&lt; ls 1000)
<!-- -->               (&gt; rs 1000))
<!-- -->	  (let ((pos (x-&gt;position (/ 1000.0 (srate))))
<!-- -->		(old-color (foreground-color)))
<!-- -->	    (set! (<em class=red>foreground-color</em>) (make-color .75 .75 .75))
<!-- -->            (fill-rectangle pos 10 50 20)
<!-- -->	    (set! (<em class=red>foreground-color</em>) (make-color 1 0 0))
<!-- -->	    (if new-font (set! (<em class=red>current-font</em>) new-font))
<!-- -->            (draw-string "hiho" (+ pos 5) 24)
<!-- -->	    (set! (<em class=red>foreground-color</em>) old-color))))))
<!-- --></pre></td></tr></table>
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- copy-context -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="copycontext">copy-context</a></em></code></span></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->the graphics mode to use to draw over whatever is currently in a graph.</td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- cursor-context -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="cursorcontext">cursor-context</a></em></code></span></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->the graphics mode for XOR drawing (cursors, normally).</td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- axis-info -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="axisinfo">axis-info</a></em> (snd chn grf)</code></span></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->returns a list describing the specified axis:
<!-- --><code>'(left-sample right-sample x0 y0 x1 y1 x-min y-min x-max y-max 
<!-- -->x0-position y0-position x1-position y1-position)</code>.  This might be
<!-- -->useful if you're drawing arbitrary figures in a graph.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- --></table>

<p>The "contexts" refer to graphics contexts used throughout Snd; the <i>copy-context</i>
copies into the current graph, whereas the <i>cursor-context</i> uses XOR.
The error returned for an unimplemented 'context' is 'no-such-graphics-context.

<p>To get the currently displayed data (i.e. the actual waveform displayed
in the graph, which can be based on an overall envelope rather than the
actual samples), use:
</p>
<pre>
  <em class=def><a name="makegraphdata">make-graph-data</a></em> (snd chn edit-position low-sample high-sample)
</pre>
<p>This returns either a vct (if the graph has one trace), or a
list of two vcts (the two sides of the envelope graph).
<i>edit-position</i> defaults to the current edit history position,
<i>low-sample</i> defaults to the current window left sample, and
<i>high-sample</i> defaults to the current rightmost sample.
The result can be use in the "lisp graph":
</p>

<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(define display-db
  (lambda (snd chn)
    "(display-db snd chn) is a lisp-graph-hook function to display the time domain data in dB"
    (let* ((datal (<em class=red>make-graph-data</em> snd chn))
	   (data (if (vct? datal) datal (cadr datal)))
           (sr (srate snd)))
      (define (dB val)
	(if (&lt; val .001)
	    -60.0
	    (* 20.0 (log10 val))))
      (vct-do! data (lambda (i)
		      (vct-set! data i (+ 60.0 (dB (abs (vct-ref data i)))))))
      (graph data "dB" 
	     (/ (left-sample snd chn) sr) (/ (right-sample snd chn) sr)  
	     0.0 60.0
	     snd chn))))

(add-hook! lisp-graph-hook display-db)
</pre></td></tr></table>

<p>Here we are taking whatever is displayed in the time domain, and
presenting the same thing in dB in the lisp graph.  <i>display-energy</i>
in examp.scm is another example.  But the real power of this function
comes from its use with <i>graph-data</i>.  
The latter takes its argument (either a vct or a list of two
vcts), and displays it in any channel's time domain graph using its current graph-style.
</p>
<pre>
  <em class=def><a name="graphdata">graph-data</a></em> data snd chn context low high graphics-style
</pre>
<p><i>graph-data</i> displays <i>data</i> in the time domain graph of <i>snd</i>'s channel
<i>chn</i> using the graphics context <i>context</i> (normally copy-context), placing the
data in the recipient's graph between points <i>low</i> and <i>high</i>
in the drawing mode (<i>graphics-style</i>).
With this function and <i>make-graph-data</i> we can overlay sounds,
overlay different versions of the same sound, place a portion of a
sound over another at an arbitrary point, and so on:
</p>

<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(define (overlay-sounds . args)
  "overlay-sounds overlays onto its first argument all subsequent arguments: (overlay-sounds 1 0 3)"
  (let ((base (car args)))
    (add-hook! 
      after-graph-hook
       (lambda (snd chn)
	 (if (= snd base)
	     (for-each 
	      (lambda (snd)
		;; perhaps this should also set syncing
		(if (and (&gt; (channels snd) chn)
			 (&gt; (channels base) chn))
		    (<em class=red>graph-data</em>
		     (<em class=red>make-graph-data</em> snd chn) 
		     base chn <em class=red>copy-context</em> #f #f graph-dots)))
	      (cdr args)))))))

(define (display-samps-in-red snd chn)
  "display samples 1000 to 2000 in red whenever they're in the current view"
  (let ((left (left-sample snd chn))
	(right (right-sample snd chn))
	(old-color (foreground-color snd chn))
	(red (make-color 1 0 0)))
    (if (and (&lt; left 2000)
	     (&gt; right 1000))
	(let* ((data (<em class=red>make-graph-data</em> snd chn)))
	  (if (vct? data)                      ;the simple, one-sided graph case
	      (let* ((samps (- (min right 2000)
			       (max left 1000)))
		     (offset (max 0 (- 1000 left)))
		     (new-data (vct-subseq data offset (+ offset samps))))
		(set! (foreground-color snd chn) red)
		(<em class=red>graph-data</em> new-data snd chn copy-context (max 1000 left) (min 2000 right))
		(set! (foreground-color snd chn) old-color))
	      (let* ((low-data (car data))     ;the two-sided envelope graph case
		     (high-data (cadr data))
                     ;; we need to place the red portion correctly in the current graph
                     ;; so the following is getting the "bin" numbers associated with 
                     ;; samples 1000 and 2000
		     (size (vct-length low-data))
		     (samps (- right left))
		     (left-offset (max 0 (- 1000 left)))
		     (left-bin (inexact-&gt;exact (/ (* size left-offset) samps)))
		     (right-offset (- (min 2000 right) left))
		     (right-bin (inexact-&gt;exact (/ (* size right-offset) samps)))
		     (new-low-data (vct-subseq low-data left-bin right-bin))
		     (new-high-data (vct-subseq high-data left-bin right-bin)))
		(set! (foreground-color snd chn) red)
		(<em class=red>graph-data</em> (list new-low-data new-high-data) snd chn copy-context left-bin right-bin)
		(set! (foreground-color snd chn) old-color)))))))

;; (add-hook! after-graph-hook display-samps-in-red)
</pre>
<center><image src="redsamps.png" alt="red samples"></center>
<pre>
(define (<A NAME="displaypreviousedits">display-previous-edits</a> snd chn)
  "display all edits of the current sound, with older versions gradually fading away"
  (let* ((edits (edit-position snd chn))
	 (old-color (foreground-color snd chn))
	 (clist (color-&gt;list old-color))
	 (r (car clist))
	 (g (cadr clist))
	 (b (caddr clist))
	 (rinc (/ (- 1.0 r) (+ edits 1)))     ;oldest version is nearly white
	 (ginc (/ (- 1.0 g) (+ edits 1)))
	 (binc (/ (- 1.0 b) (+ edits 1))))
    (if (&gt; edits 0)
	(begin
	  (do ((pos 0 (1+ pos))
	       (re (- 1.0 rinc) (- re rinc))  ;subsequent versions approach the current color
	       (ge (- 1.0 ginc) (- ge ginc))
	       (be (- 1.0 binc) (- be binc)))
	      ((&gt; pos edits))
	    (let ((data (<em class=red>make-graph-data</em> snd chn pos)))
	      (set! (foreground-color snd chn) (make-color re ge be))
	      (<em class=red>graph-data</em> data snd chn)))
	  (set! (foreground-color snd chn) old-color)))))
</pre></td></tr></table>

<p>This only scratches the surface of these functions; I'll eventually 
collect more examples into draw.scm.
</p>
<!-- TODO: info procedures -->
<!-- TODO: rest of contexts etc -->

<br>
<span class=bbox><h3><A NAME="behavior">Customizing Snd's behavior</a></h3></span>

<p>Most of Snd's behavior can be customized.  For example,
when a sound is saved, some people want to be warned if
a pre-existing sound is about to be destroyed; others (Snd's
author included) grumble "just do it".  There are two ways
this kind of situation is handled in Snd; variables and hooks.
A hook is a list of "callbacks" invoked whenever the associated
event happens.  When Snd exits, for example, any functions found
on the exit-hook list are evaluated; if any of them returns #t,
Snd does not exit.</p>

<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(define unsaved-edits?
  (lambda (ind)
    (and (&lt; ind (max-sounds))
	 (or (and (sound? ind)
		  (&gt; (car (edits ind)) 0)
		  (report-in-minibuffer "there are unsaved edits")
		  #t)
	     (unsaved-edits? (+ ind 1))))))

(add-hook! exit-hook (lambda () (unsaved-edits? 0)))
</pre></td></tr></table>

<p>Now when Snd is told to exit, it checks exit-hook, runs
unsaved-edits?, and if the latter returns #t, if prints
a worried message in the minibuffer, and refuses to
exit.  Similar hooks customize actions such as closing
a sound (close-hook), clicking a mark (mark-click-hook),
pressing a key (key-press-hook), and so on.  Slightly
special are the hooks output-comment-hook and output-name-hook;
these refer to the default file name and comment displayed
when you save a sound via the "save" dialog.</p>

<br>
<span class=cbox><h4><A NAME="sndglobalvars">Global variables</a></h4></span>

<p>The main variables affecting Snd's overall behavior are:</p>

<!-- -------------------------------- GLOBAL VARIABLE TABLE -------------------------------- -->
<!-- -->
<!-- --><table border=0 cellspacing=4>
<!-- -->
<!-- ask-before-overwrite -->
<!-- --><tr><td><code><em class=def><a name="askbeforeoverwrite">ask-before-overwrite</a></em></code></td>
<!-- --><td width=50><code>#f</code></td>
<!-- --><td>(Save-as): ask before <a href="snd.html#overwrite">overwriting</a> an existing file</td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- auto-update -->
<!-- --><tr><td><code><em class=def><a name="autoupdate">auto-update</a></em></code></td>
<!-- --><td><code>#f</code></td>
<!-- --><td>should Snd <a href="snd.html#updatefile">update</a> a file automatically.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- audio-input-device -->
<!-- --><tr><td><code><em class=def><a name="audioinputdevice">audio-input-device</a></em></code></td>
<!-- --><td colspan=2><code>mus-audio-default</code></td></tr>
<!-- --><tr><td colspan=2></td><td>Audio input device (for the recorder)
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- audio-output-device -->
<!-- --><tr><td><code><em class=def><a name="audiooutputdevice">audio-output-device</a></em></code></td>
<!-- --><td colspan=2><code>mus_audio-default</code></td></tr>
<!-- --><tr><td colspan=2></td><td>Audio output device (for the play button)
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- audio-state-file -->
<!-- --><tr><td><code><em class=def><a name="audiostatefile">audio-state-file</a></em></code></td>
<!-- --><td colspan=2><code>".snd-mixer"</code></td></tr>
<!-- --><tr><td colspan=2></td><td>Name of file in which current audio hardware settings are 
<!-- -->saved (only works in OSS and SGI).
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- auto-resize -->
<!-- --><tr><td><code><em class=def><a name="autoresize">auto-resize</a></em></code></td>
<!-- --><td><code>#t</code></td>
<!-- --><td>should Snd window resize upon open/close (see <a href="grfsnd.html#xautoresize">AutoResize</a>)
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- channel-style -->
<!-- --><tr><td><code><em class=def><a name="channelstyle">channel-style</a></em></code></td>
<!-- --><td colspan=2><code>channels-separate</code></td></tr>
<!-- --><tr><td colspan=2></td><td>The default state of the '<a href="snd.html#unitebutton">unite</a>' button in multi-channel files.  
<!-- -->Other values are <i>channels-combined</i> and <i>channels-superimposed</i>.  
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- corruption-time -->
<!-- --><tr><td valign=top><code><em class=def><a name="corruptiontime">corruption-time</a></em></code></td>
<!-- --><td valign=top><code>60</code></td>
<!-- --><td>Time (seconds) between background checks for changed file on 
<!-- -->disk (see <a href="#autoupdate">auto-update</a>). If less than 0.0, background process 
<!-- -->is turned off.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- dac-folding -->
<!-- --><tr><td><code><em class=def><a name="dacfolding">dac-folding</a></em></code></td>
<!-- --><td><code>#t</code></td>
<!-- --><td>channels folded upon dac output if not enough dac channels are 
<!-- -->available.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- dac-size -->
<!-- --><tr><td><code><em class=def><a name="dacsize">dac-size</a></em></code></td>
<!-- --><td><code>256</code></td>
<!-- --><td>Audio output buffer size (not always meaningful).
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- data-clipped -->
<!-- --><tr><td valign=top><code><em class=def><a name="dataclipped">data-clipped</a></em></code></td>
<!-- --><td valign=top><code>#f</code></td>
<!-- --><td>If #t, output values are clipped to fit the current sndlib sample
<!-- -->representation's notion of -1.0 to just less than 1.0.  The default
<!-- -->causes wrap-around which makes the out-of-range values very obvious.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- default-output-chans -->
<!-- --><tr><td valign=top><code><em class=def><a name="defaultoutputchans">default-output-chans</a></em></code></td>
<!-- --><td valign=top><code>1</code></td>
<!-- --><td>The default number of channels when a new or temporary file is created, 
<!-- -->or a save dialog is opened.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- default-output-format -->
<!-- --><tr><td valign=top><code><em class=def><a name="defaultoutputformat">default-output-format</a></em></code></td>
<!-- --><td valign=top><code>1</code></td>
<!-- --><td>The default data format when a new or temporary file is created, 
<!-- -->or a save dialog is opened. (1 = mus-bshort).  Use mus-out-format for fastest IO.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- default-output-srate -->
<!-- --><tr><td><code><em class=def><a name="defaultoutputsrate">default-output-srate</a></em></code></td>
<!-- --><td><code>22050</code></td>
<!-- --><td>The default srate when a new or temporary file is created, 
<!-- -->or a save dialog is opened.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- default-output-type -->
<!-- --><tr><td valign=top><code><em class=def><a name="defaultoutputtype">default-output-type</a></em></code></td>
<!-- --><td valign=top><code>0</code></td>
<!-- --><td>The default header type when a new or temporary file is created, 
<!-- -->or a save dialog is opened. (0 = mus-next).
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- eps-bottom-margin -->
<!-- --><tr><td valign=top><code><em class=def><a name="epsbottommargin">eps-bottom-margin</a></em></code></td>
<!-- --><td valign=top><code>0.0</code></td>
<!-- --><td>bottom margin used in snd.eps (Print command) (PS units).
<!-- -->PostScript units are 1/72 of an inch (a "point" in printer jargon); 
<!-- -->an inch is 2.54 cm:
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=3 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(define (inches-to-ps inches) 
<!-- -->  (* inches 72)
<!-- -->
<!-- -->(define (cm-to-ps cm) 
<!-- -->  (* cm (/ 72.0 2.54)))
<!-- --></pre></td></tr></table></td></tr>
<!-- -->
<!-- --><tr><td></td><td></td><td>
<!-- -->In the resulting .eps file, you'll find a concat statement near the 
<!-- -->top of the file; the first and fourth numbers are scale factors on 
<!-- -->the entire graph, the fifth is the left margin, and the sixth is the 
<!-- -->bottom margin.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- eps-file -->
<!-- --><tr><td><code><em class=def><a name="epsfile">eps-file</a></em></code></td>
<!-- --><td colspan=2><code>"snd.eps"</code></td></tr>
<!-- --><tr><td colspan=2></td><td>Name of the Postscript file produced by the <a href="snd.html#printfile">File Print</a> option.
<!-- -->See also the <a href="grfsnd.html#epsresource">epsFile</a> resource.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- eps-left-margin -->
<!-- --><tr><td valign=top><code><em class=def><a name="epsleftmargin">eps-left-margin</a></em></code></td>
<!-- --><td valign=top><code>0.0</code></td>
<!-- --><td>left margin used in snd.eps (Print command) (PS units).
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- filter-env-in-hz -->
<!-- --><tr><td><code><em class=def><a name="filterenvinhz">filter-env-in-hz</a></em></code></td>
<!-- --><td><code>#f</code></td>
<!-- --><td>If #t, filter env x axis is in Hz, otherwise 0 to 1.0.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- fit-data-on-open -->
<!-- --><tr><td valign=top><code><em class=def><a name="fitdataonopen">fit-data-on-open</a></em></code></td>
<!-- --><td valign=top><code>#f</code></td>
<!-- --><td>If #t, the initial time-domain display of a sound shows
<!-- -->its entire duration, with the Y-axis set to show its maxamp.
<!-- -->I may remove this variable; see <a href="#initialgraphhook">initial-graph-hook</a> for a better way to handle this problem.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- graph-cursor -->
<!-- --><tr><td><code><em class=def><a name="graphcursor">graph-cursor</a></em></code></td>
<!-- --><td colspan=2><code>XC_crosshair (34)</code></td></tr>
<!-- --><tr><td colspan=2></td><td>cursor displayed following mouse in graph
<!-- -->The X cursors are declared in /usr/X11R6/include/X11/cursorfont.h or some such file.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- max-regions -->
<!-- --><tr><td><code><em class=def><a name="maxregions">max-regions</a></em></code></td>
<!-- --><td>16</td><td>Size of region stack.</td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- minibuffer-history-length -->
<!-- --><tr><td valign=top><code><em class=def><a name="minibufferhistorylength">minibuffer-history-length</a></em></code></td>
<!-- --><td valign=top><code>8</code></td>
<!-- --><td>Length of minibuffer M-p/M-n history.  If set, sounds that are currently open 
<!-- -->are not affected, only subsequently opened sounds.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- movies -->
<!-- --><tr><td><code><em class=def><a name="movies">movies</a></em></code></td>
<!-- --><td><code>#t</code></td>
<!-- --><td>If #t, the mix graphs are updated constantly as the 
<!-- -->mouse drags the mix tag.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- normalize-on-open -->
<!-- --><tr><td valign=top><code><em class=def><a name="normalizeonopen">normalize-on-open</a></em></code></td>
<!-- --><td valign=top><code>#t</code></td>
<!-- --><td>When a new sound is added to the Snd window, the resultant
<!-- -->set of graphs can start to dangle off the bottom or end of the screen.
<!-- -->If <i>normalize-on-open</i> is #t, Snd tries to do something more reasonable.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- prefix-arg -->
<!-- --><tr><td><code><em class=def><a name="prefixarg">prefix-arg</a></em></code></td>
<!-- --><td><code>0</code></td>
<!-- --><td>This is the keyboard <a href="snd.html#kcu">C-u</a> style argument (named current-prefix-arg in Emacs).
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- save-dir -->
<!-- --><tr><td valign=top><code><em class=def><a name="savedir">save-dir</a></em></code></td>
<!-- --><td valign=top><code>""</code></td>
<!-- --><td>Name of directory for saved-state files.  
<!-- --><br>
<!-- -->If nil, all saved-state is placed (as text) in the saved-state.scm
<!-- -->file.  If you've edited a file, this can be unwieldy.  By setting
<!-- -->save-dir, Snd instead places the necessary intermediate files in
<!-- -->save-dir, with the file names in the saved-state file.  The assumption
<!-- -->here is that you won't mess with the save-dir files until you no
<!-- -->longer want to restart that version of Snd.  <br>
<!-- --><code>(set! (save-dir) "/tmp")</code>.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- save-state-on-exit -->
<!-- --><tr><td><code><em class=def><a name="savestateonexit">save-state-on-exit</a></em></code></td>
<!-- --><td><code>#f</code></td>
<!-- --><td>If #t, Snd saves its current state in <a href="#lsavestatefile">save-state-file</a>.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- save-state-file -->
<!-- --><tr><td><code><em class=def><a name="lsavestatefile">save-state-file</a></em></code></td>
<!-- --><td colspan=2><code>"saved-snd.scm"</code></td></tr>
<!-- --><tr><td colspan=2></td><td>The default <a href="snd.html#savedstate">saved state</a> file name.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- selection-creates-region -->
<!-- --><tr><td><code><em class=def><a name="selectioncreatesregion">selection-creates-region</a></em></code></td>
<!-- --><td><code>#t</code></td>
<!-- --><td>If #t, a region is created whenever a selection is made.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- show-backtrace -->
<!-- --><tr><td valign=top><code><em class=def><a name="showbacktrace">show-backtrace</a></em></code></td>
<!-- --><td valign=top><code>#f</code></td>
<!-- --><td>If #t, show backtrace automatically upon error.
<!-- --><br>
<!-- -->The backtrace feature in Guile has been problematic; it still 
<!-- -->sometimes segfaults deep in the scheme world somewhere, causing 
<!-- -->in the process far more pain than it might have saved if it had 
<!-- -->worked.  It takes me about a half day to isolate these bugs so 
<!-- -->that I can report them to the Guile developers, so I usually 
<!-- -->just throw up my hands and comment out the backtrace call.  
<!-- -->I finally added this switch to speed up that part of the process!  
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- show-indices -->
<!-- --><tr><td><code><em class=def><a name="showindices">show-indices</a></em></code></td>
<!-- --><td><code>#f</code></td>
<!-- --><td>If #t, each sound's name is preceded by its index.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- show-selection-transform -->
<!-- --><tr><td><code><em class=def><a name="lshowselectiontransform">show-selection-transform</a></em></code></td>
<!-- --><td><code>#f</code></td>
<!-- --><td>If #t, display the transform of the current active selection, if any.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- show-usage-stats -->
<!-- --><tr><td><code><em class=def><a name="showusagestats">show-usage-stats</a></em></code></td>
<!-- --><td><code>#f</code></td>
<!-- --><td>If #t, show approximate memory and disk space usage of current edit trees.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- sinc-width -->
<!-- --><tr><td valign=top><code><em class=def><a name="sincwidth">sinc-width</a></em></code></td>
<!-- --><td valign=top><code>10</code></td>
<!-- --><td>Width (in samples) of the sampling rate conversion sinc interpolation.
<!-- --><br>
<!-- -->The higher this number, the better the src low-pass filter, but the slower
<!-- -->src runs.  If you use too low a setting, you can sometimes hear high 
<!-- -->frequency "whistles" leaking through. To hear these on purpose, make 
<!-- -->a sine wave at (say) 55 Hz, then <code>(src-sound '(0 3 1 1))</code> with sinc-width at 4.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- temp-dir -->
<!-- --><tr><td><code><em class=def><a name="tempdir">temp-dir</a></em></code></td>
<!-- --><td><code>nil</code></td>
<!-- --><td>Name of directory for temporary files.  nil usually means "/var/tmp".
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- temp-filenames -->
<!-- --><tr><td><code><em class=def><a name="sndtempfilenames">temp-filenames</a></em></code></td>
<!-- --><td><br></td>
<!-- --><td>return vector of temp file names (see <a href="grfsnd.html#programs">external programs</a>).
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- trap-segfault -->
<!-- --><tr><td><code><em class=def><a name="trapsegfault">trap-segfault</a></em></code></td>
<!-- --><td><code>#t</code></td>
<!-- --><td>If #t, try to catch segfaults and continue anyway.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- use-sinc-interp -->
<!-- --><tr><td valign=top><code><em class=def><a name="usesincinterp">use-sinc-interp</a></em></code></td>
<!-- --><td valign=top><code>#t</code></td>
<!-- --><td>If #t, use high quality src, rather linear interpolation.
<!-- --><br>
<!-- -->This can significantly increase the computational burden on the
<!-- -->computer; if you're trying to play 8 channel 44Khz sounds on an older
<!-- -->machine, It may help to set use-sinc-interp to #f.  In fact, if you're
<!-- -->running a machine in the 100 MHz range, even stereo 44.1kHz can be a
<!-- -->problem -- if the sound has clicks or seems horribly distorted when
<!-- -->the "speed" control is not at 1.0, try setting this variable to #f.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- window-height -->
<!-- --><tr><td valign=top><code><em class=def><a name="windowheight">window-height</a></em></code></td>
<!-- --><td valign=top><code>0</code></td>
<!-- --><td>The current Snd window height in pixels.
<!-- -->This is the same as <br>
<!-- --><code>(cadr (<a href="widgetsize">widget-size</a> (cadr (<a href="mainwidgets">main-widgets</a>))))</code><br>
<!-- -->except at startup when the window-height function and friends defer the set until after the main widgets
<!-- -->have been created.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- window-width -->
<!-- --><tr><td><code><em class=def><a name="windowwidth">window-width</a></em></code></td>
<!-- --><td><code>0</code></td>
<!-- --><td>The current Snd window width in pixels.
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- window-x -->
<!-- --><tr><td valign=top><code><em class=def><a name="windowx">window-x</a></em></code></td>
<!-- --><td valign=top><code>-1</code></td>
<!-- --><td>The current Snd window left side in pixels.
<!-- -->This is (usually) the same as <br>
<!-- --><code>(car (<a href="widgetposition">widget-position</a> (cadr (<a href="mainwidgets">main-widgets</a>))))</code><br>
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- window-y -->
<!-- --><tr><td><code><em class=def><a name="windowy">window-y</a></em></code></td>
<!-- --><td><code>-1</code></td>
<!-- --><td>The current Snd window upper side in pixels (X numbering starts 
<!-- -->at 0 at the top).
<!-- --></td></tr>
<!-- --><tr><td colspan=3></td></tr>
<!-- -->
<!-- zoom-focus-style -->
<!-- --><tr><td><code><em class=def><a name="zoomfocusstyle">zoom-focus-style</a></em></code></td>
<!-- --><td colspan=2><code>focus-active</code></td></tr>
<!-- --><tr><td colspan=2></td><td>This determines what a zoom action focuses (centers) on.  See <a href="snd.html#zoomoption">Zoom options</a>.</td></tr>
<!-- -->
<!-- --></table>
<br>


<span class=cbox><h4><A NAME="sndhooks">Hooks</a></h4></span>

<p>When some user-interface action takes place, some code is called that responds to that action;
these functions are sometimes called callbacks; in Guile the variable that holds a list of such
callbacks is known as a hook.  
A hook provides
a way to customize user-interface
actions.  
The hook itself is list of functions.  The Guile function add-hook! adds a function to a hook's
list, remove-hook! removes a function, and reset-hook! clears out the list.
For example, the hook that is checked when you click the sound's name in the minibuffer is
name-click-hook.  We can cause that action to print "hi" in the listener by:</p>
<pre>
&gt;<em class=typing>(add-hook! name-click-hook (lambda (snd) (snd-print "hi") #t))</em>
</pre>
<p>
If there is more than one function attached to a hook, some of the hooks
'or' the functions together (marked <b>or hook</b> below); that is they
run through the list of functions, and if any function returns #t, the
hook immediately returns #t (ignoring the remaining functions), whereas in the other
cases, the result returned by the hook is the result of the last function in the list.
In the list below the arguments after the hook name refer to the functions invoked by
the hook.  
</p>

<!-- -------------------------------- HOOK TABLE -------------------------------- -->
<!-- -->
<!-- --><table border=0 cellspacing=10>
<!-- -->
<!-- after-graph-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="aftergraphhook">after-graph-hook</a></em> (snd chn)</code></span>
<!-- --></td></tr>
<!-- --><tr><td width=150></td><td>
<!-- -->called after a graph is updated or redisplayed.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- after-open-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="afteropenhook">after-open-hook</a></em> (snd)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called just before the new file's window is displayed.
<!-- -->This provides a way to set various sound-specific defaults.  
<!-- -->For example, the following causes Snd to default to locally 
<!-- -->sync'd channels (that is, each sound's channels are sync'd 
<!-- -->together but are independent of any other sound), united channels, 
<!-- -->and filled graphs:
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(add-hook! <em class=red>after-open-hook</em>
<!-- -->  (lambda (snd)
<!-- -->    (if (&gt; (channels snd) 1)
<!-- -->        (begin
<!-- -->          (set! (sync snd) (1+ snd)) ; 0 = #f
<!-- -->          (set! (uniting snd) channels-combined)
<!-- -->          (set! (graph-style snd) graph-filled)))
<!-- --></pre></td></tr></table></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- before-fft-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="beforeffthook">before-fft-hook</a></em> (snd chn)</code></span>
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->called just before an FFT (or spectrum) is calculated.  If it returns 
<!-- -->an integer, it is used as the starting point of the fft.  The following 
<!-- -->somewhat brute-force code shows a way to have the fft reflect the position 
<!-- -->of a moving mark:
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(define fft-position #f)
<!-- -->(add-hook! <em class=red>before-fft-hook</em> (lambda (snd chn) fft-position))
<!-- -->(add-hook! mark-drag-hook (lambda (id)
<!-- -->                            (set! fft-position (mark-sample id))
<!-- -->                            (update-fft)))
<!-- --></pre></td></tr></table></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- close-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="closehook">close-hook</a></em> (snd) </code></span>
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->called each time a file is closed (before the close). (<b>or hook</b>)
<!-- -->If it returns #t, the file is not closed. <pre><code>
<!-- -->(add-hook! close-hook 
<!-- -->  (lambda (snd) 
<!-- -->    (system \"sndplay wood16.wav\")))
<!-- --></code></pre></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- drop-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="drophook">drop-hook</a></em> (filename) </code></span>
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->called each time Snd receives a drag-and-drop event, passing the hook the filename. (<b>or hook</b>)
<!-- -->If it returns #t, the file is not opened. <pre><code>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- during-open-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="duringopenhook">during-open-hook</a></em> (fd name reason)</code></span>
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->called after file is opened, but before data has been read.
<!-- -->This provides an opportunity to set sndlib prescaling values:
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(add-hook! <em class=red>during-open-hook</em>
<!-- -->  (lambda (fd name reason)
<!-- -->    (if (= (mus-sound-header-type name) mus-raw)
<!-- -->        (mus-file-set-prescaler fd 500.0))))
<!-- --></pre></td></tr></table></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->The prescaling affects only sound data made up of floats or doubles.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- enved-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="envedhook">enved-hook</a></em> (env pt new-x new-y reason)</code></span>
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->Each time a breakpoint is changed in the envelope editor, this hook 
<!-- -->is called; if it returns a list, that list defines the new envelope, 
<!-- -->otherwise the breakpoint is moved (but not beyond the neighboring 
<!-- -->breakpoint), leaving other points untouched.  The kind of change
<!-- -->is <i>reason</i> which can be enved-move-point, enved-delete-point,
<!-- -->or enved-add-point.  This hook makes it possible to define attack 
<!-- -->and decay portions in the envelope editor, or use functions such as 
<!-- -->stretch-envelope from env.scm:
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(add-hook! <em class=red>enved-hook</em>
<!-- -->  (lambda (env pt x y reason)
<!-- -->    (if (= reason enved-move-point)
<!-- -->        (if (and (&gt; x 0.0) (&lt; x (max-x env)))
<!-- -->            (let* ((old-x (list-ref env (* pt 2)))
<!-- -->                   (new-env (<em class=red>stretch-envelope</em> env old-x x)))
<!-- -->              (list-set! new-env (+ (* pt 2) 1) y)
<!-- -->              new-env)
<!-- -->            env)
<!-- -->        #f)))
<!-- --></pre></td></tr></table></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->If there are several functions on the hook, each gets the (envelope)
<!-- -->result of the preceding function (if a function returns #f, the envelope
<!-- -->is not changed).  A math-type might call this a "function composition"
<!-- -->method combination.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- exit-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="exithook">exit-hook</a></em> ()</code></span>
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->called upon exit. (<b>or hook</b>)
<!-- -->If it returns #t, Snd does not exit.  This can be used to check 
<!-- -->for unsaved edits, or to perform cleanup activities.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- fft-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="ffthook">fft-hook</a></em> (snd chn scaler)</code></span>
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->called just after an FFT (or spectrum) is calculated.
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(add-hook! fft-hook
<!-- -->  (lambda (snd chn scale)
<!-- -->    (if (and (ffting snd chn) (= (fft-style snd chn) normal-fft))
<!-- -->	(report-in-minibuffer 
<!-- -->	 (number->string (/ (* 2.0 (vct-peak (transform-samples->vct snd chn))) 
<!-- -->                            (fft-size snd chn)))
<!-- -->	 snd)
<!-- -->      #f)))
<!-- --></pre></td></tr></table></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- graph-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="graphhook">graph-hook</a></em> (snd chn y0 y1) </code></span>
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->called each time a graph is updated or redisplayed.
<!-- -->If it returns #t, the display is not updated.
<!-- --></td></tr>
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(add-hook! graph-hook
<!-- -->  (lambda (snd chn y0 y1)
<!-- -->    "set the dot size depending on the number of samples being displayed"
<!-- -->    (let ((dots (- (right-sample snd chn) (left-sample snd chn))))
<!-- -->      (if (> dots 100) 
<!-- -->	  (set! (dot-size snd chn) 1)
<!-- -->	(if (> dots 50)
<!-- -->	    (set! (dot-size snd chn) 2)
<!-- -->	  (if (> dots 25)
<!-- -->	      (set! (dot-size snd chn) 3)
<!-- -->	    (set! (dot-size snd chn) 5))))
<!-- -->      #f)))
<!-- --></pre></td></tr></table></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- initial-graph-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="initialgraphhook">initial-graph-hook</a></em> (snd chn dur) </code></span>
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->called the first time a given channel is displayed. (<b>or hook</b>).
<!-- -->If it returns a list, the list's contents are interpreted as: <br>
<!-- --><code>'(x0 x1 y0 y1 label ymin ymax)</code><br> (all values optional), where these numbers set the
<!-- -->initial axis limits and settings.  This replaces the variable <i>initial-x0</i> and its friends.
<!-- -->The default (empty hook) is equivalent to:
<!-- --><pre>(add-hook! initial-graph-hook (lambda (snd chn dur) (list 0.0 0.1 -1.0 1.0 "time" -1.0 1.0)))</pre>
<!-- -->The <i>dur</i> argument is the total length in seconds of the channel, so to cause the
<!-- -->entire sound to be displayed initially:
<!-- --><pre>(add-hook! initial-graph-hook (lambda (snd chn dur) (list 0.0 dur)))</pre>
<!-- -->To get the data limits (rather than the default -1.0 to 1.0 as above), you can use <a href="mussoundmaxamp">mus-sound-max-amp</a>,
<!-- -->but that can in some cases require a long process of reading the underlying file. The following hook procedure
<!-- -->uses the max amp data only if it is already available:
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(add-hook! <em class=red>initial-graph-hook</em>
<!-- -->  (lambda (snd chn dur)
<!-- -->    (if (mus-sound-max-amp-exists? (file-name snd))
<!-- -->	(let* ((amp-vals (mus-sound-max-amp (file-name snd)))
<!-- -->	       (max-val (vector-ref amp-vals (+ (* chn 2) 1))))
<!-- -->	  (list 0.0 dur (- max-val) max-val))
<!-- -->	(list 0.0 dur -1.0 1.0))))
<!-- --></pre></td></tr></table>
<!-- --></td></tr><tr><td colspan=2></td></tr>
<!-- --><tr><td></td><td>A similar problem affects the <i>dur</i> argument.  If the file is very long, Snd starts
<!-- -->a background process reading its data to get an overall amplitude envelope of the file,
<!-- -->and this envelope is what it actually displays when you zoom out to look at the entire
<!-- -->sound. If you set <i>x1</i> to <i>dur</i>, you effectively get two such processes
<!-- -->contending for access to the data.  One way around this is to notice if the
<!-- -->duration is very long, and if so, set up an after-graph-hook function that looks
<!-- -->at the channel's <a href="#peakenvinfo">peak-env-info</a>, waiting for it to be completed before finally 
<!-- -->asking that the entire file be displayed:
<!-- --></td></tr>
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(use-modules (ice-9 common-list))
<!-- -->(define startups '())
<!-- --><br>
<!-- -->(define (remove-startup snd chn)
<!-- -->  (set! startups (remove-if (lambda (n) (and (= (car n) snd) (= (cadr n) chn))) startups)))
<!-- --><br>
<!-- -->(define (add-startup snd chn)
<!-- -->  (set! startups (cons (list snd chn) startups)))
<!-- --><br>
<!-- -->(define (starting? snd chn)
<!-- -->  (find-if (lambda (n) (and (= (car n) snd) (= (cadr n) chn))) startups))
<!-- --><br>
<!-- -->(define (wait-for-completed-envelope snd chn)
<!-- -->  (if (starting? snd chn)
<!-- -->      (let ((e (<em class=red>peak-env-info</em> snd chn)))
<!-- -->	(if (and e (car e))
<!-- -->	    (begin
<!-- -->	      (set! (x-bounds snd chn) (list 0.0 (/ (frames snd chn) (srate snd))))
<!-- -->	      (remove-startup snd chn))))))
<!-- --><br>
<!-- -->(add-hook! initial-graph-hook
<!-- -->  (lambda (snd chn dur)
<!-- -->    (if (< dur 100.0)
<!-- -->	(if (<em class=red>mus-sound-max-amp-exists?</em> (file-name snd))
<!-- -->	    (let* ((amp-vals (<em class=red>mus-sound-max-amp</em> (file-name snd)))
<!-- -->		   (max-val (vector-ref amp-vals (+ (* chn 2) 1))))
<!-- -->	      (list 0.0 dur (- max-val) max-val))
<!-- -->	    (list 0.0 dur -1.0 1.0))
<!-- -->	(begin
<!-- -->	  (add-startup snd chn)
<!-- -->	  #f))))
<!-- --><br>
<!-- -->(add-hook! after-graph-hook wait-for-completed-envelope)
<!-- --></pre></td></tr></table>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->But we needed three hours of sound by yesterday or the rent doesn't get paid -- no time to wait on a background process!
<!-- -->So, we read and write the entire peak-env-info contents ourselves:
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(use-modules (ice-9 format))
<!-- --><br>
<!-- -->(define save-peak-env-info #t)
<!-- --><br>
<!-- -->(define (peak-env-info-file-name snd chn)
<!-- -->  (format #f "~A-peaks-~D" (file-name snd) chn))
<!-- -->  ;; or, if we want these files saved in a directory named "peaks":
<!-- -->  ;;   (format #f "~~/peaks/~A-peaks-~D" (short-file-name snd) chn))
<!-- --><br>
<!-- -->(define (save-peak-env-info-at-close snd)
<!-- -->  ;; intended as a close-hook function
<!-- -->  (if (and save-peak-env-info
<!-- -->	   (not (null? (peak-env-info snd 0 0))))
<!-- -->      (do ((i 0 (1+ i)))
<!-- -->	  ((= i (chans snd)))
<!-- -->	(let ((peak-file (mus-expand-filename (peak-env-info-file-name snd i))))
<!-- -->	  (if (or (not (file-exists? peak-file))
<!-- -->		  (&lt; (file-write-date peak-file)
<!-- -->		     (file-write-date (file-name snd))))
<!-- -->	      (<em class=red>write-peak-env-info-file</em> snd i peak-file)))))
<!-- -->  #f)
<!-- --><br>
<!-- -->(define (restore-peak-env-info-upon-open snd chn dur)
<!-- -->  ;; intended as an initial-graph-hook-function
<!-- -->  (let ((peak-file (mus-expand-filename (peak-env-info-file-name snd chn))))
<!-- -->    (if (and (file-exists? peak-file)
<!-- -->	     (&gt; (file-write-date peak-file)
<!-- -->		(file-write-date (file-name snd))))
<!-- -->	(<em class=red>read-peak-env-info-file</em> snd chn peak-file))))
<!-- --><br>
<!-- -->(add-hook! close-hook save-peak-env-info-at-close)
<!-- -->(add-hook! exit-hook (lambda () (for-each save-peak-env-info-at-close (sounds)) #f))
<!-- -->(add-hook! initial-graph-hook restore-peak-env-info-upon-open)
<!-- --></pre></td></tr></table>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->This writes the peak-env data when a file is closed, and reads
<!-- -->it upon opening the file, if it exists; it provides essentially
<!-- -->immediate display of any size file.
<!-- -->Snd's author is not responsible for any unpaid rent.
<!-- --></td></tr><tr><td colspan=2></td></tr>
<!-- -->
<!-- just-sounds-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="justsoundshook">just-sounds-hook</a></em> (filename)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called on each file (after the sound file extension check) if the
<!-- -->just-sounds button is set. Return #f to filter out <i>filename</i>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(add-hook! <em class=red>just-sounds-hook</em>
<!-- -->  (lambda (name) ;display only stereo files in file selection dialog
<!-- -->    (and (not (= (mus-sound-header-type name) mus-raw))
<!-- -->         ;;any unrecognized file is considered "raw"
<!-- -->         (= (mus-sound-chans name) 2))))
<!-- --></pre></td></tr></table></td></tr>
<!-- --><tr><td></td><td>
<!-- -->This currently only works in Motif; the Gtk file selection dialogs 
<!-- -->don't provide a way to specialize the directory read.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- key-press-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="keypresshook">key-press-hook</a></em> (snd chn key state)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called upon key press while mouse is in lisp graph. (<b>or hook</b>)
<!-- -->If it returns #t, the key press is not passed to the main handler.
<!-- --><i>state</i> refers to the control, meta, and shift keys.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- lisp-graph-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="lispgraphhook">lisp-graph-hook</a></em> (snd chn)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called just before the lisp graph is updated or redisplayed.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- mark-click-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="markclickhook">mark-click-hook</a></em> (id)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called when a mark is clicked, return #t to squelch message.
<!-- --></td></tr>
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(add-hook! <em class=red>mark-click-hook</em>
<!-- -->  (lambda (n) 
<!-- -->    (help-dialog "Mark Help" (number-&gt;string (mark-sample n))) 
<!-- -->    #t))
<!-- --></pre></td></tr></table></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- mark-drag-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="markdraghook">mark-drag-hook</a></em> (id)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called when mark id is dragged.
<!-- --></td></tr>
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(define (report-mark-location id)
<!-- -->  ;; print current mark location in minibuffer
<!-- -->  (let ((samp (mark-sample id))
<!-- -->        (sndchn (mark-&gt;sound id)))
<!-- -->
<!-- -->    (report-in-minibuffer 
<!-- -->      (format #f "~D (~,3F) ~A[~D]"
<!-- -->              samp 
<!-- -->              (/ samp (srate (car sndchn))) 
<!-- -->              (short-file-name (car sndchn))
<!-- -->              (cadr sndchn)))))
<!-- -->
<!-- -->(add-hook! <em class=red>mark-drag-hook</em> report-mark-location)
<!-- --></pre></td></tr></table></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- mix-amp-changed-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="mixampchangedhook">mix-amp-changed-hook</a></em> (id)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called when mix amp changes via mouse (id = mix id).
<!-- -->If #t, the actual remix is the hook's responsibility.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- mix-position-changed-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="mixpositionchangedhook">mix-position-changed-hook</a></em> (id samps)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called when mix moves via mouse (id = mix id, 
<!-- -->samps = samps moved). (<b>progn hook</b>) If #t, the actual remix is the 
<!-- -->hook's responsibility.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- mix-speed-changed-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="mixspeedchangedhook">mix-speed-changed-hook</a></em> (id)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called when mix speed changes via mouse (id = mix id).
<!-- -->If #t, the actual remix is the hook's responsibility.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- mouse-drag-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="mousedraghook">mouse-drag-hook</a></em> (snd chn button state x y) </code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called upon mouse motion (with button pressed) within lisp graph.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- mouse-enter-graph-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="mouseentergraphhook">mouse-enter-graph-hook</a></em> (snd chn) </code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called when the mouse enters a channel's drawing area (graph pane).
<!-- --></td></tr>
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(add-hook! <em class=red>mouse-enter-graph-hook</em>
<!-- -->  (lambda (snd chn) 
<!-- -->    (snd-print (format #f "~A[~A]" (short-file-name snd) chn))))
<!-- --></pre></td></tr></table></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- mouse-enter-label-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="mouseenterlabelhook">mouse-enter-label-hook</a></em> (type position name) </code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called when a file viewer or region label 
<!-- -->is entered by the mouse. The 'type' is 0 for the current files list, 1 for previous files, and 2 for regions. 
<!-- -->The 'position' is the scrolled list position of the label. 
<!-- -->The label itself is 'label'. We could use the 'finfo' procedure in examp.scm
<!-- -->to popup file info as follows:
<!-- --></td></tr>
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(add-hook! mouse-enter-label-hook
<!-- -->  (lambda (type position name)
<!-- -->    (if (not (= type 2))
<!-- -->        (help-dialog name (finfo name)))))
<!-- --></pre></td></tr></table></td></tr>
<!-- --><tr><td></td><td>See also files-popup-buffer in examp.scm</td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- mouse-enter-listener-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="mouseenterlistenerhook">mouse-enter-listener-hook</a></em> (widget) </code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called when the mouse enters the lisp listener pane. This hook, along with the parallel graph hook
<!-- -->makes it possible to set up Snd to behave internally like a window manager with pointer-focus.  That is, to
<!-- -->ensure that the pane under the mouse is the one that receives keyboard input, we could define the following
<!-- -->hook procedures:
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(add-hook! <em class=red>mouse-enter-graph-hook</em>
<!-- -->  (lambda (snd chn)
<!-- -->    (if (sound? snd) (focus-widget (car (channel-widgets snd chn))))))
<!-- -->
<!-- -->(add-hook! <em class=red>mouse-enter-listener-hook</em>
<!-- -->  (lambda (widget)
<!-- -->    (focus-widget widget)))
<!-- --></pre></td></tr></table></td></tr>
<!-- --><tr><td></td><td>
<!-- -->I much prefer this style of operation.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- mouse-enter-text-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="mouseentertexthook">mouse-enter-text-hook</a></em> (widget) </code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called when the mouse enters a text widget (Motif version only currently).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- mouse-leave-graph-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="mouseleavegraphhook">mouse-leave-graph-hook</a></em> (snd chn) </code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called when the mouse leaves a channel's drawing area (graph pane). 
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- mouse-leave-label-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="mouseleavelabelhook">mouse-leave-label-hook</a></em> (type position name) </code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called when the mouse exits one of the labels covered by mouse-enter-label-hook.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- mouse-leave-listener-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="mousleavelistenerhook">mouse-leave-listener-hook</a></em> (widget) </code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called when the mouse leaves the lisp listener pane.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- mouse-leave-text-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="mousleavetexthook">mouse-leave-text-hook</a></em> (widget) </code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called when the mouse leaves a text widget (Motif version only currently).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- mouse-press-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="mousepresshook">mouse-press-hook</a></em> (snd chn button state x y) </code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called upon mouse button press within lisp graph.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- mouse-release-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="mousereleasehook">mouse-release-hook</a></em> (snd chn button state x y) </code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called upon mouse button release within lisp graph.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- multichannel-mix-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="multichannelmixhook">multichannel-mix-hook</a></em> (ids)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called when a multichannel mix happens in a sync'd sound.
<!-- --><i>ids</i> is a list of mix id numbers.  See <a href="sndscm.html#mixdoc">mix.scm</a> for an example.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- mus-error-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="muserrorhook">mus-error-hook</a></em> (error-type error-message)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called upon mus_error. (<b>or hook</b>)
<!-- -->If it returns #t, Snd ignores the error (it assumes you've handled it via the hook).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- name-click-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="nameclickhook">name-click-hook</a></em> (snd)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called when sound name clicked (<b>or hook</b>).
<!-- -->If it returns #t, the usual informative minibuffer babbling is squelched.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- open-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="openhook">open-hook</a></em> (filename)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called each time a file is opened (before the actual open).  (<b>or hook</b>)
<!-- -->If it returns #t, the file is not opened.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- open-raw-sound-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="openrawsoundhook">open-raw-sound-hook</a></em> (filename current-choices)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called each time open-sound encounters a headerless file.
<!-- -->Its result can be a list describing the raw file's attributes (thereby bypassing the Raw File Dialog and so on). 
<!-- -->The list is interpreted as '(chans srate data-format data-location data-length) where trailing elements can 
<!-- -->be omitted (location defaults to 0, and length defaults to the file length in bytes).
<!-- -->If there is more than one function on the hook list, functions after the first get the
<!-- -->on-going list result (if any) as the <i>current-choices</i> argument (the empty list is the default).
<!-- --><code>(add-hook! open-raw-sound-hook (lambda (file choices) (list 1 44100 mus-lshort)))</code>
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- output-comment-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="outputcommenthook">output-comment-hook</a></em> (str)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called in Save-As dialog, passed current sound's comment, if any.
<!-- -->If more than one hook function, results are concatenated.  
<!-- -->If the hook is empty, the current comment is used.
<!-- --></td></tr>
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(add-hook! <em class=red>output-comment-hook</em>
<!-- -->  (lambda (str) 
<!-- -->    (string-append "written " 
<!-- -->      (strftime "%a %d-%b-%Y %H:%M %Z" 
<!-- -->        (localtime (current-time)))))) 
<!-- --></pre></td></tr></table></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- output-name-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="outputnamehook">output-name-hook</a></em> ()</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called in File New dialog
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- play-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="playhook">play-hook</a></em> (samps)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called each time a buffer (size: <i>samps</i>) is about to be 
<!-- -->filled for the DAC (see <a href="sndscm.html#enveddoc">enved.scm</a> and <a href="sndscm.html#marksdoc">marks.scm</a>). (<b>progn hook</b>)
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- property-changed-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="propertychangedhook">property-changed-hook</a></em> (command)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called when Snd sees a SND_COMMAND window property change.
<!-- -->If it returns #t, the command is not evaluated (<b>or hook</b>).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- save-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="savehook">save-hook</a></em> (snd name)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called each time a file is about to be saved. (<b>or hook</b>)
<!-- -->If it returns #t, the file is not saved.  <i>name</i> is #f unless 
<!-- -->the file is being saved under a new name (as in sound-save-as).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- select-channel-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="selectchannelhook">select-channel-hook</a></em> (snd chn)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called when a channel is selected (after the sound has been selected). The arguments are the sound's index and the channel number.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- select-mix-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="selectmixhook">select-mix-hook</a></em> (id)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called when a mix is selected. The argument is the newly selected mix's id.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- select-region-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="selectregionhook">select-region-hook</a></em> (id)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called when a region is selected. The argument is the newly selected region's id.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- select-sound-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="selectsoundhook">select-sound-hook</a></em> (snd)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called when a sound is selected. The argument is the about-to-be-selected sound's index.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- snd-error-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="snderrorhook">snd-error-hook</a></em> (error-message)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called upon snd_error. (<b>or hook</b>)
<!-- -->If it returns #t, Snd flushes the error (it assumes you've 
<!-- -->reported it via the hook).
<!-- --></td></tr>
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(add-hook! <em class=red>snd-error-hook</em>
<!-- -->  (lambda (msg) 
<!-- -->    (play "bong.snd") 
<!-- -->    #f))
<!-- --></pre></td></tr></table></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- snd-warning-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndwarninghook">snd-warning-hook</a></em> (warning-message)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called upon snd_warning. (<b>or hook</b>)
<!-- -->If it returns #t, Snd flushes the warning (it assumes you've 
<!-- -->reported it via the hook).
<!-- --></td></tr>
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(define without-warnings
<!-- -->  (lambda (thunk)
<!-- -->    (define no-warning (lambda (msg) #t))
<!-- -->      (add-hook! <em class=red>snd-warning-hook</em> no-warning)
<!-- -->      (thunk)
<!-- -->      (remove-hook! <em class=red>snd-warning-hook</em> no-warning)))
<!-- --></pre></td></tr></table></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- start-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="starthook">start-hook</a></em> (filename)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called upon start-up. (<b>or hook</b>)
<!-- -->If it returns #t, snd exits immediately.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- start-playing-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="startplayinghook">start-playing-hook</a></em> (snd)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called when a play request is triggered. (<b>or hook</b>)
<!-- -->If it returns #t, snd does not play.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- stop-playing-channel-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="stopplayingchannelhook">stop-playing-channel-hook</a></em> (snd chn)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called when a sound finishes playing. (<b>or hook</b>)
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- stop-playing-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="stopplayinghook">stop-playing-hook</a></em> (snd)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called when a sound finishes playing. (<b>or hook</b>)
<!-- -->The following code plays a sound over and over until you type C-g:
<!-- --></td></tr>
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(define (play-until-c-g)
<!-- -->  (define (play-once snd)
<!-- -->    (if (c-g?)
<!-- -->        (remove-hook! stop-playing-hook play-once)
<!-- -->        (play 0 snd)))
<!-- -->  (add-hook! stop-playing-hook play-once)
<!-- -->  (play))
<!-- --></pre></td></tr></table></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- stop-playing-region-hook -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="stopplayingregionhook">stop-playing-region-hook</a></em> (n)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->called when a region finishes playing. (<b>or hook</b>)
<!-- --></td></tr>
<!-- --></table>

<pre>
  <h4>Channel-specific hooks:</h4>

  <em class=def><a name="edithook">edit-hook</a></em> (<i>snd chn</i>)

  <em class=def><a name="undohook">undo-hook</a></em> (<i>snd chn</i>)
</pre>

<table border=0><tr><td width=150><br></td><td>
These are functions that return the hooks in question associated with the specified channel.
edit-hook is called just before any attempt to edit the channel's data.  If it returns #t,
the edit is aborted. So,
</td></tr></table>
<center><pre>
  (add-hook! (<em class=red>edit-hook</em>) (lambda () #t))
</pre></center>
<table border=0><tr><td width=150><br></td><td>
aborts any attempt to edit the data; this is even more restrictive than setting the read-only
flag because the latter only refuses to overwrite the current data.  undo-hook is called
just after any undo, redo, or revert that affects the channel.  You can use edit-hook to set
up protected portions of the edit history:
</td></tr></table>
<br>
<center><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(define protect
  "(protect &amp;optional snd chn) disallows any edits before the current one"
  (lambda args
    (let* ((edit-pos (apply edit-position args))
           (hook (apply <em class=red>edit-hook</em> args)))
      (reset-hook! hook)
      (add-hook! hook 
        (lambda ()
          (let ((val (&lt; (apply edit-position args) edit-pos)))
            (if val (report-in-minibuffer "protected"))
            val))))))

(define unprotect 
  "(unprotect &amp;optional snd chn) allows edits at any edit history position"
  (lambda args 
    (reset-hook! (apply <em class=red>edit-hook</em> args))))
</pre></td></tr></table></center>

<p><a href="sndscm.html#enveddoc">enved.scm</a> uses several of these hooks to implement an envelope editor in lisp.
See also <a href="#menuhook">menu-hook</a> below.
You can find out what's on a given hook with the following (which is mostly adding carriage returns to the
printout from hook-&gt;list):
</p>
<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(define (describe-hook hook)
  (for-each 
    (lambda (n) 
      (snd-print n))
    (reverse (hook-&gt;list hook))))
</pre></td></tr></table>

<p>For example, say we pile up some random stuff on name-click-hook:
</p>
<pre>
(add-hook! name-click-hook snd-print)
(add-hook! name-click-hook (lambda (n) (snd-print n)))
(add-hook! name-click-hook (let ((ha 32)) (lambda (n) ha)))
</pre>
<p>Then we go skiing for a week, get home, and can't remember where
we were.  Do we panic and dial 911? No!  We simply type:
</p>
<pre>
<em class=listener>:</em><em class=typing>(describe-hook name-click-hook)</em>
<em class=listener>#&lt;primitive-procedure snd-print&gt;
#&lt;procedure (n) (snd-print n)&gt;
#&lt;procedure (n) ha&gt;
#&lt;unspecified&gt;
:</em>
</pre>
<p>These hooks are extremely easy to add; if there's some user-interface action
you'd like to specialize in some way, send me a note.  I'm slowly replacing
many of the global variables with hooks, since the latter are much more
flexible.
</p>

<br>
<span class=bbox><h3><A NAME="sndobjects">Snd's objects</a></h3></span>

<p>Snd presents its various data structures to the user as a list
of sounds, each with a list of channels, each with lists of edits,
marks, and mixes.  The sound data itself is accessed through
a variety of structure and functions, each aimed at a particular
kind of use.  One of the most commonly used is the <i>vct</i>.
But before launching into vcts, I need to explain a few things
about the following documentation.
</p>

<p>In the following lists, optional arguments are in italics (although
netscape sometimes displays them in bold face for some reason).
Each sound has an
associated "index" used to refer to it in all the
functions.  This somewhat arbitrary number is more
or less related to the sound's position in the
display of sounds (set the variable <a href="#showindices">show-indices</a>
to cause it to be displayed in front of the sound's name).
In the argument lists
below, <i>snd</i> as an argument refers to the sound's index, and defaults to the currently
selected sound.  Similarly, <i>chn</i> is the channel number, starting from 0, and defaults
to the currently selected channel.  So if there's only one sound active, and it has only
one channel, (cursor) (cursor 0), and (cursor 0 0) all refer to the same
thing.  If you want to refer to the currently selected sound, either use #f
as the sound index or the function selected-sound.
</p>
<p>
If the <i>snd</i> argument is a list, the first element of the list is
taken to be a mix id number, and the reference is to the underlying mix input
sound data.  That is, (frames 1) returns the number of frames (samples per channel)
in the sound whose current index is 1; (frames (list 1)) returns the frames in
the sound that underlies the mix whose id is 1.  Similarly (scale-by .5) scales
the currently selected sound by .5; (scale-by .5 (list 0) 2) scales the 3rd channel
of mix 0's input sound by .5.  I keep saying "underlying" because normally a
mix is viewed after it has gone through its panel of controls (the set of widgets displayed
in the Mix Panel dialog -- these can affect the
amplitude, amplitude envelope, and sampling rate) -- next-mix-sample, for
example, refers to the processed form of the mix data, whereas next-sample
would refer to the original form.  I may extend this to accept a list of (more than one) mixes.
</p>

<p>In many cases, the <i>snd</i>, <i>chn</i>, and <i>reg</i> arguments
can be #t (for backwards compatibility, a few of them default to #t).
#t means "all" in this case; if <i>snd</i> is #t, all sounds are included,
so, for example, <code>(expand #t)</code> returns a list of the current
control panel expansion settings of all sounds, and
<code>(set! (ffting #t #t) #t)</code>
turns on the fft display in all channels of all sounds.
</p>

<p>When an error occurs, in most cases the function throws a tag such as 'no-such-sound,
'impossible-bounds, 'no-active-selection, etc.
The error tag is mentioned with the function in the form [<em class=error>no-such-channel</em>].
All the functions that take sound and channel args ("snd chn" below) can return the errors
'no-such-sound and 'no-such-channel; all the mix-related functions can return 'no-such-mix;
all the region-related functions can return 'no-such-region; to reduce clutter, I'll omit mention
of these below.  Many of the errors are continuable, which is to say that you can continue
from the point of the error if you want, replacing the offending value or whatever with
a new one.  In the documentation, I'll indicate that an error has a continuation and what
that continuation can affect with the form [<em class=error>no-such-channel -&gt; channel</em>]
meaning that the 'no-such-channel error in this case can be continued and the continuation
argument becomes the new channel number.
</p>

<br>
<span class=cbox><h3><A NAME="Vcts">Vcts</a></h3></span>
<p>
Many of the Snd and CLM functions handle vectors (arrays) of data; 
by defining a new vector type, named vct, and providing a package
of old-style array-processing calls upon that type, we can speed up many
operations by a factor of 30.  This is enough of a difference to warrant
the added complexity, I think.  A vct object can be viewed as a vector;
to make one, call <i>make-vct</i>.  It will be freed by the Guile
garbage collector when it can't be referenced any further.  To get 
an element of a vct, use <i>vct-ref</i>; similarly <i>vct-set!</i>
sets an element (the "!" appended to the setter functions is standard in Scheme;
another is the use of "?" where Common Lisp is more likely to use "-p").
Once created, a vct object can be passed to a variety of built-in
functions:</p>
<pre>
  (define hi (make-vct 100))
  (vct-fill! hi 3.14)
  (vct-scale! hi -1.0)
</pre>
<p>Now our vct object <i>hi</i> has 100 -3.14's. <p>

<!-- -------------------------------- VCT TABLE -------------------------------- -->
<!-- -->
<!-- --><table border=0 cellspacing=5>
<!-- -->
<!-- list->vct -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndlist2vct">list-&gt;vct</a></em> (lst)</code></span></td>
<!-- --><td>return vct object with elements of list <i>lst</i></td></tr>
<!-- -->
<!-- vct -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndvct">vct</a></em> args</code></span></td>
<!-- --><td>list-&gt;vct with args not list: <code>(vct 1 2 3)</code> = <code>(list-&gt;vct '(1 2 3))</code></td></tr>
<!-- -->
<!-- make-vct -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="makevct">make-vct</a></em> (len)</code></span></td>
<!-- --><td>create vct struct of size <i>len</i>.</td></tr>
<!-- -->
<!-- sound-date->vct -->
<!-- --><tr><td><span class=defbox><code><em class=def>sound-data-&gt;vct</em> (sdobj chan vobj)</code></span></td>
<!-- --><td>place sound-data channel data in vct </td></tr>
<!-- -->
<!-- vct? -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="vctp">vct?</a></em> (vobj)</code></span></td>
<!-- --><td>#t if <i>vobj</i> is a <a href="#Vcts">vct</a> struct.</td></tr>
<!-- -->
<!-- vct-add! -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="vctadd">vct-add!</a></em> (vobj1 vobj2 <i>off</i>)</code></span></td>
<!-- --><td><code>vobj1[i+off] += vobj2[i]</code>, returns vobj1.</td></tr>
<!-- -->
<!-- vct-copy -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="vctcopy">vct-copy</a></em> (obj)</code></span></td>
<!-- --><td>return a copy of <i>obj</i>.</td></tr>
<!-- -->
<!-- vct-do! -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="vctdo">vct-do!</a></em> (vobj proc)</code></span></td>
<!-- --><td><code>vobj[i] = (funcall proc i)</code>.</td></tr>
<!-- -->
<!-- vct-fill! -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="vctfill">vct-fill!</a></em> (vobj val)</code></span></td>
<!-- --><td><code>vobj[i] = val</code>, returns vobj.</td></tr>
<!-- -->
<!-- vct-length -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="vctlength">vct-length</a></em> (vobj)</code></span></td>
<!-- --><td>length of data array in vobj.</td></tr>
<!-- -->
<!-- vct-map! -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="vctmap">vct-map!</a></em> (vobj proc)</code></span></td>
<!-- --><td><code>vobj[i] = (funcall proc)</code>.</td></tr>
<!-- -->
<!-- vct-move! -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="vctmove">vct-move!</a></em> (vobj new old <i>back</i>)</code></span></td>
<!-- --><td><code>v[new++] = v[old++]</code>, returns v (if back, <code>v[new--] = v[old--]</code>)</td></tr>
<!-- -->
<!-- vct-multiply! -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="vctmultiply">vct-multiply!</a></em> (vobj1 vobj2)</code></span></td>
<!-- --><td><code>vobj1[i] *= vobj2[i]</code>, returns vobj1.</td></tr>
<!-- -->
<!-- vct-offset! -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="vctoffset">vct-offset!</a></em> (vobj val)</code></span></td>
<!-- --><td><code>vobj[i] += val</code>, returns vobj.</td></tr>
<!-- -->
<!-- vct-peak -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="vctpeak">vct-peak</a></em> (vobj)</code></span></td>
<!-- --><td>abs max val in vobj</td></tr>
<!-- -->
<!-- vct-ref -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="vctref">vct-ref</a></em> (vobj pos)</code></span></td>
<!-- --><td>value in vobj's data at location pos.</td></tr>
<!-- -->
<!-- vct-scale! -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="vctscale">vct-scale!</a></em> (vobj scl)</code></span></td>
<!-- --><td><code>vobj[i] *= scl</code>, returns vobj.</td></tr>
<!-- -->
<!-- vct-set! -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="vctset">vct-set!</a></em> (vobj pos val)</code></span></td>
<!-- --><td>set vobj's data at location pos to val (same as <code>(set! (vct-ref ...) val)</code>).</td></tr>
<!-- -->
<!-- vct-subtract! -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="vctsubtract">vct-subtract!</a></em> (vobj1 vobj2)</code></span></td>
<!-- --><td><code>vobj1[i] -= vobj2[i]</code>, returns vobj1.</td></tr>
<!-- -->
<!-- vct->list -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="vct2list">vct-&gt;list</a></em> (v1)</code></span></td>
<!-- --><td>return list with elements of vct <i>v1</i></td></tr>
<!-- -->
<!-- vct->samples -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="vct2samples">vct-&gt;samples</a></em> (samp samps data <i>snd chn</i>)</code></span></td>
<!-- --><td>synonym for <a href="#sndsetsamples">set-samples</a>.</td></tr>
<!-- -->
<!-- vct->sound-data -->
<!-- --><tr><td><span class=defbox><code><em class=def>vct-&gt;sound-data</em> (vobj sdobj chan)</code></span></td>
<!-- --><td>place vct data in sound-data</td></tr>
<!-- -->
<!-- vct->sound-file -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="vct2soundfile">vct-&gt;sound-file</a></em> (fd vobj vals)</code></span></td>
<!-- --><td>write <i>vals</i> floats from <i>vobj</i> to <i>fd</i>.</td></tr>
<!-- -->
<!-- vcts-do! -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="vctsdo">vcts-do!</a></em> (vobj... proc)</code></span></td>
<!-- --><td><code>vobj[vi][i] = (nth vi (funcall proc num i))</code>.</td></tr>
<!-- -->
<!-- vcts-map! -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="vctsmap">vcts-map!</a></em> (vobj... proc)</code></span></td>
<!-- --><td><code>vobj[vi][i] = (nth vi (funcall proc num))</code>.</td></tr>
<!-- -->
<!-- vector-&gt;vct -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndvector2vct">vector-&gt;vct</a></em> (vect)</code></span></td>
<!-- --><td>return vct object with elements of vector <i>vect</i></td></tr>
<!-- -->
<!-- vct-subseq -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="vctsubseq">vct-subseq</a></em> (vobj start <i>end new-vobj</i>)</code></span></td>
<!-- --><td>return vct (new-vobj) with vobj[start..end].</td></tr>
<!-- -->
<!-- --></table>

<p>Many of the functions described below can take a vct object as an argument; 
there are also several functions that create and fill vcts with data:</p>
<pre>
  <a href="#sndregionsamples2vct">region-samples-&gt;vct</a> (<i>samp samps reg chn v</i>)
  <a href="#samples2vct">samples-&gt;vct</a> (<i>samp samps snd chn v pos</i>)  
  <a href="#transformsamples2vct">transform-samples-&gt;vct</a> (<i>snd chn v</i>)
</pre>
<p>There are four slightly
unusual functions in this family: <i>vct-map!</i>, <i>vct-do!</i>, <i>vcts-map!</i>, and <i>vcts-do!</i>.
These are essentially providing a do-loop over one or more vcts, calling some 
Scheme function to get the values to assign into the vct(s).  For example</p>
<pre>
  (vct-map! out-data (lambda () 
                       (convolve cnv (lambda (dir) 
                                       (next-sample sf)))))
</pre>
<p>in the cnvtest function in <a href="sndscm.html#exampdoc">examp.scm</a> is calling the convolve generator and
assigning the result to each successive member of the out-data vct.  <i>vct-do!</i>
is the same as <i>vct-map!</i> except that the called function should take one
argument, the current loop index.  Similarly, <i>vcts-map!</i> and <i>vcts-do!</i>
take any number of vcts, followed by a trailing function, and map the function's
results (assumed to be a list that matches the current number of vcts) into the
vct array.  In the map! case, the function takes one argument, the current number
of vcts awaiting values; in the do! case, it takes two arguments, the vct
number and the current loop index.  For example, we could rewrite the cnvtest
function to take stereo sounds:
</p>
<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(define cnvtest
  (lambda (snd0 snd1 amp0 amp1)
    (if (and (= (channels snd0) 2)
	     (= (channels snd1) 2))
	(let* ((flt-len (frames snd0))
	       (total-len (+ flt-len (frames snd1)))
	       (cnv10 (make-convolve :filter (samples-&gt;vct 0 flt-len snd0 0)))
	       (cnv11 (make-convolve :filter (samples-&gt;vct 0 flt-len snd0 1)))
	       (sf10 (make-sample-reader 0 snd1 0))
	       (sf11 (make-sample-reader 0 snd1 1))
	       (out-data10 (make-vct total-len))
	       (out-data11 (make-vct total-len)))
	  (<em class=red>vcts-map!</em> out-data10 out-data11 
		     (lambda (num)
		       (list
			(convolve cnv10 (lambda (dir) (next-sample sf10)))
			(convolve cnv11 (lambda (dir) (next-sample sf11))))))
	  (free-sample-reader sf10)
	  (free-sample-reader sf11)
	  (vct-scale! out-data10 amp0)
	  (vct-scale! out-data11 amp1)
	  (vct-&gt;samples 0 total-len out-data10 snd1 0)
	  (vct-&gt;samples 0 total-len out-data11 snd1 1))
	(snd-print "oops -- need stereo input"))))
</pre></td></tr></table>

<p>We can use vcts to write new sound files:</p>
<pre>
  <em class=def>open-sound-file</em> (name chans srate comment)   ; returns fd
  <em class=def>vct-&gt;sound-file</em> (fd vct vals)                ; writes vals floats to fd
  <em class=def>close-sound-file</em> (fd vals)
</pre>
<p>After opening the file, loop through the data calling samples-&gt;vct, deal with the
vct data as desired, write the samples to the file via vct-&gt;sound-file, then
when finished, close-sound-file.  If the new data is to replace the old,
call (set! (samples...) data) with the new sound file's name; otherwise call insert-samples.
</p>
<p>If you have Guile 1.4.1 or later, it's possible to access a vct object's
elements with the syntax (obj index), equivalent to (vct-ref obj index).
This is using a feature called "applicable smobs" in Guile; I may extend
it to handle vct-set! and perhaps others: sound-data objects, the various
sample readers (returning the current sample?), and so on.  The clm generators
can now use this syntax:
</p>
<pre>
  &gt;<em class=typing>(define hi (make-oscil 440.0))</em>
  <em class=listener>#&lt;unspecified&gt;</em>
  &gt;<em class=typing>(hi)</em>
  <em class=listener>0.0</em>
  &gt;<em class=typing>(oscil hi)</em>
  <em class=listener>0.125050634145737</em>
</pre>
<p>It's no accident that the generator's type (i.e. oscil or whatever)
is hidden here.  For example, we can make a generator that is either
an oscil or a sawtooth-wave:
</p>
<pre>
  &gt;<em class=typing>(define sine-or-sawtooth
     (lambda (sine)
        (let ((gen ((if sine make-oscil make-sawtooth-wave) 440.0)))
           (lambda (fm)
              (gen fm)))))</em>
  <em class=listener>#&lt;unspecified&gt;</em>
  &gt;<em class=typing>(define osc (sine-or-sawtooth #t))</em>
  <em class=listener>#&lt;unspecified&gt;</em>
  &gt;<em class=typing>(osc 0.0)</em>
  <em class=listener>0.0</em>
  &gt;<em class=typing>(osc 0.0)</em>
  <em class=listener>0.125050634145737</em>
</pre>

<br>
<span class=cbox><h3><A NAME="sndsounddata">Sound-data and Sndlib</a></h3></span>

<p>Another sound data object is the sound-data array used in Sndlib.</p>

<!-- -------------------------------- SOUND-DATA TABLE -------------------------------- -->
<!-- -->
<!-- --><table border=0 cellspacing=5>
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def>make-sound-data</em> (chans frames)</code></span></td>
<!-- --><td>return a sound-data object with <i>chans</i> arrays, each of length <i>frames</i></td></tr>
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def>sound-data-ref</em> (obj chan frame)</code></span></td>
<!-- --><td>return (as a float) the sample in channel <i>chan</i> at location <i>frame</i></td></tr>
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def>sound-data-set!</em> (obj chan frame val)</code></span></td>
<!-- --><td>set <i>obj</i>'s sample at <i>frame</i> in <i>chan</i> to (the float) <i>val</i></td></tr>
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def>sound-data?</em> (obj)</code></span></td>
<!-- --><td>#t if <i>obj</i> is of type sound-data</td></tr>
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def>sound-data-length</em> (obj)</code></span></td>
<!-- --><td>length of each channel of data in <i>obj</i></td></tr>
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def>sound-data-chans</em> (obj)</code></span></td>
<!-- --><td>number of channels of data in <i>obj</i></td></tr>
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def>sound-data-&gt;vct</em> (sdobj chan vobj)</code></span></td>
<!-- --><td>place sound-data channel data in vct </td></tr>
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def>vct-&gt;sound-data</em> (vobj sdobj chan)</code></span></td>
<!-- --><td>place vct data in sound-data</td></tr>
<!-- --></table>

<p>In fact, all of the underlying sound library (<a href="sndlib.html">Sndlib</a>)
functions are available, as well as all of (<a href="grfsnd.html#clmfuncs">CLM</a>).
The most important Sndlib functions for Snd are:</p>

<!-- -------------------------------- SNDLIB TABLE -------------------------------- -->
<!-- -->
<!-- --><table border=0 cellspacing=5>
<!-- -->
<!-- mus-audio-close -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="musaudioclose">mus-audio-close</a></em> (line)</code></span></td>
<!-- --><td>close audio port <i>line</i></td></tr>
<!-- -->
<!-- mus-audio-describe -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="describeaudiostate">mus-audio-describe</a></em> ()</code></span></td>
<!-- --><td>describe audio hardware state (in help window)</td></tr>
<!-- -->
<!-- mus-audio-error -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="audioerror">mus-audio-error</a></em> ()</code></span></td>
<!-- --><td>returns error code indicated by preceding audio call</td></tr>
<!-- -->
<!-- mus-audio-error-name -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="audioerror-name">mus-audio-error-name</a></em> (er)r</code></span></td>
<!-- --><td>string decription of error code</td></tr>
<!-- -->
<!-- mus-audio-mixer-read -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def>
<!-- --><a name="musaudiomixerread">mus-audio-mixer-read</a></em> (device field channel vals)</code></span></td>
<!-- --></tr><tr><td></td>
<!-- --><td>read current state of <i>device</i>'s <i>field</i>:
<!-- --></td></tr>
<!-- --><tr><td colspan=2>
<!-- --><pre>
<!-- -->  mus-audio-amp       mus-audio-srate    mus-audio-channel mus-audio-format
<!-- -->  mus-audio-imix      mus-audio-igain    mus-audio-reclev  mus-audio-pcm 
<!-- -->  mus-audio-ogain     mus-audio-line     mus-audio-synth   mus-audio-bass
<!-- -->  mus-audio-direction mus-audio-port     mus-audio-pcm2    mus-audio-treble
<!-- -->  mus-audio-samples-per-channel
<!-- --></pre>
<!-- --></td></tr>
<!-- mus-audio-mixer-write -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def>
<!-- --><a name="musaudiomixerwrite">mus-audio-mixer-write</a></em> (device field channel vals)</code></span></td>
<!-- --></tr><tr><td></td>
<!-- --><td>set state of <i>device</i>'s <i>field</i>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->;;; here we get the microphone volume, then set it to .5
<!-- -->(define vals (make-vector 32))
<!-- -->(mus-audio-mixer-read mus-audio-microphone mus-audio-amp 0 vals)
<!-- -->(vector-ref vals 0)
<!-- -->(vector-set! vals 0 .5)
<!-- -->(mus-audio-mixer-write mus-audio-microphone mus-audio-amp 0 vals)
<!-- --></pre></td></tr></table></td></tr>
<!-- -->
<!-- mus-audio-open-input -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def>
<!-- --><a name="musaudioopeninput">mus-audio-open-input</a></em> (device srate chans format bufsize)</code></span></td>
<!-- --></tr><tr><td></td>
<!-- --><td>open audio port <i>device</i> ready for input.  <i>device</i> is one of:
<!-- --></td></tr>
<!-- --><tr><td colspan=2>
<!-- --><pre>
<!-- -->  mus-audio-default    mus-audio-duplex-default mus-audio-line-out
<!-- -->  mus-audio-microphone mus-audio-speakers       mus-audio-dac-out    
<!-- -->  mus-audio-aes-in     mus-audio-digital-in     mus-audio-digital-out
<!-- -->  mus-audio-aes-out    mus-audio-dac-filter     mus-audio-mixer
<!-- -->  mus-audio-line2      mus-audio-line3          mus-audio-aux-input 
<!-- -->  mus-audio-line-in    mus-audio-aux-output     mus-audio-adat-in
<!-- -->  mus-audio-adat-out   mus-audio-line1          mus-audio-cd 
<!-- -->  mus-audio-spdif-in   mus-audio-spdif-out
<!-- --></pre>
<!-- --></td></tr>
<!-- -->
<!-- mus-audio-open-output -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def>
<!-- --><a name="musaudioopenoutput">mus-audio-open-output</a></em> (device srate chans format bufsize)</code></span></td>
<!-- --></tr><tr><td></td>
<!-- --><td>open audio port <i>device</i> ready for output</td></tr>
<!-- -->
<!-- mus-audio-outputs -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def>
<!-- --><a name="sndaudiooutputs">mus-audio-outputs</a></em> (speakers headphones line-out)</code></span></td>
<!-- --></tr><tr><td></td>
<!-- --><td>(Sun only) set active outputs</td></tr>
<!-- -->
<!-- mus-audio-read -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="musaudioread">mus-audio-read</a></em> (line sdata frames)</code></span></td>
<!-- --><td>read <i>frames</i> of data into sound-data object <i>sdata</i> from port <i>line</i></td></tr>
<!-- -->
<!-- mus-audio-write -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="musaudiowrite">mus-audio-write</a></em> (line sdata frames)</code></span></td>
<!-- --></tr><tr><td></td><td>write <i>frames</i> of data from sound-data object <i>sdata</i> to port <i>line</i></td></tr>
<!-- -->
<!-- mus-data-format-name -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="soundformatname">mus-data-format-name</a></em> (format)</code></span></td>
<!-- --><td>e.g. "16-bit big endian linear", <i>format</i> an integer, some of which have names (mus-out-format is the fastest):</td></tr>
<!-- --><tr><td colspan=2><pre>
<!-- -->  mus-bshort   mus-lshort   mus-mulaw   mus-alaw   mus-byte  
<!-- -->  mus-lfloat   mus-bint     mus-lint    mus-b24int mus-l24int
<!-- -->  mus-ubshort  mus-ulshort  mus-ubyte   mus-bfloat mus-bdouble 
<!-- -->  mus-ldouble
<!-- --></pre></td></tr>
<!-- -->
<!-- mus-expand-filename -->
<!-- --><tr><td valign=top><span class=defbox><code><em class=def><a name="musexpandfilename">mus-expand-filename</a></em> (name)</code></span></td>
<!-- --><td>expands <i>name</i> into its 'absolute' pathname; that is, it replaces '~' with the current home directory,
<!-- -->and whatever else seems appropriate.</td></tr>
<!-- -->
<!-- mus-header-type-name -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="soundtypename">mus-header-type-name</a></em> (type)</code></span></td>
<!-- --><td>e.g. "AIFF", <i>type</i> is an integer, some of which have names:</td></tr>
<!-- --><tr><td colspan=2><pre>
<!-- -->  mus-next  mus-aifc  mus-riff  mus-nist  mus-raw  mus-ircam  mus-aiff
<!-- --></pre></td></tr>
<!-- -->
<!-- mus-sound-chans -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="soundchans">mus-sound-chans</a></em> (filename)</code></span></td>
<!-- --><td>number of channels (samples are interleaved)</td></tr>
<!-- -->
<!-- mus-sound-close-input -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="mussoundcloseinput">mus-sound-close-input</a></em> (fd)</code></span></td>
<!-- --><td>close sound file</td></tr>
<!-- -->
<!-- mus-sound-close-output -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="mussoundcloseoutput">mus-sound-close-output</a></em> (fd bytes)</code></span></td>
<!-- --><td>close sound file and update its length indication, if any</td></tr>
<!-- -->
<!-- mus-sound-comment -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="soundcomment">mus-sound-comment</a></em> (filename)</code></span></td>
<!-- --><td>header comment, if any</td></tr>
<!-- -->
<!-- mus-sound-data-format -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sounddataformat">mus-sound-data-format</a></em> (filename)</code></span></td>
<!-- --><td>data format (e.g. <i>mus-bshort</i>)</td></tr>
<!-- -->
<!-- mus-sound-data-location -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sounddatalocation">mus-sound-data-location</a></em> (filename)</code></span></td>
<!-- --><td>location of first sample (bytes)</td></tr>
<!-- -->
<!-- mus-sound-duration -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="soundduration">mus-sound-duration</a></em> (filename)</code></span></td>
<!-- --><td>duration of sound in seconds</td></tr>
<!-- -->
<!-- mus-sound-frames -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="soundframes">mus-sound-frames</a></em> (filename)</code></span></td>
<!-- --><td>frames of sound according to header (can be incorrect)</td></tr>
<!-- -->
<!-- mus-sound-header-type -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="soundheadertype">mus-sound-header-type</a></em> (filename)</code></span></td>
<!-- --><td>header type (e.g. <i>mus-aifc</i>)</td></tr>
<!-- -->
<!-- mus-sound-length -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="soundlength">mus-sound-length</a></em> (filename)</code></span></td>
<!-- --><td>true file length (bytes)</td></tr>
<!-- -->
<!-- mus-sound-loop-info -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="soundloopinfo">mus-sound-loop-info</a></em> (filename)</code></span></td>
<!-- --><td>loop info (for an example, see <a href="sndscm.html#exampdoc">examp.scm</a> mark-loops)</td></tr>
<!-- -->
<!-- mus-sound-max-amp -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="mussoundmaxamp">mus-sound-max-amp</a></em> (filename)</code></span></td>
<!-- --><td>returns a vector of max amps and locations thereof.  The corresponding set! procedure is mus-sound-set-max-amp (this
<!-- -->affects only the sndlib table of sound file info, not the sound file itself).</td></tr>
<!-- -->
<!-- mus-sound-max-amp-exists -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="mussoundmaxampexists">mus-sound-max-amp-exists</a></em> (filename)</code></span></td>
<!-- --></tr><tr><td></td><td>returns #t if the sound's max amps are already available.</td></tr>
<!-- -->
<!-- mus-sound-open-input -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="mussoundopeninput">mus-sound-open-input</a></em> (filename)</code></span></td>
<!-- --><td>open filename (a sound file) returning an integer ("fd" below)</td></tr>
<!-- -->
<!-- mus-sound-open-output -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def>
<!-- --><a name="mussoundopenoutput">mus-sound-open-output</a></em> (filename srate chans data-format header-type comment)</code></span></td>
<!-- --></tr><tr><td></td>
<!-- --><td>create a new sound file with the indicated attributes, return "fd"</td></tr>
<!-- -->
<!-- mus-sound-read -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="mussoundread">mus-sound-read</a></em> (fd beg end chans sdata)</code></span></td>
<!-- --></tr><tr><td></td>
<!-- --><td>read data from sound file <i>fd</i> loading the data array from beg
<!-- -->to end. <i>sdata</i> is a sound-data object that should be able to
<!-- -->accommodate the read</td></tr>
<!-- -->
<!-- mus-sound-reopen-output -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def>
<!-- --><a name="mussoundreopenoutput">mus-sound-reopen-output</a></em> (filename chans data-format header-type data-location)</code></span></td>
<!-- --></tr><tr><td></td>
<!-- --><td>reopen (without disturbing) filename, ready to be written</td></tr>
<!-- -->
<!-- mus-sound-report-cache -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="mussoundreportcache">mus-sound-report-cache</a></em> (file)</code></span></td>
<!-- --><td>prints the current sound header data table to the file given or stdout if none is specified.</td></tr>
<!-- -->
<!-- mus-sound-samples -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="soundsamples">mus-sound-samples</a></em> (filename)</code></span></td>
<!-- --><td>samples of sound according to header (can be incorrect)</td></tr>
<!-- -->
<!-- mus-sound-seek -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="mussoundseek">mus-sound-seek</a></em> (fd offset origin)</code></span></td>
<!-- --><td>complicated -- see mus-sound-seek above</td></tr>
<!-- -->
<!-- mus-sound-seek-frame -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="mussoundseekframe">mus-sound-seek-frame</a></em> (fd frame)</code></span></td>
<!-- --><td>move to <i>frame</i> in sound file <i>fd</i></td></tr>
<!-- -->
<!-- mus-sound-srate -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="soundsrate">mus-sound-srate</a></em> (filename)</code></span></td>
<!-- --><td>sampling rate</td></tr>
<!-- -->
<!-- mus-sound-write -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="mussoundwrite">mus-sound-write</a></em> (fd beg end chans sdata)</code></span></td>
<!-- --></tr><tr><td></td>
<!-- --><td>write data to sound file <i>fd</i></td></tr>
<!-- -->
<!-- mus-sound-write-date -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="soundwritedate">mus-sound-write-date</a></em> (filename)</code></span></td>
<!-- --><td>sound's write date:
<!-- --></td></tr><tr><td colspan=2><pre>
<!-- -->    :<em class=typing>(strftime "%d-%b %H:%M %Z" (localtime (mus-sound-write-date "oboe.snd")))</em>
<!-- -->    <em class=listener>"18-Oct 06:56 PDT"</em>
<!-- --></pre></td></tr>
<!-- -->
<!-- set-oss-buffers -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="setossbuffers">set-oss-buffers</a></em> (num size)</code></span></td>
<!-- --><td>in Linux (OSS) sets the number and size of the OSS "fragments"</td></tr>
<!-- -->
<!-- --></table>

<p>See <a href="sndlib.html">Sndlib</a> for more information on these functions. When called from Snd, these
throw 'mus-error upon encountering an error, rather than returning -1 like the underlying sndlib functions.
</p>


<br>
<span class=cbox><h3><A NAME="samplereaders">Sample-readers</a></h3></span>
<p>
The simplest data access function is <i>sample</i>, returning the sample at
a given position in a sound's channel.  This simplicity, however, comes at
a price in computation:  if the desired sample is not in Snd's
in-core (already loaded) view of the data, it has to access the sample,
which can sometimes involve opening, reading, and closing a sound file.
The result is that in some cases, <i>sample</i> will bring your function
to a grinding halt.  There are two alternatives, leaving aside the scanning
and mapping functions mentioned below.  One involves keeping the buffer of
data around explicitly (<i>samples-&gt;vct</i>), and the other involves the
use of a special object known as a <i>sample-reader</i>.  The former is
better if you're jumping around in the data, the latter if you're treating
it generally as a stream of samples, read in order.  The <a href="grfsnd.html#expsrc">expsrc</a>
function below shows how to use <i>samples-&gt;vct</i>; there are numerous
examples of <i>sample-readers</i> in <a href="sndscm.html#exampdoc">examp.scm</a>.  The basic idea is that
you create a reader (via <i>make-sample-reader</i> or <i>make-region-sample-reader</i>) giving it the start position, the sound and channel
to read, and the initial read direction, then get data via <i>next-sample</i> and
<i>previous-sample</i>, finally closing the reader with <i>free-sample-reader</i>.
It is not strictly necessary to call <i>free-sample-reader</i> yourself; the
garbage collector will take care of it if you forget to.
A standard way to add something to the current
data is:</p>
<pre>
   ...
   (sf (make-sample-reader start))
   ...
   (vct-map! out-data (lambda () (+ (next-sample sf) &lt;new stuff&gt;))
   (free-sample-reader sf)
   (vct-&gt;samples start len out-data)
</pre>
<p>This is largely equivalent to the clm call</p>
<pre>
  (outa (+ start i) &lt;new-stuff&gt;)
</pre>
<p>but is applied as an edit to the current state in Snd.  In general, slow
things in Guile are vector references, floating point operations, and
any do loop executed on a per-sample basis.  In most cases, these can
be collected into vct operations or through the use of functions like
formant-bank.
</p>

<p>There is a similar set of functions giving access to the mix data.
<i>make-mix-sample-reader</i> returns a mix reader for the desired mix,
<i>mix-sample-reader?</i> returns #t if its argument in a mix sample reader,
<i>next-mix-sample</i> returns the next sample (before it is mixed into
the output), and <i>free-mix-sample-reader</i> releases a reader.
Mixes can be collected into tracks, so there are also <i>make-track-sample-reader</i>, <i>track-sample-reader?</i>,
<i>next-track-sample</i>, and <i>free-track-sample-reader</i>.
As mentioned above, the mix-sample-reader refers to the mix data after
it has been processed through its control panel.  The original (possibly
edited) sound can be accessed by a normal sample-reader.
</p>

<!-- -------------------------------- SAMPLE-READER TABLE -------------------------------- -->
<!-- -->
<!-- --><table border=0 cellspacing=8>
<!-- -->
<!-- free-mix-sample-reader -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="freemixsamplereader">free-mix-sample-reader</a></em> (obj)</code></span></td>
<!-- --></tr><tr><td></td>
<!-- --><td>release <a href="#samplereaders">mix-sample-reader</a> <i>obj</i>.</td></tr>
<!-- -->
<!-- free-sample-reader -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="freesamplereader">free-sample-reader</a></em> (obj)</code></span></td>
<!-- --><td>release <a href="#samplereaders">sample-reader</a> <i>obj</i>.</td></tr>
<!-- -->
<!-- free-track-sample-reader -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="freetracksamplereader">free-track-sample-reader</a></em> (obj)</code></span></td>
<!-- --></tr><tr><td></td>
<!-- --><td>release <a href="#samplereaders">track-sample-reader</a> <i>obj</i>.</td></tr>
<!-- -->
<!-- make-mix-sample-reader -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="makemixsamplereader">make-mix-sample-reader</a></em> (mix)</code></span></td>
<!-- --></tr><tr><td></td>
<!-- --><td>create a <a href="#samplereaders">mix-sample-reader</a> object reading <i>mix</i></td></tr>
<!-- -->
<!-- mix-sample-reader? -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="mixsamplereaderQ">mix-sample-reader?</a></em> (obj)</code></span></td>
<!-- --><td>#t if <i>obj</i> is a <a href="#samplereaders">mix-sample-reader</a>.</td></tr>
<!-- -->
<!-- make-region-sample-reader -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="makeregionsamplereader">make-region-sample-reader</a></em> (<i>start reg chn dir</i>)</code></span></td>
<!-- --></tr><tr><td></td>
<!-- --><td>create a <a href="#samplereaders">sample-reader</a> object reading region <i>reg</i>'s channel <i>chn</i>
<!-- --></td></tr>
<!-- -->
<!-- make-sample-reader -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="makesamplereader">make-sample-reader</a></em> (<i>start snd chn dir pos</i>)</code></span></td>
<!-- --></tr><tr><td></td>
<!-- --><td>
<!-- -->create a <a href="#samplereaders">sample-reader</a> object reading <i>snd</i>'s channel <i>chn</i>
<!-- -->starting at sample <i>start</i> with initial read direction <i>dir</i> 
<!-- -->(1=forward, -1=backward).  <i>pos</i> is the edit history position to read 
<!-- -->(defaults to current position). One use of <i>pos</i> is to get the difference 
<!-- -->between two edits:
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(define snd-diff
<!-- -->  (lambda () ;assume mono, get diff between current state and previous
<!-- -->    (let* ((index (selected-sound))
<!-- -->           (edit-pos (edit-position index))
<!-- -->           (previous-edit (<em class=red>make-sample-reader</em> 0 0 index 1 (1- edit-pos))))
<!-- -->      (lambda (x)
<!-- -->        (- x (next-sample previous-edit)) #f))))
<!-- -->
<!-- -->(map-chan (snd-diff))
<!-- --></pre></td></tr></table></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- --><i>snd</i> can also be a filename (a string); in this way a sample-reader
<!-- -->can read external sounds without going to the trouble of loading them into Snd.
<!-- --><br>
<!-- --><code>(define reader (make-sample-reader 100 "oboe.snd"))</code>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- make-track-sample-reader -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="maketracksamplereader">make-track-sample-reader</a></em> (track samp snd chn)</code></span></td>
<!-- --></tr><tr><td></td>
<!-- --><td>create a <a href="#samplereaders">track-sample-reader</a> object reading <i>track</i></td></tr>
<!-- -->
<!-- next-mix-sample -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="nextmixsample">next-mix-sample</a></em>   (obj)</code></span></td>
<!-- --><td>return next sample read by <a href="#samplereaders">mix-sample-reader</a> <i>obj</i>.</td></tr>
<!-- -->
<!-- next-sample -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="nextsample">next-sample</a></em>       (obj)</code></span></td>
<!-- --><td>return next sample read by <a href="#samplereaders">sample-reader</a> <i>obj</i>.</td></tr>
<!-- -->
<!-- next-track-sample -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="nexttracksample">next-track-sample</a></em> (obj)</code></span></td>
<!-- --><td>return next sample read by <a href="#samplereaders">track-sample-reader</a> <i>obj</i>.</td></tr>
<!-- -->
<!-- previous-sample -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="previoussample">previous-sample</a></em>   (obj)</code></span></td>
<!-- --><td>return previous sample in stream read by <a href="#samplereaders">sample-reader</a> <i>obj</i>.</td></tr>
<!-- -->
<!-- sample-reader-at-end? -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="samplereaderatendQ">sample-reader-at-end?</a></em> (obj)</code></span></td>
<!-- --><td>#t if <a href="#samplereaders">sample-reader</a> <i>obj</i> is at EOF.</td></tr>
<!-- -->
<!-- sample-reader? -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="samplereaderQ">sample-reader?</a></em>    (obj)</code></span></td>
<!-- --><td>#t if <i>obj</i> is a <a href="#samplereaders">sample-reader</a>.</td></tr>
<!-- -->
<!-- track-sample-reader? -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="tracksamplereaderQ">track-sample-reader?</a></em> (obj)</code></span></td>
<!-- --><td>#t if <i>obj</i> is a <a href="#samplereaders">track-sample-reader</a>.</td></tr>
<!-- -->
<!-- --></table>

<p>The <i>next-sample</i> functions can be omitted: <code>(reader)</code> is the same as <code>(next-sample reader)</code>.
</p>

<br>
<span class=cbox><h3><A NAME="sndmarks">Marks</a></h3></span>

<p>A mark is an object that refers to a particular sample.
Each mark has an associated sample number (<b>mark-sample</b>), name (<b>mark-name</b>), sync value (<b>mark-sync</b>), and
a globally unique id number (returned by <b>find-mark</b> or <b>add-mark</b>, for example).  
</p>

<!-- -------------------------------- MARKS TABLE -------------------------------- -->
<!-- -->
<!-- --><table border=0 cellspacing=8>
<!-- -->
<!-- add-mark -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndaddmark">add-mark</a></em> (sample <i>snd chn</i>)</code></span></td>
<!-- --><td>add mark at <i>sample</i>, returning mark id.
<!-- --></td></tr>
<!-- -->
<!-- backward-mark -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndbackwardmark">backward-mark</a></em> (<i>count snd chn</i>)</code></span></td>
<!-- --><td>move back <i>count</i> marks (C-j).
<!-- --></td></tr>
<!-- -->
<!-- delete-mark -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="snddeletemark">delete-mark</a></em> (<i>id</i>)</code></span></td>
<!-- --><td>delete mark <i>id</i> (- C-m).
<!-- --></td></tr>
<!-- -->
<!-- delete-marks -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="snddeletemarks">delete-marks</a></em> (<i>snd chn</i>)</code></span></td>
<!-- --><td>delete all marks in <i>snd</i>'s channel <i>chn</i>
<!-- --></td></tr>
<!-- -->
<!-- find-mark -->
<!-- -->
<!-- --><tr><td valign=top><span class=defbox><code><em class=def><a name="sndfindmark">find-mark</a></em> (samp <i>snd chn</i>)</code></span></td>
<!-- --><td>return identifier of mark at sample <i>samp</i> or #f if none found.
<!-- -->This identifier is used in calls such as <a href="#sndmarksample">mark-sample</a>.  Since marks
<!-- -->can move around during editing, a unique 'tag' is needed to refer to a 
<!-- -->particular mark. <i>samp</i> can also be a string; in this case <i>find-mark</i> 
<!-- -->looks for a mark of that name.
<!-- --></td></tr>
<!-- -->
<!-- forward-mark -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndforwardmark">forward-mark</a></em> (<i>count snd chn</i>)</code></span></td>
<!-- --><td>move forward <i>count</i> marks (C-j).
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a href="#markclickhook">mark-click-hook</a></em> (id)</code></span></td>
<!-- --><td>called when a mark is clicked, return #t to squelch message.
<!-- --></td></tr>
<!-- -->
<!-- mark-name -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndmarkname">mark-name</a></em> (<i>id</i>)</code></span></td>
<!-- --><td>name of mark <i>id</i>; also (set! (mark-name id) name).
<!-- --></td></tr>
<!-- -->
<!-- mark-sample -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndmarksample">mark-sample</a></em> (<i>id pos</i>)</code></span></td>
<!-- --><td>position of mark <i>id</i> at edit history position <i>pos</i>; also (set! (mark-sample id) samp)
<!-- --></td></tr>
<!-- -->
<!-- mark-sync -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndmarksync">mark-sync</a></em> (<i>id</i>)</code></span></td>
<!-- --><td>mark <i>id</i>'s sync value; also (set! (mark-sync id) sync).
<!-- --></td></tr>
<!-- -->
<!-- mark-sync-max -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndmarksyncmax">mark-sync-max</a></em> ()</code></span></td>
<!-- --><td>max mark sync value seen so far.
<!-- --></td></tr>
<!-- -->
<!-- mark->sound -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="mark2sound">mark-&gt;sound</a></em> (<i>id</i>)</code></span></td>
<!-- --><td>sound and channel that hold mark <i>id</i>.
<!-- --></td></tr>
<!-- -->
<!-- marks -->
<!-- -->
<!-- --><tr><td valign=top><span class=defbox><code><em class=def><a name="emarks">marks</a></em> (<i>snd chn pos</i>)</code></span></td>
<!-- --><td>list of mark ids in <i>snd</i>'s channel <i>chn</i> at edit history position <i>pos</i>.
<!-- -->If <i>chn</i> and <i>pos</i> are omitted, a list of lists is returned, 
<!-- -->each inner list representing a channel of <i>snd</i>.  If <i>snd</i> is 
<!-- -->also omitted, a list of lists of lists is returned, representing
<!-- -->each sound and its channels.
<!-- --></td></tr>
<!-- -->
<!-- mark? -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndmarkok">mark?</a></em> (<i>id</i>)</code></span></td>
<!-- --><td>#t if mark <i>id</i> is active.
<!-- --></td></tr>
<!-- -->
<!-- save-marks -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndsavemarks">save-marks</a></em> (<i>snd</i>)</code></span></td>
<!-- --><td>save <i>snd</i>'s marks, writing a file &lt;name&gt;.marks (returns file name).
<!-- --></td></tr>
<!-- -->
<!-- syncd-marks -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="syncdmarks">syncd-marks</a></em> (sync)</code></span></td>
<!-- --><td>list of marks (ids) that share sync.
<!-- --></td></tr>
<!-- -->
<!-- --></table>

<p>The sync value is very similar to
the mix track number or the sound sync field; it provides a way to group marks for simultaneous
changes.  Marks that share the same sync value (if not 0), move together when any one of them is
dragged, play together, etc.  <b>mark-&gt;sound</b> provides a way to go from a mark id to the sound and
channel that hold that mark; the inverse function is <b>marks</b>.  To find which marks share a given
sync value, use <b>syncd-marks</b>; to find an unused sync value use <b>mark-sync-max</b>. </p>

<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(define (move-syncd-marks sync diff)
  (map (lambda (m) 
         (set! (mark-sample m) (+ (mark-sample m) diff))) 
       (<em class=red>syncd-marks</em> sync)))
</pre></td></tr></table>

<p><b>marks</b>
without any argument, or with just a sound index returns a list of lists; each inner list is the list
of current marks (ids) active in that channel, ordered by sample number.  If the channel argument is
specified, <b>marks</b> returns just the list of mark ids.  If the edit history position is given,
the list of ids reflects the mark list at that time in the edit history.  So, for example, the
following procedure returns a list describing the history of a mark over the course of
editing a channel, each list entry being the mark sample at that time or #f if the mark was not active:
</p>

<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(define (describe-mark id)
  (let ((mark-home (mark-&gt;sound id)))
    (if (eq? mark-home 'no-such-mark)
	;; not an active mark, so go scrounging for it
	;;   we're looking at every edit of every channel
	(do ((i 0 (1+ i)))
	    ((or (= i (max-sounds)) (list? mark-home)))
	  (if (sound? i)
	      (do ((j 0 (1+ j)))
		  ((or (= j (channels i)) (list? mark-home)))
		(let* ((max-edits (apply + (edits i j))))
		  (do ((k 0 (1+ k)))
		      ((or (&gt; k max-edits) (list? mark-home)))
		    (if (member id (<em class=red>marks</em> i j k))
			(set! mark-home (list i j)))))))))
    (if (list? mark-home)
	(let* ((snd (car mark-home))
	       (chn (cadr mark-home))
	       (max-edits (apply + (edits snd chn)))
	       (descr '())
	       (header (list 'mark id 'sound snd (short-file-name snd) 'channel chn)))
	  (do ((i max-edits (1- i)))
	      ((&lt; i 0) descr)
	    (if (member id (<em class=red>marks</em> snd chn i))
		(set! descr (cons (mark-sample id i) descr))
		(set! descr (cons #f descr))))
	  (cons header descr))
	'cant-find-mark)))
</pre></td></tr></table>

<p>Marks that are syncd together can be used for insertions, and deletions, and can
set arbitrary groups of play points.  But it's a bit tedious to type (set! (mark-sync ...)...)
for each of the marks you want in the group.  The following uses the mark-clicked-hook
instead; you type (start-sync), then click the set of marks to sync, then (stop-sync).</p>

<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(define mark-sync-number 0)
(define (start-sync) (set! mark-sync-number (+ (mark-sync-max) 1)))
(define (stop-sync) (set! mark-sync-number 0))
(define (click-to-sync id) (set! (mark-sync id) mark-sync-number) #f)
(add-hook! mark-click-hook click-to-sync)
</pre></td></tr></table>

<p>Now control-click and drag one of them, and all move together deleting data, or
inserting zeros; or click the "play" triangle, and all play together starting from
the respective marks (which need not be in separate channels). See <a href="sndscm.html#marksdoc">marks.scm</a> for
more examples.</p>

<br>
<span class=cbox><h3><A NAME="sndmixes">Mixes</a></h3></span>

<p>A mix is an object that controls one channel of a sound mix.
All of the signal-processing functions can be applied to the mix data.
These variables affect all mixes:</p>

<table border=0 cellspacing=8>
<!-- mix-color -->

<tr><td valign=top><code><em class=def><a name="mixcolor">mix-color</a></em> dark gray</code></td>
<td>color of mix waveforms.<br>
The set form <code>(set! (mix-color) ...)</code> has an optional second argument; if you
want to set just a particular mix's color, give the id of the mix
here. That is, <code>(set! (mix-color) red)</code> sets all unselected mixes to
red; but <code>(set! (mix-color 3) red)</code> sets only mix #3 to be red. Similarly,
mix-color has an optional argument that can specify which mix's color
we want.</td></tr>
<!-- selected-mix-color -->

<tr><td><code><em class=def><a name="selectedmixcolor">selected-mix-color</a></em> light green</code></td><td>color of selected mix waveform.</td></tr>
<!-- mix-waveform-height -->

<tr><td><code><em class=def><a name="mixwaveformheight">mix-waveform-height</a></em> 20</code></td><td>Max height (pixels) of mix waveforms (see <a href="#showmixwaveforms">show-mix-waveforms</a>).</td></tr>
<!-- with-mix-tags -->

<tr><td><code><em class=def><a name="withmixtags">with-mix-tags</a></em> #t</code></td><td>If #f, don't make mixes editable.</td></tr>

<tr><td><code><a href="#showmixwaveforms">show-mix-waveforms</a></code></td><td></td></tr>
</table>

<p>Each mix object has a unique identifier used in the next set of functions to access
a particular mix object:</p>

<!-- -------------------------------- MIX FUNCTION TABLE -------------------------------- -->
<!-- -->
<!-- --><table border=0 cellspacing=8>
<!-- -->
<!-- backward-mix -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndbackwardmix">backward-mix</a></em> (<i>count snd chn</i>)</code></span></td>
<!-- --><td>move back <i>count</i> mix tags (C-x C-j).
<!-- --></td></tr>
<!-- -->
<!-- forward-mix -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndforwardmix">forward-mix</a></em> (<i>count snd chn</i>)</code></span></td>
<!-- --><td> move forward <i>count</i> mix tags (C-x C-j).
<!-- --></td></tr>
<!-- -->
<!-- mixes -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="mixes">mixes</a></em> (<i>snd chn pos</i>)</code></span></td>
<!-- --><td>list of currently active mixes in <i>snd</i>'s channel <i>chn</i> at history <i>pos</i>.
<!-- --></td></tr>
<!-- -->
<!-- mix-amp -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndmixamp">mix-amp</a></em> (<i>mix chan</i>)</code></span></td>
<!-- --><td>amplitude of <i>mix</i>'s channel <i>chan</i>.
<!-- --></td></tr>
<!-- -->
<!-- mix-amp-env -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndmixampenv">mix-amp-env</a></em> (<i>mix chan</i>)</code></span></td>
<!-- --><td>amplitude envelope of <i>mix</i>'s channel <i>chan</i>.
<!-- --></td></tr>
<!-- -->
<!-- mix-anchor -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndmixanchor">mix-anchor</a></em> (<i>mix</i>)</code></span></td>
<!-- --><td>anchor position (within the mix) of <i>mix</i>.
<!-- --></td></tr>
<!-- -->
<!-- mix-chans -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndmixchans">mix-chans</a></em> (<i>mix</i>)</code></span></td>
<!-- --><td>chans in <i>mix</i>.
<!-- --></td></tr>
<!-- -->
<!-- mix-length -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndmixlength">mix-length</a></em> (<i>mix</i>)</code></span></td>
<!-- --><td>length in samples of <i>mix</i>.
<!-- --></td></tr>
<!-- -->
<!-- mix-locked -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndmixlocked">mix-locked</a></em> (<i>mix</i>)</code></span></td>
<!-- --><td>#t if <i>mix</i> is locked.  
<!-- --></td></tr>
<!-- -->
<!-- mix-name -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndmixname">mix-name</a></em> (<i>mix</i>)</code></span></td>
<!-- --><td><i>mix</i>'s name.
<!-- --></td></tr>
<!-- -->
<!-- mix-position -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndmixposition">mix-position</a></em> (<i>mix</i>)</code></span></td>
<!-- --><td>position (sample number) of <i>mix</i>.
<!-- --></td></tr>
<!-- -->
<!-- mix-sound-channel -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndmixsoundchannel">mix-sound-channel</a></em> (<i>mix</i>)</code></span></td>
<!-- --><td>channel affected by <i>mix</i>.
<!-- --></td></tr>
<!-- -->
<!-- mix-sound-index -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndmixsoundindex">mix-sound-index</a></em> (<i>mix</i>)</code></span></td>
<!-- --><td>index of sound affected by <i>mix</i>.
<!-- --></td></tr>
<!-- -->
<!-- mix-speed -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndmixspeed">mix-speed</a></em> (<i>mix</i>)</code></span></td>
<!-- --><td>speed of <i>mix</i>.
<!-- --></td></tr>
<!-- -->
<!-- mix-tag-width -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndmixtagwidth">mix-tag-width</a></em> (<i>mix</i>)</code></span></td>
<!-- --><td>tag width in graph of <i>mix</i> (default 6)
<!-- --></td></tr>
<!-- -->
<!-- mix-tag-height -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndmixtagheighth">mix-tag-height</a></em> (<i>mix</i>)</code></span></td>
<!-- --><td>tag height in graph of <i>mix</i> (default 14)
<!-- --></td></tr>
<!-- -->
<!-- mix-tag-y -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndmixtagy">mix-tag-y</a></em> (<i>mix</i>)</code></span></td>
<!-- --><td>tag y offset in graph of <i>mix</i> (default 0)
<!-- --></td></tr>
<!-- -->
<!-- mix-track -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndmixtrack">mix-track</a></em> (<i>mix</i>)</code></span></td>
<!-- --><td>mix track (0 = none).  (mix-sync is a synonym for this).
<!-- --></td></tr>
<!-- -->
<!-- mix? -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndmixok">mix?</a></em> (<i>mix</i>)</code></span></td>
<!-- --><td>#t if <i>mix</i> is active.
<!-- --></td></tr>
<!-- -->
<!-- play-mix -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndplaymix">play-mix</a></em> (<i>mix</i>)</code></span></td>
<!-- --><td>play mix <i>mix</i>.
<!-- --></td></tr>
<!-- -->
<!-- play-track -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndplaytrack">play-track</a></em> (<i>track snd chn</i>)</code></span></td>
<!-- --><td>play track <i>track</i>. If snd is #t, play all associated chans.
<!-- --></td></tr>
<!-- -->
<!-- selected-mix -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndselectedmix">selected-mix</a></em> ()</code></span></td>
<!-- --><td>selected mix (-1 = none) -- set to select mix.
<!-- --></td></tr>
<!-- -->
<!-- --></table>

<p>As an example, say we have a mix active whose "id" is 123.</p>
<pre>
&gt;<em class=typing>(mix-chans 123)</em>
<em class=listener>1</em>
&gt;<em class=listener>(set! (mix-amp 123 0) .5)</em>
<em class=typing>.5</em>
</pre>
<p>This 
sets mix 123's channel 0 amplitude scaler to .5.
To mix data in such a way as to create an associated mix object:</p>

<!-- --><table border=0 cellspacing=8>
<!-- -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmix">mix</a></em> (file <i>samp in_chan snd chn with-mix-tags</i>)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->mix <i>file</i>'s channel <i>in_chan</i> starting at <i>samp</i> in <i>snd</i>'s channel <i>chn</i>.
<!-- -->if only the <i>file</i> argument is given, this is equivalent to the File menu's 
<!-- -->Mix option; the mix start sample in this case depends on the cursor location.
<!-- -->mix returns the id of the first channel's mix (subsequent channels simply 
<!-- -->increment this number). id of -1 means some error occurred.
<!-- -->If <i>with-mix-tags</i> is #f (default is #t), the data is simply
<!-- -->mixed without creating any mix tags [<em class=error>no-such-file</em>].
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmixregion">mix-region</a></em> (<i>samp reg snd chn</i>)</code></span></td></tr>
<!-- --><tr><td width=150></td><td>
<!-- -->Mix in region <i>reg</i> at sample <i>samp</i> (defaulting to the cursor sample), 
<!-- -->in <i>snd</i>'s channel <i>chn</i>.  mix-region returns the id of the first channel's 
<!-- -->mix (subsequent channels simply increment this number).
<!-- -->[<em class=error>no-such-region</em>]
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmixsound">mix-sound</a></em> (file start)</code></span></td>
<!-- --><tr><td></td><td>
<!-- -->mix <i>file</i> into selected sound at <i>start</i> [<em class=error>no-such-file</em>].
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="sndmixvct">mix-vct</a></em> (vct <i>beg snd chn with-mix-tags</i> origin)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->mix the contents of <i>vct</i> into <i>snd</i>'s channel <i>chn</i> starting at frame <i>beg</i>.
<!-- -->Returns the id of the new mix, or -1 if some error occurred.
<!-- -->If <i>with-mix-tags</i> is #f (default is #t), the data is simply
<!-- -->mixed without creating any mix tags.
<!-- --></td></tr>
<!-- --></table>

<p>In the functions that refer to a given sound, the form <code>(list mix-id)</code> refers to the
underlying mix's sound.  So, for example, <code>(src-sound 2.0 1.0 (list 0) 0)</code> performs
sampling-rate conversion on mix 0's sound's channel 0; <code>(display-edits (list 0) 0)</code>
shows the edit list of that sound, and <code>(set! (edit-position (list 0) 0) 0)</code> reverts
it to its original state.
</p>
<br>
<span class=cbox><h3><A NAME="sndregions">Regions</a></h3></span>

<p>A region is a saved portion of sound data.  There is a dialog to browse regions, and
a notion of a stack of regions.  As regions are added, old ones get pushed off the
stack and deleted.  The current selection is usually based on region 0,
although in fact there's no necessary connection between them.
The region number (e.g. 0) refers to its position in the region stack; each region also
has a unique identifier called its <i>id</i>.
Some of the <i>reg</i> arguments can be #t, referring to all current regions; 
these are indicated as <em class=targ>reg</em> below.
</p>

<!-- -------------------------------- REGION TABLE -------------------------------- -->
<!-- -->
<!-- --><table border=0 cellspacing=8>
<!-- -->
<!-- delete-region -->
<!-- -->
<!-- --><tr><td valign=top><span class=defbox><code><em class=def><a name="snddeleteregion">delete-region</a></em> (<i>reg</i>)</code></span></td>
<!-- --><td>
<!-- -->delete region number <i>reg</i> (which defaults to 0).  This removes the
<!-- -->region from the region stack; it doesn't edit the corresponding file(s).
<!-- --></td></tr>
<!-- -->
<!-- id-region -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndidregion">id-region</a></em> (<i>id</i>)</code></span></td>
<!-- --><td>
<!-- -->map from region-id <i>id</i> to its current region stack location.
<!-- --></td></tr>
<!-- -->
<!-- insert-region -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndinsertregion">insert-region</a></em> (<i>beg reg snd chn</i>)</code></span></td>
<!-- --><td>
<!-- -->insert region <i>reg</i> at sample <i>beg</i> in <i>snd</i>'s channel <i>chn</i>.
<!-- --></td></tr>
<!-- -->
<!-- make-region -->
<!-- -->
<!-- --><tr><td valign=top><span class=defbox><code><em class=def><a name="sndmakeregion">make-region</a></em> (<i>beg end snd chn</i>)</code></span></td>
<!-- --><td>
<!-- -->create a new region spanning samples <i>beg</i> to <i>end</i> in <i>snd</i>'s channel <i>chn</i>.
<!-- -->returns region's id.  If no arguments are given, the 
<!-- -->current selection is used.
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2><span class=defbox><code><a href="#makeregionsamplereader">make-region-sample-reader</a> (<i>start reg chn dir</i>)</code></span></td>
<!-- --></tr><tr><td></td><td>
<!-- -->create a <a href="#samplereaders">sample-reader</a> object reading region <i>reg</i>'s channel <i>chn</i>
<!-- --></td></tr>
<!-- -->
<!-- play-region -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndplayregion">play-region</a></em> (<i>reg wait</i>)</code></span></td>
<!-- --><td>
<!-- -->play region <i>reg</i>, if wait is #t, play to end before returning.
<!-- --></td></tr>
<!-- -->
<!-- protect-region -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndprotectregion">protect-region</a></em> (reg protect)</code></span></td>
<!-- --><td>protect/unprotect region <i>reg</i> from deletion in the <a href="snd.html#regionbrowser">region browser</a>.
<!-- --></td></tr>
<!-- -->
<!-- region-chans -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndregionchans">region-chans</a></em> (<em class=targ>reg</em>)</code></span></td>
<!-- --><td>
<!-- -->number of channels in region <i>reg</i>.
<!-- --></td></tr>
<!-- -->
<!-- region-id -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndregionid">region-id</a></em> (<em class=targ>reg</em>)</code></span></td>
<!-- --><td>
<!-- -->unique identifier attached to region <i>reg</i>.
<!-- --></td></tr>
<!-- -->
<!-- region-length -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndregionlength">region-length</a></em> (<em class=targ>reg</em>)</code></span></td>
<!-- --><td>
<!-- -->number of samples (per channel) in region <i>reg</i>.
<!-- --></td></tr>
<!-- -->
<!-- region-maxamp -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndregionmaxamp">region-maxamp</a></em> (<em class=targ>reg</em>)</code></span></td>
<!-- --><td>
<!-- -->maximum amplitude of region <i>reg</i>.
<!-- --></td></tr>
<!-- -->
<!-- region-sample -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndregionsample">region-sample</a></em> (<i>samp reg chn</i>)</code></span></td>
<!-- --><td>
<!-- -->value of sample <i>samp</i> in region <i>reg</i> in channel <i>chn</i>.
<!-- --></td></tr>
<!-- -->
<!-- region-samples -->
<!-- -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="sndregionsamples">region-samples</a></em> (<i>samp samps reg chn</i>)</code></span></td>
<!-- --></tr><tr><td></td><td>
<!-- -->return vector of <i>samps</i> samples starting at <i>samp</i> in region <i>reg</i>'s 
<!-- -->channel <i>chn</i>.
<!-- --></td></tr>
<!-- -->
<!-- region-samples->vct -->
<!-- -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="sndregionsamples2vct">region-samples-&gt;vct</a></em> (<i>samp samps reg chn v</i>)</code></span></td></tr>
<!-- --><tr><td></td>
<!-- --><td>
<!-- -->return vct struct of <i>samps</i> samples starting at <i>samp</i> in region <i>reg</i>'s 
<!-- -->channel <i>chn</i>. If v (a vct object) is provided, it is filled, 
<!-- -->rather than creating a new vct object.
<!-- --></td></tr>
<!-- -->
<!-- region-srate -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndregionsrate">region-srate</a></em> (<em class=targ>reg</em>)</code></span></td>
<!-- --><td>
<!-- -->original (nominal) sampling rate of region <i>reg</i>.
<!-- --></td></tr>
<!-- -->
<!-- regions -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="eregions">regions</a></em> ()</code></span></td>
<!-- --><td>
<!-- -->list of ids of regions currently active.
<!-- --></td></tr>
<!-- -->
<!-- region? -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="regionok">region?</a></em> (<i>reg</i>)</code></span></td>
<!-- --><td>
<!-- -->#t if region <i>reg</i> has data.
<!-- --></td></tr>
<!-- -->
<!-- save-region -->
<!-- -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="sndsaveregion">save-region</a></em> (reg filename <i>format</i>) </code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->save region <i>reg</i> in <i>filename</i> in data format <i>format</i> (default mus-bshort) 
<!-- -->[<em class=error>cannot-save</em>].
<!-- --></td></tr>
<!-- -->
<!-- select-all -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndselectall">select-all</a></em> (<i>snd chn</i>)</code></span></td>
<!-- --><td>
<!-- -->create a new region spanning all samples in <i>snd</i>'s channel <i>chn</i>.
<!-- -->returns region's id.
<!-- --></td></tr>
<!-- -->
<!-- select-region -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndselectregion">select-region</a></em> (<i>reg</i>)</code></span></td>
<!-- --><td>select region <i>reg</i> (i.e make it region 0).
<!-- --></td></tr>
<!-- -->
<!-- --></table>

<p>These are specific to the current selection (these can return the error 'no-active-selection):</p>

<!-- -------------------------------- SELECTION TABLE -------------------------------- -->
<!-- -->
<!-- --><table border=0 cellspacing=8>
<!-- -->
<!-- convolve-selection-with -->
<!-- -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="sndconvolveselectionwith">convolve-selection-with</a></em> (file <i>amp</i>)     </code></span></td>
<!-- --></tr><tr><td></td><td>
<!-- -->convolve the current selection with <i>file</i> 
<!-- --></td></tr>
<!-- -->
<!-- cut -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndcut">cut</a></em> ()</code></span></td>
<!-- --><td>
<!-- -->cut the current selection (a no-op if no active selection) 
<!-- --></td></tr>
<!-- -->
<!-- delete-selection -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="snddeleteselection">delete-selection</a></em> ()</code></span></td>
<!-- --><td>
<!-- -->same as cut (deletes currently selected portions).
<!-- --></td></tr>
<!-- -->
<!-- env-selection -->
<!-- -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="sndenvselection">env-selection</a></em> (envelope <i>env-base snd chn</i>)</code></span></td>
<!-- --></tr><tr><td></td><td>
<!-- -->apply <i>envelope</i> to the currently selected portion of <i>snd</i>'s channel <i>chn</i>.
<!-- --><i>envelope</i> can also be a CLM env generator (in this case, <i>env-base</i> 
<!-- -->is ignored).
<!-- --></td></tr>
<!-- -->
<!-- filter-selection -->
<!-- -->
<!-- --><tr><td valign=top><span class=defbox><code><em class=def><a name="sndfilterselection">filter-selection</a></em> (env <i>order</i>)</code></span></td>
<!-- --><td>
<!-- -->apply an FIR filter of order <i>order</i> and frequency response <i>env</i>
<!-- -->to the current selection.  <i>env</i> can be the filter coefficients
<!-- -->themselves in a vct object with at least order elements, or 
<!-- -->a CLM filtering generator (see <a href="filtersound">filter-sound</a>).
<!-- --></td></tr>
<!-- -->
<!-- insert-selection -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndinsertselection">insert-selection</a></em> (<i>beg snd chn</i>)</code></span></td>
<!-- --><td>
<!-- -->insert (paste) selection starting at beg in snd's channel chn.
<!-- --></td></tr>
<!-- -->
<!-- mix-selection -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndmixselection">mix-selection</a></em> (<i>beg snd chn</i>)</code></span></td>
<!-- --><td>
<!-- -->mix (add) selection starting at beg in snd's channel chn.  Returns new mix id.
<!-- --></td></tr>
<!-- -->
<!-- play-selection -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndplayselection">play-selection</a></em> (<i>wait pos</i>)</code></span></td>
<!-- --><td>
<!-- -->play the currently selected data.  If <i>pos</i> is given, it sets the edit position to be played.
<!-- --></td></tr>
<!-- -->
<!-- reverse-selection -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndreverseselection">reverse-selection</a></em> ()</code></span></td>
<!-- --><td>
<!-- -->reverse data delineated by current selection 
<!-- --></td></tr>
<!-- -->
<!-- save-selection -->
<!-- -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="sndsaveselection">save-selection</a></em> (file <i>header-type data-format srate comment</i>)</code></span></td>
<!-- --></tr><tr><td></td><td>
<!-- -->save the currently selected data in <i>file</i> 
<!-- --></td></tr>
<!-- -->
<!-- scale-selection-by -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndscaleselectionby">scale-selection-by</a></em> (<i>scalers</i>)</code></span></td>
<!-- --><td>
<!-- --><a href="snd.html#scaling">scale</a> the current selection by <i>scalers</i> which can be either a float, 
<!-- -->or a vector of floats 
<!-- --></td></tr>
<!-- -->
<!-- scale-selection-to -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndscaleselectionto">scale-selection-to</a></em> (<i>scalers</i>)</code></span></td>
<!-- --><td>
<!-- --><a href="snd.html#scaling">normalize</a> the current selection to <i>scalers</i> which can be either a float, 
<!-- -->or a vector of floats 
<!-- --></td></tr>
<!-- -->
<!-- selection-length -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="selectionlength">selection-length</a></em> ()</code></span></td>
<!-- --><td>
<!-- -->selection frames 
<!-- --></td></tr>
<!-- -->
<!-- selection-member? -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="selectionmember">selection-member?</a></em> (<i>snd chn</i>)</code></span></td>
<!-- --><td>
<!-- -->#t if snd's chn is member of active selection.
<!-- --></td></tr>
<!-- -->
<!-- selection-position -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="selectionposition">selection-position</a></em> ()</code></span></td>
<!-- --><td>
<!-- -->selection begin sample number (used to be called selection-beg).
<!-- --></td></tr>
<!-- -->
<!-- selection-to-temp -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="selectiontotemp">selection-to-temp</a></em> (<i>type format</i>)</code></span></td>
<!-- --><td>
<!-- -->write out selected data as a temp file (see <a href="grfsnd.html#programs">external programs</a>) 
<!-- --></td></tr>
<!-- -->
<!-- selection-to-temps -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="selectiontotemps">selection-to-temps</a></em> (<i>type format</i>)</code></span></td>
<!-- --><td>
<!-- -->write out selected data as temp files (see <a href="grfsnd.html#programs">external programs</a>) 
<!-- --></td></tr>
<!-- -->
<!-- selection? -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="selectionok">selection?</a></em> ()</code></span></td>
<!-- --><td>
<!-- -->#t if selection is active.
<!-- --></td></tr>
<!-- -->
<!-- smooth-selection -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndsmoothselection">smooth-selection</a></em> ()</code></span></td>
<!-- --><td>
<!-- -->apply a smoothing function to the current selection 
<!-- --></td></tr>
<!-- -->
<!-- src-selection -->
<!-- -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="sndsrcselection">src-selection</a></em> (num-or-env <i>base</i>) </code></span></td>
<!-- --></tr><tr><td></td><td>
<!-- -->same as <i>src-sound</i> but applied to current selection.
<!-- --></td></tr>
<!-- -->
<!-- temp-to-selection -->
<!-- -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="temptoselection">temp-to-selection</a></em> (data name origin) </code></span></td>
<!-- --></tr><tr><td></td><td>
<!-- -->read selected data from temp file (see <a href="grfsnd.html#programs">external programs</a>).
<!-- --></td></tr>
<!-- -->
<!-- temps-to-selection -->
<!-- -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="tempstoselection">temps-to-selection</a></em> (data names origin) </code></span></td>
<!-- --></tr><tr><td></td><td>read selected data from temp files (see <a href="grfsnd.html#programs">external programs</a>).
<!-- --></td></tr>
<!-- -->
<!-- --></table>

<p>The selected portion can be set, independent of any region, by setting selection-position and selection-length.
</p>


<br>
<span class=cbox><h3><A NAME="sndsounds">Sounds and channels</a></h3></span>

<p>This is the "heart" of Snd; we've waded through all the ancillary junk, and we've
finally reached the functions that actually edit sounds!  Most of these functions
take both a sound index and a channel number.  To make global operations simpler to achieve,
some of the <i>snd</i> and <i>chan</i> arguments can be #t, referring to all current sounds or all channels of a sound; 
of these, some default to the currently selected sound if no argument is given, whereas others
(mainly for historical reasons) default to all sounds and channels;
the former are indicated as <em class=targ>snd</em> or <em class=targ>snd chn</em> below,
and the latter as <em class=narg>snd</em> or <em class=narg>snd chn</em>.
Also, in most of the signal-processing functions, the <i>snd</i> argument can also be
a list; in this case it refers to a mix.  For example, the <b>cursor</b> function,
which refers to the current cursor location, is listed here as:
</p>
<pre>
  cursor           (<em class=targ>snd chn</em>)     cursor location
</pre>
<p>which indicates that <code>(cursor 0 0)</code> returns the cursor location in sound 0, channel 0,
<code>(cursor)</code> returns the location in the currently selected sound, <code>(cursor #t #t)</code>
returns a list of lists of all the cursor locations, and <code>(set! (cursor) 0)</code> sets (just) the
cursor in the currently selected channel;
on the other hand, the <b>fft-size</b> function
is listed as:</p>
<pre>
  fft-size         (<em class=narg>snd chn</em>)     FFT size.
</pre>
<p>which means that <code>(fft-size 0 0)</code> returns the fft size used in sound 0, channel 0,
<code>(fft-size)</code> returns the globally effective fft size, <code>(fft-size #t #t)</code>
returns a list of lists of all the fft sizes, and <code>(set! (fft-size) 512)</code> sets all
fft sizes to 512.</p>

<p>The variables are local to each sound or each channel.
That is, <code>(amp snd)</code> returns the control-panel amp setting, and <code>(set! (amp snd) val)</code>
sets its value to val.  
</p>

<p>Many of the procedures also have an <i>edpos</i> argument (standing for "edit position").
It always defaults to the current edit history position.  If specified, it can be either an edit history position (to which
the operation is applied), the constant current-edit-position (the default), or a function
of two arguments, the sound index and the channel number.  The function should return the
desired edit history position. 
</p>



<!-- -------------------------------- SOUND AND CHANNEL TABLE -------------------------------- -->
<!-- -->
<!-- --><table border=0 cellspacing=10>
<!-- -->
<!-- -->
<!-- add-player -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="addplayer">add-player</a></em> (player <i>start end pos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td width=150></td><td>
<!-- -->add <i>player</i> to the play-list (see <a href="#makeplayer">make-player</a>). 
<!-- -->If <i>pos</i> is given, play at that edit position. [<em class=error>no-such-player</em>]
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- amp -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndamp">amp</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->current amp (control panel slider) value.
<!-- -->It is possible to use these controls (in "real-time") in your own functions.
<!-- -->See amprt in <a href="sndscm.html#exampdoc">examp.scm</a> for a simple example, and <a href="sndscm.html#sndgtkdoc">snd-gtk.scm</a> for a complicated one. 
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- append-to-minibuffer -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndappendtominibuffer">append-to-minibuffer</a></em> (msg <i>snd</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->append <i>msg</i> to whatever is in <i>snd</i>'s minibuffer [<em class=error>no-such-sound</em>].
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- backward-graph -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndbackwardgraph">backward-graph</a></em> (<i>count snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->move back (up or left) <i>count</i> graphs (C-x C-o).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- backward-sample -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndbackwardsample">backward-sample</a></em> (<i>count snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->move back <i>count</i> samples (C-b), return new cursor position.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- bomb -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="bomb">bomb</a></em> (<i>snd on</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->display bomb icon in <i>snd's</i> minibuffer.  Set <i>on</i> to #f to erase bomb.  Each time <i>bomb</i>
<!-- -->is called, the bomb icon moves to the next image in its sequence (showing the bomb's fuse burning down),
<!-- -->restarting the sequence whenever it reaches the end.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- call-apply -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="callapply">call-apply</a></em> (<i>snd target</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->equivalent to pushing <i>snd</i>'s 'apply' button (this is intended 
<!-- -->for internal testing); <i>target</i> can be 0=sound, 1=channel, 2=selection.
<!-- -->call-apply can be used in conjunction with the various control panel variables:
<!-- --></td></tr>
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(define expnd 
<!-- -->  (lambda (amt) 
<!-- -->    (set! (expanding) #t) 
<!-- -->    (set! (expand) amt) 
<!-- -->    (<em class=red>call-apply</em>)))
<!-- --></pre></td></tr></table>
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- channel-sync -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndchannelsync">channel-sync</a></em> (<em class=targ>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->sync field local to channel (currently unused).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- channels -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="channels">channels</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->number of channels in <i>snd</i>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- chans -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndchans">chans</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->same as <i>channels</i> (the forgetful programmer's friend).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- close-sound -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndclose">close-sound</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->close <i>snd</i> (same as File menu Close).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- comment -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndcomment">comment</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- --><i>snd</i>'s comment, if any.  If this is set, the new value may be appended 
<!-- -->to the old (AIFC and RIFF headers are the only safe ones in this case).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- contrast -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndcontrast">contrast</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->current <a href="snd.html#contrast">contrast</a> (control panel slider) value.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- contrast-amp -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndcontrastamp">contrast-amp</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- --><i>snd</i>'s <a href="snd.html#contrast">contrast-amp</a> (control panel variable).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- contrasting -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndcontrasting">contrasting</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->#t if <i>snd</i> has <a href="snd.html#contrast">contrast</a> turned on (control panel)
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- convolve-with -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndconvolvewith">convolve-with</a></em> (file <i>amp snd chn edpos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->convolve <i>snd</i>'s channel <i>chn</i> (or the currently sync'd data)
<!-- -->with the data in the sound file <i>file</i>. <i>amp</i> is the resultant 
<!-- -->peak amplitude (leave <i>amp</i> unset, or set it to #f to get the 
<!-- -->unnormalized result) [<em class=error>no-such-file</em>].
<!-- -->Convolve-with in conjunction with mix can provide high-quality reverb:
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(define conrev
<!-- -->  (lambda (impulse amp)
<!-- -->    (<em class=red>convolve-with</em> impulse amp)
<!-- -->    (save-sound-as "reverb.snd") ;let mix scalers set reverb amount
<!-- -->    (revert-sound)
<!-- -->    (<em class=red>mix</em> "reverb.snd")))
<!-- --></pre></td></tr></table>
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- count-matches -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="lcountmatches">count-matches</a></em> (expr <i>sample snd chn edpos</i>) </code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->return how many samples satisfy the expression <i>expr</i>.  <i>expr</i>
<!-- -->is a Scheme function of one argument (the current sample value). <i>sample</i> 
<!-- -->determines where to start the search.<br><br>
<!-- -->
<!-- --><code>(count-matches (lambda (y) (&gt; y .1)))</code>
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- cursor -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndcursor">cursor</a></em> (<em class=targ>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->cursor location (samples) of channel <i>chn</i> of <i>snd</i>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- cursor-follows-play -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndcursorfollowsplay">cursor-follows-play</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->#t if cursor is following along in the sound as it plays.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- cursor-position -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="cursorposition">cursor-position</a></em> (<em class=targ>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->current cursor position as a list (x y).
<!-- -->These graph-relative values can be turned into axis-relative values with
<!-- --><a href="#position2x">position-&gt;x</a> and <a href="#position2y">position-&gt;y</a>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- cursor-size -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="cursorsize">cursor-size</a></em> (<em class=targ>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->cursor size (defaults to 15).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- cursor-style -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="cursorstyle">cursor-style</a></em> (<em class=targ>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->cursor style (<i>cursor-cross</i> or <i>cursor-line</i>)
<!-- -->The normal shape is a "+" sign; the cursor-line is a vertical line.
<!-- -->The following hooks set the cursor-style to cursor-line while playing if
<!-- -->cursor-follows-play is #t:
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(define set-sound-cursor
<!-- -->  (lambda (snd shape)
<!-- -->    (do ((j 0 (1+ j)))
<!-- -->        ((= j (channels snd)) #f)
<!-- -->      (set! (<em class=red>cursor-style</em> snd j) shape))))
<!-- -->
<!-- -->(add-hook! start-playing-hook 
<!-- -->  (lambda (snd) 
<!-- -->    (if (cursor-follows-play snd) 
<!-- -->        (set-sound-cursor snd <em class=red>cursor-line</em>))))
<!-- -->
<!-- -->(add-hook! stop-playing-hook 
<!-- -->  (lambda (snd) 
<!-- -->    (set-sound-cursor snd <em class=red>cursor-cross</em>)))
<!-- --></pre></td></tr></table>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->The <i>cursor-style</i> can also be a procedure of three arguments, the
<!-- -->sound index, channel number, and graph (always time-graph).  The procedure
<!-- -->should draw the cursor at the current cursor position using the
<!-- -->cursor-context whenever it is called.  For example, the following 
<!-- -->replaces the normal "+" cursor with an "x":
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(define (<A NAME="xcursor">x-cursor</a> snd chn ax)
<!-- -->  (let* ((point (<em class=red>cursor-position</em>))
<!-- -->         (x (car point))
<!-- -->         (y (cadr point))
<!-- -->         (size (inexact->exact (/ (<em class=red>cursor-size</em>) 2))))
<!-- -->    (<em class=red>draw-line</em> (- x size) (- y size) (+ x size) (+ y size) snd chn <em class=red>cursor-context</em>)    
<!-- -->    (<em class=red>draw-line</em> (- x size) (+ y size) (+ x size) (- y size) snd chn <em class=red>cursor-context</em>)))
<!-- --></pre></td></tr></table>
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- data-format -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="snddataformat">data-format</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- --><i>snd</i>'s data format (e.g. mus-bshort).  If you encounter a file
<!-- -->with an unknown format, or a header that has the wrong format, 
<!-- -->you can set this field forcing Snd to interpret the data in any 
<!-- -->form you like.  Similar remarks apply to the srate, data-location,
<!-- -->header-type, and channels fields.
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- data-location -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="snddatalocation">data-location</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- --><i>snd</i>'s data location (bytes).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- delete-sample -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="snddeletesample">delete-sample</a></em> (samp <i>snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->delete sample <i>samp</i> in <i>snd</i>'s channel <i>chn</i> [<em class=error>no-such-sample</em>].
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- delete-samples -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="snddeletesamples">delete-samples</a></em> (samp samps <i>snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->delete <i>samps</i> samples starting at sample <i>samp</i>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- dot-size -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="dotsize">dot-size</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->size in pixels of dots when graphing with dots (default: 1)
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- env-base -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndenvbase">env-base</a></em> (env)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->base of env (not stable -- may be removed).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- env-sound -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndenv">env-sound</a></em> (envelope <i>samp samps env-base snd chn edpos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->apply (in amplitude) <i>envelope</i> to <i>snd</i>'s channel <i>chn</i> starting
<!-- -->at sample <i>samp</i> for <i>samps</i> samples with connecting segments
<!-- -->based on <i>env-base</i>.  <i>env-base</i> defaults to 1.0 (line segments).
<!-- --><i>samp</i> defaults to 0.  <i>samps</i> defaults to the full duration.
<!-- --><i>envelope</i> is a list or vector containing the breakpoint values 
<!-- -->(as in CLM).<br>
<!-- --><code>(env-sound '(0 0 1 1 2 0))</code>
<!-- --><br>
<!-- --><i>envelope</i> can also be a CLM env generator (in this case, <i>env-base</i> 
<!-- -->is ignored, and it's assumed <i>samps</i> is reflected in the make-env call).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- expand -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndexpand">expand</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->current <a href="snd.html#expand">expansion</a> amount (control panel).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- expand-hop -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndexpandhop">expand-hop</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- --><i>snd</i>'s <a href="snd.html#expand">expansion</a> hop amount (seconds).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- expand-length -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndexpandlength">expand-length</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- --><i>snd</i>'s <a href="snd.html#expand">expansion</a> segment length (seconds).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- expand-ramp -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndexpandramp">expand-ramp</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- --><i>snd</i>'s <a href="snd.html#expand">expansion</a> ramp amount (between 0 and .5).
<!-- -->This affects the smoothness of the grain overlaps -- .001 gives a 
<!-- -->rattling effect (see make-control-dialog in <a href="sndscm.html#sndgtkdoc">snd-gtk.scm</a>).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- expanding -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndexpanding">expanding</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->#t if <i>snd</i>'s expand button is on.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- fft-beta -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="fftbeta">fft-beta</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->The fft data <a href="snd.html#Xfftbeta">window parameter</a>, if relevant.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- fft-log-frequency -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="fftlogfrequency">fft-log-frequency</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->spectrum frequency axis is logarithmic (#t) or linear (#f) (default #f).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- fft-log-magnitude -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="fftlogmagnitude">fft-log-magnitude</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->spectrum magnitude axis is in decibels (#t) or linear (#f) (default #f).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- fft-size -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="lfftsize">fft-size</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->FFT size (default = 256).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- fft-style -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="lfftstyle">fft-style</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->choice of spectral display.  The choices are (default) <i>normal-fft</i>, 
<!-- --><i>sonogram</i>, and <i>spectrogram</i>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- fft-window -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="lfftwindow">fft-window</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->fft data window (default: <i>blackman2-window</i>)
<!-- --><pre>
<!-- -->rectangular-window hann(ing)-window   welch-window      parzen-window
<!-- -->bartlett-window    hamming-window     blackman2-window  blackman3-window
<!-- -->blackman4-window   exponential-window riemann-window    kaiser-window
<!-- -->cauchy-window      poisson-window     gaussian-window   tukey-window
<!-- -->dolph-chebyshev-window (this only if GSL is loaded)
<!-- --></pre>
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- ffting -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndffting">ffting</a></em> (<em class=targ>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->#t if <i>snd</i>'s channel <i>chn</i> is displaying a spectrum (the 'f' button).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- file-name -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndfilename">file-name</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- --><i>snd</i>'s complete file name.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- filter-dBing -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndfilterdbing">filter-dBing</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- --><i>snd</i>'s <a href="snd.html#filter">filter</a> dB button state (control panel).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- filter-env -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndfilterenv">filter-env</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- --><i>snd</i>'s <a href="snd.html#filter">filter</a> envelope (control panel).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- filter-order -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndfilterorder">filter-order</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- --><i>snd</i>'s <a href="snd.html#filter">filter</a> order (control panel).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- filter-sound -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndfilter">filter-sound</a></em> (env <i>order snd chn edpos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->apply an FIR filter of order <i>order</i> and frequency response <i>env</i>
<!-- -->to <i>snd</i>'s channel <i>chn</i>.  <i>env</i> can be the filter coefficients
<!-- -->themselves, in a vct object with at least order elements 
<!-- -->(see <a href="grfsnd.html#gmeteor">gmeteor</a>).  It can also be any CLM filtering generator 
<!-- -->(e.g. comb, formant, one-pole, iir-filter, etc). The generator 
<!-- -->is called in C, not Scheme, so this is the fastest way to apply 
<!-- -->CLM filtering to a sound.
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(filter-sound '(0 1 1 0) 1024)                       ;FIR filter given frequency response
<!-- -->(filter-sound (list-&gt;vct '(.1 .2 .3 .3 .2 .1)) 6)    ;FIR filter given actual coefficients
<!-- -->(filter-sound (make-fir-filter 6 (list-&gt;vct '(.1 .2 .3 .3 .2 .1)))) ;CLM FIR filter
<!-- -->(filter-sound (make-delay 120))                      ;CLM delay (same as insert-silence)
<!-- -->(filter-sound (make-formant .99 1200))               ;CLM formant
<!-- --></pre></td></tr></table>
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- filtering -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndfiltering">filtering</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->#t if <i>snd</i> is filtering (control panel filter button).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- find -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="lfind">find</a></em> (expr <i>sample snd chn edpos</i>) </code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->find the sample that satisfies the Scheme function <i>expr</i>. <i>sample</i>
<!-- -->determines where to start the search. <br><br>
<!-- -->
<!-- --><code>(find (lambda (y) (&gt; y .1)))</code>
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- find-sound -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndfindsound">find-sound</a></em> (filename)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->returns the index of <i>filename</i> (used as <i>snd</i> throughout).
<!-- -->returns #f if no sound is found that matches <i>filename</i>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- finish-progress-report -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="finishprogressreport">finish-progress-report</a></em> (<i>snd</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->see <a href="#progressreport">progress-report</a>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- forward-graph -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndforwardgraph">forward-graph</a></em> (<i>count snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->move forward (down or right) <i>count</i> graphs (C-x C-o).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- forward-sample -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndforwardsample">forward-sample</a></em> (<i>count snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->move forward <i>count</i> samples (C-f), return new cursor position.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- frames -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndframes">frames</a></em> (<em class=targ>snd chn</em> <i>edpos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- --><i>chn</i>'s current length in samples.  Used with set!, this either truncates 
<!-- -->the sound or pads it with zeros at the end.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- graph -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndgraph">graph</a></em> (data <i>xlabel x0 x1 y0 y1 snd chn force-display</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->Display a graph of <i>data</i> in a separate display per channel.  The x axis
<!-- -->is labelled <i>xlabel</i>, the x axis units go from x0 to x1 (default 0 to 1.0),
<!-- -->the y axis goes from y0 to y1 (default fits the data), and the display is 
<!-- -->associated with channel <i>chn</i> in <i>snd</i>.
<!-- --><code>(graph #(0 .1 .2 .3 .4 .3 .2 .1 0) "roof")</code>
<!-- -->The current slider values can be read from <a href="#xpositionslider">x-position-slider</a>, 
<!-- --><a href="#xzoomslider">x-zoom-slider</a>, etc.  The <i>data</i> argument can be a list of vectors or
<!-- -->vcts; each is graphed at the same time, following the sequence of
<!-- -->colors used when channels are superimposed.  See <a href="sndscm.html#exampdoc">examp.scm</a>.  If <i>data</i>
<!-- -->is a list of numbers, it is assumed to be an envelope (a list of breakpoints).
<!-- -->If <i>force-display</i> is #f (default is #t), the graph is not
<!-- -->explicitly drawn; this is useful when you're calling graph from
<!-- -->the lisp-graph-hook, where the redisplay is automatic.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- graph-style -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="graphstyle">graph-style</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->how sound data is displayed (default: <i>graph-lines</i>)
<!-- -->The choices are:<pre>
<!-- -->
<!-- -->graph-lines  graph-dots  graph-filled  graph-lollipops  graph-dots-and-lines 
<!-- --></pre>
<!-- -->It is possible to set the graph-style of each of a channel's graphs 
<!-- -->independently.  The lower 8 bits of the graph-style apply to the main 
<!-- -->graph, and to the other graphs if they aren't set explicitly; the 
<!-- -->second 8 bits refers to the fft graph offset by 1, and the next 
<!-- -->8 bits are the lisp graph.  This is clumsy, but backwards compatible.  
<!-- -->For example,
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(set! (graph-style 0 0)
<!-- -->      (+ graph-dots (ash (+ graph-lines 1) 8) 
<!-- -->                    (ash (+ graph-lollipops 1) 16)))
<!-- --></pre></td></tr></table>
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->causes the main (time domain) graph to be displayed using dots, 
<!-- -->the fft graph to use lines, and the lisp graph lollipops.  There 
<!-- -->are some functions in <a href="sndscm.html#exampdoc">examp.scm</a> (main-graph-style et al) that 
<!-- -->might make these fields easier to access and change.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- graphing -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndgraphing">graphing</a></em> (<i>snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->#t if (lisp) graph data is being displayed.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- graphs-horizontal -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="graphshorizontal">graphs-horizontal</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->determines whether channel graphs (time domain, spectrum, lisp graph) 
<!-- -->are arranged vertically or horizontally.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- header-type -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndheadertype">header-type</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- --><i>snd</i>'s header type (e.g. mus-aiff).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- insert-silence -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndinsertsilence">insert-silence</a></em> (beg num <i>snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->insert num zeros at beg in <i>snd</i>'s channel <i>chn</i>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- insert-sound -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndinsertfile">insert-sound</a></em> (file <i>beg in_chan snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->insert channel <i>in_chan</i> of <i>file</i> at sample <i>beg</i> in <i>snd</i>'s channel <i>chn</i>.
<!-- -->beg defaults to the cursor position; if in_chan is not given, all 
<!-- -->channels are inserted. [<em class=error>no-such-file</em>].
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- insert-sample -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndinsertsample">insert-sample</a></em> (samp value <i>snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->insert sample <i>value</i> at sample <i>samp</i> in <i>snd</i>'s channel <i>chn</i> 
<!-- -->[<em class=error>no-such-sample</em>].
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- insert-samples -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndinsertsamples">insert-samples</a></em> (samp samps data <i>snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->insert <i>samps</i> samples of <i>data</i> starting at sample <i>samp</i> in <i>snd</i>'s channel <i>chn</i>.
<!-- --><i>data</i> can be a filename; Snd assumes any such file is temporary; 
<!-- -->it will be deleted when no longer needed.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- left-sample -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndleftsample">left-sample</a></em> (<em class=targ>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->return the position in samples of the left edge of the time domain
<!-- -->waveform for <i>snd</i>'s channel <i>chn</i>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- line-size -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="linesize">line-size</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->Number of samples considered to be a 'line' (<a href="snd.html#cn">C-n</a> and <a href="snd.html#cp">C-p</a> commands). 
<!-- -->default: 128.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- loop-samples -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="loopsamples">loop-samples</a></em> (reader function calls origin <i>environ</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->This calls external C functions while moving through the data accessed
<!-- -->by the sample reader. loop-samples takes a sample reader, a pointer to a 
<!-- -->(C) float function that takes one float argument (the current sample), 
<!-- -->the number of times to call that function, and a name for the editing 
<!-- -->operation for the edit history list.  If <i>environ</i> is included, it
<!-- -->is passed as the second (void *) argument to the function.  See grfsnd.html
<!-- -->for examples of both forms.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- make-player -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="makeplayer">make-player</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->make a new player associated with <i>snd</i>'s channel <i>chn</i>.
<!-- -->A <i>player</i> is a sort of wrapper for a channel of a sound that supports
<!-- -->all the control-panel functions.  Once created, you can set these
<!-- -->fields, then call <a href="#addplayer">add-player</a> to add this channel to the list of
<!-- -->channels either being played (if a play is in progress) or about
<!-- -->to be played.  Once some player is in the play-list, you can start 
<!-- -->the play with <a href="#startplaying">start-playing</a>, and stop it prematurely with either 
<!-- --><a href="#stopplayer">stop-player</a> or <a href="#sndstop">stop-playing</a>.  These functions make it possible 
<!-- -->to build custom control panels.  Here's a simple example that plays a 
<!-- -->sound with individual amplitudes for the channels:
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(define play-with-amps
<!-- -->  (lambda (sound . amps)
<!-- -->    (let ((chans (chans sound)))
<!-- -->      (do ((chan 0 (1+ chan)))
<!-- -->          ((= chan chans))
<!-- -->        (let ((player (<em class=red>make-player</em> sound chan)))
<!-- -->          (set! (amp player) (list-ref amps chan))
<!-- -->          (<em class=red>add-player</em> player)))
<!-- -->      (<em class=red>start-playing</em> chans (srate sound)))))
<!-- -->
<!-- -->(play-with-amps 0 1.0 0.5) ;plays channel 2 of stereo sound at half amplitude
<!-- --></pre></td></tr></table>
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->See also make-amp-controls in <a href="sndscm.html#sndgtkdoc">sndgtk.scm</a>, and play-syncd-marks in <a href="sndscm.html#marksdoc">marks.scm</a>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- map-across-all-chans -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="mapacrossallchans">map-across-all-chans</a></em> (func <i>start end edname edpos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->apply func to all open channels in parallel (see <a href="#scanning">Scanning Data</a>).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- map-across-chans -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="mapacrosschans">map-across-chans</a></em> (func <i>start end edname edpos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->apply func to currently syncd channels in parallel
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- map-across-sound-chans -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="mapacrosssoundchans">map-across-sound-chans</a></em> (func <i>start end edname snd edpos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->apply func to sound's channels in parallel
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- map-all-chans -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="mapallchans">map-all-chans</a></em> (func <i>start end edname edpos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->apply func to all open channels
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- map-chan -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="mapchan">map-chan</a></em> (func <i>start end edname snd chn edpos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->apply func to samples in current channel 
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- map-chans -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="mapchans">map-chans</a></em> (func <i>start end edname edpos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->apply func to currently syncd channels
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- map-sound-chans -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="mapsoundchan">map-sound-chans</a></em> (func <i>start end edname snd edpos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->apply func to current sound's channels
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- maxamp -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndmaxamp">maxamp</a></em> (<em class=targ>snd chn</em> <i>edpos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->max amp of <i>snd</i>'s channel <i>chn</i>.  Used with set!, this is equivalent to scale-to.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- max-fft-peaks -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="maxfftpeaks">max-fft-peaks</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->max number of fft peaks reported (default: 100).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- max-sounds -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndmaxsounds">max-sounds</a></em> ()</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->current size of sound array (grows as required).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- min-db -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="mindb">min-db</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->Sets the minimum dB value displayed in various graphs (default: -60.0).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- new-sound -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndnew">new-sound</a></em> (name <i>header-type data-format srate chans comment</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->create a new (empty) sound named <i>name</i>.  If the <i>type</i> and other 
<!-- -->arguments are not specified, a dialog is posted to get the needed 
<!-- -->values which default to the current <a href="#defaultoutputtype">default-output-type</a> and 
<!-- -->related settings.  Data formats are (b=big-endian, l=little, u=unsigned):
<!-- --><pre>
<!-- -->mus-bshort  mus-lshort mus-mulaw  mus-alaw   mus-byte   mus-ubyte   mus-bfloat
<!-- -->mus-lfloat  mus-bint   mus-lint   mus-b24int mus-l24int mus-bdouble mus-ldouble
<!-- -->mus-ubshort mus-ulshort
<!-- --></pre>
<!-- -->Header-types are:
<!-- --><pre>
<!-- -->mus-next mus-aifc mus-riff mus-nist mus-raw mus-ircam mus-aiff
<!-- --></pre>
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- normalize-fft -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="normalizefft">normalize-fft</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->FFT normalization choice (default: <i>normalize-by-channel</i>)
<!-- -->If normalize-by-channel (#t) or normalize-by-sound, spectral data is 
<!-- -->normalized to 1.0 before display. If dont-normalize (#f), you get the 
<!-- -->raw data values, which can reflect amplitude changes.  Snd tries to 
<!-- -->choose a y axis limit that makes successive displays move smoothly.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- open-alternate-sound -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndopenalternate">open-alternate-sound</a></em> (name)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->close the currently selected file, if any, and open <i>name</i>.
<!-- -->Returns #f if it can't open <i>name</i>, otherwise the new index. [<em class=error>no-such-file</em>].
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- open-raw-sound -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndrawopen">open-raw-sound</a></em> (name chans srate format)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->open <i>name</i> as a raw (no header) sound in the layout specified.
<!-- -->If the file has a header, it is not ignored (use (set! (data-format ...))
<!-- -->and friends if you want to ignore the header).  [<em class=error>no-such-file</em>].
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- open-sound -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndopen">open-sound</a></em> (name)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->open <i>name</i> as in File menu Open option.  [<em class=error>no-such-file</em>].
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- peak-env-info -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="peakenvinfo">peak-env-info</a></em> (<i>snd chn pos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->returns some of the overall amplitude envelope data for the given channel
<!-- -->at the given edit list position.  The data currently returned are whether
<!-- -->the envelopes are complete (they are the result of a background process), and the min and max data values.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- peaks -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndpeaks">peaks</a></em> (<i>file snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->display fft peak information.  If <i>file</i> is not null, write 
<!-- -->the information to that file, else post it in a help window 
<!-- -->(where it can be selected and pasted elsewhere).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- play -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndplay">play</a></em> (<i>samp snd chn sync end pos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->play <i>snd</i>'s channel <i>chn</i> starting from sample <i>samp</i>. 
<!-- -->If 'sync' is #t, play all sounds syncd to snd.  If 'end' is not given or #f, 
<!-- -->play until end of sound. If 'end' is given (as a sample number), the 
<!-- -->actual end point may be off by a few samples; Snd only checks on 
<!-- -->dac-buffer boundaries (normally around 256 samples).  <i>samp</i> can
<!-- -->also be a filename (a string).  In this case, <i>snd</i> can be the start 
<!-- -->sample (default 0), and <i>chn</i> can be the end sample (default end-of-file).
<!-- -->If <i>pos</i> is given, play at that edit position.
<!-- -->[<em class=error>no-such-file, no-such-sound</em>]
<!-- --><br><br>
<!-- -->The <i>pos</i> argument makes it easier to try "A:B" comparisons.
<!-- --><code>(play 0 #f #f #f #f (1- (edit-position)))</code> plays version before the latest edit.
<!-- --><code>(define (play-then-and-now) (play-and-wait 0 #f #f #f #f (1- (edit-position))) (play))</code>
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- play-and-wait -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndplayandwait">play-and-wait</a></em> (<i>samp snd chn sync end pos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->play <i>snd</i>'s channel <i>chn</i> starting from sample <i>samp</i> and wait 
<!-- -->for it to finish.
<!-- -->If <i>pos</i> is given, play at that edit position.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- player? -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="playerQ">player?</a></em> (obj)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->#t is <i>obj</i> is an active player.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- position->x -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="position2x">position-&gt;x</a></em> (xpos snd chn axis)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->returns the X axis value that corresponds to the graph position <i>xpos</i>. [<em class=error>no-such-axis</em>].
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- position->y -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="position2y">position-&gt;y</a></em> (ypos snd chn axis)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->returns the Y axis value that corresponds to the graph position <i>ypos</i>. [<em class=error>no-such-axis</em>].
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- progress-report -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="progressreport">progress-report</a></em> (pct <i>name current-channel channels snd</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->The functions <i>start-progress-report</i>, <i>progress-report</i>, and 
<!-- --><i>finish-progress-report</i> handle the animated hour-glass icon used 
<!-- -->to amuse the idle user while some long computation is in progress.  
<!-- -->The <i>pct</i> argument is a float between 0.0 and 1.0 which indicates how 
<!-- -->far along we are in the computation (there are actually only 20 separate 
<!-- -->icons, so there's no point in calling this more often than that).  
<!-- -->start-progress-report posts the initial icon, and finish-progress-report 
<!-- -->removes it.  If the icons are not available, a message is posted in 
<!-- --><i>snd's</i> minibuffer using <i>name</i> and so on to identify itself.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- prompt-in-minibuffer -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndpromptinminibuffer">prompt-in-minibuffer</a></em> (msg <i>callback snd</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->Post <i>msg</i> in <i>snd</i>'s minibuffer, and when the user responds,
<!-- -->call <i>callback</i> with the result and the <i>snd</i> (the sound's index).
<!-- -->If <i>callback</i> is specified it should be either #f or a function of 
<!-- -->two arguments [<em class=error>no-such-sound</em>].
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(<em class=red>prompt-in-minibuffer</em> "sample 0 via func:"
<!-- -->  (lambda (func snd) 
<!-- -->    (set! (sample 0) (func (sample 0)))))
<!-- -->    ;; here we're assuming the user will type a function in response to the prompt
<!-- -->    ;;   the value returned by the function will be the new sample 0 value
<!-- -->    ;;   the function should take one argument, the current sample 0 value
<!-- -->    ;; now if the user responds: (lambda (y) (+ y .5))
<!-- -->    ;; sample 0 will be set to itself + .5
<!-- --></pre></td></tr></table></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->See eval-over-selection in <a href="sndscm.html#exampdoc">examp.scm</a> for a more useful example.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- read-only -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndreadonly">read-only</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->#t if <i>snd</i> is read-only, #f otherwise.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a href="#sndredo">redo</a></em> (<i>edits snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->redo <i>edits</i> edits (default is 1) in <i>snd</i>'s channel <i>chn</i>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- read-peak-env-info-file -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="readpeakenvinfofile">read-peak-env-info-file</a></em> (snd chn filename)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->opens <i>filename</i>, assumed to be the peak-env amp info written by <a href="#writepeakenvinfofile">write-peak-env-info-file</a>
<!-- -->for the given channel.  This should be called only within <a href="#initialgraphhook">initial-graph-hook</a>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- report-in-minibuffer -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndreportinminibuffer">report-in-minibuffer</a></em> (msg <i>snd</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->post <i>msg</i> in <i>snd</i>'s minibuffer [<em class=error>no-such-sound</em>].
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- reset-control-panel -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndcontrolpanelreset">reset-control-panel</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->clears the control panel.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- restore-control-panel -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndcontrolpanelrestore">restore-control-panel</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->same as pushing the control panel '<a href="snd.html#savcontrols">r</a>' button.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- reverb-decay -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="reverbdecay">reverb-decay</a></em> (<em class=narg>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->The length (seconds) of the reverberation after the sound has 
<!-- -->finished (default: 1.0).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- reverb-feedback -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndreverbfeedback">reverb-feedback</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- --><i>snd</i>'s reverb feedback coefficient.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- reverb-length -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndreverblength">reverb-length</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- --><a href="snd.html#reverb">reverb</a> delay line length scaler (control panel).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- reverb-lowpass -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndreverblowpass">reverb-lowpass</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->reverb low pass filter coefficient.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- reverb-scale -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndreverbscale">reverb-scale</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- --><a href="snd.html#reverb">reverb</a> amount (control panel).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- reverbing -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndreverbing">reverbing</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->#t if <i>snd</i>'s reverb button is on.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- reverse-sound -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndreverse">reverse-sound</a></em> (<i>snd chn edpos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->reverse data.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- revert-sound -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndrevert">revert-sound</a></em> (<i>snd</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->revert <i>snd</i> to saved state (undo all edits).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- right-sample -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndrightsample">right-sample</a></em> (<em class=targ>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->position (samples) of right edge of time domain waveform.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- sample -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndsample">sample</a></em> (samp <i>snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->value of sample <i>samp</i> in <i>snd</i>'s channel <i>chn</i>.
<!-- -->If the desired sample happens to fall outside the current buffer 
<!-- -->for the indicated channel, this function grinds to a halt -- if you're 
<!-- -->running a loop through a bunch of samples, use the <a href="#samplereaders">sample-readers</a> 
<!-- -->or samples-&gt;vct instead.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- samples -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndsamples">samples</a></em> (<i>samp samps snd chn pos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->return vector of <i>samps</i> samples starting at <i>samp</i> in <i>snd</i>'s channel <i>chn</i>.
<!-- --><i>samp</i> defaults to 0.  <i>samps</i> defaults to frames - samp.
<!-- --><i>pos</i> is the edit history position to read (defaults to current position).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- samples->sound-data -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="samples2sounddata">samples-&gt;sound-data</a></em> (<i>samp samps snd chn v pos sdchan</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->similar to samples-&gt;vct, but fill a sound-data object [<em class=error>no-such-edit</em>].
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- samples->vct -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="samples2vct">samples-&gt;vct</a></em> (<i>samp samps snd chn v pos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->return vct struct with same data as in <i>samples</i> call above.  
<!-- -->If v (a vct object) is provided, it is filled, rather than creating 
<!-- -->a new vct object. <i>pos</i> is the edit history position to read.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- save-control-panel -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndcontrolpanelsave">save-control-panel</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->same as pushing the control panel '<a href="snd.html#savcontrols">s</a>' button.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- save-sound -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndsave">save-sound</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->save <i>snd</i>; same as File menu's Save option. [<em class=error>cannot-save</em>].
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- save-sound-as -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndsaveas">save-sound-as</a></em> (filename <i>snd header-type data-format srate channel edpos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->save <i>snd</i> as <i>filename</i> (same as File Save as option).  If channel is specified,
<!-- -->only that channel is saved (extracted).  <i>edpos</i>, if given, specifies which edit history position to save.
<!-- -->Any argument can be #f which causes its value to be taken from the sound being saved. [<em class=error>cannot-save</em>].
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!--
(save-sound-as...) followed by (open-sound...) to branch
-->
<!-- -->
<!-- -->
<!-- scale-by -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndscaleby">scale-by</a></em> (<i>scalers snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- --><a href="snd.html#scaling">scale</a> amplitude of <i>snd</i> by <i>scalers</i>.  Unlike most of these functions,
<!-- -->scale-by follows the 'sync' buttons and affects all currently sync'd 
<!-- -->channels. <i>scalers</i> can be either a float or a vector of floats.  
<!-- -->In the latter case, the values are used one by one, applying each as 
<!-- -->scale-by moves through the channels. If 'sync' is off, channel <i>chn</i> 
<!-- -->is scaled (defaults to the currently selected channel).  In addition, you
<!-- -->may notice a function named section-scale-by used in saved-state files.
<!-- -->This is essentially scale-by applied to a portion of one channel:
<!-- -->(section-scale-by scaler beg num snd chn).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- scale-to -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndscaleto">scale-to</a></em> (<i>scalers snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->(see scale-by) -- <a href="snd.html#scaling">normalize</a> <i>snd</i> to <i>scalers</i>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- scan-across-all-chans -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="scanacrossallchans">scan-across-all-chans</a></em> (func <i>start end edpos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->apply func to all open channels in parallel (see <a href="#scanning">Scanning Data</a>).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- scan-across-chans -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="scanacrosschans">scan-across-chans</a></em> (func <i>start end edpos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->apply func to currently syncd channels in parallel
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- scan-across-sound-chans -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="scanacrosssoundchans">scan-across-sound-chans</a></em> (func <i>start end snd edpos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->apply func to sound's channels in parallel
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- scan-all-chans -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="scanallchans">scan-all-chans</a></em> (func <i>start end edpos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->apply func to all open channels
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- scan-chan -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="scanchan">scan-chan</a></em> (func <i>start end snd chn edpos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->apply func to samples in current channel (see <a href="#scanning">Scanning Data</a>).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- scan-chans -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="scanchans">scan-chans</a></em> (func <i>start end edpos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->apply func to currently syncd channels
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- scan-sound-chans -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="scansoundchan">scan-sound-chans</a></em> (func <i>start end snd edpos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->apply func to current sound's channels
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- search-procedure -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="searchprocedure">search-procedure</a></em> (<i>snd</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->the current global or sound-local (if <i>snd</i> is specified) search procedure.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- selected-channel -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndselectedchannel">selected-channel</a></em> (<i>snd</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->selected channel in <i>snd</i> (set to select channel).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- selected-sound -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndselectedsound">selected-sound</a></em> ()</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->selected sound (index) (set to select sound).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- select-channel -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndselectchannel">select-channel</a></em> (<i>chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->select channel <i>chn</i>. [<em class=error>no-such-channel</em>].
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- select-sound -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndselectsound">select-sound</a></em> (<i>snd</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->select sound <i>snd</i> (an index). [<em class=error>no-such-sound -&gt; index</em>].
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- set-contrast-func -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="contrastfunc">set-contrast-func</a></em> (func)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->set contrast function to <i>func</i>, a function of two arguments, 
<!-- -->the current sample and the current 'contrast' slider setting, 
<!-- -->returning a new sample, the result of the control panel contrast 
<!-- -->function; <i>func</i> replaces the built-in contrast function.
<!-- -->The built-in default (mus-contrast-enhancement) is snd-contrast.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- set-reverb-funcs -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="reverbfuncs">set-reverb-funcs</a></em> (reverb make-reverb free-reverb)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->This function replaces the built-in Snd reverb with your own.
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(define delay-line #f)
<!-- -->(define delay-time 0.5)
<!-- -->
<!-- -->(<em class=red>set-reverb-funcs</em>
<!-- -->  (lambda (ptr invals outvals)
<!-- -->    (vct-set! outvals 0 
<!-- -->      (delay delay-line 
<!-- -->             (+ (* .75 (tap delay-line)) 
<!-- -->                (vct-ref invals 0))))
<!-- -->    outvals)
<!-- -->  (lambda (snd chans)
<!-- -->    (set! delay-line 
<!-- -->      (make-delay (inexact-&gt;exact (* (srate snd) delay-time))))
<!-- -->    delay-line)
<!-- -->  (lambda (ptr)
<!-- -->    ptr))
<!-- --></pre></td></tr></table></td></tr>
<!-- --><tr><td></td><td>
<!-- -->The three arguments are the reverb, the function that makes or
<!-- -->initializes the reverb, and the function to free the reverb.
<!-- -->The built-in defaults are snd-nrev, make-snd-nrev, and free-snd-nrev.
<!-- -->Another choice is Jezar Wakefield's Freeverb: snd-freeverb, etc.
<!-- -->The make-reverb function takes two arguments, the current sound's index,
<!-- -->and the number of output channels active; it returns an opaque object that 
<!-- -->is subsequently passed to the reverb and free-reverb functions
<!-- -->The reverb function takes 3 arguments, the thing returned by make-reverb, 
<!-- -->the current reverb input samples (a vct object), and the output vct object
<!-- -->which it should fill with the current reverb output contribution.
<!-- --><br><br>
<!-- -->I may change this to take a list of three functions, rather than the
<!-- -->three functions themselves; as it is, there's no generalized set! for
<!-- -->reverb-funcs.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- set-samples -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndsetsamples">set-samples</a></em> (samp samps data <i>snd chn trunc</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->set <i>snd</i>'s channel <i>chn</i>'s samples starting from
<!-- -->sample <i>samp</i> for <i>samps</i> samples to the values in <i>data</i>.
<!-- --><small>(If <i>samp</i> is beyond the end of the file, the file is first zero-padded to reach it).</small>
<!-- --><i>data</i> can be a filename; Snd assumes any such file is temporary; it will
<!-- -->be deleted when no longer needed.  If <i>trunc</i> is #t and <i>samp</i> is 0, the
<!-- -->sound is truncated (if necessary) to reflect the end of <i>data</i>.
<!-- -->The form (set! (samples samp samps <i>snd chn trunc</i>) data) can also be used.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- short-file-name -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndshortfilename">short-file-name</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->return the brief (no directory) form of <i>snd</i>'s filename.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- show-axes -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="showaxes">show-axes</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->(default: show-all-axes)
<!-- -->If show-all-axes, display x and y axes; if show-x-axis, 
<!-- -->just one (bottom) x axis is displayed, reducing screen clutter. 
<!-- -->The other choice is show-no-axes.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- show-controls -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndshowcontrols">show-controls</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->#t if <i>snd</i>'s control panel is open.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- show-fft-peaks -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="showfftpeaks">show-fft-peaks</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->If #t, fft peak information is included in the fft display (default: #f).
<!-- -->(This is the 'peaks' button in the <a href="snd.html#viewfft">Transform</a> options dialog).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- show-marks -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="showmarks">show-marks</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->If #t, marks are displayed.  This is the '<a href="snd.html#marks">Show marks</a>' View menu option.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- show-mix-waveforms -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="showmixwaveforms">show-mix-waveforms</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->If #t (default = #t), mix displays the waveform of the sound
<!-- -->being mixed.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- show-y-zero -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="showyzero">show-y-zero</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->If #t, the y=0 axis is displayed.  This is the '<a href="snd.html#viewy0">Show Y=0</a>' View menu option.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- smooth -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndsmooth">smooth</a></em> (beg num <i>snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->apply a smoothing function to the indicated data.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- sound? -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndok">sound?</a></em> (<i>snd</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->#t if <i>snd</i> (an index) is active.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- soundfont-info -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="soundfontinfo">soundfont-info</a></em> (<i>snd</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->return a list of lists describing <i>snd</i> as a soundfont.  Each inner list
<!-- -->consists of the sound name, start point, loop start, and loop end.
<!-- -->To set a named mark at the start of each sound with un-named marks 
<!-- -->at the loop points:
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(define (mark-sf2)
<!-- -->  (letrec ((sf2it (lambda (lst)
<!-- -->                    (if (not (null? lst))
<!-- -->                        (let ((vals (car lst)))
<!-- -->                          (let ((m1 (add-mark (cadr vals))))
<!-- -->                            (set! (mark-name m1) (car vals)))
<!-- -->                          (add-mark (caddr vals))
<!-- -->                          (add-mark (cadddr vals))
<!-- -->                          (sf2it (cdr lst)))))))
<!-- -->   (sf2it (<em class=red>soundfont-info</em>))))
<!-- --></pre></td></tr></table></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- sound-loop-info -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="sndsoundloopinfo">sound-loop-info</a></em> (<i>snd</i>)</code></span></td>
<!-- --></tr><tr><td></td>
<!-- --><td>returns or sets loop points in header.  In each case, the loop info is a list of
<!-- -->up to 4 points, the first two (start, end) refer to the "sustain" loop,
<!-- -->the second two to the "release".  This is similar to mus-sound-loop-info (but it's settable).
<!-- --></td></tr>
<!-- -->
<!-- sounds -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sounds">sounds</a></em> ()</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->list of currently active sounds (id numbers).
<!-- -->A common Snd trope is (map func (sounds)): (map maxamp (sounds)).  This can be
<!-- -->extended to provide a complete list of sounds and channels (since many Snd functions
<!-- -->take the "snd chn" arguments:
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(define (all-chans)
<!-- -->  (let ((sndlist '())
<!-- -->        (chnlist '()))
<!-- -->    (for-each (lambda (snd)
<!-- -->                (do ((i (1- (channels snd)) (1- i)))
<!-- -->                    ((&lt; i 0))
<!-- -->                  (set! sndlist (cons snd sndlist))
<!-- -->                  (set! chnlist (cons i chnlist))))
<!-- -->              (<em class=red>sounds</em>))
<!-- -->    (list sndlist chnlist)))
<!-- -->
<!-- -->(apply map maxamp (all-chans))
<!-- --></pre></td></tr></table>
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- sound-to-temp -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="soundtotemp">sound-to-temp</a></em> (<i>type format edpos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->write out sync'd edit state as a temp file (see <a href="grfsnd.html#programs">external programs</a>).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- sound-to-temps -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="soundtotemps">sound-to-temps</a></em> (<i>type format edpos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->write out sync'd edit state as temp files (see <a href="grfsnd.html#programs">external programs</a>).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- spectro-cutoff -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="spectrocutoff">spectro-cutoff</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->The amount of the frequency domain to include in the spectrum 
<!-- -->display (default: 1.0). This number changes as you drag the frequency
<!-- -->axis. This is the slider labelled '% of spectrum' in the View 
<!-- -->Orientation dialog.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- spectro-hop -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="spectrohop">spectro-hop</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->The distance (pixels) moved between successive spectrogram traces 
<!-- -->(default = 4).  This is the 'hop' slider in the Orientation dialog.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- spectro-start -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="spectrostart">spectro-start</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->The start point of the frequency domain to include in the spectrum
<!-- -->display (default 0.0).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- spectro-x-angle -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="spectroxangle">spectro-x-angle</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->Default spectrogram x-axis viewing angle (default 90.0).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- spectro-x-scale -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="spectroxscale">spectro-x-scale</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->Default scaler (stretch) along the spectrogram x axis (default 1.0).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- spectro-y-angle -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="spectroyangle">spectro-y-angle</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->Same for y-axis (default 0.0).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- spectro-y-scale -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="spectroyscale">spectro-y-scale</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->Same for y-axis (default 1.0).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- spectro-z-angle -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="spectrozangle">spectro-z-angle</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->Same for z-axis (default -2.0).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- spectro-z-scale -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="spectrozscale">spectro-z-scale</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->Same for z-axis (default 0.1).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- speed -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndspeed">speed</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->current <a href="snd.html#speed">speed</a> (control panel).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- speed-style -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="lspeedstyle">speed-style</a></em> (<em class=narg>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->In the control panel, the 'speed' control can be interpreted as a 
<!-- -->float, (<i>speed-as-float</i>, the default), as a just-intonation ratio 
<!-- -->of relatively small integers (<i>speed-as-ratio</i>) or as a step in a 
<!-- -->microtonal scale (<i>speed-as-semitone</i>).  
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- speed-tones -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="speedtones">speed-tones</a></em> (<em class=narg>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->The number of tones per octave in the <i>speed-as-semitone</i> speed 
<!-- -->style (default: 12).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- squelch-update -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="squelchupdate">squelch-update</a></em> (<em class=targ>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->are graphic updates squelched (turned off).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- srate -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndsrate">srate</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- --><i>snd</i>'s sampling rate.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- src-sound -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndsrc">src-sound</a></em> (num-or-env <i>base snd chn edpos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->sampling rate conversion using 'warped sinc interpolation'.  The
<!-- -->argument <i>num-or-env</i> can be either a number or an envelope.  In 
<!-- -->the latter case, <i>base</i> sets the segment base (default is 1.0 = linear).
<!-- -->A value greater than 1.0 causes the sound to be transposed up.
<!-- -->A value less than 0.0 causes the sound to be reversed. 
<!-- --><br>
<!-- --><i>num-or-env</i> can also be a CLM env generator (its duration should
<!-- -->be the same as the original sound).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- start-playing -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="startplaying">start-playing</a></em> (<i>chans srate background</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->if a play-list is waiting, start it.  <i>chans</i> defaults to 1, 
<!-- --><i>srate</i> defaults to 44100, <i>background</i> defaults to #t.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- start-progress-report -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="startprogressreport">start-progress-report</a></em> (<i>snd</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->see <a href="#progressreport">progress-report</a>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- stop-player -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="stopplayer">stop-player</a></em> (player)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->remove <i>player</i> from play-list(see <a href="#makeplayer">make-player</a>). [<em class=error>no-such-player</em>]
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- stop-playing -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndstop">stop-playing</a></em> (<i>snd</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->if <i>snd</i> is playing, stop it [<em class=error>no-such-sound</em>].
<!-- -->If no argument is given, stop all sounds (channels) in progress.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- swap-channels -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="swapchannels">swap-channels</a></em> (<i>snd1 chn1 snd2 chn2 beg dur</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->Swap the indicated channels, between beg and beg+dur.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- sync -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndsyncing">sync</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- --><i>snd</i>'s 'sync' value (an integer, 0=off).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- temp-to-sound -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="temptosound">temp-to-sound</a></em> (data name origin)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->read sync'd edit state from temp file (see <a href="grfsnd.html#programs">external programs</a>).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- temps-to-sound -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="tempstosound">temps-to-sound</a></em> (data names origin)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->read sync'd edit state from temp files (see <a href="grfsnd.html#programs">external programs</a>).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- transform-sample -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndtransformsample">transform-sample</a></em> (<i>bin slice snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->return the current value of the transform (if any) in <i>bin</i> and (if a 
<!-- -->sonogram or spectrogram) <i>slice</i> in <i>snd</i>'s channel <i>chn</i>.  
<!-- -->Use <a href="#sndupdatefft">update-fft</a> to make sure the transform has run to completion. [<em class=error>no-such-sample</em>].
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- transform-samples -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndtransformsamples">transform-samples</a></em> (<i>snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->return the transform data currently in <i>snd</i>'s channel <i>chn</i>.
<!-- -->Use <a href="#sndupdatefft">update-fft</a> to make sure the transform has run to completion.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- transform-samples->vct -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="transformsamples2vct">transform-samples-&gt;vct</a></em> (<i>snd chn v</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->return vct struct with the transform data currently in <i>snd</i>'s channel <i>chn</i>.
<!-- -->If v (a vct) is provided, it is filled, rather than creating a new vct.
<!-- -->Use <a href="#sndupdatefft">update-fft</a> to make sure the transform has run to completion.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- transform-size -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="transformsize">transform-size</a></em> (<i>snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->returns either 0 if no transform, fft-size if normal-fft, 
<!-- -->or (list full-size bins slices) if sonogram or spectrogram.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- transform-type -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="ltransformtype">transform-type</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->The spectrum transform type (default: <i>fourier-transform</i>).
<!-- --><pre>
<!-- -->fourier-transform  wavelet-transform   hankel-transform    chebyshev-transform
<!-- -->autocorrelation    walsh-transform     hadamard-transform  cepstrum     haar-transform
<!-- --></pre>
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a href="#sndundo">undo</a></em> (<i>edits snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->undo <i>edits</i> edits (default 1) in <i>snd</i>'s channel <i>chn</i>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- uniting -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="snduniting">uniting</a></em> (<em class=targ>snd</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->#f if channels are not superimposed or combined ('unite' button is off).
<!-- -->The global name of this is channel-style.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- update-fft -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndupdatefft">update-fft</a></em> (<i>snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->recalculate <i>chn's</i> fft, forcing it to completion.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- update-graph -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndupdategraph">update-graph</a></em> (<i>snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->redisplay <i>chn's</i> graph(s).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- update-lisp-graph -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndupdatelispgraph">update-lisp-graph</a></em> (<i>snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->redisplay <i>chn's</i> lisp graph.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- update-sound -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndupdate">update-sound</a></em> (snd)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->update <i>snd</i> (re-reads data from disk, flushing any pending edits).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- view-sound -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndview">view-sound</a></em> (filename)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->open <i>filename</i> read-only. [<em class=error>no-such-file</em>].
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- verbose-cursor -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="verbosecursor">verbose-cursor</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->If #t, the cursor's position and other information is constantly 
<!-- -->displayed in the minibuffer.  This is the View:Verbose cursor option 
<!-- -->(default: #f).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- wavelet-type -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="wavelettype">wavelet-type</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->If <i><a href="#ltransformtype">transform-type</a></i> is <i>wavelet-transform</i>, <i>wavelet-type</i> selects which 
<!-- -->wavelet is used.  The list of available wavelets is in the Transform 
<!-- -->Dialog. There are currently 20 choices, so this variable goes from 
<!-- -->0 to 19 (default: 0).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- waving -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndwaving">waving</a></em> (<em class=targ>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->the state of <i>snd</i>'s channel <i>chn</i>'s 'w' button.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- wavo -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="wavo">wavo</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->If #t, the time domain waveform is displayed as a '<a href="snd.html#wavogram">wavogram</a>'.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- wavo-hop -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="wavohop">wavo-hop</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->This sets the distance upward between wavogram traces; that is,
<!-- -->the smaller this number, the more traces can be displayed (default: 3).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- wavo-trace -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="wavotrace">wavo-trace</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->This sets the length (samples) of each wavogram trace (default: 64).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- x-axis-style -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="xaxisstyle">x-axis-style</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->The x axis labelling of the time domain waveform can be in seconds
<!-- -->(<i>x-in-seconds</i>), in samples (<i>x-in-samples</i>), or expressed
<!-- -->as a percentage of the overall duration (useful in envelope definitions).
<!-- -->The latter is <i>x-to-one</i>. This is the View menu 'X-axis units' option.
<!-- -->(default: <i>x-in-seconds</i>). 
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- write-peak-env-info-file -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="writepeakenvinfofile">write-peak-env-info-file</a></em> (snd chn filename)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->writes the current peak-env amp info of the given channel to <i>filename</i>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- x-bounds -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndxbounds">x-bounds</a></em> (<i>snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->return (list x0 x1) -- current x axis time domain bounds in seconds.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- x->position -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="x2position">x-&gt;position</a></em> (x snd chn axis)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->returns the graph position that corresponds to the X axis value <i>x</i>. [<em class=error>no-such-axis</em>].
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- x-position-slider -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="xpositionslider">x-position-slider</a></em> (<em class=targ>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->value of x axis position slider.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- x-zoom-slider -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="xzoomslider">x-zoom-slider</a></em> (<em class=targ>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->value of x axis zoom slider.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- y-bounds -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndybounds">y-bounds</a></em> (<i>snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->return (list y0 y1) -- current y axis bounds.
<!-- -->To set the bounds to reflect the channel's maxamp, use (set! (y-bounds) '()).
<!-- -->To set all channels at once using the selected sound's maxamp:
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(let ((maxval (apply max (maxamp #f #t)))) 
<!-- -->  (do ((i 0 (1+ i))) 
<!-- -->      ((= i (chans))) 
<!-- -->    (set! (<em class=red>y-bounds</em> #f i) (list (- maxval) maxval))))
<!-- --></pre></td></tr></table></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->Or to set each channel to its own maxamp:
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(do ((i 0 (1+ i))) 
<!-- -->    ((= i (chans)))
<!-- -->  (let ((maxval (maxamp #f i))) 
<!-- -->    (set! (<em class=red>y-bounds</em> #f i) (list (- maxval) maxval))))
<!-- --></pre></td></tr></table>
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- y->position -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="y2position">y-&gt;position</a></em> (y snd chn axis)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->returns the graph position that corresponds to the Y axis value <i>y</i>. [<em class=error>no-such-axis</em>].
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- y-position-slider -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="ypositionslider">y-position-slider</a></em> (<em class=targ>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->value of y axis position slider.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- y-zoom-slider -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="yzoomslider">y-zoom-slider</a></em> (<em class=targ>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->value of y axis zoom slider.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- -->
<!-- zero-pad -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="zeropad">zero-pad</a></em> (<em class=narg>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->fft zero pad size as a multiple of the fft size; <code>(set! (zero-pad) 1)</code>
<!-- -->gives you half data, half zeros (default: 0) (the data length is 
<!-- -->determined by the nominal fft-size).  Zero padding causes sinc-interpolation 
<!-- -->of the fft points, making the display smoother.
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(bind-key (char-&gt;integer #\p) 0 
<!-- -->  (lambda () 
<!-- -->    (set! (zero-pad) (+ (<em class=red>zero-pad</em>) 1)) 
<!-- -->    (update-fft)))
<!-- -->
<!-- -->(bind-key (char-&gt;integer #\m) 0 
<!-- -->  (lambda () 
<!-- -->    (set! (zero-pad) (- (<em class=red>zero-pad</em>) 1)) 
<!-- -->    (update-fft)))
<!-- --></pre></td></tr></table></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- --></table>


<span class=cbox><h4><A NAME="customcontrols">the control panel</a></h4></span>

<p>
The control panel normally processes samples as follows: if the sampling
rate conversion is on (the 'Speed' control is not 1.0), it applies srate
conversion to the incoming sample; the next stage is the expansion function,
if the 'Expand' toggle button is set; this value is passed
next to the Contrast function, if it is running, and then the result
is scaled by the Amp slider's value.  The filter is run next, if
it's on, and finally the sample is scaled by the reverb slider and
passed to the reverb, if any, which adds its result to the sample;
the final result is sent to the speakers.  Besides the various user
interface controls, and variables such as expand-hop, you can also
change this sequence by replacing the contrast, expand, or reverb
functions with your own.  <b>set-contrast-func</b> replaces the
contrast-enhancement function; <b>set-reverb-funcs</b> replaces
the reverb.
</p>

<!-- Edit Lists -->
<br>
<span class=cbox><h3><A NAME="editlists">Edit Lists</a></h3></span>

<p>An edit list describes the edit history of a channel.  When, for example, you type C-d, nothing actually
happens to any data, despite the fact that the graph no longer shows that sample, it's gone when you play the
channel, and so on.  What actually happens is that a descriptor is appended to the edit history of that
channel saying "sample n was deleted".  Undo and redo move around in this list (they simply move the
pointer to the current edit history position); all the positions are accessible just like the current
one, and are exposed in many functions described above as the <i>pos</i> argument. The edit list functions are:</p>

<!-- -------------------------------- EDIT-LIST TABLE -------------------------------- -->
<!-- -->
<!-- --><table border=0 cellspacing=10>
<!-- -->
<!-- as-one-edit -->
<!-- -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="asoneedit">as-one-edit</a></em> (func <i>origin</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td width=150></td><td>
<!-- -->apply <i>func</i> (a function of no arguments), treating it as
<!-- -->one edit (in all channels) in the edit history mechanism.
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(<em class=red>as-one-edit</em> 
<!-- -->  (lambda () 
<!-- -->    (set! (sample 100) .1) 
<!-- -->    (set! (sample 200) .2)))
<!-- --></pre></td></tr></table></td></tr>
<!-- --><tr><td></td><td></td></tr>
<!-- -->
<!-- display-edits -->
<!-- -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="snddisplayedits">display-edits</a></em> (<i>snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->returns the current edit list contents (as a string).
<!-- --></td></tr>
<!-- --><tr><td></td><td></td></tr>
<!-- -->
<!-- edit-fragment -->
<!-- -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndeditfragment">edit-fragment</a></em> (<i>num</i> <em class=targ>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->return a list similar to that displayed in the edit history window giving 
<!-- -->the origin of the specified edit, its type (delete, insert, etc), its 
<!-- -->begin sample (given the current edit tree), and the number of samples 
<!-- -->affected.  If num is omitted, return the last (currently active) 
<!-- -->edit [<em class=error>no-such-edit</em>].
<!-- --></td></tr>
<!-- --><tr><td></td><td></td></tr>
<!-- -->
<!-- edit-position -->
<!-- -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndeditposition">edit-position</a></em> (<em class=targ>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->current position in edit history list (can be set).
<!-- --></td></tr>
<!-- --><tr><td></td><td></td></tr>
<!-- -->
<!-- edits -->
<!-- -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndedits">edits</a></em> (<em class=targ>snd chn</em>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->return a list with number of undo-able edits and redo-able edits.
<!-- --></td></tr>
<!-- --><tr><td></td><td></td></tr>
<!-- -->
<!-- edit-tree -->
<!-- -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndedittree">edit-tree</a></em> (<i>snd chn pos</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->return list of lists completely describing current edit list.
<!-- -->Each inner list has the form 
<!-- --><br>
<!-- -->'(global-position data-number local-position local-end scaler).
<!-- --><br>
<!-- -->If <i>data-number</i> is -2, it marks the end of the list.  The following function uses
<!-- -->this information to highlight the changed portions of a given sound.
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(define (<A NAME="showoriginal">show-original</a> snd chn)
<!-- -->  ;; draw a bar above unchanged portions of a sound
<!-- -->  (define (check-fragment tree ls rs)
<!-- -->    (let* ((fragment (car tree))       ; current edit list fragment
<!-- -->           (pos (car fragment))        ; its position in sound
<!-- -->           (dat (cadr fragment))
<!-- -->           (scl (list-ref fragment 4)))
<!-- -->      (if (and (= dat 0)               ; original sound
<!-- -->               (= scl 1.0))            ; unscaled
<!-- -->          (let ((nxtpos (car (cadr tree))))
<!-- -->            (if (and (&lt;= pos rs)
<!-- -->                     (&gt;= nxtpos ls))   ; fragment is at least partially visible
<!-- -->                (let ((x0pos (x->position (/ (max ls pos) (srate))))
<!-- -->                      (x1pos (x->position (/ (min rs nxtpos) (srate)))))
<!-- -->                  (fill-rectangle x0pos 2 (- x1pos x0pos) 5)))))
<!-- -->      (if (and (cdr tree)              ; go to next fragment
<!-- -->               (not (= (cadr (car tree)) -2)))
<!-- -->          (check-fragment (cdr tree) ls rs))))
<!-- -->   (check-fragment (<em class=red>edit-tree</em> snd chn)
<!-- -->                   (left-sample snd chn)
<!-- -->                   (right-sample snd chn)))
<!-- -->(add-hook! after-graph-hook show-original)
<!-- --></pre></td></tr></table></td></tr>
<!-- --><tr><td></td><td></td></tr>
<!-- -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def>revert-sound</em> (<i>snd</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->revert <i>snd</i> to saved state (undo all edits).
<!-- --></td></tr>
<!-- --><tr><td></td><td></td></tr>
<!-- -->
<!-- save-edit-history -->
<!-- -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndsaveedithistory">save-edit-history</a></em> (filename <i>snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->save current edit list(s) in <i>filename</i>.
<!-- -->If <i>chn</i> is omitted, all <i>snd</i>'s channels are saved; if <i>snd</i> is omitted,
<!-- -->all edit list are saved.  If the underlying files are not subsequently 
<!-- -->changed, you can load this file to restore the current edit list state.
<!-- -->Returns #t if successful (file opened ok); if something went wrong 
<!-- -->[<em class=error>cannot-save</em>].
<!-- --></td></tr>
<!-- --><tr><td></td><td></td></tr>
<!-- -->
<!-- redo -->
<!-- -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndredo">redo</a></em> (<i>edits snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->redo <i>edits</i> edits (default is 1) in <i>snd</i>'s channel <i>chn</i>.
<!-- --></td></tr>
<!-- --><tr><td></td><td></td></tr>
<!-- -->
<!-- undo -->
<!-- -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndundo">undo</a></em> (<i>edits snd chn</i>)</code></span>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->undo <i>edits</i> edits (default 1) in <i>snd</i>'s channel <i>chn</i>.
<!-- --></td></tr>
<!-- -->
<!-- --></table>

<p>It is sometimes more convenient to edit the edit history lists
directly, than to run Snd and invoke the <a href="snd.html#savedstate">"Save State"</a> menu option.
To save a particular sound's or channel's edit list(s), use the
function <a href="#sndsaveedithistory">save-edit-history</a>.
These lists are simply Scheme programs, just like anything else
discussed in this document.  You could even write them from
scratch.  Say we want to make a stereo file that consists
of four mono files mixed at various points; we know where they
should go, and we have religious objections to using a
graphical user interface.  So we create myfile.scm, and
put in it something like:</p>

<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(let ((myfile (<a href="#sndnew">new-sound</a> "mysound.snd" mus-aifc-sound-file mus-bshort 44100 2 "this is my sound")))
	;; this is equivalent to the New file menu option
  (<a href="#sndmix">mix</a> "oboe.snd" 0 0 myfile 0)
  ;; this mixes in the mono file oboe.snd at sample 0 in channel 0
  ;; use (mix "oboe.snd" 0 0 myfile 0 #f) to forego the editable mix
  (mix "pistol.snd" 0 0 myfile 1)
  ;; now pistol.snd is at sample 0 in channel 1
  (mix "fyow.snd" 10000 0 myfile 0)
  ;; add in fyow.snd at sample 10000 in the first channel
  (mix "cardinal.snd" 20000 0 myfile 1)
  ;; etc
  )
</pre></td></tr></table>

<p>Now fire up Snd: <code>snd -l myfile.scm</code> and voila!
Files like this can contain any arbitrary Scheme code, calling
anything in Snd or anywhere else for that matter; you basically
have a CLM-like notelist reader to describe sound file edits.
Similarly, when you save Snd's state (via the Save State menu
option or by calling the function <a href="#sndsavestate">save-state</a>),
the result is a Scheme program that can be edited just like any
other such text.
</p>
<p>
Many editing operations within Snd actually only affect the current
edit lists.  For example, if you delete a portion of a sound, the
only thing that happens is that the edit list of that sound is
updated to reflect the jump over the deleted portion.  Similarly,
all scaling operations (normalization etc), operations resulting
in zeros, and simple cases of channel swaps are actually only editing
the edit list.  This means that ideally such operations are instantaneous
and take no disk space no matter how large the sound being edited
(in other cases we have to save at least the changed portion of the
sound).  I'm toying with extending this part of Snd to more complex
operations.
</p>

<!-- Scanning Data -->
<br>
<span class=bbox><h3><A NAME="scanning">Scanning Data</a></h3></span>

<p>Sound files can be enormous, far larger than available memory, so vector access to
sample data (as in <a href="#sndsetsamples">set-samples</a>) is not always very useful.
(Each sample setting call is treated as a separate edit by Snd, but we would normally
want the entire operation to be handled as one edit; we could wrap up all the sample setting
calls in <a href="#asoneedit">as-one-edit</a>, but it's a bit wasteful).
In addition, the collection of available channels of data in the editor can present
a complicated access problem.  The 14 scanning and mapping functions provide what
I hope is a straightforward answer to these problems.  The "scan" functions do
not change any data; they simply run through data presenting it to the caller.
The "map" functions can change data, if they wish; the entire mapping call
becomes one large editing operation from the editor's point of view.
There are four ways to get at the editor's data: one channel, a sound's
channels, all currently open channels, and all currently sync'd channels.
There are two ways to march through this collection of channels: in series
(that is, one channel at a time), and in parallel (all channels at once);
the former is the default, and for the latter, I use the word "across".
So map-chan maps a function over a single channel; map-chans affects
the currently syncd channels (in series); map-across-chans affects the
same set of channels, but they are presented to the caller's function
as an array, each element of the array being a channel's sample at the
current location in the map; map-all-chans affects all currently open
channels; and finally, map-sound-chans affects all of a sound's channels,
independent of the 'sync' button.  The 'scan' functions behave similarly.
In each case, an optional subsequence of the data can be requested via
'start' and 'end' points.  If beg is #f, it defaults to 0; if end is #f,
it defaults to the end of the channel.
</p>

<table cellpadding=0 cellspacing=0>
<tr><td width=450><b>map-across-all-chans</b> (func <i>start end edname edpos</i>)</td><td>apply func to all open channels in parallel</td></tr>
<tr><td><b>map-across-chans</b> (func <i>start end edname edpos</i>)</td><td>apply func to currently syncd channels in parallel</td></tr>
<tr><td><b>map-across-sound-chans</b> (func <i>start end edname snd edpos</i>)</td><td>apply func to sound's channels in parallel</td></tr>
<tr><td><b>map-all-chans</b> (func <i>start end edname edpos</i>)</td><td>apply func to all open channels</td></tr>
<tr><td><b>map-chan</b> (func <i>start end edname snd chn edpos</i>)</td><td>apply func to samples in current channel</td></tr>
<tr><td><b>map-chans</b> (func <i>start end edname edpos</i>)</td><td>apply func to currently syncd channels</td></tr>
<tr><td><b>map-sound-chans</b> (func <i>start end edname snd edpos</i>)</td><td>apply func to current sound's channels</td></tr>
<tr><td><br></td><td><br></td></tr>
<tr><td><b>scan-across-all-chans</b> (func <i>start end edpos</i>)</td><td>apply func to all open channels in parallel</td></tr>
<tr><td><b>scan-across-chans</b> (func <i>start end edpos</i>)</td><td>apply func to currently syncd channels in parallel</td></tr>
<tr><td><b>scan-across-sound-chans</b> (func <i>start end snd edpos</i>)</td><td>apply func to sound's channels in parallel</td></tr>
<tr><td><b>scan-all-chans</b> (func <i>start end edpos</i>)</td><td>apply func to all open channels</td></tr>
<tr><td><b>scan-chan</b> (func <i>start end snd chn edpos</i>)</td><td>apply func to samples in current channel</td></tr>
<tr><td><b>scan-chans</b> (func <i>start end edpos</i>)</td><td>apply func to currently syncd channels</td></tr>
<tr><td><b>scan-sound-chans</b> (func <i>start end snd edpos</i>)</td><td>apply func to current sound's channels</td></tr>
</table>

<p>In the case of the scanning operations, the function passed as the first argument takes
either the current sample (when scanning in series), or two arguments, the current
array of samples, and the array's length (when scanning in parallel).  If the function
returns something other than #f, the scan is stopped and (in the series case) a list is returned to
the caller containing the non-#f value returned, the current sample position of the
scan, the current channel number, and the current sound index; in the parallel case, the current
sample position is returned.  So, for example, the following call scans the
current channel from sample 0 to the end looking for any sample greater than
.1:</p>
<pre>
&gt;<em class=typing>(scan-chan (lambda (y) (&gt; y .1)))</em>
<em class=listener>(#t 4423 0 0)</em>
</pre>
<p>In this case, we found such a sample at position 4423 of the first channel of the
sound whose index is 0.  
Here's an example of scanning across all channels,
returning the maximum sample value found:</p>
<pre>
(define data-max 
  (lambda ()
    (let ((maxval 0.0))
      (scan-across-all-chans
        (lambda (data len)
	  (do ((i 0 (1+ i)))
	      ((= i len) #f)
	    (let ((curval (abs (vector-ref data i))))
	      (if (&gt; curval maxval) (set! maxval curval))))))
      maxval)))

&gt;<em class=typing>(data-max)</em>
<em class=listener>0.492675779232</em>

(define every-sample?
  (lambda (proc)
    (let ((baddy (scan-chan (lambda (y) (not (proc y))))))
      (if baddy (set! (cursor) (cadr baddy)))
      (not baddy))))

&gt;<em class=typing>(every-sample? (lambda (y) (&lt; y .5)))</em>
<em class=listener>#t</em>
</pre>
<p>The mapping operations are slightly more complicated because they
can edit the data.  The fourth argument <i>edname</i> is the
name of the editing operation that will be reported by the
edit history mechanism.  If none is given, it will default to
the name of the calling map function (which has little
to do with the actual edit).  The other arguments to the mapping
calls are the same as corresponding scanning calls.  The function
passed (and applied to the data) also takes the same arguments;
its return value is interpreted differently however.  The applied
function can return #f, which means that the data passed in is
deleted (replaced by nothing), or a number which replaces the
current sample (in the parallel case this is an array of numbers),
or #t which halts the mapping operation, leaving trailing samples
unaffected, or a list, vct object, or vector of numbers (in the parallel case,
an embedded array as an element of the outer array); in this
case, the numbers are spliced into the edited version, effectively
replacing the current sample with any number of samples. This sounds
more complicated than it is!  Basically, a map in series receives
each sample and returns either #f (no corresponding output), a number
(the new output), or a list of numbers; a map in parallel does the
same for each sample in the array passed to it. 
If every value returned for a given channel is #f, the data is not edited.
This makes it possible to run through all current channels in parallel,
changing only one channel (or a subset of them).
</p>
<pre>
&gt;<em class=typing>(map-chan (lambda (y) (+ y .2)))</em>
<em class=listener>#f</em>

&gt;<em class=typing>(map-chan (lambda (y) (cos y)) #f #f "(cos y)")</em>
<em class=listener>#f</em>

&gt;<em class=typing>(map-chan (lambda (y) (if (&gt; y .1) (list .1 .2 .3) y))) </em>
<em class=listener>#f</em>

(define swap-channels
  (lambda ()
    (if (= (channels) 2)
	(map-across-sound-chans
	 (lambda (data chans)
	   (let ((chan0-sample (vector-ref data 0)))
	     (vector-set! data 0 (vector-ref data 1))
	     (vector-set! data 1 chan0-sample)
	     data))
	 #f #f "swap-channels")
	(string-append (short-file-name) " is not stereo!"))))

</pre>
<p>The edit history may show multiple entries for a given map application;
it may have to delete the old samples before
inserting the new samples.  This means that you may have to repeat 'undo'
once or twice to get back to the state before the map operation. 
Wrap the call up in <a href="#asoneedit">as-one-edit</a> to get around this.
Here's a slightly more involved example;
we define a function that finds silences and replaces them with
something:<p>

<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(define map-silence
  ;; see squelch in <a href="sndscm.html#effectsdoc">effects.scm</a> for a better version
  (lambda (silence replacement)
    (let ((sum-of-squares 0.0)
	  (buffer (make-vector 128 0.0))
	  (position 0)
	  (current-sample 0)
	  (chan-samples (frames)))
      (lambda (y)
        (let ((old-y (vector-ref buffer position)))
	  (set! sum-of-squares (- (+ sum-of-squares (* y y)) (* old-y old-y)))
	  (vector-set! buffer position y)
	  (set! position (1+ position))
	  (if (= position 128) (set! position 0))
	  (set! current-sample (1+ current-sample))
	  (if (&gt; sum-of-squares silence)
	      (if (= current-sample chan-samples)
		  ;; at end return trailing samples as long as it looks like sound
		  (let ((temp-buffer (make-vector 128 0.0)))
		    (do ((i 0 (1+ i)))
			((= i 128) temp-buffer)
		      (let ((final-y (vector-ref buffer position)))
			(vector-set! temp-buffer i (if (&gt; sum-of-squares silence) final-y 0.0))
			(set! sum-of-squares (- sum-of-squares (* final-y final-y)))
			(set! position (1+ position))
			(if (= position 128) (set! position 0)))))
		  old-y)
	    replacement))))))

(map-chan (map-silence .01 0.0))  ; squelch background noise
(map-chan (map-silence .001 #f))   ; remove silences altogether
</pre></td></tr></table>

<p>In case it isn't obvious, we're using <i>buffer</i> to hold a running
portion of the sound, and <i>sum-of-squares</i> to hold the sum of the squares
of all the samples in that portion.  When the portion's sum falls below
the argument <i>silence</i>, we replace the current sample with <i>replacement</i>.
At the end, we flush out all the remaining samples awaiting output in <i>buffer</i>.</p>

<p>It is possible to break out of a map, flushing any edits, via call-with-current-continuation:</p>

<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(define ctr 0)
(call-with-current-continuation 
  (lambda (return)
    (map-chan (lambda (val)
                (set! ctr (1+ ctr)) 
                (if (&gt; ctr 100) 
                  (return "quitting!") 
                  val)))))
</pre></td></tr></table>

<p>If the editing action is not mapping something over the current sound, it is
safest to write a temp file with the new data, then pass that to set-samples
with the trunc argument set to #t.  This way you don't assume the new sound
will fit in memory (as in using vct-&gt;samples for example), nor that the
lengths will be more or less the same (as in the mapping operations).
Use snd-tempnam to get a temporary filename that reflects the current
temp-dir setting (if any).  The env-sound-interp function in <a href="sndscm.html#exenvsoundinterp">examp.scm</a>
is an example of this.</p>

<p>The sample-reader functions have made these scanning functions largely redundant.
I may remove them, or move them into Scheme.
<i>scan-chan</i> could be:
</p>
<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(define (scan-chan . args)
  (let* ((func (car args))
	 (len (length args))
	 (start (if (&gt; len 1) (cadr args) 0))
	 (snd (if (&gt; len 3) (cadddr args) (selected-sound)))
	 (chn (if (&gt; len 4) (caddddr args) (selected-channel snd)))
	 (end (if (&gt; len 2) (caddr args) (frames snd chn)))
	 (reader (make-sample-reader start snd chn))
	 (result #f))
    (do ((i start (1+ i)))
	((or result (= i end))
	 (let ((val (if result 
			(list result (- i 1) snd chn)
			#f)))
	   (free-sample-reader reader)
	   val))
      (set! result (func (next-sample reader))))))
</pre></td></tr></table>


<!-- Transforms -->
<br>
<span class=bbox><h3><A NAME="sndtransforms">Transforms</a></h3></span>

<p>Except for add-transform, the transform functions and variables have been treated above, so this is just
a list of them with cross-references.</p>

<!-- -------------------------------- TRANSFORM TABLE -------------------------------- -->

<table border=0 cellspacing=10>

<!-- add-transform -->
<tr><td colspan=2>
<span class=defbox><code><em class=def><a name="addtransform">add-transform</a></em> (name xlabel lo hi transform)</code></span>
</td></tr>
<tr><td width=150></td><td>
add-transform adds a transform to the transform tables.  <i>name</i> is the name
it will be listed by in the transform dialog. <i>xlabel</i> is the x axis label
of the resultant graph.  <i>lo</i> and <i>hi</i> set which portion of the returned data
is relevant in graphing (normally 0.0 to 1.0).  <i>proc</i> is a function of two 
arguments, the length of the desired transform, and a sample-reader that 
can be used to get the current data.  Do not free the sample-reader!  
The function should return a vct object containing the transform data.  
add-transform returns the new transform's transform-type.
Here's an example that displays a histogram of the current values in 16 bins:
</td></tr>

<tr><td colspan=2 align=center>
<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(<em class=red>add-transform</em> "histogram" "bins" 0.0 1.0 
  (lambda (len fd)
    (let ((v (make-vct len))
          (steps (/ len 16))
          (step (/ 1.0 len)))
      (do ((i 0 (1+ i))) 
          ((= i len) v)
        (let* ((val (next-sample fd))
               (bin (inexact-&gt;exact (* (abs val) 16.0))))
          (do ((j 0 (1+ j))) 
              ((= j steps))
            (vct-set! v 
                      (+ j bin) 
                      (+ step (vct-ref v (+ j bin))))))))))
</pre></td></tr></table></td></tr>

<tr><td></td><td>
And an example that lets us see the result of filtering the waveform:
</td></tr>

<tr><td colspan=2 align=center>
<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(add-transform "low-pass" "filtered" 0.0 1.0
  (lambda (len fd)
    (let ((v (make-vct len))
          (flt (make-fir-filter :order 80 
                                :xcoeffs (let ((v1 (make-vct 80)))
                                           (vct-fill! v1 .0125)
                                           v1))))
     (do ((i 0 (1+ i))) 
         ((= i len) v)
      (vct-set! v i (fir-filter flt (next-sample fd)))))))
</pre></td></tr></table></td></tr>
</table>

<p>Other related variables:</p>
<table cellpadding=0 celspacing=0 border=0>

<tr><td width=200><a href="#sndffting">ffting</a> (<em class=targ>snd chn</em>)           </td><td><a href="#showfftpeaks">show-fft-peaks</a>             </td><td><a href="#sndtransformsample">transform-sample</a> (<i>bin slice snd chn</i>)</td></tr>
<tr><td><a href="#fftbeta">fft-beta</a>                  </td><td><a href="#lshowselectiontransform">show-selection-transform</a>   </td><td><a href="#sndtransformsamples">transform-samples</a> (<i>snd chn</i>)</td></tr>
<tr><td><a href="#ffthook">fft-hook</a> (snd chn scaler) </td><td><a href="#spectrocutoff">spectro-cutoff</a>             </td><td><a href="#transformsamples2vct">transform-samples-&gt;vct</a> (<i>snd chn v</i>)</td></tr>
<tr><td><a href="#fftlogfrequency">fft-log-frequency</a>         </td><td><a href="#spectrohop">spectro-hop</a>                </td><td><a href="#transformsize">transform-size</a> (<i>snd chn</i>)</td></tr>
<tr><td><a href="#fftlogmagnitude">fft-log-magnitude</a>         </td><td><a href="#spectrostart">spectro-start</a>              </td><td><a href="#ltransformtype">transform-type</a></td></tr>
<tr><td><a href="#lfftsize">fft-size</a>                  </td><td><a href="#spectroxangle">spectro-x-angle</a>            </td><td><a href="#sndupdatefft">update-fft</a> (<i>snd chn</i>)</td></tr>
<tr><td><a href="#lfftstyle">fft-style</a>                 </td><td><a href="#spectroxscale">spectro-x-scale</a>            </td><td><a href="#normalizefft">normalize-fft</a></td></tr>
<tr><td><a href="#lfftwindow">fft-window</a>                </td><td><a href="#spectroyangle">spectro-y-angle</a>            </td><td><a href="#zeropad">zero-pad</a></td></tr>
<tr><td><a href="#maxfftpeaks">max-fft-peaks</a>             </td><td><a href="#spectroyscale">spectro-y-scale</a>            </td><td><a href="#wavelettype">wavelet-type</a></td></tr>
<tr><td><a href="#mindb">min-dB</a>                    </td><td><a href="#spectrozangle">spectro-z-angle</a>
  </td><td><a href="#normalizefft">normalize-fft</a>             <a href="#spectrozscale">spectro-z-scale</a></td></tr>
</table>

<!-- Dialogs -->
<br>
<span class=bbox><h3><A NAME="snddialogs">Dialogs</a></h3></span>
<p>Many aspects of the various dialogs can be customized.  The following is organized by dialog, or was meant to be originally.</p>

<!-- -------------------------------- DIALOG TABLE -------------------------------- -->
<!-- --><table border=0 cellspacing=8>
<!-- -->
<!-- dismiss-all-dialogs -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="dismissalldialogs">dismiss-all-dialogs</a></em> ()</code></span></td>
<!-- --><td>deactivate all dialogs.</td></tr>
<!-- -->
<!-- just-sounds -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="justsounds">just-sounds</a></em> ()</code></span></td>
<!-- --><td>reflects the just-sounds button (if any). See also <a href="#justsoundshook">just-sounds-hook</a>.</td></tr>
<!-- -->
<!-- file-dialog -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndfiledialog">file-dialog</a></em> ()</code></span></td>
<!-- --><td>create the <a href="snd.html#prevfiles">list</a> of current and previous files (not the file browser), if necessary, activate it, and return the dialog widget.</td></tr>
<!-- -->
<!-- previous-files-sort -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="previousfilessort">previous-files-sort</a></em> ()</code></span></td>
<!-- --><td>Sort choice in files dialog (0=unsorted, 1=name, etc).</td></tr>
<!-- -->
<!-- edit-header-dialog -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndeditheaderdialog">edit-header-dialog</a></em> () </code></span></td>
<!-- --><td>fire up Edit Header dialog.</td></tr>
<!-- -->
<!-- enved-active-env -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="envedactiveenv">enved-active-env</a></em> ()</code></span></td>
<!-- --><td><a href="snd.html#editenvelope">Envelope editor</a> current envelope (list).</td></tr>
<!-- -->
<!-- enved-base -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="envedbase">enved-base</a></em> () </code></span></td>
<!-- --><td><a href="snd.html#editenvelope">Envelope editor</a> exponential base value (1.0)</td></tr>
<!-- -->
<!-- enved-clipping -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="envedclipping">enved-clipping</a></em> ()</code></span></td>
<!-- --><td><a href="snd.html#editenvelope">Envelope editor</a> 'clip' button (restricts mouse motion) (#f)</td></tr>
<!-- -->
<!-- enved-dBing -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="enveddBing">enved-dBing</a></em> ()</code></span></td>
<!-- --><td><a href="snd.html#editenvelope">Envelope editor</a> 'dB' button (#f)</td></tr>
<!-- -->
<!-- enved-dialog -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndenveddialog">enved-dialog</a></em> ()</code></span></td>
<!-- --><td>create the Envelope editor dialog, if necessary, activate it, and return the dialog widget. See also <a href="#envedhook">enved-hook</a>.</td></tr>
<!-- -->
<!-- enved-exping -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="envedexping">enved-exping</a></em> ()</code></span></td>
<!-- --><td><a href="snd.html#editenvelope">Envelope editor</a> 'exp' and 'lin' buttons (type of connecting segments) (#f)</td></tr>
<!-- -->
<!-- enved-power -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="envedpower">enved-power</a></em> ()</code></span></td>
<!-- --><td><a href="snd.html#editenvelope">Envelope editor</a> base scale range (9.0^power). (3.0)</td></tr>
<!-- -->
<!-- enved-selected-env -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="envedselectedenv">enved-selected-env</a></em> ()</code></span></td>
<!-- --><td><a href="snd.html#editenvelope">Envelope editor</a> selected envelope (list).</td></tr>
<!-- -->
<!-- enved-target -->
<!-- -->
<!-- --><tr><td valign=top><span class=defbox><code><em class=def><a name="envedtarget">enved-target</a></em> ()</code></span></td>
<!-- --><td>
<!-- -->Determines how the envelope is applied to the current data
<!-- -->This chooses one of the 'amp', 'flt', and 'src' buttons in the <a href="snd.html#editenvelope">Envelope editor</a>.
<!-- -->The other (named constant) choices are <i>srate-env</i> and <i>spectrum-env</i>.
<!-- -->defaults to <i>amplitude-env</i>
<!-- --></td></tr>
<!-- -->
<!-- enved-waveform-color -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="envedwaveformcolor">enved-waveform-color</a></em> ()</code></span></td>
<!-- --><td>color of waveform displayed in envelope editor. (default is blue).</td></tr>
<!-- -->
<!-- enved-waving -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="envedwaving">enved-waving</a></em> ()</code></span></td>
<!-- --><td><a href="snd.html#editenvelope">Envelope editor</a> 'wave' button
<!-- -->The wave shown is the time domain display, even when filtering.
<!-- --></td></tr>
<!-- -->
<!-- filter-env-order -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="filterenvorder">filter-env-order</a></em> ()</code></span></td>
<!-- --><td>The order of the Envelope editor's FIR filter. (default is 40)</td></tr>
<!-- -->
<!-- help-dialog -->
<!-- -->
<!-- --><tr><td colspan=2 valign=top><span class=defbox><code><em class=def><a name="sndhelpdialog">help-dialog</a></em> (subject help-string) </code></span></td>
<!-- --><tr><td></td><td>start the help dialog with title <i>subject</i> and body <i>help</i>, returning the dialog widget.<br>
<!-- --><code>(help-dialog "xyzzy" "are we having fUn?")</code>
<!-- --></td></tr>
<!-- -->
<!-- help-text-font -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="helptextfont">help-text-font</a></em> ()</code></span></td>
<!-- --><td>help dialog text font</td></tr>
<!-- -->
<!-- html-dir -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="htmldir">html-dir</a></em> ()</code></span></td>
<!-- --><td>If an HTML widget is in use, the directory to search for documentation.</td></tr>
<!-- -->
<!-- activate-listener -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="activatelistener">activate-listener</a></em> ()</code></span></td>
<!-- --><td>make listener active, even if not open.</td></tr>
<!-- -->
<!-- hide-listener -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndhidelistener">hide-listener</a></em> ()</code></span></td>
<!-- --><td>close the lisp listener pane.</td></tr>
<!-- -->
<!-- listener-color -->
<!-- -->
<!-- --><tr><td valign=top><span class=defbox><code><em class=def><a name="listenercolor">listener-color</a></em> ()</code></span></td>
<!-- --><td>background color of lisp listener. <code>(set! (listener-color) (make-color 0 0 0))</code> is good too.</td></tr>
<!-- -->
<!-- listener-text-color -->
<!-- -->
<!-- --><tr><td valign=top><span class=defbox><code><em class=def><a name="listenertextcolor">listener-text-color</a></em> ()</code></span></td>
<!-- --><td>text color in lisp listener.</td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(define (red-alert msg)
<!-- -->  ;; this only works in the gtk version (in Motif all existing text changes color)
<!-- -->  (let ((old-color (listener-text-color)))
<!-- -->    (set! (listener-text-color) (make-color 1 0 0))
<!-- -->    (snd-print msg)
<!-- -->    (set! (listener-text-color) old-color)))
<!-- --></pre></td></tr></table></td></tr>
<!-- -->
<!-- listener-font -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="listenerfont">listener-font</a></em> ()</code></span></td>
<!-- --><td>listener font.</td></tr>
<!-- -->
<!-- listener-prompt -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="listenerprompt">listener-prompt</a></em> ()</code></span></td>
<!-- --><td>lisp listener prompt (defaults to "&gt;").</td></tr>
<!-- -->
<!-- print-length -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="printlength">print-length</a></em> ()</code></span></td>
<!-- --><td>number of elements of lists and vectors that are printed (default is 12).</td></tr>
<!-- -->
<!-- show-listener -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndshowlistener">show-listener</a></em> ()</code></span></td>
<!-- --><td>open the lisp listener pane.</td></tr>
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a href="sndsavelistener">save-listener</a></em> (filename) </code></span></td>
<!-- --><td>save listener text in filename.</td></tr>
<!-- -->
<!-- mix-panel -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndmixpanel">mix-panel</a></em> ()</code></span></td>
<!-- --><td>create the Mix Panel Dialog, if necessary, activate it, and return the dialog widget.</td></tr>
<!-- -->
<!-- orientation-dialog -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndorientationdialog">orientation-dialog</a></em> ()</code></span></td>
<!-- --><td>Create the <a href="snd.html#orientationbrowser">Orientation</a> dialog, if necessary, activate it, and return the dialog widget.</td></tr>
<!-- -->
<!-- --><tr><td valign=top><span class=defbox><code><a href="#spectrocutoff">spectro-cutoff</a> ()</code></span></td>
<!-- --><td>The amount of the frequency domain to include in the spectrum display.
<!-- -->This number changes as you drag the frequency axis, for example.  
<!-- -->This is the slider labelled '% of spectrum' in the View Orientation dialog.
<!-- -->default: 1.0.
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td valign=top><span class=defbox><code><a href="#spectrohop">spectro-hop</a> ()</code></span></td>
<!-- --><td>The distance (pixels) moved between successive spectrogram traces.
<!-- -->This is the slider labelled 'hop' in the Orientation dialog.
<!-- -->default: 4.
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td><span class=defbox><code><a href="#spectrostart">spectro-start</a> ()</code></span></td>
<!-- --><td>The start point of the frequency domain to include in the spectrum display. default: 0.0</td></tr>
<!-- -->
<!-- --><tr><td><span class=defbox><code><a href="#spectroxangle">spectro-x-angle</a> ()</code></span></td>
<!-- --><td>Default spectrogram x-axis viewing angle. default: 90.0</td></tr>
<!-- -->
<!-- --><tr><td><span class=defbox><code><a href="#spectroxscale">spectro-x-scale</a> ()</code></span></td>
<!-- --><td>Default scaler (stretch) along the spectrogram x axis. (default: 1.0)</td></tr>
<!-- -->
<!-- --><tr><td><span class=defbox><code><a href="#spectroyangle">spectro-y-angle</a> ()</code></span></td>
<!-- --><td>Same for y-axis. default: 0.0</td></tr>
<!-- -->
<!-- --><tr><td><span class=defbox><code><a href="#spectroyscale">spectro-y-scale</a> ()</code></span></td>
<!-- --><td>Same for y-axis. default: 1.0</td></tr>
<!-- -->
<!-- --><tr><td><span class=defbox><code><a href="#spectrozangle">spectro-z-angle</a> ()</code></span></td>
<!-- --><td>Same for z-axis. default: -2.0</td></tr>
<!-- -->
<!-- --><tr><td><span class=defbox><code><a href="#spectrozscale">spectro-z-scale</a> ()</code></span></td>
<!-- --><td>Same for z-axis. default: 0.1</td></tr>
<!-- -->
<!-- recorder-autoload -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="recorderautoload">recorder-autoload</a></em> ()</code></span></td>
<!-- --><td>The '<a href="snd.html#Xautoload">autoload</a>' button in the recorder dialog. (#f)</td></tr>
<!-- -->
<!-- recorder-buffer-size -->
<!-- -->
<!-- --><tr><td valign=top><span class=defbox><code><em class=def><a name="recorderbuffersize">recorder-buffer-size</a></em> ()</code></span></td>
<!-- --><td>The size of the recorder input buffer (there's a trade-off
<!-- -->between responsiveness and clicks in some cases). (4096)
<!-- --></td></tr>
<!-- -->
<!-- recorder-dialog -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndrecorderdialog">recorder-dialog</a></em> ()</code></span></td>
<!-- --><td>fire up <a href="snd.html#recordfile">recorder</a> window.</td></tr>
<!-- -->
<!-- recorder-file -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="recorderfile">recorder-file</a></em> ()</code></span></td>
<!-- --><td>Default recorder output file name.</td></tr>
<!-- -->
<!-- recorder-gain -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndrecordergain">recorder-gain</a></em> (gain)</code></span></td>
<!-- --><td>  recorder input (soundcard-audio) gain <i>gain</i>.</td></tr>
<!-- -->
<!-- recorder-in-amp -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndrecorderinamp">recorder-in-amp</a></em> (in out)</code></span></td>
<!-- --><td> recorder input channel <i>in</i> to output channel <i>out</i> amplitude.</td></tr>
<!-- -->
<!-- recorder-in-format -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="recorderinformat">recorder-in-format</a></em> ()</code></span></td>
<!-- --><td>Incoming data format for the recorder. default 16-bit linear.</td></tr>
<!-- -->
<!-- recorder-max-duration -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="recordermaxduration">recorder-max-duration</a></em> ()</code></span></td>
<!-- --><td>Recorder max output file length.</td></tr>
<!-- -->
<!-- recorder-out-amp -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndrecorderoutamp">recorder-out-amp</a></em> (out)</code></span></td>
<!-- --><td>recorder file output channel <i>out</i> amplitude.</td></tr>
<!-- -->
<!-- recorder-out-chans -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="recorderoutchans">recorder-out-chans</a></em> ()</code></span></td>
<!-- --><td>Recorder output file channels. (default: 2)</td></tr>
<!-- -->
<!-- recorder-out-format -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="recorderoutformat">recorder-out-format</a></em> ()</code></span></td>
<!-- --><td>same as <a href="#recorderinformat">recorder-in-format</a></td></tr>
<!-- -->
<!-- recorder-srate -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="recordersrate">recorder-srate</a></em> ()</code></span></td>
<!-- --><td>Recorder sampling rate.</td></tr>
<!-- -->
<!-- recorder-trigger -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="recordertrigger">recorder-trigger</a></em> ()</code></span></td>
<!-- --><td>Recorder auto-trigger value.</td></tr>
<!-- -->
<!-- vu-font -->
<!-- -->
<!-- --><tr><td valign=top><span class=defbox><code><em class=def><a name="vufont">vu-font</a></em> ()</code></span></td>
<!-- --><td>The "vu-" variables refer to the VU meters in the recorder.
<!-- --><i>vu-font</i> is the font used to label the meters.  It is normally "courier".
<!-- --></td></tr>
<!-- -->
<!-- vu-font-size -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="vufontsize">vu-font-size</a></em> ()</code></span></td>
<!-- --><td>recorder VU meter label font size. (1.0)</td></tr>
<!-- -->
<!-- vu-size -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="vusize">vu-size</a></em> ()</code></span></td>
<!-- --><td>overall size of the recorder VU meters. (1.0)</td></tr>
<!-- -->
<!-- region-dialog -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndregiondialog">region-dialog</a></em> ()</code></span></td>
<!-- --><td>fire up <a href="snd.html#regionbrowser">region browser</a> (a no-op if no regions).</td></tr>
<!-- -->
<!-- transform-dialog -->
<!-- -->
<!-- --><tr><td><span class=defbox><code><em class=def><a name="sndtransformdialog">transform-dialog</a></em> ()</code></span></td>
<!-- --><td>create the Transform Dialog, if necessary, activate it, and return the dialog widget.  (This is Option menu's Transform Options choice).</td></tr>
<!-- -->
<!-- yes-or-no-p -->
<!-- -->
<!-- --><tr><td valign=top><span class=defbox><code><em class=def><a name="sndyesornop">yes-or-no-p</a></em> (ques)</code></span></td>
<!-- --><td>modal error dialog, #t if user clicks "ok", otherwise #f.  In normal use, this is a very annoying thing to call because
<!-- -->it forces everything to stop until the poor user clicks a button; in Snd, it's used for questions like "destroy disk?".</td></tr>
<!-- -->
<!-- --></table>

<p>The main menus can be extended, and new menus added with the following functions:</p>

<!-- -------------------------------- MENU TABLE -------------------------------- -->
<!-- --><table border=0 cellspacing=8>
<!-- -->
<!-- add-to-main-menu -->
<!-- -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="sndaddtomainmenu">add-to-main-menu</a></em> (menu-label <i>update-callback</i>)</code></span></td></tr>
<!-- --><tr><td width=150></td><td>
<!-- -->add new top-level menu named <i>menu-label</i>, return menu index.
<!-- --><i>update-callback</i> can be a procedure of no arguments that will be 
<!-- -->called each time the menu is displayed. (See <a href="sndscm.html#effectsdoc">effects.scm</a> for an example).
<!-- --><br><br><pre>
<!-- -->  &gt;<em class=typing>(add-to-main-menu "Tools")</em>
<!-- -->  <em class=listener>5</em>
<!-- --></pre></td></tr>
<!-- -->
<!-- add-to-menu -->
<!-- -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="sndaddtomenu">add-to-menu</a></em> (top-menu menu-label callback)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->add menu <i>menu-label</i> to top-level menu whose index is 
<!-- --><i>top-menu</i> with the callback function <i>callback</i>.  The built-in
<!-- -->Snd menus are numbered from 0 ('File') to 4 ('Help').  [<em class=error>no-such-menu</em>]
<!-- --><br><br><pre>
<!-- -->  (<em class=red>add-to-menu</em> 5 "Denoise" 
<!-- -->    (lambda () (report-in-minibuffer "denoise")))
<!-- -->
<!-- -->  (<em class=red>add-to-menu</em> 1 "Stop Playing" 
<!-- -->    (lambda () (stop-playing)))
<!-- --></pre></td></tr>
<!-- -->
<!-- change-menu-label -->
<!-- -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="sndchangemenulabel">change-menu-label</a></em> (top-menu old-label new-label)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->
<!-- remove-from-menu -->
<!-- -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="sndremovefrommenu">remove-from-menu</a></em> (top-menu menu-label)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->remove menu <i>menu-label</i> from the top top-level menu whose index is <i>top-menu</i>.
<!-- --></td></tr>
<!-- -->
<!-- menu-sensitive -->
<!-- -->
<!-- --><tr><td colspan=2><span class=defbox><code><em class=def><a name="menusensitive">menu-sensitive</a></em> (top-menu label)</code></span></td></tr>
<!-- -->
<!-- --></table>


<p>In addition, the hook <em class=def><a name="menuhook">menu-hook</a></em> is checked each time a menu item is selected;
its entries should be functions of two arguments, the top menu name and the option
selected (both as strings), and should return #f if it wants to override the default
menu action.</p>

<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
  (add-hook! menu-hook
    (lambda (name option)
      (if (and (string=? name "File")
               (string=? option "Exit"))
        (begin
          (snd-print "no exit!")
	  #f)
        #t))) ; #t to make sure other menu items remain active
</pre></td></tr></table>
<p>I may change these menu handlers to use the menu-widgets list
and more general functions; let me know what you'd like to be able
to do!
</p>

<br>
<span class=bbox><h3><A NAME="snderrors">Errors</a></h3></span>

<p> When something goes awry, the various functions can "throw" an error (a symbol)
which is normally "caught" by the default error handler (this is a kind of "goto" 
but without the embarrassment); it prints out some message,
and in some cases appends a stack trace.  So, as a simple example, selection-position
throws 'no-active-selection is there isn't a selection. In the default case, you
get behavior like this:
</p>
<pre>
&gt;<em class=typing>(selection-position)</em>
<em class=listener>selection-position: no-active-selection</em>
&gt;<em class=typing>asdf</em>
<em class=listener>Unbound variable: asdf</em>
</pre>
<p>But there are cases where you'd rather handle an error (or all errors) specially.
In the case of 'no-active-selection, we set up our own handler for that as follows:</p>
<pre>
&gt;<em class=typing>(catch 'no-active-selection 
       (lambda () 
         (+ 1 (selection-position))) 
       (lambda (tag val) 0))</em>
<em class=listener>0</em>
</pre>
<p>Here we've "caught" 'no-active-selection (if it occurs within the
first "thunk's" body), and return 0 if it occurs; otherwise we return
<code>(+ 1 (selection-position))</code>.  Scheme (Guile) has a number
of errors such as 'out-of-range, 'wrong-type-arg, 'numerical-overflow,
etc.  The Snd-specific errors are:</p>
<pre>
'no-such-channel 'no-such-sound  'no-such-mark       'no-such-mix
'no-such-menu    'no-such-file   'no-such-region     'no-such-sample
'no-such-edit    'cannot-save    'impossible-bounds  'no-active-selection
'no-such-widget  'mus-error      'no-such-track      'no-such-envelope
'cannot-print    'no-such-axis   'no-such-player     'bad-arity
'no-such-graphics-context
</pre>
<p><i>bad-arity</i> is jargon indicating that a procedure takes the
wrong number of arguments.
The symbol #t stands for all errors in this case, so we can 
run rough-shod over any error with:</p>
<pre>
(defmacro without-errors (func)
  `(catch #t 
	  (lambda ()
	    ,func)
	  (lambda args (car args))))
</pre>
<p>You can use these errors in your code, if you like.  The following
throws the error 'no-such-file:</p>
<pre>
(define look-for-file
  (lambda (file)
    (or (file-exists? file)
	(throw 'no-such-file (list "look-for-file" file)))))
</pre>
<p>There are a variety of debugging aids supplied by Guile, including
a good backtrace facility.  You can have a backtrace displayed automatically
in the error handler by setting <a href="#showbacktrace">show-backtrace</a>
to #t; it defaults to #f because it has been plagued in the past
with segfaults.
To see what files are being loaded, set the
variable %load-verbosely to #t.
</p>
<p>As an experiment, some of the Snd-generated errors include a continuation
procedure as the second element of the last element of the list of 
arguments passed to the error handler (the first element of that list is the symbol 'snd-error-continuation).  
You can ask Snd to continue from the point
of the error as if nothing had gone wrong by invoking that procedure from the
error handler:
</p>
<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(define (continuable-error? err)
  (let* ((len (length err))
	 (last-arg (and (not (null? err)) 
			(list-ref err (- len 1)))))
    (and last-arg
	 (list? last-arg)
	 (= (length last-arg) 2)
	 (eq? (car last-arg) 'snd-error-continuation)
	 (procedure? (cadr last-arg))
	 (cadr last-arg))))

(define (with-continuations thunk newval)
  (catch #t
	 (lambda ()
	   (lazy-catch #t 
		       thunk
		       lazy-handler-dispatch))
	 (lambda args
	   (let ((go-on (continuable-error? args)))
	     (if go-on
		 (go-on newval)
		 (apply throw args))))))

(define (with-default-continuations thunk)
  (with-continuations thunk #f))

(define (select-sound-or-bust n)  ; (select-sound n) with error retry
  "if 'n' is not a valid sound index, prompt for another, giving up only if a non-number is supplied"
  (catch 'no-such-sound
	 (lambda () 
	   (lazy-catch 'no-such-sound
		       (lambda () (select-sound n))
		       lazy-handler-dispatch))
	 (lambda args
	   (let ((go-on (continuable-error? args)))
	     (if go-on
		 (prompt-in-minibuffer 
                   "try again: "
	           (lambda (val snd)
		     (if (number? val)
			 (go-on val) ; this replaces the original 'n' with 'val'
			 (apply throw args)))
		   (selected-sound))
		 (apply throw args))))))
</pre></td></tr></table>
<!-- TODO: more continuation examples -->
<p>
For a brief discussion of continuations, see <a href="sndscm.html#continuations">About Continuations</a>.
</p>


<br>
<span class=bbox><h3><A NAME="sndconstants">Constants</a></h3></span>

<p><b>Sndlib</b> (see <a href="sndlib.html#sndlibguile">sndlib.html</a> for a complete list):</p>
<pre>
  <a name="nextsoundfile">mus-next</a> mus-aifc mus-riff mus-nist mus-raw mus-ircam mus-aiff

  <A NAME="localdataformats">mus-bshort</a>  mus-lshort mus-mulaw  mus-alaw   mus-byte   mus-ubyte   mus-bfloat
  mus-lfloat  mus-bint   mus-lint   mus-b24int mus-l24int mus-bdouble mus-ldouble
  mus-ubshort mus-ulshort

  <a name="musoutformat">mus-out-format</a>
</pre>
<br>
<p><b>FFT style</b> (the Transform Options Display choice):</p>
<pre>
  normal-fft         sonogram            spectrogram
</pre>
<br>
<p><b>Transform type</b>:
<pre>
  <a name="fouriertransform">fourier-transform</a>  wavelet-transform   hankel-transform    chebyshev-transform
  autocorrelation    walsh-transform     hadamard-transform  cepstrum   haar-transform
</pre></br>

<p><b>Transform normalization</b>:
<pre>
  dont-normalize    normalize-by-channel normalize-by-sound  normalize-globally
</pre><br>

<p><b><a name="fftwindowchoices"></a>FFT Window</b> type:</p>
<pre>
  rectangular-window hann(ing)-window   welch-window      parzen-window
  bartlett-window    hamming-window     blackman2-window  blackman3-window
  blackman4-window   exponential-window riemann-window    kaiser-window
  cauchy-window      poisson-window     gaussian-window   tukey-window
  dolph-chebyshev-window (if GSL is loaded)
</pre><br>

<p><b>Zoom Focus</b> style:</p>
<pre>
  focus-left         focus-right        focus-active      focus-middle
</pre><br>

<p><b>X-axis Label</b>:</p>
<pre>
  x-in-seconds       x-in-samples       x-to-one
</pre><br>

<p><b>Speed Control</b> style:</p>
<pre>
  speed-as-float     speed-as-ratio     speed-as-semitone
</pre><br>

<p><b>Channel Combination</b> style;</p>
<pre>
  <a name="channelstyleconstants">channels-separate</a>  channels-combined  channels-superimposed
</pre><br>

<p><b>Envelope Editor</b> target:</p>
<pre>
  amplitude-env      spectrum-env       srate-env
</pre><br>

<p><b>Graph Line</b> style:</p>
<pre>
  <a name="graphlines">graph-lines</a>        graph-dots         graph-filled      graph-lollipops
  graph-dots-and-lines 
</pre><br>

<p><b>Key binding</b> cursor action:</p>
<pre>
  <a name="cursorchoices">cursor-in-view</a>     cursor-on-left     cursor-on-right   cursor-in-middle 
  cursor-update-display cursor-no-action keyboard-no-action
</pre><br>

<p><b>Cursor</b> style:</p>
<pre>
  cursor-cross   cursor-line
</pre><br>

<p><b>Axis placement</b> choice:</p>
<pre>
  show-all-axes  show-no-axes  show-x-axis
</pre><br>

<p><b>Graph</b> id:</p>
<pre>
  time-graph     fft-graph     lisp-graph
</pre>


<br>
<span class=bbox><h3><A NAME="sndmisc">Miscellaneous functions</a></h3></span>

<p>These functions don't seem to fit anywhere else:</p>

<!-- -------------------------------- MISCELLANEOUS TABLE -------------------------------- -->
<!-- -->
<!-- --><table border=0 cellspacing=8>
<!-- -->
<!-- clear-audio-inputs -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndclearaudioinputs">clear-audio-inputs</a></em> ()</code></span></td></tr>
<!-- --><tr><td width=150></td><td>
<!-- -->in Linux/OSS, try to reduce soundcard background racket.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- close-sound-file -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndclosesoundfile">close-sound-file</a></em> (fd bytes)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->close file updating header to report <i>bytes</i> bytes of data.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- open-sound-file -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndopensoundfile">open-sound-file</a></em> (<i>name chans srate comment</i>)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->Open (create) a sound file <i>name</i> (defaults to "test.snd" or "test.wav").  
<!-- -->It is assumed that the data will be floats in the native format (written by 
<!-- -->the caller interleaving channels), and that the file will be closed by 
<!-- -->close-sound-file. One simple way to write the data is to call 
<!-- --><a href="#vct2soundfile">vct-&gt;sound-file</a>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- abort -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="abort">abort</a></em> ()</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->drop into gdb
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- add-sound-file-extension -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="addsoundfileextension">add-sound-file-extension</a></em> (ext)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->add <i>ext</i> to the list of sound file extensions.
<!-- -->The initial list is ("snd" "aiff" "aif" "wav" "au" "aifc" "voc" "wve")
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- autocorrelate -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndautocorrelate">autocorrelate</a></em> (data)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->return (in place) autocorrelation of <i>data</i>
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- bind-key -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndbindkey">bind-key</a></em> (key state func <i>ignore-prefix</i>) </code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->Cause <i>key</i> (an integer) with modifiers <i>state</i> to evaluate <i>code</i>.<br><br>
<!-- -->
<!-- --><code>(bind-key (char-&gt;integer #\a) 4 (lambda () (snd-print \"hi\")))</code><br><br>
<!-- -->
<!-- -->The modifier state is a combination of shift: 1, control: 4, meta: 8, 
<!-- -->so this call causes C-a to print "hi" in the lisp listener.  The 
<!-- -->value returned should be one of the cursor choices (see below) telling Snd what 
<!-- -->action (if any) to take after evaluating <i>code</i>.  If <i>ignore-prefix</i> is 
<!-- -->#t, Snd does not repeat the key based on the prefix argument (<a href="snd.html#kcu">C-u</a>) --
<!-- -->in this case, the <i>code</i> can examine <a href="#prefixarg">prefix-arg</a> if desired.
<!-- -->Possible return values are:
<!-- --><br><pre>
<!-- -->  cursor-in-view     cursor-on-left     cursor-on-right   cursor-in-middle 
<!-- -->  cursor-update-display cursor-no-action keyboard-no-action
<!-- --></pre>
<!-- --></td></tr>
<!-- --><tr><td></td><td>
<!-- -->We can use bind-key to turn the keyboard into a sort of extended piano:
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(<em class=red>bind-key</em> (char-&gt;integer #\o) 0 
<!-- -->  (lambda () 
<!-- -->    (play "oboe.snd") 
<!-- -->    keyboard-no-action))
<!-- -->
<!-- -->(<em class=red>bind-key</em> (char-&gt;integer #\p) 0 
<!-- -->  (lambda () 
<!-- -->    (play "pistol.snd") 
<!-- -->    keyboard-no-action))
<!-- --></pre></td></tr></table></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->Now each time we hit "o", "oboe.snd" plays,  etc.  Or say we want to move
<!-- -->forward two samples in the graph each time we type "l":
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(<em class=red>bind-key</em> (char-&gt;integer #\l) 0 
<!-- -->  (lambda () 
<!-- -->    (set! (left-sample 0 0) (+ 2 (left-sample 0 0))) 
<!-- -->    cursor-update-display))
<!-- --></pre></td></tr></table></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->The key codes can usually be found in the X header file X11R6/include/X11/keysymdef.h
<!-- -->The "Page Up" key is given as 0xFF55, which in Scheme would be #xff55 (65365).
<!-- --><pre>
<!-- -->  (bind-key #xff55 0 (lambda () (snd-print "Page up")))
<!-- --></pre>
<!-- --></td></tr>
<!-- -->
<!-- c-g? -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndabort">c-g?</a></em> ()</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->check for C-g to interrupt on-going computation (and let other UI 
<!-- -->events through).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- convolve-arrays -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndconvolve">convolve-arrays</a></em> (rl1 rl2)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->convolve vectors <i>rl1</i> with <i>rl2</i>.  Result returned in rl1.
<!-- -->rl1 should be large enough to hold the full convolution result.
<!-- -->As a special dispensation for forgetful users, if rl1 is a file
<!-- -->name and rl2 is not a vector, <i>convolve-with</i> is called instead.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- exit -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndexit">exit</a></em>              (<i>exit-value</i>)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->   exit Snd.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- fft -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndfft">fft</a></em> (rl im <i>sgn</i>)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->perform an FFT on <i>rl</i> and <i>im</i> (the real and imaginary parts of the
<!-- -->input data. <i>sgn</i> is 1 for an FFT, -1 for an inverse FFT; (default 1).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- fht -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndfht">fht</a></em> (vobj)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->perform Hartley transform on vct <i>vobj</i> whose length must be a power of 4.
<!-- -->This is a fast version of the FFT (it's about 4 to 6 times faster than the fft, 
<!-- -->but can be applied only to real data; it is its own inverse).  The following 
<!-- -->function reads data from the left window edge, calls the Hartley transform 
<!-- -->(using a "rectangular window"), turns that into a magnitude spectrum, and graphs 
<!-- -->the result (which is the same as the fft-generated magnitude spectrum before 
<!-- -->any normalization etc).
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(define (hgrf snd chn y0 y1)
<!-- -->  (let* ((size (fft-size snd chn))
<!-- -->         (hv0 (samples-&gt;vct (left-sample snd chn) size))
<!-- -->         (hv1 (make-vct (/ size 2))))
<!-- -->    (<em class=red>fht</em> hv0)
<!-- -->    (do ((i 1 (1+ i)))
<!-- -->        ((= i (/ size 2)))
<!-- -->      (vct-set! hv1 i 
<!-- -->        (* (sqrt (+ (* (vct-ref hv0 i) 
<!-- -->                       (vct-ref hv0 i))
<!-- -->                    (* (vct-ref hv0 (- size i)) 
<!-- -->                       (vct-ref hv0 (- size i)))))
<!-- -->           (/ (sqrt 2.0) size))))
<!-- -->    (graph hv1)))
<!-- -->
<!-- -->(add-hook! graph-hook hgrf)
<!-- --></pre></td></tr></table></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->The explicit (slow) form of this transform is dht in <a href="sndscm.html#exampdoc">examp.scm</a>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- graph->ps -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndgraph2ps">graph-&gt;ps</a></em> (<i>file</i>)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->create Postscript description of current display 
<!-- --><i>file</i> defaults to <a href="#epsfile">eps-file</a>. [<em class=error>cannot-print</em>].
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- in -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="gin">in</a></em> (ms thunk)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- --><i>ms</i> milliseconds from now, evaluate <i>thunk</i>, a function of no arguments.
<!-- --><pre><code>(in 5000 (lambda () (snd-print "boo!")))</code></pre>
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- key -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndkey">key</a></em> (key state <i>snd chn</i>) </code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->execute the keyboard command <i>key</i> with modifier keys <i>state</i>.
<!-- -->shift: 1, control: 4, meta: 8
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- key-binding -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="keybinding">key-binding</a></em> (key state)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->the (user-defined, not built-in) procedure currently bound to key+state.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- memo-sound -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="memosound">memo-sound</a></em></code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->When a sound file is opened, Snd looks for a file with the same 
<!-- -->name but with an appended ".scm" extension.  If such a file is found, 
<!-- -->it is loaded automatically.  The variable <i>memo-sound</i> is set to 
<!-- -->the newly opened sound's index.  This supports the "snd-memo" feature 
<!-- -->in CLM, but can be used independently of CLM to store marks, selections,
<!-- -->or whatever that you want associated with a particular sound. Confusingly
<!-- -->enough, this is a Scheme variable, unlike all the others -- that is, you
<!-- -->refer to it directly, not as a procedure call.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- normalize-view -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndnormalizeview">normalize-view</a></em> ()</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->normalize Snd display as in View menu <a href="snd.html#viewnormalize">Normalize</a> option.
<!-- --></td></tr>
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(add-hook! after-open-hook 
<!-- -->  (lambda (n) (if (> (channels n) 3) (normalize-view))))
<!-- --></pre></td></tr></table></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- preload-directory -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndpreloaddirectory">preload-directory</a></em> (dir)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->preload sound files from directory <i>dir</i> (see -<a href="snd.html#minusp">p</a>).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- preload-file -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndpreloadfile">preload-file</a></em> (file)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->preload <i>file</i> (see View menu's <a href="snd.html#prevfiles">View Files</a> option).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- save-envelopes -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndsaveenvelopes">save-envelopes</a></em> (filename)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->save envelope editor contents in <i>filename</i> [<em class=error>cannot-save</em>].
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- save-listener -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndsavelistener">save-listener</a></em> (filename)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->save listener contents in <i>filename</i> [<em class=error>cannot-save</em>].
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- save-macros -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndsavemacros">save-macros</a></em> ()</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->save <a href="snd.html#kbdmacros">keyboard macros</a> in Snd's init file (~/.snd). [<em class=error>cannot-save</em>].
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- save-options -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndsaveoptions">save-options</a></em> (filename)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->save options in <i>filename</i> [<em class=error>cannot-save</em>].
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- save-state -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndsavestate">save-state</a></em> (filename)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->save current state of Snd in <i>filename</i> [<em class=error>cannot-save</em>].
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- snd-apropos -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndapropos">snd-apropos</a></em> (name) </code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->return possible completions of <i>name</i> (a string or a symbol).
<!-- --><pre>
<!-- -->:<em class=typing>(snd-apropos "mouse-enter")</em>
<!-- --><em class=listener>(guile): mouse-enter-graph-hook
<!-- -->(guile): mouse-enter-label-hook
<!-- -->(guile): mouse-enter-listener-hook
<!-- --></em></pre>
<!-- --></td></tr>
<!-- -->
<!-- snd-error -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="snderror">snd-error</a></em> (str)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->report error message <i>str</i>, return <i>str</i>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- snd-help -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndhelp">snd-help</a></em> (obj)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->returns (as a string) the help text associated with <i>obj</i>,
<!-- -->for example: <code>(snd-help vct-ref)</code>.
<!-- --><i>snd-help</i> this returns the help text associated with <i>obj</i>.  To go to the
<!-- -->HTML documentation for a given object, load <a href="sndscm.html#indexdoc">index.scm</a> and use the html function.
<!-- -->To get a more global help function, <code>(use-modules (ice-9 session))</code>.  This loads Guile's
<!-- -->help (and apropos) support which uses 'regexps' and so forth.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- snd-print -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndprint">snd-print</a></em> (str)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->display <i>str</i> in lisp listener, return <i>str</i>.  (This is intended as a
<!-- -->debugging aid -- there's still nothing like a lowly print statement).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- snd-spectrum -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndspectrum">snd-spectrum</a></em> (data window length <i>linear</i>)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->return spectrum of <i>data</i> (type vct) using fft-window <i>win</i>.
<!-- -->length of data (and fft) is <i>length</i>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- snd-tempnam -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndtempnam">snd-tempnam</a></em> ()</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->New temp file name using Snd's <a href="#tempdir">temp-dir</a>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- snd-version -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndversion">snd-version</a></em> ()</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->Snd version (a string).
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- snd-warning -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndwarning">snd-warning</a></em> (str)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->report warning message <i>str</i>, return <i>str</i>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- sound-files-in-directory -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="soundfilesindirectory">sound-files-in-directory</a></em> (dir)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->return a vector of sound file names.
<!-- -->This is useful for "batch" processing of sounds.  The following,
<!-- -->for example, prints the names of all the stereo AIFC files it finds:
<!-- --></td></tr>
<!-- -->
<!-- --><tr><td colspan=2 align=center>
<!-- --><table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<!-- -->(let ((files (<em class=red>sound-files-in-directory</em> ".")))
<!-- -->  (do ((i 0 (1+ i)))
<!-- -->      ((= i (vector-length files)))
<!-- -->    (let ((filename (vector-ref files i)))
<!-- -->      (if (and (= (mus-sound-header-type filename) mus-aifc)
<!-- -->               (= (mus-sound-chans filename) 2))
<!-- -->          (snd-print filename)))))
<!-- --></pre></td></tr></table></td></tr>
<!-- -->
<!-- --><tr><td></td><td>
<!-- -->See also map-sound-files in <a href="sndscm.html#exampdoc">examp.scm</a>.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- unbind-key -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="sndunbindkey">unbind-key</a></em> (key state)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->cause <i>key</i> with modifiers <i>state</i> to be a no-op.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- widget-position -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="widgetposition">widget-position</a></em> (widget)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->return a list giving the widget x and y coordinates.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- widget-size -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="widgetsize">widget-size</a></em> (widget) </code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->return a list giving the widget width and height.
<!-- --></td></tr>
<!-- --><tr><td colspan=2></td></tr>
<!-- -->
<!-- defvar -->
<!-- --><tr><td colspan=2>
<!-- --><span class=defbox><code><em class=def><a name="ldefvar">defvar</a></em> (var val)</code></span></td></tr>
<!-- --><tr><td></td><td>
<!-- -->same as <code>(define var val)</code> except that the envelope editor keeps track
<!-- -->of <i>var</i> thereafter and treats lists as envelopes. (<i>defvar</i> is a macro).
<!-- -->I'm using <i>defvar</i> here rather than some more perspicuous name like def-envelope
<!-- -->so that Snd and CLM can share envelope files.
<!-- --></td></tr>
<!-- -->
<!-- --></table>


<hr>
<pre>
<!-- add-input -->
<!-- remove-input -->
  <b><a name="addinput">add-input</a></b> (file callback)
  <b><a name="removeinput">remove-input</a></b> (id)

  <b><a name="addidler">add-idler</a></b> (code)
  <b><a name="removeidler">remove-idler</a></b> (id)

  <b><a name="changeproperty">change-property</a></b> (known-atom property value)

  <b><a name="listenerselection">listener-selection</a></b> ()
</pre>
<p>These are still experimental; <i>add-input</i> causes <i>callback</i> (a function of one argument, the file number)
to be called whenever input is available on <i>file</i> (a file number, as returned by C's open). <i>remove-input</i>
removes the callback.  Eventually I hope to add MIDI controls to Snd, using these two functions.
Here's a somewhat contrived example; since Scheme uses ports, not bare Unix file numbers, we
have to translate back and forth:
</p>
<pre>
(let ((p (open-input-pipe "ls -l *.h"))
      (func #f))
  (set! func (add-input 
	      (fileno p) 
	      (lambda (f) 
		(let ((instr (read-line (fdes-&gt;inport f))))
		  (if (string? instr)
		      (display (format #f "~%~S" instr))
		      (remove-input func)))))))
</pre>
<p>
<i>add-idler</i> adds a background process running <i>code</i> (a Scheme function of no arguments).
As long as the function returns #t, the process keeps calling it; <i>remove-idler</i> takes as its
argument the thing returned by <i>add-idler</i> (the identifier of that process), and kills the
associated background process.
</p>
<pre>
  (<em class=red>add-idler</em> (let ((ctr 0)) (lambda () (snd-print "hi") (set! ctr (1+ ctr)) (< ctr 3))))
</pre>
<p>prints "hi" three times, then quits.
<i>change-property</i> changes an X-window's property; there's an example in examp.scm. <i>listener-selection</i>
returns the currently selected text in the listener, or #f if there isn't any.  The following posts help related
to the selection if "h" is typed in the graph:
</p>
<pre>
  (bind-key (char->integer #\h) 0 
    (lambda ()
      (let ((subject (<em class=red>listener-selection</em>)))
	(if subject
            (help-dialog subject (snd-help subject))))))
</pre>


<br>

<br>
<span class=bbox><h3><A NAME="sndexamples">Examples</a></h3></span>

<p>These examples are simplified to make the exposition cleaner; see <a href="sndscm.html#exampdoc">examp.scm</a> for more robust versions.
<a href="sndscm.html#exampdoc">examp.scm</a> also has examples that add and remove menu items, set variables via the special "F" keys,
perform correlation on the current data, 
make a system call from the listener, and so on.  The following function computes the rms amplitude of a region:</p>

<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(define region-rms
 (lambda (n)
  (let* ((data (<a href="#sndregionsamples">region-samples</a> 0 0 n))
	 (len (vector-length data))
	 (sum 0.0))
   (do ((i 0 (1+ i))) 
	((= i len) (sqrt (/ sum len))) 
    (set! sum (+ sum (* (vector-ref data i) (vector-ref data i))))))))
</pre></td></tr></table>

<p>To get the data currently displayed in the time domain window:</p>

<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(define <A NAME="windowsamples">window-samples</a>
 (lambda ()
  (let ((wl (<a href="#sndleftsample">left-sample</a>))
	(wr (<a href="#sndrightsample">right-sample</a>)))
   (<a href="#sndsamples">samples</a> wl (+ 1 (- wr wl))))))
</pre></td></tr></table>

<p>Now we can use <i>window-samples</i> and <i>lisp-graph-hook</i>
to show a running graph of the
time domain energy:</p>

<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(define <A NAME="displayenergy">display-energy</a>
 (lambda (snd chn)
  (let* ((data (window-samples))
	 (len (vector-length data)))
   (do ((i 0 (1+ i))) 
       ((= i len))
    (vector-set! data i (* (vector-ref data i) (vector-ref data i))))
   (<a href="#sndgraph">graph</a> data))))

(add-hook! <a href="#lispgraphhook">lisp-graph-hook</a> display-energy)
</pre></td></tr></table>

<p>As the time domain window is moved, the lisp window automatically
updates itself.  Another example, display-db, displays the data in decibels.
The same thing can show the spectral energy
(via <i>transform-samples</i>).  
The functions graph, fft, insert-samples, and set-samples know about vcts,
so we can rewrite display-energy:</p>

<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(define display-energy
  (lambda (snd chn)
    (let* ((ls (left-sample snd chn))
	   (rs (right-sample snd chn))
	   (data (samples-&gt;vct ls (+ 1 (- rs ls)) snd chn))
	   (len (vct-length data))
	   (sr (srate snd)))
      (vct-multiply! data data)
      (graph data "energy" (/ ls sr) (/ rs sr) 0.0 1.0 snd chn))))
</pre></td></tr></table>

<p>But this grovels through infinite useless data if we're displaying
large sections of a sound, and leaves most of our data scrunched against
the y axis; a better version is:
</p>

<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(define display-energy
  ;; in this version, the y-zoom-slider controls the graph amp
  (lambda (snd chn)
    "(display-energy snd chn) is a lisp-graph-hook function to display the time domain data\n\
    as energy (squared)"
    (let* ((ls (left-sample))
           (rs (right-sample))
	   (datal (make-graph-data snd chn))
	   (data (if (vct? datal) datal (cadr datal)))
           (len (vct-length data))
           (sr (srate snd))
	   (y-max (y-zoom-slider snd chn)))
      (vct-multiply! data data)
      (graph data "energy" (/ ls sr) (/ rs sr) 0.0 (* y-max y-max) snd chn #f))))
</pre></td></tr></table>

<p>See <a href="sndscm.html#exampdoc">examp.scm</a> for more examples of using the vct structure.
Say we want Snd to refuse to exit if there are unsaved edits.</p>

<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(define <A NAME="unsavededits">unsaved-edits?</a>
  (lambda (ind)
    (and (&lt; ind (max-sounds))
	 (or (and (sound? ind)
		  (&gt; (car (edits ind)) 0)
		  (report-in-minibuffer "there are unsaved edits")
		  #t)
	     (unsaved-edits? (+ ind 1))))))

(add-hook! exit-hook 
  (lambda () 
    (report-in-minibuffer "") 
    (unsaved-edits? 0)))
</pre></td></tr></table>

<p>Here's somewhat brute-force code to play a sound a given number of times:</p>

<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(define (play-often n) 
  (let ((plays (- n 1)))
    (define (play-once snd)
      (if (or (= plays 0)
	      (c-g?))
	  (remove-hook! stop-playing-hook play-once)
	  (begin
	    (set! plays (- plays 1))
	    (play 0 snd))))
    (add-hook! stop-playing-hook play-once)
    (play)))

(bind-key (char-&gt;integer #\p) 0 
  (lambda () 
    (play-often (max 1 (prefix-arg)))) #t)
</pre></td></tr></table>

<p>Say we are so annoyed by the X/Motif file browser that we want
Snd to exit back to the shell if its file argument is not
found (this code obviously has to be in the init file):</p>

<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(define no-startup-file?
  (lambda (ind file)
    (if (= ind (max-sounds))
	(begin
	  (write (string-append "can't open " file) (current-error-port))
	  (newline (current-error-port))
	  #t)
	(if (sound? ind)
	    #f
	    (no-startup-file? (+ ind 1) file)))))

(add-hook! start-hook 
  (lambda (file) 
    (if (&gt; (string-length file) 0) 
        (no-startup-file? 0 file) 
        #f)))
</pre></td></tr></table>

<p>And just for completeness, here's an example of using the fft-hook.
</p>

<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
(define fft-peak
  (lambda (snd chn scale)
    (if (and (ffting) 
             (= (fft-style) normal-fft))
	(let* ((samps (transform-samples snd chn))
	       (len (vector-length samps))
	       (mx (vector-ref samps 0))
	       (peak (do ((i 1 (+ i 1))) 
                         ((= i len) 
                          (/ (* 2 mx) (fft-size)))
		       (let ((val (abs (vector-ref samps i))))
			 (if (&gt; val mx) 
                             (set! mx val))))))
	  (report-in-minibuffer (number-&gt;string peak) snd))
      #f)))
	
(add-hook! fft-hook fft-peak)
</pre></td></tr></table>

<p>The following function uses the sndlib functions to mimic the 'info' popup menu option (see <a href="sndscm.html#exampdoc">examp.scm</a> for a version that uses format):</p>

<table border=1 cellpadding=5><tr><td bgcolor="#FCFCF0"><pre>
<A NAME="sndinfo"></a>
(define info 
  (lambda (file)
    (string-append 
     file
     ": chans: " (number-&gt;string (<a href="#soundchans">mus-sound-chans</a> file))
     ", srate: " (number-&gt;string (<a href="#soundsrate">mus-sound-srate</a> file))
     ", " (<a href="#soundtypename">mus-header-type-name</a> (<a href="#soundheadertype">mus-sound-header-type</a> file))
     ", " (<a href="#soundformatname">mus-data-format-name</a> (<a href="#sounddataformat">mus-sound-data-format</a> file))
     ", len: " (number-&gt;string 
                (/ (<a href="#soundsamples">mus-sound-samples</a> file) 
                   (* (<a href="#soundchans">mus-sound-chans</a> file) (<a href="#soundsrate">mus-sound-srate</a> file)))))))
</pre></td></tr></table>
<br><br>

<img src="energy.png" alt="picture of examp.scm in action">
<br><br>

        <!-- I(open file):L(open-sound)(sndopen) -->
	<!-- I(close file):L(close-sound)(sndclose) -->
	<!-- I(save file):L(save-sound)(sndsave) -->
        <!-- I(save file as):L(save-sound-as)(sndsaveas) -->
        <!-- I(change format):L(save-sound-as)(sndsaveas) -->
	<!-- I(revert file):L(revert-sound)(sndrevert) -->
        <!-- I(open file read-only):L(view-sound)(sndview) -->
        <!-- I(create new file):L(new-sound)(sndnew) -->
	<!-- I(print file):L(graph->ps)(sndgraph2ps) -->
	<!-- I(exit Snd):L(exit)(sndexit) -->
        <!-- I(undo edit):L(undo)(sndundo) -->
	<!-- I(redo edit):L(redo)(sndredo) -->
        <!-- I(cut selection):L(cut)(sndcut) -->
	<!-- I(insert selection):L(insert-region)(sndinsertregion) -->
	<!-- I(play file):L(play, stop)(sndplay) -->
        <!-- I(show marks):L(show-marks)(showmarks) --><!-- I(show marks):A(showmarks) -->
	<!-- I(y=0 line):L(show-y-zero)(showyzero) -->
	<!-- I(dots or lines):L(graph-style)(graphstyle) -->
        <!-- I(combine channels):L(channel-style)(channelstyle) -->
        <!-- I(normalize display):L(normalize-view)(sndnormalizeview) -->
        <!-- I(control panel):L(show-controls)(sndshowcontrols) -->
	<!-- I(fft peaks):L(show-fft-peaks)(showfftpeaks) -->
        <!-- I(fft peaks):O(peaks)(sndpeaks) -->
	<!-- I(fft/sono/spectrogram):L(fft-style)(lfftstyle) -->
        <!-- I(zoom focus):L(zoom-focus-style)(zoomfocusstyle) -->
	<!-- I(fft in dB):L(fft-log-magnitude)(fftlogmagnitude) -->
	<!-- I(fft log freq):L(fft-log-frequency)(fftlogfrequency) -->
	<!-- I(select sound):L(selected-sound)(sndselectedsound) -->
	<!-- I(multichannel ops):L(sync)(sndsyncing) -->
        <!-- I(save control panel):L(control-panel-save)(sndcontrolpanelsave) -->
	<!-- I(amp env):L(env-sound)(sndenv) -->
        <!-- I(filter):L(filter-env)(sndfilterenv) -->
	<!-- I(filter):M(Edit: Edit Env)(editenvelope) -->
        <!-- I(axis bounds):L([xy]-bounds)(sndxbounds) -->
	<!-- I(max amp):L(maxamp)(sndmaxamp) -->
	<!-- I(max amp):A(sndmaxamp) -->
        <!-- I(define mark):L(add-mark)(sndaddmark) -->
	<!-- I(preload directory):L(preload-directory)(sndpreloaddirectory) -->
        <!-- I(color):L(color-dialog)(sndcolordialog) -->
	<!-- I(color):O(color-scale,color-cutoff)(colorscale) -->
        <!-- I(orientation):L(orientation-dialog)(sndorientationdialog) -->
	<!-- I(file lists):L(file-dialog)(sndfiledialog) -->
        <!-- I(define selection):L(make-region)(sndmakeregion) -->
	<!-- I(delete samples):L(delete-samples)(snddeletesamples) -->
        <!-- I(temp directory):L(temp-dir)(tempdir) -->
        <!-- I(continue session):L(load) -->
        <!-- I(fft window):L(fft-window)(lfftwindow) -->
	<!-- I(fft size):L(fft-size)(lfftsize) -->
        <!-- I(fft window parameter):L(fft-beta)(fftbeta) -->
	<!-- I(move cursor ahead):L(forward-sample)(sndforwardsample) -->
        <!-- I(move cursor back):L(backward-sample)(sndbackwardsample) -->
        <!-- I(insert zeros):L(insert-samples)(sndinsertsamples) -->
	<!-- I(change samples):L(set-samples)(sndsetsamples) -->
	<!-- I(srate conversion):L(src-sound)(sndsrc) --><!-- I(srate conversion):M(Edit: Edit Env)(editenvelope) -->
        <!-- I(srate conversion):O(src-selection)(sndsrcselection) --><!-- I(srate conversion):A(sndsrc) -->
	<!-- I(resample):L(src-sound)(sndsrc) --><!-- I(resample):M(Edit: Edit Env)(editenvelope) --><!-- I(resample):A(sndsrc) -->
	<!-- I(resample):O(src-selection)(sndsrcselection) --><!-- I(reverse samples):A(sndreverse) -->
	<!-- I(reverse samples):L(reverse-sound)(sndreverse) --><!-- I(reverse samples):O(reverse-selection)(sndreverseselection) -->
	<!-- I(filter samples):L(filter-sound)(sndfilter) --><!-- I(filter samples):M(Edit: Edit Env)(editenvelope) -->
	<!-- I(filter samples):O(filter-selection)(sndfilterselection) --><!-- I(filter samples):A(sndfilter) -->
	<!-- I(save marks):L(save-marks)(sndsavemarks) -->
        <!-- I(show freq domain):L(ffting)(sndffting) -->
	<!-- I(show time domain):L(waving)(sndwaving) -->
        <!-- I(keyboard macros):L(key)(sndkey) -->
        <!-- I(delete mark):L(delete-mark)(snddeletemark) --> <!-- I(delete mark):O(delete-marks)(snddeletemarks) -->
	<!-- I(sonogram):L(fft-style)(lfftstyle) -->
	<!-- I(spectrogram):L(fft-style)(lfftstyle) -->
        <!-- I(X axis units):L(x-axis-style)(xaxisstyle) -->
	<!-- I(speed units):L(speed-style)(lspeedstyle) -->
        <!-- I(fft normalization):L(normalize-fft)(normalizefft) -->
        <!-- I(fft normalization):A(normalizefft) -->
	<!-- I(speed units):O(speed-tones)(speedtones) -->
	<!-- I(change srate):L(src-sound)(sndsrc) -->	
	<!-- I(edit env):L(enved-dialog)(sndenveddialog) -->
	<!-- I(edit header):L(edit-header-dialog)(sndeditheaderdialog) -->
	<!-- I(insert file):L(insert-sound)(sndinsertfile) -->
	<!-- I(mix file):L(mix)(sndmix) -->
	<!-- I(move mixed file):L(mix-position)(sndmixposition) -->
	<!-- I(move to mark):L(forward-mark)(sndforwardmark) -->
	<!-- I(move to mix):L(forward-mix)(sndforwardmix) -->
	<!-- I(play selection):L(play-region)(sndplayregion) -->
	<!-- I(update file):L(update)(sndupdate) -->
	<!-- I(view envs):L(enved-dialog)(sndenveddialog) -->
	<!-- I(play channel):L(play)(sndplay) -->
	<!-- I(mix selection):L(mix-region)(sndmixregion) -->
	<!-- I(interrupt Snd):L(stop)(sndstop) -->
	<!-- I(move window back):L(left-sample)(sndleftsample) -->
	<!-- I(move window ahead):L(right-sample)(sndrightsample) -->
	<!-- I(numeric arguments):L(prefix-arg)(prefixarg) -->
	<!-- I(change tempo):L(expand)(sndexpand) -->
	<!-- I(wavelets):L(wavelet-type)(wavelettype) -->
	<!-- I(save macros):L(save-macros)(sndsavemacros) -->
        <!-- I(save selection):L(save-region)(sndsaveregion) --><!-- I(save selection):O(save-selection)(sndsaveselection) -->
	<!-- I(examine regions):L(region-dialog)(sndregiondialog) -->
	<!-- I(zoom window):L(x-bounds)(sndxbounds) -->
	<!-- I(save options):L(save-options)(sndsaveoptions) -->
	<!-- I(describe audio):A(describeaudiostate) --><!-- I(describe audio):L(mus-audio-describe)(describeaudiostate) -->
	<!-- I(abort command):L(c-g?)(sndabort) -->
	<!-- I(count matches):L(count-matches)(lcountmatches) --><!-- I(count matches):A(lcountmatches) -->
	<!-- I(convolution):L(convolve)(sndconvolve) --><!-- I(convolution):A(sndconvolve) --><!-- I(convolution):O(convolve-with)(sndconvolvewith) -->
	<!-- I(auto save):O(examp.scm) -->
        <!-- I(reverberate file):L(convolve-with)(sndconvolvewith) -->
        <!-- I(record sound):L(recorder-dialog)(sndrecorderdialog) -->
        <!-- I(describe file):L(info)(sndinfo) -->
        <!-- I(change pitch):L(src-sound)(sndsrc) -->
	<!-- I(change colors):L(make-color)(aboutcolors) --><!-- I(change colors):A(aboutcolors) --><!-- I(change colors):O(resources)(sndresources) -->
	<!-- I(create new file):O(default-output-srate)(defaultoutputsrate) -->
	<!-- I(autocorrelation):L(autocorrelate)(sndautocorrelate) -->
	<!-- I(axis bounds):O(axis-info)(axisinfo) -->
	<!-- I(horizontal panes):L(graphs-horizontal)(graphshorizontal) -->
	<!-- I(extract channel):L(save-sound-as)(sndsaveas) -->
	<!-- I(save channel):L(save-sound-as)(sndsaveas) -->
	<!-- I(swap channels):L(swap-channels)(swapchannels) -->
	<!-- I(overlay sounds):L(graph-data)(graphdata) -->
	<!-- I(overlay sounds):A(graphdata) -->
	<!-- I(edit env):O(enved-hook)(envedhook) -->
	<!-- I(file lists):O(mouse-enter-label-hook)(mouseenterlabelhook) -->
	<!-- I(swap channels):A(swapchannels) -->

<center>
<span class=htmlbox>related documentation</span><span class=htmlbox><a href="snd.html">snd.html</a><spacer type=horizontal size=25><a href="grfsnd.html">grfsnd.html</a><spacer type=horizontal size=25><a href="clm.html">clm.html</a><spacer type=horizontal size=25><a href="sndlib.html">sndlib.html</a><spacer type=horizontal size=25><a href="sndscm.html">sndscm.html</a><spacer type=horizontal size=25><a href="index.html">index.html</a></span>
</center>

</body></html>
