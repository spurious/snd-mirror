Scheme Functions included with Snd

related documentationsnd.html   extsnd.html   grfsnd.html   clm.html    sndlib.html

                       * bell.scm: the fm-bell from CLM
                       * bird.scm: North-American birds
                        * effects.scm: an Effects menu
                         * env.scm: envelope functions
                         * enved.scm: envelope editor
                          * examp.scm: many examples
                     * fmv.scm: the fm-violin in Guile-gtk
                        * glfft.scm: OpenGL for spectra
                           * gm.scm: gmeteor support
                         * goopsnd.scm: look at Goops
                        * index.scm: snd-help extension
                        * loop.scm: Common Lisp syntax
                    * marks.scm: functions related to marks
               * mix.scm: functions related to mixes and tracks
                            * moog.scm: Moog filter
                  * pqwvox.scm: phase-quadrature waveshaping
               * prc95.scm: Perry Cook's physical model examples
                           * pvoc.scm: phase-vocoder
                               * rgb.scm: colors
                          * rtio.scm: real-time stuff
                          * rubber.scm: rubber-sound
                       * snd-gtk.scm: Guile-Gtk examples
                     * snd-test.scm: Snd regression tests
                              * v.scm: fm-violin
                             * ws.scm: with-sound
                     * zip.scm: the zipper (a cross-fader)
                      * A Note on Scheme variables in Snd
                    * A Note on "As-Needed" input functions

This file contains a leisurely discourse upon the various *.scm files
included with Snd. To use any of these files, (load <file>); for example
(load "bell.scm"). To start Snd with the file already loaded, snd -l
bell.scm.

bell.scm

  fm-bell startime dur frequency amplitude amp-env index-env index

The FM bell was developed by Michael McNabb in Mus10 in the late '70s. It is
intended for low bell sounds (say middle C or so). The lines

           (mod1 (make-oscil :frequency (* frequency 2)))
           (mod2 (make-oscil :frequency (* frequency 1.41)))
           (mod3 (make-oscil :frequency (* frequency 2.82)))
           (mod4 (make-oscil :frequency (* frequency 2.4)))
           (car1 (make-oscil :frequency frequency))
           (car2 (make-oscil :frequency frequency))
           (car3 (make-oscil :frequency (* frequency 2.4)))

set up three FM pairs, car1+mod1 handling the basic harmonic spectra,
car2+mod2 creating inharmonic spectra (using the square root of 2 more or
less at random), and car3+mod3 putting a sort of formant at the minor third
(2.4 = a ratio of 12/5 = octave+6/5 = minor tenth).

  (define fbell '(0 1 2 1.1000 25 .7500 75 .5000 100 .2000 ))
  (define abell '(0 0 .1000 1 10 .6000 25 .3000 50 .1500 90 .1000 100 0 ))
  (fm-bell 0.0 1.0 220.0 .5 abell fbell 1.0)

bird.scm

  bird start dur frequency freqskew amplitude freq-envelope amp-envelope
  bigbird start dur frequency freqskew amplitude freq-envelope amp-envelope partials
  one-bird beg maxdur func birdname
  make-birds &optional (output-file "test.snd")

bird.scm is a translation of Sambox/CLM bird songs. The two instruments set
up a simple sine wave (bird) and simple waveshaping synthesis (bigbird). Use
a low-pass filter for distance effects (a bird song sounds really silly
reverberated). All the real information is in the amplitude and frequency
envelopes. These were transcribed from sonograms found in some bird guides
and articles from the Cornell Ornithology Lab. The variable
with-editable-mixes controls whether each bird is tagged so that you can
move it around later (for a pretty picture of the result, check this out).
The function one-bird mixes in one complete birdsong, using the bird's name
for the edit history list. Many of these birds were used in "Colony". To
hear all the birds, call (make-birds). This writes the sequence out as
"test.snd"; give the desired file name as the (optional) argument to
make-birds: (make-birds "birds.snd"). Waveshaping is described in Le Brun,
"Digital Waveshaping Synthesis", JAES 1979 April, vol 27, no 4, p250.

(define (one-bird beg maxdur func birdname)
  ;; it would be better if this could get the needed mix length automatically
  ;; saving the individual squeaks in one vector saves us zillions of temp files (and is faster)
  (set! out-data (make-vct (round (* (srate) maxdur))))
  (func)
  (as-one-edit
   (lambda ()
     (mix-vct out-data (round (* beg (srate))) out-file 0 with-editable-mixes))
   birdname))

The one-bird function collects all the individual tweets of a given bird
song into one vct object, then mixes that into the output sound. The beg and
maxdur arguments set the begin time and maximum duration in seconds of the
mix; the duration is used to allocate the global vct object (out-data. The
func argument is a Scheme function of no arguments (known in Scheme as a
"thunk"). It is called via (func); the assumption is that func will actually
provide a complete bird song. For example:

(define (bobwhite beg)
  (let ((bobup1 '(.00 .00 .40 1.00 1.00 1.0))
        (bobup2 '(.00 .00 .65 .50 1.00 1.0)))
    (one-bird beg 2.0
     (lambda ()
       (bigbird .4 .2 1800 200 .1 bobup1 main-amp '(1 1 2 .02))
       (bigbird 1 .20 1800 1200 .2 bobup2 main-amp '(1 1 2 .02)))
     (report-in-minibuffer "bobwhite"))))

defines a Bobwhite call (a kind of mid-western quail -- I grew up in
Oklahoma and heard these calls every day). The func in this case is:

     (lambda ()
       (bigbird .4 .2 1800 200 .1 bobup1 main-amp '(1 1 2 .02))
       (bigbird 1 .20 1800 1200 .2 bobup2 main-amp '(1 1 2 .02)))

which calls bigbird twice (the "bob" and the "white"). It also reports the
name "bobwhite" in the minibuffer (this is mostly to let the caller know
that something is happening -- since we aren't calling update-graph, there's
no visual indication that a bird has been mixed in). one-bird uses
as-one-edit mostly to package up the birdsong with any possible file
extension (if beg is beyond the current end-of-file) which would otherwise
appear as a separate edit in the edit history list. In bigbird the lines

           ...
           (coeffs (partials->polynomial (normalize-partials partials)))
           ...
                     (polynomial coeffs
                                 (oscil os (env gls-env))))))

setup and run the waveshaping synthesis (in this case it's just a fast
additive synthesis). partials->polynomial calculates the Chebychev
polynomial coefficients given the desired spectrum; the spectrum then
results from driving that polynomial with an oscillator. Besides the bird
guides, there are now numerous recordings of birds that could easily be
turned into sonograms and transcribed as envelopes. In fact, in Snd this
could be automated...

In CLM, the bird is:

(definstrument bird (startime dur frequency freq-skew amplitude freq-envelope amp-envelope
                     &optional (lpfilt 1.0) (degree 0) (reverb-amount 0))
  (multiple-value-bind (beg end) (times->samples startime dur)
    (let* ((amp-env (make-env amp-envelope amplitude dur))
           (gls-env (make-env freq-envelope (hz->radians freq-skew) dur))
           (loc (make-locsig :degree degree :distance 1.0 :reverb reverb-amount))
           (fil (make-one-pole lpfilt (- 1.0 lpfilt)))
           (s (make-oscil :frequency frequency)))
      (run
       (loop for i from beg to end do
         (locsig loc i (one-pole fil (* (env amp-env) (oscil s (env gls-env))))))))))

The bird.scm version could easily include the one-pole filter and so on.

effects.scm

effects.scm implements a simple "Effects" menu, mimicking other sound
editors. I think this is a mistake, but new Snd users expect a "real" editor
to provide a list of sound effects somewhere. The effects implemented
currently are:

  reverse
  normalize (normalization)
  gain (gain-amount)
  invert
  chordalize (chordalize-amount, chordalize-base)
  flange (increase speed and amount to get phasing, flange-speed, flange-amount, flange-time)
  compand
  reverberate (reverb-amount)
  intensify (contrast-amount)
  echo (echo-length, echo-amount)
  trim front and trim back (to/from marks)
  crop (first and last marks)
  squelch (squelch-amount, omit-silence)
  selection->new
  cut selection->new
  add silence (at cursor) (silence-amount)
  append selection (and append sound)
  remove DC
  expsrc (independent pitch/time scaling) (time-scale and pitch-scale)
  notch filter (notch-freq and notch-bw)

Most of these are either simple calls on Snd functions ("invert" is
(scale-by -1)), or use functions in examp.scm. The actual operations follow
the sync chain of the currently active channel. Many are dependent on
variables that could, I suppose, be brought out in some dialog.
"reverberate", for example, depends on the variable reverb-amount to
determine how much reverberation you get. To change such a variable (set!
reverb-amount .1).

One possibly interesting part of effects.scm is the implementation of the
Effects menu. If you change one of the variables, you'll notice that the
menu updates its notion of that variable as well. This is handled through
update-callback argument to add-to-main-menu function. Each effect is added
(when effects.scm is loaded) to the effects-list. Then each time you click
the Effects menu, causing its options to be dispayed, the update-callback
function itself calls each effect's update function to get its current
option label. That is,

(define effects-list '())
(define effects-menu
  (add-to-main-menu "Effects"
                    (lambda ()
                      (define (update-label effects)
                        (if (not (null? effects))
                            (begin
                              ((car effects))
                              (update-label (cdr effects)))))
                      (update-label effects-list))))

defines the update-callback to be a "thunk" (the outer lambda) that itself
defines a local function (update-label) that runs through the effects-list
calling each one via ((car effects)). Each effect that wants to recalculate
its option label then adds its update function to the effects-list when it
is loaded:

(set! effects-list (cons (lambda ()
                           (let ((new-label (format #f "gain (~1,2F)" gain-amount)))
                             (change-menu-label effects-menu gain-label new-label)
                             (set! gain-label new-label)))
                         effects-list))

The sound effect itself is the callback function of the given option:

(add-to-menu effects-menu "reverse" (lambda () (reverse-sound)))

I can't decide whether it would be useful to describe some of these effects
in more detail. The code is mostly straight-forward, and it's not hard to
try them out.

env.scm

An envelope in Snd/CLM is simply a list of breakpoint pairs. The x axis
extent is arbitrary, though it's simplest to use 0.0 to 1.0. env.scm
provides several envelope functions that are often useful:

  envelope-interp x env base
  window-envelope beg end env
  map-envelopes func env1 env2
  multiply-envelopes env1 env2
  max-envelope env
  integrate-envelope env
  max-x env

These are translated from CLM's env.lisp which has many more useful
functions; someday they also should be translated. (envelope-interp x env
base) returns value of env at x. If base is 0, env is treated as a step
function; if base is 1.0 (the default), its breakpoints are connected by a
straight line, and any other base connects the breakpoints with a kind of
exponential curve:

:(envelope-interp .1 '(0 0 1 1))
0.1
:(envelope-interp .1 '(0 0 1 1) 32.0)
0.0133617278184869
:(envelope-interp .1 '(0 0 1 1) .012)
0.361774730775292

The corresponding function for a CLM env generator is env-interp. If you'd
rather think in terms of e^-kt, set the base to (exp k).

window-envelope returns (as an envelope) the portion of its envelope
argument that lies between the X axis values beg and end. This is useful
when you're treating an envelope as a phrase-level control, applying
successive portions of it to many underlying notes.

:(window-envelope 1.0 3.0 '(0.0 0.0 5.0 1.0))
(1.0 0.2 3.0 0.6)

map-envelopes applies its func argument to the breakpoints in the two
envelope arguments, returning a new envelope. A simple application of this
is multiply-envelopes which multiplies two envelopes:

:(multiply-envelopes '(0 0 1 1) '(0 0 1 1 2 0))
(0 0 0.5 0.5 1 0)

As this example shows, the new envelope goes from 0.0 to 1.0 along the X
axis; the multiplied envelopes are stretched or contracted to fit 0.0 to
1.0, and wherever one has a breakpoint, the corresponding point in the other
envelope is interpolated, if necessary. The code for multiply envelopes is
simply:

(define multiply-envelopes
  (lambda (e1 e2)
    (map-envelopes * e1 e2)))

max-envelope returns the maximum Y value in env, and max-x returns the
maximum X value:

:(max-envelope '(0 0 1 1 2 3 4 0))
3.0

integrate-envelope returns the area under the envelope; this is useful when
you need to know in advance the overall effect of an envelope controlling
the sampling rate, for example.

:(integrate-envelope '(0 0 1 1))
0.5
:(integrate-envelope '(0 1 1 1))
1.0
:(integrate-envelope '(0 0 1 1 2 .5))
1.25

More of env.lisp will be translated eventually.

enved.scm

  start-enveloping
  stop-enveloping
  channel-envelope snd chn
  play-with-envs snd
  play-panned snd

enved.scm implements an independent envelope editor in each channel.
(start-enveloping) sets this in progress (for subsequently opened sounds),
(stop-enveloping) turns it off. Each envelope can be read or written via
(channel-envelope snd chn). There are also two examples that use these
envelopes: play-with-envs and play-panned. The former sets the channel's
amplitude from its envelope during playback (it should be obvious how to
apply the envelope to any of the control panel fields); the latter pans a
mono sound into stereo following the envelope. The lines:

(define channel-envelope
  (make-procedure-with-setter
    (lambda (snd chn)
      ...)
    (lambda (snd chn new-env)
      ...)))

use a feature of Guile 1.4 that provides a set! function for
channel-envelope. The first lambda is called if you're asking for the
current value of that channel-envelope:

(channel-envelope s c)

and the second if you're setting it to something new:

(set! (channel-envelope s c) e)

examp.scm

examp.scm has become a bit of a grab-bag; rather than get organized, I just
appended new stuff as it came to mind. The following documentation is mostly
a quick overview of the code; most of the examples are very simple, so (as
the saying goes) "the code is the documentation". Also, there's some overlap
between these examples, other .scm files, and discussions in other
documents.

   * play
        o play sound n times
        o play region over and over until C-g typed
        o play samples created on-the-fly
        o play while looping continuously between two movable marks
        o hold DAC open and play sounds via keyboard
   * filters
        o comb-filter, notch-filter, formant-filter
        o time varying FIR filter, notch filter, frequency-response -> FIR
          coeffs
        o filtered-env (low-pass and amplitude follow envelope)
        o Butterworth filters
   * ffts
        o correlation
        o set fft-size based on current time domain window size
        o superimpose spectra of sycn'd sounds
        o fft-edit -- FFT based editing
        o move sound down 8ve using fft
        o Dolph-Chebyshev fft data window
        o dht -- slow Hartley transform
        o phase vocoder
   * user-interface
        o XEmacs-like "Buffers" menu
        o make dot size dependent on number of samples being displayed
        o flash selected data red and green
        o show bomb icon
        o add date and time to title bar
        o how to get 'display' to write to Snd's listener
        o multi-colored rxvt printout
        o accessors for graph-style fields
        o auto-save
   * marks
        o use loop info (if any) to set marks at loop points
        o move window left edge to mark upon 'm' key
   * selections
        o delete selected portion and smooth the splice
        o eval over selection or between marks replacing current samples,
          mapped to "x" or "m" key using prompt-in-minibuffer
        o swap selection chans
        o selection-members
   * mixes
        o mix with result at original peak amp
        o mix mono sound into stereo sound panning according to env, also
          simple sound placement
        o mix with envelope
   * sound effects
        o echo (delays)
        o ring-modulation, am
        o src-related sound effects (src, rand-interp, etc)
        o compand (array-interp)
        o shift pitch keeping duration constant (src+granulate)
        o tempo change via envelope (granulate)
        o cross-synthesis (using a formant bank)
        o voiced->unvoiced (formants)
        o convolution (convolve)
        o reverb (all-pass etc)
        o "frequency division"
        o "adaptive saturation"
        o spike effect
        o fancier locsig
   * synthesis
        o scissor-tailed flycatcher (waveshaping)
        o fm-violin (FM and various other generators, #&key args)
        o FOF voice synthesis (wave-train, #&optional args)
        o pluck instrument (physical modelling)
        o voice instrument (formants via FM)
        o compute-uniform-circular-string (and scanned-synthesis)
   * miscellaneous extensions
        o 'info' from extsnd.html using format
        o make a system call
        o documentation examples made harder to break
        o example of c-g?
        o translate mpeg input to 16-bit linear and read into Snd
        o mapping extensions (map arbitrary single-channel function over
          various channel collections)
        o vct func like list
        o map-sound-files, match-sound-files
        o sound-interp, env-sound-interp

play

These examples relate to playing sounds. To set up the keyboard as a kind of
extended piano, we could map keys to sounds:

(bind-key (char->integer #\o) 0 (lambda () (play "oboe.snd")))
(bind-key (char->integer #\p) 0 (lambda () (play "pistol.snd")))

The various play hooks can be used to play sounds over and over.

  pl times
  play-region-forever region

(bind-key (char->integer #\p) 0 (lambda () (pl (max 1 (prefix-arg)))) #t)
(bind-key (char->integer #\r) 0 (lambda () (play-region-forever (max 0 (prefix-arg)))) #t)

Now C-u 31 p plays the current sound 31 time; C-u 3 r plays region 3 until
we type C-g. pl uses stop-playing-hook, and play-region-forever uses
stop-playing-region-hook. With a sufficiently fast computer, it's possible
to create the samples to be played in "real-time". play-fun starts and stops
the DAC, ampit and amprt fill up the audio buffer with data.

(play-fun (ampit (frames) 2.0) 256)

scales sound 0's samples by 2 and sends them to the DAC. More useful is:

  loop-it mark1 mark2 buffer-size

which loops continuously between the two specified marks. The marks can be
moved as the sound is played; C-g stops loopit. If you want the DAC to be
held open in the background,

  start-dac
  stop-dac

filters

  comb-filter scaler size
  comb-chord scaler size amp
  zcomb scaler size pm
  notch-filter scaler size
  formant-filter radius frequency
  formants r1 f1 r2 f2 r3 f3
  moving-formant radius move-envelope
  osc-formants radius bases amounts freqs

The two versions of comb-filter implement a comb filter both "by hand" and
using CLM. comb-chord uses comb filters at harmonically related sizes to
create a chord (see also chordalize in effects.scm). amp here is an overall
amplitude scaler. zcomb is a time-varying comb filter using the envelope pm.
notch-filter parallels comb-filter. formant-filter applies a formant to its
input. Some examples:

(map-chan (comb-filter .8 32))
(map-chan (comb-chord .95 100 .3))
(map-chan (comb-chord .95 60 .3))
(map-chan (zcomb .8 32 '(0 0 1 10)))
(map-chan (notch-filter .8 32))
(map-chan (formant-filter .99 2400))

In all these cases, however, it's actually much faster to pass the filter to
filter-sound:

(filter-sound (make-formant .99 2400))

formants applies three formants in parallel. moving-formant moves a formant
according to an envelope. osc-formants sets up any number of independently
oscillating formants.

(map-chan (formants .99 900 .98 1800 .99 2700))
(map-chan (moving-formant .99 '(0 1200 1 2400)))
(map-chan (osc-formants .99 '(400 800 1200) '(400 800 1200) '(4 2 3)))

  filtered-env envelope

filtered-env creates an amplitude envelope and a one-pole filter, and moves
them in parallel over a sound; as the sound gets softer, the low-pass
filter's cutoff frequency gets lower, a sort of poor-man's distance effect.
When envelope is at 1.0, no filtering takes place.

  butter gen
  make-butter-high-pass freq
  make-butter-low-pass freq
  make-butter-band-pass freq bandwidth
  make-butter-band-reject freq bandwidth

These are simple Butterworth filters taken from Sam Heisz's CLM version of
Paris Smaragdis's Csound version of Charles Dodge's code from "Computer
Music: synthesis, composition, and performance". See also the notch filter
in effects.scm.

  fltit
  fltit-1
  spectrum->coeffs order spectrum-envelope

fltit is a simple FIR filter call; spectrum->coeffs is a Scheme version of
Snd's very simple spectrum->coefficients procedure ("frequency sampling").
It returns the FIR filter coefficients given the filter order and desired
spectral envelope.

(map-chan (fltit-1 10 (list->vct '(0 1.0 0 0 0 0 0 0 1.0 0))))

ffts

  correlate snd chn y0 y1
  superimpose-ffts snd chn y0 y1
  dht data
  dolph n gamma
  down-oct
  fft-edit low-freq high-freq
  pvoc #:key (fftsize 512) (overlap 4) (time 1.0) (pitch 1.0) (gate 0.0) (hoffset 0.0) (snd 0) (chn 0)

correlate graphs the correlation of snd's 2 channels. To make this happen
automatically as you move the time domain position slider, (add-hook!
graph-hook correlate). superimpose-ffts is a similar graph-hook function
that superimposes the ffts of multiple (syncd) sounds. dht is the slow form
of the Hartley transform, taken from Perry Cook's SignalProcessor.m. The
built-in function fht is the fast form of this transform. The Hartley
transform is a kind of Fourier transform. dolph is the Dolph-Chebychev fft
data window, taken from Richard Lyons, "Understanding DSP". down-oct tries
to move a sound down an octave by goofing with the fft data, then inverse
ffting. fft-edit is a simple example of fft-based editing. It takes an fft
of the entire sound, removes all energy below low-freq and above high-freq,
then inverse fft's. pvoc is a phase-vocoder. pvoc applies the phase-vocoder
(i.e. fft analysis, oscil bank resynthesis). to the current sound; pitch
specifies the pitch transposition ratio, time specifies the time dilation
ratio, gate specifies a resynthesis gate in dB (partials with amplitudes
lower than the gate value will not be synthesized), hoffset is a pitch
offset in Hz. Finally there are two examples of using graph-hook to set the
fft size based on the current time domain window size. The simpler one is:

(add-hook! graph-hook
           (lambda (snd chn y0 y1)
             (if (and (ffting snd chn)
                      (= (fft-style snd chn) normal-fft))
                 (begin
                   (set! (fft-size snd chn)
                         (expt 2 (ceiling
                                  (/ (log (- (right-sample snd chn) (left-sample snd chn)))
                                     (log 2.0)))))
                   (set! (spectro-cutoff snd chn) (y-zoom-slider snd chn))))))

The expt... code is rounding the current window size (right-sample -
left-sample) up to the nearest power of 2.

user-interface

  main-graph-style snd chn
  fft-graph-style snd chn
  lisp-graph-style snd chn

These three functions provide accessors for the channel-specific graph
styles. Each is of the form:

(define main-graph-style
  (make-procedure-with-setter
   (lambda (snd chn)
     (logand (graph-style snd chn) #xff))
   (lambda (snd chn val)
     (set! (graph-style snd chn)
           (logior (logand (graph-style snd chn) #xffff00)
                   val)))))

This uses the generalized set! support in Guile; make-procedure-with-setter
takes two arguments, the reader and the writer of the field. The reader
picks off the bits that are of interest (in this case (logand (graph-style
snd chn) #xff)); the writer sets those bits without affecting the other two
fields. Normally all three fields are accessed at the same time (by
graph-style). To return to this mode after setting a specific field, set
that field to -1.

:graph-dots
1
:(set! (fft-graph-style 0 0) graph-dots) ;now the time-domain uses lines, the fft dots
512
:(fft-graph-style 0 0)
1
:(main-graph-style 0 0)
0
:(set! (fft-graph-style 0 0) -1)
0
:(fft-graph-style 0 0)
0

Two of the examples are imitations of Xemacs: a "Buffers" menu and an
auto-save hook.

  open-buffer filename
  close-buffer snd
  auto-save
  cancel-auto-save

The Buffers menu provides a list of currently open sounds; selecting one in
the menu causes it to become the selected sound; open-buffer adds a menu
item that will select a file, close-buffer removes it. To activate this, we
need to:

(add-hook! open-hook open-buffer)
(add-hook! close-hook close-buffer)

The auto-save code sets up a background process that checks periodically for
unsaved edits, and if any are found it saves them in a temporary file. The
time between checks is set by the variable auto-save-interval which defaults
to 60.0 seconds. To start auto-saving, (auto-save), and to stop,
(cancel-auto-save).

  snd-out

A minor irritation in the current Guile system is that Scheme's "display"
function writes to current-output-port, but there's no simple way to
redirect that elsewhere (and with-output-to-string is not completely
integrated with Guile's help system). So, if your code calls display, the
result may be invisible. One way around this is to reset the
current-output-port to be a "soft port" that actually calls snd-print
instead:

(define stdout (current-output-port)) ;save it in case we want to go back to it
(define snd-out
  (make-soft-port
   (vector                      ;soft port is a vector of procedures:
    (lambda (c) (snd-print c))  ;  procedure accepting one character for output
    (lambda (s) (snd-print s))  ;  procedure accepting a string for output
    (lambda () #f)              ;  thunk for flushing output (not needed here)
    #f                          ;  thunk for getting one character (also not needed)
    (lambda () #f))             ;  thunk for closing port -- hmm should this go back to the previous?
   "w"))
(set-current-output-port snd-out)

There are also a few brief examples showing simple display customizations.
For example, the following makes the graph dot size dependent on the number
of samples in the graph:

  auto-dot snd chn y0 y1

(add-hook! graph-hook auto-dot)

There are also examples tying the channel graph sliders to the fft display.
Finally there are several somewhat frivolous examples:

  title-with-date
  show-bomb n speed
  flash-selected-data time-interval

(title-with-date) adds a clock to the Snd window's title bar. Set the
variable retitle-time to 0 to turn this off. show-bomb displays the animated
bomb icon; (show-bomb 20 200) for example. flash-selected-data cause the
selected channel's graph to flash red and green. And the there are functions
to display colored text in rxvt:

(display (format #f "~Athis is red!~Abut this is not" red-text normal-text))
(display (format #f "~A~Ahiho~Ahiho" yellow-bg red-fg normal-text))

It's possible to use the same escape sequences in a normal shell script, of
course:

echo '\e[41m This is red! \e[0m'

marks

marks.scm has most of the mark-related extensions. The three in examp.scm
are:

  first-mark-in-window-at-left
  mark-loops
  eval-between-marks func snd

(bind-key (char->integer #\l) 0
          (lambda ()
            (first-mark-in-window-at-left)))

(bind-key (char->integer #\m) 0
          (lambda ()
            (prompt-in-minibuffer "mark eval:" eval-between-marks)))

first-mark-in-window-at-left moves the (time domain) graph so that the
leftmost visible mark is at the left edge; mark-loops places marks at any
loop points found in the selected sound's header. Only a few headers support
loop points (these are apparently used in synthesizers to mark portions of a
waveform that can be looped without causing clicks, thereby lengthening a
sound as a key is held down). eval-between-marks evaluates func between the
leftmost marks in snd.

selections

  selection-members
  all-chans
  delete-selection-and-smooth
  eval-over-selection func snd
  swap-selection-channels
  selection-rms-1
  selection-rms
  region-rms-1 region
  region-rms region

selection-members returns a list of lists of (snd chn) indicating the
channels participating in the current selection. It is very similar to
all-chans which returns a list of lists of all (snd chn)'s.
delete-selection-and-smooth deletes the current selection and smooths the
splice. swap-selection-channels swaps the currently selected data's
channels. The various rms functions return the rms value of the desired data
in a variety of ways. The fastest and simplest uses CLM's dot-product
function:

(define (region-rms n)
  "(region-rms n) -> rms of region n's data (chan 0)"
  (if (region? n)
      (let* ((data (region-samples->vct 0 0 n)))
        (sqrt (/ (dot-product data data) (vct-length data))))
      (throw 'no-such-region (list "region-rms" n))))

eval-over-selection evaluates func on each sample in the current selection.
The code:

(bind-key (char->integer #\x) 0
          (lambda ()
            (if (selection?)
                (prompt-in-minibuffer "selection eval:" eval-over-selection)
                (report-in-minibuffer "no selection"))))

binds the character 'x' to a function that checks for an active selection,
then prompts (in the minibuffer) for the function to apply, and when the
user eventually replies with a function, applies that function to each
sample in the selection.

mixes

mix.scm has mix and track related functions.

  normalized-mix filename beg in-chan snd chn
  pan-mono-mix-to-stereo panning-envelope)
  place mono-snd stereo-snd degree
  place1 mono-snd stereo-snd degree
  enveloped-mix filename beg env
  enveloped-mix-1 filename beg env

normalized-mix is like mix but the mixed result has same peak amplitude as
the original data. enveloped-mix is like mix-sound, but includes an
amplitude envelope over the mixed-in data.

(enveloped-mix "pistol.snd" 0 '(0 0 1 1 2 0))

The place and place1 functions have the same effect as using CLM's locate
generator; they mix a mono sound into a stereo sound, splitting it into two
copies whose amplitudes depend on the desired degree. 0 degrees: all in
channel 0, 90: all in channel 1. A slightly more complex function along the
same lines is pan-mono-mix-to-stereo which replaces the degree argument with
an envelope.

sound effects

Most of these sound effects are based on CLM generators.

  echo scaler secs
  echoes scaler secs decay-time
  zecho scaler secs frq amp      ; modulated echo
  flecho scaler secs             ; filtered echo
  ring-mod freq gliss-env        ; ring-modulation
  am freq                        ; amplitude modulation
  hello-dentist frq amp          ; randomized sampling rate changes
  fp sr osamp osfrq              ; osc-driven src ("Forbidden Planet")
  compand
  expsrc rate snd chn
  expsnd rate-envelope
  cross-synthesis cross-snd amp fftsize radius
  voiced->unvoiced amp fftsize r tempo
  cnvtest snd0 snd1 amp
  jc-reverb decay-dur low-pass volume amp-env
  freqdiv n
  adsat size
  spike
  fancier locsig

expsrc uses sampling rate conversion (the src gen) and granular synthesis
(granulate) to lengthen or shorten a sound without changing its pitch. The
same idea is used in the effects menu. expsnd is the same but the change
follows an envelope. In cross-synthesis, cross-snd is the index of the sound
that controls the spectra, not the affected sound. voiced->unvoiced is
essentially the same idea, but drives the synthesis with white noise.
cnvtest demonstrates convolution. jc-reverb is an old Mus10 reverberator
written originally by John Chowning; see jcrev.ins in CLM. freqdiv
implements "frequency division", taken from an effects package of
sed_sed@my-dejanews.com. Also from that package is adsat, "adaptive
saturation". spike performs a product of samples (as opposed to the more
common sum); that is, it multiplies together several successive samples,
causing a more spikey output. Here are some sample calls:

(map-chan (echo .5 .5) 0 44100)
(echoes .5 .75 2.0)
(map-chan (zecho .5 .75 6 10.0) 0 65000)
(map-chan (flecho .5 .9) 0 75000)
(map-chan (ring-mod 100 '(0 0 1 0)))
(map-chan (ring-mod 10 (list 0 0 1 (hz->radians 100))))
(map-chan (am 440))
(hello-dentist 40.0 .1)
(fp 1.0 .3 20)
(map-chan (compand))
(expsnd '(0 1 2 .4))
(expsnd '(0 .5 2 2.0))
(map-chan (cross-synthesis 1 .5 128 6.0))
(voiced->unvoiced 1.0 256 2.0 2.0)
(cnvtest 0 1 .1)
(jc-reverb 2.0 #f .1 #f)
(freqdiv 8)

There are lots more sound effects scattered around the Snd distribution. The
"fancier locsig", to quote Michael Edwards "avoids the 'hole in the middle'
problem that occurs when trying to centre a signal in the middle of two
speakers"; it is based on CLM's panning.lsp.

synthesis

The synthesis examples are taken primarily from CLM:

  scissor begin-time
  fm-violin ...many args...
  fofins ...many args...
  pluck start dur freq amp weighting lossfact
  voxbeg dur freq amp ampfun freqfun freqscl voxfun index vibscl
  compute-uniform-circular-string size x0 x1 x2 mass xspring damp
  compute-stringsize x0 x1 x2 masses xsprings esprings damps haptics

scissor synthesizes the squawk of the scissor-tailed flycatcher (state bird
of Oklahoma); see bird.scm for more birds. The fm-violin is discussed in
v.scm. fofins is an implementation of FOF synthesis, taken originally from
fof.c of Perry Cook and the article "Synthesis of the Singing Voice" by
Bennett and Rodet in "Current Directions in Computer Music Research" (MIT
Press). pluck is based on the Karplus-Strong algorithm as extended by David
Jaffe and Julius Smith -- see Jaffe and Smith, "Extensions of the
Karplus-Strong Plucked-String Algorithm" CMJ vol 7 no 2 Summer 1983,
reprinted in "The Music Machine". vox is a translations of Marc LeBrun's
MUS10 waveshaping voice instrument using FM in this case. The waveshaping
version can be found in pqwvox.scm. compute-uniform-circular-string and
compute-string implement scanned synthesis of Bill Verplank and Max Mathews.
To watch the wave, open some sound (so Snd has some place to put the graph),
turn off the time domain display (to give our graph all the window) then
(testunif 1.0 0.1 0.0) or whatever.

miscellaneous extensions

  finfo filename
  shell cmd
  mpg rawfile chans

finfo returns a description of the file filename. shell is similar to
Guile's system function, but output is sent to Snd's listener, rather than
stdout. mpg uses the system function to call the program mpg123 to translate
an MPEG format sound file to a headerless ("raw") file containing 16-bit
samples.

(shell "df")
(add-hook! close-hook (lambda (snd) (shell \"sndplay wood16.wav\")))
(mpg "mpeg.mpg" "mpeg.raw" 1)

Several of the functions in this section are slight robustifications of the
corresponding code in extsnd.html. These include:

  do-chans func origin
  do-all-chans func origin
  do-sound-chans func origin
  update-graphs
  every-sample? func
  sort-samples bins
  window-samples snd chn
  display-energy snd chn y0 y1
  window-rms
  unsaved-edits? ind
  no-startup-file> ind file
  fft-peak snd chn scale

do-chans applies func to all syncd channels using origin as the edit history
indication. do-all-chans is the same but applies func to all active
channels. do-sound-chans applies func to all selected channels.
update-graphs updates (redraws) all graphs. every-sample? applies func to
each sample in the current channel and returns #t if func is not #f for all
samples; otherwise it moves the cursor to the first offending sample.
sort-samples provides a histogram of the samples (by amplitude) in bins
bins. window-samples returns (via the function samples) the samples
displayed in the current window for snd's channel chn. display-energy is a
graph-hook function to display the time domain data squared. window-rms
returns the rms of the data in currently selected graph window.
unsaved-edits? is an exit-hook function that returns #t if there are any
open sounds with unsaved edits. no-startup-file> is a start-hook function
that causes Snd to exit immediately if a file is specified on Snd's
invocation line, but that file doesn't exist. fft-peak is an fft-hook
function that returns the peak spectral magnitude.

  vct args

vct returns a vct object preloaded with args; it is equivalent to list->vct.

:(vct 1 2 3)
#<vct 1.000 2.000 3.000>

  locate-zero limit
  map-sound-files func &optional dir
  match-sound-files func &optional dir

locate-zero looks for the next sample where adjacent samples together are
less than limit and moves the cursor to that sample. It can be interrupted
by C-g. map-sound-files applies func to each sound file in dir.
match-sound-files applies func to each sound file in dir and returns a list
of files for which func does not return #f.

(map-sound-files
  (lambda (n)
    (if (> (mus-sound-duration n) 10.0)
      (snd-print n))))

(let ((reg (make-regexp ".wav|.snd$")))
  (match-sound-files
    (lambda (file)
       (regexp-exec reg file))))

The argument to make-regexp is looking for *.wav and *.snd.

  make-sound-interp start &optional snd chn
  sound-interp reader loc
  env-sound-interp envelope &optional (time-scale 1.0) snd chn)

make-sound-interp returns an interpolating reader for snd's channel chn. The
"interpolating reader" reads a channel at an arbitary location,
interpolating between samples if necessary. The corresponding "generator" is
sound-interp. The function test-interp shows one way to use this, using a
sine wave to lookup the current sound. env-sound-interp reads snd's channel
chn (via a sound-interp generator) according to envelope and time-scale. It
takes an envelope that goes between 0 and 1 (y-axis), and a time-scaler (1.0
= original length) and returns a new version of the data in the specified
channel that follows that envelope (that is, when the envelope is 0 we get
sample 0, when the envelope is 1 we get the last sample, envelope = .5 we
get the middle sample of the sound and so on). (env-sound-interp '(0 0 1 1))
returns a copy of the current sound; (env-sound-interp '(0 0 1 1 2 0) 2.0)
returns a new sound with the sound copied first in normal order, then
reversed. src-sound with an envelope could be used for this effect, but it
is much more direct to apply the envelope to sound sample positions.

fmv.scm

fmv.scm implements the fm-violin (v.scm) as a CLM-style generator, making it
possible to call the violin anywhere a generator could be called; since each
call on the fm-violin function produces the next sample of the given violin,
this form of the fm-violin is easy to call in "real-time" situations (see
snd-gtk.scm). Any other CLM-style instrument could be rewritten in the same
form.

  make-fm-violin
    frequency amplitude #:key (fm-index 1.0) (amp-env #f) (periodic-vibrato-rate 5.0) (random-vibrato-rate 16.0)
    (periodic-vibrato-amplitude 0.0025) (random-vibrato-amplitude 0.005) (noise-amount 0.0) (noise-freq 1000.0)
    (ind-noise-freq 10.0) (ind-noise-amount 0.0) (amp-noise-freq 20.0) (amp-noise-amount 0.0) (gliss-env #f)
    (fm1-env #f) (fm2-env #f) (fm3-env #f) (fm1-rat 1.0) (fm2-rat 3.0) (fm3-rat 4.0) (fm1-index #f) (fm2-index #f)
    (fm3-index #f) (base 1.0) #:allow-other-keys)

  fm-violin gen
  fm-violin-ins [same args as original violin in v.scm]

fm-violin-ins shows how this generator can be fitted into the original
fm-violin code. The make-fm-violin function uses the optional arguments
support from Guile (optargs.scm, loaded via (use-modules (ice-9 optargs))).
The plethora of arguments is an historical artifact; normally only a few of
them are used at a time. There are two examples of calling this generator in
fmv.scm, the simpler one being:

(define test-v
  (lambda (beg dur freq amp amp-env)
    (let ((v (make-fm-violin
              freq amp
              :amp-env (let ((e (make-env :envelope (or amp-env '(0 0 1 1 2 0))
                                          :scaler amp
                                          :end dur)))
                         (lambda () (env e)))))
          (data (samples->vct beg dur)))
      (do ((i 0 (1+ i)))
          ((= i dur))
        (vct-set! data i (+ (vct-ref data i)
                            (fm-violin v))))
      (set-samples beg dur data))))

Here we are setting up an fm-violin generator (via make-fm-violin), then
calling it dur times, mixing its output into the current data (this could
also use mix-vct and so on). The generator is called via (fm-violin v). As
can be seen here, each envelope is treated as a function called on each
sample very much like the "as-needed" input in src or granulate; the
envelopes could actually be any arbitrary function you like (see test-v1 in
fmv.scm which uses an oscillator as one of the fm index envelopes). One
complication in some "real-time" situations is that you don't know in
advance how long a note will be; in this case, the envelope generating
functions should have attack and decay ramps, triggered by note-on and
note-off; once the ramp has reached its end point, the end value should be
held; the note itself should be called until it has had time to ramp off; an
exercise for the interested reader.

glfft.scm

  start-gl
  stop-gl
  cleanup-gl

glfft.scm and glfft.c implement a way for Snd to display spectra using
OpenGL. Due to the way Mesa (the open source OpenGL) connects with the X
server, I decided not to try to imbed this in Snd itself. Snd and glfft
communicate through shared files, one being a "lock" file and the other
containing the data to be displayed. Snd writes "glfft.data", then
"glfft.lock". glfft (the reader) waits until it sees glfft.lock, then reads
glfft.data and deletes both files. If Snd has data ready to go but sees
glfft.lock, it does not try to write glfft.data (it assumes glfft is reading
the previous version). The OpenGL code in glfft.c is very primitive; someday
I'll learn about OpenGL, or even better some OpenGL expert will take a look
at it! To use this code, build glfft.c, invoke glfft, go to Snd, set up a
spectrogram, and (start-gl). (stop-gl) turns it off. (cleanup-gl) calls
stop-gl and then removes the glfft communication files.

gm.scm

gm.scm provides a simple way to get gmeteor to run in Snd. See Snd with
gmeteor for details.

goopsnd.scm

goopsnd.scm goofs around with goops, the Guile Object System. As it stands,
it might provide simple examples of goops syntax, but I'm not sure it's of
any value yet. There are days when it seems to me that there must be
something neat we could do here. (Currently this file is broken -- something
changed in goops, and my old code no longer works).

index.scm

  *html-reader* "netscape"
  html obj
  ? obj

index.scm provides a connection between an HTML reader (default: netscape,
determined by the value of *html-reader*) and the Snd documentation. The
index itself is built by index.cl, then accessed through the html and ?
functions. (html arg) where arg can be a string, symbol, or procedure looks
for a corresponding url in the various Snd documents, and if one is found,
calls *html-reader* with it. (? obj) prints out any help it can find for
obj, and tries to find obj in the documentation. The function that actually
passes the url to the reader is send-netscape defined in snd-gxutils.c.
Since it uses X window properties specific to netscape, it's not obvious how
any other HTML reader can work. All the following forms are acceptable:

  (html "open-sound")
  (html 'open-sound)
  (html open-sound)

loop.scm

loop.scm implements (at least partially) some Common Lisp syntax in Scheme
using Scheme's define-syntax. For example, prog1 in Scheme is:

(define-syntax prog1
  (syntax-rules ()
    ((prog1 <form1>) <form1>)
    ((prog1 <form1> <form2> ...)
     (let ((_result_ <form1>)) <form2> ... _result_))
    ))

This code says that (prog1 <form>) should be expanded as <form>, and that
anything more complicated should save the value of the first form, returning
it at the end. There's nothing special (in Scheme) about the "< >" business,
and probably a better way to specify the "_result_". The "..." is Scheme's
"and so on" marker within these syntax patterns. loop.scm has a first stab
at loop, and implementations of dotimes, progn, and prog1. Any additions are
welcome!

:(define hi (prog1 (+ 1 2) (abs -1) "hi"))
#<unspecified>
:hi
3
:(loop for i from 0 to 2 do (snd-print i))
0
1
2
#f

marks.scm

marks.scm is a collection of mark-related functions.

  mark-name->id name
  describe-mark id
  syncup ids
  fit-selection-between-marks m1 m2
  pad-marks ids secs
  move-syncd-marks sync samples-to-move
  play-syncd-marks sync

mark-name->id is like find-mark but searches all currently accessible
channels. describe-mark returns a description of the movements of mark id
over the channel's edit history:

:(describe-mark 0)
((mark 0 sound 0 "oboe.snd" channel 0) 654 478)

Here I placed a mark in oboe.snd at sample 654, then deleted a few samples
before it, causing it to move to sample 478. pad-marks inserts secs seconds
of silence before each in a list of marks (ids). fit-selection-between-marks
tries to squeeze the current selection between two marks, using the
granulate generator to fix up the selection duration (this still is not
perfect). syncup synchronizes a list of marks by inserting silences as
needed. move-syncd-marks moves any marks sharing the sync value sync by
samples-to-move samples. Similarly, play-syncd-marks starts playing from all
marks sharing its sync argument.

marks.scm also has code that tries to make it simpler to sync marks together
(see start-sync and stop-sync), and report-mark-names that causes any named
mark to display its name in the minibuffer when the underlying sample
happens to be played. There are also many mark-related functions in
examp.scm and scattered around the documentation.

mix.scm

mix.scm provides various mix-related utilities, including support for
"tracks". The latter were originally called groups in Snd, with their own
elaborate dialog and what-not. That was jettisoned soon after it was
written. The next thing to go were the "mix consoles" -- originally each mix
encapsulated the current Mix Panel in a little (but incredibly complicated)
widget set that followed the mix around in the time domain graph. This was
too hard to implement in Gtk+, and too hard to use in any case. The current
version has only the "tag" to drag a mix around, the Mix Panel to set mix
amplitudes and so on, and a bunch of hooks. These hooks are used in mix.scm
to implement one view of "tracks", which I assume are groups of related
mixes (I've actually never looked at a "real" sound editor to find out what
all the fuss is about).

  mix-name->id name
  mix->vct id
  pan-mix file frame env

These are the mix utilities in mix.scm (unrelated to tracks). mix-name->id
returns the id of a given (named) mix. mix->vct returns the current samples
of mix id (taking into account its current amplitude an so on). pan-mix
mixes file into the current (stereo) sound starting at frame using the
envelope env to pan the mixed samples (0: all chan 0, 1: all chan 1).

                            [picture of panning]

  make-track id mixes
  track id
  track->vct track
  save-track track filename

  track-color track
  set-track-color track color
  set-track-amp track amp
  incf-track-amp track amp-increment
  set-track-speed track speed
  transpose-track track semitones
  track-position track
  set-track-position track position
  track-end track
  track-length track
  set-track-tempo track tempo
  set-track-amp-env track chan env

  filter-track track coeffs

A track is a list of mixes, each member mix having its track set to the
track id. The make-track function takes the track id and the list of member
mixes, returning the list of mixes. Thereafter, the track function returns
the mix list given the track id. The rest of the track functions take the
track mix list as their initial argument. track->vct places all the mix
samples in the track into a vct object. Similarly, save-track places the
track's samples into a file.

The track-color refers to the color of the mix waveform (the thing displayed
to the right of the red tag). set-track-color sets this color using Snd
colors.


:(define hi (make-track 1 (list 0 1)))
#<unspecified>
:(track 1)
(0 1)
:(mix-track 0)
1
:(set-track-color (track 1) (make-color 0 0 1))
(#<color: (0.00 0.00 1.00)> #<color: (0.00 0.00 1.00)>)

The track-position is the position (begin sample) of the first mix in the
track. set-track-position moves all the mixes in the track so that its first
sample is position:

:(track-position (track 1))
10748
:(mix-position 0)
10748
:(mix-position 1)
23287
:(set-track-position (track 1) 1500)
(1500 14039)
:(mix-position 0)
1500
:(mix-position 1)
14039

The track-amp reflects the mix amps (unless you set them individually, but I
guess that quibble is true of all these settings). set-track-amp sets each
mix channel's chan amplitude to amp. Similarly, incf-track-amp increments
each amplitude by amp-increment. The track-speed refers to its mix's speeds:
set-track-speed sets all of them to speed, and transpose-track moves them
all by semitones. track-length returns the total duration (samples) of the
track, track-end returns the last sample:

:(track-length (track 1))
16346
:(- (+ (mix-position 1) (mix-length 1)) (mix-position 0))
16346
:(track-end (track 1))
17846
:(max (+ (mix-position 0) (mix-length 0)) (+ (mix-position 1) (mix-length 1)))
17846

set-track-tempo affects the time between the successive mix begin points
(tempo > 1.0 makes the mixes happen more quickly):

:(set-track-tempo (track 1) 2.0)
(1500 7770)
:(mix-position 0)
1500
:(mix-position 1)
7770
:(+ 1500 (* .5 (- 14039 1500))) ; 14039 is the former mix 1 begin time (see above)
7769.5

set-track-amp-env applies an amplitude envelope over the entire track,
setting each mix's amp env(s) to match the portion of that envelope that
happens to fall over them (multiplying envelopes if the mix aready has one).
filter-track applies a filter to each mix sound at the pre-mix point (that
is, the mixed in sound is being edited, then the mix takes place); any kind
of edit can follow the same sequence.

Finally, the various mix hooks can be tied into these functions so that (for
example) the entire track moves when you drag one mix in it, or all the
amplitudes change at once. sync-multichannel-mixes causes multichannel mixes
to be syncd together automatically (this is normally what people expect).

moog.scm

  make-moog-filter frequency Q
  moog-filter gen input

moog.scm is a translation of CLM's moog.lisp (written by Fernando
Lopez-Lezcano -- http://www-ccrma.stanford.edu/~nando/clm/moog), itself a
translation of Tim Stilson's original C code. The functions provide a kind
of CLM generator view of the filter. Fernando describes it as a "Moog style
four pole lowpass (24db/Oct) filter clm unit generator, variable resonance,
warm, analog sound ;-)". In make-moog-filter "frequency" is the cutoff
frequency in Hz (more or less) and "Q" is the resonance: 0 = no resonance, 1
causes the filter to oscillate at frequency. My translation is a bit
simple-minded; with a little effort, this could run much faster.

  (define (moog freq Q)
    (let ((gen (make-moog-filter freq Q)))
      (lambda (inval)
        (moog-filter gen inval))))

  (map-chan (moog 1200.0 .7))

pqwvox.scm

  pqw-vox beg dur freq spacing-freq amp ampfun freqfun freqscl phonemes formant-amps formant-shapes

pqwvox ("phase-quadrature waveshaping voice") was originally written by Marc
LeBrun in the late 70's using waveshaping. It was changed to use FM for the
Samson Box since the box had trouble performing waveshaping, then changed
back to waveshaping in this version. The basic idea is that each of the
three vocal formants is created by two sets of waveshapers, one centered on
the even multiple of the base frequency closest to the desired formant
frequency, and the other on the nearest odd multiple. As the base frequency
moves (vibrato, glissando), these center frequencies are recalculated (one
each sample), and the respective amplitudes set from the distance to the
desired frequency. If a center frequency moves (for example, the base
frequency moves down far enough that the previous upper member of the pair
has to become the lower member), the upper waveshaper (which has ramped to
zero amplitude), jumps down to its new center. The formant table was
provided by Robert Poor. The "phase-quadrature" part of the business creates
single side-band spectra. For details on waveshaping, see Le Brun, "Digital
Waveshaping Synthesis", JAES 1979 April, vol 27, no 4, p250. It might be
simpler to set up three formant generators and drive them with the
waveshapers, but the "leap-frog" idea was a neat hack -- such things are
worth keeping even when they aren't all that sensible anymore. (Also, I
noticed while writing this paragraph that the single-sideband cancellation
is not working as I expected -- another bug to track down...)

prc95.scm

prc95.scm is a translation to Snd of Perry Cook's (1995) physical modelling
toolkit; prc-toolkit95.lisp in CLM. One starting point for physical
modelling is Smith, "Music Applications of Digital Waveguides", CCRMA,
Stan-M-39, 1987, or Julius's home page, or any of several classic papers
also by Julius Smith. Perry's own version of this code can be found in STK;
there's also apparently a csound version somewhere. Perry uses slightly
different versions of delay lines and so on, but much (perhaps all) of this
could be done using "vanilla" CLM generators. The generators defined here
are reedtable, bowtable, jettable, onezero, onepole, biquad (biquad filter),
lip, dcblock, and two kinds of interpolating delay line: delaya and delayl
(which I think differ in the interpolation technique -- linear and
all-pass?).

  make-reed #;key (offset 0.6) (slope -0.8)
  reedtable r sample
  make-bowt #:key (offset 0.0) (slope 1.0)
  bowtable b sample
  jettable sample
  make-onez #:key (gain 0.5) (zerocoeff 1.0) (input 0.0)
  onezero b sample
  make-onep #:key (polecoeff 0.9) (gain 1.0) (sgain 0.1) (output 0.0)
  onepole p sample
  make-biq
  biquad b sample
  make-dcb #:key (input 0.0) (output 0.0)
  dcblock b sample
  make-delaya len
  delaya d sample
  make-delayl len
  delayl d sample
  lip b mouthsample boresample

The example instruments are:

  plucky beg dur freq amplitude maxa
  bow beg dur frq amplitude maxa
  brass beg dur freq amplitude maxa
  clarinet beg dur freq amplitude maxa
  flute beg dur freq amplitude maxa

(define (test-prc95)
  (plucky 0 .3 440 .2 1.0)
  (bow .5 .3 220 .2 1.0)
  (brass 1 .3 440 .2 1.0)
  (clarinet 1.5 .3 440 .2 1.0)
  (flute 2 .3 440 .2 1.0))

pvoc.scm

This is the same as the CLM phase-vocoder generator, but implemented in
Scheme. If you're interested in how the thing works, I think the Scheme
version is easiest to understand; the Common Lisp version is in mus.lisp,
and the C version is in clm.c.

  make-pvocoder fftsize overlap interp analyze edit synthesize
  pvocoder gen input

The analyze, edit, and synthesize arguments to make-pvocoder are functions
that are applied as needed during pvocoder processing; similarly, the input
argument to pvocoder can be a function. pvoc.scm also contains a few
examples of using the CLM phase-vocoder generator. For example:

(define test-pv-4
  (lambda (gate)
    (let ((pv (make-phase-vocoder #f
                                  512 4 128 1.0
                                  #f ;no change to analysis
                                  (lambda (v)
                                    (let ((N (mus-length v)))
                                      (do ((i 0 (1+ i)))
                                          ((= i N))
                                        (if (< (pv-ampinc v i) gate)
                                            (set-pv-ampinc v i 0.0)))
                                      #t))
                                  #f ;no change to synthesis))
          (reader (make-sample-reader 0)))
      (map-chan (lambda (val)
                  (phase-vocoder pv (lambda (dir)
                                      (next-sample reader)))))
      (free-sample-reader reader))))

sets up a phase-vocoder generator whose edit function is squelching soft
partials. In this case, the input function is reading the currently selected
channel. The fastest way to try out this generator is to use it as the
argument to filter-sound. I can't think of good names for the internal
arrays (such as pv-ampinc above).

rgb.scm

rgb.scm is a simple translation of the standard X11 color names into Snd
color objects.

(define snow (make-color 1.00 0.98 0.98))

is taken from the line

255 250 250             snow

/usr/lib/X11/rgb.txt. The choice of a float between 0.0 and 1.0 (rather than
an integer between 0 and 255) mimics PostScript; as video hardware has
improved over the years, there's less and less need for these elaborate
color names, and less reason to limit these numbers to bytes.

rtio.scm

rtio.scm has a collection of functions oriented loosely around "real-time"
operations.

  show-input &optional (in-sys 0)
  show-input-fft &optional (in-sys 0)
  in-out func in-sys out-sys

These three functions show how to read incoming data (from the adc), write
data (to the dac), and interpose a function while reading and writing data.
show-input-fft displays the input data's spectrum.

rubber.scm

  rubber-sound stretch-factor

rubber-sound tries to stretch or contract a sound (in time); it scans the
sound looking for stable (periodic) sections, then either deletes periods or
interpolates new ones to shorten or lengthen the sound. It still needs a lot
of robustification. The algorithm is 1) remove all frequencies below 16 Hz,
2) resample the file to be ten times longer (interpolating samples), 3) make
a list of upward zero crossings, 4) using autocorrelation decide where the
next fundamental zero crossing probably is and see how much difference there
is between the current period and the next, 5) check intermediate crossing
weights and if the autocorrelation weight is not the smallest, throw away
this crossing, 6) sort the remaining crossings by least weight, 7)
interpolate or delete periods until the sound has been sufficiently
lengthened or shortened.

snd-gtk.scm

  make-amp-dialog
  make-control-dialog
  make-fmv-dialog
  make-amp-controls

These functions are examples of using Guile-Gtk in Snd. First you need to
build Snd with Gtk and Guile-gtk loaded. make-amp-dialog creates a dialog
with an amplitude control on playback and a play button, providing a simple
example of "real-time" controls in Snd.

                         make-control-dialog creates a dialog that controls
                         all the "hidden" control-panel variables. The
"expand-hop" control sets the hop size (per grain), "expand-length" sets the
grain length, "expand-ramp" sets the slope, essentially, of the grain
amplitude envelope, "contrast-amp" sets the prescaler for the contrast
effect, "reverb-feedback" sets the feedback amount in the reverberator (it
sets all the comb filter scalers), and "reverb-lowpass" sets the lowpass
filter coefficient in the reverberator. (make-control-dialog) adds the
"control" option to the Options menu.

make-fmv-dialog is based on the version of the fm-violin in fmv.scm; it
provides a dialog to control the violin's amplitude. Since the entire path
is interpreted here (Guile does not yet have a compiler), this is asking a
lot even of a fast machine. make-amp-controls provides a slider controlling
each channel's amplitude; this is an extension of the built-in control panel
where each control affects all channels at once.

snd-test.scm

snd-test.scm is a large test suite for Snd. The simplest use is:

snd -l snd-test

which will run all the tests, assuming you have the various sound files it
is expecting to find. I assume that for most users snd-test.scm will provide
more of a set of examples than anything directly useful.

v.scm

The fm violin was my favorite instrument while working in the 70's and 80's,
primarily on the Samson box. It was developed in Mus10 (ca 1977) based on
ideas of John Chowning; a Mus10 version was (in this code ":=" is used in
place of the original SAIL left arrow character, and so on):

ARRAY GlissFunc, DecayFunc, AttackFunc, SineWave, AmpFunc(512);
SYNTH(Sinewave); 1,1 999;
SEG(AmpFunc); 0,0 1,25 1,50 0,75 0,100;
SEG(GlissFunc);0,1 1,50, 0,100;
SEG(AttackFunc);0,0 1,100;
SEG(DecayFunc);1,1 .6,5 .3,10 .15,25 .07,50 0,100;

INSTRUMENT VN1;
VARIABLE Reset1,Noise,/NewMag,OtherFreq,/Gliss,Distance,Stereo,
        Freq,Amp1,Amp2,Duration,AttackTime,DecayTime,Memory1,
        Index1,Index2,Index3,scFreq,DecayLength,Switch1,Switch2,
        /Mod1,/Mod2,/Mod3,/Env,/Att,/Vibrato,IMult,/Snd,
        /Flutter,VibRate,VibAmp,/Ramp,/Decay,VibSwitch,LogFreq,
        GlissLength,Bowing,DecayCall,VibCall,GlissCall,RampCall;

Memory1:=1;

I_ONLY BEGIN
  Duration:=P2;
  Freq:=P3;
  Amp1:=P4;
  Amp2:=P5;
  OtherFreq:=P6;
  IF Freq>=C THEN Freq:=Freq+Freq/100;
  IF Freq<C THEN Freq:=Freq-20/Freq;

  Switch1:=P14;
  Switch2:=1-Switch1;
  IMult:=P7-(Switch2/4);
  VibSwitch:=P8;
  Bowing:=P9;

  Distance:=P10;
  Stereo:=P11;
  Noise:=P12;
  GlissLength:=P13;
  LogFreq:=ALOG(Freq);

  DecayCall:=VibCall:=RampCall:=GlissCall:=20;
  IF Amp1=Amp2 THEN RampCall:=SRATE;
  IF Freq=OtherFreq THEN GlissCall:=SRATE;
  IF VibSwitch=0 THEN VibCall:=SRATE;
  IF Switch1=1 THEN DecayCall:=SRATE;

  Vibrate:=5.25+RAND*.75;
  VibAmp:=.006+RAND*.001;

  IF Bowing=0
    THEN
      IF Memory1>.08
        THEN
          BEGIN
          DecayTime:=.7;
          AttackTime:=.2;
          END
        ELSE
          BEGIN
          DecayTime:=.7;
          AttackTime:=.05;
          Noise:=0;
          END
    ELSE
      IF Memory1>.05
        THEN
          BEGIN
          DecayTime:=.05;
          AttackTime:=.2;
          END
        ELSE
          BEGIN
          DecayTime:=.05;
          AttackTime:=.05;
          Noise:=0;
          END;

  Memory1:=DecayTime;

  IF AttackTime+DecayTime>=Duration
    THEN
      BEGIN
      AttackTime:=Duration*AttackTime;
      DecayTime:=DecayTime*Duration;
      IF AttackTime<=.05 THEN AttackTime:=Duration-DecayTime-.01;
      END;

  ScFreq:=Freq*MAG;
  DecayLength:=1000/Freq;
  IF Switch1=0 THEN Noise:=.1;
  Index1:=7.5*IMult/LogFreq;
  Index2:=5/SQRT(Freq);
  Index3:=IMult*30*(8.5-LogFreq)/Freq;
END;

Decay:=Switch1+EXPEN[DecayCall](Switch2,MAG*20/DecayLength,DecayFunc);
ENV:=Switch2+LINEN[20](Switch1,AttackTime/20,DecayTime/20,Duration/20,AmpFunc,Reset1:=0);
Ramp:=Amp1+NOSCIL[RampCall](Amp2-Amp1,20*MAG/Duration,AttackFunc);
Gliss:=Freq+EXPEN[GlissCall](OtherFreq-Freq,20*MAG/GlissLength,GlissFunc);
FLutter:=RANDI[VibCall](1,200*Mag);
Vibrato:=NOSCIL[VibCall](ENV,Vibrate*MAG*20,SineWave);
Att:=1-EXPEN[20](1,MAG*640,AttackFunc);

NewMag:=(1+Flutter*.005)*(1+Vibrato*VibAmp)*(1+RANDI(Noise*Att,2000*Mag))*Gliss*Mag;

Mod1:=NOSCIL(Decay*ScFreq*(Att+Index1),NewMag,Sinewave);
Mod2:=NOSCIL(Decay*ScFreq*(Att+Index2),4*NewMag,Sinewave);
Mod3:=NOSCIL(Decay*ScFreq*(Att+Index3),3*NewMag,Sinewave);
Snd:=ZOSCIL(Decay*ENV*Ramp,NewMag+Mod1+Mod2+Mod3,Sinewave);
OUTA:=OUTA+Snd*0.5;
END;

This instrument required about 60 seconds of computing on a PDP-10 (a
$250,000 minicomputer) for 1 second of sound (our normal sampling rate was
12800). Since the PDP was massively time-shared, 60 seconds of computing
could involve many minutes of sitting around watching AI scientists play
Space War. Mus10 was an extension of Music V for the PDP-10 family of
computers. To give a feel for how one worked in those days, here's a brief
quote from the Mus10 manual (by Tovar and Leland Smith, May 1977):

The following generates  1 second of a  440 Hz sine wave  followed by
1/2 sec. of a  660Hz sine wave. The output goes to a file, MUSIC.MSB,
which is written on DSKM.

COMMENT Fill array with sine wave;
ARRAY SINETABLE[511];
FOR I:=0 STEP 1 UNTIL 511 DO SINETABLE[I]:=SIN(2*PI/512);

INSTRUMENT SINE;
  COMMENT Generate simple sine wave.  P4 = Amplitude, P3 = frequency;
  OUTA:=OUTA+OSCIL(P4,P3*MAG,SINETABLE);
  END;

COMMENT Now, generate the sound;
PLAY ;
  SIMP 0, 1, 440, 1000;
  SIMP 1, 1/2, 660, 1000;
  FINISH;

The computation involved was considered so burdensome, that the names of the
main users were posted in the AI lab halls, apparently to try to get us to
go away. I was normally the primary user (in terms of computrons) for the
entire lab, and I had no intention of going away. In the Samson box world,
this (in its initial "chorus" version) was:

Instrument(Violin);
RECORD_POINTER(seg) nullfunc;
INTEGER ARRAY gens[1:4],indgens[1:6], GensA[1:4],AmpGens[1:2];
                                        ! synthesizer addresses;
REAL ARRAY ratsA[1:4],Indrats[1:6],ratsB[1:4],AmpRats[1:2];
                                        ! envelope data;
INTEGER ModGens1Sum,i,FuncOffSet,k,GenOutLoc,GenInLoc,ModGens2Sum,x1,x2;

Pars(<(InsName,Beg,Dur,Freq,Amp,Function AmpFunc,Function IndFunc,IndMult,
        SkewMult,Nothing,PcRev,No11,No12,No13,Function SkewFunc)>);
                                        ! the parameters of this instrument;

Dbugit(Pns);                            ! debugging aid;
GenOutLoc:=CASE (Pn[1] MOD 4) OF (Outma,Outmb,Outmc,Outmd);
                                        ! OUTMA is channel 1, OUTMB channel 2, etc;
if freq>srate/3 then return;            ! note too high, so leave it out;
x1:=3;                                  ! modulating frequency checks;
x2:=4;                                  ! (we want them less than srate/2);
If x1*freq>srate/2 Then x1:=1;
If x2*freq>srate/2 then x2:=1;
amp:=Amp/2;                             ! two carriers, so halve the amplitude;

waiter(Beg);                            ! wait for the beginning of the note;

indRats[1]:=(x1*Freq*IndMult*((8.5-log(freq))/(3+(freq/1000)))*4/srate) MIN .999;
indRats[2]:=(x2*Freq*IndMult*(1/(freq^.5))*4/srate) MIN .999;
indRats[3]:=(freq*IndMult*(5/log(freq))*4/srate) MIN .999;
indrats[4]:=indrats[1]; indrats[5]:=indrats[2]; indrats[6]:=indrats[3];

ratsA[1]:=x1; ratsA[2]:=x2;     ratsA[3]:=1;     ratsA[4]:=1;
ratsB[1]:=x1+.002; ratsB[2]:=x2+.003;     ratsB[3]:=1.002;     ratsB[4]:=1;
                                        ! this is the skewing for the chorus effect;
Gens[1]:=Osc(Pns,ModGens1Sum);          ! now set up the oscillators;
Gens[2]:=Osc(Pns,ModGens1Sum);
Gens[3]:=Osc(Pns,ModGens1Sum);
Gens[4]:=Osc(Pns,genInLoc,ModGens1Sum); ! carrier 1;

GensA[1]:=Osc(Pns,ModGens2Sum);
GensA[2]:=Osc(Pns,ModGens2Sum);
GensA[3]:=Osc(Pns,ModGens2Sum);
GensA[4]:=Osc(Pns,genInLoc,ModGens2Sum);! carrier 2;

indgens[1]:=gens[1];   indgens[2]:=gens[2];  indgens[3]:=gens[3];
indgens[4]:=gensA[1];   indgens[5]:=gensA[2];  indgens[6]:=gensA[3];
                                        ! set up envelope addressing;

ModSig(Pns,GenOutLoc,GenInLoc,1-pcRev); ! send signal to DACs;
ModSig(Pns,RevIn,GenInLoc,pcRev);       ! and signal to reverberator;

AmpGens[1]:=Gens[4]; AmpGens[2]:=GensA[4]; AmpRats[1]:=1; AmpRats[2]:=1;
                                        ! now add the envelopes;
AddArrEnv(Pns,AmpGens,2,"A",0,Amp/2,AmpFunc,AmpRats);
AddArrEnv(Pns,IndGens,6,"A",0,1,IndFunc,Indrats);
AddArrEnv(Pns,Gens,4,"F",freq,Freq*skewmult,skewfunc,ratsA,
        5,.011,.011,nullfunc,6,.017,.017,nullfunc,0,0);
AddArrEnv(Pns,GensA,4,"F",freq,Freq*skewmult,skewfunc,ratsA,
        6,.010,.010,nullfunc,5,.017,.017,nullfunc,1,0);
End!Instrument(Pns);                    ! deallocation;

The Sambox version eventually became incredibly complicated, mainly to try
to handle note list problems in the instrument. The Samson box could run
about 5 or 6 of these in "real-time", similar to a modern-day 500 MHz
Pentium running CLM. The parallel in the Sambox world to the SIMP example
above is (this is taken from SAMBOX.BIL, November 1984):

    Instrument(Simp);
    Integer Gen1;
    Gen1:=Osc(Pns,OutA,Zero,SineMode,0,0,Pn[3]);
    AddEnv(Pns,Gen1,"A",0,Pn[4],Pf[5]);
    End_Instrument(Pns);

The CLM version of this is:

(definstrument simp (start-time duration frequency amplitude
                      &optional (amp-env '(0 0 50 1 100 0)))
  (multiple-value-bind (beg end) (times->samples start-time duration)
    (let ((s (make-oscil :frequency frequency))
          (amp (make-env :envelope amp-env :scaler amplitude :duration duration)))
      (run
       (loop for i from beg below end do
         (outa i (* (env amp) (oscil s))))))))

In CLM, the fm-violin became (fm.html, 1989):

(definstrument violin (beg end frequency amplitude fm-index)
  (let* ((frq-scl (in-hz frequency))
         (maxdev (* frq-scl fm-index))
         (index1 (* maxdev (/ 5.0 (log frequency))))
         (index2 (* maxdev 3.0 (/ (- 8.5 (log frequency)) (+ 3.0 (/ frequency 1000)))))
         (index3 (* maxdev (/ 4.0 (sqrt frequency))))
         (carrier (make-oscil :frequency frequency))
         (fmosc1 (make-oscil :frequency frequency))
         (fmosc2 (make-oscil :frequency (* 3 frequency)))
         (fmosc3 (make-oscil :frequency (* 4 frequency)))
         (ampf  (make-env :envelope '(0 0 25 1 75 1 100 0) :scaler amplitude))
         (indf1 (make-env :envelope '(0 1 25 .4 75 .6 100 0) :scaler index1))
         (indf2 (make-env :envelope '(0 1 25 .4 75 .6 100 0) :scaler index2))
         (indf3 (make-env :envelope '(0 1 25 .4 75 .6 100 0) :scaler index3))
         (pervib (make-triangle-wave :frequency 5 :amplitude (* .0025 frq-scl)))
         (ranvib (make-randi :frequency 16 :amplitude (* .005 frq-scl)))
         (vib 0.0))
    (run
     (loop for i from beg to end do
       (setf vib (+ (triangle-wave pervib) (randi ranvib)))
       (outa i (* (env ampf)
                  (oscil carrier
                         (+ vib
                            (* (env indf1) (oscil fmosc1 vib))
                            (* (env indf2) (oscil fmosc2 (* 3.0 vib)))
                            (* (env indf3) (oscil fmosc3 (* 4.0 vib))))))))))))

or in its actual (non-simplified) form):

(defun bit20 (x)                        ;Samson box modifier got 2's complement 20 bit interpreted as fraction
  (if (>= x (expt 2 19))                ;(this needed to keep fm-violin backwards compatible with old note lists)
      (float (/ (- x (expt 2 20)) (expt 2 19)))
    (float (/ x (expt 2 19)))))

(defun make-frobber-function (beg end frobl)
  (let ((result (list beg))
        (val (bit20 (cadr frobl))))
    (loop for x in frobl by #'cddr and
              y in (cdr frobl) by #'cddr do
      (when (and (>= x beg)
                 (<= x end))
        (push val result)
        (push x result)
        (setf val (bit20 y))))
    (push val result)
    (push end result)
    (push val result)
    (nreverse result)))

(definstrument fm-violin
  (startime dur frequency amplitude &key
            (fm-index 1.0)
            (amp-env '(0 0  25 1  75 1  100 0))
            (periodic-vibrato-rate 5.0)
            (random-vibrato-rate 16.0)
            (periodic-vibrato-amplitude 0.0025)
            (random-vibrato-amplitude 0.005)
            (noise-amount 0.0) (noise-freq 1000.0)
            (ind-noise-freq 10.0) (ind-noise-amount 0.0)
            (amp-noise-freq 20.0) (amp-noise-amount 0.0)
            (gliss-env '(0 0  100 0)) (glissando-amount 0.0)
            (fm1-env '(0 1  25 .4  75 .6  100 0))
            (fm2-env '(0 1  25 .4  75 .6  100 0))
            (fm3-env '(0 1  25 .4  75 .6  100 0))
            (fm1-rat 1.0) (fm2-rat 3.0)  (fm3-rat 4.0)
            (fm1-index nil) (fm2-index nil) (fm3-index nil)
            (base nil) (frobber nil)
            (reverb-amount 0.01)
            (index-type :violin)
            (degree nil) (distance 1.0) (degrees nil)
            (no-waveshaping nil) (denoise nil)
            (denoise-dur .1) (denoise-amp .005)
            &allow-other-keys)
  (if (> (abs amplitude) 1.0)
      (setf amplitude (clm-cerror ".1?" .1 #'numberp "amplitude = ~A?" amplitude)))
  (if (<= (abs frequency) 1.0)
      (setf frequency (clm-cerror "440.0?" 440.0 #'numberp "frequency = ~A?" frequency)))
  (let* ((beg (floor (* startime *srate*)))
         (end (+ beg (floor (* dur *srate*))))
         (frq-scl (hz->radians frequency))
         (modulate (not (zerop fm-index)))
         (maxdev (* frq-scl fm-index))
         (vln (not (eq index-type :cello)))
         (logfreq (log frequency))
         (sqrtfreq (sqrt frequency))
         (index1 (or fm1-index (min pi (* maxdev (/ (if vln 5.0 7.5) logfreq)))))
         (index2 (or fm2-index (min pi (* maxdev 3.0 (if vln
                                                             (/ (- 8.5 logfreq) (+ 3.0 (* frequency .001)))
                                                           (/ 15.0 sqrtfreq))))))
         (index3 (or fm3-index (min pi (* maxdev (/ (if vln 4.0 8.0) sqrtfreq)))))

         (easy-case (and (not no-waveshaping)
                         (zerop noise-amount)
                         (eq fm1-env fm2-env)
                         (eq fm1-env fm3-env)
                         (zerop (- fm1-rat (floor fm1-rat)))
                         (zerop (- fm2-rat (floor fm2-rat)))
                         (zerop (- fm3-rat (floor fm3-rat)))
                         (zerop (nth-value 1 (floor fm2-rat fm1-rat)))
                         (zerop (nth-value 1 (floor fm3-rat fm1-rat)))))
         (coeffs (and easy-case modulate
                      (partials->polynomial
                       (list fm1-rat index1
                             (floor fm2-rat fm1-rat) index2
                             (floor fm3-rat fm1-rat) index3))))
         ;; that is, we're doing the polynomial evaluation using fm1osc running at fm1-rat * frequency
         ;; so everything in the polynomial table should be in terms of harmonics of fm1-rat

         (norm (or (and easy-case modulate 1.0) index1))

         (carrier (make-oscil frequency))
         (fmosc1  (and modulate (make-oscil (* fm1-rat frequency))))
         (fmosc2  (and modulate (or easy-case (make-oscil (* fm2-rat frequency)))))
         (fmosc3  (and modulate (or easy-case (make-oscil (* fm3-rat frequency)))))
         (ampf  (make-env
                  (if denoise
                       (reduce-amplitude-quantization-noise amp-env dur amplitude denoise-dur denoise-amp)
                     amp-env)
                  amplitude :base base :duration dur))
         (indf1 (and modulate (make-env fm1-env norm :duration dur)))
         (indf2 (and modulate (or easy-case (make-env fm2-env index2 :duration dur))))
         (indf3 (and modulate (or easy-case (make-env fm3-env index3 :duration dur))))
         (frqf (make-env gliss-env (* glissando-amount frq-scl) :duration dur))
         (pervib (make-triangle-wave periodic-vibrato-rate (* periodic-vibrato-amplitude frq-scl)))
         (ranvib (make-rand-interp random-vibrato-rate (* random-vibrato-amplitude frq-scl)))
         (fm-noi (if (and (/= 0.0 noise-amount)
                          (null frobber))
                     (make-rand noise-freq (* pi noise-amount))))
         (ind-noi (if (and (/= 0.0 ind-noise-amount) (/= 0.0 ind-noise-freq))
                      (make-rand-interp ind-noise-freq ind-noise-amount)))
         (amp-noi (if (and (/= 0.0 amp-noise-amount) (/= 0.0 amp-noise-freq))
                      (make-rand-interp amp-noise-freq amp-noise-amount)))
         (frb-env (if (and (/= 0.0 noise-amount) frobber)
                      (make-env (make-frobber-function startime (+ startime dur) frobber) :duration dur
                                :base 0 :scaler (* two-pi noise-amount))))
         (vib 0.0)
         (modulation 0.0)
         (loc (make-locsig :degree (or degree degrees (random 90.0)) :reverb reverb-amount :distance distance))
         (fuzz 0.0)
         (ind-fuzz 1.0)
         (amp-fuzz 1.0))
    (run
     (loop for i from beg to end do
       (if (/= 0.0 noise-amount)
           (if (null frobber)
               (setf fuzz (rand fm-noi))
             (setf fuzz (env frb-env))))
       (setf vib (+ (env frqf) (triangle-wave pervib) (rand-interp ranvib)))
       (if ind-noi (setf ind-fuzz (+ 1.0 (rand-interp ind-noi))))
       (if amp-noi (setf amp-fuzz (+ 1.0 (rand-interp amp-noi))))
       (if modulate
           (if easy-case
               (setf modulation
                 (* (env indf1)
                    (polynomial coeffs (oscil fmosc1 vib)))) ;(* vib fm1-rat)??
             (setf modulation
               (+ (* (env indf1) (oscil fmosc1 (+ (* fm1-rat vib) fuzz)))
                  (* (env indf2) (oscil fmosc2 (+ (* fm2-rat vib) fuzz)))
                  (* (env indf3) (oscil fmosc3 (+ (* fm3-rat vib) fuzz)))))))
       (locsig loc i
             (* (env ampf) amp-fuzz
                (oscil carrier (+ vib (* ind-fuzz modulation)))))))))

which is very similar to the Scheme version (v.scm). It's basically setting
up several parallel modulators of one carrier (see fm.html for details, or
(ah nostalgia...) Schottstaedt, "The Simulation of Natural Instrument Tones
Using Frequency Modulation with a Complex Modulating Wave", CMJ vol 1 no 4
1977 p46-50). The modulators themselves are modulated (vibrato, noise, etc).
The FM indices were chosen to try to mimic violin or cello sounds over a
wide range of frequencies. There's no limit on what this instrument can do;
nearly all my compositions in the 80's used it. In CLM, there's fmviolin.clm
which shows some of the effects (although it's unfortunately hard to read
due to the way the Sambox system worked). And I just found this out on the
net; I'm no csound expert, so I merely quote what I find:

;ORC
; edited by R. Pinkston, modified for use with MIDI2CS by R. Borrmann
;
;==========================================================================;
;                Schottstaedt FM String Instrument from Dodge              ;
;                                                                          ;
;p4 = amp p5 = pch p6 = rise p7 = dec p8 = vibdel p9 = vibwth p10 = vibrte ;
;==========================================================================;
;        sr      =       44100
;        kr      =       4410
;        ksmps   =       10
;        nchnls  =       1
;
;                instr   1

par
  p_maxamplitude 32000
  p_cps
endpar

        iamp    =       p4

        irise   = .2    ;p6
        idec    = .2    ;p7
        ivibdel = .75   ;p8
        ivibwth = .03   ;p9
        ivibrte = 5.5   ;p10

        ifc     =       p5
        ifm1    =       ifc
        ifm2    =       ifc*3
        ifm3    =       ifc*4
        indx1   =       7.5/log(ifc)    ;range from ca 2 to 1
        indx2   =       15/sqrt(ifc)    ;range from ca 2.6 to .5
        indx3   =       1.25/sqrt(ifc)  ;range from ca .2 to .038
        kvib    init    0

                timout  0,ivibdel,transient  ;delays vibrato for p8 seconds
        kvbctl  linen   1,.5,p3-ivibdel,.1   ;vibrato control envelope
        krnd    randi   .0075,15        ;random deviation in vib width
        kvib    oscili  kvbctl*ivibwth+krnd,ivibrte*kvbctl,1 ;vibrato generator

transient:
        timout  .2,p3,continue          ;execute for .2 secs only
        ktrans  linseg  1,.2,0,1,0      ;transient envelope
        anoise  randi   ktrans,.2*ifc   ;noise...
        attack  oscil   anoise,2000,1   ;...centered around 2kHz

continue:
        amod1   oscili  ifm1*(indx1+ktrans),ifm1,1
        amod2   oscili  ifm2*(indx2+ktrans),ifm2,1
        amod3   oscili  ifm3*(indx3+ktrans),ifm3,1
        asig    oscili  iamp,(ifc+amod1+amod2+amod3)*(1+kvib),1
        asig    linen   asig+attack,irise,p3,idec
;                out     asig
;
;                endin
        aright  = asig
        aleft   = asig

ws.scm

with-sound is the primary sound producing macro in CLM (in a sense, it is
CLM's user-interface). In Common Lisp it's defined as:

 (defmacro with-sound ((&key (srate 22050) ...) &body body)
   (unwind-protect
     (let (...) ,.body)
     (progn (cleanup...))))

and makes extensive use of Lisp's dynamic binding to handle nested
with-sound calls and so on. Optional argument syntax has changed slightly in
Guile; my first attempt to implement this macro (in Guile 1.4) was:

(defmacro with-sound (args . body)
  `((lambda* (#&key (srate 22050)
                    (output "test.snd")
                    (channels 1)
                    (explode #f))
      (let ((old-srate (mus-srate)))
        (dynamic-wind
         (lambda ()
           (set! (mus-srate) srate))
         (lambda ()
           (if (find-sound output)
               (close-sound (find-sound output)))
           (new-sound output (default-output-type) (default-output-format) srate channels)
           ,@body)
         (lambda ()
           (set! (mus-srate) old-srate)))))
    ,@args))

but in the newer Guile (1.4.1) it's possible to make this prettier (this
version is thanks to Kalle Olavi Niemitalo):

(define* (with-sound-helper thunk #&key (srate 22050) (explode #f))
  (let ((old-srate (mus-srate)))
    (dynamic-wind
      (lambda ()
        (set! (mus-srate) srate))
      thunk
      (lambda ()
        (set! (mus-srate) old-srate)))))

(defmacro with-sound (args . body)
  `(with-sound-helper (lambda () ,@body)
                      ,@args))

lambda* and define* are extensions of Scheme from Guile's ice-9/optargs.scm.
The version in ws.scm is simply an amplification of this code. The global
variables that parallel CLM's *clm-...* are:

  *snd-srate* (default-output-srate)
  *snd-file-name* "test.snd"
  *snd-channels* (default-output-chans)
  *snd-explode* #f
  *snd-data-format* (default-output-format)
  *snd-header-type* (default-output-type)

*snd-explode* here refers to the with-mix-tags setting

 with-sound
    #:key (srate *snd-srate*)
          (output *snd-file-name*)
          (channels *snd-channels*)
          (explode *snd-explode*)
          (header-type *snd-header-type*)
          (data-format *snd-data-format*)
          (comment #f)
          (continue-old-file #f)
          (statistics #f)
          (scaled-to #f)
          (scaled-by #f))

As far as possible, this parallels CLM's with-sound.

  (with-sound (:srate 44100) (fm-violin 0 1 440 .1))

If the output file isn't specified, or isn't currently open in Snd,
with-sound opens a new output file.

zip.scm

  make-zipper ramp-env frame-size frame-env
  zipper gen in1 in2

The zipper generator performs a kind of cross fade, but not one that tries
to be smooth! It marches through the two sounds taking equal short portions
of each, then abutting them while resampling so that as one takes less
overall "frame" space, the other takes more. The frame-size argument is the
maximum length of each twosome in seconds (for initial array allocation),
the frame-env argument determines the current such length as new "frames"
are needed, and the ramp-env argument determines which of the files gets
more space in the frame (0: all first, 1: all second). For example, the
following function sets up two sounds, an upward ramp and a downward ramp,
then zips them together using test-zip in zip.scm:

(define (ramp-test)
  (let ((data (make-vct 10000)))
    (new-sound "new-0.snd")
    (do ((i 0 (1+ i))) ((= i 10000))
      (vct-set! data i (* i .0001)))
    (vct->samples 0 10000 data 0)
    (new-sound "new-1.snd")
    (do ((i 0 (1+ i))) ((= i 10000))
      (vct-set! data i (- 1.0 (* i .0001))))
    (vct->samples 0 10000 data 1)
    (test-zip)))

                            [zipper ramp output]

Needless to say, this is not intended to be a suave, romantic gesture!

A Note on Scheme variables in Snd

At first glance, Snd's use of functions for nearly all variable accesses
(i.e. (listener-prompt) rather than the simpler listener-prompt) seems
unmotivated. For example, the following little program defines "counter" as
a scheme variable, accessible in C:

#include <stdio.h>
#include <guile/gh.h>

void inner_main(int argc, char **argv)
{
  SCM counter;
  int size = 512;
  char **buffer = NULL;
  buffer = (char **)calloc(1,sizeof(char *));
  buffer[0] = (char *)calloc(512,sizeof(char));
  counter = gh_define("counter",gh_int2scm(0));
  while (1)
    {
      getline(buffer,&size,stdin);
      gh_eval_str(buffer[0]);
      fprintf(stdout,"counter is %d\n",gh_scm2int(gh_cdr(counter)));
    }
}

int main(int argc, char *argv[])
{
  gh_enter(argc,argv,inner_main);
  return(0);
}

Now we compile and load it (in Linux: cc g.c -o g -lguile), and it sits in a
loop reading a line at a time, evaluating it, and printing the current value
of our counter:

/home/bil/cl/ g
(+ 1 2)
counter is 0
(set! counter 123)
counter is 123
(set! counter (* counter 2))
counter is 246

But the C code itself doesn't see the set!, and there's no way to tell set!
in Guile to call an auxiliary function when (for example) our counter is
set. We need to see that set! as soon as it happens to make the user
interface responsive. (set! basic-color red) would have no effect unless our
C code could be informed that the basic-color variable's value had changed.
In addition, in Snd, there are perhaps several hundred such variables, and
our C code will run faster if we access C variables as much as possible,
rather than calling gh_scm2int (or whatever) every time the value is needed.
So, we first defined each variable along these lines:

#include <stdio.h>
#include <guile/gh.h>

int counter = 0;

SCM g_counter(void)
{
  return(gh_int2scm(counter));
}

SCM g_set_counter(SCM newval)
{
  counter = gh_scm2int(newval);
  return(newval);
}

void inner_main(int argc, char **argv)
{
  int size = 512;
  char **buffer = NULL;
  buffer = (char **)calloc(1,sizeof(char *));
  buffer[0] = (char *)calloc(512,sizeof(char));
  gh_new_procedure0_0("counter",g_counter);
  gh_new_procedure1_0("set-counter",g_set_counter);
  while (1)
    {
      getline(buffer,&size,stdin);
      gh_eval_str(buffer[0]);
      fprintf(stdout,"counter is %d\n",counter);
    }
}

int main(int argc, char *argv[])
{
  gh_enter(argc,argv,inner_main);
  return(0);
}

Now we have two functions: counter returns (to the Scheme world) the current
value of the C variable counter, and set-counter sets it:

/home/bil/cl/ g
(+ 1 2)
counter is 0
(set-counter 123)
counter is 123
(set-counter (* (counter) 2))
counter is 246

Now the g_set_counter procedure can reflect counter's new value within C,
and the variable lives in C, so two of our problems are solved. But we don't
really want the extra name "set-counter". So, we use Guile's generalized
set! by replacing the two gh_new_procedure calls above with:

  gh_define("counter",
    scm_make_procedure_with_setter(
      gh_new_procedure0_0("",g_counter),
      gh_new_procedure1_0("",g_set_counter)));

Now we have Snd's way of handling things:

/home/bil/cl/ g
(+ 1 2)
counter is 0
(set! (counter) 123)
counter is 123
(set! (counter) (* (counter) 2))
counter is 246

It's not completely ideal, but it's close enough that I don't find it
painful to use.

A Note on "As-Needed" input functions

Several CLM generators work internally on buffers of data; only the code
internal to the generator knows when it needs input, and how much it needs.
So, src, granulate, convolve, and phase-vocoder are passed a function either
at run-time or when the generator is allocated that they can call whenever a
new value is needed. A simple C case is:

#include <stdio.h>
#include "clm.h"

typedef struct {
  float val;
} src_state;

float src_input_as_needed(void *arg, int dir)
{
  src_state *sr = (src_state *)arg;
  sr->val += (dir * .01); /* just return a ramp */
  return(sr->val);
}

int main(int argc, char **argv)
{
  mus_any *gen;
  src_state *input;
  int i;
  input = (src_state *)calloc(1,sizeof(src_state));
  input->val = 0.0;
  gen = mus_make_src(&src_input_as_needed,0.5,10,(void *)input);
  for (i=0;i<100;i++)
    fprintf(stdout,"%f ",mus_src(gen,0.0,NULL));
    /* or: fprintf(stdout,"%f ",mus_src(gen,0.0,src_input_as_needed)); */
  mus_free(gen);
  free(input);
  return(0);
}

/* cc g1.c -o g1 -L/usr/local/lib -lguile /home/bil/sndlib/sndlib.a */
/* g1: 0.010000 0.015440 0.020000 0.024761 0.029999 0.035170 0.039999 ... */

To put that code in words, the src generator uses the function
src_input_as_needed to fill its internal buffer (convolving it with sinc);
in this case, the "srate" argument is 0.5, so src will pick up a new input
sample (calling src_input_as_needed) on every other output sample. In the
Scheme CLM (and Snd), the "as-needed" input function is a Scheme function
passed in as Scheme code. A highly simplified example is:

#include <stdio.h>
#include <guile/gh.h>
#include "clm.h"

typedef struct {
  SCM input_func;
} src_state;

float src_input_as_needed(void *ptr, int direction)
{
  src_state *sr = (src_state *)ptr;
  return(gh_scm2double(gh_call1(sr->input_func,gh_int2scm(direction))));
}

void inner_main(int argc, char **argv)
{
  mus_any *gen;
  src_state *input;
  int i;
  int size = 512;
  char **buffer = NULL;
  buffer = (char **)calloc(1,sizeof(char *));
  buffer[0] = (char *)calloc(512,sizeof(char));
  input = (src_state *)calloc(1,sizeof(src_state));
  fprintf(stdout,"input function: ");
  getline(buffer,&size,stdin);
  input->input_func = gh_eval_str(buffer[0]);
  gen = mus_make_src(&src_input_as_needed,0.5,10,(void *)input);
  for (i=0;i<100;i++)
    fprintf(stdout,"%f ",mus_src(gen,0.0,src_input_as_needed));
  mus_free(gen);
  free(input);
}

int main(int argc, char *argv[])
{
  gh_enter(argc,argv,inner_main);
  return(0);
}

/* cc g1.c -o g1 -L/usr/local/lib -lguile /home/bil/sndlib/sndlib.a */
/* g1
   input function: (let ((val 0.0)) (lambda (dir) (set! val (+ val (* dir .01))) val))
   0.010000 0.015440 0.020000 0.024761 0.029999 0.035170 0.039999
*/

In this case, src_input_as_needed is calling the user-supplied Scheme
function (via gh_call1).

related documentationsnd.html   extsnd.html   grfsnd.html   clm.html    sndlib.html
