<html>
<head>
<title>CLM</title>
<style type="text/css">
<!-- 
	EM.red {color:red; font-style: normal}
	EM.gen {font-weight: bold; font-style: normal}
        EM.error {color:chocolate; font-style: normal}
        EM.narg {color:chocolate; font-style: normal}
        EM.typing {color:maroon; font-style: normal}
        EM.listener {color:darkblue; font-style: normal}
	H1 {text-align: center}
	UL {list-style-type: none}
	EM.emdef {font-weight: bold; font-style: normal}

	A {text-decoration:none}
	A:hover {text-decoration:underline}
	A.quiet {color:black; text-decoration:none}
	A.quiet:hover {text-decoration:underline}
	A.def {font-weight: bold; font-style: normal; text-decoration:none; text-color:black}
-->

<!-- the latex stuff is always embedded in:

\documentclass{amsart}
\begin{document}
\thispagestyle{empty}
\small
\begin{displaymath}
...
\end{displaymath}
\end{document}

where the "displaymath" lines change to fit the situation
-->

</style>
</head>
<body bgcolor=white>

<A NAME="sndclmtop"></A><h1>CLM</h1>

<p>CLM (originally an acronym for Common Lisp Music) is a sound synthesis
package in the Music V family.  This file describes CLM as implemented in Snd,
aiming primarily at the Scheme version.  Common Lisp users should check out clm.html
in the CLM tarball.
CLM is based on a set of functions known
as "generators".  These can be packaged into "instruments", and instrument calls
can be packaged into "note lists".  The main emphasis here is on the generators;
note lists and instruments are described in sndscm.html.
</p>
<br>


<center>Bill Schottstaedt (bil@ccrma.stanford.edu)</center>
<br>

<center>
<table bgcolor="aliceblue" border=0 cellspacing=8><tr>
<td><small>related documentation:</small></td>
<td><small><a href="snd.html" onmouseover="return escape('basic Snd user-interface documentation')">snd.html</a></small></td>
<td><small><a href="extsnd.html" onmouseover="return escape('Snd extension and customization')">extsnd.html</a></small></td>
<td><small><a href="grfsnd.html" onmouseover="return escape('Snd configuration, connection to other libraries and programs')">grfsnd.html</a></small></td>
<td><small><a href="sndscm.html" onmouseover="return escape('Scheme, Ruby, and Forth files included with Snd')">sndscm.html</a></small></td>
<td><small><a href="fm.html" onmouseover="return escape('introduction to frequency modulation')">fm.html</a></small></td>
<td><small><a href="sndlib.html" onmouseover="return escape('library that handles sound files')">sndlib.html</a></small></td>
<td><small><a href="libxm.html" onmouseover="return escape('library that ties Motif and Gtk into Snd')">libxm.html</a></small></td>
<td><small><a href="index.html" onmouseover="return escape('this is an actual index, not some introductory file')">index.html</a></small></td>
</tr></table>
</center>

<br>
<br>



<table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>Contents</h2></td></tr></table>
<br>
<table border=8 bordercolor="lightsteelblue" cellpadding=8 hspace=20>

<tr><td colspan=3><center><a href="#introduction">Introduction</a></center></td></tr>

<tr><td colspan=3><center><a href="#generators">Built-in Generators</a></center></td></tr>

<tr><td width=20 bgcolor="#f6f8ff"></td><td>
<table border=0 cellpadding=0>
  <tr><td><a href="#all-passdoc">all-pass</a></td><td width=20></td><td>all-pass filter</td></tr>
  <tr><td><a href="#asymmetric-fmdoc">asymmetric-fm</a></td><td></td><td>asymmetric fm</td></tr>
  <tr><td><a href="#combdoc">comb</a></td><td></td><td>comb filter</td></tr>
  <tr><td><a href="#convolvedoc">convolve</a></td><td></td><td>convolution</td></tr>
  <tr><td><a href="#delaydoc">delay</a></td><td></td><td>delay line</td></tr>
  <tr><td><a href="#envdoc">env</a></td><td></td><td>line segment envelope</td></tr>
  <tr><td><a href="#filterdoc">filter</a></td><td></td><td>direct form FIR/IIR filter</td></tr>
  <tr><td><a href="#combdoc">filtered-comb</a></td><td></td><td>comb filter with filter on feedback</td></tr>
  <tr><td><a href="#filetosampledoc">file-&gt;sample</a></td><td></td><td>input sample from file</td></tr>
  <tr><td><a href="#filetoframe">file-&gt;frame</a></td><td></td><td>input frame from file</td></tr>
  <tr><td><a href="#fir-filterdoc">fir-filter</a></td><td></td><td>FIR filter</td></tr>
  <tr><td><a href="#frametofile">frame-&gt;file</a></td><td></td><td>output frame to file</td></tr>
  <tr><td><a href="#formantdoc">formant</a></td><td></td><td>resonance</td></tr>
  <tr><td><a href="#granulatedoc">granulate</a></td><td></td><td>granular synthesis</td></tr>
  <tr><td><a href="#iir-filterdoc">iir-filter</a></td><td></td><td>IIR filter</td></tr>
  <tr><td><a href="#in-anydoc">in-any</a></td><td></td><td>sound file input</td></tr>
  <tr><td><a href="#locsigdoc">locsig</a></td><td></td><td>static sound placement</td></tr>
  <tr><td><a href="#move-sounddoc">move-sound</a></td><td></td><td>sound motion</td></tr>
  <tr><td><a href="#moving-averagedoc">moving-average</a></td><td></td><td>moving window average</td></tr>
  <tr><td><a href="#notchdoc">notch</a></td><td></td><td>notch filter</td></tr>
  <tr><td><a href="#one-poledoc">one-pole</a></td><td></td><td>one pole filter</td></tr>
  <tr><td><a href="#one-zerodoc">one-zero</a></td><td></td><td>one zero filter</td></tr>
</table>
</td>
<td>
<table border=0 cellpadding=0>
  <tr><td><a href="#oscildoc">oscil</a></td><td></td><td>sine wave and FM</td></tr>
  <tr><td><a href="#out-anydoc">out-any</a></td><td width=20></td><td>sound output</td></tr>
  <tr><td><a href="#polyshapedoc">polyshape</a></td><td></td><td>waveshaping</td></tr>
  <tr><td><a href="#phase-vocoderdoc">phase-vocoder</a></td><td></td><td>vocoder analysis and resynthesis</td></tr>
  <tr><td><a href="#sampletofile">sample-&gt;file</a></td><td></td><td>output sample to file</td></tr>
  <tr><td><a href="#sawtoothdoc">pulse-train</a></td><td></td><td>pulse train</td></tr>
  <tr><td><a href="#randdoc">rand,rand-interp</a></td><td></td><td>random numbers, noise</td></tr>
  <tr><td><a href="#readindoc">readin</a></td><td></td><td>sound input</td></tr>
  <tr><td><a href="#sawtoothdoc">sawtooth-wave</a></td><td></td><td>sawtooth</td></tr>
  <tr><td><a href="#sine-summationdoc">sine-summation</a></td><td></td><td>sine summation synthesis</td></tr>
  <tr><td><a href="#sawtoothdoc">square-wave</a></td><td></td><td>square wave</td></tr>
  <tr><td><a href="#srcdoc">src</a></td><td></td><td>sampling rate conversion</td></tr>
  <tr><td><a href="#ssb-amdoc">ssb-am</a></td><td></td><td>single sideband amplitude modulation</td></tr>
  <tr><td><a href="#sum-of-cosinesdoc">sum-of-cosines</a></td><td></td><td>band-limited pulse train</td></tr>
  <tr><td><a href="#sum-of-sinesdoc">sum-of-sines</a></td><td></td><td>sum of sines</td></tr>
  <tr><td><a href="#table-lookupdoc">table-lookup</a></td><td></td><td>interpolated table lookup</td></tr>
  <tr><td><a href="#delaydoc">tap</a></td><td></td><td>delay line tap</td></tr>
  <tr><td><a href="#sawtoothdoc">triangle-wave</a></td><td></td><td>triangle wave</td></tr>
  <tr><td><a href="#two-poledoc">two-pole</a></td><td></td><td>two pole filter</td></tr>
  <tr><td><a href="#two-zerodoc">two-zero</a></td><td></td><td>two zero filter</td></tr>
  <tr><td><a href="#wave-traindoc">wave-train</a></td><td></td><td>wave train</td></tr>
  <tr><td><a href="#waveshapedoc">waveshape</a></td><td></td><td>waveshaping</td></tr>
</table>
</td></tr>

<tr><td colspan=3><center><a href="#othergenerators">Other Generators</a></center></td></tr>

<tr><td colspan=3><center><a href="#functions">Functions</a></center></td></tr>

<tr><td width=20 bgcolor="#f6f8ff"></td><td>
<table border=0 cellpadding=0>
  <tr><td><a href="#autocorrelate">autocorrelate</a></td><td></td><td>autocorrelation</td></tr>
  <tr><td><a href="#amplitude-modulate">amplitude-modulate</a></td><td></td><td>sig1 * (car + sig2)</td></tr>
  <tr><td><a href="#array-interp">array-interp</a></td><td></td><td>array interpolation</td></tr>
  <tr><td><a href="#contrast-enhancement">contrast-enhancement</a></td><td width=20></td><td>modulate signal</td></tr>
  <tr><td><a href="#convolution">convolution</a></td><td></td><td>convolve signals</td></tr>
  <tr><td><a href="#correlate">correlate</a></td><td></td><td>cross correlation</td></tr>
</table>
</td>
<td>
<table border=0 cellpadding=0>
  <tr><td><a href="#dot-product">dot-product</a></td><td></td><td>vct dot (scalar) product</td></tr>
  <tr><td><a href="#fft">fft</a></td><td></td><td>Fourier transform</td></tr>
  <tr><td><a href="#make-fft-window">make-fft-window</a></td><td></td><td>various standard windows</td></tr>
  <tr><td><a href="#polynomial">polynomial</a></td><td width=20></td><td>Horner's rule</td></tr>
  <tr><td><a href="#ring-modulate">ring-modulate</a></td><td width=20></td><td>sig * sig</td></tr>
  <tr><td><a href="#spectrum">spectrum</a></td><td width=20></td><td>power spectrum of signal</td></tr>
</table>
</td></tr>

<tr><td colspan=3><center><a href="sndscm.html#definstrument">Instruments</a></center></td></tr>
</table>


<br><br>


<table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2><A class=def NAME="introduction">Introduction</a></h2></td></tr></table>

<p>Start Snd, open the listener (choose "Show listener" in the View menu), and:
</p>

<pre>
    <em class=listener>&gt;</em><em class=typing>(load "v.scm")</em>
    <em class=listener>#&lt;unspecified&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(with-sound () (fm-violin 0 1 440 .1))</em>
    <em class=listener>"test.snd"</em>
</pre>

<p>Snd's printout is in blue here, and your typing is in red.  The load function returns
"#&lt;unspecified&gt;" in Guile to indicate that it is happy.
If all went well, you should see a graph of the fm-violin's output.  Click the "play" button to
hear it; click "f" to see its spectrum.
</p>


<table border=0 hspace=40><tr><td>

<p>What if this happened instead?
</p>

<pre>
    <em class=listener>&gt;</em><em class=typing>(load "v.scm")</em>
    <em class=listener>open-file: system-error: "No such file or directory": "v.scm" (2)</em>
</pre>

<p>Snd is telling you that "open-file" (presumably part of the load sequence) can't find v.scm.
I guess it's on some other directory, so try:
</p>

<pre>
    <em class=listener>&gt;</em><em class=typing>%load-path</em>
    <em class=listener>("/usr/local/share/snd" "/usr/local/share/guile/1.9")</em>
</pre>

<p>"%load-path" is a list of directorties that the "load" function looks at.  Apparently these two directories don't have v.scm.
So find out where v.scm is ("locate v.scm" is usually the quickest way), and add its directory to %load-path:
</p>

<pre>
    <em class=listener>&gt;</em><em class=typing>(set! %load-path (cons "/home/bil/cl" %load-path))</em> ; add the "cl" directory to the search list
    <em class=listener>#&lt;unspecified&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(load-from-path "v.scm")</em>
    <em class=listener>#&lt;unspecified&gt;</em>
</pre>
</td></tr></table>


<p>In Gauche, "load" returns #t if happy, #f if not, and Gauche's name for the directory search list is *load-path*.
In Ruby, we'd do it this way:
</p>

<pre>
    <em class=listener>&gt;</em><em class=typing>load "v.rb"</em>
    <em class=listener>true</em>
    <em class=listener>&gt;</em><em class=typing>with_sound() do fm_violin_rb(0, 1.0, 440.0, 0.1) end</em>
    <em class=listener>#&lt;With_CLM: output: "test.snd", channels: 1, srate: 22050&gt;</em>
</pre>

<p>and in Forth:
</p>
<pre>
    <em class=listener>snd&gt;</em> <em class=typing>"clm-ins.fs" file-eval</em>
    <em class=listener>0</em>
    <em class=listener>snd&gt;</em> <em class=typing>0.0 1.0 440.0 0.1 ' fm-violin with-sound</em>
    <em class=listener>\ filename: test.snd</em>
</pre>

<p>In most of this document, I'll stick with Scheme as implemented by Guile.  extsnd.html and sndscm.html have numerous
Ruby and Forth examples, and I'll toss some in here as I go along.
You can save yourself a lot of typing by using two features of the listener.  First, &lt;TAB&gt; (that is, the key marked TAB) tries to complete 
the current name, so if you type "fm-&lt;TAB&gt;" the listener completes the name as "fm-violin".
And second, you can back up to a previous expression, edit it, move the cursor to the closing parenthesis, and
type &lt;RETURN&gt;, and that expression will be evaluated as if you had typed all of it in from the start. 
Needless to say, you can paste code from this file into the Snd listener.
</p>

<p>with-sound opens an output sound file, evaluates its body, closes the file, and then opens it in Snd.
If the sound is already open, with-sound replaces it with the new version. 
The body of with-sound can be any size, and can include anything that you could put in a function body.
For example, 
to get an arpeggio:</p>
<pre>
    (with-sound ()
      (do ((i 0 (1+ i)))
          ((= i 8))
        (fm-violin (* i .25) .5 (* 100 (1+ i)) .1)))
</pre>

<table border=0 hspace=40><tr><td>
<p>If that seemed to take awhile, make sure you've turned on <a href="extsnd.html#optimization">optimization</a>:
</p>

<pre>
    <em class=listener>&gt;</em><em class=typing>(set! (optimization) 6)</em>
    <em class=listener>6</em>
</pre>

<p>The optimizer, a macro named "run", can usually speed up computations by about a factor of 10.
</p>
</td></tr></table>


<p>with-sound, instruments, CLM itself are all optional, of course.  We could
do everything by hand:
</p>

<pre>
    (let ((sound (<a class=quiet href="extsnd.html#newsound">new-sound</a> "test.snd" :size 22050))
          (increment (/ (* 440.0 2.0 pi) 22050.0))
          (current-phase 0.0))
      (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (lambda (y)
	    	     (let ((val (* .1 (sin current-phase))))
		       (set! current-phase (+ current-phase increment))
		       val))))
</pre>

<p>This opens a sound file (via <a href="extsnd.html#newsound">new-sound</a>) and fills it with a .1 amplitude sine wave at 440 Hz.
The "increment" calculation turns 440 Hz into a phase increment in radians (we could also use the function <a href="#hztoradians">hz-&gt;radians</a>).
The "oscil" generator keeps track of the phase increment for us, so
essentially the same thing using with-sound and oscil is:
</p>

<pre>
    (with-sound ()
      (let ((osc (<a class=quiet href="#make-oscil">make-oscil</a> 440.0)))
        (do ((i 0 (1+ i)))
	    ((= i 22050))
          (<a class=quiet href="#outa">outa</a> i (* .1 (<a class=quiet href="#oscil">oscil</a> osc)) *output*))))
</pre>

<p>*output* is the file opened by with-sound, and outa is a function that adds its second
argument (the sinusoid) into the current output at the sample given by its first argument
("i" in this case).  oscil is our sinusoid generator, created by make-oscil.  You don't
need to worry about freeing the oscil; we can depend on the Scheme garbage collector to
deal with that.  All the generators are like oscil in that
each is a function that on each call returns the next sample in an infinite stream of samples.
An oscillator, for example, returns an endless sine wave, one sample
at a time.  
Each generator consists of a set of functions:  make-&lt;gen&gt; sets up the
data structure associated with the generator;
&lt;gen&gt; produces a new sample;
&lt;gen&gt;? checks whether a variable is that kind of generator.
Current generator state is accessible via various generic functions such as mus-frequency:
</p>
<pre>
    (set! oscillator (<a class=quiet href="#make-oscil">make-oscil</a> :frequency 330))
</pre>
<p>prepares "oscillator" to produce a sine wave
when set in motion via</p>
<pre>
    (<a class=quiet href="#oscil">oscil</a> oscillator)
</pre>

<p>
The make-&lt;gen&gt; function
takes a number of optional arguments, setting whatever state the given
generator needs to operate on.  The run-time function's first argument is
always its associated structure.  Its second argument is nearly always
something like an FM input or whatever run-time modulation might be
desired.
Frequency sweeps of all kinds (vibrato, glissando, breath
noise, FM proper) are all forms of frequency modulation.  So, in
normal usage, our oscillator looks something like:</p>
<pre>
    (<a class=quiet href="#oscil">oscil</a> oscillator (+ vibrato glissando frequency-modulation))
</pre>

<p>One special aspect of each make-&lt;gen&gt; function is the way it
read its arguments.  I use the word <a class=def Name="optional-key">optional-key</a>
in the function definitions in this document to indicate that the arguments are
keywords, but the keywords themselves are optional.
Take the make-oscil call, defined as:</p>
<pre>
    make-oscil :optional-key (frequency 440.0) (initial-phase 0.0)
</pre>
<p>This says that make-oscil has two optional arguments, frequency (in Hz), and
initial-phase (in radians).  The keywords associated with these values are
:frequency and :initial-phase.
When make-oscil is called, it scans its arguments; if a keyword is seen, that
argument and all following arguments are passed unchanged, but if a value is
seen, the corresponding keyword is prepended in the argument list:
</p>
<pre>
    (<a class=quiet href="#make-oscil">make-oscil</a> :frequency 440.0)
    (<a class=quiet href="#make-oscil">make-oscil</a> :frequency 440.0 :initial-phase 0.0)
    (<a class=quiet href="#make-oscil">make-oscil</a> 440.0)
    (<a class=quiet href="#make-oscil">make-oscil</a>)
    (<a class=quiet href="#make-oscil">make-oscil</a> 440.0 :initial-phase 0.0)
    (<a class=quiet href="#make-oscil">make-oscil</a> 440.0 0.0)
</pre>
<p>are all equivalent, but</p>
<pre>
    (<a class=quiet href="#make-oscil">make-oscil</a> :frequency 440.0 0.0)
    (<a class=quiet href="#make-oscil">make-oscil</a> :initial-phase 0.0 440.0)
</pre>

<p>are in error, because once we see any keyword, all the rest of the arguments have
to use keywords too (we can't reliably make any assumptions after that point about argument
ordering). 
</p>

<p>Since we often want to use a given sound-producing algorithm many times (in a note list,
for example), it is convenient to package up that code into a function. Our sinewave
could be rewritten:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(define (simp start end freq amp)
  (let ((os (<a class=quiet href="#make-oscil">make-oscil</a> freq)))
    (do ((i start (1+ i))) 
        ((= i end))
      (<a class=quiet href="#outa">outa</a> i (* amp (<a class=quiet href="#oscil">oscil</a> os)) *output*))))
</pre>
</td></tr></table>

<p>Now to hear our sine wave:</p>
<pre>
    (with-sound (:play #t) (simp 0 22050 330 .1))
</pre>

<p>This version of "simp" forces you to think in terms of sample numbers ("start" and "end") which
are dependent on the overall sampling rate changes.  Our first enhancement is to use seconds:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(define (simp beg dur freq amp)
  (let* ((os (<a class=quiet href="#make-oscil">make-oscil</a> freq))
	 (<em class=red>start</em> (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> beg))
	 (<em class=red>end</em> (+ start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur))))
    (do ((i start (1+ i))) 
        ((= i end))
      (<a class=quiet href="#outa">outa</a> i (* amp (<a class=quiet href="#oscil">oscil</a> os)) *output*))))
</pre>
</td></tr></table>

<p>Now we can use any sampling rate, and call "simp" using seconds:
</p>
<pre>
    (with-sound (:srate 44100) (simp 0 1.0 440.0 0.1))
</pre>

<p>Our next improvement adds the "run" macro to speed up processing by about a factor of 10:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(define (simp beg dur freq amp)
  (let* ((os (<a class=quiet href="#make-oscil">make-oscil</a> freq))
	 (start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> beg))
	 (end (+ start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur))))
    (<em class=red>run</em>
      (lambda ()
        (do ((i start (1+ i))) 
            ((= i end))
          (<a class=quiet href="#outa">outa</a> i (* amp (<a class=quiet href="#oscil">oscil</a> os)) *output*))))))
</pre>
</td></tr></table>

<p>Next we turn the "simp" function into an "instrument".  An instrument is
a function that has a variety of built-in actions within with-sound.  The only change
is the word "definstrument":
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<em class=red>definstrument</em> (simp beg dur freq amp)
  (let* ((os (<a class=quiet href="#make-oscil">make-oscil</a> freq))
	 (start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> beg))
	 (end (+ start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur))))
    (run
      (lambda ()
        (do ((i start (1+ i))) 
            ((= i end))
          (<a class=quiet href="#outa">outa</a> i (* amp (<a class=quiet href="#oscil">oscil</a> os)) *output*))))))
</pre>
</td></tr></table>

<p>Now we can simulate a telephone:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(define (telephone start telephone-number)
  (let ((touch-tab-1 '(0 697 697 697 770 770 770 852 852 852 941 941 941))
	(touch-tab-2 '(0 1209 1336 1477 1209 1336 1477 1209 1336 1477 1209 1336 1477)))
    (do ((i 0 (1+ i)))
	((= i (length telephone-number)))
      (let* ((num (list-ref telephone-number i))
	     (frq1 (list-ref touch-tab-1 num))
	     (frq2 (list-ref touch-tab-2 num)))
        (<em class=red>simp</em> (+ start (* i .4)) .3 frq1 .1)
        (<em class=red>simp</em> (+ start (* i .4)) .3 frq2 .1)))))

(with-sound () (telephone 0.0 '(7 2 3 4 9 7 1)))
</pre>
</td></tr></table>

<p>As a last change, let's add an amplitude envelope:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (simp beg dur freq amp envelope)
  (let* ((os (<a class=quiet href="#make-oscil">make-oscil</a> freq))
         (<em class=red>amp-env</em> (<a class=quiet href="#make-env">make-env</a> envelope :duration dur :scaler amp))
	 (start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> beg))
         (end (+ start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur))))
    (<a class=quiet href="extsnd.html#run">run</a>
      (lambda ()
        (do ((i start (1+ i))) 
            ((= i end))
          (<a class=quiet href="#outa">outa</a> i (* (<a class=quiet href="#env">env</a> <em class=red>amp-env</em>) (<a class=quiet href="#oscil">oscil</a> os)) *output*))))))
</pre>
</td></tr></table>

<p>A CLM envelope is a list of (x y) break-point pairs.  The
x-axis bounds are arbitrary, but it is conventional (here at ccrma) to
go from 0 to 1.0.  The y-axis values are normally between -1.0 and
1.0, to make it easier to figure out how to apply the envelope in
various different situations.  
</p>

<pre>
    (with-sound () (simp 0 2 440 .1 '(0 0  0.1 1.0  1.0 0.0)))
</pre>

<p>Add a few more oscils and envs, and you've got the fm-violin.  You can try out a generator or a patch of generators quickly by
plugging it into the following with-sound call:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(with-sound () 
  (let ((sqr (make-square-wave 100))) ; test a square-wave generator
    (do ((i 0 (1+ i))) 
        ((= i 10000)) 
      (outa i (square-wave sqr) *output*))))
</pre>
</td></tr></table>

<p>By the way, there's nothing special about a generator in CLM: it is a function, or perhaps more accurately, a closure.  If it happens to restrict itself
to functions that the "run" macro can handle (and this includes most of Scheme), then it will run
nearly as fast as any built-in function.  If it needs to keep on-going state around, it is simplest to use a vct
as the generator object:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(define (<A NAME="make-my-oscil">make-my-oscil</A> frequency)       ; we want our own oscil!
  (vct 0.0 (hz-&gt;radians frequency)))    ; current phase and frequency-based phase increment

(define (my-oscil gen fm)               ; the corresponding generator
  (let ((result (sin (vct-ref gen 0)))) ; return sin(current-phase)
    (vct-set! gen 0 (+ (vct-ref gen 0)  ; increment current phase
                       (vct-ref gen 1)  ;    by frequency
                       fm))             ;    and FM
    result))                            ; return sine wave

(with-sound () 
  (<a class=quiet href="extsnd.html#run">run</a> 
   (lambda () 
     (let ((osc (make-my-oscil 440.0)))
       (do ((i 0 (1+ i))) 
	   ((= i 22050))
	 (outa i (my-oscil osc 0.0) *output*))))))
</pre>
</td></tr></table>

<p>There are many more such generators scattered around the Snd package. For more sophisticated situations,
you can use <a href="sndscm.html#def-clm-struct">def-clm-struct</a>.
</p>
<br><br>



<!-- INDEX generators:Generators -->
<table width="80%" border=0><tr><td bgcolor="lightsteelblue" valign="middle"><h2><A class=def NAME="generators">Generators</a></h2></td></tr></table>
<br><br>


<A NAME="oscildoc"></A>
<!-- ---------------------------------------- OSCIL ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>oscil</h3></center></td></tr></table>
<br>
<pre>
  <a class=def name="make-oscil">make-oscil</a> <a class=quiet href="#optional-key">:optional-key</a> (frequency 440.0) (initial-phase 0.0)
  <a class=def name="oscil">oscil</a> os :optional (fm-input 0.0) (pm-input 0.0)
  <a class=def name="oscil?">oscil?</a> os
  <a class=def name="sine-bank">sine-bank</a> amps phases
</pre>

<p>oscil produces a sine wave (using sin) with optional frequency change (FM).
Its first argument is an oscil created by make-oscil.
Oscil's second argument is the 
frequency change (frequency modulation), and the third argument is the
phase change (phase modulation).
The initial-phase argument to make-oscil is in radians. You can
use <a href="#degreestoradians">degrees-&gt;radians</a> to convert from degrees to radians.
To get a cosine (as opposed to sine), set the initial-phase to (/ pi 2).
</p>

<p>sine-bank simply loops through its arrays of amps and phases, summing
(* amp (sin phase)) -- it is mostly a convenience function for additive synthesis
(the phase-vocoder in particular).
</p>

<table border=1 align=left hspace=40 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>oscil methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>frequency in Hz</td></tr>
<tr><td><em class=gen>mus-phase</em></td><td>phase in radians</td></tr>
<tr><td><em class=gen>mus-cosines</em></td><td>1 (no set!)</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>frequency in radians per sample</td></tr>
</table>
<br>
<pre>
  (let ((result (sin (+ phase pm-input))))
    (set! phase (+ phase (<a class=quiet href="#hztoradians">hz-&gt;radians</a> frequency) fm-input))
    result)
  <img src="sceq9.png" alt="fnm equation" hspace=10 vspace=10>
</pre>
<!-- LATEX: \cos \, (\omega_{c}t+B\sin \omega_{m}t)\:=\!\!\sum_{n=-\infty}^{\infty} \! \! J_{n}(B)\cos(\omega_{c} + n\omega_{m})t -->
<br clear=left>

<p>One slightly confusing aspect of oscil is that glissando has to be turned into a phase-increment envelope.
This means that the frequency envelope y values should be passed through <a href="#hztoradians">hz-&gt;radians</a>:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(define (simp start end freq amp frq-env)
  (let ((os (make-oscil freq)) 
        (frqe (<a class=quiet href="#make-env">make-env</a> frq-env :dur (- end start) :scaler (<em class=red>hz->radians</em> freq))))
    (do ((i start (1+ i))) 
        ((= i end))
      (<a class=quiet href="#outa">outa</a> i (* amp (oscil os (env <em class=red>frqe</em>))) *output*))))

(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> () (simp 0 10000 440 .1 '(0 0 1 1))) ; sweep up an octave
</pre>
</td></tr></table>

<p>Here is an example of FM (here the <a class=quiet href="#hztoradians">hz-&gt;radians</a> business is folded into the FM index):
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (simple-fm beg dur freq amp mc-ratio index :optional amp-env index-env)
  (let* ((start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> beg))
	 (end (+ start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur)))
	 (cr (<em class=red>make-oscil</em> freq))                     ; carrier
         (md (<em class=red>make-oscil</em> (* freq mc-ratio)))        ; modulator
         (fm-index (<a class=quiet href="#hztoradians">hz-&gt;radians</a> (* index mc-ratio freq)))
         (ampf (<a class=quiet href="#make-env">make-env</a> (or amp-env '(0 0  .5 1  1 0)) :scaler amp :duration dur))
         (indf (<a class=quiet href="#make-env">make-env</a> (or index-env '(0 0  .5 1  1 0)) :scaler fm-index :duration dur)))
    (<a class=quiet href="extsnd.html#run">run</a>
      (lambda ()
        (do ((i start (1+ i)))
            ((= i end))
          (<a class=quiet href="#outa">outa</a> i (* (<a class=quiet href="#env">env</a> ampf) (<em class=red>oscil</em> cr (* (<a class=quiet href="#env">env</a> indf) (<em class=red>oscil</em> md)))) *output*))))))

;;; (<a class=quiet href="sndscm.html#wsdoc">with-sound</a> () (simple-fm 0 1 440 .1 2 1.0))
</pre>
</td></tr></table>

<p>See <a href="fm.html">fm.html</a> for a
discussion of FM.  The standard additive synthesis instruments use an array of oscillators to
create the individual spectral components:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(define (simple-add beg dur freq amp)
  (let* ((start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> beg))
	 (end (+ start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur)))
	 (arr (make-vector 20)))     ; we'll create a tone with 20 equal amplitude harmonics
    (do ((i 0 (1+ i)))               ;   use the 'f' button to check out the spectrum
	((= i 20))
      (vector-set! arr i (<em class=red>make-oscil</em> (* (1+ i) freq))))
    (<a class=quiet href="extsnd.html#run">run</a>
     (lambda ()
       (do ((i start (1+ i))) 
           ((= i end))
	 (let ((sum 0.0))
	   (do ((k 0 (1+ k)))
	       ((= k 20))
	     (set! sum (+ sum (<em class=red>oscil</em> (vector-ref arr k)))))
	   (<a class=quiet href="#out-any">out-any</a> i (* amp .05 sum) 0 *output*)))))))

;;; (<a class=quiet href="sndscm.html#wsdoc">with-sound</a> () (simple-add 0 1 220 .3))
</pre>
</td></tr></table>


<table border=2 bgcolor="#fafafa" cellpadding=6 hspace=20 vspace=20>
<tr><td>
<p>To compare the Scheme, Ruby, Forth, and C versions of a CLM instrument (not to mention the Common Lisp
version in the CLM tarball), here are versions of the bird instrument; it produces a sinusoid with (usually
very elaborate) amplitude and frequency envelopes.
</p>

</td></tr><tr><td>

<table border=0 bgcolor="#fafafa" hspace=20><tr><td>
<pre>
(define (scheme-bird start dur frequency freqskew amplitude freq-envelope amp-envelope)
  (let* ((gls-env (<a class=quiet href="#make-env">make-env</a> freq-envelope (<a class=quiet href="#hztoradians">hz-&gt;radians</a> freqskew) dur))
         (os (<a class=quiet href="#make-oscil">make-oscil</a> frequency))
         (amp-env (<a class=quiet href="#make-env">make-env</a> amp-envelope amplitude dur))
	 (len (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur))
	 (beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> start))
	 (end (+ beg len)))
    (<a class=quiet href="extsnd.html#run">run</a>
     (lambda ()
       (do ((i beg (1+ i)))
	   ((= i end))
	 (<a class=quiet href="#outa">outa</a> i (* (<a class=quiet href="#env">env</a> amp-env) 
                    (<a class=quiet href="#oscil">oscil</a> os (<a class=quiet href="#env">env</a> gls-env)))
	       *output*))))))
</pre>
</td></tr></table>

</td></tr><tr><td>

<table border=0 bgcolor="#fafafa" hspace=20><tr><td>
<pre>
def ruby_bird(start, dur, freq, freqskew, amp, freq_envelope, amp_envelope)
  gls_env = make_env(:envelope, freq_envelope, :scaler, hz2radians(freqskew), :duration, dur)
  os = make_oscil(:frequency, freq)
  amp_env = make_env(:envelope, amp_envelope, :scaler, amp, :duration, dur)
  run_instrument(start, dur) do
    env(amp_env) * oscil(os, env(gls_env))
  end
end
</pre>
</td></tr></table>

</td></tr><tr><td>

<table border=0 bgcolor="#fafafa" hspace=20><tr><td>
<pre>
instrument: forth-bird { f: start f: dur f: freq f: freq-skew f: amp freqenv ampenv -- }
    :frequency freq make-oscil { os }
    :envelope ampenv :scaler amp :duration dur make-env { ampf }
    :envelope freqenv :scaler freq-skew hz&gt;radians :duration dur make-env { gls-env }
    90e random :locsig-degree
    start dur run-instrument  ampf env  gls-env env os oscil-1  f*  end-run
    os gen-free
    ampf gen-free
    gls-env gen-free
;instrument
</pre>
</td></tr></table>

</td></tr><tr><td>

<table border=0 bgcolor="#fafafa" hspace=20><tr><td>
<pre>
void c_bird(double start, double dur, double frequency, double freqskew, double amplitude, 
	    double *freqdata, int freqpts, double *ampdata, int amppts, mus_any *output)
{
  off_t beg, end, i;
  mus_any *amp_env, *freq_env, *osc;
  beg = start * mus_srate();
  end = start + dur * mus_srate();
  osc = mus_make_oscil(frequency, 0.0);
  amp_env = mus_make_env(ampdata, amppts, amplitude, 0.0, 1.0, dur, 0, NULL);
  freq_env = mus_make_env(freqdata, freqpts, mus_hz_to_radians(freqskew), 0.0, 1.0, dur, 0, NULL);
  for (i = beg; i &lt; end; i++)
    mus_sample_to_file(output, i, 0, 
		       mus_env(amp_env) * 
		         mus_oscil(osc, mus_env(freq_env), 0.0));
  mus_free(osc);
  mus_free(amp_env);
  mus_free(freq_env);
}
</pre>
</td></tr></table>

</td></tr></table>


<p>Related generators are 
<a href="#sum-of-cosines">sum-of-cosines</a>, 
<a href="#sum-of-sines">sum-of-sines</a>,
<a href="#asymmetric-fm">asymmetric-fm</a>, 
<a href="#sine-summation">sine-summation</a>, and
<a href="#waveshape">waveshape</a>.  
Some instruments that use oscil are 
<a href="sndscm.html#birddoc">bird and bigbird</a>,
<a href="sndscm.html#fmviolin">fm-violin</a> (v.ins),
<a href="sndscm.html#lbjpiano">lbj-piano</a> (clm-ins.scm), 
<a href="sndscm.html#fmvox">vox</a> (clm-ins.scm), and
<a href="sndscm.html#fmbell">fm-bell</a> (clm-ins.scm).  
Interesting extensions of oscil include the various
summation formulas in generators.scm (<a href="#rcos">rcos</a> et al).
For a sine-bank example, see pvoc.scm.
To goof around with FM from a graphical interface, see bess.scm and bess1.scm.
</p>

<br><br>



<A NAME="envdoc"></A>
<!-- ---------------------------------------- ENV ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>env</h3></center></td></tr></table>
<br>

<pre>
  <a class=def name="make-env">make-env</a> <a class=quiet href="#optional-key">:optional-key</a> 
      envelope      ; list of x,y break-point pairs
      (scaler 1.0)  ; scaler on every y value (before offset is added)
      duration      ; seconds
      (offset 0.0)  ; value added to every y value
      base          ; type of connecting line between break-points
      end           ; end point in samples (similar to dur)
      dur           ; duration in samples (can be used instead of end)

  <a class=def name="env">env</a> e
  <a class=def name="env?">env?</a> e

  <a class=def name="env-interp">env-interp</a> x env :optional (base 1.0)
</pre>

<table border=0 hspace=40><tr><td>
<table border=1 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>env methods</center></td></tr>
<tr><td><em class=gen>mus-location</em></td><td>number of calls so far on this env</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>base</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>breakpoint list</td></tr>
<tr><td><em class=gen>mus-scaler</em></td><td>scaler</td></tr>
<tr><td><em class=gen>mus-offset</em></td><td>offset</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>duration in samples</td></tr>
</table>
</td><td width=50></td><td>
<img src="pyr.png" alt="an envelope">
</td></tr></table>

<p>An envelope is a list of break point pairs:  '(0 0  100 1)  is
a ramp from 0 to 1 over an x-axis excursion from 0 to 100.  This list is passed
to make-env along with the scaler
applied to the y axis, the offset added to every y value,
and the time in samples or seconds that the x axis represents.  make-env
returns an env generator.  env then returns the next sample of the envelope each
time it is called.  
Say we want  a ramp moving from .3 to .5 during 1 second. 
</p>
<pre>
    (make-env '(0 0  100 1) :scaler .2 :offset .3 :duration 1.0)
    (make-env '(0 .3  1 .5) :duration 1.0)
</pre>
<p>I find the second version easier to read.  The first is handy if you have a
bunch of stored envelopes.
</p>

<table border=0><tr><td>
<p>The base argument determines how the break-points are connected.  If it is 1.0 (the
default), you get straight line segments.  If base is 0.0, you get a step
function (the envelope changes its value suddenly to the new one without any
interpolation).  Any other positive value affects the exponent of the exponential curve
connecting the points.  A base less than 1.0 gives convex curves (i.e. bowed
out), and a base greater than 1.0 gives concave curves (i.e. sagging).
If you'd rather think in terms of e^-kt, set the base to <code>(exp k)</code>. 
There are more pictures of these choices in <a href="sndscm.html#envexptchannel">sndscm.html</a>.
</p>
</td><td>
<img src="pyr03.png" alt="base .03 choice" hspace=10>
</td><td>
<img src="pyr32.png" alt="base 32 choice" hspace=10>
</td></tr></table>

<p>
To get arbitrary connecting curves between the break points, treat
the output of env as the input to the connecting function.  Here's an
instrument that maps the line segments into sin x^3:
</p>

<table border=0><tr><td>
<table border=0 bgcolor="#fafafa" hspace=20><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (mapenv beg dur frq amp en)
  (let* ((start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> beg))
	 (end (+ start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur)))
	 (osc (<a class=quiet href="#make-oscil">make-oscil</a> frq))
	 (zv (<em class=red>make-env</em> <em class=red>en</em> 1.0 dur)))
    (<a class=quiet href="extsnd.html#run">run</a>
     (lambda ()
       (do ((i start (1+ i)))
           ((= i end))
         (let ((zval (<em class=red>env</em> zv))) 
	   (<a class=quiet href="#outa">outa</a> i 
             (* amp 
                (sin (* 0.5 pi zval zval zval)) 
                (<a class=quiet href="#oscil">oscil</a> osc)) 
             *output*)))))))

(<a class=quiet href="sndscm.html#withsound">with-sound</a> () 
  (mapenv 0 1 440 .4 '(0 0 50 1 75 0 86 .5 100 0)))
</pre>
</td></tr></table>
</td><td>
<img src="sincube.png" alt="sin cubed envelope" hspace=10>
</td></tr></table>

<p>Or write a function that traces out the curve you want.
J.C.Risset's bell curve could be:</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(define <A NAME="bellcurve">(bell-curve</a> x)
  ;; x from 0.0 to 1.0 creates bell curve between .64e-4 and nearly 1.0
  ;; if x goes on from there, you get more bell curves; x can be
  ;; an envelope (a ramp from 0 to 1 if you want just a bell curve)
  (+ .64e-4 (* .1565 (- (exp (- 1.0 (cos (* 2 pi x)))) 1.0))))
</pre>
</td></tr></table>

<p>There are many more such functions in the Snd package.  See <a href="sndscm.html#envexptchannel">extensions.scm</a>
for examples and pictures.
</p>

<p>
<a href="#mus-reset">mus-reset</a> of an env causes it
to start all over again from the beginning. 
To jump to any position in
an env, use <a href="#mus-location">mus-location</a>.
Here's a function that uses these methods to apply an envelope over and over:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(define (strum e)
  (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (lambda (y)
		 (if (&gt; (<em class=red>mus-location</em> e) (<em class=red>mus-length</em> e)) ; mus-length = dur
		     (<em class=red>mus-reset</em> e))     ; start env again (default is to stick at the last value)
		 (* y (env e)))))

;;; (strum (make-env (list 0 0 1 1 10 .6 25 .3 100 0) :end 2000))
</pre>
</td></tr></table>

<p>To copy an env while changing one aspect (say
duration), it's simplest to use make-env:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(defun change-env-dur (e dur)
  (<a class=quiet href="#make-env">make-env</a> (<a class=quiet href="#mus-data">mus-data</a> e) :scaler (<a class=quiet href="#mus-scaler">mus-scaler</a> e) :offset (<a class=quiet href="#mus-offset">mus-offset</a> e) :base (<a class=quiet href="#mus-increment">mus-increment</a> e)
	    :duration dur))
</pre>
</td></tr></table>



<p>env-interp returns the value of the envelope at some point
on the x axis.
</p>

<table border=3 bordercolor="tan" hspace=40><th bgcolor="beige">Envelopes</th><tr><td>
<blockquote><small>
<br>
envelope sound: <a href="extsnd.html#envchannel">env-channel</a>, <a href="extsnd.html#envsound">env-sound</a><br>
other enveloping functions: <a href="extsnd.html#rampchannel">ramp-channel</a>, <a href="extsnd.html#xrampchannel">xramp-channel</a>, <a href="extsnd.html#smoothchannel">smooth-channel</a><br>
Various operations on envelopes: <a href="sndscm.html#envdoc">env.scm</a><br>
<table border=0 hspace=30><tr><td>
   <small>
   add-envelopes, concatenate-envelopes, envelope-exp, envelope-interp, envelope-last-x,<br>
   intergrate-envelope, make-power-env, map-envelopes, max-envelope, multiply-envelopes,<br>
   normalize-envelope, repeat-envelope, reverse-envelope, rms-envelope, scale-envelope,<br>
   stretch-envelope (also known as "adsr" in some systems, and previously "divenv" in CLM),<br>
   window-envelope.
   </small>
</td></tr></table>
The envelope editor: <a href="snd.html#editenvelope">Edit or View and Envelope</a><br>
Panning: place-sound in examp.scm<br>
Read sound indexed through envelope: <a href="sndscm.html#envsoundinterp">env-sound-interp</a><br>
Cosine as envelope: <a href="extsnd.html#cosinechannel">cosine-channel</a>, <a href="extsnd.html#cosinechannelviaptree">cosine-channel-via-ptree</a>, <a href="sndclm.html#bellcurve">bell-curve</a><br>
envelope with sinusoidal connections between points: <a href="sndscm.html#sineenvchannel">sine-env-channel</a><br>
envelope with separate base for each segment: <a href="extsnd.html#powenvchannel">powenv-channel</a><br>
envelope with x^2 connections: <a href="sndscm.html#envsquaredchannel">env-squared-channel</a><br>
envelope with x^n connections: <a href="sndscm.html#envexptchannel">env-expt-channel</a><br>
envelope with <a href="sndclm.html#sum-of-cosines">sum-of-cosines</a> connections: <a href="sndscm.html#blackman4envchannel">blackman4-env-channel</a><br>
<br>
</small></blockquote>
</td></tr></table>
<br><br>



<A NAME="table-lookupdoc"></A>
<!-- ---------------------------------------- TABLE-LOOKUP ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>table-lookup</h3></center></td></tr></table>
<br>

<pre>
  <a class=def name="make-table-lookup">make-table-lookup</a> <a class=quiet href="#optional-key">:optional-key</a> 
        (frequency 440.0)   ; in Hz
        (initial-phase 0.0) ; in radians 
        wave                ; a vct
        size                ; table size if wave not specified
        type                ; interpolation type (mus-interp-linear)

  <a class=def name="table-lookup">table-lookup</a> tl :optional (fm-input 0.0)
  <a class=def name="table-lookup?">table-lookup?</a> tl
</pre>

<p>table-lookup performs interpolating table lookup with a lookup index that moves
through the table at a speed set by make-table-lookup's "frequency" argument and table-lookup's "fm-input" argument.
That is, the waveform in the table is produced repeatedly, the repetition rate set by the frequency arguments.
Table-lookup scales its
fm-input argument to make its table size appear to be two pi.
The intention here is that table-lookup with a sinusoid in the table and a given FM signal
produces the same output as oscil with that FM signal.
The "type" argument sets the type of interpolation used: <code>mus-interp-none</code>,
<code>mus-interp-linear</code>, <code>mus-interp-lagrange</code>, <code>mus-interp-bezier</code>, or <code>mus-interp-hermite</code>.
</p>

<table border=1 align=left hspace=40 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>table-lookup methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>frequency in Hz</td></tr>
<tr><td><em class=gen>mus-phase</em></td><td>phase in radians</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>wave vct</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>wave size (no set!)</td></tr>
<tr><td><em class=gen>mus-interp-type</em></td><td>interpolation choice (no set!)</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>table increment per sample</td></tr>
</table>
<pre>
<br>
(let ((result (<a class=quiet href="#array-interp">array-interp</a> wave phase)))
  (set! phase (+ phase 
                 (<a class=quiet href="#hztoradians">hz-&gt;radians</a> frequency)
                 (* fm-input
                    (/ (length wave) 
                       (* 2 pi)))))
  result)
</pre><br clear=left>

<p>In the past, table-lookup was often used for additive synthesis, so
there are two functions that make it easier to load up
various such waveforms:
</p>

<pre>
 <a class=def name="partialstowave">partials-&gt;wave</a> synth-data :optional wave-vct (norm #t)
 <a class=def name="phase-partialstowave">phase-partials-&gt;wave</a> synth-data :optional wave-vct (norm #t)
</pre>

<p>The "synth-data" argument is a list of (partial amp) pairs: '(1 .5  2 .25)
gives a combination of a sine wave at the carrier (partial = 1) at amplitude .5, and
another at the first harmonic (partial = 2) at amplitude .25.  The partial amplitudes are
normalized to sum to a total amplitude of 1.0 unless the argument "norm"
is #f.  If the initial phases matter (they almost never do), you can use
phase-partials-&gt;wave; in this case the synth-data is a list of (partial amp phase) triples with phases in radians.
If "wave-vct" is not passed, these functions return a new vct.
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (simple-table dur)
  (let ((tab (<em class=red>make-table-lookup</em> :wave (<em class=red>partials-&gt;wave</em> '(1 .5  2 .5)))))
    (do ((i 0 (1+ i))) ((= i dur))
      (<a class=quiet href="#outa">outa</a> i (* .3 (<em class=red>table-lookup</em> tab)) *output*))))
</pre>
</td></tr></table>

<p>table-lookup can also be used as a sort of "freeze" function, looping through a sound repeatedly,
based on some previously chosen loop positions:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(define (looper start dur sound freq amp)
  (let* ((beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> start))
	 (end (+ beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur)))
	 (loop-data (<a class=quiet href="extsnd.html#mussoundloopinfo">mus-sound-loop-info</a> sound)))
    (if (or (null? loop-data)
	    (&lt;= (cadr loop-data) (car loop-data)))
	(throw 'no-loop-positions)
	(let* ((loop-start (car loop-data))
	       (loop-end (cadr loop-data))
	       (loop-length (1+ (- loop-end loop-start)))
	       (sound-section (<a class=quiet href="#filetoarray">file-&gt;array</a> sound 0 loop-start loop-length (make-vct loop-length)))
	       (original-loop-duration (/ loop-length (<a class=quiet href="extsnd.html#mussoundsrate">mus-sound-srate</a> sound)))
	       (tbl (<em class=red>make-table-lookup</em> :frequency (/ freq original-loop-duration) :wave sound-section)))
	       ;; "freq" here is how fast we read (transpose) the sound -- 1.0 returns the original
	  (<a class=quiet href="extsnd.html#run">run</a>
	   (lambda ()
	     (do ((i beg (1+ i)))
		 ((= i end))
	       (<a class=quiet href="#outa">outa</a> i (* amp (<em class=red>table-lookup</em> tbl)) *output*))))))))

(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> (:srate 44100) (looper 0 10 "/home/bil/sf1/forest.aiff" 1.0 0.5))
</pre>
</td></tr></table>

<p>And for total confusion, here's a table-lookup that modulates a sound where we specify the
modulation deviation in samples:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (fm-table file start dur amp read-speed modulator-freq index-in-samples)
  (let* ((beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> start))
	 (end (+ beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur)))
	 (table-length (<a class=quiet href="extsnd.html#mussoundframes">mus-sound-frames</a> file))
	 (tab (<em class=red>make-table-lookup</em> :frequency (/ read-speed (<a class=quiet href="extsnd.html#mussoundduration">mus-sound-duration</a> file)) 
				 :wave (<a class=quiet href="#filetoarray">file-&gt;array</a> file 0 0 table-length (<a class=quiet href="extsnd.html#makevct">make-vct</a> table-length))))
	 (osc (<a class=quiet href="#make-oscil">make-oscil</a> modulator-freq))
	 (index (/ (* (<a class=quiet href="#hztoradians">hz-&gt;radians</a> modulator-freq) 2 pi index-in-samples) table-length)))
    (<a class=quiet href="extsnd.html#run">run</a>
     (lambda ()
       (do ((i beg (1+ i)))
	   ((= i end))
	 (<a class=quiet href="#outa">outa</a> i (* amp (<em class=red>table-lookup</em> tab (* index (<a class=quiet href="#oscil">oscil</a> osc))))
	       *output*))))))
</pre>
</td></tr></table>

<p>Lessee.. there's a factor of table-length/(2*pi) in table-lookup, so that a table with a sinusoid
behaves the same as an oscil even with FM; hz-&gt;radians
adds a factor of (2*pi)/srate; so we've cancelled the internal 2*pi and table-length, and we have
an actual deviation of mfreq*2*pi*index/srate, which looks like FM; hmmm.  See <a href="#srcer">srcer</a>
below for an <a href="#src">src</a>-based way to do the same thing.
</p>

<p><a href="spectr.clm">spectr.clm</a> has a steady state spectra of
several standard orchestral instruments, courtesy of James A. Moorer.
The <a href="sndscm.html#drone">drone</a> instrument in clm-ins.scm uses table-lookup for the
bagpipe drone.  <a href="sndscm.html#twotab">two-tab</a> in the same file interpolates between two tables.
See also <a href="sndscm.html#granidoc">grani</a> and <a href="sndscm.html#displayscannedsynthesis">display-scanned-synthesis</a>.
</p>

<!-- PERHAPS: auto-freeze -->

<br><br>



<A NAME="waveshapedoc"></A>
<A NAME="polyshapedoc"></A>
<!-- ---------------------------------------- WAVESHAPE ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>waveshape</h3></center></td></tr></table>
<br>
<pre>
  <a class=def name="make-waveshape">make-waveshape</a> <a class=quiet href="#optional-key">:optional-key</a> (frequency 440.0) (partials '(1 1)) wave size
  <a class=def name="waveshape">waveshape</a> w :optional (index 1.0) (fm 0.0)
  <a class=def name="waveshape?">waveshape?</a> w

  <a class=def name="make-polyshape">make-polyshape</a> <a class=quiet href="#optional-key">:optional-key</a> 
     (frequency 440.0) (initial-phase 0.0) coeffs 
     (partials '(1 1)) 
     (kind mus-chebyshev-first-kind)
  <a class=def name="polyshape">polyshape</a> w :optional (index 1.0) (fm 0.0)
  <a class=def name="polyshape?">polyshape?</a> w

  <a class=def name="partialstowaveshape">partials-&gt;waveshape</a> <a class=quiet href="#optional-key">:optional-key</a> partials (size *clm-table-size*)
  <a class=def name="partialstopolynomial">partials-&gt;polynomial</a> partials :optional (kind mus-chebyshev-first-kind)
</pre>

<!-- LATEX: sceq16
\begin{align*}
&T_{n}(\cos \theta)=\cos n\theta \\
&U_{n}(\cos \theta)=\frac{\sin(n+1) \theta}{\sin \theta}
\end{align*}

A&S 22.3.15
-->

<p>waveshape and polyshape perform waveshaping; waveshaping drives a sum of Chebyshev polynomials with
a sinusoid, creating a sort of cross between additive synthesis and FM; see
"Digital Waveshaping Synthesis" by Marc Le Brun in JAES 1979 April, vol 27, no 4, p250.
The basic idea is:
</p>
<img src="sceq16.png" alt="Cheby eqs" hspace=40>
<p>
So, we can add scaled polynomials to get the spectrum we want;
in the simplest use, an inexpensive additive synthesis.  We can vary the peak amplitude of the
cos x to get effects similar to those of FM.  
</p>

<p>
waveshape uses an internal <a href="#table-lookup">table-lookup</a> generator, whereas polyshape uses
the <a href="#polynomial">polynomial</a> function.  The "kind" argument determines which kind of Chebyshev polynomial
is used internally:  mus-chebyshev-first-kind or mus-chebyshev-second-kind. (The <a href="#sum-of-cosines">sum-of-cosines</a> generator produces
Chebyshev polynomials of the fourth kind).
</p>

<table border=1 align=left hspace=40 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>waveshape methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>frequency in Hz</td></tr>
<tr><td><em class=gen>mus-phase</em></td><td>phase in radians</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>wave vct (no set!)</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>wave size (no set!)</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>frequency in radians per sample</td></tr>
</table>
<pre>
<br>
(let ((result (<a class=quiet href="#array-interp">array-interp</a> wave 
                (* (length wave) 
                   (+ 0.5 (* index 0.5 (sin phase)))))))
  (set! phase (+ phase (<a class=quiet href="#hztoradians">hz-&gt;radians</a> frequency) fm))
  result)

(let ((result (<a class=quiet href="#polynomial">polynomial</a> wave (sin phase))))
  (set! phase (+ phase (<a class=quiet href="#hztoradians">hz-&gt;radians</a> frequency) fm))
  result)
</pre>
<br clear=left>

<p>In its simplest use, waveshaping is additive synthesis:
</p>

<table border=0 hspace=40><tr>
<td bgcolor="#fafafa">
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (simp)
  (let ((wav (<em class=red>make-waveshape</em> 
               :frequency 440 
               :partials '(1 .5  2 .3  3 .2))))
    (do ((i 0 (1+ i))) ((= i 10000))
      (<a class=quiet href="#outa">outa</a> i (<em class=red>waveshape</em> wav) *output*))))
</pre>
</td>
<td>
<img src="waveshape.png" alt="waveshaping">
</td>
</tr></table>

<p>we can also use
partials-&gt;polynomial with polyshape;
bigbird is an example:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (bigbird start duration frequency freqskew amplitude freq-env amp-env partials)
  (let* ((beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> start))
         (end (+ beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> duration)))
         (gls-env (<a class=quiet href="#make-env">make-env</a> freq-env (<a class=quiet href="#hztoradians">hz-&gt;radians</a> freqskew) duration))
         (polyos (<em class=red>make-polyshape</em> frequency :coeffs (<em class=red>partials-&gt;polynomial</em> partials)))
         (fil (<a class=quiet href="#make-one-pole">make-one-pole</a> .1 .9))
         (amp-env (<a class=quiet href="#make-env">make-env</a> amp-env amplitude duration)))
    (<a class=quiet href="extsnd.html#run">run</a>
      (lambda ()
        (do ((i beg (1+ i)))
            ((= i end))
          (<a class=quiet href="#outa">outa</a> i 
            (<a class=quiet href="#one-pole">one-pole</a> fil   ; for distance effects
              (* (<a class=quiet href="#env">env</a> amp-env) 
                 (<em class=red>polyshape</em> polyos 1.0 (<a class=quiet href="#env">env</a> gls-env))))
            *output*))))))

(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> ()
  (bigbird 0 .05 1800 1800 .2
           '(.00 .00 .40 1.00 .60 1.00 1.00 .0)         ; freq env
           '(.00 .00 .25 1.00 .60 .70 .75 1.00 1.00 .0) ; amp env
           '(1 .5 2 1 3 .5 4 .1 5 .01)))                ; bird song spectrum
</pre>
</td></tr></table>

<p>
partials-&gt;waveshape with waveshape produces the same output as partials-&gt;polynomial with polyshape.
The <a href="sndscm.html#fmviolin">fm-violin</a> uses polyshape for the multiple FM section in some cases.
We can get single side-band spectra by using Chebyshev polynomials of the second kind.  
The <a href="sndscm.html#pqw">pqw</a> and <a href="sndscm.html#pqwvox">pqwvox</a> instruments use this
technique.  Here is a simplified example:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (pqw start dur spacing carrier partials)
  (let* ((spacing-cos (<a class=quiet href="#make-oscil">make-oscil</a> spacing (/ pi 2.0)))
	 (spacing-sin (<a class=quiet href="#make-oscil">make-oscil</a> spacing))
	 (carrier-cos (<a class=quiet href="#make-oscil">make-oscil</a> carrier (/ pi 2.0)))
	 (carrier-sin (<a class=quiet href="#make-oscil">make-oscil</a> carrier))
	 (sin-coeffs (<em class=red>partials-&gt;polynomial</em>
                       partials mus-chebyshev-second-kind))
	 (cos-coeffs (<em class=red>partials-&gt;polynomial</em>
                       partials mus-chebyshev-first-kind))
	 (beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> start))
	 (end (+ beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur))))
    (<a class=quiet href="extsnd.html#run">run</a> (lambda ()
     (do ((i beg (1+ i))) ((= i end))
       (let ((ax (<a class=quiet href="#oscil">oscil</a> spacing-cos)))
	 (<a class=quiet href="#outa">outa</a> i (- (* (<a class=quiet href="#oscil">oscil</a> carrier-sin) 
                       (<a class=quiet href="#oscil">oscil</a> spacing-sin) 
		       (<em class=red>polynomial</em> sin-coeffs ax))
		    (* (<a class=quiet href="#oscil">oscil</a> carrier-cos) 
		       (<em class=red>polynomial</em> cos-coeffs ax)))
	       *output*)))))))

(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> () (pqw 0 1 200.0 1000.0 '(2 .2  3 .3  6 .5)))
</pre>
</td><td>
<img src="pqw.png" alt="pqw example">
</td></tr></table>

<p>We can use waveshaping to make a band-limited triangle-wave:
</p>
<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(def-optkey-fun (make-band-limited-triangle-wave (frequency 440.0) (order 1))
  (let ((freqs '()))
    (do ((i 1 (1+ i))
	 (j 1 (+ j 2)))
	((&gt; i order))
      (set! freqs (cons (/ 1.0 (* j j)) (cons j freqs))))
    (<em class=red>make-waveshape</em> frequency :wave (<em class=red>partials-&gt;waveshape</em> (reverse freqs)))))

(define* (band-limited-triangle-wave gen :optional (fm 0.0))
  (<em class=red>waveshape</em> gen 1.0 fm))
</pre>
</td></tr></table>

<p>Band-limited square or sawtooth waves need sines (as opposed to cosines), so if
we absolutely insist on using waveshaping, we could do it this way:
</p>
<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (bl-saw start dur frequency order)
  (let* ((norm (if (= order 1) 1.0     ; these peak amps were determined empirically
                 (if (= order 2) 1.3   ;   actual limit is supposed to be pi/2 (G&amp;R 1.441)
                   (if (&lt; order 9) 1.7 ;   but Gibbs phenomenon pushes it to 1.851
                     1.9))))           ;   if order>25, numerical troubles -- use table-lookup
         (freqs '()))
    (do ((i 1 (1+ i)))
	((&gt; i order))
      (set! freqs (cons (/ 1.0 (* norm i)) (cons i freqs))))
    (let* ((ccos (<a class=quiet href="#make-oscil">make-oscil</a> frequency (/ pi 2.0)))
	   (csin (<a class=quiet href="#make-oscil">make-oscil</a> frequency))
	   (coeffs (<em class=red>partials-&gt;polynomial</em> (reverse freqs) mus-chebyshev-second-kind))
	   (beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> start))
	   (end (+ beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur))))
      (<a class=quiet href="extsnd.html#run">run</a> 
       (lambda ()
	 (do ((i beg (1+ i))) 
	     ((= i end))
	   (<a class=quiet href="#outa">outa</a> i (* (<a class=quiet href="#oscil">oscil</a> csin) 
                      (<em class=red>polynomial</em> coeffs (<a class=quiet href="#outa">oscil</a> ccos))) 
                 *output*)))))))
</pre></td></tr></table>

<p>Why does the high order give numerical problems?  The polynomials are related to each other
via the recursion: <img src="sceq17.png" alt="Cheby recurse" align=absmiddle>, so the first
few polynomials are:
</p>

<!-- LATEX:
\begin{align*}
&T_{0}(x)=1 \\
&T_{1}(x)=x \\
&T_{2}(x)=2x^{2}-1\\
&T_{3}(x)=4x^{3}-3x \\
&T_{4}(x)=8x^{4}-8x^{2}+1
\end{align*}

\begin{align*}
&U_{0}(x)=1 \\
&U_{1}(x)=2x \\
&U_{2}(x)=4x^{2}-1 \\
&U_{3}(x)=8x^{3}-4x \\
&U_{4}(x)=16x^{4}-12x^{2}+1
\end{align*}

-->

<table border=0 hspace=40><tr>
<td><img src="sceq18.png" alt="some Chebys"></td>
<td width=20></td>
<td><img src="sceq19.png" alt="more Chebys"></td>
</tr></table>

<p>The first coefficient is 2^n or 2^(n-1).  This is bad news if "n" is large because
we are expecting a bunch of huge numbers 
to add up to something in the vicinity of 0.0 or 1.0.  
If we're using 32-bit floats, the first sign of trouble comes when the order is around 26.
If you look at some of the coefficients, you'll see numbers like -129026688.000 (in the 32 bit case), which
should be -129026680.721 --  we have run out of bits in the mantissa!
Even if we build Snd --with-doubles, 
we can only push the order up to around 46. 
</p>

<br><br>




<A NAME="sawtoothdoc"></A>
<!-- ---------------------------------------- SAWTOOTH ETC ---------------------------------------- -->

<table width="70%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>sawtooth-wave, triangle-wave, pulse-train, square-wave</h3></center></td></tr></table>
<br>
<pre>
  <a class=def name="make-triangle-wave">make-triangle-wave</a> <a class=quiet href="#optional-key">:optional-key</a> (frequency 440.0) (amplitude 1.0) (initial-phase pi)
  <a class=def name="triangle-wave">triangle-wave</a> s :optional (fm 0.0)
  <a class=def name="triangle-wave?">triangle-wave?</a> s

  <a class=def name="make-square-wave">make-square-wave</a> <a class=quiet href="#optional-key">:optional-key</a> (frequency 440.0) (amplitude 1.0) (initial-phase 0)
  <a class=def name="square-wave">square-wave</a> s :optional (fm  0.0)
  <a class=def name="square-wave?">square-wave?</a> s

  <a class=def name="make-sawtooth-wave">make-sawtooth-wave</a> <a class=quiet href="#optional-key">:optional-key</a> (frequency 440.0) (amplitude 1.0) (initial-phase pi)
  <a class=def name="sawtooth-wave">sawtooth-wave</a> s :optional (fm 0.0)
  <a class=def name="sawtooth-wave?">sawtooth-wave?</a> s

  <a class=def name="make-pulse-train">make-pulse-train</a> <a class=quiet href="#optional-key">:optional-key</a> (frequency 440.0) (amplitude 1.0) (initial-phase (* 2 pi))
  <a class=def name="pulse-train">pulse-train</a> s :optional (fm 0.0)
  <a class=def name="pulse-train?">pulse-train?</a> s
</pre>

<table border=1 align=left hspace=40 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>saw-tooth and friends' methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>frequency in Hz</td></tr>
<tr><td><em class=gen>mus-phase</em></td><td>phase in radians</td></tr>
<tr><td><em class=gen>mus-scaler</em></td><td>amplitude arg used in make-&lt;gen&gt;</td></tr>
<tr><td><em class=gen>mus-width</em></td><td>width of square-wave pulse (0.0 to 1.0)</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>frequency in radians per sample</td></tr>
</table>
<pre>
<br>
One popular kind of vibrato is:
  (+ (triangle-wave pervib) 
     (<a class=quiet href="#rand-interp">rand-interp</a> ranvib))
</pre><br clear=left>

<p>These generators produce some standard old-timey wave forms that are still occasionally useful (well, triangle-wave
is useful; the others are silly).
sawtooth-wave ramps from -1 to 1, then goes immediately back to -1.
Use a negative frequency to turn the "teeth" the other way.
triangle-wave ramps from -1 to 1, then ramps from 1 to -1.
pulse-train produces a single sample of 1.0, then zeros.
square-wave produces 1 for half a period, then 0.  All have a period
of two pi, so the "fm" argument should have an effect comparable to the
same FM applied to the same waveform in <a href="#table-lookup">table-lookup</a>.
These do not produce band-limited output; if the frequency is too high, you can get foldover.
A more reasonable square-wave can be generated via
<code>(tanh (* n (sin theta)))</code>, where "n" (a float) sets how squared-off it is:
</p>

<table border=1 hspace=20 vspace=10>
<tr>
<td bgcolor="#f6f8ff"><center>n: 1.0</center></td>
<td width=16></td>
<td bgcolor="#f6f8ff"><center>n: 3.0</center></td>
<td width=16></td>
<td bgcolor="#f6f8ff"><center>n: 100.0</center></td>
</tr>
<tr>
<td>
<img src="tanh1.png" alt="tanh 1">
</td>
<td width=16></td>
<td>
<img src="tanh3.png" alt="tanh 1">
</td>
<td width=16></td>
<td>
<img src="tanh100.png" alt="tanh 1">
</td></tr></table>

<!-- LATEX: \tanh(x) = x-\frac{x^{3}}{3}+\frac{2x^{5}}{15}-\frac{17x^{7}}{315}+\frac{62x^{9}}{2835}-\frac{1382x^{11}}{155925}\cdots -->
<!-- LATEX: 
\tanh(\sin(x)) = 140069/172800 \sin(x) + 13319/241920 \sin(3x) + 1973/483840 \sin(5x) + 799/1451520 \sin(7x) - 71/7257600 \sin(9x) + 691/79833600 \sin(11x) + \cdots -->

<center>
<table hspace=50 border=1 vspace=10 cellpadding=8 width="70%">
<tr><td>
<p>The spectrum of tanh(sin) can be obtained by expanding tanh as a power series:
</p>
<img src="sceq11.png" alt="tanh power series" hspace=20>
<p>
plugging in "sin" for "x", expanding the sine powers, and collecting terms (very tedious!):
</p>
<img src="sceq12.png" alt="tanh sin power series" hspace=20>
<p>
which is promising since a square wave is made up of odd harmonics with amplitude 1/n.
As the "n" in tanh(n sin(x)) increases, this series doesn't apply, but we can check the
formula for tanh, and see that the e^-x term will vanish (in the positive x case), giving 1.0.
So we do get a square wave, but it's not band limited.  If a complex signal replaces the sin(x),
we get "intermodulation products" (sum and difference tones).  
</p>
<p>
(It is reassuring after all that
arithmetic that 13319/241920 / 140069/172800 is 0.068 -- we got
.070 in the fft above, and 1973/483840 / 140069/172800 is 0.005 --
we got .006).
</p>
</td></tr></table>
</center>

<p>Another choice is ecos in generators.scm, based on atan; as its "a" parameter approaches 0.0, you get closer to a square wave.
Even more amusing is this algorithm:
<img src="sceq13.png" alt="square" align=absmiddle hspace=10>
<!-- CMJ 37 4 sept 2006 p326 -->
<!-- LATEX: \frac{(c+1)^{\cos t}-(c-1)^{\cos t}}{(c+1)^{\cos t}+(c-1)^{\cos t}} -->

</p>
<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(define (cossq c theta)   ; as c -&gt; 1.0+, more of a square wave (try 1.00001)
  (let* ((cs (cos theta)) ; (+ theta pi) if matching sin case (or (- ...))
	 (cp1 (+ c 1.0))
	 (cm1 (- c 1.0))
	 (cm1c (expt cm1 cs))
	 (cp1c (expt cp1 cs)))
    (/ (- cp1c cm1c)
       (+ cp1c cm1c))))  ; from "From Squares to Circles..." Lasters and Sharpe, Math Spectrum 38:2

(define (sinsq c theta) (cossq c (- theta (* 0.5 pi))))
(define (sqsq c theta) (sinsq c (- (sinsq c theta)))) ; a sharper square wave

(let ((angle 0.0))
  (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (lambda (y)
                 (let ((val (* 0.5 (+ 1.0 (sqsq 1.001 angle))))) 
                   (set! angle (+ angle .02)) 
                   val))))
</pre>
</td></tr></table>

<p>In these generators, the "fm" argument is useful mainly for various sci-fi sound effects:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(define (tritri start dur freq amp index mcr)
  (let* ((beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> start))
	 (end (+ beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur)))
	 (carrier (<em class=red>make-triangle-wave</em> freq))
	 (modulator (<em class=red>make-triangle-wave</em> (* mcr freq))))
    (<a class=quiet href="extsnd.html#run">run</a>
     (lambda ()
       (do ((i beg (1+ i)))
	   ((= i end))
	 (<a class=quiet href="#outa">outa</a> i (* amp (<em class=red>triangle-wave</em> carrier 
                          (* index (<em class=red>triangle-wave</em> modulator)))) 
               *output*))))))

(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> (:srate 44100) (tritri 0 1 1000.0 0.5 0.1 0.01)) ; sci-fi laser gun
(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> (:srate 44100) (tritri 0 1 4000.0 0.7 0.1 0.01)) ; a sparrow?
</pre>
</td></tr></table>

<p>I think just about every combination of oscil/triangle-wave/sawtooth-wave/square-wave has been
used.  Even triangle-wave(square-wave) can make funny noises. Along these lines, there's
a <a href="sndscm.html#blsaw">band-limited sawtooth</a> generator in generators.scm, 
band-limited-triangle-wave above (waveshaping), and band-limited pulse-train via <a href="#sum-of-cosines">sum-of-cosines</a>.
</p>

<br><br>



<A NAME="sum-of-cosinesdoc"></A>
<!-- ---------------------------------------- SUM-OF-COSINES ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>sum-of-cosines</h3></center></td></tr></table>
<br>
<pre>
  <a class=def name="make-sum-of-cosines">make-sum-of-cosines</a> <a class=quiet href="#optional-key">:optional-key</a> (cosines 1) (frequency 440.0) (initial-phase 0.0)
  <a class=def name="sum-of-cosines">sum-of-cosines</a> cs :optional (fm 0.0)
  <a class=def name="sum-of-cosines?">sum-of-cosines?</a> cs
</pre>
<p>sum-of-cosines produces a band-limited pulse train containing
"cosines" cosines.  I think this was originally viewed as a way to get a speech-oriented
pulse train that would then be passed through formant filters (see pulse-voice in examp.scm).  There are many similar formulas:
see <a href="#fejer">fejer</a> and friends in generators.scm. "Trigonometric Delights" by Eli Maor has
a derivation of a sum-of-sines formula and a neat
geometric explanation.  For a derivation of the sum-of-cosines formula, see "Fourier
Analysis" by Stein and Shakarchi, or (in the formula given below) multiply the left side (the cosines) by sin(x/2), use the trig
formula 2sin(a)cos(b) = sin(b+a)-sin(b-a), and notice that all the terms in the series
cancel except the last.
</p>

<table border=1 align=left hspace=40 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>sum-of-cosines methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>frequency in Hz</td></tr>
<tr><td><em class=gen>mus-phase</em></td><td>phase in radians</td></tr>
<tr><td><em class=gen>mus-scaler</em></td><td>(/ 1.0 cosines)</td></tr>
<tr><td><em class=gen>mus-cosines</em></td><td>cosines arg  used in make-&lt;gen&gt;</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>same as mus-cosines</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>frequency in radians per sample</td></tr>
</table>
<pre>
<br>
based on:
<!-- LATEX: \sum_{k=0}^{n}\cos kx = \frac{1}{2}\Bigg(1+\frac{\sin(n+\frac{1}{2})x}{\sin \frac{x}{2}}\Bigg) -->
<img src="sceq2.png" alt="sum of cosines" hspace=40>
<!--
  cos(x) + cos(2x) + ... cos(nx) = 
    (sin((n + .5)x) / (2 * sin(x / 2))) - 1/2
-->
known as the Dirichlet kernel
see also cosine-summation, fejer-sum, etc in dsp.scm
</pre><br clear=left>

<br>
<table border=0 hspace=40>
<tr>
<td bgcolor="#fafafa">
<pre>
(define (simple-soc beg dur freq amp)
  (let* ((os (<em class=red>make-sum-of-cosines</em> 10 freq 0.0))
	 (start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> beg))
	 (end (+ start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur))))
    (<a class=quiet href="extsnd.html#run">run</a>
     (lambda ()
       (do ((i start (1+ i))) ((= i end))
	 (outa i (* amp (<em class=red>sum-of-cosines</em> os)) 
               *output*))))))

(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> () (simple-soc 0 1 100 1.0))
</pre></td>
<td>
<img src="cosines.png" alt="sum of cosines example" hspace=10>
</td></tr></table>

<p>Almost identical is the following <A NAME="sinc-train">sinc-train</a> generator:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>(define* (make-sinc-train :optional (frequency 440.0) (width #f))
  (let ((range (or width (* pi (- (* 2 (inexact-&gt;exact (floor (/ (<a class=quiet href="#mussrate">mus-srate</a>) (* 2.2 frequency))))) 1)))))
    ;; 2.2 leaves a bit of space before srate/2, (* 3 pi) is the minimum width, normally
    (list (- (* range 0.5))
	  range
	  (/ (* range frequency) (<a class=quiet href="#mussrate">mus-srate</a>)))))
	
(define* (sinc-train gen :optional (fm 0.0))
  (let* ((ang (car gen))
	 (range (cadr gen))
	 (top (* 0.5 range))
	 (frq (caddr gen))
	 (val (if (= ang 0.0) 1.0 (/ (sin ang) ang)))
	 (new-ang (+ ang frq fm)))
    (if (&gt; new-ang top)
	(list-set! gen 0 (- new-ang range))
	(list-set! gen 0 new-ang))
    val))
</pre></td></tr></table>

<p>If you sweep sum-of-cosines upwards in frequency, you'll eventually
get foldover; the generator produces its preset number of cosines no
matter what.  It is possible to vary the spectrum smoothly:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td><pre>
(let ((os (<em class=red>make-sum-of-cosines</em> 4 100.0))
      (pow (make-env '(0 1.0 1 30.0) :end 10000))) ; our "index" envelope in FM jargon
   (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (lambda (y) 
		  (let ((val (<em class=red>sum-of-cosines</em> os 0.0))) 
		    (* (signum val) 
		       (expt (abs val) (env pow)))))))
</pre></td></tr></table>
<p>This trick works on all the <a href="#fejer">pulse-train</a> functions in generators.scm (or an oscil for that matter!), 
but perhaps a filter is a simpler approach.  There are a lot more of these "kernels" in generators.scm.
</p>

<table border=1 hspace=20 cellspacing=4>
<tr>
<td bgcolor="#f6f8ff"><center>fejer (n=10)</center></td>
<td bgcolor="#f6f8ff"><center>poussin (n=5)</center></td>
<td bgcolor="#f6f8ff"><center>jackson (n=10)</center></td>
</tr><tr>
<td><img src="fejer.png" alt="fejer sum"></td>
<td><img src="poussin.png" alt="poussin sum"></td>
<td><img src="jackson.png" alt="jackson sum"></td>
</tr><tr><td height=8 colspan=3></td>
</tr><tr>
<td bgcolor="#f6f8ff"><center>legendre (n=5)</center></td>
<td bgcolor="#f6f8ff"><center>kosine (n=5, r=0.5)</center></td>
<td bgcolor="#f6f8ff"><center>kosine (n=1, r=0.95)</center></td>
</tr><tr>
<td><img src="legendre.png" alt="legendre sum"></td>
<td><img src="kosine.png" alt="kosine sum"></td>
<td><img src="kosine95.png" alt="kosine95 sum"></td>
</tr></table>

<!--
fejer-sum: fejer.png (10)
poussin (5)
legendre (5)
jackson (10)


(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> ()
  (let ((freq (hz->radians 100.0)))
    (do ((i 0 (1+ i))
	 (angle 0.0 (+ angle freq)))
	((= i 22050))
      (outa i (fejer-sum angle 10) *output*))))

(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> ()
(let ((gen (make-kosine-summation 100.0))) 
    (do ((i 0 (1+ i)))
	((= i 22050))
      (outa i (kosine-summation gen 0.5 5.0) *output*))))


kosine95
(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> ()
(let ((gen (make-kosine-summation 100.0))) 
    (do ((i 0 (1+ i)))
	((= i 22050))
      (outa i (kosine-summation gen 0.95 1.0) *output*))))
-->


<br><br>



<A NAME="sine-summationdoc"></A>
<!-- ---------------------------------------- SINE-SUMMATION ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>sine-summation</h3></center></td></tr></table>
<br>
<pre>
  <a class=def name="make-sine-summation">make-sine-summation</a> <a class=quiet href="#optional-key">:optional-key</a> (frequency 440.0) (initial-phase 0.0) (n 1) (a .5) (ratio 1.0)
  <a class=def name="sine-summation">sine-summation</a> s :optional (fm 0.0)
  <a class=def name="sine-summation?">sine-summation?</a> s
</pre>

<table align=left border=1 cellpadding=4 hspace=20>
<tr><td colspan=2 bgcolor="beige"><center>sine-summation methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>frequency in Hz</td></tr>
<tr><td><em class=gen>mus-phase</em></td><td>phase in radians</td></tr>
<tr><td><em class=gen>mus-scaler</em></td><td>"a" parameter; sideband scaler</td></tr>
<tr><td><em class=gen>mus-cosines</em></td><td>"n" parameter</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>frequency in radians per sample</td></tr>
<tr><td><em class=gen>mus-offset</em></td><td>"ratio" parameter</td></tr>
</table>
<br>
<pre>
based on:
<img src="sceq8.png" alt="sine summation formula" hspace=10 vspace=10>
</pre>
<br clear=left>

<p>sine-summation produces a kind of additive synthesis.
See J.A.Moorer, "Signal Processing Aspects of Computer Music" and "The
Synthesis of Complex Audio Spectra by means of Discrete Summation Formulae"
(Stan-M-5).  "n" is the number of sidebands (0 gives a sine wave), "a" is the amplitude
ratio between successive sidebands (don't set it to 1.0), and "ratio" is the ratio between the
carrier frequency and the spacing between successive sidebands.
A "ratio" of 2 would give odd-numbered harmonics for a (vaguely) clarinet-like sound.
The basic idea is very similar to that used in the
<a href="#sum-of-cosines">sum-of-cosines</a> generator, but you have control of the
fall-off of the spectrum and the spacing of the partials.
</p>

<p>The peak amplitude of this generator is very hard to predict, and Moorer's suggested normalization
is not helpful.  See the code (clm.c) for a long comment.  If "a" &lt; 1.0, the output will never go over 1.0, but
it also will almost never reach that peak either.  
Besides the usual FM input, you can also vary the "a" parameter (via mus-scaler) to get changing spectra.  In the
next example, we add a glissando envelope, and use the same envelope to vary "a" so that as the frequency
goes up, "a" goes down (to avoid foldover, or whatever).
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (ss beg dur freq amp :optional (N 1) (a .5) (B-ratio 1.0) (frqf #f))
  (let* ((st (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> beg))
         (nd (+ st (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur)))
         (sgen (<em class=red>make-sine-summation</em> :n N :a a :ratio B-ratio :frequency freq))
	 (frq-env (if frqf (<a class=quiet href="#make-env">make-env</a> frqf :scaler (<a class=quiet href="#hztoradians">hz-&gt;radians</a> freq) :duration dur) #f))
	 (spectr-env (if frqf (<a class=quiet href="#make-env">make-env</a> frqf :duration dur) #f))
	 (amp-env (<a class=quiet href="#make-env">make-env</a> '(0 0 1 1 2 1 3 0) :scaler amp :duration dur)))
    (<a class=quiet href="extsnd.html#run">run</a>
     (lambda ()
       (do ((i st (1+ i))) 
	   ((= i nd))
	 (if spectr-env
	     (set! (<em class=red>mus-scaler</em> sgen) (* a (exp (- (<a class=quiet href="#env">env</a> spectr-env))))))
         (<a class=quiet href="#outa">outa</a> i (* (<a class=quiet href="#env">env</a> amp-env)
		    (<em class=red>sine-summation</em> sgen (if frq-env (<a class=quiet href="#env">env</a> frq-env) 0.0)))
	       *output*))))))

(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> () (ss 0 1 400.0 1.0 5 0.5 1.0 '(0 0 1 2)))
</pre>
</td></tr></table>

<p>
There are some surprising sounds lurking in this generator; a sonata for moped, anyone?
</p>

<br><br>



<A NAME="sum-of-sinesdoc"></A>
<!-- ---------------------------------------- SUM-OF-SINES ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>sum-of-sines</h3></center></td></tr></table>
<br>
<pre>
  <a class=def name="make-sum-of-sines">make-sum-of-sines</a> <a class=quiet href="#optional-key">:optional-key</a> (sines 1) (frequency 440.0) (initial-phase 0.0)
  <a class=def name="sum-of-sines">sum-of-sines</a> cs :optional (fm 0.0)
  <a class=def name="sum-of-sines?">sum-of-sines?</a> cs
</pre>
<p>sum-of-sines produces a sum of sines.  It is very similar (good and bad) to <a href="#sum-of-cosines">sum-of-cosines</a>.
</p>
<table border=1 align=left hspace=40 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>sum-of-sines methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>frequency in Hz</td></tr>
<tr><td><em class=gen>mus-phase</em></td><td>phase in radians</td></tr>
<tr><td><em class=gen>mus-scaler</em></td><td>dependent on number of sines</td></tr>
<tr><td><em class=gen>mus-cosines</em></td><td>sines arg  used in make-&lt;gen&gt;</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>same as mus-cosines</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>frequency in radians per sample</td></tr>
</table>
<pre>
<br>
based on:
<!-- LATEX: \sum_{k=1}^{n}\sin kx = \frac{\sin\frac{n+1}{2}x \: \sin\frac{nx}{2}}{\sin\frac{x}{2}} -->
<img src="sceq1.png" alt="sum of sines" hspace=40>
<!--
  sin(x) + sin(2x) + ... sin(nx) = 
    sin(n * x / 2) * (sin((n + .5)x) / sin(x / 2))
-->
known as the conjugate Dirichlet kernel
</pre><br clear=left>

<p>See also the <a href="#sine-summation">sine-summation</a> generator, 
and generators.scm.
The original motivation for this generator was the restriction that the sine-summation generator's ratio ("a") can't be 1.0.
But it's so easy to define a generator, that I'm sorry I made sum-of-sines a built-in case.
For example, here is a generator based on a formula giving a sum of n odd sines:
</p>

<A NAME="sumofoddsines"></A>
<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(define (make-sum-of-odd-sines frequency n)
  (vct 0.0 (<a class=quiet href="#hztoradians">hz-&gt;radians</a> frequency) (exact-&gt;inexact n)))

(define (sum-of-odd-sines gen fm)
  (let* ((angle (<a class=quiet href="extsnd.html#vctref">vct-ref</a> gen 0))
	 (a2 (* angle 0.5))
	 (n (<a class=quiet href="extsnd.html#vctref">vct-ref</a> gen 2))
	 (den (* n (sin a2)))
	 (result (if (&lt; (abs den) 1.0e-9)
		     0.0
		     (/ (* (sin (* n a2)) 
			   (sin (* (1+ n) a2)))
			den))))
    (<a class=quiet href="extsnd.html#vctset">vct-set!</a> gen 0 (+ (<a class=quiet href="extsnd.html#vctref">vct-ref</a> gen 0) (<a class=quiet href="extsnd.html#vctref">vct-ref</a> gen 1) fm))
    result))
</pre>
</td></tr></table>

<!-- LATEX:
\small
\begin{align*}
&\sum_{k=0}^{n}\sin(x+ky)=\frac{\sin\Big(x+\frac{n-1}{2}y\Big)\sin\frac{ny}{2}}{\sin\frac{y}{2}} \\
&\sum_{k=0}^{n}\cos(x+ky)=\frac{\cos\Big(x+\frac{n-1}{2}y\Big)\sin\frac{ny}{2}}{\sin\frac{y}{2}} \\
&\sum_{k=0}^{2n-1}(-1)^{k}\cos(x+ky)=\frac{\sin\Big(x+\frac{2n-1}{2}y\Big)\sin ny}{\cos\frac{y}{2}} \\
&\sum_{k=0}^{2n-1}(-1)^{k}\sin(x+ky)=\frac{\sin\Big(x+\frac{n-1}{2}(y+\pi)\Big)\sin\frac{n(y+\pi)}{2}}{\cos\frac{y}{2}} \\
&\sum_{k=1}^{n}\sin(2k-1)x=\frac{\sin^{2}nx}{\sin x} \\
&\sum_{k=1}^{n}\cos(2k-1)x=\frac{1}{2}\frac{\sin 2nx}{\sin x} \\
&\sum_{k=1}^{n}(-1)^{k}\cos kx=-\frac{1}{2}+\frac{(-1)^{n}\cos(\frac{2n+1}{2}x)}{2\cos\frac{x}{2}} \\
&\sum_{k=1}^{n}(-1)^{k+1}\sin(2k-1)x = (-1)^{n+1}\frac{\sin 2nx}{2\cos x} \\
&\sum_{k=1}^{n-1}k\sin kx=\frac{\sin nx}{4 \sin^{2}\frac{x}{2}} - \frac{n \cos \frac{2n-1}{2}x}{2\sin\frac{x}{2}} \\
&\sum_{k=1}^{n-1}k\cos kx=\frac{n\sin\frac{2n-1}{2}x}{2\sin\frac{x}{2}} - \frac{1-\cos nx}{4\sin^{2}\frac{x}{2}} \\
&\sum_{k=1}^{\infty} \frac{\sin^{2k} x}{k} = -2 \ln \cos x & (x^{2} < \frac{pi^{2}}{4}) \\

&\sum_{k=1}^{n-1}p^{k}\sin kx=\frac{p\sin x - p^{n}\sin nx + p^{n+1}\sin(n-1)x}{1-2p\cos x+p^{2}} \\
&\sum_{k=0}^{n-1}p^{k}\cos kx=\frac{1-p\cos x - p^{n}\cos nx + p^{n+1}\cos(n-1)x}{1-2p\cos x + p^{2}} \\
&\sum_{k=1}^{\infty}p^{k}\sin kx=\frac{p\sin x}{1-2p\cos x + p^{2}} \\
&\sum_{k=1}^{\infty}p^{k}\cos kx=\frac{1-p\cos x}{1-2p\cos x + p^{2}} \\
&\sum_{k=1}^{\infty}\frac{p^{k}\sin kx}{k} = \arctan \frac{p\sin x}{1-p\cos x} \\
&\sum_{k=1}^{\infty}\frac{p^{k}\cos kx}{k} = \ln \frac{1}{\sqrt{1-2p\cos x + p^{2}}} \\
&\sum_{k=1}^{\infty}\frac{p^{2k-1}\sin(2k-1)x}{2k-1} = \frac{1}{2}\arctan \frac{2p\sin x}{1-p^{2}} \\
&\sum_{k=1}^{\infty}\frac{p^{2k-1}\cos(2k-1)x}{2k-1} = \frac{1}{4}\ln \frac{1+2p\cos x + p^{2}}{1-2p\cos x + p^{2}} \\
&\sum_{k=1}^{\infty}\frac{p^{k}\sin kx}{k!} = e^{p\cos x}\sin(p\sin x) \\
&\sum_{k=0}^{\infty}\frac{p^{k}\cos kx}{k!} = e^{p\cos x}\cos(p\sin x) \\
&\sum_{k=1}^{\infty}e^{-kt}\sin kx = \frac{1}{2}\frac{\sin x}{\cosh t - \cos x} \\
&1 + 2\sum_{k=1}^{\infty}e^{-kt}\cos kx = \frac{\sinh t}{\cosh t - \cos x} \\
\end{align*}

\begin{align*}
&\sum_{k=1}^{\infty} \frac{\sin kx}{2^{k-1}} = \frac{4\sin x}{5 - 4\cos x} \\
&\sum_{k=1}^{\infty} \frac{e^{(2k-1)a}\cos(2k-1)x}{2k-1} = -\frac{1}{2}\arctan \bigg(\frac{\cos x}{\sinh a}\bigg) \\
&\cos x + \frac{1}{2}\frac{\cos 3x}{3} + \frac{1 \cdot 3}{2 \cdot 4}\frac{\cos 5x}{5}\cdots = \frac{1}{2}\arccos(1 - 2\sin x) & (0\leq x \leq \pi?) \\
\end{align*}

\begin{align*}
&\sum_{k=0}^{\infty} \frac{a^{2k}\cos 2kx}{(2k)!} = \cosh(a \cos x) \cos (a \sin x) & (a^{2}<1) \\
&\sum_{k=1}^{\infty} \frac{a^{2k}\sin 2kx}{(2k)!} = \sinh(a \cos x) \sin (a \sin x) & (a^{2}<1) \\
&\frac{1}{a} + 2a \sum_{k=1}^{\infty} \frac{\cos kx}{a^{2}+k^{2}} = \pi \frac{\cosh a(\pi-x)}{\sinh a\pi} & (0 \leq x \leq 2\pi)\\
\end{align*}

sceq23 (old):
& \ln (1 - 2xt + t^{2})^{-1} = 2 \sum_{n=1}^{\infty} \frac{t^{n}}{n} T_{n}(x) \\
& (1 - 2xt + t^{2})^{-1} = \frac{1}{\sqrt{1 - x^{2}}} \sum_{n=0}^{\infty} t^{n} U_{n+1}(x) \\
& e^{z cos x}J_{\nu-\frac{1}{2}}(z \sin x) = \frac{\Gamma(\nu)}{\Gamma(\frac{1}{2})}(2 \sin x)^{\nu-\frac{1}{2}} \sum_{k=0}^{\infty}\frac{z^{\nu+k-\frac{1}{2}}}{\Gamma(2\nu + k)} \mathrm{C}^{\nu}_{k}(\cos x)

sceq25 old:
\sum_{n=0}^{\infty} r^{n} \sum_{k=0}^{\infty} \sin (k+1/2)\theta = \frac{(1+r)\sin(\theta / 2)}{(1-r)(1-2r\cos\theta + r^{2})}

sceq26 old:
\sum_{n=0}^{\infty} r^{n} \sum_{k=0}^{\infty} (n+1-k)\sin (k+1)\theta = \frac{\sin\theta}{(1-r)^{2}(1-2r\cos\theta + r^{2})}

sceq7:
&\sum_{k=1}^{\infty} \frac{\cos kx}{k} = -\ln \big(2 \sin \frac{x}{2}\big)  & (0\leq x \leq \pi) \\

sceq27:
1 + 2 &\sum_{n=1}^{\infty} \frac{(-a + \sqrt{a^{2} - b^{2}})^{n} \cos nx}{b^{n}} = \frac{\sqrt{a^{2} - b^{2}}}{a + b \cos x} & (b < a, a \neq 0) \\

sceq25:
&\sum_{k=1}^{\infty} k r^{k} \sin kx = \frac{r(1-r^{2})\sin x}{(1 - 2r\cos x + r^{2})^{2}}
Z 352

sceq26:
& \frac{8}{\pi} \sum_{k=1}^{\infty} \frac{\sin^{2}kx}{4k^{2}-1} = |\sin x|

-->

<table border=1 hspace=20 vspace=10><tr><td>
<table border=0 hspace=40 vspace=10>
<tr><td colspan=3 bgcolor="#f6f8ff"><center><h4>various sums</h4></center></td></tr>


<tr>
<td><img src="sceq14.png" alt="many sums">
</td>
<td width=40></td>
<td><img src="sceq15.png" alt="many more sums">
</td>
</tr>

<tr><td colspan=3 bgcolor="#eefdee"><center>from Gradshteyn and Ryzhik, "Table of Integrals, Series, and Products", 1.341.., 1.352.., 1.447.., 1.461, 1.518</center></td></tr>
<tr><td colspan=3 height=25></td></tr>


<!-- too complicated!
<tr><td colspan=3><img src="sceq7.png" alt="kosines" align=absmiddle hspace=10></td></tr>
<tr><td colspan=3 bgcolor="#eefdee"><center>from Askey, "Ramanujan and Hypergeometric Series"</center></td></tr>
<tr><td colspan=3 height=25></td></tr>
-->

<tr><td><img src="sceq20.png" alt="more sums"></td><td></td>
<td><img src="sceq21.png" alt="more sums"></td></tr>
<tr><td colspan=3 bgcolor="#eefdee"><center>from Jolley, "Summation of Series", 521 587 620 635 638 728</center></td></tr>
<tr><td colspan=3 height=25></td></tr>



<tr><td><img src="sceq25.png" alt="more sums"></td><td></td>
<td><img src="sceq26.png" alt="more sums"></td></tr>
<tr><td colspan=3 bgcolor="#eefdee"><center>from Zygmund, "Trigonometric Series" p34, 352</center></td></tr>
<tr><td colspan=3 height=25></td></tr>


<!--  argh! there's a mistake in the formula -- I think they meant one sum not two
<tr><td><img src="sceq2n.png" alt="more sums"></td><td></td>
<td><img src="sceq2n.png" alt="more sums"></td></tr>
<tr><td colspan=3 bgcolor="#eefdee"><center>from Andrews, Askey, Roy, "Special Functions" p396</center></td></tr>
<tr><td colspan=3 height=25></td></tr>
-->

<!-- these are basically the same as p^k/k cases using ln in G&R
<tr><td><img src="sceq23.png" alt="more sums"></td><td></td>
<td><img src="sceq24.png" alt="more sums"></td></tr>
<tr><td colspan=3 bgcolor="#eefdee"><center>from Wong and Guo, "Special Functions"</center></td></tr>
<tr><td colspan=3 height=25></td></tr>
-->


<!-- 23 and 24 are unused (and 28/29 if they exist) -->


<tr><td><img src="sceq7.png" alt="more sums"></td><td></td>
<td><img src="sceq27.png" alt="more sums"></td></tr>
<tr><td colspan=3 bgcolor="#eefdee"><center>from Sansone, "Orthogonal Functions"</center></td></tr>


</table>

</td></tr></table>

<!-- PERHAPS: Bateman -->

<p>
A few of these exist as generators, but, as far as I know, most have never been explored.
Don't shy away from the sums to infinity just because you've heard shouting about "band-limited waveforms" -- FM is also such a sum:
</p>


<!-- LATEX:
\small
\begin{align*}
& \cos(B \sin x) = J_{0}(B) + 2 \sum_{k=1}^{\infty} J_{2k}(B) \cos 2kx \\
& \cos(B \cos x) = J_{0}(B) + 2 \sum_{k=1}^{\infty} (-1)^{k} J_{2k}(B) \cos 2kx \\
& \sin(B \sin x) = 2 \sum_{k=0}^{\infty} J_{2k+1}(B) \sin (2k+1)x \\
& \sin(B \cos x) = 2 \sum_{k=0}^{\infty} (-1)^{k} J_{2k+1}(B) \cos (2k+1)x \\
\end{align*}
-->


<table border=1 hspace=40 vspace=20><tr><td>
<table border=0 hspace=20>
<tr><td>
<img src="fmeq49.png" alt="cos cos cases">
</td><td width=20></td>
<td>
<img src="fmeq50.png" alt="cos cos cases">
</td>
</tr></table>
</td></tr></table>


<p>
It is not hard to goof around with formulas like these;
take the last one in the G&amp;R section:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#def-clm-struct">def-clm-struct</a> (expcs 
		 :make-wrapper (lambda (g)
				 (if (&lt;= (expcs-et g) 0.0) (set! (expcs-et g) 0.00001))
				 (set! (expcs-frequency g) (<a class=quiet href="#hztoradians">hz-&gt;radians</a> (expcs-frequency g)))
				 (set! (expcs-sinht g) (* 0.5 (sinh (expcs-et g))))
				 (set! (expcs-cosht g) (cosh (expcs-et g)))
				 g))
  frequency phase et sinht cosht)

(define (expcs gen fm)
  (<a class=quiet href="extsnd.html#declare">declare</a> (gen expcs) (fm float))
  (let ((result (- (/ (expcs-sinht gen) 
		      (- (expcs-cosht gen) (cos (expcs-phase gen))))
		   0.5)))
    (set! (expcs-phase gen) (+ (expcs-phase gen) (expcs-frequency gen) fm))
    result))

;; see if it generates cosines at amplitudes (exp (- (* k t)))
(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> ()
  (let ((gen (make-expcs :frequency 100 :et 1.0)))
    (do ((i 0 (1+ i)))
	((= i 10000))
      (<a class=quiet href="#outa">outa</a> i (expcs gen 0.0) *output*))))

;; change "t" during note -- smoothly changing sum-of-cosines spectra
(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> ()  
  (let ((gen (make-expcs :frequency 100 :et 0.1))
	(t-env (<a class=quiet href="#make-env">make-env</a> '(0 .1 1 2) :end 10000)))
    (<a class=quiet href="extsnd.html#run">run</a> (lambda ()
      (do ((i 0 (1+ i)))
	  ((= i 10000))
        (let ((et (<a class=quiet href="#env">env</a> t-env)))
	  (set! (expcs-sinht gen) (* 0.5 (sinh et)))
	  (set! (expcs-cosht gen) (cosh et))
	  (<a class=quiet href="#outa">outa</a> i (expcs gen 0.0) *output*)))))))
</pre>
</td></tr></table>

<p>By the way, the amplitude normalization factor for this generator is:
</p>

<pre>
    (/ (- 1.0 (exp (- (expcs-et gen)))) 
       (exp (- (expcs-et gen))))
</pre>

<p>which can be folded into the original at no run-time cost.  See generators.scm for
some of these in an undigested state.  As J. A. Moorer and Marc Le Brun pointed out
eons ago, there are many more such formulas "buried in reference works".  Well, they've
done nobody any good being buried for a generation, so I say: dig them up!  If
you know of any curious formula, anything that might trigger an interesting train of
reflection, send it to me, and I'll add it to this collection.
</p>

<br><br>



<A NAME="ssb-amdoc"></A>
<!-- ---------------------------------------- SSB-AM ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>ssb-am</h3></center></td></tr></table>
<br>
<pre>
  <a class=def name="make-ssb-am">make-ssb-am</a> <a class=quiet href="#optional-key">:optional-key</a> (frequency 440.0) (order 40)
  <a class=def name="ssb-am">ssb-am</a> gen :optional (insig 0.0) (fm 0.0)
  <a class=def name="ssb-am?">ssb-am?</a> gen
</pre>
<p>ssb-am provides single sideband suppressed carrier amplitude modulation, normally used for frequency shifting.
The basic notion is to shift a spectrum up or down while cancelling either the upper or lower half of the spectrum.
See <a href="sndscm.html#ssbbank">dsp.scm</a> for a number of curious possibilities (time stretch without pitch shift for example).
When this works, which it does more often than I expected, it is much better than the equivalent
phase-vocoder or granular synthesis kludges.
</p>

<table border=1 align=left hspace=40 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>ssb-am methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>frequency in Hz</td></tr>
<tr><td><em class=gen>mus-phase</em></td><td>phase (of embedded sin osc) in radians</td></tr>
<tr><td><em class=gen>mus-order</em></td><td>embedded delay line size</td></tr>
<tr><td><em class=gen>mus-cosines</em></td><td>1</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>same as mus-order</td></tr>
<tr><td><em class=gen>mus-interp-type</em></td><td><code>mus-interp-none</code></td></tr>
<tr><td><em class=gen>mus-xcoeff</em></td><td>FIR filter coeff</td></tr>
<tr><td><em class=gen>mus-xcoeffs</em></td><td>embedded Hilbert transform FIR filter coeffs</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>embedded filter state</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>frequency in radians per sample</td></tr>
</table>

<br>

<pre>
(define* (ssb-am freq :optional (order 40)) 
  ;; higher order = better cancellation
  (let* ((car-freq (abs freq))
	 (cos-car (<a class=quiet href="#make-oscil">make-oscil</a> car-freq (* .5 pi)))
	 (sin-car (<a class=quiet href="#make-oscil">make-oscil</a> car-freq))
	 (dly (<a class=quiet href="#make-delay">make-delay</a> order))
	 (hlb (<a class=quiet href="sndscm.html#makehilberttransform">make-hilbert-transform</a> order)))
    (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> 
      (lambda (y)
        (let ((ccos (<a class=quiet href="#oscil">oscil</a> cos-car))
	      (csin (<a class=quiet href="#oscil">oscil</a> sin-car))
	      (yh (<a class=quiet href="sndscm.html#hilberttransform">hilbert-transform</a> hlb y))
  	      (yd (<a class=quiet href="#delay">delay</a> dly y)))
          (if (&gt; freq 0.0)
	      (- (* ccos yd) ; shift up
	         (* csin yh))
	      (+ (* ccos yd) ; shift down
	         (* csin yh))))))))
</pre>
<br clear=left>
<br>

<table border=0 bgcolor="#fafafa" hspace=40 vspace=10><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (shift-pitch beg dur file freq :optional (order 40))
  (let* ((st (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> beg))
         (nd (+ st (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur)))
	 (gen (<em class=red>make-ssb-am</em> freq order))
	 (rd (<a class=quiet href="#make-readin">make-readin</a> file)))
    (<a class=quiet href="extsnd.html#run">run</a>
     (lambda ()
       (do ((i st (1+ i))) 
	   ((= i nd))
	 (<a class=quiet href="#outa">outa</a> i (<em class=red>ssb-am</em> gen (<a class=quiet href="#readin">readin</a> rd)) *output*))))))

(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> () (shift-pitch 0 3 "oboe.snd" 1108.0))
</pre>
</td></tr></table>


<p>
Normal amplitude modulation, cos(x) * (amp + Y(t)), where Y is some signal, 
produces the carrier (cos(x)), and symmetric sidebands at x+/-frq where frq is each spectral
component of Y.  This is just an elaboration of 
</p>
<pre>
    cos(x) * (amp + cos(y)) = amp * cos(x) + 1/2(cos(x - y) + cos(x + y))
</pre>
<p>
So, the Y spectrum (the first picture below) is shifted up by cos(x) and mirrored on either side of it (the second picture below; the spectral components
on the left side are folding under 0).  In single side-band
AM, we create both the Y spectrum, and, via the hilbert transform, a version of Y in which the phases are shifted too.
Then we can add these two copies, using the phase differences to cancel one side of the symmetric
spectrum (this is the third picture below; the new spectral components are not harmonically related however).  
Once we can shift a pitch without creating its symmetric twin, we can split a spectrum
into many bands, shift each band separately, and thereby retain its original harmonic spacing (the fourth picture).
We have the original, but at a higher pitch.  If we then use <a href="#src">src</a> to convert it back to
its pre-shift pitch, we have the original, but with a different length.
We have decoupled the pitch from the duration, much as in a phase vocoder (which uses an FFT
rather than a filter bank, and an inverse FFT of the moved spectrum, rather than ssb-am).
</p>

<table border=1 hspace=20><tr><td>
<table border=0 hspace=20 vspace=10>
<tr>
<td><img src="orig-oboe.png" alt="unaltered oboe"></td>
<td><img src="am.png" alt="am oboe"></td>
<td><img src="ssbam.png" alt="ssbam oboe"></td>
<td><img src="ssbambank.png" alt="ssbambank oboe"></td>
</tr>
<tr>
<td><center>original</center></td>
<td><center>amplitude modulation</center></td>
<td><center>ssb-am</center></td>
<td><center>ssb-am bank</center></td>
</tr>
</table>
</td></tr></table>

<p>The second picture was created from oboe.snd (the original) via:
</p>
<pre>
    (let ((osc (<a class=quiet href="#make-oscil">make-oscil</a> 1000.0))) 
      (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> 
        (lambda (y) 
          (* .5 (<a class=quiet href="#amplitude-modulate">amplitude-modulate</a> .01 (<a class=quiet href="#oscil">oscil</a> osc) y)))))
</pre>

<p>The third picture was created by:
</p>
<pre>
    (let ((am (<em class=red>make-ssb-am</em> 1000 40))) 
      (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> 
        (lambda (y) 
          (<em class=red>ssb-am</em> am y))))
</pre>

<p>
And the fourth used the ssb-am-bank function in dsp.scm rewritten here for with-sound:
</p>

<table border=0 bgcolor="#fafafa" hspace=40 vspace=10><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (repitch beg dur sound old-freq new-freq 
	         :optional (amp 1.0) (pairs 10) (order 40) (bw 50.0))
  (let* ((start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> beg))
	 (end (+ start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur)))
	 (ssbs (make-vector pairs))
	 (bands (make-vector pairs))
	 (factor (/ (- new-freq old-freq) old-freq))
	 (rd (<a class=quiet href="#make-readin">make-readin</a> sound)))
    (do ((i 1 (1+ i)))
	((> i pairs))
      (let* ((aff (* i old-freq))
	     (bwf (* bw (+ 1.0 (/ i (* 2 pairs))))))
	(vector-set! ssbs (1- i) (<em class=red>make-ssb-am</em> (* i factor old-freq)))
	(vector-set! bands (1- i) (<a class=quiet href="sndscm.html#makebandpass">make-bandpass</a> (<a class=quiet href="#hztoradians">hz-&gt;radians</a> (- aff bwf)) 
						 (<a class=quiet href="#hztoradians">hz-&gt;radians</a> (+ aff bwf)) 
						 order))))
    (<a class=quiet href="extsnd.html#run">run</a>
     (lambda ()
       (do ((i start (1+ i))) 
           ((= i end))
	 (let ((sum 0.0)
	       (y (<a class=quiet href="#readin">readin</a> rd)))
	   (do ((band 0 (1+ band)))
	       ((= band pairs))
	     (set! sum (+ sum (<em class=red>ssb-am</em> (vector-ref ssbs band) 
				      (<a class=quiet href="sndscm.html#makebandpass">bandpass</a> (vector-ref bands band) y)))))
	   (<a class=quiet href="#outa">outa</a> i (* amp sum) *output*)))))))

 (let* ((sound "oboe.snd")
        (mx (cadr (<a class=quiet href="extsnd.html#mussoundmaxamp">mus-sound-maxamp</a> sound)))
	(dur (<a class=quiet href="extsnd.html#mussoundduration">mus-sound-duration</a> sound)))
    (<a class=quiet href="sndscm.html#wsdoc">with-sound</a> (:scaled-to mx) 
      (repitch 0 dur sound 554 1000)))
</pre>
</td></tr></table>


<!-- PERHAPS: ssb-am and formant placement -->

<br><br>



<A NAME="wave-traindoc"></A>
<!-- ---------------------------------------- WAVE-TRAIN ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>wave-train</h3></center></td></tr></table>

<pre>
  <a class=def name="make-wave-train">make-wave-train</a> <a class=quiet href="#optional-key">:optional-key</a> (frequency 440.0) (initial-phase 0.0) wave size type
  <a class=def name="wave-train">wave-train</a> w :optional (fm 0.0)
  <a class=def name="wave-train?">wave-train?</a> w
</pre>

<p>wave-train adds a copy its "wave" (a "grain" in more modern parlance) into its output at "frequency" times per second.
These copies can overlap or have long intervals of silence in between, so
wave train can be viewed either as an extension of pulse-train and table-lookup,
or as a primitive form of granular synthesis.
</p>

<table border=1 cellpadding=4 hspace=40>
<tr><td colspan=2 bgcolor="beige"><center>wave-train methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>frequency in Hz</td></tr>
<tr><td><em class=gen>mus-phase</em></td><td>phase in radians</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>wave array (no set!)</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>length of wave array (no set!)</td></tr>
<tr><td><em class=gen>mus-interp-type</em></td><td>interpolation choice (no set!)</td></tr>
</table>

<p>
With some simple envelopes or filters, you can
use this for VOSIM and other related techniques. 
Here is a FOF instrument based loosely on fof.c of Perry Cook and the article
"Synthesis of the Singing Voice" by Bennett and Rodet in 
"Current Directions in Computer Music Research".
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (fofins beg dur frq amp vib f0 a0 f1 a1 f2 a2 :optional ve ae)
  (let* ((start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> beg))
         (end (+ start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur)))
         (ampf (<a class=quiet href="#make-env">make-env</a> (or ae (list 0 0 25 1 75 1 100 0)) :scaler amp :duration dur))
         (frq0 (<a class=quiet href="#hztoradians">hz-&gt;radians</a> f0))
         (frq1 (<a class=quiet href="#hztoradians">hz-&gt;radians</a> f1))
         (frq2 (<a class=quiet href="#hztoradians">hz-&gt;radians</a> f2))
         (foflen (if (= (<a class=quiet href="#mussrate">mus-srate</a>) 22050) 100 200))
         (vibr (<a class=quiet href="#make-oscil">make-oscil</a> 6))
	 (vibenv (<a class=quiet href="#make-env">make-env</a> (or ve (list 0 1 100 1)) :scaler vib :duration dur))
         (win-freq (/ (* 2 pi) foflen))
         (foftab (make-vct foflen))
         (wt0 (<em class=red>make-wave-train</em> :wave foftab :frequency frq)))
    (do ((i 0 (1+ i)))
        ((= i foflen))
      (set! (vct-ref foftab i) ;; this is not the pulse shape used by B&amp;R
            (* (+ (* a0 (sin (* i frq0))) 
                  (* a1 (sin (* i frq1))) 
                  (* a2 (sin (* i frq2)))) 
               .5 (- 1.0 (cos (* i win-freq))))))
    (<a class=quiet href="extsnd.html#run">run</a>
     (lambda ()
       (do ((i start (1+ i)))
           ((= i end))
         (<a class=quiet href="#outa">outa</a> i (* (<a class=quiet href="#env">env</a> ampf) (<em class=red>wave-train</em> wt0 (* (<a class=quiet href="#env">env</a> vibenv) (<a class=quiet href="#oscil">oscil</a> vibr)))) *output*))))))

(<a class=quiet href="sndscm.html#withsound">with-sound</a> () (fofins 0 1 270 .2 .001 730 .6 1090 .3 2440 .1)) ; "Ahh"

(<a class=quiet href="sndscm.html#withsound">with-sound</a> () ; one of JC's favorite demos
  (fofins 0 4 270 .2 0.005 730 .6 1090 .3 2440 .1 '(0 0 40 0 75 .2 100 1) 
          '(0 0 .5 1 3 .5 10 .2 20 .1 50 .1 60 .2 85 1 100 0))
  (fofins 0 4 (* 6/5 540) .2 0.005 730 .6 1090 .3 2440 .1 '(0 0 40 0 75 .2 100 1) 
          '(0 0 .5 .5 3 .25 6 .1 10 .1 50 .1 60 .2 85 1 100 0))
  (fofins 0 4 135 .2 0.005 730 .6 1090 .3 2440 .1 '(0 0 40 0 75 .2 100 1) 
          '(0 0 1 3 3 1 6 .2 10 .1 50 .1 60 .2 85 1 100 0)))
</pre>
</td></tr></table>


<p>The "wave" is a vct accessible via mus-data.  The "fm" argument affects the frequency of
repetition.  Here is a wave-train instrument that increasingly filters its grain (the word "now", for example) 
while increasing the repetition rate.  We're also using a pulse train as a sort of internal click track,
using the same frequency envelope as the wave-train, so we have some idea when to refilter the grain.
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (when? start-time duration start-freq end-freq grain-file)
  (let* ((beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> start-time))
	 (len (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> duration))
	 (end (+ beg len))
	 (grain-dur (<a class=quiet href="extsnd.html#mussoundduration">mus-sound-duration</a> grain-file))
	 (frqf (<a class=quiet href="#make-env">make-env</a> '(0 0 1 1) :scaler (<a class=quiet href="#hztoradians">hz-&gt;radians</a> (- end-freq start-freq)) :duration duration))
	 (click-track (<em class=red>make-pulse-train</em> start-freq))
	 (grain-size (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> grain-dur))
	 (grains (<em class=red>make-wave-train</em> :size grain-size :frequency start-freq))
	 (ampf (<a class=quiet href="#make-env">make-env</a> '(0 1 1 0) :scaler .7 :offset .3 :duration duration :base 3.0))
	 (grain (<em class=red>mus-data</em> grains)))
    (<a class=quiet href="#filetoarray">file-&gt;array</a> grain-file 0 0 grain-size grain)
    (let ((original-grain (<a class=quiet href="extsnd.html#vctcopy">vct-copy</a> grain)))
      (<a class=quiet href="extsnd.html#run">run</a>
       (lambda ()
	 (do ((i beg (1+ i)))
	     ((= i end))
	   (let* ((gliss (<a class=quiet href="#env">env</a> frqf)))
	     (outa i (* (<a class=quiet href="#env">env</a> ampf) (<em class=red>wave-train</em> grains gliss)) *output*)
	     (let ((click (<em class=red>pulse-train</em> click-track gliss)))
	       (if (&gt; click 0.0)
		   (let* ((scaler (max 0.1 (exact-&gt;inexact (/ (- i beg) len))))
			  (comb-len 32)
			  (c1 (<a class=quiet href="#make-comb">make-comb</a> scaler comb-len))
			  (c2 (<a class=quiet href="#make-comb">make-comb</a> scaler (inexact-&gt;exact (floor (* comb-len .75)))))
			  (c3 (<a class=quiet href="#make-comb">make-comb</a> scaler (inexact-&gt;exact (floor (* comb-len 1.25))))))
		     (do ((k 0 (1+ k)))
			 ((= k grain-size))
		       (let ((x (<a class=quiet href="extsnd.html#vctref">vct-ref</a> original-grain k)))
			 (<a class=quiet href="extsnd.html#vctset">vct-set!</a> grain k (+ (<a class=quiet href="#comb">comb</a> c1 x) (<a class=quiet href="#comb">comb</a> c2 x) (<a class=quiet href="#comb">comb</a> c3 x)))))))))))))))

(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> () (when? 0 4 2.0 8.0 "right-now.snd"))
</pre>
</td></tr></table>

<br><br>



<A NAME="randdoc"></A>
<!-- ---------------------------------------- RAND, RAND-INTERP ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>rand, rand-interp</h3></center></td></tr></table>

<pre>
  <a class=def name="make-rand">make-rand</a> <a class=quiet href="#optional-key">:optional-key</a> 
        (frequency 440.0)          ; frequency at which new random numbers occur
        (amplitude 1.0)            ; numbers are between -amplitude and amplitude
        (envelope '(-1 1 1 1))     ; distribution envelope (uniform distribution is the default)
        distribution               ; pre-computed distribution
  <a class=def name="rand">rand</a> r :optional (sweep 0.0)
  <a class=def name="rand?">rand?</a> r

  <a class=def name="make-rand-interp">make-rand-interp</a> <a class=quiet href="#optional-key">:optional-key</a> 
        (frequency 440.0) 
        (amplitude 1.0)
        (envelope '(-1 1 1 1)
        distribution)
  <a class=def name="rand-interp">rand-interp</a> r :optional (sweep 0.0)
  <a class=def name="rand-interp?">rand-interp?</a> r

  <a class=def name="mus-random">mus-random</a> amp
  <a class=def Name="mus-rand-seed">mus-rand-seed</a>
</pre>

<p>rand produces a sequence of random numbers between -amplitude and
amplitude (a sort of step function).
rand-interp interpolates between successive
random numbers.
rand-interp could be defined as (<a class=quiet href="#moving-average">moving-average</a> agen (rand rgen)) where the
averager has the same period (length) as the rand.  
In both cases, the "envelope" argument or the "distribution" argument determines the random number distribution.
mus-random returns a random number between -amplitude and amplitude.
mus-rand-seed provides access to the seed for mus-random's random number generator.
</p>

<table border=1 align=left hspace=40 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>rand and rand-interp methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>frequency in Hz</td></tr>
<tr><td><em class=gen>mus-phase</em></td><td>phase in radians</td></tr>
<tr><td><em class=gen>mus-scaler</em></td><td>amplitude arg used in make-&lt;gen&gt;</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>distribution table (vct) length</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>distribution table (vct), if any</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>frequency in radians per sample</td></tr>
</table>
<pre>
<br>
rand:
  (if (&gt;= phase (* 2 pi))
      (set! output (<em class=red>mus-random</em> amplitude)))
  (set! phase (+ phase (<a class=quiet href="#hztoradians">hz-&gt;radians</a> frequency) sweep))
</pre>
<br clear=left>

<p>There are a variety of ways to get a non-uniform random number distribution:
<code>(random (random 1.0))</code> or <code>(sin (mus-random pi))</code> are simple examples. Exponential distribution could be:
</p>
<pre>
  (/ (log (max .01 (random 1.0))) (log .01))
</pre>
<p>where the ".01"'s affect how tightly the resultant values cluster toward 0.0 --
set them to .0001, for example, to get most of the random values close to 0.0.
The central-limit theorem says that you can get closer and closer to gaussian
noise simply by adding rand's together.  Orfanidis in 
"Introduction to Signal Processing" says 12 calls on rand will
do perfectly well:
</p><pre>
    (define (gaussian-noise)
      (let ((val 0.0))
        (do ((i 0 (1+ i))) 
            ((= i 12) (/ val 12.0) )
          (set! val (+ val (random 1.0))))))
</pre>
<p>You can watch this (or any other distribution) in action via:
</p>
<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(define (add-rands n)
  (let ((bins (make-vector 201 0))
	(rands (make-vector n #f)))
    (do ((i 0 (1+ i)))
	((= i n))
      (vector-set! rands i (<em class=red>make-rand</em> :frequency (<a class=quiet href="#mussrate">mus-srate</a>) :amplitude (/ 100 n)))
      (rand (vector-ref rands i)))
    (do ((i 0 (1+ i)))
	((= i 100000))
      (let ((sum 0.0))
	(do ((k 0 (1+ k)))
	    ((= k n))
	  (set! sum (+ sum (<em class=red>rand</em> (vector-ref rands k)))))
	(let ((bin (inexact-&gt;exact (+ 100 (round sum)))))
	  (vector-set! bins bin (+ (vector-ref bins bin) 1)))))
    bins))

(let ((ind (<a class=quiet href="extsnd.html#newsound">new-sound</a> "test.snd")))
  (do ((n 1 (+ n 1)))
      ((or (c-g?) (= n 12)))
    (let* ((bins (vector-&gt;vct (add-rands n)))
	   (pk (<a class=quiet href="extsnd.html#vctpeak">vct-peak</a> bins)))
      (<a class=quiet href="extsnd.html#vcttochannel">vct-&gt;channel</a> (<a class=quiet href="extsnd.html#vctscale">vct-scale!</a> bins (/ 1.0 pk)))
      (set! (<a class=quiet href="extsnd.html#xaxislabel">x-axis-label</a>) (format #f "n: ~D" n))
      (<a class=quiet href="extsnd.html#updatetimegraph">update-time-graph</a>))))
</pre>
</td></tr></table>

<p>
Another way to get different distributions is the "rejection method" in which we generate random number
pairs until we get a pair that falls within the
desired distribution; see <a href="sndscm.html#anyrandom">any-random</a> in dsp.scm.
The rand and rand-interp generators, however, use the "transformation method".
The make-rand and make-rand-interp "envelope" arguments specify
the desired distribution function; the generator takes the
inverse of the integral of this envelope, loads that into an array, and uses
<code>(array-interp (random array-size))</code>.  This gives
random numbers of any arbitrary distribution at a computational cost
equivalent to the waveshape generator (which is very similar).
The x axis of the envelope sets the output range (before scaling by the "amplitude" argument), and
the y axis sets the relative weight of the corresponding x axis value.
So, the default is <code>'(-1 1 1 1)</code> which says "output numbers between -1 and 1,
each number having the same chance of being chosen".
An envelope of <code>'(0 1 1 0)</code> outputs values between 0 and 1, denser toward 0.
If you already have the distribution table (a vct, the result of <code>(inverse-integrate envelope)</code> for example),
you can pass it through the "distribution" argument.  Here is gaussian noise
using the "envelope" argument:
</p>
<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(define (gaussian-envelope s)
  (let ((e '())
	(den (* 2.0 s s)))
    (do ((i 0 (1+ i))
	 (x -1.0 (+ x .1))
	 (y -4.0 (+ y .4)))
	((= i 21))
      (set! e (cons x e))
      (set! e (cons (exp (- (/ (* y y) den))) e)))
    (reverse e)))

(<em class=red>make-rand</em> :envelope (gaussian-envelope 1.0))
</pre>
</td></tr></table>

<p>If you want a particular set of values, it's simplest to fill a vct with those values,
then use random as the index into the array.  Say we want 0.0, 0.5, and 1.0 at random,
but 0.5 should happen three times as often as either of the others:
</p>

<pre>
    (let ((vals (vct 0.0 0.5 0.5 0.5 1.0)))
      (do ((i 0 (1+ i)))
          ((= i 10))
        (snd-display ";~A " (vct-ref vals (inexact->exact (floor (random 5.0)))))))
</pre>

<p>These "distributions" refer to the values returned by the random number
generator, but all of them produce white noise (all frequencies are equally
likely).  
You can, of course, filter the output of rand to get a different
frequency distribution.
Orfanidis also mentions a clever way to get reasonably good 1/f noise:
sum together n rand's, where each rand is running an octave slower
than the preceding:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(define (make-1f-noise n)
  ;; returns an array of rand's ready for the 1f-noise generator
  (let ((rans (make-vector n)))
    (do ((i 0 (1+ i))) 
        ((= i n) rans)
      (vector-set! rans i (<em class=red>make-rand</em> :frequency (/ (<a class=quiet href="#mussrate">mus-srate</a>) (expt 2 i)))))))

(define (1f-noise rans)
  (let ((val 0.0) 
        (len (vector-length rans)))
    (do ((i 0 (1+ i)))
        ((= i len) (/ val len))
      (set! val (+ val (<em class=red>rand</em> (vector-ref rans i)))))))
</pre>
</td></tr></table>

<p>See also <a href="sndscm.html#greendoc">green.scm</a> -- bounded brownian noise that can mimic 1/f noise in some cases.
(The brownian graph below has a different dB range).
</p>

<table border=1 hspace=20 cellpadding=5>
<tr><td>
<table border=0>
<tr>
<td bgcolor="#f6f8ff"><center>random</center></td>
<td bgcolor="#f6f8ff"><center>rand</center></td>
<td bgcolor="#f6f8ff"><center>rand-interp</center></td>
</tr><tr>
<td><img src="random.png" alt="random spectrum"></td>
<td><img src="rand.png" alt="rand spectrum"></td>
<td><img src="randi.png" alt="rand-interp spectrum"></td>
</tr></table>
</td></tr><tr><td>
<table border=0>
<tr>
<td bgcolor="#f6f8ff"><center>1/f</center></td>
<td bgcolor="#f6f8ff"><center>brownian</center></td>
<td bgcolor="#f6f8ff"><center>green</center></td>
</tr><tr>
<td><img src="1f.png" alt="1/f spectrum"></td>
<td><img src="brownian.png" alt="brownian spectrum"></td>
<td><img src="green.png" alt="green spectrum"></td>
</tr></table>
</td></tr></table>

<!-- CLM:
;; 1f.png
(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> ()
  (let ((noise (make-1f-noise 12)))
    (do ((i 0 (1+ i)))
	((= i 10000))
      (outa i (1f-noise noise) *output*))))

;; rand.png
(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> ()
  (let ((noise (make-rand 10000.0)))
    (do ((i 0 (1+ i)))
	((= i 10000))
      (outa i (rand noise) *output*))))

;; randi.png
(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> ()
  (let ((noise (make-rand-interp 10000.0)))
    (do ((i 0 (1+ i)))
	((= i 10000))
      (outa i (rand-interp noise) *output*))))

;; random.png
(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> (:clipped #f)
  (do ((i 0 (1+ i)))
      ((= i 10000))
    (outa i (- 0.5 (random 1.0)) *output*)))

;; brownian.png
(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> (:clipped #f)
  (let ((val 0.0))
    (do ((i 0 (1+ i)))
	((= i 10000))
      (set! val (+ val -.005 (random 0.01)))
      (outa i val *output*))))

;; green.png
(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> ()
  (let ((noise (make-green-noise 10000.0 1)))
    (do ((i 0 (1+ i)))
	((= i 10000))
      (outa i (green-noise noise 0.0) *output*))))
-->


<p>And we can't talk about noise without mentioning fractals:</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (fractal start duration m x amp)
  ;; use formula of M J Feigenbaum
  (let* ((beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> start))
	 (end (+ beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> duration))))
    (<a class=quiet href="extsnd.html#run">run</a>
     (lambda ()
       (do ((i beg (1+ i)))
           ((= i end))
         (<a class=quiet href="#outa">outa</a> i (* amp x) *output*)
         (set! x (- 1.0 (* m x x))))))))

;;; this quickly reaches a stable point for any m in[0,.75], so:
(<a class=quiet href="sndscm.html#withsound">with-sound</a> () (fractal 0 1 .5 0 .5)) 
;;; is just a short "ftt"
(<a class=quiet href="sndscm.html#withsound">with-sound</a> () (fractal 0 1 1.5 .20 .2))
</pre>
</td></tr></table>

<p>With this instrument you can hear
the change over from the stable equilibria, to the period doublings,
and finally into the combination of noise and periodicity that
has made these curves famous. See appendix 2 to Ekeland's "Mathematics and the Unexpected" for more details.
Another instrument based on similar ideas is:</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (attract beg dur amp c) ; c from 1 to 10 or so
  ;; by James McCartney, from CMJ vol 21 no 3 p 6
  (let* ((st (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> beg))
	 (nd (+ st (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur)))
	 (a .2) (b .2) (dt .04)
	 (scale (/ (* .5 amp) c))
	 (x1 0.0) (x -1.0) (y 0.0) (z 0.0))
    (<a class=quiet href="extsnd.html#run">run</a>
     (lambda ()
      (do ((i st (1+ i)))
          ((= i nd))
       (set! x1 (- x (* dt (+ y z))))
       (set! y (+ y (* dt (+ x (* a y)))))
       (set! z (+ z (* dt (- (+ b (* x z)) (* c z)))))
       (set! x x1)
       (<a class=quiet href="#outa">outa</a> i (* scale x) *output*))))))
</pre>
</td></tr></table>

<p>which gives brass-like sounds!
We can also get all the period doublings and so on from sin:
</p>
<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
  (let ((x 0.5)) 
    (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> 
      (lambda (y) 
        (let ((val x)) 
          (set! x (* 4 (sin (* pi x)))) 
          val))))
</pre>
</td></tr></table>

<p>See also 
<a href="sndscm.html#ditherchannel">dither-channel</a> (dithering),
<a href="sndscm.html#maracadoc">maraca.scm</a> (physical modelling), 
<a href="sndscm.html#noisedoc">noise.scm, noise.rb</a> (a truly ancient noise-maker),
<a href="sndscm.html#anyrandom">any-random</a> (arbitrary distribution via the rejection method),
and <a href="sndscm.html#greendoc">green.scm</a> (bounded Brownian noise).
</p>

<br><br>



<A NAME="one-poledoc"></A>
<A NAME="one-zerodoc"></A>
<A NAME="two-poledoc"></A>
<A NAME="two-zerodoc"></A>
<!-- ---------------------------------------- SIMPLE FILTERS ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>one-pole, one-zero, two-pole, two-zero</h3></center></td></tr></table>

<pre>
   <a class=def name="make-one-pole">make-one-pole</a> <a class=quiet href="#optional-key">:optional-key</a> a0 b1    ; b1 &lt; 0.0 gives lowpass, b1 &gt; 0.0 gives highpass
   <a class=def name="one-pole">one-pole</a> f input 
   <a class=def name="one-pole?">one-pole?</a> f

   <a class=def name="make-one-zero">make-one-zero</a> <a class=quiet href="#optional-key">:optional-key</a> a0 a1    ; a1 &gt; 0.0 gives weak lowpass, a1 &lt; 0.0 highpass
   <a class=def name="one-zero">one-zero</a> f input 
   <a class=def name="one-zero?">one-zero?</a> f

   <a class=def name="make-two-pole">make-two-pole</a> <a class=quiet href="#optional-key">:optional-key</a> a0 b1 b2 frequency radius
   <a class=def name="two-pole">two-pole</a> f input 
   <a class=def name="two-pole?">two-pole?</a> f

   <a class=def name="make-two-zero">make-two-zero</a> <a class=quiet href="#optional-key">:optional-key</a> a0 a1 a2 frequency radius
   <a class=def name="two-zero">two-zero</a> f input 
   <a class=def name="two-zero?">two-zero?</a> f
</pre>

<p>These are the simplest of filters. 
For everything you want to know about filters, see Julius Smith's <A HREF="http://ccrma.stanford.edu/~jos">home page</a>.
</p>

<table border=1 align=left hspace=40 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>simple filter methods</center></td></tr>
<tr><td><em class=gen>mus-xcoeff</em></td><td>a0, a1, a2 in equations</td></tr>
<tr><td><em class=gen>mus-ycoeff</em></td><td>b1, b2 in equations</td></tr>
<tr><td><em class=gen>mus-order</em></td><td>1 or 2 (no set!)</td></tr>
<tr><td><em class=gen>mus-scaler</em></td><td>two-pole and two-zero radius</td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>two-pole and two-zero center frequency</td></tr>
</table>
<pre>
one-zero  y(n) = a0 x(n) + a1 x(n-1)
one-pole  y(n) = a0 x(n) - b1 y(n-1)
two-pole  y(n) = a0 x(n) - b1 y(n-1) - b2 y(n-2)
two-zero  y(n) = a0 x(n) + a1 x(n-1) + a2 x(n-2)
</pre>
<br clear=left>
<p>
The "a0, b1" nomenclature is taken from Julius Smith's "An Introduction to Digital
Filter Theory" in Strawn "Digital Audio Signal Processing", and is different
from that used in the more general filters such as <a href="#fir-filter">fir-filter</a>.
In make-two-pole and make-two-zero you can specify either the actual
desired coefficients ("a0" and friends), or the center frequency and radius of the
filter ("frequency" and "radius").  The word "radius" refers to the unit circle,
so it should be between 0.0 and (less than) 1.0.
"frequency" should be between 0 and srate/2.  
</p>

<p>We can use a one-pole filter as an "exponentially weighted moving average":
</p>
<pre>
    (make-one-pole (/ 1.0 order) (/ (- order) (+ 1.0 order)))
</pre>
<p>where "order" is more or less how long an input affects the output.
The <a href="sndclm.html#mus-xcoeff">mus-xcoeff</a> and <a href="sndclm.html#mus-ycoeff">mus-ycoeff</a> functions give access to the filter coefficients.
<a href="sndscm.html#prc95doc">prc95.scm</a> uses them to make "run time"
alterations to the filters:
</p>

<pre>
    (set! (mus-ycoeff p 1) (- val))     ; "p" is a one-pole filter, this is setting "b1"
    (set! (mus-xcoeff p 0) (- 1.0 val)) ; this is setting "a0"
</pre>

<p>We can also use <a href="sndclm.html#mus-frequency">mus-frequency</a> and <a href="sndclm.html#mus-scaler">mus-scaler</a> (the pole "radius") as a more intuitive handle on these coefficients:
</p>

<pre>
    <em class=listener>&gt;</em><em class=typing>(define p (make-two-pole :radius .9 :frequency 1000.0))</em>
    <em class=listener>#&lt;unspecified&gt;</em>
    <em class=listener>&gt;</em><em class=typing>p</em>
    <em class=listener>#&lt;two-pole: a0: 1.000, b1: -1.727, b2: 0.810, y1: 0.000, y2: 0.000&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(mus-frequency p)</em>
    <em class=listener>1000.00025329731</em>
    <em class=listener>&gt;</em><em class=typing>(mus-scaler p)</em>
    <em class=listener>0.899999968210856</em>
    <em class=listener>&gt;</em><em class=typing>(set! (mus-frequency p) 2000.0)</em>
    <em class=listener>2000.0</em>
    <em class=listener>&gt;</em><em class=typing>p</em>
    <em class=listener>#&lt;two-pole: a0: 1.000, b1: -1.516, b2: 0.810, y1: 0.000, y2: 0.000&gt;</em>
</pre>

<p>A quick way to see the frequency response of a filter is to drive it with a sine wave sweeping from
0 Hz to half the sampling rate; if the sound length is 0.5 seconds, you can read off the time axis
as the response at that frequency (in terms of a sampling rate of 1.0):
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(define (test-filter flt)
  (let* ((osc (<a class=quiet href="#make-oscil">make-oscil</a> 0.0))
	 (samps (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> 0.5))
	 (ramp (<a class=quiet href="#make-env">make-env</a> '(0 0 1 1) :scaler (<a class=quiet href="#hztoradians">hz-&gt;radians</a> samps) :end samps)))
    (<a class=quiet href="sndscm.html#wsdoc">with-sound</a> ()
      (do ((i 0 (1+ i)))
	  ((= i samps))
        (<a class=quiet href="#outa">outa</a> i (flt (<a class=quiet href="#oscil">oscil</a> osc (<a class=quiet href="#env">env</a> ramp))) *output*)))))
		
(test-filter (make-one-zero 0.5 0.5))
(test-filter (make-one-pole 0.1 -0.9))
(test-filter (make-two-pole 0.1 0.1 0.9))
(test-filter (make-two-zero 0.5 0.2 0.3))
</pre>
</td></tr></table>


<br><br>




<A NAME="formantdoc"></A>
<!-- ---------------------------------------- FORMANT ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>formant</h3></center></td></tr></table>

<pre>
  <a class=def name="make-formant">make-formant</a> <a class=quiet href="#optional-key">:optional-key</a> radius frequency (gain 1.0)
  <a class=def name="formant">formant</a> f input
  <a class=def name="formant?">formant?</a> f
</pre>

<p>formant is a resonator (a two-pole, two-zero bandpass filter) centered at "frequency", with its bandwidth set by "radius".
</p>

<table border=0><tr><td>
<table border=0>
<tr><td>
<table border=1 hspace=40 vspace=16 cellpadding=4 align=left>
<tr><td colspan=2 bgcolor="beige"><center>formant methods</center></td></tr>
<tr><td><em class=gen>mus-xcoeff</em></td><td>a0, a1, a2 in equations</td></tr>
<tr><td><em class=gen>mus-ycoeff</em></td><td>b1, b2 in equations</td></tr>
<tr><td><em class=gen>mus-formant-radius</em></td><td>formant radius</td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>formant center frequency</td></tr>
<tr><td><em class=gen>mus-order</em></td><td>2 (no set!)</td></tr>
<tr><td><em class=gen>mus-scaler</em></td><td>gain</td></tr>
</table>

</td></tr><tr><td>
<pre>
    y(n) = x(n) - 
           r * x(n-2) + 
           2 * r * cos(frq-in-rads) * y(n-1) - 
           r * r * y(n-2)
</pre>
</td></tr></table>

</td><td>

<img src="formant.png" alt="various formant cases" hspace=20>

</td></tr></table>

<p>The formant generator is described in "A Constant-gain Digital Resonator Tuned By a Single Coefficient" by Julius
O. Smith and James B. Angell in Computer Music Journal Vol. 6 No. 4 (winter
1982).
The filter coefficients are set as a function of the "radius",
"frequency", and "gain". 
The bandwidth of the resonance is (* 2 (- 1.0 radius)), so as the radius approaches 1.0 (the unit circle), the
resonance gets narrower.
Use <a href="sndclm.html#mus-frequency">mus-frequency</a> to change the center frequency, and <a href="sndclm.html#mus-formant-radius">mus-formant-radius</a> to change the radius.
In the paper mentioned above,
radius can be set in terms of desired bandwidth in Hz, via:
</p>
<pre>
    (exp (* -0.5 (hz-&gt;radians bandwidth)))
</pre>

<p>
See also "A note on
Constant-Gain Digital Resonators" by Ken Steiglitz, CMJ vol 18 No. 4 pp.8-10
(winter 1994).
The "gain" argument to make-formant is not used directly; it becomes
<code>gain * (1 - radius)</code> or some variant thereof (see mus_make_formant in clm.c).
When you set mus-formant-radius, the gain is also adjusted.
</p>

<p>formant generators are commonly used in a bank of filters to provide a sort of sample-by-sample spectrum.
An example is <a href="sndscm.html#fadedoc">fade.scm</a> which has various functions for frequency domain mixing.
See also 
<a href="sndscm.html#grapheq">grapheq</a> (a non-graphic equalizer), and
<a href="sndscm.html#crosssynthesis">cross-synthesis</a>.
Here's a simpler example that moves a set of harmonically related formants through a sound.
If "radius" is .99, you get a glass-harmonica effect; if it's less, you get more of an FM index envelope effect.
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (move-formants start file amp radius move-env num-formants)
  (let* ((frms (make-vector num-formants))
	 (beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> start))
	 (dur (<a class=quiet href="extsnd.html#mussoundframes">mus-sound-frames</a> file))
	 (end (+ beg dur))
	 (rd (<a class=quiet href="#make-readin">make-readin</a> file))
	 (menv (<a class=quiet href="#make-env">make-env</a> move-env :end dur)))
    (let ((start-frq (<a class=quiet href="#env">env</a> menv)))
      (do ((i 0 (1+ i)))
	  ((= i num-formants))
	(vector-set! frms i (<em class=red>make-formant</em> radius (* (+ i 1) start-frq)))))
    (<a class=quiet href="extsnd.html#run">run</a>
     (lambda ()
       (do ((k beg (1+ k)))
	   ((= k end))
	 (let ((sum 0.0)
	       (x (<a class=quiet href="#readin">readin</a> rd))
	       (frq (<a class=quiet href="#env">env</a> menv)))
	   (do ((i 0 (1+ i)))
	       ((= i num-formants))
	     (set! sum (+ sum (<em class=red>formant</em> (vector-ref frms i) x)))
	     (let ((curfrq (* (+ i 1) frq)))
	       (if (&lt; (* 2 curfrq) (<a class=quiet href="#mussrate">mus-srate</a>))
		   (set! (<em class=red>mus-frequency</em> (vector-ref frms i)) curfrq))))
	   (<a class=quiet href="#outa">outa</a> k (* amp sum) *output*)))))))

(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> () 
  (move-formants 0 "oboe.snd" 2.0 0.99 '(0 1200 1.6 2400 2 1400) 4))
</pre>
</td></tr></table>

<p>The Mathews/Smith <a href="sndscm.html#mfilter">filter</a> in dsp.scm is very similar to the formant generator.
</p>

<br><br>



<A NAME="filterdoc"></A>
<A NAME="fir-filterdoc"></A>
<A NAME="iir-filterdoc"></A>
<!-- ---------------------------------------- FILTERS ---------------------------------------- -->
<br>
<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>filter, iir-filter, fir-filter</h3></center></td></tr></table>

<pre>
   <a class=def name="make-filter">make-filter</a> <a class=quiet href="#optional-key">:optional-key</a> order xcoeffs ycoeffs
   <a class=def name="filter">filter</a> fl inp 
   <a class=def name="filter?">filter?</a> fl

   <a class=def name="make-fir-filter">make-fir-filter</a> <a class=quiet href="#optional-key">:optional-key</a> order xcoeffs
   <a class=def name="fir-filter">fir-filter</a> fl inp 
   <a class=def name="fir-filter?">fir-filter?</a> fl

   <a class=def name="make-iir-filter">make-iir-filter</a> <a class=quiet href="#optional-key">:optional-key</a> order ycoeffs
   <a class=def name="iir-filter">iir-filter</a> fl inp 
   <a class=def name="iir-filter?">iir-filter?</a> fl

   <em class=emdef>envelope-&gt;coeffs</em> :key order envelope dc
</pre>

<p>These are general FIR/IIR filters of arbitrary order.
The "order" argument is one greater than the nominal filter
order (it is the size of the coefficient arrays).
</p>

<table border=0 hspace=20 cellspacing=20><tr><td>
<table border=1 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>general filter methods</center></td></tr>
<tr><td><em class=gen>mus-order</em></td><td>filter order</td></tr>
<tr><td><em class=gen>mus-xcoeff</em></td><td>x (input) coeff</td></tr>
<tr><td><em class=gen>mus-xcoeffs</em></td><td>x (input) coeffs</td></tr>
<tr><td><em class=gen>mus-ycoeff</em></td><td>y (output) coeff</td></tr>
<tr><td><em class=gen>mus-ycoeffs</em></td><td>y (output) coeffs</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>current state (input values)</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>same as mus-order</td></tr>
</table>
</td>
<td>
<pre>
  (let ((xout 0.0))
    (vct-set! state 0 input)

    (do ((j (1- order) (1- j)))
        ((= j 0))
      (set! xout (+ xout 
                    (* (vct-ref xcoeffs j)
                       (vct-ref state j))))
      (vct-set! state 0 (- (vct-ref state 0) 
                           (* (vct-ref ycoeffs j) 
                              (vct-ref state j))))
      (vct-set! state j (vct-ref state (1- j))))

    (+ xout 
       (* (vct-ref state 0) 
          (vct-ref xcoeffs 0))))
</pre>
</td>
</tr></table>

<p>dsp.scm has a number of filter design functions,
and various specializations of the filter generators, including such
perennial favorites as biquad, butterworth, hilbert transform, and
notch filters. Similarly, analog-filter.scm has
the usual IIR suspects: Butterworth, Chebyshev, Bessel, and Elliptic filters.
A biquad section can be implemented as:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
   (define (make-biquad a0 a1 a2 b1 b2) 
      (make-filter 3 (vct a0 a1 a2) (vct 0.0 b1 b2)))
</pre>
</td></tr></table>

<p>
The Hilbert transform can be implemented with an fir-filter:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(define* (make-hilbert-transform :optional (len 30))
  (let* ((arrlen (1+ (* 2 len)))
	 (arr (make-vct arrlen))
	 (lim (if (even? len) len (1+ len))))
    (do ((i (- len) (1+ i)))
	((= i lim))
      (let* ((k (+ i len))
	     (denom (* pi i))
	     (num (- 1.0 (cos (* pi i)))))
	(if (or (= num 0.0) (= i 0))
	    (vct-set! arr k 0.0)
	    (vct-set! arr k (* (/ num denom) 
			       (+ .54 (* .46 (cos (/ (* i pi) len)))))))))
    (<em class=red>make-fir-filter</em> arrlen arr)))

(define hilbert-transform <em class=red>fir-filter</em>)
</pre>
</td></tr></table>

<p>envelope-&gt;coeffs translates a frequency response envelope into the corresponding FIR filter coefficients.
The order of the filter determines how close you
get to the envelope. 
</p>

<br>

<table border=3 bordercolor="tan" hspace=40><th bgcolor="beige">Filters</th><tr><td>
<blockquote><small>
<br>
filter a sound: <a href="extsnd.html#filtersound">filter-sound</a>, <a href="extsnd.html#filterchannel">filter-channel</a>, and <a href="extsnd.html#clmchannel">clm-channel</a><br>
lowpass filter: <a href="sndscm.html#makelowpass">make-lowpass</a> in dsp.scm<br>
highpass filter: <a href="sndscm.html#makehighpass">make-highpass</a> in dsp.scm<br>
bandpass filter: <a href="sndscm.html#makebandpass">make-bandpass</a> in dsp.scm<br>
bandstop filter: <a href="sndscm.html#makebandstop">make-bandstop</a> in dsp.scm<br>
the usual analog filters (Butterworth, Chebyshev, Bessel, Elliptic): <a href="sndscm.html#analogfilterdoc">analog-filter.scm</a><br>
Butterworth filters: <a href="sndscm.html#makebutter">make-butter-high-pass</a>, make-butter-low etc in dsp.scm, used in new-effects.scm<br>
IIR filters of various orders/kinds: <a href="sndscm.html#IIRfilters">dsp.scm</a><br>
Hilbert transform: <a href="sndscm.html#makehilberttransform">make-hilbert-transform</a> in dsp.scm<br>
differentiator: <a href="sndscm.html#makedifferentiator">make-differentiator</a> in dsp.scm<br>
block DC: see example above, dc-block in prc95.scm, or stereo-flute in clm-ins.scm<br>
hum elimination: see <a href="sndscm.html#IIRfilters">eliminate-hum</a> and <a href="sndscm.html#notchchannel">notch-channel</a> in dsp.scm<br>
hiss elimination: <a href="sndscm.html#notchoutrumbleandhiss">notch-out-rumble-and-hiss</a><br>
smoothing filters: <a href="sndscm.html#smoothingfilter">smoothing-filter</a>, weighted-moving-average, exponentially-weighted-moving-average<br>
notch-filters: <a href="sndscm.html#notchchannel">notch-channel</a> and <a href="sndscm.html#notchselection">notch-selection</a><br>
arbitrary spectrum via FIR filter: <a href="sndscm.html#spectrumtocoeffs">spectrum-&gt;coeffs</a> in dsp.scm<br>
invert an FIR filter: <a href="sndscm.html#invertfilter">invert-filter</a> in dsp.scm<br>
filtered echo sound effect: <a href="sndscm.html#zecho">flecho</a> in examp.scm<br>
time varying filter: fltit in examp.scm<br>
draw frequency response: use <a href="snd.html#editenvelope">envelope editor</a> or <a href="snd.html#filtercontrol">filter control</a> in control panel<br>
Moog filter: <a href="sndscm.html#moogdoc">moog.scm</a><br>
Savitzky-Golay filter: <a href="sndscm.html#sgfilter">savitzky-golay-filter</a><br>
Click reduction: <a href="sndscm.html#removeclicks">remove-clicks</a>, <a href="sndscm.html#cleanchannel">clean-channel</a><br>
LADSPA-based filter effects: see ladspa.scm<br>
Max Mathews resonator: <a href="sndscm.html#maxfdoc">maxf.scm, maxf.rb</a>, <a href="sndscm.html#mfilter">mfilter</a><br>
graphical equalizer filter bank: <a href="sndscm.html#clminsdoc">graphEq</a><br>
nonlinear (Volterra) filter: <a href="sndscm.html#volterrafilter">volterra-filter</a><br>
Kalman filter: <a href="sndscm.html#kalmanfilterchannel">kalman-filter-channel</a><br>
see also convolution, physical modeling, reverb, and <a href="sndscm.html#ssffts">fft-based filtering</a><br>
<br>
</small></blockquote>
</td></tr></table>
<br><br>



<A NAME="delaydoc"></A>
<!-- ---------------------------------------- DELAY ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>delay, tap</h3></center></td></tr></table>

<pre>
  <a class=def name="make-delay">make-delay</a> <a class=quiet href="#optional-key">:optional-key</a> size initial-contents (initial-element 0.0) max-size type
  <a class=def name="delay">delay</a> d input :optional (pm 0.0)
  <a class=def name="delay?">delay?</a> d

  <a class=def name="tap">tap</a> d :optional (offset 0)
  <a class=def name="delaytick">delay-tick</a> d input
</pre>

<p>The delay generator is a delay line.  
The make-delay "size" argument sets the delay line length (in samples).
Input fed into a delay line reappears at the output size samples later. 
If "max-size" is specified in make-delay,
and it is larger than "size", the delay line can provide varying-length delays (including fractional amounts).
The delay generator's "pm" argument determines how far from the original "size" we are; that is,
it is difference between the length set by make-delay
and the current actual delay length, size + pm.  So, a positive "pm" corresponds to a longer
delay line.  See <a href="sndscm.html#zecho">zecho</a> in examp.scm for an example.
The make-delay "type" argument sets the interpolation type in the case of fractional delays:
mus-interp-none, mus-interp-linear, mus-interp-all-pass, 
mus-interp-lagrange, mus-interp-bezier, or mus-interp-hermite.
</p>

<table border=1 align=left hspace=40 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>delay methods</center></td></tr>
<tr><td><em class=gen>mus-length</em></td><td>length of delay (no set!)</td></tr>
<tr><td><em class=gen>mus-order</em></td><td>same as mus-length</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>delay line itself (no set!)</td></tr>
<tr><td><em class=gen>mus-interp-type</em></td><td>interpolation choice (no set!)</td></tr>
<tr><td><em class=gen>mus-scaler</em></td><td>available for delay specializations</td></tr>
</table>
<br>
<pre>
(let ((result (<a class=quiet href="#array-interp">array-interp</a> line (- loc pm))))
  (set! (vct-ref line loc) input)
  (set! loc (1+ loc))
  (if (&lt;= size loc) (set! loc 0))
  result)
</pre>
<br clear=left>
<br>

<p>
The tap function taps a delay line at a given offset from the output point.
delay-tick is a function that just puts a sample in the delay line, 'ticks' the delay forward, and
returns its "input" argument.  
See prc95.scm for examples of both of these functions.
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (echo beg dur scaler secs file)
  (let ((del (<em class=red>make-delay</em> (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> secs)))
	(rd (make-sample-reader 0 file)))
    (<a class=quiet href="extsnd.html#run">run</a>
     (lambda ()
       (do ((i beg (1+ i)))
           ((= i (+ beg dur)))
         (let ((inval (rd)))
  	   (<a class=quiet href="#outa">outa</a> i (+ inval (<em class=red>delay</em> del (* scaler (+ (<em class=red>tap</em> del) inval)))) *output*)))))))

(<a class=quiet href="sndscm.html#withsound">with-sound</a> () (echo 0 60000 .5 1.0 "pistol.snd"))
</pre>
</td></tr></table>

<p>The <a href="sndclm.html#mus-scaler">mus-scaler</a> field is available for simple extensions of the delay.  For example,
the following "moving-max" generator uses mus-scaler to track the current maximum sample value
in the delay line; the result is an envelope that tracks the peak amplitude in the
last "size" samples.
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(define* (make-moving-max :optional (size 128))
  (let ((gen (<em class=red>make-delay</em> size)))
    (set! (<a class=quiet href="#mus-scaler">mus-scaler</a> gen) 0.0)
    gen))

(define (moving-max gen y)
  (let* ((absy (abs y))
         (mx (<em class=red>delay</em> gen absy)))
    (if (>= absy (<a class=quiet href="#mus-scaler">mus-scaler</a> gen))
	(set! (<a class=quiet href="#mus-scaler">mus-scaler</a> gen) absy)
	(if (>= mx (<a class=quiet href="#mus-scaler">mus-scaler</a> gen))
	    (set! (<a class=quiet href="#mus-scaler">mus-scaler</a> gen) (<a class=quiet href="extsnd.html#vctpeak">vct-peak</a> (<a class=quiet href="#mus-data">mus-data</a> gen)))))
    (<a class=quiet href="#mus-scaler">mus-scaler</a> gen)))
</pre>
</td></tr></table>

<p>The delay generator is used in some reverbs (<a href="sndscm.html#nrev">nrev</a>), many physical
models (<a href="sndscm.html#stereoflute">stereo-flute</a>), <a href="sndscm.html#dlocsigdoc">dlocsig</a>,
chorus effects (<a href="sndscm.html#chorus">chorus</a> in dsp.scm), and flanging (<a href="sndscm.html#neweffectsdoc">new-effects</a>),
and is the basis for about a dozen extensions (comb and friends below).
</p>

<br><br>




<A NAME="combdoc"></A>
<A NAME="notchdoc"></A>
<!-- ---------------------------------------- COMB, NOTCH ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>comb, notch</h3></center></td></tr></table>

<pre>
  <a class=def name="make-comb">make-comb</a> <a class=quiet href="#optional-key">:optional-key</a> (scaler size 1.0) initial-contents (initial-element 0.0) max-size
  <a class=def name="comb">comb</a> cflt input :optional (pm 0.0)
  <a class=def name="comb?">comb?</a> cflt

  <a class=def name="make-filtered-comb">make-filtered-comb</a> <a class=quiet href="#optional-key">:optional-key</a> (scaler 1.0) size initial-contents (initial-element 0.0) max-size filter
  <a class=def name="filtered-comb">filtered-comb</a> cflt input :optional (pm 0.0)
  <a class=def name="filtered-comb?">filtered-comb?</a> cflt

  <a class=def name="make-notch">make-notch</a> <a class=quiet href="#optional-key">:optional-key</a> (scaler 1.0) size initial-contents (initial-element 0.0) max-size
  <a class=def name="notch">notch</a> cflt input :optional (pm 0.0)
  <a class=def name="notch?">notch?</a> cflt
</pre>

<p>The comb generator is a delay line with a scaler on the feedback.  notch
is a delay line with a scaler on the current input.
filtered-comb is a comb filter with a filter on the feedback.  
Although normally this is a <a href="#one-zero">one-zero</a> filter, it can be any CLM generator.
The make-&lt;gen&gt; "size" argument sets the length
in samples of the delay line,
and the other arguments are also handled as in <a href="#delay">delay</a>.
</p>

<table border=0><tr><td>
<table border=1 hspace=40 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>comb, filtered-comb, and notch methods</center></td></tr>
<tr><td><em class=gen>mus-length</em></td><td>length of delay (no set!)</td></tr>
<tr><td><em class=gen>mus-order</em></td><td>same as mus-length</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>delay line itself (no set!)</td></tr>
<tr><td><em class=gen>mus-feedback</em></td><td>scaler (comb only)</td></tr>
<tr><td><em class=gen>mus-feedforward</em></td><td>scaler (notch only)</td></tr>
<tr><td><em class=gen>mus-interp-type</em></td><td>interpolation choice (no set!)</td></tr>
</table>
</td>
<td>


<pre>
 comb:           y(n) = x(n - size) + scaler * y(n - size)
 notch:          y(n) = x(n) * scaler  + x(n - size)
 filtered-comb:  y(n) = x(n - size) + scaler * filter(y(n - size))
</pre>

<img src="comb.png" alt="sonogram of comb" vspace=10>

</td></tr></table>


<p>As a rule of thumb, the decay time of the feedback is
7.0 * size / (1.0 - scaler) samples, so to get a decay of feedback-dur seconds,
</p>
<pre>
    (make-delay :size size :scaler (- 1.0 (/ (* 7.0 size) (* feedback-dur (<a class=quiet href="#mussrate">mus-srate</a>)))))
</pre>

<p>The peak gain is 1.0 / (1.0 - (abs scaler)).  The peaks (or valleys in notch's case) are evenly spaced
at (<a class=quiet href="#mussrate">mus-srate</a>) / size. The height (or depth) thereof is determined by scaler --
the closer to 1.0 it is, the more pronounced the dips or peaks.
See Julius Smith's "An Introduction to Digital Filter Theory" in
Strawn "Digital Audio Signal Processing", or Smith's "Music Applications of
Digital Waveguides".
The following instrument sweeps the comb filter using the pm argument:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (zc time dur freq amp length1 length2 feedback)
  (let* ((beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> time))
         (end (+ beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur)))
         (s (<a class=quiet href="#make-pulse-train">make-pulse-train</a> :frequency freq))  ; some raspy input so we can hear the effect easily
         (d0 (<em class=red>make-comb</em> :size length1 :max-size (max length1 length2) :scaler feedback))
         (aenv (<a class=quiet href="#make-env">make-env</a> '(0 0 .1 1 .9 1 1 0) :scaler amp :duration dur))
         (zenv (<a class=quiet href="#make-env">make-env</a> '(0 0 1 1) :scaler (- length2 length1) :base 12.0 :duration dur)))
    (<a class=quiet href="extsnd.html#run">run</a> (lambda ()
      (do ((i beg (1+ i))) ((= i end))
        (<a class=quiet href="#outa">outa</a> i (* (env aenv) (<em class=red>comb</em> d0 (<a class=quiet href="#pulse-train">pulse-train</a> s) (<a class=quiet href="#env">env</a> zenv))) *output*))))))

(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> () 
  (zc 0 3 100 .1 20 100 .5) 
  (zc 3.5 3 100 .1 90 100 .95))
</pre></td></tr></table>

<p>The comb filter can produce some nice effects; here's one that treats the comb filter's
delay line as the coefficients for an FIR filter:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(define (fir+comb beg dur freq amp size)
  (let* ((start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> beg))
	 (end (+ start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur)))
	 (dly (<em class=red>make-comb</em> :scaler .9 :size size)) 
	 (flt (<a class=quiet href="#make-fir-filter">make-fir-filter</a> :order size :xcoeffs (<em class=red>mus-data</em> dly))) ; comb delay line as FIR coeffs
	 (r (<a class=quiet href="#make-rand">make-rand</a> freq)))                                       ; feed comb with white noise
    (<a class=quiet href="extsnd.html#run">run</a> 
     (lambda () 
       (do ((i start (1+ i))) 
	   ((= i end)) 
	 (<a class=quiet href="#outa">outa</a> i (* amp (<a class=quiet href="#fir-filter">fir-filter</a> flt (<em class=red>comb</em> dly (<a class=quiet href="#rand">rand</a> r)))) *output*))))))

(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> () 
  (fir+comb 0 2 10000 .001 200)
  (fir+comb 2 2 1000 .0005 400)
  (fir+comb 4 2 3000 .001 300)
  (fir+comb 6 2 3000 .0005 1000))
</pre></td></tr></table>

<p>Here's another that fluctuates between two sets of combs; it usually works best with voice sounds:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (flux start-time file frequency combs0 combs1 :optional (scaler 0.99) (comb-len 32))
  (let* ((beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> start-time))
	 (len (<a class=quiet href="extsnd.html#mussoundframes">mus-sound-frames</a> file))
	 (end (+ beg len))
	 (num-combs0 (length combs0))
	 (num-combs1 (length combs1))
	 (cmbs0 (make-vector num-combs0))
	 (cmbs1 (make-vector num-combs1))
	 (osc (<a class=quiet href="#make-oscil">make-oscil</a> frequency))
	 (rd (<a class=quiet href="#make-readin">make-readin</a> file)))
    (do ((k 0 (1+ k)))
	((= k num-combs0))
      (vector-set! cmbs0 k 
		   (<em class=red>make-comb</em> scaler 
			      (inexact->exact (floor (* comb-len (list-ref combs0 k)))))))
    (do ((k 0 (1+ k)))
	((= k num-combs1))
      (vector-set! cmbs1 k 
		   (<em class=red>make-comb</em> scaler 
			      (inexact->exact (floor (* comb-len (list-ref combs1 k)))))))
    (<a class=quiet href="extsnd.html#run">run</a>
     (lambda ()
       (do ((i beg (1+ i)))
	   ((= i end))
	 (let* ((interp (<a class=quiet href="#oscil">oscil</a> osc))
		(sum0 0.0)
		(sum1 0.0)
		(x (<a class=quiet href="#readin">readin</a> rd)))
	   (do ((k 0 (1+ k)))
	       ((= k num-combs0))
	     (set! sum0 (+ sum0 (<em class=red>comb</em> (vector-ref cmbs0 k) x))))
	   (do ((k 0 (1+ k)))
	       ((= k num-combs1))
	     (set! sum1 (+ sum1 (<em class=red>comb</em> (vector-ref cmbs1 k) x))))
	   (<a class=quiet href="#outa">outa</a> i (+ (* interp sum0) (* (- 1.0 interp) sum1)) *output*)))))))

(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> (:scaled-to .5) 
  (flux 0 "oboe.snd" 10.0 '(1.0 1.25 1.5) '(1.0 1.333 1.6)) ; bowed oboe?
  (flux 2 "now.snd" 4.0 '(1.0 1.25 1.5) '(1.0 1.333 1.6 2.0 3.0))
  (flux 4 "now.snd" 1.0 '(1.0 1.25 1.5) '(1.0 1.333 1.6 2.0 3.0) 0.995 20)
  (flux 6 "now.snd" 10.0 '(1.0 1.25 1.5) '(1.0 1.333 1.6 2.0 3.0) 0.99 10)
  (flux 8 "now.snd" 10.0 '(2.0) '(1.0 1.333 1.6 2.0 3.0) 0.99 120)
  (flux 10 "fyow.snd" .50 '(1.0 2.0 1.5) '(1.0 1.333 1.6 2.0 3.0) 0.99 120))
</pre></td></tr></table>


<p>For more comb filter examples,
see examp.scm, <a href="sndscm.html#chordalize">chordalize</a> in dsp.scm, or
any of the standard reverbs such as <a href="sndscm.html#nrev">nrev</a>. 
filtered-comb is used in <a href="sndscm.html#freeverb">freeverb</a>
where a <a href="#one-zero">one-zero</a> filter is placed
in the feedback loop:
</p>
<pre>
    (make-filtered-comb :size len :scaler room-decay-val :filter (make-one-zero :a0 (- 1.0 dmp) :a1 dmp))
</pre>

<br><br>



<A NAME="all-passdoc"></A>
<!-- ---------------------------------------- ALL-PASS ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>all-pass</h3></center></td></tr></table>

<pre>
  <a class=def name="make-all-pass">make-all-pass</a> <a class=quiet href="#optional-key">:optional-key</a> 
        (feedback 0.0) (feedforward 0.0)
        size 
        initial-contents (initial-element 0.0) 
        max-size
  <a class=def name="all-pass">all-pass</a> f input :optional (pm 0.0)
  <a class=def name="all-pass?">all-pass?</a> f
</pre>

<p>The all-pass or moving average comb generator is just like <a href="#comb">comb</a> but with
an added scaler on the input ("feedforward" is Julius Smith's suggested name for it).  If feedback is 0.0, we get a
comb filter.  If both scale terms are 0.0, we get a pure delay line. 
</p>

<table border=1 align=left hspace=40 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>all-pass methods</center></td></tr>
<tr><td><em class=gen>mus-length</em></td><td>length of delay (no set!)</td></tr>
<tr><td><em class=gen>mus-order</em></td><td>same as mus-length</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>delay line itself (no set!)</td></tr>
<tr><td><em class=gen>mus-feedback</em></td><td>feedback scaler</td></tr>
<tr><td><em class=gen>mus-feedforward</em></td><td>feedforward scaler</td></tr>
<tr><td><em class=gen>mus-interp-type</em></td><td>interpolation choice (no set!)</td></tr>
</table>
<br>

<pre>
 y(n) = feedforward * x(n) + x(n - size) + feedback * y(n - size)
</pre><br clear=left>

<p>all-pass filters are used extensively in reverberation; 
see <a href="sndscm.html#jcrevdoc">jcrev.ins</a> or <a href="sndscm.html#nrev">nrev.ins</a>.
</p>
<br><br>




<A NAME="moving-averagedoc"></A>
<!-- ---------------------------------------- MOVING-AVERAGE ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>moving-average</h3></center></td></tr></table>

<pre>
  <a class=def name="make-moving-average">make-moving-average</a> <a class=quiet href="#optional-key">:optional-key</a> size initial-contents (initial-element 0.0)
  <a class=def name="moving-average">moving-average</a> f input
  <a class=def name="moving-average?">moving-average?</a> f
</pre>

<p>The moving-average or moving window average generator returns the average of the last "size" values input to it.
</p>

<table align=left border=1 hspace=40 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>moving-average methods</center></td></tr>
<tr><td><em class=gen>mus-length</em></td><td>length of table</td></tr>
<tr><td><em class=gen>mus-order</em></td><td>same as mus-length</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>table of last 'size' values</td></tr>
</table>
<br>

<pre>
result = sum-of-last-n-inputs / n
</pre>
<br clear=left>

<p>
moving-average is used both to track rms values and to generate ramps between 0 and 1 in a "gate"
effect in new-effects.scm and in rms-envelope in env.scm.  It can also be viewed as a low-pass filter.
And 
in <a href="sndscm.html#soundstosegmentdata">sounds-&gt;segment-data</a> in examp.scm, it is used to segment a sound library.
Here is an example (from new-effects.scm) that implements a "squelch" effect,
throwing away any samples below a threshhold, and ramping between portions
that are squelched and those that are unchanged (to avoid clicks):
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(define (squelch-channel amount snd chn gate-size)  ; gate-size = ramp length and rms window length
  (let ((gate (<em class=red>make-moving-average</em> gate-size))
        (ramp (<em class=red>make-moving-average</em> gate-size :initial-element 1.0)))
    (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (lambda (y) 
                   (* y (<em class=red>moving-average</em> ramp                           ; ramp between 0 and 1
                          (if (&lt; (<em class=red>moving-average</em> gate (* y y)) amount) ; local (r)ms value
                              0.0                               ; below "amount" so squelch
                            1.0))))
                 0 #f snd chn)))
</pre>
</td></tr></table>

<p>See also dsp.scm for several related functions:
<a href="sndscm.html#movingrms">moving-rms</a>, <a href="sndscm.html#movingsum">moving-sum</a>, 
<a href="sndscm.html#movinglength">moving-length</a>, <a href="sndscm.html#weightedmovingaverage">weighted-moving-average</a>, and 
<a href="sndscm.html#exponentiallyweightedmovingaverage">exponentially-weighted-moving-average</a>
(the latter being just a one-pole filter).
</p>
<br><br>




<A NAME="srcdoc"></A>
<!-- ---------------------------------------- SRC ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>src</h3></center></td></tr></table>

<pre>
  <a class=def name="make-src">make-src</a> <a class=quiet href="#optional-key">:optional-key</a> input (srate 1.0) (width 5)
  <a class=def name="src">src</a> s :optional (sr-change 0.0) input-function
  <a class=def name="src?">src?</a> s
</pre>

<table border=1 cellpadding=4 hspace=40>
<tr><td colspan=2 bgcolor="beige"><center>src methods</center></td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>srate arg to make-src</td></tr>
</table>

<p>The src generator performs sampling rate conversion
by convolving its input with a sinc
function.
make-src's "srate" argument is the
ratio between the old sampling rate and the new;  an srate of 2 causes the sound to be half as long, transposed up an octave.
A negative "srate" reads the sound backwards, if possible.
</p>

<p>
The "width" argument sets how many neighboring samples to convolve with the sinc function.
If you hear high-frequency artifacts in the conversion, try increasing this number;
Perry Cook's default value is 40, and I've seen cases where it needs to be 100.
It can also be set as low as 2 in some cases.
The greater the width, the slower the src generator runs.
</p>

<p>
The src generator's "sr-change"
argument is the amount to add to the current srate on a sample by sample
basis (if it's 0.0 and the original make-src srate argument was also 0.0, you get a constant output because the generator is not moving at all).  
Here's
an instrument that provides time-varying sampling rate conversion:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (simple-src start-time duration amp srt srt-env filename)
  (let* ((senv (<a class=quiet href="#make-env">make-env</a> srt-env :duration duration))
         (beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> start-time))
         (end (+ beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> duration)))
         (src-gen (<em class=red>make-src</em> :input (<a class=quiet href="#make-readin">make-readin</a> filename) :srate srt)))
    (<a class=quiet href="extsnd.html#run">run</a>
      (lambda ()
        (do ((i beg (1+ i)))
            ((= i end))
          (<a class=quiet href="#outa">outa</a> i (* amp (<em class=red>src</em> src-gen (<a class=quiet href="#env">env</a> senv))) *output*))))))

(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> () (simple-src 0 4 1.0 0.5 '(0 1 1 2) "oboe.snd"))
</pre>
</td></tr></table>

<p>src can provide an all-purpose "Forbidden Planet" sound effect:</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (<A NAME="srcer">srcer</A> start-time duration amp srt fmamp fmfreq filename)
  (let* ((os (<a class=quiet href="#make-oscil">make-oscil</a> fmfreq))
         (beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> start-time))
         (end (+ beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> duration)))
         (src-gen (<em class=red>make-src</em> :input (<a class=quiet href="#make-readin">make-readin</a> filename) :srate srt)))
    (<a class=quiet href="extsnd.html#run">run</a>
      (lambda ()
        (do ((i beg (1+ i)))
            ((= i end))
          (<a class=quiet href="#outa">outa</a> i (* amp (<em class=red>src</em> src-gen (* fmamp (<a class=quiet href="#oscil">oscil</a> os)))) *output*))))))

(<a class=quiet href="sndscm.html#withsound">with-sound</a> () (srcer 0 2 1.0   1 .3 20 "fyow.snd"))   
(<a class=quiet href="sndscm.html#withsound">with-sound</a> () (srcer 0 25 10.0   .01 1 10 "fyow.snd"))
(<a class=quiet href="sndscm.html#withsound">with-sound</a> () (srcer 0 2 1.0   .9 .05 60 "oboe.snd")) 
(<a class=quiet href="sndscm.html#withsound">with-sound</a> () (srcer 0 2 1.0   1.0 .5 124 "oboe.snd"))
(<a class=quiet href="sndscm.html#withsound">with-sound</a> () (srcer 0 10 10.0   .01 .2 8 "oboe.snd"))
(<a class=quiet href="sndscm.html#withsound">with-sound</a> () (srcer 0 2 1.0   1 3 20 "oboe.snd"))    
</pre>
</td></tr></table>

<p>The "input" argument to make-src and the "input-function" argument
to src provide the generator with input as it is needed. 
The input function
is a function of one argument (the desired read direction, if the reader can support it), that is called each time src needs another
sample of input. 
</p>

<p>
If you jump around in the input (via mus-location for example), use
<a href="#mus-reset">mus-reset</a> to clear out any lingering state before starting to read at
the new position. (src, like many other generators, has an internal buffer
of recently read samples, so a sudden jump to a new location will otherwise cause
a click).
</p>

<p>There are several other ways to resample a sound.  Some of the more interesting ones are in
dsp.scm (down-oct, sound-interp, linear-src, etc).  To calculate a sound's new duration after
a time-varying src is applied, use <a href="sndscm.html#srcduration">src-duration</a>.
</p>
<br><br>




<A NAME="convolvedoc"></A>
<!-- ---------------------------------------- CONVOLVE ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>convolve</h3></center></td></tr></table>

<pre>
  <a class=def name="make-convolve">make-convolve</a> <a class=quiet href="#optional-key">:optional-key</a> input filter fft-size filter-size
   <a class=def name="convolve">convolve</a> ff :optional input-function
   <a class=def name="convolve?">convolve?</a> ff

   <a class=def name="convolvefiles">convolve-files</a> file1 file2 :optional (maxamp 1.0) (output-file "tmp.snd")
</pre>

<table border=1 cellpadding=4 hspace=40>
<tr><td colspan=2 bgcolor="beige"><center>convolve methods</center></td></tr>
<tr><td><em class=gen>mus-length</em></td><td>fft size used in the convolution</td></tr>
</table>

<p>The convolve generator convolves its input with the impulse response "filter" (a vct).
"input" and "input-function" are functions of one argument that are
called whenever convolve needs input.
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (convins beg dur filter file :optional (size 128))
  (let* ((start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> beg))
         (end (+ start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur)))
         (ff (<em class=red>make-convolve</em> :input (<a class=quiet href="#make-readin">make-readin</a> file) :fft-size size :filter filter)))
    (<a class=quiet href="extsnd.html#run">run</a>
      (lambda ()
        (do ((i start (1+ i)))
            ((= i end))
          (<a class=quiet href="#outa">outa</a> i (<em class=red>convolve</em> ff) *output*))))))

(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> () 
  (convins 0 2 (vct 1.0 0.5 0.25 0.125) "oboe.snd")) ; same as fir-filter with those coeffs
</pre>
</td></tr></table>

<p>convolve-files handles a very common special case: convolve
two files, then normalize the result to some maxamp.  The convolve generator does not
know in advance what its maxamp will be, and when the two files are more or less
the same size, there's no real computational savings to using overlap-add (i.e.
the generator), so a one-time giant FFT saved as a temporary sound file is much
handier.
</p>

<p>The convolve generator is the modern way to add reverb.  There are impulse responses of various concert
halls floating around the web.  convolve and <a href="#fir-filter">fir-filter</a> actually perform the same mathematical operation,
but convolve uses an FFT internally, rather than a laborious dot-product.
</p>

<br><br>




<A NAME="granulatedoc"></A>
<!-- ---------------------------------------- GRANULATE ---------------------------------------- -->

<!-- INDEX grains:Granular synthesis --><A class=def NAME="grains"></a>
<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>granulate</h3></center></td></tr></table>

<pre>
  <a class=def name="make-granulate">make-granulate</a> <a class=quiet href="#optional-key">:optional-key</a>   
        input
        (expansion 1.0)   ; how much to lengthen or compress the file
        (length .15)      ; length of file slices that are overlapped
        (scaler .6)       ; amplitude scaler on slices (to avoid overflows)
        (hop .05)         ; speed at which slices are repeated in output
        (ramp .4)         ; amount of slice-time spent ramping up/down
        (jitter 1.0)      ; affects spacing of successive grains
        max-size          ; internal buffer size
        edit              ; grain editing function
  <a class=def name="granulate">granulate</a> e :optional input-function edit-function
  <a class=def name="granulate?">granulate?</a> e
</pre>

<table align=left border=1 cellpadding=4 hspace=40>
<tr><td colspan=2 bgcolor="beige"><center>granulate methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>time (seconds) between output grains (hop)</td></tr>
<tr><td><em class=gen>mus-ramp</em></td><td>length (samples) of grain envelope ramp segment</td></tr>
<tr><td><em class=gen>mus-hop</em></td><td>time (samples)  between output grains (hop)</td></tr>
<tr><td><em class=gen>mus-scaler</em></td><td>grain amp (scaler)</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>expansion</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>grain length (samples)</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>grain samples (a vct)</td></tr>
<tr><td><em class=gen>mus-location</em></td><td>granulate's local random number seed</td></tr>
</table>
<br>
<pre>
result = overlap add many tiny slices from input
</pre>
<br clear=left>

<p>The granulate generator "granulates" its input (normally a sound file).  It is the poor man's way
to change the speed at which things happen in a recorded sound without
changing the pitches.  It works by slicing the input file into short
pieces, then overlapping these slices to lengthen (or shorten) the
result; this process is sometimes known as granular synthesis, and is
similar to the freeze function.  
</p>

<p>The duration of each slice is
"length" -- the longer the slice, the more the effect resembles reverb.  The
portion of the length (on a scale from 0 to 1.0) spent on each
ramp (up or down) is set by the "ramp" argument.  It can control the smoothness of
the result of the overlaps. 
</p>

<p>The "jitter" argument sets
the accuracy with which granulate hops.  If you set it to 0 (no randomness), you can get very strong
comb filter effects, or tremolo.
The more-or-less average time between
successive segments is "hop".  
If jitter is 0.0, and hop is very small (say .01),
you're asking for trouble (a big comb filter).
If you're granulating more than one channel at a time, and want the channels to remain
in-sync, make each granulator use the same initial random number seed (via mus-location).
</p>

<p>The overall amplitude scaler on each segment is set by the
"scaler" argument; this is used to try to avoid overflows as we add
all these zillions of segments together.  "expansion"
determines the input hop in relation to the output hop; an
expansion-amount of 2.0 should more or less double the length of the
original, whereas an expansion-amount of 1.0 should return something
close to the original tempo.
"input" and "input-function" are the same as in src and convolve (functions of
one argument that return a new input sample whenever they are called by granulate).
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (granulate-sound file beg :optional dur (orig-beg 0.0) (exp-amt 1.0))
  (let* ((f-srate (<a class=quiet href="extsnd.html#mussoundsrate">mus-sound-srate</a> file))
	 (f-start (inexact-&gt;exact (round (* f-srate orig-beg))))
         (f (<a class=quiet href="#make-readin">make-readin</a> file :start f-start))
	 (st (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> beg))
	 (new-dur (or dur (- (<a class=quiet href="extsnd.html#mussoundduration">mus-sound-duration</a> file) orig-beg)))
	 (exA (<em class=red>make-granulate</em> :input f :expansion exp-amt))
	 (nd (+ st (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> new-dur))))
    (<a class=quiet href="extsnd.html#run">run</a>
     (lambda ()
       (do ((i st (1+ i)))
           ((= i nd))
         (<a class=quiet href="#outa">outa</a> i (<em class=red>granulate</em> exA) *output*))))))

(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> () (granulate-sound "now.snd" 0 3.0 0 2.0))
</pre>
</td></tr></table>

<p>See <a href="sndscm.html#expsrc">clm-expsrc</a> in clm-ins.scm.  Here's an instrument that uses the input-function
argument to granulate.  It cause the granulation to run backwards through the file:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (grev beg dur exp-amt file file-beg)
  (let* ((exA (<em class=red>make-granulate</em> :expansion exp-amt))
	 (fil (<a class=quiet href="#make-filetosample">make-file-&gt;sample</a> file))
	 (ctr file-beg))
    (<a class=quiet href="extsnd.html#run">run</a>
      (lambda ()
       (do ((i beg (1+ i)))
           ((= i (+ beg dur)))
         (<a class=quiet href="#outa">outa</a> i (<em class=red>granulate</em> exA
		   (lambda (dir)
		     (let ((inval (<a class=quiet href="#filetosample">file-&gt;sample</a> fil ctr 0)))
		       (if (&gt; ctr 0) (set! ctr (1- ctr)))
		       inval)))
	        *output*))))))

(<a class=quiet href="sndscm.html#withsound">with-sound</a> () (grev 0 100000 2.0 "pistol.snd" 40000))
</pre>
</td></tr></table>

<p>
The "edit" argument can
be a function of one argument, the current granulate generator.  It is called just before
a grain is added into the output buffer. The current grain is accessible via mus-data.
The edit function, if any, should return the length in samples of the grain, or 0.
In the following example, we use the edit function to reverse every other grain:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(let ((forward #t))
  (let ((grn (<em class=red>make-granulate</em> :expansion 2.0
			     :edit (lambda (g)
				     (let ((grain (<a class=quiet href="#mus-data">mus-data</a> g))  ; current grain
					   (len (<a class=quiet href="#mus-length">mus-length</a> g))) ; current grain length
				       (if forward ; no change to data
				           (set! forward #f)
					   (begin
					     (set! forward #t)
					     (<a class=quiet href="extsnd.html#vctreverse">vct-reverse!</a> grain len)))
				       len))))
	(rd (<a class=quiet href="extsnd.html#makesamplereader">make-sample-reader</a> 0)))
    (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> (lambda (y) (<em class=red>granulate</em> grn (lambda (dir) (rd)))))))
</pre>
</td></tr></table>
<br><br>




<A NAME="phase-vocoderdoc"></A>
<!-- ---------------------------------------- PHASE-VOCODER ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>phase-vocoder</h3></center></td></tr></table>

<pre>
  <a class=def name="make-phase-vocoder">make-phase-vocoder</a> <a class=quiet href="#optional-key">:optional-key</a> 
        input (fft-size 512) (overlap 4) interp (pitch 1.0) analyze edit synthesize
  <a class=def name="phase-vocoder">phase-vocoder</a> pv input-function analyze-function edit-function synthesize-function
  <a class=def name="phase-vocoder?">phase-vocoder?</a> pv
</pre>

<table border=1 cellpadding=4 hspace=40>
<tr><td colspan=2 bgcolor="beige"><center>phase-vocoder methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>pitch shift</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>fft-size</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>interp</td></tr>
<tr><td><em class=gen>mus-hop</em></td><td>fft-size / overlap</td></tr>
</table>

<p>The phase-vocoder generator performs phase-vocoder analysis and resynthesis.  The process is
split into three pieces, the analysis stage, editing of the amplitudes and phases, then the resynthesis.
Each stage has a default that is invoked if the "analyze", "edit", or "synthesize"
arguments are omitted from make-phase-vocoder or the phase-vocoder generator.  The edit and synthesize arguments are functions of one argument, the
phase-vocoder generator.  The analyze argument is a function of two arguments, the generator and
the input function. The default is to read the current input,
take an fft, get the new amplitudes and phases (as the edit
function default), then resynthesize using <a href="sndclm.html#sine-bank">sine-bank</a> (the synthesize function default); so, the
default case simply returns a resynthesis of the original input.  The "interp" argument sets the time between
ffts (for time stretching, etc). 
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (simple-pvoc beg dur amp size file)
  (let* ((start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> beg))
	 (end (+ start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur)))
	 (sr (<em class=red>make-phase-vocoder</em> (<a class=quiet href="#make-readin">make-readin</a> file) :fft-size size)))
    (<a class=quiet href="extsnd.html#run">run</a>
      (lambda ()
        (do ((i start (1+ i)))
            ((= i end))
          (<a class=quiet href="#outa">outa</a> i (* amp (<em class=red>phase-vocoder</em> sr)) *output*))))))

(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> () (simple-pvoc 0 2.0 1.0 512 "oboe.snd"))
</pre>
</td></tr></table>

<p>clm23.scm
has a variety of instruments calling the phase-vocoder generator, including pvoc-e that
specifies all of the functions with their default values (that is, it explicitly passes
in functions that do what the phase-vocoder would have done without any function arguments).
pvoc.scm implements the phase-vocoder directly in Scheme (rather than going through the CLM
generator).
</p>
<br><br>




<A NAME="asymmetric-fmdoc"></A>
<!-- ---------------------------------------- ASYMMETRIC-FM ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>asymmetric-fm</h3></center></td></tr></table>

<pre>
  <a class=def name="make-asymmetric-fm">make-asymmetric-fm</a> <a class=quiet href="#optional-key">:optional-key</a> (frequency 440.0) (initial-phase 0.0) (r 1.0) (ratio 1.0)
  <a class=def name="asymmetric-fm">asymmetric-fm</a> af index :optional (fm 0.0)
  <a class=def name="asymmetric-fm?">asymmetric-fm?</a> af
</pre>

<table align=left border=1 cellpadding=4 hspace=40>
<tr><td colspan=2 bgcolor="beige"><center>asymmetric-fm methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>frequency in Hz</td></tr>
<tr><td><em class=gen>mus-phase</em></td><td>phase in radians</td></tr>
<tr><td><em class=gen>mus-scaler</em></td><td>"r" parameter; sideband scaler</td></tr>
<tr><td><em class=gen>mus-offset</em></td><td>"ratio" parameter</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>frequency in radians per sample</td></tr>
</table>
<br>

<!-- LATEX: 
original:
e^{(\frac{B}{2}(r-\frac{1}{r})\cos \omega_{m}t)}\sin(\omega_{c}t+\frac{B}{2}(r+\frac{1}{r})\sin \omega_{m}t)=\sum_{n=-\infty}^{\infty} r^{n}J_{n}(B)\sin(\omega_{c}t+n\omega_{m}t)
my version (for predicatable peak amp):
e^{(\frac{B}{2}(r-\frac{1}{r})\cos \omega_{m}t)}\cos(\omega_{c}t+\frac{B}{2}(r+\frac{1}{r})\sin \omega_{m}t)=\sum_{n=-\infty}^{\infty} r^{n}J_{n}(B)\cos(\omega_{c}t+n\omega_{m}t)

original:
e^{(\frac{B}{2}(r+\frac{1}{r})\cos \omega_{m}t)}\sin(\omega_{c}t+\frac{B}{2}(r-\frac{1}{r})\sin \omega_{m}t)=\sum_{n=-\infty}^{\infty} r^{n}I_{n}(B)\sin(\omega_{c}t+n\omega_{m}t)
my version:
e^{(\frac{B}{2}(r+\frac{1}{r})\cos \omega_{m}t)}\cos(\omega_{c}t+\frac{B}{2}(r-\frac{1}{r})\sin \omega_{m}t)=\sum_{n=-\infty}^{\infty} r^{n}I_{n}(B)\cos(\omega_{c}t+n\omega_{m}t)

here's the complicated case:
e^{\big( \big(\frac{B}{2}\big(r+\frac{1}{r}\big)\cos \omega_{m}t\big) - \frac{1}{2} \ln \big(I_{0}\big(B\big(r+\frac{1}{r}\big)\big)\big) \big)} \sin\big(\omega_{c}t+\frac{B}{2}\big(r-\frac{1}{r}\big)\sin \omega_{m}t\big)=\frac{1}{\sqrt{I_{0}(B(r+\frac{1}{r}))}} \sum r^{n}I_{n}(B)\sin(\omega_{c}t+n\omega_{m}t)
 -->

<pre>
based on:

<img src="sceq10.png" alt="e sin"><br>
<img src="sceq22.png" alt="I form">
</pre>
<br clear=left>

<p>The asymmetric-fm generator provides a way around the symmetric spectra normally produced by FM.
See  Palamin and Palamin, "A Method of Generating and Controlling Asymmetrical
Spectra" JAES vol 36, no 9, Sept 88, p671-685.  P&amp;P use sin(sin), but I'm using cos(sin) so
that we get a sum of cosines, and can therefore easily normalize the peak amplitude to -1.0..1.0.
</p>

<p>"r" is the ratio between successive 
sideband amplitudes, r &lt; 0.0 or r &gt; 1.0 pushes energy above the carrier, whereas r between 0.0 and 1.0 pushes it below. (r = 1.0
gives normal FM).  The mirror image of r (around a given
carrier) is produced by -1/r.
"ratio" is the ratio between the carrier and modulator (i.e. sideband spacing). It's somewhat inconsistent
that asymmetric-fm takes "index" (the fm-index) as its second argument, but otherwise it
would be tricky to get time-varying indices.  In this instrument we sweep "r" with an envelope:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (asy beg dur freq amp index :optional (ratio 1.0))
  (let* ((st (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> beg))
         (nd (+ st (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur)))
         (r-env (<a class=quiet href="#make-env">make-env</a> '(0 -1 1 -20) :duration dur))
         (asyf (<em class=red>make-asymmetric-fm</em> :ratio ratio :frequency freq)))
    (do ((i st (1+ i))) 
        ((= i nd))
      (set! (<a class=quiet href="#mus-scaler">mus-scaler</a> asyf) (<a class=quiet href="#env">env</a> r-env)) ; this sets "r"
      (<a class=quiet href="#outa">outa</a> i (* amp (<em class=red>asymmetric-fm</em> asyf index)) *output*))))
</pre>
</td></tr></table>

<p>For the other kind of asymmetric-fm see generators.scm, and for asymmetric spectra via "single sideband FM" see dsp.scm.
</p>
<br><br>



<!-- INDEX framedoc:frames -->
<!-- INDEX framedoc:mixers -->

<A NAME="framedoc"></A>
<!-- ---------------------------------------- FRAME, MIXER ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>frames and mixers</h3></center></td></tr></table>

<p>
There are two special data types in CLM: frames and mixers.
A frame is an array that represents
a multichannel sample (that is, in a stereo file, at time 0.0, there
are two samples, one for each channel, and the frame that represents it has 2 samples).  A mixer is a array of arrays
that represents a set of input to output scalers, as if it were the
current state of a mixing console's volume controls.  A frame (a multichannel
input) can be mixed into a new frame (a multichannel output) by passing
it through a mixer (a matrix, the operation being a (left) matrix multiply).
These are combined with the notion of a sample (one datum of sampled music), and
input/output ports (files, audio ports, etc) to handle all the 
sound data input and output.
</p>

<table cellspacing=0 cellpadding=0 hspace=40>
<tr><td><a class=def name="make-frame">make-frame</a><code> chans :rest args</code></td><td width=20></td><td>create frame and load it with args</td></tr>
<tr><td><a class=def name="frame?">frame?</a><code> obj</code></td><td></td><td>is obj a frame</td></tr>
<tr><td><a class=def name="frame-ref">frame-ref</a><code> f1 chan</code></td><td></td><td>return f1[chan]</td></tr>
<tr><td><a class=def name="frame-set!">frame-set!</a><code> f1 chan val</code></td><td></td><td>f1[chan] = val (also set! with frame-ref)</td></tr>
<tr><td><a class=def name="frame+">frame+</a><code> f1 f2 :optional outf</code></td><td></td><td>add f1 and f2 element-wise, return new frame (or outf)</td></tr>
<tr><td><a class=def name="frame*">frame*</a><code> f1 f2 :optional outf</code></td><td></td><td>multiply f1 and f2 element-size, return new frame (or outf)</td></tr>
<tr><td><br></td><td></td><td></td></tr>
<tr><td><a class=def name="make-mixer">make-mixer</a><code> chans :rest args</code></td><td></td><td>create a mixer and load it with args</td></tr>
<tr><td><a class=def name="make-scalar-mixer">make-scalar-mixer</a><code> chans scl</code></td><td></td><td>create a mixer with scl on the diagonal</td></tr>
<tr><td><a class=def name="mixer?">mixer?</a><code> obj</code></td><td></td><td>is obj a mixer</td></tr>
<tr><td><a class=def name="mixer-ref">mixer-ref</a><code> m1 in out</code></td><td></td><td>m1[in,out] (use set! to change)</td></tr>
<tr><td><a class=def name="mixer-set!">mixer-set!</a><code> m1 in out val</code></td><td></td><td>m1[in,out] = val (also set! with mixer-ref)</td></tr>
<tr><td><a class=def name="mixermultiply">mixer*</a><code> m1 m2 :optional outm</code></td><td></td><td>matrix multiply of m1 and m2, return new mixer (or outm)</td></tr>
<tr><td><a class=def name="mixeradd">mixer+</a><code> m1 m2 :optional outm</code></td><td></td><td>matrix add of m1 and m2, return new mixer (or outm)</td></tr>
<tr><td></td><td><br></td><td></td></tr>
<tr><td><a class=def name="frametoframe">frame-&gt;frame</a><code> mf mf :optional outf</code></td><td></td><td>pass frame through mixer, return new frame (or outf)</td></tr>
<tr><td><a class=def name="frametolist">frame-&gt;list</a><code> frame</code></td><td></td><td>return list of frame's contents</td></tr>
<tr><td><a class=def name="sampletoframe">sample-&gt;frame</a><code> mf sample :optional outf</code></td><td></td><td>pass sample through mf (a frame or mixer), return new frame (or outf)</td></tr>
<tr><td><a class=def name="frametosample">frame-&gt;sample</a><code> mf frame</code></td><td></td><td>pass frame through mf (a frame or mixer), return sample</td></tr>
</table>

<A NAME="framemuschannels"></A>
<table border=1 cellpadding=4 hspace=40 vspace=20>
<tr><td colspan=2 bgcolor="beige"><center>frame and mixer methods</center></td></tr>
<tr><td><em class=gen>mus-channels</em></td><td>number of channels accommodated</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>same as mus-channels</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>frame data (vct)</td></tr>
</table>

<p>
The arguments to frame*, frame+, mixer*, and mixer+ can be floats as well as mixers and
frames. In that case, the mixer or frame is either scaled by the float, or the float is
added to each element.  
In matrix terminology, a mixer is a square matrix, a frame is a column (or row) vector, mixer* is a 
matrix multiply, and so on. 
The form <code>(frame-&gt;frame frame mixer frame)</code> multiplies a row vector (the first frame)
by a matrix (the mixer), whereas <code>(frame-&gt;frame mixer frame frame)</code> multiplies
a matrix by a column vector.
See <a href="sndscm.html#framedoc">frame.scm</a> for many more
frame-related functions, and <a href="sndscm.html#mixerdoc">mixer.scm</a> for mixer functions.
In Ruby, frame* is frame_multiply, frame+ is frame_add, and mixer* is mixer_multiply.
</p>

<pre>
    <em class=listener>&gt;</em><em class=typing>(define f1 (make-frame 3 1.0 0.5 0.1))</em>
    <em class=listener>#&lt;unspecified&gt;</em>
    <em class=listener>&gt;</em><em class=typing>f1</em>
    <em class=listener>#&lt;frame[3]: [1.000 0.500 0.100]&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(frame-ref f1 2)</em>
    <em class=listener>0.100000001490116</em>
    <em class=listener>&gt;</em><em class=typing>(frame* f1 2.0)</em>
    <em class=listener>#&lt;frame[3]: [2.000 1.000 0.200]&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(define f2 (make-frame 3 0.0 1.0 0.0))</em>
    <em class=listener>#&lt;unspecified&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(frame+ f1 f2)</em>
    <em class=listener>#&lt;frame[3]: [1.000 1.500 0.100]&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(frame-&gt;sample f1 f2)</em> ; dot-product in this case
    <em class=listener>0.5</em>
    <em class=listener>&gt;</em><em class=typing>(define m1 (make-mixer 3 1 0 0  0 1 0  0 0 2))</em>
    <em class=listener>#&lt;unspecified&gt;</em>
    <em class=listener>&gt;</em><em class=typing>m1</em>
    <em class=listener>#&lt;mixer: chans: 3, [
     1.000 0.000 0.000
     0.000 1.000 0.000
     0.000 0.000 2.000
    ]&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(mixer-ref m1 2 2)</em>
    <em class=listener>2.0</em>
    <em class=listener>&gt;</em><em class=typing>(frame-&gt;frame m1 f1)</em>
    <em class=listener>#&lt;frame[3]: [1.000 0.500 0.200]&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(mus-length m1)</em>
    <em class=listener>3</em>
    <em class=listener>&gt;</em><em class=typing>(mus-data f1)</em>
    <em class=listener>#&lt;vct[len=3]: 1.000 0.500 0.100&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(frame-set! f1 1 -.5)</em> ; same as (set! (frame-ref f1 1) -.5)
    <em class=listener>-0.5</em>
    <em class=listener>&gt;</em><em class=typing>f1</em>
    <em class=listener>#&lt;frame[3]: [1.000 -0.500 0.100]&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(mixer-set! m1 0 1 0.5)</em> ; same as (set! (mixer-ref m1 0 1) 0.5)
    <em class=listener>0.5</em>
    <em class=listener>&gt;</em><em class=typing>m1</em>
    <em class=listener>#&lt;mixer: chans: 3, [
     1.000 0.500 0.000
     0.000 1.000 0.000
     0.000 0.000 2.000
    ]&gt;</em>
</pre>
<br><br>




<A NAME="filetosampledoc"></A>
<!-- ---------------------------------------- FILE->SAMPLE ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>sound IO</h3></center></td></tr></table>

<p>Sound file IO is based on a set of file readers and writers that deal either in samples, frames, or vcts.
The six functions are file-&gt;sample, sample-&gt;file, file-&gt;frame, frame-&gt;file, array-&gt;file, and file-&gt;array.
The name "array" is used here, rather than "vct" for historical reasons (the CL version of CLM predates
Snd by many years).
These functions are then packaged up in more convenient forms as in-any, out-any, locsig, readin, etc.
Within with-sound, the variable *output* is bound to the with-sound output file via a sample-&gt;file
object.
</p>


<pre>
  <a class=def name="make-filetosample">make-file-&gt;sample</a> name :optional (buffer-size 8192)
  <a class=def name="make-sampletofile">make-sample-&gt;file</a> name :optional (chans 1) (format mus-lfloat) (type mus-next) comment
  <a class=def name="filetosample?">file-&gt;sample?</a> obj
  <a class=def name="sampletofile?">sample-&gt;file?</a> obj
  <a class=def name="filetosample">file-&gt;sample</a> obj samp :optional chan
  <a class=def name="sampletofile">sample-&gt;file</a> obj samp chan val
  <a class=def name="continue-sampletofile">continue-sample-&gt;file</a> file

  <a class=def name="make-filetoframe">make-file-&gt;frame</a> name :optional (buffer-size 8192)
  <a class=def name="make-frametofile">make-frame-&gt;file</a> name :optional (chans 1) (format mus-lfloat) (type mus-next) comment
  <a class=def name="frametofile?">frame-&gt;file?</a> obj
  <a class=def name="filetoframe?">file-&gt;frame?</a> obj
  <a class=def name="filetoframe">file-&gt;frame</a> obj samp :optional outf
  <a class=def name="frametofile">frame-&gt;file</a> obj samp val
  <a class=def name="continue-frametofile">continue-frame-&gt;file</a> file

  <a class=def name="filetoarray">file-&gt;array</a> file channel beg dur array
  <a class=def name="arraytofile">array-&gt;file</a> file data len srate channels

  <a class=def name="mus-input?">mus-input?</a> obj
  <a class=def name="mus-output?">mus-output?</a> obj
  <a class=def name="mus-close">mus-close</a> obj
  <a class=def name="*output*">*output*</a>
  <a class=def name="*reverb*">*reverb*</a>
  <a class=def name="musfilebuffersize">mus-file-buffer-size</a>
</pre>

<p>file-&gt;sample writes a sample to a file, frame-&gt;file writes a frame, file-&gt;sample reads a sample
from a file, and file-&gt;frame reads a frame.
continue-frame-&gt;file and continue-sample-&gt;file reopen an existing file to continue adding sound data to it.
mus-output? returns #t is its argument is some sort of file writing generator, and mus-input? returns #t if its 
argument is a file reader.  file-&gt;frame returns a new frame unless you pass it an "outf" argument (a frame).
In make-file-&gt;sample and make-file-&gt;frame, the buffer-size defaults to <a href="#musfilebuffersize">mus-file-buffer-size</a>.
There are many examples of these functions in snd-test.scm, clm-ins.scm, and clm23.scm.
Here is one that uses file-&gt;sample to mix in a sound file (there are a zillion other ways to do this):
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(define (simple-f2s beg dur amp file)
  (let* ((start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> beg))
	 (end (+ start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur)))
	 (fil (<em class=red>make-file-&gt;sample</em> file))
	 (ctr 0))
    (<a class=quiet href="extsnd.html#run">run</a>
     (lambda ()
       (do ((i start (1+ i))) ((= i end))
	 (out-any i (* amp (<em class=red>file-&gt;sample</em> fil ctr 0)) 0 *output*)
	 (set! ctr (1+ ctr)))))))
</pre>
</td></tr></table>

<p>If you forget to call mus-close, the GC will eventually do it for you.
</p>
<br><br>




<A NAME="in-anydoc"></A>
<A NAME="out-anydoc"></A>
<!-- ---------------------------------------- IN-ANY, OUT-ANY ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>in-any, out-any</h3></center></td></tr></table>

<pre>
  <a class=def name="out-any">out-any</a> loc data channel output
  <a class=def name="outa">outa</a> loc data output
  <em class=emdef>outb</em> loc data output
  <em class=emdef>outc</em> loc data output
  <em class=emdef>outd</em> loc data output

  <a class=def name="in-any">in-any</a> loc channel input
  <a class=def name="ina">ina</a> loc input
  <a class=def name="inb">inb</a> loc input
</pre>

<p>out-any adds its "data" argument (a sound sample) into the "output" object at sample
position "loc".  
In with-sound, the current output is *output* and the reverb output is *reverb*.
outa is the same as out-any with a channel of 0.
The "output" argument can be a vct or a sound-data object, as well as the more usual frame-&gt;file object.
</p>

<p>in-any returns the sample at position "loc" in
"input".  ina is the same as in-any with a channel of 0.
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (simple-ina beg dur amp file)
  (let* ((start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> beg))
	 (end (+ start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur)))
	 (fil (<em class=red>make-file-&gt;sample</em> file)))
    (<a class=quiet href="extsnd.html#run">run</a>
      (lambda ()
        (do ((i start (1+ i)))
            ((= i end))
          (<a class=quiet href="#outa">outa</a> i 
             (* amp (<em class=red>in-any</em> i 0 fil)) ; same as (<em class=red>ina</em> i fil)
             *output*))))))

(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> () (simple-ina 0 1 .5 "oboe.snd"))
</pre>
</td></tr></table>
<br><br>




<A NAME="readindoc"></A>
<!-- ---------------------------------------- READIN ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>readin</h3></center></td></tr></table>

<pre>
 <a class=def name="make-readin">make-readin</a> <a class=quiet href="#optional-key">:optional-key</a> file (channel 0) (start 0) (direction 1) size
 <a class=def name="readin">readin</a> rd
 <a class=def name="readin?">readin?</a> rd
</pre>

<table border=1 cellpadding=4 hspace=40>
<tr><td colspan=2 bgcolor="beige"><center>readin methods</center></td></tr>
<tr><td><em class=gen>mus-channel</em></td><td>channel arg to make-readin (no set!)</td></tr>
<tr><td><em class=gen>mus-location</em></td><td>current location in file</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>sample increment (direction arg to make-readin)</td></tr>
<tr><td><em class=gen>mus-file-name</em></td><td>name of file associated with gen</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>number of frames in file associated with gen</td></tr>
</table>

<p>readin returns successive samples from a file.
Its "file" argument is the input file's name.
"start" is the frame at which to start reading the input file. 
"channel" is which channel to read (0-based).
"size" is the read buffer size in samples.  It defaults to <a href="#musfilebuffersize">mus-file-buffer-size</a>.
Here is an instrument that applies an envelope to a sound file using
readin and <a href="#env">env</a>:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (env-sound file beg :optional (amp 1.0) (amp-env '(0 1 100 1)))
  (let* ((st (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> beg))
         (dur (<a class=quiet href="extsnd.html#mussoundduration">mus-sound-duration</a> file))
         (rev-amount .01)
         (rdA (<em class=red>make-readin</em> file))
         (ampf (<a class=quiet href="#make-env">make-env</a> amp-env amp dur))
         (nd (+ st (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur))))
    (<a class=quiet href="extsnd.html#run">run</a>
      (lambda ()
        (do ((i st (1+ i)))
	    ((= i nd))
          (let ((outval (* (<a class=quiet href="#env">env</a> ampf) (<em class=red>readin</em> rdA))))
  	    (<a class=quiet href="#outa">outa</a> i outval *output*)
	    (if *reverb* 
              (<a class=quiet href="#outa">outa</a> i (* outval rev-amount) *reverb*))))))))

(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> () (env-sound "oboe.snd" 0 1.0 '(0 0 1 1 2 1 3 0)))
</pre>
</td></tr></table>
<br><br>




<A NAME="locsigdoc"></A>
<!-- ---------------------------------------- LOCSIG ---------------------------------------- -->

<!-- INDEX make-locsig:Sound placement -->
<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>locsig</h3></center></td></tr></table>

<pre>
 <a class=def name="make-locsig">make-locsig</a> <a class=quiet href="#optional-key">:optional-key</a> 
        (degree 0.0) (distance 1.0) (reverb 0.0) 
        (channels 1) output revout 
        (type mus-interp-linear)
 <a class=def name="locsig">locsig</a> loc i in-sig
 <a class=def name="locsig?">locsig?</a> loc

 <a class=def name="locsig-ref">locsig-ref</a> loc chan
 <a class=def name="locsig-set!">locsig-set!</a> loc chan val
 <a class=def name="locsig-reverb-ref">locsig-reverb-ref</a> loc chan
 <a class=def name="locsig-reverb-set!">locsig-reverb-set!</a> loc chan val

 <a class=def name="move-locsig">move-locsig</a> loc degree distance
 <a class=def name="locsig-type">locsig-type</a> ()
</pre>

<table border=1 cellpadding=4 hspace=40>
<tr><td colspan=2 bgcolor="beige"><center>locsig methods</center></td></tr>
<tr><td><em class=gen>mus-data</em></td><td>output scalers (a vct)</td></tr>
<tr><td><em class=gen>mus-xcoeff</em></td><td>reverb scaler</td></tr>
<tr><td><em class=gen>mus-xcoeffs</em></td><td>reverb scalers (a vct)</td></tr>
<tr><td><em class=gen>mus-channels</em></td><td>output channels</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>output channels</td></tr>
</table>

<p>locsig normally takes the place of <a href="#outa">out-any</a> in an
instrument.  It tries to place a signal in a N-channel circle
by scaling the respective amplitudes
("that old trick <i>never</i> works").  "reverb" determines how much of
the direct signal gets sent to the reverberator.  "distance" tries to
imitate a distance cue by fooling with the relative amounts of direct and
reverberated signal (independent of the "reverb" argument).  The distance should
be greater than or equal to 1.0.  
"type" (returned by the function locsig-type) can be <code>mus-interp-linear</code> (the default) or <code>mus-interp-sinusoidal</code>.
The mus-interp-sinusoidal
case uses sin and cos to set the respective channel amplitudes (this is reported to
help with the "hole-in-the-middle" problem).
The "output" argument can be a vct or a sound-data object, as well as a frame-&gt;file generator.
</p>

<p>Locsig can send output to any number of channels.
If channels &gt; 2, the speakers are assumed to be evenly spaced in
a circle.
You can use locsig-set! and locsig-ref to override the placement decisions.
To have full output to both channels,</p>
<pre>
(set! (locsig-ref loc 0) 1.0) ; or (<a class=quiet href="#locsig-set!">locsig-set!</a> loc 0 1.0)
(set! (locsig-ref loc 1) 1.0)
</pre>

<p>Here is an instrument that has envelopes on the distance and degrees, and optionally reverberates a file:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument">definstrument</a> (space file onset duration :key (distance-env '(0 1 100 10)) (amplitude-env '(0 1 100 1))
		     (degree-env '(0 45 50 0 100 90)) (reverb-amount .05))
  (let* ((beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> onset))
	 (end (+ beg (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> duration)))
         (loc (<em class=red>make-locsig</em> :degree 0 :distance 1 :reverb reverb-amount :output *output* :revout *reverb*))
         (rdA (<a class=quiet href="#make-readin">make-readin</a> :file file))
         (dist-env (<a class=quiet href="#make-env">make-env</a> distance-env :duration duration))
         (amp-env (<a class=quiet href="#make-env">make-env</a> amplitude-env :duration duration))
         (deg-env (<a class=quiet href="#make-env">make-env</a> degree-env :scaler (/ 1.0 90.0) :duration duration))
         (dist-scaler 0.0))
    (<a class=quiet href="extsnd.html#run">run</a>
      (lambda ()
        (do ((i beg (1+ i)))
            ((= i end))
          (let ((rdval (* (<a class=quiet href="#readin">readin</a> rdA) (<a class=quiet href="#env">env</a> amp-env)))
	        (degval (<a class=quiet href="#env">env</a> deg-env))
	        (distval (<a class=quiet href="#env">env</a> dist-env)))
            (set! dist-scaler (/ 1.0 distval))
            (set! (<em class=red>locsig-ref</em> loc 0) (* (- 1.0 degval) dist-scaler))
            (if (&gt; (<a class=quiet href="#mus-channels">mus-channels</a> *output*) 1)
                (set! (<em class=red>locsig-ref</em> loc 1) (* degval dist-scaler)))
            (if *reverb* 
                (set! (<em class=red>locsig-reverb-ref</em> loc 0) (* reverb-amount (sqrt dist-scaler))))
            (<em class=red>locsig</em> loc i rdval)))))))

(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> (:reverb jc-reverb :channels 2) 
  (space "pistol.snd" 0 3 :distance-env '(0 1 1 2) :degree-env '(0 0 1 90)))
</pre>
</td></tr></table>

<p>For a moving sound
source, see either move-locsig, or Fernando Lopez Lezcano's <a class=def href="http://ccrma.stanford.edu/~nando/clm/dlocsig/index.html">dlocsig</a>.
Here is an example of move-locsig:
</p>

<table border=0><tr><td>
<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> (:channels 4)
  (let ((loc (<em class=red>make-locsig</em> :channels 4 :output *output*))
	(osc (<a class=quiet href="#make-oscil">make-oscil</a> 440.0))
	(j 0))
    (<a class=quiet href="extsnd.html#run">run</a>  ; 360 notes one at each degree in a circle
      (lambda ()
        (do ((i 0 (1+ i)))
            ((= i 360))
          (do ((k 0 (1+ k)))
              ((= k 1000))
	    (let ((sig (* .5 (<a class=quiet href="#oscil">oscil</a> osc))))
              (<em class=red>locsig</em> loc j sig)
	      (set! j (1+ j))))
	  (<em class=red>move-locsig</em> loc (exact->inexact i) 1.0))))))
</pre>
</td></tr></table>

</td><td>
<img src="circle.png" alt="move-locsig example" hspace=20>
</td></tr></table>

<br><br>




<A NAME="move-sounddoc"></A>
<!-- ---------------------------------------- MOVE-SOUND ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>move-sound</h3></center></td></tr></table>

<pre>
 <a class=def name="make-move-sound">make-move-sound</a> dlocs-list output revout
 <a class=def name="move-sound">move-sound</a> dloc i in-sig
 <a class=def name="move-sound?">move-sound?</a> dloc
</pre>

<p>move-sound is intended as the run-time portion of <a href="sndscm.html#dlocsigdoc">dlocsig</a>.  make-dlocsig
creates a move-sound structure, passing it to the move-sound generator inside the
dlocsig macro.  All the necessary data is packaged up in a list:
</p>
<pre>
(list
  (start 0)               ; absolute sample number at which samples first reach the listener
  (end 0)                 ; absolute sample number of end of input samples
  (out-channels 0)        ; number of output channels in soundfile
  (rev-channels 0)        ; number of reverb channels in soundfile
  path                    ; interpolated delay line for doppler
  delay                   ; tap doppler env
  rev                     ; reverberation amount
  out-delays              ; delay lines for output channels that have additional delays
  gains                   ; gain envelopes, one for each output channel
  rev-gains               ; reverb gain envelopes, one for each reverb channel
  out-map)                ; mapping of speakers to output channels
</pre>
<p>Here's an instrument that uses this generator to pan a sound through four channels:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(define (simple-dloc beg dur freq amp)
  "(simple-dloc-4 beg dur freq amp) test instrument for dlocsig"
  (let* ((os (<a class=quiet href="#make-oscil">make-oscil</a> freq))
	 (start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> beg))
	 (end (+ start (<a class=quiet href="#secondstosamples">seconds-&gt;samples</a> dur)))
	 (loc (<em class=red>make-move-sound</em> (list start end 4 0
	      	   		     (<a class=quiet href="#make-delay">make-delay</a> 12) 
				     (<a class=quiet href="#make-env">make-env</a> '(0 0 10 1) :end dur)
				     #f
				     (make-vector 4 #f)
				     (vector (<a class=quiet href="#make-env">make-env</a> '(0 0 1 1 2 0 3 0 4 0) :duration dur)
					     (<a class=quiet href="#make-env">make-env</a> '(0 0 1 0 2 1 3 0 4 0) :duration dur)
					     (<a class=quiet href="#make-env">make-env</a> '(0 0 1 0 2 0 3 1 4 0) :duration dur)
					     (<a class=quiet href="#make-env">make-env</a> '(0 0 1 0 2 0 3 0 4 1) :duration dur))
				     #f
				     (vector 0 1 2 3))
			       *output*)))
    (<a class=quiet href="extsnd.html#run">run</a>
     (lambda ()
       (do ((i start (1+ i)))
	   ((= i end))
         (<em class=red>move-sound</em> loc i (* amp (<a class=quiet href="#oscil">oscil</a> os))))))))

(<a class=quiet href="sndscm.html#wsdoc">with-sound</a> (:channels 4) (simple-dloc 0 2 440 .5))
</pre>
</td></tr></table>

<br><br>



<table width="80%" border=0><tr><td bgcolor="lightsteelblue" valign="middle"><h2>Other Generators</h2></td></tr></table>
<A NAME="othergenerators"></A>

<!-- ---------------------------------------- OTHER GENERATORS ---------------------------------------- -->

<p>in progress... (generators.scm, etc)
</p>

<p>There are dozens of generators scattered around the *.scm files that come with Snd.  Some that come to mind:
</p>


<pre>
dsp.scm:
    fir-filter: <a class=quiet href="sndscm.html#hilberttransform">hilbert-transform</a>, 
                <a class=quiet href="sndscm.html#makehighpass">highpass, lowpass, bandpass, bandstop</a>, 
                <a class=quiet href="sndscm.html#makedifferentiator">differentiator</a>,
                <a class=quiet href="sndscm.html#makespencerfilter">make-spencer-filter</a>, 
                <a class=quiet href="sndscm.html#sgfilter">savitzky-golay-filter</a>
   
    filter: <a class=quiet href="sndscm.html#makebutter">butter-high-pass, butter-low-pass, butter-band-pass, butter-band-reject</a>, 
            <a class=quiet href="sndscm.html#makebiquad">biquad</a>,
            <a class=quiet href="sndscm.html#IIRfilters">iir-low-pass, iir-high-pass, iir-band-pass, iir-band-stop, peaking</a>,
            <a class=quiet href="sndscm.html#makebutter">butter-lp, butter-hp, butter-bp, butter-bs</a>
   
    delay: <a class=quiet href="sndscm.html#movingmax">moving-max</a>
    average:  <a class=quiet href="sndscm.html#movingsum">moving-sum, moving-rms, moving-length, weighted-moving-average</a>
    one-pole: <a class=quiet href="sndscm.html#exponentiallyweightedmovingaverage">exponentially-weighted-moving-average </a>
    <a class=quiet href="sndscm.html#mfilter">mfilter</a> 
    <a class=quiet href="sndscm.html#volterrafilter">volterra-filter</a>

analog-filter.scm:
    filter: <a class=quiet href="sndscm.html#analogfilterdoc">butterworth-lowpass|highpass|bandpass|bandstop</a>, 
            <a class=quiet href="sndscm.html#analogfilterdoc">chebyshev-lowpass|highpass|bandpass|bandstop</a>, 
            <a class=quiet href="sndscm.html#analogfilterdoc">inverse-chebyshev-lowpass|highpass|bandpass|bandstop</a>, 
            <a class=quiet href="sndscm.html#analogfilterdoc">elliptic-lowpass|highpass|bandpass|bandstop</a>,
            <a class=quiet href="sndscm.html#analogfilterdoc">bessel-lowpass|highpass|bandpass|bandstop</a>

env.scm:
    <a class=quiet href="sndscm.html#powerenv">power-env</a> (and many env makers/modifiers)

examp.scm:
    <a class=quiet href="sndscm.html#makeramp">ramp</a>, 
    <a class=quiet href="sndscm.html#soundinterp">sound-interp</a>

green.scm:
    rand and rand-interp: <a class=quiet href="sndscm.html#greendoc">green-noise</a>, <a class=quiet href="sndscm.html#greendoc">brownian-noise</a>

moog.scm:
    <a class=quiet href="sndscm.html#moogfilter">moog-filter</a>

prc95.scm:
    <a class=quiet href="sndscm.html#prc95doc">reed, bowtable, jettable, onep, lip, dc-block, delaya, delayl</a>

sndclm.html:
    <a class=quiet href="sndclm.html#sinc-train">sinc-train</a>, 
    <a class=quiet href="sndclm.html#sumofoddsines">sum-of-odd-sines</a>, 
    <a class=quiet href="sndclm.html#make-rand">1f-noise</a>

clm-ins.scm:
    <a class=quiet href="sndscm.html#rmsgain">rms gain balance</a>

zip.scm:
    <a class=quiet href="sndscm.html#zipper">zipper</a>
</pre>

<p>In this section, we concentrate on the generators defined in generators.scm.

</p>

<!-- TODO: other generators doc -->



<table border=0 cellspacing=0 hspace=20>

<!-- rcos -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="make-rcos">rcos</A> <code>(frequency 0.0) (initial-phase 0.0) (r 1.0)</code><br>
<em class=emdef>rcos</em> <code>gen fm</code>
</td></tr><tr><td width=60></td><td>
rcos 
produces a sum of cosines with control
over the ratio between successive cosines (the "r" parameter).
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- kosine -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="make-kosine">kosine</A> <code>(frequency 0.0) (initial-phase 0.0) (r 1.0) (k 0.0)</code><br>
<em class=emdef>kosine</em> <code>gen fm</code>
</td></tr><tr><td></td><td>
kosine is another sum of cosines generator, with both a scaler on successive harmonic amplitudes ("r"), and
a control on how many harmonics there are ("k").
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- legendre -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<A class=def NAME="fejer">fejer</A> <code>gen fm</code>, <em class=emdef>make-fejer</em> <code>(frequency 0.0) (initial-phase 0.0) (n 1)</code><br>
<em class=emdef>legendre</em> <code>gen</code>, <em class=emdef>make-legendre</em> <code>(frequency 0.0) (initial-phase 0.0) (n 1)</code><br>
<em class=emdef>jackson</em> <code>gen fm</code>, <em class=emdef>make-jackson</em> <code>(frequency 0.0) (initial-phase 0.0) (n 1)</code><br>
<em class=emdef>poussin</em> <code>gen</code>, <em class=emdef>make-poussin</em> <code>(frequency 0.0) (initial-phase 0.0) (n 1)</code>
</td></tr><tr><td></td><td>
These functions
produce various sums of cosines.
fejer's harmonics are scaled by (/ (- n i) (+ n 1)); decreasing evenly.
poussin's harmonic amplitudes start at 0, go up to a peak at n, then decrease to 0.

<pre>
fejer: <img src="sceq3.png" alt="fejer" align=absmiddle hspace=10 vspace=8>
jackson: fejer^2

poussin: 2*fejer(x, 2n+1) - fejer(x, n)

legendre: <img src="sceq4.png" alt="legendre" align=absmiddle hspace=10>
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- sum-of-n-sines -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<em class=emdef>oddsin</em> <code>gen fm</code>, <em class=emdef>make-oddsin</em> <code>(frequency 0.0) (initial-phase 0.0) (n 1)</code><br>
<em class=emdef>oddcos</em> <code>gen fm</code>, <em class=emdef>make-oddcos</em> <code>(frequency 0.0) (initial-phase 0.0) (n 1)</code>
</td></tr><tr><td></td><td>
<pre>
oddsin: <img src="sceq5.png" alt="sum of odd sines" align=middle hspace=10 vspace=5>
oddcos: <img src="sceq6.png" alt="sum of odd cosines" align=middle hspace=10 vspace=5>
</pre>
</td></tr><tr><td colspan=2 height=16></td></tr>


<!-- blsaw -->
<tr><td colspan=2 bgcolor="#f6f8ff">
<a class=def name="blsaw">blsaw</a> <code>gen</code>, <em class=emdef>make-blsaw</em> <code>(frequency 0.0) (a 0.0) (n 1)</code>
</td></tr><tr><td></td><td>
blsaw is apparently originally from Tim Stilson and Julius Smith (I got it via Alexander Kritov);
it had the name "discrete summation formula" which conveys nothing to me.  The parameter
"a" is more or less the amplitude.
</td></tr><tr><td colspan=2 height=16></td></tr>


</table>



<br><br>

<table width="80%" border=0><tr><td bgcolor="lightsteelblue" valign="middle"><h2>Functions</h2></td></tr></table>
<A NAME="genericfunctions"></A>

<!-- ---------------------------------------- GENERIC FUNCTIONS ---------------------------------------- -->
<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>Generic Functions</h3></center></td></tr></table>

<p>The generators respond to a set of "generic" functions.  mus-frequency, for example, tries to return (or set) a generator's
frequency, wherever that makes sense.
The generic functions are:
</p>

<table cellspacing=0 cellpadding=0 hspace=40>
<tr><td bgcolor="#f6f8ff"><a class=def name="mus-channel">mus-channel</a></td><td width=30 bgcolor="#f6f8ff"></td><td bgcolor="#f6f8ff">channel being read/written</td></tr>
<tr><td><a class=def name="mus-channels">mus-channels</a></td><td></td><td>channels open</td></tr>
<tr><td bgcolor="#f6f8ff"><a class=def name="mus-cosines">mus-cosines</a></td><td bgcolor="#f6f8ff"></td><td bgcolor="#f6f8ff">sinusoids in output</td></tr>
<tr><td><a class=def name="mus-data">mus-data</a></td><td></td><td>vct of data</td></tr>
<tr><td bgcolor="#f6f8ff"><a class=def name="mus-describe">mus-describe</a></td><td bgcolor="#f6f8ff"></td><td bgcolor="#f6f8ff">description of current state</td></tr>
<tr><td><a class=def name="mus-feedback">mus-feedback</a></td><td></td><td>feedback coefficient</td></tr>
<tr><td bgcolor="#f6f8ff"><a class=def name="mus-feedforward">mus-feedforward</a></td><td bgcolor="#f6f8ff"></td><td bgcolor="#f6f8ff">feedforward coefficient</td></tr>
<tr><td><a class=def name="mus-file-name">mus-file-name</a></td><td></td><td>file being read/written</td></tr>
<tr><td bgcolor="#f6f8ff"><a class=def name="mus-formant-radius">mus-formant-radius</a></td><td bgcolor="#f6f8ff"></td><td bgcolor="#f6f8ff">width of formant</td></tr>
<tr><td><a class=def name="mus-frequency">mus-frequency</a></td><td></td><td>frequency (Hz)</td></tr>
<tr><td bgcolor="#f6f8ff"><a class=def name="mus-hop">mus-hop</a></td><td bgcolor="#f6f8ff"></td><td bgcolor="#f6f8ff">hop size for block processing</td></tr>
<tr><td><a class=def name="mus-increment">mus-increment</a></td><td></td><td>various increments</td></tr>
<tr><td bgcolor="#f6f8ff"><a class=def name="mus-interp-type">mus-interp-type</a></td><td bgcolor="#f6f8ff"></td><td bgcolor="#f6f8ff">interpolation type (mus-interp-linear, etc)</td></tr>
<tr><td><a class=def name="mus-length">mus-length</a></td><td></td><td>data length</td></tr>
<tr><td bgcolor="#f6f8ff"><a class=def name="mus-location">mus-location</a></td><td bgcolor="#f6f8ff"></td><td bgcolor="#f6f8ff">sample location for reads/writes</td></tr>
<tr><td><a class=def name="mus-name">mus-name</a></td><td></td><td>generator name ("oscil")</td></tr>
<tr><td bgcolor="#f6f8ff"><a class=def name="mus-offset">mus-offset</a></td><td bgcolor="#f6f8ff"></td><td bgcolor="#f6f8ff">envelope offset</td></tr>
<tr><td><a class=def name="mus-order">mus-order</a></td><td></td><td>filter order</td></tr>
<tr><td bgcolor="#f6f8ff"><a class=def name="mus-phase">mus-phase</a></td><td bgcolor="#f6f8ff"></td><td bgcolor="#f6f8ff">phase (radians)</td></tr>
<tr><td><a class=def name="mus-ramp">mus-ramp</a></td><td></td><td>granulate grain envelope ramp setting</td></tr>
<tr><td bgcolor="#f6f8ff"><a class=def name="mus-reset">mus-reset</a></td><td bgcolor="#f6f8ff"></td><td bgcolor="#f6f8ff">set gen to default starting state</td></tr>
<tr><td><a class=def name="mus-run">mus-run</a></td><td></td><td>run any generator</td></tr>
<tr><td bgcolor="#f6f8ff"><a class=def name="mus-scaler">mus-scaler</a></td><td bgcolor="#f6f8ff"></td><td bgcolor="#f6f8ff">scaler, normally on an amplitude</td></tr>
<tr><td><a class=def name="mus-width">mus-width</a></td><td></td><td>width of interpolation tables, etc</td></tr>
<tr><td bgcolor="#f6f8ff"><a class=def name="mus-xcoeff">mus-xcoeff</a></td><td bgcolor="#f6f8ff"></td><td bgcolor="#f6f8ff">x (input) coefficient</td></tr>
<tr><td><a class=def name="mus-xcoeffs">mus-xcoeffs</a></td><td></td><td>vct of x (input) coefficients</td></tr>
<tr><td bgcolor="#f6f8ff"><a class=def name="mus-ycoeff">mus-ycoeff</a></td><td bgcolor="#f6f8ff"></td><td bgcolor="#f6f8ff">y (output, feedback) coefficient</td></tr>
<tr><td><a class=def name="mus-ycoeffs">mus-ycoeffs</a></td><td></td><td>vct of y (feedback) coefficients</td></tr>

</table>

<p>Many of these are settable:
<code>(set! (mus-frequency osc1) 440.0)</code>
sets osc1's phase increment to (<a class=quiet href="#hztoradians">hz-&gt;radians</a> 440.0). 
<a class=def name="musgeneratorp">mus-generator?</a> returns #t if its argument is
a generator.
<a href="sndscm.html#clminsdoc">clm-ins.scm</a> has many examples of these functions.
A generator defined via <a href="sndscm.html#def-clm-struct">def-clm-struct</a> can take part in these methods.
If the last element of the list (returned by def-clm-struct) is an association list, the generic functions
will search that list for their name, and use the functions that follow to implement their method.
These added methods are not currently optimizable via the run macro.
</p>
<br>

<pre>
  <a class=def name="musfloatequalfudgefactor">mus-float-equal-fudge-factor</a>
</pre>

<p>This function sets how far apart generator vct elements can be and still be considered equal in equal?, and
</p>

<pre>
  <a class=def name="musarrayprintlength">mus-array-print-length</a>
</pre>

<p>
determines how many vct elements are printed by mus-describe.
</p>
<br><br>




<!-- ---------------------------------------- FUNCTIONS ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3><A class=def NAME="functions">Other Functions</a></h3></center></td></tr></table>

<p>There are several functions closely tied to the generators and instruments.
</p>

<table cellspacing=0 cellpadding=0 hspace=40>
<tr><td><a class=def name="hztoradians">hz-&gt;radians</a><code> freq</code></td><td width=20></td><td>convert freq to radians per sample (using mus-srate): (freq * 2 * pi) / srate</td></tr>
<tr><td><a class=def name="radianstohz">radians-&gt;hz</a><code> rads</code></td><td></td><td>convert rads to Hz (using mus-srate): (rads * srate) / (2 * pi)</td></tr>
<tr><td><a class=def name="dbtolinear">db-&gt;linear</a><code> dB</code></td><td></td><td>convert dB to linear value: 10^(dB/20)</td></tr>
<tr><td><a class=def name="lineartodb">linear-&gt;db</a><code> val</code></td><td></td><td>convert val to dB: 20 * log(x) / log(10)</td></tr>
<tr><td><a class=def Name="timestosamples">times-&gt;samples</a><code> start duration</code></td><td></td><td>convert start and duration from seconds to samples (beg+dur in latter case)</td></tr>
<tr><td><a class=def name="samplestoseconds">samples-&gt;seconds</a><code> samps</code></td><td></td><td>convert samples to seconds (using mus-srate): samps / srate</td></tr>
<tr><td><a class=def name="secondstosamples">seconds-&gt;samples</a><code> secs</code></td><td></td><td>convert seconds to samples (using mus-srate): secs * srate</td></tr>
<tr><td><a class=def name="degreestoradians">degrees-&gt;radians</a><code> degs</code></td><td></td><td>convert degrees to radians: (degs * 2 * pi) / 360</td></tr>
<tr><td><a class=def name="radianstodegrees">radians-&gt;degrees</a><code> rads</code></td><td></td><td>convert radians to degrees: (rads * 360) / (2 * pi)</td></tr>
<tr><td><a class=def name="clear-array">clear-array</a><code> arr</code></td><td></td><td>set all values in arr (a vct) to 0.0</td></tr>
<tr><td><a class=def name="mussrate">mus-srate</a></td><td></td><td>sampling rate in with-sound</td></tr>
</table>

<p>
hz-&gt;radians
converts its argument to radians/sample (for any situation where a
frequency is used as an amplitude -- glissando or FM).
</p>
<blockquote>
<p>
<code>freq-in-hz * 2 * pi</code> gives us the number of radians traversed per
second; we then divide by the number of samples per second to get the
radians per sample; in dimensional terms: (radians/sec) /
(sample/sec) = radians/sample.  We need this conversion whenever a
frequency-related value is being accessed on every sample, as
an increment of a phase variable.  
</p></blockquote>
<br><br>



<!-- ---------------------------------------- POLYNOMIAL ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>polynomial</h3></center></td></tr></table>

<pre>
   <a class=def name="polynomial">polynomial</a> coeffs x
</pre>

<p>The polynomial function evaluates a polynomial, defined by giving its coefficients,
at the point "x".
"coeffs" is a vct of coefficients where
coeffs[0] is the constant term, and so on. 
</p>

<pre>
    <em class=listener>&gt;</em><em class=typing>(polynomial (vct 0.0 1.0) 2.0)</em> ; x
    <em class=listener>2.0</em>
    <em class=listener>&gt;</em><em class=typing>(polynomial (vct 1.0 2.0 3.0) 2.0)</em> ; 3x*x + 2x + 1
    <em class=listener>17.0</em>
</pre>

<p>
<a href="sndscm.html#polydoc">poly.scm</a> has a variety of polynomial-related functions.
Abramowitz and Stegun, "A Handbook of Mathematical Functions" is a
treasure-trove of interesting polynomials.
For waveshaping, use the function <a href="#partialstopolynomial">partials-&gt;polynomial</a> to
generate the coefficients, then drive polynomial with a cosine.
</p>
<br><br>



<!-- ---------------------------------------- ARRAY-INTERP ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>array-interp, dot-product</h3></center></td></tr></table>

<pre>
  <a class=def name="array-interp">array-interp</a> fn x :optional size
  <a class=def name="dot-product">dot-product</a> in1 in2
  <a class=def name="edot-product">edot-product</a> freq data
  <a class=def name="mus-interpolate">mus-interpolate</a> type x v size y1
</pre>

<p>array-interp interpolates in the array "fn" at the point "x".  It underlies the <a href="#table-lookup">table-lookup</a>
generator, among others.  Here's array-interp as a "compander":
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(define compand-table (vct -1.0 -0.96 -0.90 -0.82 -0.72 -0.60 -0.45 -0.25 
                            0.0 0.25 0.45 0.60 0.72 0.82 0.90 0.96 1.0))

(<a class=quiet href="extsnd.html#mapchannel">map-channel</a>
  (lambda (inval)
    (let ((index (+ 8.0 (* 8.0 inval))))
      (<em class=red>array-interp</em> compand-table index 17))))
</pre>
</td></tr></table>


<p>
dot-product is the usual "inner product" or "scalar product" (a name that should be banned from polite society).
We could define our own FIR filter using dot-product:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(define (make-fr-filter coeffs)
  (list coeffs (<a class=quiet href="extsnd.html#makevct">make-vct</a> (<a class=quiet href="extsnd.html#vctlength">vct-length</a> coeffs))))

(define (fr-filter flt x)
  (let* ((coeffs (car flt))
	 (xs (cadr flt))
	 (xlen (<a class=quiet href="extsnd.html#vctlength">vct-length</a> xs)))
    (<a class=quiet href="extsnd.html#vctmove">vct-move!</a> xs (- xlen 1) (- xlen 2) #t)
    (<a class=quiet href="extsnd.html#vctset">vct-set!</a> xs 0 x)
    (<em class=red>dot-product</em> coeffs xs xlen)))
</pre>
</td></tr></table>


<p>
edot-product returns the complex dot-product of the "data" argument (a vct or a vector) with <code>(exp (* freq i))</code>.
Here, "i" goes from 0 to data's size - 1.
"freq" and the elements of "data" can be complex, as can the return value.  See <a href="sndscm.html#stretchsoundviadft">stretch-sound-via-dft</a>
for an example.
</p>


<p>
mus-interpolate is the function used whenever table lookup interpolation is requested, as in
<a href="#delay">delay</a> or <a href="#wave-train">wave-train</a>. 
The "type" argument is one of the interpolation types (<code>mus-interp-linear</code>, for example).
</p>
<br><br>




<!-- ---------------------------------------- CONTRAST-ENHANCEMENT ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>contrast-enhancement</h3></center></td></tr></table>

<pre>
   <a class=def name="contrast-enhancement">contrast-enhancement</a> in-samp :optional (fm-index 1.0)
</pre>

<p>contrast-enhancement phase-modulates a sound file:
</p>
<pre>
    (sin (+ (* input pi 0.5)
            (* index (sin (* input pi 2)))))
</pre>

<p>
This brightens the
sound, helping it cut through a huge mix.
A similar (slightly simpler) effect is:
</p>

<table border=0 bgcolor="#fafafa" hspace=40><tr><td>
<pre>
(let ((mx (maxamp))) 
  (<a class=quiet href="extsnd.html#mapchannel">map-channel</a> 
    (lambda (y) 
      (* mx (sin (/ (* pi y) mx))))))
</pre>
</td></tr></table>

<p>This modulates the sound but keeps the output maxamp the same as the input.
There is a similar function in sndscm.html that does this kind of scaling throughout the sound,
resulting in a steady modulation, rather than an intensification of just the peaks -- see
<a href="sndscm.html#movingmax">moving-max</a>.
</p>
<br><br>



<!-- ---------------------------------------- AMPLITUDE-MODULATE ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>ring-modulate, amplitude-modulate</h3></center></td></tr></table>

<pre>
  <a class=def name="ring-modulate">ring-modulate</a> in1 in2                  ; returns <code>(* in1 in2)</code>
  <a class=def name="amplitude-modulate">amplitude-modulate</a> am-carrier in1 in2  ; returns <code>(* in1 (+ am-carrier in2))</code>
</pre>

<p>ring-modulation is sometimes called "double-sideband-suppressed-carrier" modulation --
that is, amplitude modulation with the carrier subtracted out (set to 0.0 above).
The nomenclature here is a bit confusing -- I can't remember now why I used
these names; think of "carrier" as "carrier amplitude" and "in1" as "carrier". Normal amplitude modulation using this function would be:
</p>
<pre>
  (define carrier (<a class=quiet href="#make-oscil">make-oscil</a> carrier-freq (* .5 pi)))
  ...
  (amplitude-modulate 1.0 (<a class=quiet href="#oscil">oscil</a> carrier) signal)
</pre>

<p>Both of these functions take advantage of the "Modulation Theorem"; since
multiplying a signal by a phasor (e ^ (j w t)) translates its spectrum by w /
two pi Hz, multiplying by a sinusoid splits its spectrum into two equal parts
translated up and down by w/(two pi) Hz:
</p>

<img src="fmeq8.png" alt="coscos and sinsin" hspace=20>

<br><br><br>



<!-- ---------------------------------------- FFT ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>FFT (fourier transform)</h3></center></td></tr></table>
<pre>
  <a class=def Name="fft">mus-fft</a> rdat idat fftsize :optional sign
  <a class=def name="make-fft-window">make-fft-window</a> <a class=quiet href="#optional-key">:optional-key</a> type size (beta 0.0) (alpha 0.0)
  <a class=def name="multiply-arrays">multiply-arrays</a> rdat window
  <a class=def name="rectangulartopolar">rectangular-&gt;polar</a> rdat idat
  <a class=def name="polartorectangular">polar-&gt;rectangular</a> rdat idat
  <a class=def name="spectrum">spectrum</a> rdat idat window norm-type
  <a class=def name="convolution">convolution</a> rdat idat size
  <a class=def name="autocorrelate">autocorrelate</a> data
  <a class=def name="correlate">correlate</a> data1 data2
</pre>

<p>mus-fft, spectrum, and convolution are the standard functions used everywhere.
fft is the Fourier transform, convolution convolves its arguments, and spectrum
returns (magnitude (rectangular-&gt;polar (fft))).  The results are in dB (if "norm-type" is 0),
or linear and normalized to 1.0 ("norm-type" = 1), or linear unnormalized.
The name "mus-fft" is used to distuinguish clm's fft routine from Snd's; the
only difference is that mus-fft includes the fft length as an argument, whereas
<a href="extsnd.html#fft">fft</a> does not.
</p>

<p>make-fft-window can return many of the standard windows including:
</p>

<pre>
  bartlett-hann-window     bartlett-window        blackman2-window       blackman3-window
  blackman4-window         bohman-window          cauchy-window          connes-window       
  dolph-chebyshev-window   exponential-window     flat-top-window        gaussian-window     
  hamming-window           hann-poisson-window    hann-window            kaiser-window
  parzen-window            poisson-window         rectangular-window     riemann-window      
  samaraki-window          tukey-window           ultraspherical-window  welch-window        
  blackman5-window         blackman6-window       blackman7-window       blackman8-window       
  blackman9-window         blackman10-window      rv2-window             rv3-window
  rv4-window               mlt-sine-window
</pre>


<p>rectangular-&gt;polar and polar-&gt;rectangular change how we view the FFT data: in polar or rectangular coordinates.
multiply-arrays does an element-wise multiply of two vcts.
autocorrelate performs an (in place) autocorrelation of 'data' (a vct).  See <a href="sndscm.html#spotfreq">spot-freq</a> in dsp.scm, 
or <a href="sndscm.html#rubberdoc">rubber.scm</a>.
correlate performs an in-place cross-correlation of data1 and data2.
</p>


<!-- TODO: add examples for fft etc -->

<br><br>



<!-- INDEX instruments:Instruments -->

<table width="80%" border=0><tr><td bgcolor="lightsteelblue" valign="middle"><h3><a class=def name="instruments">Instruments</a></h3></td></tr></table>

<p>It's hard to decide what's an "instrument" in this context, but I think I'll treat
it as something that can be called as a note in a notelist (in with-sound) and
generate its own sound.
There are hundreds of instruments scattered around the documentation, and most of the
<a href="extsnd.html#mapchannel">map-channel</a> functions can be recast as instruments.
There are also several that represent "classic" computer music instruments; they
are listed here, documented in sndscm.html, and tested (via sample runs) in
test 23 in snd-test.
</p>


<table border=8 bordercolor="lightgreen" cellpadding=2>
<tr><th width=120 bgcolor="beige">instrument</th><th bgcolor="beige">function</th><th bgcolor="beige">CL</th><th bgcolor="beige">Scheme</th><th bgcolor="beige">Ruby</th><th bgcolor="beige">Forth</th></tr>
<tr><td>complete-add</td>      
    <td>additive synthesis</td>
    <td><a href="add.ins">add.ins</a></td>
    </tr>

<tr><td>addflts</td>
    <td>filters</td>
    <td><a href="addflt.ins">addflt.ins</a></td> 
        <td><a href="dsp.scm">dsp.scm</a></td>
	<td><a href="dsp.rb">dsp.rb</a></td>
    </tr>

<tr><td>add-sound</td>
    <td>mix in a sound file</td>
    <td><a href="addsnd.ins">addsnd.ins</a></td>
    </tr>

<tr><td>anoi</td>
    <td>noise reduction</td>
    <td><a href="anoi.ins">anoi.ins</a></td>
        <td><a href="clm-ins.scm">clm-ins.scm</a></td>
        <td><a href="clm-ins.rb">clm-ins.rb</a></td>
        <td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>autoc</td>
    <td>autocorrelation-based pitch estimation (Bret Battey)</td>
    <td><a href="autoc.ins">autoc.ins</a></td>
    </tr>

<tr><td>badd</td>
    <td>fancier additive synthesis (Doug Fulton)</td>
    <td><a href="badd.ins">badd.ins</a></td>
    </tr>

<tr><td>fm-bell</td>
    <td>fm bell sounds (Michael McNabb)</td>
    <td><a href="bell.ins">bell.ins</a></td>
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>bigbird</td>
    <td>waveshaping (bird.clm and bird.ins)</td>
    <td><a href="bigbird.ins">bigbird.ins</a></td>
	<td><a href="bird.scm">bird.scm</a></td>
	<td><a href="bird.rb">bird.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs, bird.fs</a></td>
    </tr>

<tr><td>canter</td>            
    <td>fm (<a href="bag.clm">bag.clm</a> -- bagpipes) (Peter Commons)</td>      
    <td><a href="canter.ins">canter.ins</a></td>
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>cellon</td>            
    <td>feedback fm (Stanislaw Krupowicz)</td>      
    <td><a href="cellon.ins">cellon.ins</a></td>    
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>cnvrev</td>            
    <td>convolution (aimed at reverb)</td>      
    <td><a href="cnv.ins">cnv.ins</a></td>          
    </tr>

<tr><td>moving sounds</td>     
    <td>quad sound movement (Fernando Lopez-Lezcano)</td>      
    <td><a href="dlocsig.html">dlocsig.lisp</a></td> 
	<td><a href="dlocsig.scm">dlocsig.scm</a></td>
        <td><a href="dlocsig.rb">dlocsig.rb</a></td>
    </tr>

<tr><td>drone</td>             
    <td>additive synthesis (bag.clm) (Peter Commons)</td>      
    <td><a href="drone.ins">drone.ins</a></td>      
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>granulate-sound</td>   
    <td>examples of the granulate generator (granular synthesis)</td>      
    <td><a href="expsrc.ins">expsrc.ins</a></td>    
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>cross-fade</td>        
    <td>cross-fades and dissolves in the frequency domain</td>      
    <td><a href="fade.ins">fade.ins</a></td>        
	<td><a href="fade.scm">fade.scm</a></td>
    </tr>

<tr><td>filter-sound</td>      
    <td>filter a sound file</td>      
    <td><a href="fltsnd.ins">fltsnd.ins</a></td>    
	<td><a href="dsp.scm">dsp.scm</a></td>
    </tr>

<tr><td>stereo-flute</td>      
    <td>physical model of a flute (Nicky Hind)</td>      
    <td><a href="flute.ins">flute.ins</a></td>      
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>fm examples</td>       
    <td>fm bell, gong, drum (Paul Weineke, Jan Mattox)</td>      
    <td><a href="fmex.ins">fmex.ins</a></td>        
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>Jezar's reverb</td>    
    <td>fancy reverb (Jezar Wakefield)</td>      
    <td><a href="freeverb.html">freeverb/freeverb.ins</a></td> 
	<td><a href="freeverb.scm">freeverb.scm</a></td>
	<td><a href="freeverb.rb">freeverb.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>fofins</td>
    <td>FOF synthesis</td>
    <td><a href="#wave-train">sndclm.html</a></td> 
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>fullmix</td>           
    <td>a mixer</td>      
    <td><a href="fullmix.ins">fullmix.ins</a></td>  
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>grani</td>             
    <td>granular synthesis (Fernando Lopez-Lezcano)</td>      
    <td><a href="grani.ins">grani.ins</a></td>      
	<td><a href="grani.scm">grani.scm</a></td>
    </tr>

<tr><td>grapheq</td>           
    <td>graphic equalizer (Marco Trevisani)</td>      
    <td><a href="grapheq.ins">grapheq.ins</a></td>  
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>fm-insect</td>         
    <td>fm</td>      
    <td><a href="insect.ins">insect.ins</a></td>    
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
    </tr>

<tr><td>jc-reverb</td>         
    <td>an old reverberator (jlrev is a cavernous version)</td>      
    <td><a href="jcrev.ins">jcrev.ins</a></td>      
	<td><a href="jcrev.scm">jcrev.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>fm-voice</td>          
    <td>fm voice (John Chowning)</td>      
    <td><a href="jcvoi.ins">jcvoi.ins</a></td>      
    </tr>

<tr><td>kiprev</td>            
    <td>a fancier (temperamental) reverberator (Kip Sheeline)</td>      
    <td><a href="kiprev.ins">kiprev.ins</a></td>    
    </tr>

<tr><td>lbj-piano</td>         
    <td>additive synthesis piano (Doug Fulton)</td>      
    <td><a href="lbjPiano.ins">lbjPiano.ins</a></td> 
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>maraca</td>            
    <td>Perry Cook's maraca physical models</td>      
    <td><a href="maraca.ins">maraca.ins</a></td>    
	<td><a href="maraca.scm">maraca.scm</a></td>
	<td><a href="maraca.rb">maraca.rb</a></td>
    </tr>

<tr><td>maxfilter</td>         
    <td>Juan Reyes modular synthesis</td>      
    <td><a href="maxf.ins">maxf.ins</a></td>        
	<td><a href="maxf.scm">maxf.scm</a></td>
	<td><a href="maxf.rb">maxf.rb</a></td>
    </tr>

<tr><td>mlb-voice</td>         
    <td>fm (originally waveshaping) voice (Marc LeBrun)</td>      
    <td><a href="mlbvoi.ins">mlbvoi.ins</a></td>
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>moog filters</td>      
    <td>Moog filters (Fernando Lopez-Lezcano)</td>      
    <td><a href="moog.lisp">moog.lisp</a></td>      
	<td><a href="moog.scm">moog.scm</a></td>
    </tr>

<tr><td>fm-noise</td>          
    <td>noise maker</td>      
    <td><a href="noise.ins">noise.ins</a></td>      
	<td><a href="noise.scm">noise.scm</a></td>
	<td><a href="noise.rb">noise.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>nrev</td>              
    <td>a popular reverberator (Michael McNabb)</td>      
    <td><a href="nrev.ins">nrev.ins</a></td>        
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>one-cut</td>           
    <td>a "cut and paste" instrument (Fernando Lopez-Lezcano)</td>      
    <td><a href="one-cut.ins">one-cut.ins</a></td>  
    </tr>

<tr><td>p</td>                 
    <td>Scott van Duyne's piano physical model</td>      
    <td><a href="piano.ins">piano.ins</a></td>      
	<td><a href="piano.scm">piano.scm</a></td>
	<td><a href="piano.rb">piano.rb</a></td>
    </tr>

<tr><td>pluck</td>             
    <td>Karplus-Strong synthesis (David Jaffe)</td>      
    <td><a href="pluck.ins">pluck.ins</a></td>      
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>pqw</td>               
    <td>waveshaping</td>      
    <td><a href="pqw.ins">pqw.ins</a></td>          
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>	
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>pqw-vox</td>           
    <td>waveshaping voice</td>      
    <td><a href="pqwvox.ins">pqwvox.ins</a></td>    
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>physical models</td>   
    <td>physical modelling (Perry Cook)</td>      
    <td><a href="prc-toolkit95.lisp">prc-toolkit95.lisp</a></td>
	<td><a href="prc95.scm">prc95.scm</a></td>
	<td><a href="prc95.rb">prc95.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>various ins</td>       
    <td>from Perry Cook's Synthesis Toolkit</td>      
    <td><a href="prc96.ins">prc96.ins</a></td>      
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>pvoc</td>              
    <td>phase vocoder (Michael Klingbeil)</td>      
    <td><a href="pvoc.ins">pvoc.ins</a></td>        
	<td><a href="pvoc.scm">pvoc.scm</a></td>
	<td><a href="pvoc.rb">pvoc.rb</a></td>
    </tr>

<tr><td>resflt</td>            
    <td>filters (3 resonators) (Xavier Serra, Richard Karpen)</td>      
    <td><a href="resflt.ins">resflt.ins</a></td>    
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>reson</td>             
    <td>fm formants (John Chowning)</td>      
    <td><a href="reson.ins">reson.ins</a></td>      
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>ring-modulate</td>     
    <td>ring-modulation of sounds (Craig Sapp)</td>      
    <td><a href="ring-modulate.ins">ring-modulate.ins</a></td>
	<td><a href="examp.scm">examp.scm</a></td>
	<td><a href="examp.rb">examp.rb</a></td>
    </tr>

<tr><td>rmsenv</td>            
    <td>rms envelope of sound (Bret Battey)</td>      
    <td><a href="rmsenv.ins">rmsenv.ins</a></td>    
    </tr>

<tr><td>track-rms</td>         
    <td>rms envelope of sound file (Michael Edwards)</td>      
    <td><a href="rmsp.ins">rmsp.ins</a></td>        
    </tr>

<tr><td>pins</td>              
    <td>spectral modelling</td>      
    <td><a href="san.ins">san.ins</a></td>          
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>scanned</td>           
    <td>Juan Reyes scanned synthesis instrument</td>      
    <td><a href="scanned.ins">scanned.ins</a></td>  
	<td><a href="dsp.scm">dsp.scm</a></td>
    </tr>

<tr><td>scentroid</td>         
    <td>spectral scentroid envelope (Bret Battey)</td>      
    <td><a href="scentroid.ins">scentroid.ins</a></td> 
	<td><a href="dsp.scm">dsp.scm</a></td>
    </tr>

<tr><td>shepard</td>            
    <td>Shepard tones (Juan Reyes)</td>      
    <td><a href="shepard.ins">shepard.ins</a></td>    
	<td><a href="sndscm.html#wsdoc">sndscm.html</a></td>
	<td></td>
    </tr>

<tr><td>singer</td>            
    <td>Perry Cook's vocal tract physical model</td>      
    <td><a href="singer.ins">singer.ins</a></td>    
	<td><a href="singer.scm">singer.scm</a></td>
	<td><a href="singer.rb">singer.rb</a></td>
    </tr>

<tr><td>sndwarp</td>           
    <td>Csound-like sndwarp generator (Bret Battey)</td>      
    <td><a href="sndwarp.ins">sndwarp.ins</a></td>   
	<td><a href="sndwarp.scm">sndwarp.scm</a></td>
    </tr>

<tr><td>stochastic</td>        
    <td>Bill Sack's stochastic synthesis implementation</td>      
    <td><a href="stochastic.ins">stochastic.ins</a></td>
    </tr>

<tr><td>bow</td>               
    <td>Juan Reyes bowed string physical model</td>      
    <td><a href="strad.ins">strad.ins</a></td>      
	<td><a href="strad.scm">strad.scm</a></td>
	<td><a href="strad.rb">strad.rb</a></td>
    </tr>

<tr><td>fm-trumpet</td>        
    <td>fm trumpet (Dexter Morrill)</td>      
    <td><a href="trp.ins">trp.ins</a></td>          
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>various ins</td>       
    <td>granular synthesis, formants, etc</td>      
    <td><a href="ugex.ins">ugex.ins</a></td>        
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
    </tr>

<tr><td>test ins</td>          
    <td>CLM regression tests -- see clm-test.lisp</td>      
    <td><a href="ug.ins">ug(1,2,3,4).ins</a></td>   
	<td><a href="clm23.scm">clm23.scm</a></td>
    </tr>

<tr><td>fm-violin</td>         
    <td>fm violin (fmviolin.clm, popi.clm)</td>      
    <td><a href="v.ins">v.ins</a></td>              
	<td><a href="v.scm">v.scm</a></td>
	<td><a href="v.rb">v.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>vowel</td>             
    <td>vowels via pulse-train and formant (Michelle Daniels)</td>      
    <td><a href="vowel.ins">vowel.ins</a></td>      
    </tr>

<tr><td>vox</td>               
    <td>fm voice (cream.clm)</td>      
    <td><a href="vox.ins">vox.ins</a></td>          
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>zc, zn</td>            
    <td>interpolating delays</td>      
    <td><a href="zd.ins">zd.ins</a></td>            
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>zipper</td>            
    <td>The 'digital zipper' effect.</td>      
    <td><a href="zipper.ins">zipper.ins</a></td>    
	<td><a href="zip.scm">zip.scm</a></td>
	<td><a href="zip.rb">zip.rb</a></td>
    </tr>

</table>

<p>
If you develop
an interesting instrument that you're willing to share, please send it to me
(bil@ccrma.stanford.edu). 
</p>

<p>The individual instruments and <a href="sndscm.html#wsdoc">with-sound</a> are documented primarily in sndscm.html.
</p>


<br><br>
<center>
<table bgcolor="aliceblue" border=0 cellspacing=8><tr>
<td><small>related documentation:</small></td>
<td><small><a href="snd.html" onmouseover="return escape('basic Snd user-interface documentation')">snd.html</a></small></td>
<td><small><a href="extsnd.html" onmouseover="return escape('Snd extension and customization')">extsnd.html</a></small></td>
<td><small><a href="grfsnd.html" onmouseover="return escape('Snd configuration, connection to other libraries and programs')">grfsnd.html</a></small></td>
<td><small><a href="sndscm.html" onmouseover="return escape('Scheme, Ruby, and Forth files included with Snd')">sndscm.html</a></small></td>
<td><small><a href="fm.html" onmouseover="return escape('introduction to frequency modulation')">fm.html</a></small></td>
<td><small><a href="sndlib.html" onmouseover="return escape('library that handles sound files')">sndlib.html</a></small></td>
<td><small><a href="libxm.html" onmouseover="return escape('library that ties Motif and Gtk into Snd')">libxm.html</a></small></td>
<td><small><a href="index.html" onmouseover="return escape('this is an actual index, not some introductory file')">index.html</a></small></td>
</tr></table>
</center>

<script language=JavaScript type="text/javascript" src="wz_tooltip.js"></script>
</body></html>
