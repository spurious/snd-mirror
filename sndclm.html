<html>
<head>
<title>CLM</title>
<style type="text/css">
<!-- 
	EM.red {color:red; font-style: normal}
	EM.gen {font-weight: bold; font-style: normal}
        EM.error {color:chocolate; font-style: normal}
        EM.narg {color:chocolate; font-style: normal}
        EM.typing {color:maroon; font-style: normal}
        EM.listener {color:darkblue; font-style: normal}
	H1 {text-align: center}
	UL {list-style-type: none}
	EM.emdef {font-weight: bold; font-style: normal; padding-right: 0.2cm}

	A {text-decoration:none}
	A:hover {text-decoration:underline}
	A.quiet {color:black; text-decoration:none}
	A.quiet:hover {text-decoration:underline}
	A.invisible {color:white; text-decoration:none}
	A.def {font-weight: bold; font-style: normal; text-decoration:none; text-color:black; padding-right: 0.2cm}
	A.olddef {font-style: normal; text-decoration:none; color:gray; padding-right: 0.2cm}
	EM.gray {color:gray; font-style: normal}
-->

<!-- the latex stuff is always embedded in:

\documentclass{amsart}
\begin{document}
\thispagestyle{empty}
\small
\begin{displaymath}
...
\end{displaymath}
\end{document}

where the "displaymath" lines change to fit the situation


in the new (FC9) latex/pdf2png case, I need:

\documentclass[fleqn,11pt]{amsart}

\setlength\paperwidth{1500pt}
\setlength\textwidth{1200pt}

\begin{document}
...

and then in the output PDF file, set the line
/MediaBox [0 0 595.276 841.89]
to something like
/MediaBox [0 0 1595.276 841.89]
before calling pdf2png

pdf2png is in the cairo tarball (cairo/test dir)
-->

</style>
</head>
<body bgcolor=white>

<script language=JavaScript type="text/javascript" src="wz_tooltip.js"></script>
<script language=JavaScript type="text/javascript" src="wz_data.js"></script>

<A NAME="sndclmtop"></A><h1>CLM</h1>

<p>CLM (originally an acronym for Common Lisp Music) is a sound synthesis
package in the Music V family.  This file describes CLM as implemented in Snd,
aiming primarily at the Scheme version.  Common Lisp users should check out clm.html
in the CLM tarball.
CLM is based on a set of functions known
as "generators".  These can be packaged into "instruments", and instrument calls
can be packaged into "note lists".  (These names are just convenient historical artifacts).
The main emphasis here is on the generators;
note lists and instruments are described in <a href="sndscm.html">sndscm.html</a>.
</p>
<br>


<center>Bill Schottstaedt (bil@ccrma.stanford.edu)</center>
<br>

<center>
<table bgcolor="aliceblue" border=0 cellspacing=8><tr>
<td><small>related documentation:</small></td>
<td><small><a href="snd.html" onmouseout="UnTip()" onmouseover="Tip(snd_html_tip)">snd.html</a></small></td>
<td><small><a href="extsnd.html" onmouseout="UnTip()" onmouseover="Tip(extsnd_html_tip)">extsnd.html</a></small></td>
<td><small><a href="grfsnd.html" onmouseout="UnTip()" onmouseover="Tip(grfsnd_html_tip)">grfsnd.html</a></small></td>
<td><small><a href="sndscm.html" onmouseout="UnTip()" onmouseover="Tip(sndscm_html_tip)">sndscm.html</a></small></td>
<td><small><a href="fm.html" onmouseout="UnTip()" onmouseover="Tip(fm_html_tip)">fm.html</a></small></td>
<td><small><a href="sndlib.html" onmouseout="UnTip()" onmouseover="Tip(sndlib_html_tip)">sndlib.html</a></small></td>
<td><small><a href="libxm.html" onmouseout="UnTip()" onmouseover="Tip(libxm_html_tip)">libxm.html</a></small></td>
<td><small><a href="s7.html" onmouseout="UnTip()" onmouseover="Tip(s7_html_tip)">s7.html</a></small></td>
<td><small><a href="index.html" onmouseout="UnTip()" onmouseover="Tip(index_html_tip)">index.html</a></small></td>
</tr></table>
</center>

<br>
<br>


<table border=0 bordercolor="lightgreen" width=100% cellpadding=2 cellspacing=0><tr><td bgcolor="lightgreen">
<table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2>Contents</h2></td></tr></table>
</td></tr></table>

<br>
<table border=8 bordercolor="lightsteelblue" cellpadding=8 hspace=20>

<tr><td colspan=3><center><a href="#introduction">Introduction</a></center></td></tr>

<tr><td colspan=3><center><a href="#generators">Built-in Generators</a></center></td></tr>

<tr><td width=20 bgcolor="#f2f4ff"></td><td>
<table border=0 cellpadding=0>
  <tr><td><a href="#all-passdoc">all-pass</a></td><td width=20></td><td>all-pass filter</td></tr>
  <tr><td><a href="#asymmetric-fmdoc">asymmetric-fm</a></td><td></td><td>asymmetric fm</td></tr>
  <tr><td><a href="#combdoc">comb</a></td><td></td><td>comb filter</td></tr>
  <tr><td><a href="#convolvedoc">convolve</a></td><td></td><td>convolution</td></tr>
  <tr><td><a href="#delaydoc">delay</a></td><td></td><td>delay line</td></tr>
  <tr><td><a href="#envdoc">env</a></td><td></td><td>line segment envelope</td></tr>
  <tr><td><a href="#filetosampledoc">file-&gt;sample</a></td><td></td><td>input sample from file</td></tr>
  <tr><td><a href="#filetoframe">file-&gt;frame</a></td><td></td><td>input frame from file</td></tr>
  <tr><td><a href="#filterdoc">filter</a></td><td></td><td>direct form FIR/IIR filter</td></tr>
  <tr><td><a href="#combdoc">filtered-comb</a></td><td></td><td>comb filter with filter on feedback</td></tr>
  <tr><td><a href="#fir-filterdoc">fir-filter</a></td><td></td><td>FIR filter</td></tr>
  <tr><td><a href="#formantdoc">formant and firmant</a></td><td></td><td>resonance</td></tr>
  <tr><td><a href="#frametofile">frame-&gt;file</a></td><td></td><td>output frame to file</td></tr>
  <tr><td><a href="#granulatedoc">granulate</a></td><td></td><td>granular synthesis</td></tr>
  <tr><td><a href="#iir-filterdoc">iir-filter</a></td><td></td><td>IIR filter</td></tr>
  <tr><td><a href="#in-anydoc">in-any</a></td><td></td><td>sound file input</td></tr>
  <tr><td><a href="#locsigdoc">locsig</a></td><td></td><td>static sound placement</td></tr>
  <tr><td><a href="#move-sounddoc">move-sound</a></td><td></td><td>sound motion</td></tr>
  <tr><td><a href="#moving-averagedoc">moving-average</a></td><td></td><td>moving window average</td></tr>
  <tr><td><a href="#ncosdoc">ncos</a></td><td></td><td>n equal amplitude cosines</td></tr>
  <tr><td><a href="#notchdoc">notch</a></td><td></td><td>notch filter</td></tr>
  <tr><td><a href="#nrxydoc">nrxycos</a></td><td></td><td>n scaled cosines</td></tr>
</table>
</td>
<td>
<table border=0 cellpadding=0>
  <tr><td><a href="#nrxydoc">nrxysin</a></td><td></td><td>n scaled sines</td></tr>
  <tr><td><a href="#ncosdoc">nsin</a></td><td></td><td>n equal amplitude sines</td></tr>
  <tr><td><a href="#one-poledoc">one-pole</a></td><td></td><td>one pole filter</td></tr>
  <tr><td><a href="#one-zerodoc">one-zero</a></td><td></td><td>one zero filter</td></tr>
  <tr><td><a href="#oscildoc">oscil</a></td><td></td><td>sine wave and FM</td></tr>
  <tr><td><a href="#out-anydoc">out-any</a></td><td width=20></td><td>sound output</td></tr>
  <tr><td><a href="#phase-vocoderdoc">phase-vocoder</a></td><td></td><td>vocoder analysis and resynthesis</td></tr>
  <tr><td><a href="#polyshapedoc">polyshape and polywave</a></td><td></td><td>waveshaping</td></tr>
  <tr><td><a href="#sawtoothdoc">pulse-train</a></td><td></td><td>pulse train</td></tr>
  <tr><td><a href="#randdoc">rand, rand-interp</a></td><td></td><td>random numbers, noise</td></tr>
  <tr><td><a href="#readindoc">readin</a></td><td></td><td>sound input</td></tr>
  <tr><td><a href="#sampletofile">sample-&gt;file</a></td><td></td><td>output sample to file</td></tr>
  <tr><td><a href="#sawtoothdoc">sawtooth-wave</a></td><td></td><td>sawtooth</td></tr>
  <tr><td><a href="#sawtoothdoc">square-wave</a></td><td></td><td>square wave</td></tr>
  <tr><td><a href="#srcdoc">src</a></td><td></td><td>sampling rate conversion</td></tr>
  <tr><td><a href="#ssb-amdoc">ssb-am</a></td><td></td><td>single sideband amplitude modulation</td></tr>
  <tr><td><a href="#table-lookupdoc">table-lookup</a></td><td></td><td>interpolated table lookup</td></tr>
  <tr><td><a href="#delaydoc">tap</a></td><td></td><td>delay line tap</td></tr>
  <tr><td><a href="#sawtoothdoc">triangle-wave</a></td><td></td><td>triangle wave</td></tr>
  <tr><td><a href="#two-poledoc">two-pole</a></td><td></td><td>two pole filter</td></tr>
  <tr><td><a href="#two-zerodoc">two-zero</a></td><td></td><td>two zero filter</td></tr>
  <tr><td><a href="#wave-traindoc">wave-train</a></td><td></td><td>wave train</td></tr>
</table>
</td></tr>

<tr><td colspan=3><center><a href="#genericfunctions">Generic Functions</a></center></td></tr>

<tr><td colspan=3><center><a href="#othergenerators">Other Generators</a></center></td></tr>

<tr><td colspan=3><center><a href="#otherfunctions">Other Functions</a></center></td></tr>

<tr><td width=20 bgcolor="#f2f4ff"></td><td>
<table border=0 cellpadding=0>
  <tr><td><a href="#autocorrelate">autocorrelate</a></td><td></td><td>autocorrelation</td></tr>
  <tr><td><a href="#amplitude-modulate">amplitude-modulate</a></td><td></td><td>sig1 * (car + sig2)</td></tr>
  <tr><td><a href="#array-interp">array-interp</a></td><td></td><td>array interpolation</td></tr>
  <tr><td><a href="#contrast-enhancement">contrast-enhancement</a></td><td width=20></td><td>modulate signal</td></tr>
  <tr><td><a href="#convolution">convolution</a></td><td></td><td>convolve signals</td></tr>
  <tr><td><a href="#correlate">correlate</a></td><td></td><td>cross correlation</td></tr>
</table>
</td>
<td>
<table border=0 cellpadding=0>
  <tr><td><a href="#dot-product">dot-product</a></td><td></td><td>vct dot (scalar) product</td></tr>
  <tr><td><a href="#fft">fft</a></td><td></td><td>Fourier transform</td></tr>
  <tr><td><a href="#make-fft-window">make-fft-window</a></td><td></td><td>various standard windows</td></tr>
  <tr><td><a href="#polynomial">polynomial</a></td><td width=20></td><td>Horner's rule</td></tr>
  <tr><td><a href="#ring-modulate">ring-modulate</a></td><td width=20></td><td>sig * sig</td></tr>
  <tr><td><a href="#spectrum">spectrum</a></td><td width=20></td><td>power spectrum of signal</td></tr>
</table>
</td></tr>

<tr><td colspan=3><center><a href="#instruments">Instruments</a></center></td></tr>
</table>


<br><br>

<table border=0 bordercolor="lightgreen" width=100% cellpadding=2 cellspacing=0><tr><td bgcolor="lightgreen">
<table width="100%" border=0><tr><td bgcolor="beige" align="center" valign="middle"><h2><A class=def NAME="introduction">Introduction</a></h2></td></tr></table>
</td></tr></table>

<table border=0 hspace=100 vspace=20><tr><td>
<p><small>
If you try to make
new sounds, or recreate and alter existing sounds, you'll find that there are
some functions that seem to pop up everywhere.  The basic
building block of sound is the sinusoid, so we have things like oscil and polywave.
Another basic thing is noise, so we have rand and rand-interp.
Sounds get louder and softer, or go up and down in pitch, so we have envelopes (env).
We need a way to get at them (in-any, readin), and play them (out-any, locsig).
We need tons of reverb (delay, convolve).
</small></p></td></tr></table>

<p>Start Snd, open the listener (choose "Show listener" in the View menu), and:
</p>

<pre>
    <em class=listener>&gt;</em><em class=typing>(load "v.scm")</em>
    <em class=listener>fm-violin</em>
    <em class=listener>&gt;</em><em class=typing>(with-sound () (fm-violin 0 1 440 .1))</em>
    <em class=listener>"test.snd"</em>
</pre>

<p>Snd's printout is in blue here, and your typing is in red.
If all went well, you should see a graph of the fm-violin's output.  Click the "play" button to
hear it; click "f" to see its spectrum.
</p>

<p>
In Ruby, we'd do it this way:
</p>

<pre>
    <em class=listener>&gt;</em><em class=typing>load "v.rb"</em>
    <em class=listener>true</em>
    <em class=listener>&gt;</em><em class=typing>with_sound() do fm_violin_rb(0, 1.0, 440.0, 0.1) end</em>
    <em class=listener>#&lt;With_CLM: output: "test.snd", channels: 1, srate: 22050&gt;</em>
</pre>

<p>and in Forth:
</p>
<pre>
    <em class=listener>snd&gt;</em> <em class=typing>"clm-ins.fs" file-eval</em>
    <em class=listener>0</em>
    <em class=listener>snd&gt;</em> <em class=typing>0.0 1.0 440.0 0.1 ' fm-violin with-sound</em>
    <em class=listener>\ filename: test.snd</em>
</pre>


<p>In most of this document, I'll stick with Scheme as implemented by s7.  
<a href="extsnd.html">extsnd.html</a> and <a href="sndscm.html">sndscm.html</a> have numerous
Ruby and Forth examples, and I'll toss some in here as I go along.
You can save yourself a lot of typing by using two features of the listener.  First, &lt;TAB&gt; (that is, the key marked TAB) tries to complete 
the current name, so if you type "fm-&lt;TAB&gt;" the listener completes the name as "fm-violin".
And second, you can back up to a previous expression, edit it, move the cursor to the closing parenthesis, and
type &lt;RETURN&gt;, and that expression will be evaluated as if you had typed all of it in from the start. 
Needless to say, you can paste code from this file into the Snd listener.
</p>

<p>with-sound opens an output sound file, evaluates its body, closes the file, and then opens it in Snd.
If the sound is already open, with-sound replaces it with the new version. 
The body of with-sound can be any size, and can include anything that you could put in a function body.
For example, 
to get an arpeggio:</p>
<pre>
    (with-sound ()
      (do ((i 0 (+ 1 i)))
          ((= i 8))
        (fm-violin (* i .25) .5 (* 100 (+ 1 i)) .1)))
</pre>

<table border=0 hspace=40><tr><td>
<p>If that seemed to take awhile, make sure you've turned on <a href="extsnd.html#optimization">optimization</a>:
</p>

<pre>
    <em class=listener>&gt;</em><em class=typing>(set! (optimization) 6)</em>
    <em class=listener>6</em>
</pre>

<p>The optimizer, a macro named "run", can usually speed up computations by about a factor of 10.
</p>
</td></tr></table>


<p>with-sound, instruments, CLM itself are all optional, of course.  We could
do everything by hand:
</p>

<pre>
    (let ((sound (<a class=quiet href="extsnd.html#newsound" onmouseout="UnTip()" onmouseover="Tip(extsnd_newsound_tip)">new-sound</a> "test.snd" :size 22050))
          (increment (/ (* 440.0 2.0 pi) 22050.0))
          (current-phase 0.0))
      (<a class=quiet href="extsnd.html#mapchannel" onmouseout="UnTip()" onmouseover="Tip(extsnd_mapchannel_tip)">map-channel</a> (lambda (y)
	    	     (let ((val (* .1 (sin current-phase))))
		       (set! current-phase (+ current-phase increment))
		       val))))
</pre>

<p>This opens a sound file (via <a href="extsnd.html#newsound">new-sound</a>) and fills it with a .1 amplitude sine wave at 440 Hz.
The "increment" calculation turns 440 Hz into a phase increment in radians (we could also use the function <a href="#hztoradians">hz-&gt;radians</a>).
The "oscil" generator keeps track of the phase increment for us, so
essentially the same thing using with-sound and oscil is:
</p>

<pre>
    (with-sound ()
      (let ((osc (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> 440.0)))
        (do ((i 0 (+ 1 i)))
	    ((= i 44100))
          (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* .1 (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> osc)) *output*))))
</pre>

<p>*output* is the file opened by with-sound, and outa is a function that adds its second
argument (the sinusoid) into the current output at the sample given by its first argument
("i" in this case).  oscil is our sinusoid generator, created by make-oscil.  You don't
need to worry about freeing the oscil; we can depend on the Scheme garbage collector to
deal with that.  All the generators are like oscil in that
each is a function that on each call returns the next sample in an infinite stream of samples.
An oscillator, for example, returns an endless sine wave, one sample
at a time.  
Each generator consists of a set of functions:  make-&lt;gen&gt; sets up the
data structure associated with the generator;
&lt;gen&gt; produces a new sample;
&lt;gen&gt;? checks whether a variable is that kind of generator.
Current generator state is accessible via various generic functions such as mus-frequency:
</p>
<pre>
    (set! oscillator (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> :frequency 330))
</pre>
<p>prepares "oscillator" to produce a sine wave
when set in motion via</p>
<pre>
    (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> oscillator)
</pre>

<p>
The make-&lt;gen&gt; function
takes a number of optional arguments, setting whatever state the given
generator needs to operate on.  The run-time function's first argument is
always its associated structure.  Its second argument is nearly always
something like an FM input or whatever run-time modulation might be
desired.
Frequency sweeps of all kinds (vibrato, glissando, breath
noise, FM proper) are all forms of frequency modulation.  So, in
normal usage, our oscillator looks something like:</p>
<pre>
    (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> oscillator (+ vibrato glissando frequency-modulation))
</pre>

<p>One special aspect of each make-&lt;gen&gt; function is the way it
reads its arguments.  I use parenthesized parameters
in the function definitions to indicate that the argument names are
keywords, but the keywords themselves are optional.
Take the make-oscil call, defined as:</p>
<pre>
    make-oscil (frequency *clm-default-frequency*) (initial-phase 0.0)
</pre>
<p>This says that make-oscil has two optional arguments, frequency (in Hz), and
initial-phase (in radians).  The keywords associated with these values are
:frequency and :initial-phase.
When make-oscil is called, it scans its arguments; if a keyword is seen, that
argument and all following arguments are passed unchanged, but if a value is
seen, the corresponding keyword is prepended in the argument list:
</p>
<pre>
    (<a class=quiet href="#make-oscil">make-oscil</a> :frequency 440.0)
    (<a class=quiet href="#make-oscil">make-oscil</a> :frequency 440.0 :initial-phase 0.0)
    (<a class=quiet href="#make-oscil">make-oscil</a> 440.0)
    (<a class=quiet href="#make-oscil">make-oscil</a> 440.0 :initial-phase 0.0)
    (<a class=quiet href="#make-oscil">make-oscil</a> 440.0 0.0)
</pre>
<p>are all equivalent, but</p>
<pre>
    (<a class=quiet href="#make-oscil">make-oscil</a> :frequency 440.0 0.0)
    (<a class=quiet href="#make-oscil">make-oscil</a> :initial-phase 0.0 440.0)
</pre>

<p>are in error, because once we see any keyword, all the rest of the arguments have
to use keywords too (we can't reliably make any assumptions after that point about argument
ordering). 
This style of argument passing is the same as that of s7's define*, and is very similar to the "Optional
Positional and Named Parameters" extension of scheme: <a href="http://srfi.schemers.org/srfi-89/">SRFI-89</a>.
</p>

<p>Since we often want to use a given sound-producing algorithm many times (in a note list,
for example), it is convenient to package up that code into a function. Our sinewave
could be rewritten:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(define (simp start end freq amp)
  (let ((os (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> freq)))
    (do ((i start (+ 1 i))) 
        ((= i end))
      (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* amp (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> os)))))) ; outa output defaults to *output* so we can omit it
</pre>
</td></tr></table>

<p>Now to hear our sine wave:</p>
<pre>
    (with-sound (:play #t) (simp 0 44100 330 .1))
</pre>

<p>This version of "simp" forces you to think in terms of sample numbers ("start" and "end") which
are dependent on the sampling rate.  Our first enhancement is to use seconds:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(define (simp beg dur freq amp)
  (let* ((os (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> freq))
	 (<em class=red>start</em> (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> beg))
	 (<em class=red>end</em> (+ start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur))))
    (do ((i start (+ 1 i))) 
        ((= i end))
      (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* amp (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> os))))))
</pre>
</td></tr></table>

<p>Now we can use any sampling rate, and call "simp" using seconds:
</p>
<pre>
    (with-sound (:srate 44100) (simp 0 1.0 440.0 0.1))
</pre>

<p>Our next improvement adds the "run" macro to speed up processing by about a factor of 10:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(define (simp beg dur freq amp)
  (let* ((os (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> freq))
	 (start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> beg))
	 (end (+ start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur))))
    (<em class=red>run</em>
      (do ((i start (+ 1 i))) 
          ((= i end))
        (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* amp (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> os)))))))
</pre>
</td></tr></table>

<p>Since we're using a do loop in all these examples, we could save some typing by
defining a macro to package up the run and loop boiler-plate:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(define-macro (run-loop start end . body) 
  `(run 
    (do ((i ,start (+ i 1))) 
         ((= i ,end)) 
       ,@body)))
</pre>
</td></tr></table>

<p>and now our instrument is just:
</p>
<table border=0 hspace=40><tr><td>
<pre>
(define (simp beg dur freq amp)
  (let* ((os (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> freq))
	 (start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> beg))
	 (end (+ start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur))))
    (<em class=red>run-loop</em> start end
     (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* amp (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> os))))))
</pre>
</td></tr></table>

<p>But I think I'll stick with the do loops in this document.
Next we turn the "simp" function into an "instrument".  An instrument is
a function that has a variety of built-in actions within with-sound.  The only change
is the word "definstrument":
</p>

<table border=0 hspace=40><tr><td>
<pre>
(<em class=red>definstrument</em> (simp beg dur freq amp)
  (let* ((os (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> freq))
	 (start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> beg))
	 (end (+ start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur))))
    (run
      (do ((i start (+ 1 i))) 
          ((= i end))
        (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* amp (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> os)))))))
</pre>
</td></tr></table>

<p>Now we can simulate a telephone:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(define (telephone start telephone-number)
  (let ((touch-tab-1 '(0 697 697 697 770 770 770 852 852 852 941 941 941))
	(touch-tab-2 '(0 1209 1336 1477 1209 1336 1477 1209 1336 1477 1209 1336 1477)))
    (do ((i 0 (+ 1 i)))
	((= i (length telephone-number)))
      (let* ((num (telephone-number i))
	     (frq1 (touch-tab-1 num))
	     (frq2 (touch-tab-2 num)))
        (<em class=red>simp</em> (+ start (* i .4)) .3 frq1 .1)
        (<em class=red>simp</em> (+ start (* i .4)) .3 frq2 .1)))))

(with-sound () (telephone 0.0 '(7 2 3 4 9 7 1)))
</pre>
</td></tr></table>

<p>As a last change, let's add an amplitude envelope:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (simp beg dur freq amp envelope)
  (let* ((os (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> freq))
         (<em class=red>amp-env</em> (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> envelope :duration dur :scaler amp))
	 (start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> beg))
         (end (+ start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur))))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
      (do ((i start (+ 1 i))) 
          ((= i end))
        (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> <em class=red>amp-env</em>) (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> os)))))))
</pre>
</td></tr></table>

<p>A CLM envelope is a list of (x y) break-point pairs.  The
x-axis bounds are arbitrary, but it is conventional (here at ccrma) to
go from 0 to 1.0.  The y-axis values are normally between -1.0 and
1.0, to make it easier to figure out how to apply the envelope in
various different situations.  
</p>

<pre>
    (with-sound () (simp 0 2 440 .1 '(0 0  0.1 1.0  1.0 0.0)))
</pre>

<p>Add a few more oscils and envs, and you've got the fm-violin.  You can try out a generator or a patch of generators quickly by
plugging it into the following with-sound call:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(with-sound () 
  (let ((sqr (make-square-wave 100))) ; test a square-wave generator
    (do ((i 0 (+ 1 i))) 
        ((= i 10000)) 
      (outa i (square-wave sqr)))))
</pre>
</td></tr></table>

<p>By the way, there's nothing special about a generator in CLM: it is a function, or perhaps more accurately, a closure.  
If such a function happens to restrict itself
to functions that the "run" macro can handle (and this includes most of Scheme), then it will run
nearly as fast as any built-in function.  If it needs to keep on-going state around, it is simplest to use a vct
as the generator object:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(define (<A NAME="make-my-oscil">make-my-oscil</A> frequency)       ; we want our own oscil!
  (<a class=quiet href="extsnd.html#vct" onmouseout="UnTip()" onmouseover="Tip(extsnd_vct_tip)">vct</a> 0.0 (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> frequency)))    ; current phase and frequency-based phase increment

(define (my-oscil gen fm)       ; the corresponding generator
  (let ((result (sin (gen 0)))) ; return sin(current-phase)
    (set! (gen 0) (+ (gen 0)    ; increment current phase
                       (gen 1)  ;    by frequency
                       fm))     ;    and FM
    result))                    ; return sine wave

(with-sound () 
  (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a> 
   (let ((osc (make-my-oscil 440.0)))
     (do ((i 0 (+ 1 i))) 
         ((= i 44100))
       (outa i (my-oscil osc 0.0))))))
</pre>
</td></tr></table>

<p>There are many more such generators scattered around the Snd package, most now collected in generators.scm.
I'm also writing pure-scheme versions of the built-in generators: big-gens.scm.  For comparison, here is the sinewave
instrument in Grace (Common Music) and Snd-rt:
</p>
<table border=0 hspace=40><tr><td>
<pre>

file "test.wav" () 
  with osc = make-oscil(440) 
  loop for i below 44100 
       outa(i, .1 * oscil(osc)) 
  end 
end 


snd-rt:

(&lt;rt-out&gt; :len 1 (oscil :freq 440)) 

(&lt;rt-stalin&gt;
   (sound :dur 1:-s 
     (out (oscil :freq 440)))) 
</pre>
</td></tr></table>

<br><br>


<!-- INDEX generators:Generators -->
<table width="80%" border=0><tr><td bgcolor="lightsteelblue" valign="middle"><h2><A class=def NAME="generators">Generators</a></h2></td></tr></table>
<br><br>


<A NAME="oscildoc"></A>
<!-- ---------------------------------------- OSCIL ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>oscil</h3></center></td></tr></table>
<br>
<pre>
  <a class=def name="make-oscil">make-oscil</a> (frequency *clm-default-frequency*) (initial-phase 0.0)
  <a class=def name="oscil">oscil</a> os (fm-input 0.0) (pm-input 0.0)
  <a class=def name="oscil?">oscil?</a> os
</pre>


<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t)
  (let ((gen (make-oscil 440.0)))
    (do ((i 0 (+ 1 i)))
        ((= i 44100))
      (outa i (* 0.5 (oscil gen))))))
</pre>
</td>

<td width=4></td>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true) do
  gen = make_oscil(440.0);
  44100.times do |i| 
    outa(i, 0.5 * oscil(gen), $output) 
    end
  end.output
</pre>
</td>

<td width=4></td>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  440.0 make-oscil { gen }
  44100 0 do
    i  gen 0 0 oscil  f2/ *output* outa drop
  loop
; :play #t with-sound drop
</pre>
</td>
</tr>
</table>


<p>oscil produces a sine wave (using sin) with optional frequency change (FM).
Its first argument is an oscil created by make-oscil.
Oscil's second argument is the 
frequency change (frequency modulation), and the third argument is the
phase change (phase modulation).
The initial-phase argument to make-oscil is in radians. You can
use <a href="#degreestoradians">degrees-&gt;radians</a> to convert from degrees to radians.
To get a cosine (as opposed to sine), set the initial-phase to (/ pi 2).
</p>

<table border=1 align=left hspace=40 vspace=10 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>oscil methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>frequency in Hz</td></tr>
<tr><td><em class=gen>mus-phase</em></td><td>phase in radians</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>1 (no set!)</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>frequency in radians per sample</td></tr>
</table>
<br>
<pre>
  (let ((result (sin (+ phase pm-input))))
    (set! phase (+ phase (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> frequency) fm-input))
    result)
<!--  <img src="pix/sceq9.png" alt="fnm equation" hspace=10 vspace=10> -->
</pre>
<!-- LATEX: \cos \, (\omega_{c}t+B\sin \omega_{m}t)\:=\!\!\sum_{n=-\infty}^{\infty} \! \! J_{n}(B)\cos(\omega_{c} + n\omega_{m})t -->
<br clear=left>

<p>One slightly confusing aspect of oscil is that glissando has to be turned into a phase-increment envelope.
This means that the frequency envelope y values should be passed through <a href="#hztoradians">hz-&gt;radians</a>:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(define (simp start end freq amp frq-env)
  (let ((os (make-oscil freq)) 
        (frqe (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> frq-env :length (+ 1 (- end start)) :scaler (<em class=red>hz-&gt;radians</em> freq))))
    (do ((i start (+ 1 i))) 
        ((= i end))
      (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* amp (oscil os (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> <em class=red>frqe</em>)))))))

(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () (simp 0 10000 440 .1 '(0 0 1 1))) ; sweep up an octave
</pre>
</td></tr></table>

<p>Here is an example of FM (here the <a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> business is folded into the FM index):
</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (simple-fm beg dur freq amp mc-ratio index amp-env index-env)
  (let* ((start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> beg))
	 (end (+ start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur)))
	 (cr (<em class=red>make-oscil</em> freq))                     ; carrier
         (md (<em class=red>make-oscil</em> (* freq mc-ratio)))        ; modulator
         (fm-index (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> (* index mc-ratio freq)))
         (ampf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> (or amp-env '(0 0  .5 1  1 0)) :scaler amp :duration dur))
         (indf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> (or index-env '(0 0  .5 1  1 0)) :scaler fm-index :duration dur)))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
      (do ((i start (+ 1 i)))
          ((= i end))
        (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> ampf) 
                   (<em class=red>oscil</em> cr (* (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> indf) 
                 
               (<em class=red>oscil</em> md)))))))))

;;; (<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () (simple-fm 0 1 440 .1 2 1.0))
</pre>
</td></tr></table>

<p><a href="fm.html">fm.html</a> has an introduction to FM.
FM and PM behave slightly differently during a glissando; FM is the more "natural" in that, left to its own devices,
it produces a spectrum that varies inversely with the pitch.  Compare these two cases.  Both involve a slow glissando
up an octave, FM in channel 0, and PM in channel 1.  In the first note, I fix up the FM index during the sweep to
keep the spectra steady, and in the second, I fix up the PM index.
</p>

<table border=0 cellpadding=6 hspace=20>
<tr><td>
<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:channels 2)
  (let* ((dur 2.0)
	 (samps (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur))
	 (pitch 1000)
	 (modpitch 100)
	 (pm-index 4.0)
	 (fm-index (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> (* 4.0 modpitch))))
    (let* ((car1 (make-oscil pitch))
	   (mod1 (make-oscil modpitch))
	   (car2 (make-oscil pitch))
	   (mod2 (make-oscil modpitch))
	   (frqf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1) :duration dur))
	   (ampf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1 20 1 21 0) :duration dur :scaler .5)))
      (do ((i 0 (+ 1 i)))
	  ((= i samps))
	(let* ((frq (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> frqf))
	       (rfrq (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> frq))
	       (amp (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> ampf)))
	  (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* amp (oscil car1 (+ (* rfrq pitch)
					(* <em class=red>fm-index (+ 1 frq)</em> ; keep spectrum the same
					   (oscil mod1 (* rfrq modpitch)))))))
	  (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outb</a> i (* amp (oscil car2 (* rfrq pitch)
				(+ (* <em class=red>pm-index</em>
				      (oscil mod2 (* rfrq modpitch)))))))))
      (let* ((car1 (make-oscil pitch))
	     (mod1 (make-oscil modpitch))
	     (car2 (make-oscil pitch))
	     (mod2 (make-oscil modpitch))
	     (frqf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1) :duration dur))
	     (ampf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1 20 1 21 0) :duration dur :scaler .5)))
	(do ((i 0 (+ 1 i)))
	    ((= i samps))
	  (let* ((frq (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> frqf))
		 (rfrq (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> frq))
		 (amp (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> ampf)))
	    (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> (+ i samps) (* amp (oscil car1 (+ (* rfrq pitch)
						    (* <em class=red>fm-index</em>   ; let spectrum decay
						       (oscil mod1 (* rfrq modpitch)))))))
	    (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outb</a> (+ i samps) (* amp (oscil car2 (* rfrq pitch)
					    (+ (* <em class=red>(/ pm-index (+ 1 frq))</em>
						  (oscil mod2 (* rfrq modpitch)))))))))))))
</pre>
</td></tr></table>


<p>To show CLM in its various embodiments, here are the Scheme, Common Lisp, Ruby, Forth, and C versions of the bird instrument;
it produces a sinusoid with (usually very elaborate) amplitude and frequency envelopes.
</p>

<table border=2 cellpadding=6 hspace=20 vspace=20>
<tr><td bgcolor="#f0f4ff">

<table border=0 hspace=20><tr><td bgcolor="#f0f4ff">
<pre>
(define (scheme-bird start dur frequency freqskew amplitude freq-envelope amp-envelope)
  (let* ((gls-env (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> freq-envelope (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> freqskew) dur))
         (os (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> frequency))
         (amp-env (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> amp-envelope amplitude dur))
	 (beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> start))
	 (end (+ beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur))))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
     (do ((i beg (+ 1 i)))
	 ((= i end))
       (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> amp-env) 
                  (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> os (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> gls-env))))))))
</pre>
</td></tr></table>

</td></tr><tr><td bgcolor="#fbf4f0">

<table border=0 hspace=20><tr><td bgcolor="#fbf4f0">
<pre>
(definstrument common-lisp-bird (startime dur frequency freq-skew amplitude freq-envelope amp-envelope)
  (multiple-value-bind (beg end) (times-&gt;samples startime dur)
    (let* ((amp-env (make-env amp-envelope amplitude dur))
	   (gls-env (make-env freq-envelope (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> freq-skew) dur))
	   (os (make-oscil frequency)))
      (run
       (loop for i from beg to end do
	 (outa i (* (env amp-env) 
                    (oscil os (env gls-env)))))))))
</pre>
</td></tr></table>

</td></tr><tr><td bgcolor="#fbfbf0">

<table border=0 hspace=20><tr><td bgcolor="#fbfbf0">
<pre>
def ruby_bird(start, dur, freq, freqskew, amp, freq_envelope, amp_envelope)
  gls_env = make_env(:envelope, freq_envelope, :scaler, hz2radians(freqskew), :duration, dur)
  os = make_oscil(:frequency, freq)
  amp_env = make_env(:envelope, amp_envelope, :scaler, amp, :duration, dur)
  run_instrument(start, dur) do
    env(amp_env) * oscil(os, env(gls_env))
  end
end
</pre>
</td></tr></table>

</td></tr><tr><td bgcolor="#effdef">

<table border=0 hspace=20><tr><td bgcolor="#effdef">
<pre>
instrument: forth-bird { f: start f: dur f: freq f: freq-skew f: amp freqenv ampenv -- }
    :frequency freq make-oscil { os }
    :envelope ampenv :scaler amp :duration dur make-env { ampf }
    :envelope freqenv :scaler freq-skew hz&gt;radians :duration dur make-env { gls-env }
    90e random :locsig-degree
    start dur run-instrument  ampf env  gls-env env os oscil-1  f*  end-run
    os gen-free
    ampf gen-free
    gls-env gen-free
;instrument
</pre>
</td></tr></table>

</td></tr><tr><td bgcolor="#f0f0f0">

<table border=0 hspace=20><tr><td bgcolor="#f0f0f0">
<pre>
void c_bird(double start, double dur, double frequency, double freqskew, double amplitude, 
	    mus_float_t *freqdata, int freqpts, mus_float_t *ampdata, int amppts, mus_any *output)
{
  mus_long_t beg, end, i;
  mus_any *amp_env, *freq_env, *osc;
  beg = start * mus_srate();
  end = start + dur * mus_srate();
  osc = mus_make_oscil(frequency, 0.0);
  amp_env = mus_make_env(ampdata, amppts, amplitude, 0.0, 1.0, dur, 0, NULL);
  freq_env = mus_make_env(freqdata, freqpts, mus_hz_to_radians(freqskew), 0.0, 1.0, dur, 0, NULL);
  for (i = beg; i &lt; end; i++)
    mus_sample_to_file(output, i, 0, 
		       mus_env(amp_env) * 
		         mus_oscil(osc, mus_env(freq_env), 0.0));
  mus_free(osc);
  mus_free(amp_env);
  mus_free(freq_env);
}
</pre>
</td></tr></table>

</td></tr></table>

<p>Many of the synthesis functions in this document try to make it
faster or more convenient to produce a lot of sinusoids, but there
are times when nothing but a ton of oscils will do:
</p>

<table border=1 hspace=20><tr><td>
<table border=0 hspace=20>
<tr><td bgcolor="#eefdee"><center>add lots of reverb!</center></td></tr>
<tr><td>
<pre>

(<a class=quiet href="sndscm.html#withsound" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () 
 (let* ((peaks (list  23  0.0051914    32  0.0090310    63  0.0623477    123  0.1210755    185  0.1971876
		      209  0.0033631  247  0.5797809   309  1.0000000    370  0.1713255    432  0.9351965
		      481  0.0369873  495  0.1335089   518  0.0148626    558  0.1178001    617  0.6353443
		      629  0.1462804  661  0.0208941   680  0.1739281    701  0.0260423    742  0.1203807
		      760  0.0070301  803  0.0272111   865  0.0418878    926  0.0090197    992  0.0098687
		      1174  0.00444  1298  0.0039722  2223  0.0033486   2409  0.0083675   2472  0.0100995
		      2508  0.004262 2533  0.0216248  2580  0.0047732   2596  0.0088663   2612  0.0040592
		      2657  0.005971 2679  0.0032541  2712  0.0048836   2761  0.0050938   2780  0.0098877
		      2824  0.003421 2842  0.0134356  2857  0.0050194   2904  0.0147466   2966  0.0338878
		      3015  0.004832 3027  0.0095497  3040  0.0041434   3092  0.0044802   3151  0.0038269
		      3460  0.003633 3585  0.0050849  4880  0.0042301   5121  0.0037906   5136  0.0048349
		      5158  0.004336 5192  0.0037841  5200  0.0038025   5229  0.0035555   5356  0.0045781
		      5430  0.003687 5450  0.0055170  5462  0.0057821   5660  0.0041789   5673  0.0044932
		      5695  0.007370 5748  0.0031716  5776  0.0037921   5800  0.0062308   5838  0.0034629
		      5865  0.005942 5917  0.0032254  6237  0.0046164   6360  0.0034708   6420  0.0044593
		      6552  0.005939 6569  0.0034665  6752  0.0041965   7211  0.0039695   7446  0.0031611
		      7468  0.003330 7482  0.0046322  8013  0.0034398   8102  0.0031590   8121  0.0031972
		      8169  0.003345 8186  0.0037020  8476  0.0035857   8796  0.0036703   8927  0.0042374
		      9388  0.003173 9443  0.0035844  9469  0.0053484   9527  0.0049137   9739  0.0032365
		      9853  0.004297 10481  0.0036424  10490  0.0033786  10606  0.0031366))
	(len (/ (length peaks) 2))
	(dur 10)
	(oscs (make-vector len))
	(amps (make-vector len))
	(ramps (make-vector len))
	(freqs (make-vector len))
	(vib (<a class=quiet href="#make-rand-interp" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_rand_interp_tip)">make-rand-interp</a> 50 (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> .01)))
	(ampf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1 10 1 11 0) :duration dur :scaler .1))
	(samps (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur)))

   (do ((i 0 (+ 1 i)))
       ((= i len))
     (set! (freqs i) (peaks (* i 2)))
     (set! (oscs i) (<em class=red>make-oscil</em> (freqs i) (random pi)))
     (set! (amps i) (peaks (+ 1 (* 2 i))))
     (set! (ramps i) (<a class=quiet href="#make-rand-interp" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_rand_interp_tip)">make-rand-interp</a> (+ 1.0 (* i (/ 20.0 len))) 
				       (* (+ .1 (* i (/ 3.0 len))) (amps i)))))
   (run
    (do ((i 0 (+ 1 i)))
	((= i samps))
      (let ((sum 0.0)
	    (fm (<a class=quiet href="#rand-interp" onmouseout="UnTip()" onmouseover="Tip(sndclm_rand_interp_tip)">rand-interp</a> vib)))
        (do ((k 0 (+ 1 k)))
	    ((= k len))
	  (set! sum (+ sum (* (+ (amps k)
			         (<a class=quiet href="#rand-interp" onmouseout="UnTip()" onmouseover="Tip(sndclm_rand_interp_tip)">rand-interp</a> (ramps k)))
			      (<em class=red>oscil</em> (oscs k) (* (freqs k) fm))))))
	(<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> ampf) sum)))))))
</pre>
</td></tr></table>
</td></tr></table>

<p>Actually, we could do this with <a href="#mus-chebyshev-tu-sum">mus-chebyshev-t-sum</a>:
</p>

<pre>
    ...
	(amps (make-vct 10607))
	(angle 0.0)
	(freq (hz-&gt;radians 1.0))
   ...
   (do ((i 0 (+ i 1))
	(k 0 (+ k 2)))
       ((= i len))
     (set! (amps (peaks k)) (peaks (+ k 1))))
   ...
   (outa i (* (env ampf) (<em class=red>mus-chebyshev-t-sum</em> angle amps)))
   (set! angle (+ angle freq (rand-interp vib)))
   ...
</pre>

<!--
(with-sound () 
 (let* ((peaks (list  23  0.0051914    32  0.0090310    63  0.0623477    123  0.1210755    185  0.1971876
		      209  0.0033631  247  0.5797809   309  1.0000000    370  0.1713255    432  0.9351965
		      481  0.0369873  495  0.1335089   518  0.0148626    558  0.1178001    617  0.6353443
		      629  0.1462804  661  0.0208941   680  0.1739281    701  0.0260423    742  0.1203807
		      760  0.0070301  803  0.0272111   865  0.0418878    926  0.0090197    992  0.0098687
		      1174  0.00444  1298  0.0039722  2223  0.0033486   2409  0.0083675   2472  0.0100995
		      2508  0.004262 2533  0.0216248  2580  0.0047732   2596  0.0088663   2612  0.0040592
		      2657  0.005971 2679  0.0032541  2712  0.0048836   2761  0.0050938   2780  0.0098877
		      2824  0.003421 2842  0.0134356  2857  0.0050194   2904  0.0147466   2966  0.0338878
		      3015  0.004832 3027  0.0095497  3040  0.0041434   3092  0.0044802   3151  0.0038269
		      3460  0.003633 3585  0.0050849  4880  0.0042301   5121  0.0037906   5136  0.0048349
		      5158  0.004336 5192  0.0037841  5200  0.0038025   5229  0.0035555   5356  0.0045781
		      5430  0.003687 5450  0.0055170  5462  0.0057821   5660  0.0041789   5673  0.0044932
		      5695  0.007370 5748  0.0031716  5776  0.0037921   5800  0.0062308   5838  0.0034629
		      5865  0.005942 5917  0.0032254  6237  0.0046164   6360  0.0034708   6420  0.0044593
		      6552  0.005939 6569  0.0034665  6752  0.0041965   7211  0.0039695   7446  0.0031611
		      7468  0.003330 7482  0.0046322  8013  0.0034398   8102  0.0031590   8121  0.0031972
		      8169  0.003345 8186  0.0037020  8476  0.0035857   8796  0.0036703   8927  0.0042374
		      9388  0.003173 9443  0.0035844  9469  0.0053484   9527  0.0049137   9739  0.0032365
		      9853  0.004297 10481  0.0036424  10490  0.0033786  10606  0.0031366))
	(len (/ (length peaks) 2))
	(dur 10)
	(ramps (make-vector len))
	(vib (make-rand-interp 50 (hz->radians .01)))
	(ampf (make-env '(0 0 1 1 10 1 11 0) :duration dur :scaler .1))
	(samps (seconds->samples dur))
	(amps (make-vct 10607))
	(angle 0.0)
	(freq (hz->radians 1.0)))

   (do ((i 0 (+ i 1))
	(k 0 (+ k 2)))
       ((= i len))
     (set! (amps (peaks k)) (peaks (+ k 1))))

   (run
      (do ((i 0 (+ 1 i)))
	  ((= i samps))
	(outa i (* (env ampf)
		   (mus-chebyshev-t-sum angle amps)))
	(set! angle (+ angle freq (rand-interp vib)))))))
-->


<p>but it seems a bit unnatural.
Related generators are 
<a href="#ncos">ncos</a>, 
<a href="#nsin">nsin</a>,
<a href="#asymmetric-fm">asymmetric-fm</a>, and
<a href="#nrxydoc">nrxysin</a>.
Some instruments that use oscil are 
<a href="sndscm.html#birddoc">bird and bigbird</a>,
<a href="sndscm.html#fmviolin">fm-violin</a> (v),
<a href="sndscm.html#lbjpiano">lbj-piano</a> (clm-ins.scm), 
<a href="sndscm.html#fmvox">vox</a> (clm-ins.scm), and
<a href="sndscm.html#fmbell">fm-bell</a> (clm-ins.scm).  
Interesting extensions of oscil include the various
summation formulas in <a href="#othergenerators">generators.scm</a>.
To goof around with FM from a graphical interface, see bess.scm and bess1.scm.
</p>


<table border=1 hspace=100 cellpadding=8><tr><td>
<p><small>When oscil's frequency is high relative to the sampling rate,
the waveform it produces may not look very sinusoidal.  Here, for example, is oscil
at 440 Hz when the srate is 1000, 4000, and 16000:
</small></p>
<img src="pix/srates.png" alt="effect of different srates" hspace=40>
</td></tr></table>


<!--
(set! (selected-graph-color) (make-color 1 1 1))
(set! (selected-data-color) (make-color 0 0 0))
(set! (axis-numbers-font) (tiny-font))
(set! (x-axis-label 0 0 0) "srate: 1000")
(set! (x-axis-label 1 0 0) "srate: 4000")
(set! (x-axis-label 2 0 0) "srate: 16000")
(set! (axis-label-font) "12x24")

(with-sound (:srate 1000) ; 4000 16000
   (let ((gen (make-oscil 440.0)))
      (do ((i 0 (+ 1 i)))
          ((= i 20000))
        (outa i (oscil gen)))))

-->

<br><br>



<A NAME="envdoc"></A>
<!-- ---------------------------------------- ENV ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>env</h3></center></td></tr></table>
<br>

<pre>
  <a class=def name="make-env">make-env</a> 
      envelope      ; list or vct of x,y break-point pairs
      (scaler 1.0)  ; scaler on every y value (before offset is added)
      duration      ; duration in seconds
      (offset 0.0)  ; value added to every y value
      base          ; type of connecting line between break-points
      end           ; end sample number (obsolete, use length)
      length        ; duration in samples

  <a class=def name="env">env</a> e
  <a class=def name="env?">env?</a> e

  <a class=def name="env-interp">env-interp</a> x env (base 1.0) ;value of env at x
  <a class=def name="env-any">env-any</a> e connecting-function
</pre>



<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t)
  (let ((gen (make-oscil 440.0))
        (ampf (make-env 
                '(0 0  .01 1  .25 .1 1 0)
	        :scaler 0.5
                :length 44100)))
    (do ((i 0 (+ 1 i)))
        ((= i 44100))
      (outa i (* (env ampf) (oscil gen))))))
</pre>
</td>

<td width=4></td>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true) do
  gen = make_oscil(440.0);
  ampf = make_env(
          [0, 0, 0.01, 1.0, 0.25, 0.1, 1, 0],
          :scaler, 0.5,
          :length, 44100);
  44100.times do |i| 
    outa(i, env(ampf) * oscil(gen), $output) 
    end
  end.output
</pre>
</td>

<td width=4></td>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  440.0 make-oscil { gen }
  '( 0 0 0.01 1 0.25 0.1 1 0 )
  :scaler 0.5 :length 44100 make-env { ampf }
  44100 0 do
    i  gen 0 0 oscil  ampf env  f* *output*  outa drop
  loop
; :play #t with-sound drop
</pre>
</td>
</tr>
</table>




<table border=0 hspace=40 vspace=20><tr><td>
<table border=1 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>env methods</center></td></tr>
<tr><td><em class=gen>mus-location</em></td><td>number of calls so far on this env</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>base</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>breakpoint list</td></tr>
<tr><td><em class=gen>mus-scaler</em></td><td>scaler</td></tr>
<tr><td><em class=gen>mus-offset</em></td><td>offset</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>duration in samples</td></tr>
<tr><td><em class=gen>mus-channels</em></td><td>current position in the break-point list</td></tr>
</table>
</td><td width=50></td>
<td>
<img src="pix/pyr.png" alt="an envelope">
</td>
</tr></table>

<p>An envelope is a list or vct of break point pairs: <code>'(0 0  100 1)</code>  is
a ramp from 0 to 1 over an x-axis excursion from 0 to 100, as is <code>(<a class=quiet href="extsnd.html#vct" onmouseout="UnTip()" onmouseover="Tip(extsnd_vct_tip)">vct</a> 0 0 100 1)</code>.  
This data is passed
to make-env along with the scaler (multiplier)
applied to the y axis, the offset added to every y value,
and the time in samples or seconds that the x axis represents.  
make-env returns an env generator.  
env then returns the next sample of the envelope each time it is called.  
Say we want  a ramp moving from .3 to .5 during 1 second. 
</p>
<pre>
    (make-env '(0 0  100 1) :scaler .2 :offset .3 :duration 1.0)
    (make-env '(0 .3  1 .5) :duration 1.0)
</pre>
<p>
I find the second version easier to read.  The first is handy if you have a
bunch of stored envelopes.  To specify the breakpoints, you can also use the form '((0 0) (100 1)).
</p>

<table border=0><tr><td>
<p>The base argument determines how the break-points are connected.  If it is 1.0 (the
default), you get straight line segments.  If base is 0.0, you get a step
function (the envelope changes its value suddenly to the new one without any
interpolation).  Any other positive value affects the exponent of the exponential curve
connecting the points.  A base less than 1.0 gives convex curves (i.e. bowed
out), and a base greater than 1.0 gives concave curves (i.e. sagging).
If you'd rather think in terms of e^-kt, set the base to <code>(exp k)</code>. 
</p>
</td><td>
<img src="pix/pyr03.png" alt="base .03 choice" hspace=10>
</td><td>
<img src="pix/pyr32.png" alt="base 32 choice" hspace=10>
</td></tr></table>

<p>
You can get a lot from a couple of envelopes:
</p>

<pre>
    <em class=listener>&gt;</em> <em class=typing>(load "animals.scm")</em>
    <em class=listener>#&lt;unspecified&gt;</em>
    <em class=listener>&gt;</em> <em class=typing>(with-sound (:play #t) (pacific-chorus-frog 0 .5))</em>
    <em class=listener>"test.snd"</em>
    <em class=listener>&gt;</em> <em class=typing>(with-sound (:play #t) (house-finch 0 .5))</em>
    <em class=listener>"test.snd"</em>
</pre>


<p>
There are several ways to get arbitrary connecting curves between the break points.
The simplest method is to treat
the output of env as the input to the connecting function.  Here's an
instrument that maps the line segments into sin x^3:
</p>

<table border=0><tr><td>
<table border=0 hspace=20><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (mapenv beg dur frq amp en)
  (let* ((start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> beg))
	 (end (+ start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur)))
	 (osc (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> frq))
	 (zv (<em class=red>make-env</em> <em class=red>en</em> 1.0 dur)))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
     (do ((i start (+ 1 i)))
         ((= i end))
       (let ((zval (<em class=red>env</em> zv))) 
	 (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i 
           (* amp 
              (sin (* 0.5 pi zval zval zval)) 
              (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> osc))))))))

(<a class=quiet href="sndscm.html#withsound" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () 
  (mapenv 0 1 440 .5 '(0 0  50 1  75 0  86 .5  100 0)))
</pre>
</td></tr></table>
</td><td>
<img src="pix/sincube.png" alt="sin cubed envelope" hspace=10>
</td></tr></table>

<!--
(define (fixup-axes)
  (set! (selected-data-color) (make-color 0 0 0))(set! (selected-data-color) (make-color 0 0 0))
  (set! (selected-graph-color) (make-color 1 1 1))
  (set! (x-axis-label 0 0) "sin^3 of '(0 0  50 1  75 0  86 .5  100 0)"))
-->

<p>Another method is to write a function that traces out the curve you want.
J.C.Risset's bell curve is:</p>

<table border=0 hspace=40><tr><td>
<pre>
(define <A NAME="bellcurve">(bell-curve</a> x)
  ;; x from 0.0 to 1.0 creates bell curve between .64e-4 and nearly 1.0
  ;; if x goes on from there, you get more bell curves; x can be
  ;; an envelope (a ramp from 0 to 1 if you want just a bell curve)
  (+ .64e-4 (* .1565 (- (exp (- 1.0 (cos (* 2 pi x)))) 1.0))))
</pre>
</td></tr></table>

<p>But the most flexible method is to use <b>env-any</b>.
env-any takes the env generator that produces the underlying envelope,
and a function to "connect the dots", and returns the new envelope
applying that connecting function between the break points.
For example, say we want to square each envelope value:
</p>

<table border=0 hspace=40 cellpadding=10>
<tr><td>
<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> ()
  (let ((e (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1 2 .25 3 1 4 0) 
                     :duration 0.5)))
    (do ((i 0 (+ 1 i)))
	((= i 44100))
      (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (<em class=red>env-any</em> e (lambda (y) (* y y)))))))


;; or connect the dots with a sinusoid:

(define (sine-env e)
  (<em class=red>env-any</em> e (lambda (y)
	       (* 0.5 (+ 1.0 (sin (+ (* -0.5 pi) 
				     (* pi y))))))))

(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> ()
  (let ((e (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1 2 .25 3 1 4 0)
                     :duration 0.5)))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
     (do ((i 0 (+ 1 i)))
	 ((= i 44100))
       (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (sine-env e))))))
</pre>

</td>
<td>
<img src="pix/envany.png" alt="env-any pix">
</td></tr>
</table>

<!--
(define (fixup-axes)
  (set! (selected-data-color) (make-color 0 0 0))(set! (selected-data-color) (make-color 0 0 0))
  (set! (selected-graph-color) (make-color 1 1 1))
  (set! (axis-numbers-font) (tiny-font))
  (set! (x-axis-label 0 0) "(env-any e (lambda (y) (* y y)))")
  (set! (x-axis-label 0 1) "(sine-env)"))
-->

<p>The env-any connecting function takes one argument, the current envelope value treated as
going between 0.0 and 1.0 between each two points.  It returns a value that is then
fitted back into the original (scaled, offset) envelope.  There are a couple more of these
functions in generators.scm, one to apply a blackman4 window between the points, and the
other to cycle through a set of exponents.
</p>


<p>
<a href="#mus-reset">mus-reset</a> of an env causes it
to start all over again from the beginning. 
mus-reset is called internally if you use mus-scaler to set an env's scaler (and similarly for offset and length).
To jump to any position in
an env, use <a href="#mus-location">mus-location</a>.
Here's a function that uses these methods to apply an envelope over and over:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(define (strum e)
  (<a class=quiet href="extsnd.html#mapchannel" onmouseout="UnTip()" onmouseover="Tip(extsnd_mapchannel_tip)">map-channel</a> (lambda (y)
		 (if (&gt; (<em class=red>mus-location</em> e) (<em class=red>mus-length</em> e)) ; mus-length = dur
		     (<em class=red>mus-reset</em> e))     ; start env again (default is to stick at the last value)
		 (* y (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> e)))))

;;; (strum (make-env (list 0 0 1 1 10 .6 25 .3 100 0) :length 2000))
</pre>
</td></tr></table>

<p>To copy an env while changing one aspect (say
duration), it's simplest to use make-env:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(define (change-env-dur e dur)
  (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> (<a class=quiet href="#mus-data" onmouseout="UnTip()" onmouseover="Tip(sndclm_mus_data_tip)">mus-data</a> e) :scaler (<a class=quiet href="#mus-scaler" onmouseout="UnTip()" onmouseover="Tip(sndclm_mus_scaler_tip)">mus-scaler</a> e) :offset (<a class=quiet href="#mus-offset" onmouseout="UnTip()" onmouseover="Tip(sndclm_mus_offset_tip)">mus-offset</a> e) :base (<a class=quiet href="#mus-increment" onmouseout="UnTip()" onmouseover="Tip(sndclm_mus_increment_tip)">mus-increment</a> e)
	    :duration dur))
</pre>
</td></tr></table>

<p>make-env signals an error if the envelope breakpoints are either out of order, or an x axis value
occurs twice.  The default error handler in with-sound may not give you the information you need to
track down the offending note, even given the original envelope.  Here's one way to trap the error
and get more info (in this case, the begin time and duration of the enclosing note):
</p>

<table border=0 hspace=40><tr><td>
<pre>
(define* (make-env-with-catch beg dur :rest args)
  (catch 'mus-error
	 (lambda ()
	   (apply <em class=red>make-env</em> args))
	 (lambda args
	   (display (<a class=quiet onmouseout="UnTip()" onmouseover="Tip(scheme_format_tip)">format</a> #f ";~A ~A: ~A~%" beg dur args)))))
</pre>
</td></tr></table>

<p>
An envelope applied to the amplitude of a signal is a form of amplitude modulation,
and glissando is frequency modulation.  Both cause a broadening of the spectral components:
</p>

<table border=1 hspace=40><tr>
<td>
<img src="pix/ampenvspectrum.png" alt="amp env spectrum" onmouseout="UnTip()" onmouseover="Tip('fft size: 65536, Blackman10 window.<br><br><pre>(with-sound (:srate 10000)<br>  (let* ((ampf (make-env \'(0 0 1 1 15 1 16 0) :duration 15))<br>	 (osc (make-oscil 50))<br>	 (samps (seconds-&gt;samples 15))<br>	 (start (seconds-&gt;samples 7))<br>	 (end (+ start samps)))<br>    (do ((i 0 (+ 1 i)))<br>        ((= i end))<br>      (outa (+ i start) (* (env ampf) (oscil osc))))))</pre>')">
</td><td width=10>
</td><td>
<img src="pix/frqenvspectrum.png" alt="frq env spectrum" onmouseout="UnTip()" onmouseover="Tip('fft size: 65536, Blackman10 window.<br><br><pre>(with-sound (:srate 10000)<br>  (let* ((ampf (make-env \'(0 0 10 0 11 1 25 1 26 0 40 0) <br>			 :duration 40<br>			 :scaler (hz-&gt;radians 200)))<br>	 (osc (make-oscil 100))<br>	 (samps (seconds-&gt;samples 40))<br>	 (start (seconds-&gt;samples 0))<br>	 (end (+ start samps)))<br>    (do ((i 0 (+ 1 i)))<br>	((= i end))<br>      (outa (+ i start) (oscil osc (env ampf))))))<br></pre>')">
</td></tr>
<tr>
<td bgcolor="#f2f4ff"><small><center>truncated pyramid amplitude envelope<br>multiplied by sinusoid at 50Hz</center></small>
</td><td></td>
<td bgcolor="#f2f4ff"><small><center>truncated pyramid frquency envelope<br>sinusoid from 100Hz to 300Hz</center></small>
</td>
</tr></table>

<!--
ampenvspectrum.png:
(with-sound (:srate 10000)
  (let* ((ampf (make-env '(0 0 1 1 15 1 16 0) :duration 15))
	 (osc (make-oscil 50))
	 (samps (seconds->samples 15))
	 (start (seconds->samples 7))
	 (end (+ start samps)))
    (run
       (do ((i 0 (+ 1 i)))
	   ((= i end))
	 (outa (+ i start) (* (env ampf) (oscil osc)))))))

;;; GL/ data cutoff .015 dark 78 jet invert blackman10 65536 db-100
;;; x 299 1.84 y 281 .082 z 342 1.25
;;; hop 3
(set! (spectrum-end) .02)
(set! (selected-graph-color) (make-color 1 1 1))

frqenvspectrum.png:
(with-sound (:srate 10000)
  (let* ((ampf (make-env '(0 0 10 0 11 1 25 1 26 0 40 0) :duration 40 :scaler (hz->radians 200)))
	 (osc (make-oscil 100))
	 (samps (seconds->samples 40))
	 (start (seconds->samples 0))
	 (end (+ start samps)))
    (run
       (do ((i 0 (+ 1 i)))
	   ((= i end))
	 (outa (+ i start) (oscil osc (env ampf)))))))

65536 GL blackman10 -100 dB 
x 299 1.84 y 281 0.82 z 10 1.25
hop 3 % 0.11
jet .015 78 invert
-->

<p>The amplitude case reflects the spectrum of the amplitude envelope all by itself, translated (by multiplication)
up to the sinusoid's pitch.  The sidebands are about 1 Hz apart (the envelope takes 1 second to go linearly from 0 to 1).
Despite appearances, we hear this (are you sitting down?) as a changing amplitude, not a timbral mess.
Spectra can be tricky to interpret, and I've tried to choose parameters for this display that emphasize 
the broadening.  
</p>

<br>

<table border=3 bordercolor="tan" hspace=40 vspace=10><th bgcolor="beige">Envelopes</th><tr><td>
<blockquote><small>
<br>
Various operations on envelopes: <a href="sndscm.html#envdoc">env.scm</a><br>
<table border=0 cellpadding=0 cellspacing=0 hspace=30 vspace=6>
    <tr><td><small>add-envelopes</small></td><td width=40></td><td><small>   add two envelopes</small></td></tr>
    <tr><td><small>concatenate-envelopes</small></td><td></td><td><small>    concatenate a bunch of envelopes</small></td></tr>
    <tr><td><small>envelope-exp</small></td><td></td><td><small>             interpolate points to approximate exponential curves</small></td></tr>
    <tr><td><small>envelope-interp</small></td><td></td><td><small>          return the value of an envelope given the x position</small></td></tr>
    <tr><td><small>envelope-last-x</small></td><td></td><td><small>          return the last x value in an envelope</small></td></tr>
    <tr><td><small>intergrate-envelope</small></td><td></td><td><small>      return the area under an envelope</small></td></tr>
    <tr><td><small>make-power-env</small></td><td></td><td><small>           exponential curves with multiple exponents (see also multi-expt-env in generators.scm)</small></td></tr>
    <tr><td><small>map-envelopes</small></td><td></td><td><small>            apply a function to the breakpoints in two envelopes, returning a new envelope</small></td></tr>
    <tr><td><small>max-envelope</small></td><td></td><td><small>             return the maximum y value in an envelope (also min-envelope)</small></td></tr>
    <tr><td><small>multiply-envelopes</small></td><td></td><td><small>       multiply two envelopes</small></td></tr>
    <tr><td><small>normalize-envelope</small></td><td></td><td><small>       scale the y values of an envelope to peak at 1.0</small></td></tr>
    <tr><td><small>repeat-envelope</small></td><td></td><td><small>          concatenate copies of an envelope</small></td></tr>
    <tr><td><small>reverse-envelope</small></td><td></td><td><small>         reverse the breakpoints in an envelope</small></td></tr>
    <tr><td><small>scale-envelope</small></td><td></td><td><small>           scale and offset the y values of an envelope</small></td></tr>
    <tr><td><small>stretch-envelope</small></td><td></td><td><small>         apply attack and decay times to an envelope ("adsr", or "divenv")</small></td></tr>
    <tr><td><small>window-envelope</small></td><td></td><td><small>          return the portion of an envelope within given x axis bounds</small></td></tr>
</table>

envelope sound: <a href="extsnd.html#envchannel">env-channel</a>, <a href="extsnd.html#envsound">env-sound</a><br>
other enveloping functions: <a href="extsnd.html#rampchannel">ramp-channel</a>, <a href="extsnd.html#xrampchannel">xramp-channel</a>, <a href="extsnd.html#smoothchannel">smooth-channel</a><br>
envelope editor: <a href="snd.html#editenvelope">Edit or View and Envelope</a><br>
panning: place-sound in examp.scm<br>
read sound indexed through envelope: <a href="sndscm.html#envsoundinterp">env-sound-interp</a><br>
repeating envelope: <a href="#pulsedenv">pulsed-env</a><br>
step envelope in pitch: <a href="#rxyk!cos">brassy</a> in generators.scm<br>
<br>
</small></blockquote>
</td></tr></table>
<br><br>



<A NAME="table-lookupdoc"></A>
<!-- ---------------------------------------- TABLE-LOOKUP ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>table-lookup</h3></center></td></tr></table>
<br>

<pre>
  <a class=def name="make-table-lookup">make-table-lookup</a> 
        (frequency *clm-default-frequency*) ; table repetition rate in Hz
        (initial-phase 0.0)                 ; starting point in radians (pi = mid-table)
        wave                                ; a vct containing the signal
        (size *clm-table-size*)             ; table size if wave not specified
        (type mus-interp-linear)            ; interpolation type

  <a class=def name="table-lookup">table-lookup</a> tl (fm-input 0.0)
  <a class=def name="table-lookup?">table-lookup?</a> tl

  <a class=def NAME="make-table-lookup-with-env">make-table-lookup-with-env</a> frequency env size
</pre>


<table border=1 bordercolor="lightgray" hspace=20 cellspacing=8 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t)
  (let ((gen (make-table-lookup 440.0 :wave (partials-&gt;wave '(1 .5  2 .5)))))
    (do ((i 0 (+ 1 i)))
        ((= i 44100))
      (outa i (* 0.5 (table-lookup gen))))))
</pre>
</td>
</tr><tr>
<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true) do
  gen = make_table_lookup(440.0, :wave, partials2wave([1.0, 0.5, 2.0, 0.5]));
  44100.times do |i| 
    outa(i, 0.5 * table_lookup(gen), $output) 
    end
  end.output
</pre>
</td>
</tr><tr>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  440.0 :wave '( 1 0.5  2 0.5 ) #f #f partials-&gt;wave make-table-lookup { gen }
  44100 0 do
    i  gen 0 table-lookup  f2/ *output* outa drop
  loop
; :play #t with-sound drop
</pre>
</td>
</tr>
</table>


<p>table-lookup performs interpolating table lookup with a lookup index that moves
through the table at a speed set by make-table-lookup's "frequency" argument and table-lookup's "fm-input" argument.
That is, the waveform in the table is produced repeatedly, the repetition rate set by the frequency arguments.
Table-lookup scales its
fm-input argument to make its table size appear to be two pi.
The intention here is that table-lookup with a sinusoid in the table and a given FM signal
produces the same output as oscil with that FM signal.
The "type" argument sets the type of interpolation used: <code>mus-interp-none</code>,
<code>mus-interp-linear</code>, <code>mus-interp-lagrange</code>, or <code>mus-interp-hermite</code>.
make-table-lookup-with-env (defined in generators.scm) returns a new table-lookup generator with the envelope 'env' loaded into its table.
</p>

<table border=1 align=left hspace=40 vspace=10 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>table-lookup methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>frequency in Hz</td></tr>
<tr><td><em class=gen>mus-phase</em></td><td>phase in radians</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>wave vct</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>wave size (no set!)</td></tr>
<tr><td><em class=gen>mus-interp-type</em></td><td>interpolation choice (no set!)</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>table increment per sample</td></tr>
</table>
<pre>
<br>
(let ((result (<a class=quiet href="#array-interp" onmouseout="UnTip()" onmouseover="Tip(sndclm_array_interp_tip)">array-interp</a> wave phase)))
  (set! phase (+ phase 
                 (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> frequency)
                 (* fm-input
                    (/ (length wave) 
                       (* 2 pi)))))
  result)
</pre><br clear=left>

<p>
In the past, table-lookup was often used for additive synthesis, so
there are two functions that make it easier to load up
various such waveforms:
</p>

<pre>
 <a class=def name="partialstowave">partials-&gt;wave</a> synth-data wave-vct (norm #t)
 <a class=def name="phase-partialstowave">phase-partials-&gt;wave</a> synth-data wave-vct (norm #t)
</pre>

<p>The "synth-data" argument is a list or vct of (partial amp) pairs: '(1 .5  2 .25)
gives a combination of a sine wave at the carrier (partial = 1) at amplitude .5, and
another at the first harmonic (partial = 2) at amplitude .25.  The partial amplitudes are
normalized to sum to a total amplitude of 1.0 unless the argument "norm"
is #f.  If the initial phases matter (they almost never do), you can use
phase-partials-&gt;wave; in this case the synth-data is a list or vct of (partial amp phase) triples with phases in radians.
If "wave-vct" is not passed, these functions return a new vct.
</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (simple-table dur)
  (let ((tab (<em class=red>make-table-lookup</em> :wave (<em class=red>partials-&gt;wave</em> '(1 .5  2 .5)))))
    (do ((i 0 (+ 1 i))) ((= i dur))
      (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* .3 (<em class=red>table-lookup</em> tab))))))
</pre>
</td></tr></table>

<p>table-lookup can also be used as a sort of "freeze" function, looping through a sound repeatedly,
based on some previously chosen loop positions:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(define (looper start dur sound freq amp)
  (let* ((beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> start))
         (end (+ beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur)))
         (loop-data (<a class=quiet href="extsnd.html#mussoundloopinfo" onmouseout="UnTip()" onmouseover="Tip(extsnd_mussoundloopinfo_tip)">mus-sound-loop-info</a> sound)))
    (if (or (null? loop-data)
            (&lt;= (cadr loop-data) (car loop-data)))
        (throw 'no-loop-positions)
        (let* ((loop-start (car loop-data))
               (loop-end (cadr loop-data))
               (loop-length (+ 1 (- loop-end loop-start)))
               (sound-section (<a class=quiet href="#filetoarray" onmouseout="UnTip()" onmouseover="Tip(sndclm_filetoarray_tip)">file-&gt;array</a> sound 0 loop-start loop-length (<a class=quiet href="extsnd.html#makevct" onmouseout="UnTip()" onmouseover="Tip(extsnd_makevct_tip)">make-vct</a> loop-length)))
               (original-loop-duration (/ loop-length (srate sound)))
               (tbl (<em class=red>make-table-lookup</em> :frequency (/ freq original-loop-duration) :wave sound-section)))
               ;; "freq" here is how fast we read (transpose) the sound &mdash; 1.0 returns the original
          (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
           (do ((i beg (+ 1 i)))
               ((= i end))
             (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* amp (<em class=red>table-lookup</em> tbl)))))))))

(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:srate 44100) (looper 0 10 "/home/bil/sf1/forest.aiff" 1.0 0.5))
</pre>
</td></tr></table>

<p>And for total confusion, here's a table-lookup that modulates a sound where we specify the
modulation deviation in samples:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (fm-table file start dur amp read-speed modulator-freq index-in-samples)
  (let* ((beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> start))
         (end (+ beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur)))
         (table-length (<a class=quiet href="extsnd.html#mussoundframes" onmouseout="UnTip()" onmouseover="Tip(extsnd_mussoundframes_tip)">mus-sound-frames</a> file))
         (tab (<em class=red>make-table-lookup</em> :frequency (/ read-speed (<a class=quiet href="extsnd.html#mussoundduration" onmouseout="UnTip()" onmouseover="Tip(extsnd_mussoundduration_tip)">mus-sound-duration</a> file)) 
                                 :wave (<a class=quiet href="#filetoarray" onmouseout="UnTip()" onmouseover="Tip(sndclm_filetoarray_tip)">file-&gt;array</a> file 0 0 table-length (<a class=quiet href="extsnd.html#makevct" onmouseout="UnTip()" onmouseover="Tip(extsnd_makevct_tip)">make-vct</a> table-length))))
         (osc (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> modulator-freq))
         (index (/ (* (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> modulator-freq) 2 pi index-in-samples) table-length)))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
     (do ((i beg (+ 1 i)))
         ((= i end))
       (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* amp (<em class=red>table-lookup</em> tab (* index (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> osc)))))))))
</pre>
</td></tr></table>

<p>Lessee.. there's a factor of table-length/(2*pi) in table-lookup, so that a table with a sinusoid
behaves the same as an oscil even with FM; hz-&gt;radians
adds a factor of (2*pi)/srate; so we've cancelled the internal 2*pi and table-length, and we have
an actual deviation of mfreq*2*pi*index/srate, which looks like FM; hmmm.  See <a href="#srcer">srcer</a>
below for an <a href="#src">src</a>-based way to do the same thing.
</p>

<br>
<p>
There is one annoying problem with table-lookup: noise.
Say we have a sine wave in a table with L elements, and we want to read it at a frequency of
f Hz at a sampling rate of Fs.  This requires that we read the table at locations that are multiples of
L * f / Fs.  This is ordinarily not an integer (that is, we've fallen between the
table elements).  We have no data between the elements, but we can make (plenty of)
assumptions about what ought to be there.  In the no-interpolation case (type = <code>mus-interp-none</code>), we take the floor of
the table-relative phase, returning a squared-off sine-wave:
</p>

<img src="pix/interp1.png" alt="squared-off sine spectra" hspace=40 onmouseout="UnTip()" onmouseover="Tip('srate=1000000 so that aliasing does not cause confusion.<br>FFT size=262144 with a blackman2 window.<br>In detail, the first 10 pairs (with 1/nL in parens) are:<br><pre>    100  1.000000<br>   9900  0.010368  (.01)<br>  10100  0.010192<br>  19900  0.005174  (.005)<br>  20100  0.005099<br>  29900  0.003431  (.0033)<br>  30100  0.003436<br>  39900  0.002594  (.0025)<br>  40100  0.002560<br>  49900  0.002060  (.002)<br>  50100  0.002066<br>  59900  0.001732  (.0017)<br>  60100  0.001715<br>  69900  0.001477  (.0014)<br>  70100  0.001478<br>  79900  0.001300  (.00125)<br>  80100  0.001296<br>  89900  0.001157  (.0011)<br>  90100  0.001153<br>  99900  0.001043  (.001)<br> 100100  0.001046</pre>')">

<!--
(with-sound (:srate 1000000 :channels 2) 
  (let ((gen1 (make-table-lookup 100.0 :wave (partials->wave '(1 1) (make-vct 100)) :type mus-interp-none))
        (sine (make-oscil 100.0)))
    (run 
       (do ((i 0 (+ 1 i))) 
           ((= i 1000000))
	 (let ((qsine (table-lookup gen1))
	       (tsine (oscil sine)))
	   (outa i qsine)
	   (outb i (- tsine qsine)))))))

(set! (selected-graph-color) (make-color 1 1 1))
(set! (selected-data-color) (make-color 0 0 0))
(set! (x-axis-label 0 0 0) "no interpolation, table size=100, sine at 100 Hz")
(set! (x-axis-label 0 1 0) "difference between sine and squared-off sine")
(set! (x-axis-label 0 0 1) "squared-off sine spectrum: srate=1000000")
(set! (x-axis-label 0 1 1) "spectrum of the error")
(set! (axis-label-font) (axis-numbers-font))
(set! (transform-normalization) normalize-by-sound)
(set! (graphs-horizontal) #f)
-->

<!-- 
     maxamp of sawtooth is 2pi/L (it's a max at 0 when sin x ~ x, and each phase increment is 2pi/L) 
-->

<p>
In addition to the sine at 100 Hz, we're getting lots of pairs of components, each pair centered around n * L * f, (10000 = 100 * 100 is the first),
and separated from it by f, (9900 and 10100),
and the amplitude of each pair is 1/(nL): -40 dB is 1/100 for the n=1 case.
This spectrum says "amplitude modulation" (the fast square wave times the slow sinusoid).
After scribbling a bit on the back of an envelope, we announce with a confident air that
the sawtooth error signal gives us the 1/n (it is a sum of sin nx/n), and its amplitude gives us the 1/L.
Now we try linear interpolation (<code>mus-interp-linear</code>), and get the same components as before, but
the amplitude is going (essentially) as 1.0 / (n * n * L * L).  So the interpolation
reduces the original problem by a factor of n * L:
</p>

<img src="pix/interp2.png" alt="squared-off sine spectra" hspace=40 onmouseout="UnTip()" onmouseover="Tip('as before, srate=1000000 so that aliasing does not cause confusion.<br>FFT size=262144 with a blackman2 window.<br>In detail, the first 10 pairs (with 1/(n^2 L^2) in parens) are:<br><pre>    100  1.00000000<br>   9900  0.00010508  (.0001)<br>  10100  0.00010086<br>  19900  0.00002580  (.000025)<br>  20100  0.00002524<br>  29900  0.00001133  (.000011)<br>  30100  0.00001157<br>  39900  0.00000661  (.0000063)<br>  40100  0.00000652<br>  49900  0.00000419  (.000004)<br>  50100  0.00000422<br>  59900  0.00000263  (.0000027)<br>  60100  0.00000282<br>  69900  0.00000216  (.000002)<br>  70100  0.00000201<br>  79900  0.00000161  (.0000015)<br>  80100  0.00000155<br>  89900  0.00000120  (.0000012)<br>  90100  0.00000123<br>  99900  0.00000099  (.000001)<br> 100100  0.00000102</pre>')">

<!--
(with-sound (:srate 1000000 :channels 2) 
  (let ((gen1 (make-table-lookup 100.0 :wave (partials->wave '(1 1) (make-vct 100)) :type mus-interp-linear))
	(sine (make-oscil 100.0)))
    (run 
       (do ((i 0 (+ 1 i))) 
	   ((= i 1000000))
	 (let ((qsine (table-lookup gen1))
	       (tsine (oscil sine)))
	   (outa i qsine)
	   (outb i (- tsine qsine)))))))

(set! (x-axis-label 0 0 0) "linear interpolation, table size=100, sine at 100 Hz")
(set! (x-axis-label 0 1 0) "difference between sine and interpolated sine")
(set! (x-axis-label 0 0 1) "interpolated sine spectrum: srate=1000000")
(set! (x-axis-label 0 1 1) "spectrum of the error")
-->

<p>
We can view this also as amplitude modulation:
the sinusoid at frequency f times the little blip during each table sample at frequency L * f.
Each component
is at n * L * f, as before, and split in half by the modulation.
Since L * f is normally a very high frequency, and sampling rates are not in the megahertz range (as in our examples),
these components
alias to such an extent that they look like noise, but they are noise only in the
sense that we wish they weren't there.  
</p>

<p>
The table length (L above) is the "effective" length.  If we store an nth harmonic
in the table, each period gets L/n elements (we want to avoid clicks caused by discontinuities between the first and last table elements), 
so the amplitude of the nth harmonic's noise components
is higher (by n^2) than the fundamental's.  We either have to use enormous
tables or stick to low
numbered partials.  To keep the noise components out of sight in 16-bit output (down 90 dB),
we need 180 elements per period.  So a table with a 50th harmonic has to be at least length 8192.
It's odd that the cutoff here is so similar to
the waveshaping case; a 50-th harmonic is trouble in either case.
(This leaves an opening for <a href="#ncos">ncos</a> and friends even when dynamic spectra aren't the issue).
</p>

<p>
We can try fancier interpolations.  <code>mus-interp-lagrange</code> and <code>mus-interp-hermite</code>
reduce the components (which are at the same frequencies as before) by about another factor of L.
But these interpolations are expensive and ugly.
If you're trying to produce a sum of sinusoids, use polywave &mdash; it makes a monkey out of table lookup in every case.
</p>


<!-- an earlier example showing the interpolation waveforms:

(with-sound (:channels 4 :clipped #f :statistics #t)
  (let* ((pitch 1000.0)
	 (size 64)
	 (tbl1 (make-table-lookup pitch 0.0 (partials->wave '(1 1) (make-vct size)) size mus-interp-none))
	 (tbl2 (make-table-lookup pitch 0.0 (partials->wave '(1 1) (make-vct size)) size mus-interp-linear))
	 (tbl3 (make-table-lookup pitch 0.0 (partials->wave '(1 1) (make-vct size)) size mus-interp-lagrange))
	 (tbl4 (make-table-lookup pitch 0.0 (partials->wave '(1 1) (make-vct size)) size mus-interp-hermite)))
    (run 
       (do ((i 0 (+ 1 i)))
	   ((= i 100000))
	 (outa i (table-lookup tbl1))
	 (outb i (table-lookup tbl2))
	 (out-any i (table-lookup tbl3) 2)
	 (out-any i (table-lookup tbl4) 3)))))

(with-sound (:channels 5 :clipped #f :statistics #t)
  (let* ((pitch 2.0)
	 (size 64)
	 (wave (let ((v (make-vct size 0.0)))
		 (set! (v (/ size 2)) 1.0)
		 v))
	 (tbl1 (make-table-lookup pitch 0.0 wave size mus-interp-none))
	 (tbl2 (make-table-lookup pitch 0.0 wave size mus-interp-linear))
	 (tbl3 (make-table-lookup pitch 0.0 wave size mus-interp-lagrange))
	 (tbl4 (make-table-lookup pitch 0.0 wave size mus-interp-hermite))
	 (tbl5 (make-table-lookup pitch 0.0 wave size mus-interp-all-pass)))
    (run 
       (do ((i 0 (+ 1 i)))
	   ((= i 100000))
	 (outa i (table-lookup tbl1))
	 (outb i (table-lookup tbl2))
	 (out-any i (table-lookup tbl3) 2)
	 (out-any i (table-lookup tbl4) 3)
	 (out-any i (table-lookup tbl5) 4)))))
-->


<center><table border=1 hspace=100 cellpadding=4 vspace=10><tr><td>
<small> 
<p>table-lookup of a sine (or some facsimile thereof) probably predates Ptolemy.
One neat method of generating the table is that of Bhaskara I, AD 600, India, mentioned
in van Brummelen, "The Mathematics of the Heavens and the Earth": use the rational
approximation 4x(180-x)/(40500-x(180-x)), x in degrees, or more readably:
4x(pi-x)/(12.337-x(pi-x)), x in radians.  The maximum error is 0.00163 at x=11.54 (degrees)!
</p>
</small>
</td></tr></table></center>

<!--
(define (bhaskara-sine x) ; x degrees
  (list (/ (* 4.0 x (- 180 x))
	   (- 40500 (* x (- 180 x))))
	(sin (degrees->radians x))
	(let* ((dx (degrees->radians x))
	       (px (- pi dx))
	       (cs (degrees->radians (degrees->radians 40500))))
	  (/ (* 4 dx px)
	     (- cs (* dx px))))
	(let ((dx (degrees->radians x)))
	  (/ (* 4 dx (- pi dx))
	     (- 12.337 (* dx (- pi dx)))))))

Ayyangar: Ganesh -- same thing using n=pi/x: 16(n-1)/(5n^2-4n+4)
(define (ganesh-sine x) ; x radians
  (list (if (= x 0.0)
	    0.0
	    (let ((n (/ pi x)))
	      (/ (* 16 (- n 1))
		 (+ (* 5 n n) (* -4 n) 4))))
	(if (= x 0.0)
	    0.0
	    (let* ((n (/ pi x))
		   (n2 (* n n))
		   (n-2 (- n 2))
		   (n2-2 (* n-2 n-2)))
	      (/ (- n2 n2-2)
		 (+ n2 (/ n2-2 4)))))
	(sin x)))

(define (pade-sine x) ; x < pi/4, Martin Brown
  (list (* x (/ (- 60 (* 7 x x))
		(+ 60 (* 3 x x))))
	(sin x)))

(define (koren-sine ux) ; |ux|<pi/4, Kren and Zinaty
  (let* ((x (/ (* 4 ux) pi))
	 (x2 (* x x))
	 (a0 1805490264.6910)
	 (a1 -164384678.2275)
	 (a2    3664210.6476)
	 (a3     -28904.1402)
	 (a4         76.5690)
	 (b0 2298821602.6389)
	 (b1   27037050.1189)
	 (b2     155791.3885)
	 (b3        540.5675))
    (* x (/ (+ a0 (* x2 (+ a1 (* x2 (+ a2 (* x2 (+ a3 (* x2 a4))))))))
	    (+ b0 (* x2 (+ b1 (* x2 (+ b2 (* x2 (+ b3 x2)))))))))))
-->

<br>
<p><a href="spectr.scm">spectr.scm</a> has a steady state spectra of
several standard orchestral instruments, courtesy of James A. Moorer.
The <a href="sndscm.html#drone">drone</a> instrument in clm-ins.scm uses table-lookup for the
bagpipe drone.  <a href="sndscm.html#twotab">two-tab</a> in the same file interpolates between two tables.
See also <a href="sndscm.html#granidoc">grani</a> and <a href="sndscm.html#displayscannedsynthesis">display-scanned-synthesis</a>.
</p>

<br><br>



<A NAME="polyshapedoc"></A>
<A NAME="polywavedoc"></A>
<!-- ---------------------------------------- POLYWAVE, POLYSHAPE ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>polywave, polyshape</h3></center></td></tr></table>
<br>
<pre>
  <a class=def name="make-polywave">make-polywave</a> 
         (frequency *clm-default-frequency*) 
         (partials '(1 1))                   ; a list of harmonic numbers and their associated amplitudes
         (type mus-chebyshev-first-kind)     ; Chebyshev polynomial choice

  <a class=def name="polywave">polywave</a> w (fm 0.0)
  <a class=def name="polywave?">polywave?</a> w

  <a class=def name="make-polyshape">make-polyshape</a> 
        (frequency *clm-default-frequency*) 
        (initial-phase 0.0) 
        coeffs 
        (partials '(1 1)) 
        (kind mus-chebyshev-first-kind)

  <a class=def name="polyshape">polyshape</a> w (index 1.0) (fm 0.0)
  <a class=def name="polyshape?">polyshape?</a> w

  <a class=def name="partialstopolynomial">partials-&gt;polynomial</a> partials (kind mus-chebyshev-first-kind)
  <a class=def name="normalizepartials">normalize-partials</a> partials

  <a class=def name="mus-chebyshev-tu-sum">mus-chebyshev-tu-sum</a> x t-coeffs u-coeffs
  <em class=emdef>mus-chebyshev-t-sum</em> x t-coeffs
  <em class=emdef>mus-chebyshev-u-sum</em> x u-coeffs
</pre>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t)
  (let ((gen (make-polywave 440.0
               :partials '(1 .5  2 .5))))
    (do ((i 0 (+ 1 i)))
        ((= i 44100))
      (outa i (* 0.5 (polywave gen))))))
</pre>
</td>

<td width=4></td>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true) do
  gen = make_polywave(440.0,
         :partials, [1.0, 0.5, 2.0, 0.5]);
  44100.times do |i| 
    outa(i, 0.5 * polywave(gen), $output) 
    end
  end.output
</pre>
</td>

<td width=4></td>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  440.0 :partials '( 1 0.5 2 0.5 ) make-polywave { gen }
  44100 0 do
    i  gen 0 polywave  f2/ *output* outa drop
  loop
; :play #t with-sound drop
</pre>
</td>

</tr>
</table>


<!-- LATEX: sceq16
\begin{align*}
&T_{n}(\cos \theta)=\cos n\theta \\
&U_{n}(\cos \theta)=\frac{\sin(n+1) \theta}{\sin \theta}
\end{align*}

A&S 22.3.15
-->

<p>
These two generators
drive a sum of scaled Chebyshev polynomials with
a cosine, creating a sort of cross between additive synthesis and FM; see
"Digital Waveshaping Synthesis" by Marc Le Brun in JAES 1979 April, vol 27, no 4, p250.
The basic idea is:
</p>

<img src="pix/sceq16.png" alt="Cheby eqs" hspace=40>

<p>
We can add scaled Tns (polynomials) to get the spectrum we want, producing
in the simplest case an inexpensive additive synthesis.  We can vary the peak amplitude of the
input (cos theta) to get effects similar to those of FM. 
polyshape uses a prebuilt sum of Chebyshev polynomials,
whereas polywave uses the underlying Chebyshev recursion.  
polywave is stable and noise-free even with high partial numbers (I've tried it with 16384 harmonics).
The "partials" argument to the make function can
be either a list or a vct.
The "type" or "kind" argument determines which kind of Chebyshev polynomial
is used internally:  mus-chebyshev-first-kind (Tn) which produces a sum of cosines,
or mus-chebyshev-second-kind (Un), which produces a sum of sines.
</p>

<p>normalize-partials takes the list or vct of partial number and amplitudes, and
returns a vct with the amplitudes normalized so that their magnitudes add to 1.0. 
</p>

<pre>
    <em class=listener>&gt;</em><em class=typing>(normalize-partials '(1 1 3 2 6 1))</em>
    <em class=listener>#&lt;vct[len=6]: 1.000 0.250 3.000 0.500 6.000 0.250&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(normalize-partials (vct 1 .1 2 .1 3 -.2))</em>
    <em class=listener>#&lt;vct[len=6]: 1.000 0.250 2.000 0.250 3.000 -0.500&gt;</em>
</pre>

<p>
partials-&gt;polynomial
takes a list or vct of partial numbers and amplitudes
and returns the Chebyshev polynomial coefficients that 
produce that spectrum.  These coefficients can be passed to
polyshape (the coeffs argument), or used directly by <a href="#polynomial">polynomial</a> (there are examples of both below).
</p>

<pre>
    <em class=listener>&gt;</em><em class=typing>(partials-&gt;polynomial '(1 1 3 2 6 1))</em>
    <em class=listener>#&lt;vct[len=7]: -1.000 -5.000 18.000 8.000 -48.000 0.000 32.000&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(partials-&gt;polynomial '(1 1 3 2 6 1) mus-chebyshev-second-kind)</em>
    <em class=listener>#&lt;vct[len=7]: -1.000 6.000 8.000 -32.000 0.000 32.000 0.000&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(partials-&gt;polynomial (vct 1 .1 2 .1 3 -.2))</em>
    <em class=listener>#&lt;vct[len=4]: -0.100 0.700 0.200 -0.800&gt;</em>
</pre>

<p>mus-chebyshev-tu-sum and friends perform the same function as partials-&gt;polynomial, but
use the much more stable and accurate underlying recursion (see below for a long-winded
explanation).  They are the innards of the polywave and <a href="#polyoid">polyoid</a> generators.
The arguments are "x" (normally a phase), and one or two
vcts of component amplitudes.  
These functions makes it easy to do additive synthesis
with any number of harmonics (I've tried 16384), each with arbitrary
initial-phase and amplitude, and each harmonic independently changeable 
in phase and amplitude at run-time by setting a vct value.
</p>


<table border=1 align=left hspace=40 vspace=10 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>polywave methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>frequency in Hz</td></tr>
<tr><td><em class=gen>mus-scaler</em></td><td>index (polywave only)</td></tr>
<tr><td><em class=gen>mus-phase</em></td><td>phase in radians</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>polynomial coeffs</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>number of partials</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>frequency in radians per sample</td></tr>
</table>

<pre>
<br>
(let ((result (<a class=quiet href="#polynomial" onmouseout="UnTip()" onmouseover="Tip(sndclm_polynomial_tip)">polynomial</a> wave (cos phase))))
  (set! phase (+ phase (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> frequency) fm))
  result)
</pre>

<br clear=left>

<p>In its simplest use, waveshaping is additive synthesis:
</p>

<table border=0 hspace=40><tr>
<td>
<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> ()
  (let ((wav (<em class=red>make-polyshape</em> 
               :frequency 500.0
               :partials '(1 .5  2 .3  3 .2))))
    (do ((i 0 (+ 1 i))) ((= i 40000))
      (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (<em class=red>polyshape</em> wav)))))
</pre>
</td>
<td>
<img src="pix/polyshape.png" alt="waveshaping" hspace=40>
</td>
</tr></table>

<p>Say we want every third harmonic at amplitude 1/sqrt(harmonic-number) for 5 harmonics total:
</p>

<table border=0 hspace=40><tr>
<td>
<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:clipped #f :statistics #t :play #t :scaled-to .5)
  (let* ((gen (<em class=red>make-polywave</em> 200 (let ((harms (make-vct (* 5 2)))) ; 5 harmonics, 2 numbers for each
				   (do ((k 1 (+ k 3))
					(i 0 (+ i 2)))
				       ((= i (* 5 2)))
				     (set! (harms i) k) ; harmonic number (k*freq)
				     (set! (harms (+ i 1)) (/ 1.0 (sqrt k)))) ; harmonic amplitude
				   harms)))
	 (ampf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1 10 1 11 0) :duration 1.0 :scaler .5)))
    (do ((i 0 (+ 1 i)))
	((= i 44100))
      (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> ampf) (<em class=red>polywave</em> gen))))))
</pre>
</td>
</tr></table>

<p>See animals.scm for many more examples along these lines.
normalize-partials makes sure that the component amplitudes (magnitudes) add to 1.0.  Its argument can be either a list or vct,
but it always returns a vct.
The <a href="sndscm.html#fmviolin">fm-violin</a> uses polyshape for the multiple FM section in some cases.
The <a href="sndscm.html#pqw">pqw</a> and <a href="sndscm.html#pqwvox">pqwvox</a> instruments use
both kinds of Chebyshev polynomials to produce single side-band spectra.
Here is a somewhat low-level example:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (pqw start dur spacing carrier partials)
  (let* ((spacing-cos (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> spacing (/ pi 2.0)))
	 (spacing-sin (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> spacing))
	 (carrier-cos (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> carrier (/ pi 2.0)))
	 (carrier-sin (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> carrier))
	 (sin-coeffs (<em class=red>partials-&gt;polynomial</em>
                       partials mus-chebyshev-second-kind))
	 (cos-coeffs (<em class=red>partials-&gt;polynomial</em>
                       partials mus-chebyshev-first-kind))
	 (beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> start))
	 (end (+ beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur))))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
     (do ((i beg (+ 1 i))) ((= i end))
       (let ((ax (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> spacing-cos)))
	 (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (- (* (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> carrier-sin) 
                       (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> spacing-sin) 
		       (<em class=red>polynomial</em> sin-coeffs ax))
		    (* (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> carrier-cos) 
		       (<em class=red>polynomial</em> cos-coeffs ax)))))))))

(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () (pqw 0 1 200.0 1000.0 '(2 .2  3 .3  6 .5)))
</pre>
</td><td>
<img src="pix/pqw.png" alt="pqw example">
</td></tr></table>

<p>We can use waveshaping to make a band-limited triangle-wave:
</p>
<table border=0 hspace=40><tr><td>
<pre>
(define* (make-band-limited-triangle-wave (frequency *clm-default-frequency*) (order 1))
  (let ((freqs '()))
    (do ((i 1 (+ 1 i))
	 (j 1 (+ j 2)))
	((&gt; i order))
      (set! freqs (cons (/ 1.0 (* j j)) (cons j freqs))))
    (<em class=red>make-polywave</em> frequency :partials (reverse freqs))))

(define* (band-limited-triangle-wave gen (fm 0.0))
  (<em class=red>polywave</em> gen fm))
</pre>
</td></tr></table>

<p>Band-limited square or sawtooth waves:
</p>
<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (bl-saw start dur frequency order)
  (let* ((norm (if (= order 1) 1.0     ; these peak amps were determined empirically
                 (if (= order 2) 1.3   ;   actual limit is supposed to be pi/2 (G&amp;R 1.441)
                   (if (&lt; order 9) 1.7 ;   but Gibbs phenomenon pushes it to 1.851
                     1.852))))
         (freqs '()))
    (do ((i 1 (+ 1 i)))
	((&gt; i order))
      (set! freqs (cons (/ 1.0 (* norm i)) (cons i freqs))))
    (let* ((gen (<em class=red>make-polywave</em> frequency :partials (reverse freqs) :type <em class=red>mus-chebyshev-second-kind</em>))
	   (beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> start))
	   (end (+ beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur))))
      (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a> 
       (do ((i beg (+ 1 i))) 
	   ((= i end))
	 (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (<em class=red>polywave</em> gen)))))))
</pre></td></tr></table>

<table border=0>
<tr><td>
The "fm" argument to these generators is intended mainly for vibrato and frequency envelopes. 
If you use it for frequency modulation, you'll notice that the result is not the necessarily same as applying that
modulation to the equivalent bank of oscillators, but it is the same as (for example) applying it to an ncos
generator, or most of the other generators (table-lookup, nsin, etc).  The polynomial in cos(x) produces
a sum of cos(nx) for various "n", but if "x" is itself a sinusoid, its
effective index includes the factor of "n" (the partial number). 
This is what you want
if all the components should move together (as in vibrato).  If you need better control of the FM spectrum,
use a bank of oscils where you can set each index independently.  Here we used '(1 1 2 1 3 1) and polyshape
with sinusoidal FM with an index of 1.
</td><td width=20></td><td>
<img src="pix/polyfm.png" alt="polyshape fm">
</td></tr>
</table>

<p>The same thing happens if you use polyshape or ncos (or whatever) as the (complex) modulating signal to an oscil
(the reverse of the situation above).
The effective index of each partial is divided by the partial number (and in ncos, for example, the output
is scaled to be -1..1, so that adds another layer of confusion). There's a longer discussion of this under
<a href="#ncosdoc">ncos</a>.
</p>

<!--
(define* (fmsin beg dur freq amp mc-ratio index type)
  (let* ((start (seconds->samples beg))
         (end (+ start (seconds->samples dur)))
	 (carrier (if (= type 0)
		      (let ((oscs (make-vector 3 #f)))
			(do ((i 0 (+ 1 i)))
			    ((= i 3))
			  (set! (oscs i) (make-oscil (* freq (+ 1 i)))))
			oscs)
		      (if (= type 1)
			  (make-ncos freq 3)
			  (if (= type 2)
			      (make-polyshape freq :coeffs (partials->polynomial '(1 1 2 1 3 1)))
			      (if (= type 3)
				  (make-table-lookup freq :wave (partials->wave '(1 1 2 1 3 1)))
				  (if (= type 4)
				      (make-waveshape freq :partials '(1 1 2 1 3 1))
				      (if (= type 5)
					  (make-nsin freq 3)
					  (if (= type 6)
					      (make-ncos2 freq 3)
					      (if (= type 7)
						  (make-ncos4 freq 3)
						  (if (= type 8)
						  (make-nrcos freq 3 .99)
						  (if (= type 9)
						      (make-nkssb freq freq 3)
						      )))))))))))
	 (modulator (make-oscil (* freq mc-ratio)))
	 (fm-index (hz->radians (* index freq mc-ratio)))
	 (ampf (make-env '(0 0 1 1 10 1 11 0) :scaler amp :duration dur)))
    (do ((i start (+ 1 i)))
	((= i end))
      (let ((md (* fm-index (oscil modulator))))
	(outa i (* (env ampf)
		   (if (= type 0)
		       (let ((sum 0.0))
			 (do ((k 0 (+ 1 k)))
			     ((= k 3))
			   (set! sum (+ sum (oscil (carrier k) (* (+ 1 k) md))))) ; or leave unscaled
			 (/ sum 3))
		       (if (= type 1)
			   (sum-of-cosines carrier md)
			   (if (= type 2)
			       (/ (polyshape carrier 1.0 md) 3)
			       (if (= type 3)
				   (/ (table-lookup carrier md) 3)
				   (if (= type 4)
				       (waveshape carrier 1.0 md)
				       (if (= type 5)
					   (sum-of-sines carrier md)
					   (if (= type 6)
					       (ncos2 carrier md)
					       (if (= type 7)
						   (ncos4 carrier md)
						   (if (= type 8)
						       (nrcos carrier md)
						       (if (= type 9)
							   (nkssb carrier md)
							   0.0))))))))))))))))
-->

<p>To get the FM effect of a spectrum centered around a carrier, multiply the waveshaping output by the carrier (the 0Hz term gives us the carrier):
</p>

<table border=0 hspace=20>
<tr><td>
<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> ()
  (let ((modulator (<em class=red>make-polyshape</em> 100.0 :partials (list 0 .4  1 .4  2 .1  3 .05  4 .05)))
	(carrier (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> 1000.0)))
    (do ((i 0 (+ 1 i))) ((= i 20000))
      (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* .5 (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> carrier) (<em class=red>polyshape</em> modulator))))))
</pre>
</td></tr></table>


<p>The simplest way to get 
get changing spectra is to interpolate between two or more sets of coefficients.
</p>
<pre>
    (+ (* interp (polywave p1 ...))  ; see animals.scm for many examples
       (* (- 1.0 interp) (polywave p2 ...)))
</pre>

<p>Or use mus-chebyshev-*-sum and set the component amplitudes directly:
</p>

<table border=0 hspace=20>
<tr><td>
<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> ()
  (let* ((dur 1.0)
	 (samps (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur))
	 (coeffs (<a class=quiet href="extsnd.html#vct" onmouseout="UnTip()" onmouseover="Tip(extsnd_vct_tip)">vct</a> 0.0 0.5 0.25 0.125 0.125))
	 (x 0.0)
	 (incr (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> 100.0))
	 (ampf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1 10 1 11 0) :duration dur :scaler .5))
	 (harmf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 .125 1 .25) :duration dur)))
    (do ((i 0 (+ 1 i)))
	((= i samps))
      (let ((harm (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> harmf)))
	(set! (coeffs 3) harm)
	(set! (coeffs 4) (- .25 harm))
	(<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> ampf)
		   (<em class=red>mus-chebyshev-t-sum</em> x coeffs)))
	(set! x (+ x incr))))))
</pre>
</td></tr></table>

<p>
But we can also vary 
the index (the amplitude of the cosine driving the sum of polynomials), much as in FM.
The kth partial's amplitude
at a given index, given a set h[k] of coefficients, is:
</p>

<img src="pix/sceq43.png" alt="cheby hka calc" hspace=40>

<!-- LATEX:
    &h_{k}(a) = \sum_{j=0}^{\infty} \binom{p}{j} a^{p} \sum_{i=0}^{\infty} (-1)^{i}\Big(\tbinom{p+i}{i} + \tbinom{p+i-1}{i-1}\Big) h_{p+2i}(1) & p=k+2j \\
-->

<p>(This formula is implemented by <a href="sndscm.html#chebyhka">cheby-hka</a> in dsp.scm).
The function traced out by the harmonic (analogous to the role the Bessel function Jn plays in FM)
is a polynomial in the index whose order depends on the number of coefficients.  When the index is less than 1.0,
energy appears in lower harmonics even if they are not included in the index=1.0 list:
</p>

<pre>
    &gt; (cheby-hka 3 0.25 (<a class=quiet href="extsnd.html#vct" onmouseout="UnTip()" onmouseover="Tip(extsnd_vct_tip)">vct</a> 0 0 0 0 1.0 1.0))
    -0.0732421875
    &gt; (cheby-hka 2 0.25 (<a class=quiet href="extsnd.html#vct" onmouseout="UnTip()" onmouseover="Tip(extsnd_vct_tip)">vct</a> 0 0 0 0 1.0 1.0))
    -0.234375
    &gt; (cheby-hka 1 0.25 (<a class=quiet href="extsnd.html#vct" onmouseout="UnTip()" onmouseover="Tip(extsnd_vct_tip)">vct</a> 0 0 0 0 1.0 1.0))
    1.025390625
    &gt; (cheby-hka 0 0.25 (<a class=quiet href="extsnd.html#vct" onmouseout="UnTip()" onmouseover="Tip(extsnd_vct_tip)">vct</a> 0 0 0 0 1.0 1.0))
    1.5234375
</pre>

<p>
Below we sweep the index from 0.0
to 1.0 (sticking at 1.0 for a moment at the end), with a partials list of '(11 1.0 20 1.0).  These numbers were chosen to show that the even and
odd harmonics are independent:
</p>

<table border=0 hspace=20>
<tr><td colspan=2>
<pre>
  (<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> ()
    (let ((gen (<em class=red>make-polyshape</em> 100.0 :partials (list 11 1 20 1)))
	  (ampf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1 20 1 21 0) :scaler .4 :length 88200))
	  (indf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1 1.1 1) :length 88200)))
      (do ((i 0 (+ 1 i)))
	  ((= i 88200))
        (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> ampf) (<em class=red>polyshape</em> gen (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> indf)))))))
</pre>
</td></tr>

<tr><td>
<img src="pix/waver.png" alt="picture of waveshaping sweep">
</td><td>
<img src="pix/waver2.png" alt="time domain" hspace=20>
</td></tr>
</table>

<!--
;;; data cutoff .015 light 56 jet
;;; xangle 292 scale 1.45 yangle 0 scale .68 zangle 0 scale 1.39, % 43
-->

<p>You can see there's
another annoying "gotcha":  the DC component can be arbitrarily large.
If we don't counteract it in some way, we lose dynamic range, and we get a big click when the generator stops.
In addition (as the right graph shows, although in this case the effect is minor), the peak amplitude is dependent on the index.  We can reduce this
problem somewhat by changing the signs of the harmonics to follow the
pattern + + - -: 
</p>

<pre>
    (list 1 .5  2 .25  3 -.125  4 -.125) ; squeeze the amplitude change toward index=0
</pre>

<p>but now the peak amplitude is hard to predict (it's .6242 in this example).  Perhaps <a href="sndscm.html#flattenpartials">flatten-partials</a>
would be a better choice here.
To follow an amplitude envelope despite a changing index, we can use a <a href="#moving-max">moving-max</a> generator (from generators.scm):
</p>

<table border=0 hspace=20>
<tr><td>
<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> ()
  (let ((gen (<em class=red>make-polyshape</em> 1000.0 :partials (list 1 .25 2 .25 3 .125 4 .125 5 .25)))
	(indf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1 2 0) :duration 2.0))     ; index env
	(ampf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1 2 1 3 0) :duration 2.0)) ; desired amp env
	(mx (<a class=quiet href="#moving-max" onmouseout="UnTip()" onmouseover="Tip(sndclm_moving_max_tip)">make-moving-max</a> 256))                         ; track actual current amp
	(samps (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> 2.0)))
    (do ((i 0 (+ 1 i)))
	((= i samps))
      (let ((val (<em class=red>polyshape</em> gen (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> indf))))              ; polyshape with index env
	(<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (/ (* (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> ampf) val)
		   (max 0.001 (<a class=quiet href="#moving-max" onmouseout="UnTip()" onmouseover="Tip(sndclm_moving_max_tip)">moving-max</a> mx val))))))))
</pre>
</td></tr></table>

<p>The harmonic amplitude formula for the Chebyshev polynomials of the second kind is:
</p>

<img src="pix/sceq44.png" alt="more cheby hka calcs" hspace=40>

<!-- LATEX:
    &h_{k}(a) = \sum_{j=0}^{\infty} \Big(\tbinom{p-1}{j} - \tbinom{p-1}{j-1}\Big) a^p \sum_{i=0}^{\infty} (-1)^{i} \tbinom{p+i-1}{i} h_{p+2i}(1) & p=k+2j \\
-->

<p>
On a related topic, if we drive the sum of Chebyshev polynomials with more than one sinusoid,
we get sum and difference tones, much as in complex FM:
</p>

<!-- LATEX t5sum:
\lefteqn{T_{5}\Big(  \frac{\cos(x) + \cos(20x)}{2}\Big) = } \\
\frac{1}{32} \big( & \cos (100x)+5 \cos (81x)+5 \cos (79x)+10 \cos (62x)+5 \cos (60x)+ \\
                   & 10 \cos (58x)+ 10 \cos (43x)-10  \cos (41x)-10 \cos (39x)+10 \cos (37x)+ \\
                   & 5 \cos (24x)-10 \cos (22x)- 10 \cos (18x)+5 \cos (16x)+ \cos (5x)+5 \cos (3x) \big)
-->

<table border=1 cellpadding=10 hspace=20>
<tr><td>
<center>T5 driven with sinusoids at 100Hz and 2000Hz</center>
<hr>
<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> ()
  (let ((pcoeffs (<em class=red>partials-&gt;polynomial</em> (<a class=quiet href="extsnd.html#vct" onmouseout="UnTip()" onmouseover="Tip(extsnd_vct_tip)">vct</a> 5 1)))
	(gen1 (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> 100.0))
	(gen2 (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> 2000.0)))
    (do ((i 0 (+ 1 i)))
	((= i 44100))
      (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (<em class=red>polynomial</em> pcoeffs 
                (+ (* 0.5 (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> gen1))
		   (* 0.5 (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> gen2))))))))
</pre>
<hr>
<center><img src="pix/t5sum.png"></center>
</td>
<td>
<img src="pix/crosswave.png">
</td></tr></table>

<p>This kind of output is typical; I get the impression that the cross products are
much more noticeable here than in FM. 
Of course, we can take advantage of that:
</p>
<table border=0 hspace=20><tr><td>
<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:channels 2)
  (let* ((dur 2.0)
	 (samps (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur))
	 (p1 (<em class=red>make-polywave</em> 800 (list 1 .1  2 .3  3 .4 5 .2)))
	 (p2 (<em class=red>make-polywave</em> 400 (list 1 .1  2 .3  3 .4 5 .2)))
	 (interpf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1) :duration dur))
	 (p3 (<em class=red>partials-&gt;polynomial</em> (list 1 .1  2 .3  3 .4  5 .2)))
	 (g1 (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> 800))
	 (g2 (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> 400))
	 (ampf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1 10 1 11 0) :duration dur)))
    (do ((i 0 (+ 1 i)))
	((= i samps))
      (let ((interp (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> interpf))
	    (amp (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> ampf)))
	;; chan A: interpolate from one spectrum to the next directly
	(<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* amp (+ (* interp (<em class=red>polywave</em> p1))
			  (* (- 1.0 interp) (<em class=red>polywave</em> p2)))))
        ;; chan B: interpolate inside the sum of Tns!
	(<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outb</a> i (* amp (<em class=red>polynomial</em> p3 (+ (* interp (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> g1))
					 (* (- 1.0 interp) (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> g2))))))))))
</pre></td></tr></table>

<p>
If we use an arbitrary sound as the argument
to the polynomial, the output is a brightened or distorted version of the
original:
</p>

<!-- 
(The comparison in the T5 case above is between
T5(a+b) = 16(a+b)^5 - 20(a+b)^3 + 5(a+b) and the complex FM equation cos(5*(a+b))).
-->

<pre>
  (define (brighten-slightly coeffs)
    (let ((pcoeffs (partials-&gt;polynomial coeffs))
	  (mx (<a class=quiet href="extsnd.html#maxamp" onmouseout="UnTip()" onmouseover="Tip(extsnd_maxamp_tip)">maxamp</a>)))
      (<a class=quiet href="extsnd.html#mapchannel" onmouseout="UnTip()" onmouseover="Tip(extsnd_mapchannel_tip)">map-channel</a>
       (lambda (y)
         (* mx (<a class=quiet href="#polynomial" onmouseout="UnTip()" onmouseover="Tip(sndclm_polynomial_tip)">polynomial</a> pcoeffs (/ y mx)))))))
</pre>

<p>but watch out for clicks from the DC component if any of the "n" in the Tn are even.
When I use this idea, I either use only odd numbered partials in the partials-&gt;polynomial list,
or add an amplitude envelope to make sure the result ends at 0.  I suppose you could also subtract out
the DC term (coeffs[0]), but I haven't tried this.
</p>

<!--
(with-sound (:channels 3 :clipped #f :statistics #t)
  (let* ((dur 1.0)
	 (samps (seconds->samples dur))
	 (coeffs (partials->polynomial '(5 1)))
	 (gen (make-oscil 100.0))
	 (gen1 (make-oscil 500.0)))
    (do ((i 0 (+ 1 i)))
	((= i samps))
      (let* ((val (oscil gen))
	     (nval (oscil gen1))
	     (aval (polynomial coeffs (- 1.0 (* 2 val val))))
	     (bval (- 1.0 (* 2 nval nval)))
	     (cval (- aval bval)))
	(outa i aval)
	(outb i bval)
	(outc i cval)))))
-->

<p>If you push the polyshape generator into high harmonics (above say 30), you'll
run into numerical trouble (the polywave generator is immune to this bug).
Where does the trouble lie?
The polynomials are related to each other
via the recursion: <img src="pix/sceq17.png" alt="Cheby recurse" align=absmiddle>, so the first
few polynomials are:
</p>

<!-- LATEX:
\begin{align*}
&T_{0}(x)=1 \\
&T_{1}(x)=x \\
&T_{2}(x)=2x^{2}-1\\
&T_{3}(x)=4x^{3}-3x \\
&T_{4}(x)=8x^{4}-8x^{2}+1
\end{align*}

\begin{align*}
&U_{0}(x)=1 \\
&U_{1}(x)=2x \\
&U_{2}(x)=4x^{2}-1 \\
&U_{3}(x)=8x^{3}-4x \\
&U_{4}(x)=16x^{4}-12x^{2}+1
\end{align*}

-->

<table border=0 hspace=40><tr>
<td><img src="pix/sceq18.png" alt="some Chebys"></td>
<td width=20></td>
<td><img src="pix/sceq19.png" alt="more Chebys"></td>
</tr></table>

<p>The first coefficient is 2^n or 2^(n-1).  This is bad news if "n" is large because
we are expecting a bunch of huge numbers 
to add up to something in the vicinity of 0.0 or 1.0.  
If we're using 32-bit floats, the first sign of trouble comes when the order is around 26.
If you look at some of the coefficients, you'll see numbers like -129026688.000 (in the 32 bit case), which
should be -129026680.721 &mdash;  we have run out of bits in the mantissa!
Even if we build Snd --with-doubles, 
we can only push the order up to around 46. 
polywave, on the other hand, builds up the sum of sines from the underlying recursion, which is only slightly
slower than using the polynomial, and it is not bothered by these numerical problems.
I have run polywave with 16384 harmonics, and the maximum error compared to the
equivalent sum of sinusoids was around 5.0e-12.
</p>

<p>Since it is primarily used for additive synthesis, and we can always do that with oscils or table-lookup,
we might ask why we'd want polywave at all.  Leaving aside
speed (the Chebyshev computation is 10 to 20 times faster than the equivalent sum of oscils)
and memory (the defunct table-lookup based waveshape generator and table-lookup itself use a table that has to be loaded),
the main reason to use polywave is accuracy.  polywave
produces output that is as clean as the equivalent sum of oscils, whereas table-lookup 
and poor old waveshape, both of which interpolate into a sampled version of the desired function, are noisy.
To make the difference almost appalling, here are spectra comparing a sum of oscils, polyshape,
(table-lookup based) waveshape, and table-lookup. 
</p>

<img src="pix/4grfs.png" alt="compare ffts" hspace=40>

<!--
(with-sound (:channels 4)
  (let ((poly (make-polyshape 100.0 :partials '(1 1 8 1 16 1)))
	(wave (make-waveshape 100.0 :partials '(1 1 8 1 16 1))) ; this is normalized
	(gen1 (make-oscil 100))
	(gen2 (make-oscil 800))
	(gen3 (make-oscil 1600))
	(table (make-table-lookup 100.0 :wave (partials->wave '(1 1 8 1 16 1))))
	)
    (run
       (do ((i 0 (+ 1 i)))
	   ((= i 500000))
	 (out-any i (* .3 (+ (oscil gen1) (oscil gen2) (oscil gen3))) 0)
	 (out-any i (* .3 (polyshape poly)) 1)
	 (out-any i (* .9 (waveshape wave)) 2)
	 (out-any i (* .3 (table-lookup table)) 3)))))
	 
(set! (x-axis-label 0 0 1) "sum of oscils: frequency")
(set! (x-axis-label 0 1 1) "polyshape: frequency")
(set! (x-axis-label 0 2 1) "waveshape: frequency")
(set! (x-axis-label 0 3 1) "table-lookup: frequency")
-->

<table border=1 hspace=200 vspace=10 cellpadding=6><tr><td>
<p><small>
The table size is 512, but that almost doesn't matter; you'd have to use a table size of at least 8192
to approach the oscil and polyshape cases.  The FFT size is 1048576, with no data window ("rectangular"), and the y-axis
is in dB, going down to -120 dB.  The choice of fft window
can make a big difference; using no window, but a huge fft seems like the least confusing
way to present this result.
</small></p>
<p><small>
Notice the lower peaks in the table-lookup case.  partials-&gt;wave puts n periods of the nth harmonic
in the table, so the nth harmonic has an effective table length of table-length/n.  n * 1/n = 1, so all
our components have their first interpolation noise peak centered (in this case) around 7100 Hz ((512 * 100) mod 22050).
Since the 1600 Hz component has an effective table size of only 32 samples, it creates big sidebands at 5500 Hz
and 8700 Hz.  The 800 Hz component makes smaller peaks (by a factor of 4, since this is proportional to n^2) at
6300 Hz and 7900 Hz, and the 100 Hz
cases are at 7000 Hz and 7200 Hz (down in amplitude by 16^2).  The highest peaks are down only 60 dB.
See <a href="#table-lookup">table-lookup</a> for more discussion of interpolation noise (it's actually
amplitude modulation of the stored signal and the linear interpolating signal with severe aliasing).
</small></p>
<p><small>
The waveshaping noise is much worse because the polynomial is so 
sensitive numerically.  Here is a portion of the error signal at the point where the driving sinusoid
is at its maximum:
</small></p>
<img src="pix/errorwave.png" alt="cheby error" hspace=40>
</td></tr></table>

<!--
;;; omitted 100 component since it is clean and I couldn't get it to cancel...
(with-sound (:srate 1000000)
  (let ((wave (make-waveshape 100.0 :partials '(8 1 16 1) :size 512))
	(osc1 (make-oscil 1600.0 (* 0.5 pi))) 
	(osc2 (make-oscil 800.0 (* 0.5 pi))))
    (do ((i 0 (+ 1 i)))
	((= i 1000000))
      (outa i (- (waveshape wave)
		 (* 1/2 (+ (oscil osc1) 
			   (oscil osc2))))))))
-->


<!-- this works: (make-waveshape 100.0 :partials '(1 1) :size 2)
     because the initial "polynomial" is a straight line: 
       :(mus-data (make-waveshape 100.0 :partials '(1 1) :size 2))
       #<vct[len=2]: -1.000 1.000>
     and we use array-interp to drive it with a sinusoid, so x=x!
-->

<p>
See also <a href="#polyoid">polyoid and noid</a> in generators.scm.
</p>

<br><br>




<A NAME="sawtoothdoc"></A>
<!-- ---------------------------------------- SAWTOOTH ETC ---------------------------------------- -->

<table width="70%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>sawtooth-wave, triangle-wave, pulse-train, square-wave</h3></center></td></tr></table>
<br>
<pre>
  <a class=def name="make-triangle-wave">make-triangle-wave</a> (frequency *clm-default-frequency*) (amplitude 1.0) (initial-phase pi)
  <a class=def name="triangle-wave">triangle-wave</a> s (fm 0.0)
  <a class=def name="triangle-wave?">triangle-wave?</a> s

  <a class=def name="make-square-wave">make-square-wave</a> (frequency *clm-default-frequency*) (amplitude 1.0) (initial-phase 0)
  <a class=def name="square-wave">square-wave</a> s (fm  0.0)
  <a class=def name="square-wave?">square-wave?</a> s

  <a class=def name="make-sawtooth-wave">make-sawtooth-wave</a> (frequency *clm-default-frequency*) (amplitude 1.0) (initial-phase pi)
  <a class=def name="sawtooth-wave">sawtooth-wave</a> s (fm 0.0)
  <a class=def name="sawtooth-wave?">sawtooth-wave?</a> s

  <a class=def name="make-pulse-train">make-pulse-train</a> (frequency *clm-default-frequency*) (amplitude 1.0) (initial-phase (* 2 pi))
  <a class=def name="pulse-train">pulse-train</a> s (fm 0.0)
  <a class=def name="pulse-train?">pulse-train?</a> s
</pre>


<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t)
  (let ((gen (make-triangle-wave 440.0)))
    (do ((i 0 (+ 1 i)))
        ((= i 44100))
      (outa i (* 0.5 
                 (triangle-wave gen))))))
</pre>
</td>

<td width=4></td>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true) do
  gen = make_triangle_wave(440.0);
  44100.times do |i| 
    outa(i, 0.5 * triangle_wave(gen), 
         $output) 
    end
  end.output
</pre>
</td>
<td width=4></td>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  440.0 make-triangle-wave { gen }
  44100 0 do
    i  gen 0 triangle-wave  f2/ *output* outa drop
  loop
; :play #t with-sound drop
</pre>
</td>
</tr>
</table>




<table border=1 align=left hspace=40 vspace=20 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>saw-tooth and friends' methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>frequency in Hz</td></tr>
<tr><td><em class=gen>mus-phase</em></td><td>phase in radians</td></tr>
<tr><td><em class=gen>mus-scaler</em></td><td>amplitude arg used in make-&lt;gen&gt;</td></tr>
<tr><td><em class=gen>mus-width</em></td><td>width of square-wave pulse (0.0 to 1.0)</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>frequency in radians per sample</td></tr>
</table>
<pre>
<br>
One popular kind of vibrato is:
  (+ (triangle-wave pervib) 
     (<a class=quiet href="#rand-interp" onmouseout="UnTip()" onmouseover="Tip(sndclm_rand_interp_tip)">rand-interp</a> ranvib))
</pre><br clear=left>

<p>These generators produce some standard old-timey wave forms that are still occasionally useful (well, triangle-wave
is useful; the others are silly).
sawtooth-wave ramps from -1 to 1, then goes immediately back to -1.
Use a negative frequency to turn the "teeth" the other way.
To get a sawtooth from 0 to 1, you can use modulo:
</p>
<pre>
    (with-sound () (do ((i 0 (+ i 1)) (x 0.0 (+ x .01))) ((= i 22050)) (outa i (modulo x 1.0))))
</pre>
<p>
triangle-wave ramps from -1 to 1, then ramps from 1 to -1.
pulse-train produces a single sample of 1.0, then zeros.
square-wave produces 1 for half a period, then 0.  All have a period
of two pi, so the "fm" argument should have an effect comparable to the
same FM applied to the same waveform in <a href="#table-lookup">table-lookup</a>.
To get a square-wave with control over the "duty-factor":
</p>

<table border=0 hspace=40>
<tr><td>
<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> ()
  (let* ((duty-factor .25) ; ratio of pulse duration to pulse period
	 (p-on (<em class=red>make-pulse-train</em> 100 0.5))
	 (p-off (<em class=red>make-pulse-train</em> 100 -0.5 (* 2 pi (- 1.0 duty-factor))))
	 (sum 0.0))
    (do ((i 0 (+ 1 i)))
	((= i 44100))
      (set! sum (+ sum (<em class=red>pulse-train</em> p-on) (<em class=red>pulse-train</em> p-off)))
      (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i sum))))
</pre>
</td></tr>
</table>

<p>
This is the <a href="#adjustable-square-wave">adjustable-square-wave</a> generator in generators.scm.
That file also defines <a href="#adjustable-triangle-wave">adjustable-triangle-wave</a> and
<a href="#adjustable-sawtooth-wave">adjustable-sawtooth-wave</a>.
All of these generators produce non-band-limited output; if the frequency is too high, you can get foldover.
A more reasonable square-wave can be generated via
<code>(tanh (* B (sin theta)))</code>, where "B" (a float) sets how squared-off it is:
</p>

<!-- MAXIMA:

(%i25) g:tanh(x);
(%o25)                              tanh(x)

(%i26) taylor(g, x, 0, 30);
               3      5       7       9         11          13           15
              x    2 x    17 x    62 x    1382 x     21844 x     929569 x
(%o26)/T/ x - -- + ---- - ----- + ----- - -------- + --------- - ----------
              3     15     315    2835     155925     6081075    638512875
            17              19                21                 23
   6404582 x     443861162 x     18888466084 x     113927491862 x
 + ----------- - ------------- + --------------- - ----------------
   10854718875   1856156927625   194896477400625   2900518163668125
                   25                       27                         29
   58870668456604 x       8374643517010684 x       689005380505609448 x
 + ------------------- - ---------------------- + ------------------------
   3698160658676859375   1298054391195577640625   263505041412702261046875
 + . . .


(%i27) %o26, x=sin(z);
                                 29                             27
(%o27)/R/ (689005380505609448 sin  (z) - 1700052633953168852 sin  (z)
                          25                              23
 + 4194711739538404812 sin  (z) - 10350036361494934650 sin  (z)
                           21                              19
 + 25537691106934706700 sin  (z) - 63011727151730106750 sin  (z)
                            17                               15
 + 155475205260997371750 sin  (z) - 383619700449993632625 sin  (z)
                            13                                11
 + 946543847036760472500 sin  (z) - 2335507245357412376250 sin  (z)
                             9                                 7
 + 5762720482394194068750 sin (z) - 14220906996875995040625 sin (z)
                              5                                 3
 + 35134005521693634806250 sin (z) - 87835013804234087015625 sin (z)
 + 263505041412702261046875 sin(z))/263505041412702261046875

(%i28) trigreduce(%);
(%o28) (86125672563201181 sin(29 z) - 1647618187356249823 sin(27 z)
 + 20405735981368709608 sin(25 z) - 143279266372116745248 sin(23 z)
 + 988870340521967329881 sin(21 z) - 2752920136953483215355 sin(19 z)
 + 29747753151337835654040 sin(17 z) + 129373079585789187237960 sin(15 z)
 + 2185282463071876214254065 sin(13 z) + 24072873961147105570521045 sin(11 z)
 + 287379988570533329332221360 sin(9 z) + 3380634686040416561206315320 sin(7 z)
 + 39937948481686006738647866205 sin(5 z)
 + 479626886628129180815136726345 sin(3 z)
 + 7176645106520349975113077043760 sin(z))/8841761993739701954543616000000



(%i40) tanh(sin(x));
(%o40)                           tanh(sin(x))

(%i41) exponentialize(%);
                       %i x     - %i x            %i x     - %i x
                 %i (%e     - %e      )     %i (%e     - %e      )
               - ----------------------     ----------------------
                           2                          2
             %e                         - %e
(%o41)       -----------------------------------------------------
                     %i x     - %i x              %i x     - %i x
               %i (%e     - %e      )       %i (%e     - %e      )
               ----------------------     - ----------------------
                         2                            2
             %e                       + %e

(%i42) ratsimp (%);
                                  %i x          - %i x
                             %i %e         %i %e
                           %e          - %e
(%o42)                   - ---------------------------
                                  %i x          - %i x
                             %i %e         %i %e
                           %e          + %e

(%i44) demoivre(%o42);
                %i (%i sin(x) + cos(x))     %i (cos(x) - %i sin(x))
              %e                        - %e
(%o44)      - -----------------------------------------------------
                %i (%i sin(x) + cos(x))     %i (cos(x) - %i sin(x))
              %e                        + %e

(%i45) trigsimp(%);
                                  2 sin(x)
                                %e         - 1
(%o45)                          --------------
                                  2 sin(x)
                                %e         + 1

(%i46) factor(%);
                            sin(x)         sin(x)
                         (%e       - 1) (%e       + 1)
(%o46)                   -----------------------------
                                  2 sin(x)
                                %e         + 1
;; if B sin x:
(%i53) trigsimp(%);
                                 2 sin(x) B
                               %e           - 1
(%o53)                         ----------------
                                 2 sin(x) B
                               %e           + 1

(%i79) bfloat(%o28);
(%o79) 1.130996288644772B-31 (8.612567256320118B16 sin(2.9B1 z)
 - 1.64761818735625B18 sin(2.7B1 z) + 2.040573598136871B19 sin(2.5B1 z)
 - 1.432792663721167B20 sin(2.3B1 z) + 9.888703405219673B20 sin(2.1B1 z)
 - 2.752920136953483B21 sin(1.9B1 z) + 2.974775315133784B22 sin(1.7B1 z)
 + 1.293730795857892B23 sin(1.5B1 z) + 2.185282463071876B24 sin(1.3B1 z)
 + 2.407287396114711B25 sin(1.1B1 z) + 2.873799885705333B26 sin(9.0B0 z)
 + 3.380634686040417B27 sin(7.0B0 z) + 3.993794848168601B28 sin(5.0B0 z)
 + 4.796268866281292B29 sin(3.0B0 z) + 7.17664510652035B30 sin(z))
(%i80) expand(%);
(%o80) 9.740781602601538B-15 sin(2.9B1 z) - 1.863450055003545B-13 sin(2.7B1 z)
 + 2.307881166199309B-12 sin(2.5B1 z) - 1.620483185066097B-11 sin(2.3B1 z)
 + 1.118408685081237B-10 sin(2.1B1 z) - 3.113542457829846B-10 sin(1.9B1 z)
 + 3.36445984096839B-9 sin(1.7B1 z) + 1.463204728620722B-8 sin(1.5B1 z)
 + 2.471546355374797B-7 sin(1.3B1 z) + 2.722633110707074B-6 sin(1.1B1 z)
 + 3.250257005040501B-5 sin(9.0B0 z) + 3.823485283175494B-4 sin(7.0B0 z)
 + 4.516967150887297B-3 sin(5.0B0 z) + 5.424562287106608B-2 sin(3.0B0 z)
 + 8.116758980395178B-1 sin(z)

(%i4) (%e^(2*B*sin(x))-1)/(%e^(2*B*sin(x))+1);
                                 2 sin(x) B
                               %e           - 1
(%o4)                          ----------------
                                 2 sin(x) B
                               %e           + 1
(%i5) taylor(%, x, 0, 20);
                   3       3        5       3       5
               (2 B  + B) x    (16 B  + 20 B  + B) x
(%o5)/T/ B x - ------------- + ----------------------
                     6                  120
         7        5        3       7
   (272 B  + 560 B  + 182 B  + B) x
 - ---------------------------------
                 5040
          9          7          5         3       9
   (7936 B  + 22848 B  + 15456 B  + 1640 B  + B) x
 + ------------------------------------------------
                        362880
            11            9            7           5          3       11
   (353792 B   + 1309440 B  + 1382304 B  + 399520 B  + 14762 B  + B) x
 - ---------------------------------------------------------------------
                                 39916800
               13              11              9             7             5
 + ((22368256 B   + 101184512 B   + 146395392 B  + 74524736 B  + 10106096 B
           3       13                             15                13
 + 132860 B  + B) x  )/6227020800 - ((1903757312 B   + 10177556480 B
                11                9               7              5            3
 + 18769726976 B   + 14032395520 B  + 3823515696 B  + 253715280 B  + 1195742 B
       15                                  17                  15
 + B) x  )/1307674368000 + ((209865342976 B   + 1294554972160 B
                  13                  11                  9                 7
 + 2906710130688 B   + 2896710209536 B   + 1248180730368 B  + 191665428864 B
               5             3       17
 + 6352447936 B  + 10761680 B  + B) x  )/355687428096000
                     19                    17                    15
 - ((29088885112832 B   + 203359517343744 B   + 538664323915776 B
                    13                    11                    9
 + 674376523857920 B   + 406146637591552 B   + 106694759907840 B
                  7                 5             3       19
 + 9499597629248 B  + 158897291840 B  + 96855122 B  + B) x  )
/121645100408832000 + . . .


;;; the B^3 term is (9^n - 1)/4 (Sloane encyc A12587)
;;; (do ((n 0 (+ n 1))) ((= n 8)) (format #t "~A " (/ (- (expt 9 n) 1) 4)))
;;; 0 2 20 182 1640 14762 132860 1195742

;;; B^5 is some 25^n business:
;;; Sloane A002453:
;;; (do ((n 0 (+ n 1))) ((= n 8)) (format #t "~A " (* (+ (* 625 (expt 25 n)) (* -243 (expt 9 n)) 2) 16/384)))
;;; 16 560 15456 399520 10106096 253715280 6352447936 158897291840 "central factorial"

;;; B^7 is 49 
;;; B^9 is probably 81 etc


(%o3)                        tanh(sin(y) + sin(x))
(%i4) exponentialize(%)
;
                 %i y     - %i y          %i x     - %i x
           %i (%e     - %e      )   %i (%e     - %e      )
         - ---------------------- - ----------------------
                     2                        2
(%o4) (%e
           %i y     - %i y          %i x     - %i x
     %i (%e     - %e      )   %i (%e     - %e      )
     ---------------------- + ----------------------
               2                        2
 - %e                                               )
          %i y     - %i y          %i x     - %i x
    %i (%e     - %e      )   %i (%e     - %e      )
    ---------------------- + ----------------------
              2                        2
/(%e
             %i y     - %i y          %i x     - %i x
       %i (%e     - %e      )   %i (%e     - %e      )
     - ---------------------- - ----------------------
                 2                        2
 + %e                                                 )
(%i5) ratsimp(%);
                     %i y        %i x          - %i y        - %i x
                %i %e     + %i %e         %i %e       + %i %e
              %e                      - %e
(%o5)       - -----------------------------------------------------
                     %i y        %i x          - %i y        - %i x
                %i %e     + %i %e         %i %e       + %i %e
              %e                      + %e
(%i6) demoivre(%);
           %i (%i sin(y) + cos(y)) + %i (%i sin(x) + cos(x))
(%o6) - (%e
     %i (cos(y) - %i sin(y)) + %i (cos(x) - %i sin(x))
 - %e                                                 )
    %i (%i sin(y) + cos(y)) + %i (%i sin(x) + cos(x))
/(%e
     %i (cos(y) - %i sin(y)) + %i (cos(x) - %i sin(x))
 + %e                                                 )
(%i7) trigsimp(%);
                             2 sin(y) + 2 sin(x)
                           %e                    - 1
(%o7)                      -------------------------
                             2 sin(y) + 2 sin(x)
                           %e                    + 1

-->


<table border=1 hspace=20 vspace=10>
<tr>
<td bgcolor="#f2f4ff"><center>B: 1.0</center></td>
<td width=16></td>
<td bgcolor="#f2f4ff"><center>B: 3.0</center></td>
<td width=16></td>
<td bgcolor="#f2f4ff"><center>B: 100.0</center></td>
</tr>
<tr>
<td>
<img src="pix/tanh1.png" alt="tanh 1">
</td>
<td width=16></td>
<td>
<img src="pix/tanh3.png" alt="tanh 1">
</td>
<td width=16></td>
<td>
<img src="pix/tanh100.png" alt="tanh 1">
</td></tr></table>

<!-- LATEX: sceq11
 \tanh(x) = x-\frac{x^{3}}{3}+\frac{2x^{5}}{15}-\frac{17x^{7}}{315}+\frac{62x^{9}}{2835}-\frac{1382x^{11}}{155925}\cdots 

long form:

\tanh(x) = x-\frac{x^{3}}{3}+\frac{2x^{5}}{15}-\frac{17x^{7}}{315}+\frac{62x^{9}}{2835}-\frac{1382x^{11}}{155925}+\frac{21844x^{13}}{6081075}-\frac{929569x^{15}}{638512875}\cdots

\tanh(x) = x-\frac{x^{3}}{3}+\frac{2x^{5}}{15}-\frac{17x^{7}}{315}+\frac{62x^{9}}{2835}-\frac{1382x^{11}}{155925}+\frac{21844x^{13}}{6081075}-\frac{929569x^{15}}{638512875}+\frac{6404582x^{17}}{10854718875}-\frac{443861162x^{19}}{1856156927625}\cdots

-->
<!-- LATEX: sceq12
\tanh(\sin(x)) = \frac{140069}{172800} \sin(x) + \frac{13319}{241920} \sin(3x) + \frac{1973}{483840} \sin(5x) + \frac{799}{1451520} \sin(7x) - \frac{71}{7257600} \sin(9x) + \frac{691}{79833600} \sin(11x) + \cdots 
-->

<!-- LATEX: tanhsum.png
& \tanh(B \sin(x)) = \frac{\sinh(B \sin(x))}{\cosh(B \sin(x))} = \frac{2 \sum_{k=0}^{\infty} (-1)^{k} I_{2k+1}(B) \sin(2k+1)x}{\cosh(B \sin(x))}

second try:
& \tanh(B \sin(x)) = \frac{-i \sin(iB \sin(x))}{\cos(iB \sin(x))} = \frac{2 \sum_{k=0}^{\infty} (-1)^{k} I_{2k+1}(B) \sin(2k+1)x}{\cos(iB \sin(x))} = \frac{e^{2B\sin(x)} - 1}{e^{2B\sin(x)}+1}

third try:
\tanh(B \sin(x)) = \frac{-i \sin(iB \sin(x))}{\cos(iB \sin(x))} = \frac{2 \sum_{k=0}^{\infty} (-1)^{k} I_{2k+1}(B) \sin(2k+1)x}{\cos(iB \sin(x))} = \frac{e^{2B\sin(x)} - 1}{e^{2B\sin(x)}+1}

fourth try (break it in 2!!):
\tanh(B \sin(x)) = \frac{-i \sin(iB \sin(x))}{\cos(iB \sin(x))}
= \frac{2 \sum_{k=0}^{\infty} (-1)^{k} I_{2k+1}(B) \sin(2k+1)x}{\cos(iB \sin(x))} = \frac{e^{2B\sin(x)} - 1}{e^{2B\sin(x)}+1}

fifth try: do it as one, and set the "MediaBox" line in the pdf file by hand!!
\tanh(B \sin(x)) = \frac{-i \sin(iB \sin(x))}{\cos(iB \sin(x))} = \frac{2 \sum_{k=0}^{\infty} (-1)^{k} I_{2k+1}(B) \sin(2k+1)x}{\cos(iB \sin(x))} = \frac{e^{2B\sin(x)} - 1}{e^{2B\sin(x)}+1}

-->

<br>
<center>
<table hspace=40 border=0 cellpadding=8>
<tr><td>
<p>
The spectrum of tanh(sin) can be obtained by expanding tanh as a power series:
</p>
<img src="pix/sceq11.png" alt="tanh power series" hspace=20>
<p>
plugging in "sin" for "x", expanding the sine powers, and collecting terms (very tedious &mdash; 
use <a class=quiet onmouseout="UnTip()" onmouseover="Tip('<pre>(%i25) g:tanh(x);<br>(%o25)                              tanh(x)<br><br>(%i26) taylor(g, x, 0, 30);<br>               3      5       7       9         11          13           15<br>              x    2 x    17 x    62 x    1382 x     21844 x     929569 x<br>(%o26)/T/ x - -- + ---- - ----- + ----- - -------- + --------- - ----------<br>              3     15     315    2835     155925     6081075    638512875<br>            17              19                21                 23<br>   6404582 x     443861162 x     18888466084 x     113927491862 x<br> + ----------- - ------------- + --------------- - ----------------<br>   10854718875   1856156927625   194896477400625   2900518163668125<br>                   25                       27                         29<br>   58870668456604 x       8374643517010684 x       689005380505609448 x<br> + ------------------- - ---------------------- + ------------------------<br>   3698160658676859375   1298054391195577640625   263505041412702261046875<br> + . . .<br></pre>')">maxima</a>!):
</p>
<img src="pix/sceq12.png" alt="tanh sin power series" hspace=20>
<p>
which is promising since a square wave is made up of odd harmonics with amplitude 1/n.
As the "B" in tanh(B sin(x)) increases above pi/2, this series doesn't apply.
</p>

<img src="pix/tanhsum.png" alt="more tanh" hspace=20>

<p>but I haven't found a completion of this expansion that isn't ugly when B &gt; pi/2. 
In any case, we can check the
formula for tanh, and see that the e^-x term will vanish (in the positive x case), giving 1.0.
So we do get a square wave, but it's not band limited.  If a complex signal replaces the sin(x),
we get "intermodulation products" (sum and difference tones); this use of tanh as a soft clipper
goes way back &mdash; I don't know who invented it.
</p>
</td></tr></table>
</center>

<p>If you try to make a square wave by adding harmonics at amplitude 1/n,
you run into "Gibb's phenomenon": although the sum
converges on a square wave, it does so "pointwise" &mdash; each point converges to the square wave,
but the sum always has an overshoot.  To get something that looks square, we need to round-off the
corners. 
Bill Gosper shows one mathematical
way to do this (<a href="http://www.tweedledum.com/rwg/gibbs.html">gibbs.html</a>).
We could also use <a href="sndscm.html#withmixedsound">with-mixed-sound</a> and the Mixes dialog:
</p>

<table hspace=40 border=0><tr><td>
<pre>
(definstrument (sine-wave start dur freq amp)
  (let* ((beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> start))
	 (end (+ beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur)))
	 (osc (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> freq)))
    (run 
     (do ((i beg (+ 1 i))) 
	 ((= i end))
       (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* amp (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> osc)))))))

(<em class=red>with-mixed-sound</em> ()
  (sine-wave 0 1 10.0 1.0)
  (sine-wave 0 1 30.0 .333)
  (sine-wave 0 1 50.0 .2)
  (sine-wave 0 1 70.0 .143))
</pre>
</td></tr></table>

<p>
Now we can play with the
individual sinewave amplitudes in the Mixes dialog, seeing "in realtime" what
effect an amplitude has on the waveform.  In the graph below, we've taken the original set of four sines
and chosen amplitudes 1.16, .87, .46, .14 (these are multipliers on the original 1/n amps).
The first graph is the original waveform, the last is the result of the
amplitude changes, and the middle one shows 100 sines (it is the usual demo that
the Gibbs overshoot is not reduced by adding lots more components).
The peak amplitude should be pi/4, but the Gibbs phenomenon adds .14.
</p>

<img src="pix/smoothsq.png" alt="reduce Gibbs" hspace=40>
<br>

<!--
(definstrument (sine-wave start dur freq amp)
  (let* ((beg (seconds->samples start))
	 (end (+ beg (seconds->samples dur)))
	 (osc (make-oscil freq)))
    (run 
       (do ((i beg (+ 1 i))) 
	   ((= i end))
	 (outa i (* amp (oscil osc)))))))

(with-sound (:output "4-sines.snd")
  (sine-wave 0 1 10.0 1.0)
  (sine-wave 0 1 30.0 .333)
  (sine-wave 0 1 50.0 .2)
  (sine-wave 0 1 70.0 .143))

(with-sound (:output "100-sines.snd")
  (do ((i 1 (+ i 2)))
      ((> i 200))
    (sine-wave 0 1 (* i 10.0) (/ 1.0 i))))

(with-mixed-sound (:output "4-sines-mixed.snd")
  (sine-wave 0 1 10.0 1.0)
  (sine-wave 0 1 30.0 .333)
  (sine-wave 0 1 50.0 .2)
  (sine-wave 0 1 70.0 .143))
-->

<p>But goofing with individual amplitudes quickly becomes tiresome.  This "realtime" business
depends on luck; if we have some idea of what we're doing, we don't have to get lucky.
Since 
tanh(B sin(x)) produces a nice square wave, 
we can truncate its spectrum at the desired number of harmonics:
</p>


<table hspace=40 border=0><tr><td>
<pre>
(define square-wave-&gt;coeffs
  (let ((previous-results (make-vector 128 #f)))
    (lambda* (n B)
      (or (and (&lt; n 128)
	       (not B)
	       (previous-results n))
	  (let* ((coeffs (<a class=quiet href="extsnd.html#makevct" onmouseout="UnTip()" onmouseover="Tip(extsnd_makevct_tip)">make-vct</a> (* 2 n)))
		 (size (expt 2 12))
		 (rl (<a class=quiet href="extsnd.html#makevct" onmouseout="UnTip()" onmouseover="Tip(extsnd_makevct_tip)">make-vct</a> size))
		 (im (<a class=quiet href="extsnd.html#makevct" onmouseout="UnTip()" onmouseover="Tip(extsnd_makevct_tip)">make-vct</a> size))
		 (incr (/ (* 2 pi) size))
		 (index (or B (max 1 (floor (/ n 2))))))
	    (do ((i 0 (+ 1 i))
		 (x 0.0 (+ x incr)))
		((= i size))
	      (set! (rl i) (<em class=red>tanh</em> (* index (<em class=red>sin</em> x))))) ; make our desired square wave
	    (<a class=quiet href="#spectrum" onmouseout="UnTip()" onmouseover="Tip(sndclm_spectrum_tip)">spectrum</a> rl im #f 2)                       ; get its spectrum
	    (do ((i 0 (+ i 1))
		 (j 0 (+ j 2)))
		((= i n))
	      (set! (coeffs j) (+ j 1))
	      (set! (coeffs (+ j 1)) (/ (* 2 (rl (+ j 1))) size)))
	    (if (and (&lt; n 128)                          ; save this set so we don't have to compute it again
		     (not B))
		(set! (previous-results n) coeffs))
	    coeffs)))))

(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> ()
  (let* ((samps (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> 1.0))
	 (wave (<a class=quiet href="#make-polywave" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_polywave_tip)">make-polywave</a> 100.0 
			      :partials (<em class=red>square-wave-&gt;coeffs</em> 16)
			      :type mus-chebyshev-second-kind)))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
     (do ((i 0 (+ 1 i)))
	 ((= i samps))
       (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* 0.5 (<a class=quiet href="#polywave" onmouseout="UnTip()" onmouseover="Tip(sndclm_polywave_tip)">polywave</a> wave)))))))
</pre>
</td></tr></table>

<table border=1 hspace=20 cellpadding=10 vspace=10><tr><td>
<img src="pix/tanhexs.png">
</td></tr></table>

<p>See also <a href="#tanhsin">tanhsin</a> in generators.scm.
Another square-wave choice is <a href="#eoddcos">eoddcos</a> in <a href="#othergenerators">generators.scm</a>, 
based on atan; as its "r" parameter approaches 0.0, you get closer to a square wave.
Even more amusing is this algorithm (related to tanh(sin)):
<img src="pix/sceq13.png" alt="square" align=absmiddle hspace=10>
<!-- CMJ 37 4 sept 2006 p326 -->
<!-- LATEX: \frac{(c+1)^{\cos t}-(c-1)^{\cos t}}{(c+1)^{\cos t}+(c-1)^{\cos t}} -->

</p>
<table border=0 hspace=40><tr><td>
<pre>
(define (cossq c theta)   ; as c -&gt; 1.0+, more of a square wave (try 1.00001)
  (let* ((cs (cos theta)) ; (+ theta pi) if matching sin case (or (- ...))
	 (cp1 (+ c 1.0))
	 (cm1 (- c 1.0))
	 (cm1c (expt cm1 cs))
	 (cp1c (expt cp1 cs)))
    (/ (- cp1c cm1c)
       (+ cp1c cm1c))))  ; from "From Squares to Circles..." Lasters and Sharpe, Math Spectrum 38:2

(define (sinsq c theta) (cossq c (- theta (* 0.5 pi))))
(define (sqsq c theta) (sinsq c (- (sinsq c theta)))) ; a sharper square wave

(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> ()
  (let ((angle 0.0))
    (do ((i 0 (+ 1 i))
	 (angle 0.0 (+ angle 0.02)))
	((= i 44100))
      (outa i (* 0.5 (+ 1.0 (sqsq 1.001 angle)))))))
</pre>
</td></tr></table>

<p>And in the slightly batty category is this method which uses only nested sines:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> ()
  (let ((angle 0.0) (z 1.18)
        (incr (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> 100.0)))
    (do ((i 0 (+ 1 i)))
        ((= i 20000))
      (let* ((result (* z (sin angle))))
        (do ((k 0 (+ 1 k)))
            ((= k 100))  ; the limit here sets how square it is, and also the overall amplitude
          (set! result (* z (sin result))))
        (set! angle (+ angle incr))
        (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i result)))))
</pre>
</td></tr></table>



<p>The continuously variable square-wave, tanh(B sin), can be differentiated to get a variable pulse-train,
or integrated to get a variable triangle-wave.
The derivative is B * cos(x) / (cosh^2(B * sin(x))):
</p>

<table border=0 hspace=40><tr><td width=450>
<pre>
(with-sound ()
  (let* ((Benv (make-env '(0 .1 .1 1 .7 2 2 5) 
		 :end 10000))
	 (osc (make-oscil 100)))	 
    (do ((i 0 (+ i 1)))
	((= i 10000))
      (let* ((B (env Benv))
	     (num (cos (mus-phase osc)))
	     (den (cosh (* B (oscil osc)))))
	(outa i (/ num (* den den)))))))
</pre>
</td><td>
<img src="pix/tanhsinderiv.png" alt="tanh(sin) as pulse train">
</td></tr></table>

<p>
Similar, but simpler is B*cos(x)/(e^(B*cos(x)) - 1):
</p>

<table border=0 hspace=40><tr><td width=480>
<pre>
(with-sound ()
  (let* ((gen (make-oscil 40.0))
	 (Benv (make-env '(0 .75 1 1.5 2 20) 
                 :end 10000)))
    (run
     (do ((i 0 (+ i 1)))
	 ((= i 10000))
       (let* ((B (env Benv))
	      (arg (* B pi (+ 1.0 (oscil gen)))))
	 (outa i (/ arg (- (exp arg) 1))))))))
</pre>
</td><td>
<img src="pix/xex.png" alt="another pulse train">
</td></tr></table>

<p>
When we integrate tanh(B sin), the peak amp depends
on both the frequency and the "B" factor (which sets how close we get to a triangle wave):
</p>

<table border=0 hspace=40><tr><td width=450>
<pre>
(with-sound ()
  (let* ((gen (make-oscil 30.0))
	 (Benv (make-env '(0 .1 .25 1 2 3 3 10) 
                 :end 20000))
	 (scl (hz-&gt;radians 30.0))
	 (sum 0.0))
    (do ((i 0 (+ i 1)))
	((= i 20000))
      (let* ((B (env Benv))
	     (val (/ (* scl (max 1.0 (log B)) 
	                (tanh (* B (oscil gen)))) 
                     B)))
	(outa i (- sum 1.0))
	(set! sum (+ sum val))))))
</pre>
</td><td>
<img src="pix/tanhsininteg.png" alt="tanh(sin) as triangle-wave">
</td></tr></table>

<!--
(set! (selected-graph-color) (make-color 1 1 1))
(set! (selected-data-color) (make-color 0 0 0))
(set! (x-axis-label 0 0 0) "derivative of tanh(B*sin), B from .1 to 5")
(set! (x-axis-label 0 0 0) "integration of tanh(B*sin), B from .1 to 10")
-->

<p>The amplitude scaling is obviously not right (if "B" &gt; 3, it works to use (* (/ scl 1.6) (tanh (* B (oscil gen))))
and (outa i (- sum .83)), but if "B" is following an envelope, the integration makes it hard to keep everything
centered and normalized).
For sawtooth output, see also <a href="#rksin">rksin</a>.
In these generators, the "fm" argument is useful mainly for various sci-fi sound effects:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(define (tritri start dur freq amp index mcr)
  (let* ((beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> start))
         (end (+ beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur)))
	 (carrier (<em class=red>make-triangle-wave</em> freq))
	 (modulator (<em class=red>make-triangle-wave</em> (* mcr freq))))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
     (do ((i beg (+ 1 i)))
	 ((= i end))
       (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* amp (<em class=red>triangle-wave</em> carrier 
                      (* index (<em class=red>triangle-wave</em> modulator)))))))))

(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:srate 44100) (tritri 0 1 1000.0 0.5 0.1 0.01)) ; sci-fi laser gun
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:srate 44100) (tritri 0 1 4000.0 0.7 0.1 0.01)) ; a sparrow?
</pre>
</td></tr></table>

<p>On the other hand, animals.scm uses pulse-train's fm argument to track a frequency envelope,
triggering a new peep each time the pulse goes by.
I think just about every combination of oscil/triangle-wave/sawtooth-wave/square-wave has been
used.  Even triangle-wave(square-wave) can make funny noises.  See <a href="#ncosdoc">ncos</a>
for more dicussion about using these generators as FM modulators.
</p>

<br><br>



<A NAME="ncosdoc"></A>
<!-- ---------------------------------------- NCOS, NSIN ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>ncos and nsin</h3></center></td></tr></table>
<br>

<pre>
  <a class=def name="make-ncos">make-ncos</a> (frequency *clm-default-frequency*) (n 1)
  <a class=def name="ncos">ncos</a> nc (fm 0.0)
  <a class=def name="ncos?">ncos?</a> nc

  <a class=def name="make-nsin">make-nsin</a> (frequency *clm-default-frequency*) (n 1)
  <a class=def name="nsin">nsin</a> ns (fm 0.0)
  <a class=def name="nsin?">nsin?</a> ns
</pre>
<br>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t)
  (let ((gen (make-ncos 440.0 10)))
    (do ((i 0 (+ 1 i)))
        ((= i 44100))
      (outa i (* 0.5 (ncos gen))))))
</pre>
</td>

<td width=4></td>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true) do
  gen = make_ncos(440.0, 10);
  44100.times do |i| 
    outa(i, 0.5 * ncos(gen), $output) 
    end
  end.output
</pre>
</td>
<td width=4></td>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  440.0 10 make-ncos { gen }
  44100 0 do
    i  gen 0 ncos  f2/ *output* outa drop
  loop
; :play #t with-sound drop
</pre>
</td>
</tr>
</table>


<p>ncos produces a band-limited pulse train containing
"n" cosines.  I think this was originally viewed as a way to get a speech-oriented
pulse train that would then be passed through formant filters (see pulse-voice in examp.scm).  
Set "n" to srate/2 to get a pulse-train (a single non-zero sample).
There are many similar formulas:
see <a href="#ncos2">ncos2</a> and friends in <a href="#othergenerators">generators.scm</a>. "Trigonometric Delights" by Eli Maor has
a derivation of the nsin formula and a neat
geometric explanation.  For a derivation of the ncos formula, see "Fourier
Analysis" by Stein and Shakarchi, or (in the formula given below) multiply the left side (the cosines) by sin(x/2), use the trig
formula 2sin(a)cos(b) = sin(b+a)-sin(b-a), and notice that all the terms in the series
cancel except the last. 
</p>

<table border=1 align=left hspace=40 vspace=10 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>ncos methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>frequency in Hz</td></tr>
<tr><td><em class=gen>mus-phase</em></td><td>phase in radians</td></tr>
<tr><td><em class=gen>mus-scaler</em></td><td>(/ 1.0 cosines)</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>n or cosines arg  used in make-&lt;gen&gt;</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>frequency in radians per sample</td></tr>
</table>
<pre>
<br>
based on:
</pre>
<!-- LATEX: \sum_{k=0}^{n}\cos kx = \frac{1}{2}\Bigg(1+\frac{\sin(n+\frac{1}{2})x}{\sin \frac{x}{2}}\Bigg) -->
<img src="pix/sceq2.png" alt="sum of cosines" hspace=40>
<!--
  cos(x) + cos(2x) + ... cos(nx) = 
    (sin((n + .5)x) / (2 * sin(x / 2))) - 1/2
-->
<pre>
the Dirichlet kernel
see also <a href="#othergenerators">generators.scm</a>
</pre><br clear=left>

<br>

<table border=0 hspace=40>
<tr>
<td>
<pre>
(define (simple-soc beg dur freq amp)
  (let* ((os (<em class=red>make-ncos</em> freq 10))
         (start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> beg))
         (end (+ start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur))))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
     (do ((i start (+ 1 i))) ((= i end))
       (outa i (* amp (<em class=red>ncos</em> os)))))))

(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () (simple-soc 0 1 100 1.0))
</pre></td>
<td>
<img src="pix/cosines.png" alt="sum of cosines example" hspace=10>
</td></tr></table>

<p>The <a href="#sinc-train">sinc-train</a> generator (in generators.scm) is very similar to ncos.
If you use ncos as the FM modulating signal, you may be surprised and disappointed.
As the modulating signal approaches a spike (as n increases), the bulk of the energy collapses back onto the carrier:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> ()
  (for-each
    (lambda (arg)
      (let ((car1 (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> 1000))
            (mod1 (<em class=red>make-ncos</em> 100 (cadr arg)))
            (start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> (car arg)))
            (samps (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> 1.0))
            (ampf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1 20 1 21 0) 
                    :duration 1.0 :scaler .8))
            (index (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> (* 100 3.0))))
        (do ((i start (+ 1 i)))
            ((= i (+ start samps)))
            (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> ampf)
                       (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> car1 (* index
                         (<em class=red>ncos</em> mod1))))))))
    (list
     (list 0.0 1)   (list 2.0 2)
     (list 4.0 4)   (list 6.0 8)   
     (list 8.0 16)  (list 10.0 32)
     (list 12.0 64) (list 14.0 128))))
</pre>
</td><td>
<img src="pix/ncosfm.png" alt="ncos as FM" onmouseout="UnTip()" onmouseover="Tip('The n=1 case is at the bottom, the n=128 case at the top.<br>I tried adding axes and labels to this graph, but they looked really dumb')" hspace=40>
</td></tr></table>

<!--
ncosfm.png:
jet .001 59 invert
x 317 1.53
y 237 0.65
z 0 1.28
hop 4 % 0.14
blackman2 8192
-->

<!--
pulsefm.png:
(with-sound (:channels 2)
  (let* ((car1 (make-oscil 1000))
         (mod1 (make-pulse-train 100))
         (samps (seconds->samples 1.0))
         (ampf (make-env '(0 0 1 1 20 1 21 0) :duration 1.0 :scaler .8))
	 (index (hz->radians (* 100 3.0))))
    (do ((i 0 (+ 1 i)))
	((= i samps))
      (let ((amp (env ampf))
	    (fm (* index (pulse-train mod1))))
	(outa i fm)
	(outb i (* amp (oscil car1 fm)))))))

(set! (selected-graph-color) (make-color 1 1 1))
(set! (selected-data-color) (make-color 0 0 0))
(set! (show-transform-peaks 0 0) #f)
cursor 10584
(set! (axis-label-font) (axis-numbers-font))
(set! (x-axis-label 0 0 0) "pulse train modulating signal, FM index: 3.0")
(set! (x-axis-label 0 1 0) "modulated signal")
-->

<img src="pix/pulsefm.png" alt="pulse-train as FM" align=right hspace=20 vspace=20 border=1 onmouseout="UnTip()" onmouseover="Tip('<pre>(with-sound (:channels 2)<br>  (let* ((car1 (make-oscil 1000))<br>	 (mod1 (<em class=red>make-pulse-train</em> 100))<br>	 (samps (seconds-&gt;samples 1.0))<br>	 (ampf (make-env \'(0 0 1 1 20 1 21 0)<br>                 :duration 1.0 :scaler .8))<br>	 (index (hz-&gt;radians (* 100 3.0))))<br>    (do ((i 0 (+ 1 i)))<br>	((= i samps))<br>      (let ((amp (env ampf))<br>	    (fm (* index (<em class=red>pulse-train</em> mod1))))<br>	(outa i fm)<br>	(outb i (* amp (oscil car1 fm)))))))</pre>')">

<p>If you go all the way and use a pulse-train as the FM source, you get a
large component for the carrier, and all the others are very small.
One very sketchy explanation is that since a pulse is close to zero most of the time,
the modulation is also close to zero.
I believe this is the basis of FM radio's
noise reduction: we can filter out the high stuff which is weak anyway, and otherwise
the spike has no effect on our carrier.
Another handwaving approach is:
let "n" be the number of components ncos creates, "B" the amplitude of the modulating signal,
and "k" be the component number.
Since each component produced by ncos has the same
amplitude (B/n), if it is treated as an FM component its FM index is B/(k*n); B/n because 
that's the amplitude of each component, and 1/k since we have to cancel the factor of the
modulating frequency in its index calculation.
As more
components are produced (as n increases), 
the higher ones only matter when all the Ji(B/(k * n))'s are not negligible (since
it's a huge product of J's, <img src="pix/jprod.png" alt="product of Js" align=absmiddle> &mdash; see <a href="fm.html">fm.html</a>).  
B/(k * n) is heading for 0, so the product of J's is non-negligible
only when all the J's are J0 except the solitary J1 that hits that component directly (i.e. the kth).
J0(0) is 1, and J1(0) is 0, and the factor of n is scrunching all our components closer
and closer to 0, so the carrier (all J0's) approaches 1, whereas the others (J0's except
for J1(B/(n*k))) approach 0.
</p>

<!-- LATEX jprod.png \prod_{i=1}^{k}J_{k_{i}}(B_{i}) -->

<!-- j0j1.png:
(with-sound (:channels 2 :srate 10000)
  (do ((x 0.0 (+ x .0001))
       (i 0 (+ 1 i)))
      ((= i 40000))
    (outa i (bes-j0 x))
    (outb i (bes-j1 x))))


(set! (x-axis-label 0 0) "J0 and J1")
(set! (x-axis-label 0 1) "")
(set! (axis-label-font)"9x15")
-->


<table border=0 hspace=20>
<tr><td>
<img src="pix/j0j1.png" alt="j0 and j1">
</td><td colspan=2>
<pre>
(define (ncfm freq-we-want wc modfreq baseindex n)
  ;; get amplitude of "freq-we-want" given ncos as FM, 
  ;;   "wc" as carrier, "modfreq" as ncos freq,
  ;;   "baseindex" as FM-index of 1st harmonic, 
  ;;   "n" as number of harmonics
  (let ((harms '())
	(amps '()))
    (do ((i 1 (+ 1 i)))
	((&gt; i n))
      (set! harms (cons (* i modfreq) harms))
      (set! amps (cons (/ baseindex (* i n)) amps)))
    (<a class=quiet href="sndscm.html#fmparallelcomponent">fm-parallel-component</a> freq-we-want wc 
      (reverse harms) (reverse amps) '() '() #f)))
</pre>
</td></tr>
<tr><td>

<table border=1 cellpadding=4>
<tr><td colspan=3 bgcolor="#f2f4ff"><center>4 components: (ncfm x 1000 100 3.0 4)</center></td></tr>
<tr><td>x=1000</td><td> 0.81</td><td> 0.81 from J0(3/(4*k)) '(0 0 0 0)</td></tr>
<tr><td>x=900</td><td>-0.44</td><td>-0.32 from J1(3/4)*J0s  '(-1 0 0 0)</td></tr>
<tr><td>x=800</td><td>-0.14</td><td>-0.16 from J1(3/8)*J0s  '(0 -1 0 0)</td></tr>
<tr><td>x=700</td><td>-0.06</td><td>-0.10 from J1(3/12)*J0s '(0 0 -1 0)</td></tr>
</table>

</td><td width=20></td><td>

<table border=1 cellpadding=4>
<tr><td colspan=3 bgcolor="#f2f4ff"><center>24 components: (ncfm x 1000 100 3.0 24)</center></td></tr>
<tr><td>x=1000</td><td>0.99</td><td> 0.99 from J0(3/(24*k)) '(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)</td></tr>
<tr><td>x=900</td><td>-0.06</td><td>-0.06 from J1(3/24)*J0s '(-1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)</td></tr>
<tr><td>x=800</td><td>-0.03</td><td>-0.03 from J1(3/48)*J0s '(0 -1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)</td></tr>
<tr><td>x=700</td><td>-0.02</td><td>-0.02 from J1(3/96)*J0s '(0 0 -1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)</td></tr>
</table>

</td></tr></table>


<table border=0 vspace=10>
<tr><td>
<p>You can multiply the index by n to counteract the effect of the n modulators
(in the n=128 case mentioned above, the index becomes 384!).
I find it surprising how smooth the spectral evolution is in this context.
Here we sweep the index from 0 to 48 using n=16:
</p>
</td><td>
<table border=1><tr><td>
<img src="pix/ncossweep.png">
</td></tr>
<tr><td bgcolor="#f2f3ff"><center>ncos (n=16) as FM, index from 0 to 48</center></td></tr>
</table>
</td></tr></table>

<!--
(with-sound (:statistics #t)
  (let* ((dur 10.0)
	 (samps (seconds->samples dur))
	 (car1 (make-oscil 1000))
	 (mod1 (make-sum-of-cosines 16 100))
	 (ampf (make-env '(0 0 1 1 20 1 21 0) :duration dur :scaler .8))
	 (index (hz->radians (* 100 16 3.0)))
	 (indf (make-env '(0 0 1 1) :scaler index :duration dur)))
    (do ((i 0 (+ 1 i)))
	((= i samps))
      (outa i (* (env ampf)
		 (oscil car1 (* (env indf)
				(sum-of-cosines mod1))))))))

4096 blackman2 100(dark) 0 cutoff invert jet
319 1.5
289 0.71
0 1.0
4 0.25
-->

<p>But if our second analysis is correct, there's nothing special about the spike waveform that ncos produces.
We only need a lot of components of decreasing effective FM index.  If we randomize the initial
phases of the n harmonically related equal amplitude sinusoids, we can minimize the peak amplitude (to reduce the
spike), 
getting waveforms and results like these:
</p>


<table border=0 hspace=20><tr><td>
<img src="pix/nsinfm.png" alt="ncos case but random phases">
</td>
<td>
<img src="pix/randomsins.png" alt="ncos case but random phases">
</td></tr>
<tr><td><center><table border=0><tr><td bgcolor="#f2f3ff">FM of sum of n sinusoids</td></tr></table></center></td>
<td><center><table border=0><tr><td bgcolor="#f2f3ff">sum of n sinusoids minimizing resemblance to pulse-train</td></tr></table></center></td>
</tr></table>


<!-- same setting as above

(defgenerator (ngencos 
	       :make-wrapper (lambda (g)
			       (let ((n (ngencos-n g))
				     (frq (ngencos-frequency g))
				     (phases (ngencos-phases g)))
				 (set! (ngencos-arr g) (make-vector n))
				 (do ((i 0 (+ 1 i)))
				     ((= i n))
				   (if (vct? phases)
				       (set! ((ngencos-arr g) i) (make-oscil (* frq (+ 1 i)) (phases i)))
				       (set! ((ngencos-arr g) i) (make-oscil (* frq (+ 1 i)) (random (* 2 pi)))))))
			       g))
  (frequency 0.0) (n 1 :type int) (phases #f :type vct) (arr #f :type clm-vector))


(define* (ngencos gen (fm 0.0)) ; polyoid now, I think
  (declare (gen ngencos) (fm float))
  (let* ((n (ngencos-n gen))
	 (arr (ngencos-arr gen))
	 (sum 0.0))
    (do ((i 0 (+ 1 i)))
	((= i n))
      (set! sum (+ sum (oscil (arr i) (* (+ 1 i) fm)))))
    (/ sum n)))

(with-sound (:channels 1 :clipped #f)
  (for-each
    (lambda (arg)
      (let ((car1 (make-oscil 1000))
	    (norm (/ 1.0 (caddr arg)))
	    (mod1 (make-ngencos 100 (cadr arg) (cadddr arg)))
	    (start (seconds->samples (car arg)))
	    (samps (seconds->samples 1.0))
	    (ampf (make-env '(0 0 1 1 20 1 21 0) 
	            :duration 1.0 :scaler .8))
	    (index (hz->radians (* 100 3.0)))
	    (mx 0.0))
	(run 
	(do ((i start (+ 1 i)))
	    ((= i (+ start samps)))
	  (let ((md (ngencos mod1)))
	    (outa i (* (env ampf)
                       (oscil car1 (* index norm md))))
	    (set! mx (max mx (abs md)))
	    ))))
	(snd-display ";~A ~A ~A" (cadr arg) (caddr arg) mx)))
                         
    (list
     (list 0.0 1    1.0    (vct 0))
     (list 2.0 2    0.881 (vct 0 0))
     (list 4.0 4    0.5184 (vct 1.295 0.248 0.304 2.785))
     (list 6.0 8    0.393  (vct 4.515 1.780 4.259 1.771 1.166 0.254 1.419 2.735))
     (list 8.0 16   0.302  (vct 0.432 2.086 2.763 2.344 2.811 3.409 1.836 6.173 3.770 2.339 6.158 1.530 6.132 3.006 4.967 0.859))
     (list 10.0 32  0.266  (vct 6.208 4.197 3.109 1.718 5.050 1.317 4.334 3.778 4.936 0.069 3.025 2.115 5.060 1.286 3.499 5.191 1.822 5.985 4.384 1.394 3.453 2.579 3.031 3.255 3.834 2.621 1.390 0.717 0.409 3.370 6.042 6.052))
     (list 12.0 64  0.2124 (vct 4.913 5.507 5.262 1.926 4.819 3.794 0.355 1.178 4.959 1.012 3.433 2.855 2.191 4.792 3.740 1.865 5.196 1.078 4.139 5.518 3.053 3.958 3.131 6.260 2.157 4.279 2.352 4.314 1.102 5.967 3.551 2.439 5.456 4.833 5.213 3.523 3.263 2.810 0.433 0.639 2.554 3.469 2.682 4.765 0.125 3.824 1.137 6.166 0.019 2.240 4.406 4.734 5.451 6.230 4.943 4.160 3.577 5.086 2.444 0.900 1.952 2.234 4.794 3.424))
     (list 14.0 128 0.16121 (vct 1.531 4.987 1.847 0.632 6.101 4.309 0.517 1.910 4.921 4.949 6.040 5.611 2.831 5.338 0.891 5.388 0.599 2.677 6.248 5.592 1.977 1.794 3.572 2.638 1.903 3.083 2.412 6.125 3.799 5.619 5.949 1.241 3.044 5.395 5.865 4.846 4.899 2.267 4.537 3.979 1.783 3.826 1.325 5.278 5.799 4.977 2.066 3.029 1.036 4.606 1.691 6.079 4.957 6.138 2.603 1.111 1.335 1.765 5.767 2.730 0.702 1.122 1.628 1.848 0.712 2.338 5.099 6.249 2.009 3.379 1.653 4.831 2.245 1.831 1.113 5.462 5.533 2.944 4.376 4.734 3.285 4.361 1.015 2.100 5.022 3.269 0.796 0.317 5.244 2.613 4.609 3.415 4.454 0.228 2.025 0.216 1.785 3.599 3.207 5.019 3.591 5.138 4.333 3.005 6.208 5.296 0.763 3.741 3.446 3.962 0.204 1.715 4.054 2.402 1.455 1.842 4.637 4.427 0.536 2.700 4.289 3.066 0.574 6.106 1.472 5.793 4.294 2.287))))
-->


<table border=1 hspace=100 vspace=20 cellpadding=6>
<tr><td>
<small>
Compare the sound of the n=64 and n=128 cases using ncos and random phases: they sound very different
despite having the same spectrum.  We confront the burning question: given n equal amplitude
harmonically related sinusoids, what is the minimum peak amplitude?  sqrt(n) is too low.  Here are (some of) the
best minimum peaks I've found:
<pre>
    1 1.0, 2 1.76, 4 2.04, 8 2.79, 16 3.87, 32 5.53, 64 8.02, 128 11.71, 256 19.42, 512 31.39, 1024 49.87, 2048 77.35
</pre>
For the actual phases, see <a href="sndscm.html#peakphasesdoc">peak-phases</a>.scm.
</small>
</td></tr></table>

<p>
If you use ncos (or nsin) as both the carrier and modulator, you get a very similar effect.  As n increases,
the ncos(wc + ncos(wm)) output gradually approaches the unmodulated ncos output &mdash; the crunch happens on each carrier component,
but most strongly on the earlier ones (the "effective index" is less on those components, as mentioned
under <a href="#polywave">polywave</a>).  
And (for some reason this makes me smile), polywave modulated by ncos behaves the same way:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> ()
  (let ((modulator (<em class=red>make-ncos</em> 100 :n 128))
        (carrier (<em class=red>make-polywave</em> 1000 (list 1 .5 3 .25 6 .25))))
    (do ((i 0 (+ 1 i))) 
        ((= i 20000))
      (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* .5 (<em class=red>polywave</em> carrier 
                      (* (<a class=quiet href="#hztoradians">hz-&gt;radians</a> (* 3 100)) 
                         (<em class=red>ncos</em> modulator 0.0))))))))
</pre>
</td></tr></table>

<p>So, a pulse-train modulated by a pulse-train is a pulse-train.
Are there any other cases where gen(wc + gen(wm)) = gen(wc)?  My first thought was rand, but that has a hidden
surprise: the modulation obscures the underlying square-wave!
</p>

<img src="pix/randfm.png" alt="rand(rand) spectrum" hspace=40>

<!-- randfm.png:

(with-sound (:channels 3)
  (let* ((car1 (make-rand 1000))
         (car2 (make-rand 1000))
         (mod1 (make-rand 100))
	 (samps (seconds->samples 1.0))
	 (ampf (make-env '(0 0 1 1 20 1 21 0) :duration 1.0 :scaler .8))
	 (index (hz->radians (* 100 3.0))))
    (do ((i 0 (+ 1 i)))
	((= i samps))
      (let ((amp (env ampf))
	    (fm (* index (rand mod1))))
	(outa i fm)
	(outb i (* amp (rand car2)))
	(outc i (* amp (rand car1 fm)))))))

(set! (selected-graph-color) (make-color 1 1 1))
(set! (selected-data-color) (make-color 0 0 0))
(set! (x-axis-label 0 0 1) "100Hz rand modulating signal spectrum")
(set! (x-axis-label 0 1 1) "1000Hz rand, no modulation")
(set! (x-axis-label 0 2 1) "1000Hz rand, 100Hz modulation (from chan 0), index: 3")
-->

<!--
compare ncos as FM and direct sum of cos:

(with-sound (:channels 2)
  (for-each
    (lambda (arg)
      (let* ((beg (car arg))
	     (n (cadr arg))
	     (car1 (make-oscil 1000))
	     (mod1 (make-sum-of-cosines n 100 (random pi)))
	     (start (seconds->samples beg))
	     (dur 1.0)
	     (samps (seconds->samples dur))
	     (stop (+ start samps))
	     (ampf (make-env '(0 0 1 1 20 1 21 0) :duration dur :scaler .8))
	     (index (hz->radians (* 100 3.0)))
	     (car2 (make-oscil 1000))
	     (mods (make-vector n)))
	(do ((i 0 (+ 1 i)))
	    ((= i n))
	  (set! (mods i) (make-oscil (* (+ 1 i) 100) (* 0.5 pi))))
	(do ((i start (+ 1 i)))
	    ((= i stop))
	  (let ((amp (env ampf)))
	    (outa i (* amp (oscil car1 (* index (sum-of-cosines mod1)))))
	    (let ((sum 0.0))
	      (do ((k 0 (+ 1 k)))
		  ((= k n))
		(set! sum (+ sum (oscil (mods k)))))
	      (outb i (* amp (oscil car2 (* (/ index n) sum)))))))))
    (list
     (list 0.0 1)
     (list 2.0 2)
     (list 4.0 4)
     (list 6.0 8)
     (list 8.0 16)
     (list 10.0 32)
     (list 12.0 64)
     (list 14.0 128))))
-->

<br>
<p>What FM input (to oscil, for a given index) would give the most dispersed output?  My first guess was square-wave, but looking at graphs,
I'd say rand gives it a good contest.
If you sweep ncos upwards in frequency, you'll eventually
get foldover; the generator produces its preset number of cosines no
matter what.  It is possible to vary the spectrum smoothly:
</p>

<table border=0 hspace=40><tr><td><pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> ()
  (let ((os (<em class=red>make-ncos</em> 100.0 4))
        (pow (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 1.0 1 30.0) :length 10000))) ; our "index" envelope in FM jargon
    (do ((i 0 (+ 1 i)))
	((= i 10000))
      (let ((val (<em class=red>ncos</em> os)))
	(<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* (signum val) ; signum is in dsp.scm
		   (expt (abs val) (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> pow))))))))
</pre></td></tr></table>

<p>This is not a very polite sound.  The same trick works on all the <a href="#ncos2">pulse-train</a> functions in generators.scm (or an oscil for that matter!), 
but perhaps a filter is a simpler approach.  There are a lot more of these "kernels" in <a href="#othergenerators">generators.scm</a>.
</p>

<table border=1 hspace=20 cellspacing=4>
<tr>
<td bgcolor="#f2f4ff"><center>ncos2 (Fejer, n=10)</center></td>
<td bgcolor="#f2f4ff"><center>npcos (Poussin, n=5)</center></td>
<td bgcolor="#f2f4ff"><center>ncos4 (Jackson, n=10)</center></td>
</tr><tr>
<td><img src="pix/fejer.png" alt="fejer sum"></td>
<td><img src="pix/poussin.png" alt="poussin sum"></td>
<td><img src="pix/jackson.png" alt="jackson sum"></td>
</tr></table>

<br><br>


<p>nsin produces a sum of equal amplitude sines.  It is very similar (good and bad) to <a href="#ncos">ncos</a>.
For n greater than 10 or so, its peak amplitude occurs at approximately 3pi/4n, and is about .7245*n (that is, 8n*(sin^2(3pi/8))/3pi).
The nsin generator scales its output to be between -1 and 1 for any n.  We can use nxysin to try any initial-phase in a
sum of equal sinusoids.  The peak amp in this case varys sinusoidally from a sum of sines n * 0.7245 to a sum of cosines n * 1.0;
the peak amp is nsin-max(n) + abs(sin(initial-phase))*(1 - nsin-max(n)).
</p>

<table border=1 align=left hspace=40 vspace=10 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>nsin methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>frequency in Hz</td></tr>
<tr><td><em class=gen>mus-phase</em></td><td>phase in radians</td></tr>
<tr><td><em class=gen>mus-scaler</em></td><td>dependent on number of sines</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>n or sines arg used in make-&lt;gen&gt;</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>frequency in radians per sample</td></tr>
</table>

<!-- LATEX: \sum_{k=1}^{n}\sin kx = \frac{\sin\frac{n+1}{2}x \: \sin\frac{nx}{2}}{\sin\frac{x}{2}} -->

<table border=0 cellspacing=20>
<tr><td>
<img src="pix/sceq1.png" alt="sum of sines" hspace=40>
<pre>
the conjugate Dirichlet kernel
</pre>
</td></tr>
<tr><td>
<img src="pix/sos.png" alt="sum of sines graphs">
</td></tr></table>

<p>
As with all the paired cos/sin generators (waveshaping, generators.scm, etc), we can vary
the initial phase by taking advantage of the trig identity:
</p>
<img src="pix/fmeq18.png" alt="sin split" hspace=20><br>

<p>that is,
</p>

<pre>
     (+ (* (ncos nc) (sin initial-phase))
        (* (nsin ns) (cos initial-phase)))
</pre>

<p>Or vary it via an envelope at run-time:
</p>

<table border=0 hspace=40>
<tr><td>
<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> ()
  (let* ((nc (<em class=red>make-ncos</em> 500.0 6))
	 (ns (<em class=red>make-nsin</em> 500.0 6))
	 (phase (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1) 
                   :length 1000 :scaler (/ pi 2))))
    (do ((i 0 (+ 1 i)))
	((= i 1000)) 
      (let ((angle (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> phase)))
	(<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (+ (* (<em class=red>ncos</em> nc) (sin angle))
		   (* (<em class=red>nsin</em> ns) (cos angle))))))))
</pre>
</td><td>
<img src="pix/varyphase.png" alt="ncos+nsin example" hspace=20>
</td></tr></table>

<p>Compared to ncos or nsin, polywave is probably always faster and more accurate, but less convenient to set up.
Both ncos and nsin could be implemented as polynomials in cos x, just as in polyshape; in fact, ncos is
almost the same as the Chebyshev polynomial of the 4th kind. 
See also the <a href="#nrxydoc">nrxycos</a> generator, 
and <a href="#othergenerators">generators.scm</a>.
</p>


<!-- LATEX:
sceq14:
\small
\begin{align*}
&\sum_{k=0}^{n}\sin(x+ky)=\frac{\sin\Big(x+\frac{n-1}{2}y\Big)\sin\frac{ny}{2}}{\sin\frac{y}{2}} \\
&\sum_{k=0}^{n}\cos(x+ky)=\frac{\cos\Big(x+\frac{n-1}{2}y\Big)\sin\frac{ny}{2}}{\sin\frac{y}{2}} \\
&\sum_{k=0}^{2n-1}(-1)^{k}\cos(x+ky)=\frac{\sin\Big(x+\frac{2n-1}{2}y\Big)\sin ny}{\cos\frac{y}{2}} \\
&\sum_{k=0}^{n-1}(-1)^{k}\sin(x+ky)=\frac{\sin\Big(x+\frac{n-1}{2}(y+\pi)\Big)\sin\frac{n(y+\pi)}{2}}{\cos\frac{y}{2}} \\
&\sum_{k=1}^{n}\sin(2k-1)x=\frac{\sin^{2}nx}{\sin x} \\
&\sum_{k=1}^{n}\cos(2k-1)x=\frac{1}{2}\frac{\sin 2nx}{\sin x} \\
&\sum_{k=1}^{n}(-1)^{k}\cos kx=-\frac{1}{2}+\frac{(-1)^{n}\cos(\frac{2n+1}{2}x)}{2\cos\frac{x}{2}} \\
&\sum_{k=1}^{n}(-1)^{k+1}\sin(2k-1)x = (-1)^{n+1}\frac{\sin 2nx}{2\cos x} \\
&\sum_{k=1}^{n-1}k\sin kx=\frac{\sin nx}{4 \sin^{2}\frac{x}{2}} - \frac{n \cos \frac{2n-1}{2}x}{2\sin\frac{x}{2}} \\
&\sum_{k=1}^{n-1}k\cos kx=\frac{n\sin\frac{2n-1}{2}x}{2\sin\frac{x}{2}} - \frac{1-\cos nx}{4\sin^{2}\frac{x}{2}} \\
&2^{1-n} \sum_{0}^{\lfloor n/2 \rfloor} \binom{n}{k} \cos (n-2k)\theta = \cos^{n}\theta \\

sceq15:
&\sum_{k=1}^{n-1}p^{k}\sin kx=\frac{p\sin x - p^{n}\sin nx + p^{n+1}\sin(n-1)x}{1-2p\cos x+p^{2}} \\
&\sum_{k=0}^{n-1}p^{k}\cos kx=\frac{1-p\cos x - p^{n}\cos nx + p^{n+1}\cos(n-1)x}{1-2p\cos x + p^{2}} \\
&\sum_{k=1}^{\infty}p^{k}\sin kx=\frac{p\sin x}{1-2p\cos x + p^{2}} \\
&\sum_{k=0}^{\infty}p^{k}\cos kx=\frac{1-p\cos x}{1-2p\cos x + p^{2}} \\
&\sum_{k=1}^{\infty}\frac{p^{k}\sin kx}{k} = \arctan \frac{p\sin x}{1-p\cos x} \\
&\sum_{k=1}^{\infty}\frac{p^{k}\cos kx}{k} = \ln \frac{1}{\sqrt{1-2p\cos x + p^{2}}} \\
&\sum_{k=1}^{\infty}\frac{p^{2k-1}\sin(2k-1)x}{2k-1} = \frac{1}{2}\arctan \frac{2p\sin x}{1-p^{2}} \\
&\sum_{k=1}^{\infty}\frac{p^{2k-1}\cos(2k-1)x}{2k-1} = \frac{1}{4}\ln \frac{1+2p\cos x + p^{2}}{1-2p\cos x + p^{2}} \\
&\sum_{k=1}^{\infty}e^{-kt}\sin kx = \frac{1}{2}\frac{\sin x}{\cosh t - \cos x} \\
&1 + 2\sum_{k=1}^{\infty}e^{-kt}\cos kx = \frac{\sinh t}{\cosh t - \cos x} \\
&\sum_{k=0}^{\infty} \frac{(2n+2k)(2n+k-1)!}{k!}J_{2n+2k}(2z \sin \theta) = (z \sin \theta)^{2n} \\
&J_{0}^{2}\Big(\frac{z}{2}\Big)+2\sum_{k=1}^{\infty} J_{k}^{2}\Big(\frac{z}{2}\Big)\cos2k\theta = J_{0}(z \sin \theta) \\
\end{align*}



old in 2nd col (replaced by JO cases):
&\sum_{k=1}^{\infty}\frac{p^{k}\sin kx}{k!} = e^{p\cos x}\sin(p\sin x) \\
&\sum_{k=0}^{\infty}\frac{p^{k}\cos kx}{k!} = e^{p\cos x}\cos(p\sin x) \\
rk!sin and cos

original last of 1st col:
&\sum_{k=1}^{\infty} \frac{\sin^{2k} x}{k} = -2 \ln \cos x & (x^{2} < \frac{pi^{2}}{4}) \\


sceq20:
\begin{align*}
&\sum_{k=0}^{\infty} p^{k} \cos(x + ky) = \frac{\cos x - p \cos(x - y)}{1 - 2p\cos y + p^{2}} \\
&\sum_{k=0}^{\infty} p^{k} \sin(x + ky) = \frac{\sin x - p \sin(x - y)}{1 - 2p\cos y + p^{2}} \\
&\sum_{k=1}^{\infty} \frac{\sin kx}{2^{k-1}} = \frac{4\sin x}{5 - 4\cos x} \\
&\sum_{k=1}^{\infty} \frac{(-1)^{k} e^{(2k-1)a} \cos(2k-1)x}{2k-1} = \frac{1}{2}\arctan \bigg(\frac{\cos x}{\sinh a}\bigg) \\
&\sum_{k=1}^{\infty} \frac{\sin nx}{n(n^{2}-4)} = -\frac{\pi}{8}\sin^{2}x \\
\end{align*}


sceq21:
\begin{align*}
&\sum_{k=0}^{\infty} \frac{a^{k}}{k!} \cos(x + ky) = e^{a \cos y} \cos (x + a \sin y) \\
&\sum_{k=0}^{\infty} \frac{a^{k}}{k!} \sin(x + ky) = e^{a \cos y} \sin (x + a \sin y) \\
&\sum_{k=0}^{\infty} \frac{a^{2k}\cos 2kx}{(2k)!} = \cosh(a \cos x) \cos (a \sin x) & (a^{2}<1) \\
&\sum_{k=1}^{\infty} \frac{a^{2k}\sin 2kx}{(2k)!} = \sinh(a \cos x) \sin (a \sin x) & (a^{2}<1) \\
&\frac{1}{a} + 2a \sum_{k=1}^{\infty} \frac{\cos kx}{a^{2}+k^{2}} = \pi \frac{\cosh a(\pi-x)}{\sinh a\pi} & (0 \leq x \leq 2\pi)\\
\end{align*}

sceq23 (old):
& \ln (1 - 2xt + t^{2})^{-1} = 2 \sum_{n=1}^{\infty} \frac{t^{n}}{n} T_{n}(x) \\
& (1 - 2xt + t^{2})^{-1} = \frac{1}{\sqrt{1 - x^{2}}} \sum_{n=0}^{\infty} t^{n} U_{n+1}(x) \\
& e^{z cos x}J_{\nu-\frac{1}{2}}(z \sin x) = \frac{\Gamma(\nu)}{\Gamma(\frac{1}{2})}(2 \sin x)^{\nu-\frac{1}{2}} \sum_{k=0}^{\infty}\frac{z^{\nu+k-\frac{1}{2}}}{\Gamma(2\nu + k)} \mathrm{C}^{\nu}_{k}(\cos x)

sceq25 old:
\sum_{n=0}^{\infty} r^{n} \sum_{k=0}^{\infty} \sin (k+1/2)\theta = \frac{(1+r)\sin(\theta / 2)}{(1-r)(1-2r\cos\theta + r^{2})}

sceq26 old:
\sum_{n=0}^{\infty} r^{n} \sum_{k=0}^{\infty} (n+1-k)\sin (k+1)\theta = \frac{\sin\theta}{(1-r)^{2}(1-2r\cos\theta + r^{2})}

sceq7: (p73)
&\sum_{k=1}^{\infty} \frac{\cos kx}{k} = -\ln \big(2 \sin \frac{x}{2}\big)  & (0\leq x \leq \pi) \\

sceq27: (p183)
1 + 2 &\sum_{n=1}^{\infty} \frac{(-a + \sqrt{a^{2} - b^{2}})^{n} \cos nx}{b^{n}} = \frac{\sqrt{a^{2} - b^{2}}}{a + b \cos x} & (b < a, a \neq 0) \\

sceq25:
&\sum_{k=1}^{\infty} k r^{k} \sin kx = \frac{r(1-r^{2})\sin x}{(1 - 2r\cos x + r^{2})^{2}}
Z 352

sceq26:
original: & \frac{8}{\pi} \sum_{k=1}^{\infty} \frac{\sin^{2}kx}{4k^{2}-1} = |\sin x|
& \frac{8}{\pi} \sum_{k=1}^{\infty} \frac{\sin^{2}kx}{4k^{2}-1} = | \sin x \, | = \frac{2}{\pi} - \frac{8}{\pi} \sum_{k=1}^{\infty} \frac{\cos 2kx}{4k^{2} - 1}

sceq31:
J_{0}(ka)J_{0}(kr) + 2 \sum_{m=1}^{\infty} J_{m}(kr)J_{m}(ka) \cos m\theta = J_{0}\Big(k \sqrt{r^{2}+a^{2}-2ar\cos \theta}\Big)

sceq32 old form (redundant):
1 + 2 \sum_{n=1}^{\infty} J_{n}(nz)\cos n(x-z\sin x) = \frac{1}{1-z\cos x}
sceq32 new form:
&2^{n} \Gamma(n) \sum_{m=0}^{\infty} (n+m)\frac{J_{n+m}(r)}{r^{n}} \frac{J_{n+m}(a)}{a^{n}} C_{m}^{n}(\cos \theta) = \frac{J_{n}\big(\sqrt{r^{2}+a^{2}-2ar\cos \theta}\big)}{\big(\sqrt{r^{2}+a^{2}-2ar\cos \theta}\big)^{n}} \\

sceq33:
\sum_{m=0}^{\infty}(m+\frac{1}{2})\frac{J_{m+\frac{1}{2}}(ka)}{\sqrt{a}} \frac{J_{m+\frac{1}{2}}(kr)}{\sqrt{r}} P_{m}(\cos \theta) = \frac{\sin\Big(k \sqrt{r^{2}+a^{2}-2ar\cos \theta}\Big)}{\pi \sqrt{r^{2}+a^{2}-2ar\cos \theta}}

Pn(cos x) is p776 A&S (P=Jacobi)

sceq34:
old form: \sum_{m=0}^{\infty} (n+m)\Big(\frac{J_{n+m}(z)}{z^{n}}\Big)^{2} C_{m}^{n}(\cos \theta) = \frac{J_{n}(2z \sin \frac{\theta}{2})}{2^{n}\Gamma(n)(2z\sin \frac{\theta}{2})}
\sum_{m=0}^{\infty} (n+m)\Big(\frac{J_{n+m}(z)}{z^{n}}\Big)^{2} \sum_{k=0}^{m} \frac{(n)_{k}(n)_{m-k}}{k!(m-k)!} \cos(m-2k)\theta = \frac{J_{n}(2z \sin \frac{\theta}{2})}{2^{n}\Gamma(n)(2z\sin \frac{\theta}{2})}


from Gray and Mathews, "A Treatise on Bessel Functions and Their Applications to Physics" p 28, 29, 92, 240
sceq36:
& J_{0}^{2}\Big(\frac{z}{2}\Big)+2\sum_{k=1}^{\infty} (-1)^{k} J_{k}^{2}\Big(\frac{z}{2}\Big)\cos2kx = J_{0}(z \cos x) \\
& 2\sum_{k=0}^{\infty} (-1)^{k} J_{k}\Big(\frac{z}{2}\Big)J_{k+1}\Big(\frac{z}{2}\Big)\cos (2k+1)x = J_{1}(z \cos x) \\

sceq37:
& Y_{0}(b)J_{0}(c) + 2 \sum_{m=1}^{\infty} Y_{m}(b)J_{m}(c) \cos m\theta = Y_{0}\Big(\sqrt{b^{2}+c^{2}-2bc\cos \theta}\Big) & (b > c)\\
& \sum_{n=0}^{\infty} \frac{r^{n}}{n!}P_{n}(\cos \theta) = e^{r \cos \theta}J_{0}(r \sin \theta) \\

from Abramowitz and Stegun, "Handbook of Mathematical Functions"
9.6.34 (p376)  (9.1.42 is the FM formula)
sceq39:
I_{0}(z) + 2 \sum_{k=1}^{\infty} I_{k}(z) \cos k\theta = e^{z \cos \theta}

sceq40: 27.8.6 (p1005)
&\sum_{n=1}^{\infty} \frac{\sin n\theta}{n^{3}} = \frac{\pi^{2}\theta}{6} - \frac{\pi \theta^{2}}{4} + \frac{\theta^{3}}{12} & (0 \leq \theta \leq 2\pi)


from Askey "Ramanujan and Hypergeometric Series" in Berndt and Rankin "Ramanujan: Essays and Surveys" p283 (the formula was found by Gauss):
   this is r2k!cos in generators.scm [sceq30.png]
&(1 - 2r \cos \theta + r^{2})^{-k} = \frac{{}_{2}F_{1}(k, k; 1; r^{2})}{2} + \sum_{n=1}^{\infty} \frac{(k)_{n}}{n!} r^{n} {}_{2}F_{1}(k, k+n; n+1; r^{2}) \cos n\theta


Montgomery and Vorhauer:
&\sum_{n=1}^{\infty} \frac{\sin \frac{k \pi}{n+1}}{\sin \frac{\pi}{n+1}} \cos k\theta = \frac{(\cos \frac{1}{2}(n+1)\theta)^{2}}{\cos \theta - \cos \frac{\pi}{n+1}}


;;; Bessel funcs as confluent hypergeometric series
&J_{n}(x) = \frac{(\frac{x}{2})^{n}}{\Gamma(n+1)} e^{-ix} \Phi(n+\frac{1}{2}, 2n+1; 2ix) \\
&I_{n}(x) = \frac{(\frac{x}{2})^{n}}{\Gamma(n+1)} e^{-x} \Phi(n+\frac{1}{2}, 2n+1; 2x) \\

from Klapper, Selected Papers on Frequency Modulation, p 156
&\sum_{n=-\infty}^{\infty} (-1)^{n} J_{2n}(x) J_{2n}(y(\omega + B \cos z)) = J_{0}( \sqrt{x^{2} + y^{2} (\omega + B\cos z)^{2}})

another kernel set: binomial coeffs G&R 1.320 etc -- not different enough
-->


<table border=1 hspace=20 vspace=10><tr><td>
<table border=0 hspace=40 vspace=10>
<tr><td colspan=3 bgcolor="#f2f4ff"><center><h4>various sums</h4></center></td></tr>


<tr>
<td>
<img src="pix/sceq14.png" alt="many sums" usemap="#GR1" border=0>
<map name="GR1">
  <area shape=rect coords="0,0,300,60" href="#nxysin" alt="nxysin">
  <area shape=rect coords="0,61,300,100" href="#nxycos" alt="nxycos">
  <area shape=rect coords="0,101,300,150" href="#nxy1cos" alt="nxy1cos">
  <area shape=rect coords="0,151,300,200" href="#nxy1sin" alt="nxy1sin">
  <area shape=rect coords="0,201,300,240" href="#noddsin" alt="noddsin">
  <area shape=rect coords="0,241,300,280" href="#noddcos" alt="noddcos">
  <area shape=rect coords="0,281,300,320">
  <area shape=rect coords="0,321,300,360">
  <area shape=rect coords="0,361,300,410" href="#nkssb" alt="nkssb">
  <area shape=rect coords="0,411,300,450" href="#nkssb" alt="nkssb">
  <area shape=rect coords="0,450,300,485" href="#nchoosekcos" alt="nchoosekcos">
</map>
</td>
<td width=40></td>
<td>
<img src="pix/sceq15.png" alt="many more sums" usemap="#GR2" border=0>
<map name="GR2">
  <area shape=rect coords="0,0,300,40" href="#nrsin" alt="nrsin">
  <area shape=rect coords="0,41,300,90" href="#nrcos" alt="nrcos">
  <area shape=rect coords="0,91,300,140" href="#rssb" alt="rssb">
  <area shape=rect coords="0,141,300,180" href="#rcos" alt="rcos">
  <area shape=rect coords="0,181,300,220" href="#rksin" alt="rksin">
  <area shape=rect coords="0,221,300,250" href="#rkcos" alt="rkcos">
  <area shape=rect coords="0,251,300,300" href="#rkoddssb" alt="rkoddssb">
  <area shape=rect coords="0,301,300,340" href="#rkoddssb" alt="rkoddssb">
  <area shape=rect coords="0,341,300,380" href="#erssb" alt="erssb">
  <area shape=rect coords="0,381,300,420" href="#ercos" alt="ercos">
  <area shape=rect coords="0,465,300,490" href="#j0evencos" alt="j0evencos">
</map>
</td>
</tr>

<!--  <area shape=rect coords="0,421,300,500" href="#sin2n" alt="sin2n"> -->


<tr><td colspan=3 bgcolor="#eefdee"><center>Gradshteyn and Ryzhik, "Table of Integrals, Series, and Products", 1.341.., 1.352.., 1.447.., 1.461, 1.518, 8.516, 8.531</center></td></tr>
<tr><td colspan=3 height=25></td></tr>


<tr><td><img src="pix/sceq20.png" alt="more sums" usemap="#J1" border=0>
<map name="J1">
    <area shape=rect coords="0,0,300,30" href="#rxycos" alt="rxycos">
    <area shape=rect coords="0,31,300,60" href="#rxysin" alt="rxysin">
    <area shape=rect coords="0,61,300,100" href="#k2sin" alt="k2sin">
    <area shape=rect coords="0,101,300,140" href="#eoddcos" alt="eoddcos">
    <area shape=rect coords="0,141,300,180" href="#k32sin" alt="k32sin">
</map>
</td><td></td>
<td><img src="pix/sceq21.png" alt="more sums" usemap="#J2" border=0>
<map name="J2">
    <area shape=rect coords="0,0,300,30" href="#rxyk!cos" alt="rxyk!cos">
    <area shape=rect coords="0,31,300,60" href="#rxyk!cos" alt="rxyk!sin">
    <area shape=rect coords="0,61,300,100" alt="r2cos">
    <area shape=rect coords="0,101,300,140" alt="r2sin">
    <area shape=rect coords="0,141,300,180">
</map>
</td></tr>
<tr><td colspan=3 bgcolor="#eefdee"><center>Jolley, "Summation of Series", 521 587 623 635 638 685 686 691 692 728</center></td></tr>
<tr><td colspan=3 height=25></td></tr>


<tr><td><a class=invisible href="#izcos"><img src="pix/sceq39.png" alt="I(k) sum"></a></td><td></td>
<td><a class=invisible href="#k3sin"><img src="pix/sceq40.png" alt="n3 case"></a></td></tr>
<tr><td colspan=3 bgcolor="#eefdee"><center>Abramowitz and Stegun, "Handbook of Mathematical Functions", 9.6.34, 27.8.6</center></td></tr>
<tr><td colspan=3 height=25></td></tr>


<tr><td><a class=invisible href="#krksin"><img src="pix/sceq25.png" alt="more sums"></a></td><td></td>
<td><a class=invisible href="#abssin"><img src="pix/sceq26.png" alt="more sums"></a></td></tr>
<tr><td colspan=3 bgcolor="#eefdee"><center>Zygmund, "Trigonometric Series" p34, 352</center></td></tr>
<tr><td colspan=3 height=25></td></tr>


<tr><td><img src="pix/sceq7.png" alt="more sums"></td><td></td>
<td><a class=invisible href="#abcos"><img src="pix/sceq27.png" alt="more sums"></a></td></tr>
<tr><td colspan=3 bgcolor="#eefdee"><center>Sansone, "Orthogonal Functions"</center></td></tr>
<tr><td colspan=3 height=25></td></tr>


<tr><td><img src="pix/sceq36.png" alt="more sums" usemap="#GM1" border=0>
<map name="GM1">
    <area shape=rect coords="0,0,300,50" href="#j0j1cos" alt="j0j1cos">
    <area shape=rect coords="0,51,300,80" href="#j0j1cos" alt="j0j1cos">
</map>
</td><td></td>
<td><img src="pix/sceq37.png" alt="more sums" usemap="#GM2" border=0>
<map name="GM2">
    <area shape=rect coords="0,0,300,50" href="#jycos" alt="jycos">
    <area shape=rect coords="0,51,300,100" alt="jjesin">
</map>
</td></tr>
<tr><td colspan=3 bgcolor="#eefdee"><center>Gray and Mathews, "A Treatise on Bessel Functions and Their Applications to Physics" p 28, 29, 92, 240</center></td></tr>
<tr><td colspan=3 height=25></td></tr>


<tr>
<td><a class=invisible href="#jncos"><img src="pix/sceq32.png" alt="more sums"></a></td><td></td>
<td><a class=invisible href="#jjcos"><img src="pix/sceq31.png" alt="more sums"></a></td>
</tr><tr>
<td><a class=invisible href="#j2cos"><img src="pix/sceq34.png" alt="more sums"></a></td><td></td>
<td><a class=invisible href="#jpcos"><img src="pix/sceq33.png" alt="more sums"></a></td>
</tr><tr>
<td colspan=3 bgcolor="#eefdee"><center>Watson, "A Treatise on the Theory of Bessel Functions": 4.82, 11.41, 17.31</center></td></tr>
<tr><td colspan=3 height=25></td></tr>


<tr><td colspan><a class=invisible href="#r2k!cos"><img src="pix/sceq30.png" alt="kosines" onmouseout="UnTip()" onmouseover="Tip('<img src=\'pix/r2kfactcos.png\' width=\'400\' height=\'177\'>')"></a></td>
<td></td>
<td>
<a class=invisible href="#n1cos"><img src="pix/sceq45.png" alt="linear cosines"></a>
</td>
</tr>
 
<tr><td bgcolor="#eefdee"><center>Askey, "Ramanujan and Hypergeometric Series"</center></td>
<td bgcolor="#eefdee"></td>
<td bgcolor="#eefdee"><center>Ramanujan, "On certain Arithmetical Functions"</center></td>
</tr>

</table>

</td></tr></table>

<!-- LATEX
sceq38:
\sum_{k=-\infty}^{\infty} J_{k}(m\rho) Z_{\nu+k}(mr) e^{ik\phi} = e^{i \nu \psi}Z_{\nu}(mR)
-->

<!-- LATEX
sceq45.png
& 2n-1 + 4\sum_{k=1}^{n-1} (n-k)\cos k\theta + \cos n\theta = \cot^{2}\frac{\theta}{2}\  (1 - \cos n\theta) \\
-->

<p>
There are many formulas that produce exponentially decaying or bell-curve shaped spectra;
I think these all sound about the same, so I have included only a representative sample of them.
A couple of the formulas are special cases of the "Bessel function summation theorem", G&amp;R 8.530:
<img src="pix/sceq38.png" alt="summation formula" align=absmiddle>,
where Z stands for any of the various Bessel functions (J, Y, etc),
and R stands for the Poisson-like business (or is it Legendre?) in the square root.
Don't shy away from the sums to infinity just because you've heard shouting about "band-limited waveforms" &mdash; FM is an infinite sum:
</p>


<!-- LATEX:
\small
\begin{align*}
& \cos(B \sin x) = J_{0}(B) + 2 \sum_{k=1}^{\infty} J_{2k}(B) \cos 2kx \\
& \cos(B \cos x) = J_{0}(B) + 2 \sum_{k=1}^{\infty} (-1)^{k} J_{2k}(B) \cos 2kx \\
& \sin(B \sin x) = 2 \sum_{k=0}^{\infty} J_{2k+1}(B) \sin (2k+1)x \\
& \sin(B \cos x) = 2 \sum_{k=0}^{\infty} (-1)^{k} J_{2k+1}(B) \cos (2k+1)x \\
\end{align*}
-->



<table border=1 hspace=40 vspace=20><tr><td>
<table border=0 hspace=20>
<tr><td>
<img src="pix/fmeq49.png" alt="cos cos cases">
</td><td width=20></td>
<td>
<img src="pix/fmeq50.png" alt="cos cos cases">
</td>
</tr>
<tr><td></td><td></td><td></td></tr>
<tr><td colspan=3><center>
<small>(Is cos(sin(x)) is always greater than sin(cos(x))?)</small>
</center>
</td>
</tr></table>
</td></tr></table>

<p>
Most of the formulas are implemented as generators in <a href="#othergenerators">generators.scm</a>,
along with the single side-band cases, where possible.
As J. A. Moorer and Marc Le Brun pointed out
long ago, there are many more such formulas "buried in reference works".  Well, they've
done nobody any good being buried for a generation, so I say: dig them up!  If
you know of any curious formula, anything that might trigger an interesting train of
reflection, please send it to me, and I'll add it to this collection. 
</p>

<br><br>


<A NAME="nrxydoc"></A>
<!-- ---------------------------------------- NRXYSIN and NRXYCOS ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>nrxysin and nrxycos</h3></center></td></tr></table>

<br>
<pre>
  <a class=def name="make-nrxysin">make-nrxysin</a> 
      (frequency *clm-default-frequency*) 
      (ratio 1.0)               ; ratio between frequency and the spacing between successive sidebands
      (n 1)                     ; number of sidebands
      (r .5)                    ; amplitude ratio between successive sidebands (-1.0 &lt; r &lt; 1.0)
  <a class=def name="nrxysin">nrxysin</a> s (fm 0.0)
  <a class=def name="nrxysin?">nrxysin?</a> s

  <a class=def name="make-nrxycos">make-nrxycos</a> (frequency *clm-default-frequency*) (ratio 1.0) (n 1) (r .5)
  <a class=def name="nrxycos">nrxycos</a> s (fm 0.0)
  <a class=def name="nrxycos?">nrxycos?</a> s
</pre>
<br>

<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t)
  (let ((gen (make-nrxycos 440.0 :n 10)))
    (do ((i 0 (+ 1 i)))
        ((= i 44100))
      (outa i (* 0.5 (nrxycos gen))))))
</pre>
</td>

<td width=4></td>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true) do
  gen = make_nrxycos(440.0, 1.0, 10, 0.5);
  44100.times do |i| 
    outa(i, 0.5 * nrxycos(gen), $output) 
    end
  end.output
</pre>
</td>

<td width=4></td>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  440.0 :n 10 make-nrxycos { gen }
  44100 0 ?do
    i  gen 0 nrxycos  f2/ *output* outa drop
  loop
; :play #t with-sound drop
</pre>
</td>
</tr>
</table>


<table border=0 hspace=20>

<tr><td>
<table align=left border=1 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>nrxysin methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>frequency in Hz</td></tr>
<tr><td><em class=gen>mus-phase</em></td><td>phase in radians</td></tr>
<tr><td><em class=gen>mus-scaler</em></td><td>"r" parameter; sideband scaler</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>"n" parameter</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>frequency in radians per sample</td></tr>
<tr><td><em class=gen>mus-offset</em></td><td>"ratio" parameter</td></tr>
</table>

</td>
<td>

<table border=0 cellspacing=20>
<tr><td>
<!-- sinesummation.png:
(with-sound (:clipped #f)
  (let ((gen (make-sine-summation 400.0 0.0 5 0.5)))
    (run 
       (do ((i 0 (+ 1 i)))
	   ((= i 30000))
	 (outa i (sine-summation gen 0.0))))))
-->

<!-- Jolley 475 is different [it runs 0 .. n-1 in our terminology, whereas Moorer's runs 0 .. n] -->

<!-- LATEX:
& \sum_{k=0}^{n} r^{k}\sin(x+ky) = \frac{\sin(x) - r\sin(x-y) - r^{n+1}\Big(\sin(x+(n+1)y) - r\sin(x+ny)\Big)}{1+r^{2}-2r\cos(y)} \\
& \sum_{k=0}^{n} r^{k}\cos(x+ky) = \frac{\cos(x) - r\cos(x-y) - r^{n+1}\Big(\cos(x+(n+1)y) - r\cos(x+ny)\Big)}{1+r^{2}-2r\cos(y)} \\
-->

<img src="pix/sceq8.png" alt="nxry formulas">
</td></tr>
<tr><td>

<table border=1 hspace=40><tr><td>
<img src="pix/sinesummation.png" alt="nxry formula">
</td></tr>
<tr><td bgcolor="#f2f4ff"><center>nrxysin, n=5, r=0.5</center></td></tr>
</table></td></tr>
</table>

</td></tr></table>

<p>These three generators 
produce a kind of additive synthesis.
"n" is the number of sidebands (0 gives a sine wave), "r" is the amplitude
ratio between successive sidebands (don't set it to 1.0), and "ratio" is the ratio between the
carrier frequency and the spacing between successive sidebands.
A "ratio" of 2 gives odd-numbered harmonics for a (vaguely) clarinet-like sound.
A negative ratio puts the side-bands below the carrier.
A negative r is the same as shifting the initial phase by pi (instead of lining up
for the spike at multiples of 2*pi, the (-1)^n causes them to line up at (2k-1)*pi,
but the waveform is the same otherwise).
The basic idea is very similar to that used in the
<a href="#ncos">ncos</a> generator, but you have control of the
fall-off of the spectrum and the spacing of the partials.
</p>

<p>The peak amplitude of nrxysin is hard to predict.
I think nrxysin is close to the -1.0..1.0 ideal, and won't go over 1.0.
<a href="#nrxycos">nrxycos</a> is normalized correctly.
</p>

<p>
Besides the usual FM input, you can also vary the "r" parameter (via mus-scaler) to get changing spectra.  In the
next example, we add a glissando envelope, and use the same envelope to vary "r" so that as the frequency
goes up, "r" goes down (to avoid foldover, or whatever).
</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (ss beg dur freq amp (n 1) (r .5) (ratio 1.0) (frqf #f))
  (let* ((st (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> beg))
         (nd (+ st (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur)))
         (sgen (<em class=red>make-nrxysin</em> freq ratio n r))
         (frq-env (if frqf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> frqf :scaler (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> freq) :duration dur) #f))
         (spectr-env (if frqf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> frqf :duration dur) #f))
         (amp-env (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1 2 1 3 0) :scaler amp :duration dur)))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
     (do ((i st (+ 1 i))) 
         ((= i nd))
       (if spectr-env
           (set! (<em class=red>mus-scaler</em> sgen) (* r (exp (- (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> spectr-env))))))
       (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> amp-env)
                  (<em class=red>nrxysin</em> sgen (if frq-env (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> frq-env) 0.0))))))))

(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () (ss 0 1 400.0 1.0 5 0.5 1.0 '(0 0 1 2)))
</pre>
</td></tr></table>

<p>"r" can also be used in the same way as an FM index, but with much simpler spectral evolution (x^n, x between -1.0 and 1.0, rather than Jn(x)).
In the graph, r is 0 at the midpoint, r goes from -1.0 to 1.0 along the horizontal axis &mdash; I forgot to label the axes.
</p>

<table border=0 hspace=30 cellpadding=10>
<tr><td>
<img src="pix/nrxy-r.png" alt="nrxycos changing r">
</td><td>
<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> ()
  (let ((gen1 (<em class=red>make-nrxycos</em> 400 1 15 0.95))
        (indr (<a class=quiet href="#make-env" onmouseout="UnTip()" omnouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 -1 1 1) 
                :length 80000 :scaler 0.9999)))
    (do ((i 0 (+ 1 i)))
        ((= i 80000))
      (set! (<em class=red>mus-scaler</em> gen1) (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> indr)) ; this sets r
      (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* .5 (<em class=red>nrxycos</em> gen1 0.0))))))
</pre>
</td></tr></table>


<!-- MLB's index idea is not so great:
(with-sound (:clipped #f :statistics #t)
  (let* ((dur 2.0)
         (ampf (make-env '(0 1 10 1 11 0) :duration dur :scaler .5))
	 (indf (make-env '(0 0 1 .999) :duration dur))
	 (samps (seconds->samples dur))
	 (N 60))

    (do ((i 0 (+ 1 i))
	 (th 0.0 (+ th (hz->radians 1000.0))))
	((= i samps))
  
      (let* ((a .999)
	     (index (env indf))
	     (a2 (+ 1.0 (* a a)))
	     (an (expt a (+ N 1)))
	     (b 1/10)
	     (B (* b th))
	     (thB (- th B))
	     (divisor (* (- a2 (* 2 a index (cos B)))
			 (/ (- (expt a N) 1.0)
			    (- a 1.0))))
	     (val (/ (- (sin th) (* a (sin thB))
			(* an (- (sin (+ th (* (+ N 1) B))) 
				 (* a (sin (+ th (* N B)))))))
		     divisor)))
	(outa i (* (env ampf) val))))))
-->

<br><br>



<A NAME="ssb-amdoc"></A>
<!-- ---------------------------------------- SSB-AM ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>ssb-am</h3></center></td></tr></table>
<br>
<pre>
  <a class=def name="make-ssb-am">make-ssb-am</a> (frequency *clm-default-frequency*) (order 40)
  <a class=def name="ssb-am">ssb-am</a> gen (insig 0.0) (fm 0.0)
  <a class=def name="ssb-am?">ssb-am?</a> gen
</pre>


<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t :srate 44100)
  (let ((shifter (make-ssb-am 440.0 20))
	(osc (make-oscil 440.0)))
    (do ((i 0 (+ 1 i)))
	((= i 44100))
      (outa i (* 0.5 (ssb-am shifter 
                       (oscil osc)))))))
</pre>
</td>

<td width=4></td>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true, :srate, 44100) do
  shifter = make_ssb_am(440.0, 20);
  osc = make_oscil(440.0);
  44100.times do |i|
    outa(i, 
         0.5 * ssb_am(shifter, oscil(osc)), 
         $output);
    end
  end.output
</pre>
</td>

<td width=4></td>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  440.0 20 make-ssb-am { shifter }
  440.0 make-oscil { osc }
  44100 0 ?do
    i  shifter  osc 0 0 oscil  0 ssb-am f2/ *output* outa drop
  loop
; :play #t :srate 44100 with-sound drop
</pre>
</td>
</tr>
</table>


<p>ssb-am provides single sideband suppressed carrier amplitude modulation, normally used for frequency shifting.
The basic notion is to shift a spectrum up or down while cancelling either the upper or lower half of the spectrum.
See <a href="sndscm.html#ssbbank">dsp.scm</a> for a number of curious possibilities (time stretch without pitch shift for example).
When this works, which it does more often than I expected, it is much better than the equivalent
phase-vocoder or granular synthesis kludges.
</p>

<table border=1 align=left hspace=40 vspace=10 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>ssb-am methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>frequency in Hz</td></tr>
<tr><td><em class=gen>mus-phase</em></td><td>phase (of embedded sin osc) in radians</td></tr>
<tr><td><em class=gen>mus-order</em></td><td>embedded delay line size</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>same as mus-order</td></tr>
<tr><td><em class=gen>mus-interp-type</em></td><td><code>mus-interp-none</code></td></tr>
<tr><td><em class=gen>mus-xcoeff</em></td><td>FIR filter coeff</td></tr>
<tr><td><em class=gen>mus-xcoeffs</em></td><td>embedded Hilbert transform FIR filter coeffs</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>embedded filter state</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>frequency in radians per sample</td></tr>
</table>

<br>

<pre>
(define* (ssb-am freq (order 40)) 
  ;; higher order = better cancellation
  (let* ((car-freq (abs freq))
	 (cos-car (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> car-freq (* .5 pi)))
	 (sin-car (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> car-freq))
	 (dly (<a class=quiet href="#make-delay" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_delay_tip)">make-delay</a> order))
	 (hlb (<a class=quiet href="sndscm.html#makehilberttransform" onmouseout="UnTip()" onmouseover="Tip(sndscm_makehilberttransform_tip)">make-hilbert-transform</a> order)))
    (<a class=quiet href="extsnd.html#mapchannel" onmouseout="UnTip()" onmouseover="Tip(extsnd_mapchannel_tip)">map-channel</a> 
      (lambda (y)
        (let ((ccos (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> cos-car))
	      (csin (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> sin-car))
	      (yh (<a class=quiet href="sndscm.html#hilberttransform" onmouseout="UnTip()" onmouseover="Tip(sndscm_hilberttransform_tip)">hilbert-transform</a> hlb y))
  	      (yd (<a class=quiet href="#delay" onmouseout="UnTip()" onmouseover="Tip(sndclm_delay_tip)">delay</a> dly y)))
          (if (&gt; freq 0.0)
	      (- (* ccos yd) ; shift up
	         (* csin yh))
	      (+ (* ccos yd) ; shift down
	         (* csin yh))))))))
</pre>
<br clear=left>
<br>

<table border=0 hspace=40 vspace=10><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (shift-pitch beg dur file freq (order 40))
  (let* ((st (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> beg))
         (nd (+ st (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur)))
	 (gen (<em class=red>make-ssb-am</em> freq order))
	 (rd (<a class=quiet href="#make-readin" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_readin_tip)">make-readin</a> file)))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
     (do ((i st (+ 1 i))) 
	 ((= i nd))
       (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (<em class=red>ssb-am</em> gen (<a class=quiet href="#readin" onmouseout="UnTip()" onmouseover="Tip(sndclm_readin_tip)">readin</a> rd)))))))

(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () (shift-pitch 0 3 "oboe.snd" 1108.0))
</pre>
</td></tr></table>


<p>
Normal amplitude modulation, cos(x) * (amp + Y(t)), where Y is some signal, 
produces the carrier (cos(x)), and symmetric sidebands at x+/-frq where frq is each spectral
component of Y.  This is just an elaboration of 
</p>
<pre>
    cos(x) * (amp + cos(y)) = amp * cos(x) + 1/2(cos(x - y) + cos(x + y))
</pre>
<p>
So, the Y spectrum (the first picture below) is shifted up by cos(x) and mirrored on either side of it (the second picture below; the spectral components
on the left side are folding under 0).  In single side-band
AM, we create both the Y spectrum, and, via the hilbert transform, a version of Y in which the phases are shifted too.
Then we can add these two copies, using the phase differences to cancel one side of the symmetric
spectrum (this is the third picture below; the new spectral components are not harmonically related however).  
Once we can shift a pitch without creating its symmetric twin, we can split a spectrum
into many bands, shift each band separately, and thereby retain its original harmonic spacing (the fourth picture).
We have the original, but at a higher pitch.  If we then use <a href="#src">src</a> to convert it back to
its pre-shift pitch, we have the original, but with a different length.
We have decoupled the pitch from the duration, much as in a phase vocoder (which uses an FFT
rather than a filter bank, and an inverse FFT of the moved spectrum, rather than ssb-am).
</p>

<table border=1 hspace=20><tr><td>
<table border=0 hspace=20 vspace=10>
<tr>
<td><img src="pix/orig-oboe.png" alt="unaltered oboe"></td>
<td><img src="pix/am.png" alt="am oboe"></td>
<td><img src="pix/ssbam.png" alt="ssbam oboe"></td>
<td><img src="pix/ssbambank.png" alt="ssbambank oboe"></td>
</tr>
<tr>
<td><center>original</center></td>
<td><center>amplitude modulation</center></td>
<td><center>ssb-am</center></td>
<td><center>ssb-am bank</center></td>
</tr>
</table>
</td></tr></table>

<p>The second picture was created from oboe.snd (the original) via:
</p>
<pre>
    (let ((osc (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> 1000.0))) 
      (<a class=quiet href="extsnd.html#mapchannel" onmouseout="UnTip()" onmouseover="Tip(extsnd_mapchannel_tip)">map-channel</a> 
        (lambda (y) 
          (* .5 (<a class=quiet href="#amplitude-modulate" onmouseout="UnTip()" onmouseover="Tip(sndclm_amplitude_modulate_tip)">amplitude-modulate</a> .01 (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> osc) y)))))
</pre>

<p>The third picture was created by:
</p>
<pre>
    (let ((am (<em class=red>make-ssb-am</em> 1000 40))) 
      (<a class=quiet href="extsnd.html#mapchannel" onmouseout="UnTip()" onmouseover="Tip(extsnd_mapchannel_tip)">map-channel</a> 
        (lambda (y) 
          (<em class=red>ssb-am</em> am y))))
</pre>

<p>
And the fourth used the ssb-am-bank function in dsp.scm rewritten here for with-sound:
</p>

<table border=0 hspace=40 vspace=10><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (repitch beg dur sound old-freq new-freq 
                 (amp 1.0) (pairs 10) (order 40) (bw 50.0))
  (let* ((start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> beg))
         (end (+ start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur)))
         (ssbs (make-vector pairs))
         (bands (make-vector pairs))
         (factor (/ (- new-freq old-freq) old-freq))
         (rd (<a class=quiet href="#make-readin" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_readin_tip)">make-readin</a> sound)))
    (do ((i 1 (+ 1 i)))
        ((&gt; i pairs))
      (let* ((aff (* i old-freq))
             (bwf (* bw (+ 1.0 (/ i (* 2 pairs))))))
        (set! (ssbs (- i 1)) (<em class=red>make-ssb-am</em> (* i factor old-freq)))
        (set! (bands (- i 1)) (<a class=quiet href="sndscm.html#makebandpass" onmouseout="UnTip()" onmouseover="Tip(sndscm_makebandpass_tip)">make-bandpass</a> (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> (- aff bwf)) ; bandpass is in dsp.scm
                                             (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> (+ aff bwf)) 
                                             order))))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
     (do ((i start (+ 1 i))) 
         ((= i end))
       (let ((sum 0.0)
             (y (<a class=quiet href="#readin" onmouseout="UnTip()" onmouseover="Tip(sndclm_readin_tip)">readin</a> rd)))
         (do ((band 0 (+ 1 band)))
             ((= band pairs))
           (set! sum (+ sum (<em class=red>ssb-am</em> (ssbs band) 
                                    (<a class=quiet href="sndscm.html#makebandpass" onmouseout="UnTip()" onmouseover="Tip(sndscm_makebandpass_tip)">bandpass</a> (bands band) y)))))
         (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* amp sum)))))))

 (let* ((sound "oboe.snd")
        (mx (maxamp sound))
        (dur (<a class=quiet href="extsnd.html#mussoundduration" onmouseout="UnTip()" onmouseover="Tip(extsnd_mussoundduration_tip)">mus-sound-duration</a> sound)))
    (<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:scaled-to mx  :srate (srate sound))
      (repitch 0 dur sound 554 1000)))
</pre>
</td></tr></table>


<p>If you'd like to move formants independently of the fundamental, add
or subtract integer multiples of the new fundamental from the make-ssb-am
frequency argument.  In the repitch instrument above, say we wanted to 
add a "stretch" argument to spread out or squeeze down the spectrum.
We would replace the current make-ssb-am line with:
</p>
<pre>
    (set! (ssbs (- i 1)) (<em class=red>make-ssb-am</em> (+ (* i factor old-freq)
                                       (* new-freq (round (* i <em class=red>stretch</em>))))))
</pre>


<br><br>



<A NAME="wave-traindoc"></A>
<!-- ---------------------------------------- WAVE-TRAIN ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>wave-train</h3></center></td></tr></table>

<pre>
  <a class=def name="make-wave-train">make-wave-train</a> 
        (frequency *clm-default-frequency*) 
        (initial-phase 0.0) 
        wave 
        (size *clm-table-size*) 
        (type mus-interp-linear)

  <a class=def name="wave-train">wave-train</a> w (fm 0.0)
  <a class=def name="wave-train?">wave-train?</a> w

  <a class=def NAME="make-wave-train-with-env">make-wave-train-with-env</a> frequency env size
</pre>


<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t)
  (let ((gen (make-wave-train 440.0
               :wave (let ((v (make-vct 64)) 
                           (g (make-ncos 400 10)))
                       (set! (mus-phase g) (* -0.5 pi))
                       (do ((i 0 (+ 1 i))) 
                           ((= i 64)) 
                         (set! (v i) (ncos g))) 
                       v))))
    (do ((i 0 (+ 1 i)))
        ((= i 44100))
      (outa i (* 0.5 (wave-train gen))))))
</pre>
</td>

<td width=4></td>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true) do
  v = make_vct(64);
  g = make_ncos(400, 10);
  g.phase =  -0.5 * 3.14159;
  64.times do |i|
    v[i] = ncos(g);
    end
  gen = make_wave_train(440.0, :wave, v);
  44100.times do |i| 
    outa(i, 0.5 * wave_train(gen), $output) 
    end
  end.output
</pre>
</td>

<td width=4></td>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  400 10 make-ncos { g }
  g -0.5 pi f* set-mus-phase drop
  64 make-vct map! g 0 ncos end-map { v }
  440.0 :wave v make-wave-train { gen }
  44100 0 do
    i  gen 0 wave-train  f2/ *output* outa drop
  loop
; :play #t with-sound drop
</pre>
</td>
</tr>
</table>


<p>wave-train adds a copy of its "wave" (a "grain" in more modern parlance) into its output at "frequency" times per second.
These copies can overlap or have long intervals of silence in between, so
wave train can be viewed either as an extension of pulse-train and table-lookup,
or as a primitive form of granular synthesis.
make-wave-train-with-env (defined in generators.scm) returns a new wave-train generator with the envelope 'env' loaded into its table.
</p>

<table border=1 cellpadding=4 hspace=40 vspace=10 align=left>
<tr><td colspan=2 bgcolor="beige"><center>wave-train methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>frequency in Hz</td></tr>
<tr><td><em class=gen>mus-phase</em></td><td>phase in radians</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>wave array (no set!)</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>length of wave array (no set!)</td></tr>
<tr><td><em class=gen>mus-interp-type</em></td><td>interpolation choice (no set!)</td></tr>
</table>

<img src="pix/wt.png" alt="wave-train example" vspace=20>
<br clear=left>


<!--
(with-sound (:clipped #f :statistics #t :scaled-to .5 :play #t)
  (let ((gen (make-wave-train 300.0 :wave (let ((v (make-vct 64)) 
                                                (g (make-sum-of-cosines 10 400 (* -0.5 pi)))) 
                                            (do ((i 0 (+ 1 i))) 
                                                ((= i 64)) 
                                              (set! (v i) (sum-of-cosines g))) 
                                            v))))
    (run 
       (do ((i 0 (+ 1 i)))
           ((= i 1000))
         (outa i (wave-train gen))))))
-->

<p>
With some simple envelopes or filters, you can
use this for VOSIM and other related techniques. 
Here is a FOF instrument based loosely on fof.c of Perry Cook and the article
"Synthesis of the Singing Voice" by Bennett and Rodet in 
"Current Directions in Computer Music Research".
</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (fofins beg dur frq amp vib f0 a0 f1 a1 f2 a2 ve ae)
  (let* ((start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> beg))
         (end (+ start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur)))
         (ampf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> (or ae (list 0 0 25 1 75 1 100 0)) :scaler amp :duration dur))
         (frq0 (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> f0))
         (frq1 (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> f1))
         (frq2 (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> f2))
         (foflen (if (= (<a class=quiet href="#mussrate" onmouseout="UnTip()" onmouseover="Tip(sndclm_mussrate_tip)">mus-srate</a>) 22050) 100 200))
         (vibr (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> 6))
         (vibenv (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> (or ve (list 0 1 100 1)) :scaler vib :duration dur))
         (win-freq (/ (* 2 pi) foflen))
         (foftab (<a class=quiet href="extsnd.html#makevct" onmouseout="UnTip()" onmouseover="Tip(extsnd_makevct_tip)">make-vct</a> foflen))
         (wt0 (<em class=red>make-wave-train</em> :wave foftab :frequency frq)))
    (do ((i 0 (+ 1 i)))
        ((= i foflen))
      (set! (foftab i) ;; this is not the pulse shape used by B&amp;R
            (* (+ (* a0 (sin (* i frq0))) 
                  (* a1 (sin (* i frq1))) 
                  (* a2 (sin (* i frq2)))) 
               .5 (- 1.0 (cos (* i win-freq))))))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
     (do ((i start (+ 1 i)))
         ((= i end))
       (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> ampf) (<em class=red>wave-train</em> wt0 (* (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> vibenv) (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> vibr)))))))))

(<a class=quiet href="sndscm.html#withsound" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () (fofins 0 1 270 .2 .001 730 .6 1090 .3 2440 .1)) ; "Ahh"

(<a class=quiet href="sndscm.html#withsound" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () ; one of JC's favorite demos
  (fofins 0 4 270 .2 0.005 730 .6 1090 .3 2440 .1 '(0 0 40 0 75 .2 100 1) 
          '(0 0 .5 1 3 .5 10 .2 20 .1 50 .1 60 .2 85 1 100 0))
  (fofins 0 4 (* 6/5 540) .2 0.005 730 .6 1090 .3 2440 .1 '(0 0 40 0 75 .2 100 1) 
          '(0 0 .5 .5 3 .25 6 .1 10 .1 50 .1 60 .2 85 1 100 0))
  (fofins 0 4 135 .2 0.005 730 .6 1090 .3 2440 .1 '(0 0 40 0 75 .2 100 1) 
          '(0 0 1 3 3 1 6 .2 10 .1 50 .1 60 .2 85 1 100 0)))
</pre>
</td></tr></table>


<p>The "wave" is a vct accessible via mus-data.  The "fm" argument affects the frequency of
repetition.  Here is a wave-train instrument that increasingly filters its grain (the word "now", for example) 
while increasing the repetition rate.  We're also using a pulse train as a sort of internal click track,
using the same frequency envelope as the wave-train, so we have some idea when to refilter the grain.
</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (when? start-time duration start-freq end-freq grain-file)
  (let* ((beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> start-time))
         (len (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> duration))
         (end (+ beg len))
         (grain-dur (<a class=quiet href="extsnd.html#mussoundduration" onmouseout="UnTip()" onmouseover="Tip(extsnd_mussoundduration_tip)">mus-sound-duration</a> grain-file))
         (frqf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1) :scaler (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> (- end-freq start-freq)) :duration duration))
         (click-track (<em class=red>make-pulse-train</em> start-freq))
         (grain-size (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> grain-dur))
         (grains (<em class=red>make-wave-train</em> :size grain-size :frequency start-freq))
         (ampf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 1 1 0) :scaler .7 :offset .3 :duration duration :base 3.0))
         (grain (<em class=red>mus-data</em> grains)))
    (<a class=quiet href="#filetoarray" onmouseout="UnTip()" onmouseover="Tip(sndclm_filetoarray_tip)">file-&gt;array</a> grain-file 0 0 grain-size grain)
    (let ((original-grain (<a class=quiet href="extsnd.html#vctcopy" onmouseout="UnTip()" onmouseover="Tip(extsnd_vctcopy_tip)">vct-copy</a> grain)))
      (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
       (do ((i beg (+ 1 i)))
           ((= i end))
         (let* ((gliss (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> frqf)))
           (outa i (* (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> ampf) (<em class=red>wave-train</em> grains gliss)))
           (let ((click (<em class=red>pulse-train</em> click-track gliss)))
             (if (&gt; click 0.0)
                 (let* ((scaler (max 0.1 (* 1.0 (/ (- i beg) len))))
                        (comb-len 32)
                        (c1 (<a class=quiet href="#make-comb" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_comb_tip)">make-comb</a> scaler comb-len))
                        (c2 (<a class=quiet href="#make-comb" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_comb_tip)">make-comb</a> scaler (floor (* comb-len .75))))
                        (c3 (<a class=quiet href="#make-comb" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_comb_tip)">make-comb</a> scaler (floor (* comb-len 1.25)))))
                   (do ((k 0 (+ 1 k)))
                       ((= k grain-size))
                     (let ((x (original-grain k)))
                       (set! (grain k) (+ (<a class=quiet href="#comb" onmouseout="UnTip()" onmouseover="Tip(sndclm_comb_tip)">comb</a> c1 x) (<a class=quiet href="#comb" onmouseout="UnTip()" onmouseover="Tip(sndclm_comb_tip)">comb</a> c2 x) (<a class=quiet href="#comb" onmouseout="UnTip()" onmouseover="Tip(sndclm_comb_tip)">comb</a> c3 x))))))))))))))

(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () (when? 0 4 2.0 8.0 "right-now.snd"))
</pre>
</td></tr></table>

<p>wave-train is built on table-lookup and shares all of its questionable aspects.  See also the <a href="#pulsedenv">pulsed-env</a>e generator
in generators.scm, used in animals.scm.  It is often simpler to use <a href="#pulse-train">pulse-train</a> as the repetition
trigger, and mus-reset to restart an envelope.  
</p>
<br><br>



<A NAME="randdoc"></A>
<!-- ---------------------------------------- RAND, RAND-INTERP ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>rand, rand-interp</h3></center></td></tr></table>

<pre>
  <a class=def name="make-rand">make-rand</a> 
        (frequency *clm-default-frequency*) ; frequency at which new random numbers occur
        (amplitude 1.0)                     ; numbers are between -amplitude and amplitude
        (envelope '(-1 1 1 1))              ; distribution envelope (uniform distribution is the default)
        distribution                        ; pre-computed distribution

  <a class=def name="rand">rand</a> r (sweep 0.0)
  <a class=def name="rand?">rand?</a> r

  <a class=def name="make-rand-interp">make-rand-interp</a> 
        (frequency *clm-default-frequency*) 
        (amplitude 1.0)
        (envelope '(-1 1 1 1)
        distribution)

  <a class=def name="rand-interp">rand-interp</a> r (sweep 0.0)
  <a class=def name="rand-interp?">rand-interp?</a> r

  <a class=def name="mus-random">mus-random</a> amp
  <a class=def Name="mus-rand-seed">mus-rand-seed</a>
</pre>


<table border=1 bordercolor="lightgray" hspace=20 cellspacing=8 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:channels 2 :play #t)
  (let ((ran1 (make-rand 5.0 (hz-&gt;radians 220.0)))
        (ran2 (make-rand-interp 5.0 (hz-&gt;radians 220.0)))
	(osc1 (make-oscil 440.0))
	(osc2 (make-oscil 1320.0)))
    (do ((i 0 (+ 1 i)))
	((= i 88200))
      (outa i (* 0.5 (oscil osc1 (rand ran1))))
      (outb i (* 0.5 (oscil osc2 (rand-interp ran2)))))))
</pre>
</td>

</tr><tr>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true, :channels, 2) do
  ran1 = make_rand(5.0, hz2radians(220.0));
  ran2 = make_rand_interp(5.0, hz2radians(220.0));
  osc1 = make_oscil(440.0);  
  osc2 = make_oscil(1320.0);
  88200.times do |i|
    outa(i, 0.5 * oscil(osc1, rand(ran1)), $output);
    outb(i, 0.5 * oscil(osc2, rand_interp(ran2)), $output);
    end
  end.output
</pre>
</td>

</tr><tr>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  5.0 220.0 hz-&gt;radians make-rand { ran1 }
  5.0 330.0 hz-&gt;radians make-rand-interp { ran2 }
   440.0 make-oscil { osc1 }
  1320.0 make-oscil { osc2 }
  88200 0 do
    i  osc1  ran1 0 rand         0 oscil  f2/ *output* outa drop
    i  osc2  ran2 0 rand-interp  0 oscil  f2/ *output* outb drop
  loop
; :channels 2 :play #t with-sound drop
</pre>
</td>
</tr>
</table>



<p>rand produces a sequence of random numbers between -amplitude and
amplitude (a sort of step function).
rand-interp interpolates between successive
random numbers.
rand-interp could be defined as (<a class=quiet href="#moving-average">moving-average</a> agen (rand rgen)) where the
averager has the same period (length) as the rand.  
In both cases, the "envelope" argument or the "distribution" argument determines the random number distribution.
mus-random returns a random number between -amplitude and amplitude.
mus-rand-seed provides access to the seed for mus-random's random number generator.
</p>

<table border=1 align=left hspace=40 vspace=10 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>rand and rand-interp methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>frequency in Hz</td></tr>
<tr><td><em class=gen>mus-phase</em></td><td>phase in radians</td></tr>
<tr><td><em class=gen>mus-scaler</em></td><td>amplitude arg used in make-&lt;gen&gt;</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>distribution table (vct) length</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>distribution table (vct), if any</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>frequency in radians per sample</td></tr>
</table>
<pre>
<br>
rand:
  (if (&gt;= phase (* 2 pi))
      (set! output (<em class=red>mus-random</em> amplitude)))
  (set! phase (+ phase (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> frequency) sweep))
</pre>
<br clear=left>

<p>The "frequency" is the rate at which new values are produced, so it makes sense to request a frequency above srate/2.
If rand's frequency is the current srate, it produces a new random value on every sample.  
Since rand is (normally) producing a sequence of square-waves, and rand-interp a sequence of triangle-waves,
both reflect that in their spectra (spectrum y axis is in dB):
</p>

<!--
(with-sound ()
  (let ((gen (make-rand 2000)))
    (do ((i 0 (+ 1 i)))
	((= i 50000))
      (outa i (* .5 (rand gen))))))

(with-sound ()
  (let ((gen (make-rand-interp 2000)))
    (do ((i 0 (+ 1 i)))
	((= i 50000))
      (outa i (* .5 (rand-interp gen))))))

(with-sound ()
  (let ((gen (make-square-wave 1000)))
    (do ((i 0 (+ 1 i)))
	((= i 50000))
      (outa i (* .5 (square-wave gen))))))

(with-sound ()
  (let ((gen (make-triangle-wave 1000)))
    (do ((i 0 (+ 1 i)))
	((= i 50000))
      (outa i (* .5 (triangle-wave gen))))))
-->

<table border=1 hspace=20 vspace=10>
<tr>
<td><img src="pix/sqsq.png" alt="sqwave spectrum"></td><td width=20></td><td><img src="pix/tritri.png" alt="triwave spectrum"></td>
</tr>
<tr>
<td bgcolor="#f2f4ff"><center>square-wave (freq=1000)</center></td><td></td><td bgcolor="#f2f4ff"><center>triangle-wave (freq=1000)</center></td>
</tr>

<tr>
<td><img src="pix/randsq.png" alt="rand spectrum"></td><td></td><td><img src="pix/randtri.png" alt="rand-interp spectrum"></td>
</tr>
<tr>
<td bgcolor="#f2f4ff"><center>rand (freq=2000)</center></td><td></td><td bgcolor="#f2f4ff"><center>rand-interp (freq=2000)</center></td>
</tr>
</table>


<p>There are a variety of ways to get a non-uniform random number distribution:
<code>(random (random 1.0))</code> or <code>(sin (mus-random pi))</code> are examples. Exponential distribution could be:
</p>
<pre>
  (/ (log (max .01 (random 1.0))) (log .01))
</pre>
<p>where the ".01"'s affect how tightly the resultant values cluster toward 0.0 &mdash;
set them to .0001, for example, to get most of the random values close to 0.0.
The central-limit theorem says that you can get closer and closer to gaussian
noise by adding rand's together.  Orfanidis in 
"Introduction to Signal Processing" says 12 calls on rand will
do perfectly well:
</p><pre>
    (define (gaussian-noise)
      (let ((val 0.0))
        (do ((i 0 (+ 1 i))) 
            ((= i 12) (/ val 12.0) )
          (set! val (+ val (random 1.0))))))
</pre>
<p>You can watch this (or any other distribution) in action via:
</p>
<table border=0 hspace=40><tr><td>
<pre>
(define (add-rands n)
  (let ((bins (make-vector 201 0))
	(rands (make-vector n #f)))
    (do ((i 0 (+ 1 i)))
	((= i n))
      (set! (rands i) (<em class=red>make-rand</em> :frequency (<a class=quiet href="#mussrate" onmouseout="UnTip()" onmouseover="Tip(sndclm_mussrate_tip)">mus-srate</a>) :amplitude (/ 100 n)))
      (rand (rands i)))
    (do ((i 0 (+ 1 i)))
	((= i 100000))
      (let ((sum 0.0))
	(do ((k 0 (+ 1 k)))
	    ((= k n))
	  (set! sum (+ sum (<em class=red>rand</em> (rands k)))))
	(let ((bin (floor (+ 100 (round sum)))))
	  (set! (bins bin) (+ (bins bin) 1)))))
    bins))

(let ((ind (<a class=quiet href="extsnd.html#newsound" onmouseout="UnTip()" onmouseover="Tip(extsnd_newsound_tip)">new-sound</a> "test.snd")))
  (do ((n 1 (+ n 1)))
      ((= n 12))
    (let* ((bins (vector-&gt;vct (add-rands n)))
	   (pk (<a class=quiet href="extsnd.html#vctpeak" onmouseout="UnTip()" onmouseover="Tip(extsnd_vctpeak_tip)">vct-peak</a> bins)))
      (<a class=quiet href="extsnd.html#vcttochannel" onmouseout="UnTip()" onmouseover="Tip(extsnd_vcttochannel_tip)">vct-&gt;channel</a> (<a class=quiet href="extsnd.html#vctscale" onmouseout="UnTip()" onmouseover="Tip(extsnd_vctscale_tip)">vct-scale!</a> bins (/ 1.0 pk)))
      (set! (<a class=quiet href="extsnd.html#xaxislabel" onmouseout="UnTip()" onmouseover="Tip(extsnd_xaxislabel_tip)">x-axis-label</a>) (<a class=quiet onmouseout="UnTip()" onmouseover="Tip(scheme_format_tip)">format</a> #f "n: ~D" n))
      (<a class=quiet href="extsnd.html#updatetimegraph" onmouseout="UnTip()" onmouseover="Tip(extsnd_updatetimegraph_tip)">update-time-graph</a>))))
</pre>
</td></tr></table>

<p>
Another way to get different distributions is the "rejection method" in which we generate random number
pairs until we get a pair that falls within the
desired distribution; see <a href="sndscm.html#anyrandom">any-random</a> in dsp.scm.
The rand and rand-interp generators, however, use the "transformation method".
The make-rand and make-rand-interp "envelope" arguments specify
the desired distribution function; the generator takes the
inverse of the integral of this envelope, loads that into an array, and uses
<code>(array-interp (random array-size))</code>.  This gives
random numbers of any arbitrary distribution at a computational cost
equivalent to the old waveshape generator.
The x axis of the envelope sets the output range (before scaling by the "amplitude" argument), and
the y axis sets the relative weight of the corresponding x axis value.
So, the default is <code>'(-1 1 1 1)</code> which says "output numbers between -1 and 1,
each number having the same chance of being chosen".
An envelope of <code>'(0 1 1 0)</code> outputs values between 0 and 1, denser toward 0.
If you already have the distribution table (a vct, the result of <code>(inverse-integrate envelope)</code> for example),
you can pass it through the "distribution" argument.  Here is gaussian noise
using the "envelope" argument:
</p>
<table border=0 hspace=40><tr><td>
<pre>
(define (gaussian-envelope s)
  (let ((e '())
	(den (* 2.0 s s)))
    (do ((i 0 (+ 1 i))
	 (x -1.0 (+ x .1))
	 (y -4.0 (+ y .4)))
	((= i 21))
      (set! e (cons x e))
      (set! e (cons (exp (- (/ (* y y) den))) e)))
    (reverse e)))

(<em class=red>make-rand</em> :envelope (gaussian-envelope 1.0))
</pre>
</td></tr></table>

<p>If you want a particular set of values, it's simplest to fill a vct with those values,
then use random as the index into the array.  Say we want 0.0, 0.5, and 1.0 at random,
but 0.5 should happen three times as often as either of the others:
</p>

<pre>
    (let ((vals (<a class=quiet href="extsnd.html#vct" onmouseout="UnTip()" onmouseover="Tip(extsnd_vct_tip)">vct</a> 0.0 0.5 0.5 0.5 1.0)))
      (do ((i 0 (+ 1 i)))
          ((= i 10))
        (display (<a class=quiet onmouseout="UnTip()" onmouseover="Tip(scheme_format_tip)">format</a> #f ";~A " (vals (floor (random 5.0)))))))
</pre>

<p>These "distributions" refer to the values returned by the random number
generator, but all of them produce white noise (all frequencies are equally
likely).  
You can, of course, filter the output of rand to get a different
frequency distribution.  See, for example, <a href="#round-interp">round-interp</a> in generators.scm.
It uses a <a href="#moving-average">moving-average</a> generator to low-pass filter the output of a rand-interp
generator; the result is a rand-interp signal with rounded corners.
Orfanidis also mentions a clever way to get reasonably good 1/f noise:
sum together n rand's, where each rand is running an octave slower
than the preceding:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(define (make-1f-noise n)
  ;; returns an array of rand's ready for the 1f-noise generator
  (let ((rans (make-vector n)))
    (do ((i 0 (+ 1 i))) 
        ((= i n) rans)
      (set! (rans i) (<em class=red>make-rand</em> :frequency (/ (<a class=quiet href="#mussrate" onmouseout="UnTip()" onmouseover="Tip(sndclm_mussrate_tip)">mus-srate</a>) (expt 2 i)))))))

(define (1f-noise rans)
  (let ((val 0.0) 
        (len (length rans)))
    (do ((i 0 (+ 1 i)))
        ((= i len) (/ val len))
      (set! val (+ val (<em class=red>rand</em> (rans i)))))))
</pre>
</td></tr></table>

<p>This is the <a href="#pink-noise">pink-noise</a> generator in generators.scm.
See also <a href="#green-noise">green-noise</a> &mdash; bounded brownian noise that can mimic 1/f noise in some cases.
(The brownian graph below has a different dB range, and the rand graph would be flat if we used a frequency of 44100).
</p>

<table border=1 hspace=20 cellpadding=5>
<tr><td>
<table border=0>
<tr>
<td bgcolor="#f2f4ff"><center>random</center></td>
<td bgcolor="#f2f4ff"><center>rand</center></td>
<td bgcolor="#f2f4ff"><center>rand-interp</center></td>
</tr><tr>
<td><img src="pix/random.png" alt="random spectrum"></td>
<td><img src="pix/rand.png" alt="rand spectrum"></td>
<td><img src="pix/randi.png" alt="rand-interp spectrum"></td>
</tr></table>
</td></tr><tr><td>
<table border=0>
<tr>
<td bgcolor="#f2f4ff"><center>1/f</center></td>
<td bgcolor="#f2f4ff"><center>brownian</center></td>
<td bgcolor="#f2f4ff"><center>green</center></td>
</tr><tr>
<td><img src="pix/1f.png" alt="1/f spectrum"></td>
<td><img src="pix/brownian.png" alt="brownian spectrum"></td>
<td><img src="pix/green.png" alt="green spectrum"></td>
</tr></table>
</td></tr></table>

<!-- CLM:
;; 1f.png
(with-sound ()
  (let ((noise (make-1f-noise 12)))
    (do ((i 0 (+ 1 i)))
	((= i 10000))
      (outa i (1f-noise noise)))))

;; rand.png
(with-sound ()
  (let ((noise (make-rand 10000.0)))
    (do ((i 0 (+ 1 i)))
	((= i 10000))
      (outa i (rand noise)))))

;; randi.png
(with-sound ()
  (let ((noise (make-rand-interp 10000.0)))
    (do ((i 0 (+ 1 i)))
	((= i 10000))
      (outa i (rand-interp noise)))))

;; random.png
(with-sound ()
  (do ((i 0 (+ 1 i)))
      ((= i 10000))
    (outa i (- 0.5 (random 1.0)))))

;; brownian.png
(with-sound ()
  (let ((val 0.0))
    (do ((i 0 (+ 1 i)))
	((= i 10000))
      (set! val (+ val -.005 (random 0.01)))
      (outa i val))))

;; green.png
(with-sound ()
  (let ((noise (make-green-noise 10000.0 1)))
    (do ((i 0 (+ 1 i)))
	((= i 10000))
      (outa i (green-noise noise 0.0)))))
-->


<p>And we can't talk about noise without mentioning fractals:</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (fractal start duration m x amp)
  ;; use formula of M J Feigenbaum
  (let* ((beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> start))
	 (end (+ beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> duration))))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
     (do ((i beg (+ 1 i)))
         ((= i end))
       (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* amp x))
       (set! x (- 1.0 (* m x x)))))))

;;; this quickly reaches a stable point for any m in[0,.75], so:
(<a class=quiet href="sndscm.html#withsound" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () (fractal 0 1 .5 0 .5)) 
;;; is just a short "ftt"
(<a class=quiet href="sndscm.html#withsound" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () (fractal 0 1 1.5 .20 .2))
</pre>
</td></tr></table>

<p>With this instrument you can hear
the change over from the stable equilibria, to the period doublings,
and finally into the combination of noise and periodicity that
has made these curves famous. See appendix 2 to Ekeland's "Mathematics and the Unexpected" for more details.
Another instrument based on similar ideas is:</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (attract beg dur amp c) ; c from 1 to 10 or so
  ;; by James McCartney, from CMJ vol 21 no 3 p 6
  (let* ((st (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> beg))
	 (nd (+ st (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur)))
	 (a .2) (b .2) (dt .04)
	 (scale (/ (* .5 amp) c))
	 (x1 0.0) (x -1.0) (y 0.0) (z 0.0))
    (do ((i st (+ 1 i)))
        ((= i nd))
     (set! x1 (- x (* dt (+ y z))))
     (set! y (+ y (* dt (+ x (* a y)))))
     (set! z (+ z (* dt (- (+ b (* x z)) (* c z)))))
     (set! x x1)
     (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* scale x)))))
</pre>
</td></tr></table>

<p>which gives brass-like sounds!
We can also get all the period doublings and so on from sin:
</p>
<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#withsound" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:clipped #f :scaled-to 0.5)
  (let ((x 0.5)) 
    (do ((i 0 (+ 1 i)))
	((= i 44100))
      (outa i x)
      (set! x (* 4 (sin (* pi x)))))))
</pre>
</td></tr></table>

<p>For an extended discussion of this case, complete with pictures of the
period doublings, see Strogatz, "Nonlinear Dynamics and Chaos". 
</p>

<p>See also 
<a href="sndscm.html#ditherchannel">dither-channel</a> (dithering),
<a href="sndscm.html#maracadoc">maraca.scm</a> (physical modelling), 
<a href="sndscm.html#noisedoc">noise.scm, noise.rb</a> (a truly ancient noise-maker),
<a href="sndscm.html#anyrandom">any-random</a> (arbitrary distribution via the rejection method),
and <a href="#green-noise">green-noise</a> (bounded Brownian noise).
</p>

<br><br>



<A NAME="one-poledoc"></A>
<A NAME="one-zerodoc"></A>
<A NAME="two-poledoc"></A>
<A NAME="two-zerodoc"></A>
<!-- ---------------------------------------- SIMPLE FILTERS ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>one-pole, one-zero, two-pole, two-zero</h3></center></td></tr></table>

<pre>
   <a class=def name="make-one-pole">make-one-pole</a> a0 b1    ; b1 &lt; 0.0 gives lowpass, b1 &gt; 0.0 gives highpass
   <a class=def name="one-pole">one-pole</a> f input 
   <a class=def name="one-pole?">one-pole?</a> f

   <a class=def name="make-one-zero">make-one-zero</a> a0 a1    ; a1 &gt; 0.0 gives weak lowpass, a1 &lt; 0.0 highpass
   <a class=def name="one-zero">one-zero</a> f input 
   <a class=def name="one-zero?">one-zero?</a> f

   <a class=def name="make-two-pole">make-two-pole</a> frequency [or a0] radius [or b1] b2
   <a class=def name="two-pole">two-pole</a> f input 
   <a class=def name="two-pole?">two-pole?</a> f

   <a class=def name="make-two-zero">make-two-zero</a> frequency [or a0] radius [or a1] a2
   <a class=def name="two-zero">two-zero</a> f input 
   <a class=def name="two-zero?">two-zero?</a> f
</pre>


<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t)
  (let ((flt (make-two-pole 1000.0 0.999))
	(ran1 (make-rand 10000.0 .002)))
    (do ((i 0 (+ 1 i)))
	((= i 44100))
      (outa i (* 0.5 (two-pole flt 
                       (rand ran1)))))))
</pre>
</td>

<td width=4></td>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true) do
  flt = make_two_pole(1000.0, 0.999);
  ran1 = make_rand(10000.0, 0.002); 
  44100.times do |i|
    outa(i, 
         0.5 * two_pole(flt, rand(ran1)), 
         $output);
    end
  end.output
</pre>
</td>

<td width=4></td>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  1000.0 0.999 make-two-pole { flt }
  10000.0 0.002 make-rand { ran1 }
  44100 0 do
    i  flt  ran1 0 rand  two-pole  f2/ *output* outa drop
  loop
; :play #t with-sound drop
</pre>
</td>
</tr>
</table>


<p>These are the simplest of filters. If you're curious about filters, 
Julius Smith's on-line <a href="http://www-ccrma.stanford.edu/~jos/filters/">Introduction to Digital Filters</a> is
excellent.
</p>

<table border=1 align=left hspace=40 vspace=10 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>simple filter methods</center></td></tr>
<tr><td><em class=gen>mus-xcoeff</em></td><td>a0, a1, a2 in equations</td></tr>
<tr><td><em class=gen>mus-ycoeff</em></td><td>b1, b2 in equations</td></tr>
<tr><td><em class=gen>mus-order</em></td><td>1 or 2 (no set!)</td></tr>
<tr><td><em class=gen>mus-scaler</em></td><td>two-pole and two-zero radius</td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>two-pole and two-zero center frequency</td></tr>
</table>
<pre>
one-zero  y(n) = a0 x(n) + a1 x(n-1)
one-pole  y(n) = a0 x(n) - b1 y(n-1)
two-pole  y(n) = a0 x(n) - b1 y(n-1) - b2 y(n-2)
two-zero  y(n) = a0 x(n) + a1 x(n-1) + a2 x(n-2)
</pre>
<br clear=left>
<p>
The "a0, b1" nomenclature is taken from Julius Smith's "An Introduction to Digital
Filter Theory" in Strawn "Digital Audio Signal Processing", and is different
from that used in the more general filters such as <a href="#fir-filter">fir-filter</a>.
In make-two-pole and make-two-zero you can specify either the actual
desired coefficients ("a0" and friends), or the center frequency and radius of the
filter ("frequency" and "radius").  The word "radius" refers to the unit circle,
so it should be between 0.0 and (less than) 1.0.
"frequency" should be between 0 and srate/2.  
</p>

<p>We can use a one-pole filter as an "exponentially weighted moving average":
</p>
<pre>
    (make-one-pole (/ 1.0 order) (/ (- order) (+ 1.0 order)))
</pre>
<p>where "order" is more or less how long an input affects the output.
The <a href="#mus-xcoeff">mus-xcoeff</a> and <a href="#mus-ycoeff">mus-ycoeff</a> functions give access to the filter coefficients.
<a href="sndscm.html#prc95doc">prc95.scm</a> uses them to make "run time"
alterations to the filters:
</p>

<pre>
    (set! (mus-ycoeff p 1) (- val))     ; "p" is a one-pole filter, this is setting "b1"
    (set! (mus-xcoeff p 0) (- 1.0 val)) ; this is setting "a0"
</pre>

<p>We can also use <a href="#mus-frequency">mus-frequency</a> and <a href="#mus-scaler">mus-scaler</a> (the pole "radius") as a more intuitive handle on these coefficients:
</p>

<pre>
    <em class=listener>&gt;</em><em class=typing>(define p (make-two-pole :radius .9 :frequency 1000.0))</em>
    <em class=listener>#&lt;unspecified&gt;</em>
    <em class=listener>&gt;</em><em class=typing>p</em>
    <em class=listener>#&lt;two-pole: a0: 1.000, b1: -1.727, b2: 0.810, y1: 0.000, y2: 0.000&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(mus-frequency p)</em>
    <em class=listener>1000.00025329731</em>
    <em class=listener>&gt;</em><em class=typing>(mus-scaler p)</em>
    <em class=listener>0.899999968210856</em>
    <em class=listener>&gt;</em><em class=typing>(set! (mus-frequency p) 2000.0)</em>
    <em class=listener>2000.0</em>
    <em class=listener>&gt;</em><em class=typing>p</em>
    <em class=listener>#&lt;two-pole: a0: 1.000, b1: -1.516, b2: 0.810, y1: 0.000, y2: 0.000&gt;</em>
</pre>

<p>A quick way to see the frequency response of a filter is to drive it with a sine wave sweeping from
0 Hz to half the sampling rate; if the sound length is 0.5 seconds, you can read off the time axis
as the response at that frequency (in terms of a sampling rate of 1.0):
</p>

<table border=0 hspace=20>
<tr><td>
<pre>
(define (test-filter flt)
  (let* ((osc (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a>))
	 (samps (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> 0.5))
	 (ramp (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1) 
                     :scaler (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> samps) 
                     :length samps)))
    (<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> ()
      (do ((i 0 (+ 1 i)))
	  ((= i samps))
        (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (flt (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> osc (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> ramp))))))))
		
(test-filter (make-one-zero 0.5 0.5))
(test-filter (make-one-pole 0.1 -0.9))
(test-filter (make-two-pole 0.1 0.1 0.9))
(test-filter (make-two-zero 0.5 0.2 0.3))
</pre>
</td><td>
<img src="pix/2pole.png" alt="simple filters">
</td>
</tr>
</table>


<!--
(define (test-filter flt chan)
  (let* ((osc (make-oscil 0.0))
	 (samps (seconds->samples 0.5))
	 (ramp (make-env '(0 0 1 1) :scaler (hz->radians samps) :length samps)))

      (do ((i 0 (+ 1 i)))
	  ((= i samps))
        (out-any i (flt (oscil osc (env ramp))) chan))))

(with-sound (:channels 4)
  (test-filter (make-one-zero 0.5 0.5) 0)
  (test-filter (make-one-pole 0.1 -0.9) 1)
  (test-filter (make-two-pole 0.1 0.1 0.9) 2)
  (test-filter (make-two-zero 0.5 0.2 0.3) 3))

(define (fixup-axes)
  (set! (selected-data-color) (make-color 0 0 0))
  (set! (selected-graph-color) (make-color 1 1 1))
  (set! (x-axis-label 0 0) "(make-one-zero 0.5 0.5)")
  (set! (x-axis-label 0 1) "(make-one-pole 0.1 -0.9)")
  (set! (x-axis-label 0 2) "(make-two-pole 0.1 0.1 0.9)")
  (set! (x-axis-label 0 3) "(make-two-zero 0.5 0.2 0.3)"))
-->

<br><br>




<A NAME="formantdoc"></A>
<!-- ---------------------------------------- FORMANT ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>formant</h3></center></td></tr></table>

<pre>
  <a class=def name="make-formant">make-formant</a> 
      frequency   ; resonance center frequency in Hz
      radius      ; resonance width, indirectly
  <a class=def name="formant">formant</a> f input center-frequency-in-radians
  <a class=def name="formant?">formant?</a> f

  <a class=def name="make-firmant">make-firmant</a> frequency radius
  <a class=def name="firmant">firmant</a> f input center-frequency-in-radians
  <a class=def name="firmant?">firmant?</a> f
</pre>


<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t)
  (let ((flt (make-firmant 1000.0 0.999))
	(ran1 (make-rand 10000.0 5.0)))
    (do ((i 0 (+ 1 i)))
	((= i 44100))
      (outa i (* 0.5 (firmant flt 
                       (rand ran1)))))))
</pre>
</td>

<td width=4></td>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true) do
  flt = make_firmant(1000.0, 0.999);
  ran1 = make_rand(10000.0, 5.0); 
  44100.times do |i|
    outa(i, 
         0.5 * firmant(flt, rand(ran1)), 
         $output);
    end
  end.output
</pre>
</td>

<td width=4></td>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  1000.0 0.999 make-firmant { flt }
  10000.0 5.0 make-rand { ran1 }
  44100 0 do
    i  flt  ran1 0 rand  #f firmant  f2/ *output* outa drop
  loop
; :play #t with-sound drop
</pre>
</td>
</tr>
</table>


<p>formant and firmant are resonators (two-pole, two-zero bandpass filters) centered at "frequency", with the bandwidth set by "radius".
</p>

<table border=0>
<tr><td>
<table border=1 hspace=40 vspace=16 cellpadding=4 align=left>
<tr><td colspan=2 bgcolor="beige"><center>formant methods</center></td></tr>
<tr><td><em class=gen>mus-phase</em></td><td>formant radius</td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>formant center frequency</td></tr>
<tr><td><em class=gen>mus-order</em></td><td>2 (no set!)</td></tr>
</table>

</td><td>
<pre>
    formant:
    y(n) = x(n) - 
           r * x(n-2) + 
           2 * r * cos(frq) * y(n-1) - 
           r * r * y(n-2)

    firmant:
    x(n+1) = r * (x(n) - 2 * sin(frq/2) * y(n)) + input
    y(n+1) = r * (2 * sin(frq/2) * x(n+1) + y(n))
</pre>
</td></tr></table>

<p>The formant generator is described in "A Constant-gain Digital Resonator Tuned By a Single Coefficient" by Julius
O. Smith and James B. Angell in Computer Music Journal Vol. 6 No. 4 (winter
1982) and "A note on
Constant-Gain Digital Resonators" by Ken Steiglitz, CMJ vol 18 No. 4 pp.8-10
(winter 1994).
The formant bandwidth is a function of the "radius", and its center frequency is set by "frequency".
As the radius approaches 1.0 (the unit circle), the
resonance gets narrower.
Use <a href="#mus-frequency">mus-frequency</a> to change the center frequency, and <a href="#mus-scaler">mus-scaler</a> to change the radius.
The radius can be set in terms of desired bandwidth in Hz via:
</p>
<pre>
    (exp (* -0.5 (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> bandwidth)))
</pre>

<p>If you change the radius, the peak amplitude 
of the output changes.  
The firmant generator is the "modified coupled form" of the formant generator,
developed by Max Mathews and Julius Smith in "Methods for Synthesizing Very High Q Parametrically
Well Behaved Two Pole Filters".
Here are some graphs showing the formant and firmant filtering white noise
as we sweep either the frequency or the radius:
</p>

<img src="pix/formant.png" alt="various formant cases" hspace=20>

<!--
(with-sound (:channels 4 :clipped #f :statistics #t)
  (let* ((dur 100)
	 (samps (seconds->samples dur))
	 (flta (make-formant 100 .999))
	 (fltb (make-formant 5000 .1))
	 (fltc (make-firmant 100 .999))
	 (fltd (make-firmant 5000 .1))
	 (ampf (make-env '(0 0 1 1 100 1 101 0) :duration dur))
	 (frqf (make-env '(0 100 1 10000) :scaler (hz->radians 1.0) :duration dur))
	 (rf (make-env '(0 .6 1 .999) :base .01 :duration dur)))
    (run
       (do ((i 0 (+ 1 i)))
	   ((= i samps))
	 (let* ((frq (env frqf))
		(r (env rf))
		(amp (env ampf))
		(pulse (- (random 2.0) 1.0)))
	   (outa i (* amp (formant flta pulse frq)))
	   (set! (mus-scaler fltb) r)
	   (outc i (* amp (formant fltb pulse)))
	   (outb i (* amp (firmant fltc pulse frq)))
	   (outd i (* amp (firmant fltd pulse)))
	   (set! (mus-scaler fltd) r)
	   )))))

(define (fixup-axes)
  (set! (selected-data-color) (make-color 0 0 0))
  (set! (selected-graph-color) (make-color 1 1 1))
  (set! (x-axis-label 0 0 0) "formant: sweep frequency from 100 to 10000")
  (set! (x-axis-label 0 1 0) "firmant: sweep frequency from 100 to 10000")
  (set! (x-axis-label 0 0 1) "formant radius: .999")
  (set! (x-axis-label 0 1 1) "firmant radius: .999")
  (set! (x-axis-label 0 2 0) "formant: sweep radius from .6 to .999")
  (set! (x-axis-label 0 3 0) "firmant: sweep radius from .6 to .999")
  (set! (x-axis-label 0 2 1) "formant frequency: 5000")
  (set! (x-axis-label 0 3 1) "firmant frequency: 5000"))
-->

<p>formant and firmant are often used to sculpt away unwanted spectral components, or emphasize formant regions.
In animals.scm, the crow, for example, 
</p>

<pre>
    (load "animals.scm")
    (with-sound (:play #t) (american-crow 0 .5))
</pre>

<p>has three formant filters.  Without them, it would sound like this:
</p>

<pre>
    (with-sound (:play #t) (american-crow-no-formants 0 .5))
</pre>


<p>formant generators are also commonly used in a bank of filters to provide a sort of sample-by-sample spectrum.
An example is <a href="sndscm.html#fadedoc">fade.scm</a> which has various functions for frequency domain mixing.
See also 
<a href="sndscm.html#grapheq">grapheq</a> (a non-graphic equalizer), and
<a href="sndscm.html#crosssynthesis">cross-synthesis</a>.
Here's an example that moves a set of harmonically related formants through a sound.
If "radius" is .99, you get a glass-harmonica effect; if it's less, you get more of an FM index envelope effect.
</p>


<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (move-formants start file amp radius move-env num-formants)
  (let* ((frms (make-vector num-formants))
	 (beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> start))
	 (dur (<a class=quiet href="extsnd.html#mussoundframes" onmouseout="UnTip()" onmouseover="Tip(extsnd_mussoundframes_tip)">mus-sound-frames</a> file))
	 (end (+ beg dur))
	 (rd (<a class=quiet href="#make-readin" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_readin_tip)">make-readin</a> file))
	 (menv (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> move-env :length dur)))
    (let ((start-frq (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> menv)))
      (do ((i 0 (+ 1 i)))
	  ((= i num-formants))
	(set! (frms i) (<em class=red>make-formant</em> (* (+ i 1) start-frq) radius))))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
     (do ((k beg (+ 1 k)))
         ((= k end))
       (let ((sum 0.0)
	     (x (<a class=quiet href="#readin" onmouseout="UnTip()" onmouseover="Tip(sndclm_readin_tip)">readin</a> rd))
	     (frq (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> menv)))
	 (do ((i 0 (+ 1 i)))
	     ((= i num-formants))
	   (set! sum (+ sum (<em class=red>formant</em> (frms i) x)))
	   (let ((curfrq (* (+ i 1) frq)))
	     (if (&lt; (* 2 curfrq) (<a class=quiet href="#mussrate" onmouseout="UnTip()" onmouseover="Tip(sndclm_mussrate_tip)">mus-srate</a>))
	         (set! (<em class=red>mus-frequency</em> (frms i)) curfrq))))
         (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> k (* amp sum)))))))

(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () 
  (move-formants 0 "oboe.snd" 2.0 0.99 '(0 1200 1.6 2400 2 1400) 4))
</pre>
</td></tr></table>


<p>The clm-3 formant gain calculation was incorrect.  To translate from the old
formant to the new one, multiply the old gain by (* 2 (sin (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> frequency))).
</p>

<p>If you change the radius or frequency rapidly, the formant generator will either produce
clicks or overflow, but firmant gives good output.   Here's an
example that puts formant on the edge of disaster (the glitch is about to explode), but firmant plugs away happily:
</p>

<table border=0 hspace=20>
<tr>
<td width=500>
<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:channels 2)
  (let* ((dur 3)
	 (samps (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur))
	 (flta (<em class=red>make-formant</em> 100 .999))
	 (fltc (<em class=red>make-firmant</em> 100 .999))
	 (vib (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> 10))
	 (index (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> 100))
	 (click (<a class=quiet href="#make-ncos" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_ncos_tip)">make-ncos</a> 40 500)))
    (run
     (do ((i 0 (+ 1 i)))
         ((= i samps))
       (let* ((vib (* index (+ 1 (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> vib))))
	      (pulse (<a class=quiet href="#ncos" onmouseout="UnTip()" onmouseover="Tip(sndclm_ncos_tip)">ncos</a> click)))
	 (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* 10 (<em class=red>formant</em> flta pulse vib)))
	 (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outb</a> i (* 10 (<em class=red>firmant</em> fltc pulse vib))))))))
</pre>
</td><td>
<img src="pix/firmant.png" alt="firmant is happy" hspace=20>
</td>
</tr></table>

<br><br>



<A NAME="filterdoc"></A>
<A NAME="fir-filterdoc"></A>
<A NAME="iir-filterdoc"></A>
<!-- ---------------------------------------- FILTERS ---------------------------------------- -->
<br>
<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>filter, iir-filter, fir-filter</h3></center></td></tr></table>

<pre>
   <a class=def name="make-filter">make-filter</a> order xcoeffs ycoeffs
   <a class=def name="filter">filter</a> fl inp 
   <a class=def name="filter?">filter?</a> fl

   <a class=def name="make-fir-filter">make-fir-filter</a> order xcoeffs
   <a class=def name="fir-filter">fir-filter</a> fl inp 
   <a class=def name="fir-filter?">fir-filter?</a> fl

   <a class=def name="make-iir-filter">make-iir-filter</a> order ycoeffs
   <a class=def name="iir-filter">iir-filter</a> fl inp 
   <a class=def name="iir-filter?">iir-filter?</a> fl

   <a class=def name="make-fir-coeffs">make-fir-coeffs</a> order v
</pre>


<table border=1 bordercolor="lightgray" hspace=20 cellspacing=8 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t)
  (let ((flt (make-iir-filter 3 (vct 0.0 -1.978 0.998)))
	(ran1 (make-rand 10000.0 0.002)))
    (do ((i 0 (+ 1 i)))
	((= i 44100))
      (outa i (* 0.5 (iir-filter flt (rand ran1)))))))
</pre>
</td>

</tr><tr>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true) do
  flt = make_iir_filter(3, vct(0.0, -1.978, 0.998));
  ran1 = make_rand(10000.0, 0.002); 
  44100.times do |i|
    outa(i, 0.5 * iir_filter(flt, rand(ran1)), $output);
    end
  end.output
</pre>
</td>

</tr><tr>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  3 vct( 0.0 -1.978 0.998 ) make-iir-filter { flt }
  10000.0 0.002 make-rand { ran1 }
  44100 0 do
    i  flt  ran1 0 rand  iir-filter  f2/ *output* outa drop
  loop
; :play #t with-sound drop
</pre>
</td>
</tr>
</table>


<p>These are general FIR/IIR filters of arbitrary order.
The "order" argument is one greater than the nominal filter
order (it is the size of the coefficient array).
</p>

<table border=0 hspace=20 cellspacing=20><tr><td>
<table border=1 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>general filter methods</center></td></tr>
<tr><td><em class=gen>mus-order</em></td><td>filter order</td></tr>
<tr><td><em class=gen>mus-xcoeff</em></td><td>x (input) coeff</td></tr>
<tr><td><em class=gen>mus-xcoeffs</em></td><td>x (input) coeffs</td></tr>
<tr><td><em class=gen>mus-ycoeff</em></td><td>y (output) coeff</td></tr>
<tr><td><em class=gen>mus-ycoeffs</em></td><td>y (output) coeffs</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>current state (input values)</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>same as mus-order</td></tr>
</table>
</td>
<td>
<pre>
  (let ((xout 0.0))
    (set! (state 0) input)
    (do ((j (- order 1) (- j 1)))
        ((= j 0))
      (set! xout (+ xout (* (xcoeffs j) (state j))))
      (set! (state 0) (- (state 0) (* (ycoeffs j) (state j))))
      (set! (state j) (state (- j 1))))
    (+ xout (* (state 0) (xcoeffs 0))))
</pre>
</td>
</tr></table>

<p><a href="sndscm.html#dspdoc">dsp.scm</a> has a number of filter design functions,
and various specializations of the filter generators, including such
perennial favorites as biquad, butterworth, hilbert transform, and
notch filters. Similarly, <a href="sndscm.html#analogfilterdoc">analog-filter.scm</a> has
the usual IIR suspects: Butterworth, Chebyshev, Bessel, and Elliptic filters.
A biquad section can be implemented as:
</p>

<table border=0 hspace=40><tr><td>
<pre>
   (define (make-biquad a0 a1 a2 b1 b2) 
      (make-filter 3 (<a class=quiet href="extsnd.html#vct" onmouseout="UnTip()" onmouseover="Tip(extsnd_vct_tip)">vct</a> a0 a1 a2) (<a class=quiet href="extsnd.html#vct" onmouseout="UnTip()" onmouseover="Tip(extsnd_vct_tip)">vct</a> 0.0 b1 b2)))
</pre>
</td></tr></table>

<p>
The Hilbert transform can be implemented with an fir-filter:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(define* (make-hilbert-transform (len 30))
  (let* ((arrlen (+ 1 (* 2 len)))
         (arr (<a class=quiet href="extsnd.html#makevct" onmouseout="UnTip()" onmouseover="Tip(extsnd_makevct_tip)">make-vct</a> arrlen))
         (lim (if (even? len) len (+ 1 len))))
    (do ((i (- len) (+ 1 i)))
        ((= i lim))
      (let* ((k (+ i len))
             (denom (* pi i))
             (num (- 1.0 (cos (* pi i)))))
        (if (or (= num 0.0) (= i 0))
            (set! (arr k) 0.0)
            (set! (arr k) (* (/ num denom) 
                             (+ .54 (* .46 (cos (/ (* i pi) len)))))))))
    (<em class=red>make-fir-filter</em> arrlen arr)))

(define hilbert-transform <em class=red>fir-filter</em>)
</pre>
</td></tr></table>

<p>make-fir-coeffs translates a frequency response envelope (actually, evenly spaced points in a vct) into the corresponding FIR filter coefficients.
The order of the filter determines how close you
get to the envelope. 
</p>

<br>

<table border=3 bordercolor="tan" hspace=40><th bgcolor="beige">Filters</th>
<tr><td>
<blockquote><small>
<br>
lowpass filter: <a href="sndscm.html#makelowpass">make-lowpass</a> in dsp.scm<br>
highpass filter: <a href="sndscm.html#makehighpass">make-highpass</a> in dsp.scm<br>
bandpass filter: <a href="sndscm.html#makebandpass">make-bandpass</a> in dsp.scm<br>
bandstop filter: <a href="sndscm.html#makebandstop">make-bandstop</a> in dsp.scm<br>
Butterworth, Chebyshev, Bessel, Elliptic filters: <a href="sndscm.html#analogfilterdoc">analog-filter.scm</a><br>
Hilbert transform: <a href="sndscm.html#makehilberttransform">make-hilbert-transform</a> in dsp.scm<br>
differentiator: <a href="sndscm.html#makedifferentiator">make-differentiator</a> in dsp.scm<br>
block DC: dc-block in prc95.scm or (make-filter 2 (<a class=quiet href="extsnd.html#vct" onmouseout="UnTip()" onmouseover="Tip(extsnd_vct_tip)">vct</a> 1 -1) (<a class=quiet href="extsnd.html#vct" onmouseout="UnTip()" onmouseover="Tip(extsnd_vct_tip)">vct</a> 0 -0.99))<br>
hum elimination: <a href="sndscm.html#IIRfilters">eliminate-hum</a> and <a href="sndscm.html#notchchannel">notch-channel</a> in dsp.scm<br>
hiss elimination: <a href="sndscm.html#notchoutrumbleandhiss">notch-out-rumble-and-hiss</a><br>
smoothing filters: <a href="#moving-average">moving-average</a>, <a href="#weighted-moving-average">weighted-moving-average</a>, exponentially-weighted-moving-average<br>
notch-filters: <a href="sndscm.html#notchchannel">notch-channel</a> and <a href="sndscm.html#notchselection">notch-selection</a><br>
arbitrary spectrum via FIR filter: <a href="sndscm.html#spectrumtocoeffs">spectrum-&gt;coeffs</a> in dsp.scm<br>
invert an FIR filter: <a href="sndscm.html#invertfilter">invert-filter</a> in dsp.scm<br>
filtered echo sound effect: <a href="sndscm.html#zecho">flecho</a> in examp.scm<br>
time varying filter: fltit in examp.scm<br>
draw frequency response: use the <a href="snd.html#editenvelope">envelope editor</a> or <a href="snd.html#filtercontrol">filter control</a> in control panel<br>
Moog filter: <a href="sndscm.html#moogdoc">moog.scm</a><br>
Savitzky-Golay filter: <a href="sndscm.html#sgfilter">savitzky-golay-filter</a><br>
click reduction: <a href="sndscm.html#removeclicks">remove-clicks</a>, <a href="sndscm.html#cleanchannel">clean-channel</a><br>
graphical equalizer filter bank: <a href="sndscm.html#clminsdoc">graphEq</a><br>
nonlinear (Volterra) filter: <a href="sndscm.html#volterrafilter">volterra-filter</a><br>
Kalman filter: <a href="sndscm.html#kalmanfilterchannel">kalman-filter-channel</a><br>
filter a sound: <a href="extsnd.html#filtersound">filter-sound</a>, <a href="extsnd.html#filterchannel">filter-channel</a><br>
see also convolution, physical modeling, reverb, and <a href="sndscm.html#ssffts">fft-based filtering</a><br>
<br>
</small></blockquote>
</td></tr></table>
<br><br>



<A NAME="delaydoc"></A>
<!-- ---------------------------------------- DELAY ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>delay, tap</h3></center></td></tr></table>

<pre>
  <a class=def name="make-delay">make-delay</a> 
      size                  ; delay length
      initial-contents      ; delay line's initial values (a vct or a list)
      (initial-element 0.0) ; delay line's initial element
      max-size              ; maximum delay size in case the delay changes 
      type                  ; interpolation type
  <a class=def name="delay">delay</a> d input (pm 0.0)
  <a class=def name="delay?">delay?</a> d

  <a class=def name="tap">tap</a> d (offset 0)
  <a class=def name="delaytick">delay-tick</a> d input
</pre>


<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t)
  (let ((dly (make-delay (seconds-&gt;samples 0.5)))
        (osc1 (make-oscil 440.0))
        (osc2 (make-oscil 660.0)))
    (do ((i 0 (+ 1 i)))
        ((= i 44100))
      (outa i (* 0.5 
                 (+ (oscil osc1)
                    (delay dly 
                           (oscil osc2))))))))
</pre>
</td>

<td width=4></td>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true) do
  dly = make_delay(seconds2samples(0.5));
  osc1 = make_oscil(440.0);
  osc2 = make_oscil(660.0);
  44100.times do |i|
    outa(i, 
         0.5 * (oscil(osc1) + 
                delay(dly, oscil(osc2))), 
         $output);
    end
  end.output
</pre>
</td>

<td width=4></td>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  0.5 seconds-&gt;samples make-delay { dly }
  440.0 make-oscil { osc1 }
  660.0 make-oscil { osc2 }
  44100 0 do
    i
    osc1 0 0 oscil
    dly  osc2 0 0 oscil  0 delay f+
    f2/ *output* outa drop
  loop
; :play #t with-sound drop
</pre>
</td>
</tr>
</table>


<p>The delay generator is a delay line.  
The make-delay "size" argument sets the delay line length (in samples).
Input fed into a delay line reappears at the output size samples later. 
If "max-size" is specified in make-delay,
and it is larger than "size", the delay line can provide varying-length delays (including fractional amounts).
The delay generator's "pm" argument determines how far from the original "size" we are; that is,
it is difference between the length set by make-delay
and the current actual delay length, size + pm.  So, a positive "pm" corresponds to a longer
delay line.  See <a href="sndscm.html#zecho">zecho</a> in examp.scm for an example.
The make-delay "type" argument sets the interpolation type in the case of fractional delays:
mus-interp-none, mus-interp-linear, mus-interp-all-pass, 
mus-interp-lagrange, mus-interp-bezier, or mus-interp-hermite.
</p>

<table border=1 align=left hspace=40 vspace=10 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>delay methods</center></td></tr>
<tr><td><em class=gen>mus-length</em></td><td>length of delay</td></tr>
<tr><td><em class=gen>mus-order</em></td><td>same as mus-length</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>delay line itself (no set!)</td></tr>
<tr><td><em class=gen>mus-interp-type</em></td><td>interpolation choice (no set!)</td></tr>
<tr><td><em class=gen>mus-scaler</em></td><td>available for delay specializations</td></tr>
<tr><td><em class=gen>mus-location</em></td><td>current delay line write position</td></tr>
</table>
<br>
<pre>
(let ((result (<a class=quiet href="#array-interp" onmouseout="UnTip()" onmouseover="Tip(sndclm_array_interp_tip)">array-interp</a> line (- loc pm))))
  (set! (line loc) input)
  (set! loc (+ 1 loc))
  (if (&lt;= size loc) (set! loc 0))
  result)
</pre>
<br clear=left>
<br>

<p>
The tap function taps a delay line at a given offset from the output point.
delay-tick is a function that just puts a sample in the delay line, 'ticks' the delay forward, and
returns its "input" argument.  
See prc95.scm for examples of both of these functions.
</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (echo beg dur scaler secs file)
  (let ((del (<em class=red>make-delay</em> (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> secs)))
        (rd (make-sampler 0 file)))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
     (do ((i beg (+ 1 i)))
         ((= i (+ beg dur)))
       (let ((inval (rd)))
         (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (+ inval (<em class=red>delay</em> del (* scaler (+ (<em class=red>tap</em> del) inval))))))))))

(<a class=quiet href="sndscm.html#withsound" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () (echo 0 60000 .5 1.0 "pistol.snd"))
</pre>
</td></tr></table>

<p>The <a href="#mus-scaler">mus-scaler</a> field is available for simple extensions of the delay.  For example,
the <a href="#moving-max">moving-max</a> generator uses mus-scaler to track the current maximum sample value
in the delay line; the result is an envelope that tracks the peak amplitude in the
last "size" samples.
The <a href="#mus-location">mus-location</a> field returns the current delay line write position.
To access the delay line contents as a sliding window on the input data, use:
</p>

<pre>
  (define (delay-ref dly loc)
    (vct-ref (mus-data dly) (modulo (+ loc (<em class=red>mus-location</em> dly)) (mus-length dly))))
</pre>

<p>
The delay generator is used in some reverbs (<a href="sndscm.html#nrev">nrev</a>), many physical
models (<a href="sndscm.html#stereoflute">stereo-flute</a>), <a href="sndscm.html#dlocsigdoc">dlocsig</a>,
chorus effects (<a href="sndscm.html#chorus">chorus</a> in dsp.scm), and flanging (<a href="sndscm.html#neweffectsdoc">new-effects</a>),
and is the basis for about a dozen extensions (comb and friends below).
</p>

<br><br>




<A NAME="combdoc"></A>
<A NAME="notchdoc"></A>
<!-- ---------------------------------------- COMB, NOTCH ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>comb, notch</h3></center></td></tr></table>

<pre>
  <a class=def name="make-comb">make-comb</a> (scaler 1.0) size initial-contents (initial-element 0.0) max-size
  <a class=def name="comb">comb</a> cflt input (pm 0.0)
  <a class=def name="comb?">comb?</a> cflt

  <a class=def name="make-filtered-comb">make-filtered-comb</a> (scaler 1.0) size initial-contents (initial-element 0.0) max-size filter
  <a class=def name="filtered-comb">filtered-comb</a> cflt input (pm 0.0)
  <a class=def name="filtered-comb?">filtered-comb?</a> cflt

  <a class=def name="make-notch">make-notch</a> (scaler 1.0) size initial-contents (initial-element 0.0) max-size
  <a class=def name="notch">notch</a> cflt input (pm 0.0)
  <a class=def name="notch?">notch?</a> cflt
</pre>


<table border=1 bordercolor="lightgray" hspace=20 cellspacing=8 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t)
  (let ((cmb (make-comb 0.4 (seconds-&gt;samples 0.4)))
        (osc (make-oscil 440.0))
        (ampf (make-env '(0 0 1 1 2 1 3 0) :length 4410)))
    (do ((i 0 (+ 1 i)))
	((= i 88200))
      (outa i (* 0.5 (comb cmb (* (env ampf) (oscil osc))))))))
</pre>
</td>

</tr><tr>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true) do
  cmb = make_comb(0.4, seconds2samples(0.4));
  osc = make_oscil(440.0);
  ampf = make_env([0.0, 0.0, 1.0, 1.0, 2.0, 1.0, 3.0, 0.0], :length, 4410);
  88200.times do |i|
    outa(i, 0.5 * (comb(cmb, env(ampf) * oscil(osc))), $output);
    end
  end.output
</pre>
</td>

</tr><tr>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  0.4 0.4 seconds-&gt;samples make-comb { cmb }
  440.0 make-oscil { osc }
  '( 0 0 1 1 2 1 3 0 ) :length 4410 make-env { ampf }
  88200 0 do
    i
    cmb ( gen )
    ampf env  osc 0 0 oscil  f* ( val )
    0 ( pm )
    comb f2/ *output* outa drop
  loop
; :play #t with-sound drop
</pre>
</td>
</tr>
</table>


<p>The comb generator is a delay line with a scaler on the feedback.  notch
is a delay line with a scaler on the current input.
filtered-comb is a comb filter with a filter on the feedback.  
Although normally this is a <a href="#one-zero">one-zero</a> filter, it can be any CLM generator.
The make-&lt;gen&gt; "size" argument sets the length
in samples of the delay line,
and the other arguments are also handled as in <a href="#delay">delay</a>.
</p>

<table border=0><tr><td>
<table border=1 hspace=40 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>comb, filtered-comb, and notch methods</center></td></tr>
<tr><td><em class=gen>mus-length</em></td><td>length of delay</td></tr>
<tr><td><em class=gen>mus-order</em></td><td>same as mus-length</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>delay line itself (no set!)</td></tr>
<tr><td><em class=gen>mus-feedback</em></td><td>scaler (comb only)</td></tr>
<tr><td><em class=gen>mus-feedforward</em></td><td>scaler (notch only)</td></tr>
<tr><td><em class=gen>mus-interp-type</em></td><td>interpolation choice (no set!)</td></tr>
</table>
</td>
<td>


<pre>
 comb:           y(n) = x(n - size) + scaler * y(n - size)
 notch:          y(n) = x(n) * scaler  + x(n - size)
 filtered-comb:  y(n) = x(n - size) + scaler * filter(y(n - size))
</pre>

<img src="pix/comb.png" alt="sonogram of comb" vspace=10>

<!-- 1024 blackman2 dB jet light=1 data-cutoff around .009 invert off using the local zc (not clm-ins!): (with-sound (:srate 44100) (zc 0 2 2000 .1 100 1000 .99))
-->

</td></tr></table>


<p>As a rule of thumb, the decay time of the feedback is
7.0 * size / (1.0 - scaler) samples, so to get a decay of feedback-dur seconds,
</p>
<pre>
    (make-comb :size size :scaler (- 1.0 (/ (* 7.0 size) (* feedback-dur (<a class=quiet href="#mussrate" onmouseout="UnTip()" onmouseover="Tip(sndclm_mussrate_tip)">mus-srate</a>)))))
</pre>

<p>The peak gain is 1.0 / (1.0 - (abs scaler)).  The peaks (or valleys in notch's case) are evenly spaced
at (<a class=quiet href="#mussrate" onmouseout="UnTip()" onmouseover="Tip(sndclm_mussrate_tip)">mus-srate</a>) / size. The height (or depth) thereof is determined by scaler &mdash;
the closer to 1.0 it is, the more pronounced the dips or peaks.
See Julius Smith's "An Introduction to Digital Filter Theory" in
Strawn "Digital Audio Signal Processing", or Smith's "Music Applications of
Digital Waveguides".
The following instrument sweeps the comb filter using the pm argument:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (zc time dur freq amp length1 length2 feedback)
  (let* ((beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> time))
         (end (+ beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur)))
         (s (<a class=quiet href="#make-pulse-train" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_pulse_train_tip)">make-pulse-train</a> :frequency freq))  ; some raspy input so we can hear the effect easily
         (d0 (<em class=red>make-comb</em> :size length1 :max-size (max length1 length2) :scaler feedback))
         (aenv (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 .1 1 .9 1 1 0) :scaler amp :duration dur))
         (zenv (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1) :scaler (- length2 length1) :base 12.0 :duration dur)))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
      (do ((i beg (+ 1 i))) ((= i end))
        (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> aenv) (<em class=red>comb</em> d0 (<a class=quiet href="#pulse-train" onmouseout="UnTip()" onmouseover="Tip(sndclm_pulse_train_tip)">pulse-train</a> s) (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> zenv))))))))

(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () 
  (zc 0 3 100 .1 20 100 .5) 
  (zc 3.5 3 100 .1 90 100 .95))
</pre></td></tr></table>

<p>The comb filter can produce some nice effects; here's one that treats the comb filter's
delay line as the coefficients for an FIR filter:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(define (fir+comb beg dur freq amp size)
  (let* ((start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> beg))
         (end (+ start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur)))
         (dly (<em class=red>make-comb</em> :scaler .9 :size size)) 
         (flt (<a class=quiet href="#make-fir-filter" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_fir_filter_tip)">make-fir-filter</a> :order size :xcoeffs (<em class=red>mus-data</em> dly))) ; comb delay line as FIR coeffs
         (r (<a class=quiet href="#make-rand" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_rand_tip)">make-rand</a> freq)))                                       ; feed comb with white noise
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a> 
     (do ((i start (+ 1 i))) 
         ((= i end)) 
       (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* amp (<a class=quiet href="#fir-filter" onmouseout="UnTip()" onmouseover="Tip(sndclm_fir_filter_tip)">fir-filter</a> flt (<em class=red>comb</em> dly (<a class=quiet href="#rand" onmouseout="UnTip()" onmouseover="Tip(sndclm_rand_tip)">rand</a> r)))))))))

(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () 
  (fir+comb 0 2 10000 .001 200)
  (fir+comb 2 2 1000 .0005 400)
  (fir+comb 4 2 3000 .001 300)
  (fir+comb 6 2 3000 .0005 1000))
</pre></td></tr></table>

<p>Here's another that fluctuates between two sets of combs; it usually works best with voice sounds:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (flux start-time file frequency combs0 combs1 (scaler 0.99) (comb-len 32))
  (let* ((beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> start-time))
         (len (<a class=quiet href="extsnd.html#mussoundframes" onmouseout="UnTip()" onmouseover="Tip(extsnd_mussoundframes_tip)">mus-sound-frames</a> file))
         (end (+ beg len))
         (num-combs0 (length combs0))
         (num-combs1 (length combs1))
         (cmbs0 (make-vector num-combs0))
         (cmbs1 (make-vector num-combs1))
         (osc (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> frequency))
         (rd (<a class=quiet href="#make-readin" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_readin_tip)">make-readin</a> file)))
    (do ((k 0 (+ 1 k)))
        ((= k num-combs0))
      (set! (cmbs0 k)
            (<em class=red>make-comb</em> scaler 
              (floor (* comb-len (combs0 k))))))
    (do ((k 0 (+ 1 k)))
        ((= k num-combs1))
      (set! (cmbs1 k)
            (<em class=red>make-comb</em> scaler 
              (floor (* comb-len (combs1 k))))))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
     (do ((i beg (+ 1 i)))
         ((= i end))
       (let* ((interp (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> osc))
              (sum0 0.0)
              (sum1 0.0)
              (x (<a class=quiet href="#readin" onmouseout="UnTip()" onmouseover="Tip(sndclm_readin_tip)">readin</a> rd)))
         (do ((k 0 (+ 1 k)))
             ((= k num-combs0))
           (set! sum0 (+ sum0 (<em class=red>comb</em> (cmbs0 k) x))))
         (do ((k 0 (+ 1 k)))
             ((= k num-combs1))
           (set! sum1 (+ sum1 (<em class=red>comb</em> (cmbs1 k) x))))
         (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (+ (* interp sum0) (* (- 1.0 interp) sum1))))))))

(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:scaled-to .5) 
  (flux 0 "oboe.snd" 10.0 '(1.0 1.25 1.5) '(1.0 1.333 1.6)) ; bowed oboe?
  (flux 2 "now.snd" 4.0 '(1.0 1.25 1.5) '(1.0 1.333 1.6 2.0 3.0))
  (flux 4 "now.snd" 1.0 '(1.0 1.25 1.5) '(1.0 1.333 1.6 2.0 3.0) 0.995 20)
  (flux 6 "now.snd" 10.0 '(1.0 1.25 1.5) '(1.0 1.333 1.6 2.0 3.0) 0.99 10)
  (flux 8 "now.snd" 10.0 '(2.0) '(1.0 1.333 1.6 2.0 3.0) 0.99 120)
  (flux 10 "fyow.snd" .50 '(1.0 2.0 1.5) '(1.0 1.333 1.6 2.0 3.0) 0.99 120))
</pre></td></tr></table>


<p>For more comb filter examples,
see examp.scm, <a href="sndscm.html#chordalize">chordalize</a> in dsp.scm, or
any of the standard reverbs such as <a href="sndscm.html#nrev">nrev</a>. 
filtered-comb is used in <a href="sndscm.html#freeverb">freeverb</a>
where a <a href="#one-zero">one-zero</a> filter is placed
in the feedback loop:
</p>
<pre>
    (make-filtered-comb :size len :scaler room-decay-val :filter (make-one-zero :a0 (- 1.0 dmp) :a1 dmp))
</pre>

<br><br>



<A NAME="all-passdoc"></A>
<!-- ---------------------------------------- ALL-PASS ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>all-pass</h3></center></td></tr></table>

<pre>
  <a class=def name="make-all-pass">make-all-pass</a> 
        (feedback 0.0) 
        (feedforward 0.0)
        size 
        initial-contents 
        (initial-element 0.0) 
        max-size

  <a class=def name="all-pass">all-pass</a> f input (pm 0.0)
  <a class=def name="all-pass?">all-pass?</a> f
</pre>


<table border=1 bordercolor="lightgray" hspace=20 cellspacing=12 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t)
  (let ((alp (make-all-pass -0.4 0.4 (seconds-&gt;samples 0.4)))
        (osc (make-oscil 440.0))
        (ampf (make-env '(0 0 1 1 2 1 3 0) :length 4410)))
    (do ((i 0 (+ 1 i)))
        ((= i 88200))
      (outa i (* 0.5 (all-pass alp (* (env ampf) (oscil osc))))))))
</pre>
</td>
</tr>
<tr>
<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true) do
  alp = make_all_pass(-0.4, 0.4, seconds2samples(0.4));
  osc = make_oscil(440.0);
  ampf = make_env([0.0, 0.0, 1.0, 1.0, 2.0, 1.0, 3.0, 0.0], :length, 4410);
  88200.times do |i|
    outa(i, 0.5 * (all_pass(alp, env(ampf) * oscil(osc))), $output);
    end
  end.output
</pre>
</td>
</tr>

<tr>
<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  -0.4 0.4 0.4 seconds-&gt;samples make-all-pass { alp }
  440.0 make-oscil { osc }
  '( 0 0 1 1 2 1 3 0 ) :length 4410 make-env { ampf }
  88200 0 do
    i
    alp ( gen )
    ampf env  osc 0 0 oscil  f* ( val )
    0 ( pm )
    all-pass f2/ *output* outa drop
  loop
; :play #t with-sound drop
</pre>
</td>

</tr>
</table>


<p>The all-pass or moving average comb generator is just like <a href="#comb">comb</a> but with
an added scaler on the input ("feedforward" is Julius Smith's suggested name for it).  If feedforward is 0.0, we get a
comb filter.  If both scale terms are 0.0, we get a pure delay line. 
</p>

<table border=1 align=left hspace=40 vspace=10 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>all-pass methods</center></td></tr>
<tr><td><em class=gen>mus-length</em></td><td>length of delay</td></tr>
<tr><td><em class=gen>mus-order</em></td><td>same as mus-length</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>delay line itself (no set!)</td></tr>
<tr><td><em class=gen>mus-feedback</em></td><td>feedback scaler</td></tr>
<tr><td><em class=gen>mus-feedforward</em></td><td>feedforward scaler</td></tr>
<tr><td><em class=gen>mus-interp-type</em></td><td>interpolation choice (no set!)</td></tr>
</table>
<br>

<pre>
 y(n) = feedforward * x(n) + x(n - size) + feedback * y(n - size)
</pre><br clear=left>

<p>all-pass filters are used extensively in reverberation; 
see <a href="sndscm.html#jcrevdoc">jcrev</a> or <a href="sndscm.html#nrev">nrev</a>.
To get the "all-pass" behavior, set feedback equal to -feedforward. Here's an example
(based on John Chowning's ancient reverb) that was inspired by the bleed-through you get on
old analog tapes &mdash; the reverb slightly precedes the direct signal:
</p>

<table border=0 hspace=40>
<tr><td>
<pre>
(define (later file dly rev)
  (let* ((allpass1 (<em class=red>make-all-pass</em> -0.700 0.700 1051))
         (allpass2 (<em class=red>make-all-pass</em> -0.700 0.700  337))
         (allpass3 (<em class=red>make-all-pass</em> -0.700 0.700  113))
         (comb1 (make-comb 0.742 4799))
         (comb2 (make-comb 0.733 4999))
         (comb3 (make-comb 0.715 5399))
         (comb4 (make-comb 0.697 5801))
         (file-dur (mus-sound-frames file))
         (decay-dur (mus-srate))
         (len (floor (+ decay-dur file-dur)))
         (rd (make-readin file)) ; the direct signal (via sound-let below)
         (d (make-delay dly))    ; this delays the direct signal
         (backup (min 4799 dly)))
    (run
     (do ((i 0 (+ 1 i)))
         ((= i len))
       (let* ((inval (readin rd))
              (allpass-sum (<em class=red>all-pass</em> allpass3 
                             (<em class=red>all-pass</em> allpass2 
                               (<em class=red>all-pass</em> allpass1 
                                 (* rev inval)))))
              (comb-sum 
               (+ (comb comb1 allpass-sum)
                  (comb comb2 allpass-sum)
                  (comb comb3 allpass-sum)
                  (comb comb4 allpass-sum)))
              (orig (delay d inval)))  
         (if (&gt;= i backup)
             (outa (- i backup) (+ comb-sum orig))))))))

(with-sound () 
  (sound-let ((tmp () (fm-violin 0 .1 440 .1))) 
    (later tmp 10000 .1)))
</pre>
</td>
</tr>
</table>

<br><br>




<A NAME="moving-averagedoc"></A>
<!-- ---------------------------------------- MOVING-AVERAGE ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>moving-average</h3></center></td></tr></table>

<pre>
  <a class=def name="make-moving-average">make-moving-average</a> size initial-contents (initial-element 0.0)
  <a class=def name="moving-average">moving-average</a> f input
  <a class=def name="moving-average?">moving-average?</a> f
</pre>


<table border=1 bordercolor="lightgray" hspace=20 cellspacing=8 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t)
  (let ((avg (make-moving-average 4410))
	(osc (make-oscil 440.0))
	(stop (- 44100 4410)))
    (do ((i 0 (+ 1 i)))
	((= i stop))
      (let ((val (oscil osc)))
	(outa i (* val (moving-average avg (abs val))))))
    (do ((i stop (+ 1 i)))
	((= i 44100))
      (outa i (* (oscil osc) (moving-average avg 0.0))))))
</pre>
</td>

</tr><tr>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true) do
  avg = make_moving_average(4410);
  osc = make_oscil(440.0);
  stop = 44100 - 4410;
  stop.times do |i|
    val = oscil(osc);
    outa(i, val * moving_average(avg, val.abs), $output);
    end
  4410.times do |i|
    outa(stop + i, oscil(osc) * moving_average(avg, 0.0), $output);
    end
  end.output</pre>
</td>

</tr><tr>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  4410 make-moving-average { avg }
  440.0 make-oscil { osc }
  44100 4410 - { stop }
  0.0 { val }
  stop 0 do
    osc 0 0 oscil to val
    i  avg val fabs moving-average  val f* *output* outa drop
  loop
  44100 stop do
    i  avg 0.0 moving-average  osc 0 0 oscil f*  *output* outa drop
  loop
; :play #t with-sound drop
</pre>
</td>
</tr>
</table>



<p>The moving-average or moving window average generator returns the average of the last "size" values input to it.
</p>

<table align=left border=1 hspace=40 vspace=10 cellpadding=4>
<tr><td colspan=2 bgcolor="beige"><center>moving-average methods</center></td></tr>
<tr><td><em class=gen>mus-length</em></td><td>length of table</td></tr>
<tr><td><em class=gen>mus-order</em></td><td>same as mus-length</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>table of last 'size' values</td></tr>
</table>
<br>

<pre>
result = sum-of-last-n-inputs / n
</pre>
<br clear=left>

<p>
moving-average is used both to track rms values and to generate ramps between 0 and 1 in a "gate"
effect in new-effects.scm and in rms-envelope in env.scm.  It can also be viewed as a low-pass filter.
And 
in <a href="sndscm.html#soundstosegmentdata">sounds-&gt;segment-data</a> in examp.scm, it is used to segment a sound library.
Here is an example (from new-effects.scm) that implements a "squelch" effect,
throwing away any samples below a threshhold, and ramping between portions
that are squelched and those that are unchanged (to avoid clicks):
</p>

<table border=0 hspace=40><tr><td>
<pre>
(define (squelch-channel amount snd chn gate-size)  ; gate-size = ramp length and rms window length
  (let ((gate (<em class=red>make-moving-average</em> gate-size))
        (ramp (<em class=red>make-moving-average</em> gate-size :initial-element 1.0)))
    (<a class=quiet href="extsnd.html#mapchannel" onmouseout="UnTip()" onmouseover="Tip(extsnd_mapchannel_tip)">map-channel</a> (lambda (y) 
                   (* y (<em class=red>moving-average</em> ramp                           ; ramp between 0 and 1
                          (if (&lt; (<em class=red>moving-average</em> gate (* y y)) amount) ; local (r)ms value
                              0.0                               ; below "amount" so squelch
                            1.0))))
                 0 #f snd chn)))
</pre>
</td></tr></table>

<p>See also generators.scm for several related functions:
<a href="#moving-max">moving-max</a>,
<a href="#moving-rms">moving-rms</a>, <a href="#moving-sum">moving-sum</a>, 
<a href="#moving-length">moving-length</a>, <a href="#weighted-moving-average">weighted-moving-average</a>, and 
<a href="#exponentially-weighted-moving-average">exponentially-weighted-moving-average</a>
(the latter being just a one-pole filter).
</p>
<br><br>




<A NAME="srcdoc"></A>
<!-- ---------------------------------------- SRC ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>src</h3></center></td></tr></table>

<pre>
  <a class=def name="make-src">make-src</a> input (srate 1.0) (width 5)
  <a class=def name="src">src</a> s (sr-change 0.0) input-function
  <a class=def name="src?">src?</a> s
</pre>


<table border=1 bordercolor="lightgray" hspace=20 cellspacing=8 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t :srate 22050)
  (let* ((rd (make-readin "oboe.snd"))
         (len (* 2 (mus-sound-frames "oboe.snd")))
         (sr (make-src rd 0.5)))
    (do ((i 0 (+ 1 i)))
        ((= i len))
      (outa i (src sr)))))
</pre>
</td>
</tr>
<tr>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true, :srate, 22050) do
  rd = make_readin("oboe.snd");
  len = 2 * mus_sound_frames("oboe.snd");
  sr = make_src(lambda do |dir| 
                 readin(rd) end, 0.5);
  len.times do |i|
    outa(i, src(sr), $output);
    end
  end.output
</pre>
</td>
</tr>
<tr>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  "oboe.snd" make-readin { rd }
  rd 0.5 make-src { sr }
  "oboe.snd" mus-sound-frames 2* ( len ) 0 do
    i  sr 0 #f src  *output* outa drop
  loop
; :play #t :srate 22050 with-sound drop
</pre>
</td>

</tr>
<tr>

<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t)
  (let ((osc (make-oscil 440.0))
        (sr (make-src :srate 2.0)))
    (do ((i 0 (+ 1 i)))
        ((= i 44100))
      (outa i (src sr 0.0 (lambda (dir) (oscil osc)))))))
</pre>
</td>
</tr>
<tr>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true) do
  osc = make_oscil(440.0);
  sr = make_src(:srate, 2.0);
  44100.times do |i|
    outa(i, src(sr, 0.0, lambda do |dir| 
                           oscil(osc) 
                           end), 
                    $output);
    end
  end.output
</pre>
</td>
</tr>
<tr>

<td bgcolor="#effdef">
<pre>
: make-src-proc { osc -- prc; dir self -- val }
  1 proc-create osc , ( prc )
 does> { dir self -- val }
  self @ ( osc ) 0 0 oscil
;

lambda: ( -- )
  440.0 make-oscil { osc }
  osc make-src-proc { prc }
  :srate 2.0 make-src { sr }
  44100 0 do
    i  sr 0 prc src  *output* outa drop
  loop
; :play #t with-sound drop
</pre>
</td>

</tr>
</table>



<p>The src generator performs sampling rate conversion
by convolving its input with a sinc
function.
make-src's "srate" argument is the
ratio between the old sampling rate and the new;  an srate of 2 causes the sound to be half as long, transposed up an octave.
</p>

<table border=1 cellpadding=4 hspace=40 vspace=10>
<tr><td colspan=2 bgcolor="beige"><center>src methods</center></td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>srate arg to make-src</td></tr>
</table>


<p>
The "width" argument sets how many neighboring samples to convolve with the sinc function.
If you hear high-frequency artifacts in the conversion, try increasing this number;
Perry Cook's default value is 40, and I've seen cases where it needs to be 100.
It can also be set as low as 2 in some cases.
The greater the width, the slower the src generator runs.
</p>

<p>
The src generator's "sr-change"
argument is the amount to add to the current srate on a sample by sample
basis (if it's 0.0 and the original make-src srate argument was also 0.0, you get a constant output because the generator is not moving at all).  
Here's
an instrument that provides time-varying sampling rate conversion:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (simple-src start-time duration amp srt srt-env filename)
  (let* ((senv (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> srt-env :duration duration))
         (beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> start-time))
         (end (+ beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> duration)))
         (src-gen (<em class=red>make-src</em> :input (<a class=quiet href="#make-readin" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_readin_tip)">make-readin</a> filename) :srate srt)))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
      (do ((i beg (+ 1 i)))
          ((= i end))
        (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* amp (<em class=red>src</em> src-gen (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> senv))))))))

(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () (simple-src 0 4 1.0 0.5 '(0 1 1 2) "oboe.snd"))
</pre>
</td></tr></table>

<p>src can provide an all-purpose "Forbidden Planet" sound effect:</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (<A NAME="srcer">srcer</A> start-time duration amp srt fmamp fmfreq filename)
  (let* ((os (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> fmfreq))
         (beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> start-time))
         (end (+ beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> duration)))
         (src-gen (<em class=red>make-src</em> :input (<a class=quiet href="#make-readin" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_readin_tip)">make-readin</a> filename) :srate srt)))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
      (do ((i beg (+ 1 i)))
          ((= i end))
        (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* amp (<em class=red>src</em> src-gen (* fmamp (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> os)))))))))

(<a class=quiet href="sndscm.html#withsound" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () (srcer 0 2 1.0   1 .3 20 "fyow.snd"))   
(<a class=quiet href="sndscm.html#withsound" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () (srcer 0 25 10.0   .01 1 10 "fyow.snd"))
(<a class=quiet href="sndscm.html#withsound" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () (srcer 0 2 1.0   .9 .05 60 "oboe.snd")) 
(<a class=quiet href="sndscm.html#withsound" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () (srcer 0 2 1.0   1.0 .5 124 "oboe.snd"))
(<a class=quiet href="sndscm.html#withsound" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () (srcer 0 2 10.0   .01 .2 8 "oboe.snd"))
(<a class=quiet href="sndscm.html#withsound" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () (srcer 0 2 1.0   1 3 20 "oboe.snd"))    
</pre>
</td></tr></table>

<p>The "input" argument to make-src and the "input-function" argument
to src provide the generator with input as it is needed. 
The input function
is a function of one argument (the desired read direction, if the reader can support it), that is called each time src needs another
sample of input. Here's an example instrument that reads a file with an envelope on the src:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(definstrument (src-change filename start-time duration file-start srcenv)
  (let* ((beg (seconds-&gt;samples start-time))
         (end (+ beg (seconds-&gt;samples duration)))
	 (loc (seconds-&gt;samples file-start))
         (src-gen (make-src :srate 0.0))
	 (e (make-env srcenv :duration duration))
	 (inp (make-file-&gt;sample filename)))
    (run
     (do ((i beg (+ i 1)))
	 ((= i end))
       (outa i (src src-gen (env e) 
		 (<em class=red>lambda (dir)</em>  ; our input function
		   (set! loc (+ loc dir))
		   (ina loc inp))))))))

;;; (with-sound () (src-change "pistol.snd" 0 2 0 '(0 0.5 1 -1.5)))
</pre>
</td></tr></table>

<p>
If you jump around in the input (via mus-location for example), use
<a href="#mus-reset">mus-reset</a> to clear out any lingering state before starting to read at
the new position. (src, like many other generators, has an internal buffer
of recently read samples, so a sudden jump to a new location will otherwise cause
a click).
</p>

<p>There are several other ways to resample a sound.  Some of the more interesting ones are in
dsp.scm (<a href="sndscm.html#downoct">down-oct</a>, <a href="sndscm.html#soundinterp">sound-interp</a>, 
<a href="sndscm.html#linearsrcchannel">linear-src</a>, etc).  To calculate a sound's new duration after
a time-varying src is applied, use <a href="sndscm.html#srcduration">src-duration</a>.  To scale an src
envelope so that the result has a given duration, use <a href="sndscm.html#srcfitenvelope">scr-fit-envelope</a>.
</p>

<br><br>




<A NAME="convolvedoc"></A>
<!-- ---------------------------------------- CONVOLVE ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>convolve</h3></center></td></tr></table>

<pre>
  <a class=def name="make-convolve">make-convolve</a> input filter fft-size filter-size
  <a class=def name="convolve">convolve</a> ff input-function
  <a class=def name="convolve?">convolve?</a> ff

  <a class=def name="convolvefiles">convolve-files</a> file1 file2 (maxamp 1.0) (output-file "tmp.snd")
</pre>


<table border=1 bordercolor="lightgray" hspace=20 cellspacing=8 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t :statistics #t)
  (let ((cnv (make-convolve 
              (make-readin "pistol.snd")
              (file-&gt;vct "oboe.snd")))) ; file-&gt;vct is in examp.scm
    (do ((i 0 (+ 1 i)))
	((= i 88200))
      (outa i (* 0.25 (convolve cnv))))))
</pre>
</td>
</tr>
<tr>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true, :statistics, true) do
  rd = make_readin("oboe.snd");
  flt = file2vct("pistol.snd"); # examp.rb
  cnv = make_convolve(lambda { |dir| readin(rd)}, flt);
  88200.times do |i|
    outa(i, 0.25 * convolve(cnv), $output);
    end
  end.output
</pre>
</td>
</tr>
<tr>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  "pistol.snd" make-readin ( rd )
  "oboe.snd" file-&gt;vct ( v ) make-convolve { cnv }
  88200 0 do
    i  cnv #f convolve  0.25 f* *output* outa drop
  loop
; :play #t :statistics #t with-sound drop
</pre>
</td>

</tr>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t)
  (let* ((tempfile (convolve-files "oboe.snd" 
  		   		   "pistol.snd" 0.5 
				   "convolved.snd"))
	 (len (mus-sound-frames tempfile))
	 (reader (make-readin tempfile)))
    (do ((i 0 (+ 1 i)))
	((= i len))
      (outa i (readin reader)))
    (delete-file tempfile)))
</pre>
</td>
</tr>
<tr>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true) do
  tempfile = convolve_files("oboe.snd", 
  	                    "pistol.snd", 0.5, 
			    "convolved.snd");
  len = mus_sound_frames(tempfile);
  reader = make_readin(tempfile);
  len.times do |i|
    outa(i, readin(reader), $output);
    end
  File.unlink(tempfile)
  end.output
</pre>
</td>
</tr>
<tr>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  "oboe.snd" "pistol.snd" 0.5 "convolved.snd" convolve-files { tempfile }
  tempfile make-readin { reader }
  tempfile mus-sound-frames ( len ) 0 do
    i  reader readin  *output* outa drop
  loop
  tempfile file-delete
; :play #t with-sound drop
</pre>
</td>

</tr>
</table>



<p>The convolve generator convolves its input with the impulse response "filter" (a vct).
"input" and "input-function" are functions of one argument that are
called whenever convolve needs input.
</p>

<table border=1 cellpadding=4 hspace=40 vspace=10>
<tr><td colspan=2 bgcolor="beige"><center>convolve methods</center></td></tr>
<tr><td><em class=gen>mus-length</em></td><td>fft size used in the convolution</td></tr>
</table>


<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (convins beg dur filter file (size 128))
  (let* ((start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> beg))
         (end (+ start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur)))
         (ff (<em class=red>make-convolve</em> :input (<a class=quiet href="#make-readin" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_readin_tip)">make-readin</a> file) :fft-size size :filter filter)))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
      (do ((i start (+ 1 i)))
          ((= i end))
        (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (<em class=red>convolve</em> ff))))))

(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () 
  (convins 0 2 (<a class=quiet href="extsnd.html#vct" onmouseout="UnTip()" onmouseover="Tip(extsnd_vct_tip)">vct</a> 1.0 0.5 0.25 0.125) "oboe.snd")) ; same as fir-filter with those coeffs
</pre>
</td></tr></table>

<p>convolve-files handles a very common special case: convolve
two files, then normalize the result to some maxamp.  The convolve generator does not
know in advance what its maxamp will be, and when the two files are more or less
the same size, there's no real computational savings to using overlap-add (i.e.
the generator), so a one-time giant FFT saved as a temporary sound file is much
handier.  If you're particular about the format of the convolved data:
</p>


<table border=0 hspace=40><tr><td>
<pre>
(define* (convolve-files-&gt;aifc file1 file2 (maxamp 1.0) (output-file "test.snd"))
  (let ((outname (string-append "temp-" output-file)))
    (<em class=red>convolve-files</em> file1 file2 maxamp outname)
    (with-sound (:header-type mus-aifc :data-format mus-bfloat)
      (let ((len (seconds-&gt;samples (mus-sound-duration outname)))
	    (reader (make-readin outname)))
	(run 
          (do ((i 0 (+ i 1)))
	      ((= i len))
	    (outa i (readin reader))))))
    (delete-file outname)
    output-file))
</pre>
</td></tr></table>


<p>The convolve generator is the modern way to add reverb.  There are impulse responses of various concert
halls floating around the web.  convolve and <a href="#fir-filter">fir-filter</a> actually perform the same mathematical operation,
but convolve uses an FFT internally, rather than a laborious dot-product.
</p>

<br><br>



<A NAME="granulatedoc"></A>
<!-- ---------------------------------------- GRANULATE ---------------------------------------- -->

<!-- INDEX grains:Granular synthesis --><A class=def NAME="grains"></a>
<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>granulate</h3></center></td></tr></table>

<pre>
  <a class=def name="make-granulate">make-granulate</a>   
        input
        (expansion 1.0)   ; how much to lengthen or compress the file
        (length .15)      ; length of file slices that are overlapped
        (scaler .6)       ; amplitude scaler on slices (to avoid overflows)
        (hop .05)         ; speed at which slices are repeated in output
        (ramp .4)         ; amount of slice-time spent ramping up/down
        (jitter 1.0)      ; affects spacing of successive grains
        max-size          ; internal buffer size
        edit              ; grain editing function

  <a class=def name="granulate">granulate</a> e input-function edit-function
  <a class=def name="granulate?">granulate?</a> e
</pre>


<table border=1 bordercolor="lightgray" hspace=20 cellspacing=8 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t)
  (let ((grn (make-granulate (make-readin "oboe.snd") 2.0)))
    (do ((i 0 (+ 1 i)))
	((= i 44100))
      (outa i (granulate grn)))))
</pre>
</td>
</tr>
<tr>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true) do
  rd = make_readin("oboe.snd");
  grn = make_granulate(lambda do |dir| readin(rd) end, 2.0);
  88200.times do |i|
    outa(i, granulate(grn), $output);
    end
  end.output
</pre>
</td>
</tr>
<tr>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  "oboe.snd" make-readin 2.0 make-granulate { grn }
  44100 0 do
    i  grn #f #f granulate  *output* outa drop
  loop
; :play #t with-sound drop
</pre>
</td>
</tr>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t)
  (let* ((osc (make-oscil 440.0))
	 (sweep (make-env '(0 0 1 1) 
			  :scaler (hz-&gt;radians 440.0) 
			  :length 44100))
	 (grn (make-granulate (lambda (dir)
				(* 0.2 (oscil osc (env sweep))))
			      :expansion 2.0
			      :length .5)))
    (do ((i 0 (+ 1 i)))
	((= i 88200))
      (outa i (granulate grn)))))
</pre>
</td>
</tr>
<tr>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true) do
  osc = make_oscil(440.0);
  sweep = make_env([0.0, 0.0, 1.0, 1.0],
                   :scaler, hz2radians(440.0),
		   :length, 44100);
  grn = make_granulate(lambda { |dir| 0.2 * oscil(osc, env(sweep))},
	               :expansion, 2.0,
	               :length, 0.5);
  88200.times do |i|
    outa(i, granulate(grn), $output);
    end
  end.output
</pre>
</td>
</tr>
<tr>

<td bgcolor="#effdef">
<pre>
: make-granulate-proc { osc sweep -- prc; dir self -- val }
  1 proc-create osc , sweep , ( prc )
 does> { dir self -- val }
  self @ ( osc )  self cell+ @ ( sweep ) env  0 oscil  0.2 f*
;

lambda: ( -- )
  440.0 make-oscil { osc }
  '( 0 0 1 1 ) :scaler 440.0 hz-&gt;radians :length 44100 make-env { sweep }
  osc sweep make-granulate-proc :expansion 2.0 :length 0.5 make-granulate { grn }
  88200 0 do
    i  grn #f #f granulate  *output* outa drop
  loop
; :play #t with-sound drop
</pre>
</td>
</tr>
</table>


<p>The granulate generator "granulates" its input (normally a sound file).  It is the poor man's way
to change the speed at which things happen in a recorded sound without
changing the pitches.  It works by slicing the input file into short
pieces, then overlapping these slices to lengthen (or shorten) the
result; this process is sometimes known as granular synthesis, and is
similar to the freeze function.  
</p>

<table align=left border=1 cellpadding=4 hspace=40 vspace=10>
<tr><td colspan=2 bgcolor="beige"><center>granulate methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>time (seconds) between output grains (hop)</td></tr>
<tr><td><em class=gen>mus-ramp</em></td><td>length (samples) of grain envelope ramp segment</td></tr>
<tr><td><em class=gen>mus-hop</em></td><td>time (samples)  between output grains (hop)</td></tr>
<tr><td><em class=gen>mus-scaler</em></td><td>grain amp (scaler)</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>expansion</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>grain length (samples)</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>grain samples (a vct)</td></tr>
<tr><td><em class=gen>mus-location</em></td><td>granulate's local random number seed</td></tr>
</table>
<br>
<pre>
result = overlap add many tiny slices from input
</pre>
<br clear=left>

<p>The duration of each slice is
"length" &mdash; the longer the slice, the more the effect resembles reverb.  The
portion of the length (on a scale from 0 to 1.0) spent on each
ramp (up or down) is set by the "ramp" argument.  It can control the smoothness of
the result of the overlaps. 
</p>

<p>The "jitter" argument sets
the accuracy with which granulate hops.  If you set it to 0 (no randomness), you can get very strong
comb filter effects, or tremolo.
The more-or-less average time between
successive segments is "hop".  
If jitter is 0.0, and hop is very small (say .01),
you're asking for trouble (a big comb filter).
If you're granulating more than one channel at a time, and want the channels to remain
in-sync, make each granulator use the same initial random number seed (via mus-location).
</p>

<p>The overall amplitude scaler on each segment is set by the
"scaler" argument; this is used to try to avoid overflows as we add
all these zillions of segments together.  "expansion"
determines the input hop in relation to the output hop; an
expansion-amount of 2.0 should more or less double the length of the
original, whereas an expansion-amount of 1.0 should return something
close to the original tempo.
"input" and "input-function" are the same as in src and convolve (functions of
one argument that return a new input sample whenever they are called by granulate).
</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (granulate-sound file beg dur (orig-beg 0.0) (exp-amt 1.0))
  (let* ((f-srate (srate file))
	 (f-start (round (* f-srate orig-beg)))
         (f (<a class=quiet href="#make-readin" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_readin_tip)">make-readin</a> file :start f-start))
	 (st (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> beg))
	 (new-dur (or dur (- (<a class=quiet href="extsnd.html#mussoundduration" onmouseout="UnTip()" onmouseover="Tip(extsnd_mussoundduration_tip)">mus-sound-duration</a> file) orig-beg)))
	 (exA (<em class=red>make-granulate</em> :input f :expansion exp-amt))
	 (nd (+ st (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> new-dur))))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
     (do ((i st (+ 1 i)))
         ((= i nd))
       (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (<em class=red>granulate</em> exA))))))

(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () (granulate-sound "now.snd" 0 3.0 0 2.0))
</pre>
</td></tr></table>

<p>See <a href="sndscm.html#expsrc">clm-expsrc</a> in clm-ins.scm.  Here's an instrument that uses the input-function
argument to granulate.  It cause the granulation to run backwards through the file:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (grev beg dur exp-amt file file-beg)
  (let* ((exA (<em class=red>make-granulate</em> :expansion exp-amt))
	 (fil (<a class=quiet href="#make-filetosample" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_filetosample_tip)">make-file-&gt;sample</a> file))
	 (ctr file-beg))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
     (do ((i beg (+ 1 i)))
         ((= i (+ beg dur)))
       (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (<em class=red>granulate</em> exA
                 (lambda (dir)
		   (let ((inval (<a class=quiet href="#filetosample" onmouseout="UnTip()" onmouseover="Tip(sndclm_filetosample_tip)">file-&gt;sample</a> fil ctr 0)))
		     (if (&gt; ctr 0) (set! ctr (- ctr 1)))
		     inval))))))))

(<a class=quiet href="sndscm.html#withsound" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () (grev 0 100000 2.0 "pistol.snd" 40000))
</pre>
</td></tr></table>

<p>But it's unnecessary to write clever input functions.  It is just as fast, and much more perspicuous,
to use sound-let in cases like this.  Here's an example that takes any set of notes and calls granulate
on the result:
</p>
<table border=0 hspace=40><tr><td>
<pre>
(define-macro (gran-any beg dur expansion . body)
  `(<em class=red>sound-let</em> ((tmp () ,@body))
     (let* ((start (floor (* (mus-srate) ,beg)))
	    (end (+ start (* (mus-srate) ,dur)))
	    (rd (make-readin tmp))
	    (gran (<em class=red>make-granulate</em> :input rd :expansion ,expansion)))
       (run
	(do ((i start (+ i 1)))
	    ((= i end))
	  (outa i (granulate gran)))))))

(with-sound () 
  (gran-any 0 2.5 4 
    (fm-violin 0 .1 440 .1) 
    (fm-violin .2 .1 660 .1) 
    (fm-violin .4 .1 880 .1)))
</pre>
</td></tr></table>

<p>Any of the input-oriented generators (src, etc) can use this trick.
</p>

<p>
The "edit" argument can
be a function of one argument, the current granulate generator.  It is called just before
a grain is added into the output buffer. The current grain is accessible via mus-data.
The edit function, if any, should return the length in samples of the grain, or 0.
In the following example, we use the edit function to reverse every other grain:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(let ((forward #t))
  (let ((grn (<em class=red>make-granulate</em> :expansion 2.0
                             :edit (lambda (g)
                                     (let ((grain (<a class=quiet href="#mus-data" onmouseout="UnTip()" onmouseover="Tip(sndclm_mus_data_tip)">mus-data</a> g))  ; current grain
                                           (len (<a class=quiet href="#mus-length" onmouseout="UnTip()" onmouseover="Tip(sndclm_mus_length_tip)">mus-length</a> g))) ; current grain length
                                       (if forward ; no change to data
                                           (set! forward #f)
                                           (begin
                                             (set! forward #t)
                                             (<a class=quiet href="extsnd.html#vctreverse" onmouseout="UnTip()" onmouseover="Tip(extsnd_vctreverse_tip)">vct-reverse!</a> grain len)))
                                       len))))
        (rd (<a class=quiet href="extsnd.html#makesampler" onmouseout="UnTip()" onmouseover="Tip(extsnd_makesampler_tip)">make-sampler</a> 0)))
    (<a class=quiet href="extsnd.html#mapchannel" onmouseout="UnTip()" onmouseover="Tip(extsnd_mapchannel_tip)">map-channel</a> (lambda (y) (<em class=red>granulate</em> grn (lambda (dir) (rd)))))))
</pre>
</td></tr></table>
<br><br>




<A NAME="phase-vocoderdoc"></A>
<!-- ---------------------------------------- PHASE-VOCODER ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>phase-vocoder</h3></center></td></tr></table>

<pre>
  <a class=def name="make-phase-vocoder">make-phase-vocoder</a> input (fft-size 512) (overlap 4) (interp 128) (pitch 1.0) analyze edit synthesize
  <a class=def name="phase-vocoder">phase-vocoder</a> pv input-function analyze-function edit-function synthesize-function
  <a class=def name="phase-vocoder?">phase-vocoder?</a> pv
</pre>


<table border=1 bordercolor="lightgray" hspace=20 cellspacing=8 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t) ; new pitch = 2 * old
  (let ((pv (make-phase-vocoder 
             (make-readin "oboe.snd") :pitch 2.0)))
    (do ((i 0 (+ 1 i)))
	((= i 44100))
      (outa i (phase-vocoder pv)))))
</pre>
</td>
</tr>
<tr>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true) do
  rd = make_readin("oboe.snd");
  pv = make_phase_vocoder(
         lambda do |dir| 
           readin(rd) end, :pitch, 2.0);
  88200.times do |i|
    outa(i, phase_vocoder(pv), $output);
    end
  end.output
</pre>
</td>
</tr>
<tr>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  "oboe.snd" make-readin :pitch 2.0 make-phase-vocoder { pv }
  44100 0 do
    i  pv #f #f #f #f phase-vocoder  *output* outa drop
  loop
; :play #t with-sound drop
</pre>
</td>
</tr>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t :srate 22050) ; new dur = 2 * old
  (let ((pv (make-phase-vocoder 
	     (make-readin "oboe.snd")
	     :interp 256)) ; 2 * 512 / 4
        ;; 512: fft size, 4: overlap, new dur: 2 * old dur
	(samps (* 2 (mus-sound-frames "oboe.snd"))))
    (do ((i 0 (+ 1 i)))
	((= i samps))
      (outa i (phase-vocoder pv)))))
</pre>
</td>
</tr>
<tr>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true, :srate, 22050) do
  rd = make_readin("oboe.snd");
  pv = make_phase_vocoder(
	lambda do |dir| readin(rd) end,
        :interp, 2 * 512 / 4);
  samps = 2 * mus_sound_frames("oboe.snd");
  samps.times do |i|
    outa(i, phase_vocoder(pv), $output);
    end
  end.output
</pre>
</td>
</tr>
<tr>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  "oboe.snd" make-readin :interp 256 make-phase-vocoder { pv }
  "oboe.snd" mus-sound-frames 2* ( samps ) 0 do
    i  pv #f #f #f #f phase-vocoder  *output* outa drop
  loop
; :play #t :srate 22050 with-sound drop
</pre>
</td>
</tr>
</table>
<br>


<table border=1 cellpadding=4 hspace=40 vspace=10>
<tr><td colspan=2 bgcolor="beige"><center>phase-vocoder methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>pitch shift</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>fft-size</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>interp</td></tr>
<tr><td><em class=gen>mus-hop</em></td><td>fft-size / overlap</td></tr>
<tr><td><em class=gen>mus-location</em></td><td>outctr (counter to next fft)</td></tr>
</table>

<p>The phase-vocoder generator performs phase-vocoder analysis and resynthesis.  The process is
split into three pieces, the analysis stage, editing of the amplitudes and phases, then the resynthesis.
Each stage has a default that is invoked if the "analyze", "edit", or "synthesize"
arguments are omitted from make-phase-vocoder or the phase-vocoder generator.  The edit and synthesize arguments are functions of one argument, the
phase-vocoder generator.  The analyze argument is a function of two arguments, the generator and
the input function. The default is to read the current input,
take an fft, get the new amplitudes and phases (as the edit
function default), then resynthesize using sines; so, the
default case returns a resynthesis of the original input.  The "interp" argument sets the time between
ffts (for time stretching, etc). 
</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (simple-pvoc beg dur amp size file)
  (let* ((start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> beg))
	 (end (+ start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur)))
	 (sr (<em class=red>make-phase-vocoder</em> (<a class=quiet href="#make-readin" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_readin_tip)">make-readin</a> file) :fft-size size)))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
      (do ((i start (+ 1 i)))
          ((= i end))
        (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* amp (<em class=red>phase-vocoder</em> sr)))))))

(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () (simple-pvoc 0 2.0 1.0 512 "oboe.snd"))
</pre>
</td></tr></table>

<p>There are several functions giving access to the phase-vocoder data:
</p>

<pre>
  <em class=emdef>phase-vocoder-amps</em> gen
  <em class=emdef>phase-vocoder-freqs</em> gen
  <em class=emdef>phase-vocoder-phases</em> gen
  <em class=emdef>phase-vocoder-amp-increments</em> gen
  <em class=emdef>phase-vocoder-phase-increments</em> gen
</pre>

<p>These are arrays (vcts) containing the spectral data the phase-vocoder uses to
reconstruct the sound.  See clm23.scm for examples,
in particular pvoc-e that
specifies all of the functions with their default values (that is, it explicitly passes
in functions that do what the phase-vocoder would have done without any function arguments).
pvoc.scm implements the phase-vocoder directly in Scheme (rather than going through the CLM
generator).
In the next example we use all these special functions to resynthesize down an octave:
</p>


<table border=0 hspace=40><tr><td>
<pre>

(with-sound (:srate 22050 :statistics #t)
  (let ((pv (<em class=red>make-phase-vocoder</em>
	     (make-readin "oboe.snd")
	     512 4 128 1.0
	     #f ; no change to analysis method
	     #f ; no change to spectrum
	     (lambda (gen) ; resynthesis function
	       (vct-add! (phase-vocoder-amps gen) (phase-vocoder-amp-increments gen))
	       (vct-add! (phase-vocoder-phase-increments gen) (phase-vocoder-freqs gen))
	       (vct-add! (phase-vocoder-phases gen) (phase-vocoder-phase-increments gen))
	       (let ((sum 0.0)
		     (n (length (phase-vocoder-amps gen))))
		 (do ((k 0 (+ 1 k)))
		     ((= k n))
		   (set! sum (+ sum (* (vct-ref (phase-vocoder-amps gen) k)
				       (sin (* 0.5 (vct-ref (phase-vocoder-phases gen) k)))))))
		 sum)))))
    (run
     (do ((i 0 (+ 1 i)))
	 ((= i 44100))
       (outa i (<em class=red>phase-vocoder</em> pv))))))
</pre>
</td></tr></table>

<p>but, sadly, this code crawls.  It won't actually be useful until I optimize
handling of the caller's resynthesis function, but I am dragging my feet because I've never felt
that this phase-vocoder (as a generator) was the "right thing".  The first step toward something less stupid is
moving-spectrum in generators.scm.
</p>

<br><br>




<A NAME="asymmetric-fmdoc"></A>
<!-- ---------------------------------------- ASYMMETRIC-FM ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>asymmetric-fm</h3></center></td></tr></table>

<pre>
  <a class=def name="make-asymmetric-fm">make-asymmetric-fm</a> 
      (frequency *clm-default-frequency*) 
      (initial-phase 0.0) 
      (r 1.0)             ; amplitude ratio between successive sidebands
      (ratio 1.0)         ; ratio between carrier and sideband spacing
  <a class=def name="asymmetric-fm">asymmetric-fm</a> af index (fm 0.0)
  <a class=def name="asymmetric-fm?">asymmetric-fm?</a> af
</pre>


<table border=1 bordercolor="lightgray" hspace=20 cellspacing=8 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t)
  (let ((fm (make-asymmetric-fm 440.0 0.0 0.9 0.5)))
    (do ((i 0 (+ 1 i)))
	((= i 44100))
      (outa i (* 0.5 (asymmetric-fm fm 1.0))))))
</pre>
</td>
</tr>
<tr>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true) do
  fm = make_asymmetric_fm(440.0, 0.0, 0.9, 0.5);
  44100.times do |i|
    outa(i, 0.5 * asymmetric_fm(fm, 1.0), $output);
    end
  end.output
</pre>
</td>
</tr>
<tr>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  440.0 0.0 0.9 0.5 make-asymmetric-fm { fm }
  44100 0 do
    i  fm 1.0 0 asymmetric-fm  f2/ *output* outa drop
  loop
; :play #t with-sound drop
</pre>
</td>
</tr>
</table>


<p>The asymmetric-fm generator provides a way around the symmetric spectra normally produced by FM.
See  Palamin and Palamin, "A Method of Generating and Controlling Asymmetrical
Spectra" JAES vol 36, no 9, Sept 88, p671-685.  P&amp;P use sin(sin), but I'm using cos(sin) so
that we get a sum of cosines, and can therefore easily normalize the peak amplitude to -1.0..1.0.
</p>


<table align=left border=1 cellpadding=4 hspace=40 vspace=10>
<tr><td colspan=2 bgcolor="beige"><center>asymmetric-fm methods</center></td></tr>
<tr><td><em class=gen>mus-frequency</em></td><td>frequency in Hz</td></tr>
<tr><td><em class=gen>mus-phase</em></td><td>phase in radians</td></tr>
<tr><td><em class=gen>mus-scaler</em></td><td>"r" parameter; sideband scaler</td></tr>
<tr><td><em class=gen>mus-offset</em></td><td>"ratio" parameter</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>frequency in radians per sample</td></tr>
</table>
<br>

<!-- LATEX: 
original:
e^{(\frac{B}{2}(r-\frac{1}{r})\cos \omega_{m}t)}\sin(\omega_{c}t+\frac{B}{2}(r+\frac{1}{r})\sin \omega_{m}t)=\sum_{n=-\infty}^{\infty} r^{n}J_{n}(B)\sin(\omega_{c}t+n\omega_{m}t)
my version (for predicatable peak amp):
e^{(\frac{B}{2}(r-\frac{1}{r})\cos \omega_{m}t)}\cos(\omega_{c}t+\frac{B}{2}(r+\frac{1}{r})\sin \omega_{m}t)=\sum_{n=-\infty}^{\infty} r^{n}J_{n}(B)\cos(\omega_{c}t+n\omega_{m}t)

original:
e^{(\frac{B}{2}(r+\frac{1}{r})\cos \omega_{m}t)}\sin(\omega_{c}t+\frac{B}{2}(r-\frac{1}{r})\sin \omega_{m}t)=\sum_{n=-\infty}^{\infty} r^{n}I_{n}(B)\sin(\omega_{c}t+n\omega_{m}t)
my version:
e^{(\frac{B}{2}(r+\frac{1}{r})\cos \omega_{m}t)}\cos(\omega_{c}t+\frac{B}{2}(r-\frac{1}{r})\sin \omega_{m}t)=\sum_{n=-\infty}^{\infty} r^{n}I_{n}(B)\cos(\omega_{c}t+n\omega_{m}t)

here's the complicated case:
e^{\big( \big(\frac{B}{2}\big(r+\frac{1}{r}\big)\cos \omega_{m}t\big) - \frac{1}{2} \ln \big(I_{0}\big(B\big(r+\frac{1}{r}\big)\big)\big) \big)} \sin\big(\omega_{c}t+\frac{B}{2}\big(r-\frac{1}{r}\big)\sin \omega_{m}t\big)=\frac{1}{\sqrt{I_{0}(B(r+\frac{1}{r}))}} \sum r^{n}I_{n}(B)\sin(\omega_{c}t+n\omega_{m}t)
 -->

<pre>
based on:
</pre>
<img src="pix/sceq10.png" alt="e sin"><br>
<img src="pix/sceq22.png" alt="I form">

<br clear=left>

<p>"r" is the ratio between successive 
sideband amplitudes, r &lt; 0.0 or r &gt; 1.0 pushes energy above the carrier, whereas r between 0.0 and 1.0 pushes it below. (r = 1.0
gives normal FM).  The mirror image of r (around a given
carrier) is produced by -1/r.
"ratio" is the ratio between the carrier and modulator (i.e. sideband spacing). It's somewhat inconsistent
that asymmetric-fm takes "index" (the fm-index) as its second argument, but otherwise it
would be tricky to get time-varying indices.  In this instrument we sweep "r" with an envelope:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (asy beg dur freq amp index (ratio 1.0))
  (let* ((st (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> beg))
         (nd (+ st (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur)))
         (r-env (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 -1 1 -20) :duration dur))
         (asyf (<em class=red>make-asymmetric-fm</em> :ratio ratio :frequency freq)))
    (do ((i st (+ 1 i))) 
        ((= i nd))
      (set! (<a class=quiet href="#mus-scaler" onmouseout="UnTip()" onmouseover="Tip(sndclm_mus_scaler_tip)">mus-scaler</a> asyf) (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> r-env)) ; this sets "r"
      (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* amp (<em class=red>asymmetric-fm</em> asyf index))))))
</pre>
</td></tr></table>

<p>For the other kind of asymmetric-fm see generators.scm, and for asymmetric spectra via "single sideband FM" see generators.scm.
</p>
<br><br>



<!-- INDEX framedoc:frames -->
<!-- INDEX framedoc:mixers -->

<A NAME="framedoc"></A>
<!-- ---------------------------------------- FRAME, MIXER ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>frames and mixers</h3></center></td></tr></table>

<p>
There are two special data types in CLM: frames and mixers.
A frame is an array that represents
a multichannel sample (that is, in a stereo file, at time 0.0, there
are two samples, one for each channel, and the frame that represents it has 2 samples).  A mixer is a array of arrays
that represents a set of input to output scalers, as if it were the
current state of a mixing console's volume controls.  A frame (a multichannel
input) can be mixed into a new frame (a multichannel output) by passing
it through a mixer (a matrix, the operation being a (left) matrix multiply).
These are combined with the notion of a sample (one datum of sampled music), and
input/output ports (files, audio ports, etc) to handle all the 
sound data input and output.
</p>

<table cellspacing=0 cellpadding=0 hspace=40>
<tr><td><a class=def name="make-frame">make-frame</a><code> chans :rest args</code></td><td width=20></td><td>create frame and load it with args</td></tr>
<tr><td><a class=def name="make-frame!">make-frame!</a><code> chans :rest args</code></td><td width=20></td><td>create frame of any size and load it with args</td></tr>
<tr><td><a class=def name="frame1">frame</a><code> :rest args</code></td><td width=20></td><td>create frame and load it with args</td></tr>
<tr><td><a class=def name="frame?">frame?</a><code> obj</code></td><td></td><td>is obj a frame</td></tr>
<tr><td><a class=def name="frame-ref">frame-ref</a><code> f1 chan</code></td><td></td><td>return f1[chan]</td></tr>
<tr><td><a class=def name="frame-set!">frame-set!</a><code> f1 chan val</code></td><td></td><td>f1[chan] = val (also set! with frame-ref)</td></tr>
<tr><td><a class=def name="frame+">frame+</a><code> f1 f2 outf</code></td><td></td><td>add f1 and f2 element-wise, return new frame (or outf)</td></tr>
<tr><td><a class=def name="frame*">frame*</a><code> f1 f2 outf</code></td><td></td><td>multiply f1 and f2 element-size, return new frame (or outf)</td></tr>
<tr><td><br></td><td></td><td></td></tr>
<tr><td><a class=def name="make-mixer">make-mixer</a><code> chans :rest args</code></td><td></td><td>create a mixer and load it with args</td></tr>
<tr><td><a class=def name="make-mixer!">make-mixer!</a><code> chans :rest args</code></td><td></td><td>create a mixer of any size and load it with args</td></tr>
<tr><td><a class=def name="mixer1">mixer</a><code> :rest args</code></td><td></td><td>create a mixer and load it with args</td></tr>
<tr><td><a class=def name="make-scalar-mixer">make-scalar-mixer</a><code> chans scl</code></td><td></td><td>create a mixer with scl on the diagonal</td></tr>
<tr><td><a class=def name="mixer?">mixer?</a><code> obj</code></td><td></td><td>is obj a mixer</td></tr>
<tr><td><a class=def name="mixer-ref">mixer-ref</a><code> m1 in out</code></td><td></td><td>m1[in,out] (use set! to change)</td></tr>
<tr><td><a class=def name="mixer-set!">mixer-set!</a><code> m1 in out val</code></td><td></td><td>m1[in,out] = val (also set! with mixer-ref)</td></tr>
<tr><td><a class=def name="mixermultiply">mixer*</a><code> m1 m2 outm</code></td><td></td><td>matrix multiply of m1 and m2, return new mixer (or outm)</td></tr>
<tr><td><a class=def name="mixeradd">mixer+</a><code> m1 m2 outm</code></td><td></td><td>matrix add of m1 and m2, return new mixer (or outm)</td></tr>
<tr><td></td><td><br></td><td></td></tr>
<tr><td><a class=def name="frametoframe">frame-&gt;frame</a><code> mf mf outf</code></td><td></td><td>pass frame through mixer, return new frame (or outf)</td></tr>
<tr><td><a class=def name="frametolist">frame-&gt;list</a><code> frame</code></td><td></td><td>return list of frame's contents</td></tr>
<tr><td><a class=def name="sampletoframe">sample-&gt;frame</a><code> mf sample outf</code></td><td></td><td>pass sample through mf (a frame or mixer), return new frame (or outf)</td></tr>
<tr><td><a class=def name="frametosample">frame-&gt;sample</a><code> mf frame</code></td><td></td><td>pass frame through mf (a frame or mixer), return sample</td></tr>
</table>

<A NAME="framemuschannels"></A>
<table border=1 cellpadding=4 hspace=40 vspace=20>
<tr><td colspan=2 bgcolor="beige"><center>frame and mixer methods</center></td></tr>
<tr><td><em class=gen>mus-channels</em></td><td>number of channels accommodated</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>same as mus-channels</td></tr>
<tr><td><em class=gen>mus-data</em></td><td>frame data (vct)</td></tr>
</table>

<p>
The arguments to frame*, frame+, mixer*, and mixer+ can be floats as well as mixers and
frames. In that case, the mixer or frame is either scaled by the float, or the float is
added to each element.  
In matrix terminology, a mixer is a square matrix, a frame is a column (or row) vector, mixer* is a 
matrix multiply, and so on. 
The form <code>(frame-&gt;frame frame mixer frame)</code> multiplies a row vector (the first frame)
by a matrix (the mixer), whereas <code>(frame-&gt;frame mixer frame frame)</code> multiplies
a matrix by a column vector.
See <a href="sndscm.html#framedoc">frame.scm</a> for many more
frame-related functions, <a href="sndscm.html#mixerdoc">mixer.scm</a> for mixer functions,
and fullmix in clm-ins.scm for an extended example.
In Ruby, frame* is frame_multiply, frame+ is frame_add, and mixer* is mixer_multiply.
</p>

<pre>
    <em class=listener>&gt;</em><em class=typing>(define f1 (make-frame 3 1.0 0.5 0.1))</em>
    <em class=listener>#&lt;unspecified&gt;</em>
    <em class=listener>&gt;</em><em class=typing>f1</em>
    <em class=listener>#&lt;frame[3]: [1.000 0.500 0.100]&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(frame-ref f1 2)</em>
    <em class=listener>0.100000001490116</em>
    <em class=listener>&gt;</em><em class=typing>(frame* f1 2.0)</em>
    <em class=listener>#&lt;frame[3]: [2.000 1.000 0.200]&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(define f2 (make-frame 3 0.0 1.0 0.0))</em>
    <em class=listener>#&lt;unspecified&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(frame+ f1 f2)</em>
    <em class=listener>#&lt;frame[3]: [1.000 1.500 0.100]&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(frame-&gt;sample f1 f2)</em> ; dot-product in this case
    <em class=listener>0.5</em>
    <em class=listener>&gt;</em><em class=typing>(define m1 (make-mixer 3 1 0 0  0 1 0  0 0 2))</em>
    <em class=listener>#&lt;unspecified&gt;</em>
    <em class=listener>&gt;</em><em class=typing>m1</em>
    <em class=listener>#&lt;mixer: chans: 3, [
     1.000 0.000 0.000
     0.000 1.000 0.000
     0.000 0.000 2.000
    ]&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(mixer-ref m1 2 2)</em>
    <em class=listener>2.0</em>
    <em class=listener>&gt;</em><em class=typing>(frame-&gt;frame m1 f1)</em>
    <em class=listener>#&lt;frame[3]: [1.000 0.500 0.200]&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(mus-length m1)</em>
    <em class=listener>3</em>
    <em class=listener>&gt;</em><em class=typing>(mus-data f1)</em>
    <em class=listener>#&lt;vct[len=3]: 1.000 0.500 0.100&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(frame-set! f1 1 -.5)</em> ; same as (set! (f1 1) -.5)
    <em class=listener>-0.5</em>
    <em class=listener>&gt;</em><em class=typing>f1</em>
    <em class=listener>#&lt;frame[3]: [1.000 -0.500 0.100]&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(mixer-set! m1 0 1 0.5)</em> ; same as (set! (m1 0 1) 0.5)
    <em class=listener>0.5</em>
    <em class=listener>&gt;</em><em class=typing>m1</em>
    <em class=listener>#&lt;mixer: chans: 3, [
     1.000 0.500 0.000
     0.000 1.000 0.000
     0.000 0.000 2.000
    ]&gt;</em>
</pre>

<p>make-mixer! (with the exclamation point) overrides an internal size check.  Since the size
is interpreted normally as the number of channels, make-mixer (without the trailing "!") imposes a maximum size that is pretty
low (128 when last checked).  If you're using mixers as honest matrices, you'll often want large
mixers.  Here's a curious example that takes the "wavogram" view of a sound (as a sequence
of equal length traces), loads it into a mixer, inverts the mixer (via matrix inversion, <a href="sndscm.html#invertmatrix">invert-matrix</a>), then
writes out the new "sound":
</p>

<pre>
(let* ((snd (open-sound "oboe.snd"))
       (size 225) ; 225 * 225 is about the size of oboe.snd
       (mx (<em class=red>make-mixer!</em> size))
       (rd (make-sampler 0)))
  (do ((i 0 (+ i 1)))
      ((= i size))
    (do ((j 0 (+ j 1)))
	((= j size))
      (<em class=red>mixer-set!</em> mx i j (rd))))

  (invert-matrix mx)

  (let ((nsnd (new-sound "test.snd" :srate 22050))
	(samp 0)
	(samps (make-vct (* size size))))
    (do ((i 0 (+ i 1)))
	((= i size))
      (do ((j 0 (+ j 1)))
	  ((= j size))
	(set! (samps samp) (<em class=red>mixer-ref</em> mx i j))
	(set! samp (+ samp 1))))

    (vct-&gt;channel samps 0 (* size size) nsnd)))
</pre>

<p>In s7, mixers and frames are "applicable objects", like vcts, so mixer-ref and frame-ref are
unnecessary, and mixer-set! and frame-set! can be replaced with set!:
</p>
<pre>
    <em class=listener>&gt;</em><em class=typing>(let ((fr (frame .1 .2)))
       (set! (fr 1) .3)
       (fr 1))</em>
    <em class=listener>0.3</em>
</pre>

<br><br>




<A NAME="filetosampledoc"></A>
<!-- ---------------------------------------- FILE->SAMPLE ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>sound IO</h3></center></td></tr></table>

<p>Sound file IO is based on a set of file readers and writers that deal either in samples, frames, or vcts.
The six functions are file-&gt;sample, sample-&gt;file, file-&gt;frame, frame-&gt;file, array-&gt;file, and file-&gt;array.
The name "array" is used here, rather than "vct" for historical reasons (the CL version of CLM predates
Snd by many years).
These functions are then packaged up in more convenient forms as in-any, out-any, locsig, readin, etc.
Within with-sound, the variable *output* is bound to the with-sound output file via a sample-&gt;file
object.
</p>


<pre>
  <a class=def name="make-filetosample">make-file-&gt;sample</a> name (buffer-size 8192)
  <a class=def name="make-sampletofile">make-sample-&gt;file</a> name (chans 1) (format mus-lfloat) (type mus-next) comment
  <a class=def name="filetosample?">file-&gt;sample?</a> obj
  <a class=def name="sampletofile?">sample-&gt;file?</a> obj
  <a class=def name="filetosample">file-&gt;sample</a> obj samp chan
  <a class=def name="sampletofile">sample-&gt;file</a> obj samp chan val
  <a class=def name="continue-sampletofile">continue-sample-&gt;file</a> file

  <a class=def name="make-filetoframe">make-file-&gt;frame</a> name (buffer-size 8192)
  <a class=def name="make-frametofile">make-frame-&gt;file</a> name (chans 1) (format mus-lfloat) (type mus-next) comment
  <a class=def name="frametofile?">frame-&gt;file?</a> obj
  <a class=def name="filetoframe?">file-&gt;frame?</a> obj
  <a class=def name="filetoframe">file-&gt;frame</a> obj samp outf
  <a class=def name="frametofile">frame-&gt;file</a> obj samp val
  <a class=def name="continue-frametofile">continue-frame-&gt;file</a> file

  <a class=def name="filetoarray">file-&gt;array</a> file channel beg dur array
  <a class=def name="arraytofile">array-&gt;file</a> file data len srate channels

  <a class=def name="mus-input?">mus-input?</a> obj
  <a class=def name="mus-output?">mus-output?</a> obj
  <a class=def name="mus-close">mus-close</a> obj
  <a class=def name="*output*">*output*</a>
  <a class=def name="*reverb*">*reverb*</a>
  <a class=def name="musfilebuffersize">mus-file-buffer-size</a>
</pre>


<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:channels 2)
  ;; swap channels of stereo file
  (let* ((input (make-file-&gt;frame "stereo.snd"))
	 (len (mus-sound-frames "stereo.snd"))
	 (frame (make-frame 2)))
    (do ((i 0 (+ 1 i)))
	((= i len))
      (file-&gt;frame input i frame)
      (let ((val (frame 0)))
	(set! (frame 0) (frame 1))
	(set! (frame 1) val))
      (frame-&gt;file *output* i frame))))
</pre>
</td>

<td width=4></td>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:channels, 2) do
  input = make_file2frame("stereo.snd");
  len = mus_sound_frames("stereo.snd");
  frame = make_frame(2);
  len.times do |i|
    file2frame(input, i, frame);
    val = frame_ref(frame, 0);
    frame_set!(frame, 0, frame_ref(frame, 1));
    frame_set!(frame, 1, val);
    frame2file($output, i, frame);
    end
  end.output
</pre>
</td>

<td width=4></td>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  "stereo.snd" make-file-&gt;frame { input }
  2 make-frame { frm }
  "stereo.snd" mus-sound-frames ( len ) 0 do
    input i frm file-&gt;frame ( frm ) 1 frame-ref ( val1 )
    frm 0 frame-ref ( val0 ) frm 1 rot frame-set! drop
    ( val1 ) frm 0 rot frame-set! drop
    *output* i frm frame-&gt;file drop
  loop
; :channels 2 :play #t with-sound drop
</pre>
</td>
</tr>
</table>


<p>file-&gt;sample writes a sample to a file, frame-&gt;file writes a frame, file-&gt;sample reads a sample
from a file, and file-&gt;frame reads a frame.
continue-frame-&gt;file and continue-sample-&gt;file reopen an existing file to continue adding sound data to it.
mus-output? returns #t is its argument is some sort of file writing generator, and mus-input? returns #t if its 
argument is a file reader.  file-&gt;frame returns a new frame unless you pass it an "outf" argument (a frame).
In make-file-&gt;sample and make-file-&gt;frame, the buffer-size defaults to <a href="#musfilebuffersize">mus-file-buffer-size</a>.
There are many examples of these functions in snd-test.scm, clm-ins.scm, and clm23.scm.
Here is one that uses file-&gt;sample to mix in a sound file (there are a zillion other ways to do this):
</p>

<table border=0 hspace=40><tr><td>
<pre>
(define (simple-f2s beg dur amp file)
  (let* ((start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> beg))
         (end (+ start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur)))
         (fil (<em class=red>make-file-&gt;sample</em> file))
         (ctr 0))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
     (do ((i start (+ 1 i))) ((= i end))
       (<a class=quiet href="#out-any" onmouseout="UnTip()" onmouseover="Tip(sndclm_out_any_tip)">out-any</a> i (* amp (<em class=red>file-&gt;sample</em> fil ctr 0)) 0)
       (set! ctr (+ 1 ctr))))))
</pre>
</td></tr></table>

<p>mus-close flushes any pending output and closes the output stream 'obj'.
This is normally done for you by with-sound, but if you have your own
output streams,
and you forget to call mus-close, the GC will eventually do it for you.
</p>

<p>Here's a function to convert a sound file to some other header or data type using file-&gt;frame and frame-&gt;file:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(define* (convert-soundfile in-file out-file header data)
  (with-sound (:output (or out-file "test.snd")
	       :header-type (or header (mus-sound-header-type in-file))
	       :data-format (or data (mus-sound-data-format in-file))
	       :channels (mus-sound-chans in-file) 
	       :srate (mus-sound-srate in-file))
    (let ((r (<em class=red>make-file-&gt;frame</em> in-file))
	  (len (mus-sound-frames in-file))
	  (outf (make-frame (mus-sound-chans in-file))))
      (run
       (do ((i 0 (+ i 1)))
	   ((= i len))
	 (<em class=red>file-&gt;frame</em> r i outf)
	 (<em class=red>frame-&gt;file</em> *output* i outf))))))

(convert-soundfile "oboe.snd" "test.snd" mus-aifc mus-bfloat)
</pre>
</td></tr></table>

<br><br>



<A NAME="readindoc"></A>
<!-- ---------------------------------------- READIN ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>readin</h3></center></td></tr></table>

<pre>
 <a class=def name="make-readin">make-readin</a> file (channel 0) (start 0) (direction 1) size
 <a class=def name="readin">readin</a> rd
 <a class=def name="readin?">readin?</a> rd
</pre>


<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t)
  (let ((reader (make-readin "oboe.snd")))
    (do ((i 0 (+ 1 i)))
        ((= i 44100))
      (outa i (* 2.0 (readin reader))))))
</pre>
</td>

<td width=4></td>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true) do
  reader = make_readin("oboe.snd");
  44100.times do |i|
   outa(i, 2.0 * readin(reader), 
        $output);
   end
  end.output
</pre>
</td>

<td width=4></td>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  "oboe.snd" make-readin { reader }
  44100 0 do
    i  reader readin  f2/ *output* outa drop
  loop
; :play #t with-sound drop
</pre>
</td>
</tr>
</table>


<table border=1 cellpadding=4 hspace=40 vspace=10>
<tr><td colspan=2 bgcolor="beige"><center>readin methods</center></td></tr>
<tr><td><em class=gen>mus-channel</em></td><td>channel arg to make-readin (no set!)</td></tr>
<tr><td><em class=gen>mus-location</em></td><td>current location in file</td></tr>
<tr><td><em class=gen>mus-increment</em></td><td>sample increment (direction arg to make-readin)</td></tr>
<tr><td><em class=gen>mus-file-name</em></td><td>name of file associated with gen</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>number of frames in file associated with gen</td></tr>
</table>

<p>readin returns successive samples from a file; it is an elaboration of file-&gt;sample that keeps track of the
current read location and channel number for you.
Its "file" argument is the input file's name.
"start" is the frame at which to start reading the input file. 
"channel" is which channel to read (0-based).
"size" is the read buffer size in samples.  It defaults to <a href="#musfilebuffersize">mus-file-buffer-size</a>.
Here is an instrument that applies an envelope to a sound file using
readin and <a href="#env">env</a>:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (env-sound file beg (amp 1.0) (amp-env '(0 1 100 1)))
  (let* ((st (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> beg))
         (dur (<a class=quiet href="extsnd.html#mussoundduration" onmouseout="UnTip()" onmouseover="Tip(extsnd_mussoundduration_tip)">mus-sound-duration</a> file))
         (rev-amount .01)
         (rdA (<em class=red>make-readin</em> file))
         (ampf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> amp-env amp dur))
         (nd (+ st (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur))))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
      (do ((i st (+ 1 i)))
          ((= i nd))
        (let ((outval (* (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> ampf) (<em class=red>readin</em> rdA))))
            (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i outval)
          (if <a class=quiet onmouseout="UnTip()" onmouseover="Tip(sndclm_reverb_tip)">*reverb*</a> 
            (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* outval rev-amount) <a class=quiet onmouseout="UnTip()" onmouseover="Tip(sndclm_reverb_tip)">*reverb*</a>)))))))

(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () (env-sound "oboe.snd" 0 1.0 '(0 0 1 1 2 1 3 0)))
</pre>
</td></tr></table>
<br><br>




<A NAME="in-anydoc"></A>
<A NAME="out-anydoc"></A>
<!-- ---------------------------------------- IN-ANY, OUT-ANY ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>in-any, out-any</h3></center></td></tr></table>

<pre>
  <a class=def name="out-any">out-any</a> loc data channel (output *output*)
  <a class=def name="outa">outa</a> loc data (output *output*)
  <em class=emdef>outb</em> loc data (output *output*)
  <em class=emdef>outc</em> loc data (output *output*)
  <em class=emdef>outd</em> loc data (output *output*)

  <a class=def name="in-any">in-any</a> loc channel input
  <a class=def name="ina">ina</a> loc input
  <a class=def name="inb">inb</a> loc input
</pre>


<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t)
  (let ((infile 
          (make-file-&gt;sample "oboe.snd")))
    (do ((i 0 (+ 1 i)))
        ((= i 44100))
      (out-any i (in-any i 0 infile) 0))))
</pre>
</td>

<td width=4></td>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true) do
  infile = make_file2sample("oboe.snd");
  44100.times do |i|
    out_any(i, in_any(i, 0, infile), 
            0, $output);
    end
  end.output
</pre>
</td>

<td width=4></td>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  "oboe.snd" make-file-&gt;sample { infile }
  44100 0 do
    i  i 0 infile in-any  0 *output* out-any drop
  loop
; :play #t with-sound drop
</pre>
</td>
</tr>
</table>



<p>These are the "generic" input and output functions.
out-any adds its "data" argument (a sound sample) into the "output" object at sample
position "loc".  
The "output" argument can be a vct, a vector, a sound-data object, or a function, as well as the more usual frame-&gt;file object.
or any output-capable CLM generator.
In with-sound, the current output is *output* and the reverb output is *reverb*.
outa is the same as out-any with a channel of 0.  It is not an error to try to write to a channel that doesn't exist;
the function just returns.
</p>

<p>in-any returns the sample at position "loc" in
"input".  ina is the same as in-any with a channel of 0.
As in out-any and friends, the "input" argument can be a file-&gt;frame object, a vct, a vector, sound-data object, or a function.
If "input" is a function, it should take two arguments, the location and the channel number.
</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (simple-ina beg dur amp file)
  (let* ((start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> beg))
         (end (+ start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur)))
         (fil (<em class=red>make-file-&gt;sample</em> file)))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
      (do ((i start (+ 1 i)))
          ((= i end))
        (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i 
          (* amp (<em class=red>in-any</em> i 0 fil))))))) ; same as (<em class=red>ina</em> i fil)
            

(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () (simple-ina 0 1 .5 "oboe.snd"))
</pre>
</td></tr></table>

<p>To write from <a href="sndscm.html#wsdoc">with-sound</a> to a vct or sound-data object, rather than a file,
use its :output argument:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(with-sound (<em class=red>:output</em> (<a class=quiet href="extsnd.html#makevct" onmouseout="UnTip()" onmouseover="Tip(extsnd_makevct_tip)">make-vct</a> 44100)) ; this sets *output*, the default output location
   (<a class=quiet href="sndscm.html#vdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_fmviolin_tip)">fm-violin</a> 0 1 440 .1))

;; returns #&lt;vct[len=44100]: 0.000 0.000 0.000 ...&gt;
</pre>
</td></tr></table>


<p>If *output* is a function, it should take 3 arguments, the sample number, current output value, and channel.
</p>

<table border=0 hspace=40><tr><td>
<pre>
(let ((avg 0.0)
      (samps 0))
  (with-sound (<em class=red>:output</em> (lambda (frame val chan) ; get the average of all the samples
                         (set! avg (+ avg val))
                         (set! samps (+ 1 samps))
                	 val))
    (do ((i 0 (+ 1 i)))
	((&gt; i 10))
      (<em class=red>outa</em> i (* i .1))))
  (/ avg samps))

;; returns 0.5
</pre>
</td></tr></table>

<p>Similarly, if in-any's "input" argument is a function, it takes the input location (sample number), and channel (0-based).
</p>

<table border=0 hspace=40><tr><td>
<pre>
(let ((input (<a class=quiet href="#make-readin" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_readin_tip)">make-readin</a> "oboe.snd" :start 1000)))
  (with-sound (:output (<a class=quiet href="extsnd.html#makevct" onmouseout="UnTip()" onmouseover="Tip(extsnd_makevct_tip)">make-vct</a> 10))
    (do ((i 0 (+ 1 i)))
	((= i 10))
      (<em class=red>outa</em> i (<em class=red>ina</em> i (lambda (loc chn)
		       (<a class=quiet href="#readin" onmouseout="UnTip()" onmouseover="Tip(sndclm_readin_tip)">readin</a> input)))))))
</pre>
</td></tr></table>

<table border=0 hspace=40><tr><td>
<pre>
(let ((outv (<a class=quiet href="extsnd.html#makevct" onmouseout="UnTip()" onmouseover="Tip(extsnd_makevct_tip)">make-vct</a> 10)))
  (with-sound ()
    (<em class=red>run</em>
      (do ((i 0 (+ 1 i)))
	  ((= i 10))
	(outa i (* i .1) (lambda (loc val chan)
			   (set! (outv loc) val))))))
  outv) ; this is equivalent to using :output (<a class=quiet href="extsnd.html#makevct" onmouseout="UnTip()" onmouseover="Tip(extsnd_makevct_tip)">make-vct</a> 10) as a with-sound argument
</pre>
</td></tr></table>


<br><br>




<A NAME="locsigdoc"></A>
<!-- ---------------------------------------- LOCSIG ---------------------------------------- -->

<!-- INDEX make-locsig:Sound placement -->
<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>locsig</h3></center></td></tr></table>

<pre>
 <a class=def name="make-locsig">make-locsig</a> 
        (degree 0.0)
        (distance 1.0) 
	(reverb 0.0)       ; reverb amount
        (output *output*)  ; output generator or location
	(revout *reverb*)  ; reverb output generator or location
        (channels (channels output))
	(type mus-interp-linear)
 <a class=def name="locsig">locsig</a> loc i in-sig
 <a class=def name="locsig?">locsig?</a> loc

 <a class=def name="locsig-ref">locsig-ref</a> loc chan
 <a class=def name="locsig-set!">locsig-set!</a> loc chan val
 <a class=def name="locsig-reverb-ref">locsig-reverb-ref</a> loc chan
 <a class=def name="locsig-reverb-set!">locsig-reverb-set!</a> loc chan val

 <a class=def name="move-locsig">move-locsig</a> loc degree distance
 <a class=def name="locsig-type">locsig-type</a> ()
</pre>


<table border=1 bordercolor="lightgray" hspace=20 cellspacing=2 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t :channels 2)
  (let ((loc (make-locsig 60.0))
	(osc (make-oscil 440.0)))
    (do ((i 0 (+ 1 i)))
	((= i 44100))
      (locsig loc i 
              (* 0.5 (oscil osc))))))
</pre>
</td>

<td width=4></td>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true, :channels, 2) do
  loc = make_locsig(60.0, :output, $output);
  osc = make_oscil(440.0);
  44100.times do |i|
    locsig(loc, i, 0.5 * oscil(osc));
    end
  end.output
</pre>
</td>

<td width=4></td>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  60.0 make-locsig { loc }
  440.0 make-oscil { osc }
  44100 0 do
    loc i  osc 0 0 oscil f2/  locsig drop
  loop
; :play #t :channels 2 with-sound drop
</pre>
</td>
</tr>
</table>


<p>locsig places a sound in 
an N-channel circle of speakers
by scaling the respective channel amplitudes
("that old trick <i>never</i> works"). It normally replaces <a href="#outa">out-any</a>.
</p> 

<table border=1 cellpadding=4 hspace=40>
<tr><td colspan=2 bgcolor="beige"><center>locsig methods</center></td></tr>
<tr><td><em class=gen>mus-data</em></td><td>output scalers (a vct)</td></tr>
<tr><td><em class=gen>mus-xcoeff</em></td><td>reverb scaler</td></tr>
<tr><td><em class=gen>mus-xcoeffs</em></td><td>reverb scalers (a vct)</td></tr>
<tr><td><em class=gen>mus-channels</em></td><td>output channels</td></tr>
<tr><td><em class=gen>mus-length</em></td><td>output channels</td></tr>
</table>

<p>"reverb" determines how much of
the direct signal gets sent to the reverberator.  "distance" tries to
imitate a distance cue by fooling with the relative amounts of direct and
reverberated signal (independent of the "reverb" argument).  The distance should
be greater than or equal to 1.0.  
"type" (returned by the function locsig-type) can be <code>mus-interp-linear</code> (the default) or <code>mus-interp-sinusoidal</code>.
The mus-interp-sinusoidal
case uses sin and cos to set the respective channel amplitudes (this is reported to
help with the "hole-in-the-middle" problem).
The "output" argument can be a vct or a sound-data object, as well as a frame-&gt;file generator.
</p>

<p>Locsig can send output to any number of channels.
If channels &gt; 2, the speakers are assumed to be evenly spaced in
a circle.
You can use locsig-set! to override the placement decisions.
To have full output to both channels,</p>
<pre>
(locsig-set! loc 0 1.0) 
(locsig-set! loc 1 1.0)
</pre>

<p>Here is an instrument that has envelopes on the distance and degrees, and optionally reverberates a file:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (space file onset duration (distance-env '(0 1 100 10)) (amplitude-env '(0 1 100 1))
		     (degree-env '(0 45 50 0 100 90)) (reverb-amount .05))
  (let* ((beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> onset))
	 (end (+ beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> duration)))
         (loc (<em class=red>make-locsig</em> :degree 0 :distance 1 :reverb reverb-amount))
         (rdA (<a class=quiet href="#make-readin" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_readin_tip)">make-readin</a> :file file))
         (dist-env (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> distance-env :duration duration))
         (amp-env (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> amplitude-env :duration duration))
         (deg-env (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> degree-env :scaler (/ 1.0 90.0) :duration duration))
         (dist-scaler 0.0))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
     (do ((i beg (+ 1 i)))
         ((= i end))
       (let ((rdval (* (<a class=quiet href="#readin" onmouseout="UnTip()" onmouseover="Tip(sndclm_readin_tip)">readin</a> rdA) (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> amp-env)))
             (degval (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> deg-env))
	     (distval (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> dist-env)))
         (set! dist-scaler (/ 1.0 distval))
         (locsig-set! loc 0 (* (- 1.0 degval) dist-scaler))
         (if (&gt; (channels <a class=quiet onmouseout="UnTip()" onmouseover="Tip(sndclm_output_tip)">*output*</a>) 1)
             (locsig-set! loc 1 (* degval dist-scaler)))
         (if <a class=quiet onmouseout="UnTip()" onmouseover="Tip(sndclm_reverb_tip)">*reverb*</a> 
             (locsig-reverb-set! loc 0 (* reverb-amount (sqrt dist-scaler))))
         (<em class=red>locsig</em> loc i rdval))))))

(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:reverb jc-reverb :channels 2) 
  (space "pistol.snd" 0 3 :distance-env '(0 1 1 2) :degree-env '(0 0 1 90)))
</pre>
</td></tr></table>

<p>For a moving sound
source, see either move-locsig, Fernando Lopez Lezcano's <a class=def href="http://ccrma.stanford.edu/~nando/clm/dlocsig/index.html">dlocsig</a>,
or <a href="#flocsig">flocsig</a> (flanged locsig) in generators.scm.
Here is an example of move-locsig:
</p>

<table border=0 cellspacing=15><tr><td>
<table border=0><tr><td>
<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:channels 4)
  (let ((loc (<em class=red>make-locsig</em>))
	(osc (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> 440.0))
	(j 0))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>  ; 360 notes one at each degree in a circle
     (do ((i 0 (+ 1 i)))
         ((= i 360))
       (do ((k 0 (+ 1 k)))
           ((= k 1000))
         (let ((sig (* .5 (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> osc))))
           (<em class=red>locsig</em> loc j sig)
	   (set! j (+ 1 j))))
       (<em class=red>move-locsig</em> loc (* 1.0 i) 1.0)))))
</pre>
</td></tr></table>

</td><td>
<img src="pix/circle.png" alt="move-locsig example">
<br><center>linear interp</center>
</td>

<td>
<img src="pix/locsine.png" alt="move-locsig example">
<br><center>sinusoidal interp</center>
</td>

</tr></table>

<br><br>




<A NAME="move-sounddoc"></A>
<!-- ---------------------------------------- MOVE-SOUND ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>move-sound</h3></center></td></tr></table>

<pre>
 <a class=def name="make-move-sound">make-move-sound</a> dlocs-list (output *output*) (revout *reverb*)
 <a class=def name="move-sound">move-sound</a> dloc i in-sig
 <a class=def name="move-sound?">move-sound?</a> dloc
</pre>

<p>move-sound is intended as the run-time portion of <a href="sndscm.html#dlocsigdoc">dlocsig</a>.  make-dlocsig
creates a move-sound structure, passing it to the move-sound generator inside the
dlocsig macro.  All the necessary data is packaged up in a list:
</p>
<pre>
(list
  (start 0)               ; absolute sample number at which samples first reach the listener
  (end 0)                 ; absolute sample number of end of input samples
  (out-channels 0)        ; number of output channels in soundfile
  (rev-channels 0)        ; number of reverb channels in soundfile
  path                    ; interpolated delay line for doppler
  delay                   ; tap doppler env
  rev                     ; reverberation amount
  out-delays              ; delay lines for output channels that have additional delays
  gains                   ; gain envelopes, one for each output channel
  rev-gains               ; reverb gain envelopes, one for each reverb channel
  out-map)                ; mapping of speakers to output channels
</pre>
<p>Here's an instrument that uses this generator to pan a sound through four channels:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(define (simple-dloc beg dur freq amp)
  "(simple-dloc-4 beg dur freq amp) test instrument for dlocsig"
  (let* ((os (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> freq))
         (start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> beg))
         (end (+ start (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur)))
         (loc (<em class=red>make-move-sound</em> (list start end 4 0
                                              (<a class=quiet href="#make-delay" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_delay_tip)">make-delay</a> 12) 
                                     (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 10 1) :length dur)
                                     #f
                                     (make-vector 4 #f)
                                     (vector (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1 2 0 3 0 4 0) :duration dur)
                                             (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 0 2 1 3 0 4 0) :duration dur)
                                             (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 0 2 0 3 1 4 0) :duration dur)
                                             (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 0 2 0 3 0 4 1) :duration dur))
                                     #f
                                     (vector 0 1 2 3)))))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
     (do ((i start (+ 1 i)))
         ((= i end))
       (<em class=red>move-sound</em> loc i (* amp (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> os)))))))

(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:channels 4) (simple-dloc 0 2 440 .5))
</pre>
</td></tr></table>

<br><br>



<table width="80%" border=0><tr><td bgcolor="lightsteelblue" valign="middle"><h2>Generic Functions</h2></td></tr></table>
<A NAME="genericfunctions"></A>

<!-- ---------------------------------------- GENERIC FUNCTIONS ---------------------------------------- -->


<p>Besides the 30 or so built-in generators, there are around 100 others defined in generators.scm. If we
required separate functions for each generator for access to the generator internal state (current phase, for example),
we'd end up with hundreds, or even thousands of accessors.  Instead, 
all the generators respond to a set of "generic" functions.  mus-frequency, for example, tries to return (or set) a generator's
frequency, for any generator that has some sort of frequency field.
The generic functions are:
</p>

<table bordercolor="#f2f4ff" border=2 cellpadding=10 hspace=40><tr><td>

<table cellspacing=0 cellpadding=0>
<tr><td bgcolor="#f2f4ff"><a class=def name="mus-channel">mus-channel</a></td><td width=30 bgcolor="#f2f4ff"></td><td bgcolor="#f2f4ff">channel being read/written</td></tr>
<tr><td><a class=def name="mus-channels">mus-channels</a></td><td></td><td>channels open</td></tr>
<tr><td bgcolor="#f2f4ff"><a class=def name="mus-data">mus-data</a></td><td bgcolor="#f2f4ff"></td><td bgcolor="#f2f4ff">vct of data</td></tr>
<tr><td><a class=def name="mus-describe">mus-describe</a></td><td></td><td>description of current state</td></tr>
<tr><td bgcolor="#f2f4ff"><a class=def name="mus-feedback">mus-feedback</a></td><td bgcolor="#f2f4ff"></td><td bgcolor="#f2f4ff">feedback coefficient</td></tr>
<tr><td><a class=def name="mus-feedforward">mus-feedforward</a></td><td></td><td>feedforward coefficient</td></tr>
<tr><td bgcolor="#f2f4ff"><a class=def name="mus-file-name">mus-file-name</a></td><td bgcolor="#f2f4ff"></td><td bgcolor="#f2f4ff">file being read/written</td></tr>
<tr><td><a class=def name="mus-frequency">mus-frequency</a></td><td></td><td>frequency (Hz)</td></tr>
<tr><td bgcolor="#f2f4ff"><a class=def name="mus-hop">mus-hop</a></td><td bgcolor="#f2f4ff"></td><td bgcolor="#f2f4ff">hop size for block processing</td></tr>
<tr><td><a class=def name="mus-increment">mus-increment</a></td><td></td><td>various increments</td></tr>
<tr><td bgcolor="#f2f4ff"><a class=def name="mus-interp-type">mus-interp-type</a></td><td bgcolor="#f2f4ff"></td><td bgcolor="#f2f4ff">interpolation type (mus-interp-linear, etc)</td></tr>
<tr><td><a class=def name="mus-length">mus-length</a></td><td></td><td>data length</td></tr>
<tr><td bgcolor="#f2f4ff"><a class=def name="mus-location">mus-location</a></td><td bgcolor="#f2f4ff"></td><td bgcolor="#f2f4ff">sample location for reads/writes</td></tr>
<tr><td><a class=def name="mus-name">mus-name</a></td><td></td><td>generator name ("oscil")</td></tr>
<tr><td bgcolor="#f2f4ff"><a class=def name="mus-offset">mus-offset</a></td><td bgcolor="#f2f4ff"></td><td bgcolor="#f2f4ff">envelope offset</td></tr>
<tr><td><a class=def name="mus-order">mus-order</a></td><td></td><td>filter order</td></tr>
<tr><td bgcolor="#f2f4ff"><a class=def name="mus-phase">mus-phase</a></td><td bgcolor="#f2f4ff"></td><td bgcolor="#f2f4ff">phase (radians)</td></tr>
<tr><td><a class=def name="mus-ramp">mus-ramp</a></td><td></td><td>granulate grain envelope ramp setting</td></tr>
<tr><td bgcolor="#f2f4ff"><a class=def name="mus-reset">mus-reset</a></td><td bgcolor="#f2f4ff"></td><td bgcolor="#f2f4ff">set gen to default starting state</td></tr>
<tr><td><a class=def name="mus-run">mus-run</a></td><td></td><td>run any generator</td></tr>
<tr><td><a class=def name="mus-scaler">mus-scaler</a></td><td></td><td>scaler, normally on an amplitude</td></tr>
<tr><td bgcolor="#f2f4ff"><a class=def name="mus-width">mus-width</a></td><td bgcolor="#f2f4ff"></td><td bgcolor="#f2f4ff">width of interpolation tables, etc</td></tr>
<tr><td><a class=def name="mus-xcoeff">mus-xcoeff</a></td><td></td><td>x (input) coefficient</td></tr>
<tr><td bgcolor="#f2f4ff"><a class=def name="mus-xcoeffs">mus-xcoeffs</a></td><td bgcolor="#f2f4ff"></td><td bgcolor="#f2f4ff">vct of x (input) coefficients</td></tr>
<tr><td><a class=def name="mus-ycoeff">mus-ycoeff</a></td><td></td><td>y (output, feedback) coefficient</td></tr>
<tr><td bgcolor="#f2f4ff"><a class=def name="mus-ycoeffs">mus-ycoeffs</a></td><td bgcolor="#f2f4ff"></td><td bgcolor="#f2f4ff">vct of y (feedback) coefficients</td></tr>
</table>

</td></tr></table>

<p>Many of these are settable:
<code>(set! (mus-frequency osc1) 440.0)</code>
sets osc1's phase increment to (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> 440.0). 
When I have a cold, I sometimes use the following function to see how high I can hear; count
the audible tones and multiply by 1000:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(define (quick-check)
  (<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () 
    (let ((gen (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> 1000))) 
      (run 
        (do ((i 0 (+ 1 i))) 
            ((= i 400000))
          (if (= (modulo i 20000) 0) 
              (set! (<em class=red>mus-frequency</em> gen) (+ 1000 (/ i 20))))
          (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* .5 (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> gen))))))))
</pre>
</td></tr></table>

<p>Another example is run-with-fm-and-pm in generators.scm which applies phase modulation (as well as
the default frequency modulation) to any generator:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(define (run-with-fm-and-pm gen fm pm)
  (set! (<em class=red>mus-phase</em> gen) (+ (<em class=red>mus-phase</em> gen) pm))
  (let ((result (<em class=red>mus-run</em> gen fm 0.0)))
    (set! (<em class=red>mus-phase</em> gen) (- (<em class=red>mus-phase</em> gen) pm))
    result))
</pre>
</td></tr></table>

<p>
<a class=def name="musgeneratorp">mus-generator?</a> returns #t if its argument is
a generator.
A generator defined via <a href="#defgenerator">defgenerator</a> can take part in these methods.
If the last element of the list (returned by defgenerator) is an association list, the generic functions
will search that list for their name, and use the functions that follow to implement their method.
</p>
<br>
<br><br>



<table width="80%" border=0><tr><td bgcolor="lightsteelblue" valign="middle"><h2>Other Generators</h2></td></tr></table>
<A NAME="othergenerators"></A>

<!-- ---------------------------------------- OTHER GENERATORS ---------------------------------------- -->

<p>(this section is work in progress...)
</p>

<p>There are dozens of generators scattered around the *.scm files that come with Snd.  Some that come to mind:
</p>

<pre>
analog-filter.scm:
    filter: <a class=quiet href="sndscm.html#analogfilterdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_analogfilterdoc_tip)">butterworth-lowpass|highpass|bandpass|bandstop</a>, 
            <a class=quiet href="sndscm.html#analogfilterdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_analogfilterdoc_tip)">chebyshev-lowpass|highpass|bandpass|bandstop</a>, 
            <a class=quiet href="sndscm.html#analogfilterdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_analogfilterdoc_tip)">inverse-chebyshev-lowpass|highpass|bandpass|bandstop</a>, 
            <a class=quiet href="sndscm.html#analogfilterdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_analogfilterdoc_tip)">elliptic-lowpass|highpass|bandpass|bandstop</a>,
            <a class=quiet href="sndscm.html#analogfilterdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_analogfilterdoc_tip)">bessel-lowpass|highpass|bandpass|bandstop</a>

clm-ins.scm:
    <a class=quiet href="sndscm.html#rmsgain" onmouseout="UnTip()" onmouseover="Tip(sndscm_rmsgain_tip)">rms gain balance</a>

dsp.scm:
    fir-filter: <a class=quiet href="sndscm.html#hilberttransform" onmouseout="UnTip()" onmouseover="Tip(sndscm_hilberttransform_tip)">hilbert-transform</a>, 
                <a class=quiet href="sndscm.html#makehighpass" onmouseout="UnTip()" onmouseover="Tip(sndscm_makehighpass_tip)">highpass, lowpass, bandpass, bandstop</a>, 
                <a class=quiet href="sndscm.html#makedifferentiator" onmouseout="UnTip()" onmouseover="Tip(sndscm_makedifferentiator_tip)">differentiator</a>,
                <a class=quiet href="sndscm.html#makespencerfilter" onmouseout="UnTip()" onmouseover="Tip(sndscm_makespencerfilter_tip)">make-spencer-filter</a>, 
                <a class=quiet href="sndscm.html#sgfilter" onmouseout="UnTip()" onmouseover="Tip(sndscm_sgfilter_tip)">savitzky-golay-filter</a>
   
    filter: <a class=quiet href="sndscm.html#makebutter" onmouseout="UnTip()" onmouseover="Tip(sndscm_makebutter_tip)">butter-high-pass, butter-low-pass, butter-band-pass, butter-band-reject</a>, 
            <a class=quiet href="sndscm.html#makebiquad" onmouseout="UnTip()" onmouseover="Tip(sndscm_makebiquad_tip)">biquad</a>,
            <a class=quiet href="sndscm.html#IIRfilters" onmouseout="UnTip()" onmouseover="Tip(sndscm_IIRfilters_tip)">iir-low-pass, iir-high-pass, iir-band-pass, iir-band-stop, peaking</a>,
            <a class=quiet href="sndscm.html#makebutter" onmouseout="UnTip()" onmouseover="Tip(sndscm_makebutter_tip)">butter-lp, butter-hp, butter-bp, butter-bs</a>
   
    <a class=quiet href="sndscm.html#volterrafilter" onmouseout="UnTip()" onmouseover="Tip(sndscm_volterrafilter_tip)">volterra-filter</a>

env.scm:
    <a class=quiet href="sndscm.html#powerenv" onmouseout="UnTip()" onmouseover="Tip(sndscm_powerenv_tip)">power-env</a> (and many env makers/modifiers)

extensions.scm:
    <a class=quiet href="sndscm.html#envexptchannel" onmouseout="UnTip()" onmouseover="Tip(sndscm_envexptchannel_tip)">env-expt-channel</a> (and many related env modifiers)

examp.scm:
    <a class=quiet href="sndscm.html#makeramp" onmouseout="UnTip()" onmouseover="Tip(sndscm_makeramp_tip)">ramp</a>, 
    <a class=quiet href="sndscm.html#soundinterp" onmouseout="UnTip()" onmouseover="Tip(sndscm_soundinterp_tip)">sound-interp</a>

moog.scm:
    <a class=quiet href="sndscm.html#moogfilter" onmouseout="UnTip()" onmouseover="Tip(sndscm_moogfilter_tip)">moog-filter</a>

prc95.scm:
    <a class=quiet href="sndscm.html#prc95doc" onmouseout="UnTip()" onmouseover="Tip(sndscm_prc95doc_tip)">reed, bowtable, jettable, onep, lip, dc-block, delaya, delayl</a>

zip.scm:
    <a class=quiet href="sndscm.html#zipper" onmouseout="UnTip()" onmouseover="Tip(sndscm_zipper_tip)">zipper</a>
</pre>

<p>In this section, we concentrate on the generators defined in generators.scm.  Nearly all of them respond to the
generic functions mus-name, mus-reset, mus-describe, mus-frequency, mus-scaler, mus-offset, mus-phase, and mus-order.
The parameters are generally "frequency", "n" (the number of sidebands), "r" (the ratio between successive sideband
amplitudes), and "ratio" (the ratio between the
frequency and the spacing between successive sidebands).
</p>


<br>
<pre style="background-color: #f2f4ff">
  <a class=def name="make-polyoid">make-polyoid</a> 
         (frequency *clm-default-frequency*) 
         (partial-amps-and-phases '(1 1 0.0))   ; a list of harmonic numbers, their associated amplitudes, and their initial-phases

  <a class=def name="polyoid">polyoid</a> w (fm 0.0)
  <a class=def name="polyoid?">polyoid?</a> w

  <a class=def name="polyoidenv">polyoid-env</a> w fm amps phases

  <a class=def name="make-noid">make-noid</a> (frequency 0.0) (n 1) phases
  <a class=def name="noid">noid</a> w (fm 0.0)
</pre>

<p>polyoid combines the first and second Chebyshev polynomials to provide
a sum of sinusoids each with arbitrary amplitude and initial-phase.
noid is a wrapper for polyoid that sets up n equal amplitude components, a generalization
of <a href="#ncosdoc">ncos and nsin</a>.
noid's phase argument can be a vct, <code>'min-peak</code>, <code>'max-peak</code>, or omitted (#f).
If omitted, the phases are set to random numbers between 0 and 2 pi; if
a vct, the vct's values are used as the phases; if 'max-peak, all phases are set
to pi/2 (ncos essentially &mdash; use <code>(make-vct n 0.0)</code> to get nsin);
and if 'min-peak, the minimum peak amplitude phases in <a href="sndscm.html#peakphasesdoc">peak-phases.scm</a> are used.
In the 'min-peak and 'max-peak cases, noid's output is normalized to fall between -1.0 and 1.0.
polyoid-env is an extension of polyoid that takes envelopes to control the amplitude and phase of each
harmonic.
</p>

<img src="pix/noidchoices.png" alt="noid choices" hspace=20>

<!--
  run -horizontal
  (do ((i 0 (+ 1 i)))
      ((= i 4))
    (with-sound (:clipped #f :output (string-append "test-noid-" (number->string i) ".snd"))
      (let ((samps 44100)
            (gen (make-noid 100.0 32 (if (= i 0) 'max-peak
                                         (if (= i 1) (make-vct 32 0.0)
                                	     (if (= i 2) #f
						 'min-peak))))))
	(do ((i 0 (+ 1 i)))
	    ((= i samps))
	  (outa i (noid gen 0.0))))))
-->

<p>We can use the <a href="sndscm.html#peakphasesdoc">peak-phases.scm</a> phases to reduce the "spikiness" of the waveform with any
set of components and component amplitudes.  We could, for example, change noid to use
</p>

<pre>
    (set! (amps (+ j 1)) (/ (expt r (- i 1)) norm))
</pre>

<p>where "r" is the ratio between successive component amplitude: "nroid"?
This is not as pointless as it might at first appear.  Many of these waveforms actually
sound different, despite having the same (magnitude) spectrum; the minimum peak
version usually sounds raspier, and in the limit it sounds like white noise!
</p>

<!--
(with-sound (:clipped #f)
  (let* ((dur 2.0)
	 (samps (seconds->samples dur))
	 (gen1 (make-noid 40.0 128 'max-peak))
	 (gen2 (make-noid 40.0 128 'min-peak))
	 (ampf (make-env '(0 0 .1 1 1 1 2 .25 3 .25) :scaler 0.5 :duration dur))
	 (indf (make-env '(0 0 1 0 2 1 3 1) :duration dur)))
    (do ((i 0 (+ 1 i)))
	((= i samps))
      (let ((ind (env indf)))
	(outa i (* (env ampf)
		   (+ (* ind 
			 (noid gen2 0.0))
		      (* (- 1.0 ind) 
			 (noid gen1 0.0)))))))))
-->

<!--
<img src="noid2.png">
-->

<p>Check out the n=1024 case:
</p>

<table border=0 cellpadding=5 hspace=20><tr>
<td><pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () 
  (let ((samps 44100)
	(gen (<em class=red>make-noid</em> 10.0 1024 'min-peak)))
    (do ((i 0 (+ 1 i)))
	((= i samps))
      (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* 0.5 (<em class=red>noid</em> gen 0.0))))))
</pre></td></tr></table>

<br>


<br>
<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-asyfm">make-asyfm</A> (frequency 0.0) (ratio 1.0) (r 1.0) (index 1.0)
  <A class=def NAME="asyfmJ">asyfm-J</A> gen (fm 0.0)
  <A class=def NAME="asyfmI">asyfm-I</A> gen (fm 0.0)
  <A class=def NAME="asyfm?">asyfm?</A> gen
</pre>

<p>These two generators produce the two flavors of asymmetric-fm.  asyfm-J is the same as the built-in asymmetric generator;
asyfm-I is the modified Bessel function version (the second formula in the <a href="#asymmetric-fm">asymmetric-fm</a> section).
</p>
<br>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-fmssb">make-fmssb</A> (frequency 0.0) (ratio 1.0) (index 1.0)
  <A class=def NAME="fmssb">fmssb</A> gen (fm 0.0)
  <A class=def NAME="fmssb?">fmssb?</A> gen
</pre>

<p>This generator produces the "gapped" spectra mentioned in <a href="fm.html">fm.html</a>. It is used extensively in the
various "imaginary machines".  Also included in this section of generators.scm is fpmc, an instrument
that performs FM with a complex index (complex in the sense of complex numbers).  It can be used
in with-sound, but not within run (the run macro does not currently handle complex numbers).
</p>
<br>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-pulsed-env">make-pulsed-env</A> envelope duration frequency
  <A class=def NAME="pulsedenv">pulsed-env</A> gen (fm 0.0)
  <A class=def NAME="pulsedenv?">pulsed-env?</A> gen
</pre>

<p>
This produces a repeating envelope.  <a href="#env">env</a> sticks at its last value, but pulsed-env repeats it over and over.
"duration" is the envelope duration, and "frequency" is the repeitition rate, changeable via the "fm" argument to the pulsed-env generator.
Many of the instruments in animals.scm use this generator.  (In a sense, this is the original Music V OSC generator).
</p>
<br>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-blackman">make-blackman</A> frequency n ; 1 &lt;= n &lt;= 10
  <A class=def NAME="blackman">blackman</A> gen (fm 0.0)
  <A class=def NAME="blackman?">blackman?</A> gen
</pre>

<p>
This produces a Blackman-Harris sum of cosines of order 'n'.  It could be viewed as a special case of pulsed-env, or
as yet another "kernel" along the lines of <a href="#ncos">ncos</a>.
</p>
<br>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-sinc-train">make-sinc-train</A> frequency (n 1)
  <a class=def name="sinc-train">sinc-train</a> gen (fm 0.0)
  <A class=def NAME="sinc-train?">sinc-train?</A> gen
</pre>

<p>
This produces a sinc-train ((sin x)/x) with n components.  It is very similar to <a href="#ncos">ncos</a>.
</p>
<br>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-pink-noise">make-pink-noise</A> (n 1)
  <a class=def name="pink-noise">pink-noise</a> gen
  <A class=def NAME="pink-noise?">pink-noise?</A> gen
</pre>

<p>
This produces a reasonable approximation to 1/f noise, also known as pink-noise. 'n' sets the number of octaves used (starting at the high end);
12 is the recommended choice.  (If n=1, you get white noise).
</p>
<br>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-brown-noise">make-brown-noise</A> frequency (amplitude 1.0)
  <a class=def name="brown-noise">brown-noise</a> gen
  <A class=def NAME="brown-noise?">brown-noise?</A> gen
</pre>

<p>
This produces (unbounded) brownian noise.  'amplitude' sets the maximum size of individual jumps.
</p>
<br>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-green-noise">make-green-noise</A> (frequency 0.0) (amplitude 1.0) (low -1.0) (high 1.0)
  <a class=def name="green-noise">green-noise</a> gen (fm 0.0)
  <A class=def NAME="green-noise?">green-noise?</A> gen

  <A class=def NAME="make-green-noise-interp">make-green-noise-interp</A> (frequency 0.0) (amplitude 1.0) (low -1.0) (high 1.0)
  <a class=def name="green-noise-interp">green-noise-interp</a> gen (fm 0.0)
  <A class=def NAME="green-noise-interp?">green-noise-interp?</A> gen
</pre>

<p>These two generators produce bounded brownian noise; "green-noise" was Michael McNabb's name for it.
Unlike CLM's <a href="#rand">rand</a> or <a href="#rand-interp">rand-interp</a> which
produce white noise centered around 0.0, green-noise wanders around, bouncing off its bounds
every now and then.  This produces a noise that can be similar to pink noise (see some graphs under <a href="#rand">rand</a>).
My informal explanation is that each time we bounce off an edge, we're transferring energy
from a low frequency into some higher frequency.  It is still brownian noise however.
The 'amplitude' argument controls how large individual steps can be; 'low' and 'high' set
the overall output bounds; 'frequency' controls how often a new random number is chosen.
Here's an instrument that fuzzes up its amplitude envelope a bit using green noise:
</p>

<table border=0 cellpadding=5 hspace=20><tr>
<td><pre>
(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (green3 start dur freq amp amp-env noise-freq noise-width noise-max-step)
  (let* ((grn (<em class=red>make-green-noise-interp</em> :frequency noise-freq 
                                       :amplitude noise-max-step 
                                       :high (* 0.5 noise-width) :low (* -0.5 noise-width)))
	 (osc (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> freq))
	 (e (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> amp-env :scaler amp :duration dur))
	 (beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> start))
	 (end (+ beg (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur))))
    (run
     (do ((i beg (+ 1 i)))
	 ((= i end))
       (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> e) 
		  (+ 1.0 (<em class=red>green-noise-interp</em> grn))
		  (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> osc)))))))

(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> () 
  (green3 0 2.0 440 .5 '(0 0 1 1 2 1 3 0) 100 .2 .02))
</pre></td></tr></table>

<br>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-adjustable-square-wave">make-adjustable-square-wave</A> frequency (duty-factor 0.5) (amplitude 1.0)
  <A class=def NAME="adjustable-square-wave">adjustable-square-wave</A> gen (fm 0.0)
  <A class=def NAME="adjustable-square-wave?">adjustable-square-wave?</A> gen

  <A class=def NAME="make-adjustable-triangle-wave">make-adjustable-triangle-wave</A> frequency (duty-factor 0.5) (amplitude 1.0)
  <A class=def NAME="adjustable-triangle-wave">adjustable-triangle-wave</A> gen (fm 0.0)
  <A class=def NAME="adjustable-triangle-wave?">adjustable-triangle-wave?</A> gen

  <A class=def NAME="make-adjustable-sawtooth-wave">make-adjustable-sawtooth-wave</A> frequency (duty-factor 0.5) (amplitude 1.0)
  <A class=def NAME="adjustable-sawtooth-wave">adjustable-sawtooth-wave</A> gen (fm 0.0)
  <A class=def NAME="adjustable-sawtooth-wave?">adjustable-sawtooth-wave?</A> gen
</pre>

<p>
adjustable-square-wave produces a square-wave with optional "duty-factor" (ratio of pulse duration to pulse period).
The other two are similar, producing triangle and sawtooth waves.  There is also an adjustable-oscil.
Use mus-scaler to set the duty-factor at run-time.
</p>

<img src="pix/adjustable.png" alt="mus-scaler adjusts" hspace=40>

<!-- adjustable.png:

(with-sound (:channels 4)
  (let* ((fsamps 500)
	 (freq (radians->hz (/ 1.0 fsamps)))
	 (sq (make-adjustable-square-wave freq 0.01))
	 (sw (make-adjustable-sawtooth-wave freq 0.01))
	 (tr (make-adjustable-triangle-wave freq 0.01))
	 (os (make-adjustable-oscil freq 0.01))
	 (pl (make-pulse-train freq))
	 (dur 1.0)
	 (samps (seconds->samples dur))
	 (ampf (make-env '(0 0 1 1 100 1 101 0) :duration dur))
	 (adjf (make-env '(0 .01 1 .99) :duration dur)))
    (run
    (do ((i 0 (+ 1 i)))
	((= i samps))
      (let ((amp (env ampf))
	    (adj (env adjf))
	    (trigger (pulse-train pl)))

	(if (> trigger 0.1)
	    (begin
	      (set! (mus-scaler sq) adj)
	      (set! (mus-scaler sw) adj)
	      (set! (mus-scaler tr) adj)
	      (set! (mus-scaler os) adj)))

	(outa i (* amp (adjustable-square-wave sq)))
	(outb i (* amp (adjustable-sawtooth-wave sw)))
	(outc i (* amp (adjustable-triangle-wave tr)))
	(outd i (* amp (adjustable-oscil os)))
	)))
    ))

(set! (selected-graph-color) (make-color 1 1 1))
(set! (selected-data-color) (make-color 0 0 0))
(set! (x-axis-label 0 0) "adjustable-square-wave, duty-factor from .01 to .99")
(set! (x-axis-label 0 1) "adjustable-sawtooth-wave")
(set! (x-axis-label 0 2) "adjustable-triangle-wave")
(set! (x-axis-label 0 3) "adjustable-oscil")
(set! (axis-numbers-font) (tiny-font))
(set! (axis-label-font) "10x20")
-->

<p>A similar trick can make, for example, a squared-off triangle-wave:
</p>
<pre>
    (gen (<a class=quiet href="#make-triangle-wave">make-triangle-wave</a> 200.0 :amplitude 4)) ; amp sets slope
    ...
    (outa i (max -1.0 (min 1.0 (<a class=quiet href="#triangle-wave">triangle-wave</a> gen))))
</pre>

<br>
<br>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-round-interp">make-round-interp</A> frequency n amplitude
  <A class=def NAME="round-interp">round-interp</A> gen (fm 0.0)
  <A class=def NAME="round-interp?">round-interp?</A> gen
</pre>

<p>
This is a <a href="#rand-interp">rand-interp</a> generator feeding a <a href="#moving-average">moving-average</a> generator.  "n" is the length of the moving-average;
the higher "n", the more low-passed the output.
</p>
<img src="pix/roundinterp.png" alt="round-interp" hspace=40>

<!--
(with-sound (:channels 5)
  (let ((gen0 (make-round-interp 100 1))
	(gen1 (make-round-interp 100 10))
	(gen2 (make-round-interp 100 100))
	(gen3 (make-round-interp 100 1000))
	(gen4 (make-round-interp 100 10000)))
    (run
       (do ((i 0 (+ 1 i)))
	   ((= i 100000))
	 (out-any i (round-interp gen0) 0)
	 (out-any i (round-interp gen1) 1)
	 (out-any i (round-interp gen2) 2)
	 (out-any i (round-interp gen3) 3)
	 (out-any i (round-interp gen4) 4)))))

(set! (x-axis-label 0 0) "round-interp, n=1")
(set! (x-axis-label 0 1) "round-interp, n=10")
(set! (x-axis-label 0 2) "round-interp, n=100")
(set! (x-axis-label 0 3) "round-interp, n=1000")
(set! (x-axis-label 0 4) "round-interp, n=10000")
(set! (axis-label-font) "-*-times-medium-r-normal-*-20-*-*-*-*-*-*-*")
-->

<br>
<br>


<pre style="background-color: #f2f4ff">
  <A class=def>make-moving-max</A> (n 128)
  <a class=def name="moving-max">moving-max</a> gen y
  <A class=def>moving-max?</A> gen

  <A class=def>make-moving-sum</A> (n 128)
  <a class=def name="moving-sum">moving-sum</a> gen y
  <A class=def>moving-sum?</A> gen

  <A class=def>make-moving-rms</A> (n 128)
  <a class=def name="moving-rms">moving-rms</a> gen y
  <A class=def>moving-rms?</A> gen

  <A class=def>make-moving-length</A> (n 128)
  <a class=def name="moving-length">moving-length</a> gen y
  <A class=def>moving-length?</A> gen

  <A class=def>make-weighted-moving-average</A> n
  <a class=def name="weighted-moving-average">weighted-moving-average</a> gen y
  <A class=def>weighted-moving-average?</A> gen

  <A class=def>make-exponentially-weighted-moving-average</A> n
  <a class=def name="exponentially-weighted-moving-average">exponentially-weighted-moving-average</a> gen y
  <A class=def>exponentially-weighted-moving-average?</A> gen
</pre>

<p>
moving-max is a specialization
of the <a href="#delay">delay</a> generator; it produces an envelope that tracks the peak amplitude of the last 'n' samples.
<code>(make-moving-max 256)</code> returns the generator (this one's window size is 256),
and <code>(moving-max gen y)</code> then returns the envelope traced out by the signal 'y'.
The <a href="sndscm.html#harmonicizer">harmonicizer</a> uses this generator to normalize an in-coming signal to 1.0
so that the Chebyshev polynomials it is driving will produce a full spectrum at all times.
Here is a similar, but simpler, example; we use the moving-max generator to track the
current peak amplitude over a small window, use that value to drive a <a href="#contrast-enhancement">contrast-enhancement</a>
generator (so that its output is always fully modulated), and rescale by the same value
upon output (to track the original sound's amplitude envelope):
</p>

<pre>
    (define (intensify index)
      (let* ((mx (<em class=red>make-moving-max</em>))
	     (flt (<a class=quiet href="sndscm.html#makelowpass" onmouseout="UnTip()" onmouseover="Tip(sndscm_makelowpass_tip)">make-lowpass</a> (* pi .1) 8))) ; smooth the maxamp signal
        (<a class=quiet href="extsnd.html#mapchannel" onmouseout="UnTip()" onmouseover="Tip(extsnd_mapchannel_tip)">map-channel</a> (lambda (y)
		       (let ((amp (max .1 (<a class=quiet href="#fir-filter" onmouseout="UnTip()" onmouseover="Tip(sndclm_fir_filter_tip)">fir-filter</a> flt (<em class=red>moving-max</em> mx y)))))
		         (* amp (<a class=quiet href="#contrast-enhancement" onmouseout="UnTip()" onmouseover="Tip(sndclm_contrast_enhancement_tip)">contrast-enhancement</a> (/ y amp) index)))))))
</pre>

<p>
This can also be used for automatic gain control &mdash; see generators.scm for the agc function.
The other "moving" generators are specializations of the <a href="#moving-average">moving-average</a>
generator.  moving-sum keeps the ongoing sum of absolute values, moving-length the square root of the sum
of squares, and moving-rms the square root of the sum of squares divided by the size.
moving-rms is used in <a href="sndscm.html#overlayrmsenv">overlay-rms-env</a> in draw.scm.
weighted-moving-average weights the
table entries by 1/n.  Similarly exponentially-weighted-moving-average applies exponential weights (it is
actually just a one-pole filter &mdash; this generator wins the "longest-name-for-simplest-effect" award).
Also defined, but not tested, is moving-variance; in the same mold, but not defined, are things like moving-inner-product and moving-distance.
</p>

<br>
<br>


<!-- bessel functions -->
<table border=1 width=200 vspace=10 hspace=20><tr><td bgcolor="#eefdee"><center><h5>Bessel functions</h5></center></td></tr></table>

<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-bess">make-bess</A> (frequency 0.0) (n 0)
  <A class=def NAME="bess">bess</A> gen (fm 0.0)
  <A class=def NAME="bess?">bess?</A> gen
</pre>

<!-- LATEX: & J_{n}(x) = \frac{a}{\sqrt{x}}\sin(x+\delta) + \frac{r_{n}(x)}{x^{\frac{3}{2}}} \\ -->

<p>bess produces the nth Bessel function.  The generator output is scaled to have a maximum of 1.0,
so bess's output is not the same as the raw bessel function value returned by <a href="extsnd.html#besj0">bes-jn</a>.
The "frequency" argument actually makes sense here because the Bessel functions
are close to damped sinusoids after their initial hesitation:
</p>
<img src="pix/sceq24.png" alt="Jn" hspace=40>
<p>
where the variables other than x remain bounded as x increases.  This explains, in a sketchy way, why Jn(cos) and Jn(Jn)
behave like FM.  To see how close these are to FM, compare the expansion of J0(sin) with FM's cos(sin):
</p>

<!-- LATEX:
sceq35:
& J_{0}(B \sin x) = J_{0}^{2}\Big(\frac{B}{2}\Big)+2\sum_{k=1}^{\infty} J_{k}^{2}\Big(\frac{B}{2}\Big)\cos2kx \\
& \cos(B \sin x) = J_{0}(B) + 2 \sum_{k=1}^{\infty} J_{2k}(B) \cos 2kx \\
-->

<img src="pix/sceq35.png" alt="J(sin) and cos(sin)" hspace=40>

<p>Except for jpcos, the rest of the generators in this section suffer a similar fate.  From a waveshaping perspective,
we're using a sinusoid, or a modulated sinusoid, to index into the near-zero portion of a Bessel
function, and the result is sadly reminiscent of standard FM.  But they're such pretty formulas;
I must be missing something.
</p>

<br>
<br>

<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-j0evencos">make-j0evencos</A> (frequency 0.0) (index 1.0)
  <A class=def NAME="j0evencos">j0evencos</A> gen (fm 0.0)
  <A class=def NAME="j0evencos?">j0evencos?</A> gen
</pre>

<p>j0evencos produces the J0(index * sin(x)) case mentioned above (with the DC component subtracted out).
If you sweep the index, the bandwidth is the same as in normal FM (J2k(B) is about 3log(k)*Jk(B/2)^2),
but the B/2 factor causes
the individual component amplitudes to follow the Bessel functions half as fast. 
So j0evencos produces a spectral sweep that is like FM's but smoother.
</p>

<table border=0 hspace=40 cellspacing=20><tr><td>
<img src="pix/j0fm.png" alt="compare FM and j0evencos">
</td><td>
<img src="pix/j0jfm.png" alt="compare FM and j0evencos">
</td></tr>
<tr> <td colspan=2>
<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:channels 2)
  (let* ((dur 1.0)
         (end (<a class=quiet href="#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur))
         (jmd (<em class=red>make-j0evencos</em> 200.0))
	 (fmd (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> 200.0))
         (ampf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0  1 1  20 1  21 0) :scaler 0.5 :duration dur))
         (indf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0  1 20) :duration dur)))
    (do ((i 0 (+ 1 i)))
	((= i end))
      (let ((ind (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> indf))
	    (vol (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> ampf)))
	(set! (<em class=red>j0evencos-index</em> jmd) ind)
	(<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* vol (- (cos (* ind (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> fmd))) 
                          (<a class=quiet href="extsnd.html#besj0" onmouseout="UnTip()" onmouseover="Tip(extsnd_besj0_tip)">bes-j0</a> ind)))) ; subtract out DC (see cos(B sin x) above)
	(<a class=quiet href="#out-any" onmouseout="UnTip()" onmouseover="Tip(sndclm_outb_tip)">outb</a> i (* vol (<em class=red>j0evencos</em> jmd)))))))
</pre>
</td></tr>
</table>



<!--
snd -horizontal

(define* (fm beg dur freq amp mc-ratio index (index-env '(0 1 100 1)))
  (let* ((start (seconds->samples beg))
         (end (+ start (seconds->samples dur)))
         (md (make-oscil (* freq mc-ratio)))
         (ampf (make-env '(0 0 1 1 20 1 21 0) :scaler amp :duration dur)) 
         (indf (make-env index-env :scaler index :duration dur)))
    (run
       (do ((i start (+ 1 i)))
	   ((= i end))
	 (let ((ind (env indf)))
	   (outa i (* (env ampf)  
		      (- (cos (* ind (oscil md)))
			 (bes-j0 ind)))))))))

(with-sound (:output "test.snd") (fm 0 1.0 2000.0 0.5 .1 20.0 '(0 0 1 1)))

(define* (jfm beg dur freq amp mc-ratio index (index-env '(0 1 100 1)))
  (let* ((start (seconds->samples beg))
         (end (+ start (seconds->samples dur)))
         (md (make-j0evencos (* freq mc-ratio)))
         (ampf (make-env '(0 0 1 1 20 1 21 0) :scaler amp :duration dur)) 
         (indf (make-env index-env :scaler index :duration dur)))
    (run
       (do ((i start (+ 1 i)))
	   ((= i end))
	 (set! (j0evencos-index md) (env indf))
	 (outa i (* (env ampf)
                    (j0evencos md)))))))

(with-sound (:output "test1.snd") (jfm 0 1.0 2000.0 0.5 .1 20.0 '(0 0 1 1)))

x 314 1.36
y 327 .4
z 0 1.9
4 0.24
blackman6 2048

(set! (selected-graph-color) (make-color 1 1 1))
-->
<br>

<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-j0j1cos">make-j0j1cos</A> (frequency 0.0) (index 0.0)
  <A class=def NAME="j0j1cos">j0j1cos</A> gen fm
  <A class=def NAME="j0j1cos?">j0j1cos?</A> gen
</pre>

<img src="pix/sceq36.png" alt="j0j1 formulsa" hspace=40>

<p>
This uses J0(index * cos(x)) + J1(index * cos(x)) to produce a full set of cosines.  It is not yet normalized correctly,
and is very similar to normal FM.
</p>

<br>

<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-izcos">make-izcos</A> (frequency 0.0) (r 1.0)
  <A class=def NAME="izcos">izcos</A> gen (fm 0.0)
  <A class=def NAME="izcos?">izcos?</A> gen
</pre>

<img src="pix/sceq39.png" alt="I(k) sum" hspace=40>

<p>This produces a sum of cosines scaled by In(r), again very similar to normal FM.
</p>



<br>

<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-jjcos">make-jjcos</A> (frequency 0.0) (r 0.5) (a 1.0) (k 1.0)
  <A class=def NAME="jjcos">jjcos</A> gen (fm 0.0)
  <A class=def NAME="jjcos?">jjcos?</A> gen

  <A class=def NAME="make-j2cos">make-j2cos</A> (frequency 0.0) (r 0.5) (n 1)
  <A class=def NAME="j2cos">j2cos</A> gen (fm 0.0)
  <A class=def NAME="j2cos?">j2cos?</A> gen

  <A class=def NAME="make-jpcos">make-jpcos</A> (frequency 0.0) (r 0.5) (a 0.0) (k 1.0)
  <A class=def NAME="jpcos">jpcos</A> gen (fm 0.0)
  <A class=def NAME="jpcos?">jpcos?</A> gen

  <A class=def NAME="make-jncos">make-jncos</A> (frequency 0.0) (r 0.5) (a 1.0) (n 0)
  <A class=def NAME="jncos">jncos</A> gen (fm 0.0)
  <A class=def NAME="jncos?">jncos?</A> gen
</pre>

<p>These produce a sum of cosines scaled by a product of Bessel functions; in a sense, there are two, or maybe three "indices".
Normalization is handled correctly at least for jpcos.  Of the four, jpcos seems the most interesting.  "a" should not equal "r";
in general as a and r approach 1.0, the spectrum approaches "k" components, sometimes in a highly convoluted manner.
</p>

<table border=0 hspace=40 cellspacing=10>
<tr><td>jjcos:</td><td width=10></td><td><img src="pix/sceq31.png" alt="more sums"></td></tr>
<tr><td>j2cos:</td><td width=10></td><td><img src="pix/sceq34.png" alt="more sums"></td></tr>
<tr><td>jpcos:</td><td width=10></td><td><img src="pix/sceq33.png" alt="more sums"></td></tr>
<tr><td>jncos:</td><td width=10></td><td><img src="pix/sceq32.png" alt="more sums"></td></tr>
</table>

<br>

<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-jycos">make-jycos</A> (frequency 0.0) (r 1.0) (a 1.0)
  <A class=def NAME="jycos">jycos</A> gen (fm 0.0)
  <A class=def NAME="jycos?">jycos?</A> gen
</pre>

<p>This uses bes-y0 to produce components scaled by Yn(r)*Jn(a).  bes-y0(0) is -inf, so a^2 + r^2 should be greater than 2ar,
and r should be greater than 0.0.  Tricky to use.  (If you get an inf or a NaN from division by zero or whatever in Scheme,
both the time and frequency graphs will be unhappy).
</p>

<br><br>




<!-- finite sums -->
<table border=1 width=200 vspace=10 hspace=20><tr><td bgcolor="#eefdee"><center><h5>finite sums</h5></center></td></tr></table>

<p>These generators produce a set of n sinusoids.
With a bit of bother, 
they could be done with polywave.  I don't
think there would be any difference, even taking FM into account. 
</p>

<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-nssb">make-nssb</A> (frequency 0.0) (ratio 1.0) (n 1)
  <A class=def NAME="nssb">nssb</A> gen (fm 0.0)
  <A class=def NAME="nssb?">nssb?</A> gen
</pre>

<p>nssb is the single side-band version of ncos and nsin.  It is very similar to <a href="#nxysin">nxysin</a> and <a href="#nxycos">nxycos</a>.
</p>

<br>

<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-ncos2" onmouseout="UnTip()" onmouseover="Tip('<img src=\'pix/fejer.png\' width=\'320\' height=\'170\'>', TITLE, 'ncos2 (Fejer), n=10', ABOVE, true)">make-ncos2</A> (frequency 0.0) (n 1)
  <A class=def NAME="ncos2" onmouseout="UnTip()" onmouseover="Tip('<img src=\'pix/fejer.png\' width=\'320\' height=\'170\'>', TITLE, 'ncos2 (Fejer), n=10', ABOVE, true)">ncos2</A> gen (fm 0.0)
  <A class=def NAME="ncos2?">ncos2?</A> gen
</pre>

<p>This is the Fejer kernel.  The i-th harmonic amplitude is (n-i)/(n+1).
</p>

<!-- LATEX: &\frac{\sin^{2} \frac{1}{2}nx}{\sin^{2} \frac{1}{2}x} = \frac{n}{2} + \sum_{k=1}^{n-1} (n-k)\cos kx -->

<img src="pix/sceq23.png" alt="sum of cosines" hspace=40><br>
<br>

<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-ncos4" onmouseout="UnTip()" onmouseover="Tip('<img src=\'pix/jackson.png\' width=\'320\' height=\'170\'>', TITLE, 'ncos4 (Jackson), n=10', ABOVE, true)">make-ncos4</A> (frequency 0.0) (n 1)
  <A class=def NAME="ncos4" onmouseout="UnTip()" onmouseover="Tip('<img src=\'pix/jackson.png\' width=\'320\' height=\'170\'>', TITLE, 'ncos4 (Jackson), n=10', ABOVE, true)">ncos4</A> gen (fm 0.0)
  <A class=def NAME="ncos4?">ncos4?</A> gen
</pre>

<p>This is the Jackson kernel, the square of ncos2.
</p>

<!-- LATEX: &\Bigg(\frac{\sin(n+\frac{1}{2})x}{\sin \frac{x}{2}}\Bigg)^{4} -->
<!-- pointless...
<img src="pix/sceq24.png" alt="sum of cosines" hspace=40>
-->



<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-npcos" onmouseout="UnTip()" onmouseover="Tip('<img src=\'pix/poussin.png\' width=\'320\' height=\'170\'>', TITLE, 'npcos (Poussin), n=5', ABOVE, true)">make-npcos</A> (frequency 0.0) (n 1)
  <A class=def NAME="npcos" onmouseout="UnTip()" onmouseover="Tip('<img src=\'pix/poussin.png\' width=\'320\' height=\'170\'>', TITLE, 'npcos (Poussin), n=5', ABOVE, true)">npcos</A> gen (fm 0.0)
  <A class=def NAME="npcos?">npcos?</A> gen
</pre>

<p>This is the Poussin kernel, a combination of two ncos2 generators, one at "n" subtracted from twice another at 2n+1.
</p>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-n1cos">make-n1cos</A> (frequency 0.0) (n 1)
  <A class=def NAME="n1cos">n1cos</A> gen (fm 0.0)
  <A class=def NAME="n1cos?">n1cos?</A> gen
</pre>

<p>Another spikey waveform, very similar to ncos2 above.
</p>

<img src="pix/sceq45.png" alt="linear cosines" hspace=20>


<br>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-nxycos">make-nxycos</A> (frequency 0.0) (ratio 1.0) (n 1)
  <A class=def NAME="nxycos">nxycos</A> gen (fm 0.0)
  <A class=def NAME="nxycos?">nxycos?</A> gen

  <A class=def NAME="make-nxysin">make-nxysin</A> (frequency 0.0) (ratio 1.0) (n 1)
  <A class=def NAME="nxysin">nxysin</A> gen (fm 0.0)
  <A class=def NAME="nxysin?">nxysin?</A> gen

  <A class=def NAME="make-nxy1cos">make-nxy1cos</A> (frequency 0.0) (ratio 1.0) (n 1)
  <A class=def NAME="nxy1cos">nxy1cos</A> gen (fm 0.0)
  <A class=def NAME="nxy1cos?">nxy1cos?</A> gen

  <A class=def NAME="make-nxy1sin">make-nxy1sin</A> (frequency 0.0) (ratio 1.0) (n 1)
  <A class=def NAME="nxy1sin">nxy1sin</A> gen (fm 0.0)
  <A class=def NAME="nxy1sin?">nxy1sin?</A> gen
</pre>
<p>These produce a sum of "n" sinsoids starting at "frequency", spaced by "ratio".  Since "frequency" can be treated
as the carrier, there's no point in an ssb version.  nxy1cos is the same as nxycos, but every other
component is multiplied by -1, and "n" produces 2n components.
Normalization in the "sin" cases is tricky.  If ratio is 1, we can use nsin's normalization, and if ratio = 2, noddsin's,
but otherwise nxysin currently uses 1/n.  This ensures that the generator output is always between -1 and 1,
but in some cases (mainly involving low "n" and simple "ratio"), the output might not be full amplitude.  nxy1sin is
even trickier, so it divides by "n".
</p>

<br>

<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-noddcos">make-noddcos</A> (frequency 0.0) (n 1)
  <A class=def NAME="noddcos">noddcos</A> gen (fm 0.0)
  <A class=def NAME="noddcos?">noddcos?</A> gen

  <A class=def NAME="make-noddsin">make-noddsin</A> (frequency 0.0) (n 1)
  <A class=def NAME="noddsin">noddsin</A> gen (fm 0.0)
  <A class=def NAME="noddsin?">noddsin?</A> gen

  <A class=def NAME="make-noddssb">make-noddssb</A> (frequency 0.0) (ratio 1.0) (n 1)
  <A class=def NAME="noddssb">noddssb</A> gen (fm 0.0)
  <A class=def NAME="noddssb?">noddssb?</A> gen
</pre>


<!-- LATEX: &\sum_{k=1}^{n}\cos(2k-1)x=\frac{1}{2}\frac{\sin 2nx}{\sin x} \\ -->

<p>These produce the sum of "n" equal amplitude odd-numbered sinusoids:
</p>

<img src="pix/sceq29.png" alt="sum of cosines" hspace=40><br>

<!-- LATEX: &\sum_{k=1}^{n}\sin(2k-1)x=\frac{\sin^{2}nx}{\sin x} \\ -->

<img src="pix/sceq28.png" alt="sum of sines" hspace=40><br>

<p>The corresponding "even" case is the same as ncos with twice the frequency.  noddsin produces a somewhat clarinet-like tone:
</p>

<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:play #t)
  (let ((gen (<em class=red>make-noddsin</em> 300 :n 3))
	(ampf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1 2 1 3 0) :length 40000 :scaler .5)))
    (run
      (do ((i 0 (+ 1 i)))
	  ((= i 40000))
	(<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> ampf) (<em class=red>noddsin</em> gen)))))))
</pre>

<p>noddsin normalization is the same as nsin.  The peak happens half as far from the 0 crossing as in nsin (3pi/(4n) for nsin, 
and 3pi/(8n) for noddsin (assuming large n)), and its amplitude is 8n*sin^2(3pi/8)/(3pi), just as in nsin.  The noddsin generator scales its output
by the inverse of this, so it is always between -1 and 1.
</p>
<br>

<!--
(%i1) (sin(A+((n+1)/2*X))*sin(n*X/2))/sin(X/2);
                              n X      (n + 1) X
                          sin(---) sin(--------- + A)
                               2           2
(%o1)                     ---------------------------
                                        X
                                    sin(-)
                                        2
(%i2) diff(%i1, X)
;
            X      n X      (n + 1) X              n X      (n + 1) X
        cos(-) sin(---) sin(--------- + A)   n cos(---) sin(--------- + A)
            2       2           2                   2           2
(%o2) - ---------------------------------- + -----------------------------
                         2 X                                 X
                    2 sin (-)                          2 sin(-)
                           2                                 2
                                                        n X      (n + 1) X
                                            (n + 1) sin(---) cos(--------- + A)
                                                         2           2
                                          + -----------------------------------
                                                               X
                                                         2 sin(-)
                                                               2

(%i9) trigsimp(%o2); 
              X      n X          X      n X       (n + 1) X + 2 A
(%o9) - ((cos(-) sin(---) - n sin(-) cos(---)) sin(---------------)
              2       2           2       2               2
                                  X      n X      (n + 1) X + 2 A         2 X
                  + (- n - 1) sin(-) sin(---) cos(---------------))/(2 sin (-))
                                  2       2              2                  2
-->


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-nrcos">make-nrcos</A> (frequency 0.0) (n 1) (r 0.5)             ; -1.0 &lt; r &lt; 1.0
  <A class=def NAME="nrcos">nrcos</A> gen (fm 0.0)
  <A class=def NAME="nrcos?">nrcos?</A> gen

  <A class=def NAME="make-nrsin">make-nrsin</A> (frequency 0.0) (n 1) (r 0.5)             ; -1.0 &lt; r &lt; 1.0
  <A class=def NAME="nrsin">nrsin</A> gen (fm 0.0)
  <A class=def NAME="nrsin?">nrsin?</A> gen

  <A class=def NAME="make-nrssb">make-nrssb</A> (frequency 0.0) (ratio 1.0) (n 1) (r 0.5) ; 0.0 &lt;= r &lt; 1.0
  <A class=def NAME="nrssb">nrssb</A> gen (fm 0.0)
  <A class=def NAME="nrssbinterp">nrssb-interp</A> gen fm interp
  <A class=def NAME="nrssb?">nrssb?</A> gen
</pre>

<p>These produce the sum of "n" sinusoids, with successive sinusoids scaled by "r"; the nth component has amplitude r^n.
nrsin is just a wrapper for <a href="#nrxysin">nrxysin</a>, and the other two are obviously variants of <a href="#nrxycos">nrxycos</a>.
In the nrssb-interp generator, the "interp" argument interpolates between the upper (interp=1.0) and lower (interp=-1.0) side bands.
</p>

<p>The instrument lutish uses nrcos: <code>lutish beg dur freq amp</code>:
</p>

<pre>
    (<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:play #t)
      (do ((i 0 (+ 1 i)))
          ((= i 10))
        (lutish (* i .1) 2 (* 100 (+ 1 i)) .05)))
</pre>

<p>The instrument oboish uses nrssb: <code>oboish beg dur freq amp amp-env</code>:
</p>

<pre>
    (<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:play #t)
      (do ((i 0 (+ 1 i)))
          ((= i 10))
        (oboish (* i .3) .4 (+ 100 (* 50 i)) .05 '(0 0 1 1 2 1 3 0))))
</pre>

<p>organish also uses nrssb: <code>organish beg dur freq amp fm-index amp-env</code>:
</p>

<pre>
    (<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:play #t)
      (do ((i 0 (+ 1 i)))
          ((= i 10))
        (organish (* i .3) .4 (+ 100 (* 50 i)) .5 1.0 #f)))
</pre>

<br>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-nkssb">make-nkssb</A> (frequency 0.0) (ratio 1.0) (n 1)
  <A class=def NAME="nkssb">nkssb</A> gen (fm 0.0)
  <A class=def NAME="nkssbinterp">nkssb-interp</A> gen fm interp
  <A class=def NAME="nkssb?">nkssb?</A> gen
</pre>

<p>This generator produces the single side-band version of the sum of "n" sinusoids, where the nth component has amplitude n.
In the nkssb-interp generator, the "interp" argument interpolates between the upper and lower side bands.
The instrument nkssber uses nkssb-interp:
</p>

<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:play #t)
  (nkssber 0 1 1000 100 5 5 0.5)
  (nkssber 1 2 600 100 4 1 0.5)
  (nkssber 3 2 1000 540 3 3 0.5)
  (nkssber 5 4 300 120 2 0.25 0.5)
  (nkssber 9 1 30 4 40 0.5 0.5)
  (nkssber 10 1 20 6 80 0.5 0.5))
</pre>
<br>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-nsincos">make-nsincos</A> (frequency 0.0) (n 1)
  <A class=def NAME="nsincos">nsincos</A> gen (fm 0.0)
  <A class=def NAME="nsincos?">nsincos?</A> gen
</pre>

<p>This generator produces a sum of n cosines scaled by sin(k*pi/(n+1))/sin(pi/(n+1)).
</p>
<br>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-nchoosekcos">make-nchoosekcos</A> (frequency 0.0) (ratio 1.0) (n 1)
  <A class=def NAME="nchoosekcos">nchoosekcos</A> gen (fm 0.0)
  <A class=def NAME="nchoosekcos?">nchoosekcos?</A> gen
</pre>

<p>This generator produces a sum of n cosines scaled by the binomial coefficients.  If n is even, the last term is halved.
All these "finite sum" generators are a bit inflexible, and sound more or less the same.  One (desperate) countermeasure
is amplitude modulation:
</p>

<table border=0 hspace=20>
<tr><td>
<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> ()
  (let ((modulator (<em class=red>make-nchoosekcos</em> 100.0 1.0 4))
	(carrier (<a class=quiet href="#make-nrcos">make-nrcos</a> 2000.0 :n 3 :r .5)))
    (do ((i 0 (+ 1 i))) ((= i 20000))
      (<a class=quiet href="#outa">outa</a> i (* .5 (<a class=quiet href="#nrcos">nrcos</a> carrier) 
                    (<em class=red>nchoosekcos</em> modulator))))))
</pre>
</td><td>
<img src="pix/nkcos.png" alt="am nchoosekcos">
</td></tr></table>

<br><br>



<!-- infinite sums -->
<table border=1 width=200 vspace=10 hspace=20><tr><td bgcolor="#eefdee"><center><h5>infinite sums</h5></center></td></tr></table>

<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-rcos">make-rcos</A> (frequency 0.0) (r 0.5) ; -1.0 &lt; r &lt; 1.0
  <A class=def NAME="rcos">rcos</A> gen (fm 0.0)
  <A class=def NAME="rcos?">rcos?</A> gen

  <A class=def NAME="make-rssb">make-rssb</A> (frequency 0.0) (ratio 1.0) (r 0.5) ; -1.0 &lt; r &lt; 1.0
  <A class=def NAME="rssb">rssb</A> gen (fm 0.0)
  <A class=def NAME="rssbinterp">rssb-interp</A> gen fm interp
  <A class=def NAME="rssb?">rssb?</A> gen

  <A class=def NAME="make-rxycos">make-rxycos</A> (frequency 0.0) (ratio 1.0) (r 0.5) ; -1.0 &lt; r &lt; 1.0
  <A class=def NAME="rxycos">rxycos</A> gen (fm 0.0)
  <A class=def NAME="rxycos?">rxycos?</A> gen

  <A class=def NAME="make-rxysin">make-rxysin</A> (frequency 0.0) (ratio 1.0) (r 0.5) ; -1.0 &lt; r &lt; 1.0
  <A class=def NAME="rxysin">rxysin</A> gen (fm 0.0)
  <A class=def NAME="rxysin?">rxysin?</A> gen
</pre>

<p>These generators produce an infinite sum of sinusoids, each successive component scaled by "r" (so the nth component has amplitude r^n).
The bump instrument uses rssb-interp: <code>bump beg dur freq amp f0 f1 f2</code>:
</p>

<table border=0 hspace=20><tr><td>
<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:play #t)
  (do ((k 0 (+ 1 k))) 
      ((= k 10))
    (bump (* 0.4 k) 1 (* 16.3 (expt 2.0 (+ 3 (/ k 12)))) .5 520 1190 2390))
  (do ((k 0 (+ 1 k))) 
      ((= k 10))
    (let* ((freq (* 16.3 (expt 2.0 (+ 3 (/ k 12)))))
	   (scl (sqrt (/ freq 120))))
      (bump (+ 4 (* 0.4 k)) 1 freq  .5 (* scl 520) (* scl 1190) (* scl 2390)))))
</pre>
</td></tr></table>

<p>As with all the "infinite sums" generators, aliasing is a major concern.  We can use the following
relatively conservative function to find the highest safe "r" given the current fundamental and sampling rate:
</p>

<pre>
   (define (safe-r-max freq srate) ; the safe-rxycos generator in generators.scm has this built-in
     (expt .001 (/ 1.0 (floor (/ srate (* 3 freq))))))
</pre>


<table border=0>
<tr><td>
<p>
If you go over that value, be prepared for some very unintuitive behavior!  For example,
at an srate of 44100:
</p>

<table border=0 hspace=20><tr><td>
<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:channels 2)
  (let* ((gen1 (<em class=red>make-rcos</em> 1050 0.99))
         ;; r=.6 or so is the safe max
	 (gen2 (<em class=red>make-rcos</em> 1048 0.99)))
    (do ((i 0 (+ 1 i)))
	((= i 88200))
      (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (<em class=red>rcos</em> gen1))
      (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outb_tip)">outb</a> i (<em class=red>rcos</em> gen2)))))
</pre>
</td></tr></table>

<p>In the first case, all the aliased harmonics line up perfectly with the
unaliased ones because 21*1050 is 22050, but in the second case,
we get (for example) the strong 84 Hz component because the 42nd harmonic
which falls at 44100 - 42*1048 = 84 still has an amplitude of 0.99^42 = .66!
</p>
</td><td>
<img src="pix/rcos.png" alt="rcos aliased">
</td></tr></table>

<p>Another artifact of aliasing is that at some frequencies, 
for example at 100 Hz, and a sampling rate of 44100, if r is -0.99 and the initial phase is 0.5*pi, or if r is 0.99 and the initial phase is 1.5*pi, the peak amp
is only 0.6639.  Finally(?),
there's a sharp discontinuity (a click) as you sweep r through 0.0.  As in nrxycos, the waveforms produced by r and -r
are the same, but there's an overall phase difference of pi.  
</p>

<p>Other notes: the output of rssb is not normalized, nor is rxysin.
</p>

<!--
(set! (x-axis-label 0 0 0) "rcos freq=1050 r=.99")
(set! (x-axis-label 0 1 0) "rcos freq=1048 r=.99")
(set! (axis-label-font) "9x15")
-->

<br>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-ercos">make-ercos</A> (frequency 0.0) (r 0.5) ; r &gt; 0.0
  <A class=def NAME="ercos">ercos</A> gen (fm 0.0)
  <A class=def NAME="ercos?">ercos?</A> gen

  <A class=def NAME="make-erssb">make-erssb</A> (frequency 0.0) (ratio 1.0) (r 0.5)
  <A class=def NAME="erssb">erssb</A> gen (fm 0.0)
  <A class=def NAME="erssb?">erssb?</A> gen
</pre>

<p>These produce a sum of sinusoids, each scaled by e^(-kr), a special case of rcos.  Our safe (minimum) "r" here becomes <code>(/ (log 0.001) (floor (/ srate (* -3 freq))))</code>.
The ercoser instrument uses ercos:
<code>ercoser beg dur freq amp r</code>:
</p>

<pre>
    (<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:play #t)
      (ercoser 0 1 100 .5 0.1))
</pre>
<br>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-eoddcos">make-eoddcos</A> (frequency 0.0) (r 0.5)
  <A class=def NAME="eoddcos">eoddcos</A> gen (fm 0.0)
  <A class=def NAME="eoddcos?">eoddcos?</A> gen
</pre>

<p>This produces a sum of odd harmonics, each scaled by e^r(2k-1)/(2k-1).  As "r" approches 0.0, this approaches a square wave.
</p>

<pre>
    (<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:play #t)
      (let ((gen1 (<em class=red>make-eoddcos</em> 400.0 :r 0.0))
	    (gen2 (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> 400.0))
	    (a-env (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1) :length 10000)))
        (do ((i 0 (+ 1 i)))
	    ((= i 10000))
	  (set! (eoddcos-r gen1) (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> a-env))
 	  (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* .5 (<em class=red>eoddcos</em> gen1 (* .1 (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> gen2))))))))
</pre>
<br>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-rkcos">make-rkcos</A> (frequency 0.0) (r 0.5) ; -1.0 &lt; r &lt; 1.0
  <A class=def NAME="rkcos">rkcos</A> gen (fm 0.0)
  <A class=def NAME="rkcos?">rkcos?</A> gen

  <A class=def NAME="make-rksin">make-rksin</A> (frequency 0.0) (r 0.5) ; -1.0 &lt; r &lt; 1.0
  <A class=def NAME="rksin">rksin</A> gen (fm 0.0)
  <A class=def NAME="rksin?">rksin?</A> gen

  <A class=def NAME="make-rkssb">make-rkssb</A> (frequency 0.0) (ratio 1.0) (r 0.5) ; -1.0 &lt; r &lt; 1.0
  <A class=def NAME="rkssb">rkssb</A> gen (fm 0.0)
  <A class=def NAME="rkssb?">rkssb?</A> gen
</pre>

<!--
(with-sound (:output "r7.snd")
  (let ((gen (make-rksin 100.0 :r .7)))
    (do ((i 0 (+ 1 i)))
        ((= i 44100))
      (outa i (* 0.5 (rksin gen))))))
-->

<p>These produce a sum of sinusoids scaled by (r^k)/k.  As r approaches 1.0 or -1.0, rksin approaches a sawtooth.  
</p>

<img src="pix/rksin3.png" alt="sawtooths" hspace=40>

<p>As with rcos, we
can calculate the safe maximum r, given the current srate and frequency (this function is perhaps too cautious...):
</p>

<pre>
    (define (safe-rk-max freq srate)
      (let ((topk (floor (/ srate (* 3 freq)))))
        (min 0.999999 (expt (* .001 topk) (/ 1.0 topk)))))
</pre>

<p>Similar to rkcos is (expt (asin (sqrt (oscil x))) 2).
rksin and rkcos provide a nice demonstration of how insensitive the ear is to phase.  These two waveforms look different, but
have the same timbre. The sawtooth sounds louder to me, despite having the same peak amplitude.
</p>

<table border=0 hspace=20>
<tr><td>
<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:channels 2)
  (let ((gen1 (<em class=red>make-rkcos</em> 200.0 :r 0.9))
        (gen2 (<em class=red>make-rksin</em> 200.0 :r 0.9)))
    (do ((i 0 (+ 1 i)))
	((= i 100000))
      (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* .95 (<em class=red>rkcos</em> gen1)))
      (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outb_tip)">outb</a> i (* .95 (<em class=red>rksin</em> gen2))))))

<em class=typing>&gt;</em> <em class=listener>(channel-rms 0 0)</em> ; from dsp.scm
<em class=typing>0.305301097090353</em>
<em class=typing>&gt;</em> <em class=listener>(channel-rms 0 1)</em>
<em class=typing>0.627769794744852</em>
</pre>
</td><td>
<img src="pix/rksin.png" alt="sin vs cos" hspace=30>
</td></tr></table>

<p>We might conclude that the RMS value gives the perceived amplitude, but
in the next case, the RMS values are the same, and the peak amplitudes
differ by a factor of 3.  I think the one with the higher peak amplitude sounds louder.
</p>

<table border=0 hspace=20>
<tr><td>
<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:channels 2)
  (let* ((gen1 (<a class=quiet href="#make-adjustable-square-wave">make-adjustable-square-wave</a> 400 
		 :duty-factor .75 :amplitude .25))
	 (gen2 (<a class=quiet href="#make-adjustable-square-wave">make-adjustable-square-wave</a> 400 
                 :duty-factor .11 :amplitude .75))
	 (flt1 (<a class=quiet href="#make-moving-average">make-moving-average</a> 10))
	 (flt2 (<a class=quiet href="#make-moving-average">make-moving-average</a> 10)))
    (do ((i 0 (+ 1 i)))
	((= i 50000))
      (<a class=quiet href="#outa">outa</a> i (<a class=quiet href="#moving-average">moving-average</a> flt1 
                (<a class=quiet href="#adjustable-square-wave">adjustable-square-wave</a> gen1)))
      (<a class=quiet href="#outa">outb</a> i (<a class=quiet href="#moving-average">moving-average</a> flt2 
                (<a class=quiet href="#adjustable-square-wave">adjustable-square-wave</a> gen2))))))
</pre>
</td><td>
<img src="pix/rmspk.png" alt="rms vs peak" hspace=30>
</td></tr></table>

<p>Since clipping is a disaster, we focus on peak amplitudes in the generators.
</p>


<!--
(set! (selected-graph-color) (make-color 1 1 1))
(set! (selected-data-color) (make-color 0 0 0))

(set! (x-axis-label 0 0) "rkcos, r=.9")
(set! (x-axis-label 0 1) "rksin, r=.9")
(set! (axis-label-font) "9x15")

(set! (x-axis-label 0 0) "rms: .21, peak amp: .25")
(set! (x-axis-label 0 1) "rms: .21, peak amp: .75")
-->

<br>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-rk!cos">make-rk!cos</A> (frequency 0.0) (r 0.5)  ; rk!cos is a special case of rxyk!cos
  <A class=def NAME="rk!cos">rk!cos</A> gen (fm 0.0)
  <A class=def NAME="rk!cos?">rk!cos?</A> gen

  <A class=def NAME="make-rk!ssb">make-rk!ssb</A> (frequency 0.0) (ratio 1.0) (r 0.5)
  <A class=def NAME="rk!ssb">rk!ssb</A> gen (fm 0.0)
  <A class=def NAME="rk!ssb?">rk!ssb?</A> gen

  <A class=def NAME="make-rxyk!cos">make-rxyk!cos</A> (frequency 0.0) (ratio 1.0) (r 0.5)
  <A class=def NAME="rxyk!cos">rxyk!cos</A> gen (fm 0.0)
  <A class=def NAME="rxyk!cos?">rxyk!cos?</A> gen

  <A class=def NAME="make-rxyk!sin">make-rxyk!sin</A> (frequency 0.0) (ratio 1.0) (r 0.5)
  <A class=def NAME="rxyk!sin">rxyk!sin</A> gen (fm 0.0)
  <A class=def NAME="rxyk!sin?">rxyk!sin?</A> gen
</pre>


<!-- LATEX: for rk!cos
&\sum_{k=1}^{\infty}\frac{p^{k}\sin kx}{k!} = e^{p\cos x}\sin(p\sin x) \\
&\sum_{k=0}^{\infty}\frac{p^{k}\cos kx}{k!} = e^{p\cos x}\cos(p\sin x) \\
-->

<table border=0>
<tr>
<td>
<p>These produce a sum of sinusoids scaled by (r^k)/k!.  
The k! denominator dominates eventually, so r * ratio * frequency is approximately the spectral center
(the ratio between successive harmonic amplitudes is (r^(k+1)/(k+1)!)/(r^k/k!) = r/(k+1), which
becomes less than 1.0 at k=r).
For example, in the graph on the right, the frequency is 100 and r is 30, so the center of the spectrum is around 3kHz.
Negative "r" gives the same spectrum as positive, but the waveform's initial-phase is shifted by pi.
The (very) safe maximum "r" is:
</p>
<pre>
  (define (safe-rk!-max freq srate)
    (let ((topk (floor (/ srate (* 3 freq)))))
      (expt (* .001 (factorial topk)) (/ 1.0 topk))))
                  ;; factorial is in numerics.scm
</pre>
</td><td>
<img src="pix/rkbang.png" alt="rk!cos spectrum" hspace=30>
</td></tr></table>

<p>As in other such cases, varying "r" gives changing spectra.  You can sweep r through 0 smoothly except in rk!cos where you'll get a click.
Coupled with the fm argument, these generators provide an extension of multi-carrier FM, similar in effect to the "leap-frog" FM voice.
Here is a use of rk!cos to make a bird twitter:
</p>

<pre>
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:play #t :scaled-to .5)
  (do ((k 0 (+ 1 k)))
      ((= k 6))
    (let ((gen (<em class=red>make-rk!cos</em> 3000.0 :r 0.6)) 
          (ampf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1 2 1 3 0) :length 3000))
	  (frqf (<a class=quiet href="#make-env" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_env_tip)">make-env</a> '(0 0 1 1) :base .1 :scaler (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> 2000) :length 3000)))
      (run 
       (do ((i 0 (+ 1 i)))
	   ((= i 3000)) 
	 (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> (+ i (* k 4000)) 
	       (* (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> ampf) 
		  (<em class=red>rk!cos</em> gen (<a class=quiet href="#env" onmouseout="UnTip()" onmouseover="Tip(sndclm_env_tip)">env</a> frqf)))))))))
</pre>

<p>The instrument bouncy uses rk!ssb: <code>bouncy beg dur freq amp (bounce-freq 5) (bounce-amp 20)</code>
</p>

<pre>
    (<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:play #t)
      (bouncy 0 2 200 .5 3 2))
</pre>

<p>brassy (also in generators.scm) uses rxyk!cos, but it is more of an experiment with envelopes than spectra.
It takes a gliss envelope and turns it into a series of quick jumps between harmonics, handling both the
pitch and the index ("r") of the rxyk!cos generator.  The effect is vaguely brass-like.
</p>

<br>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-r2k!cos">make-r2k!cos</A> (frequency 0.0) (r 0.5) (k 0.0)
  <A class=def NAME="r2k!cos">r2k!cos</A> gen (fm 0.0)
  <A class=def NAME="r2k!cos?">r2k!cos?</A> gen
</pre>

<p>
This generator produces a sum of cosines with a complicated-looking formula for
the component amplitudes.  It's actually pretty simple, as this graph shows.
The "F" notation stands for a hypergeometric series, a generalization
of sinusoids and Bessel functions.  
</p>

<!-- LATEX: sceq30:
  &(1 - 2r \cos \theta + r^{2})^{-k} = \frac{1}{2} {}_{2}F_{1}(k, k; 1; r^{2}) + \sum_{n=1}^{\infty} \frac{(k)_{n}}{n!} r^{n} {}_{2}F_{1}(k, k+n; n+1; r^{2}) \cos n\theta
-->

<table border=1 hspace=40 cellpadding=6><tr><td>
<img src="pix/sceq30.png" alt="sum of sines">
</td></tr>
<tr><td>
<img src="pix/r2kfactcos.png" alt="r2k!cos spectra">
</td></tr></table>

<!-- r2kfactcos.png:

(with-sound (:clipped #f :statistics #t :play #t :scaled-to .5)
  (let* ((gen (make-r2k!cos 440.0 :r 0.65 :k 3.0)) 
	 (dur 2.0)
	 (samps (seconds->samples dur))
	 (indf (make-env '(0 0 1 1) :duration dur :scaler 10.0 :offset 1))
	 (ampf (make-env '(0 0 1 1 20 1 21 0) :duration dur))
	 )
    (run 
       (do ((i 0 (+ 1 i)))
	   ((= i samps))
	 (set! (r2k!cos-k gen) (env indf))
	 (outa i (* (env ampf)
		    (r2k!cos gen)))))))

dark 3 rainbow .001 not inverted
2048 blackman2
x 311 1.67
y 281 0.94
z 350 1.30
hop 3
(spectrum-end 0 0) 0.544793281259146

-->

<br>

<p>Negative "r" gives the same output as the corresponding positive "r", and 
there is sometimes a lot of DC.  Despite appearances, as r increases beyond 1.0,
the spectrum collapses back towards the fundamental.  (I think that r and 1/r produce the same spectrum).
Aliasing can be a problem,
especially when r is close to 1.
The instruments pianoy and pianoy1 use r2k!cos: <code>pianoy beg dur freq amp</code>, and 
<code>pianoy1 beg dur freq amp (bounce-freq 5) (bounce-amp 20)</code>:
</p>

<pre>
    (<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:play #t)
      (pianoy 0 3 100 .5))

    (<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:play #t)
      (pianoy1 0 4 200 .5 1 .1))
</pre>

<p>pianoy2 combines r2k!cos with fmssb to try to get closer to the hammer sound:
</p>

<pre>
    (<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:play #t) 
      (pianoy2 0 1 100 .5))
</pre>

<br>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-rkoddssb">make-rkoddssb</A> (frequency 0.0) (ratio 1.0) (r 0.5) ; -1.0 &lt; r &lt; 1.0
  <A class=def NAME="rkoddssb">rkoddssb</A> gen (fm 0.0)
  <A class=def NAME="rkoddssb?">rkoddssb?</A> gen
</pre>

<p>This produces a sum of odd-numbered harmonics scaled by (r^(2k-1))/(2k-1).  This kind of spectrum is usually
called "clarinet-like".
Negative r gives the
same output as positive. The (not very)
safe maximum r is:
</p>

<pre>
  (define (safe-rkodd-max-r freq srate)
    (let* ((topk (floor (/ srate (* 3 freq))))
           (k2-1 (- (* 2 topk) 1)))
      (expt (* .001 k2-1) (/ 1.0 k2-1))))
</pre>


<p>The instrument stringy uses rkoddssb and rcos: <code>stringy beg dur freq amp</code>:
</p>

<pre>
    (<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:play #t)
      (do ((i 0 (+ 1 i)))
          ((= i 10))
        (stringy (* i .3) .3 (+ 200 (* 100 i)) .5)))
</pre>

<p>glassy also uses rkoddssb: <code>glassy beg dur freq amp</code>:
</p>

<pre>
    (<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> (:play #t)
      (do ((i 0 (+ 1 i)))
          ((= i 10))
        (glassy (* i .3) .1 (+ 400 (* 100 i)) .5)))
</pre>
<br>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-k2sin">make-k2sin</A> (frequency 0.0)
  <A class=def NAME="k2sin">k2sin</A> gen (fm 0.0)
  <A class=def NAME="k2sin?">k2sin?</A> gen

  <A class=def NAME="make-k2cos">make-k2cos</A> (frequency 0.0)
  <A class=def NAME="k2cos">k2cos</A> gen (fm 0.0)
  <A class=def NAME="k2cos?">k2cos?</A> gen

  <A class=def NAME="make-k2ssb">make-k2ssb</A> (frequency 0.0) (ratio 1.0)
  <A class=def NAME="k2ssb">k2ssb</A> gen (fm 0.0)
  <A class=def NAME="k2ssb?">k2ssb?</A> gen
</pre>

<p>These produce a sum of sinusoids scaled by 1/(2^k).
</p>
<br>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-k3sin">make-k3sin</A> (frequency 0.0)
  <A class=def NAME="k3sin">k3sin</A> gen fm
  <A class=def NAME="k3sin?">k3sin?</A> gen
</pre>

<p>This produces a sum of sines scaled by 1.0/(k^3).
</p>
<br>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-krksin">make-krksin</A> (frequency 0.0) (r 0.5)
  <A class=def NAME="krksin">krksin</A> gen (fm 0.0)
  <A class=def NAME="krksin?">krksin?</A> gen
</pre>

<img src="pix/sceq25.png" alt="sum of sines" hspace=40>
<br>

<p>This produces a sum of sinusoids scaled by kr^k.  Its output is not normalized.  I think the formula
given assumes that r is less than 1.0, and in that case, the safe maximum r is given by:
</p>

<pre>
  (define (safe-krk-max-r freq srate)
    (let* ((topk (floor (/ srate (* 3 freq)))))
      (expt (/ .001 topk) (/ 1.0 topk))))
</pre>

<p>However, r can be greater than 1.0 without causing any trouble, and behaves in that case much like r2k!cos &mdash; as it increases, the spectrum collapses;
I think r in that case is equivalent to 1/r.
The only value to avoid is 1.0.
</p>

<br>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-abcos">make-abcos</A> (frequency 0.0) (a 0.5) (b 0.25)
  <A class=def NAME="abcos">abcos</A> gen (fm 0.0)
  <A class=def NAME="abcos?">abcos?</A> gen

  <A class=def NAME="make-absin">make-absin</A> (frequency 0.0) (a 0.5) (b 0.25)
  <A class=def NAME="absin">absin</A> gen (fm 0.0)
  <A class=def NAME="absin?">absin?</A> gen
</pre>

<p>These produce a sum of sinusoids scaled as follows:
</p>

<img src="pix/sceq27.png" alt="sum of sines" hspace=40>
<br>
<br>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-r2k2cos">make-r2k2cos</A> (frequency 0.0) (r 0.5)
  <A class=def NAME="r2k2cos">r2k2cos</A> gen (fm 0.0)
  <A class=def NAME="r2k2cos?">r2k2cos?</A> gen
</pre>

<p>This produces a sum of cosines, each scaled by 1/(r^2+k^2).  r shouldn't be 0, but otherwise it almost doesn't matter what it is &mdash;
this is not a very flexible generator!
</p>

<p>There are a dozen or so other generators defined in generators.scm, but most are close
variants of those given above.
</p>

<br><br>


<pre style="background-color: #f2f4ff">
  <A class=def NAME="make-tanhsin">make-tanhsin</A> (frequency *clm-default-frequency*) (r 1.0) (initial-phase 0.0)
  <A class=def NAME="tanhsin">tanhsin</A> gen (fm 0.0)
  <A class=def NAME="tanhsin?">tanhsin?</A> gen
</pre>

<p>This produces tanh(r * sin(x)) which approaches a square wave as "r" increases.
</p>
<br>


<pre style="background-color: #f2f4ff">
  <a class=def name="make-moving-fft">make-moving-fft</a> (input #f :type clm) (n 512) (hop 128)
  <a class=def name="moving-fft">moving-fft</A> gen
  <a class=def name="moving-fft?">moving-fft?</A> gen
</pre>

<p>moving-fft provides a sample-by-sample FFT (magnitudes and phases) of its
input (currently assumed to be a readin generator).  
mus-xcoeffs returns the magnitudes, mus-ycoeffs returns the phases, and mus-data returns the current input block.
We could mimic the fft display window in the "lisp graph" via:
</p>
<pre>
(let* ((rd (make-readin "oboe.snd"))
       (ft (<em class=red>make-moving-fft</em> rd))
       (data (make-vct 256)))
  (set! (lisp-graph?) #t)
  (do ((i 0 (+ i 1)))
      ((= i 10000))
    (<em class=red>moving-fft</em> ft)
    (vct-subseq (mus-xcoeffs ft) 0 255 data)
    (graph data "fft" 0.0 11025.0 0.0 0.1 0 0 #t)))
</pre>
<br>

<pre style="background-color: #f2f4ff">
  <a class=def name="make-moving-spectrum">make-moving-spectrum</a> (input #f :type clm) (n 512) (hop 128)
  <a class=def name="moving-spectrum">moving-spectrum</A> gen
  <a class=def name="moving-spectrum?">moving-spectrum?</A> gen
</pre>

<p>moving-spectrum provides a sample-by-sample spectrum (amplitudes, frequencies, and current phases) of its
input (currently assumed to be a readin generator).  It is identical to the first (analysis) portion of
the phase-vocoder generator (see test-sv in generators.scm for details).  To access the current amps and so on,
use moving-spectrum-amps, moving-spectrum-phases, and moving-spectrum-freqs.
</p>
<br>


<pre style="background-color: #f2f4ff">
  <a class=def name="make-moving-autocorrelation">make-moving-autocorrelation</a> (input #f :type clm) (n 512) (hop 128)
  <a class=def name="moving-autocorrelation">moving-autocorrelation</A> gen
  <a class=def name="moving-autocorrelation?">moving-autocorrelation?</A> gen
</pre>

<p>moving-autocorrelation provides the autocorrelation of the last 'n' samples every 'hop' samples.
The samples come from 'input' (currently assumed to be a readin generator). The output is accessible
via mus-data.
</p>
<br>


<pre style="background-color: #f2f4ff">
  <a class=def name="make-moving-pitch">make-moving-pitch</a> (input #f :type clm) (n 512) (hop 128)
  <a class=def name="moving-pitch">moving-pitch</A> gen
  <a class=def name="moving-pitch?">moving-pitch?</A> gen
</pre>

<p>moving-pitch provides the current pitch of its input, recalculated (via moving-autocorrelation) every 'hop' samples.
</p>
<pre>
(let* ((rd (make-readin "oboe.snd"))
       (cur-srate (srate "oboe.snd"))
       (old-srate (mus-srate)))
  (set! (mus-srate) cur-srate)
  (let* ((scn (<em class=red>make-moving-pitch</em> rd))
	 (last-pitch 0.0)
	 (pitch 0.0))
    (do ((i 0 (+ i 1)))
	((= i 22050))
      (set! last-pitch pitch)
      (set! pitch (<em class=red>moving-pitch</em> scn))
      (if (not (= last-pitch pitch))
	  (format #t "~A: ~A~%" (* 1.0 (/ i cur-srate)) pitch))))
  (set! (mus-srate) old-srate))
</pre>
<br>


<pre style="background-color: #f2f4ff">
  <a class=def name="make-moving-scentroid">make-moving-scentroid</a> (dbfloor -40.0) (rfreq 100.0) (size 4096)
  <a class=def name="moving-scentroid">moving-scentroid</A> gen
  <a class=def name="moving-scentroid?">moving-scentroid?</A> gen
</pre>

<p>moving-scentroid provides a generator that mimics Bret Battey's scentroid instrument (in dsp.scm or scentroid.ins).
</p>
<br>


<pre style="background-color: #f2f4ff">
  <a class=def name="make-flocsig">make-flocsig</a> (reverb-amount 0.0) (frequency 1.0) (amplitude 2.0) offset
  <a class=def name="flocsig">flocsig</A> gen i val
  <a class=def name="flocsig?">flocsig?</A> gen
</pre>

<p>flocsig is a version of locsig that adds changing delays between the channels (flanging).  
The delay amount is set by a rand-interp centered around 'offset', moving as many as 'amplitude'
samples (this also affects signal placement), and moving at a speed set by 'frequency'.
Currently flocsig assumes stereo output and stereo reverb output.
This generator is trying to open up the space in the same manner that flanging does, but
hopefully unobtrusively.  Here is an example, including a stereo reverb:
</p>

<pre>
(definstrument (jcrev2)
  (let* (
	 (allpass11 (make-all-pass -0.700 0.700 1051))
	 (allpass21 (make-all-pass -0.700 0.700  337))
	 (allpass31 (make-all-pass -0.700 0.700  113))
	 (comb11 (make-comb 0.742 4799))
	 (comb21 (make-comb 0.733 4999))
	 (comb31 (make-comb 0.715 5399))
	 (comb41 (make-comb 0.697 5801))
	 (outdel11 (make-delay (seconds-&gt;samples .01)))

	 (allpass12 (make-all-pass -0.700 0.700 1051))
	 (allpass22 (make-all-pass -0.700 0.700  337))
	 (allpass32 (make-all-pass -0.700 0.700  113))
	 (comb12 (make-comb 0.742 4799))
	 (comb22 (make-comb 0.733 4999))
	 (comb32 (make-comb 0.715 5399))
	 (comb42 (make-comb 0.697 5801))
	 (outdel12 (make-delay (seconds-&gt;samples .01)))

	 (file-dur (frames *reverb*))
	 (decay-dur (mus-srate))
	 (len (floor (+ decay-dur file-dur))))

	(run
	   (do ((i 0 (+ 1 i)))
	       ((= i len))

	     (let* ((allpass-sum (all-pass allpass31 
					   (all-pass allpass21 
						     (all-pass allpass11 
							       (ina i *reverb*)))))
		    (comb-sum (+ (comb comb11 allpass-sum)
				 (comb comb21 allpass-sum)
				 (comb comb31 allpass-sum)
				 (comb comb41 allpass-sum))))
	       (outa i (delay outdel11 comb-sum)))

	     (let* ((allpass-sum (all-pass allpass32 
					   (all-pass allpass22 
						     (all-pass allpass12 
							       (inb i *reverb*)))))
		    (comb-sum (+ (comb comb12 allpass-sum)
				 (comb comb22 allpass-sum)
				 (comb comb32 allpass-sum)
				 (comb comb42 allpass-sum))))
	       (outb i (delay outdel12 comb-sum)))))))

(definstrument (simp beg dur (amp 0.5) (freq 440.0) (ramp 2.0) (rfreq 1.0) offset)
  (let* ((os (make-pulse-train freq))
	 (floc (<em class=red>make-flocsig</em> :reverb-amount 0.1
			     :frequency rfreq
			     :amplitude ramp
			     :offset offset))
	 (start (seconds-&gt;samples beg))
	 (end (+ start (seconds-&gt;samples dur))))
    (run
     (do ((i start (+ i 1))) 
	 ((= i end))
       (<em class=red>flocsig</em> floc i (* amp (pulse-train os)))))))


(with-sound (:channels 2 :reverb-channels 2 :reverb jcrev2) 
  (simp 0 1))

</pre>

<br><br>




<!-- defgenerator -->
<table border=1 width=200 vspace=10 hspace=20><tr><td bgcolor="#eefdee"><center><h5>defgenerator</h5></center></td></tr></table>

<pre>
  <a class=def name="defgenerator">defgenerator</a> name fields
</pre>

<p>defgenerator defines a generator.  Its syntax is modelled after Common Lisp's defstruct.
It sets up
a structure, an object with named slots that you can get and set, and ties it into the
optimizer so that you can use the structures without any speed penalty.  It also defines a "make"
function to create an instance of the structure, and a predicate for it.  The original impetus for
this came from user-defined generators in CLM.  We want to package together all the disparate
variables that make up a generator, just as in function groups such as 
<a href="sndclm.html#make-oscil">make-oscil</a>, <a href="sndclm.html#oscil">oscil</a>, and <a href="sndclm.html#oscil?">oscil?</a>.
So, as a first example, here is a way to define your own oscil using defgenerator (oscil is so simple that
you could also use a vct &mdash; see <a href="sndclm.html#make-my-oscil">make-my-oscil</a>).
</p>

<table border=0 cellpadding=5 hspace=20><tr><td><pre>
(<em class=red>defgenerator</em> osc freq phase)

;;; this defines a struct named "osc" with the (float) fields freq and phase.
;;;   make-osc creates an osc, and osc? returns #t if passed an osc.
;;;   the fields are accessed via osc-freq and osc-phase.

(define (osc gen fm)                ; our new generator
  (<a class=quiet href="extsnd.html#declare" onmouseout="UnTip()" onmouseover="Tip(extsnd_declare_tip)">declare</a> (gen osc) (fm float))
  (let ((result (sin (<em class=red>osc-phase</em> gen))))
    (set! (<em class=red>osc-phase</em> gen) (+ (<em class=red>osc-phase</em> gen) (<em class=red>osc-freq</em> gen) fm))
    result))

;;; now we can use the osc generator in an instrument:

(<a class=quiet href="sndscm.html#definstrument" onmouseout="UnTip()" onmouseover="Tip(sndscm_definstrument_tip)">definstrument</a> (osc-fm beg dur freq amp mc-ratio fm-index)
  (let* ((start (<a class=quiet href="sndclm.html#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> beg))
	 (end (+ start (<a class=quiet href="sndclm.html#secondstosamples" onmouseout="UnTip()" onmouseover="Tip(sndclm_secondstosamples_tip)">seconds-&gt;samples</a> dur)))
	 (carrier (<em class=red>make-osc</em> (<a class=quiet href="sndclm.html#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> freq)))
	 (modulator (<em class=red>make-osc</em> (<a class=quiet href="sndclm.html#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> (* mc-ratio freq))))
	 (index (<a class=quiet href="sndclm.html#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> (* freq mc-ratio fm-index))))
    (run
     (do ((i start (+ 1 i)))
	 ((= i end))
       (<a class=quiet href="sndclm.html#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* amp (<em class=red>osc</em> carrier (* index (<em class=red>osc</em> modulator 0.0)))))))))

(with-sound () (osc-fm 0 1 440 .1 1 1))
</pre></td></tr></table>

<p>
The first argument to defgenerator is the new struct's name, and the rest are the fields of that struct.
Each field has a name, a type, and an optional initial value. The type defaults to float, and
the initial value to 0.0, so our declaration above is the same as any of these:
</p>

<pre>
    (defgenerator osc freq (phase 0.0))
    (defgenerator osc (freq 0.0) (phase 0.0))
    (defgenerator osc (freq 0.0 :type float) (phase 0.0 :type float))
</pre>

<p>and so on. The "make" function (make-osc in our example) uses define* with
the field names and types as the optional keys.  So make-osc above is declared (by the
defgenerator macro) as:
</p>

<pre>
    (define* (make-osc (freq 0.0) (phase 0.0)) ...)
</pre>

<p>which we can invoke in various ways, e.g.:
</p>

<pre>
    (make-osc 440)
    (make-osc :phase (/ pi 2) :freq 440)
    (make-osc 440 :phase 0.0)
</pre>

<p>
The currently implemented field types are:
</p>

<pre>
    int float boolean char string list symbol keyword vct sampler mix-sampler 
    sound-data clm float-vector int-vector vct-vector list-vector clm-vector 
</pre>

<p>The struct name can be a list; in this case the first element is the actual struct name.  The
next elements are optionally <code>:make-wrapper</code> followed by a function of one argument
(the default struct normally returned by defgenerator), and optionally <code>:methods</code>, followed
by a list of the methods the generator responds to.  The make wrapper function can 
make any changes it pleases, then return the fixed-up generator.  For example, in our
"osc" generator, we had to remember to change frequency in Hz to radians; we can use the
wrapper to handle that:
</p>

<pre>
    (defgenerator 
      (osc <em class=red>:make-wrapper</em> (lambda (gen)
			   (set! (osc-freq gen) (<a class=quiet href="sndclm.html#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> (osc-freq gen)))
			   gen))
      (freq 0.0) (phase 0.0))
</pre>

<p>and now the make process in the instrument can be simplified to:
</p>

<pre>
    ...
    (carrier (make-osc freq))
    (modulator (make-osc (* mc-ratio freq)))
    ...
</pre>

<p>If you want the struct to take part in the <a href="sndclm.html#genericfunctions">generic function</a> facility
in CLM, add the desired methods as an association list with the name :methods:
</p>

<table border=0 cellpadding=5 hspace=20><tr><td><pre>
(defgenerator (osc :make-wrapper
		     (lambda (gen)
		       (set! (osc-freq gen) (<a class=quiet href="sndclm.html#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> (osc-freq gen)))
		       gen)
		     <em class=red>:methods</em>
		     (list
		      (list 'mus-frequency 
			    (lambda (g) (<a class=quiet href="sndclm.html#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">radians-&gt;hz</a> (osc-freq g)))
			    (lambda (g val) (set! (osc-freq g) (<a class=quiet href="sndclm.html#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> val))))
		      
		      (list 'mus-phase 
			    (lambda (g) (osc-phase g))
			    (lambda (g val) (set! (osc-phase g) val)))
		      
		      (list 'mus-describe 
			    (lambda (g) (<a class=quiet onmouseout="UnTip()" onmouseover="Tip(scheme_format_tip)">format</a> #f "osc freq: ~A, phase: ~A" 
					  (mus-frequency g) 
					  (mus-phase g))))))
  freq phase)
</pre></td></tr></table>

<p>The first function is the "getter" and the (optional) second function is the "setter".
You can also use make-procedure-with-setter.
The standard methods are actually defined for you.
If the generator has a frequency field,
defgenerator adds the method
mus-frequency (radians-&gt;hz of the frequency field); similarly "angle" or "phase" become mus-phase,
"n" or "order" becomes mus-order, and "r" or "amplitude" becomes mus-scaler.
To specialize the make function,
or add your own methods, the generator name can be a list: 
</p>

<table border=0 hspace=40><tr><td>
<pre>
(defgenerator (name 
                :make-wrapper (lambda (gen) ... gen) 
                :methods (list 
                           (list 'method-name
                                  (lambda (gen) ...)     ; get method
                                  (lambda (gen val) ...) ; set method, if any
				  ...)))
   fields...)
</pre>
</td></tr></table>

<p>The make-wrapper might more accurately be called an after-method; it is
evaluated at the end of the automatically-created make function.  All the
fields have been set at that point either by arguments to the make function,
or from the default values given in the defgenerator declaration.  The make
function returns whatever
the make-wrapper function returns, so you almost always want to return the "gen" argument.
The added methods can be optimized by run, as can the generator function itself, but
remember to declare the generator type (the "declare" business above).
Here is an example that produces abs(oscil):
</p>

<table border=0 hspace=40><tr><td>
<pre>
(defgenerator (abssin
	       :make-wrapper (lambda (g)
			       (set! (abssin-osc g) (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> (abssin-frequency g)))
			       g)	       
	       :methods (list
			 (list 'mus-frequency
			       (lambda (g) (mus-frequency (abssin-osc g)))
			       (lambda (g val) (set! (mus-frequency (abssin-osc g)) val) val))

			 (list 'mus-phase
			       (lambda (g) (mus-phase (abssin-osc g)))
			       (lambda (g val) (set! (mus-phase (abssin-osc g)) val) val))))
  (frequency *clm-default-frequency*)
  (osc #f :type clm))

(define* (abssin gen (fm 0.0))
  (declare (gen abssin) (fm float))
  (/ (- (abs (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> (abssin-osc gen) fm))
	(/ 2.0 pi))  ; remove DC
     (/ 2.0 pi)))    ; normalize

#|
(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> ()
  (let ((gen (<em class=red>make-abssin</em> 440.0)))
    (run 
     (do ((i 0 (+ 1 i)))
	 ((= i 10000))
       (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (* .5 (<em class=red>abssin</em> gen)))))))
#|
</pre>
</td></tr></table>


<br>
<br><br>



<!-- ---------------------------------------- FUNCTIONS ---------------------------------------- -->

<table width="80%" border=0><tr><td bgcolor="lightsteelblue" valign="middle"><h2><a class=def NAME="otherfunctions">Other Functions</a></h2></td></tr></table>

<p>There are several functions closely tied to the generators and instruments.
</p>

<table cellspacing=0 cellpadding=0 hspace=40>
<tr><td><a class=def name="hztoradians">hz-&gt;radians</a><code> freq</code></td><td width=20></td><td>convert freq to radians per sample (using mus-srate): (freq * 2 * pi) / srate</td></tr>
<tr><td><a class=def name="radianstohz">radians-&gt;hz</a><code> rads</code></td><td></td><td>convert rads to Hz (using mus-srate): (rads * srate) / (2 * pi)</td></tr>
<tr><td><a class=def name="dbtolinear">db-&gt;linear</a><code> dB</code></td><td></td><td>convert dB to linear value: 10^(dB/20)</td></tr>
<tr><td><a class=def name="lineartodb">linear-&gt;db</a><code> val</code></td><td></td><td>convert val to dB: 20 * log(x) / log(10)</td></tr>
<tr><td><a class=def Name="timestosamples">times-&gt;samples</a><code> start duration</code></td><td></td><td>convert start and duration from seconds to samples (beg+dur in latter case)</td></tr>
<tr><td><a class=def name="samplestoseconds">samples-&gt;seconds</a><code> samps</code></td><td></td><td>convert samples to seconds (using mus-srate): samps / srate</td></tr>
<tr><td><a class=def name="secondstosamples">seconds-&gt;samples</a><code> secs</code></td><td></td><td>convert seconds to samples (using mus-srate): secs * srate</td></tr>
<tr><td><a class=def name="degreestoradians">degrees-&gt;radians</a><code> degs</code></td><td></td><td>convert degrees to radians: (degs * 2 * pi) / 360</td></tr>
<tr><td><a class=def name="radianstodegrees">radians-&gt;degrees</a><code> rads</code></td><td></td><td>convert radians to degrees: (rads * 360) / (2 * pi)</td></tr>
<tr><td><a class=def name="clear-array">clear-array</a><code> arr</code></td><td></td><td>set all values in arr (a vct) to 0.0</td></tr>
<tr><td><a class=def name="mussrate">mus-srate</a></td><td></td><td>sampling rate in with-sound</td></tr>
</table>

<p>
hz-&gt;radians
converts its argument to radians/sample (for any situation where a
frequency is used as an amplitude &mdash; glissando or FM).
</p>
<blockquote>
<p>
<code>freq-in-hz * 2 * pi</code> gives us the number of radians traversed per
second; we then divide by the number of samples per second to get the
radians per sample; in dimensional terms: (radians/sec) /
(sample/sec) = radians/sample.  We need this conversion whenever a
frequency-related value is being accessed on every sample, as
an increment of a phase variable.  
</p></blockquote>

<pre>
    <em class=listener>&gt;</em><em class=typing>(mus-srate)</em>
    <em class=listener>44100.0</em>

    <em class=listener>&gt;</em><em class=typing>(hz-&gt;radians 440.0)</em>
    <em class=listener>0.0626893772144902</em>
    <em class=listener>&gt;</em><em class=typing>(/ (* 440.0 2 pi) 44100.0)</em>
    <em class=listener>0.0626893772144902</em>

    <em class=listener>&gt;</em><em class=typing>(linear-&gt;db .1)</em>
    <em class=listener>-20.0</em>

    <em class=listener>&gt;</em><em class=typing>(times-&gt;samples 1.0 2.0)</em>
    <em class=listener>(44100 132300)</em>
    <em class=listener>&gt;</em><em class=typing>(seconds-&gt;samples 2.0)</em>
    <em class=listener>88200</em>
    <em class=listener>&gt;</em><em class=typing>(samples-&gt;seconds 44100)</em>
    <em class=listener>1.0</em>

    <em class=listener>&gt;</em><em class=typing>(degrees-&gt;radians 45)</em>
    <em class=listener>0.785398163397448</em>
    <em class=listener>&gt;</em><em class=typing>(radians-&gt;degrees (/ pi 4))</em>
    <em class=listener>45.0</em>
</pre>

<br>

<pre>
  <a class=def name="musfloatequalfudgefactor">mus-float-equal-fudge-factor</a>
</pre>

<p>This function sets how far apart generator vct elements can be and still be considered equal in equal?
</p>

<pre>
    <em class=listener>&gt;</em><em class=typing>(mus-float-equal-fudge-factor)</em>
    <em class=listener>1.0e-7</em>
    <em class=listener>&gt;</em><em class=typing>(define v1 (vct .1 .1 .101))</em>
    <em class=listener>#&lt;unspecified&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(define v2 (vct .1 .1 .1))</em>
    <em class=listener>#&lt;unspecified&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(equal? v1 v2)</em>
    <em class=listener>#f</em>
    <em class=listener>&gt;</em><em class=typing>(set! (mus-float-equal-fudge-factor) .01)</em>
    <em class=listener>1.0e-7</em> ; set! returns the previous value
    <em class=listener>&gt;</em><em class=typing>(equal? v1 v2)</em>
    <em class=listener>#t</em>
</pre>

<br>

<pre>
  <a class=def name="musarrayprintlength">mus-array-print-length</a>
</pre>

<p>
This function determines how many mixer elements are printed by mus-describe.
</p>

<pre>
    <em class=listener>&gt;</em><em class=typing>(mus-array-print-length)</em>
    <em class=listener>8</em>
    <em class=listener>&gt;</em><em class=typing>(define m1 (make-mixer 12))</em>
    <em class=listener>#&lt;unspecified&gt;</em>
    <em class=listener>&gt;</em><em class=typing>(set! (mus-array-print-length) 3)</em>
    <em class=listener>8</em> ; set! returns the old value
    <em class=listener>&gt;</em><em class=typing>m1</em>
    <em class=listener>#&lt;mixer chans: 12, [
     0.000 0.000 0.000...
     0.000 0.000 0.000...
     0.000 0.000 0.000...
    ]&gt;</em>
</pre>

<br><br>



<!-- ---------------------------------------- POLYNOMIAL ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>polynomial</h3></center></td></tr></table>

<pre>
   <a class=def name="polynomial">polynomial</a> coeffs x
</pre>

<p>The polynomial function evaluates a polynomial, defined by giving its coefficients,
at the point "x".
"coeffs" is a vct of coefficients where
coeffs[0] is the constant term, and so on. 
</p>

<pre>
    <em class=listener>&gt;</em><em class=typing>(polynomial (vct 0.0 1.0) 2.0)</em> ; x
    <em class=listener>2.0</em>
    <em class=listener>&gt;</em><em class=typing>(polynomial (vct 1.0 2.0 3.0) 2.0)</em> ; 3x*x + 2x + 1
    <em class=listener>17.0</em>
</pre>

<p>
<a href="sndscm.html#polydoc">poly.scm</a> has a variety of polynomial-related functions.
Abramowitz and Stegun, "A Handbook of Mathematical Functions" is a
treasure-trove of interesting polynomials.
Here's a generator that uses polynomial to produce a Blackman4 waveform (see also <a href="#make-blackman">make-blackman</a> in generators.scm):
</p>

<table border=0 hspace=40><tr><td>
<pre>
(<a class=quiet href="sndclm.html#defgenerator" onmouseout="UnTip()" onmouseover="Tip(sndclm_defgenerator_tip)">defgenerator</a> (blackman4 :make-wrapper 
		  (lambda (g)
	 	    (set! (blackman4-incr g) (<a class=quiet href="#hztoradians" onmouseout="UnTip()" onmouseover="Tip(sndclm_hztoradians_tip)">hz-&gt;radians</a> (blackman4-frequency g)))
		    (set! (blackman4-coeffs g) (<a class=quiet href="extsnd.html#vct" onmouseout="UnTip()" onmouseover="Tip(extsnd_vct_tip)">vct</a> .084037 -.29145 .375696 -.20762 .041194))
		    g))
    (frequency 0.0) (initial-phase 0.0) (coeffs #f :type vct) (angle 0.0) (incr 0.0))

(define (blackman4 gen fm)
  (<a class=quiet href="extsnd.html#declare" onmouseout="UnTip()" onmouseover="Tip(extsnd_declare_tip)">declare</a> (gen blackman4) (fm float))
  (let ((x (blackman4-angle gen)))
    (set! (blackman4-angle gen) (+ x fm (blackman4-incr gen)))
    (<em class=red>polynomial</em> (blackman4-coeffs gen) (cos x))))

(<a class=quiet href="sndscm.html#wsdoc" onmouseout="UnTip()" onmouseover="Tip(sndscm_wsdoc_tip)">with-sound</a> ()
  (let ((black4 (make-blackman4 440.0)))
    (<a class=quiet href="extsnd.html#run" onmouseout="UnTip()" onmouseover="Tip(extsnd_run_tip)">run</a>
       (do ((i 0 (+ 1 i)))
	   ((= i 20000))
	 (<a class=quiet href="#outa" onmouseout="UnTip()" onmouseover="Tip(sndclm_outa_tip)">outa</a> i (blackman4 black4 0.0))))))
</pre>
</td></tr></table>

<br><br>



<!-- ---------------------------------------- ARRAY-INTERP ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>array-interp, dot-product</h3></center></td></tr></table>

<pre>
  <a class=def name="array-interp">array-interp</a> fn x size
  <a class=def name="dot-product">dot-product</a> in1 in2
  <a class=def name="edot-product">edot-product</a> freq data
  <a class=def name="mus-interpolate">mus-interpolate</a> type x v size y1
</pre>

<p>array-interp interpolates in the array "fn" at the point "x".  It underlies the <a href="#table-lookup">table-lookup</a>
generator, among others.  Here's array-interp as a "compander":
</p>

<table border=0 hspace=40><tr><td>
<pre>
(define compand-table (<a class=quiet href="extsnd.html#vct" onmouseout="UnTip()" onmouseover="Tip(extsnd_vct_tip)">vct</a> -1.0 -0.96 -0.90 -0.82 -0.72 -0.60 -0.45 -0.25 
                            0.0 0.25 0.45 0.60 0.72 0.82 0.90 0.96 1.0))

(<a class=quiet href="extsnd.html#mapchannel" onmouseout="UnTip()" onmouseover="Tip(extsnd_mapchannel_tip)">map-channel</a>
  (lambda (inval)
    (let ((index (+ 8.0 (* 8.0 inval))))
      (<em class=red>array-interp</em> compand-table index 17))))
</pre>
</td></tr></table>


<p><a href="sndscm.html#soundinterp">sound-interp</a> in examp.scm fills an array with an entire sound,
then uses array-interp to read it.
</p>

<p>
dot-product is the usual "inner product" or "scalar product" (a name that should be banned from polite society).
We could define our own FIR filter using dot-product:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(define (make-fr-filter coeffs)
  (list coeffs (<a class=quiet href="extsnd.html#makevct" onmouseout="UnTip()" onmouseover="Tip(extsnd_makevct_tip)">make-vct</a> (length coeffs))))

(define (fr-filter flt x)
  (let* ((coeffs (car flt))
	 (xs (cadr flt))
	 (xlen (length xs)))
    (<a class=quiet href="extsnd.html#vctmove" onmouseout="UnTip()" onmouseover="Tip(extsnd_vctmove_tip)">vct-move!</a> xs (- xlen 1) (- xlen 2) #t)
    (set! (xs 0) x)
    (<em class=red>dot-product</em> coeffs xs xlen)))
</pre>
</td></tr></table>


<p>
edot-product returns the complex dot-product of the "data" argument (a vct or a vector) with <code>(exp (* freq i))</code>.
Here, "i" goes from 0 to data's size - 1.
"freq" and the elements of "data" can be complex, as can the return value.  See <a href="sndscm.html#stretchsoundviadft">stretch-sound-via-dft</a>
for an example.
</p>


<p>
mus-interpolate is the function used whenever table lookup interpolation is requested, as in
<a href="#delay">delay</a> or <a href="#wave-train">wave-train</a>. 
The "type" argument is one of the interpolation types (<code>mus-interp-linear</code>, for example).
</p>
<br><br>




<!-- ---------------------------------------- CONTRAST-ENHANCEMENT ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>contrast-enhancement</h3></center></td></tr></table>

<pre>
   <a class=def name="contrast-enhancement">contrast-enhancement</a> in-samp (fm-index 1.0)
</pre>

<p>contrast-enhancement passes its input to sin as a kind of phase modulation.
</p>
<pre>
    (sin (+ (* input pi 0.5)
            (* index (sin (* input pi 2)))))
</pre>

<p>
This brightens the
input, helping it cut through a huge mix.
A similar (slightly simpler) effect is:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(let ((mx (maxamp))) 
  (<a class=quiet href="extsnd.html#mapchannel" onmouseout="UnTip()" onmouseover="Tip(extsnd_mapchannel_tip)">map-channel</a> 
    (lambda (y) 
      (* mx (sin (/ (* pi y) mx))))))
</pre>
</td></tr></table>

<p>This modulates the sound but keeps the output maxamp the same as the input.
See <a href="#moving-max">moving-max</a> for a similar function that does this kind of scaling throughout the sound,
resulting in a steady modulation, rather than an intensification of just the peaks.
And a sort of converse is <a href="sndscm.html#soundinterp">sound-interp</a>.
</p>
<br><br>



<!-- ---------------------------------------- AMPLITUDE-MODULATE ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>ring-modulate, amplitude-modulate</h3></center></td></tr></table>

<pre>
  <a class=def name="ring-modulate">ring-modulate</a> in1 in2                  ; returns <code>(* in1 in2)</code>
  <a class=def name="amplitude-modulate">amplitude-modulate</a> am-carrier in1 in2  ; returns <code>(* in1 (+ am-carrier in2))</code>
</pre>


<table border=1 bordercolor="lightgray" hspace=20 vspace=10 cellspacing=8 cellpadding=5>

<tr>
<td bgcolor="#f0f4ff">
<pre>
(with-sound (:play #t)
  (let ((osc1 (make-oscil 440.0))
	(osc2 (make-oscil 220.0)))
    (do ((i 0 (+ 1 i)))
	((= i 44100))
      (outa i (* 0.5 (amplitude-modulate 0.3 (oscil osc1) (oscil osc2)))))))
</pre>
</td>

</tr><tr>

<td bgcolor="#fbfbf0">
<pre>
with_sound(:play, true) do
  osc1 = make_oscil(440.0);
  osc2 = make_oscil(220.0);
  44100.times do |i|
    outa(i, 0.5 * amplitude_modulate(0.3, oscil(osc1), oscil(osc2)), $output);
    end
  end.output
</pre>
</td>

</tr><tr>

<td bgcolor="#effdef">
<pre>
lambda: ( -- )
  440.0 make-oscil { osc1 }
  220.0 make-oscil { osc2 }
  44100 0 do
    i
    0.3            ( car )
    osc1 0 0 oscil ( in1 )
    osc2 0 0 oscil ( in2 ) amplitude-modulate  f2/ *output* outa drop
  loop
; :play #t with-sound drop
</pre>
</td>

</tr>
</table>


<p>ring-modulation is sometimes called "double-sideband-suppressed-carrier" modulation &mdash;
that is, amplitude modulation with the carrier omitted (set to 0.0 above).
The nomenclature here is a bit confusing &mdash; I can't remember now why I used
these names; think of "carrier" as "carrier amplitude" and "in1" as "carrier". Normal amplitude modulation using this function is:
</p>

<pre>
  (define carrier (<a class=quiet href="#make-oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_make_oscil_tip)">make-oscil</a> carrier-freq (* .5 pi)))
  ...
  (amplitude-modulate 1.0 (<a class=quiet href="#oscil" onmouseout="UnTip()" onmouseover="Tip(sndclm_oscil_tip)">oscil</a> carrier) signal)
</pre>

<p>Both of these functions take advantage of the "Modulation Theorem"; since
multiplying a signal by e^(iwt) translates its spectrum by w /
two pi Hz, multiplying by a sinusoid splits its spectrum into two equal parts
translated up and down by w/(two pi) Hz:
</p>

<img src="pix/fmeq8.png" alt="coscos and sinsin" hspace=20>

<p>Waveshaping (via the Chebyshev polynomials) is an elaboration of AM.  For example, cos^2x is amplitude modulation of cos x
with itself, splitting into cos2x and cos0x.  T2 (that is, 2cos^2x - 1) then subtracts the cos0x term to return cos2x.
</p>
<p>
The upper sidebands may foldover (alias); if it's a problem, low-pass filter the inputs (surely no CLM user needs that silly reminder!).
</p>

<br><br><br>




<!-- ---------------------------------------- FFT ---------------------------------------- -->

<table width="60%" border=0><tr><td bgcolor="lightgreen" valign="middle"><center><h3>FFT (fourier transform)</h3></center></td></tr></table>
<pre>
  <a class=def Name="fft">mus-fft</a> rdat idat fftsize sign
  <a class=def name="make-fft-window">make-fft-window</a> type size (beta 0.0) (alpha 0.0)
  <a class=def name="multiply-arrays">multiply-arrays</a> rdat window
  <a class=def name="rectangulartopolar">rectangular-&gt;polar</a> rdat idat
  <a class=def name="rectangulartomagnitudes">rectangular-&gt;magnitudes</a> rdat idat
  <a class=def name="polartorectangular">polar-&gt;rectangular</a> rdat idat
  <a class=def name="spectrum">spectrum</a> rdat idat window norm-type
  <a class=def name="convolution">convolution</a> rdat idat size
  <a class=def name="autocorrelate">autocorrelate</a> data
  <a class=def name="correlate">correlate</a> data1 data2
</pre>

<p>mus-fft, spectrum, and convolution are the standard functions used everywhere.
fft is the Fourier transform, convolution convolves its arguments, and spectrum
returns '(magnitude (rectangular-&gt;polar (fft))).  The results are in dB (if "norm-type" is 0),
or linear and normalized to 1.0 ("norm-type" = 1), or linear unnormalized.
The name "mus-fft" is used to distuinguish clm's fft routine from Snd's; the
only difference is that mus-fft includes the fft length as an argument, whereas
<a href="extsnd.html#fft">fft</a> does not.  Here we use mus-fft to low-pass filter a sound:
</p>

<table border=0 hspace=40><tr><td>
<pre>
(let* ((len (mus-sound-frames "oboe.snd"))
       (fsize (expt 2 (ceiling (/ (log len) (log 2.0)))))
       (rdata (make-vct fsize))
       (idata (make-vct fsize))
       (cutoff (round (/ fsize 10)))
       (fsize2 (/ fsize 2)))
  (file-&gt;array "oboe.snd" 0 0 len rdata)
  
  (<em class=red>mus-fft</em> rdata idata fsize 1)
  (do ((i cutoff (+ 1 i))
       (j (- fsize 1) (- j 1)))
      ((= i fsize2))
    (set! (rdata i) 0.0)
    (set! (idata i) 0.0)
    (set! (rdata j) 0.0)
    (set! (idata j) 0.0))
  (<em class=red>mus-fft</em> rdata idata fsize -1)
  
  (array-&gt;file "test.snd" 
	       (vct-scale! rdata (/ 1.0 fsize)) 
	       len 
	       (srate "oboe.snd") 
	       1)
  (let ((previous-case (find-sound "test.snd")))
    (if (sound? previous-case)
	(close-sound previous-case)))
  (open-sound "test.snd"))
</pre>
</td></tr></table>


<p>make-fft-window can return many of the standard windows including:
</p>

<pre>
  bartlett-hann-window     bartlett-window        blackman2-window       blackman3-window
  blackman4-window         bohman-window          cauchy-window          connes-window       
  dolph-chebyshev-window   exponential-window     flat-top-window        gaussian-window     
  hamming-window           hann-poisson-window    hann-window            kaiser-window
  parzen-window            poisson-window         rectangular-window     riemann-window      
  samaraki-window          tukey-window           ultraspherical-window  welch-window        
  blackman5-window         blackman6-window       blackman7-window       blackman8-window       
  blackman9-window         blackman10-window      rv2-window             rv3-window
  rv4-window               mlt-sine-window        papoulis-window        dpss-window
  sinc-window
</pre>

<p>rectangular-&gt;polar and polar-&gt;rectangular change how we view the FFT data: in polar or rectangular coordinates.
rectangular-&gt;magnitudes is the same as rectangular-&gt;polar, but only calculates the magnitudes.
multiply-arrays does an element-wise multiply of two vcts.
autocorrelate performs an (in place) autocorrelation of 'data' (a vct).  See <a href="#moving-pitch">moving-pitch</a> in generators.scm, 
or <a href="sndscm.html#rubberdoc">rubber.scm</a>.
correlate performs an in-place cross-correlation of data1 and data2 (see, for example, <a href="sndscm.html#snddiffdoc">snddiff</a>).
</p>

<table border=3 bordercolor="tan" hspace=40><th bgcolor="beige">FFTs</th><tr><td>
<small><blockquote>
Hartley transform in Scheme: <a href="sndscm.html#dht">dht</a><br>
Spectral edit dialog: <a href="snd.html#editenvelope">Envelope Editor</a><br>
fft-based filter: <a href="sndscm.html#fftedit">fft-edit</a>, <a href="sndscm.html#fftenvedit">fft-env-edit</a>, <a href="sndscm.html#fftenvinterp">fft-env-interp</a>, <a href="sndscm.html#fftsquelch">fft-squelch</a>, <a href="sndscm.html#fftcancel">fft-cancel</a><br>
phase-vocoder: <a href="#phase-vocoder">phase-vocoder</a>. <a href="sndscm.html#pvocdoc">pvoc</a><br>
transposition via fft: <a href="sndscm.html#downoct">down-oct</a><br>
phase rotation via fft: <a href="sndscm.html#zerophase">zero-phase, rotate-phase</a><br>
duration change via autocorrelation: <a href="sndscm.html#rubberdoc">rubber-sound</a><br>
smoothing via fft: <a href="sndscm.html#fftsmoother">fft-smoother</a><br>
cross-synthesis: <a href="sndscm.html#crosssynthesis">cross-synthesis</a><br>
voiced-&gt;unvoiced effect: <a href="sndscm.html#voicedtounvoiced">voiced-&gt;unvoiced</a><br>
noise reduction: <a href="sndscm.html#cleanchannel">clean-channel</a>, <a href="sndscm.html#clminsdoc">anoi</a><br>
spectral modeling: <a href="sndscm.html#clminsdoc">pins</a><br>
polynomial approach to spectral multiplies (convolution): <a href="sndscm.html#spectralpolynomial">spectral-polynomial</a><br>
More transforms: <a href="sndscm.html#fractionalfouriertransform">fractional-fourier-transform</a>, <a href="sndscm.html#ztransform">z-transform</a> in dsp.scm<br>
bark, mel, erb scale display: <a href="sndscm.html#displaybarkfft">display-bark-fft</a><br>
apply function to spectrum, inverse fft: <a href="sndscm.html#filterfft">filter-fft</a><br>
</blockquote></small>
</td></tr></table>

<br><br>



<table width="80%" border=0><tr><td bgcolor="lightsteelblue" valign="middle"><h3><a class=def name="instruments">Instruments</a></h3></td></tr></table>

<p>It's hard to decide what's an "instrument" in this context, but I think I'll treat
it as something that can be called as a note in a notelist (in with-sound) and
generate its own sound.
There are hundreds of instruments scattered around the documentation, and most of the
<a href="extsnd.html#mapchannel">map-channel</a> functions can be recast as instruments.
There are also several that represent "classic" computer music instruments; they
are listed here, documented in sndscm.html, and tested (via sample runs) in
test 23 in snd-test.
</p>


<table border=8 bordercolor="lightgreen" cellpadding=2 hspace=10>
<tr><th width=120 bgcolor="beige">instrument</th><th bgcolor="beige">function</th><th bgcolor="beige">CL</th><th bgcolor="beige">Scheme</th><th bgcolor="beige">Ruby</th><th bgcolor="beige">Forth</th></tr>
<tr><td>complete-add</td>      
    <td>additive synthesis</td>
    <td>add.ins</td>
    </tr>

<tr><td>addflts</td>
    <td>filters</td>
    <td>addflt.ins</td> 
        <td><a href="dsp.scm">dsp.scm</a></td>
	<td><a href="dsp.rb">dsp.rb</a></td>
    </tr>

<tr><td>add-sound</td>
    <td>mix in a sound file</td>
    <td>addsnd.ins</td>
    </tr>

<tr><td>bullfrog et al</td>
    <td>many animals (frogs, insects, birds)</td>
    <td></td>
    <td><a href="animals.scm">animals.scm</a></td>
    </tr>

<tr><td>anoi</td>
    <td>noise reduction</td>
    <td>anoi.ins</td>
        <td><a href="clm-ins.scm">clm-ins.scm</a></td>
        <td><a href="clm-ins.rb">clm-ins.rb</a></td>
        <td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>autoc</td>
    <td>autocorrelation-based pitch estimation (Bret Battey)</td>
    <td>autoc.ins</td>
    </tr>

<tr><td>badd</td>
    <td>fancier additive synthesis (Doug Fulton)</td>
    <td>badd.ins</td>
    </tr>

<tr><td>fm-bell</td>
    <td>fm bell sounds (Michael McNabb)</td>
    <td>bell.ins</td>
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>bigbird</td>
    <td>waveshaping</td>
    <td>bigbird.ins</td>
	<td><a href="bird.scm">bird.scm</a></td>
	<td><a href="bird.rb">bird.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs, bird.fs</a></td>
    </tr>

<tr><td>canter</td>            
    <td>fm bagpipes (Peter Commons)</td>      
    <td>canter.ins</td>
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>cellon</td>            
    <td>feedback fm (Stanislaw Krupowicz)</td>      
    <td>cellon.ins</td>    
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>cnvrev</td>            
    <td>convolution (aimed at reverb)</td>      
    <td>cnv.ins</td><td><a href="clm-ins.scm">clm-ins.scm</a></td>
    </tr>

<tr><td>moving sounds</td>     
    <td>quad sound movement (Fernando Lopez-Lezcano)</td>      
    <td>dlocsig.lisp</td> 
	<td><a href="dlocsig.scm">dlocsig.scm</a></td>
        <td><a href="dlocsig.rb">dlocsig.rb</a></td>
    </tr>

<tr><td>drone</td>             
    <td>additive synthesis (bag.clm) (Peter Commons)</td>      
    <td>drone.ins</td>      
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>expandn</td>             
    <td>granular synthesis (Michael Klingbeil)</td>      
    <td>expandn.ins</td>      
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td></td>
	<td></td>
    </tr>

<tr><td>granulate-sound</td>   
    <td>examples of the granulate generator (granular synthesis)</td>      
    <td>expsrc.ins</td>    
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>cross-fade</td>        
    <td>cross-fades and dissolves in the frequency domain</td>      
    <td>fade.ins</td>        
	<td><a href="fade.scm">fade.scm</a></td>
    </tr>

<tr><td>filter-sound</td>      
    <td>filter a sound file</td>      
    <td>fltsnd.ins</td>    
	<td><a href="dsp.scm">dsp.scm</a></td>
    </tr>

<tr><td>stereo-flute</td>      
    <td>physical model of a flute (Nicky Hind)</td>      
    <td>flute.ins</td>      
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>fm examples</td>       
    <td>fm bell, gong, drum (Paul Weineke, Jan Mattox)</td>      
    <td>fmex.ins</td>        
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>Jezar's reverb</td>    
    <td>fancy reverb (Jezar Wakefield)</td>      
    <td>freeverb.ins</td> 
	<td><a href="freeverb.scm">freeverb.scm</a></td>
	<td><a href="freeverb.rb">freeverb.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>fofins</td>
    <td>FOF synthesis</td>
    <td><a href="#wave-train">sndclm.html</a></td> 
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>fullmix</td>           
    <td>a mixer</td>      
    <td>fullmix.ins</td>  
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>grani</td>             
    <td>granular synthesis (Fernando Lopez-Lezcano)</td>      
    <td>grani.ins</td>      
	<td><a href="grani.scm">grani.scm</a></td>
    </tr>

<tr><td>grapheq</td>           
    <td>graphic equalizer (Marco Trevisani)</td>      
    <td>grapheq.ins</td>  
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>fm-insect</td>         
    <td>fm</td>      
    <td>insect.ins</td>    
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
    </tr>

<tr><td>jc-reverb</td>         
    <td>an old reverberator (jlrev is a cavernous version)</td>      
    <td>jcrev.ins</td>      
	<td><a href="jcrev.scm">jcrev.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>fm-voice</td>          
    <td>fm voice (John Chowning)</td>      
    <td>jcvoi.ins</td>     
    <td><a href="jcvoi.scm">jcvoi.scm </a></td>
    </tr>

<tr><td>kiprev</td>            
    <td>a fancier (temperamental) reverberator (Kip Sheeline)</td>      
    <td>kiprev.ins</td>    
    </tr>

<tr><td>lbj-piano</td>         
    <td>additive synthesis piano (Doug Fulton)</td>      
    <td>lbjPiano.ins</td> 
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>maraca</td>            
    <td>Perry Cook's maraca physical models</td>      
    <td>maraca.ins</td>    
	<td><a href="maraca.scm">maraca.scm</a></td>
	<td><a href="maraca.rb">maraca.rb</a></td>
    </tr>

<tr><td>maxfilter</td>         
    <td>Juan Reyes modular synthesis</td>      
    <td>maxf.ins</td>        
	<td><a href="maxf.scm">maxf.scm</a></td>
	<td><a href="maxf.rb">maxf.rb</a></td>
    </tr>

<tr><td>mlb-voice</td>         
    <td>fm (originally waveshaping) voice (Marc LeBrun)</td>      
    <td>mlbvoi.ins</td>
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>moog filters</td>      
    <td>Moog filters (Fernando Lopez-Lezcano)</td>      
    <td>moog.lisp</td>      
	<td><a href="moog.scm">moog.scm</a></td>
    </tr>

<tr><td>fm-noise</td>          
    <td>noise maker</td>      
    <td>noise.ins</td>      
	<td><a href="noise.scm">noise.scm</a></td>
	<td><a href="noise.rb">noise.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>nrev</td>              
    <td>a popular reverberator (Michael McNabb)</td>      
    <td>nrev.ins</td>        
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>one-cut</td>           
    <td>a "cut and paste" instrument (Fernando Lopez-Lezcano)</td>      
    <td>one-cut.ins</td>  
    </tr>

<tr><td>p</td>                 
    <td>Scott van Duyne's piano physical model</td>      
    <td>piano.ins</td>      
	<td><a href="piano.scm">piano.scm</a></td>
	<td><a href="piano.rb">piano.rb</a></td>
    </tr>

<tr><td>pluck</td>             
    <td>Karplus-Strong synthesis (David Jaffe)</td>      
    <td>pluck.ins</td>      
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>pqw</td>               
    <td>waveshaping</td>      
    <td>pqw.ins</td>          
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>	
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>pqw-vox</td>           
    <td>waveshaping voice</td>      
    <td>pqwvox.ins</td>    
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>physical models</td>   
    <td>physical modelling (Perry Cook)</td>      
    <td>prc-toolkit95.lisp</td>
	<td><a href="prc95.scm">prc95.scm</a></td>
	<td><a href="prc95.rb">prc95.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>various ins</td>       
    <td>from Perry Cook's Synthesis Toolkit</td>      
    <td>prc96.ins</td>      
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>pvoc</td>              
    <td>phase vocoder (Michael Klingbeil)</td>      
    <td>pvoc.ins</td>        
	<td><a href="pvoc.scm">pvoc.scm</a></td>
	<td><a href="pvoc.rb">pvoc.rb</a></td>
    </tr>

<tr><td>resflt</td>            
    <td>filters (3 resonators) (Xavier Serra, Richard Karpen)</td>      
    <td>resflt.ins</td>    
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>reson</td>             
    <td>fm formants (John Chowning)</td>      
    <td>reson.ins</td>      
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>ring-modulate</td>     
    <td>ring-modulation of sounds (Craig Sapp)</td>      
    <td>ring-modulate.ins</td>
	<td><a href="examp.scm">examp.scm</a></td>
	<td><a href="examp.rb">examp.rb</a></td>
    </tr>

<tr><td>rmsenv</td>            
    <td>rms envelope of sound (Bret Battey)</td>      
    <td>rmsenv.ins</td>    
    </tr>

<tr><td>pins</td>              
    <td>spectral modelling</td>      
    <td>san.ins</td>          
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>scanned</td>           
    <td>Juan Reyes scanned synthesis instrument</td>      
    <td>scanned.ins</td>  
	<td><a href="dsp.scm">dsp.scm</a></td>
    </tr>

<tr><td>scentroid</td>         
    <td>spectral scentroid envelope (Bret Battey)</td>      
    <td>scentroid.ins</td> 
	<td><a href="dsp.scm">dsp.scm</a></td>
    </tr>

<tr><td>shepard</td>            
    <td>Shepard tones (Juan Reyes)</td>      
    <td>shepard.ins</td>    
	<td><a href="sndscm.html#wsdoc">sndscm.html</a></td>
	<td></td>
    </tr>

<tr><td>singer</td>            
    <td>Perry Cook's vocal tract physical model</td>      
    <td>singer.ins</td>    
	<td><a href="singer.scm">singer.scm</a></td>
	<td><a href="singer.rb">singer.rb</a></td>
    </tr>

<tr><td>sndwarp</td>           
    <td>Csound-like sndwarp generator (Bret Battey)</td>      
    <td>sndwarp.ins</td>   
	<td><a href="sndwarp.scm">sndwarp.scm</a></td>
    </tr>

<tr><td>stochastic</td>        
    <td>Bill Sack's stochastic synthesis implementation</td>      
    <td>stochastic.ins</td><td><a href="stochastic.scm">stochastic.scm</a></td>
    </tr>

<tr><td>bow</td>               
    <td>Juan Reyes bowed string physical model</td>      
    <td>strad.ins</td>      
	<td><a href="strad.scm">strad.scm</a></td>
	<td><a href="strad.rb">strad.rb</a></td>
    </tr>

<tr><td>track-rms</td>         
    <td>rms envelope of sound file (Michael Edwards)</td>      
    <td>track-rms.ins</td>        
    </tr>

<tr><td>fm-trumpet</td>        
    <td>fm trumpet (Dexter Morrill)</td>      
    <td>trp.ins</td>          
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>various ins</td>       
    <td>granular synthesis, formants, etc</td>      
    <td>ugex.ins</td>        
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
    </tr>

<tr><td>test ins</td>          
    <td>CLM regression tests &mdash; see clm-test.lisp</td>      
    <td>ug(1,2,3,4).ins</td>   
	<td><a href="clm23.scm">clm23.scm</a></td>
    </tr>

<tr><td>fm-violin</td>         
    <td>fm violin (fmviolin.clm, popi.clm)</td>      
    <td>v.ins</td>              
	<td><a href="v.scm">v.scm</a></td>
	<td><a href="v.rb">v.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>vowel</td>             
    <td>vowels via pulse-train and formant (Michelle Daniels)</td>      
    <td>vowel.ins</td>      
    </tr>

<tr><td>vox</td>               
    <td>fm voice (cream.clm)</td>      
    <td>vox.ins</td>          
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>zc, zn</td>            
    <td>interpolating delays</td>      
    <td>zd.ins</td>            
	<td><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td>zipper</td>            
    <td>The 'digital zipper' effect.</td>      
    <td>zipper.ins</td>    
	<td><a href="zip.scm">zip.scm</a></td>
	<td><a href="zip.rb">zip.rb</a></td>
    </tr>

</table>

<p>
If you develop
an interesting instrument that you're willing to share, please send it to me
(bil@ccrma.stanford.edu). 
</p>

<p><a href="sndscm.html#definstrument">definstrument</a>, the individual instruments, and <a href="sndscm.html#wsdoc">with-sound</a> are documented in 
<a href="sndscm.html">sndscm.html</a>.
</p>


<br><br>
<center>
<table bgcolor="aliceblue" border=0 cellspacing=8><tr>
<td><small>related documentation:</small></td>
<td><small><a href="snd.html" onmouseout="UnTip()" onmouseover="Tip(snd_html_tip)">snd.html</a></small></td>
<td><small><a href="extsnd.html" onmouseout="UnTip()" onmouseover="Tip(extsnd_html_tip)">extsnd.html</a></small></td>
<td><small><a href="grfsnd.html" onmouseout="UnTip()" onmouseover="Tip(grfsnd_html_tip)">grfsnd.html</a></small></td>
<td><small><a href="sndscm.html" onmouseout="UnTip()" onmouseover="Tip(sndscm_html_tip)">sndscm.html</a></small></td>
<td><small><a href="fm.html" onmouseout="UnTip()" onmouseover="Tip(fm_html_tip)">fm.html</a></small></td>
<td><small><a href="sndlib.html" onmouseout="UnTip()" onmouseover="Tip(sndlib_html_tip)">sndlib.html</a></small></td>
<td><small><a href="libxm.html" onmouseout="UnTip()" onmouseover="Tip(libxm_html_tip)">libxm.html</a></small></td>
<td><small><a href="s7.html" onmouseout="UnTip()" onmouseover="Tip(s7_html_tip)">s7.html</a></small></td>
<td><small><a href="index.html" onmouseout="UnTip()" onmouseover="Tip(index_html_tip)">index.html</a></small></td>
</tr></table>
</center>

</body></html>
