/* xm.c: Guile/Gauche/Ruby/Forth bindings for X/Xt/Xpm/Xm/Xp/Xext
 *   needs xen.h
 *   for tests and examples see snd-motif.scm, bess.scm|rb, and snd-test.scm
 */

#include <mus-config.h>

#define XM_DATE "26-Aug-06"

/* HISTORY: 
 *
 *   26-Aug:    removed WITH_GTK_AND_X11 switch.
 *   21-Apr:    Gauche additions.
 *   30-Jan:    removed XmMultiList.
 *   1-Jan-06:  XmNpopupEnabled resource type changed from boolean to int (enum) (Motif docs bug).
 *   --------
 *   16-Sep:    XmUNSPECIFIED_PIXEL and friends should be unsigned long (not int).
 *   17-Aug:    XtSetArg 3rd arg should be 0, not NULL (type mismatch if 64-bit).
 *   14-June:   various xen-related updates (XEN_DEFINE).
 *   13-June:   fold xm-ruby.c into xm.c.
 *   15-Apr:    XGetWindowProperty free bugfix.
 *   28-Mar:    fix some Ruby error strings (#f->false).
 *   31-Jan:    remove Motif 1 support, and Lesstif.
 *   4-Jan-05:  replace XEN_VECTOR_ELEMENTS usages.
 *   --------
 *   30-Dec:    plug various memory leaks.
 *   23-Nov:    resource type lookup indexing bugfix.
 *   22-Sep:    various minor cleanups.
 *   23-Aug:    more changes for new Guile.
 *   12-Aug:    some changes to accommodate new Guile names.
 *   22-June:   XmColorSelector resources.
 *   19-May:    plug several memory leaks.
 *   21-Apr:    XmMultiList, XmTabStack.
 *   19-Apr:    XmDataField.
 *   12-Apr:    XmDropDown, XmColumn.
 *   7-Apr:     XmButtonBox.
 *   22-Mar:    added feature 'Xp to indicate that the Xp stuff is included.
 *   8-Mar:     XtAppAddActionHook arity bugfix.
 *   12-Jan:    resources for XmFontSelector.
 *   8-Jan:     various changes for the SGI C compiler, thanks to Avi Bercovich.
 *   5-Jan-04:  added (Motif 2.2.3) XmCreateFontSelector, XmCreateColorSelector.
 *   --------
 *   1-Dec:     XShapeGetRectangles XRectangle array needed local allocation.
 *              removed (unusable) XtCallCallbackList.
 *   25-Nov:    more GC protection. Removed XInitThreads, XLockDisplay, XUnlockDisplay. Fixed XmTextBlock allocation bug.
 *   15-Oct:    XFontsOfFontSet indexing bugfix and several more struct field accessors from MS.
 *   14-Oct:    XShapeQueryExtension from Michael Scholz, plus other extensions/shape.h functions and constants.
 *              Also XSizeHints, XSet[Standard|WM]Properties and accessors for input and initial_state.
 *   3-Oct:     removed some macros that were intended only for testing, added XmTOP_LEFT etc.
 *   29-Sep:    changed: XSetWindowBorder, XSetWindowBackground, XCreatePixmapFromBitmapData, XSetWindowAttributes,
 *                 .backing_pixel, .border_pixel, .background_pixel, .base_pixel; these now use the "wrapped"
 *                 form of pixels, not the bare unsigned long.
 *   26-Sep:    .event -> #f if event is NULL.
 *   3-Sep:     XmRenderTableGetRenditions was incorrectly freeing the XmRenditions.
 *   20-Aug:    XtEventHandler *flag set to false if handler returns 'done.
 *   11-Aug:    int -> bool.
 *   17-July:   XpmAttributes .colorsymbols is a list.
 *   15-July:   type check cleanups.
 *   14-July:   .depths returns a list of Depth pointers; similar change for .visuals.
 *   11-July:   Several int->Dimension|Position|short resource type changes.
 *              removed several more undocumented resource names.
 *   23-June:   Motif 1 fixups.
 *   10-June:   added XmCvtByteStreamToXmString, XmCvtXmStringToByteStream, XmStringByteStreamLength.
 *              removed XFreeStringList (a no-op).
 *   20-May:    showValue resource is int (enumeration) in Motif 2.  resizeWidth|Height are booleans, not ints.
 *   9-May:     Ruby fixups (some functions accidentally omitted earlier).
 *   8-Apr:     XSetErrorHandler proc takes XErrorEvent, not XEvent 2nd arg (thanks Friedrich Delgado Friedrichs)
 *   7-Apr:     more changes for the WITH_GTK_AND_X11 switch.
 *   1-Apr:     XGetWindowProperty uses mem2string if not XA_STRING.
 *   31-Mar:    added WITH_GTK_AND_X11 switch for xg+local X funcs.
 *   4-Mar:     xm-ruby XM_DEFINE_ACCESSOR quoted SetName bugfix (Michael Scholz).
 *   1-Feb-03:  XChangeProperty data (arg7) can be list of ints as well as string.
 *   ----------
 *   19-Dec:    more Ruby fixups.
 *   6-Nov:     Ruby XmWMProtocols bugfixes thanks to Michael Scholz.
 *   17-Oct:    XtAppSetFallbackResources and fallbacks added to XtAppInitialize etc.
 *   15-Oct:    XtGetResourceList.
 *   11-Oct:    xm-ruby XM_DEFINE* cleaned up (thanks to Michael Scholz).
 *              removed all (ignored) XrmOptionDesc args (XtAppInitialize etc).
 *   8-Oct:     added [MUS_]WITH_EDITRES to include _XEditResCheckMessages.
 *   1-Oct:     some int args are now KeyCodes (Modifiermap stuff).
 *   23-Sep:    X ScreenSaver constants omitted earlier.
 *   18-Sep:    properties XFontStruct field now returns list of all properties.
 *              removed XmFontListCreate_r, XmFontListEntryCreate_r
 *   9-Sep:     added Motif WMProtocol convenience macros.
 *   30-Aug:    added add-resource for user-defined extensions to the resources.
 *   29-Aug:    added ten resources accidentally omitted earlier (thanks to Michael Scholz).
 *   2-Aug:     some Lesstif-related compile-time switches.
 *   26-Jul:    removed wrappers Widget Pixel GC and XtAppContext.
 *   24-Jul:    removed "|" prefix, use "." as default struct field prefix.
 *   19-Jul:    XM_FIELD_PREFIX for change from using vertical-bar ("|" is reserved in R5RS).
 *   17-Jun:    removed XtSetWMColormapWindows.
 *   29-Apr:    minor 64-bit fixups.
 *   29-Mar:    XmParseProc.
 *   20-Mar:    XpmGetErrorString omitted inadvertently earlier.
 *   4-Mar:     XWindowChanges and XSetWindowAttributes struct creators.
 *   1-Mar:     XmTabListFree, various ->* conversions (->strings etc).
 *   25-Feb:    XmTextBlock fields
 *   22-Feb:    #f = NULL and vice-versa throughout
 *   21-Feb:    added various callback struct makers, changed XtCallCallbacks to be compatible with them.
 *   18-Feb:    removed undocumented functions: XmCvtFromHorizontalPixels, XmCvtFromVerticalPixels, XmCvtToHorizontalPixels, XInitImage
 *                XmCvtToVerticalPixels, XmGetIconFileName, XmStringCreateFontList, XmStringCreateFontList_r, XmStringLtoRCreate
 *              added XM_DISABLE_DEPRECATED which affects:
 *                XtError, XtSetErrorHandler, XtSetWarningHandler, XtSetErrorMsgHandler, XtSetWarningMsgHandler, XtWarningMsg, XtAppWarning, XtErrorMsg
 *                XtSetSelectionTimeout, XtInitialize , XtAddActions, XtAddInput, XtAddTimeout, XtAddWorkProc, XtCreateApplicationShell
 *                XtNextEvent, XtPeekEvent, XtPending, XtProcessEvent, XtMainLoop, XtGetSelectionTimeout, XtWarning,
 *                XmNdefaultFontList, XmNshellUnitType, XmNfontList, XmFontList*, XmNchildType, XmGetMenuCursor, 
 *                XmNstringDirection, XmMainWindowSep1, XmMainWindowSep2, XmMainWindowSep3, XmMainWindowSetAreas, 
 *                XmNwhichButton, XmScrolledWindowSetAreas, XmSetFontUnit, XmSetFontUnits, XmNdefaultFontList, 
 *                XmSetMenuCursor, XmStringByteCompare, XmStringCreateLtoR, XmSTRING_COMPONENT_CHARSET, XmSTRING_COMPONENT_FONTLIST_ELEMENT_TAG,
 *                XmStringCreateSimple, XmStringGetLtoR, XmStringGetNextComponent, XmStringGetNextSegment, XmStringLength, XmStringNConcat
 *                XmStringNCopy, XmStringPeekNextComponent, XmStringSegmentCreate, XmTrackingLocate, XmRemoveFrom|AddTo|PostFromList
 *                XGet|SetStandardColormap
 *              added XmWidgetGetDisplayRect inadvertently omitted earlier.
 *   14-Feb:    XUniqueContext added, XExtentsOfFontSet and XGetErrorDatabaseText deleted.
 *              X save-set and X host-address stuff deleted.
 *              XVisualInfo fields added. 
 *              Cursor type added.
 *   1-Feb:     Motif 2.2 additions (tooltip).
 *   21-Jan:    Ruby fixups (XEN_COPY_ARG to protect lists)
 *   7-Jan-02:  XEvent fields settable. added XtCallCallbacks-raw.
 *   ----------
 *   12-Sep:    xm-version.
 *   13-Aug:    Xp bindings, X11 predefined Atoms.
 *   6-Aug:     XmTransfer functions inadvertently omitted earlier.
 *   3-Aug:     type checks in XtSetValues.
 *   23-Jul-01: use lists rather than vectors.
 */

#if UNDEF_USE_SND
  #undef USE_SND
  #define USE_SND 0
#endif

#if HAVE_EXTENSION_LANGUAGE

#if HAVE_MOTIF
  #include <Xm/XmAll.h>
#else
  #include <X11/Xlib.h>
  #include <X11/Intrinsic.h>
  #include <X11/Shell.h>
  #include <X11/Xatom.h>
#endif

#include <X11/keysym.h>
#include <X11/cursorfont.h>
#include <stdio.h>

#if HAVE_XSHAPEQUERYEXTENSION
#include <X11/extensions/shape.h>
#endif

/* compile-time flags are HAVE_XPM HAVE_MOTIF HAVE_XM_XP HAVE_GUILE|HAVE_RUBY XM_DISABLE_DEPRECATED MUS_WITH_EDITRES */

/* if you're using g++ and it complains about XmRemoveFromPostFromList, update Motif (you need 2.1.30) */

#if USE_SND
  /* USE_SND causes xm to use Snd's error handlers which are much smarter than xen's fallback versions */
  #include "snd.h"
#else
  #include "xen.h"
  /* in snd-0.h: */
  #if HAVE_RUBY
    #define S_setB "set_"
    #define PROC_FALSE "false"
  #endif
  #if HAVE_SCHEME
    #define S_setB "set! "
    #define PROC_FALSE "#f"
  #endif
  #if HAVE_FORTH
    #define S_setB "set-"
    #define PROC_FALSE "#f"
  #endif
  #define NOT_A_GC_LOC -1
#endif

#ifndef CALLOC
  #define CALLOC(a, b)  calloc((size_t)(a), (size_t)(b))
  #define MALLOC(a)     malloc((size_t)(a))
  #define FREE(a)       free(a)
  #define REALLOC(a, b) realloc(a, (size_t)(b))
#endif

#if HAVE_XPM
  #include <X11/xpm.h>
#endif
#if HAVE_XmCreateDataField
  #include <Xm/DataF.h>
#endif
#if HAVE_XmCreateTabStack
  #include <Xm/TabStack.h>
#endif
#if HAVE_XmCreateButtonBox
  #include <Xm/ButtonBox.h>
#endif
#if HAVE_XmCreateColumn
  #include <Xm/Column.h>
#endif
#if HAVE_XmCreateDropDown
  #include <Xm/DropDown.h>
#endif
#if HAVE_XmCreateFontSelector
  #include <Xm/FontS.h>
#endif
#if HAVE_XmCreateColorSelector
  #include <Xm/ColorS.h>
#endif
#if MUS_WITH_EDITRES
  #include <X11/Xmu/Editres.h>
#endif

/* prefix for all names */
#if HAVE_SCHEME
  #define XM_PREFIX ""
  #define XM_POSTFIX ""
  #define XM_FIELD_PREFIX "."
#endif
#if HAVE_RUBY
/* for Ruby, XM PREFIX needs to be uppercase */
  #define XM_PREFIX "R"
  #define XM_POSTFIX ""
  #define XM_FIELD_PREFIX "R"
#endif
#if HAVE_FORTH
  #define XM_PREFIX "F"
  #define XM_POSTFIX ""
  #define XM_FIELD_PREFIX "F"
#endif

#define XM_FIELD_ASSERT_TYPE(Assertion, Arg, Position, Caller, Correct_Type) \
  XEN_ASSERT_TYPE(Assertion, Arg, Position, XM_FIELD_PREFIX Caller XM_POSTFIX, Correct_Type)

#if HAVE_RUBY
  #define XM_SET_FIELD_ASSERT_TYPE(Assertion, Arg, Position, Caller, Correct_Type) \
    XEN_ASSERT_TYPE(Assertion, Arg, Position, XM_FIELD_PREFIX S_setB Caller XM_POSTFIX, Correct_Type)
#endif
#if HAVE_SCHEME || HAVE_FORTH
  #define XM_SET_FIELD_ASSERT_TYPE(Assertion, Arg, Position, Caller, Correct_Type) \
    XEN_ASSERT_TYPE(Assertion, Arg, Position, S_setB XM_FIELD_PREFIX Caller XM_POSTFIX, Correct_Type)
#endif

#define XtIsSubClass XtIsSubclass
/* kludge around a bug in some Motif versions */

/* layout of file:
 *    preliminaries
 *    type manglers
 *    arglist handlers
 *    Motif procedures
 *    X procedures
 *    Xt procedures
 *    Xp procedures
 *    Xpm procedures
 *    struct handlers
 *    string constants
 *    integer constants
 *    pointer constants
 *    atom constants
 */

/* --------------------------------------------------------------------------------
 * a sample program

(let* ((shell-app (XtVaOpenApplication 
		    "Test" 0 '() applicationShellWidgetClass
		    (list XmNallowShellResize #t)))
       (app (cadr shell-app))
       (shell (car shell-app))
       (black (BlackPixelOfScreen 
		(DefaultScreenOfDisplay 
		  (XtDisplay shell)))))
  (if (not (XtIsApplicationShell shell))
      (display "not appshell"?))
  (XtSetValues shell (list XmNtitle "Hi!"))
  (let* ((main-pane 
	  (XtVaCreateManagedWidget 
	    "main-pane" xmFormWidgetClass shell
	    (list XmNforeground       black
		  XmNtopAttachment    XmATTACH_FORM
		  XmNbottomAttachment XmATTACH_FORM
		  XmNleftAttachment   XmATTACH_FORM
		  XmNrightAttachment  XmATTACH_FORM
		  XmNallowResize      #t)))
	 (button (XtCreateManagedWidget 
		   "push me" xmPushButtonWidgetClass main-pane '() 0)))
    (XtAddCallback button XmNactivateCallback 
		    (lambda (widget context event-info)
		      (display widget)
		      (display (.reason event-info))
		      (display context))
		    123)
    (XtRealizeWidget shell)
    (XtAppMainLoop app)))
 */


/* --------------------------------------------------------------------------------
 * differences from C:
 *
 *    Arg list is lisp list of name/value pairs and the "len" arg associated with it is optional
 *    ref args are usually returned by proc, and not passed in unless init val is needed
 *    array args are passed as lists, returned as lists
 *    pointers to structs are '(type val) where val is opaque except via accessors 
 *      that is, all non-simple types are lists in xm where the first element is a symbol describing the type
 *      and the second is usually the C value stored directly as an unsigned long
 *    "Va" args are passed and returned as lists
 *    XtCallback procedure args are passed by value
 *    various "client data" args are optional
 *    XtCallbackLists are passed as lists of procedure/data pairs
 *    where explicit NULL is needed as arg, use #f (or '() for list args)
 *
 * omitted:       
 *
 *    Xwc*, Xrm*, XIM*, XOM*, XIC*, XOC*, Xcms*, 
 *    "resource" handlers and "quark" stuff (XtAppSetTypeConverter etc)
 *    all XTextProperty, XClassHint, XSizeHints support, XSetIconSizes
 *    XConnection internal stuff, XVaCreateNestedList, XSetAuthorization
 *    XtQueryGeometry and XtMakeGeometryRequest, all text16 stuff
 *    XtGetKeySymTable, XtChangeManagedSet (undocumented), XtAppGet|SetExitFlag
 *    XtSetEventDispatcher (undoc), XtSignal stuff (undoc), XtGetErrorDatabaseText
 *    XtBlockHook stuff (undoc), XtRegisterExtensionSelector (undoc)
 *    XmResolvePartOffsets, XmResolveAllPartOffsets
 *    XpSet|GetLocaleHinter, XFreeStringList
 *    XtHooksOfDisplay, XtRegiserDrawable, XtUnregisterDrawable
 *
 * added:
 *
 *    XGCValues -> a blank XGCValues struct (for XCreateGC etc)
 *    XColor pixel red green blue flags pad
 *    XArc XRectangle XPoint XSegment XEvent XWindowChanges XSetWindowAttributes
 *    XTextItem XpmImage XpmColorSymbol
 *    XDrawLinesDirect same as XDrawLines but takes (opaque) ptr to XPoint array
 *    vector->XPoints vect packages point data in vector as (opaque) array of XPoints 
 *    freeXPoints to free (opaque) XPoint array created by vector->Xpoints
 *    <name>? -> #t if arg is of type <name>
 *    <name> -> empty struct of type <name>
 *
 * Structs are accessed by the field name and the lisp variable (which contains the struct type)
 *   (.pixel color) for example, or (.foreground gcvalue)
 */
 


/* -------------------------------- smob for GC -------------------------------- */

/* "smob" for locally created stuff (X graphics entities mainly) */

static XEN_OBJECT_TYPE xm_obj_tag;

#if HAVE_GUILE
static size_t xm_obj_free(XEN obj)
{
  void *val;
  val = (void *)XEN_OBJECT_REF(obj);
  FREE(val);
  return(0);
}
#endif

#if HAVE_GAUCHE
static void xm_obj_free(XEN obj)
{
  void *val;
  val = (void *)XEN_OBJECT_REF(obj);
  FREE(val);
}
#endif

#if HAVE_RUBY
static void *xm_obj_free(XEN obj)
{
  void *vobj;
  vobj = (void *)obj;
  FREE(vobj);
  return(NULL);
}
#endif

#if HAVE_FORTH
static void xm_obj_free(XEN obj)
{
  void *val;
  val = (void *)XEN_OBJECT_REF(obj);
  FREE(val);
}
#endif

static XEN make_xm_obj(void *ptr)
{
  XEN_MAKE_AND_RETURN_OBJECT(xm_obj_tag, ptr, 0, xm_obj_free);
}

static void define_xm_obj(void)
{
#if (!HAVE_GAUCHE)
  xm_obj_tag = XEN_MAKE_OBJECT_TYPE("XmObj", sizeof(void *));
#else
  xm_obj_tag = XEN_MAKE_OBJECT_TYPE("XmObj", sizeof(void *), NULL, xm_obj_free);
#endif
#if HAVE_GUILE
  scm_set_smob_free(xm_obj_tag, xm_obj_free);
#endif
#if HAVE_FORTH
  fth_set_object_free(xm_obj_tag, xm_obj_free);
#endif
}  


/* -------------------------------- type manglers -------------------------------- */

/* most non-simple vars are handled as a list: (type ptr) where ptr is the (un-interpreted) C value
 *   the _OBJ form is used where we need to eventually free the memory
 *   the _PTR form treats NULL as #f and vice-versa
 */

#define WRAP_FOR_XEN(Name, Value) XEN_LIST_2(C_STRING_TO_XEN_SYMBOL(Name), C_TO_XEN_ULONG((unsigned long)Value))
#define WRAP_FOR_XEN_OBJ(Name, Value) XEN_LIST_3(C_STRING_TO_XEN_SYMBOL(Name), C_TO_XEN_ULONG((unsigned long)Value), make_xm_obj(Value))
#define WRAP_P(Name, Value) (XEN_LIST_P(Value) && \
                            (XEN_LIST_LENGTH(Value) >= 2) && \
                            (XEN_SYMBOL_P(XEN_CAR(Value))) && \
                            (strcmp(Name, XEN_SYMBOL_TO_C_STRING(XEN_CAR(Value))) == 0))

#define XM_TYPE(Name, XType) \
  static XEN C_TO_XEN_ ## Name (XType val) {return(WRAP_FOR_XEN(#Name, val));} \
  static XType XEN_TO_C_ ## Name (XEN val) {return((XType)XEN_TO_C_ULONG(XEN_CADR(val)));} \
  static bool XEN_ ## Name ## _P(XEN val) {return(WRAP_P(#Name, val));} \
  static XEN XEN_ ## Name ## _p(XEN val) {return(C_TO_XEN_BOOLEAN(WRAP_P(#Name, val)));}

#define XM_TYPE_NO_p(Name, XType) \
  static XEN C_TO_XEN_ ## Name (XType val) {return(WRAP_FOR_XEN(#Name, val));} \
  static XType XEN_TO_C_ ## Name (XEN val) {return((XType)XEN_TO_C_ULONG(XEN_CADR(val)));} \
  static bool XEN_ ## Name ## _P(XEN val) {return(WRAP_P(#Name, val));}

#define XM_TYPE_PTR(Name, XType) \
  static XEN C_TO_XEN_ ## Name (XType val) {if (val) return(WRAP_FOR_XEN(#Name, val)); return(XEN_FALSE);} \
  static XType XEN_TO_C_ ## Name (XEN val) {if (XEN_FALSE_P(val)) return((XType)NULL); return((XType)XEN_TO_C_ULONG(XEN_CADR(val)));} \
  static bool XEN_ ## Name ## _P(XEN val) {return(WRAP_P(#Name, val));} \
  static XEN XEN_ ## Name ## _p(XEN val) {return(C_TO_XEN_BOOLEAN(WRAP_P(#Name, val)));}

#define XM_TYPE_PTR_NO_p(Name, XType) \
  static XEN C_TO_XEN_ ## Name (XType val) {if (val) return(WRAP_FOR_XEN(#Name, val)); return(XEN_FALSE);} \
  static XType XEN_TO_C_ ## Name (XEN val) {if (XEN_FALSE_P(val)) return((XType)NULL); return((XType)XEN_TO_C_ULONG(XEN_CADR(val)));} \
  static bool XEN_ ## Name ## _P(XEN val) {return(WRAP_P(#Name, val));}

#define XM_TYPE_PTR_NO_p_NO_P(Name, XType) \
  static XEN C_TO_XEN_ ## Name (XType val) {if (val) return(WRAP_FOR_XEN(#Name, val)); return(XEN_FALSE);} \
  static XType XEN_TO_C_ ## Name (XEN val) {if (XEN_FALSE_P(val)) return((XType)NULL); return((XType)XEN_TO_C_ULONG(XEN_CADR(val)));}

#define XM_TYPE_PTR_NO_C2X(Name, XType) \
  static XType XEN_TO_C_ ## Name (XEN val) {if (XEN_FALSE_P(val)) return((XType)NULL); return((XType)XEN_TO_C_ULONG(XEN_CADR(val)));} \
  static bool XEN_ ## Name ## _P(XEN val) {return(WRAP_P(#Name, val));} \
  static XEN XEN_ ## Name ## _p(XEN val) {return(C_TO_XEN_BOOLEAN(WRAP_P(#Name, val)));}

#define XM_TYPE_PTR_NO_C2X_NO_p(Name, XType) \
  static XType XEN_TO_C_ ## Name (XEN val) {if (XEN_FALSE_P(val)) return((XType)NULL); return((XType)XEN_TO_C_ULONG(XEN_CADR(val)));} \
  static bool XEN_ ## Name ## _P(XEN val) {return(WRAP_P(#Name, val));}

#define XM_TYPE_PTR_OBJ(Name, XType) \
  static XEN C_TO_XEN_ ## Name (XType val) {if (val) return(WRAP_FOR_XEN_OBJ(#Name, val)); return(XEN_FALSE);} \
  static XType XEN_TO_C_ ## Name (XEN val) {if (XEN_FALSE_P(val)) return(NULL); return((XType)XEN_TO_C_ULONG(XEN_CADR(val)));} \
  static bool XEN_ ## Name ## _P(XEN val) {return(WRAP_P(#Name, val));} \
  static XEN XEN_ ## Name ## _p(XEN val) {return(C_TO_XEN_BOOLEAN(WRAP_P(#Name, val)));}


#define XEN_TO_C_Dimension(Arg)  (Dimension)(XEN_TO_C_INT(Arg))
#define C_TO_XEN_Dimension(Arg)  (C_TO_XEN_INT((Dimension)Arg))
#define XEN_Dimension_P(Arg)     (XEN_INTEGER_P(Arg))

#define XEN_TO_C_Position(Arg)   (Position)(XEN_TO_C_INT(Arg))
#define C_TO_XEN_Position(Arg)   (C_TO_XEN_INT((Position)Arg))
#define XEN_Position_P(Arg)      (XEN_INTEGER_P(Arg))

#define XEN_TO_C_char(Arg)       (char)(XEN_TO_C_INT(Arg))
#define C_TO_XEN_char(Arg)       (C_TO_XEN_INT(Arg))
#define XEN_char_P(Arg)          (XEN_INTEGER_P(Arg))

#define XEN_TO_C_Modifiers(Arg)  (Modifiers)(XEN_TO_C_ULONG(Arg))
#define C_TO_XEN_Modifiers(Arg)  (C_TO_XEN_ULONG(Arg))
#define XEN_Modifiers_P(Arg)     (XEN_ULONG_P(Arg))

XM_TYPE(Cursor, Cursor)
XM_TYPE_PTR(Screen, Screen *)
XM_TYPE_PTR_OBJ(XRectangle, XRectangle *)
XM_TYPE_PTR_OBJ(XArc, XArc *)
XM_TYPE_PTR_OBJ(XPoint, XPoint *)
XM_TYPE_PTR_OBJ(XSegment, XSegment *)
XM_TYPE_PTR_OBJ(XColor, XColor *)
XM_TYPE(Atom, Atom)
XM_TYPE_PTR(Colormap, Colormap)
XM_TYPE_PTR_NO_C2X(Depth, Depth *)
XM_TYPE_PTR(Display, Display *)
XM_TYPE(Font, Font)
XM_TYPE(GC, GC)
XM_TYPE(KeySym, KeySym)
XM_TYPE(Pixel, Pixel)
XM_TYPE(Pixmap, Pixmap)
XM_TYPE(Region, Region)
XM_TYPE(Time, Time)
XM_TYPE_PTR(Visual, Visual *)
XM_TYPE_PTR(Window, Window)
XM_TYPE_PTR(XCharStruct, XCharStruct *)
XM_TYPE_PTR(XFontProp, XFontProp *)
XM_TYPE(XFontSet, XFontSet)
XM_TYPE_PTR(XFontStruct, XFontStruct *)
XM_TYPE_PTR(XGCValues, XGCValues *)
XM_TYPE_PTR_NO_C2X(XTextItem, XTextItem *)
XM_TYPE_PTR(XModifierKeymap, XModifierKeymap *) /* opaque in this implementation */
XM_TYPE_PTR(XImage, XImage *)
static XAnyEvent *XEN_TO_C_XAnyEvent(XEN val) {return((XAnyEvent *)XEN_TO_C_ULONG(XEN_CADR(val)));}
XM_TYPE_PTR_NO_C2X(XButtonEvent, XButtonEvent *)
XM_TYPE_PTR_NO_C2X(XCirculateEvent, XCirculateEvent *)
XM_TYPE_PTR_NO_C2X(XCirculateRequestEvent, XCirculateRequestEvent *)
XM_TYPE_PTR_NO_C2X(XClientMessageEvent, XClientMessageEvent *)
XM_TYPE_PTR_NO_C2X(XColormapEvent, XColormapEvent *)
XM_TYPE_PTR_NO_C2X(XConfigureEvent, XConfigureEvent *)
XM_TYPE_PTR_NO_C2X(XConfigureRequestEvent, XConfigureRequestEvent *)
XM_TYPE_PTR_NO_C2X(XCreateWindowEvent, XCreateWindowEvent *)
XM_TYPE_PTR_NO_C2X(XCrossingEvent, XCrossingEvent *)
XM_TYPE_PTR_NO_C2X(XDestroyWindowEvent, XDestroyWindowEvent *)
XM_TYPE_PTR(XErrorEvent, XErrorEvent *)
XM_TYPE_PTR_NO_C2X(XExposeEvent, XExposeEvent *)
XM_TYPE_PTR_NO_C2X(XFocusChangeEvent, XFocusChangeEvent *)
XM_TYPE_PTR_NO_C2X(XGraphicsExposeEvent, XGraphicsExposeEvent *)
XM_TYPE_PTR_NO_C2X(XGravityEvent, XGravityEvent *)
XM_TYPE_PTR_NO_C2X(XKeyEvent, XKeyEvent *)
XM_TYPE_PTR_NO_C2X(XKeymapEvent, XKeymapEvent *)
XM_TYPE_PTR_NO_C2X(XMapEvent, XMapEvent *)
XM_TYPE_PTR_NO_C2X(XMapRequestEvent, XMapRequestEvent *)
XM_TYPE_PTR_NO_C2X(XMappingEvent, XMappingEvent *)
XM_TYPE_PTR_NO_C2X(XMotionEvent, XMotionEvent *)
XM_TYPE_PTR_NO_C2X(XNoExposeEvent, XNoExposeEvent *)
XM_TYPE_PTR_NO_C2X(XPropertyEvent, XPropertyEvent *)
XM_TYPE_PTR_NO_C2X(XReparentEvent, XReparentEvent *)
XM_TYPE_PTR_NO_C2X(XResizeRequestEvent, XResizeRequestEvent *)
XM_TYPE_PTR_NO_C2X(XSelectionClearEvent, XSelectionClearEvent *)
XM_TYPE_PTR_NO_C2X(XSelectionEvent, XSelectionEvent *)
XM_TYPE_PTR(XSelectionRequestEvent, XSelectionRequestEvent *)
XM_TYPE_PTR_NO_C2X(XUnmapEvent, XUnmapEvent *)
XM_TYPE_PTR_NO_C2X(XVisibilityEvent, XVisibilityEvent *)
XM_TYPE_PTR_OBJ(XSetWindowAttributes, XSetWindowAttributes *)
XM_TYPE_PTR(XVisualInfo, XVisualInfo *)
XM_TYPE_PTR(XWMHints, XWMHints *)
XM_TYPE_PTR_NO_C2X_NO_p(XSizeHints, XSizeHints *)
XM_TYPE_PTR(XWindowAttributes, XWindowAttributes *)
XM_TYPE_PTR_OBJ(XWindowChanges, XWindowChanges *)
XM_TYPE_PTR(XStandardColormap, XStandardColormap *)
XM_TYPE(KeyCode, KeyCode)
XM_TYPE(XContext, XContext)
XM_TYPE_PTR(XIconSize, XIconSize *)

#if HAVE_XM_XP
XM_TYPE(XPContext, XPContext)
#endif

#if HAVE_MOTIF
XM_TYPE_PTR(Widget, Widget)
XM_TYPE(WidgetClass, WidgetClass)
XM_TYPE(XtAppContext, XtAppContext)
XM_TYPE(XtRequestId, XtRequestId)
XM_TYPE(XtWorkProcId, XtWorkProcId)
XM_TYPE(XtInputId, XtInputId)
XM_TYPE(XtIntervalId, XtIntervalId)
XM_TYPE_NO_p(XtActionHookId, XtActionHookId)
XM_TYPE_NO_p(XtTranslations, XtTranslations) /* opaque */
XM_TYPE_PTR(XmString, XmString)
XM_TYPE_PTR_NO_p_NO_P(XmAnyCallbackStruct, XmAnyCallbackStruct *)
XM_TYPE_PTR_NO_p(XmArrowButtonCallbackStruct, XmArrowButtonCallbackStruct *)
XM_TYPE_PTR_NO_p(XmCommandCallbackStruct, XmCommandCallbackStruct *)
XM_TYPE_PTR_NO_p(XmDragDropFinishCallbackStruct, XmDragDropFinishCallbackStruct *)
XM_TYPE_PTR_NO_p(XmDragMotionCallbackStruct, XmDragMotionCallbackStruct *)
XM_TYPE_PTR_NO_p(XmDragProcCallbackStruct, XmDragProcCallbackStruct *)
XM_TYPE_PTR_NO_p(XmDrawingAreaCallbackStruct, XmDrawingAreaCallbackStruct *)
XM_TYPE_PTR_NO_p(XmDrawnButtonCallbackStruct, XmDrawnButtonCallbackStruct *)
XM_TYPE_PTR_NO_p(XmDropFinishCallbackStruct, XmDropFinishCallbackStruct *)
XM_TYPE_PTR_NO_p(XmDropProcCallbackStruct, XmDropProcCallbackStruct *)
XM_TYPE_PTR_NO_p(XmDropSiteEnterCallbackStruct, XmDropSiteEnterCallbackStruct *)
XM_TYPE_PTR_NO_p(XmDropSiteLeaveCallbackStruct, XmDropSiteLeaveCallbackStruct *)
XM_TYPE_PTR_NO_p(XmDropStartCallbackStruct, XmDropStartCallbackStruct *)
XM_TYPE_PTR_NO_p(XmFileSelectionBoxCallbackStruct, XmFileSelectionBoxCallbackStruct *)
XM_TYPE_PTR_NO_p(XmListCallbackStruct, XmListCallbackStruct *)
XM_TYPE(XmTab, XmTab) /* opaque */
XM_TYPE_PTR_NO_p(XmDragStartCallbackStruct, XmDragStartCallbackStruct *)
XM_TYPE_PTR_NO_p(XmDisplayCallbackStruct, XmDisplayCallbackStruct *)
XM_TYPE_PTR_NO_p(XmDestinationCallbackStruct, XmDestinationCallbackStruct *)
XM_TYPE_PTR_NO_p(XmConvertCallbackStruct, XmConvertCallbackStruct *)
XM_TYPE_PTR_NO_p(XmComboBoxCallbackStruct, XmComboBoxCallbackStruct *)
XM_TYPE_PTR_NO_p(XmContainerOutlineCallbackStruct, XmContainerOutlineCallbackStruct *)
XM_TYPE_PTR_NO_p(XmContainerSelectCallbackStruct, XmContainerSelectCallbackStruct *)
XM_TYPE_PTR_NO_p(XmNotebookCallbackStruct, XmNotebookCallbackStruct *)
XM_TYPE_PTR_NO_p(XmNotebookPageInfo, XmNotebookPageInfo *)
XM_TYPE_PTR(XmRenderTable, XmRenderTable)
XM_TYPE_PTR(XmRendition, XmRendition)
XM_TYPE_PTR_NO_p(XmSpinBoxCallbackStruct, XmSpinBoxCallbackStruct *)
XM_TYPE_PTR_NO_p(XmTraverseObscuredCallbackStruct, XmTraverseObscuredCallbackStruct *)
XM_TYPE_PTR_NO_p(XmTopLevelLeaveCallbackStruct, XmTopLevelLeaveCallbackStruct *)
XM_TYPE_PTR_NO_p(XmTopLevelEnterCallbackStruct, XmTopLevelEnterCallbackStruct *)
#if HAVE_XM_XP
XM_TYPE_PTR_NO_p(XmPrintShellCallbackStruct, XmPrintShellCallbackStruct *)
#endif
XM_TYPE_PTR_NO_p(XmPopupHandlerCallbackStruct, XmPopupHandlerCallbackStruct *)
XM_TYPE_PTR_NO_p(XmSelectionCallbackStruct, XmSelectionCallbackStruct *)
XM_TYPE_PTR_NO_C2X_NO_p(XmTransferDoneCallbackStruct, XmTransferDoneCallbackStruct *)
XM_TYPE_PTR(XmTabList, XmTabList) /* opaque */
XM_TYPE(XmParseMapping, XmParseMapping)
XM_TYPE_PTR_NO_p(XmOperationChangedCallbackStruct, XmOperationChangedCallbackStruct *)
XM_TYPE_PTR_NO_p(XmPushButtonCallbackStruct, XmPushButtonCallbackStruct *)
XM_TYPE_PTR_NO_p(XmRowColumnCallbackStruct, XmRowColumnCallbackStruct *)
XM_TYPE_PTR_NO_p(XmScaleCallbackStruct, XmScaleCallbackStruct *)
XM_TYPE_PTR_NO_p(XmScrollBarCallbackStruct, XmScrollBarCallbackStruct *)
XM_TYPE_PTR_NO_p(XmSelectionBoxCallbackStruct, XmSelectionBoxCallbackStruct *)
XM_TYPE_PTR_NO_p(XmTextVerifyCallbackStruct, XmTextVerifyCallbackStruct *)
XM_TYPE_PTR_NO_C2X_NO_p(XmTextBlock, XmTextBlock)
XM_TYPE_PTR_NO_p(XmToggleButtonCallbackStruct, XmToggleButtonCallbackStruct *)
#if HAVE_XmCreateDataField
XM_TYPE_PTR_NO_p(XmDataFieldCallbackStruct, XmDataFieldCallbackStruct *)
#endif
#if HAVE_XmCreateTabStack
XM_TYPE_PTR_NO_p(XmTabStackCallbackStruct, XmTabStackCallbackStruct *)
#endif
#if (!XM_DISABLE_DEPRECATED)
  XM_TYPE(XmFontContext, XmFontContext) /* opaque */
  XM_TYPE(XmFontList, XmFontList) /* opaque, obsolete == XmRenderTable in motif 2 */
  XM_TYPE(XmFontListEntry, XmFontListEntry) /* opaque */
#else
  #define XEN_TO_C_XmFontList(Arg) XEN_TO_C_XmRenderTable(Arg)
#endif
XM_TYPE(XmTextSource, XmTextSource)
XM_TYPE(XmStringContext, XmStringContext)

static int XEN_XmFontList_or_XmRenderTable_P(XEN arg)
{
#if (!XM_DISABLE_DEPRECATED)
  return(XEN_XmFontList_P(arg) || XEN_XmRenderTable_P(arg));
#else
  return(XEN_XmRenderTable_P(arg));
#endif
}
#endif

static XEN type_to_event_symbol(int utype)
{
  char *type;
  type = "XErrorEvent"; /* -1 for an error event? */
  switch (utype)
    {
    case 0:                type = "XAnyEvent";              break;
    case KeyPress:
    case KeyRelease:       type = "XKeyEvent";              break;
    case ButtonPress:
    case ButtonRelease:    type = "XButtonEvent";           break;
    case MotionNotify:     type = "XMotionEvent";           break;
    case EnterNotify:
    case LeaveNotify:      type = "XCrossingEvent";         break;
    case FocusIn:
    case FocusOut:         type = "XFocusChangeEvent";      break;
    case KeymapNotify:     type = "XKeymapEvent";           break;
    case Expose:           type = "XExposeEvent";           break;
    case GraphicsExpose:   type = "XGraphicsExposeEvent";   break;
    case NoExpose:         type = "XNoExposeEvent";         break;
    case VisibilityNotify: type = "XVisibilityEvent";       break;
    case CreateNotify:     type = "XCreateWindowEvent";     break;
    case DestroyNotify:    type = "XDestroyWindowEvent";    break;
    case UnmapNotify:      type = "XUnmapEvent";            break;
    case MapNotify:        type = "XMapEvent";              break;
    case MapRequest:       type = "XMapRequestEvent";       break;
    case ReparentNotify:   type = "XReparentEvent";         break;
    case ConfigureNotify:  type = "XConfigureEvent";        break;
    case ConfigureRequest: type = "XConfigureRequestEvent"; break;
    case GravityNotify:    type = "XGravityEvent";          break;
    case ResizeRequest:    type = "XResizeRequestEvent";    break;
    case CirculateNotify:  type = "XCirculateEvent";        break;
    case CirculateRequest: type = "XCirculateRequestEvent"; break;
    case PropertyNotify:   type = "XPropertyEvent";         break;
    case SelectionClear:   type = "XSelectionClearEvent";   break;
    case SelectionRequest: type = "XSelectionRequestEvent"; break;
    case SelectionNotify:  type = "XSelectionEvent";        break;
    case ColormapNotify:   type = "XColormapEvent";         break;
    case ClientMessage:    type = "XClientMessageEvent";    break;
    case MappingNotify:    type = "XMappingEvent";          break;
    }
  return(C_STRING_TO_XEN_SYMBOL(type));
}

static XEN C_TO_XEN_XEvent_1(XEvent *e, int need_free)
{
  if (e == NULL) return(XEN_FALSE); /* synthetic callback may have no event */
  if (need_free)
    return(XEN_LIST_4(type_to_event_symbol(e->type),
		      C_TO_XEN_ULONG((unsigned long)e),
		      make_xm_obj(e),
		      C_STRING_TO_XEN_SYMBOL("XEvent")));
  return(XEN_LIST_4(type_to_event_symbol(e->type),
		    C_TO_XEN_ULONG((unsigned long)e),
		    XEN_FALSE,
		    C_STRING_TO_XEN_SYMBOL("XEvent")));
}


#define C_TO_XEN_XEvent(e)     C_TO_XEN_XEvent_1(e, false)
#define C_TO_XEN_XEvent_OBJ(e) C_TO_XEN_XEvent_1(e, true)
#define XEN_TO_C_XEvent(Arg)   (XEvent *)XEN_TO_C_ULONG(XEN_CADR(Arg))
#define XEN_XEvent_P(Value)    (XEN_LIST_P(Value) &&\
                               (XEN_LIST_LENGTH(Value) == 4) &&\
                               (XEN_SYMBOL_P(XEN_CADDDR(Value))) &&\
                               (strcmp("XEvent", XEN_SYMBOL_TO_C_STRING(XEN_CADDDR(Value))) == 0))

static XEN XEN_XEvent_p(XEN val) 
{
  return(C_TO_XEN_BOOLEAN(XEN_XEvent_P(val)));
}

static XEN gxm_XEvent(XEN type)
{
  XEvent *e;
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(type), type, XEN_ONLY_ARG, "XEvent", "an X event type (integer)");
  e = (XEvent *)CALLOC(1, sizeof(XEvent));
  if (XEN_INTEGER_P(type))
    e->type = XEN_TO_C_INT(type);
  return(XEN_LIST_4(type_to_event_symbol(e->type),
		    C_TO_XEN_ULONG((unsigned long)e),
		    make_xm_obj(e),
		    C_STRING_TO_XEN_SYMBOL("XEvent")));
}

static XEN gxm_XGCValues(void) 
{
  XGCValues *e;
  e = (XGCValues *)CALLOC(1, sizeof(XGCValues));
  return(WRAP_FOR_XEN_OBJ("XGCValues", e));
}

#if HAVE_MOTIF

#ifdef XEN_ARGIFY_1
  #define XM_Make(Name) \
    static XEN gxm_ ## Name (void) {Name *e; e = (Name *)CALLOC(1, sizeof(Name)); return(WRAP_FOR_XEN_OBJ(#Name, e));} \
    XEN_NARGIFY_0(gxm_ ## Name ## _w, gxm_ ## Name)
  #define XM_Declare(Name) \
    XEN_DEFINE_PROCEDURE(XM_PREFIX #Name XM_POSTFIX, gxm_ ## Name ## _w, 0, 0, 0, "Make an " #Name " struct")
#else
  #define XM_Make(Name) \
    static XEN gxm_ ## Name (void) {Name *e; e = (Name *)CALLOC(1, sizeof(Name)); return(WRAP_FOR_XEN_OBJ(#Name, e));}
  #define XM_Declare(Name) \
    XEN_DEFINE_PROCEDURE(XM_PREFIX #Name XM_POSTFIX, gxm_ ## Name, 0, 0, 0, "Make an " #Name " struct")
#endif

XM_Make(XmAnyCallbackStruct)
XM_Make(XmArrowButtonCallbackStruct)
XM_Make(XmCommandCallbackStruct)
XM_Make(XmDragDropFinishCallbackStruct)
XM_Make(XmDragMotionCallbackStruct)
XM_Make(XmDragProcCallbackStruct)
XM_Make(XmDrawingAreaCallbackStruct)
XM_Make(XmDrawnButtonCallbackStruct)
XM_Make(XmDropFinishCallbackStruct)
XM_Make(XmDropProcCallbackStruct)
XM_Make(XmDropSiteEnterCallbackStruct)
XM_Make(XmDropSiteLeaveCallbackStruct)
XM_Make(XmDropStartCallbackStruct)
XM_Make(XmFileSelectionBoxCallbackStruct)
XM_Make(XmListCallbackStruct)
XM_Make(XmOperationChangedCallbackStruct)
XM_Make(XmPushButtonCallbackStruct)
XM_Make(XmRowColumnCallbackStruct)
XM_Make(XmScaleCallbackStruct)
XM_Make(XmScrollBarCallbackStruct)
XM_Make(XmSelectionBoxCallbackStruct)
XM_Make(XmTextVerifyCallbackStruct)
XM_Make(XmToggleButtonCallbackStruct)
XM_Make(XmDestinationCallbackStruct)
XM_Make(XmConvertCallbackStruct)
XM_Make(XmComboBoxCallbackStruct)
XM_Make(XmContainerOutlineCallbackStruct)
XM_Make(XmContainerSelectCallbackStruct)
XM_Make(XmNotebookCallbackStruct)
XM_Make(XmSpinBoxCallbackStruct)
XM_Make(XmTraverseObscuredCallbackStruct)
XM_Make(XmTopLevelLeaveCallbackStruct)
XM_Make(XmTopLevelEnterCallbackStruct)
XM_Make(XmPopupHandlerCallbackStruct)
XM_Make(XmSelectionCallbackStruct)
XM_Make(XmTransferDoneCallbackStruct)
XM_Make(XmDisplayCallbackStruct)
XM_Make(XmDragStartCallbackStruct)
#if HAVE_XmCreateDataField
XM_Make(XmDataFieldCallbackStruct)
#endif
#if HAVE_XmCreateTabStack
XM_Make(XmTabStackCallbackStruct)
#endif

static XEN gxm_XmTextBlock(void) 
{
  XmTextBlockRec *e; 
  e = (XmTextBlockRec *)CALLOC(1, sizeof(XmTextBlockRec)); 
  return(WRAP_FOR_XEN_OBJ("XmTextBlock", e));
}

#ifdef XEN_ARGIFY_1
  XEN_NARGIFY_0(gxm_XmTextBlock_w, gxm_XmTextBlock)
#else
  #define gxm_XmTextBlock_w gxm_XmTextBlock
#endif
  
static void define_makes(void)
{
  XM_Declare(XmAnyCallbackStruct);
  XM_Declare(XmArrowButtonCallbackStruct);
  XM_Declare(XmCommandCallbackStruct);
  XM_Declare(XmDragDropFinishCallbackStruct);
  XM_Declare(XmDragMotionCallbackStruct);
  XM_Declare(XmDragProcCallbackStruct);
  XM_Declare(XmDrawingAreaCallbackStruct);
  XM_Declare(XmDrawnButtonCallbackStruct);
  XM_Declare(XmDropFinishCallbackStruct);
  XM_Declare(XmDropProcCallbackStruct);
  XM_Declare(XmDropSiteEnterCallbackStruct);
  XM_Declare(XmDropSiteLeaveCallbackStruct);
  XM_Declare(XmDropStartCallbackStruct);
  XM_Declare(XmFileSelectionBoxCallbackStruct);
  XM_Declare(XmListCallbackStruct);
  XM_Declare(XmOperationChangedCallbackStruct);
  XM_Declare(XmPushButtonCallbackStruct);
  XM_Declare(XmRowColumnCallbackStruct);
  XM_Declare(XmScaleCallbackStruct);
  XM_Declare(XmScrollBarCallbackStruct);
  XM_Declare(XmSelectionBoxCallbackStruct);
  XM_Declare(XmTextVerifyCallbackStruct);
  XM_Declare(XmToggleButtonCallbackStruct);
  XEN_DEFINE_PROCEDURE(XM_PREFIX "XmTextBlock" XM_POSTFIX, gxm_XmTextBlock_w, 0, 0, 0, "Make an XmTextBlock struct");
  XM_Declare(XmDestinationCallbackStruct);
  XM_Declare(XmConvertCallbackStruct);
  XM_Declare(XmComboBoxCallbackStruct);
  XM_Declare(XmContainerOutlineCallbackStruct);
  XM_Declare(XmContainerSelectCallbackStruct);
  XM_Declare(XmNotebookCallbackStruct);
  XM_Declare(XmSpinBoxCallbackStruct);
  XM_Declare(XmTraverseObscuredCallbackStruct);
  XM_Declare(XmTopLevelLeaveCallbackStruct);
  XM_Declare(XmTopLevelEnterCallbackStruct);
  XM_Declare(XmPopupHandlerCallbackStruct);
  XM_Declare(XmSelectionCallbackStruct);
  XM_Declare(XmTransferDoneCallbackStruct);
  XM_Declare(XmDisplayCallbackStruct);
  XM_Declare(XmDragStartCallbackStruct);
#if HAVE_XmCreateDataField
  XM_Declare(XmDataFieldCallbackStruct);
#endif
#if HAVE_XmCreateTabStack
  XM_Declare(XmTabStackCallbackStruct);
#endif
}

static int its_a_callbackstruct(char *name)
{
  if (name)
    {
      int len;
      len = strlen(name);
      if (len > 16)
	{
	  char *end_name;
	  end_name = (char *)(name + len - 14);
	  return(strcmp(end_name, "CallbackStruct") == 0);
	}
    }
  return(0);
}

#define XEN_AnyCallbackStruct_P(Value) (XEN_LIST_P(Value) && \
                                       (XEN_LIST_LENGTH(Value) >= 2) && \
                                       (XEN_SYMBOL_P(XEN_CAR(Value))) && \
                                       (its_a_callbackstruct(XEN_SYMBOL_TO_C_STRING(XEN_CAR(Value)))))
#endif

static int xm_protect(XEN obj);
static void xm_unprotect_at(int ind);

#if HAVE_MOTIF

/* in XtGetValues we need to return tagged-types (etc) for arbitrarily named resources,
 *   and in XtSetValues we need to do type checks, so resources are hashed by
 *   name and type:
 */

typedef enum {XM_INT, XM_ULONG, XM_UCHAR, XM_FLOAT, XM_STRING, XM_XMSTRING, XM_STRING_TABLE,
	      XM_INT_TABLE, XM_RENDER_TABLE, XM_TAB_LIST, XM_WIDGET, XM_WIDGET_LIST, 
	      XM_BOOLEAN, XM_CALLBACK, XM_PIXEL, XM_PIXMAP, XM_XFONTSTRUCT, XM_DIMENSION,
	      XM_ATOM, XM_ATOM_LIST, XM_STRING_LIST, XM_CHARSET_TABLE, XM_TEXT_SOURCE,
	      XM_FONTLIST, XM_COLORMAP, XM_KEYSYM, XM_KEYSYM_TABLE, XM_SCREEN, XM_WINDOW,
	      XM_VISUAL, XM_RECTANGLE_LIST, XM_WIDGET_CLASS, XM_STRING_OR_INT,
	      XM_TRANSFER_CALLBACK, XM_CONVERT_CALLBACK, XM_SEARCH_CALLBACK, XM_ORDER_CALLBACK,
	      XM_QUALIFY_CALLBACK, XM_ALLOC_COLOR_CALLBACK, XM_POPUP_CALLBACK, XM_SCREEN_COLOR_CALLBACK,
	      XM_DROP_CALLBACK, XM_TRANSFER_ENTRY_LIST, XM_DRAG_CALLBACK, XM_STRING_OR_XMSTRING, XM_PARSE_CALLBACK,
	      XM_BOOLEAN_OR_INT, XM_POSITION, XM_SHORT, XM_ROW_INFO, XM_CURSOR
} xm_resource_t;

static xm_resource_t resource_type(char *resource);

static XEN C_TO_XEN_Widgets(Widget *array, int len)
{
  XEN lst = XEN_EMPTY_LIST;
  if (array)
    {
      int i, loc;
      loc = xm_protect(lst);
      for (i = len - 1; i >= 0; i--)
	lst = XEN_CONS(C_TO_XEN_Widget(array[i]), lst);
      xm_unprotect_at(loc);
    }
  return(lst);
}

static XEN C_TO_XEN_XmStringTable(XmStringTable array, int len)
{
  XEN lst = XEN_EMPTY_LIST;
  if (array)
    {
      int i, loc;
      loc = xm_protect(lst);
      for (i = len - 1; i >= 0; i--)
	lst = XEN_CONS(C_TO_XEN_XmString(array[i]), lst);
      xm_unprotect_at(loc);
    }
  return(lst);
}

static Widget *XEN_TO_C_Widgets(XEN lst_1, int n)
{
  Widget *ws;
  int i;
  XEN lst;
  lst = XEN_COPY_ARG(lst_1);
  ws = (Widget *)CALLOC(n, sizeof(Widget));
  for (i = 0; (i < n) && (XEN_NOT_NULL_P(lst)); i++, lst = XEN_CDR(lst))
    if (XEN_Widget_P(XEN_CAR(lst)))
      ws[i] = XEN_TO_C_Widget(XEN_CAR(lst));
    else 
      {
	FREE(ws);
	ws = NULL;
	XEN_ASSERT_TYPE(0, XEN_CAR(lst), i, c__FUNCTION__, "a Widget");
	break;
      }
  return(ws);
}

static XmString *XEN_TO_C_XmStrings(XEN v_1, int len)
{
  XmString *str;
  int i;
  XEN v;
  v = XEN_COPY_ARG(v_1);
  str = (XmString *)CALLOC(len, sizeof(XmString));
  for (i = 0; (i < len) && (XEN_NOT_NULL_P(v)); i++, v = XEN_CDR(v))
    if (XEN_XmString_P(XEN_CAR(v)))
      str[i] = (XmString)XEN_TO_C_XmString(XEN_CAR(v));
    else 
      {
	FREE(str);
	str = NULL;
	XEN_ASSERT_TYPE(0, XEN_CAR(v), i, c__FUNCTION__, "an XmString");
	break;
      }
  return(str);
}

static XmDropTransferEntryRec *XEN_TO_C_XmDropTransferEntryRecs(XEN v_1, int len)
{
  XmDropTransferEntryRec *ps;
  int i;
  XEN v;
  v = XEN_COPY_ARG(v_1);
  ps = (XmDropTransferEntryRec *)CALLOC(len, sizeof(XmDropTransferEntryRec));
  for (i = 0; (i < len) && (XEN_NOT_NULL_P(v)); i++, v = XEN_CDR(v))
    {
      if (XEN_Atom_P(XEN_CAR(v)))
	ps[i].target = XEN_TO_C_Atom(XEN_CAR(v));
      else 
	{
	  if (XEN_LIST_P(XEN_CAR(v)))
	    {
	      if (XEN_Atom_P(XEN_CAR(XEN_CAR(v))))
		ps[i].target = XEN_TO_C_Atom(XEN_CAR(XEN_CAR(v)));
	      else XEN_ASSERT_TYPE(0, XEN_CAR(v), i, c__FUNCTION__, "an Atom");
	      ps[i].client_data = (XtPointer)XEN_CADR(XEN_CAR(v));
	    }
	}
    }
  return(ps);
}

static XmStringTable XEN_TO_C_XmStringTable(XEN v_1, int len)
{
  XEN v;
  XmStringTable str;
  int i;
  v = XEN_COPY_ARG(v_1);
  str = (XmStringTable)CALLOC(len + 1, sizeof(XmString));
  for (i = 0; (i < len) && (XEN_NOT_NULL_P(v)); i++, v = XEN_CDR(v))
    if (XEN_XmString_P(XEN_CAR(v)))
      str[i] = XEN_TO_C_XmString(XEN_CAR(v));
    else 
      {
	FREE(str);
	str = NULL;
	XEN_ASSERT_TYPE(0, XEN_CAR(v), i, c__FUNCTION__, "an XmString");
	break;
      }
  return(str);
}

#endif

static XEN C_TO_XEN_Ints(int *array, int len)
{
  XEN lst = XEN_EMPTY_LIST;
  if (array)
    {
      int i, loc;
      loc = xm_protect(lst);
      for (i = len - 1; i >= 0; i--)
	lst = XEN_CONS(C_TO_XEN_INT(array[i]), lst);
      xm_unprotect_at(loc);
    }
  return(lst);
}

#if HAVE_SCHEME
static XEN c_to_xen_ints(XEN array, XEN len)
{
  #define H_to_ints "->ints translates a Motif int array (from a .value reference for example) into a scheme list of ints"
  return(C_TO_XEN_Ints((int *)XEN_TO_C_ULONG(array), XEN_TO_C_INT(len)));
}
#endif

static XEN C_TO_XEN_Atoms(Atom *array, int len)
{
  XEN lst = XEN_EMPTY_LIST;
  if (array)
    {
      int i, loc;
      loc = xm_protect(lst);
      for (i = len - 1; i >= 0; i--)
	lst = XEN_CONS(C_TO_XEN_Atom(array[i]), lst);
      xm_unprotect_at(loc);
    }
  return(lst);
}

#if HAVE_SCHEME
static XEN c_to_xen_atoms(XEN array, XEN len)
{
  #define H_to_Atoms "->Atoms translates a Motif Atoms array (from a .value reference for example) into a scheme list of Atoms"
  return(C_TO_XEN_Atoms((Atom *)XEN_TO_C_ULONG(array), XEN_TO_C_INT(len)));
}
#endif

static XEN C_TO_XEN_Strings(char **array, int len)
{
  XEN lst = XEN_EMPTY_LIST;
  if (array)
    {
      int i, loc;
      loc = xm_protect(lst);
      for (i = len - 1; i >= 0; i--)
	lst = XEN_CONS(C_TO_XEN_STRING(array[i]), lst);
      xm_unprotect_at(loc);
    }
  return(lst);
}

#if HAVE_SCHEME
static XEN c_to_xen_strings(XEN array, XEN len)
{
  #define H_to_strings "->strings translates a Motif string array (from a .value reference for example) into a scheme list of strings"
  return(C_TO_XEN_Strings((char **)XEN_TO_C_ULONG(array), XEN_TO_C_INT(len)));
}

static XEN c_to_xen_string(XEN str)
{
  #define H_to_string "->string translates a Motif string (from a .value reference for example) into a scheme string"
  char *tmp;
  tmp = (char *)XEN_TO_C_ULONG(str);
  if (tmp)
    return(C_TO_XEN_STRING(tmp));
  return(XEN_FALSE);
}
#endif

static XEN copy_xrectangle(XRectangle *old_r)
{
  XRectangle *r;
  r = (XRectangle *)CALLOC(1, sizeof(XRectangle));
  r->x = old_r->x;
  r->y = old_r->y;
  r->width = old_r->width;
  r->height = old_r->height;
  return(C_TO_XEN_XRectangle(r));
}

static XEN C_TO_XEN_XRectangles(XRectangle *array, int len)
{
  XEN lst = XEN_EMPTY_LIST;
  if (array)
    {
      int i, loc;
      loc = xm_protect(lst);
      for (i = len - 1; i >= 0; i--)
	lst = XEN_CONS(copy_xrectangle(&(array[i])), lst);
      xm_unprotect_at(loc);
    }
  return(lst);
}

#if HAVE_SCHEME
static XEN c_to_xen_xrectangles(XEN array, XEN len)
{
  #define H_to_XRectangles "->XRectangles translates a Motif rectangle array (from a .value reference for example) into a scheme list of rectangles"
  return(C_TO_XEN_XRectangles((XRectangle *)XEN_TO_C_ULONG(array), XEN_TO_C_INT(len)));
}
#endif

static XEN C_TO_XEN_KeySyms(KeySym *array, int len)
{
  XEN lst = XEN_EMPTY_LIST;
  if (array)
    {
      int i, loc;
      loc = xm_protect(lst);
      for (i = len - 1; i >= 0; i--)
	lst = XEN_CONS(C_TO_XEN_KeySym(array[i]), lst);
      xm_unprotect_at(loc);
    }
  return(lst);
}

static Window *XEN_TO_C_Windows(XEN lst_1, int n)
{
  Window *ws;
  int i;
  XEN lst;
  if (n == 0) return(NULL);
  lst = XEN_COPY_ARG(lst_1);
  ws = (Window *)CALLOC(n, sizeof(Window));
  for (i = 0; (i < n) && (XEN_NOT_NULL_P(lst)); i++, lst = XEN_CDR(lst))
    if (XEN_Window_P(XEN_CAR(lst)))
      ws[i] = XEN_TO_C_Window(XEN_CAR(lst));
    else 
      {
	FREE(ws);
	ws = NULL;
	XEN_ASSERT_TYPE(0, XEN_CAR(lst), i, c__FUNCTION__, "a Window");
	break;
      }
  return(ws);
}

#if HAVE_MOTIF
static XmRendition *XEN_TO_C_XmRenditions(XEN lst_1, int n)
{
  XEN lst;
  XmRendition *ws;
  int i;
  if (n == 0) return(NULL);
  lst = XEN_COPY_ARG(lst_1);
  ws = (XmRendition *)CALLOC(n, sizeof(XmRendition));
  for (i = 0; (i < n) && (XEN_NOT_NULL_P(lst)); i++, lst = XEN_CDR(lst))
    if (XEN_XmRendition_P(XEN_CAR(lst)))
      ws[i] = XEN_TO_C_XmRendition(XEN_CAR(lst));
    else 
      {
	FREE(ws);
	ws = NULL;
	XEN_ASSERT_TYPE(0, XEN_CAR(lst), i, c__FUNCTION__, "an XmRendition");
	break;
      }
  return(ws);
}

static XmTab *XEN_TO_C_XmTabs(XEN v_1, int len)
{
  XEN v;
  XmTab *str;
  int i;
  if (len == 0) return(NULL);
  v = XEN_COPY_ARG(v_1);
  str = (XmTab *)CALLOC(len, sizeof(XmTab));
  for (i = 0; (i < len) && (XEN_NOT_NULL_P(v)); i++, v = XEN_CDR(v))
    if (XEN_XmTab_P(XEN_CAR(v)))
      str[i] = (XmTab)XEN_TO_C_XmTab(XEN_CAR(v));
    else 
      {
	FREE(str);
	str = NULL;
	XEN_ASSERT_TYPE(0, XEN_CAR(v), i, c__FUNCTION__, "an XmTab");
	break;
      }
  return(str);
}
#endif

static Atom *XEN_TO_C_Atoms(XEN v_1, int len)
{
  XEN v;
  Atom *str;
  int i;
  if (len == 0) return(NULL);
  v = XEN_COPY_ARG(v_1);
  str = (Atom *)CALLOC(len, sizeof(Atom));
  for (i = 0; (i < len) && (XEN_NOT_NULL_P(v)); i++, v = XEN_CDR(v))
    if (XEN_Atom_P(XEN_CAR(v)))
      str[i] = (Atom)XEN_TO_C_Atom(XEN_CAR(v));
    else 
      {
	FREE(str);
	str = NULL;
	XEN_ASSERT_TYPE(0, XEN_CAR(v), i, c__FUNCTION__, "an Atom");
	break;
      }
  return(str);
}

static Pixel *XEN_TO_C_Pixels(XEN v_1, int len)
{
  XEN v;
  Pixel *str;
  int i;
  if (len == 0) return(NULL);
  v = XEN_COPY_ARG(v_1);
  str = (Pixel *)CALLOC(len, sizeof(Pixel));
  for (i = 0; (i < len) && (XEN_NOT_NULL_P(v)); i++, v = XEN_CDR(v))
    if (XEN_Pixel_P(XEN_CAR(v)))
      str[i] = (Pixel)XEN_TO_C_Pixel(XEN_CAR(v));
    else 
      {
	FREE(str);
	str = NULL;
	XEN_ASSERT_TYPE(0, XEN_CAR(v), i, c__FUNCTION__, "a Pixel");
	break;
      }
  return(str);
}

static KeySym *XEN_TO_C_KeySyms(XEN v_1, int len)
{
  XEN v;
  KeySym *str;
  int i;
  if (len == 0) return(NULL);
  v = XEN_COPY_ARG(v_1);
  str = (KeySym *)CALLOC(len, sizeof(KeySym));
  for (i = 0; (i < len) && (XEN_NOT_NULL_P(v)); i++, v = XEN_CDR(v))
    if (XEN_KeySym_P(XEN_CAR(v)))
      str[i] = (KeySym)XEN_TO_C_KeySym(XEN_CAR(v));
    else 
      {
	FREE(str);
	str = NULL;
	XEN_ASSERT_TYPE(0, XEN_CAR(v), i, c__FUNCTION__, "a KeySym");
	break;
      }
  return(str);
}

static char **XEN_TO_C_Strings(XEN v_1, int len)
{
  XEN v;
  char **str;
  int i;
  if (len == 0) return(NULL);
  v = XEN_COPY_ARG(v_1);
  str = (char **)CALLOC(len, sizeof(char *));
  for (i = 0; (i < len) && (XEN_NOT_NULL_P(v)); i++, v = XEN_CDR(v))
    if (XEN_STRING_P(XEN_CAR(v)))
      str[i] = XEN_TO_C_STRING(XEN_CAR(v)); /* should this be protected? */
    else 
      {
	FREE(str);
	str = NULL;
	XEN_ASSERT_TYPE(0, XEN_CAR(v), i, c__FUNCTION__, "a char*");
	break;
      }
  return(str);
}

static int *XEN_TO_C_Ints(XEN v_1, int len)
{
  XEN v;
  int *ps;
  int i;
  if (len == 0) return(NULL);
  v = XEN_COPY_ARG(v_1);
  ps = (int *)CALLOC(len, sizeof(int));
  for (i = 0; (i < len) && (XEN_NOT_NULL_P(v)); i++, v = XEN_CDR(v))
    if (XEN_INTEGER_P(XEN_CAR(v)))
      ps[i] = XEN_TO_C_INT(XEN_CAR(v));
    else 
      {
	FREE(ps);
	ps = NULL;
	XEN_ASSERT_TYPE(0, XEN_CAR(v), i, c__FUNCTION__, "an int");
	break;
      }
  return(ps);
}

static Cardinal *XEN_TO_C_Cardinals(XEN v_1, int len)
{
  XEN v;
  Cardinal *ps;
  int i;
  if (len == 0) return(NULL);
  v = XEN_COPY_ARG(v_1);
  ps = (Cardinal *)CALLOC(len, sizeof(int));
  for (i = 0; (i < len) && (XEN_NOT_NULL_P(v)); i++, v = XEN_CDR(v))
    if (XEN_INTEGER_P(XEN_CAR(v)))
      ps[i] = (Cardinal)XEN_TO_C_INT(XEN_CAR(v));
    else 
      {
	FREE(ps);
	ps = NULL;
	XEN_ASSERT_TYPE(0, XEN_CAR(v), i, c__FUNCTION__, "a Cardinal");
	break;
      }
  return(ps);
}

static XRectangle *XEN_TO_C_XRectangles(XEN v_1, int len)
{
  XEN v;
  XRectangle *str, *dat;
  int i;
  if (len == 0) return(NULL);
  v = XEN_COPY_ARG(v_1);
  str = (XRectangle *)CALLOC(len, sizeof(XRectangle));
  for (i = 0; (i < len) && (XEN_NOT_NULL_P(v)); i++, v = XEN_CDR(v))
    {
      if (XEN_XRectangle_P(XEN_CAR(v)))
	dat = (XRectangle *)XEN_TO_C_XRectangle(XEN_CAR(v));
      else 
	{
	  FREE(str);
	  str = NULL;
	  XEN_ASSERT_TYPE(0, XEN_CAR(v), i, c__FUNCTION__, "an XRectangle");
	  break;
	}
      str[i].x = dat->x;
      str[i].y = dat->y;
      str[i].width = dat->width;
      str[i].height = dat->height;
    }
  return(str);
}


#if HAVE_MOTIF

/* -------- arglists -------- */

static XEN wrap_callback_struct(int type, XtPointer info);
static int map_over_protected_elements(bool (*func)(XEN val, int loc, unsigned long fid), unsigned long id);
static XEN xm_protected_element(int loc);
static int callback_struct_type(Widget w, const char *name);
static void xm_unprotect(XEN obj);

enum {CALLBACK_TYPE, CALLBACK_FUNC, CALLBACK_DATA, CALLBACK_STRUCT_TYPE, CALLBACK_GC_LOC};

#define C_TO_XEN_XM_XtCallback(Code, Context) \
  XEN_LIST_5(C_STRING_TO_XEN_SYMBOL("XtCallback"), Code, Context, XEN_ZERO, XEN_ZERO)

static void gxm_XtCallbackProc(Widget w, XtPointer context, XtPointer info)
{
  XEN descr = (XEN)context;
  XEN_CALL_3(XEN_LIST_REF(descr, CALLBACK_FUNC),    /* descr: (list "XtCallback" func user-data struct-type gc-loc) */
	     C_TO_XEN_Widget(w),
	     XEN_LIST_REF(descr, CALLBACK_DATA),
	     wrap_callback_struct(XEN_TO_C_INT(XEN_LIST_REF(descr, CALLBACK_STRUCT_TYPE)), info),
	     c__FUNCTION__);
}

#define C_TO_XEN_XM_Drop_Callback(Code) \
  XEN_LIST_5(C_STRING_TO_XEN_SYMBOL("Drop_Callback"), Code, XEN_FALSE, XEN_ZERO, XEN_ZERO)
#define XM_Drop_Callback_P(Arg) WRAP_P("Drop_Callback", Arg)

static bool find_dropproc(XEN val, int loc, unsigned long w)
{
  return((XM_Drop_Callback_P(val)) &&
	 (((XEN_FALSE_P((XEN)w)) && 
	   (XEN_FALSE_P(XEN_LIST_REF(val, CALLBACK_DATA)))) ||
	  ((XEN_Widget_P(XEN_LIST_REF(val, CALLBACK_DATA))) &&
	   (XEN_TO_C_ULONG(XEN_CADR(XEN_LIST_REF(val, CALLBACK_DATA))) == w))));
}

static void gxm_Drop_Callback(Widget w, XtPointer context, XtPointer info)
{
  int i;
  XmDropProcCallbackStruct *cb = (XmDropProcCallbackStruct *)info;
  i = map_over_protected_elements(find_dropproc, (unsigned long)w);
  if (i >= 0)
    {
      XEN code;
      code = XEN_LIST_REF(xm_protected_element(i), CALLBACK_FUNC);
      if (XEN_PROCEDURE_P(code))
	XEN_CALL_3(code,
		   C_TO_XEN_Widget(w),
		   XEN_FALSE,
		   C_TO_XEN_XmDropProcCallbackStruct(cb),
		   c__FUNCTION__);
    }
  cb->dropSiteStatus = XmINVALID_DROP_SITE; /* try to exit cleanly from on-going drop */
}

#define C_TO_XEN_XM_Drag_Callback(Code) \
  XEN_LIST_5(C_STRING_TO_XEN_SYMBOL("Drag_Callback"), Code, XEN_FALSE, XEN_ZERO, XEN_ZERO)
#define XM_Drag_Callback_P(Arg) WRAP_P("Drag_Callback", Arg)

static bool find_dragproc(XEN val, int loc, unsigned long w)
{
  return((XM_Drag_Callback_P(val)) &&
	 (((XEN_FALSE_P((XEN)w)) && 
	   (XEN_FALSE_P(XEN_LIST_REF(val, CALLBACK_DATA)))) ||
	  ((XEN_Widget_P(XEN_LIST_REF(val, CALLBACK_DATA))) &&
	   (XEN_TO_C_ULONG(XEN_CADR(XEN_LIST_REF(val, CALLBACK_DATA))) == w))));
}

static void gxm_Drag_Callback(Widget w, XtPointer context, XtPointer info)
{
  int i;
  XmDragProcCallbackStruct *cb = (XmDragProcCallbackStruct *)info;
  i = map_over_protected_elements(find_dragproc, (unsigned long)w);
  if (i >= 0)
    {
      XEN code;
      code = XEN_LIST_REF(xm_protected_element(i), CALLBACK_FUNC);
      if (XEN_PROCEDURE_P(code))
	XEN_CALL_3(code,
		   C_TO_XEN_Widget(w),
		   XEN_FALSE,
		   C_TO_XEN_XmDragProcCallbackStruct(cb),
		   c__FUNCTION__);
    }
}

#define C_TO_XEN_XM_XtPopupChild(Code) \
  XEN_LIST_5(C_STRING_TO_XEN_SYMBOL("XtPopupChild"), Code, XEN_FALSE, XEN_ZERO, XEN_ZERO)
#define XM_XtPopupChild_P(Arg) WRAP_P("XtPopupChild", Arg)

static bool find_popupchild(XEN val, int loc, unsigned long w)
{
  return((XM_XtPopupChild_P(val)) &&
	 (((XEN_FALSE_P((XEN)w)) && 
	   (XEN_FALSE_P(XEN_LIST_REF(val, CALLBACK_DATA)))) ||
	  ((XEN_Widget_P(XEN_LIST_REF(val, CALLBACK_DATA))) &&
	   (XEN_TO_C_ULONG(XEN_CADR(XEN_LIST_REF(val, CALLBACK_DATA))) == w))));
}

static void gxm_XtPopupChild(Widget w)
{
  /* since all we have to go by is the widget, we have to scan the gc table for any associated code */
  int i;
  i = map_over_protected_elements(find_popupchild, (unsigned long)w);
  if (i >= 0)
    {
      XEN code;
      code = XEN_LIST_REF(xm_protected_element(i), CALLBACK_FUNC);
      if (XEN_PROCEDURE_P(code))
	XEN_CALL_1(code,
		   C_TO_XEN_Widget(w),
		   c__FUNCTION__);
    }
}

#define C_TO_XEN_XM_XmSearchProc(Code) \
  XEN_LIST_5(C_STRING_TO_XEN_SYMBOL("XmSearchProc"), Code, XEN_FALSE, XEN_ZERO, XEN_ZERO)
#define XM_XmSearchProc_P(Arg) WRAP_P("XmSearchProc", Arg)

static bool find_searchproc(XEN val, int loc, unsigned long w)
{
  return((XM_XmSearchProc_P(val)) &&
	 (((XEN_FALSE_P((XEN)w)) && 
	   (XEN_FALSE_P(XEN_LIST_REF(val, CALLBACK_DATA)))) ||
	  ((XEN_Widget_P(XEN_LIST_REF(val, CALLBACK_DATA))) &&
	   (XEN_TO_C_ULONG(XEN_CADR(XEN_LIST_REF(val, CALLBACK_DATA))) == w))));
}

static void gxm_XmSearchProc(Widget w, XmFileSelectionBoxCallbackStruct *info)
{
  /* here we again have to go by the widget */
  int i;
  i = map_over_protected_elements(find_searchproc, (unsigned long)w);
  if (i >= 0)
    {
      XEN code;
      code = XEN_LIST_REF(xm_protected_element(i), CALLBACK_FUNC);
      if (XEN_PROCEDURE_P(code))
	XEN_CALL_2(code,
		   C_TO_XEN_Widget(w),
		   C_TO_XEN_XmFileSelectionBoxCallbackStruct(info),
		   c__FUNCTION__);
    }
}

#define C_TO_XEN_XM_XmQualifyProc(Code) \
  XEN_LIST_5(C_STRING_TO_XEN_SYMBOL("XmQualifyProc"), Code, XEN_FALSE, XEN_ZERO, XEN_ZERO)
#define XM_XmQualifyProc_P(Arg) WRAP_P("XmQualifyProc", Arg)

static bool find_qualifyproc(XEN val, int loc, unsigned long w)
{
  return((XM_XmQualifyProc_P(val)) &&
	 (((XEN_FALSE_P((XEN)w)) && 
	   (XEN_FALSE_P(XEN_LIST_REF(val, CALLBACK_DATA)))) ||
	  ((XEN_Widget_P(XEN_LIST_REF(val, CALLBACK_DATA))) &&
	   (XEN_TO_C_ULONG(XEN_CADR(XEN_LIST_REF(val, CALLBACK_DATA))) == w))));
}

static void gxm_XmQualifyProc(Widget w, XtPointer indata, XtPointer outdata)
{
  /* here we again have to go by the widget */
  int i;
  i = map_over_protected_elements(find_qualifyproc, (unsigned long)w);
  if (i >= 0)
    {
      XEN code;
      code = XEN_LIST_REF(xm_protected_element(i), CALLBACK_FUNC);
      if (XEN_PROCEDURE_P(code))
	XEN_CALL_3(code,
		   C_TO_XEN_Widget(w),
		   C_TO_XEN_XmFileSelectionBoxCallbackStruct((XmFileSelectionBoxCallbackStruct *)indata),
		   C_TO_XEN_XmFileSelectionBoxCallbackStruct((XmFileSelectionBoxCallbackStruct *)outdata),
		   c__FUNCTION__);
    }
}

#define C_TO_XEN_XM_XtOrderProc(Code) \
  XEN_LIST_5(C_STRING_TO_XEN_SYMBOL("XtOrderProc"), Code, XEN_FALSE, XEN_ZERO, XEN_ZERO)
#define XM_XtOrderProc_P(Arg) WRAP_P("XtOrderProc", Arg)

static bool find_orderproc(XEN val, int loc, unsigned long w)
{
  return((XM_XtOrderProc_P(val)) &&
	 (((XEN_FALSE_P((XEN)w)) && 
	   (XEN_FALSE_P(XEN_LIST_REF(val, CALLBACK_DATA)))) ||
	  ((XEN_Widget_P(XEN_LIST_REF(val, CALLBACK_DATA))) &&
	   (XEN_TO_C_ULONG(XEN_CADR(XEN_LIST_REF(val, CALLBACK_DATA))) == w))));
}

static Cardinal gxm_XtOrderProc(Widget w)
{
  /* here we again have to go by the widget */
  int i, result = 0;
  i = map_over_protected_elements(find_orderproc, (unsigned long)w);
  if (i >= 0)
    {
      XEN code;
      code = XEN_LIST_REF(xm_protected_element(i), CALLBACK_FUNC);
      if (XEN_PROCEDURE_P(code))
	result = XEN_TO_C_INT(XEN_CALL_1(code,
					 C_TO_XEN_Widget(w),
					 c__FUNCTION__));
    }
  return((Cardinal)result);
}


#define C_TO_XEN_XM_Parse_Callback(Code) \
  XEN_LIST_5(C_STRING_TO_XEN_SYMBOL("Parse_Callback"), Code, XEN_FALSE, XEN_ZERO, XEN_ZERO)
#define XM_Parse_Callback_P(Arg) WRAP_P("Parse_Callback", Arg)

static bool find_parseproc(XEN val, int loc, unsigned long w)
{
  return((XM_Parse_Callback_P(val)) &&
	 (((XEN_FALSE_P((XEN)w)) && 
	   (XEN_FALSE_P(XEN_LIST_REF(val, CALLBACK_DATA)))) ||
	  ((XEN_XmParseMapping_P(XEN_LIST_REF(val, CALLBACK_DATA))) &&
	   (XEN_TO_C_ULONG(XEN_CADR(XEN_LIST_REF(val, CALLBACK_DATA))) == w))));
}

static XmIncludeStatus gxm_Parse_Callback(XtPointer *in_out, XtPointer text_end, XmTextType type, XmStringTag locale_tag,
					  XmParseMapping entry, int pattern_length, XmString *str_include, XtPointer call_data)
{
  int i;
  i = map_over_protected_elements(find_parseproc, (unsigned long)entry);
  if (i >= 0)
    {
      XEN code;
      code = XEN_LIST_REF(xm_protected_element(i), CALLBACK_FUNC);
      if (XEN_PROCEDURE_P(code))
	return(XEN_TO_C_INT(XEN_APPLY(code,
				      XEN_LIST_8(C_TO_XEN_STRING((char *)(*in_out)),
						 C_TO_XEN_ULONG(text_end), /* can't work... */
						 C_TO_XEN_INT(type),
						 C_TO_XEN_STRING(locale_tag),
						 C_TO_XEN_XmParseMapping(entry),
						 C_TO_XEN_INT(pattern_length),
						 C_TO_XEN_XmString((*str_include)), /* can't work... */
						 (XEN)call_data),
				      c__FUNCTION__)));
    }
  return(0);
}

static XEN xm_XmColorAllocationProc = XEN_FALSE;

static void gxm_XmAllocColorProc(Display *dpy, Colormap color, XColor *bs)
{
  /* DIFF: XmAllocColorProc should return new XColor value
   */
  XEN val;
  val = XEN_CALL_3(xm_XmColorAllocationProc,
		   C_TO_XEN_Display(dpy),
		   C_TO_XEN_Colormap(color),
		   C_TO_XEN_XColor(bs),
		   c__FUNCTION__);
  bs = XEN_TO_C_XColor(val);
}

static XEN xm_XmColorCalculationProc = XEN_FALSE;

static void gxm_XmColorCalculationProc(Screen *scr, XColor *bg, XColor *fg, XColor *sel, XColor *ts, XColor *bs)
{
  /* DIFF: XmColorCalculationProc takes 2 args, returns list of 4 colors
   */
  XEN lst;
  int loc;
  lst = XEN_CALL_2(xm_XmColorCalculationProc,
		   C_TO_XEN_Screen(scr),
		   C_TO_XEN_XColor(bg),
		   c__FUNCTION__);
  loc = xm_protect(lst);
  if (XEN_LIST_P(lst))
    {
      fg = XEN_TO_C_XColor(XEN_LIST_REF(lst, 0)); 
      sel = XEN_TO_C_XColor(XEN_LIST_REF(lst, 1));
      ts = XEN_TO_C_XColor(XEN_LIST_REF(lst, 2));
      bs = XEN_TO_C_XColor(XEN_LIST_REF(lst, 3));
   }
  xm_unprotect_at(loc);
}

static XEN xm_XmColorProc = XEN_FALSE; /* XmColorProc is not the same as XmScreen color calculation proc */

static void gxm_XmColorProc(XColor *bg, XColor *fg, XColor *sel, XColor *ts, XColor *bs)
{
  XEN lst;
  int loc;
  lst = XEN_CALL_1(xm_XmColorProc,
		   C_TO_XEN_XColor(bg),
		   c__FUNCTION__);
  loc = xm_protect(lst);
  if (XEN_LIST_P(lst))
    {
      fg = XEN_TO_C_XColor(XEN_LIST_REF(lst, 0)); 
      sel = XEN_TO_C_XColor(XEN_LIST_REF(lst, 1));
      ts = XEN_TO_C_XColor(XEN_LIST_REF(lst, 2));
      bs = XEN_TO_C_XColor(XEN_LIST_REF(lst, 3));
   }
  xm_unprotect_at(loc);
}

static XtCallbackList XEN_TO_C_XtCallbackList(XEN call_list1)
{
  XEN call_list;
  int call_i, call_len;
  XtCallbackRec *cl = NULL;
  call_list = XEN_COPY_ARG(call_list1);
  call_len = XEN_LIST_LENGTH(call_list) / 2;
  if (call_len == 0) return(NULL);
  cl = (XtCallbackRec *)CALLOC(call_len + 1, sizeof(XtCallbackRec));
  for (call_i = 0; call_i < call_len; call_i++, call_list = XEN_CDDR(call_list))
    {
      XEN func, data;
      func = XEN_CAR(call_list);
      if (XEN_LIST_LENGTH(call_list) == 2)
	data = XEN_CADR(call_list);
      else data = XEN_FALSE;
      if ((XEN_PROCEDURE_P(func)) && (XEN_REQUIRED_ARGS_OK(func, 3)))
	{
	  XEN descr;
	  cl[call_i].callback = gxm_XtCallbackProc;
	  descr = C_TO_XEN_XM_XtCallback(XEN_CAR(call_list), data);
	  cl[call_i].closure = (XtPointer)descr;
	  XEN_LIST_SET(descr, CALLBACK_GC_LOC, C_TO_XEN_INT(xm_protect(descr)));
	}
    }
  return(cl);
}

static XEN C_TO_XEN_STRING_WITH_TERMINATION(char *str, unsigned long len)
{
  if ((len == 0) || (str == NULL)) return(XEN_FALSE);
  str[len] = '\0';
  return(C_TO_XEN_STRING(str));
}

static XEN xm_XtSelectionCallback_Descr = XEN_FALSE;
static void gxm_XtSelectionCallbackProc(Widget w, XtPointer x, Atom *a1, Atom *a2, XtPointer x1, unsigned long *l, int *i)
{
  XEN_APPLY(XEN_CAR(xm_XtSelectionCallback_Descr),
	    XEN_LIST_7(C_TO_XEN_Widget(w),
		       XEN_CADR(xm_XtSelectionCallback_Descr),
		       C_TO_XEN_Atom(*a1),
		       C_TO_XEN_Atom(*a2),
		       C_TO_XEN_STRING_WITH_TERMINATION((char *)x1, *l), /* should we handle Atom -> Lisp type conversions? */
		       C_TO_XEN_ULONG(*l),
		       C_TO_XEN_INT(*i)),
	    c__FUNCTION__);
}

static XEN xm_XtConvertSelectionIncr_Descr = XEN_FALSE;
static Boolean gxm_XtConvertSelectionIncrProc(Widget w, Atom *selection, Atom *target, 
					   Atom *type_return, XtPointer *value_return, 
					   unsigned long *length_return, int *format_return, 
					   unsigned long *max_length, XtPointer client_data, 
					   XtRequestId *request_id)
{
  /* DIFF: user callback here takes 6 args (w selection target max_length client_data request_id)
   *       should return (list ...) if ok, #f if not
   *       the list should be (type value length format)
   */
  XEN result;
  result = XEN_APPLY(xm_XtConvertSelectionIncr_Descr,
		     XEN_LIST_6(C_TO_XEN_Widget(w),
				C_TO_XEN_Atom(*selection),
				C_TO_XEN_Atom(*target),
				C_TO_XEN_INT(*max_length),
				C_TO_XEN_ULONG(client_data),
				C_TO_XEN_ULONG(*request_id)), /* XtRequestId is XtPointer */
		     c__FUNCTION__);
  if (XEN_FALSE_P(result))
    return(0);
  (*type_return) = XEN_TO_C_Atom(XEN_LIST_REF(result, 0));
  (*value_return) = (XtPointer)XEN_TO_C_ULONG(XEN_LIST_REF(result, 1));
  (*length_return) = (unsigned long)XEN_TO_C_INT(XEN_LIST_REF(result, 2));
  (*format_return) = XEN_TO_C_INT(XEN_LIST_REF(result, 3));
  return(1);
}

static Arg *protect_args(Arg *args, int len)
{
  /* probably too clever... trying to put off the copy until after all error checking to reduce memory leakage */
  int i;
  for (i = 0; i < len; i++)
    if (args[i].name)
      args[i].name = strdup(args[i].name); /* XEN_TO_C_STRING will eventually gc, so protect against that until we're done with args */
  return(args);
}

static Arg *free_args(Arg *args, int len)
{
  int i;
  for (i = 0; i < len; i++)
    if (args[i].name)
      free(args[i].name); /* free what we strdup'd above */
  FREE(args);
  return(NULL);
}

static Arg *XEN_TO_C_Args(XEN inargl)
{
  /* an Arg array in xm is a list of name value pairs */
  Arg *args = NULL;
  int i, len, gcloc;
  XEN descr, inarg;
  /* if XtVaNestedList supported, scan for it here, and increase length as needed,
   *   then make recursive call to XEN_TO_C_Args in that branch, unloading afterwards
   *   this is not actually needed in xm -- just use append!
   */
  inarg = XEN_COPY_ARG(inargl);
  len = XEN_LIST_LENGTH(inarg) / 2;
  if (len == 0) return(NULL);
  gcloc = xm_protect(inarg);
  args = (Arg *)CALLOC(len, sizeof(Arg));
  for (i = 0; i < len; i++, inarg = XEN_CDDR(inarg))
    {
      XtCallbackRec *cl = NULL;
      xm_resource_t type;
      XEN xname, value;
      char *name;
      xname = XEN_CAR(inarg);
      XEN_ASSERT_TYPE(XEN_STRING_P(xname), xname, 0, c__FUNCTION__, "string");
      name = XEN_TO_C_STRING(xname);
      type = resource_type(name);
      value = XEN_CADR(inarg);
      switch (type)
	{
	  /* here the XtSetArg call wants an XtCallbackList, the incoming XEN type is a list of callback data pairs
	   *   the new callback rec.callback = gxm_XtCallback (etc -- chosen by resource type)
	   *   the rec.closure will be the wrapped func/data info
	   *   we don't have all the data we need for the actual wrapped list here since we need the widget to choose the callback struct type
	   *   so fixup_args should always follow if there's a possible callback list in the resource settings 
	   * also, which callback is invoked may depend on callback type 
	   */
	case XM_CALLBACK:
	  cl = XEN_TO_C_XtCallbackList(value);
	  if (cl) XtSetArg(args[i], name, cl);
	  break;
	case XM_PARSE_CALLBACK:
	  if ((XEN_PROCEDURE_P(value)) && (XEN_REQUIRED_ARGS_OK(value, 8)))
	    {
	      XtSetArg(args[i], name, (unsigned long)gxm_Parse_Callback);
	      descr = C_TO_XEN_XM_Parse_Callback(value);
	      XEN_LIST_SET(descr, CALLBACK_GC_LOC, C_TO_XEN_INT(xm_protect(descr)));
	    }
	  else 
	    {
	      if (XEN_FALSE_P(value))
		XtSetArg(args[i], name, 0);
	      else XEN_ASSERT_TYPE(0, value, 0, name, "procedure of 8 args");
	    }
	  break;
	case XM_DROP_CALLBACK:
	  if ((XEN_PROCEDURE_P(value)) && (XEN_REQUIRED_ARGS_OK(value, 3)))
	    {
	      XtSetArg(args[i], name, (unsigned long)gxm_Drop_Callback);
	      descr = C_TO_XEN_XM_Drop_Callback(value);
	      XEN_LIST_SET(descr, CALLBACK_GC_LOC, C_TO_XEN_INT(xm_protect(descr)));
	    }
	  else 
	    {
	      if (XEN_FALSE_P(value))
		XtSetArg(args[i], name, 0);
	      else XEN_ASSERT_TYPE(0, value, 0, name, "procedure of 3 args");
	    }
	  break;
	case XM_DRAG_CALLBACK:
	  if ((XEN_PROCEDURE_P(value)) && (XEN_REQUIRED_ARGS_OK(value, 3)))
	    {
	      XtSetArg(args[i], name, (unsigned long)gxm_Drag_Callback);
	      descr = C_TO_XEN_XM_Drag_Callback(value);
	      XEN_LIST_SET(descr, CALLBACK_GC_LOC, C_TO_XEN_INT(xm_protect(descr)));
	    }
	  else 
	    {
	      if (XEN_FALSE_P(value))
		XtSetArg(args[i], name, 0);
	      else XEN_ASSERT_TYPE(0, value, 0, name, "procedure of 3 args");
	    }
	  break;
	case XM_SEARCH_CALLBACK:    /* XmNfileSearchProc and XmNdirSearchProc, XmSearchProc XmFileSelectionBox 756 */
	  if ((XEN_PROCEDURE_P(value)) && (XEN_REQUIRED_ARGS_OK(value, 2)))
	    {
	      XtSetArg(args[i], name, (unsigned long)gxm_XmSearchProc);
	      descr = C_TO_XEN_XM_XmSearchProc(value);
	      XEN_LIST_SET(descr, CALLBACK_GC_LOC, C_TO_XEN_INT(xm_protect(descr)));
	    }
	  else 
	    {
	      if (XEN_FALSE_P(value))
		XtSetArg(args[i], name, 0);
	      else XEN_ASSERT_TYPE(0, value, 0, name, "procedure of 2 args");
	    }
	  break;
	case XM_QUALIFY_CALLBACK:   /* XmNqualifySearchDataProc, XmQualifyProc */
	  if ((XEN_PROCEDURE_P(value)) && (XEN_REQUIRED_ARGS_OK(value, 3)))
	    {
	      XtSetArg(args[i], name, (unsigned long)gxm_XmQualifyProc);
	      descr = C_TO_XEN_XM_XmQualifyProc(value);
	      XEN_LIST_SET(descr, CALLBACK_GC_LOC, C_TO_XEN_INT(xm_protect(descr)));
	    }
	  else 
	    {
	      if (XEN_FALSE_P(value))
		XtSetArg(args[i], name, 0);
	      else XEN_ASSERT_TYPE(0, value, 0, name, "procedure of 3 args");
	    }
	  break;
	case XM_ORDER_CALLBACK:
	  if ((XEN_PROCEDURE_P(value)) && (XEN_REQUIRED_ARGS_OK(value, 1)))
	    {
	      XtSetArg(args[i], name, (unsigned long)gxm_XtOrderProc);
	      descr = C_TO_XEN_XM_XtOrderProc(value);
	      XEN_LIST_SET(descr, CALLBACK_GC_LOC, C_TO_XEN_INT(xm_protect(descr)));
	    }
	  else 
	    {
	      if (XEN_FALSE_P(value))
		XtSetArg(args[i], name, 0);
	      else XEN_ASSERT_TYPE(0, value, 0, name, "procedure of 1 arg");
	    }
	  break;
	case XM_TRANSFER_CALLBACK:  /* XmNtransferProc, XtSelectionCallbackProc, XmDropTransfer */
	  /* for now I'll assume no collisions here */
	  xm_XtSelectionCallback_Descr = XEN_LIST_2(value, XEN_FALSE);
	  xm_protect(xm_XtSelectionCallback_Descr);
	  XtSetArg(args[i], name, (unsigned long)gxm_XtSelectionCallbackProc);
	  break;
	case XM_CONVERT_CALLBACK:   /* XmNconvertProc, XtConvertSelectionIncrProc, XmDragContext */
	  xm_XtConvertSelectionIncr_Descr = value;
	  xm_protect(xm_XtConvertSelectionIncr_Descr);
	  XtSetArg(args[i], name, (unsigned long)gxm_XtConvertSelectionIncrProc);
	  break;
	case XM_ALLOC_COLOR_CALLBACK:     /* XmNcolorAllocationProc, XmAllocColorProc XmScreen 921 */
	  if ((XEN_PROCEDURE_P(value)) && (XEN_REQUIRED_ARGS_OK(value, 3)))
	    {
	      XtSetArg(args[i], name, (unsigned long)gxm_XmAllocColorProc);
	      if (XEN_PROCEDURE_P(xm_XmColorAllocationProc)) xm_unprotect(xm_XmColorAllocationProc);
	      xm_protect(value);
	      xm_XmColorAllocationProc = value;
	    }
	  else 
	    {
	      if (XEN_FALSE_P(value))
		XtSetArg(args[i], name, 0);
	      else XEN_ASSERT_TYPE(0, value, 0, name, "procedure of 3 args");
	    }
	  break;
	case XM_SCREEN_COLOR_CALLBACK:     /* XmNcolorCalculationProc, XmScreen 921 */
	  if ((XEN_PROCEDURE_P(value)) && (XEN_REQUIRED_ARGS_OK(value, 2)))
	    {
	      XtSetArg(args[i], name, (unsigned long)gxm_XmColorCalculationProc);
	      if (XEN_PROCEDURE_P(xm_XmColorCalculationProc)) xm_unprotect(xm_XmColorCalculationProc);
	      xm_protect(value);
	      xm_XmColorCalculationProc = value;
	    }
	  else 
	    {
	      if (XEN_FALSE_P(value))
		XtSetArg(args[i], name, 0);
	      else XEN_ASSERT_TYPE(0, value, 0, name, "procedure of 2 args");
	    }
	  break;
	case XM_POPUP_CALLBACK:     /* XmNcreatePopupChildProc, XtCreatePopupChildProc */
	  if ((XEN_PROCEDURE_P(value)) && (XEN_REQUIRED_ARGS_OK(value, 1)))
	    {
	      XtSetArg(args[i], name, (unsigned long)gxm_XtPopupChild);
	      descr = C_TO_XEN_XM_XtPopupChild(value);
	      XEN_LIST_SET(descr, CALLBACK_GC_LOC, C_TO_XEN_INT(xm_protect(descr)));
	    }
	  else 
	    {
	      if (XEN_FALSE_P(value))
		XtSetArg(args[i], name, 0);
	      else XEN_ASSERT_TYPE(0, value, 0, name, "procedure of 1 arg");
	    }
	  break;

	  /* the rest are just doing type checks before the conversion to C */

	case XM_INT:
	  XEN_ASSERT_TYPE(XEN_INTEGER_P(value), value, XEN_ONLY_ARG, name, "an integer");
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_INT(value)));
	  break;
	case XM_FLOAT:
	  XEN_ASSERT_TYPE(XEN_DOUBLE_P(value), value, XEN_ONLY_ARG, name, "a float");
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_DOUBLE(value)));
	  break;
	case XM_STRING:	      
	  XEN_ASSERT_TYPE(XEN_STRING_P(value), value, XEN_ONLY_ARG, name, "a string");      
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_STRING(value)));
	  break;
	case XM_STRING_OR_INT:
	  XEN_ASSERT_TYPE(XEN_STRING_P(value) || XEN_INTEGER_P(value), value, XEN_ONLY_ARG, name, "an integer or a string");      
	  if (XEN_STRING_P(value))
	    XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_STRING(value)));
	  else XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_INT(value)));
	  break;
	case XM_XMSTRING:
	  XEN_ASSERT_TYPE(XEN_XmString_P(value), value, XEN_ONLY_ARG, name, "an XmString");      	      
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_XmString(value)));
	  break;
	case XM_STRING_OR_XMSTRING:
	  XEN_ASSERT_TYPE(XEN_XmString_P(value) || XEN_STRING_P(value), value, XEN_ONLY_ARG, name, "a string or an XmString");  
	  if (XEN_STRING_P(value))
	    XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_STRING(value)));
	  else XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_XmString(value)));
	  break;
	case XM_STRING_TABLE:
	  XEN_ASSERT_TYPE(XEN_LIST_P(value), value, XEN_ONLY_ARG, name, "an XmStringTable");      	           
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_XmStringTable(value, XEN_LIST_LENGTH(value))));
	  break;
	case XM_TRANSFER_ENTRY_LIST:
	  XEN_ASSERT_TYPE(XEN_LIST_P(value), value, XEN_ONLY_ARG, name, "a list");      	           
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_XmDropTransferEntryRecs(value, XEN_LIST_LENGTH(value))));
	  break;
	case XM_RENDER_TABLE: 
	  XEN_ASSERT_TYPE(XEN_XmRenderTable_P(value), value, XEN_ONLY_ARG, name, "an XmRenderTable");
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_XmRenderTable(value)));
	  break;
	case XM_TAB_LIST:
	  XEN_ASSERT_TYPE(XEN_XmTabList_P(value), value, XEN_ONLY_ARG, name, "an XmTabList"); 
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_XmTabList(value)));
	  break;
	case XM_WIDGET:
	  XEN_ASSERT_TYPE(XEN_Widget_P(value), value, XEN_ONLY_ARG, name, "a Widget"); 
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_Widget(value)));
	  break;
	case XM_BOOLEAN:
	  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(value), value, XEN_ONLY_ARG, name, "a boolean"); 
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_BOOLEAN(value)));
	  break;
	case XM_BOOLEAN_OR_INT:
	  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(value) || XEN_INTEGER_P(value), value, XEN_ONLY_ARG, name, "a boolean or int"); 
	  if (XEN_BOOLEAN_P(value))
	    XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_BOOLEAN(value)));
	  else XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_INT(value)));
	  break;
	case XM_PIXEL:
	  XEN_ASSERT_TYPE(XEN_Pixel_P(value), value, XEN_ONLY_ARG, name, "a pixel"); 
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_Pixel(value)));
	  break;
	case XM_PIXMAP:
	  XEN_ASSERT_TYPE(XEN_Pixmap_P(value), value, XEN_ONLY_ARG, name, "a pixmap"); 
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_Pixmap(value)));
	  break;
	case XM_DIMENSION:
	  XEN_ASSERT_TYPE(XEN_INTEGER_P(value), value, XEN_ONLY_ARG, name, "a Dimension (integer)");      
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_Dimension(value)));
	  break;
	case XM_POSITION:
	  XEN_ASSERT_TYPE(XEN_INTEGER_P(value), value, XEN_ONLY_ARG, name, "a Position (integer)");      
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_Position(value)));
	  break;
	case XM_SHORT:
	  XEN_ASSERT_TYPE(XEN_INTEGER_P(value), value, XEN_ONLY_ARG, name, "a short");      
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_INT(value)));
	  break;
	case XM_ATOM:
	  XEN_ASSERT_TYPE(XEN_Atom_P(value), value, XEN_ONLY_ARG, name, "an Atom");      
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_Atom(value)));
	  break;
	case XM_TEXT_SOURCE:
	  XEN_ASSERT_TYPE(XEN_XmTextSource_P(value), value, XEN_ONLY_ARG, name, "an XmTextSource");      
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_XmTextSource(value)));
	  break;
#if (!XM_DISABLE_DEPRECATED)
	case XM_FONTLIST:
	  XEN_ASSERT_TYPE(XEN_XmFontList_or_XmRenderTable_P(value), value, XEN_ONLY_ARG, name, "an XmFontList");      
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_XmFontList(value)));
	  break;
#endif
	case XM_COLORMAP:
	  XEN_ASSERT_TYPE(XEN_Colormap_P(value), value, XEN_ONLY_ARG, name, "a Colormap");      
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_Colormap(value)));
	  break;
	case XM_KEYSYM:
	  XEN_ASSERT_TYPE(XEN_KeySym_P(value), value, XEN_ONLY_ARG, name, "a KeySym");      
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_KeySym(value)));
	  break;
	case XM_SCREEN:
	  XEN_ASSERT_TYPE(XEN_Screen_P(value), value, XEN_ONLY_ARG, name, "a Screen");      
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_Screen(value)));
	  break;
	case XM_WINDOW:
	  XEN_ASSERT_TYPE(XEN_Window_P(value), value, XEN_ONLY_ARG, name, "a Window");      
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_Window(value)));
	  break;
	case XM_VISUAL:
	  XEN_ASSERT_TYPE(XEN_Visual_P(value), value, XEN_ONLY_ARG, name, "a Visual");      
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_Visual(value)));
	  break;
	case XM_WIDGET_CLASS:
	  XEN_ASSERT_TYPE(XEN_WidgetClass_P(value), value, XEN_ONLY_ARG, name, "a WidgetClass");      
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_WidgetClass(value)));
	  break;

	case XM_ATOM_LIST:
	  XEN_ASSERT_TYPE(XEN_LIST_P(value), value, XEN_ONLY_ARG, name, "a list of Atoms");
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_Atoms(value, XEN_LIST_LENGTH(value))));
	  break;
	case XM_INT_TABLE:
	  XEN_ASSERT_TYPE(XEN_LIST_P(value), value, XEN_ONLY_ARG, name, "a list of ints");
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_Ints(value, XEN_LIST_LENGTH(value))));
	  break;
	case XM_WIDGET_LIST:
	  XEN_ASSERT_TYPE(XEN_LIST_P(value), value, XEN_ONLY_ARG, name, "a list of Widgets");
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_Widgets(value, XEN_LIST_LENGTH(value))));
	  break;
	case XM_KEYSYM_TABLE:
	  XEN_ASSERT_TYPE(XEN_LIST_P(value), value, XEN_ONLY_ARG, name, "a list of KeySyms");
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_KeySyms(value, XEN_LIST_LENGTH(value))));
	  break;
	case XM_STRING_LIST:
	case XM_CHARSET_TABLE:
	  XEN_ASSERT_TYPE(XEN_LIST_P(value), value, XEN_ONLY_ARG, name, "a list of char *");
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_Strings(value, XEN_LIST_LENGTH(value))));
	  break;
	case XM_RECTANGLE_LIST:
	  XEN_ASSERT_TYPE(XEN_LIST_P(value), value, XEN_ONLY_ARG, name, "a list of XRectangles");
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_XRectangles(value, XEN_LIST_LENGTH(value))));
	  break;
	case XM_CURSOR:
	  XEN_ASSERT_TYPE(XEN_Cursor_P(value), value, XEN_ONLY_ARG, name, "a cursor"); 
	  XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_Cursor(value)));
	  break;

	default:
	  if (XEN_ULONG_P(value))
	    XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_ULONG(value)));
	  else if (XEN_INTEGER_P(value))
	    XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_INT(value)));
	  else if (XEN_BOOLEAN_P(value))
	    XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_BOOLEAN(value)));
	  else if (XEN_STRING_P(value))
	    XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_STRING(value)));
	  else if (XEN_LIST_P(value))
	    XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_ULONG(XEN_CADR(value))));  /* all tagged types */
	  else 
	    XtSetArg(args[i], name, (XtArgVal)(XEN_TO_C_ULONG(value)));
	  break;
	}
    }
  xm_unprotect_at(gcloc);
  return(protect_args(args, len));
}

static void fixup_args(Widget w, Arg *args, int len)
{
  /* search for and fill-in incompletely specified callback info now that we have the widget type */
  int i;
  for (i = 0; i < len; i++)
    {
      char *name;
      name = args[i].name;
      if (name)
	{
	  XtCallbackRec *cl = NULL;
	  int j;
	  XEN data;
	  switch (resource_type(name))
	    {
	    case XM_STRING_TABLE:
	      {
		XmStringTable *st;
		st = (XmStringTable *)(args[i].value);
		FREE(st);
	      }
	      break;
	    case XM_WIDGET_LIST:
	      {
		Widget *w;
		w =(Widget *)(args[i].value); 
		FREE(w);
	      }
	      break;
	    case XM_CALLBACK:
	      cl = (XtCallbackRec *)(args[i].value);
	      for (j = 0 ;; j++)
		{
		  if (cl[j].callback == NULL) break;
		  data = (XEN)(cl[j].closure);
		  XEN_LIST_SET(data, CALLBACK_STRUCT_TYPE, C_TO_XEN_INT(callback_struct_type(w, name)));
		}
	      FREE(cl);
	      break;

	    case XM_DROP_CALLBACK:
	      j = map_over_protected_elements(find_dropproc, (unsigned long)w);
	      if (j >= 0)
		{
		  data = xm_protected_element(j);
		  xm_unprotect_at(XEN_TO_C_INT(XEN_LIST_REF(data, CALLBACK_GC_LOC)));
		}
	      j = map_over_protected_elements(find_dropproc, (unsigned long)XEN_FALSE);
	      if (j >= 0)
		{
		  data = xm_protected_element(j);
		  XEN_LIST_SET(data, CALLBACK_DATA, C_TO_XEN_Widget(w));
		}
	      else fprintf(stderr,"can't fixup drop proc!");
	      break;
	    case XM_DRAG_CALLBACK:
	      j = map_over_protected_elements(find_dragproc, (unsigned long)w);
	      if (j >= 0)
		{
		  data = xm_protected_element(j);
		  xm_unprotect_at(XEN_TO_C_INT(XEN_LIST_REF(data, CALLBACK_GC_LOC)));
		}
	      j = map_over_protected_elements(find_dragproc, (unsigned long)XEN_FALSE);
	      if (j >= 0)
		{
		  data = xm_protected_element(j);
		  XEN_LIST_SET(data, CALLBACK_DATA, C_TO_XEN_Widget(w));
		}
	      else fprintf(stderr,"can't fixup drag proc!");
	      break;
	    case XM_QUALIFY_CALLBACK:
	      j = map_over_protected_elements(find_qualifyproc, (unsigned long)w); /* see if one already exists */
	      if (j >= 0)
		{
		  data = xm_protected_element(j);
		  xm_unprotect_at(XEN_TO_C_INT(XEN_LIST_REF(data, CALLBACK_GC_LOC)));
		}
	      j = map_over_protected_elements(find_qualifyproc, (unsigned long)XEN_FALSE); /* i.e. find the unset one */
	      if (j >= 0)
		{
		  data = xm_protected_element(j);
		  XEN_LIST_SET(data, CALLBACK_DATA, C_TO_XEN_Widget(w));
		}
	      break;
	    case XM_SEARCH_CALLBACK:
	      j = map_over_protected_elements(find_searchproc, (unsigned long)w);
	      if (j >= 0)
		{
		  data = xm_protected_element(j);
		  xm_unprotect_at(XEN_TO_C_INT(XEN_LIST_REF(data, CALLBACK_GC_LOC)));
		}
	      j = map_over_protected_elements(find_searchproc, (unsigned long)XEN_FALSE);
	      if (j >= 0)
		{
		  data = xm_protected_element(j);
		  XEN_LIST_SET(data, CALLBACK_DATA, C_TO_XEN_Widget(w));
		}
	      break;
	    case XM_ORDER_CALLBACK:
	      j = map_over_protected_elements(find_orderproc, (unsigned long)w);
	      if (j >= 0)
		{
		  data = xm_protected_element(j);
		  xm_unprotect_at(XEN_TO_C_INT(XEN_LIST_REF(data, CALLBACK_GC_LOC)));
		}
	      j = map_over_protected_elements(find_orderproc, (unsigned long)XEN_FALSE);
	      if (j >= 0)
		{
		  data = xm_protected_element(j);
		  XEN_LIST_SET(data, CALLBACK_DATA, C_TO_XEN_Widget(w));
		}
	      break;
	    case XM_POPUP_CALLBACK:
	      j = map_over_protected_elements(find_popupchild, (unsigned long)w);
	      if (j >= 0)
		{
		  data = xm_protected_element(j);
		  xm_unprotect_at(XEN_TO_C_INT(XEN_LIST_REF(data, CALLBACK_GC_LOC)));
		}
	      j = map_over_protected_elements(find_popupchild, (unsigned long)XEN_FALSE);
	      if (j >= 0)
		{
		  data = xm_protected_element(j);
		  XEN_LIST_SET(data, CALLBACK_DATA, C_TO_XEN_Widget(w));
		}
	      break;
	    default:
	      break;
	    }
	}
    }
}

static int xmstringtable_length(Widget w, const char *name)
{
  /* it's not safe here to search for 0 as end of table, so where possible we'll match resources with counts */
  int len = 0;
  if (strcmp(name, XmNitems) == 0) XtVaGetValues(w, XmNitemCount, &len, NULL);
  else if (strcmp(name, XmNlistItems) == 0) XtVaGetValues(w, XmNlistItemCount, &len, NULL);
  else if (strcmp(name, XmNselectedItems) == 0) XtVaGetValues(w, XmNselectedItemCount, &len, NULL);
  else if (strcmp(name, XmNhistoryItems) == 0) XtVaGetValues(w, XmNhistoryItemCount, &len, NULL);
  else if (strcmp(name, XmNfileListItems) == 0) XtVaGetValues(w, XmNfileListItemCount, &len, NULL);
  else if (strcmp(name, XmNdirListItems) == 0) XtVaGetValues(w, XmNdirListItemCount, &len, NULL);
  else if (strcmp(name, XmNdetail) == 0) XtVaGetValues(w, XmNdetailCount, &len, NULL);
  else if (strcmp(name, XmNvalues) == 0) XtVaGetValues(w, XmNnumValues, &len, NULL);
  else XtVaGetValues(w, XmNbuttonCount, &len, NULL);
  return(len);
}

static XEN C_TO_XEN_ANY(Widget w, Arg arg)
{
  /* XtGetValues -- a list of pairs: resource-name place-holder where we fill in the 2nd element */
  /* this has to wait until the last moment to decide what arg.value is -- if we assume unsigned long*
   *   (which works on the Pentium/Linux), the Sun gets confused by Dimensions (unsigned short)
   */
  Arg a[1];
  int j, ilen = 0;
  switch (resource_type(arg.name))
    {
    case XM_INT:	      return(C_TO_XEN_INT((*((int *)(arg.value)))));
    case XM_ULONG:	      return(C_TO_XEN_ULONG((*((unsigned long *)(arg.value)))));
    case XM_UCHAR:	      return(C_TO_XEN_INT((*((unsigned char *)(arg.value)))));
    case XM_FLOAT:	      return(C_TO_XEN_DOUBLE((*((float *)(arg.value))))); /* the resource values are floats */
    case XM_STRING:	      return(C_TO_XEN_STRING((char *)(*((char **)(arg.value)))));
    case XM_STRING_OR_XMSTRING: /* fileselectionbox here , not parsemapping */
    case XM_XMSTRING:	      return(C_TO_XEN_XmString((XmString)(*((XmString *)(arg.value)))));
    case XM_STRING_TABLE:     return(C_TO_XEN_XmStringTable((XmStringTable)(*((XmStringTable *)(arg.value))), xmstringtable_length(w, arg.name)));
    case XM_RENDER_TABLE:     return(C_TO_XEN_XmRenderTable((XmRenderTable)(*((XmRenderTable *)(arg.value)))));
    case XM_TAB_LIST:	      return(C_TO_XEN_XmTabList((XmTabList)(*((XmTabList *)(arg.value)))));
    case XM_WIDGET:	      return(C_TO_XEN_Widget((Widget)(*((Widget *)(arg.value)))));
    case XM_WIDGET_LIST:      /* (XtGetValues c1 (list XmNchildren 0) 1) */
      if (strcmp(arg.name, XmNchildren) == 0)
	XtSetArg(a[0], XmNnumChildren, &ilen);             /* Composite */
      else XtSetArg(a[0], XmNselectedObjectCount, &ilen);  /* Container */
      XtGetValues(w, a, 1);
      return(C_TO_XEN_Widgets((Widget *)(*((Widget **)(arg.value))), ilen));
      break;
    case XM_BOOLEAN:	      return(C_TO_XEN_BOOLEAN((*((Boolean *)(arg.value)))));
    case XM_BOOLEAN_OR_INT:   return(C_TO_XEN_INT((*((int *)(arg.value)))));
    case XM_SEARCH_CALLBACK:
      j = map_over_protected_elements(find_searchproc, (unsigned long)w);
      if (j >= 0) return(XEN_LIST_REF(xm_protected_element(j), CALLBACK_FUNC));
      break;
    case XM_DROP_CALLBACK:
      j = map_over_protected_elements(find_dropproc, (unsigned long)w);
      if (j >= 0) return(XEN_LIST_REF(xm_protected_element(j), CALLBACK_FUNC));
      break;
    case XM_DRAG_CALLBACK:
      j = map_over_protected_elements(find_dragproc, (unsigned long)w);
      if (j >= 0) return(XEN_LIST_REF(xm_protected_element(j), CALLBACK_FUNC));
      break;
    case XM_ORDER_CALLBACK:
      j = map_over_protected_elements(find_orderproc, (unsigned long)w);
      if (j >= 0) return(XEN_LIST_REF(xm_protected_element(j), CALLBACK_FUNC));
      break;
    case XM_QUALIFY_CALLBACK:
      j = map_over_protected_elements(find_qualifyproc, (unsigned long)w);
      if (j >= 0) return(XEN_LIST_REF(xm_protected_element(j), CALLBACK_FUNC));
      break;
    case XM_ALLOC_COLOR_CALLBACK:
      return(xm_XmColorAllocationProc);
      break;
    case XM_SCREEN_COLOR_CALLBACK:
      return(xm_XmColorCalculationProc);
      break;
    case XM_POPUP_CALLBACK:
      j = map_over_protected_elements(find_popupchild, (unsigned long)w);
      if (j >= 0) return(XEN_LIST_REF(xm_protected_element(j), CALLBACK_FUNC));
      break;
    case XM_TRANSFER_CALLBACK:
      return(xm_XtSelectionCallback_Descr);
    case XM_CONVERT_CALLBACK:
      return(xm_XtConvertSelectionIncr_Descr);
    case XM_CALLBACK:	   
      /* this can't work because we don't know what the desired callback was, so we can't search the gc table */
      /*   and if the callback was a C procedure, what good would its address be in this context? */
      /*   (XtGetValues_1 would need to pass the entire Arg or something) */
      return(C_TO_XEN_ULONG((*((unsigned long *)(arg.value)))));
      break;

    case XM_PIXEL:	      return(C_TO_XEN_Pixel((*((Pixel *)(arg.value)))));
    case XM_PIXMAP:	      return(C_TO_XEN_Pixmap((*((Pixmap *)(arg.value)))));
    case XM_XFONTSTRUCT:      return(C_TO_XEN_XFontStruct((XFontStruct *)(*((XFontStruct **)(arg.value)))));
    case XM_DIMENSION:	      return(C_TO_XEN_Dimension((*((Dimension *)(arg.value)))));
    case XM_POSITION:	      return(C_TO_XEN_Position((*((Position *)(arg.value)))));
    case XM_SHORT:	      return(C_TO_XEN_INT((*((short *)(arg.value)))));
    case XM_ATOM:	      return(C_TO_XEN_Atom((*((Atom *)(arg.value)))));
    case XM_TEXT_SOURCE:      return(C_TO_XEN_XmTextSource((XmTextSource)(*((XmTextSource *)(arg.value)))));
    case XM_ATOM_LIST:	      
      if (strcmp(arg.name, XmNexportTargets) == 0)            /* DragContext */
	XtSetArg(a[0], XmNnumExportTargets, &ilen);        /* DropSite */
      else XtSetArg(a[0], XmNnumImportTargets, &ilen);
      XtGetValues(w, a, 1);
      if ((ilen > 0) && (ilen < 100))
	return(C_TO_XEN_Atoms((Atom *)(*((Atom **)(arg.value))), ilen));
      else return(XEN_FALSE);
      break;
    case XM_STRING_LIST:                                  /* ApplicationShell */
      XtSetArg(a[0], XmNargc, &ilen);
      XtGetValues(w, a, 1);
      return(C_TO_XEN_Strings((char **)(*((char ***)(arg.value))), ilen));
      break;
    case XM_CHARSET_TABLE:    
      XtSetArg(a[0], XmNbuttonCount, &ilen); /* may not be long enough... */
      XtGetValues(w, a, 1);
      return(C_TO_XEN_Strings((char **)(*((char ***)(arg.value))), ilen));
      break;
#if (!XM_DISABLE_DEPRECATED)
    case XM_FONTLIST:	      return(C_TO_XEN_XmFontList((XmFontList)(*((XmFontList *)(arg.value)))));
#endif
    case XM_COLORMAP:	      return(C_TO_XEN_Colormap((*((Colormap *)(arg.value)))));
    case XM_KEYSYM:	      return(C_TO_XEN_KeySym((*((KeySym *)(arg.value)))));
    case XM_KEYSYM_TABLE:     
      XtSetArg(a[0], XmNbuttonCount, &ilen);
      XtGetValues(w, a, 1);
      return(C_TO_XEN_KeySyms((KeySym *)(*((KeySym **)(arg.value))), ilen));
      break;
    case XM_SCREEN:	      return(C_TO_XEN_Screen((Screen *)(*((Screen **)(arg.value)))));
    case XM_WINDOW:	      return(C_TO_XEN_Window((Window)(*((Window *)(arg.value)))));
    case XM_VISUAL:	      return(C_TO_XEN_Visual((Visual *)(*((Visual **)(arg.value)))));
    case XM_INT_TABLE:	      
      if (strcmp(arg.name, XmNdetailOrder) == 0) 
	XtSetArg(a[0], XmNdetailOrderCount, &ilen); 
      else
	{
	  if (strcmp(arg.name, XmNselectionArray) == 0) 
	    XtSetArg(a[0], XmNselectionArrayCount, &ilen); 
	  else XtSetArg(a[0], XmNselectedPositionCount, &ilen);
	}
      XtGetValues(w, a, 1);
      return(C_TO_XEN_Ints((int *)(*((int **)(arg.value))), ilen));
      break;
    case XM_RECTANGLE_LIST:                              /* XmNrectangles exists but is not documented */
      XtSetArg(a[0], XmNnumDropRectangles, &ilen);
      XtGetValues(w, a, 1);
      return(C_TO_XEN_XRectangles((XRectangle *)(*((XRectangle **)(arg.value))), ilen));
      break;
    case XM_WIDGET_CLASS:     return(C_TO_XEN_WidgetClass((WidgetClass)(*((WidgetClass *)(arg.value)))));
    case XM_STRING_OR_INT:
      if ((w) &&
	  ((XmIsText(w)) || (XmIsTextField(w))))
	return(C_TO_XEN_STRING((char *)(*((char **)(arg.value)))));
      else return(C_TO_XEN_INT((int)(*((int *)(arg.value)))));
      break;
    default:
      break;
    }
  return(C_TO_XEN_ULONG((*((unsigned long *)(arg.value))))); /* fallback */
}

static XEN C_TO_XEN_Args(Widget w, Arg *args, int len)
{
  /* here XtGetValues (or equivalent) has filled in the resource values and we need to pass them back
   *   to scheme properly wrapped
   */
  int i, loc;
  XEN lst = XEN_EMPTY_LIST;
  loc = xm_protect(lst);
  for (i = len - 1; i >= 0; i--) 
    lst = XEN_CONS_2(C_TO_XEN_STRING(args[i].name),
		     C_TO_XEN_ANY(w, args[i]),
		     lst);
  xm_unprotect_at(loc);
  return(lst);
}

/* (XtGetValues c1 (list XmNx 0) 1) */

static XEN gxm_XtGetValues_1(XEN arg1, XEN larg2, int len)
{
  Arg *args;
  unsigned long *locs;
  Widget w;
  XEN val, arg2;
  int i, gcloc;
  /* here we need to make sure the ref args are ok from C's point of view */
  if (len <= 0) return(XEN_FALSE);
  w = XEN_TO_C_Widget(arg1);
  arg2 = XEN_COPY_ARG(larg2);
  gcloc = xm_protect(arg2);
  args = (Arg *)CALLOC(len, sizeof(Arg));
  locs = (unsigned long *)CALLOC(len, sizeof(unsigned long));
  for (i = 0; i < len; i++, arg2 = XEN_CDDR(arg2))
    {
      char *name;
      name = strdup(XEN_TO_C_STRING(XEN_CAR(arg2)));
      XtSetArg(args[i], name, &(locs[i]));
    }
  XtGetValues(w, args, len);
  val = C_TO_XEN_Args(w, args, len);
  free_args(args, len);
  FREE(locs);
  xm_unprotect_at(gcloc);
  return(xen_return_first(val, larg2));
}

#endif


/* -------------------------------- gc protection -------------------------------- */

static XEN xm_protected = XEN_FALSE;
static int xm_protected_size = 0;
static XEN xm_gc_table = XEN_FALSE;
static int last_xm_unprotect = NOT_A_GC_LOC;

static int xm_protect(XEN obj)
{
  int i, new_size;
  XEN new_table;
  if (last_xm_unprotect >= 0)
    {
      i = last_xm_unprotect;
      if (XEN_FALSE_P(XEN_VECTOR_REF(xm_protected, i)))
	{
	  XEN_VECTOR_SET(xm_protected, i, obj);
	  last_xm_unprotect = NOT_A_GC_LOC;
	  return(i);
	}
      last_xm_unprotect = NOT_A_GC_LOC;
    }
  for (i = 0; i < xm_protected_size; i++)
    if (XEN_FALSE_P(XEN_VECTOR_REF(xm_protected, i)))
      {
	XEN_VECTOR_SET(xm_protected, i, obj);
	return(i);
      }
  new_size = xm_protected_size * 2;
  new_table = XEN_MAKE_VECTOR(new_size, XEN_FALSE);
  for (i = 0; i < xm_protected_size; i++)
    {
      XEN_VECTOR_SET(new_table, i, XEN_VECTOR_REF(xm_protected, i));
      XEN_VECTOR_SET(xm_protected, i, XEN_FALSE);
    }
  XEN_VECTOR_SET(new_table, xm_protected_size, obj);
  XEN_VECTOR_SET(xm_gc_table, 0, new_table);
  i = xm_protected_size;
  xm_protected_size = new_size;
  xm_protected = new_table;
  return(i);
}

static void xm_unprotect(XEN obj)
{
  int i;
  for (i = 0; i < xm_protected_size; i++)
    if (XEN_EQ_P(XEN_VECTOR_REF(xm_protected, i), obj))
      {
	XEN_VECTOR_SET(xm_protected, i, XEN_FALSE);
	last_xm_unprotect = i;
	return;
      }
}

static void xm_unprotect_at(int ind)
{
  XEN_VECTOR_SET(xm_protected, ind, XEN_FALSE);
  last_xm_unprotect = ind;
}

static int map_over_protected_elements(bool (*func)(XEN val, int loc, unsigned long fid), unsigned long id)
{
  int i;
  for (i = 0; i < xm_protected_size; i++)
    if (func(XEN_VECTOR_REF(xm_protected, i), i, id))
      return(i);
  return(-1);
}

static XEN xm_protected_element(int loc)
{
  return(XEN_VECTOR_REF(xm_protected, loc));
}


/* ----------------------------------------------------------------------------------------------------
 *
 *                            *         *  *         *
 *                             *       *   **       **
 *                              *     *    * *     * *
 *                               *   *     *  *   *  *
 *                                * *      *   * *   *
 *                                 *       *    *    *
 *                                * *      *         *
 *                               *   *     *         *
 *                              *     *    *         *
 *                             *       *   *         *
 *                            *         *  *         *
 * ----------------------------------------------------------------------------------------------------
 */

/* Motif */
#if HAVE_MOTIF

/* weird order of procedures here and throughout caused by the C-header scripts --
 *   basically I forgot to reverse the main lists before pouring out the code,
 *   so everything is slightly backwards
 */

static int XEN_TO_C_INT_DEF(XEN len, XEN lst) 
{
  if (XEN_INTEGER_P(len))
    return(XEN_TO_C_INT(len));
  else
    {
      int list_len;
      list_len = XEN_LIST_LENGTH(lst);
      return((int)(list_len / 2));
    }
}

static XEN gxm_XmTransferDone(XEN arg1, XEN arg2)
{
  #define H_XmTransferDone "void XmTransferDone(XtPointer transfer_id, XmTransferStatus status) completes a data transfer"
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg1), arg1, 1, "XmTransferDone", "XtPointer");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTransferDone", "XmTransferStatus");
  XmTransferDone((XtPointer)XEN_TO_C_ULONG(arg1), (XmTransferStatus)XEN_TO_C_INT(arg2));
  return(arg1);
}

static XEN gxm_XmTransferSendRequest(XEN arg1, XEN arg2)
{
  #define H_XmTransferSendRequest "void XmTransferSendRequest(XtPointer transfer_id, Time time) transfers a MULTIPLE request"
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg1), arg1, 1, "XmTransferSendRequest", "XtPointer");
  XEN_ASSERT_TYPE(XEN_Time_P(arg2), arg2, 2, "XmTransferSendRequest", "Time");
  XmTransferSendRequest((XtPointer)XEN_TO_C_ULONG(arg1), XEN_TO_C_Time(arg2));
  return(arg1);
}

static XEN gxm_XmTransferStartRequest(XEN arg1)
{
  #define H_XmTransferStartRequest "void XmTransferStartRequest(XtPointer transfer_id) begins a MULTIPLE transfer"
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg1), arg1, 1, "XmTransferStartRequest", "XtPointer");
  XmTransferStartRequest((XtPointer)XEN_TO_C_ULONG(arg1));
  return(arg1);
}

static XEN gxm_XmTransferSetParameters(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XmTransferSetParameters "void XmTransferSetParameters(XtPointer transfer_id, XtPointer parm, int parm_fmt, \
unsigned long parm_length, Atom parm_type)  establishes parameters to be passed by the next call to XmTransferValue"
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg1), arg1, 1, "XmTransferSetParameters", "XtPointer");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XmTransferSetParameters", "XtPointer");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmTransferSetParameters", "an integer");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg4), arg4, 4, "XmTransferSetParameters", "unsigned long");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg5), arg5, 5, "XmTransferSetParameters", "an Atom");
  XmTransferSetParameters((XtPointer)XEN_TO_C_ULONG(arg1), 
			  (XtPointer)XEN_TO_C_ULONG(arg2), 
			  XEN_TO_C_INT(arg3),
			  XEN_TO_C_ULONG(arg4), 
			  XEN_TO_C_Atom(arg5));
  return(arg1);
}

static void gxm_TransferValueProc(Widget w, XtPointer context, XtPointer info)
{
  XEN descr = (XEN)context;
  XEN_CALL_3(XEN_LIST_REF(descr, 0),
	     C_TO_XEN_Widget(w),
	     XEN_LIST_REF(descr, 1),
	     C_TO_XEN_XmSelectionCallbackStruct((XmSelectionCallbackStruct *)info),
	     c__FUNCTION__);
}

static XEN gxm_XmTransferValue(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XmTransferValue "void XmTransferValue(XtPointer transfer_id, Atom target, XtCallbackProc proc, XtPointer client_data, Time time) \
transfers data to a destination"
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg1), arg1, 1, "XmTransferValue", "XtPointer");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg2), arg2, 2, "XmTransferValue", "an Atom");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg3) && (XEN_REQUIRED_ARGS_OK(arg3, 3)), arg3, 3, "XmTransferValue", "XtCallbackProc (3 args)");
  XEN_ASSERT_TYPE(XEN_Time_P(arg5), arg5, 5, "XmTransferValue", "Time");
  XmTransferValue((XtPointer)XEN_TO_C_ULONG(arg1), 
		  XEN_TO_C_Atom(arg2), 
		  gxm_TransferValueProc,
		  (XtPointer)XEN_LIST_2(arg3, arg4),
		  XEN_TO_C_Time(arg5));
  return(arg1);
}

static XEN gxm_new_widget(const char *caller, Widget (*func)(Widget parent, char *name, ArgList al, Cardinal ac), XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  Widget w;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, caller, "Widget");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, caller, "char*");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg3), arg3, 3, caller, "ArgList");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg4), arg4, 4, caller, "int");
  {
    Arg *args;
    int arglen;
    args = XEN_TO_C_Args(arg3);
    w = (*func)(XEN_TO_C_Widget(arg1), 
		XEN_TO_C_STRING(arg2), 
		args, 
		arglen = XEN_TO_C_INT_DEF(arg4, arg3));
    if (args)
      {
	fixup_args(w, args, arglen);
	free_args(args, arglen);
      }
  }
  return(C_TO_XEN_Widget(w));
}

static XEN gxm_XmCreateMenuShell(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateMenuShell "Widget XmCreateMenuShell(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The MenuShell widget creation function"
  return(gxm_new_widget("XmCreateMenuShell", XmCreateMenuShell, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmProcessTraversal(XEN arg1, XEN arg2)
{
  #define H_XmProcessTraversal "Boolean XmProcessTraversal(Widget widget, XmTraversalDirection direction) determines which \
component receives keyboard events when a widget has the focus"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmProcessTraversal", "Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmProcessTraversal", "XmTraversalDirection");
  return(C_TO_XEN_BOOLEAN(XmProcessTraversal(XEN_TO_C_Widget(arg1), (XmTraversalDirection)XEN_TO_C_INT(arg2))));
}

static XEN gxm_XmGetFocusWidget(XEN arg1)
{
  #define H_XmGetFocusWidget "Widget XmGetFocusWidget(Widget widget) returns the ID of the widget that has keyboard focus"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmGetFocusWidget", "Widget");
  return(C_TO_XEN_Widget(XmGetFocusWidget(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmGetTabGroup(XEN arg1)
{
  #define H_XmGetTabGroup "Widget XmGetTabGroup(Widget widget) returns the widget ID of a tab group"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmGetTabGroup", "Widget");
  return(C_TO_XEN_Widget(XmGetTabGroup(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmGetVisibility(XEN arg1)
{
  #define H_XmGetVisibility "XmVisibility XmGetVisibility(Widget widget) determines if a widget is visible"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmGetVisibility", "Widget");
  return(C_TO_XEN_INT(XmGetVisibility(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmIsTraversable(XEN arg1)
{
  #define H_XmIsTraversable "Boolean XmIsTraversable(Widget widget) identifies whether a widget can be traversed"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmIsTraversable", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsTraversable(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmGetDestination(XEN arg1)
{
  #define H_XmGetDestination "Widget XmGetDestination(Display *display) gets the current destination widget for paste etc"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmGetDestination", "Display*");
  return(C_TO_XEN_Widget(XmGetDestination(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XmRenderTableAddRenditions(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmRenderTableAddRenditions "XmRenderTable XmRenderTableAddRenditions(XmRenderTable oldtable, \
XmRendition *renditions, Cardinal rendition_count, XmMergeMode merge_mode) adds renditions to a render table"
  /* DIFF: XmRenderTableAddRenditions arg2 is list of Renditions, arg1 can be #f = NULL
   */
  int len, listlen;
  XmRendition *rs;
  XmRenderTable res;
  XEN_ASSERT_TYPE(XEN_XmRenderTable_P(arg1) || XEN_FALSE_P(arg1), arg1, 1, "XmRenderTableAddRenditions", "XmRenderTable");
  XEN_ASSERT_TYPE(XEN_LIST_P_WITH_LENGTH(arg2, listlen), arg2, 2, "XmRenderTableAddRenditions", "list of XmRendition");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmRenderTableAddRenditions", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XmRenderTableAddRenditions", "XmMergeMode");
  len = XEN_TO_C_INT(arg3);
  if (len > listlen) len = listlen;
  if (len <= 0) return(XEN_FALSE);
  rs = XEN_TO_C_XmRenditions(arg2, len);
  res = XmRenderTableAddRenditions(XEN_FALSE_P(arg1) ? NULL : XEN_TO_C_XmRenderTable(arg1), 
				   rs, (Cardinal)len, 
				   (XmMergeMode)XEN_TO_C_INT(arg4));
  FREE(rs);
  return(C_TO_XEN_XmRenderTable(res));
}

static XEN gxm_XmRenderTableRemoveRenditions(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmRenderTableRemoveRenditions "XmRenderTable XmRenderTableRemoveRenditions(XmRenderTable oldtable, XmStringTag *tags, int tag_count) \
removes renditions"
  /* DIFF: XmRenderTableRemoveRenditions arg2 is list of strings
   */
  int len = 0;
  XmStringTag *tags = NULL;
  XmRenderTable rt = NULL;
  if (XEN_NOT_BOUND_P(arg1) || XEN_FALSE_P(arg1)) return(XEN_FALSE);
  XEN_ASSERT_TYPE(XEN_XmRenderTable_P(arg1) || XEN_FALSE_P(arg1), arg1, 1, "XmRenderTableRemoveRenditions", "XmRenderTable");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2) || XEN_FALSE_P(arg2) || XEN_NOT_BOUND_P(arg2), arg2, 2, "XmRenderTableRemoveRenditions", "XmStringTag*");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg3), arg3, 3, "XmRenderTableRemoveRenditions", "int");
  if (XEN_INTEGER_P(arg3)) 
    {
      len = XEN_TO_C_INT(arg3); 
      if (len <= 0) return(XEN_FALSE);
    }
  else 
    {
      if (XEN_LIST_P(arg2))
	len = XEN_LIST_LENGTH(arg2);
    }
  if (XEN_BOUND_P(arg2)) tags = (XmStringTag *)XEN_TO_C_Strings(arg2, len);
  rt = XmRenderTableRemoveRenditions(XEN_TO_C_XmRenderTable(arg1), tags, len);
  if (tags) FREE(tags);
  return(xen_return_first(C_TO_XEN_XmRenderTable(rt), arg2));
}

static XEN gxm_XmRenderTableCopy(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmRenderTableCopy "XmRenderTable XmRenderTableCopy(XmRenderTable table, XmStringTag *tags, int tag_count) copies renditions"
  /* DIFF: XmRenderTableCopy arg2 is list of strings
   */
  int len = 0;
  XmStringTag *tags = NULL;
  XmRenderTable rt = NULL;
  if (XEN_NOT_BOUND_P(arg1) || XEN_FALSE_P(arg1)) return(XEN_FALSE);
  XEN_ASSERT_TYPE(XEN_XmRenderTable_P(arg1), arg1, 1, "XmRenderTableCopy", "XmRenderTable");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2) || XEN_FALSE_P(arg2) || XEN_NOT_BOUND_P(arg2), arg2, 2, "XmRenderTableCopy", "XmStringTag*");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg3), arg3, 3, "XmRenderTableCopy", "int");
  if (XEN_INTEGER_P(arg3)) 
    {
      len = XEN_TO_C_INT(arg3); 
      if (len <= 0) return(XEN_FALSE);
    }
  else 
    {
      if (XEN_LIST_P(arg2))
	len = XEN_LIST_LENGTH(arg2);
    }
  if (XEN_BOUND_P(arg2)) tags = (XmStringTag *)XEN_TO_C_Strings(arg2, len);
  rt = XmRenderTableCopy(XEN_TO_C_XmRenderTable(arg1), tags, len);
  if (tags) FREE(tags);
  return(xen_return_first(C_TO_XEN_XmRenderTable(rt), arg2));
}

static XEN gxm_XmRenderTableFree(XEN arg1)
{
  #define H_XmRenderTableFree "void XmRenderTableFree(XmRenderTable table)  recovers memory"
  XEN_ASSERT_TYPE(XEN_XmRenderTable_P(arg1), arg1, 1, "XmRenderTableFree", "XmRenderTable");
  XmRenderTableFree(XEN_TO_C_XmRenderTable(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmRenderTableGetTags(XEN arg1)
{
  #define H_XmRenderTableGetTags "int XmRenderTableGetTags(XmRenderTable table) gets rendition tags (list of strings)"
  /* DIFF: XmRenderTableGetTags omits arg2, returns list of strings
   */
  int len, loc;
  XEN lst = XEN_EMPTY_LIST;
  XmStringTag *str;
  XEN_ASSERT_TYPE(XEN_XmRenderTable_P(arg1), arg1, 1, "XmRenderTableGetTags", "XmRenderTable");
  loc = xm_protect(lst);
  len = XmRenderTableGetTags(XEN_TO_C_XmRenderTable(arg1), &str);
  if (str)
    {
      int i;
      for (i = len - 1; i >= 0; i--)
	{
	  lst = XEN_CONS(C_TO_XEN_STRING(str[i]), lst);
	  free(str[i]);
	}
      free(str);
    }
  xm_unprotect_at(loc);
  return(lst);
}

static XEN gxm_XmRenderTableGetRendition(XEN arg1, XEN arg2)
{
  #define H_XmRenderTableGetRendition "XmRendition XmRenderTableGetRendition(XmRenderTable table, XmStringTag tag) \
matches a rendition tag"
  XEN_ASSERT_TYPE(XEN_XmRenderTable_P(arg1), arg1, 1, "XmRenderTableGetRendition", "XmRenderTable");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmRenderTableGetRendition", "XmStringTag");
  return(C_TO_XEN_XmRendition(XmRenderTableGetRendition(XEN_TO_C_XmRenderTable(arg1), XEN_TO_C_STRING(arg2))));
}

static XEN gxm_XmRenderTableGetRenditions(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmRenderTableGetRenditions "XmRendition *XmRenderTableGetRenditions(XmRenderTable table, XmStringTag *tags, Cardinal tag_count) \
matches rendition tags"
  /* DIFF: XmRenderTableGetRenditions returns list of XmRenditions, arg2 is list of strings
   */
  int i, len = 0, loc;
  XEN lst = XEN_EMPTY_LIST;
  XmRendition *rs;
  XmStringTag *tags;
  if ((XEN_NOT_BOUND_P(arg1)) || XEN_NOT_BOUND_P(arg2) || XEN_FALSE_P(arg2)) return(XEN_FALSE);
  XEN_ASSERT_TYPE(XEN_XmRenderTable_P(arg1), arg1, 1, "XmRenderTableGetRenditions", "XmRenderTable");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XmRenderTableGetRenditions", "list of String");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg3), arg3, 3, "XmRenderTableGetRenditions", "int");
  if (XEN_BOUND_P(arg3))
    len = XEN_TO_C_INT(arg3);
  else len = XEN_LIST_LENGTH(arg2);
  if (len <= 0) return(XEN_FALSE);
  loc = xm_protect(lst);
  tags = (XmStringTag *)XEN_TO_C_Strings(arg2, len);
  rs = XmRenderTableGetRenditions(XEN_TO_C_XmRenderTable(arg1), tags, (Cardinal)len);
  FREE(tags);
  for (i = len - 1; i >= 0; i--)
    lst = XEN_CONS(C_TO_XEN_XmRendition(rs[i]), lst);
  free(rs);
  xm_unprotect_at(loc);
  return(xen_return_first(lst, arg2));
}

static XEN gxm_XmRenditionCreate(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmRenditionCreate "XmRendition XmRenditionCreate(Widget widget, XmStringTag tag, ArgList arglist, Cardinal argcount) \
creates a rendition"
  XmRendition w;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmRenditionCreate", "Widget");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmRenditionCreate", "XmStringTag");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg3), arg3, 3, "XmRenditionCreate", "ArgList");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg4), arg4, 4, "XmRenditionCreate", "int");
  {
    Arg *args;
    int arglen;
    args = XEN_TO_C_Args(arg3);
    arglen = XEN_TO_C_INT_DEF(arg4, arg3);
    w = XmRenditionCreate(XEN_TO_C_Widget(arg1), XEN_TO_C_STRING(arg2), args, arglen);
    if (args) free_args(args, arglen);
  }
  return(C_TO_XEN_XmRendition(w));
}

static XEN gxm_XmRenditionFree(XEN arg1)
{
  #define H_XmRenditionFree "void XmRenditionFree(XmRendition rendition) frees a rendition"
  XEN_ASSERT_TYPE(XEN_XmRendition_P(arg1), arg1, 1, "XmRenditionFree", "XmRendition");
  XmRenditionFree(XEN_TO_C_XmRendition(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmRenditionRetrieve(XEN arg1, XEN larg2, XEN arg3)
{
  #define H_XmRenditionRetrieve "void XmRenditionRetrieve(XmRendition rendition, ArgList arglist, Cardinal argcount) \
retrieves rendition resources"
  XEN_ASSERT_TYPE(XEN_XmRendition_P(arg1), arg1, 1, "XmRenditionRetrieve", "XmRendition");
  XEN_ASSERT_TYPE(XEN_LIST_P(larg2), larg2, 2, "XmRenditionRetrieve", "ArgList");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg3), arg3, 3, "XmRenditionRetrieve", "int");
  {
    /* this is a kind of XtGetvalues, not set
     */
    Arg *args;
    unsigned long *locs;
    XEN val;
    int i, len, gcloc;
    XmRendition r;
    char *name;
    XEN arg2;
    arg2 = XEN_COPY_ARG(larg2);
    gcloc = xm_protect(arg2);
    /* here we need to make sure the ref args are ok from C's point of view */
    r = XEN_TO_C_XmRendition(arg1);
    len = XEN_TO_C_INT_DEF(arg3, arg2);
    if (len <= 0) XEN_ASSERT_TYPE(0, arg3, 3, "XmRenditionRetrieve", "positive integer");
    args = (Arg *)CALLOC(len, sizeof(Arg));
    locs = (unsigned long *)CALLOC(len, sizeof(unsigned long));
    for (i = 0; i < len; i++, arg2 = XEN_CDDR(arg2))
      {
	name = strdup(XEN_TO_C_STRING(XEN_CAR(arg2)));
	XtSetArg(args[i], name, &(locs[i]));
      }
    XmRenditionRetrieve(r, args, len);
    val = C_TO_XEN_Args((Widget)r, args, len);
    free_args(args, len);
    FREE(locs);
    xm_unprotect_at(gcloc);
    return(xen_return_first(val, larg2));
  }
}

static XEN gxm_XmRenditionUpdate(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmRenditionUpdate "void XmRenditionUpdate(XmRendition rendition, ArgList arglist, Cardinal argcount) \
modifies resources"
  XEN_ASSERT_TYPE(XEN_XmRendition_P(arg1), arg1, 1, "XmRenditionUpdate", "XmRendition");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XmRenditionUpdate", "ArgList");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg3), arg3, 3, "XmRenditionUpdate", "int");
  {
    Arg *args;
    int arglen;
    args = XEN_TO_C_Args(arg2);
    arglen = XEN_TO_C_INT_DEF(arg3, arg2);
    XmRenditionUpdate(XEN_TO_C_XmRendition(arg1), args, arglen);
    if (args) free_args(args, arglen);
  }
  return(XEN_FALSE);
}

static XEN gxm_XmRenderTableCvtToProp(XEN arg1, XEN arg2)
{
  #define H_XmRenderTableCvtToProp "unsigned int XmRenderTableCvtToProp(Widget widget, XmRenderTable table) \
converts a render table to a string representation -> (val props)"
  /* DIFF: XmRenderTableCvtToProp omits and rtns arg3
   */
  char *buf;
  unsigned int val;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmRenderTableCvtToProp", "Widget");
  XEN_ASSERT_TYPE(XEN_XmRenderTable_P(arg2), arg2, 2, "XmRenderTableCvtToProp", "XmRenderTable");
  val = XmRenderTableCvtToProp(XEN_TO_C_Widget(arg1), XEN_TO_C_XmRenderTable(arg2), &buf);
  return(XEN_LIST_2(C_TO_XEN_ULONG(val),
		    C_TO_XEN_STRING(buf)));
}

static XEN gxm_XmRenderTableCvtFromProp(XEN arg1, XEN arg2, XEN arg3)
{
  char *str;
  int len;
  #define H_XmRenderTableCvtFromProp "XmRenderTable XmRenderTableCvtFromProp(Widget widget, char *property, unsigned int length) \
converts from a string representation to a render table"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmRenderTableCvtFromProp", "Widget");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmRenderTableCvtFromProp", "char*");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XmRenderTableCvtFromProp", "unsigned int");
  str = XEN_TO_C_STRING(arg2);
  len = XEN_TO_C_ULONG(arg3);
  if ((str) || ((int)strlen(str) == len))
    return(C_TO_XEN_XmRenderTable(XmRenderTableCvtFromProp(XEN_TO_C_Widget(arg1), str, len)));
  return(XEN_FALSE);
}

static XEN gxm_XmTabListInsertTabs(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmTabListInsertTabs "XmTabList XmTabListInsertTabs(XmTabList oldlist, XmTab *tabs, Cardinal tab_count, int position) \
inserts tabs into a tab list"
  /* DIFF: XmTabListInsertTabs arg2 is list of XmTabs (can be #f = NULL)
   */
  int len, listlen;
  XmTab *tabs;
  XmTabList tl;
  XEN_ASSERT_TYPE(XEN_XmTabList_P(arg1) || XEN_FALSE_P(arg1), arg1, 1, "XmTabListInsertTabs", "XmTabList");
  XEN_ASSERT_TYPE(XEN_LIST_P_WITH_LENGTH(arg2, listlen), arg2, 2, "XmTabListInsertTabs", "list of XmTab");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmTabListInsertTabs", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XmTabListInsertTabs", "int");
  len = XEN_TO_C_INT(arg3);
  if (len > listlen) len = listlen;
  if (len <= 0) return(XEN_FALSE);
  tabs = XEN_TO_C_XmTabs(arg2, len);
  tl = XmTabListInsertTabs(XEN_FALSE_P(arg1) ? NULL : XEN_TO_C_XmTabList(arg1), 
			   tabs, len, XEN_TO_C_INT(arg4));
  FREE(tabs);
  return(C_TO_XEN_XmTabList(tl));
}

static XEN gxm_XmTabListCopy(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmTabListCopy "XmTabList XmTabListCopy(XmTabList tablist, int offset, Cardinal count) creates \
a new tab list from an existing list"
  /* Motif documentation incorrectly calls this "XmTabListTabCopy" */
  XEN_ASSERT_TYPE(XEN_XmTabList_P(arg1), arg1, 1, "XmTabListCopy", "XmTabList");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTabListCopy", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmTabListCopy", "int");
  return(C_TO_XEN_XmTabList(XmTabListCopy(XEN_TO_C_XmTabList(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_INT(arg3))));
}

static XEN gxm_XmTabListTabCount(XEN arg1)
{
  #define H_XmTabListTabCount "Cardinal XmTabListTabCount(XmTabList tablist) returns length of tablist"
  XEN_ASSERT_TYPE(XEN_XmTabList_P(arg1), arg1, 1, "XmTabListTabCount", "XmTabList");  
  return(C_TO_XEN_INT(XmTabListTabCount(XEN_TO_C_XmTabList(arg1))));
}


static XEN gxm_XmTabListGetTab(XEN arg1, XEN arg2)
{
  #define H_XmTabListGetTab "XmTab XmTabListGetTab(XmTabList tablist, Cardinal position) returns a copy of a tab"
  XEN_ASSERT_TYPE(XEN_XmTabList_P(arg1), arg1, 1, "XmTabListGetTab", "XmTabList");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTabListGetTab", "int");
  return(C_TO_XEN_XmTab(XmTabListGetTab(XEN_TO_C_XmTabList(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XmTabListReplacePositions(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmTabListReplacePositions "XmTabList XmTabListReplacePositions(XmTabList oldlist, Cardinal *position_list, XmTab *tabs, Cardinal tab_count) \
creates a new tab list with replacement tabs"
  /* DIFF: XmTabListReplacePositions arg2 is list of ints, arg3 is list of XmTabs
   */
  Cardinal *ts;
  int len;
  XEN res;
  XmTab *tabs;
  XEN_ASSERT_TYPE(XEN_XmTabList_P(arg1), arg1, 1, "XmTabListReplacePositions", "XmTabList");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XmTabListReplacePositions", "list of ints");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg3), arg3, 3, "XmTabListReplacePositions", "list of XmTab");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg4), arg4, 4, "XmTabListReplacePositions", "int");
  if (XEN_INTEGER_P(arg4)) len = XEN_TO_C_INT(arg4); else len = XEN_LIST_LENGTH(arg3);
  if (len <= 0) return(XEN_FALSE);
  ts = XEN_TO_C_Cardinals(arg2, len);
  tabs = XEN_TO_C_XmTabs(arg3, len);
  res = C_TO_XEN_XmTabList(XmTabListReplacePositions(XEN_TO_C_XmTabList(arg1), ts, tabs, len));
  FREE(ts);
  FREE(tabs);
  return(res);
}

static XEN gxm_XmTabListRemoveTabs(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmTabListRemoveTabs "XmTabList XmTabListRemoveTabs(XmTabList oldlist, Cardinal *position_list, Cardinal position_count) \
removes noncontiguous tabs"
  /* DIFF: XmTabListRemoveTabs arg2 is list of ints
   */
  Cardinal *ts;
  int len;
  XEN res;
  XEN_ASSERT_TYPE(XEN_XmTabList_P(arg1), arg1, 1, "XmTabListRemoveTabs", "XmTabList");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XmTabListRemoveTabs", "list of int");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg3), arg3, 3, "XmTabListRemoveTabs", "int");
  if (XEN_INTEGER_P(arg3)) len = XEN_TO_C_INT(arg3); else len = XEN_LIST_LENGTH(arg2);
  if (len <= 0) return(XEN_FALSE);
  ts = XEN_TO_C_Cardinals(arg2, len);
  res = C_TO_XEN_XmTabList(XmTabListRemoveTabs(XEN_TO_C_XmTabList(arg1), ts, len));
  FREE(ts);
  return(res);
}

static XEN gxm_XmTabCreate(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XmTabCreate "XmTab XmTabCreate(float value, unsigned char units, XmOffsetModel offset_model, unsigned char alignment, char *decimal) \
creates a tab stop"
  XEN_ASSERT_TYPE(XEN_DOUBLE_P(arg1), arg1, 1, "XmTabCreate", "float");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTabCreate", "unsigned char");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmTabCreate", "XmOffsetModel"); 
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XmTabCreate", "unsigned char");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg5), arg5, 5, "XmTabCreate", "char*");
  return(C_TO_XEN_XmTab(XmTabCreate((float)XEN_TO_C_DOUBLE(arg1), 
				    (unsigned char)(XEN_TO_C_INT(arg2)),
				    (XmOffsetModel)XEN_TO_C_INT(arg3), 
				    (unsigned char)(XEN_TO_C_INT(arg4)),
				    XEN_TO_C_STRING(arg5))));
}

static XEN gxm_XmTabListFree(XEN arg1)
{
  #define H_XmTabListFree "void XmTabListFree(XmTabList tab) frees a tab list"
  XEN_ASSERT_TYPE(XEN_XmTabList_P(arg1), arg1, 1, "XmTabListFree", "XmTabList");
  XmTabListFree(XEN_TO_C_XmTabList(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmTabFree(XEN arg1)
{
  #define H_XmTabFree "void XmTabFree(XmTab tab) frees a tab"
  XEN_ASSERT_TYPE(XEN_XmTab_P(arg1), arg1, 1, "XmTabFree", "XmTab");
  XmTabFree(XEN_TO_C_XmTab(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmTabGetValues(XEN arg1)
{
  #define H_XmTabGetValues "float XmTabGetValues(XmTab tab) returns tab values"
  /* DIFF: XmTabGetValues tab [units offset align decimal] -> (list val units ofset align decimal)
     arg2/3/4/5 omit rtn with float 
  */
  XmOffsetModel off;
  unsigned char a1, a2;
  char **a3;
  float res;
  XEN val;
  XEN_ASSERT_TYPE(XEN_XmTab_P(arg1), arg1, 1, "XmTabGetValues", "XmTab");
  a3 = (char **)CALLOC(1, sizeof(char *));
  res = XmTabGetValues(XEN_TO_C_XmTab(arg1), &a1, &off, &a2, a3);
  val = XEN_LIST_5(C_TO_XEN_DOUBLE((double)res),
		   C_TO_XEN_INT((int)a1),
		   C_TO_XEN_INT((int)off),
		   C_TO_XEN_INT((int)a2),
		   C_TO_XEN_STRING(a3[0]));
  FREE(a3);
  return(val);
}

static XEN gxm_XmTabSetValue(XEN arg1, XEN arg2)
{
  #define H_XmTabSetValue "void XmTabSetValue(XmTab tab, float value) sets a tab stop"
  XEN_ASSERT_TYPE(XEN_XmTab_P(arg1), arg1, 1, "XmTabSetValue", "XmTab");
  XEN_ASSERT_TYPE(XEN_DOUBLE_P(arg2), arg2, 2, "XmTabSetValue", "float");
  XmTabSetValue(XEN_TO_C_XmTab(arg1), (float)XEN_TO_C_DOUBLE(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmStringTableProposeTablist(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XmStringTableProposeTablist "XmTabList XmStringTableProposeTablist(XmStringTable strings, Cardinal num_strings, Widget widget, \
float pad_value, XmOffsetModel offset_model) returns a tab list"
  /* DIFF: XmStringTableProposetablist 1st arg is list of XmStrings
   */
  XmStringTable tab;
  XmTabList tabl;
  XEN_ASSERT_TYPE(XEN_LIST_P(arg1), arg1, 1, "XmStringTableProposeTablist", "XmStringTable");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmStringTableProposeTablist", "int");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg3), arg3, 3, "XmStringTableProposeTablist", "Widget");
  XEN_ASSERT_TYPE(XEN_DOUBLE_P(arg4), arg4, 4, "XmStringTableProposeTablist", "float");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XmStringTableProposeTablist", "XmOffsetModel");
  tab = XEN_TO_C_XmStringTable(arg1, XEN_TO_C_INT(arg2)); 
  tabl = XmStringTableProposeTablist(tab,
				     XEN_TO_C_INT(arg2), 
				     XEN_TO_C_Widget(arg3),
				     (float)XEN_TO_C_DOUBLE(arg4), 
				     (XmOffsetModel)XEN_TO_C_INT(arg5));
  FREE(tab);
  return(C_TO_XEN_XmTabList(tabl));
}

#define XEN_XmParseTable_P(Arg) XEN_LIST_P(Arg)

static XmParseTable XEN_TO_C_XmParseTable(XEN lst, int size)
{
  int i;
  XmParseTable pt;
  if (size <= 0) return(NULL);
  pt = (XmParseTable)XtCalloc(size, sizeof(XmParseMapping));
  for (i = 0; i < size; i++)
    {
      XEN val;
      val = XEN_LIST_REF(lst, i);
      if (XEN_XmParseMapping_P(val))
	pt[i] = XEN_TO_C_XmParseMapping(val);
      else XEN_ASSERT_TYPE(0, val, i, c__FUNCTION__, "an XmParseMapping");
    }
  return(pt);
}

static XEN gxm_XmParseTableFree(XEN arg1, XEN arg2)
{
  #define H_XmParseTableFree "void XmParseTableFree(XmParseTable parse_table, Cardinal count) recovers memory"
  XEN_ASSERT_TYPE(XEN_XmParseTable_P(arg1), arg1, 1, "XmParseTableFree", "XmParseTable");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg2), arg2, 2, "XmParseTableFree", "int");
  /* can't happen -- a no-op */
  return(XEN_FALSE);
}

static XEN gxm_XmParseMappingFree(XEN arg1)
{
  #define H_XmParseMappingFree "void XmParseMappingFree(XmParseMapping parse_mapping) frees a parse mapping"
  XEN_ASSERT_TYPE(XEN_XmParseMapping_P(arg1), arg1, 1, "XmParseMappingFree", "XmParseMapping");
  XmParseMappingFree(XEN_TO_C_XmParseMapping(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmParseMappingGetValues(XEN arg1, XEN larg2, XEN arg3)
{
  #define H_XmParseMappingGetValues "void XmParseMappingGetValues(XmParseMapping parse_mapping, ArgList arglist, Cardinal argcount) \
retrieves attributes of a parse mapping"
  XEN_ASSERT_TYPE(XEN_XmParseMapping_P(arg1), arg1, 1, "XmParseMappingGetValues", "XmParseMapping");
  XEN_ASSERT_TYPE(XEN_LIST_P(larg2), larg2, 2, "XmParseMappingGetValues", "ArgList");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg3), arg3, 3, "XmParseMappingGetValues", "int");
  {
    Arg *args;
    unsigned long *locs;
    int len, gcloc;
    XEN val, arg2;
    int i;
    len = XEN_TO_C_INT_DEF(arg3, larg2);
    arg2 = XEN_COPY_ARG(larg2);
    gcloc = xm_protect(arg2);
    args = (Arg *)CALLOC(len, sizeof(Arg));
    locs = (unsigned long *)CALLOC(len, sizeof(unsigned long));
    for (i = 0; i < len; i++, arg2 = XEN_CDDR(arg2))
      {
	char *name;
	name = strdup(XEN_TO_C_STRING(XEN_CAR(arg2)));
	XtSetArg(args[i], name, &(locs[i]));
      }
    XmParseMappingGetValues(XEN_TO_C_XmParseMapping(arg1), args, len);
    val = C_TO_XEN_Args(NULL, args, len);
    free_args(args, len);
    FREE(locs);
    xm_unprotect_at(gcloc);
    return(xen_return_first(val, larg2));
  }
}

static XEN gxm_XmParseMappingSetValues(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmParseMappingSetValues "void XmParseMappingSetValues(XmParseMapping parse_mapping, ArgList arglist, Cardinal argcount) \
sets attributes of a parse mapping"
  XEN_ASSERT_TYPE(XEN_XmParseMapping_P(arg1), arg1, 1, "XmParseMappingSetValues", "XmParseMapping");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XmParseMappingSetValues", "ArgList");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg3), arg3, 3, "XmParseMappingSetValues", "int");
  {
    Arg *args;
    int arglen;
    args = XEN_TO_C_Args(arg2);
    arglen = XEN_TO_C_INT_DEF(arg3, arg2);
    XmParseMappingSetValues(XEN_TO_C_XmParseMapping(arg1), args, arglen);
    if (args) free_args(args, arglen);
    return(XEN_FALSE);
  }
}

static XEN gxm_XmParseMappingCreate(XEN arg1, XEN arg2)
{
  #define H_XmParseMappingCreate "XmParseMapping XmParseMappingCreate(ArgList arglist, Cardinal argcount) create a parse mapping"
  XmParseMapping w;
  XEN_ASSERT_TYPE(XEN_LIST_P(arg1), arg1, 1, "XmParseMappingCreate", "ArgList");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg2), arg2, 2, "XmParseMappingCreate", "int");
  {
    Arg *args;
    int arglen;
    args = XEN_TO_C_Args(arg1);
    arglen = XEN_TO_C_INT_DEF(arg2, arg1);
    w = XmParseMappingCreate(args, arglen);
    if (args) free_args(args, arglen);
  }
  return(C_TO_XEN_XmParseMapping(w));
}

static XEN gxm_XmCvtXmStringToByteStream(XEN str)
{
  #define H_XmCvtXmStringToByteStream "int XmCvtXmStringToByteStream(XmString str) converts an XmString into a byte stream."
  unsigned char *prop = NULL;
  int res = 0; /* #bytes in returned val */
  XmString xstr;
  XEN_ASSERT_TYPE(XEN_XmString_P(str), str, XEN_ONLY_ARG, "XmCvtXmStringToByteStream", "XmString");
  xstr = XEN_TO_C_XmString(str);
  if (!(XmStringEmpty(xstr)))
    res = XmCvtXmStringToByteStream(xstr, &prop);
  /* here there is apparently no trailing 0, so this function worries Valgrind */
  return(XEN_LIST_2(C_TO_XEN_INT(res), C_TO_XEN_STRING((const char *)prop)));
}

static XEN gxm_XmCvtByteStreamToXmString(XEN str)
{
  #define H_XmCvtByteStreamToXmString "XmString XmCvtByteStreamToXmString(char *str) converts a byte stream into an XmString."
  XmString res = NULL;
  char *bstr;
  XEN_ASSERT_TYPE(XEN_STRING_P(str), str, XEN_ONLY_ARG, "XmCvtByteStreamToXmString", "char *");
  bstr = XEN_TO_C_STRING(str);
  if (bstr)
    res = XmCvtByteStreamToXmString((unsigned char *)(XEN_TO_C_STRING(str)));
  return(C_TO_XEN_XmString(res));
}

static XEN gxm_XmStringByteStreamLength(XEN str)
{
  #define H_XmStringByteStreamLength "int XmStringByteStreamLength(char *str) returns the length of the byte stream."
  int res;
  XEN_ASSERT_TYPE(XEN_STRING_P(str), str, XEN_ONLY_ARG, "XmStringByteStreamLength", "char *");
  res = (int)XmStringByteStreamLength((unsigned char *)(XEN_TO_C_STRING(str)));
  return(C_TO_XEN_INT(res));
}

static XEN gxm_XmStringPutRendition(XEN arg1, XEN arg2)
{
  #define H_XmStringPutRendition "XmString XmStringPutRendition(XmString string, XmStringTag rendition) places \
renditions around strings"
  XEN_ASSERT_TYPE(XEN_XmString_P(arg1), arg1, 1, "XmStringPutRendition", "XmString");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmStringPutRendition", "XmStringTag");
  return(C_TO_XEN_XmString(XmStringPutRendition(XEN_TO_C_XmString(arg1), XEN_TO_C_STRING(arg2))));
}

static XEN gxm_XmStringGenerate(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmStringGenerate "XmString XmStringGenerate(XtPointer text, XmStringTag tag, XmTextType type, XmStringTag rendition) \
generates a compound string"

  XmTextType type;
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XmStringGenerate", "XtPointer");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2) || XEN_FALSE_P(arg2), arg2, 2, "XmStringGenerate", "XmStringTag");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmStringGenerate", "XmTextType");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg4), arg4, 4, "XmStringGenerate", "XmStringTag");
  type = (XmTextType)XEN_TO_C_INT(arg3);
  if (type > 1) XEN_ASSERT_TYPE(0, arg3, 3, "XmStringGenerate", "XmTextType");
  return(C_TO_XEN_XmString(XmStringGenerate((XtPointer)XEN_TO_C_STRING(arg1), 
					    XEN_FALSE_P(arg2) ? NULL : XEN_TO_C_STRING(arg2), 
					    type,
					    XEN_TO_C_STRING(arg4))));
}

static XEN gxm_XmStringDirectionToDirection(XEN arg1)
{
  #define H_XmStringDirectionToDirection "XmDirection XmStringDirectionToDirection(XmStringDirection direction) converts \
from XmStringDirection to XmDirection"
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg1), arg1, 1, "XmStringDirectionToDirection", "XmStringDirection");
  return(C_TO_XEN_INT(XmStringDirectionToDirection(XEN_TO_C_INT(arg1))));
}

static XEN gxm_XmDirectionToStringDirection(XEN arg1)
{
  #define H_XmDirectionToStringDirection "XmStringDirection XmDirectionToStringDirection (dir) converts an XmDirection \
value to an XmStringDirection value"
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg1), arg1, 1, "XmDirectionToStringDirection", "XmDirection");
  return(C_TO_XEN_INT(XmDirectionToStringDirection(XEN_TO_C_INT(arg1))));
}

static XEN gxm_XmStringTableParseStringArray(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7)
{
  #define H_XmStringTableParseStringArray "XmStringTable XmStringTableParseStringArray(XtPointer *strings, Cardinal count, XmStringTag tag, \
XmTextType type, XmParseTable parse, Cardinal parse_count, XtPointer call_data) converts an array of strings \
to a compound string table"
  /* DIFF: XmStringTableParseStringArray arg1 is list of strings
   */
  char **strs;
  int len;
  XmStringTable val;
  XmParseTable pt = NULL;
  XEN lst;
  XmTextType type;
  XEN_ASSERT_TYPE(XEN_LIST_P(arg1), arg1, 1, "XmStringTableParseStringArray", "list of strings");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmStringTableParseStringArray", "int");
  XEN_ASSERT_TYPE(XEN_FALSE_P(arg3) || XEN_STRING_P(arg3), arg3, 3, "XmStringTableParseStringArray", "XmStringTag");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XmStringTableParseStringArray", "XmTextType");
  XEN_ASSERT_TYPE(XEN_FALSE_P(arg5) || XEN_XmParseTable_P(arg5), arg5, 5, "XmStringTableParseStringArray", "XmParseTable");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XmStringTableParseStringArray", "int");
  type = (XmTextType)XEN_TO_C_INT(arg4);
  if (type > 1) XEN_ASSERT_TYPE(0, arg4, 4, "XmStringTableParseStringArray", "XmTextType");
  len = XEN_TO_C_INT(arg2);
  if (len <= 0) return(XEN_FALSE);
  strs = XEN_TO_C_Strings(arg1, len);
  if (XEN_XmParseTable_P(arg5)) pt = XEN_TO_C_XmParseTable(arg5, len);
  val = XmStringTableParseStringArray((XtPointer *)strs, 
				      (Cardinal)len, 
				      (XEN_FALSE_P(arg3)) ? NULL : XEN_TO_C_STRING(arg3),
				      type,
				      pt,
				      XEN_TO_C_INT(arg6),
				      (XtPointer)arg7);
  FREE(strs);
  lst = C_TO_XEN_XmStringTable(val, len);
  free(val);
  if (pt) free(pt); 
  return(xen_return_first(lst, arg1));
}

static XEN gxm_XmStringTableUnparse(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7, XEN arg8)
{
  #define H_XmStringTableUnparse "XtPointer *XmStringTableUnparse(XmStringTable table, Cardinal count, XmStringTag tag, XmTextType tag_type, \
XmTextType output_type, XmParseTable parse, Cardinal parse_count, XmParseModel parse_model) converts a table of \
compound strings to an array of text"
  /* DIFF: XmStringTableUnparse returns list of strings, 1st arg is list of XmStrings
   */
  XEN lst = XEN_EMPTY_LIST;
  char **tab;
  XmStringTable tb;
  int i, len, loc;
  XmTextType type1, type2;
  XmParseTable pt = NULL;
  XEN_ASSERT_TYPE(XEN_LIST_P(arg1), arg1, 1, "XmStringTableUnparse", "XmStringTable");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmStringTableUnparse", "int");
  XEN_ASSERT_TYPE(XEN_FALSE_P(arg3) || XEN_STRING_P(arg3), arg3, 3, "XmStringTableUnparse", "XmStringTag");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XmStringTableUnparse", "XmTextType");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XmStringTableUnparse", "XmTextType");
  XEN_ASSERT_TYPE(XEN_FALSE_P(arg6) || XEN_XmParseTable_P(arg6), arg6, 6, "XmStringTableUnparse", "XmParseTable");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg7), arg7, 7, "XmStringTableUnparse", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg8), arg8, 8, "XmStringTableUnparse", "XmParseModel");
  type1 = (XmTextType)XEN_TO_C_INT(arg4);
  if (type1 > 1) XEN_ASSERT_TYPE(0, arg4, 4, "XmStringTableUnparse", "XmTextType");
  type2 = (XmTextType)XEN_TO_C_INT(arg5);
  if (type2 > 1) XEN_ASSERT_TYPE(0, arg5, 5, "XmStringTableUnparse", "XmTextType");
  len = XEN_TO_C_INT(arg2);
  if (len <= 0) return(XEN_FALSE);
  loc = xm_protect(lst);
  tb = XEN_TO_C_XmStringTable(arg1, len);
  if (XEN_XmParseTable_P(arg6)) pt = XEN_TO_C_XmParseTable(arg6, len);
  tab = (char **)XmStringTableUnparse(tb,
				      len, 
				      (XEN_FALSE_P(arg3)) ? NULL : XEN_TO_C_STRING(arg3), 
				      type1,
				      type2,
				      pt,
				      XEN_TO_C_INT(arg7), 
				      (XmParseModel)XEN_TO_C_INT(arg8));
  FREE(tb);
  for (i = len - 1; i >= 0; i--)
    {
      lst = XEN_CONS(C_TO_XEN_STRING(tab[i]), lst);
      free(tab[i]);
    }
  free(tab);
  if (pt) free(pt);
  xm_unprotect_at(loc);
  return(lst);
}

static XEN gxm_XmStringTableToXmString(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmStringTableToXmString "XmString XmStringTableToXmString(XmStringTable table, Cardinal count, XmString break_component) \
converts a compound string table to a single compound string"
  /* DIFF: XmStringTableToXmString 1st arg is list of XmStrings
   */
  int count;
  XmStringTable tab;
  XmString val;
  XEN_ASSERT_TYPE(XEN_LIST_P(arg1), arg1, 1, "XmStringTableToXmString", "XmStringTable");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmStringTableToXmString", "int");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg3) || XEN_FALSE_P(arg3), arg3, 3, "XmStringTableToXmString", "XmString");
  count = XEN_TO_C_INT(arg2);
  if (count <= 0) return(XEN_FALSE);
  tab = XEN_TO_C_XmStringTable(arg1, count);
  val = XmStringTableToXmString(tab,
				count,
				(XEN_XmString_P(arg3)) ? XEN_TO_C_XmString(arg3) : NULL);
  FREE(tab);
  return(C_TO_XEN_XmString(val));
}

static XEN gxm_XmStringToXmStringTable(XEN arg1, XEN arg2)
{
  #define H_XmStringToXmStringTable "Cardinal XmStringToXmStringTable(XmString string, XmString break_component) \
converts a single compound string to a table of compound strings"
  /* DIFF: XmStringToXmStringTable omits and rtns (list len table)
   */
  XmStringTable tab;
  Cardinal val;
  XEN_ASSERT_TYPE(XEN_XmString_P(arg1), arg1, 1, "XmStringToXmStringTable", "XmString");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2) || XEN_FALSE_P(arg2), arg2, 2, "XmStringToXmStringTable", "XmString");
  val = XmStringToXmStringTable(XEN_TO_C_XmString(arg1), 
				(XEN_XmString_P(arg2)) ? XEN_TO_C_XmString(arg2) : NULL,
				&tab);
  return(XEN_LIST_2(C_TO_XEN_INT(val), C_TO_XEN_XmStringTable(tab, val)));
}

static XEN gxm_XmStringParseText(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7)
{
  #define H_XmStringParseText "XmString XmStringParseText(XtPointer text, XtPointer *text_end, XmStringTag tag, XmTextType type, \
XmParseTable parse_table, Cardinal parse_count, XtPointer call_data) converts a character string to a compound string"
  /* DIFF: XmStringParseText arg1 is string, arg2 is int
   */
  int loc, len;
  char *str, *tag = NULL;
  XmTextType type;
  XtPointer *intext = NULL;
  XmParseTable pt = NULL;
  XEN rtn;
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XmStringParseText", "string");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2) || XEN_FALSE_P(arg2), arg2, 2, "XmStringParseText", "int");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3) || XEN_FALSE_P(arg3), arg3, 3, "XmStringParseText", "XmStringTag");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XmStringParseText", "XmTextType");
  XEN_ASSERT_TYPE(XEN_XmParseTable_P(arg5), arg5, 5, "XmStringParseText", "XmParseTable");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XmStringParseText", "int");
  type = (XmTextType)XEN_TO_C_INT(arg4);
  if (type > 1) XEN_ASSERT_TYPE(0, arg4, 4, "XmStringParseText", "XmTextType");
  str = XEN_TO_C_STRING(arg1);
  if (XEN_INTEGER_P(arg2)) 
    {
      loc = XEN_TO_C_INT(arg2);
      intext = (XtPointer *)(str + loc);
    }
  if (XEN_STRING_P(arg3)) tag = XEN_TO_C_STRING(arg3);
  len = XEN_TO_C_INT(arg6);
  if (XEN_XmParseTable_P(arg5)) pt = XEN_TO_C_XmParseTable(arg5, len);
  rtn = C_TO_XEN_XmString(XmStringParseText(str, intext, tag, type, pt, len, (XtPointer)arg7));
  if (pt) free(pt);
  return(xen_return_first(rtn, arg1, arg2));
}

static XEN gxm_XmStringUnparse(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7)
{
  #define H_XmStringUnparse "XtPointer XmStringUnparse(XmString string, XmStringTag tag, XmTextType tag_type, XmTextType output_type, \
XmParseTable parse_table, Cardinal parse_count, XmParseModel parse_model) unparses text"
  XmTextType type1, type2;
  XEN rtn;
  char *str;
  XmParseTable pt = NULL;
  int len;
  XEN_ASSERT_TYPE(XEN_XmString_P(arg1), arg1, 1, "XmStringUnparse", "XmString");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2) || XEN_FALSE_P(arg2), arg2, 2, "XmStringUnparse", "XmStringTag or " PROC_FALSE);
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmStringUnparse", "XmTextType");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XmStringUnparse", "XmTextType");
  XEN_ASSERT_TYPE(XEN_XmParseTable_P(arg5) || XEN_FALSE_P(arg5), arg5, 5, "XmStringUnparse", "XmParseTable");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XmStringUnparse", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg7), arg7, 7, "XmStringUnparse", "XmParseModel");
  type1 = (XmTextType)XEN_TO_C_INT(arg3);
  if (type1 > 1) XEN_ASSERT_TYPE(0, arg3, 3, "XmStringUnparse", "XmTextType");
  type2 = (XmTextType)XEN_TO_C_INT(arg4);
  if (type2 > 1) XEN_ASSERT_TYPE(0, arg4, 4, "XmStringUnparse", "XmTextType");
  len = XEN_TO_C_INT(arg6);
  if (XEN_XmParseTable_P(arg5)) pt = XEN_TO_C_XmParseTable(arg5, len);
  str = (char *)XmStringUnparse(XEN_TO_C_XmString(arg1), 
				(XEN_STRING_P(arg2)) ? XEN_TO_C_STRING(arg2) : NULL,
				type1, type2, pt, len,
				(XmParseModel)XEN_TO_C_INT(arg7));
  rtn = C_TO_XEN_STRING(str);
  if (str) XtFree(str);
  if (pt) free(pt);
  return(rtn);
}

static XEN gxm_XmStringComponentCreate(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmStringComponentCreate "XmString XmStringComponentCreate(XmStringComponentType c_type, unsigned int length, XtPointer value) \
creates arbitrary components"
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg1), arg1, 1, "XmStringComponentCreate", "XmStringComponentType");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XmStringComponentCreate", "unsigned int");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3) || XEN_FALSE_P(arg3), arg3, 3, "XmStringComponentCreate", "XtPointer");
  return(C_TO_XEN_XmString(XmStringComponentCreate(XEN_TO_C_INT(arg1), 
						   XEN_TO_C_ULONG(arg2), 
						   XEN_FALSE_P(arg3) ? NULL : XEN_TO_C_STRING(arg3))));
}

static XEN gxm_XmStringGetNextTriple(XEN arg1)
{
  #define H_XmStringGetNextTriple "XmStringComponentType XmStringGetNextTriple(XmStringContext context) \
returns the type, length, and value of the next component in the compound string"
  /* DIFF: XmStringGetNextTriple omits last 2 args, returns val
   */
  unsigned int len;
  int val;
  XtPointer *ptr = NULL;
  XEN_ASSERT_TYPE(XEN_XmStringContext_P(arg1), arg1, 1, "XmStringGetNextTriple", "XmStringContext");
  val = XmStringGetNextTriple(XEN_TO_C_XmStringContext(arg1), &len, ptr);
  return(XEN_LIST_3(C_TO_XEN_INT(val),
		    C_TO_XEN_INT((int)len),
		    (val == XmSTRING_COMPONENT_TEXT) ? C_TO_XEN_STRING((char *)(*ptr)) : C_TO_XEN_ULONG((unsigned long)ptr)));
}

static XEN gxm_XmStringPeekNextTriple(XEN arg1)
{
  #define H_XmStringPeekNextTriple "XmStringComponentType XmStringPeekNextTriple(XmStringContext context) returns the \
component type of the next component"
  XEN_ASSERT_TYPE(XEN_XmStringContext_P(arg1), arg1, 1, "XmStringPeekNextTriple", "XmStringContext");
  return(C_TO_XEN_INT(XmStringPeekNextTriple(XEN_TO_C_XmStringContext(arg1))));
}

static XEN gxm_XmStringDrawUnderline(XEN args)
{
  #define H_XmStringDrawUnderline "void XmStringDrawUnderline(Display *d, Window w, XmRenderTable rendertable, XmString string, GC gc, \
Position x, Position y, Dimension width, unsigned char alignment, unsigned char layout_direction, XRectangle *clip, XmString underline) \
underlines a string drawn in an X Window"
  XEN arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12;
  arg1 = XEN_LIST_REF(args, 0);
  arg2 = XEN_LIST_REF(args, 1);
  arg3 = XEN_LIST_REF(args, 2);
  arg4 = XEN_LIST_REF(args, 3);
  arg5 = XEN_LIST_REF(args, 4);
  arg6 = XEN_LIST_REF(args, 5);
  arg7 = XEN_LIST_REF(args, 6);
  arg8 = XEN_LIST_REF(args, 7);
  arg9 = XEN_LIST_REF(args, 8);
  arg10 = XEN_LIST_REF(args, 9);
  arg11 = XEN_LIST_REF(args, 10);
  arg12 = XEN_LIST_REF(args, 11);
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmStringDrawUnderline", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XmStringDrawUnderline", "Window");
  XEN_ASSERT_TYPE(XEN_XmFontList_or_XmRenderTable_P(arg3), arg3, 3, "XmStringDrawUnderline", "XmFontList");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg4), arg4, 4, "XmStringDrawUnderline", "XmString");
  XEN_ASSERT_TYPE(XEN_GC_P(arg5), arg5, 5, "XmStringDrawUnderline", "GC");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XmStringDrawUnderline", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg7), arg7, 7, "XmStringDrawUnderline", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg8), arg8, 8, "XmStringDrawUnderline", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg9), arg9, 9, "XmStringDrawUnderline", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg10), arg10, 10, "XmStringDrawUnderline", "unsigned int");
  XEN_ASSERT_TYPE(XEN_XRectangle_P(arg11), arg11, 11, "XmStringDrawUnderline", "XRectangle");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg12), arg12, 12, "XmStringDrawUnderline", "XmString");
  XmStringDrawUnderline(XEN_TO_C_Display(arg1), 
			XEN_TO_C_Window(arg2), 
			XEN_TO_C_XmFontList(arg3), 
			XEN_TO_C_XmString(arg4), 
			XEN_TO_C_GC(arg5), 
			XEN_TO_C_INT(arg6), XEN_TO_C_INT(arg7), XEN_TO_C_INT(arg8), 
			XEN_TO_C_ULONG(arg9), XEN_TO_C_ULONG(arg10), 
			XEN_TO_C_XRectangle(arg11), 
			XEN_TO_C_XmString(arg12));
  return(XEN_FALSE);
}

static XEN gxm_XmStringDrawImage(XEN args)
{
  #define H_XmStringDrawImage "void XmStringDrawImage(Display *d, Window w, XmRenderTable rendertable, XmString string, GC gc, Position x, \
Position y, Dimension width, unsigned char alignment, unsigned char layout_direction, XRectangle *clip) \
draws a compound string in an X Window and creates an image"
  XEN arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11;
  arg1 = XEN_LIST_REF(args, 0);
  arg2 = XEN_LIST_REF(args, 1);
  arg3 = XEN_LIST_REF(args, 2);
  arg4 = XEN_LIST_REF(args, 3);
  arg5 = XEN_LIST_REF(args, 4);
  arg6 = XEN_LIST_REF(args, 5);
  arg7 = XEN_LIST_REF(args, 6);
  arg8 = XEN_LIST_REF(args, 7);
  arg9 = XEN_LIST_REF(args, 8);
  arg10 = XEN_LIST_REF(args, 9);
  arg11 = XEN_LIST_REF(args, 10);
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmStringDrawImage", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XmStringDrawImage", "Window");
  XEN_ASSERT_TYPE(XEN_XmFontList_or_XmRenderTable_P(arg3), arg3, 3, "XmStringDrawImage", "XmFontList");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg4), arg4, 4, "XmStringDrawImage", "XmString");
  XEN_ASSERT_TYPE(XEN_GC_P(arg5), arg5, 5, "XmStringDrawImage", "GC");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XmStringDrawImage", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg7), arg7, 7, "XmStringDrawImage", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg8), arg8, 8, "XmStringDrawImage", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg9), arg9, 9, "XmStringDrawImage", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg10), arg10, 10, "XmStringDrawImage", "unsigned int");
  XEN_ASSERT_TYPE(XEN_XRectangle_P(arg11), arg11, 11, "XmStringDrawImage", "XRectangle*");
  XmStringDrawImage(XEN_TO_C_Display(arg1), 
		    XEN_TO_C_Window(arg2), 
		    XEN_TO_C_XmFontList(arg3), 
		    XEN_TO_C_XmString(arg4), 
		    XEN_TO_C_GC(arg5), 
		    XEN_TO_C_INT(arg6), XEN_TO_C_INT(arg7), XEN_TO_C_INT(arg8), 
		    XEN_TO_C_ULONG(arg9), XEN_TO_C_ULONG(arg10), 
		    XEN_TO_C_XRectangle(arg11));
  return(XEN_FALSE);
}

static XEN gxm_XmStringDraw(XEN args)
{
  #define H_XmStringDraw "void XmStringDraw(Display *d, Window w, XmRenderTable rendertable, XmString string, GC gc, Position x, Position y, \
Dimension width, unsigned char alignment, unsigned char layout_direction, XRectangle *clip) draws a compound \
string in an X window"
  XEN arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11;
  arg1 = XEN_LIST_REF(args, 0);
  arg2 = XEN_LIST_REF(args, 1);
  arg3 = XEN_LIST_REF(args, 2);
  arg4 = XEN_LIST_REF(args, 3);
  arg5 = XEN_LIST_REF(args, 4);
  arg6 = XEN_LIST_REF(args, 5);
  arg7 = XEN_LIST_REF(args, 6);
  arg8 = XEN_LIST_REF(args, 7);
  arg9 = XEN_LIST_REF(args, 8);
  arg10 = XEN_LIST_REF(args, 9);
  arg11 = XEN_LIST_REF(args, 10);
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmStringDraw", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XmStringDraw", "Window");
  XEN_ASSERT_TYPE(XEN_XmFontList_or_XmRenderTable_P(arg3), arg3, 3, "XmStringDraw", "XmFontList");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg4), arg4, 4, "XmStringDraw", "XmString");
  XEN_ASSERT_TYPE(XEN_GC_P(arg5), arg5, 5, "XmStringDraw", "GC");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XmStringDraw", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg7), arg7, 7, "XmStringDraw", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg8), arg8, 8, "XmStringDraw", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg9), arg9, 9, "XmStringDraw", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg10), arg10, 10, "XmStringDraw", "unsigned int");
  XEN_ASSERT_TYPE(XEN_XRectangle_P(arg11), arg11, 11, "XmStringDraw", "XRectangle*");
  XmStringDraw(XEN_TO_C_Display(arg1), 
	       XEN_TO_C_Window(arg2), 
	       XEN_TO_C_XmFontList(arg3), 
	       XEN_TO_C_XmString(arg4), 
	       XEN_TO_C_GC(arg5), 
	       XEN_TO_C_INT(arg6), XEN_TO_C_INT(arg7), XEN_TO_C_INT(arg8), 
	       XEN_TO_C_ULONG(arg9), XEN_TO_C_ULONG(arg10), 
	       XEN_TO_C_XRectangle(arg11));
  return(XEN_FALSE);
}

static XEN gxm_XmStringLineCount(XEN arg1)
{
  #define H_XmStringLineCount "int XmStringLineCount(XmString string) returns the number of separators plus one \
in the provided compound string"
  XEN_ASSERT_TYPE(XEN_XmString_P(arg1), arg1, 1, "XmStringLineCount", "XmString");
  return(C_TO_XEN_INT(XmStringLineCount(XEN_TO_C_XmString(arg1))));
}

static XEN gxm_XmStringExtent(XEN arg1, XEN arg2)
{
  #define H_XmStringExtent "void XmStringExtent(XmRenderTable rendertable, XmString string) \
determines the size of the smallest rectangle that will enclose the compound string"
  /* DIFF: XmStringExtent omits and returns the last 2 args
   */
  Dimension w, h;
  XEN_ASSERT_TYPE(XEN_XmFontList_or_XmRenderTable_P(arg1), arg1, 1, "XmStringExtent", "XmFontList");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmStringExtent", "XmString");
  XmStringExtent(XEN_TO_C_XmFontList(arg1), XEN_TO_C_XmString(arg2), &w, &h);
  return(XEN_LIST_2(C_TO_XEN_Dimension(w),
		    C_TO_XEN_Dimension(h)));
}

static XEN gxm_XmStringHeight(XEN arg1, XEN arg2)
{
  #define H_XmStringHeight "Dimension XmStringHeight(XmRenderTable rendertable, XmString string) returns the line \
height of the given compound string"
  XEN_ASSERT_TYPE(XEN_XmFontList_or_XmRenderTable_P(arg1), arg1, 1, "XmStringHeight", "XmFontList");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmStringHeight", "XmString");
  return(C_TO_XEN_Dimension(XmStringHeight(XEN_TO_C_XmFontList(arg1), XEN_TO_C_XmString(arg2))));
}

static XEN gxm_XmStringWidth(XEN arg1, XEN arg2)
{
  #define H_XmStringWidth "Dimension XmStringWidth(XmRenderTable rendertable, XmString string) returns \
the width of the widest line in a compound string"
  XEN_ASSERT_TYPE(XEN_XmFontList_or_XmRenderTable_P(arg1), arg1, 1, "XmStringWidth", "XmFontList");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmStringWidth", "XmString");
  return(C_TO_XEN_Dimension(XmStringWidth(XEN_TO_C_XmFontList(arg1), XEN_TO_C_XmString(arg2))));
}

static XEN gxm_XmStringBaseline(XEN arg1, XEN arg2)
{
  #define H_XmStringBaseline "Dimension XmStringBaseline(XmRenderTable rendertable, XmString string) returns \
the number of pixels between \
the top of the character box and the baseline of the first line of text"
  XEN_ASSERT_TYPE(XEN_XmFontList_or_XmRenderTable_P(arg1), arg1, 1, "XmStringBaseline", "XmFontList");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmStringBaseline", "XmString");
  return(C_TO_XEN_Dimension(XmStringBaseline(XEN_TO_C_XmFontList(arg1), XEN_TO_C_XmString(arg2))));
}

static XEN gxm_XmStringFree(XEN arg1)
{
  #define H_XmStringFree "void XmStringFree(XmString string) conditionally deallocates memory"
  XEN_ASSERT_TYPE(XEN_XmString_P(arg1), arg1, 1, "XmStringFree", "XmString");
  XmStringFree(XEN_TO_C_XmString(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmStringHasSubstring(XEN arg1, XEN arg2)
{
  #define H_XmStringHasSubstring "Boolean XmStringHasSubstring(XmString string, XmString substring) indicates \
whether one compound string is contained within another"
  XEN_ASSERT_TYPE(XEN_XmString_P(arg1), arg1, 1, "XmStringHasSubstring", "XmString");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmStringHasSubstring", "XmString");
  return(C_TO_XEN_BOOLEAN(XmStringHasSubstring(XEN_TO_C_XmString(arg1), XEN_TO_C_XmString(arg2))));
}

static XEN gxm_XmStringIsVoid(XEN arg1)
{
  #define H_XmStringIsVoid "Boolean XmStringIsVoid(XmString s1) provides information on the existence of non-zero-length text \
components, tab components, or separator components"
  XEN_ASSERT_TYPE(XEN_XmString_P(arg1), arg1, 1, "XmStringIsVoid", "XmString");
  return(C_TO_XEN_BOOLEAN(XmStringIsVoid(XEN_TO_C_XmString(arg1))));
}

static XEN gxm_XmStringEmpty(XEN arg1)
{
  #define H_XmStringEmpty "Boolean XmStringEmpty(XmString s1) provides information on the existence of \
non-zero-length text components"
  XEN_ASSERT_TYPE(XEN_XmString_P(arg1), arg1, 1, "XmStringEmpty", "XmString");
  return(C_TO_XEN_BOOLEAN(XmStringEmpty(XEN_TO_C_XmString(arg1))));
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XmStringLength(XEN arg1)
{
  #define H_XmStringLength "int XmStringLength(XmString s1) obtains the length of a compound string"
  XEN_ASSERT_TYPE(XEN_XmString_P(arg1), arg1, 1, "XmStringLength", "XmString");
  return(C_TO_XEN_INT(XmStringLength(XEN_TO_C_XmString(arg1))));
}
#endif

static XEN gxm_XmStringCompare(XEN arg1, XEN arg2)
{
  #define H_XmStringCompare "Boolean XmStringCompare(XmString s1, XmString s2) compares two strings"
  XEN_ASSERT_TYPE(XEN_XmString_P(arg1), arg1, 1, "XmStringCompare", "XmString");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmStringCompare", "XmString");
  return(C_TO_XEN_BOOLEAN(XmStringCompare(XEN_TO_C_XmString(arg1), XEN_TO_C_XmString(arg2))));
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XmStringByteCompare(XEN arg1, XEN arg2)
{
  #define H_XmStringByteCompare "Boolean XmStringByteCompare(XmString s1, XmString s2) indicates the results of a \
byte-by-byte comparison"
  XEN_ASSERT_TYPE(XEN_XmString_P(arg1), arg1, 1, "XmStringByteCompare", "XmString");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmStringByteCompare", "XmString");
  return(C_TO_XEN_BOOLEAN(XmStringByteCompare(XEN_TO_C_XmString(arg1), XEN_TO_C_XmString(arg2))));
}

static XEN gxm_XmStringNCopy(XEN arg1, XEN arg2)
{
  #define H_XmStringNCopy "XmString XmStringNCopy(XmString s1, int num_bytes) creates a copy of a compound string"
  XEN_ASSERT_TYPE(XEN_XmString_P(arg1), arg1, 1, "XmStringNCopy", "XmString");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmStringNCopy", "int");
  return(C_TO_XEN_XmString(XmStringNCopy(XEN_TO_C_XmString(arg1), XEN_TO_C_INT(arg2))));
}
#endif

static XEN gxm_XmStringCopy(XEN arg1)
{
  #define H_XmStringCopy "XmString XmStringCopy(XmString s1)  makes a copy of a string"
  XEN_ASSERT_TYPE(XEN_XmString_P(arg1), arg1, 1, "XmStringCopy", "XmString");
  return(C_TO_XEN_XmString(XmStringCopy(XEN_TO_C_XmString(arg1))));
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XmStringNConcat(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmStringNConcat "XmString XmStringNConcat(XmString s1, XmString s2, int num_bytes) appends a specified \
number of bytes to a compound string"
  XEN_ASSERT_TYPE(XEN_XmString_P(arg1), arg1, 1, "XmStringNConcat", "XmString");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmStringNConcat", "XmString");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmStringNConcat", "int");
  return(C_TO_XEN_XmString(XmStringNConcat(XEN_TO_C_XmString(arg1), XEN_TO_C_XmString(arg2), XEN_TO_C_INT(arg3))));
}
#endif

static XEN gxm_XmStringConcatAndFree(XEN arg1, XEN arg2)
{
  #define H_XmStringConcatAndFree "XmString XmStringConcatAndFree(XmString s1, XmString s2) appends one string to \
another and frees the original strings"
  XEN_ASSERT_TYPE(XEN_XmString_P(arg1), arg1, 1, "XmStringConcatAndFree", "XmString");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmStringConcatAndFree", "XmString");
  return(C_TO_XEN_XmString(XmStringConcatAndFree(XEN_TO_C_XmString(arg1), XEN_TO_C_XmString(arg2))));
}

static XEN gxm_XmStringConcat(XEN arg1, XEN arg2)
{
  #define H_XmStringConcat "XmString XmStringConcat(XmString s1, XmString s2) appends one string to another"
  XEN_ASSERT_TYPE(XEN_XmString_P(arg1), arg1, 1, "XmStringConcat", "XmString");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmStringConcat", "XmString");
  return(C_TO_XEN_XmString(XmStringConcat(XEN_TO_C_XmString(arg1), XEN_TO_C_XmString(arg2))));
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XmFontListFreeFontContext(XEN arg1)
{
  #define H_XmFontListFreeFontContext "void XmFontListFreeFontContext(XmFontContext context) instructs the toolkit that \
the font list context is no longer needed"
  XEN_ASSERT_TYPE(XEN_XmFontContext_P(arg1), arg1, 1, "XmFontListFreeFontContext", "XmFontContext");
  XmFontListFreeFontContext(XEN_TO_C_XmFontContext(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmFontListGetNextFont(XEN arg1)
{
  #define H_XmFontListGetNextFont "Boolean XmFontListGetNextFont(XmFontContext context) \
allows applications to access the fonts and character sets in a font list"
  /* DIFF: XmFontListGetNextFont omits args 2 3, returns list
   */
  XmStringCharSet s;
  XFontStruct *f;
  int b;
  XEN_ASSERT_TYPE(XEN_XmFontContext_P(arg1), arg1, 1, "XmFontListGetNextFont", "XmFontContext");
  b = XmFontListGetNextFont(XEN_TO_C_XmFontContext(arg1), &s, &f);
  if (b) /* else "s" may be garbage */
    return(XEN_LIST_3(C_TO_XEN_BOOLEAN(b),
		      C_TO_XEN_STRING(s),
		      C_TO_XEN_XFontStruct(f)));
  return(XEN_FALSE);
}

static XEN gxm_XmFontListInitFontContext(XEN arg1)
{
  #define H_XmFontListInitFontContext "Boolean XmFontListInitFontContext(XmFontList fontlist) \
allows applications to access the entries in a font list"
  /* DIFF: XmFontListInitFontContext omits arg1 and rtns it
   */
  XmFontContext fc;
  Boolean b;
  XEN_ASSERT_TYPE(XEN_XmFontList_or_XmRenderTable_P(arg1), arg1, 1, "XmFontListInitFontContext", "XmFontList");
  b = XmFontListInitFontContext(&fc, XEN_TO_C_XmFontList(arg1));
  if (b)
    return(C_TO_XEN_XmFontContext(fc));
  return(XEN_FALSE);
}

static XEN gxm_XmFontListCopy(XEN arg1)
{
  #define H_XmFontListCopy "XmFontList XmFontListCopy(XmFontList fontlist) copies a font list"
  XEN_ASSERT_TYPE(XEN_XmFontList_or_XmRenderTable_P(arg1), arg1, 1, "XmFontListCopy", "XmFontList");
  return(C_TO_XEN_XmFontList(XmFontListCopy(XEN_TO_C_XmFontList(arg1))));
}

static XEN gxm_XmFontListAdd(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmFontListAdd "XmFontList XmFontListAdd(XmFontList oldlist, XFontStruct *font, XmStringCharSet charset) \
creates a new font list"
  XEN_ASSERT_TYPE(XEN_XmFontList_or_XmRenderTable_P(arg1), arg1, 1, "XmFontListAdd", "XmFontList");
  XEN_ASSERT_TYPE(XEN_XFontStruct_P(arg2), arg2, 2, "XmFontListAdd", "XFontStruct*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3), arg3, 3, "XmFontListAdd", "XmStringCharSet");
  return(C_TO_XEN_XmFontList(XmFontListAdd(XEN_TO_C_XmFontList(arg1), XEN_TO_C_XFontStruct(arg2), XEN_TO_C_STRING(arg3))));
}

static XEN gxm_XmFontListFree(XEN arg1)
{
  #define H_XmFontListFree "void XmFontListFree(XmFontList list) recovers memory used by a font list"
  XEN_ASSERT_TYPE(XEN_XmFontList_or_XmRenderTable_P(arg1), arg1, 1, "XmFontListFree", "XmFontList");
  XmFontListFree(XEN_TO_C_XmFontList(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmFontListCreate(XEN arg1, XEN arg2)
{
  #define H_XmFontListCreate "XmFontList XmFontListCreate(XFontStruct *font, XmStringCharSet charset) creates a font list"
  XEN_ASSERT_TYPE(XEN_XFontStruct_P(arg1), arg1, 1, "XmFontListCreate", "XFontStruct*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmFontListCreate", "XmStringCharSet");
  return(C_TO_XEN_XmFontList(XmFontListCreate(XEN_TO_C_XFontStruct(arg1), XEN_TO_C_STRING(arg2))));
}

static XEN gxm_XmFontListEntryLoad(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmFontListEntryLoad "XmFontListEntry XmFontListEntryLoad(Display *display, char *font_name, XmFontType type, char *tag) \
loads a font or creates a font set and creates an accompanying font list entry"

  XmFontType type;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmFontListEntryLoad", "Display*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmFontListEntryLoad", "char*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmFontListEntryLoad", "XmFontType");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg4), arg4, 4, "XmFontListEntryLoad", "char*");
  type = (XmFontType)XEN_TO_C_INT(arg3);
  if (type > 1) XEN_WRONG_TYPE_ARG_ERROR("XmFontListEntryLoad", 3, arg3, "XmFontType");
  return(C_TO_XEN_XmFontListEntry(XmFontListEntryLoad(XEN_TO_C_Display(arg1),
						      XEN_TO_C_STRING(arg2),
						      type,
						      XEN_TO_C_STRING(arg4))));
}

static XEN gxm_XmFontListRemoveEntry(XEN arg1, XEN arg2)
{
  #define H_XmFontListRemoveEntry "XmFontList XmFontListRemoveEntry(XmFontList oldlist, XmFontListEntry entry) removes a \
font list entry from a font list"
  XEN_ASSERT_TYPE(XEN_XmFontList_or_XmRenderTable_P(arg1), arg1, 1, "XmFontListRemoveEntry", "XmFontList");
  XEN_ASSERT_TYPE(XEN_XmFontListEntry_P(arg2), arg2, 2, "XmFontListRemoveEntry", "XmFontListEntry");
  return(C_TO_XEN_XmFontList(XmFontListRemoveEntry(XEN_TO_C_XmFontList(arg1), XEN_TO_C_XmFontListEntry(arg2))));
}

static XEN gxm_XmFontListNextEntry(XEN arg1)
{
  #define H_XmFontListNextEntry "XmFontListEntry XmFontListNextEntry(XmFontContext context) returns the next entry in a font list"
  XEN_ASSERT_TYPE(XEN_XmFontContext_P(arg1), arg1, 1, "XmFontListNextEntry", "XmFontContext");
  return(C_TO_XEN_XmFontListEntry(XmFontListNextEntry(XEN_TO_C_XmFontContext(arg1))));
}

static XEN gxm_XmFontListAppendEntry(XEN arg1, XEN arg2)
{
  #define H_XmFontListAppendEntry "XmFontList XmFontListAppendEntry(XmFontList oldlist, XmFontListEntry entry) appends an \
entry to a font list"
  XEN_ASSERT_TYPE(XEN_XmFontList_or_XmRenderTable_P(arg1) || XEN_FALSE_P(arg1), arg1, 1, "XmFontListAppendEntry", "XmFontList");
  XEN_ASSERT_TYPE(XEN_XmFontListEntry_P(arg2), arg2, 2, "XmFontListAppendEntry", "XmFontListEntry");
  return(C_TO_XEN_XmFontList(XmFontListAppendEntry((XEN_FALSE_P(arg1)) ? NULL : XEN_TO_C_XmFontList(arg1), 
						   XEN_TO_C_XmFontListEntry(arg2))));
}

static XEN gxm_XmFontListEntryGetTag(XEN arg1)
{
  char *str;
  XEN res;
  #define H_XmFontListEntryGetTag "char* XmFontListEntryGetTag(XmFontListEntry entry) retrieves the tag of a font list entry"
  XEN_ASSERT_TYPE(XEN_XmFontListEntry_P(arg1), arg1, 1, "XmFontListEntryGetTag", "XmFontListEntry");
  str = XmFontListEntryGetTag(XEN_TO_C_XmFontListEntry(arg1));
  res = C_TO_XEN_STRING(str);
  if (str) XtFree(str);
  return(res);
}

static XEN gxm_XmFontListEntryGetFont(XEN arg1)
{
  #define H_XmFontListEntryGetFont "XtPointer XmFontListEntryGetFont(XmFontListEntry entry) \
retrieves font information from a font list entry -> fontstruct"
  /* DIFF: XmFontListEntryGetFont omits arg2
   */
  XmFontType f;
  XtPointer ptr;
  XEN_ASSERT_TYPE(XEN_XmFontListEntry_P(arg1), arg1, 1, "XmFontListEntryGetFont", "XmFontListEntry");
  ptr  = XmFontListEntryGetFont(XEN_TO_C_XmFontListEntry(arg1), &f);
  if (f == XmFONT_IS_FONTSET)
    return(C_TO_XEN_XFontSet((XFontSet)ptr)); 
  return(C_TO_XEN_XFontStruct((XFontStruct *)ptr));
}

static XEN gxm_XmFontListEntryFree(XEN arg1)
{
  #define H_XmFontListEntryFree "void XmFontListEntryFree(XmFontListEntry *entry) recovers memory used by a font list entry"
  /* DIFF: XmFontListEntryFree takes FontListEntry (not ptr to it)
   */
  XmFontListEntry f;
  XEN_ASSERT_TYPE(XEN_XmFontListEntry_P(arg1), arg1, 1, "XmFontListEntryFree", "XmFontListEntry");
  f = XEN_TO_C_XmFontListEntry(arg1);
  XmFontListEntryFree(&f);
  return(XEN_FALSE);
}

static XEN gxm_XmFontListEntryCreate(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmFontListEntryCreate "XmFontListEntry XmFontListEntryCreate(char *tag, XmFontType type, XtPointer font) \
creates a font list entry"
  XmFontType type;
  XtPointer gad;
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XmFontListEntryCreate", "char*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmFontListEntryCreate", "XmFontType");
  XEN_ASSERT_TYPE(XEN_XFontStruct_P(arg3) || XEN_XFontSet_P(arg3), arg3, 3, "XmFontListEntryCreate", "XFontSet or XFontStruct");
  type = (XmFontType)XEN_TO_C_INT(arg2);
  if (type > 1) XEN_WRONG_TYPE_ARG_ERROR("XmFontListEntryCreate", 2, arg2, "XmFontType");
  if (type == XmFONT_IS_FONTSET)
    gad = (XtPointer)XEN_TO_C_XFontSet(arg3);
  else gad = (XtPointer)XEN_TO_C_XFontStruct(arg3);
  return(C_TO_XEN_XmFontListEntry(XmFontListEntryCreate(XEN_TO_C_STRING(arg1), 
							type,
							gad)));
}

static XEN gxm_XmStringGetLtoR(XEN arg1, XEN arg2)
{
  #define H_XmStringGetLtoR "Boolean XmStringGetLtoR(XmString string, XmStringCharSet tag) searches \
for a text segment in the input compound string"
  /* DIFF: XmStringGetLtoR omits and rtns last arg
   */
  char *str;
  Boolean b;
  XEN val;
  XEN_ASSERT_TYPE(XEN_XmString_P(arg1), arg1, 1, "XmStringGetLtoR", "XmString");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmStringGetLtoR", "XmStringCharSet");
  b = XmStringGetLtoR(XEN_TO_C_XmString(arg1), XEN_TO_C_STRING(arg2), &str);
  val = C_TO_XEN_STRING(str);
  free(str);
  return(XEN_LIST_2(C_TO_XEN_BOOLEAN(b), val));
}

static XEN gxm_XmStringGetNextSegment(XEN arg1)
{
  #define H_XmStringGetNextSegment "Boolean XmStringGetNextSegment(XmStringContext context) fetches the bytes in the next segment of a compound string"
  /* DIFF: XmStringGetNextSegment omits last args, returns them
   */
  Boolean b; /* returned boolean omitted arg 5 */
  int val;
  unsigned char c;
  XmStringCharSet tag;
  char *text;
  XEN_ASSERT_TYPE(XEN_XmStringContext_P(arg1), arg1, 1, "XmStringGetNextSegment", "XmStringContext");
  val = XmStringGetNextSegment(XEN_TO_C_XmStringContext(arg1), 
			       &text, &tag, &c, &b);
  return(XEN_LIST_5(C_TO_XEN_BOOLEAN(val),
		    C_TO_XEN_STRING(text),
		    C_TO_XEN_STRING(tag),
		    C_TO_XEN_INT((int)c),
		    C_TO_XEN_BOOLEAN(b)));
}

static XEN gxm_XmStringPeekNextComponent(XEN arg1)
{
  #define H_XmStringPeekNextComponent "XmStringComponentType XmStringPeekNextComponent(XmStringContext context) \
returns the component type of the next component to be fetched"
  XEN_ASSERT_TYPE(XEN_XmStringContext_P(arg1), arg1, 1, "XmStringPeekNextComponent", "XmStringContext");
  return(C_TO_XEN_INT(XmStringPeekNextComponent(XEN_TO_C_XmStringContext(arg1))));
}

static XEN gxm_XmStringGetNextComponent(XEN arg1)
{
  #define H_XmStringGetNextComponent "XmStringComponentType XmStringGetNextComponent(XmStringContext context) \
returns the type and value of the next component in a compound string (list val text tag direction component len value)"
  /* DIFF: XmStringGetNextComponent omits all but 1st arg, returns list
   */
  XmStringDirection direction = 0;
  unsigned short len;
  unsigned char *value;
  XmStringComponentType component;
  XmStringCharSet tag;
  char *text = NULL;
  int val;
  XEN xtext = XEN_FALSE, xdir = XEN_FALSE, xtag = XEN_FALSE, xvalue = XEN_FALSE;
  XEN_ASSERT_TYPE(XEN_XmStringContext_P(arg1), arg1, 1, "XmStringGetNextComponent", "XmStringContext");
  val = XmStringGetNextComponent(XEN_TO_C_XmStringContext(arg1), &text, &tag, &direction, &component, &len, &value);
  if ((val == XmSTRING_COMPONENT_TEXT) || (val == XmSTRING_COMPONENT_LOCALE_TEXT))
    {
      xtext = C_TO_XEN_STRING(text);
      if (text) XtFree(text);
    }
  else
    {
      if (val == XmSTRING_COMPONENT_DIRECTION)
	xdir = C_TO_XEN_INT((int)direction);
      else 
	{
	  if ((val == XmSTRING_COMPONENT_FONTLIST_ELEMENT_TAG) || (val == XmSTRING_COMPONENT_CHARSET))
	    {
	      xtag = C_TO_XEN_STRING(tag);
	      if (tag) XtFree(tag);
	    }
	}
    }
  xvalue = C_TO_XEN_STRING((const char *)value);
  if ((len > 0) && (value) && ((component == XmSTRING_COMPONENT_TEXT) || (component == XmSTRING_COMPONENT_LOCALE_TEXT)))
    XtFree((char *)value);
  return(XEN_LIST_7(C_TO_XEN_INT(val),
		    xtext,
		    xtag,
		    xdir,
		    C_TO_XEN_INT((int)component),
		    C_TO_XEN_INT((int)len),
		    xvalue));
}
#endif

static XEN gxm_XmStringFreeContext(XEN arg1)
{
  #define H_XmStringFreeContext "void XmStringFreeContext(XmStringContext context) releases the string scanning \
context data structure"
  XEN_ASSERT_TYPE(XEN_XmStringContext_P(arg1), arg1, 1, "XmStringFreeContext", "XmStringContext");
  XmStringFreeContext(XEN_TO_C_XmStringContext(arg1));
  return(XEN_FALSE);
}

static XmStringContext gxm_initxmsc;
static XEN gxm_XmStringInitContext(XEN arg2)
{
  #define H_XmStringInitContext "Boolean XmStringInitContext(XmString string) creates \
a data structure for scanning an XmString component by component"
  /* DIFF XmStringInitContext 1st arg omitted and rtn
   */
  int val;
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 1, "XmStringInitContext", "XmString");
  val = XmStringInitContext(&gxm_initxmsc, XEN_TO_C_XmString(arg2));
  return(XEN_LIST_2(C_TO_XEN_BOOLEAN(val), C_TO_XEN_XmStringContext(gxm_initxmsc)));
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XmStringCreateLtoR(XEN arg1, XEN arg2)
{
  #define H_XmStringCreateLtoR "XmString XmStringCreateLtoR(char *text, char *tag) creates a compound string"
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XmStringCreateLtoR", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmStringCreateLtoR", "XmStringCharSet");
  return(C_TO_XEN_XmString(XmStringCreateLtoR(XEN_TO_C_STRING(arg1), XEN_TO_C_STRING(arg2))));
}

static XEN gxm_XmStringSegmentCreate(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmStringSegmentCreate "XmString XmStringSegmentCreate(char *text, XmStringTag tag, XmStringDirection direction, Boolean separator) \
creates a compound string"
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XmStringSegmentCreate", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmStringSegmentCreate", "XmStringCharSet");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmStringSegmentCreate", "int");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg4), arg4, 4, "XmStringSegmentCreate", "boolean");
  return(C_TO_XEN_XmString(XmStringSegmentCreate(XEN_TO_C_STRING(arg1), 
						 XEN_TO_C_STRING(arg2), 
						 XEN_TO_C_INT(arg3), 
						 XEN_TO_C_BOOLEAN(arg4))));
}
#endif

static XEN gxm_XmStringSeparatorCreate(void)
{
  #define H_XmStringSeparatorCreate "XmString XmStringSeparatorCreate(void) creates a compound string"
  return(C_TO_XEN_XmString(XmStringSeparatorCreate()));
}

static XEN gxm_XmStringDirectionCreate(XEN arg1)
{
  #define H_XmStringDirectionCreate "XmString XmStringDirectionCreate(XmStringDirection direction) creates a compound string"
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg1), arg1, 1, "XmStringDirectionCreate", "int");
  return(C_TO_XEN_XmString(XmStringDirectionCreate(XEN_TO_C_INT(arg1))));
}

static XEN gxm_XmStringCreateLocalized(XEN arg1)
{
  #define H_XmStringCreateLocalized "XmString XmStringCreateLocalized(char *text) creates a compound string in the current locale"
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XmStringCreateLocalized", "String");
  return(C_TO_XEN_XmString(XmStringCreateLocalized(XEN_TO_C_STRING(arg1))));
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XmStringCreateSimple(XEN arg1)
{
  #define H_XmStringCreateSimple "XmString XmStringCreateSimple(char *text) creates a compound string in the \
language environment of a widget"
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XmStringCreateSimple", "char*");
  return(C_TO_XEN_XmString(XmStringCreateSimple(XEN_TO_C_STRING(arg1))));
}
#endif

static XEN gxm_XmStringCreate(XEN arg1, XEN arg2)
{
  #define H_XmStringCreate "XmString XmStringCreate(char *text, char *tag) creates a compound string"
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XmStringCreate", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmStringCreate", "XmStringCharSet");
  return(C_TO_XEN_XmString(XmStringCreate(XEN_TO_C_STRING(arg1), XEN_TO_C_STRING(arg2))));
}

static XEN gxm_XmChangeColor(XEN arg1, XEN arg2)
{
  #define H_XmChangeColor "void XmChangeColor(Widget widget, Pixel background) recalculates all associated colors of a widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmChangeColor", "Widget");
  XEN_ASSERT_TYPE(XEN_Pixel_P(arg2), arg2, 2, "XmChangeColor", "Pixel");
  XmChangeColor(XEN_TO_C_Widget(arg1), XEN_TO_C_Pixel(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmGetColors(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmGetColors "void XmGetColors(Screen *screen, Colormap colormap, Pixel background) generates foreground, select, and shadow colors"
  /* DIFF: XmGetColors omits trailing 4 args and returns them
   */
  Pixel fg,ts, bs, sr;
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XmGetColors", "Screen*");
  XEN_ASSERT_TYPE(XEN_Colormap_P(arg2), arg2, 2, "XmGetColors", "Colormap");
  XEN_ASSERT_TYPE(XEN_Pixel_P(arg3), arg3, 3, "XmGetColors", "Pixel");
  XmGetColors(XEN_TO_C_Screen(arg1), 
	      XEN_TO_C_Colormap(arg2), 
	      XEN_TO_C_Pixel(arg3),
	      &fg, &ts, &bs, &sr);
  return(XEN_LIST_4(C_TO_XEN_Pixel(fg),
		    C_TO_XEN_Pixel(ts),
		    C_TO_XEN_Pixel(bs),
		    C_TO_XEN_Pixel(sr)));
}

static XEN gxm_XmGetColorCalculation(void)
{
  #define H_XmGetColorCalculation "XmColorProc XmGetColorCalculation(void) get the procedure used for default color calculation"
  return(xm_XmColorProc);
}

static XEN gxm_XmSetColorCalculation(XEN arg1)
{
  #define H_XmSetColorCalculation "XmColorProc XmSetColorCalculation(XmColorProc color_proc) set the procedure used for default color calculation"
  /* DIFF: XmSetColorCalculation NULL -> #f
   */
  if (XEN_PROCEDURE_P(xm_XmColorProc)) xm_unprotect(xm_XmColorProc);
  if (XEN_FALSE_P(arg1))
    {
      xm_XmColorProc = XEN_FALSE;
      XmSetColorCalculation(NULL);
    }
  else
    {
      XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg1) && (XEN_REQUIRED_ARGS_OK(arg1, 1)), arg1, 1, "XmSetColorCalculation", "(XmColorProc but 1 arg)");
      xm_protect(arg1);
      xm_XmColorProc = arg1;
      XmSetColorCalculation((XmColorProc)gxm_XmColorProc);
    }
  return(arg1);
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XmTrackingLocate(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmTrackingLocate "Widget XmTrackingLocate(Widget widget, Cursor cursor, Boolean confine_to) allows for modal \
selection of a component (obsolete)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmTrackingLocate", "Widget");
  XEN_ASSERT_TYPE(XEN_Cursor_P(arg2), arg2, 2, "XmTrackingLocate", "Cursor");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg3), arg3, 3, "XmTrackingLocate", "boolean");
  return(C_TO_XEN_Widget(XmTrackingLocate(XEN_TO_C_Widget(arg1), XEN_TO_C_ULONG(arg2), XEN_TO_C_BOOLEAN(arg3))));
}
#endif

static XEN gxm_XmTrackingEvent(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmTrackingEvent "Widget XmTrackingEvent(Widget widget, Cursor cursor, Boolean confine_to) -> (widget event)"
  /* DIFF: XmTrackingEvent widget cursor confine [event] -> (list widget event)
   */
  XEvent *e; /* do we need to allocate? */
  Widget w;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmTrackingEvent", "Widget");
  XEN_ASSERT_TYPE(XEN_Cursor_P(arg2), arg2, 2, "XmTrackingEvent", "Cursor");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg3), arg3, 3, "XmTrackingEvent", "boolean");
  e = (XEvent *)CALLOC(1, sizeof(XEvent));
  w = XmTrackingEvent(XEN_TO_C_Widget(arg1), XEN_TO_C_ULONG(arg2), XEN_TO_C_BOOLEAN(arg3), e);
  return(XEN_LIST_2(C_TO_XEN_Widget(w), C_TO_XEN_XEvent_OBJ(e)));
}


/* The various XmVaCreateSimple{object} require special arg handling --
     these are not "normal" resource lists, but can also contain special indicators
     -- not immediately clear how to handle these things!
     Apparently we need to run through the args, split out the special args,
     collect arglists, add to arglist buttons, buttonCount etc, then call the
     underlying simple creator. (see lesstif lib/Xm/VaSimple.c)

   rowcol = XmVaCreateSimpleCheckBox(toplevel, "checkBox", cb,
				     XmNspacing, 2,
				     XmNmarginHeight, 4,
				     XmVaCHECKBUTTON, s1, 0, NULL, NULL,
				     XmVaCHECKBUTTON, s2, 0, NULL, NULL,
				     NULL);

   option = XmVaCreateSimpleOptionMenu(form, "option", cs("MyLabel"), 
				      (KeySym) 'M', 1, SimpleCallbackProc,
				      XmVaPUSHBUTTON, cs("Red"), (int) 'R', 
				      "", XmNULL,
				      XmVaCASCADEBUTTON, cs("Help"), (int) 'H',
				      XmVaSEPARATOR,
				      XmVaPUSHBUTTON, cs("Green"), (int) 'G', 
				      "", XmNULL,
				      XmVaSEPARATOR,
				      XmVaPUSHBUTTON, cs("Blue"), (int) 'B', 
				      "", XmNULL,
				      NULL);				    
*/

static XEN gxm_XmVaCreateSimpleCheckBox(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmVaCreateSimpleCheckBox "Widget XmVaCreateSimpleCheckBox(Widget parent, String name, XtCallbackProc callback, args)"
  Widget w;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmVaCreateSimpleCheckBox", "Widget");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmVaCreateSimpleCheckBox", "String");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg3) && (XEN_REQUIRED_ARGS_OK(arg3, 3)), arg3, 3, "XmVaCreateSimpleCheckBox", "XtCallbackProc (3 args)");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg4), arg4, 4, "XmVaCreateSimpleCheckBox", "List");
  arg4 = XEN_CONS_2(C_TO_XEN_STRING(XmNvalueChangedCallback),
		    XEN_LIST_2(arg3, XEN_FALSE), /* XtCallbackList technically */
		    arg4);
  {
    int arglen;
    Arg *args;
    args = XEN_TO_C_Args(arg4);
    arglen = XEN_LIST_LENGTH(arg4) / 2;
    w = XmCreateSimpleCheckBox(XEN_TO_C_Widget(arg1), 
			       XEN_TO_C_STRING(arg2), 
			       args,
			       arglen);
    if (args)
      {
	fixup_args(w, args, arglen);
	free_args(args, arglen);
      }
  }
  return(C_TO_XEN_Widget(w));

}

static XEN gxm_XmVaCreateSimpleRadioBox(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XmVaCreateSimpleRadioBox "Widget XmVaCreateSimpleRadioBox(Widget parent, String name, int button_set, XtCallbackProc callback, args)"
  Widget w;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmVaCreateSimpleRadioBox", "Widget");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmVaCreateSimpleRadioBox", "String");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmVaCreateSimpleRadioBox", "int");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg4) && (XEN_REQUIRED_ARGS_OK(arg4, 3)), arg4, 4, "XmVaCreateSimpleRadioBox", "XtCallbackProc (3 args");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg5), arg5, 5, "XmVaCreateSimpleRadioBox", "List");
  arg5 = XEN_CONS_2(C_TO_XEN_STRING(XmNvalueChangedCallback),
		    XEN_LIST_2(arg4, XEN_FALSE),
		    arg5);
  /* can't handle button set here since the menuHistory resource is the widget allocated later */
  {
    int arglen;
    Arg *args;
    args = XEN_TO_C_Args(arg5);
    arglen = XEN_LIST_LENGTH(arg5) / 2;
    w = XmCreateSimpleRadioBox(XEN_TO_C_Widget(arg1), 
			       XEN_TO_C_STRING(arg2), 
			       args,
			       arglen);
    if (args)
      {
	fixup_args(w, args, arglen);
	free_args(args, arglen);
      }
  }
  return(C_TO_XEN_Widget(w));
}

static XEN gxm_XmVaCreateSimpleOptionMenu(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7)
{
  #define H_XmVaCreateSimpleOptionMenu "Widget XmVaCreateSimpleOptionMenu(Widget parent, String name, XmString option_label, \
KeySym option_mnemonic, int button_set, XtCallbackProc callback, args)"
  Widget w;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmVaCreateSimpleOptionMenu", "Widget");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmVaCreateSimpleOptionMenu", "String");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg3), arg3, 3, "XmVaCreateSimpleOptionMenu", "XmString");
  XEN_ASSERT_TYPE(XEN_KeySym_P(arg4), arg4, 4, "XmVaCreateSimpleOptionMenu", "KeySym");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XmVaCreateSimpleOptionMenu", "int");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg6) && (XEN_REQUIRED_ARGS_OK(arg6, 3)), arg6, 6, "XmVaCreateSimpleOptionMenu", "XtCallbackProc (3 args)");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg7), arg7, 7, "XmVaCreateSimpleOptionMenu", "List");
  arg7 = XEN_CONS_2(C_TO_XEN_STRING(XmNlabelString),
		    arg3,
		    XEN_CONS_2(C_TO_XEN_STRING(XmNmnemonic),
			       arg4,
			       XEN_CONS_2(C_TO_XEN_STRING(XmNvalueChangedCallback),
					  XEN_LIST_2(arg6, XEN_FALSE),
					  arg7)));
  {
    int arglen;
    Arg *args;
    args = XEN_TO_C_Args(arg7);
    arglen = XEN_LIST_LENGTH(arg7) / 2;
    w = XmCreateSimpleOptionMenu(XEN_TO_C_Widget(arg1), 
				 XEN_TO_C_STRING(arg2), 
				 args,
				 arglen);
    if (args)
      {
	fixup_args(w, args, arglen);
	free_args(args, arglen);
      }
  }
  return(C_TO_XEN_Widget(w));
}

static XEN gxm_XmVaCreateSimplePulldownMenu(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XmVaCreateSimplePulldownMenu "Widget XmVaCreateSimplePulldownMenu(Widget parent, String name, int post_from_button, XtCallbackProc callback, args)"
  Widget w;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmVaCreateSimplePulldownMenu", "Widget");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmVaCreateSimplePulldownMenu", "String");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmVaCreateSimplePulldownMenu", "int");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg4) && (XEN_REQUIRED_ARGS_OK(arg4, 3)), arg4, 4, "XmVaCreateSimplePulldownMenu", "XtCallbackProc (3 args)");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg5), arg5, 5, "XmVaCreateSimplePulldownMenu", "List");
  arg5 = XEN_CONS_2(C_TO_XEN_STRING(XmNvalueChangedCallback),
		    XEN_LIST_2(arg4, XEN_FALSE),
		    arg5);
  {
    int arglen;
    Arg *args;
    args = XEN_TO_C_Args(arg5);
    arglen = XEN_LIST_LENGTH(arg5) / 2;
    w = XmCreateSimplePulldownMenu(XEN_TO_C_Widget(arg1), 
				   XEN_TO_C_STRING(arg2), 
				   args,
				   arglen);
    if (args)
      {
	fixup_args(w, args, arglen);
	free_args(args, arglen);
      }
  }
  return(C_TO_XEN_Widget(w));
}

static XEN gxm_XmVaCreateSimplePopupMenu(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmVaCreateSimplePopupMenu "Widget XmVaCreateSimplePopupMenu(Widget parent, String name, XtCallbackProc callback, args)"
  Widget w;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmVaCreateSimplePopupMenu", "Widget");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmVaCreateSimplePopupMenu", "String");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg3) && (XEN_REQUIRED_ARGS_OK(arg3, 3)), arg3, 3, "XmVaCreateSimplePopupMenu", "XtCallbackProc (3 args)");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg4), arg4, 4, "XmVaCreateSimplePopupMenu", "List");
  arg4 = XEN_CONS_2(C_TO_XEN_STRING(XmNvalueChangedCallback),
		    XEN_LIST_2(arg3, XEN_FALSE),
		    arg4);
  {
    int arglen;
    Arg *args;
    args = XEN_TO_C_Args(arg4);
    arglen = XEN_LIST_LENGTH(arg4) / 2;
    w = XmCreateSimplePopupMenu(XEN_TO_C_Widget(arg1), 
				XEN_TO_C_STRING(arg2), 
				args,
				arglen);
    if (args)
      {
	fixup_args(w, args, arglen);
	free_args(args, arglen);
      }
  }
  return(C_TO_XEN_Widget(w));
}

static XEN gxm_XmVaCreateSimpleMenuBar(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmVaCreateSimpleMenuBar "Widget XmVaCreateSimpleMenuBar(Widget parent, String name, args)"
  Widget w;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmVaCreateSimpleMenuBar", "Widget");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmVaCreateSimpleMenuBar", "String");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg3), arg3, 3, "XmVaCreateSimpleMenuBar", "List");
  {
    int arglen;
    Arg *args;
    args = XEN_TO_C_Args(arg3);
    arglen = XEN_LIST_LENGTH(arg3) / 2;
    w = XmVaCreateSimpleMenuBar(XEN_TO_C_Widget(arg1), 
				XEN_TO_C_STRING(arg2),
				args,
				arglen);
    if (args)
      {
	fixup_args(w, args, arglen);
	free_args(args, arglen);
      }
  }
  return(C_TO_XEN_Widget(w));
}

static XEN gxm_XmCreateSimpleCheckBox(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateSimpleCheckBox "Widget XmCreateSimpleCheckBox(Widget parent, String name, ArgList arglist, Cardinal argcount)"
  return(gxm_new_widget("XmCreateSimpleCheckBox", XmCreateSimpleCheckBox, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateSimpleRadioBox(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateSimpleRadioBox "Widget XmCreateSimpleRadioBox(Widget parent, String name, ArgList arglist, Cardinal argcount)"
  return(gxm_new_widget("XmCreateSimpleRadioBox", XmCreateSimpleRadioBox, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateSimpleOptionMenu(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateSimpleOptionMenu "Widget XmCreateSimpleOptionMenu(Widget parent, String name, ArgList arglist, Cardinal argcount)"
  return(gxm_new_widget("XmCreateSimpleOptionMenu", XmCreateSimpleOptionMenu, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateSimplePulldownMenu(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateSimplePulldownMenu "Widget XmCreateSimplePulldownMenu(Widget parent, String name, ArgList arglist, Cardinal argcount)"
  return(gxm_new_widget("XmCreateSimplePulldownMenu", XmCreateSimplePulldownMenu, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateSimplePopupMenu(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateSimplePopupMenu "Widget XmCreateSimplePopupMenu(Widget parent, String name, ArgList arglist, Cardinal argcount)"
  return(gxm_new_widget("XmCreateSimplePopupMenu", XmCreateSimplePopupMenu, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateSimpleMenuBar(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateSimpleMenuBar "Widget XmCreateSimpleMenuBar(Widget parent, String name, ArgList arglist, Cardinal argcount)"
  return(gxm_new_widget("XmCreateSimpleMenuBar", XmCreateSimpleMenuBar, arg1, arg2, arg3, arg4));
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XmGetMenuCursor(XEN arg1)
{
  #define H_XmGetMenuCursor "Cursor XmGetMenuCursor(Display *display) returns the cursor ID for the current menu cursor"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmGetMenuCursor", "Display*");
  return(C_TO_XEN_Cursor(XmGetMenuCursor(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XmSetMenuCursor(XEN arg1, XEN arg2)
{
  #define H_XmSetMenuCursor "void XmSetMenuCursor(Display *display, Cursor cursorId) modifies the menu cursor for a client"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmSetMenuCursor", "Display*");
  XEN_ASSERT_TYPE(XEN_Cursor_P(arg2), arg2, 2, "XmSetMenuCursor", "Cursor");
  XmSetMenuCursor(XEN_TO_C_Display(arg1), XEN_TO_C_Cursor(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmSetFontUnit(XEN arg1, XEN arg2)
{
  #define H_XmSetFontUnit "void XmSetFontUnit(Display *display, int font_unit_value) sets the font unit value for a display"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmSetFontUnit", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmSetFontUnit", "int");
  XmSetFontUnit(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmSetFontUnits(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmSetFontUnits "void XmSetFontUnits(Display *display, int h_value, int v_value) sets the font unit value for a display"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmSetFontUnits", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmSetFontUnits", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmSetFontUnits", "int");
  XmSetFontUnits(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_INT(arg3));
  return(XEN_FALSE);
}
#endif

static XEN gxm_XmConvertUnits(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XmConvertUnits "int XmConvertUnits(Widget widget, int orientation, int from_unit_type, int from_value, int to_unit_type) \
converts a value in one unit type to another unit type"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmConvertUnits", "Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmConvertUnits", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmConvertUnits", "register");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XmConvertUnits", "register");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XmConvertUnits", "register");
  return(C_TO_XEN_INT(XmConvertUnits(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_INT(arg3), XEN_TO_C_INT(arg4), XEN_TO_C_INT(arg5))));
}

static XEN gxm_XmConvertStringToUnits(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmConvertStringToUnits "int XmConvertStringToUnits(Screen *screen, String spec, int orientation, int to_type, XtEnum *parse_error) \
converts a string specification to a unit value"
  /* DIFF: XmConvertStringToUnits scr spec orient type [err] -> #f (err) or val
   */
  XtEnum err = 0;
  int val;
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XmConvertStringToUnits", "Screen*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmConvertStringToUnits", "String");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmConvertStringToUnits", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XmConvertStringToUnits", "int");
  val = XmConvertStringToUnits(XEN_TO_C_Screen(arg1), XEN_TO_C_STRING(arg2), XEN_TO_C_INT(arg3), XEN_TO_C_INT(arg4), &err);
  if (err == 0)
    return(C_TO_XEN_INT(val));
  return(XEN_FALSE);
}

static XEN gxm_XmCvtXmStringToCT(XEN arg1)
{
  #define H_XmCvtXmStringToCT "char *XmCvtXmStringToCT(XmString string) converts a compound string to compound text"
  XEN_ASSERT_TYPE(XEN_XmString_P(arg1), arg1, 1, "XmCvtXmStringToCT", "XmString");
  return(C_TO_XEN_STRING(XmCvtXmStringToCT(XEN_TO_C_XmString(arg1))));
  /* memory leak here, but the docs don't say that I should free the string of "compound text" */
}

static XEN gxm_XmCvtCTToXmString(XEN arg1)
{
  #define H_XmCvtCTToXmString "XmString XmCvtCTToXmString(char *text) converts compound text to a compound string"
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XmCvtCTToXmString", "char*");
  return(C_TO_XEN_XmString(XmCvtCTToXmString(XEN_TO_C_STRING(arg1))));
}

static XEN gxm_XmMapSegmentEncoding(XEN arg1)
{
  char *str;
  XEN res;
  #define H_XmMapSegmentEncoding "char *XmMapSegmentEncoding(char *fontlist_tag) returns the compound text \
encoding format associated with the specified font list tag"
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XmMapSegmentEncoding", "char*");
  str = XmMapSegmentEncoding(XEN_TO_C_STRING(arg1));
  res = C_TO_XEN_STRING(str);
  if (str) XtFree(str);
  return(res);
}

static XEN gxm_XmRegisterSegmentEncoding(XEN arg1, XEN arg2)
{
  char *str;
  XEN res;
  #define H_XmRegisterSegmentEncoding "char *XmRegisterSegmentEncoding(char *fontlist_tag, char *ct_encoding) \
registers a compound text encoding format for a specified font list element tag"
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XmRegisterSegmentEncoding", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmRegisterSegmentEncoding", "char*");
  str = XmRegisterSegmentEncoding(XEN_TO_C_STRING(arg1), XEN_TO_C_STRING(arg2));
  res = C_TO_XEN_STRING(str);
  if (str) XtFree(str);
  return(res);
}

static XEN gxm_XmWidgetGetBaselines(XEN arg1)
{
  #define H_XmWidgetGetBaselines "Boolean XmWidgetGetBaselines(Widget widget) retrieves baseline information for a widget"
  /* DIFF: XmWidgetGetBaselines omits args 2 and 3, returns list of Dimensions
   */
  Dimension *ds;
  int len, i, loc;
  Boolean b;
  XEN lst = XEN_EMPTY_LIST;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmWidgetGetBaselines", "Widget");
  b = XmWidgetGetBaselines(XEN_TO_C_Widget(arg1), &ds, &len);
  if (!b)
    return(XEN_FALSE);
  loc = xm_protect(lst);
  for (i = len - 1; i >= 0; i--)
    lst = XEN_CONS(C_TO_XEN_Dimension(ds[i]), lst);
  free(ds);
  xm_unprotect_at(loc);
  return(lst);
}

static XEN gxm_XmWidgetGetDisplayRect(XEN arg1)
{
  #define H_XmWidgetGetDisplayRect "Boolean XmWidgetGetDisplayRect(Widget widget) returns widget's bounding box as XRectangle"
  XRectangle *r;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmWidgetGetDisplayRect", "Widget");
  r = (XRectangle *)CALLOC(1, sizeof(XRectangle));
  if (!(XmWidgetGetDisplayRect(XEN_TO_C_Widget(arg1), r)))
    {
      FREE(r);
      return(XEN_FALSE);
    }
  return(C_TO_XEN_XRectangle(r));
}

static XEN gxm_XmObjectAtPoint(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmObjectAtPoint "Widget XmObjectAtPoint(Widget widget, Position x, Position y) determines which child \
intersects or comes closest to a specified point"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmObjectAtPoint", "Widget");
  XEN_ASSERT_TYPE(XEN_Position_P(arg2), arg2, 2, "XmObjectAtPoint", "Position");
  XEN_ASSERT_TYPE(XEN_Position_P(arg3), arg3, 3, "XmObjectAtPoint", "Position");
  return(C_TO_XEN_Widget(XmObjectAtPoint(XEN_TO_C_Widget(arg1), XEN_TO_C_Position(arg2), XEN_TO_C_Position(arg3))));
}

static XEN gxm_XmUpdateDisplay(XEN arg1)
{
  #define H_XmUpdateDisplay "void XmUpdateDisplay (widget) processes all pending exposure events immediately"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmUpdateDisplay", "Widget");
  XmUpdateDisplay(XEN_TO_C_Widget(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmDestroyPixmap(XEN arg1, XEN arg2)
{
  #define H_XmDestroyPixmap "Boolean XmDestroyPixmap(Screen *screen, Pixmap pixmap) removes a pixmap from the pixmap cache"
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XmDestroyPixmap", "Screen*");
  XEN_ASSERT_TYPE(XEN_Pixmap_P(arg2), arg2, 2, "XmDestroyPixmap", "Pixmap");
  return(C_TO_XEN_BOOLEAN(XmDestroyPixmap(XEN_TO_C_Screen(arg1), 
					  XEN_TO_C_Pixmap(arg2))));
}

static XEN gxm_XmGetPixmapByDepth(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XmGetPixmapByDepth "Pixmap XmGetPixmapByDepth(Screen *screen, char *image_name, Pixel foreground, Pixel background, int depth) \
generates a pixmap, stores it in a pixmap cache, and returns the pixmap"
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XmGetPixmapByDepth", "Screen*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmGetPixmapByDepth", "char*");
  XEN_ASSERT_TYPE(XEN_Pixel_P(arg3), arg3, 3, "XmGetPixmapByDepth", "Pixel");
  XEN_ASSERT_TYPE(XEN_Pixel_P(arg4), arg4, 4, "XmGetPixmapByDepth", "Pixel");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XmGetPixmapByDepth", "int");
  return(C_TO_XEN_Pixmap(XmGetPixmapByDepth(XEN_TO_C_Screen(arg1), 
					    XEN_TO_C_STRING(arg2), 
					    XEN_TO_C_Pixel(arg3), 
					    XEN_TO_C_Pixel(arg4), 
					    XEN_TO_C_INT(arg5))));
}

static XEN gxm_XmGetPixmap(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmGetPixmap "Pixmap XmGetPixmap(Screen *screen, char *image_name, Pixel foreground, Pixel background) A pixmap caching function \
that generates a pixmap, stores it in a pixmap cache, and returns the pixmap"
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XmGetPixmap", "Screen*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmGetPixmap", "char*");
  XEN_ASSERT_TYPE(XEN_Pixel_P(arg3), arg3, 3, "XmGetPixmap", "Pixel");
  XEN_ASSERT_TYPE(XEN_Pixel_P(arg4), arg4, 4, "XmGetPixmap", "Pixel");
  return(C_TO_XEN_Pixmap(XmGetPixmap(XEN_TO_C_Screen(arg1), 
				     XEN_TO_C_STRING(arg2), 
				     XEN_TO_C_Pixel(arg3), 
				     XEN_TO_C_Pixel(arg4))));
}

static XEN gxm_XmUninstallImage(XEN arg1)
{
  #define H_XmUninstallImage "Boolean XmUninstallImage(XImage *image) removes an image from the image cache"
  XEN_ASSERT_TYPE(XEN_XImage_P(arg1), arg1, 1, "XmUninstallImage", "XImage*");
  return(C_TO_XEN_BOOLEAN(XmUninstallImage(XEN_TO_C_XImage(arg1))));
}

static XEN gxm_XmInstallImage(XEN arg1, XEN arg2)
{
  #define H_XmInstallImage "Boolean XmInstallImage(XImage *image, char *image_name) adds an image to the image cache"
  XEN_ASSERT_TYPE(XEN_XImage_P(arg1), arg1, 1, "XmInstallImage", "XImage*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmInstallImage", "char*");
  return(C_TO_XEN_BOOLEAN(XmInstallImage(XEN_TO_C_XImage(arg1), 
					 XEN_TO_C_STRING(arg2))));
}

static XEN gxm_XmCreateMainWindow(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateMainWindow "Widget XmCreateMainWindow(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The MainWindow widget creation function"
  return(gxm_new_widget("XmCreateMainWindow", XmCreateMainWindow, arg1, arg2, arg3, arg4));
}

#if (!XM_DISABLE_DEPRECATED)
#define XEN_MainWindowWidget_P(Arg) (XEN_Widget_P(Arg) && XmIsMainWindow(XEN_TO_C_Widget(Arg)))

static XEN gxm_XmMainWindowSep3(XEN arg1)
{
  #define H_XmMainWindowSep3 "Widget XmMainWindowSep3(Widget widget) returns the widget ID of the third Separator widget"
  XEN_ASSERT_TYPE(XEN_MainWindowWidget_P(arg1), arg1, 1, "XmMainWindowSep3", "MainWindow Widget");
  return(C_TO_XEN_Widget(XmMainWindowSep3(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmMainWindowSep2(XEN arg1)
{
  #define H_XmMainWindowSep2 "Widget XmMainWindowSep2(Widget widget) the widget ID of the second Separator widget"
  XEN_ASSERT_TYPE(XEN_MainWindowWidget_P(arg1), arg1, 1, "XmMainWindowSep2", "MainWindow Widget");
  return(C_TO_XEN_Widget(XmMainWindowSep2(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmMainWindowSep1(XEN arg1)
{
  #define H_XmMainWindowSep1 "Widget XmMainWindowSep1(Widget widget) returns the widget ID of the first Separator"
  XEN_ASSERT_TYPE(XEN_MainWindowWidget_P(arg1), arg1, 1, "XmMainWindowSep1", "MainWindow Widget");
  return(C_TO_XEN_Widget(XmMainWindowSep1(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmMainWindowSetAreas(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6)
{
  #define H_XmMainWindowSetAreas "void XmMainWindowSetAreas(Widget widget, Widget menu_bar, Widget command_window, Widget horizontal_scrollbar, \
Widget vertical_scrollbar, Widget work_region) identifies manageable children for each area"
  XEN_ASSERT_TYPE(XEN_MainWindowWidget_P(arg1), arg1, 1, "XmMainWindowSetAreas", "MainWindow Widget");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg2) || XEN_BOOLEAN_P(arg2), arg2, 2, "XmMainWindowSetAreas", "Widget or " PROC_FALSE "=null");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg3) || XEN_BOOLEAN_P(arg3), arg3, 3, "XmMainWindowSetAreas", "Widget or " PROC_FALSE "=null");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg4) || XEN_BOOLEAN_P(arg4), arg4, 4, "XmMainWindowSetAreas", "Widget or " PROC_FALSE "=null");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg5) || XEN_BOOLEAN_P(arg5), arg5, 5, "XmMainWindowSetAreas", "Widget or " PROC_FALSE "=null");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg6) || XEN_BOOLEAN_P(arg6), arg6, 6, "XmMainWindowSetAreas", "Widget or " PROC_FALSE "=null");
  XmMainWindowSetAreas(XEN_TO_C_Widget(arg1),
		       (XEN_Widget_P(arg2) ? XEN_TO_C_Widget(arg2) : NULL),
		       (XEN_Widget_P(arg3) ? XEN_TO_C_Widget(arg3) : NULL),
		       (XEN_Widget_P(arg4) ? XEN_TO_C_Widget(arg4) : NULL),
		       (XEN_Widget_P(arg5) ? XEN_TO_C_Widget(arg5) : NULL),
		       (XEN_Widget_P(arg6) ? XEN_TO_C_Widget(arg6) : NULL));
  return(XEN_FALSE);
}
#endif

static XEN gxm_XmTranslateKey(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmTranslateKey "void XmTranslateKey(Display *display, KeyCode keycode, Modifiers modifiers) \
The default keycode-to-keysym translator -> (modifiers keysym)"
  /* DIFF: XmTranslateKey omit and rtn last 2 args
   */
  Modifiers m;
  KeySym k;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmTranslateKey", "Display*");
  XEN_ASSERT_TYPE(XEN_KeyCode_P(arg2), arg2, 2, "XmTranslateKey", "KeyCode");
  XEN_ASSERT_TYPE(XEN_Modifiers_P(arg3), arg3, 3, "XmTranslateKey", "Modifiers");
  XmTranslateKey(XEN_TO_C_Display(arg1), XEN_TO_C_KeyCode(arg2), XEN_TO_C_Modifiers(arg3), &m, &k);
  return(XEN_LIST_2(C_TO_XEN_Modifiers(m),
		    C_TO_XEN_KeySym(k)));
}

static XEN gxm_XmCreateScrolledList(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateScrolledList "Widget XmCreateScrolledList(Widget parent, String name, ArgList arglist, Cardinal argcount) The List \
ScrolledList creation function"
  return(gxm_new_widget("XmCreateScrolledList", XmCreateScrolledList, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateList(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateList "Widget XmCreateList(Widget parent, String name, ArgList arglist, Cardinal argcount) The List widget creation function"
  return(gxm_new_widget("XmCreateList", XmCreateList, arg1, arg2, arg3, arg4));
}

#define XEN_ListWidget_P(Arg) (XEN_Widget_P(Arg) && XmIsList(XEN_TO_C_Widget(Arg)))

static XEN gxm_XmListPosSelected(XEN arg1, XEN arg2)
{
  #define H_XmListPosSelected "Boolean XmListPosSelected(Widget widget, int position) determines if the list item at a \
specified position is selected"
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListPosSelected", "List Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmListPosSelected", "int");
  return(C_TO_XEN_BOOLEAN(XmListPosSelected(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XmListUpdateSelectedList(XEN arg1)
{
  #define H_XmListUpdateSelectedList "void XmListUpdateSelectedList(Widget widget) updates the XmNselectedItems resource"
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListUpdateSelectedList", "List Widget");
  XmListUpdateSelectedList(XEN_TO_C_Widget(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmListSetHorizPos(XEN arg1, XEN arg2)
{
  #define H_XmListSetHorizPos "void XmListSetHorizPos(Widget widget, int position) scrolls to the specified position in the list"
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListSetHorizPos", "List Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmListSetHorizPos", "int");
  XmListSetHorizPos(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmListGetSelectedPos(XEN arg1)
{
  #define H_XmListGetSelectedPos "Boolean XmListGetSelectedPos(Widget widget) A List function that returns the position of every selected item in the list"
  /* DIFF: XmListGetSelectedPos omits args 2 and 3, returns list of positions
   */
  int *ps;
  int i, len, loc;
  Boolean b;
  XEN lst = XEN_EMPTY_LIST;
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListGetSelectedPos", "List Widget");
  b = XmListGetSelectedPos(XEN_TO_C_Widget(arg1), &ps, &len);
  if (!b)
    return(XEN_FALSE);
  loc = xm_protect(lst);
  for (i = len - 1; i >= 0; i--)
    lst = XEN_CONS(C_TO_XEN_INT(ps[i]), lst);
  free(ps);
  xm_unprotect_at(loc);
  return(lst);
}

static XEN gxm_XmListGetMatchPos(XEN arg1, XEN arg2)
{
  #define H_XmListGetMatchPos "Boolean XmListGetMatchPos(Widget widget, XmString item) returns all instances of an item in the list"
  /* DIFF: XmListGetSelectedPos omits args 3 and 4, returns list of positions
   */
  int *ps;
  int i, len, loc;
  Boolean b;
  XEN lst = XEN_EMPTY_LIST;
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListGetMatchPos", "List Widget");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmListGetMatchPos", "XmString");
  b = XmListGetMatchPos(XEN_TO_C_Widget(arg1), XEN_TO_C_XmString(arg2), &ps, &len);
  if (!b)
    return(XEN_FALSE);
  loc = xm_protect(lst);
  for (i = len - 1; i >= 0; i--)
    lst = XEN_CONS(C_TO_XEN_INT(ps[i]), lst);
  free(ps);
  xm_unprotect_at(loc);
  return(lst);
}

static XEN gxm_XmListPosToBounds(XEN arg1, XEN arg2)
{
  #define H_XmListPosToBounds "Boolean XmListPosToBounds(Widget widget, int position) returns the bounding box of an item at a specified position in a list"
  /* DIFF: XmListPosToBounds last 4 args omitted and returned 
   */
  Position x, y;
  Dimension w, h;
  int val;
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListPosToBounds", "List Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmListPosToBounds", "int");
  val = XmListPosToBounds(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2), &x, &y, &w, &h);
  return(XEN_LIST_5(C_TO_XEN_BOOLEAN(val),
		    C_TO_XEN_Position(x),
		    C_TO_XEN_Position(y),
		    C_TO_XEN_Dimension(w),
		    C_TO_XEN_Dimension(h)));
}


static XEN gxm_XmListYToPos(XEN arg1, XEN arg2)
{
  #define H_XmListYToPos "int XmListYToPos(Widget widget, Position y) returns the position of the item at a specified y-coordinate"
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListYToPos", "List Widget");
  XEN_ASSERT_TYPE(XEN_Position_P(arg2), arg2, 2, "XmListYToPos", "Position");
  return(C_TO_XEN_INT(XmListYToPos(XEN_TO_C_Widget(arg1), XEN_TO_C_Position(arg2))));
}

static XEN gxm_XmListSetKbdItemPos(XEN arg1, XEN arg2)
{
  #define H_XmListSetKbdItemPos "Boolean XmListSetKbdItemPos(Widget widget, int position) sets the location cursor at a specified position"
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListSetKbdItemPos", "List Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmListSetKbdItemPos", "int");
  return(C_TO_XEN_BOOLEAN(XmListSetKbdItemPos(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XmListGetKbdItemPos(XEN arg1)
{
  #define H_XmListGetKbdItemPos "int XmListGetKbdItemPos(Widget widget) returns the position of the item at the location cursor"
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListGetKbdItemPos", "List Widget");
  return(C_TO_XEN_INT(XmListGetKbdItemPos(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmListItemPos(XEN arg1, XEN arg2)
{
  #define H_XmListItemPos "int XmListItemPos(Widget widget, XmString item) returns the position of an item in the list"
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListItemPos", "List Widget");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmListItemPos", "XmString");
  return(C_TO_XEN_INT(XmListItemPos(XEN_TO_C_Widget(arg1), XEN_TO_C_XmString(arg2))));
}

static XEN gxm_XmListItemExists(XEN arg1, XEN arg2)
{
  #define H_XmListItemExists "Boolean XmListItemExists(Widget widget, XmString item) checks if a specified item is in the list"
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListItemExists", "List Widget");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmListItemExists", "XmString");
  return(C_TO_XEN_BOOLEAN(XmListItemExists(XEN_TO_C_Widget(arg1), XEN_TO_C_XmString(arg2))));
}

static XEN gxm_XmListSetAddMode(XEN arg1, XEN arg2)
{
  #define H_XmListSetAddMode "void XmListSetAddMode(Widget widget, Boolean state) sets add mode in the list"
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListSetAddMode", "List Widget");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg2), arg2, 2, "XmListSetAddMode", "boolean");
  XmListSetAddMode(XEN_TO_C_Widget(arg1), XEN_TO_C_BOOLEAN(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmListSetBottomItem(XEN arg1, XEN arg2)
{
  #define H_XmListSetBottomItem "void XmListSetBottomItem(Widget widget, XmString item) makes an existing item the last \
visible item in the list"
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListSetBottomItem", "List Widget");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmListSetBottomItem", "XmString");
  XmListSetBottomItem(XEN_TO_C_Widget(arg1), XEN_TO_C_XmString(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmListSetItem(XEN arg1, XEN arg2)
{
  #define H_XmListSetItem "void XmListSetItem(Widget widget, XmString item) makes an existing item the first visible item in the list"
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListSetItem", "List Widget");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmListSetItem", "XmString");
  XmListSetItem(XEN_TO_C_Widget(arg1), XEN_TO_C_XmString(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmListSetBottomPos(XEN arg1, XEN arg2)
{
  #define H_XmListSetBottomPos "void XmListSetBottomPos(Widget widget, int position) makes a specified item the last visible item in the list"
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListSetBottomPos", "List Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmListSetBottomPos", "int");
  XmListSetBottomPos(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmListSetPos(XEN arg1, XEN arg2)
{
  #define H_XmListSetPos "void XmListSetPos(Widget widget, int position) makes the item at the given position the first \
visible position in the list"
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListSetPos", "List Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmListSetPos", "int");
  XmListSetPos(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmListDeselectAllItems(XEN arg1)
{
  #define H_XmListDeselectAllItems "void XmListDeselectAllItems(Widget widget) unhighlights and removes all items from the selected list"
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListDeselectAllItems", "List Widget");
  XmListDeselectAllItems(XEN_TO_C_Widget(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmListDeselectPos(XEN arg1, XEN arg2)
{
  #define H_XmListDeselectPos "void XmListDeselectPos(Widget widget, int position) deselects an item at a specified position in the list"
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListDeselectPos", "List Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmListDeselectPos", "int");
  XmListDeselectPos(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmListDeselectItem(XEN arg1, XEN arg2)
{
  #define H_XmListDeselectItem "void XmListDeselectItem(Widget widget, XmString item) deselects the specified item from the selected list"
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListDeselectItem", "List Widget");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmListDeselectItem", "XmString");
  XmListDeselectItem(XEN_TO_C_Widget(arg1), XEN_TO_C_XmString(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmListSelectPos(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmListSelectPos "void XmListSelectPos(Widget widget, int position, Boolean notify) selects an item at a specified \
position in the list"
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListSelectPos", "List Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmListSelectPos", "int");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg3), arg3, 3, "XmListSelectPos", "boolean");
  XmListSelectPos(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_BOOLEAN(arg3));
  return(XEN_FALSE);
}

static XEN gxm_XmListSelectItem(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmListSelectItem "void XmListSelectItem(Widget widget, XmString item, Boolean notify) selects an item in the list"
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListSelectItem", "List Widget");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmListSelectItem", "XmString");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg3), arg3, 3, "XmListSelectItem", "boolean");
  XmListSelectItem(XEN_TO_C_Widget(arg1), XEN_TO_C_XmString(arg2), XEN_TO_C_BOOLEAN(arg3));
  return(XEN_FALSE);
}

static XEN gxm_XmListReplacePositions(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmListReplacePositions "void XmListReplacePositions(Widget widget, int *position_list, XmString *item_list, int item_count) \
replaces items in a list based on position"
  /* DIFF: XmListReplacePositions arg 2 is list of ints, arg3 is list of XmStrings
   */
  int *ps;
  XmString *str;
  int len;
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListReplacePositions", "List Widget");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XmListReplacePositions", "list of int");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg3), arg3, 3, "XmListReplacePositions", "list of XmString");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg4), arg4, 4, "XmListReplacePositions", "int");
  if (XEN_INTEGER_P(arg4)) len = XEN_TO_C_INT(arg4); else len = XEN_LIST_LENGTH(arg3);
  if (len <= 0) return(XEN_FALSE);
  ps = XEN_TO_C_Ints(arg2, len);
  str = XEN_TO_C_XmStrings(arg3, len);
  XmListReplacePositions(XEN_TO_C_Widget(arg1), ps, str, len);
  FREE(ps);
  FREE(str);
  return(XEN_FALSE);
}

static XEN gxm_XmListReplaceItemsPosUnselected(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmListReplaceItemsPosUnselected "void XmListReplaceItemsPosUnselected(Widget widget, XmString *new_items, int item_count, int position) \
replaces items in a list without selecting the replacement items"
  /* DIFF: XmListReplaceItemsPosUnselected arg 2 is list of XmStrings
   */
  XmString *str;
  int len;
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListReplaceItemsPosUnselected", "List Widget");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XmListReplaceItemsPosUnselected", "list of XmString");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmListReplaceItemsPosUnselected", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XmListReplaceItemsPosUnselected", "int");
  len = XEN_TO_C_INT(arg3);
  if (len <= 0) return(XEN_FALSE);
  str = XEN_TO_C_XmStrings(arg2, len);
  XmListReplaceItemsPosUnselected(XEN_TO_C_Widget(arg1), str, len, XEN_TO_C_INT(arg4));
  FREE(str);
  return(XEN_FALSE);
}

static XEN gxm_XmListReplaceItemsUnselected(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmListReplaceItemsUnselected "void XmListReplaceItemsUnselected(Widget widget, XmString *old_items, int item_count, XmString *new_items) \
replaces items in a list"
  /* DIFF: XmListReplaceItemsUnselected args 2 and 4 are lists of XmStrings
   */
  XmString *str1, *str2;
  int len;
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListReplaceItemsUnselected", "List Widget");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XmListReplaceItemsUnselected", "list of XmString");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmListReplaceItemsUnselected", "int");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg4), arg4, 4, "XmListReplaceItemsUnselected", "list of XmString");
  len = XEN_TO_C_INT(arg3);
  if (len <= 0) return(XEN_FALSE);
  str1 = XEN_TO_C_XmStrings(arg2, len);
  str2 = XEN_TO_C_XmStrings(arg4, len);
  XmListReplaceItemsUnselected(XEN_TO_C_Widget(arg1), str1, len, str2);
  FREE(str1);
  FREE(str2);
  return(XEN_FALSE);
}

static XEN gxm_XmListReplaceItemsPos(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmListReplaceItemsPos "void XmListReplaceItemsPos(Widget widget, XmString *new_items, int item_count, int position) \
replaces the specified elements in the list"
  /* DIFF: XmListReplaceItemsPos arg 2 is list of XmStrings
   */
  XmString *str;
  int len;
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListReplaceItemsPos", "List Widget");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XmListReplaceItemsPos", "list of XmString");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmListReplaceItemsPos", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XmListReplaceItemsPos", "int");
  len = XEN_TO_C_INT(arg3);
  if (len <= 0) return(XEN_FALSE);
  str = XEN_TO_C_XmStrings(arg2, len);
  XmListReplaceItemsPos(XEN_TO_C_Widget(arg1), str, len, XEN_TO_C_INT(arg4));
  FREE(str);
  return(XEN_FALSE);
}

static XEN gxm_XmListReplaceItems(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmListReplaceItems "void XmListReplaceItems(Widget widget, XmString *old_items, int item_count, XmString *new_items) \
replaces the specified elements in the list"
  /* DIFF: XmListReplaceItems args 2 and 4 are lists of XmStrings
   */
  XmString *str1, *str2;
  int len;
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListReplaceItems", "List Widget");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XmListReplaceItems", "list of XmString");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmListReplaceItems", "int");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg4), arg4, 4, "XmListReplaceItems", "XmString*");
  len = XEN_TO_C_INT(arg3);
  if (len <= 0) return(XEN_FALSE);
  str1 = XEN_TO_C_XmStrings(arg2, len);
  str2 = XEN_TO_C_XmStrings(arg4, len);
  XmListReplaceItems(XEN_TO_C_Widget(arg1), str1, len, str2);
  FREE(str1);
  FREE(str2);
  return(XEN_FALSE);
}

static XEN gxm_XmListDeleteAllItems(XEN arg1)
{
  #define H_XmListDeleteAllItems "void XmListDeleteAllItems(Widget widget) deletes all items from the list"
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListDeleteAllItems", "List Widget");
  XmListDeleteAllItems(XEN_TO_C_Widget(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmListDeleteItemsPos(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmListDeleteItemsPos "void XmListDeleteItemsPos(Widget widget, int item_count, int position) deletes \
items from the list starting at the given position"
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListDeleteItemsPos", "List Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmListDeleteItemsPos", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmListDeleteItemsPos", "int");
  XmListDeleteItemsPos(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_INT(arg3));
  return(XEN_FALSE);
}

static XEN gxm_XmListDeletePos(XEN arg1, XEN arg2)
{
  #define H_XmListDeletePos "void XmListDeletePos(Widget widget, int position) deletes an item from a list at a specified position"
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListDeletePos", "List Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmListDeletePos", "int");
  XmListDeletePos(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmListDeletePositions(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmListDeletePositions "void XmListDeletePositions(Widget widget, int *position_list, int position_count) deletes \
items from a list based on an array of positions"
  /* DIFF: XmListDeletePositions arg2 is list of ints
   */
  int *pos;
  int len;
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListDeletePositions", "List Widget");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XmListDeletePositions", "list of int");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg3), arg3, 3, "XmListDeletePositions", "int");
  if (XEN_INTEGER_P(arg3)) len = XEN_TO_C_INT(arg3); else len = XEN_LIST_LENGTH(arg2);
  if (len <= 0) return(XEN_FALSE);
  pos = XEN_TO_C_Ints(arg2, len);
  XmListDeletePositions(XEN_TO_C_Widget(arg1), pos, len);
  FREE(pos);
  return(XEN_FALSE);
}

static XEN gxm_XmListDeleteItems(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmListDeleteItems "void XmListDeleteItems(Widget widget, XmString *items, int item_count) deletes items from the list"
  /* DIFF: XmListDeleteItems arg 2 is list of XmStrings
   */
  XmString *str;
  int len;
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListDeleteItems", "List Widget");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XmListDeleteItems", "list of XmString");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg3), arg3, 3, "XmListDeleteItems", "int");
  if (XEN_INTEGER_P(arg3)) len = XEN_TO_C_INT(arg3); else len = XEN_LIST_LENGTH(arg2);
  if (len <= 0) return(XEN_FALSE);
  str = XEN_TO_C_XmStrings(arg2, len);
  XmListDeleteItems(XEN_TO_C_Widget(arg1), str, len);
  FREE(str);
  return(XEN_FALSE);
}

static XEN gxm_XmListDeleteItem(XEN arg1, XEN arg2)
{
  #define H_XmListDeleteItem "void XmListDeleteItem(Widget widget, XmString item) deletes an item from the list"
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListDeleteItem", "List Widget");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmListDeleteItem", "XmString");
  XmListDeleteItem(XEN_TO_C_Widget(arg1), XEN_TO_C_XmString(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmListAddItemUnselected(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmListAddItemUnselected "void XmListAddItemUnselected(Widget widget, XmString item, int position) adds an item to the list"
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListAddItemUnselected", "List Widget");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmListAddItemUnselected", "XmString");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmListAddItemUnselected", "int");
  XmListAddItemUnselected(XEN_TO_C_Widget(arg1), XEN_TO_C_XmString(arg2), XEN_TO_C_INT(arg3));
  return(XEN_FALSE);
}

static XEN gxm_XmListAddItemsUnselected(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmListAddItemsUnselected "void XmListAddItemsUnselected(Widget widget, XmString *items, int item_count, int position) \
adds items to a list"
  /* DIFF: XmListAddItemsUnselected arg 2 is list of XmStrings
   */
  XmString *str;
  int len;
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListAddItemsUnselected", "List Widget");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XmListAddItemsUnselected", "list of XmString");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmListAddItemsUnselected", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XmListAddItemsUnselected", "int");
  len = XEN_TO_C_INT(arg3);
  if (len <= 0) return(XEN_FALSE);
  str = XEN_TO_C_XmStrings(arg2, len);
  XmListAddItemsUnselected(XEN_TO_C_Widget(arg1), str, len, XEN_TO_C_INT(arg4));
  FREE(str);
  return(XEN_FALSE);
}

static XEN gxm_XmListAddItems(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmListAddItems "void XmListAddItems(Widget widget, XmString *items, int item_count, int position) adds items to the list"
  /* DIFF: XmListAddItems arg 2 is list of XmStrings
   */
  XmString *str;
  int len;
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListAddItems", "List Widget");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XmListAddItems", "XmString*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmListAddItems", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XmListAddItems", "int");
  len = XEN_TO_C_INT(arg3);
  if (len <= 0) return(XEN_FALSE);
  str = XEN_TO_C_XmStrings(arg2, len);
  XmListAddItems(XEN_TO_C_Widget(arg1), str, len, XEN_TO_C_INT(arg4));
  FREE(str);
  return(XEN_FALSE);
}

static XEN gxm_XmListAddItem(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmListAddItem "void XmListAddItem(Widget widget, XmString item, int position) adds an item to the list"
  XEN_ASSERT_TYPE(XEN_ListWidget_P(arg1), arg1, 1, "XmListAddItem", "List Widget");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmListAddItem", "XmString");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmListAddItem", "int");
  XmListAddItem(XEN_TO_C_Widget(arg1), XEN_TO_C_XmString(arg2), XEN_TO_C_INT(arg3));
  return(XEN_FALSE);
}

static XEN gxm_XmIsMotifWMRunning(XEN arg1)
{
  #define H_XmIsMotifWMRunning "Boolean XmIsMotifWMRunning(Widget shell)  determines whether the window manager is running"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmIsMotifWMRunning", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsMotifWMRunning(XEN_TO_C_Widget(arg1))));
}

/* DIFF: all XmCreate<Obj> arglist is a list of args 
 */
static XEN gxm_XmCreateLabel(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateLabel "Widget XmCreateLabel(Widget parent, String name, ArgList arglist, Cardinal argcount) The Label widget creation function"
  return(gxm_new_widget("XmCreateLabel", XmCreateLabel, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateLabelGadget(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateLabelGadget "Widget XmCreateLabelGadget(Widget parent, String name, ArgList arglist, Cardinal argcount) The LabelGadget creation function"
  return(gxm_new_widget("XmCreateLabelGadget", XmCreateLabelGadget, arg1, arg2, arg3, arg4));
}

#if HAVE_XmToolTipGetLabel
static XEN gxm_XmToolTipGetLabel(XEN arg1)
{
  #define H_XmToolTipGetLabel "Widget XmToolTipGetLabel(Widget wid) apparently returns the tooltip label associated with its argument"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, XEN_ONLY_ARG, "XmToolTipGetLabel", "Widget");
  return(C_TO_XEN_Widget(XmToolTipGetLabel(XEN_TO_C_Widget(arg1))));
}
#endif

#if HAVE_XmCreateTabStack

#ifndef XmIsTabStack
#define XmIsTabStack(w) (XtIsSubclass(w, xmTabStackWidgetClass))
#endif

static XEN gxm_XmCreateTabStack(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateTabStack "Widget XmCreateTabStack(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The TabStack widget creation function"
  return(gxm_new_widget("XmCreateTabStack", XmCreateTabStack, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmIsTabStack(XEN arg)
{
  #define H_XmIsTabStack "XmIsTabStack(arg) -> #t if arg is a TabStack widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsTabStack", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsTabStack(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmTabStackGetSelectedTab(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmTabStackGetSelectedTab", "Widget");
  return(C_TO_XEN_Widget(XmTabStackGetSelectedTab(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmTabStackSelectTab(XEN arg, XEN arg1)
{
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 1, "XmTabStackSelectTab", "Widget");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg1), arg1, 2, "XmTabStackSelectTab", "boolean");
  XmTabStackSelectTab(XEN_TO_C_Widget(arg), XEN_TO_C_BOOLEAN(arg1));
  return(XEN_FALSE);
}

#if HAVE_XmTabStackXYToWidget
static XEN gxm_XmTabStackIndexToWidget(XEN arg, XEN arg1)
{
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 1, "XmTabStackIndexToWidget", "Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg1), arg1, 2, "XmTabStackIndexToWidget", "int");
  return(XEN_TO_C_Widget(XmTabStackIndexToWidget(XEN_TO_C_Widget(arg), XEN_TO_C_INT(arg1))));
}

static XEN gxm_XmTabStackXYToWidget(XEN arg, XEN arg1, XEN arg2)
{
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 1, "XmTabStackXYToWidget", "Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg1), arg1, 2, "XmTabStackXYToWidget", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 3, "XmTabStackXYToWidget", "int");
  return(XEN_TO_C_Widget(XmTabStackXYToWidget(XEN_TO_C_Widget(arg), XEN_TO_C_INT(arg1), XEN_TO_C_INT(arg2))));
}
#endif
#endif

#if HAVE_XmCreateDataField

#ifndef XmIsDataField
#define XmIsDataField(w) (XtIsSubclass(w, xmDataFieldWidgetClass))
#endif

static XEN gxm_XmCreateDataField(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateDataField "Widget XmCreateDataField(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The DataField widget creation function"
  return(gxm_new_widget("XmCreateDataField", XmCreateDataField, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmIsDataField(XEN arg)
{
  #define H_XmIsDataField "XmIsDataField(arg) -> #t if arg is a DataField widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsDataField", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsDataField(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmDataFieldGetString(XEN arg)
{
  char *str;
  XEN rtn;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmDataFieldGetString", "Widget");
  str = XmDataFieldGetString(XEN_TO_C_Widget(arg));
  rtn = C_TO_XEN_STRING(str);
  if (str) XtFree(str);
  return(rtn);
}

static XEN gxm_XmDataFieldGetSelection(XEN arg)
{
  char *str;
  XEN rtn;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmDataFieldGetSelection", "Widget");
  str = XmDataFieldGetSelection(XEN_TO_C_Widget(arg));
  rtn = C_TO_XEN_STRING(str);
  if (str) XtFree(str);
  return(rtn);
}

static XEN gxm_XmDataFieldPaste(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmDataFieldPaste", "Widget");
  return(C_TO_XEN_BOOLEAN(XmDataFieldPaste(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmDataFieldCut(XEN arg, XEN arg1)
{
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 1, "XmDataFieldCut", "Widget");
  XEN_ASSERT_TYPE(XEN_Time_P(arg1), arg1, 2, "XmDataFieldCut", "Time");
  return(C_TO_XEN_BOOLEAN(XmDataFieldCut(XEN_TO_C_Widget(arg), XEN_TO_C_Time(arg1))));
}

static XEN gxm_XmDataFieldCopy(XEN arg, XEN arg1)
{
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 1, "XmDataFieldCopy", "Widget");
  XEN_ASSERT_TYPE(XEN_Time_P(arg1), arg1, 2, "XmDataFieldCopy", "Time");
  return(C_TO_XEN_BOOLEAN(XmDataFieldCopy(XEN_TO_C_Widget(arg), XEN_TO_C_Time(arg1))));
}

static XEN gxm_XmDataFieldSetString(XEN arg, XEN arg1)
{
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 1, "XmDataFieldSetString", "Widget");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 2, "XmDataFieldSetString", "char*");
  XmDataFieldSetString(XEN_TO_C_Widget(arg), XEN_TO_C_STRING(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmDataFieldSetEditable(XEN arg, XEN arg1)
{
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 1, "XmDataFieldSetEditable", "Widget");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg1), arg1, 2, "XmDataFieldSetEditable", "boolean");
  XmDataFieldSetEditable(XEN_TO_C_Widget(arg), XEN_TO_C_BOOLEAN(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmDataFieldSetAddMode(XEN arg, XEN arg1)
{
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 1, "XmDataFieldSetAddMode", "Widget");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg1), arg1, 2, "XmDataFieldSetAddMode", "boolean");
  XmDataFieldSetAddMode(XEN_TO_C_Widget(arg), XEN_TO_C_BOOLEAN(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmDataFieldSetInsertionPosition(XEN arg, XEN arg1)
{
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 1, "XmDataFieldSetInsertionPosition", "Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg1), arg1, 2, "XmDataFieldSetInsertionPosition", "int");
  XmDataFieldSetInsertionPosition(XEN_TO_C_Widget(arg), (XmTextPosition)XEN_TO_C_INT(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmDataFieldShowPosition(XEN arg, XEN arg1)
{
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 1, "XmDataFieldShowPosition", "Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg1), arg1, 2, "XmDataFieldShowPosition", "int");
  XmDataFieldShowPosition(XEN_TO_C_Widget(arg), (XmTextPosition)XEN_TO_C_INT(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmDataFieldXYToPos(XEN arg, XEN arg1, XEN arg2)
{
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 1, "XmDataFieldXYToPos", "Widget");
  XEN_ASSERT_TYPE(XEN_Position_P(arg1), arg1, 2, "XmDataFieldXYToPos", "Position");
  XEN_ASSERT_TYPE(XEN_Position_P(arg2), arg2, 3, "XmDataFieldXYToPos", "Position");
  return(C_TO_XEN_INT((int)(XmDataFieldXYToPos(XEN_TO_C_Widget(arg), XEN_TO_C_Position(arg1), XEN_TO_C_Position(arg2)))));
}

static XEN gxm_XmDataFieldSetHighlight(XEN arg, XEN arg1, XEN arg2, XEN arg3)
{
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 1, "XmDataFieldSetHighlight", "Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg1), arg1, 2, "XmDataFieldSetHighlight", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 3, "XmDataFieldSetHighlight", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg3, 4, "XmDataFieldSetHighlight", "int (highligh mode)");
  XmDataFieldSetHighlight(XEN_TO_C_Widget(arg), (XmTextPosition)XEN_TO_C_INT(arg1), (XmTextPosition)XEN_TO_C_INT(arg2), 
			  (XmHighlightMode)XEN_TO_C_INT(arg3));
  return(XEN_FALSE);
}

static XEN gxm_XmDataFieldSetSelection(XEN arg, XEN arg1, XEN arg2, XEN arg3)
{
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 1, "XmDataFieldSetSelection", "Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg1), arg1, 2, "XmDataFieldSetSelection", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 3, "XmDataFieldSetSelection", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg3, 4, "XmDataFieldSetSelection", "Time");
  XmDataFieldSetSelection(XEN_TO_C_Widget(arg), (XmTextPosition)XEN_TO_C_INT(arg1), (XmTextPosition)XEN_TO_C_INT(arg2), XEN_TO_C_Time(arg3));
  return(XEN_FALSE);
}

static XEN gxm_XmDataFieldGetSelectionPosition(XEN arg)
{
  XmTextPosition pos1 = 0, pos2 = 0;
  Boolean val = False;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmDataFieldGetSelectionPosition", "Widget");
  val = XmDataFieldGetSelectionPosition(XEN_TO_C_Widget(arg), &pos1, &pos2);
  return(XEN_LIST_3(C_TO_XEN_BOOLEAN(val),
		    C_TO_XEN_INT((int)pos1),
		    C_TO_XEN_INT((int)pos2)));
}
#endif

#if HAVE_XmCreateButtonBox
static XEN gxm_XmCreateButtonBox(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateButtonBox "Widget XmCreateButtonBox(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The ButtonBox widget creation function"
  return(gxm_new_widget("XmCreateButtonBox", XmCreateButtonBox, arg1, arg2, arg3, arg4));
}

#ifndef XmIsButtonBox
#define XmIsButtonBox(w) (XtIsSubclass(w, xmButtonBoxWidgetClass))
#endif

static XEN gxm_XmIsButtonBox(XEN arg)
{
  #define H_XmIsButtonBox "XmIsButtonBox(arg) -> #t if arg is a ButtonBox widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsButtonBox", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsButtonBox(XEN_TO_C_Widget(arg))));
}
#endif

#if HAVE_XmCreateColumn
static XEN gxm_XmCreateColumn(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateColumn "Widget XmCreateColumn(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The Column widget creation function"
  return(gxm_new_widget("XmCreateColumn", XmCreateColumn, arg1, arg2, arg3, arg4));
}

#ifndef XmIsColumn
#define XmIsColumn(w) (XtIsSubclass(w, xmColumnWidgetClass))
#endif

static XEN gxm_XmIsColumn(XEN arg)
{
  #define H_XmIsColumn "XmIsColumn(arg) -> #t if arg is a Column widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsColumn", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsColumn(XEN_TO_C_Widget(arg))));
}

#if HAVE_XmColumnGetChildLabel
static XEN gxm_XmColumnGetChildLabel(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmColumnGetChildLabel", "Widget");
  return(C_TO_XEN_Widget(XmColumnGetChildLabel(XEN_TO_C_Widget(arg))));
}
#endif
#endif

#if HAVE_XmCreateDropDown
static XEN gxm_XmCreateDropDown(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateDropDown "Widget XmCreateDropDown(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The DropDown widget creation function"
  /* there is a problem here: the XmCreateDropDown macro in DropDown.h does not give us
     function argument access to the actual function.  Hence a short-term kludge...
  */
#ifdef _XmCominationBox2_h
  /* yes, it actually is spelled that way! */
return(gxm_new_widget("XmCreateDropDown", XmCreateCombinationBox2, arg1, arg2, arg3, arg4));
#else
  return(gxm_new_widget("XmCreateDropDown", XmCreateDropDown, arg1, arg2, arg3, arg4));
#endif
}

#ifndef XmIsDropDown
#define XmIsDropDown(w) (XtIsSubclass(w, xmDropDownWidgetClass))
#endif

static XEN gxm_XmIsDropDown(XEN arg)
{
  #define H_XmIsDropDown "XmIsDropDown(arg) -> #t if arg is a DropDown widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsDropDown", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsDropDown(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmDropDownGetValue(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmDropDownGetValue", "Widget");
  return(C_TO_XEN_STRING((char *)XmDropDownGetValue(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmDropDownGetText(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmDropDownGetText", "Widget");
  return(C_TO_XEN_Widget(XmDropDownGetText(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmDropDownGetLabel(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmDropDownGetLabel", "Widget");
  return(C_TO_XEN_Widget(XmDropDownGetLabel(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmDropDownGetArrow(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmDropDownGetArrow", "Widget");
  return(C_TO_XEN_Widget(XmDropDownGetArrow(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmDropDownGetList(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmDropDownGetList", "Widget");
  return(C_TO_XEN_Widget(XmDropDownGetList(XEN_TO_C_Widget(arg))));
}
#endif

#if HAVE_XmCreateFontSelector
static XEN gxm_XmCreateFontSelector(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateFontSelector "Widget XmCreateFontSelector(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The FontSelector widget creation function"
  return(gxm_new_widget("XmCreateFontSelector", XmCreateFontSelector, arg1, arg2, arg3, arg4));
}
#endif

#if HAVE_XmCreateColorSelector
static XEN gxm_XmCreateColorSelector(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateColorSelector "Widget XmCreateColorSelector(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The ColorSelector widget creation function"
  return(gxm_new_widget("XmCreateColorSelector", XmCreateColorSelector, arg1, arg2, arg3, arg4));
}
#endif

static XEN gxm_XmCreateIconHeader(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateIconHeader "Widget XmCreateIconHeader(Widget parent, String name, ArgList arglist, Cardinal argcount)"
  return(gxm_new_widget("XmCreateIconHeader", XmCreateIconHeader, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateIconGadget(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateIconGadget "Widget XmCreateIconGadget(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The IconGadget widget creation function"
  return(gxm_new_widget("XmCreateIconGadget", XmCreateIconGadget, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateToggleButton(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateToggleButton "Widget XmCreateToggleButton(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The ToggleButton widget creation function"
  return(gxm_new_widget("XmCreateToggleButton", XmCreateToggleButton, arg1, arg2, arg3, arg4));
}

#define XEN_ToggleButtonWidget_P(Arg) (XEN_Widget_P(Arg) && (XmIsToggleButton(XEN_TO_C_Widget(Arg)) || XmIsToggleButtonGadget(XEN_TO_C_Widget(Arg))))

static XEN gxm_XmToggleButtonSetValue(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmToggleButtonSetValue "void XmToggleButtonSetValue(Widget widget, XmToggleButtonState state, Boolean notify) \
sets or changes the current state"
  XEN_ASSERT_TYPE(XEN_ToggleButtonWidget_P(arg1), arg1, 1, "XmToggleButtonSetValue", "ToggleButton Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmToggleButtonSetValue", "int (actually XmToggleButtonState)");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg3), arg3, 3, "XmToggleButtonSetValue", "boolean");
  return(C_TO_XEN_BOOLEAN(XmToggleButtonSetValue(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_BOOLEAN(arg3))));
}

static XEN gxm_XmToggleButtonSetState(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmToggleButtonSetState "void XmToggleButtonSetState(Widget widget, Boolean state, Boolean notify) \
sets or changes the current state"
  XEN_ASSERT_TYPE(XEN_ToggleButtonWidget_P(arg1), arg1, 1, "XmToggleButtonSetState", "ToggleButton Widget");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg2), arg2, 2, "XmToggleButtonSetState", "boolean");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg3), arg3, 3, "XmToggleButtonSetState", "boolean");
  XmToggleButtonSetState(XEN_TO_C_Widget(arg1), XEN_TO_C_BOOLEAN(arg2), XEN_TO_C_BOOLEAN(arg3));
  return(XEN_FALSE);
}

static XEN gxm_XmToggleButtonGetState(XEN arg1)
{
  #define H_XmToggleButtonGetState "Boolean XmToggleButtonGetState(Widget widget) obtains the state of a ToggleButton"
  XEN_ASSERT_TYPE(XEN_ToggleButtonWidget_P(arg1), arg1, 1, "XmToggleButtonGetState", "ToggleButton Widget");
  return(C_TO_XEN_BOOLEAN(XmToggleButtonGetState(XEN_TO_C_Widget(arg1))));
}


static XEN gxm_XmCreateToggleButtonGadget(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateToggleButtonGadget "Widget XmCreateToggleButtonGadget(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The ToggleButtonGadget creation function"
  return(gxm_new_widget("XmCreateToggleButtonGadget", XmCreateToggleButtonGadget, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmToggleButtonGadgetSetValue(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmToggleButtonGadgetSetValue "Boolean XmToggleButtonGadgetSetValue(Widget w, XmToggleButtonState newstate, Boolean notify)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmToggleButtonGadgetSetValue", "Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmToggleButtonGadgetSetValue", "int");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg3), arg3, 3, "XmToggleButtonGadgetSetValue", "boolean");
  return(C_TO_XEN_BOOLEAN(XmToggleButtonGadgetSetValue(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_BOOLEAN(arg3))));
}

static XEN gxm_XmCreateGrabShell(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateGrabShell "Widget XmCreateGrabShell(Widget parent, char *name, ArgList al, Cardinal ac) -> a new GrabShell"
  return(gxm_new_widget("XmCreateGrabShell", XmCreateGrabShell, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmToggleButtonGadgetSetState(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmToggleButtonGadgetSetState "void XmToggleButtonGadgetSetState(Widget widget, Boolean state, Boolean notify) \
sets or changes the current state"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmToggleButtonGadgetSetState", "Widget");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg2), arg2, 2, "XmToggleButtonGadgetSetState", "boolean");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg3), arg3, 3, "XmToggleButtonGadgetSetState", "boolean");
  XmToggleButtonGadgetSetState(XEN_TO_C_Widget(arg1), XEN_TO_C_BOOLEAN(arg2), XEN_TO_C_BOOLEAN(arg3));
  return(XEN_FALSE);
}

static XEN gxm_XmToggleButtonGadgetGetState(XEN arg1)
{
  #define H_XmToggleButtonGadgetGetState "Boolean XmToggleButtonGadgetGetState(Widget widget) obtains \
the state of a ToggleButtonGadget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmToggleButtonGadgetGetState", "Widget");
  return(C_TO_XEN_BOOLEAN(XmToggleButtonGadgetGetState(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmCreateFrame(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateFrame "Widget XmCreateFrame(Widget parent, String name, ArgList arglist, Cardinal argcount) The Frame widget creation function"
  return(gxm_new_widget("XmCreateFrame", XmCreateFrame, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateFormDialog(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateFormDialog "Widget XmCreateFormDialog(Widget parent, String name, ArgList arglist, Cardinal argcount) \
A Form FormDialog creation function"
  return(gxm_new_widget("XmCreateFormDialog", XmCreateFormDialog, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateForm(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateForm "Widget XmCreateForm(Widget parent, String name, ArgList arglist, Cardinal argcount) The Form widget creation function"
  return(gxm_new_widget("XmCreateForm", XmCreateForm, arg1, arg2, arg3, arg4));
}

#define XEN_TextWidget_P(Arg) (XEN_Widget_P(Arg) && (XmIsText(XEN_TO_C_Widget(Arg)) || XmIsTextField(XEN_TO_C_Widget(Arg))))
#define XEN_JustTextWidget_P(Arg) (XEN_Widget_P(Arg) && XmIsText(XEN_TO_C_Widget(Arg)))

static XEN gxm_XmTextFindString(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmTextFindString "Boolean XmTextFindString(Widget widget, XmTextPosition start, char *string, XmTextDirection direction) \
finds the beginning position of a text string"
  /* DIFF: XmTextFindString widget start string dir [pos] -> pos or #f
  */
  XmTextPosition pos;
  int res;
  XEN_ASSERT_TYPE(XEN_JustTextWidget_P(arg1), arg1, 1, "XmTextFindString", "Text or TextField Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextFindString", "XmTextPosition");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3), arg3, 3, "XmTextFindString", "char*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XmTextFindString", "XmTextDirection");
  res = XmTextFindString(XEN_TO_C_Widget(arg1), 
			 (XmTextPosition)XEN_TO_C_INT(arg2), 
			 XEN_TO_C_STRING(arg3), 
			 (XmTextDirection)XEN_TO_C_INT(arg4), 
			 &pos);
  if (res)
    return(C_TO_XEN_INT(pos));
  return(XEN_FALSE);
}

static XEN gxm_XmTextEnableRedisplay(XEN arg1)
{
  #define H_XmTextEnableRedisplay "void XmTextEnableRedisplay(Widget widget) forces the visual update of a Text widget"
  XEN_ASSERT_TYPE(XEN_JustTextWidget_P(arg1), arg1, 1, "XmTextEnableRedisplay", "Text or TextField Widget");
  XmTextEnableRedisplay(XEN_TO_C_Widget(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmTextDisableRedisplay(XEN arg1)
{
  #define H_XmTextDisableRedisplay "void XmTextDisableRedisplay(Widget widget) temporarily prevents visual update of the Text widget"
  XEN_ASSERT_TYPE(XEN_JustTextWidget_P(arg1), arg1, 1, "XmTextDisableRedisplay", "Text or TextField Widget");
  XmTextDisableRedisplay(XEN_TO_C_Widget(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmTextGetCenterline(XEN arg1)
{
  #define H_XmTextGetCenterline "int XmTextGetCenterline(Widget widget) Return the height (length) of a character string when the writing direction is vertical"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextGetCenterline", "Text or TextField Widget");
  return(C_TO_XEN_INT(XmTextGetCenterline(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmTextGetBaseline(XEN arg1)
{
  #define H_XmTextGetBaseline "int XmTextGetBaseline(Widget widget) accesses the y position of the baseline"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextGetBaseline", "Text or TextField Widget");
  return(C_TO_XEN_INT(XmTextGetBaseline(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmTextScroll(XEN arg1, XEN arg2)
{
  #define H_XmTextScroll "void XmTextScroll(Widget widget, int lines) scrolls text"
  XEN_ASSERT_TYPE(XEN_JustTextWidget_P(arg1), arg1, 1, "XmTextScroll", "Text or TextField Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextScroll", "int");
  XmTextScroll(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmTextShowPosition(XEN arg1, XEN arg2)
{
  #define H_XmTextShowPosition "void XmTextShowPosition(Widget widget, XmTextPosition position) forces text at a given position to be displayed"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextShowPosition", "Text or TextField Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextShowPosition", "XmTextPosition");
  XmTextShowPosition(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmTextSetSource(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmTextSetSource "void XmTextSetSource(Widget widget, XmTextSource source, XmTextPosition top_character, \
XmTextPosition cursor_position) sets the source of the widget"
  XEN_ASSERT_TYPE(XEN_JustTextWidget_P(arg1), arg1, 1, "XmTextSetSource", "Text or TextField Widget");
  XEN_ASSERT_TYPE(XEN_XmTextSource_P(arg2), arg2, 2, "XmTextSetSource", "XmTextSource");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmTextSetSource", "XmTextPosition");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XmTextSetSource", "XmTextPosition");
  XmTextSetSource(XEN_TO_C_Widget(arg1), XEN_TO_C_XmTextSource(arg2), XEN_TO_C_INT(arg3), XEN_TO_C_INT(arg4));
  return(XEN_FALSE);
}

static XEN gxm_XmTextGetSource(XEN arg1)
{
  #define H_XmTextGetSource "XmTextSource XmTextGetSource(Widget widget) accesses the source of the widget"
  XEN_ASSERT_TYPE(XEN_JustTextWidget_P(arg1), arg1, 1, "XmTextGetSource", "Text or TextField Widget");
  return(C_TO_XEN_XmTextSource(XmTextGetSource(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmTextPosToXY(XEN arg1, XEN arg2)
{
  #define H_XmTextPosToXY "Boolean XmTextPosToXY(Widget widget, XmTextPosition position) A Text function \
that returns the x and y position of a character position"
  /* DIFF: XmTextPosToXY omits last 2 args and returns them
   */
  Position x, y;
  int val;
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextPosToXY", "Text or TextField Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextPosToXY", "XmTextPosition");
  val = XmTextPosToXY(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2), &x, &y);
  return(XEN_LIST_3(C_TO_XEN_BOOLEAN(val),
		    C_TO_XEN_Position(x),
		    C_TO_XEN_Position(y)));
}

static XEN gxm_XmTextXYToPos(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmTextXYToPos "XmTextPosition XmTextXYToPos(Widget widget, Position x, Position y) accesses \
the character position nearest an x and y position"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextXYToPos", "Text or TextField Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextXYToPos", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmTextXYToPos", "int");
  return(C_TO_XEN_INT(XmTextXYToPos(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_INT(arg3))));
}

static XEN gxm_XmTextGetSelectionPosition(XEN arg1)
{
  #define H_XmTextGetSelectionPosition "Boolean XmTextGetSelectionPosition(Widget widget) returns the position of the primary selection"
  /* DIFF: XmTextGetSelectionPosition widget [left right] -> (list res left right)
     no arg2 arg3, returns (owner left right) instead */
  XmTextPosition pos1, pos2;
  int res;
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextGetSelectionPosition", "Text or TextField Widget");
  res = XmTextGetSelectionPosition(XEN_TO_C_Widget(arg1), &pos1, &pos2);
  return(XEN_LIST_3(C_TO_XEN_BOOLEAN(res),
		    C_TO_XEN_INT(pos1),
		    C_TO_XEN_INT(pos2)));
}

static XEN gxm_XmTextClearSelection(XEN arg1, XEN arg2)
{
  #define H_XmTextClearSelection "void XmTextClearSelection(Widget widget, Time time) clears the primary selection"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextClearSelection", "Text or TextField Widget");
  XEN_ASSERT_TYPE(XEN_Time_P(arg2), arg2, 2, "XmTextClearSelection", "Time");
  XmTextClearSelection(XEN_TO_C_Widget(arg1), XEN_TO_C_Time(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmTextSetSelection(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmTextSetSelection "void XmTextSetSelection(Widget widget, XmTextPosition first, XmTextPosition last, Time time) \
sets the primary selection of the text"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextSetSelection", "Text or TextField Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextSetSelection", "XmTextPosition");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmTextSetSelection", "XmTextPosition");
  XEN_ASSERT_TYPE(XEN_Time_P(arg4), arg4, 4, "XmTextSetSelection", "Time");
  XmTextSetSelection(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_INT(arg3), XEN_TO_C_Time(arg4));
  return(XEN_FALSE);
}

static XEN gxm_XmTextGetSelection(XEN arg1)
{
  char *str;
  XEN res;
  #define H_XmTextGetSelection "char *XmTextGetSelection(Widget widget) retrieves the value of the primary selection"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextGetSelection", "Text or TextField Widget");
  str = XmTextGetSelection(XEN_TO_C_Widget(arg1));
  res = C_TO_XEN_STRING(str);
  if (str) XtFree(str);
  return(res);
}

static XEN gxm_XmTextPasteLink(XEN arg1)
{
  #define H_XmTextPasteLink "Boolean XmTextPasteLink(Widget widget) inserts a link to the clipboard selection"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextPasteLink", "Text or TextField Widget");
  return(C_TO_XEN_BOOLEAN(XmTextPasteLink(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmTextPaste(XEN arg1)
{
  #define H_XmTextPaste "Boolean XmTextPaste(Widget widget) inserts the clipboard selection"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextPaste", "Text or TextField Widget");
  return(C_TO_XEN_BOOLEAN(XmTextPaste(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmTextCut(XEN arg1, XEN arg2)
{
  #define H_XmTextCut "Boolean XmTextCut(Widget widget, Time time) copies the primary selection to the clipboard and deletes the selected text"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextCut", "Text or TextField Widget");
  XEN_ASSERT_TYPE(XEN_Time_P(arg2), arg2, 2, "XmTextCut", "Time");
  return(C_TO_XEN_BOOLEAN(XmTextCut(XEN_TO_C_Widget(arg1), XEN_TO_C_Time(arg2))));
}

static XEN gxm_XmTextCopyLink(XEN arg1, XEN arg2)
{
  #define H_XmTextCopyLink "Boolean XmTextCopyLink(Widget widget, Time time) copies a link to the primary selection to the clipboard"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextCopyLink", "Text or TextField Widget");
  XEN_ASSERT_TYPE(XEN_Time_P(arg2), arg2, 2, "XmTextCopyLink", "Time");
  return(C_TO_XEN_BOOLEAN(XmTextCopyLink(XEN_TO_C_Widget(arg1), XEN_TO_C_Time(arg2))));
}

static XEN gxm_XmTextCopy(XEN arg1, XEN arg2)
{
  #define H_XmTextCopy "Boolean XmTextCopy(Widget widget, Time time) copies the primary selection to the clipboard"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextCopy", "Text or TextField Widget");
  XEN_ASSERT_TYPE(XEN_Time_P(arg2), arg2, 2, "XmTextCopy", "Time");
  return(C_TO_XEN_BOOLEAN(XmTextCopy(XEN_TO_C_Widget(arg1), XEN_TO_C_Time(arg2))));
}

static XEN gxm_XmTextRemove(XEN arg1)
{
  #define H_XmTextRemove "Boolean XmTextRemove(Widget widget) deletes the primary selection"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextRemove", "Text or TextField Widget");
  return(C_TO_XEN_BOOLEAN(XmTextRemove(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmTextSetCursorPosition(XEN arg1, XEN arg2)
{
  #define H_XmTextSetCursorPosition "void XmTextSetCursorPosition(Widget w, int position) sets the insertion cursor position"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextSetCursorPosition", "Text or TextField Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextSetCursorPosition", "XmTextPosition");
  XmTextSetCursorPosition(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmTextSetInsertionPosition(XEN arg1, XEN arg2)
{
  #define H_XmTextSetInsertionPosition "void XmTextSetInsertionPosition(Widget widget, XmTextPosition position) \
sets the position of the insert cursor"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextSetInsertionPosition", "Text or TextField Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextSetInsertionPosition", "XmTextPosition");
  XmTextSetInsertionPosition(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmTextGetInsertionPosition(XEN arg1)
{
  #define H_XmTextGetInsertionPosition "XmTextPosition XmTextGetInsertionPosition(Widget widget) accesses the \
position of the insert cursor"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextGetInsertionPosition", "Text or TextField Widget");
  return(C_TO_XEN_INT(XmTextGetInsertionPosition(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmTextGetCursorPosition(XEN arg1)
{
  #define H_XmTextGetCursorPosition "int XmTextGetCursorPosition(Widget w) presumably returns the widget's insertion cursor position"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextGetCursorPosition", "Text or TextField Widget");
  return(C_TO_XEN_INT(XmTextGetCursorPosition(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmTextSetTopCharacter(XEN arg1, XEN arg2)
{
  #define H_XmTextSetTopCharacter "void XmTextSetTopCharacter(Widget widget, XmTextPosition top_character) sets \
the position of the first character displayed"
  XEN_ASSERT_TYPE(XEN_JustTextWidget_P(arg1), arg1, 1, "XmTextSetTopCharacter", "Text or TextField Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextSetTopCharacter", "XmTextPosition");
  XmTextSetTopCharacter(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmTextGetTopCharacter(XEN arg1)
{
  #define H_XmTextGetTopCharacter "XmTextPosition XmTextGetTopCharacter(Widget widget) accesses the position of the first character displayed"
  XEN_ASSERT_TYPE(XEN_JustTextWidget_P(arg1), arg1, 1, "XmTextGetTopCharacter", "Text or TextField Widget");
  return(C_TO_XEN_INT(XmTextGetTopCharacter(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmTextSetMaxLength(XEN arg1, XEN arg2)
{
  #define H_XmTextSetMaxLength "void XmTextSetMaxLength(Widget widget, int max_length) sets the value of the current \
maximum allowable length of a text string entered from the keyboard"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextSetMaxLength", "Text or TextField Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextSetMaxLength", "int");
  XmTextSetMaxLength(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmTextGetMaxLength(XEN arg1)
{
  #define H_XmTextGetMaxLength "int XmTextGetMaxLength(Widget widget) accesses the value of the current maximum allowable \
length of a text string entered from the keyboard"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextGetMaxLength", "Text or TextField Widget");
  return(C_TO_XEN_INT(XmTextGetMaxLength(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmTextSetEditable(XEN arg1, XEN arg2)
{
  #define H_XmTextSetEditable "void XmTextSetEditable(Widget widget, Boolean editable) sets the edit permission"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextSetEditable", "Text or TextField Widget");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg2), arg2, 2, "XmTextSetEditable", "boolean");
  XmTextSetEditable(XEN_TO_C_Widget(arg1), XEN_TO_C_BOOLEAN(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmTextGetEditable(XEN arg1)
{
  #define H_XmTextGetEditable "Boolean XmTextGetEditable(Widget widget) accesses the edit permission state"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextGetEditable", "Text or TextField Widget");
  return(C_TO_XEN_BOOLEAN(XmTextGetEditable(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmTextGetAddMode(XEN arg1)
{
  #define H_XmTextGetAddMode "Boolean XmTextGetAddMode(Widget w) presumably returns the widget's current add mode."
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextGetAddMode", "Text or TextField Widget");
  return(C_TO_XEN_BOOLEAN(XmTextGetAddMode(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmTextSetAddMode(XEN arg1, XEN arg2)
{
  #define H_XmTextSetAddMode "void XmTextSetAddMode(Widget widget, Boolean state) sets the widget's add mode -- \
this determines whether you can move the insertion cursor without changing the primary selection"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextSetAddMode", "Text or TextField Widget");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg2), arg2, 2, "XmTextSetAddMode", "boolean");
  XmTextSetAddMode(XEN_TO_C_Widget(arg1), XEN_TO_C_BOOLEAN(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmTextInsert(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmTextInsert "void XmTextInsert(Widget widget, XmTextPosition position, char *value) inserts a character \
string into a text string"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextInsert", "Text or TextField Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextInsert", "XmTextPosition");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3), arg3, 3, "XmTextInsert", "char*");
  XmTextInsert(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_STRING(arg3));
  return(XEN_FALSE);
}

static XEN gxm_XmTextReplace(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmTextReplace "void XmTextReplace(Widget widget, XmTextPosition from_pos, XmTextPosition to_pos, char *value) \
replaces part of a text string"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextReplace", "Text or TextField Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextReplace", "XmTextPosition");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmTextReplace", "XmTextPosition");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg4), arg4, 4, "XmTextReplace", "char*");
  XmTextReplace(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_INT(arg3), XEN_TO_C_STRING(arg4));
  return(XEN_FALSE);
}

static XEN gxm_XmTextSetString(XEN arg1, XEN arg2)
{
  #define H_XmTextSetString "void XmTextSetString(Widget widget, char *value) sets the string value"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextSetString", "Text or TextField Widget");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmTextSetString", "char*");
  XmTextSetString(XEN_TO_C_Widget(arg1), XEN_TO_C_STRING(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmTextGetLastPosition(XEN arg1)
{
  #define H_XmTextGetLastPosition "XmTextPosition XmTextGetLastPosition(Widget widget) accesses the last position in the text"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextGetLastPosition", "Text or TextField Widget");
  return(C_TO_XEN_INT(XmTextGetLastPosition(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmTextGetString(XEN arg1)
{
  char *str;
  XEN res;
  #define H_XmTextGetString "char *XmTextGetString(Widget widget) accesses the string value"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextGetString", "Text or TextField Widget");
  str = XmTextGetString(XEN_TO_C_Widget(arg1));
  res = C_TO_XEN_STRING(str);
  if (str) XtFree(str);
  return(res);
}

static XEN gxm_XmTextGetSubstring(XEN arg1, XEN arg2, XEN arg3)
{
  /* DIFF: omit and rtn last 2 args */
  #define H_XmTextGetSubstring "int XmTextGetSubstring(Widget widget, XmTextPosition start, int num_chars) \
retrieves a copy of a portion of the internal text buffer"
  int rtn, len;
  char *buf;
  XEN str = XEN_FALSE;
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextGetSubstring", "Text or TextField Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextGetSubstring", "XmTextPosition");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmTextGetSubstring", "int");
  len = XEN_TO_C_INT(arg3);
  buf = (char *)CALLOC(len + 1, sizeof(char));
  rtn = XmTextGetSubstring(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2), len, len + 1, buf);
  if (rtn != XmCOPY_FAILED)
    str = C_TO_XEN_STRING(buf);
  FREE(buf);
  return(str);
}

static XEN gxm_XmCreateText(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateText "Widget XmCreateText(Widget parent, String name, ArgList arglist, Cardinal argcount) The Text widget creation function"
  return(gxm_new_widget("XmCreateText", XmCreateText, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateScrolledText(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateScrolledText "Widget XmCreateScrolledText(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The Text ScrolledText creation function"
  return(gxm_new_widget("XmCreateScrolledText", XmCreateScrolledText, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmTextSetHighlight(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmTextSetHighlight "void XmTextSetHighlight(Widget widget, XmTextPosition left, XmTextPosition right, XmHighlightMode mode) \
highlights text"
  XEN_ASSERT_TYPE(XEN_TextWidget_P(arg1), arg1, 1, "XmTextSetHighlight", "Text or TextField Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextSetHighlight", "XmTextPosition");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmTextSetHighlight", "XmTextPosition");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XmTextSetHighlight", "XmHighlightMode");
  XmTextSetHighlight(XEN_TO_C_Widget(arg1), 
		     (XmTextPosition)XEN_TO_C_INT(arg2), 
		     (XmTextPosition)XEN_TO_C_INT(arg3), 
		     (XmHighlightMode)XEN_TO_C_INT(arg4));
  return(XEN_FALSE);
}

static XEN gxm_XmCreateFileSelectionDialog(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateFileSelectionDialog "Widget XmCreateFileSelectionDialog(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The FileSelectionBox FileSelectionDialog creation function"
  return(gxm_new_widget("XmCreateFileSelectionDialog", XmCreateFileSelectionDialog, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateFileSelectionBox(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateFileSelectionBox "Widget XmCreateFileSelectionBox(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The FileSelectionBox widget creation function"
  return(gxm_new_widget("XmCreateFileSelectionBox", XmCreateFileSelectionBox, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmFileSelectionDoSearch(XEN arg1, XEN arg2)
{
  #define H_XmFileSelectionDoSearch "void XmFileSelectionDoSearch(Widget widget, XmString dirmask) \
initiates a directory search"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmFileSelectionDoSearch", "Widget");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2) || XEN_FALSE_P(arg2), arg2, 2, "XmFileSelectionDoSearch", "XmString");
  XmFileSelectionDoSearch(XEN_TO_C_Widget(arg1), XEN_FALSE_P(arg2) ? NULL : XEN_TO_C_XmString(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmFileSelectionBoxGetChild(XEN arg1, XEN arg2)
{
  #define H_XmFileSelectionBoxGetChild "Widget XmFileSelectionBoxGetChild(Widget widget, unsigned char child) \
used to access a component"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmFileSelectionBoxGetChild", "Widget");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XmFileSelectionBoxGetChild", "unsigned int");
  return(C_TO_XEN_Widget(XmFileSelectionBoxGetChild(XEN_TO_C_Widget(arg1), XEN_TO_C_ULONG(arg2))));
}

static XEN gxm_XmCreateTextField(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateTextField "Widget XmCreateTextField(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The TextField widget creation function"
  return(gxm_new_widget("XmCreateTextField", XmCreateTextField, arg1, arg2, arg3, arg4));
}

#define XEN_TextFieldWidget_P(Arg) (XEN_Widget_P(Arg) && XmIsTextField(XEN_TO_C_Widget(Arg)))

static XEN gxm_XmTextFieldGetBaseline(XEN arg1)
{
  #define H_XmTextFieldGetBaseline "int XmTextFieldGetBaseline(Widget widget) accesses the y position of the baseline"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldGetBaseline", "TextField Widget");
  return(C_TO_XEN_INT(XmTextFieldGetBaseline(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmTextFieldSetHighlight(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmTextFieldSetHighlight "void XmTextFieldSetHighlight(Widget widget, XmTextPosition left, XmTextPosition right, XmHighlightMode mode) \
highlights text"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldSetHighlight", "TextField Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextFieldSetHighlight", "XmTextPosition");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmTextFieldSetHighlight", "XmTextPosition");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XmTextFieldSetHighlight", "XmHighlightMode");
  XmTextFieldSetHighlight(XEN_TO_C_Widget(arg1), 
			  (XmTextPosition)XEN_TO_C_INT(arg2), 
			  (XmTextPosition)XEN_TO_C_INT(arg3), 
			  (XmHighlightMode)XEN_TO_C_INT(arg4));
  return(XEN_FALSE);
}

static XEN gxm_XmTextFieldShowPosition(XEN arg1, XEN arg2)
{
  #define H_XmTextFieldShowPosition "void XmTextFieldShowPosition(Widget widget, XmTextPosition position) \
forces text at a given position to be displayed"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldShowPosition", "TextField Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextFieldShowPosition", "XmTextPosition");
  XmTextFieldShowPosition(XEN_TO_C_Widget(arg1), 
			  (XmTextPosition)XEN_TO_C_INT(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmTextFieldPosToXY(XEN arg1, XEN arg2)
{
  #define H_XmTextFieldPosToXY "Boolean XmTextFieldPosToXY(Widget widget, XmTextPosition position) returns the x and y position of a character position"
  /* DIFF: XmTextFieldPosToXY omits last 2 args and returns them
   */
  Position x, y;
  int val;
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldPosToXY", "TextField Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextFieldPosToXY", "XmTextPosition");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmTextPosToXY", "Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextPosToXY", "XmTextPosition");
  val = XmTextFieldPosToXY(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2), &x, &y);
  return(XEN_LIST_3(C_TO_XEN_BOOLEAN(val),
		    C_TO_XEN_Position(x),
		    C_TO_XEN_Position(y)));
}

static XEN gxm_XmTextFieldXYToPos(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmTextFieldXYToPos "XmTextPosition XmTextFieldXYToPos(Widget widget, Position x, Position y) \
accesses the character position nearest an x and y position"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldXYToPos", "TextField Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextFieldXYToPos", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmTextFieldXYToPos", "int");
  return(C_TO_XEN_INT(XmTextFieldXYToPos(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_INT(arg3))));
}

static XEN gxm_XmTextFieldSetSelection(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmTextFieldSetSelection "void XmTextFieldSetSelection(Widget widget, XmTextPosition first, XmTextPosition last, Time time) \
sets the primary selection of the text"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldSetSelection", "TextField Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextFieldSetSelection", "XmTextPosition");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmTextFieldSetSelection", "XmTextPosition");
  XEN_ASSERT_TYPE(XEN_Time_P(arg4), arg4, 4, "XmTextFieldSetSelection", "Time");
  XmTextFieldSetSelection(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_INT(arg3), XEN_TO_C_Time(arg4));
  return(XEN_FALSE);
}

static XEN gxm_XmTextFieldClearSelection(XEN arg1, XEN arg2)
{
  #define H_XmTextFieldClearSelection "void XmTextFieldClearSelection(Widget widget, Time time) clears the primary selection"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldClearSelection", "TextField Widget");
  XEN_ASSERT_TYPE(XEN_Time_P(arg2), arg2, 2, "XmTextFieldClearSelection", "Time");
  XmTextFieldClearSelection(XEN_TO_C_Widget(arg1), XEN_TO_C_Time(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmTextFieldPasteLink(XEN arg1)
{
  #define H_XmTextFieldPasteLink "Boolean XmTextFieldPasteLink(Widget widget) inserts a link to the clipboard selection"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldPasteLink", "TextField Widget");
  return(C_TO_XEN_BOOLEAN(XmTextFieldPasteLink(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmTextFieldCopyLink(XEN arg1, XEN arg2)
{
  #define H_XmTextFieldCopyLink "Boolean XmTextFieldCopyLink(Widget widget, Time time) copies a link to the \
primary selection to the clipboard"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldCopyLink", "TextField Widget");
  XEN_ASSERT_TYPE(XEN_Time_P(arg2), arg2, 2, "XmTextFieldCopyLink", "Time");
  return(C_TO_XEN_BOOLEAN(XmTextFieldCopyLink(XEN_TO_C_Widget(arg1), XEN_TO_C_Time(arg2))));
}

static XEN gxm_XmTextFieldPaste(XEN arg1)
{
  #define H_XmTextFieldPaste "Boolean XmTextFieldPaste(Widget widget) inserts the clipboard selection"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldPaste", "TextField Widget");
  return(C_TO_XEN_BOOLEAN(XmTextFieldPaste(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmTextFieldCut(XEN arg1, XEN arg2)
{
  #define H_XmTextFieldCut "Boolean XmTextFieldCut(Widget widget, Time time) copies the primary selection \
to the clipboard and deletes the selected text"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldCut", "TextField Widget");
  XEN_ASSERT_TYPE(XEN_Time_P(arg2), arg2, 2, "XmTextFieldCut", "Time");
  return(C_TO_XEN_BOOLEAN(XmTextFieldCut(XEN_TO_C_Widget(arg1), XEN_TO_C_Time(arg2))));
}

static XEN gxm_XmTextFieldCopy(XEN arg1, XEN arg2)
{
  #define H_XmTextFieldCopy "Boolean XmTextFieldCopy(Widget widget, Time time) copies the primary selection to the clipboard"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldCopy", "TextField Widget");
  XEN_ASSERT_TYPE(XEN_Time_P(arg2), arg2, 2, "XmTextFieldCopy", "Time");
  return(C_TO_XEN_BOOLEAN(XmTextFieldCopy(XEN_TO_C_Widget(arg1), XEN_TO_C_Time(arg2))));
}

static XEN gxm_XmTextFieldRemove(XEN arg1)
{
  #define H_XmTextFieldRemove "Boolean XmTextFieldRemove(Widget widget) deletes the primary selection"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldRemove", "TextField Widget");
  return(C_TO_XEN_BOOLEAN(XmTextFieldRemove(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmTextFieldGetSelection(XEN arg1)
{
  char *str;
  XEN res;
  #define H_XmTextFieldGetSelection "char *XmTextFieldGetSelection(Widget widget) retrieves the value of the primary selection"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldGetSelection", "TextField Widget");
  str = XmTextFieldGetSelection(XEN_TO_C_Widget(arg1));
  res = C_TO_XEN_STRING(str);
  if (str) XtFree(str);
  return(res);
}

static XEN gxm_XmTextFieldGetSelectionPosition(XEN arg1)
{
  #define H_XmTextFieldGetSelectionPosition "Boolean XmTextFieldGetSelectionPosition(Widget widget) \
returns the position of the primary selection"
  /* DIFF: XmTextFieldGetSelectionPosition widget [left right] -> (list res left right)
     no arg2 arg3, returns (owner left right) instead 
  */
  XmTextPosition pos1, pos2;
  int res;
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldGetSelectionPosition", "TextField Widget");
  res = XmTextFieldGetSelectionPosition(XEN_TO_C_Widget(arg1), &pos1, &pos2);
  return(XEN_LIST_3(C_TO_XEN_BOOLEAN(res),
		    C_TO_XEN_INT(pos1),
		    C_TO_XEN_INT(pos2)));
}

static XEN gxm_XmTextFieldSetInsertionPosition(XEN arg1, XEN arg2)
{
  #define H_XmTextFieldSetInsertionPosition "void XmTextFieldSetInsertionPosition(Widget widget, XmTextPosition position) \
sets the position of the insertion cursor"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldSetInsertionPosition", "TextField Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextFieldSetInsertionPosition", "XmTextPosition");
  XmTextFieldSetInsertionPosition(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmTextFieldSetCursorPosition(XEN arg1, XEN arg2)
{
  #define H_XmTextFieldSetCursorPosition "void XmTextFieldSetCursorPosition(Widget w, int position) sets the insertion cursor position"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldSetCursorPosition", "TextField Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextFieldSetCursorPosition", "XmTextPosition");
  XmTextFieldSetCursorPosition(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmTextFieldGetInsertionPosition(XEN arg1)
{
  #define H_XmTextFieldGetInsertionPosition "XmTextPosition XmTextFieldGetInsertionPosition(Widget widget) \
accesses the position of the insertion cursor"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldGetInsertionPosition", "TextField Widget");
  return(C_TO_XEN_INT(XmTextFieldGetInsertionPosition(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmTextFieldGetCursorPosition(XEN arg1)
{
  #define H_XmTextFieldGetCursorPosition "int XmTextFieldGetCursorPosition(Widget w) presumably returns the widget's insertion cursor position"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldGetCursorPosition", "TextField Widget");
  return(C_TO_XEN_INT(XmTextFieldGetCursorPosition(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmTextFieldSetMaxLength(XEN arg1, XEN arg2)
{
  #define H_XmTextFieldSetMaxLength "void XmTextFieldSetMaxLength(Widget widget, int max_length) sets the \
value of the current maximum allowable length of a text string \
entered from the keyboard"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldSetMaxLength", "TextField Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextFieldSetMaxLength", "int");
  XmTextFieldSetMaxLength(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmTextFieldGetMaxLength(XEN arg1)
{
  #define H_XmTextFieldGetMaxLength "int XmTextFieldGetMaxLength(Widget widget) accesses the value of the \
current maximum allowable length of a text string \
entered from the keyboard"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldGetMaxLength", "TextField Widget");
  return(C_TO_XEN_INT(XmTextFieldGetMaxLength(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmTextFieldSetEditable(XEN arg1, XEN arg2)
{
  #define H_XmTextFieldSetEditable "void XmTextFieldSetEditable(Widget widget, Boolean editable) sets the edit permission"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldSetEditable", "TextField Widget");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg2), arg2, 2, "XmTextFieldSetEditable", "boolean");
  XmTextFieldSetEditable(XEN_TO_C_Widget(arg1), XEN_TO_C_BOOLEAN(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmTextFieldGetEditable(XEN arg1)
{
  #define H_XmTextFieldGetEditable "Boolean XmTextFieldGetEditable(Widget widget) accesses the edit permission state"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldGetEditable", "TextField Widget");
  return(C_TO_XEN_BOOLEAN(XmTextFieldGetEditable(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmTextFieldGetAddMode(XEN arg1)
{
  #define H_XmTextFieldGetAddMode "Boolean XmTextFieldGetAddMode(Widget w) presumably returns the widget's current add mode."
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldGetAddMode", "TextField Widget");
  return(C_TO_XEN_BOOLEAN(XmTextFieldGetAddMode(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmTextFieldSetAddMode(XEN arg1, XEN arg2)
{
  #define H_XmTextFieldSetAddMode "void XmTextFieldSetAddMode(Widget widget, Boolean state) sets the state of Add mode"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldSetAddMode", "TextField Widget");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg2), arg2, 2, "XmTextFieldSetAddMode", "boolean");
  XmTextFieldSetAddMode(XEN_TO_C_Widget(arg1), XEN_TO_C_BOOLEAN(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmTextFieldInsert(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmTextFieldInsert "void XmTextFieldInsert(Widget widget, XmTextPosition position, char *value) \
inserts a character string into a text string"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldInsert", "TextField Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextFieldInsert", "XmTextPosition");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3), arg3, 3, "XmTextFieldInsert", "char*");
  XmTextFieldInsert(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_STRING(arg3));
  return(XEN_FALSE);
}

static XEN gxm_XmTextFieldReplace(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmTextFieldReplace "void XmTextFieldReplace(Widget widget, XmTextPosition from_pos, XmTextPosition to_pos, char *value) \
replaces part of a text string"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldReplace", "TextField Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextFieldReplace", "XmTextPosition");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmTextFieldReplace", "XmTextPosition");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg4), arg4, 4, "XmTextFieldReplace", "char*");
  XmTextFieldReplace(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_INT(arg3), XEN_TO_C_STRING(arg4));
  return(XEN_FALSE);
}

static XEN gxm_XmTextFieldSetString(XEN arg1, XEN arg2)
{
  #define H_XmTextFieldSetString "void XmTextFieldSetString(Widget widget, char *value) sets the string value"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldSetString", "TextField Widget");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmTextFieldSetString", "char*");
  XmTextFieldSetString(XEN_TO_C_Widget(arg1), XEN_TO_C_STRING(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmTextFieldGetLastPosition(XEN arg1)
{
  #define H_XmTextFieldGetLastPosition "XmTextPosition XmTextFieldGetLastPosition(Widget widget) accesses \
the position of the last text character"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldGetLastPosition", "TextField Widget");
  return(C_TO_XEN_INT(XmTextFieldGetLastPosition(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmTextFieldGetSubstring(XEN arg1, XEN arg2, XEN arg3)
{
  /* DIFF: omit and rtn last 2 args */
  #define H_XmTextFieldGetSubstring "int XmTextFieldGetSubstring(Widget widget, XmTextPosition start, int num_chars) \
retrieves a copy of a portion of the internal text buffer"
  int rtn, len;
  char *buf;
  XEN str = XEN_FALSE;
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldGetSubstring", "TextField Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmTextFieldGetSubstring", "XmTextPosition");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmTextFieldGetSubstring", "int");
  len = XEN_TO_C_INT(arg3);
  buf = (char *)CALLOC(len + 1, sizeof(char));
  rtn = XmTextFieldGetSubstring(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2), len, len + 1, buf);
  if (rtn != XmCOPY_FAILED)
    str = C_TO_XEN_STRING(buf);
  FREE(buf);
  return(str);
}

static XEN gxm_XmTextFieldGetString(XEN arg1)
{
  char *str;
  XEN res;
  #define H_XmTextFieldGetString "char *XmTextFieldGetString(Widget widget) accesses the string value"
  XEN_ASSERT_TYPE(XEN_TextFieldWidget_P(arg1), arg1, 1, "XmTextFieldGetString", "TextField Widget");
  str = XmTextFieldGetString(XEN_TO_C_Widget(arg1));
  res = C_TO_XEN_STRING(str);
  if (str) XtFree(str);
  return(res);
}

static XEN gxm_XmDropTransferAdd(XEN arg1, XEN arg2)
{
  #define H_XmDropTransferAdd "void XmDropTransferAdd(Widget drop_transfer, XmDropTransferEntryRec *transfers) \
enables additional drop transfer entries to be processed after initiating a drop transfer"
  /* DIFF: XmDropTransferAdd  arg2 is list of (atom data) lists, arg3 omitted
   */
  int len;
  XmDropTransferEntryRec *entries;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmDropTransferAdd", "Widget");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XmDropTransferAdd", "XmDropTransferEntry");
  len = XEN_LIST_LENGTH(arg2);
  if (len <= 0) return(XEN_FALSE);
  entries = XEN_TO_C_XmDropTransferEntryRecs(arg2, len);
  XmDropTransferAdd(XEN_TO_C_Widget(arg1), entries, len);
  FREE(entries);
  return(XEN_FALSE);
}

static XEN gxm_XmDropTransferStart(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmDropTransferStart "Widget XmDropTransferStart(Widget widget, ArgList arglist, Cardinal argcount) \
initiates a drop transfer"
  Widget w;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmDropTransferStart", "Widget");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XmDropTransferStart", "ArgList");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg3), arg3, 3, "XmDropTransferStart", "int");
  {
    Arg *args;
    int arglen;
    args = XEN_TO_C_Args(arg2);
    arglen = XEN_TO_C_INT_DEF(arg3, arg2);
    w = XmDropTransferStart(XEN_TO_C_Widget(arg1), args, arglen);
    if (args)
      {
	fixup_args(w, args, arglen);
	free_args(args, arglen);
      }
  }
  return(C_TO_XEN_Widget(w));
}

static XEN gxm_XmDropSiteConfigureStackingOrder(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmDropSiteConfigureStackingOrder "void XmDropSiteConfigureStackingOrder(Widget widget, Widget sibling, Cardinal stack_mode) \
reorders a stack of widgets that are registered drop sites"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmDropSiteConfigureStackingOrder", "Widget");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg2), arg2, 2, "XmDropSiteConfigureStackingOrder", "Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmDropSiteConfigureStackingOrder", "int");
  XmDropSiteConfigureStackingOrder(XEN_TO_C_Widget(arg1), XEN_TO_C_Widget(arg2), XEN_TO_C_INT(arg3));
  return(XEN_FALSE);
}

static XEN gxm_XmDropSiteQueryStackingOrder(XEN arg1)
{
  #define H_XmDropSiteQueryStackingOrder "Status XmDropSiteQueryStackingOrder(Widget widget) -> (list parent child ...)"
  /* DIFF: XmDropSiteQueryStackingOrder widget [parent child numchild] -> (list parent child ...)
     no parent children num_children -- returned as '(parent child1...) or #f 
  */
  Widget parent;
  Widget *children;
  XEN lst = XEN_EMPTY_LIST;
  unsigned int num_children;
  int res, i, loc;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmDropSiteQueryStackingOrder", "Widget");
  res = XmDropSiteQueryStackingOrder(XEN_TO_C_Widget(arg1), &parent, &children, &num_children);
  if (res == 0)
    return(XEN_FALSE);
  loc = xm_protect(lst);
  for (i = num_children - 1; i >= 0; i--)
    lst = XEN_CONS(C_TO_XEN_Widget(children[i]), lst);
  xm_unprotect_at(loc);
  return(XEN_CONS(C_TO_XEN_Widget(parent), lst));
}

static XEN gxm_XmDropSiteRetrieve(XEN arg1, XEN larg2, XEN arg3)
{
  #define H_XmDropSiteRetrieve "void XmDropSiteRetrieve(Widget widget, ArgList arglist, Cardinal argcount) \
retrieves resource values set on a drop site"

  Arg *args;
  unsigned long *locs;
  XEN val = XEN_FALSE;
  int i, len, gcloc;
  XEN arg2;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmDropSiteRetrieve", "Widget");
  XEN_ASSERT_TYPE(XEN_LIST_P(larg2), larg2, 2, "XmDropSiteRetrieve", "ArgList");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg3), arg3, 3, "XmDropSiteRetrieve", "int");
  arg2 = XEN_COPY_ARG(larg2);
  gcloc = xm_protect(arg2);
  len = XEN_TO_C_INT_DEF(arg3, larg2);
  if (len <= 0) XEN_ASSERT_TYPE(0, arg3, 3, "XmDropSiteRetrieve", "positive integer");
  args = (Arg *)CALLOC(len, sizeof(Arg));
  locs = (unsigned long *)CALLOC(len, sizeof(unsigned long));
  for (i = 0; i < len; i++, arg2 = XEN_CDDR(arg2))
    {
      char *name;
      name = strdup(XEN_TO_C_STRING(XEN_CAR(arg2)));
      XtSetArg(args[i], name, &(locs[i]));
    }
  XmDropSiteRetrieve(XEN_TO_C_Widget(arg1), args, len);
  val = C_TO_XEN_Args((Widget)(XEN_TO_C_Widget(arg1)), args, len);
  free_args(args, len);
  FREE(locs);
  xm_unprotect_at(gcloc);
  return(xen_return_first(val, larg2));
}

static XEN gxm_XmDropSiteEndUpdate(XEN arg1)
{
  #define H_XmDropSiteEndUpdate "void XmDropSiteEndUpdate(Widget widget) facilitates processing updates to multiple drop sites"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmDropSiteEndUpdate", "Widget");
  XmDropSiteEndUpdate(XEN_TO_C_Widget(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmDropSiteUpdate(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmDropSiteUpdate "void XmDropSiteUpdate(Widget widget, ArgList arglist, Cardinal argcount) sets \
resource values for a drop site"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmDropSiteUpdate", "Widget");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XmDropSiteUpdate", "ArgList");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg3), arg3, 3, "XmDropSiteUpdate", "int");
  {
    Widget w;
    Arg *args;
    int arglen;
    w = XEN_TO_C_Widget(arg1);
    args = XEN_TO_C_Args(arg2);
    arglen = XEN_TO_C_INT_DEF(arg3, arg2);
    XmDropSiteUpdate(w, args, arglen);
    if (args)
      {
	fixup_args(w, args, arglen);
	free_args(args, arglen);
      }
  }
  return(XEN_FALSE);
}

static XEN gxm_XmDropSiteStartUpdate(XEN arg1)
{
  #define H_XmDropSiteStartUpdate "void XmDropSiteStartUpdate(Widget widget) facilitates processing updates \
to multiple drop sites"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmDropSiteStartUpdate", "Widget");
  XmDropSiteStartUpdate(XEN_TO_C_Widget(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmDropSiteRegistered(XEN arg1)
{
  #define H_XmDropSiteRegistered "Boolean XmDropSiteRegistered(Widget widget) determines if a drop site has been registered"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmDropSiteRegistered", "Widget");
  return(C_TO_XEN_BOOLEAN(XmDropSiteRegistered(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmDropSiteUnregister(XEN arg1)
{
  #define H_XmDropSiteUnregister "void XmDropSiteUnregister(Widget widget) frees drop site information"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmDropSiteUnregister", "Widget");
  XmDropSiteUnregister(XEN_TO_C_Widget(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmDropSiteRegister(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmDropSiteRegister "void XmDropSiteRegister(Widget widget, ArgList arglist, Cardinal argcount) \
identifies a drop site and assigns resources that specify its behavior"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmDropSiteRegister", "Widget");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XmDropSiteRegister", "ArgList");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg3), arg3, 3, "XmDropSiteRegister", "int");
  {
    Widget w;
    Arg *args;
    int arglen;
    w = XEN_TO_C_Widget(arg1);
    args = XEN_TO_C_Args(arg2);
    arglen = XEN_TO_C_INT_DEF(arg3, arg2);
    XmDropSiteRegister(w, args, arglen);
    if (args)
      {
	fixup_args(w, args, arglen);
	free_args(args, arglen);
      }
  }
  return(XEN_FALSE);
}

static XEN gxm_XmSimpleSpinBoxSetItem(XEN arg1, XEN arg2)
{
  #define H_XmSimpleSpinBoxSetItem "void XmSimpleSpinBoxSetItem(Widget w, XmString item) set an item in the XmSimpleSpinBox list"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmSimpleSpinBoxSetItem", "Widget");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmSimpleSpinBoxSetItem", "XmString");
  XmSimpleSpinBoxSetItem(XEN_TO_C_Widget(arg1), XEN_TO_C_XmString(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmSimpleSpinBoxDeletePos(XEN arg1, XEN arg2)
{
  #define H_XmSimpleSpinBoxDeletePos "void XmSimpleSpinBoxDeletePos(Widget w, int pos) delete a XmSimpleSpinBox item"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmSimpleSpinBoxDeletePos", "Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmSimpleSpinBoxDeletePos", "int");
  XmSimpleSpinBoxDeletePos(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmSimpleSpinBoxAddItem(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmSimpleSpinBoxAddItem "void XmSimpleSpinBoxAddItem(Widget w, XmString item, int pos) add an item to the XmSimpleSpinBox"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmSimpleSpinBoxAddItem", "Widget");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmSimpleSpinBoxAddItem", "XmString");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmSimpleSpinBoxAddItem", "int");
  XmSimpleSpinBoxAddItem(XEN_TO_C_Widget(arg1), XEN_TO_C_XmString(arg2), XEN_TO_C_INT(arg3));
  return(XEN_FALSE);
}

static XEN gxm_XmCreateSimpleSpinBox(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateSimpleSpinBox "Widget XmCreateSimpleSpinBox(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The SimpleSpinBox widget creation function"
  return(gxm_new_widget("XmCreateSimpleSpinBox", XmCreateSimpleSpinBox, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateDrawnButton(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateDrawnButton "Widget XmCreateDrawnButton(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The DrawnButton widget creation function"
  return(gxm_new_widget("XmCreateDrawnButton", XmCreateDrawnButton, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmSpinBoxValidatePosition(XEN arg1)
{
  #define H_XmSpinBoxValidatePosition "int XmSpinBoxValidatePosition(Widget textfield) translate the current value of \
the specified XmSpinBox child into a valid position"
  /* DIFF: XmSpinBoxValidatePosition omits arg2, returns pos
   */
  int pos;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmSpinBoxValidatePosition", "Widget");
  XmSpinBoxValidatePosition(XEN_TO_C_Widget(arg1), &pos);
  return(C_TO_XEN_INT(pos));
}

static XEN gxm_XmCreateSpinBox(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateSpinBox "The SpinBox creation function"
  return(gxm_new_widget("XmCreateSpinBox", XmCreateSpinBox, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateDrawingArea(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateDrawingArea "Widget XmCreateDrawingArea(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The DrawingArea widget creation function"
  return(gxm_new_widget("XmCreateDrawingArea", XmCreateDrawingArea, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateSeparator(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateSeparator "Widget XmCreateSeparator(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The Separator widget creation function"
  return(gxm_new_widget("XmCreateSeparator", XmCreateSeparator, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateDragIcon(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateDragIcon "Widget XmCreateDragIcon(Widget widget, String name, ArgList arglist, Cardinal argcount) \
creates a DragIcon widget"
  return(gxm_new_widget("XmCreateDragIcon", XmCreateDragIcon, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateSeparatorGadget(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateSeparatorGadget "Widget XmCreateSeparatorGadget(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The SeparatorGadget creation function"
  return(gxm_new_widget("XmCreateSeparatorGadget", XmCreateSeparatorGadget, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmTargetsAreCompatible(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XmTargetsAreCompatible "Boolean XmTargetsAreCompatible(Display *display, Atom *export_targets, Cardinal num_export_targets, \
Atom *import_targets, Cardinal num_import_targets)  tests whether the target types match between a drop site and source object"
  /* DIFF: XmTargetsAreCompatible arg2 and arg4 are lists of Atoms
   */
  Atom *outs, *ins;
  int val, len1, len2;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmTargetsAreCompatible", "Display*");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XmTargetsAreCompatible", "list of Atom");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmTargetsAreCompatible", "int");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg4), arg4, 4, "XmTargetsAreCompatible", "list of Atom");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XmTargetsAreCompatible", "int");
  len1 = XEN_TO_C_INT(arg3);
  outs = XEN_TO_C_Atoms(arg2, len1);
  len2 = XEN_TO_C_INT(arg5);
  ins = XEN_TO_C_Atoms(arg4, len2);
  val = XmTargetsAreCompatible(XEN_TO_C_Display(arg1), outs, len1, ins, len2);
  FREE(outs);
  FREE(ins);
  return(C_TO_XEN_BOOLEAN(val));
}

static XEN gxm_XmDragCancel(XEN arg1)
{
  #define H_XmDragCancel "void XmDragCancel(Widget dragcontext) terminates a drag transaction"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmDragCancel", "Widget");
  XmDragCancel(XEN_TO_C_Widget(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmDragStart(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmDragStart "Widget XmDragStart(Widget widget, XEvent *event, ArgList arglist, Cardinal argcount) \
initiates a drag and drop transaction"
  Widget w;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmDragStart", "Widget");
  XEN_ASSERT_TYPE(XEN_XEvent_P(arg2), arg2, 2, "XmDragStart", "XEvent*");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg3), arg3, 3, "XmDragStart", "ArgList");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg4), arg4, 4, "XmDragStart", "int");
  {
    Arg *args;
    int arglen;
    args = XEN_TO_C_Args(arg3);
    arglen = XEN_TO_C_INT_DEF(arg4, arg3);
    w = XmDragStart(XEN_TO_C_Widget(arg1), 
		    XEN_TO_C_XEvent(arg2), 
		    args, arglen);
    if (args)
      {
	fixup_args(w, args, arglen);
	free_args(args, arglen);
      }
  }
  return(C_TO_XEN_Widget(w));
}

static XEN gxm_XmCreatePromptDialog(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreatePromptDialog "Widget XmCreatePromptDialog(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The SelectionBox PromptDialog creation function"
  return(gxm_new_widget("XmCreatePromptDialog", XmCreatePromptDialog, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateSelectionDialog(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateSelectionDialog "Widget XmCreateSelectionDialog(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The SelectionBox SelectionDialog creation function"
  return(gxm_new_widget("XmCreateSelectionDialog", XmCreateSelectionDialog, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateSelectionBox(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateSelectionBox "Widget XmCreateSelectionBox(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The SelectionBox widget creation function"
  return(gxm_new_widget("XmCreateSelectionBox", XmCreateSelectionBox, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmSelectionBoxGetChild(XEN arg1, XEN arg2)
{
  #define H_XmSelectionBoxGetChild "Widget XmSelectionBoxGetChild(Widget widget, unsigned char child) used to access a SelectionBox component"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmSelectionBoxGetChild", "Widget");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XmSelectionBoxGetChild", "unsigned int");
  return(C_TO_XEN_Widget(XmSelectionBoxGetChild(XEN_TO_C_Widget(arg1), XEN_TO_C_ULONG(arg2))));
}

static XEN gxm_XmGetXmDisplay(XEN arg1)
{
  #define H_XmGetXmDisplay "Widget XmGetXmDisplay(Display *display) A Display function that returns the"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmGetXmDisplay", "Display*");
  return(C_TO_XEN_Widget(XmGetXmDisplay(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XmGetDragContext(XEN arg1, XEN arg2)
{
  #define H_XmGetDragContext "Widget XmGetDragContext(Widget refwidget, Time timestamp) retrieves \
the DragContext widget ID associated with a timestamp"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmGetDragContext", "Widget");
  XEN_ASSERT_TYPE(XEN_Time_P(arg2), arg2, 2, "XmGetDragContext", "Time");
  return(C_TO_XEN_Widget(XmGetDragContext(XEN_TO_C_Widget(arg1), XEN_TO_C_Time(arg2))));
}

static XEN gxm_XmScrollVisible(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmScrollVisible "void XmScrollVisible(Widget scrollw_widget, Widget widget, Dimension left_right_margin, Dimension top_bottom_margin) \
makes an invisible  descendant of a ScrolledWindow work area visible"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmScrollVisible", "Widget");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg2), arg2, 2, "XmScrollVisible", "Widget");
  XEN_ASSERT_TYPE(XEN_Dimension_P(arg3), arg3, 3, "XmScrollVisible", "Dimension");
  XEN_ASSERT_TYPE(XEN_Dimension_P(arg4), arg4, 4, "XmScrollVisible", "Dimension");
  XmScrollVisible(XEN_TO_C_Widget(arg1), XEN_TO_C_Widget(arg2), 
		  XEN_TO_C_Dimension(arg3), XEN_TO_C_Dimension(arg4));
  return(XEN_FALSE);
}

static XEN gxm_XmCreateScrolledWindow(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateScrolledWindow "Widget XmCreateScrolledWindow(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The ScrolledWindow widget creation function"
  return(gxm_new_widget("XmCreateScrolledWindow", XmCreateScrolledWindow, arg1, arg2, arg3, arg4));
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XmScrolledWindowSetAreas(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmScrolledWindowSetAreas "void XmScrolledWindowSetAreas(Widget widget, Widget horizontal_scrollbar, Widget vertical_scrollbar, \
Widget work_region) adds or changes a window work region and a horizontal or vertical \
ScrollBar widget to the ScrolledWindow widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmScrolledWindowSetAreas", "Widget");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg2), arg2, 2, "XmScrolledWindowSetAreas", "Widget");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg3), arg3, 3, "XmScrolledWindowSetAreas", "Widget");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg4), arg4, 4, "XmScrolledWindowSetAreas", "Widget");
  XmScrolledWindowSetAreas(XEN_TO_C_Widget(arg1), XEN_TO_C_Widget(arg2), 
			   XEN_TO_C_Widget(arg3), XEN_TO_C_Widget(arg4));
  return(XEN_FALSE);
}
#endif

static XEN gxm_XmCreateDialogShell(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateDialogShell "Widget XmCreateDialogShell(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The DialogShell widget creation function"
  return(gxm_new_widget("XmCreateDialogShell", XmCreateDialogShell, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmScrollBarSetValues(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6)
{
  #define H_XmScrollBarSetValues "void XmScrollBarSetValues (widget, value, slider_size, increment, page_increment, notify) \
changes ScrollBar's increment values and the slider's size and position"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmScrollBarSetValues", "Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmScrollBarSetValues", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmScrollBarSetValues", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XmScrollBarSetValues", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XmScrollBarSetValues", "int");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg6), arg6, 6, "XmScrollBarSetValues", "boolean");
  XmScrollBarSetValues(XEN_TO_C_Widget(arg1), 
		       XEN_TO_C_INT(arg2), XEN_TO_C_INT(arg3), 
		       XEN_TO_C_INT(arg4), XEN_TO_C_INT(arg5), 
		       XEN_TO_C_BOOLEAN(arg6));
  return(XEN_FALSE);
}

static XEN gxm_XmScrollBarGetValues(XEN arg1)
{
  #define H_XmScrollBarGetValues "void XmScrollBarGetValues (widget) returns the ScrollBar's increment values (list val size incr page)"
  /* DIFF: XmScrollBarGetValues omits and returns last 4 args
   */
  int val, size, incr, page;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmScrollBarGetValues", "Widget");
  XmScrollBarGetValues(XEN_TO_C_Widget(arg1), &val, &size, &incr, &page);
  return(XEN_LIST_4(C_TO_XEN_INT(val),
		    C_TO_XEN_INT(size),
		    C_TO_XEN_INT(incr),
		    C_TO_XEN_INT(page)));
}

static XEN gxm_XmCreateScrollBar(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateScrollBar "Widget XmCreateScrollBar(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The ScrollBar widget creation function"
  return(gxm_new_widget("XmCreateScrollBar", XmCreateScrollBar, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmGetXmScreen(XEN arg1)
{
  #define H_XmGetXmScreen "Widget XmGetXmScreen(Screen *screen) returns the XmScreen object ID for a specified screen"
  /* this is the Motif Screen "widget" */
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XmGetXmScreen", "Screen*");
  return(C_TO_XEN_Widget(XmGetXmScreen(XEN_TO_C_Screen(arg1))));
}

static XEN gxm_XmClipboardRegisterFormat(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmClipboardRegisterFormat "int XmClipboardRegisterFormat (display, format_name, format_length) registers a new format"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmClipboardRegisterFormat", "Display*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmClipboardRegisterFormat", "char*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmClipboardRegisterFormat", "int");
  return(C_TO_XEN_INT(XmClipboardRegisterFormat(XEN_TO_C_Display(arg1), 
						XEN_TO_C_STRING(arg2), XEN_TO_C_INT(arg3))));
}

static XEN gxm_XmClipboardInquirePendingItems(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmClipboardInquirePendingItems "int XmClipboardInquirePendingItems (display, window, format_name) \
returns a list of data ID/private ID pairs"
  /* DIFF: XmClipboardInquirePendingItems omits last 2 args, returns list of pairs
   */
  unsigned long len;
  XmClipboardPendingList clst;
  int i, loc, rtn;
  XEN lst = XEN_EMPTY_LIST;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmClipboardInquirePendingItems", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XmClipboardInquirePendingItems", "Window");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3), arg3, 3, "XmClipboardInquirePendingItems", "char*");
  rtn = XmClipboardInquirePendingItems(XEN_TO_C_Display(arg1), 
				       XEN_TO_C_Window(arg2), 
				       XEN_TO_C_STRING(arg3), 
				       &clst,
				       &len);
  loc = xm_protect(lst);
  for (i = len - 1; i >= 0; i--)
    lst = XEN_CONS(XEN_LIST_2(C_TO_XEN_INT(clst[i].DataId), 
			      C_TO_XEN_INT(clst[i].PrivateId)),
		   lst);
  lst = XEN_CONS(C_TO_XEN_INT(rtn), lst);
  xm_unprotect_at(loc);
  return(lst);
}

static XEN gxm_XmClipboardInquireLength(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmClipboardInquireLength "int XmClipboardInquireLength (display, window, format_name) returns the length of the stored data"
  /* DIFF: XmClipboardInquireLength omit and rtn last arg
   */
  unsigned long len;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmClipboardInquireLength", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XmClipboardInquireLength", "Window");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3), arg3, 3, "XmClipboardInquireLength", "char*");
  val = XmClipboardInquireLength(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_STRING(arg3), &len);
  return(XEN_LIST_2(C_TO_XEN_INT(val),
		    C_TO_XEN_ULONG(len)));
}

static XEN gxm_XmClipboardInquireFormat(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmClipboardInquireFormat "int XmClipboardInquireFormat (display, window, index, buffer_len) \
returns a specified format name"
  /* DIFF: XmClipboardInquireFormat omits arg4 (XtPointer buffer) and arg6, returns them
   */
  XEN res;
  XtPointer buf;
  unsigned long len, n;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmClipboardInquireFormat", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XmClipboardInquireFormat", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmClipboardInquireFormat", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg4), arg4, 4, "XmClipboardInquireFormat", "ulong");
  len = XEN_TO_C_ULONG(arg4);
  if (len == 0) return(XEN_FALSE);
  buf = (XtPointer)CALLOC(len + 1, sizeof(char));
  val = XmClipboardInquireFormat(XEN_TO_C_Display(arg1), 
				 XEN_TO_C_Window(arg2), 
				 XEN_TO_C_INT(arg3), 
				 buf, len, &n);
  res = C_TO_XEN_STRING((char *)buf);
  FREE(buf);
  return(XEN_LIST_2(C_TO_XEN_INT(val), res));
}

static XEN gxm_XmClipboardInquireCount(XEN arg1, XEN arg2)
{
  #define H_XmClipboardInquireCount "int XmClipboardInquireCount (display, window) returns the number of data item formats"
  /* DIFF: XmClipboardInquireCount omits and rtns last 2 args
   */
  int count, val;
  unsigned long len;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmClipboardInquireCount", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XmClipboardInquireCount", "Window");
  val = XmClipboardInquireCount(XEN_TO_C_Display(arg1), 
				XEN_TO_C_Window(arg2),
				&count, &len);
  return(XEN_LIST_3(C_TO_XEN_INT(val),
		    C_TO_XEN_INT(count),
		    C_TO_XEN_ULONG(len)));
}

static XEN gxm_XmClipboardRetrieve(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmClipboardRetrieve "int XmClipboardRetrieve (display, window, format_name, length) retrieves a data item from the clipboard"
  /* DIFF: XmClipboardRetrieve omits buf arg, and last 2, returning them and a list of ulongs
   */
  unsigned long n;
  long id;
  XtPointer buf;
  int len, val;
  XEN str;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmClipboardRetrieve", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XmClipboardRetrieve", "Window");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3), arg3, 3, "XmClipboardRetrieve", "char*");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg4), arg4, 4, "XmClipboardRetrieve", "ulong");
  len = XEN_TO_C_ULONG(arg4);
  if (len <= 0) return(XEN_FALSE);
  buf = (XtPointer)MALLOC(len);
  val = XmClipboardRetrieve(XEN_TO_C_Display(arg1), 
			    XEN_TO_C_Window(arg2), 
			    XEN_TO_C_STRING(arg3), 
			    buf, len, &n, &id);
  str = C_TO_XEN_STRING((char *)buf);
  FREE(buf);
  return(XEN_LIST_3(C_TO_XEN_INT(val),
		    str,
		    C_TO_XEN_ULONG(id)));
}

static XEN gxm_XmClipboardEndRetrieve(XEN arg1, XEN arg2)
{
  #define H_XmClipboardEndRetrieve "int XmClipboardEndRetrieve (display, window) completes retrieval of \
data from the clipboard"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmClipboardEndRetrieve", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XmClipboardEndRetrieve", "Window");
  return(C_TO_XEN_INT(XmClipboardEndRetrieve(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2))));
}

static XEN gxm_XmClipboardStartRetrieve(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmClipboardStartRetrieve "int XmClipboardStartRetrieve (display, window, timestamp) \
prepares to retrieve data from the clipboard"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmClipboardStartRetrieve", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XmClipboardStartRetrieve", "Window");
  XEN_ASSERT_TYPE(XEN_Time_P(arg3), arg3, 3, "XmClipboardStartRetrieve", "Time");
  return(C_TO_XEN_INT(XmClipboardStartRetrieve(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_Time(arg3))));
}

static XEN gxm_XmClipboardUnlock(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmClipboardUnlock "int XmClipboardUnlock (display, window, remove_all_locks) unlocks the clipboard"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmClipboardUnlock", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XmClipboardUnlock", "Window");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg3), arg3, 3, "XmClipboardUnlock", "boolean");
  return(C_TO_XEN_INT(XmClipboardUnlock(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_BOOLEAN(arg3))));
}

static XEN gxm_XmClipboardLock(XEN arg1, XEN arg2)
{
  #define H_XmClipboardLock "int XmClipboardLock (display, window) locks the clipboard"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmClipboardLock", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XmClipboardLock", "Window");
  return(C_TO_XEN_INT(XmClipboardLock(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2))));
}

static XEN gxm_XmClipboardUndoCopy(XEN arg1, XEN arg2)
{
  #define H_XmClipboardUndoCopy "int XmClipboardUndoCopy (display, window) deletes the last item placed on the clipboard"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmClipboardUndoCopy", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XmClipboardUndoCopy", "Window");
  return(C_TO_XEN_INT(XmClipboardUndoCopy(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2))));
}

static XEN gxm_XmClipboardCopyByName(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6)
{
  #define H_XmClipboardCopyByName "int XmClipboardCopyByName (display, window, data_id,  buf, len, id) copies a data item passed by name"
  /* DIFF: XmClipboardCopyByName arg4 is string
   */
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmClipboardCopyByName", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XmClipboardCopyByName", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmClipboardCopyByName", "long");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg4), arg4, 4, "XmClipboardCopyByName", "XtPointer");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg5), arg5, 5, "XmClipboardCopyByName", "ulong");
  return(C_TO_XEN_INT(XmClipboardCopyByName(XEN_TO_C_Display(arg1), 
					    XEN_TO_C_Window(arg2), XEN_TO_C_INT(arg3), 
					    (XtPointer)XEN_TO_C_STRING(arg4), 
					    XEN_TO_C_ULONG(arg5), 
					    (unsigned long)arg6)));
}

static XEN gxm_XmClipboardWithdrawFormat(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmClipboardWithdrawFormat "int XmClipboardWithdrawFormat (display, window, data_id) \
indicates that the application no longer wants to supply a data item"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmClipboardWithdrawFormat", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XmClipboardWithdrawFormat", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmClipboardWithdrawFormat", "long");
  return(C_TO_XEN_INT(XmClipboardWithdrawFormat(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_INT(arg3))));
}

static XEN gxm_XmClipboardCancelCopy(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmClipboardCancelCopy "int XmClipboardCancelCopy (display, window, item_id) cancels a copy to the clipboard"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmClipboardCancelCopy", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XmClipboardCancelCopy", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmClipboardCancelCopy", "long");
  return(C_TO_XEN_INT(XmClipboardCancelCopy(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_INT(arg3))));
}

static XEN gxm_XmClipboardEndCopy(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmClipboardEndCopy "int XmClipboardEndCopy (display, window, item_id) completes the \
copying of data to the clipboard"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmClipboardEndCopy", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XmClipboardEndCopy", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmClipboardEndCopy", "long");
  return(C_TO_XEN_INT(XmClipboardEndCopy(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_INT(arg3))));
}

static XEN gxm_XmClipboardCopy(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7)
{
  #define H_XmClipboardCopy "int XmClipboardCopy (display, window, item_id, format_name, buffer, len, id) copies a data item \
to temporary storage for later copying to clipboard"
  /* DIFF: XmClipboardCopy omits and returns last arg, arg5 is string
   */
  long id;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmClipboardCopy", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XmClipboardCopy", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmClipboardCopy", "long");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg4), arg4, 4, "XmClipboardCopy", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg5), arg5, 5, "XmClipboardCopy", "XtPointer");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg6), arg6, 6, "XmClipboardCopy", "ulong");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg7), arg7, 7, "XmClipboardCopy", "long");
  val = XmClipboardCopy(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), 
			XEN_TO_C_INT(arg3), XEN_TO_C_STRING(arg4), 
			(XtPointer)XEN_TO_C_STRING(arg5), XEN_TO_C_ULONG(arg6), 
			XEN_TO_C_INT(arg7), &id);
  return(XEN_LIST_2(C_TO_XEN_INT(val),
		    C_TO_XEN_INT(id)));
}

/* There's just one clipboard, I think, so these callbacks must be globals */
static XEN xm_XmCutPasteProc = XEN_FALSE;

static void gxm_XmCutPasteProc(Widget w, long *data, long *privater, int *reason)
{
  XEN_CALL_4(xm_XmCutPasteProc, 
	     C_TO_XEN_Widget(w),
	     C_TO_XEN_ULONG(*data),
	     C_TO_XEN_ULONG(*privater),
	     C_TO_XEN_INT(*reason),
	     c__FUNCTION__);
}

static XEN gxm_XmClipboardStartCopy(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6)
{
  #define H_XmClipboardStartCopy "int XmClipboardStartCopy (display, window, clip_label, timestamp, widget, callback) \
sets up a storage and data structure, returns id"
  /* DIFF: XmClipboardStartCopy omits and returns last arg
   */
  long id;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmClipboardStartCopy", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XmClipboardStartCopy", "Window");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg3), arg3, 3, "XmClipboardStartCopy", "XmString");
  XEN_ASSERT_TYPE(XEN_Time_P(arg4), arg4, 4, "XmClipboardStartCopy", "Time");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg5), arg5, 5, "XmClipboardStartCopy", "Widget");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg6) && (XEN_REQUIRED_ARGS_OK(arg6, 4)), arg6, 6, "XmClipboardStartCopy", "(XmCutPasteProc widget data priv reason)");
  xm_protect(arg6);
  if (XEN_PROCEDURE_P(xm_XmCutPasteProc)) xm_unprotect(xm_XmCutPasteProc);
  xm_XmCutPasteProc = arg6;
  val = XmClipboardStartCopy(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_XmString(arg3), 
			     XEN_TO_C_Time(arg4), XEN_TO_C_Widget(arg5), (XmCutPasteProc)gxm_XmCutPasteProc, &id);
  return(XEN_LIST_2(C_TO_XEN_INT(val),
		    C_TO_XEN_INT(id)));
}

static XEN xm_XmVoidProc = XEN_FALSE;
static void gxm_XmVoidProc(Widget w, int *data, int *privater, int *reason)
{
  XEN_CALL_4(xm_XmVoidProc, 
	     C_TO_XEN_Widget(w),
	     C_TO_XEN_ULONG(*data),
	     C_TO_XEN_ULONG(*privater),
	     C_TO_XEN_INT(*reason),
	     c__FUNCTION__);
}

static XEN gxm_XmClipboardBeginCopy(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XmClipboardBeginCopy "int XmClipboardBeginCopy(display, window, XmString label, widget, callback)"
  /* DIFF: XmClipboardBeinCopy omits and returns last arg
   */
  long id;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmClipboardBeginCopy", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XmClipboardBeginCopy", "Window");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg3), arg3, 3, "XmClipboardBeginCopy", "XmString");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg4), arg4, 4, "XmClipboardBeginCopy", "Widget");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg5) && (XEN_REQUIRED_ARGS_OK(arg5, 4)), arg5, 5, "XmClipboardBeginCopy", "(XmVoidProc widget data priv reason)");
  xm_protect(arg5);
  if (XEN_PROCEDURE_P(xm_XmVoidProc)) xm_unprotect(xm_XmVoidProc);
  xm_XmVoidProc = arg5;
  val = XmClipboardBeginCopy(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), 
			     XEN_TO_C_XmString(arg3), XEN_TO_C_Widget(arg4), 
			     gxm_XmVoidProc, &id);
  return(XEN_LIST_2(C_TO_XEN_INT(val),
		    C_TO_XEN_INT(id)));
}

#define XEN_ScaleWidget_P(Arg) (XEN_Widget_P(Arg) && XmIsScale(XEN_TO_C_Widget(Arg)))

static XEN gxm_XmScaleSetTicks(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7)
{
  #define H_XmScaleSetTicks "void XmScaleSetTicks(Widget scale, int big_every, Cardinal num_medium, Cardinal num_small, Dimension size_big, \
Dimension size_medium, Dimension size_small) controls Scale tick marks"
  XEN_ASSERT_TYPE(XEN_ScaleWidget_P(arg1), arg1, 1, "XmScaleSetTicks", "Scale Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmScaleSetTicks", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmScaleSetTicks", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XmScaleSetTicks", "int");
  XEN_ASSERT_TYPE(XEN_Dimension_P(arg5), arg5, 5, "XmScaleSetTicks", "Dimension");
  XEN_ASSERT_TYPE(XEN_Dimension_P(arg6), arg6, 6, "XmScaleSetTicks", "Dimension");
  XEN_ASSERT_TYPE(XEN_Dimension_P(arg7), arg7, 7, "XmScaleSetTicks", "Dimension");
  XmScaleSetTicks(XEN_TO_C_Widget(arg1), 
		  XEN_TO_C_INT(arg2), XEN_TO_C_INT(arg3), XEN_TO_C_INT(arg4), 
		  XEN_TO_C_Dimension(arg5), XEN_TO_C_Dimension(arg6), XEN_TO_C_Dimension(arg7));
  return(XEN_FALSE);
}

static XEN gxm_XmCreateScale(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateScale "Widget XmCreateScale(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The Scale widget creation function"
  return(gxm_new_widget("XmCreateScale", XmCreateScale, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmScaleGetValue(XEN arg1)
{
  #define H_XmScaleGetValue "void XmScaleGetValue(Widget widget) returns the current (scale) slider position"
  /* DIFF: XmScaleGetValue omits and returns arg2
   */
  int val;
  XEN_ASSERT_TYPE(XEN_ScaleWidget_P(arg1), arg1, 1, "XmScaleGetValue", "Scale Widget");
  XmScaleGetValue(XEN_TO_C_Widget(arg1), &val);
  return(C_TO_XEN_INT(val));
}

static XEN gxm_XmScaleSetValue(XEN arg1, XEN arg2)
{
  #define H_XmScaleSetValue "void XmScaleSetValue(Widget widget, int value) sets a Scale slider value"
  XEN_ASSERT_TYPE(XEN_ScaleWidget_P(arg1), arg1, 1, "XmScaleSetValue", "Scale Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmScaleSetValue", "int");
  XmScaleSetValue(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2));
  return(XEN_FALSE);
}

#define XEN_ContainerWidget_P(Arg) (XEN_Widget_P(Arg) && XmIsContainer(XEN_TO_C_Widget(Arg)))

static XEN gxm_XmContainerPasteLink(XEN arg1)
{
  #define H_XmContainerPasteLink "Boolean XmContainerPasteLink(Widget container) container function to insert links from the clipboard"
  XEN_ASSERT_TYPE(XEN_ContainerWidget_P(arg1), arg1, 1, "XmContainerPasteLink", "Container Widget");
  return(C_TO_XEN_BOOLEAN(XmContainerPasteLink(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmContainerCopyLink(XEN arg1, XEN arg2)
{
  #define H_XmContainerCopyLink "Boolean XmContainerCopyLink(Widget container, Time timestamp) Container function to copy links to the clipboard"
  XEN_ASSERT_TYPE(XEN_ContainerWidget_P(arg1), arg1, 1, "XmContainerCopyLink", "Container Widget");
  XEN_ASSERT_TYPE(XEN_Time_P(arg2), arg2, 2, "XmContainerCopyLink", "Time");
  return(C_TO_XEN_BOOLEAN(XmContainerCopyLink(XEN_TO_C_Widget(arg1), XEN_TO_C_Time(arg2))));
}

static XEN gxm_XmContainerPaste(XEN arg1)
{
  #define H_XmContainerPaste "Boolean XmContainerPaste(Widget container) Container function to insert items from the clipboard"
  XEN_ASSERT_TYPE(XEN_ContainerWidget_P(arg1), arg1, 1, "XmContainerPaste", "Container Widget");
  return(C_TO_XEN_BOOLEAN(XmContainerPaste(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmContainerCopy(XEN arg1, XEN arg2)
{
  #define H_XmContainerCopy "Boolean XmContainerCopy(Widget container, Time timestamp) Container function to copy primary selection to the clipboard"
  XEN_ASSERT_TYPE(XEN_ContainerWidget_P(arg1), arg1, 1, "XmContainerCopy", "Container Widget");
  XEN_ASSERT_TYPE(XEN_Time_P(arg2), arg2, 2, "XmContainerCopy", "Time");
  return(C_TO_XEN_BOOLEAN(XmContainerCopy(XEN_TO_C_Widget(arg1), XEN_TO_C_Time(arg2))));
}

static XEN gxm_XmContainerCut(XEN arg1, XEN arg2)
{
  #define H_XmContainerCut "Boolean XmContainerCut(Widget container, Time timestamp) Container function to move items to the clipboard"
  XEN_ASSERT_TYPE(XEN_ContainerWidget_P(arg1), arg1, 1, "XmContainerCut", "Container Widget");
  XEN_ASSERT_TYPE(XEN_Time_P(arg2), arg2, 2, "XmContainerCut", "Time");
  return(C_TO_XEN_BOOLEAN(XmContainerCut(XEN_TO_C_Widget(arg1), XEN_TO_C_Time(arg2))));
}

static XEN gxm_XmContainerReorder(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmContainerReorder "void XmContainerReorder(Widget container, WidgetList widgets, int num_widgets) Container function to reorder children"
  /* DIFF: XmContainerReorder arg2 is list of Widgets
   */
  int len;
  XEN_ASSERT_TYPE(XEN_ContainerWidget_P(arg1), arg1, 1, "XmContainerReorder", "Container Widget");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XmContainerReorder", "WidgetList");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmContainerReorder", "int");
  len = XEN_TO_C_INT(arg3);
  if (len > 0)
    {
      if (len > XEN_LIST_LENGTH(arg2))
	XEN_OUT_OF_RANGE_ERROR("XmContainerReorder", 3, arg3, "len too large");
      else
	{
	  WidgetList ws;
	  ws = XEN_TO_C_Widgets(arg2, len);
	  XmContainerReorder(XEN_TO_C_Widget(arg1), ws, len);
	  if (ws) FREE(ws);
	}
    }
  return(XEN_FALSE);
}

static XEN gxm_XmContainerRelayout(XEN arg1)
{
  #define H_XmContainerRelayout "void XmContainerRelayout(Widget container) Container relayout function"
  XEN_ASSERT_TYPE(XEN_ContainerWidget_P(arg1), arg1, 1, "XmContainerRelayout", "Container Widget");
  XmContainerRelayout(XEN_TO_C_Widget(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmContainerGetItemChildren(XEN arg1, XEN arg2)
{
  #define H_XmContainerGetItemChildren "int XmContainerGetItemChildren(Widget container, Widget item) \
returns a list of all children of an item"
  /* DIFF: XmContainerGetItemChildren omits arg3, rtns widget list
   */
  Widget *ws;
  int len;
  XEN_ASSERT_TYPE(XEN_ContainerWidget_P(arg1), arg1, 1, "XmContainerGetItemChildren", "Container Widget");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg2), arg2, 2, "XmContainerGetItemChildren", "Widget");
  len = XmContainerGetItemChildren(XEN_TO_C_Widget(arg1), XEN_TO_C_Widget(arg2), &ws);
  return(C_TO_XEN_Widgets(ws, len));
}

static XEN gxm_XmCreateContainer(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateContainer "Widget XmCreateContainer(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The Container creation function"
  return(gxm_new_widget("XmCreateContainer", XmCreateContainer, arg1, arg2, arg3, arg4));
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XmRemoveFromPostFromList(XEN arg1, XEN arg2)
{
  #define H_XmRemoveFromPostFromList "void XmRemoveFromPostFromList(Widget menu, Widget post_from_widget) \
disables a menu for a particular widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmRemoveFromPostFromList", "Widget");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg2), arg2, 2, "XmRemoveFromPostFromList", "Widget");
  XmRemoveFromPostFromList(XEN_TO_C_Widget(arg1), XEN_TO_C_Widget(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmAddToPostFromList(XEN arg1, XEN arg2)
{
  #define H_XmAddToPostFromList "void XmAddToPostFromList(Widget menu, Widget post_from_widget) \
makes a menu accessible from more than one widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmAddToPostFromList", "Widget");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg2), arg2, 2, "XmAddToPostFromList", "Widget");
  XmAddToPostFromList(XEN_TO_C_Widget(arg1), XEN_TO_C_Widget(arg2));
  return(XEN_FALSE);
}
#endif

static XEN gxm_XmGetTearOffControl(XEN arg1)
{
  #define H_XmGetTearOffControl "Widget XmGetTearOffControl(Widget menu) obtains the widget ID for the tear-off control in a menu"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmGetTearOffControl", "Widget");
  return(C_TO_XEN_Widget(XmGetTearOffControl(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmGetPostedFromWidget(XEN arg1)
{
  #define H_XmGetPostedFromWidget "Widget XmGetPostedFromWidget(Widget menu) returns the widget from which a menu was posted"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmGetPostedFromWidget", "Widget");
  return(C_TO_XEN_Widget(XmGetPostedFromWidget(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmCreatePulldownMenu(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreatePulldownMenu "Widget XmCreatePulldownMenu(Widget parent, String name, ArgList arglist, Cardinal argcount) \
A RowColumn widget creation function"
  return(gxm_new_widget("XmCreatePulldownMenu", XmCreatePulldownMenu, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreatePopupMenu(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreatePopupMenu "Widget XmCreatePopupMenu(Widget parent, String name, ArgList arglist, Cardinal argcount) \
A RowColumn widget creation function"
  return(gxm_new_widget("XmCreatePopupMenu", XmCreatePopupMenu, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateMenuBar(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateMenuBar "Widget XmCreateMenuBar(Widget parent, String name, ArgList arglist, Cardinal argcount) \
A RowColumn widget creation function"
  return(gxm_new_widget("XmCreateMenuBar", XmCreateMenuBar, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmOptionButtonGadget(XEN arg1)
{
  #define H_XmOptionButtonGadget "Widget XmOptionButtonGadget(Widget option_menu) obtains \
the widget ID for the CascadeButtonGadget in an OptionMenu"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmOptionButtonGadget", "Widget");
  return(C_TO_XEN_Widget(XmOptionButtonGadget(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmOptionLabelGadget(XEN arg1)
{
  #define H_XmOptionLabelGadget "Widget XmOptionLabelGadget(Widget option_menu) obtains the \
widget ID for the LabelGadget in an OptionMenu"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmOptionLabelGadget", "Widget");
  return(C_TO_XEN_Widget(XmOptionLabelGadget(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XmCreateOptionMenu(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateOptionMenu "Widget XmCreateOptionMenu(Widget parent, String name, ArgList arglist, Cardinal argcount) \
A RowColumn widget creation function"
  return(gxm_new_widget("XmCreateOptionMenu", XmCreateOptionMenu, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateRadioBox(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateRadioBox "Widget XmCreateRadioBox(Widget parent, String name, ArgList arglist, Cardinal argcount) \
A RowColumn widget creation function"
  return(gxm_new_widget("XmCreateRadioBox", XmCreateRadioBox, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateWorkArea(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateWorkArea "Widget XmCreateWorkArea(Widget parent, String name, ArgList arglist, Cardinal argcount) \
creates a RowColumn WorkArea"
  return(gxm_new_widget("XmCreateWorkArea", XmCreateWorkArea, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateRowColumn(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateRowColumn "Widget XmCreateRowColumn(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The RowColumn widget creation function"
  return(gxm_new_widget("XmCreateRowColumn", XmCreateRowColumn, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmMenuPosition(XEN arg1, XEN arg2)
{
  #define H_XmMenuPosition "void XmMenuPosition(Widget menu, XButtonPressedEvent *event) positions a Popup menu pane"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmMenuPosition", "Widget");
  XEN_ASSERT_TYPE(XEN_XButtonEvent_P(arg2), arg2, 2, "XmMenuPosition", "XButtonPressedEvent*");
  XmMenuPosition(XEN_TO_C_Widget(arg1), XEN_TO_C_XButtonEvent(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmCreateCommandDialog(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateCommandDialog "Widget XmCreateCommandDialog(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The Command CommandDialog creation function"
  return(gxm_new_widget("XmCreateCommandDialog", XmCreateCommandDialog, arg1, arg2, arg3, arg4));
}

#define XEN_CommandWidget_P(Arg) (XEN_Widget_P(Arg) && XmIsCommand(XEN_TO_C_Widget(Arg)))

static XEN gxm_XmCommandError(XEN arg1, XEN arg2)
{
  #define H_XmCommandError "void XmCommandError(Widget widget, XmString error) Command function that displays an error message"
  XEN_ASSERT_TYPE(XEN_CommandWidget_P(arg1), arg1, 1, "XmCommandError", "Command Widget");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmCommandError", "XmString");
  XmCommandError(XEN_TO_C_Widget(arg1), XEN_TO_C_XmString(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmCommandAppendValue(XEN arg1, XEN arg2)
{
  #define H_XmCommandAppendValue "void XmCommandAppendValue(Widget widget, XmString command) \
appends the passed XmString to the end of the string displayed in the command area of the widget"
  XEN_ASSERT_TYPE(XEN_CommandWidget_P(arg1), arg1, 1, "XmCommandAppendValue", "Command Widget");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmCommandAppendValue", "XmString");
  XmCommandAppendValue(XEN_TO_C_Widget(arg1), XEN_TO_C_XmString(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmCommandSetValue(XEN arg1, XEN arg2)
{
  #define H_XmCommandSetValue "void XmCommandSetValue(Widget widget, XmString command) A Command function that replaces a displayed string"
  XEN_ASSERT_TYPE(XEN_CommandWidget_P(arg1), arg1, 1, "XmCommandSetValue", "Command Widget");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmCommandSetValue", "XmString");
  XmCommandSetValue(XEN_TO_C_Widget(arg1), XEN_TO_C_XmString(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmCommandGetChild(XEN arg1, XEN arg2)
{
  #define H_XmCommandGetChild "Widget XmCommandGetChild(Widget widget, unsigned char child) A Command function that is used to access a component"
  XEN_ASSERT_TYPE(XEN_CommandWidget_P(arg1), arg1, 1, "XmCommandGetChild", "Command Widget");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XmCommandGetChild", "unsigned int");
  return(C_TO_XEN_Widget(XmCommandGetChild(XEN_TO_C_Widget(arg1), XEN_TO_C_ULONG(arg2))));
}

static XEN gxm_XmCreateCommand(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateCommand "Widget XmCreateCommand(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The Command widget creation function"
  return(gxm_new_widget("XmCreateCommand", XmCreateCommand, arg1, arg2, arg3, arg4));
}

#define XEN_ComboBoxWidget_P(Arg) (XEN_Widget_P(Arg) && XmIsComboBox(XEN_TO_C_Widget(Arg)))

static XEN gxm_XmComboBoxUpdate(XEN arg1)
{
  #define H_XmComboBoxUpdate "void XmComboBoxUpdate(Widget widget) A ComboBox function that resynchronizes data"
  XEN_ASSERT_TYPE(XEN_ComboBoxWidget_P(arg1), arg1, 1, "XmComboBoxUpdate", "ComboBox Widget");
  XmComboBoxUpdate(XEN_TO_C_Widget(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmComboBoxSetItem(XEN arg1, XEN arg2)
{
  #define H_XmComboBoxSetItem "void XmComboBoxSetItem(Widget w, XmString item) set an item in the XmComboBox list"
  XEN_ASSERT_TYPE(XEN_ComboBoxWidget_P(arg1), arg1, 1, "XmComboBoxSetItem", "ComboBox Widget");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmComboBoxSetItem", "XmString");
  XmComboBoxSetItem(XEN_TO_C_Widget(arg1), XEN_TO_C_XmString(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmComboBoxSelectItem(XEN arg1, XEN arg2)
{
  #define H_XmComboBoxSelectItem "void XmComboBoxSelectItem(Widget w, XmString item) select a XmComboBox item"
  XEN_ASSERT_TYPE(XEN_ComboBoxWidget_P(arg1), arg1, 1, "XmComboBoxSelectItem", "ComboBox Widget");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmComboBoxSelectItem", "XmString");
  XmComboBoxSelectItem(XEN_TO_C_Widget(arg1), XEN_TO_C_XmString(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmComboBoxDeletePos(XEN arg1, XEN arg2)
{
  #define H_XmComboBoxDeletePos "void XmComboBoxDeletePos(Widget w, int pos)  Delete a XmComboBox item"
  XEN_ASSERT_TYPE(XEN_ComboBoxWidget_P(arg1), arg1, 1, "XmComboBoxDeletePos", "ComboBox Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmComboBoxDeletePos", "int");
  XmComboBoxDeletePos(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmComboBoxAddItem(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmComboBoxAddItem "void XmComboBoxAddItem(Widget w, XmString item, int pos, Boolean unique) add an item to the ComboBox widget"
  XEN_ASSERT_TYPE(XEN_ComboBoxWidget_P(arg1), arg1, 1, "XmComboBoxAddItem", "ComboBox Widget");
  XEN_ASSERT_TYPE(XEN_XmString_P(arg2), arg2, 2, "XmComboBoxAddItem", "XmString");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XmComboBoxAddItem", "int");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg4), arg4, 4, "XmComboBoxAddItem", "Boolean");
  XmComboBoxAddItem(XEN_TO_C_Widget(arg1), XEN_TO_C_XmString(arg2), XEN_TO_C_INT(arg3), XEN_TO_C_BOOLEAN(arg4));
  return(XEN_FALSE);
}

static XEN gxm_XmCreateDropDownList(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateDropDownList "Widget XmCreateDropDownList(Widget parent, String name, ArgList arglist, Cardinal arg_count) \
The Drop-down list ComboBox widget creation function"
  return(gxm_new_widget("XmCreateDropDownList", XmCreateDropDownList, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateDropDownComboBox(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateDropDownComboBox "Widget XmCreateDropDownComboBox(Widget parent, String name, ArgList arglist, Cardinal arg_count) \
The Drop-down ComboBox widget creation function"
  return(gxm_new_widget("XmCreateDropDownComboBox", XmCreateDropDownComboBox, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateComboBox(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateComboBox "Widget XmCreateComboBox(Widget parent, String name, ArgList arglist, Cardinal arg_count) \
The default ComboBox widget creation function"
  return(gxm_new_widget("XmCreateComboBox", XmCreateComboBox, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreatePushButton(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreatePushButton "Widget XmCreatePushButton(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The PushButton widget creation function"
  return(gxm_new_widget("XmCreatePushButton", XmCreatePushButton, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreatePushButtonGadget(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreatePushButtonGadget "Widget XmCreatePushButtonGadget(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The PushButtonGadget creation function"
  return(gxm_new_widget("XmCreatePushButtonGadget", XmCreatePushButtonGadget, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCascadeButtonHighlight(XEN arg1, XEN arg2)
{
  #define H_XmCascadeButtonHighlight "void XmCascadeButtonHighlight(Widget cascadeButton, Boolean highlight) A CascadeButton and \
CascadeButtonGadget function that sets the highlight state"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmCascadeButtonHighlight", "Widget");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg2), arg2, 2, "XmCascadeButtonHighlight", "boolean");
  XmCascadeButtonHighlight(XEN_TO_C_Widget(arg1), XEN_TO_C_BOOLEAN(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmCreateCascadeButton(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateCascadeButton "Widget XmCreateCascadeButton(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The CascadeButton widget creation function"
  return(gxm_new_widget("XmCreateCascadeButton", XmCreateCascadeButton, arg1, arg2, arg3, arg4));
}

static void gxm_ProtocolProc(Widget w, XtPointer context, XtPointer info)
{
  XEN descr = (XEN)context;
  XEN_CALL_3(XEN_CADR(descr),
	     C_TO_XEN_Widget(w),
	     XEN_CADDR(descr),
	     C_TO_XEN_ULONG(info), /* what's this? */
	     c__FUNCTION__);
}

#define C_TO_XEN_XM_ProtocolHook(Code, Context, PropertyAtom, ProtocolAtom) \
  XEN_LIST_5(C_STRING_TO_XEN_SYMBOL("ProtocolHook"), Code, Context, PropertyAtom, ProtocolAtom)
/* #define XM_ProtocolHook_P(Arg) WRAP_P("ProtocolHook", Arg) */

#define C_TO_XEN_XM_ProtocolProc(Code, Context, PropertyAtom, ProtocolAtom) \
  XEN_LIST_5(C_STRING_TO_XEN_SYMBOL("ProtocolProc"), Code, Context, PropertyAtom, ProtocolAtom)
#define XM_ProtocolProc_P(Arg) WRAP_P("ProtocolProc", Arg)

static XEN gxm_XmSetProtocolHooks(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7)
{
  #define H_XmSetProtocolHooks "void XmSetProtocolHooks(Widget shell, Atom property, Atom protocol, XtCallbackProc prehook, \
XtPointer pre_closure, XtCallbackProc posthook, XtPointer post_closure) A VendorShell function that allows preactions and postactions \
to be executed when a protocol message is received from MWM"
  XEN descr1, descr2;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmSetProtocolHooks", "Widget");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg2), arg2, 2, "XmSetProtocolHooks", "Atom");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg3), arg3, 3, "XmSetProtocolHooks", "Atom");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg4) && (XEN_REQUIRED_ARGS_OK(arg4, 3)), arg4, 4, "XmSetProtocolHooks", "(XtCallbackProc widget data callb)");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg6) && (XEN_REQUIRED_ARGS_OK(arg6, 3)), arg6, 6, "XmSetProtocolHooks", "(XtCallbackProc widget data callb)");
  descr1 = C_TO_XEN_XM_ProtocolHook(arg4, arg5, arg2, arg3);
  descr2 = C_TO_XEN_XM_ProtocolHook(arg6, arg7, arg2, arg3);
  xm_protect(descr1);
  xm_protect(descr2);
  XmSetProtocolHooks(XEN_TO_C_Widget(arg1), XEN_TO_C_Atom(arg2), XEN_TO_C_Atom(arg3),
		     gxm_ProtocolProc, (XtPointer)descr1,
		     gxm_ProtocolProc, (XtPointer)descr2);
  return(XEN_FALSE);
}

static XEN gxm_XmDeactivateProtocol(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmDeactivateProtocol "void XmDeactivateProtocol(Widget shell, Atom property, Atom protocol) \
deactivates a protocol without removing it"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmDeactivateProtocol", "Widget");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg2), arg2, 2, "XmDeactivateProtocol", "Atom");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg3), arg3, 3, "XmDeactivateProtocol", "Atom");
  XmDeactivateProtocol(XEN_TO_C_Widget(arg1), XEN_TO_C_Atom(arg2), XEN_TO_C_Atom(arg3));
  return(XEN_FALSE);
}

static XEN gxm_XmActivateProtocol(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmActivateProtocol "oid XmActivateProtocol(Widget shell, Atom property, Atom protocol) activates a protocol"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmActivateProtocol", "Widget");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg2), arg2, 2, "XmActivateProtocol", "Atom");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg3), arg3, 3, "XmActivateProtocol", "Atom");
  XmActivateProtocol(XEN_TO_C_Widget(arg1), XEN_TO_C_Atom(arg2), XEN_TO_C_Atom(arg3));
  return(XEN_FALSE);
}

static bool unprotect_protocolproc(XEN val, int loc, unsigned long udescr)
{
  XEN descr = (XEN)udescr; /* ('protocolproc func data propatom protoatom) */
  return((XM_ProtocolProc_P(val)) &&
	 (XEN_TO_C_ULONG(XEN_CADR(val)) == XEN_TO_C_ULONG(XEN_CADR(descr))) &&
	 (XEN_TO_C_ULONG(XEN_CADDR(val)) == XEN_TO_C_ULONG(XEN_CADDR(descr))) &&
	 (XEN_TO_C_Atom(XEN_LIST_REF(val, 3)) == XEN_TO_C_Atom(XEN_LIST_REF(val,3))) &&
	 (XEN_TO_C_Atom(XEN_LIST_REF(val, 4)) == XEN_TO_C_Atom(XEN_LIST_REF(val,4))));
}

static XEN gxm_XmRemoveProtocolCallback(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XmRemoveProtocolCallback "void XmRemoveProtocolCallback(Widget shell, Atom property, Atom protocol, XtCallbackProc callback, \
XtPointer closure) removes a callback from the internal list"
  XEN descr;
  int loc, dloc;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmRemoveProtocolCallback", "Widget");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg2), arg2, 2, "XmRemoveProtocolCallback", "Atom");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg3), arg3, 3, "XmRemoveProtocolCallback", "Atom"); 
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg4) && (XEN_REQUIRED_ARGS_OK(arg4, 3)), arg4, 4, "XmRemoveProtocolCallback", "XtCallbackProc (3 args)");
  descr = C_TO_XEN_XM_ProtocolProc(arg4, arg5, arg2, arg3);
  dloc = xm_protect(descr);
  loc = map_over_protected_elements(unprotect_protocolproc, (unsigned long)descr);
  XmRemoveProtocolCallback(XEN_TO_C_Widget(arg1), 
			   XEN_TO_C_Atom(arg2), 
			   XEN_TO_C_Atom(arg3), 
			   gxm_ProtocolProc,
			   (XtPointer)(XEN_VECTOR_REF(xm_protected, loc))); /* this was the original tag passed in */
  /* now unprotect the proc and our descr */
  xm_unprotect_at(dloc);
  xm_unprotect_at(loc);
  return(XEN_FALSE);
}

static XEN gxm_XmAddProtocolCallback(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XmAddProtocolCallback "void XmAddProtocolCallback(Widget shell, Atom property, Atom protocol, XtCallbackProc callback, \
XtPointer closure) adds client callbacks for a protocol"
  XEN descr;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmAddProtocolCallback", "Widget");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg2), arg2, 2, "XmAddProtocolCallback", "Atom");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg3), arg3, 3, "XmAddProtocolCallback", "Atom");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg4) && (XEN_REQUIRED_ARGS_OK(arg4, 3)), arg4, 4, "XmAddProtocolCallback", "(XtCallbackProc widget data callb)");
  descr = C_TO_XEN_XM_ProtocolProc(arg4, arg5, arg2, arg3);
  xm_protect(descr);
  XmAddProtocolCallback(XEN_TO_C_Widget(arg1), 
			XEN_TO_C_Atom(arg2),
			XEN_TO_C_Atom(arg3),
			gxm_ProtocolProc,
			(XtPointer)descr);
  return(XEN_FALSE);
}

static XEN gxm_XmRemoveProtocols(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmRemoveProtocols "void XmRemoveProtocols(Widget shell, Atom property, Atom *protocols, Cardinal num_protocols) \
removes the protocols from the protocol manager and deallocates the internal tables"
  /* DIFF: XmRemoveProtocols takes list of Atoms
   */
  Atom *outs;
  int len;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmRemoveProtocols", "Widget");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg2), arg2, 2, "XmRemoveProtocols", "Atom");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg3), arg3, 3, "XmRemoveProtocols", "list of Atom");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg4), arg4, 4, "XmRemoveProtocols", "int");
  if (XEN_INTEGER_P(arg4)) len = XEN_TO_C_INT(arg4); else len = XEN_LIST_LENGTH(arg3);
  if (len <= 0) return(XEN_FALSE);
  outs = XEN_TO_C_Atoms(arg3, len);
  XmRemoveProtocols(XEN_TO_C_Widget(arg1), XEN_TO_C_Atom(arg2), outs, len);
  FREE(outs);
  return(XEN_FALSE);
}

static XEN gxm_XmAddProtocols(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmAddProtocols "void XmAddProtocols(Widget shell, Atom property, Atom *protocols, Cardinal num_protocols) \
adds the protocols to the protocol manager and allocates the internal tables"
  /* DIFF: XmAddProtocols takes list of Atoms
   */
  Atom *outs;
  int len;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmAddProtocols", "Widget");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg2), arg2, 2, "XmAddProtocols", "Atom");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg3), arg3, 3, "XmAddProtocols", "list of Atom");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg4), arg4, 4, "XmAddProtocols", "int");
  if (XEN_INTEGER_P(arg4)) len = XEN_TO_C_INT(arg4); else len = XEN_LIST_LENGTH(arg3);
  if (len <= 0) return(XEN_FALSE);
  outs = XEN_TO_C_Atoms(arg3, len);
  XmAddProtocols(XEN_TO_C_Widget(arg1), XEN_TO_C_Atom(arg2), outs, len);
  FREE(outs);
  return(XEN_FALSE);
}

static XEN gxm_XmCascadeButtonGadgetHighlight(XEN arg1, XEN arg2)
{
  #define H_XmCascadeButtonGadgetHighlight "void XmCascadeButtonGadgetHighlight(Widget cascadeButtonGadget, Boolean highlight) \
A CascadeButtonGadget function that sets the highlight state"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmCascadeButtonGadgetHighlight", "Widget");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg2), arg2, 2, "XmCascadeButtonGadgetHighlight", "boolean");
  XmCascadeButtonGadgetHighlight(XEN_TO_C_Widget(arg1), XEN_TO_C_BOOLEAN(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XmCreateCascadeButtonGadget(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateCascadeButtonGadget "Widget XmCreateCascadeButtonGadget(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The CascadeButtonGadget creation function"
  return(gxm_new_widget("XmCreateCascadeButtonGadget", XmCreateCascadeButtonGadget, arg1, arg2, arg3, arg4));
}

#if HAVE_XM_XP
static XEN gxm_XmRedisplayWidget(XEN arg1)
{
  #define H_XmRedisplayWidget "voidXmRedisplayWidget(Widgetwidget) Synchronously activates the expose method of a widget to draw its content"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmRedisplayWidget", "Widget");
  XmRedisplayWidget(XEN_TO_C_Widget(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XmPrintPopupPDM(XEN arg1, XEN arg2)
{
  #define H_XmPrintPopupPDM "XtEnum XmPrintPopupPDM(Widgetprint_shell, Widget video_transient_for) Send a notification for the PDM to be popped up"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmPrintPopupPDM", "Widget");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg2), arg2, 2, "XmPrintPopupPDM", "Widget");
  return(C_TO_XEN_INT(XmPrintPopupPDM(XEN_TO_C_Widget(arg1), XEN_TO_C_Widget(arg2))));
}

static void gxm_XPFinishProc(Display *display, XPContext context, XPGetDocStatus status, XPointer client_data);

static XEN gxm_XmPrintToFile(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmPrintToFile "XtEnumXmPrintToFile(Display*dpy, Stringfilename, XPFinishProcfinish_proc, XtPointerclient_data) \
retrieves and saves data that would normally be printed by the X Print Server"
  XEN descr;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmPrintToFile", "Display*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmPrintToFile", "char*");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg3) && (XEN_REQUIRED_ARGS_OK(arg3, 4)), arg3, 3, "XmPrintToFile", "XPFinishProc (4 args)");
  descr = XEN_LIST_3(XEN_FALSE, arg3, arg4);
  xm_protect(descr);
  return(C_TO_XEN_INT(XmPrintToFile(XEN_TO_C_Display(arg1), 
				    XEN_TO_C_STRING(arg2), 
				    (XPFinishProc)gxm_XPFinishProc,
				    (char *)descr)));
}

static XEN gxm_XmPrintSetup(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XmPrintSetup "Widget XmPrintSetup(Widget video_widget, Screen *print_screen, String print_shell_name, ArgList args, Cardinal num_args) \
setup and create a Print Shell widget"
  Widget w;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmPrintSetup", "Widget");
  XEN_ASSERT_TYPE(XEN_Screen_P(arg2), arg2, 2, "XmPrintSetup", "Screen*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3), arg3, 3, "XmPrintSetup", "String");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg4), arg4, 4, "XmPrintSetup", "ArgList");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg5), arg5, 5, "XmPrintSetup", "int");
  {
    Arg *args;
    int arglen;
    args = XEN_TO_C_Args(arg4);
    arglen = XEN_TO_C_INT_DEF(arg5, arg4);
    w = XmPrintSetup(XEN_TO_C_Widget(arg1), 
		     XEN_TO_C_Screen(arg2), 
		     XEN_TO_C_STRING(arg3), 
		     args, arglen);
    if (args)
      {
	fixup_args(w, args, arglen);
	free_args(args, arglen);
      }
  }
  return(C_TO_XEN_Widget(w));
}
#endif

static XEN gxm_XmCreateBulletinBoardDialog(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateBulletinBoardDialog "Widget XmCreateBulletinBoardDialog(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The BulletinBoard BulletinBoardDialog creation function"
  return(gxm_new_widget("XmCreateBulletinBoardDialog", XmCreateBulletinBoardDialog, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateBulletinBoard(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateBulletinBoard "Widget XmCreateBulletinBoard(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The BulletinBoard widget creation function"
  return(gxm_new_widget("XmCreateBulletinBoard", XmCreateBulletinBoard, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreatePanedWindow(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreatePanedWindow "Widget XmCreatePanedWindow(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The PanedWindow widget creation function"
  return(gxm_new_widget("XmCreatePanedWindow", XmCreatePanedWindow, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmGetAtomName(XEN arg1, XEN arg2)
{
  char *str;
  XEN res;
  #define H_XmGetAtomName "String XmGetAtomName(Display *display, Atom atom)  returns the string representation for an atom"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmGetAtomName", "Display*");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg2), arg2, 2, "XmGetAtomName", "Atom");
  str = XmGetAtomName(XEN_TO_C_Display(arg1), XEN_TO_C_Atom(arg2));
  res = C_TO_XEN_STRING(str);
  if (str) XtFree(str);
  return(res);
}

static XEN gxm_XmInternAtom(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XmInternAtom "A macro that returns an atom for a given name"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XmInternAtom", "Display*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XmInternAtom", "String");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg3), arg3, 3, "XmInternAtom", "Boolean");
  return(C_TO_XEN_Atom(XmInternAtom(XEN_TO_C_Display(arg1), XEN_TO_C_STRING(arg2), XEN_TO_C_BOOLEAN(arg3))));
}

static XEN gxm_XmNotebookGetPageInfo(XEN arg1, XEN arg2)
{
  #define H_XmNotebookGetPageInfo "XmNotebookPageStatus XmNotebookGetPageInfo(Widget notebook, int page_number) \
A Notebook function that returns page information"
  XmNotebookPageInfo *info;
  int err;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmNotebookGetPageInfo", "Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XmNotebookGetPageInfo", "int");
  info = (XmNotebookPageInfo *)CALLOC(1, sizeof(XmNotebookPageInfo));
  err = XmNotebookGetPageInfo(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2), info);
  return(XEN_LIST_2(C_TO_XEN_INT(err), C_TO_XEN_XmNotebookPageInfo(info)));
}

static XEN gxm_XmCreateNotebook(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateNotebook "void XmCreateNotebook(Widget parent, String name, ArgList arglist, Cardinal argcount) The Notebook widget creation function"
  return(gxm_new_widget("XmCreateNotebook", XmCreateNotebook, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateArrowButton(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateArrowButton "Widget XmCreateArrowButton(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The ArrowButton widget creation function"
  return(gxm_new_widget("XmCreateArrowButton", XmCreateArrowButton, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateArrowButtonGadget(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateArrowButtonGadget "Widget XmCreateArrowButtonGadget(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The ArrowButtonGadget creation function"
  return(gxm_new_widget("XmCreateArrowButtonGadget", XmCreateArrowButtonGadget, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmMessageBoxGetChild(XEN arg1, XEN arg2)
{
  #define H_XmMessageBoxGetChild "Widget XmMessageBoxGetChild(Widget widget, unsigned char child) A MessageBox function that is used to access a component"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XmMessageBoxGetChild", "Widget");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XmMessageBoxGetChild", "unsigned int");
  return(C_TO_XEN_Widget(XmMessageBoxGetChild(XEN_TO_C_Widget(arg1), XEN_TO_C_ULONG(arg2))));
}

static XEN gxm_XmCreateTemplateDialog(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateTemplateDialog "Widget XmCreateTemplateDialog(Widget parent, String name, ArgList arglist, Cardinal argcount) \
A MessageBox TemplateDialog creation function"
  return(gxm_new_widget("XmCreateTemplateDialog", XmCreateTemplateDialog, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateWorkingDialog(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateWorkingDialog "Widget XmCreateWorkingDialog(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The MessageBox WorkingDialog creation function"
  return(gxm_new_widget("XmCreateWorkingDialog", XmCreateWorkingDialog, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateWarningDialog(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateWarningDialog "Widget XmCreateWarningDialog(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The MessageBox WarningDialog creation function"
  return(gxm_new_widget("XmCreateWarningDialog", XmCreateWarningDialog, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateQuestionDialog(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateQuestionDialog "Widget XmCreateQuestionDialog(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The MessageBox QuestionDialog creation function"
  return(gxm_new_widget("XmCreateQuestionDialog", XmCreateQuestionDialog, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateInformationDialog(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateInformationDialog "Widget XmCreateInformationDialog(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The MessageBox InformationDialog creation function"
  return(gxm_new_widget("XmCreateInformationDialog", XmCreateInformationDialog, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateErrorDialog(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateErrorDialog "Widget XmCreateErrorDialog(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The MessageBox ErrorDialog creation function"
  return(gxm_new_widget("XmCreateErrorDialog", XmCreateErrorDialog, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateMessageDialog(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateMessageDialog "Widget XmCreateMessageDialog(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The MessageBox MessageDialog creation function"
  return(gxm_new_widget("XmCreateMessageDialog", XmCreateMessageDialog, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmCreateMessageBox(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XmCreateMessageBox "Widget XmCreateMessageBox(Widget parent, String name, ArgList arglist, Cardinal argcount) \
The MessageBox widget creation function"
  return(gxm_new_widget("XmCreateMessageBox", XmCreateMessageBox, arg1, arg2, arg3, arg4));
}

static XEN gxm_XmIsMessageBox(XEN arg)
{
  #define H_XmIsMessageBox "XmIsMessageBox(arg) -> #t if arg is a MessageBox widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsMessageBox", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsMessageBox(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsArrowButtonGadget(XEN arg)
{
  #define H_XmIsArrowButtonGadget "XmIsArrowButtonGadget(arg) -> #t if arg is an ArrowButton gadget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsArrowButtonGadget", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsArrowButtonGadget(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsArrowButton(XEN arg)
{
  #define H_XmIsArrowButton "XmIsArrowButton(arg) -> #t if arg is an ArrowButton widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsArrowButton", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsArrowButton(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsNotebook(XEN arg)
{
  #define H_XmIsNotebook "XmIsNotebook(arg) -> #t if arg is a Notebook widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsNotebook", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsNotebook(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsPanedWindow(XEN arg)
{
  #define H_XmIsPanedWindow "XmIsPanedWindow(arg) -> #t if arg is a PanedWindow widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsPanedWindow", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsPanedWindow(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsBulletinBoard(XEN arg)
{
  #define H_XmIsBulletinBoard "XmIsBulletinBoard(arg) -> #t if arg is a BulletinBoard widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsBulletinBoard", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsBulletinBoard(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsPrimitive(XEN arg)
{
  #define H_XmIsPrimitive "XmIsPrimitive(arg) -> #t if arg is a Primitive widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsPrimitive", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsPrimitive(XEN_TO_C_Widget(arg))));
}

#if HAVE_XM_XP
static XEN gxm_XmIsPrintShell(XEN arg)
{
  #define H_XmIsPrintShell "Boolean XmIsPrintShell "XmIsPrintShell "Boolean XmIsPrintShell(Widget)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsPrintShell", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsPrintShell(XEN_TO_C_Widget(arg))));
}
#endif

static XEN gxm_XmIsCascadeButtonGadget(XEN arg)
{
  #define H_XmIsCascadeButtonGadget "XmIsCascadeButtonGadget(arg) -> #t if arg is a CascadeButtonGadget gadget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsCascadeButtonGadget", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsCascadeButtonGadget(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsCascadeButton(XEN arg)
{
  #define H_XmIsCascadeButton "XmIsCascadeButton(arg) -> #t if arg is a CascadeButton widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsCascadeButton", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsCascadeButton(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsPushButtonGadget(XEN arg)
{
  #define H_XmIsPushButtonGadget "XmIsPushButtonGadget(arg) -> #t if arg is a PushButtonGadget gadget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsPushButtonGadget", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsPushButtonGadget(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsPushButton(XEN arg)
{
  #define H_XmIsPushButton "XmIsPushButton(arg) -> #t if arg is a PushButton widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsPushButton", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsPushButton(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsComboBox(XEN arg)
{
  #define H_XmIsComboBox "XmIsComboBox(arg) -> #t if arg is a ComboBox widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsComboBox", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsComboBox(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsCommand(XEN arg)
{
  #define H_XmIsCommand "XmIsCommand(arg) -> #t if arg is a Command widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsCommand", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsCommand(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsRowColumn(XEN arg)
{
  #define H_XmIsRowColumn "XmIsRowColumn(arg) -> #t if arg is a RowColumn widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsRowColumn", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsRowColumn(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsContainer(XEN arg)
{
  #define H_XmIsContainer "XmIsContainer(arg) -> #t if arg is a Container widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsContainer", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsContainer(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsScreen(XEN arg)
{
  #define H_XmIsScreen "XmIsScreen(arg) -> #t if arg is a Screen widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsScreen", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsScreen(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsScale(XEN arg)
{
  #define H_XmIsScale "XmIsScale(arg) -> #t if arg is a Scale widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsScale", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsScale(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsScrollBar(XEN arg)
{
  #define H_XmIsScrollBar "XmIsScrollBar(arg) -> #t if arg is a ScrollBar widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsScrollBar", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsScrollBar(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsDialogShell(XEN arg)
{
  #define H_XmIsDialogShell "XmIsDialogShell(arg) -> #t if arg is a DialogShell widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsDialogShell", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsDialogShell(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsScrolledWindow(XEN arg)
{
  #define H_XmIsScrolledWindow "XmIsScrolledWindow(arg) -> #t if arg is a ScrolledWindow widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsScrolledWindow", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsScrolledWindow(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsDisplay(XEN arg)
{
  #define H_XmIsDisplay "XmIsDisplay(arg) -> #t if arg is a Display widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsDisplay", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsDisplay(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsSelectionBox(XEN arg)
{
  #define H_XmIsSelectionBox "XmIsSelectionBox(arg) -> #t if arg is a SelectionBox widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsSelectionBox", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsSelectionBox(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsDragContext(XEN arg)
{
  #define H_XmIsDragContext "XmIsDragContext(arg) -> #t if arg is a DragContext widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsDragContext", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsDragContext(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsSeparatorGadget(XEN arg)
{
  #define H_XmIsSeparatorGadget "XmIsSeparatorGadget(arg) -> #t if arg is a SeparatorGadget gadget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsSeparatorGadget", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsSeparatorGadget(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsDragIconObjectClass(XEN arg)
{
  #define H_XmIsDragIconObjectClass "XmIsDragIconObjectClass(arg) -> #t if arg is a DragIconObjectClass widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsDragIconObjectClass", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsDragIconObjectClass(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsSeparator(XEN arg)
{
  #define H_XmIsSeparator "XmIsSeparator(arg) -> #t if arg is a Separator widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsSeparator", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsSeparator(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsDrawingArea(XEN arg)
{
  #define H_XmIsDrawingArea "XmIsDrawingArea(arg) -> #t if arg is a DrawingArea widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsDrawingArea", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsDrawingArea(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsDrawnButton(XEN arg)
{
  #define H_XmIsDrawnButton "XmIsDrawnButton(arg) -> #t if arg is a DrawnButton widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsDrawnButton", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsDrawnButton(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsDropSiteManager(XEN arg)
{
  #define H_XmIsDropSiteManager "XmIsDropSiteManager(arg) -> #t if arg is a DropSiteManager widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsDropSiteManager", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsDropSiteManager(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsDropTransfer(XEN arg)
{
  #define H_XmIsDropTransfer "XmIsDropTransfer(arg) -> #t if arg is a DropTransfer widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsDropTransfer", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsDropTransfer(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsTextField(XEN arg)
{
  #define H_XmIsTextField "XmIsTextField(arg) -> #t if arg is a TextField widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsTextField", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsTextField(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsFileSelectionBox(XEN arg)
{
  #define H_XmIsFileSelectionBox "XmIsFileSelectionBox(arg) -> #t if arg is a FileSelectionBox widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsFileSelectionBox", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsFileSelectionBox(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsText(XEN arg)
{
  #define H_XmIsText "XmIsText(arg) -> #t if arg is a Text widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsText", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsText(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsForm(XEN arg)
{
  #define H_XmIsForm "XmIsForm(arg) -> #t if arg is a Form widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsForm", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsForm(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsFrame(XEN arg)
{
  #define H_XmIsFrame "XmIsFrame(arg) -> #t if arg is a Frame widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsFrame", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsFrame(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsGadget(XEN arg)
{
  #define H_XmIsGadget "XmIsGadget(arg) -> #t if arg is a Gadget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsGadget", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsGadget(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsToggleButtonGadget(XEN arg)
{
  #define H_XmIsToggleButtonGadget "XmIsToggleButtonGadget(arg) -> #t if arg is a ToggleButtonGadget gadget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsToggleButtonGadget", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsToggleButtonGadget(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsGrabShell(XEN arg)
{
  #define H_XmIsGrabShell "XmIsGrabShell(arg) -> #t if arg is a GrabShell widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsGrabShell", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsGrabShell(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsToggleButton(XEN arg)
{
  #define H_XmIsToggleButton "XmIsToggleButton(arg) -> #t if arg is a ToggleButton widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsToggleButton", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsToggleButton(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsIconGadget(XEN arg)
{
  #define H_XmIsIconGadget "XmIsIconGadget(arg) -> #t if arg is a IconGadget widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsIconGadget", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsIconGadget(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsIconHeader(XEN arg)
{
  #define H_XmIsIconHeader "XmIsIconHeader(arg) -> #t if arg is a IconHeader widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsIconHeader", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsIconHeader(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsLabelGadget(XEN arg)
{
  #define H_XmIsLabelGadget "XmIsLabelGadget(arg) -> #t if arg is a LabelGadget widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsLabelGadget", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsLabelGadget(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsLabel(XEN arg)
{
  #define H_XmIsLabel "XmIsLabel(arg) -> #t if arg is a Label widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsLabel", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsLabel(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsVendorShell(XEN arg)
{
  #define H_XmIsVendorShell "XmIsVendorShell(arg) -> #t if arg is a VendorShell widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsVendorShell", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsVendorShell(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsList(XEN arg)
{
  #define H_XmIsList "XmIsList(arg) -> #t if arg is a List widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsList", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsList(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsMainWindow(XEN arg)
{
  #define H_XmIsMainWindow "XmIsMainWindow(arg) -> #t if arg is a MainWindow widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsMainWindow", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsMainWindow(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsManager(XEN arg)
{
  #define H_XmIsManager "XmIsManager(arg) -> #t if arg is a Manager widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsManager", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsManager(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XmIsMenuShell(XEN arg)
{
  #define H_XmIsMenuShell "XmIsMenuShell(arg) -> #t if arg is a MenuShell widget"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XmIsMenuShell", "Widget");
  return(C_TO_XEN_BOOLEAN(XmIsMenuShell(XEN_TO_C_Widget(arg))));
}


#endif
/* end HAVE_MOTIF */

/* ----------------------------------------------------------------------------------------------------
 *
 *                            *         *
 *                             *       *
 *                              *     *
 *                               *   *
 *                                * *
 *                                 *
 *                                * *
 *                               *   *
 *                              *     *
 *                             *       *
 *                            *         *
 * ----------------------------------------------------------------------------------------------------
 */

static XEN gxm_XXorRegion(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XXorRegion "XXorRegion(sra, srb, dr_return) calculates the difference between the union and intersection of two regions."
  XEN_ASSERT_TYPE(XEN_Region_P(arg1), arg1, 1, "XXorRegion", "Region");
  XEN_ASSERT_TYPE(XEN_Region_P(arg2), arg2, 2, "XXorRegion", "Region");
  XEN_ASSERT_TYPE(XEN_Region_P(arg3), arg3, 3, "XXorRegion", "Region");
  return(C_TO_XEN_INT(XXorRegion(XEN_TO_C_Region(arg1), XEN_TO_C_Region(arg2), XEN_TO_C_Region(arg3))));
}

static XEN gxm_XUnionRegion(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XUnionRegion "XUnionRegion(sra, srb, dr_return) computes the union of two regions."
  XEN_ASSERT_TYPE(XEN_Region_P(arg1), arg1, 1, "XUnionRegion", "Region");
  XEN_ASSERT_TYPE(XEN_Region_P(arg2), arg2, 2, "XUnionRegion", "Region");
  XEN_ASSERT_TYPE(XEN_Region_P(arg3), arg3, 3, "XUnionRegion", "Region");
  return(C_TO_XEN_INT(XUnionRegion(XEN_TO_C_Region(arg1), XEN_TO_C_Region(arg2), XEN_TO_C_Region(arg3))));
}

static XEN gxm_XUnionRectWithRegion(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XUnionRectWithRegion "XUnionRectWithRegion(rectangle, src_region, dest_region_return) updates the destination region from a \
union of the specified rectangle and the specified source region."
  XEN_ASSERT_TYPE(XEN_XRectangle_P(arg1), arg1, 1, "XUnionRectWithRegion", "XRectangle*");
  XEN_ASSERT_TYPE(XEN_Region_P(arg2), arg2, 2, "XUnionRectWithRegion", "Region");
  XEN_ASSERT_TYPE(XEN_Region_P(arg3), arg3, 3, "XUnionRectWithRegion", "Region");
  return(C_TO_XEN_INT(XUnionRectWithRegion(XEN_TO_C_XRectangle(arg1), XEN_TO_C_Region(arg2), XEN_TO_C_Region(arg3))));
}

static XEN gxm_XSubtractRegion(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSubtractRegion "XSubtractRegion(sra, srb, dr_return) subtracts srb from sra and stores the results in dr_return."
  XEN_ASSERT_TYPE(XEN_Region_P(arg1), arg1, 1, "XSubtractRegion", "Region");
  XEN_ASSERT_TYPE(XEN_Region_P(arg2), arg2, 2, "XSubtractRegion", "Region");
  XEN_ASSERT_TYPE(XEN_Region_P(arg3), arg3, 3, "XSubtractRegion", "Region");
  return(C_TO_XEN_INT(XSubtractRegion(XEN_TO_C_Region(arg1), XEN_TO_C_Region(arg2), XEN_TO_C_Region(arg3))));
}

static XEN gxm_XShrinkRegion(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XShrinkRegion "XShrinkRegion(r, dx, dy) reduces the specified region by a specified amount."
  XEN_ASSERT_TYPE(XEN_Region_P(arg1), arg1, 1, "XShrinkRegion", "Region");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XShrinkRegion", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XShrinkRegion", "int");
  return(C_TO_XEN_INT(XShrinkRegion(XEN_TO_C_Region(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_INT(arg3))));
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XSetStandardColormap(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XSetStandardColormap "XSetStandardColormap(dpy, window, colormap, atom) sets the standard colormap property"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetStandardColormap", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XSetStandardColormap", "Window");
  XEN_ASSERT_TYPE(XEN_XStandardColormap_P(arg3), arg3, 3, "XSetStandardColormap", "XStandardColormap*");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg4), arg4, 4, "XSetStandardColormap", "Atom");
  XSetStandardColormap(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_XStandardColormap(arg3), XEN_TO_C_Atom(arg4));
  return(XEN_FALSE);
}
static XEN gxm_XSetStandardProperties(XEN dpy, XEN win, XEN win_name, XEN icon_name, XEN icon_pixmap, XEN argv, XEN argc, XEN hints)
{
  #define H_XSetStandardProperties "XSetStandardProperties(dpy, win, win_name, icon_name, icon_pixmap, argv, argc, hints) sets the standard properties"
  int c_argc = 0;
  char **c_argv = NULL;
  XEN_ASSERT_TYPE(XEN_Display_P(dpy), dpy, XEN_ARG_1, "XSetStandardProperties", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(win), win, XEN_ARG_2, "XSetStandardProperties", "Window");
  XEN_ASSERT_TYPE(XEN_STRING_P(win_name) || XEN_NULL_P(win_name) || XEN_FALSE_P(win_name), win_name, XEN_ARG_3, "XSetStandardProperties", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(icon_name) || XEN_NULL_P(icon_name) || XEN_FALSE_P(icon_name), icon_name, XEN_ARG_4, "XSetStandardProperties", "char*");
  XEN_ASSERT_TYPE(XEN_Pixmap_P(icon_pixmap) || XEN_INTEGER_P(icon_pixmap), icon_pixmap, XEN_ARG_5, "XSetStandardProperties", "Pixmap or None");
  XEN_ASSERT_TYPE(XEN_LIST_P(argv), argv, XEN_ARG_6, "XSetStandardProperties", "list of char*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(argc), argc, XEN_ARG_7, "XSetStandardProperties", "int");
  XEN_ASSERT_TYPE(XEN_FALSE_P(hints) || XEN_NULL_P(hints) || XEN_XSizeHints_P(hints), hints, XEN_ARG_8, "XSetStandardProperties", "XSizeHints* or false");
  c_argc = XEN_TO_C_INT(argc);
  if (c_argc > 0) c_argv = XEN_TO_C_Strings(argv, c_argc);
  XSetStandardProperties(XEN_TO_C_Display(dpy),
			 XEN_TO_C_Window(win),
			 (XEN_STRING_P(win_name)) ? XEN_TO_C_STRING(win_name): NULL,
			 (XEN_STRING_P(icon_name)) ? XEN_TO_C_STRING(icon_name) : NULL,
			 (XEN_Pixmap_P(icon_pixmap)) ? XEN_TO_C_Pixmap(icon_pixmap) : None,
			 c_argv,
			 c_argc,
			 (XEN_XSizeHints_P(hints)) ? XEN_TO_C_XSizeHints(hints) : NULL);
  if (c_argv) FREE(c_argv);
  return(xen_return_first(XEN_FALSE, argv));
}
#endif
static XEN gxm_XSetWMProperties(XEN dpy, XEN win, XEN win_name, XEN icon_name, XEN argv, XEN argc, XEN normal_hints, XEN wm_hints)
{
  /* last arg omitted -- XClassHint not supported */
  #define H_XSetWMProperties "XSetWMProperties(dpy, win, win_name, icon_name, argv, argc, normal_hints wm_hints) sets the window properties"
  int c_argc = 0;
  char **c_argv = NULL;
  XTextProperty w_name, i_name;
  bool use_w_name = false, use_i_name = false;
  XEN_ASSERT_TYPE(XEN_Display_P(dpy), dpy, XEN_ARG_1, "XSetWMProperties", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(win), win, XEN_ARG_2, "XSetWMProperties", "Window");
  XEN_ASSERT_TYPE(XEN_STRING_P(win_name) || XEN_NULL_P(win_name) || XEN_FALSE_P(win_name), win_name, XEN_ARG_3, "XSetWMProperties", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(icon_name) || XEN_NULL_P(icon_name) || XEN_FALSE_P(icon_name), icon_name, XEN_ARG_4, "XSetWMProperties", "char*");
  XEN_ASSERT_TYPE(XEN_LIST_P(argv), argv, XEN_ARG_5, "XSetWMProperties", "list of char*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(argc), argc, XEN_ARG_6, "XSetWMProperties", "int");
  XEN_ASSERT_TYPE(XEN_FALSE_P(normal_hints) || XEN_XSizeHints_P(normal_hints), normal_hints, XEN_ARG_7, "XSetWMProperties", "XSizeHints* or false");
  XEN_ASSERT_TYPE(XEN_FALSE_P(wm_hints) || XEN_XWMHints_P(wm_hints), wm_hints, XEN_ARG_8, "XSetWMProperties", "XWMHints* or false");
  c_argc = XEN_TO_C_INT(argc);
  if (c_argc > 0) c_argv = XEN_TO_C_Strings(argv, c_argc);
  if (XEN_STRING_P(win_name))
    {
      char *name;
      use_w_name = true;
      name = XEN_TO_C_STRING(win_name);
      XStringListToTextProperty(&name, 1, &w_name);
    }
  if (XEN_STRING_P(icon_name))
    {
      char *name;
      use_i_name = true; 
      name = XEN_TO_C_STRING(icon_name);
      XStringListToTextProperty(&name, 1, &i_name);
   }
  XSetWMProperties(XEN_TO_C_Display(dpy),
		   XEN_TO_C_Window(win),
		   (use_w_name) ? &w_name : NULL,
		   (use_i_name) ? &i_name : NULL,
		   c_argv,
		   c_argc,
		   XEN_TO_C_XSizeHints(normal_hints),
		   XEN_TO_C_XWMHints(wm_hints),
		   NULL);
  if (c_argv) FREE(c_argv);
  return(xen_return_first(XEN_FALSE, win_name, icon_name, argv));
}

static XEN gxm_XSetRegion(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSetRegion "XSetRegion(display, gc, r) sets the clip-mask in the GC to the specified region."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetRegion", "Display*");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XSetRegion", "GC");
  XEN_ASSERT_TYPE(XEN_Region_P(arg3), arg3, 3, "XSetRegion", "Region");
  return(C_TO_XEN_INT(XSetRegion(XEN_TO_C_Display(arg1), XEN_TO_C_GC(arg2), XEN_TO_C_Region(arg3))));
}

static XEN gxm_XSetWMHints(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSetWMHints "XSetWMHints(display, w, wmhints) sets the window manager hints that include icon information and location, the \
initial state of the window, and whether the application relies on the window manager to get keyboard input."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetWMHints", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XSetWMHints", "Window");
  XEN_ASSERT_TYPE(XEN_XWMHints_P(arg3), arg3, 3, "XSetWMHints", "XWMHints*");
  return(C_TO_XEN_INT(XSetWMHints(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_XWMHints(arg3))));
}

static XEN gxm_XSetRGBColormaps(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XSetRGBColormaps "void XSetRGBColormaps(display, w, std_colormap, count, property) replaces the RGB colormap definition in the \
specified property on the named window."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetRGBColormaps", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XSetRGBColormaps", "Window");
  XEN_ASSERT_TYPE(XEN_XStandardColormap_P(arg3), arg3, 3, "XSetRGBColormaps", "XStandardColormap*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XSetRGBColormaps", "int");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg5), arg5, 5, "XSetRGBColormaps", "Atom");
  XSetRGBColormaps(XEN_TO_C_Display(arg1), 
		   XEN_TO_C_Window(arg2), 
		   XEN_TO_C_XStandardColormap(arg3), 
		   XEN_TO_C_INT(arg4), 
		   XEN_TO_C_Atom(arg5));
  return(XEN_FALSE);
}

static XEN gxm_XUniqueContext(void)
{
  #define H_XUniqueContext "XContext XUniqueContext() creates a unique context type that may be used in subsequent calls to XSaveContext."
  return(C_TO_XEN_XContext(XUniqueContext()));
}

static XEN gxm_XSaveContext(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XSaveContext "XSaveContext(dpy, rid, context) saves a context"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSaveContext", "Display*");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XSaveContext", "XID");
  XEN_ASSERT_TYPE(XEN_XContext_P(arg3), arg3, 3, "XSaveContext", "XContext");
  return(C_TO_XEN_INT(XSaveContext(XEN_TO_C_Display(arg1), XEN_TO_C_ULONG(arg2), XEN_TO_C_XContext(arg3), (caddr_t)arg4)));
}

static XEN gxm_XRectInRegion(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XRectInRegion "int XRectInRegion(r, x, y, width, height) returns RectangleIn if the rectangle is entirely in the specified region, \
RectangleOut if the rectangle is entirely out of the specified region, and RectanglePart if the rectangle is partially in the specified region. "
  XEN_ASSERT_TYPE(XEN_Region_P(arg1), arg1, 1, "XRectInRegion", "Region");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XRectInRegion", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XRectInRegion", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg4), arg4, 4, "XRectInRegion", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg5), arg5, 5, "XRectInRegion", "unsigned int");
  return(C_TO_XEN_INT(XRectInRegion(XEN_TO_C_Region(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_INT(arg3), XEN_TO_C_ULONG(arg4), XEN_TO_C_ULONG(arg5))));
}

static XEN gxm_XPolygonRegion(XEN larg1, XEN arg2, XEN arg3)
{
  #define H_XPolygonRegion "Region XPolygonRegion(points, n, fill_rule) returns a region for the polygon defined by the points list."
  /* DIFF: XPolygonRegion XPoint* arg (arg 1) is list of XPoints
   */
  XPoint *pt, *pt1;
  int i, len;
  Region res;
  XEN arg1;
  XEN_ASSERT_TYPE(XEN_LIST_P(larg1), larg1, 1, "XPolygonRegion", "list of XPoints");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XPolygonRegion", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XPolygonRegion", "int");
  arg1 = XEN_COPY_ARG(larg1);
  len = XEN_TO_C_INT(arg2);
  if (len <= 0) XEN_ASSERT_TYPE(0, arg2, 2, "XPolygonRegion", "positive integer");
  pt = (XPoint *)CALLOC(len, sizeof(XPoint));
  for (i = 0; (i < len) && (XEN_NOT_NULL_P(arg1)); i++, arg1 = XEN_CDR(arg1))
    {
      XEN xp;
      xp = XEN_CAR(arg1);
      if (!(XEN_XPoint_P(xp))) {FREE(pt); XEN_ASSERT_TYPE(0, xp, i, "XPolygonRegion", "XPoint"); return(XEN_FALSE);}
      pt1 = XEN_TO_C_XPoint(XEN_CAR(arg1));
      pt[i].x = pt1->x;
      pt[i].y = pt1->y;
    }
  res = XPolygonRegion(pt, len, XEN_TO_C_INT(arg3));
  FREE(pt);
  return(C_TO_XEN_Region(res));
}

static XEN gxm_XPointInRegion(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XPointInRegion "Bool XPointInRegion(r, x, y) returns #t if the point (x, y) is contained in the region r."
  XEN_ASSERT_TYPE(XEN_Region_P(arg1), arg1, 1, "XPointInRegion", "Region");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XPointInRegion", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XPointInRegion", "int");
  return(C_TO_XEN_BOOLEAN(XPointInRegion(XEN_TO_C_Region(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_INT(arg3))));
}

static XEN gxm_XOffsetRegion(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XOffsetRegion "XOffsetRegion(r, dx, dy) moves the specified region by a specified amount."
  XEN_ASSERT_TYPE(XEN_Region_P(arg1), arg1, 1, "XOffsetRegion", "Region");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XOffsetRegion", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XOffsetRegion", "int");
  return(C_TO_XEN_INT(XOffsetRegion(XEN_TO_C_Region(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_INT(arg3))));
}

static XVisualInfo *match_visual_info;
static XEN gxm_XMatchVisualInfo(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XMatchVisualInfo "Status XMatchVisualInfo(display, screen, depth, class) returns the visual information for a \
visual that matches the specified depth and class for a screen."
  /* DIFF: XMatchVisualInfo dpy scr dep class [visual] -> #f or visual
   */
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XMatchVisualInfo", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XMatchVisualInfo", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XMatchVisualInfo", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XMatchVisualInfo", "int");
  match_visual_info = (XVisualInfo *)CALLOC(1, sizeof(XVisualInfo));
  val = XMatchVisualInfo(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_INT(arg3), XEN_TO_C_INT(arg4), match_visual_info);
  if (val)
    return(C_TO_XEN_XVisualInfo(match_visual_info));
  return(XEN_FALSE);
}

static XEN gxm_XLookupString(XEN arg1)
{
  #define H_XLookupString "int XLookupString(event_struct) translates a key event to a KeySym and a string -> (len str keysym)."
  /* DIFF: XLookupString last arg is ignored, keyevent and all but last omitted -> (list len str keysym)
   */
  KeySym key;
  char *str;
  int len;
  XEN res;
  XEN_ASSERT_TYPE(XEN_XKeyEvent_P(arg1), arg1, 1, "XLookupString", "XKeyEvent*");/* user-created */
  str = (char *)CALLOC(16, sizeof(char));
  len = XLookupString(XEN_TO_C_XKeyEvent(arg1), str, 16, &key, NULL);
  res = XEN_LIST_3(C_TO_XEN_INT(len),
		   C_TO_XEN_STRING(str),
		   C_TO_XEN_KeySym(key));
  FREE(str);
  return(res);
}

static XEN gxm_XConvertCase(XEN arg1)
{
  #define H_XConvertCase "void XConvertCase(keysym) returns the uppercase and lowercase forms of the specified \
Keysym, if the KeySym is subject to case conversion; otherwise, the specified KeySym is returned to both lower_return and upper_return."
  /* DIFF: XConvertCase keysym [k1 k2] -> (list k1 k2)
   */
  KeySym k1, k2;
  XEN_ASSERT_TYPE(XEN_KeySym_P(arg1), arg1, 1, "XConvertCase", "KeySym");
  XConvertCase(XEN_TO_C_KeySym(arg1), &k1, &k2);
  return(XEN_LIST_2(C_TO_XEN_KeySym(k1),
		    C_TO_XEN_KeySym(k2)));
}

static XEN gxm_XIntersectRegion(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XIntersectRegion "XIntersectRegion(sra, srb, dr_return) computes the intersection of two regions."
  XEN_ASSERT_TYPE(XEN_Region_P(arg1), arg1, 1, "XIntersectRegion", "Region");
  XEN_ASSERT_TYPE(XEN_Region_P(arg2), arg2, 2, "XIntersectRegion", "Region");
  XEN_ASSERT_TYPE(XEN_Region_P(arg3), arg3, 3, "XIntersectRegion", "Region");
  return(C_TO_XEN_INT(XIntersectRegion(XEN_TO_C_Region(arg1), XEN_TO_C_Region(arg2), XEN_TO_C_Region(arg3))));
}

static XEN gxm_XGetWMHints(XEN arg1, XEN arg2)
{
  #define H_XGetWMHints "XWMHints *XGetWMHints(display, w) reads the window manager hints and returns NULL if no WM_HINTS property was \
set on the window or returns a pointer to a XWMHints structure if it succeeds."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetWMHints", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XGetWMHints", "Window");
  return(C_TO_XEN_XWMHints(XGetWMHints(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2))));
}

static XEN gxm_XGetVisualInfo(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XGetVisualInfo "XVisualInfo *XGetVisualInfo(display, vinfo_mask, vinfo_template) returns a list of visual \
structures that have attributes equal to the attributes specified by vinfo_template."
  /* DIFF: XGetVisualInfo dpy mask template [nitems] -> '() or (list visual...)
   */
  XVisualInfo *v;
  int len;
  XEN lst = XEN_EMPTY_LIST;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetVisualInfo", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XGetVisualInfo", "long");
  XEN_ASSERT_TYPE(XEN_XVisualInfo_P(arg3), arg3, 3, "XGetVisualInfo", "XVisualInfo*");
  v = XGetVisualInfo(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_XVisualInfo(arg3), &len);
  if (v)
    {
      int i, loc;
      loc = xm_protect(lst);
      for (i = len - 1; i >= 0; i--)
	lst = XEN_CONS(C_TO_XEN_XVisualInfo(v + i), lst);
      xm_unprotect_at(loc);
      /* XFree(v); */ /* valgrind says this is a bad idea */
    }
  return(lst);
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XGetStandardColormap(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XGetStandardColormap "XGetStandardColormap(dpy, window, atom) gets the standard colormap property"
  /* DIFF: XGetStandardColormap omits colormap arg and returns it or #f
   */
  XStandardColormap *c;
  Status val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetStandardColormap", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XGetStandardColormap", "Window");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg3), arg3, 3, "XGetStandardColormap", "Atom");
  c = (XStandardColormap *)CALLOC(1, sizeof(XStandardColormap));
  val = XGetStandardColormap(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), c, XEN_TO_C_Atom(arg3));
  if (val != 0)
    return(C_TO_XEN_XStandardColormap(c));
  FREE(c);
  return(XEN_FALSE);
}
#endif

static XEN gxm_XGetRGBColormaps(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XGetRGBColormaps "Status XGetRGBColormaps(display, w, property) returns the RGB colormap \
definitions stored in the specified property on the named window."
  /* DIFF: XGetRGBColormaps omits arg 3 and 4, returns list of XStandardColormaps 
   */
  int len, i, loc;
  Status val;
  XEN lst = XEN_EMPTY_LIST;
  XStandardColormap **cs = NULL; /* do I allocate this?? */
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetRGBColormaps", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XGetRGBColormaps", "Window");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg3), arg3, 3, "XGetRGBColormaps", "Atom");
  val = XGetRGBColormaps(XEN_TO_C_Display(arg1), 
			 XEN_TO_C_Window(arg2), 
			 cs, &len,
			 XEN_TO_C_Atom(arg3));
  if (val == 0)
    return(XEN_FALSE);
  loc = xm_protect(lst);
  for (i = len - 1; i >= 0; i--)
    lst = XEN_CONS(C_TO_XEN_XStandardColormap(cs[i]), lst);
  xm_unprotect_at(loc);
  return(lst);
}

static XEN gxm_XGetIconSizes(XEN arg1, XEN arg2)
{
  #define H_XGetIconSizes "Status XGetIconSizes(display, w) returns #f if the window manager has not \
set icon sizes; otherwise, it return nonzero and a list of XIconSize structs."
  /* DIFF: XGetIconSizes omit last 2 args, return list of XIconSizes
   */
  XIconSize *sizes;
  int i, len, val, loc;
  XEN lst = XEN_EMPTY_LIST;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetIconSizes", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XGetIconSizes", "Window");
  val = XGetIconSizes(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), &sizes, &len);
  if (val == 0)
    return(XEN_FALSE);
  loc = xm_protect(lst);
  for (i = len - 1; i >= 0; i--)
    lst = XEN_CONS(C_TO_XEN_XIconSize(&(sizes[i])), lst);
  XFree(sizes);
  xm_unprotect_at(loc);
  return(XEN_LIST_2(C_TO_XEN_INT(val),
		    lst));
}

static XEN gxm_XFindContext(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XFindContext "XFindContext(dpy, rid, context) gets data from the context manager"
  /* DIFF: XFindContext last arg omitted, val returned
   */
  caddr_t x;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XFindContext", "Display*");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XFindContext", "XID");
  XEN_ASSERT_TYPE(XEN_XContext_P(arg3), arg3, 3, "XFindContext", "XContext");
  val = XFindContext(XEN_TO_C_Display(arg1), XEN_TO_C_ULONG(arg2), XEN_TO_C_XContext(arg3), &x);
  return(XEN_LIST_2(C_TO_XEN_INT(val),
		    (XEN)x));
}

static XEN gxm_XEqualRegion(XEN arg1, XEN arg2)
{
  #define H_XEqualRegion "Bool XEqualRegion(r1, r2) returns #t if the two regions have the same offset, size, and shape."
  XEN_ASSERT_TYPE(XEN_Region_P(arg1), arg1, 1, "XEqualRegion", "Region");
  XEN_ASSERT_TYPE(XEN_Region_P(arg2), arg2, 2, "XEqualRegion", "Region");
  return(C_TO_XEN_BOOLEAN(XEqualRegion(XEN_TO_C_Region(arg1), XEN_TO_C_Region(arg2))));
}

static XEN gxm_XEmptyRegion(XEN arg1)
{
  #define H_XEmptyRegion "Bool XEmptyRegion(r) returns #t if the region is empty."
  XEN_ASSERT_TYPE(XEN_Region_P(arg1), arg1, 1, "XEmptyRegion", "Region");
  return(C_TO_XEN_BOOLEAN(XEmptyRegion(XEN_TO_C_Region(arg1))));
}

static XEN gxm_XDestroyRegion(XEN arg1)
{
  #define H_XDestroyRegion "XDestroyRegion(r) deallocates the storage associated with a specified region."
  XEN_ASSERT_TYPE(XEN_Region_P(arg1), arg1, 1, "XDestroyRegion", "Region");
  return(C_TO_XEN_INT(XDestroyRegion(XEN_TO_C_Region(arg1))));
}

static XEN gxm_XDeleteContext(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XDeleteContext "int XDeleteContext(display, rid, context) deletes the entry for the given resource ID and type from the data structure."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDeleteContext", "Display*");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XDeleteContext", "XID");
  XEN_ASSERT_TYPE(XEN_XContext_P(arg3), arg3, 3, "XDeleteContext", "XContext");
  return(C_TO_XEN_INT(XDeleteContext(XEN_TO_C_Display(arg1), XEN_TO_C_ULONG(arg2), XEN_TO_C_XContext(arg3))));
}

static XEN gxm_XDefaultString(void)
{
  #define H_XDefaultString "char *XDefaultString() returns the default string used by Xlib for text conversion"
  return(C_TO_XEN_STRING(XDefaultString()));
}

static XEN gxm_XCreateRegion(void)
{
  #define H_XCreateRegion "Region XCreateRegion()"
  return(C_TO_XEN_Region(XCreateRegion()));
}

static XEN gxm_XClipBox(XEN arg1)
{
  #define H_XClipBox "XClipBox(r) returns the smallest rectangle enclosing the specified region."
  /* DIFF: XClipBox region [rectangle] -> (list val rectangle)
   */
  XRectangle *r;
  int val;
  XEN_ASSERT_TYPE(XEN_Region_P(arg1), arg1, 1, "XClipBox", "Region");
  r = (XRectangle *)CALLOC(1, sizeof(XRectangle));
  val = XClipBox(XEN_TO_C_Region(arg1), r);
  return(XEN_LIST_2(C_TO_XEN_INT(val), C_TO_XEN_XRectangle(r)));
}

static XEN gxm_XAllocWMHints(void)
{
  #define H_XAllocWMHints "XAllocWMHints() allocates a window manager hints structure"
  return(C_TO_XEN_XWMHints(XAllocWMHints()));
}

static XEN gxm_XAllocStandardColormap(void)
{
  #define H_XAllocStandardColormap "XStandardColormap *XAllocStandardColormap() allocates and returns a pointer to a XStandardColormap structure."
  return(C_TO_XEN_XStandardColormap(XAllocStandardColormap()));
}

static XEN gxm_XAllocIconSize(void)
{
  #define H_XAllocIconSize "XIconSize *XAllocIconSize() allocates and returns a pointer to a XIconSize structure."
  return(C_TO_XEN_XIconSize(XAllocIconSize()));
}

static XEN gxm_XFilterEvent(XEN arg1, XEN arg2)
{
  #define H_XFilterEvent "Bool XFilterEvent(event, w) passes the event to any filters registered for it in the given window"
  XEN_ASSERT_TYPE(XEN_XEvent_P(arg1), arg1, 1, "XFilterEvent", "XEvent*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XFilterEvent", "Window");
  return(C_TO_XEN_BOOLEAN(XFilterEvent(XEN_TO_C_XEvent(arg1), XEN_TO_C_Window(arg2))));
}

static XEN gxm_XContextualDrawing(XEN arg1)
{
  #define H_XContextualDrawing "Bool XContextualDrawing(font_set) returns #t if text drawn with the font set might include context-dependent drawing."
  XEN_ASSERT_TYPE(XEN_XFontSet_P(arg1), arg1, 1, "XContextualDrawing", "XFontSet");
  return(C_TO_XEN_BOOLEAN(XContextualDrawing(XEN_TO_C_XFontSet(arg1))));
}

static XEN gxm_XDirectionalDependentDrawing(XEN arg1)
{
  #define H_XDirectionalDependentDrawing "Bool XDirectionalDependentDrawing(font_set) returns #t if the drawing functions implement \
implicit text directionality."
  XEN_ASSERT_TYPE(XEN_XFontSet_P(arg1), arg1, 1, "XDirectionalDependentDrawing", "XFontSet");
  return(C_TO_XEN_BOOLEAN(XDirectionalDependentDrawing(XEN_TO_C_XFontSet(arg1))));
}

static XEN gxm_XContextDependentDrawing(XEN arg1)
{
  #define H_XContextDependentDrawing "Bool XContextDependentDrawing(font_set) returns #t if the drawing functions implement implicit \
text directionality or if text drawn with the font_set might include context-dependent drawing."
  XEN_ASSERT_TYPE(XEN_XFontSet_P(arg1), arg1, 1, "XContextDependentDrawing", "XFontSet");
  return(C_TO_XEN_BOOLEAN(XContextDependentDrawing(XEN_TO_C_XFontSet(arg1))));
}

static XEN gxm_XLocaleOfFontSet(XEN arg1)
{
  #define H_XLocaleOfFontSet "char *XLocaleOfFontSet(font_set) returns the name of the locale bound to the specified XFontSet, as a \
null-terminated string."
  XEN_ASSERT_TYPE(XEN_XFontSet_P(arg1), arg1, 1, "XLocaleOfFontSet", "XFontSet");
  return(C_TO_XEN_STRING(XLocaleOfFontSet(XEN_TO_C_XFontSet(arg1))));
}

static XEN gxm_XBaseFontNameListOfFontSet(XEN arg1)
{
  #define H_XBaseFontNameListOfFontSet "char *XBaseFontNameListOfFontSet(font_set) returns the original base font name list supplied \
by the client when the  XFontSet was created."
  XEN_ASSERT_TYPE(XEN_XFontSet_P(arg1), arg1, 1, "XBaseFontNameListOfFontSet", "XFontSet");
  return(C_TO_XEN_STRING(XBaseFontNameListOfFontSet(XEN_TO_C_XFontSet(arg1))));
}

static XEN gxm_XFontsOfFontSet(XEN arg1)
{
  #define H_XFontsOfFontSet "int XFontsOfFontSet(font_set) returns a list of one or more \
XFontStructs and font names for the fonts used by the Xmb and Xwc layers, for the given font set."
  /* DIFF: XFontsOfFontSet omit last 2 args, return 2 lists
   */
  int i, len, loc1, loc2;
  char **names;
  XEN lst1 = XEN_EMPTY_LIST, lst2 = XEN_EMPTY_LIST;
  XFontStruct **fs;
  XEN_ASSERT_TYPE(XEN_XFontSet_P(arg1), arg1, 1, "XFontsOfFontSet", "XFontSet");
  len = XFontsOfFontSet(XEN_TO_C_XFontSet(arg1), &fs, &names);
  loc1 = xm_protect(lst1);
  loc2 = xm_protect(lst2);
  for (i = len - 1; i >= 0; i--)
    {
      lst1 = XEN_CONS(C_TO_XEN_XFontStruct(fs[i]), lst1);
      lst2 = XEN_CONS(C_TO_XEN_STRING(names[i]), lst2);
    }
  xm_unprotect_at(loc1);
  xm_unprotect_at(loc2);
  return(XEN_LIST_2(lst1, lst2));
}

static XEN gxm_XFreeFontSet(XEN arg1, XEN arg2)
{
  #define H_XFreeFontSet "void XFreeFontSet(display, font_set) frees the specified font set."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XFreeFontSet", "Display*");
  XEN_ASSERT_TYPE(XEN_XFontSet_P(arg2), arg2, 2, "XFreeFontSet", "XFontSet");
  XFreeFontSet(XEN_TO_C_Display(arg1), XEN_TO_C_XFontSet(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XCreateFontSet(XEN arg1, XEN arg2)
{
  #define H_XCreateFontSet "XFontSet XCreateFontSet(display, base_font_name_list) creates a font set for the specified display."
  /* DIFF: XCreateFontSet ignores (omits) the 3 trailing missing glyph args
   */
  char **cs;
  int len;
  char *str;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XCreateFontSet", "Display*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XCreateFontSet", "char*");
  return(C_TO_XEN_XFontSet(XCreateFontSet(XEN_TO_C_Display(arg1), XEN_TO_C_STRING(arg2), &cs, &len, &str)));
}

static XEN gxm_XSetLocaleModifiers(XEN arg1)
{
  #define H_XSetLocaleModifiers "char *XSetLocaleModifiers(modifier_list) sets the X modifiers for the current locale setting."
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XSetLocaleModifiers", "char*");
  return(C_TO_XEN_STRING(XSetLocaleModifiers(XEN_TO_C_STRING(arg1))));
}

static XEN gxm_XSupportsLocale(void)
{
  #define H_XSupportsLocale "Bool XSupportsLocale() returns #t if Xlib functions are capable of operating under the current locale."
  return(C_TO_XEN_BOOLEAN(XSupportsLocale()));
}

static XEN gxm_XWriteBitmapFile(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7)
{
  #define H_XWriteBitmapFile "int XWriteBitmapFile(display, filename, bitmap, width, height, x_hot, y_hot) writes a bitmap out to a file in \
the X Version 11 format."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XWriteBitmapFile", "Display*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XWriteBitmapFile", "char*");
  XEN_ASSERT_TYPE(XEN_Pixmap_P(arg3), arg3, 3, "XWriteBitmapFile", "Pixmap");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg4), arg4, 4, "XWriteBitmapFile", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg5), arg5, 5, "XWriteBitmapFile", "unsigned int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XWriteBitmapFile", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg7), arg7, 7, "XWriteBitmapFile", "int");
  return(C_TO_XEN_INT(XWriteBitmapFile(XEN_TO_C_Display(arg1), 
				       XEN_TO_C_STRING(arg2), 
				       XEN_TO_C_Pixmap(arg3), 
				       XEN_TO_C_ULONG(arg4), XEN_TO_C_ULONG(arg5), 
				       XEN_TO_C_INT(arg6), XEN_TO_C_INT(arg7))));
}

static XEN gxm_XWindowEvent(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XWindowEvent "XWindowEvent(display, w, event_mask) searches the event queue for an event that matches both \
the specified window and event mask, and removes it or waits until it arrives."
  /* DIFF: XWindowEvent dpy win ev [evrtn] -> (list val evrtn)
   */
  XEvent *e;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XWindowEvent", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XWindowEvent", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XWindowEvent", "long");
  e = (XEvent *)CALLOC(1, sizeof(XEvent));
  val = XWindowEvent(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_INT(arg3), e);
  return(XEN_LIST_2(C_TO_XEN_INT(val), C_TO_XEN_XEvent_OBJ(e)));
}

static XEN gxm_XWidthOfScreen(XEN arg1)
{
  #define H_WidthOfScreen "XWidthOfScreen(screen) returns the width of the specified screen."
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XWidthOfScreen", "Screen*");
  return(C_TO_XEN_INT(XWidthOfScreen(XEN_TO_C_Screen(arg1))));
}

static XEN gxm_XWidthMMOfScreen(XEN arg1)
{
  #define H_WidthMMOfScreen "XWidthMMOfScreen(screen) returns the width of the specified screen in millimeters."
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XWidthMMOfScreen", "Screen*");
  return(C_TO_XEN_INT(XWidthMMOfScreen(XEN_TO_C_Screen(arg1))));
}

static XEN gxm_XWarpPointer(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7, XEN arg8, XEN arg9)
{
  #define H_XWarpPointer "XWarpPointer(display, src_w, dest_w, src_x, src_y, src_width, src_height, dest_x, dest_y)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XWarpPointer", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XWarpPointer", "Window");
  XEN_ASSERT_TYPE(XEN_Window_P(arg3), arg3, 3, "XWarpPointer", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XWarpPointer", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XWarpPointer", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg6), arg6, 6, "XWarpPointer", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg7), arg7, 7, "XWarpPointer", "unsigned int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg8), arg8, 8, "XWarpPointer", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg9), arg9, 9, "XWarpPointer", "int");
  return(C_TO_XEN_INT(XWarpPointer(XEN_TO_C_Display(arg1), 
				   XEN_TO_C_Window(arg2), XEN_TO_C_Window(arg3), 
				   XEN_TO_C_INT(arg4), XEN_TO_C_INT(arg5), 
				   XEN_TO_C_ULONG(arg6), XEN_TO_C_ULONG(arg7), 
				   XEN_TO_C_INT(arg8), XEN_TO_C_INT(arg9))));
}

static XEN gxm_XVendorRelease(XEN arg1)
{
  #define H_VendorRelease "VendorRelease(display) returns a number related to a vendor's release of the X server."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XVendorRelease", "Display*");
  return(C_TO_XEN_INT(XVendorRelease(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XUnmapWindow(XEN arg1, XEN arg2)
{
  #define H_XUnmapWindow "XUnmapWindow(display, w) unmaps the specified window and causes the X server to generate an UnmapNotify event."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XUnmapWindow", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XUnmapWindow", "Window");
  return(C_TO_XEN_INT(XUnmapWindow(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2))));
}

static XEN gxm_XUnmapSubwindows(XEN arg1, XEN arg2)
{
  #define H_XUnmapSubwindows "XUnmapSubwindows(display, w) unmaps all subwindows for the specified window in bottom-to-top stacking order."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XUnmapSubwindows", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XUnmapSubwindows", "Window");
  return(C_TO_XEN_INT(XUnmapSubwindows(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2))));
}

static XEN gxm_XUnloadFont(XEN arg1, XEN arg2)
{
  #define H_XUnloadFont "XUnloadFont(display, font) deletes the association between the font resource ID and the specified font."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XUnloadFont", "Display*");
  XEN_ASSERT_TYPE(XEN_Font_P(arg2), arg2, 2, "XUnloadFont", "Font");
  return(C_TO_XEN_INT(XUnloadFont(XEN_TO_C_Display(arg1), XEN_TO_C_Font(arg2))));
}

static XEN gxm_XUninstallColormap(XEN arg1, XEN arg2)
{
  #define H_XUninstallColormap "XUninstallColormap(display, colormap) removes the specified colormap from the required list for its screen."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XUninstallColormap", "Display*");
  XEN_ASSERT_TYPE(XEN_Colormap_P(arg2), arg2, 2, "XUninstallColormap", "Colormap");
  return(C_TO_XEN_INT(XUninstallColormap(XEN_TO_C_Display(arg1), XEN_TO_C_Colormap(arg2))));
}

static XEN gxm_XUngrabServer(XEN arg1)
{
  #define H_XUngrabServer "XUngrabServer(display) restarts processing of requests and close downs on other connections."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XUngrabServer", "Display*");
  return(C_TO_XEN_INT(XUngrabServer(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XUngrabPointer(XEN arg1, XEN arg2)
{
  #define H_XUngrabPointer "XUngrabPointer(display, time) releases the pointer and any queued events if this client has actively grabbed the \
pointer from XGrabPointer, XGrabButton,or from a normal button press."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XUngrabPointer", "Display*");
  XEN_ASSERT_TYPE(XEN_Time_P(arg2), arg2, 2, "XUngrabPointer", "Time");
  return(C_TO_XEN_INT(XUngrabPointer(XEN_TO_C_Display(arg1), XEN_TO_C_Time(arg2))));
}

static XEN gxm_XUngrabKeyboard(XEN arg1, XEN arg2)
{
  #define H_XUngrabKeyboard "XUngrabKeyboard(display, time) releases the keyboard and any queued events if this client has it actively grabbed \
from either XGrabKeyboard or XGrabKey."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XUngrabKeyboard", "Display*");
  XEN_ASSERT_TYPE(XEN_Time_P(arg2), arg2, 2, "XUngrabKeyboard", "Time");
  return(C_TO_XEN_INT(XUngrabKeyboard(XEN_TO_C_Display(arg1), XEN_TO_C_Time(arg2))));
}

static XEN gxm_XUngrabKey(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XUngrabKey "XUngrabKey(display, keycode, modifiers, grab_window) releases the key combination on the specified window if it was \
grabbed by this client."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XUngrabKey", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XUngrabKey", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XUngrabKey", "unsigned int");
  XEN_ASSERT_TYPE(XEN_Window_P(arg4), arg4, 4, "XUngrabKey", "Window");
  return(C_TO_XEN_INT(XUngrabKey(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_ULONG(arg3), XEN_TO_C_Window(arg4))));
}

static XEN gxm_XUngrabButton(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XUngrabButton "XUngrabButton(display, button, modifiers, grab_window) releases the passive button/key combination on the specified \
window if it was grabbed by this client."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XUngrabButton", "Display*");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XUngrabButton", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XUngrabButton", "unsigned int");
  XEN_ASSERT_TYPE(XEN_Window_P(arg4), arg4, 4, "XUngrabButton", "Window");
  return(C_TO_XEN_INT(XUngrabButton(XEN_TO_C_Display(arg1), XEN_TO_C_ULONG(arg2), XEN_TO_C_ULONG(arg3), XEN_TO_C_Window(arg4))));
}

static XEN gxm_XUndefineCursor(XEN arg1, XEN arg2)
{
  #define H_XUndefineCursor "XUndefineCursor(display, w) undoes the effect of a previous XDefineCursor for this window."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XUndefineCursor", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XUndefineCursor", "Window");
  return(C_TO_XEN_INT(XUndefineCursor(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2))));
}

static XEN gxm_XTranslateCoordinates(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XTranslateCoordinates "Bool XTranslateCoordinates(display, src_w, dest_w, src_x, src_y) \
takes the src_x and src_y coordinates relative to the source window's origin and returns these coordinates to dest_x_return and dest_y_return \
relative to the destination window's origin -> (rtn x y win)."
  /* DIFF: XTranslateCoordinates omit last 3 args
   */
  Window w;
  int x, y, rtn;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XTranslateCoordinates", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XTranslateCoordinates", "Window");
  XEN_ASSERT_TYPE(XEN_Window_P(arg3), arg3, 3, "XTranslateCoordinates", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XTranslateCoordinates", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XTranslateCoordinates", "int");
  rtn = XTranslateCoordinates(XEN_TO_C_Display(arg1), 
			      XEN_TO_C_Window(arg2), 
			      XEN_TO_C_Window(arg3), 
			      XEN_TO_C_INT(arg4), XEN_TO_C_INT(arg5), 
			      &x, &y, &w);
  return(XEN_LIST_4(C_TO_XEN_BOOLEAN(rtn),
		    C_TO_XEN_INT(x),
		    C_TO_XEN_INT(y),
		    C_TO_XEN_Window(w)));
}

static XEN gxm_XTextWidth(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XTextWidth "int XTextWidth(font_struct, string, count) returns the width of the specified 8-bit string."
  XEN_ASSERT_TYPE(XEN_XFontStruct_P(arg1), arg1, 1, "XTextWidth", "XFontStruct*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XTextWidth", "char*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XTextWidth", "int");
  return(C_TO_XEN_INT(XTextWidth(XEN_TO_C_XFontStruct(arg1), XEN_TO_C_STRING(arg2), XEN_TO_C_INT(arg3))));
}

static XEN gxm_XTextExtents(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XTextExtents "XTextExtents(font_struct, string, nchars) returns an XCharStruct structure describing the text."
  /* DIFF: XTextExtents omit final 4 args and returns them [Xcharset returned as embedded list)
   */
  int dir, fa, fd, rtn;
  XCharStruct val;
  XEN_ASSERT_TYPE(XEN_XFontStruct_P(arg1), arg1, 1, "XTextExtents", "XFontStruct*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XTextExtents", "char*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XTextExtents", "int");
  rtn = XTextExtents(XEN_TO_C_XFontStruct(arg1), 
		     XEN_TO_C_STRING(arg2), 
		     XEN_TO_C_INT(arg3), 
		     &dir, &fa, &fd, &val);
  return(XEN_LIST_5(C_TO_XEN_INT(rtn),
		    C_TO_XEN_INT(dir),
		    C_TO_XEN_INT(fa),
		    C_TO_XEN_INT(fd),
		    XEN_LIST_6(C_TO_XEN_INT((int)(val.lbearing)),
			       C_TO_XEN_INT((int)(val.rbearing)),
			       C_TO_XEN_INT((int)(val.width)),
			       C_TO_XEN_INT((int)(val.ascent)),
			       C_TO_XEN_INT((int)(val.descent)),
			       C_TO_XEN_INT((int)(val.attributes)))));
}

static XEN gxm_XSync(XEN arg1, XEN arg2)
{
  #define H_XSync "XSync(display, discard) flushes the output buffer and then waits until all requests have been received and processed by the X server."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSync", "Display*");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg2), arg2, 2, "XSync", "Bool");
  return(C_TO_XEN_INT(XSync(XEN_TO_C_Display(arg1), XEN_TO_C_BOOLEAN(arg2))));
}

static XEN gxm_XStoreNamedColor(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XStoreNamedColor "XStoreNamedColor(display, colormap, color, pixel, flags) looks up the named color with respect to the screen \
associated with the colormap and stores the result in the specified colormap."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XStoreNamedColor", "Display*");
  XEN_ASSERT_TYPE(XEN_Colormap_P(arg2), arg2, 2, "XStoreNamedColor", "Colormap");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3), arg3, 3, "XStoreNamedColor", "char*");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg4), arg4, 4, "XStoreNamedColor", "ulong"); /* this is explicitly an index into the colormap, so I'll leave it as is */
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XStoreNamedColor", "int");
  return(C_TO_XEN_INT(XStoreNamedColor(XEN_TO_C_Display(arg1), 
				       XEN_TO_C_Colormap(arg2), 
				       XEN_TO_C_STRING(arg3), XEN_TO_C_ULONG(arg4), XEN_TO_C_INT(arg5))));
}

static XEN gxm_XStoreName(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XStoreName "XStoreName(display, w, window_name) assigns the name passed to window_name to the specified window."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XStoreName", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XStoreName", "Window");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3), arg3, 3, "XStoreName", "char*");
  return(C_TO_XEN_INT(XStoreName(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_STRING(arg3))));
}

static XEN gxm_XStoreColors(XEN arg1, XEN arg2, XEN larg3, XEN arg4)
{
  #define H_XStoreColors "XStoreColors(display, colormap, color, ncolors) changes the colormap entries of the pixel values specified in the \
pixel members of the XColor structures."
  /* DIFF: XStoreColors arg 3 is list of XColor 
   */
  XColor *xc;
  int i, len;
  XEN arg3;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XStoreColors", "Display*");
  XEN_ASSERT_TYPE(XEN_Colormap_P(arg2), arg2, 2, "XStoreColors", "Colormap");
  XEN_ASSERT_TYPE(XEN_LIST_P(larg3), larg3, 3, "XStoreColors", "list of XColor");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XStoreColors", "int");
  arg3 = XEN_COPY_ARG(larg3);
  len = XEN_TO_C_INT(arg4);
  if (len <= 0) XEN_ASSERT_TYPE(0, arg4, 4, "XStoreColors", "positive integer");
  xc = (XColor *)CALLOC(len, sizeof(XColor));
  for (i = 0; (i < len) && (XEN_NOT_NULL_P(arg3)); i++, arg3 = XEN_CDR(arg3))
    {
      XColor *xc1;
      xc1 = XEN_TO_C_XColor(XEN_CAR(arg3));
      xc[i].pixel = xc1->pixel;
      xc[i].red = xc1->red;
      xc[i].green = xc1->green;
      xc[i].blue = xc1->blue;
      xc[i].flags = xc1->flags;
      xc[i].pad = xc1->pad;
    }
  XStoreColors(XEN_TO_C_Display(arg1), 
	       XEN_TO_C_Colormap(arg2),
	       xc, len);
  FREE(xc);
  return(C_TO_XEN_INT(len));
}

static XEN gxm_XStoreColor(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XStoreColor "XStoreColor(display, colormap, color) changes the colormap entry of the pixel value specified in the pixel member \
of the XColor structure."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XStoreColor", "Display*");
  XEN_ASSERT_TYPE(XEN_Colormap_P(arg2), arg2, 2, "XStoreColor", "Colormap");
  XEN_ASSERT_TYPE(XEN_XColor_P(arg3), arg3, 3, "XStoreColor", "XColor"); 
  return(C_TO_XEN_INT(XStoreColor(XEN_TO_C_Display(arg1), XEN_TO_C_Colormap(arg2), XEN_TO_C_XColor(arg3))));
}

static XEN gxm_XStoreBytes(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XStoreBytes "XStoreBytes(display, bytes, nbytes)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XStoreBytes", "Display*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XStoreBytes", "char*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XStoreBytes", "int");
  return(C_TO_XEN_INT(XStoreBytes(XEN_TO_C_Display(arg1), XEN_TO_C_STRING(arg2), XEN_TO_C_INT(arg3) + 1)));
}

static XEN gxm_XStoreBuffer(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XStoreBuffer "XStoreBuffer(display, bytes, nbytes, buffer)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XStoreBuffer", "Display*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XStoreBuffer", "char*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XStoreBuffer", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XStoreBuffer", "int");
  return(C_TO_XEN_INT(XStoreBuffer(XEN_TO_C_Display(arg1), XEN_TO_C_STRING(arg2), XEN_TO_C_INT(arg3) + 1, XEN_TO_C_INT(arg4))));
}

static XEN gxm_XSetWindowColormap(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSetWindowColormap "XSetWindowColormap(display, w, colormap) sets the specified colormap of the specified window."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetWindowColormap", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XSetWindowColormap", "Window");
  XEN_ASSERT_TYPE(XEN_Colormap_P(arg3), arg3, 3, "XSetWindowColormap", "Colormap");
  return(C_TO_XEN_INT(XSetWindowColormap(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_Colormap(arg3))));
}

static XEN gxm_XSetWindowBorderWidth(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSetWindowBorderWidth "XSetWindowBorderWidth(display, w, width) sets the specified window's border width to the specified width."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetWindowBorderWidth", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XSetWindowBorderWidth", "Window");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XSetWindowBorderWidth", "unsigned int");
  return(C_TO_XEN_INT(XSetWindowBorderWidth(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_ULONG(arg3))));
}

static XEN gxm_XSetWindowBorderPixmap(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSetWindowBorderPixmap "XSetWindowBorderPixmap(display, w, border_pixmap) sets the border pixmap of the window to the pixmap you specify."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetWindowBorderPixmap", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XSetWindowBorderPixmap", "Window");
  XEN_ASSERT_TYPE(XEN_Pixmap_P(arg3) || XEN_INTEGER_P(arg3), arg3, 3, "XSetWindowBorderPixmap", "Pixmap");
  return(C_TO_XEN_INT(XSetWindowBorderPixmap(XEN_TO_C_Display(arg1), 
					     XEN_TO_C_Window(arg2),
					     (XEN_Pixmap_P(arg3)) ? XEN_TO_C_Pixmap(arg3) : CopyFromParent)));
}

static XEN gxm_XSetWindowBorder(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSetWindowBorder "XSetWindowBorder(display, w, border_pixel) sets the border of the window to the pixel value you specify."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetWindowBorder", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XSetWindowBorder", "Window");
  XEN_ASSERT_TYPE(XEN_Pixel_P(arg3), arg3, 3, "XSetWindowBorder", "pixel"); 
  return(C_TO_XEN_INT(XSetWindowBorder(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_Pixel(arg3))));
}

static XEN gxm_XSetWindowBackgroundPixmap(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSetWindowBackgroundPixmap "XSetWindowBackgroundPixmap(display, w, background_pixmap) sets the background pixmap of the window to \
the specified pixmap."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetWindowBackgroundPixmap", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XSetWindowBackgroundPixmap", "Window");
  XEN_ASSERT_TYPE(XEN_Pixmap_P(arg3) || XEN_INTEGER_P(arg3), arg3, 3, "XSetWindowBackgroundPixmap", "Pixmap");
  return(C_TO_XEN_INT(XSetWindowBackgroundPixmap(XEN_TO_C_Display(arg1), 
						 XEN_TO_C_Window(arg2), 
						 (XEN_Pixmap_P(arg3)) ? XEN_TO_C_Pixmap(arg3) : XEN_TO_C_ULONG(arg3))));
}

static XEN gxm_XSetWindowBackground(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSetWindowBackground "XSetWindowBackground(display, w, background_pixel) sets the background of the window to the specified pixel value."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetWindowBackground", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XSetWindowBackground", "Window");
  XEN_ASSERT_TYPE(XEN_Pixel_P(arg3), arg3, 3, "XSetWindowBackground", "pixel"); 
  return(C_TO_XEN_INT(XSetWindowBackground(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_Pixel(arg3))));
}

static XEN gxm_XSetTile(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSetTile "XSetTile(display, gc, tile) sets the fill tile in the specified GC."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetTile", "Display*");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XSetTile", "GC");
  XEN_ASSERT_TYPE(XEN_Pixmap_P(arg3), arg3, 3, "XSetTile", "Pixmap");
  return(C_TO_XEN_INT(XSetTile(XEN_TO_C_Display(arg1), XEN_TO_C_GC(arg2), XEN_TO_C_Pixmap(arg3))));
}

static XEN gxm_XSetTSOrigin(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XSetTSOrigin "XSetTSOrigin(display, gc, ts_x_origin, ts_y_origin) sets the tile/stipple origin in the specified GC."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetTSOrigin", "Display*");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XSetTSOrigin", "GC");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XSetTSOrigin", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XSetTSOrigin", "int");
  return(C_TO_XEN_INT(XSetTSOrigin(XEN_TO_C_Display(arg1), XEN_TO_C_GC(arg2), XEN_TO_C_INT(arg3), XEN_TO_C_INT(arg4))));
}

static XEN gxm_XSetSubwindowMode(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSetSubwindowMode "XSetSubwindowMode(display, gc, subwindow_mode) sets the subwindow mode in the specified GC."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetSubwindowMode", "Display*");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XSetSubwindowMode", "GC");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XSetSubwindowMode", "int");
  return(C_TO_XEN_INT(XSetSubwindowMode(XEN_TO_C_Display(arg1), XEN_TO_C_GC(arg2), XEN_TO_C_INT(arg3))));
}

static XEN gxm_XSetStipple(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSetStipple "XSetStipple(display, gc, stipple) sets the stipple in the specified GC."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetStipple", "Display*");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XSetStipple", "GC");
  XEN_ASSERT_TYPE(XEN_Pixmap_P(arg3), arg3, 3, "XSetStipple", "Pixmap");
  return(C_TO_XEN_INT(XSetStipple(XEN_TO_C_Display(arg1), XEN_TO_C_GC(arg2), XEN_TO_C_Pixmap(arg3))));
}

static XEN gxm_XSetState(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6)
{
  #define H_XSetState "XSetState(display, gc, foreground, background, function, plane_mask) sets the foreground, background, plane mask, and \
function components for the specified GC."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetState", "Display*");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XSetState", "GC");
  XEN_ASSERT_TYPE(XEN_Pixel_P(arg3), arg3, 3, "XSetState", "Pixel");
  XEN_ASSERT_TYPE(XEN_Pixel_P(arg4), arg4, 4, "XSetState", "Pixel");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XSetState", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg6), arg6, 6, "XSetState", "ulong");
  return(C_TO_XEN_INT(XSetState(XEN_TO_C_Display(arg1), 
				XEN_TO_C_GC(arg2), 
				XEN_TO_C_Pixel(arg3), XEN_TO_C_Pixel(arg4), 
				XEN_TO_C_INT(arg5), XEN_TO_C_ULONG(arg6))));
}

static XEN gxm_XSetSelectionOwner(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XSetSelectionOwner "XSetSelectionOwner(display, selection, owner, time) changes the owner and last-change time for the specified selection"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetSelectionOwner", "Display*");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg2), arg2, 2, "XSetSelectionOwner", "Atom");
  XEN_ASSERT_TYPE(XEN_Window_P(arg3), arg3, 3, "XSetSelectionOwner", "Window");
  XEN_ASSERT_TYPE(XEN_Time_P(arg4), arg4, 4, "XSetSelectionOwner", "Time");
  return(C_TO_XEN_INT(XSetSelectionOwner(XEN_TO_C_Display(arg1), XEN_TO_C_Atom(arg2), XEN_TO_C_Window(arg3), XEN_TO_C_Time(arg4))));
}

static XEN gxm_XSetScreenSaver(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XSetScreenSaver "XSetScreenSaver(display, timeout, interval, prefer_blanking, allow_exposures) enables the screen saver."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetScreenSaver", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XSetScreenSaver", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XSetScreenSaver", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XSetScreenSaver", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XSetScreenSaver", "int");
  return(C_TO_XEN_INT(XSetScreenSaver(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_INT(arg3), XEN_TO_C_INT(arg4), XEN_TO_C_INT(arg5))));
}

static XEN gxm_XSetPointerMapping(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSetPointerMapping "int XSetPointerMapping(display, map, nmap) sets the mapping of the pointer."
  int i, len, rtn;
  unsigned char *map;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetPointerMapping", "Display*");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XSetPointerMapping", "list of ints");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg3), arg3, 3, "XSetPointerMapping", "int");
  if (XEN_INTEGER_P(arg3)) len = XEN_TO_C_INT(arg3); else len = XEN_LIST_LENGTH(arg2);
  map = (unsigned char *)CALLOC(len, sizeof(unsigned char));
  for (i = 0; i < len; i++)
    map[i] = (unsigned char)XEN_TO_C_INT(XEN_LIST_REF(arg2, i));
  rtn = XSetPointerMapping(XEN_TO_C_Display(arg1), map, len);
  FREE(map);
  return(C_TO_XEN_INT(rtn));
}

static XEN gxm_XSetPlaneMask(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSetPlaneMask "XSetPlaneMask(display, gc, plane_mask) sets the plane mask in the specified GC."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetPlaneMask", "Display*");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XSetPlaneMask", "GC");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XSetPlaneMask", "ulong");
  return(C_TO_XEN_INT(XSetPlaneMask(XEN_TO_C_Display(arg1), XEN_TO_C_GC(arg2), XEN_TO_C_ULONG(arg3))));
}

static XEN gxm_XSetModifierMapping(XEN arg1, XEN arg2)
{
  #define H_XSetModifierMapping "int XSetModifierMapping(display, modmap) specifies the KeyCodes of the keys (if any) that are to be used as modifiers."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetModifierMapping", "Display*");
  XEN_ASSERT_TYPE(XEN_XModifierKeymap_P(arg2), arg2, 2, "XSetModifierMapping", "XModifierKeymap*");
  return(C_TO_XEN_INT(XSetModifierMapping(XEN_TO_C_Display(arg1), XEN_TO_C_XModifierKeymap(arg2))));
}

static XEN gxm_XSetLineAttributes(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6)
{
  #define H_XSetLineAttributes "XSetLineAttributes(display, gc, line_width, line_style, cap_style, join_style) sets the line drawing components \
in the specified GC."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetLineAttributes", "Display*");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XSetLineAttributes", "GC");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XSetLineAttributes", "unsigned int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XSetLineAttributes", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XSetLineAttributes", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XSetLineAttributes", "int");
  return(C_TO_XEN_INT(XSetLineAttributes(XEN_TO_C_Display(arg1), 
					 XEN_TO_C_GC(arg2), 
					 XEN_TO_C_ULONG(arg3), XEN_TO_C_INT(arg4), XEN_TO_C_INT(arg5), XEN_TO_C_INT(arg6))));
}

static XEN gxm_XSetInputFocus(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XSetInputFocus "XSetInputFocus(display, focus, revert_to, time) changes the input focus and the last-focus-change time."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetInputFocus", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XSetInputFocus", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XSetInputFocus", "int");
  XEN_ASSERT_TYPE(XEN_Time_P(arg4), arg4, 4, "XSetInputFocus", "Time");
  return(C_TO_XEN_INT(XSetInputFocus(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_INT(arg3), XEN_TO_C_Time(arg4))));
}

static XEN gxm_XSetIconName(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSetIconName "XSetIconName(display, w, icon_name) sets the name to be displayed in a window's icon."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetIconName", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XSetIconName", "Window");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3), arg3, 3, "XSetIconName", "char*");
  return(C_TO_XEN_INT(XSetIconName(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_STRING(arg3))));
}

static XEN gxm_XSetGraphicsExposures(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSetGraphicsExposures "XSetGraphicsExposures(display, gc, graphics_exposures) sets the graphics-exposures flag in the specified GC."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetGraphicsExposures", "Display*");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XSetGraphicsExposures", "GC");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg3), arg3, 3, "XSetGraphicsExposures", "Bool");
  return(C_TO_XEN_INT(XSetGraphicsExposures(XEN_TO_C_Display(arg1), XEN_TO_C_GC(arg2), XEN_TO_C_BOOLEAN(arg3))));
}

static XEN gxm_XSetFunction(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSetFunction "XSetFunction(display, gc, function) sets a specified value in the specified GC"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetFunction", "Display*");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XSetFunction", "GC");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XSetFunction", "int");
  return(C_TO_XEN_INT(XSetFunction(XEN_TO_C_Display(arg1), XEN_TO_C_GC(arg2), XEN_TO_C_INT(arg3))));
}

static XEN gxm_XSetForeground(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSetForeground "XSetForeground(display, gc, foreground) sets the foreground in the specified GC."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetForeground", "Display*");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XSetForeground", "GC");
  XEN_ASSERT_TYPE(XEN_Pixel_P(arg3), arg3, 3, "XSetForeground", "Pixel");
  return(C_TO_XEN_INT(XSetForeground(XEN_TO_C_Display(arg1), XEN_TO_C_GC(arg2), XEN_TO_C_Pixel(arg3))));
}

static XEN gxm_XSetFontPath(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSetFontPath "XSetFontPath(display, directories, ndirs) defines the directory search path for font lookup."
  /* DIFF: XSetFontPath arg2 is list of strings
   */
  char **paths;
  int len, rtn;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetFontPath", "Display*");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XSetFontPath", "list of char*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XSetFontPath", "int");
  len = XEN_TO_C_INT(arg3);
  if (len > 0)
    paths = XEN_TO_C_Strings(arg2, len);
  else paths = NULL;
  rtn = XSetFontPath(XEN_TO_C_Display(arg1), paths, len);
  if (paths) FREE(paths);
  return(xen_return_first(C_TO_XEN_INT(rtn), arg2));
}

static XEN gxm_XSetFont(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSetFont "XSetFont(display, gc, font) sets the current font in the specified GC."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetFont", "Display*");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XSetFont", "GC");
  XEN_ASSERT_TYPE(XEN_Font_P(arg3), arg3, 3, "XSetFont", "Font");
  return(C_TO_XEN_INT(XSetFont(XEN_TO_C_Display(arg1), XEN_TO_C_GC(arg2), XEN_TO_C_Font(arg3))));
}

static XEN gxm_XSetFillStyle(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSetFillStyle "XSetFillStyle(display, gc, fill_style) sets the fill-style in the specified GC."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetFillStyle", "Display*");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XSetFillStyle", "GC");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XSetFillStyle", "int");
  return(C_TO_XEN_INT(XSetFillStyle(XEN_TO_C_Display(arg1), XEN_TO_C_GC(arg2), XEN_TO_C_INT(arg3))));
}

static XEN gxm_XSetFillRule(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSetFillRule "XSetFillRule(display, gc, fill_rule) sets the fill-rule in the specified GC."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetFillRule", "Display*");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XSetFillRule", "GC");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XSetFillRule", "int");
  return(C_TO_XEN_INT(XSetFillRule(XEN_TO_C_Display(arg1), XEN_TO_C_GC(arg2), XEN_TO_C_INT(arg3))));
}

static XEN gxm_XSetDashes(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XSetDashes "XSetDashes(display, gc, dash_offset, dash_list, n) sets the dash-offset and dash-list attributes for dashed line styles \
in the specified GC."
  char *dashes;
  int i, len = 0, val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetDashes", "Display*");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XSetDashes", "GC");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XSetDashes", "int");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg4), arg4, 4, "XSetDashes", "list of ints");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg5), arg5, 5, "XSetDashes", "optional length of list (int)");
  if (XEN_INTEGER_P(arg5)) len = XEN_TO_C_INT(arg5);
  if (len <= 0) len = XEN_LIST_LENGTH(arg4);
  dashes = (char *)CALLOC(len, sizeof(char));
  for (i = 0; i < len; i++) dashes[i] = (char)(XEN_TO_C_INT(XEN_LIST_REF(arg4, i)));
  val = XSetDashes(XEN_TO_C_Display(arg1), 
		   XEN_TO_C_GC(arg2), 
		   XEN_TO_C_INT(arg3),
		   dashes, len);
  FREE(dashes);
  return(C_TO_XEN_INT(val));
}

static XEN gxm_XSetCommand(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XSetCommand "XSetCommand(display, w, argv, argc) sets the command and arguments used to invoke the application."
  /* DIFF: XSetCommand argv is list of strings
   */
  int len, val;
  char **str;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetCommand", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XSetCommand", "Window");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg3), arg3, 3, "XSetCommand", "list of char*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XSetCommand", "int");
  len = XEN_TO_C_INT(arg4);
  if (len <= 0) return(XEN_FALSE);
  str = XEN_TO_C_Strings(arg3, len);
  val = XSetCommand(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), str, len);
  FREE(str);
  return(xen_return_first(C_TO_XEN_INT(val), arg3));
}

static XEN gxm_XSetCloseDownMode(XEN arg1, XEN arg2)
{
  #define H_XSetCloseDownMode "XSetCloseDownMode(display, close_mode) defines what will happen to the client's resources at connection close."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetCloseDownMode", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XSetCloseDownMode", "int");
  return(C_TO_XEN_INT(XSetCloseDownMode(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XSetClipRectangles(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN larg5, XEN arg6, XEN arg7)
{
  #define H_XSetClipRectangles "XSetClipRectangles(display, gc, clip_x_origin, clip_y_origin, rectangles, n, ordering) changes the clip-mask in \
the specified GC to the specified list of rectangles and sets the clip origin."
  /* DIFF: XSetClipRectangles XRectangle* arg (arg 5) is list of XRectangles
   */
  XRectangle *pt;
  int i, len;
  XEN arg5;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetClipRectangles", "Display*");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XSetClipRectangles", "GC");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XSetClipRectangles", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XSetClipRectangles", "int");
  XEN_ASSERT_TYPE(XEN_LIST_P(larg5), larg5, 5, "XSetClipRectangles", "list of XRectangles");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XSetClipRectangles", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg7), arg7, 7, "XSetClipRectangles", "int");
  arg5 = XEN_COPY_ARG(larg5);
  len = XEN_TO_C_INT(arg6);
  if (len <= 0) XEN_ASSERT_TYPE(0, arg6, 6, "XSetClipRectangles", "positive integer");
  pt = (XRectangle *)CALLOC(len, sizeof(XRectangle));
  for (i = 0; (i < len) && (XEN_NOT_NULL_P(arg5)); i++, arg5 = XEN_CDR(arg5))
    {
      XRectangle *pt1;
      pt1 = XEN_TO_C_XRectangle(XEN_CAR(arg5));
      pt[i].x = pt1->x;
      pt[i].y = pt1->y;
      pt[i].width = pt1->width;
      pt[i].height = pt1->height;
    }
  XSetClipRectangles(XEN_TO_C_Display(arg1), 
		     XEN_TO_C_GC(arg2), 
		     XEN_TO_C_INT(arg3), 
		     XEN_TO_C_INT(arg4), 
		     pt, len,
		     XEN_TO_C_INT(arg7));
  FREE(pt);
  return(C_TO_XEN_INT(len));
}

static XEN gxm_XSetClipOrigin(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XSetClipOrigin "XSetClipOrigin(display, gc, clip_x_origin, clip_y_origin) sets the clip origin in the specified GC."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetClipOrigin", "Display*");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XSetClipOrigin", "GC");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XSetClipOrigin", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XSetClipOrigin", "int");
  return(C_TO_XEN_INT(XSetClipOrigin(XEN_TO_C_Display(arg1), XEN_TO_C_GC(arg2), XEN_TO_C_INT(arg3), XEN_TO_C_INT(arg4))));
}

static XEN gxm_XSetClipMask(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSetClipMask "XSetClipMask(display, gc, pixmap) sets the clip-mask in the specified GC to the specified pixmap."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetClipMask", "Display*");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XSetClipMask", "GC");
  XEN_ASSERT_TYPE(XEN_Pixmap_P(arg3) || XEN_INTEGER_P(arg3), arg3, 3, "XSetClipMask", "Pixmap or None");
  return(C_TO_XEN_INT(XSetClipMask(XEN_TO_C_Display(arg1), 
				   XEN_TO_C_GC(arg2),
				   (XEN_Pixmap_P(arg3)) ? XEN_TO_C_Pixmap(arg3) : None)));
}

static XEN gxm_XSetBackground(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSetBackground "XSetBackground(display, gc, background) sets the background in the specified GC."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetBackground", "Display*");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XSetBackground", "GC");
  XEN_ASSERT_TYPE(XEN_Pixel_P(arg3), arg3, 3, "XSetBackground", "Pixel");
  return(C_TO_XEN_INT(XSetBackground(XEN_TO_C_Display(arg1), XEN_TO_C_GC(arg2), XEN_TO_C_Pixel(arg3))));
}

static XEN gxm_XSetArcMode(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSetArcMode "XSetArcMode(display, gc, arc_mode)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetArcMode", "Display*");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XSetArcMode", "GC");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XSetArcMode", "int");
  return(C_TO_XEN_INT(XSetArcMode(XEN_TO_C_Display(arg1), XEN_TO_C_GC(arg2), XEN_TO_C_INT(arg3))));
}

static XEN gxm_XSetAccessControl(XEN arg1, XEN arg2)
{
  #define H_XSetAccessControl "XSetAccessControl(display, mode) either enables or disables the use of the access control list at each connection setup."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetAccessControl", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XSetAccessControl", "int");
  return(C_TO_XEN_INT(XSetAccessControl(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XSendEvent(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XSendEvent "Status XSendEvent(display, w, propagate, event_mask, event_send) identifies the destination window, determines which \
clients should receive the specified events, "
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSendEvent", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XSendEvent", "Window");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg3), arg3, 3, "XSendEvent", "Bool");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XSendEvent", "long");
  XEN_ASSERT_TYPE(XEN_XEvent_P(arg5), arg5, 5, "XSendEvent", "XEvent*");
  return(C_TO_XEN_INT(XSendEvent(XEN_TO_C_Display(arg1), 
				 XEN_TO_C_Window(arg2), 
				 XEN_TO_C_BOOLEAN(arg3), XEN_TO_C_INT(arg4), XEN_TO_C_XEvent(arg5))));
}

static XEN gxm_XSelectInput(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSelectInput "XSelectInput(dpy, window, event_mask) selects input events"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSelectInput", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XSelectInput", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XSelectInput", "long");
  return(C_TO_XEN_INT(XSelectInput(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_INT(arg3))));
}

static XEN gxm_XScreenCount(XEN arg1)
{
  #define H_ScreenCount "returns the number of available screens."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XScreenCount", "Display*");
  return(C_TO_XEN_INT(XScreenCount(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XRotateWindowProperties(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XRotateWindowProperties "XRotateWindowProperties(display, w, properties, num_prop, npositions) allows you to rotate properties on a \
window and causes the X server to generate PropertyNotify events."
  /* DIFF: XRotateWindowProperties arg3 is list of atoms
   */
  Atom *outs;
  int val, len;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XRotateWindowProperties", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XRotateWindowProperties", "Window");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg3), arg3, 3, "XRotateWindowProperties", "list of Atom");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XRotateWindowProperties", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XRotateWindowProperties", "int");
  len = XEN_TO_C_INT(arg4);
  if (len <= 0) return(XEN_FALSE);
  outs = XEN_TO_C_Atoms(arg3, len);
  val = XRotateWindowProperties(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), outs, len, XEN_TO_C_INT(arg5));
  FREE(outs);
  return(C_TO_XEN_INT(val));
}

static XEN gxm_XRotateBuffers(XEN arg1, XEN arg2)
{
  #define H_XRotateBuffers "XRotateBuffers(display, rotate) rotates the cut buffers, such that buffer 0 becomes buffer n, buffer 1 becomes n + 1 \
mod 8, and so on. "
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XRotateBuffers", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XRotateBuffers", "int");
  return(C_TO_XEN_INT(XRotateBuffers(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XRestackWindows(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XRestackWindows "XRestackWindows(display, windows, nwindows) restacks the windows in the order specified, from top to bottom."
  /* DIFF: XRestackWindows arg2 is list of Windows
   */
  int len, rtn;
  Window *ws;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XRestackWindows", "Display*");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XRestackWindows", "list of Windows");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XRestackWindows", "int");
  len = XEN_TO_C_INT(arg3);
  if (len <= 0) return(XEN_FALSE);
  ws = XEN_TO_C_Windows(arg2, len);
  rtn = XRestackWindows(XEN_TO_C_Display(arg1), ws, len);
  FREE(ws);
  return(C_TO_XEN_INT(rtn));
}

static XEN gxm_XResizeWindow(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XResizeWindow "XResizeWindow(display, w, width, height) changes the inside dimensions of the specified window, not including its borders."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XResizeWindow", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XResizeWindow", "Window");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XResizeWindow", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg4), arg4, 4, "XResizeWindow", "unsigned int");
  return(C_TO_XEN_INT(XResizeWindow(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_ULONG(arg3), XEN_TO_C_ULONG(arg4))));
}

static XEN gxm_XResetScreenSaver(XEN arg1)
{
  #define H_XResetScreenSaver "XResetScreenSaver(display) resets the screen saver."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XResetScreenSaver", "Display*");
  return(C_TO_XEN_INT(XResetScreenSaver(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XReparentWindow(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XReparentWindow "XReparentWindow(display, w, parent, x, y)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XReparentWindow", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XReparentWindow", "Window");
  XEN_ASSERT_TYPE(XEN_Window_P(arg3), arg3, 3, "XReparentWindow", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XReparentWindow", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XReparentWindow", "int");
  return(C_TO_XEN_INT(XReparentWindow(XEN_TO_C_Display(arg1), 
				      XEN_TO_C_Window(arg2), 
				      XEN_TO_C_Window(arg3), 
				      XEN_TO_C_INT(arg4), XEN_TO_C_INT(arg5))));
}

static XEN gxm_XRefreshKeyboardMapping(XEN arg1)
{
  #define H_XRefreshKeyboardMapping "XRefreshKeyboardMapping(event_map) refreshes the stored modifier and keymap information."
  XEN_ASSERT_TYPE(XEN_XMappingEvent_P(arg1), arg1, 1, "XRefreshKeyboardMapping", "XMappingEvent*");
  return(C_TO_XEN_INT(XRefreshKeyboardMapping(XEN_TO_C_XMappingEvent(arg1))));
}

static XEN gxm_XRecolorCursor(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XRecolorCursor "XRecolorCursor(display, cursor, foreground_color, background_color) changes the color of the specified cursor, and if \
the cursor is being displayed on a screen, the change is visible immediately."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XRecolorCursor", "Display*");
  XEN_ASSERT_TYPE(XEN_Cursor_P(arg2), arg2, 2, "XRecolorCursor", "Cursor");
  XEN_ASSERT_TYPE(XEN_XColor_P(arg3), arg3, 3, "XRecolorCursor", "XColor");
  XEN_ASSERT_TYPE(XEN_XColor_P(arg4), arg4, 4, "XRecolorCursor", "XColor");
  return(C_TO_XEN_INT(XRecolorCursor(XEN_TO_C_Display(arg1), XEN_TO_C_Cursor(arg2), 
				     XEN_TO_C_XColor(arg3), XEN_TO_C_XColor(arg4))));
}

static XEN gxm_XRebindKeysym(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6)
{
  #define H_XRebindKeysym "XRebindKeysym(display, keysym, list, mod_count, string, num_bytes) can be used to rebind the meaning of a KeySym for the client."
  /* DIFF: XRebindKeysym mod_list is list of keysyms
   */
  KeySym *ks;
  int len, val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XRebindKeysym", "Display*");
  XEN_ASSERT_TYPE(XEN_KeySym_P(arg2), arg2, 2, "XRebindKeysym", "KeySym");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg3), arg3, 3, "XRebindKeysym", "list of KeySym");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XRebindKeysym", "int");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg5), arg5, 5, "XRebindKeysym", "string");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XRebindKeysym", "int");
  len = XEN_TO_C_INT(arg4);
  if (len <= 0) return(XEN_FALSE);
  ks = XEN_TO_C_KeySyms(arg3, len);
  val = XRebindKeysym(XEN_TO_C_Display(arg1), 
		      XEN_TO_C_KeySym(arg2),
		      ks, len, 
		      (unsigned char *)XEN_TO_C_STRING(arg5), XEN_TO_C_INT(arg6));
  FREE(ks);
  return(C_TO_XEN_INT(val));
}

static XEN gxm_XReadBitmapFileData(XEN arg1)
{
  #define H_XReadBitmapFileData "int XReadBitmapFileData(filename) reads in a \
file containing a bitmap, in the same manner as XReadBitmapFile, but returns the data directly rather than creating a pixmap in the server."
  /* DIFF: XReadBitmapFileData omits last 5 args, returns as list
   */
  unsigned int w, h, i, j;
  int x, y;
  unsigned char **str = NULL; /* allocated by X? */
  int val, loc;
  XEN bits = XEN_EMPTY_LIST;
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XReadBitmapFileData", "char*");
  val = XReadBitmapFileData(XEN_TO_C_STRING(arg1), &w, &h, str, &x, &y);
  loc = xm_protect(bits);
  for (i = 0; i < h; i++)
    for (j = 0; j < w; j++)
      bits = XEN_CONS(C_TO_XEN_INT((int)(str[i][j])), bits);
  if (str) free(str);
  xm_unprotect_at(loc);
  return(XEN_LIST_6(C_TO_XEN_INT(val),
		    C_TO_XEN_INT((int)w),
		    C_TO_XEN_INT((int)h),
		    bits,
		    C_TO_XEN_INT((int)x),
		    C_TO_XEN_INT((int)y)));
}

static XEN gxm_XReadBitmapFile(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XReadBitmapFile "int XReadBitmapFile(display, d, filename) reads in a file containing a bitmap."
  /* DIFF: XReadBitmapFile omits last 5 args, returns as list
   */
  unsigned int w, h;
  int x, y;
  int val;
  Pixmap *p = NULL; /* allocated by X? */
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XReadBitmapFile", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XReadBitmapFile", "Drawable");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3), arg3, 3, "XReadBitmapFile", "char*");
  val = XReadBitmapFile(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_STRING(arg3), &w, &h, p, &x, &y);
  return(XEN_LIST_6(C_TO_XEN_INT(val),
		    C_TO_XEN_INT((int)w),
		    C_TO_XEN_INT((int)h),
		    C_TO_XEN_Pixmap(*p),
		    C_TO_XEN_INT((int)x),
		    C_TO_XEN_INT((int)y)));
}

static XEN gxm_XRaiseWindow(XEN arg1, XEN arg2)
{
  #define H_XRaiseWindow "XRaiseWindow(display, w)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XRaiseWindow", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XRaiseWindow", "Window");
  return(C_TO_XEN_INT(XRaiseWindow(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2))));
}

static XEN gxm_XQueryTree(XEN arg1, XEN arg2)
{
  #define H_XQueryTree "Status XQueryTree(display, w) returns the root ID, the \
parent window ID, a pointer to the list of children windows and the number of children in the list for the specified window."
  /* DIFF: XQueryTree last 4 arg omit, returns (list val root parent (list children))
   */
  unsigned int arrlen;
  Window *ws;
  Window root, parent;
  int i, val, loc;
  XEN lst = XEN_EMPTY_LIST;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XQueryTree", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XQueryTree", "Window");
  val = XQueryTree(XEN_TO_C_Display(arg1), 
		   XEN_TO_C_Window(arg2), 
		   &root, &parent, &ws, &arrlen);
  loc = xm_protect(lst);
  for (i = arrlen - 1; i >= 0; i--)
    lst = XEN_CONS(C_TO_XEN_Window(ws[i]), lst);
  XFree(ws);
  xm_unprotect_at(loc);
  return(XEN_LIST_4(C_TO_XEN_INT(val),
		    C_TO_XEN_Window(root),
		    C_TO_XEN_Window(parent),
		    lst));
}

static XEN gxm_XQueryTextExtents(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XQueryTextExtents "XQueryTextExtents(display, font, string) returns the bounding box of the specified 8-bit string."
  /* DIFF: XQueryTextExtents omits last 5 args, returns list 
   */
  XCharStruct *c;
  int fa, fd, dr, val;
  char *str;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XQueryTextExtents", "Display*");
  XEN_ASSERT_TYPE(XEN_Font_P(arg2), arg2, 2, "XQueryTextExtents", "Font");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3), arg3, 3, "XQueryTextExtents", "char*");
  str = XEN_TO_C_STRING(arg3);
  c = (XCharStruct *)CALLOC(1, sizeof(XCharStruct));
  val = XQueryTextExtents(XEN_TO_C_Display(arg1), 
			  XEN_TO_C_Font(arg2), 
			  str, strlen(str), &dr, &fa, &fd, c); 
  return(XEN_LIST_5(C_TO_XEN_INT(val),
		    C_TO_XEN_INT(dr),
		    C_TO_XEN_INT(fa),
		    C_TO_XEN_INT(fd),
		    WRAP_FOR_XEN_OBJ("XCharStruct", c)));
}

static XEN gxm_XQueryPointer(XEN arg1, XEN arg2)
{
  #define H_XQueryPointer "Bool XQueryPointer(display, w) returns the root window the pointer is logically on and the pointer \
coordinates relative to the root window's origin."
  /* DIFF: XQueryPointer last 7 args omit and rtn
   */
  Window w1, w2;
  int rx, ry, wx, wy;
  unsigned int mask;
  int rtn;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XQueryPointer", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XQueryPointer", "Window");
  rtn = XQueryPointer(XEN_TO_C_Display(arg1), 
		      XEN_TO_C_Window(arg2), 
		      &w1, &w2, &rx, &ry, &wx, &wy, &mask);
  return(XEN_LIST_8(C_TO_XEN_BOOLEAN(rtn),
		    C_TO_XEN_Window(w1),
		    C_TO_XEN_Window(w2),
		    C_TO_XEN_INT(rx),
		    C_TO_XEN_INT(ry),
		    C_TO_XEN_INT(wx),
		    C_TO_XEN_INT(wy),
		    C_TO_XEN_ULONG((unsigned long)mask)));
}

static XEN gxm_XQueryKeymap(XEN arg1)
{
  #define H_XQueryKeymap "XQueryKeymap(display) returns a bit vector for the logical state of the keyboard, where each bit \
set to 1 indicates that the corresponding key is currently pressed down."
  /* DIFF: XQueryKeymap omits keys -> (list val keys)
   */
  char keys[32];
  int val, i, loc;
  XEN lst = XEN_EMPTY_LIST;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XQueryKeymap", "Display*");
  val = XQueryKeymap(XEN_TO_C_Display(arg1), keys);
  loc = xm_protect(lst);
  for (i = 31; i >= 0; i--)
    lst = XEN_CONS(C_TO_XEN_INT((int)keys[i]), lst);
  xm_unprotect_at(loc);
  return(XEN_CONS(C_TO_XEN_INT(val), lst));
}

static XEN gxm_XQueryExtension(XEN arg1, XEN arg2)
{
  #define H_XQueryExtension "Bool XQueryExtension(dpy, name) gets extension version information"
  /* DIFF: XQueryExtension dpy name [op er er] -> (list val op er er)
   */
  int op, err1, err2, val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XQueryExtension", "Display*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XQueryExtension", "char*");
  val = XQueryExtension(XEN_TO_C_Display(arg1), XEN_TO_C_STRING(arg2), &op, &err1, &err2);
  return(XEN_LIST_4(C_TO_XEN_BOOLEAN(val),
		    C_TO_XEN_INT(op),
		    C_TO_XEN_INT(err1),
		    C_TO_XEN_INT(err2)));
}

static XEN gxm_XQueryColors(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XQueryColors "XQueryColors(display, colormap, defs_in_out, ncolors)"
  int i, len, rtn;
  XEN lst;
  XColor *cols;
  XColor *col;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XQueryColors", "Display*");
  XEN_ASSERT_TYPE(XEN_Colormap_P(arg2), arg2, 2, "XQueryColors", "Colormap");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg3), arg3, 3, "XQueryColors", "XColor list");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg4), arg4, 4, "XQueryColors", "int");
  if (XEN_INTEGER_P(arg4)) len = XEN_TO_C_INT(arg4); else len = XEN_LIST_LENGTH(arg3);
  lst = XEN_COPY_ARG(arg3);
  cols = (XColor *)CALLOC(len, sizeof(XColor));
  for (i = 0; (i < len) && (XEN_NOT_NULL_P(lst)); i++, lst = XEN_CDR(lst))
    {
      if (XEN_XColor_P(XEN_CAR(lst)))
	{
	  col = XEN_TO_C_XColor(XEN_CAR(lst));
	  cols[i].pixel = col->pixel;
	}
      else XEN_ASSERT_TYPE(0, XEN_CAR(lst), i, c__FUNCTION__, "an XColor");
    }
  rtn = XQueryColors(XEN_TO_C_Display(arg1), XEN_TO_C_Colormap(arg2), cols, len);
  for (i = 0; i < len; i++)
    {
      col = XEN_TO_C_XColor(XEN_LIST_REF(arg3, i));
      col->red = cols[i].red;
      col->green = cols[i].green;
      col->blue = cols[i].blue;
      col->flags = cols[i].flags;
    }
  FREE(cols);
  return(C_TO_XEN_INT(rtn));
}

static XEN gxm_XQueryColor(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XQueryColor "XQueryColor(display, colormap, def_in_out) returns the current RGB value for the pixel in the XColor structure \
and sets the DoRed, DoGreen, DoBlue flags."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XQueryColor", "Display*");
  XEN_ASSERT_TYPE(XEN_Colormap_P(arg2), arg2, 2, "XQueryColor", "Colormap");
  XEN_ASSERT_TYPE(XEN_XColor_P(arg3), arg3, 3, "XQueryColor", "XColor*");
  return(C_TO_XEN_INT(XQueryColor(XEN_TO_C_Display(arg1), XEN_TO_C_Colormap(arg2), XEN_TO_C_XColor(arg3))));
}

static XEN gxm_XQueryBestTile(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XQueryBestTile "Status XQueryBestTile(display, which_screen, width, height)  returns the best or \
closest size, that is, the size that can be tiled fastest on the screen specified by which_screen."
  /* DIFF: XQueryBestTile dpy scr wid hgt [wd hg] -> (list status wd hg)
   */
  unsigned int w, h;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XQueryBestTile", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XQueryBestTile", "Drawable");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XQueryBestTile", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg4), arg4, 4, "XQueryBestTile", "unsigned int");
  val = XQueryBestTile(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), 
		       XEN_TO_C_ULONG(arg3), XEN_TO_C_ULONG(arg4), &w, &h);
  return(XEN_LIST_3(C_TO_XEN_INT(val),
		    C_TO_XEN_ULONG(w),
		    C_TO_XEN_ULONG(h)));
}

static XEN gxm_XQueryBestStipple(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XQueryBestStipple "Status XQueryBestStipple(display, which_screen, width, height)  returns the \
best or closest size, that is, the size that can be stippled fastest on the screen specified by which_screen."
  /* DIFF: XQueryBestStipple dpy scr wid hgt [wd hg] -> (list status wd hg)
   */
  unsigned int w, h;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XQueryBestStipple", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XQueryBestStipple", "Drawable");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XQueryBestStipple", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg4), arg4, 4, "XQueryBestStipple", "unsigned int");
  val = XQueryBestStipple(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), 
			  XEN_TO_C_ULONG(arg3), XEN_TO_C_ULONG(arg4), 
			  &w, &h);
  return(XEN_LIST_3(C_TO_XEN_INT(val),
		    C_TO_XEN_ULONG(w),
		    C_TO_XEN_ULONG(h)));
}

static XEN gxm_XQueryBestSize(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XQueryBestSize "Status XQueryBestSize(display, class, which_screen, width, height)  returns the \
best or closest size to the specified size."
  /* DIFF: XQueryBestSize dpy cls scr wid hgt [wd hg] -> (list status wd hg)
   */
  unsigned int w, h;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XQueryBestSize", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XQueryBestSize", "int");
  XEN_ASSERT_TYPE(XEN_Window_P(arg3), arg3, 3, "XQueryBestSize", "Drawable");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg4), arg4, 4, "XQueryBestSize", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg5), arg5, 5, "XQueryBestSize", "unsigned int");
  val = XQueryBestSize(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_Window(arg3), 
		       XEN_TO_C_ULONG(arg4), XEN_TO_C_ULONG(arg5), 
		       &w, &h);
  return(XEN_LIST_3(C_TO_XEN_INT(val),
		    C_TO_XEN_ULONG(w),
		    C_TO_XEN_ULONG(h)));
}

static XEN gxm_XQueryBestCursor(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XQueryBestCursor "Status XQueryBestCursor(display, d, width, height) provides a way to find \
out what size cursors are actually possible on the display."
  /* DIFF: XQueryBestCursor dpy d wid hgt [wd hg] -> (list status wd hg)
   */
  unsigned int w, h;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XQueryBestCursor", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XQueryBestCursor", "Drawable");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XQueryBestCursor", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg4), arg4, 4, "XQueryBestCursor", "unsigned int");
  val = XQueryBestCursor(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), 
			 XEN_TO_C_ULONG(arg3), XEN_TO_C_ULONG(arg4), 
			 &w, &h);
  return(XEN_LIST_3(C_TO_XEN_INT(val),
		    C_TO_XEN_ULONG(w),
		    C_TO_XEN_ULONG(h)));
}

static XEN gxm_XQLength(XEN arg1)
{
  #define H_QLength "returns the length of the event queue for the connected display."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XQLength", "Display*");
  return(C_TO_XEN_INT(XQLength(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XPutImage(XEN args)
{
  #define H_XPutImage "XPutImage(display, d, gc, image, src_x, src_y, dest_x, dest_y, width, height) combines an image with a rectangle \
of the specified drawable."
  XEN arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10;
  arg1 = XEN_LIST_REF(args, 0);
  arg2 = XEN_LIST_REF(args, 1);
  arg3 = XEN_LIST_REF(args, 2);
  arg4 = XEN_LIST_REF(args, 3);
  arg5 = XEN_LIST_REF(args, 4);
  arg6 = XEN_LIST_REF(args, 5);
  arg7 = XEN_LIST_REF(args, 6);
  arg8 = XEN_LIST_REF(args, 7);
  arg9 = XEN_LIST_REF(args, 8);
  arg10 = XEN_LIST_REF(args, 9);
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XPutImage", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XPutImage", "Drawable");
  XEN_ASSERT_TYPE(XEN_GC_P(arg3), arg3, 3, "XPutImage", "GC");
  XEN_ASSERT_TYPE(XEN_XImage_P(arg4), arg4, 4, "XPutImage", "XImage*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XPutImage", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XPutImage", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg7), arg7, 7, "XPutImage", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg8), arg8, 8, "XPutImage", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg9), arg9, 9, "XPutImage", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg10), arg10, 10, "XPutImage", "unsigned int");
  return(C_TO_XEN_INT(XPutImage(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), 
				XEN_TO_C_GC(arg3), XEN_TO_C_XImage(arg4), XEN_TO_C_INT(arg5), XEN_TO_C_INT(arg6), 
				XEN_TO_C_INT(arg7), XEN_TO_C_INT(arg8), XEN_TO_C_ULONG(arg9), XEN_TO_C_ULONG(arg10))));
}

static XEN gxm_XPutBackEvent(XEN arg1, XEN arg2)
{
  #define H_XPutBackEvent "XPutBackEvent(display, event) pushes an event back onto the head of the display's event queue by copying the event into the queue."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XPutBackEvent", "Display*");
  XEN_ASSERT_TYPE(XEN_XEvent_P(arg2), arg2, 2, "XPutBackEvent", "XEvent*");
  return(C_TO_XEN_INT(XPutBackEvent(XEN_TO_C_Display(arg1), XEN_TO_C_XEvent(arg2))));
}

static XEN gxm_XProtocolVersion(XEN arg1)
{
  #define H_ProtocolVersion "ProtocolVersion(display) returns the major version number (11) of the X protocol associated with the connected display."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XProtocolVersion", "Display*");
  return(C_TO_XEN_INT(XProtocolVersion(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XProtocolRevision(XEN arg1)
{
  #define H_ProtocolRevision "ProtocolRevision(display) returns the minor protocol revision number of the X server."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XProtocolRevision", "Display*");
  return(C_TO_XEN_INT(XProtocolRevision(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XPlanesOfScreen(XEN arg1)
{
  #define H_PlanesOfScreen "PlanesOfScreen(screen) returns the number of planes in the root window of the specified screen."
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XPlanesOfScreen", "Screen*");
  return(C_TO_XEN_INT(XPlanesOfScreen(XEN_TO_C_Screen(arg1))));
}

static XEN gxm_XPending(XEN arg1)
{
  #define H_XPending "int XPending(display) returns the number of events that have been received from the X server but have not been removed \
from the event queue."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XPending", "Display*");
  return(C_TO_XEN_INT(XPending(XEN_TO_C_Display(arg1))));
}

static XEN xm_XPeekIfEventProc = XEN_FALSE;
static Bool gxm_XPeekIfEventProc(Display *dpy, XEvent *e, XtPointer p)
{
  return(XEN_TO_C_BOOLEAN(XEN_CALL_3(xm_XPeekIfEventProc, C_TO_XEN_Display(dpy), C_TO_XEN_XEvent(e), (XEN)(p), c__FUNCTION__)));
}

static XEN gxm_XPeekIfEvent(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XPeekIfEvent "XPeekIfEvent(display, predicate, arg) returns only when the specified predicate procedure returns #t for an event."
  /* DIFF: XPeekIfEvent dpy [evrtn] proc ptr -> (list val evrtn)
   */
  XEvent *e;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XPeekIfEvent", "Display*");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg2) && (XEN_REQUIRED_ARGS_OK(arg2, 3)), arg2, 2, "XPeekIfEvent", "(Bool_Proc dpy ev data)");
  e = (XEvent *)CALLOC(1, sizeof(XEvent));
  val = XPeekIfEvent(XEN_TO_C_Display(arg1), 
		     e, 
		     (Bool (*)(Display *d, XEvent *ev, char *p))gxm_XPeekIfEventProc, /* C++ insists on the cast */
		     (XPointer)arg3);
  return(XEN_LIST_2(C_TO_XEN_INT(val), C_TO_XEN_XEvent_OBJ(e)));
}

static XEN gxm_XPeekEvent(XEN arg1)
{
  #define H_XPeekEvent "XPeekEvent(display) returns the first event from the event queue, but it does not remove the event from the queue."
  /* DIFF: XPeekEvent dpy [ev] -> (list int event)
   */
  XEvent *e;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XPeekEvent", "Display*");
  e = (XEvent *)CALLOC(1, sizeof(XEvent));
  val = XPeekEvent(XEN_TO_C_Display(arg1), e);
  return(XEN_LIST_2(C_TO_XEN_INT(val), C_TO_XEN_XEvent_OBJ(e)));
}

static XEN gxm_XParseGeometry(XEN arg1)
{
  #define H_XParseGeometry "int XParseGeometry(parsestring) returns a bitmask that \
indicates which of the four values (width, height, xoffset, and yoffset) were actually found in the string and whether the x and y values are negative. "
  /* DIFF: XParseGeometry str [x y w h] -> (list bit x y w h)
   */
  int x = 0, y = 0, val = 0;
  unsigned int w = 0, h = 0;
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XParseGeometry", "char*");
  val = XParseGeometry(XEN_TO_C_STRING(arg1), &x, &y, &w, &h);
  return(XEN_LIST_5(C_TO_XEN_INT(val),
		    C_TO_XEN_INT(x),
		    C_TO_XEN_INT(y),
		    C_TO_XEN_INT(w),
		    C_TO_XEN_INT(h)));
}

static XEN gxm_XParseColor(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XParseColor "Status XParseColor(display, colormap, spec, exact_def_return) looks up the string name of a color with respect \
to the screen associated with the specified colormap."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XParseColor", "Display*");
  XEN_ASSERT_TYPE(XEN_Colormap_P(arg2), arg2, 2, "XParseColor", "Colormap");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3), arg3, 3, "XParseColor", "char*");
  XEN_ASSERT_TYPE(XEN_XColor_P(arg4), arg4, 4, "XParseColor", "XColor");
  return(C_TO_XEN_INT(XParseColor(XEN_TO_C_Display(arg1), XEN_TO_C_Colormap(arg2), XEN_TO_C_STRING(arg3), XEN_TO_C_XColor(arg4))));
}

static XEN gxm_XNoOp(XEN arg1)
{
  #define H_XNoOp "XNoOp(dpy) sends the server a no-op for exercise"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XNoOp", "Display*");
  return(C_TO_XEN_INT(XNoOp(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XNextEvent(XEN arg1)
{
  #define H_XNextEvent "XNextEvent(display) copies the first event from the event queue into the specified XEvent structure \
and then removes it from the queue."
  /* DIFF: XNextEvent dpy [ev] -> (list int event)
   */
  XEvent *e;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XNextEvent", "Display*");
  e = (XEvent *)CALLOC(1, sizeof(XEvent));
  val = XNextEvent(XEN_TO_C_Display(arg1), e);
  return(XEN_LIST_2(C_TO_XEN_INT(val), C_TO_XEN_XEvent_OBJ(e)));
}

static XEN gxm_XMoveWindow(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XMoveWindow "XMoveWindow(display, w, x, y) moves the specified window to the specified x and y coordinates, but it does not \
change the window's size, raise the window, or change the mapping state of the window."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XMoveWindow", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XMoveWindow", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XMoveWindow", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XMoveWindow", "int");
  return(C_TO_XEN_INT(XMoveWindow(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_INT(arg3), XEN_TO_C_INT(arg4))));
}

static XEN gxm_XMoveResizeWindow(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6)
{
  #define H_XMoveResizeWindow "XMoveResizeWindow(display, w, x, y, width, height) changes the size and location of the specified window without raising it."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XMoveResizeWindow", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XMoveResizeWindow", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XMoveResizeWindow", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XMoveResizeWindow", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg5), arg5, 5, "XMoveResizeWindow", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg6), arg6, 6, "XMoveResizeWindow", "unsigned int");
  return(C_TO_XEN_INT(XMoveResizeWindow(XEN_TO_C_Display(arg1), 
					XEN_TO_C_Window(arg2), 
					XEN_TO_C_INT(arg3), XEN_TO_C_INT(arg4), 
					XEN_TO_C_ULONG(arg5), XEN_TO_C_ULONG(arg6))));
}

static XEN gxm_XMinCmapsOfScreen(XEN arg1)
{
  #define H_MinCmapsOfScreen "returns the minimum number of installed colormaps supported by the specified screen."
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XMinCmapsOfScreen", "Screen*");
  return(C_TO_XEN_INT(XMinCmapsOfScreen(XEN_TO_C_Screen(arg1))));
}

static XEN gxm_XMaxCmapsOfScreen(XEN arg1)
{
  #define H_MaxCmapsOfScreen "returns the maximum number of installed colormaps supported by the specified screen."
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XMaxCmapsOfScreen", "Screen*");
  return(C_TO_XEN_INT(XMaxCmapsOfScreen(XEN_TO_C_Screen(arg1))));
}

static XEN gxm_XMaskEvent(XEN arg1, XEN arg2)
{
  #define H_XMaskEvent "XMaskEvent(display, event_mask) searches the event queue for the events associated with the specified mask."
  /* DIFF: XMaskEvent dpy mask [ev] -> (list val ev)
   */
  XEvent *e;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XMaskEvent", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XMaskEvent", "long");
  e = (XEvent *)CALLOC(1, sizeof(XEvent));
  val = XMaskEvent(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2), e);
  return(XEN_LIST_2(C_TO_XEN_INT(val), C_TO_XEN_XEvent_OBJ(e)));
}

static XEN gxm_XMapWindow(XEN arg1, XEN arg2)
{
  #define H_XMapWindow "XMapWindow(display, w) maps the window and all of its subwindows that have had map requests."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XMapWindow", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XMapWindow", "Window");
  return(C_TO_XEN_INT(XMapWindow(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2))));
}

static XEN gxm_XMapSubwindows(XEN arg1, XEN arg2)
{
  #define H_XMapSubwindows "XMapSubwindows(display, w) maps all subwindows for a specified window in top-to-bottom stacking order."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XMapSubwindows", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XMapSubwindows", "Window");
  return(C_TO_XEN_INT(XMapSubwindows(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2))));
}

static XEN gxm_XMapRaised(XEN arg1, XEN arg2)
{
  #define H_XMapRaised "XMapRaised(display, w) maps the window and all of its subwindows that have had map requests, and raises the \
specified window to the top of the stack."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XMapRaised", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XMapRaised", "Window");
  return(C_TO_XEN_INT(XMapRaised(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2))));
}

static XEN gxm_XLowerWindow(XEN arg1, XEN arg2)
{
  #define H_XLowerWindow "XLowerWindow(display, w) lowers the specified window to the bottom of the stack so that it does not obscure any sibling windows."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XLowerWindow", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XLowerWindow", "Window");
  return(C_TO_XEN_INT(XLowerWindow(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2))));
}

static XEN gxm_XLookupColor(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XLookupColor "Status XLookupColor(display, colormap, color_name, exact_def_return, screen_def_return) looks up the string name \
of a color with respect to the screen associated with the specified colormap."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XLookupColor", "Display*");
  XEN_ASSERT_TYPE(XEN_Colormap_P(arg2), arg2, 2, "XLookupColor", "Colormap");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3), arg3, 3, "XLookupColor", "char*");
  XEN_ASSERT_TYPE(XEN_XColor_P(arg4), arg4, 4, "XLookupColor", "XColor*");
  XEN_ASSERT_TYPE(XEN_XColor_P(arg5), arg5, 5, "XLookupColor", "XColor*");
  return(C_TO_XEN_INT(XLookupColor(XEN_TO_C_Display(arg1), 
				   XEN_TO_C_Colormap(arg2), 
				   XEN_TO_C_STRING(arg3), 
				   XEN_TO_C_XColor(arg4), XEN_TO_C_XColor(arg5))));
}

static XEN gxm_XKillClient(XEN arg1, XEN arg2)
{
  #define H_XKillClient "XKillClient(display, resource) forces a close-down of the client that created the resource"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XKillClient", "Display*");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XKillClient", "XID");
  return(C_TO_XEN_INT(XKillClient(XEN_TO_C_Display(arg1), XEN_TO_C_ULONG(arg2))));
}

static XEN gxm_XKeysymToKeycode(XEN arg1, XEN arg2)
{
  #define H_XKeysymToKeycode "KeyCode XKeysymToKeycode(display, keysym)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XKeysymToKeycode", "Display*");
  XEN_ASSERT_TYPE(XEN_KeySym_P(arg2), arg2, 2, "XKeysymToKeycode", "KeySym");
  return(C_TO_XEN_KeyCode(XKeysymToKeycode(XEN_TO_C_Display(arg1), XEN_TO_C_KeySym(arg2))));
}

static XEN gxm_XInstallColormap(XEN arg1, XEN arg2)
{
  #define H_XInstallColormap "XInstallColormap(display, colormap) installs the specified colormap for its associated screen."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XInstallColormap", "Display*");
  XEN_ASSERT_TYPE(XEN_Colormap_P(arg2), arg2, 2, "XInstallColormap", "Colormap");
  return(C_TO_XEN_INT(XInstallColormap(XEN_TO_C_Display(arg1), XEN_TO_C_Colormap(arg2))));
}

static XEN gxm_XImageByteOrder(XEN arg1)
{
  #define H_ImageByteOrder "specifies the required byte order for images for each scanline unit in XY format (bitmap) or for each pixel value in Z format."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XImageByteOrder", "Display*");
  return(C_TO_XEN_INT(XImageByteOrder(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XIfEvent(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XIfEvent "XIfEvent(display, predicate, arg) completes only when the specified predicate procedure returns #t for \
an event, which indicates an event in the queue matches."
  /* DIFF: XIfEvent dpy [ev] proc ptr -> (list val ev)
   */
  XEvent *e;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XIfEvent", "Display*");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg2) && (XEN_REQUIRED_ARGS_OK(arg2, 3)), arg2, 2, "XIfEvent", "(Bool_Proc dpy ev data)");
  e = (XEvent *)CALLOC(1, sizeof(XEvent));
  val = XIfEvent(XEN_TO_C_Display(arg1), 
		 e, 
		 (Bool (*)(Display *d1, XEvent *e1, char *p1))gxm_XPeekIfEventProc, 
		 (char *)arg3);
  return(XEN_LIST_2(C_TO_XEN_INT(val), C_TO_XEN_XEvent_OBJ(e)));
}

static XEN gxm_XHeightOfScreen(XEN arg1)
{
  #define H_HeightOfScreen "XHeightOfScreen(screen) returns the height of the specified screen."
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XHeightOfScreen", "Screen*");
  return(C_TO_XEN_INT(XHeightOfScreen(XEN_TO_C_Screen(arg1))));
}

static XEN gxm_XHeightMMOfScreen(XEN arg1)
{
  #define H_HeightMMOfScreen "XHeightMMOfScreen(screen) returns the height of the specified screen in millimeters."
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XHeightMMOfScreen", "Screen*");
  return(C_TO_XEN_INT(XHeightMMOfScreen(XEN_TO_C_Screen(arg1))));
}

static XEN gxm_XGrabServer(XEN arg1)
{
  #define H_XGrabServer "XGrabServer(display) disables processing of requests and close downs on all other connections than the one this request arrived on."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGrabServer", "Display*");
  return(C_TO_XEN_INT(XGrabServer(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XGrabPointer(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7, XEN arg8, XEN arg9)
{
  #define H_XGrabPointer "int XGrabPointer(display, grab_window, owner_events, event_mask, pointer_mode, keyboard_mode, confine_to, cursor, time) \
actively grabs control of the pointer and returns GrabSuccess if the grab was successful."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGrabPointer", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XGrabPointer", "Window");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg3), arg3, 3, "XGrabPointer", "Bool");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg4), arg4, 4, "XGrabPointer", "unsigned int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XGrabPointer", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XGrabPointer", "int");
  XEN_ASSERT_TYPE(XEN_Window_P(arg7), arg7, 7, "XGrabPointer", "Window");
  XEN_ASSERT_TYPE(XEN_Cursor_P(arg8), arg8, 8, "XGrabPointer", "Cursor");
  XEN_ASSERT_TYPE(XEN_Time_P(arg9), arg9, 9, "XGrabPointer", "Time");
  return(C_TO_XEN_INT(XGrabPointer(XEN_TO_C_Display(arg1), 
				   XEN_TO_C_Window(arg2), 
				   XEN_TO_C_BOOLEAN(arg3), 
				   XEN_TO_C_ULONG(arg4), XEN_TO_C_INT(arg5), XEN_TO_C_INT(arg6), 
				   XEN_TO_C_Window(arg7), XEN_TO_C_Cursor(arg8), 
				   XEN_TO_C_Time(arg9))));
}

static XEN gxm_XGrabKeyboard(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6)
{
  #define H_XGrabKeyboard "int XGrabKeyboard(display, grab_window, owner_events, pointer_mode, keyboard_mode, time) actively grabs control of \
the keyboard and generates FocusIn and FocusOut events."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGrabKeyboard", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XGrabKeyboard", "Window");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg3), arg3, 3, "XGrabKeyboard", "Bool");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XGrabKeyboard", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XGrabKeyboard", "int");
  XEN_ASSERT_TYPE(XEN_Time_P(arg6), arg6, 6, "XGrabKeyboard", "Time");
  return(C_TO_XEN_INT(XGrabKeyboard(XEN_TO_C_Display(arg1), 
				    XEN_TO_C_Window(arg2), 
				    XEN_TO_C_BOOLEAN(arg3), XEN_TO_C_INT(arg4), XEN_TO_C_INT(arg5), 
				    XEN_TO_C_Time(arg6))));
}

static XEN gxm_XGrabKey(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7)
{
  #define H_XGrabKey "XGrabKey(display, keycode, modifiers, grab_window, owner_events, pointer_mode, keyboard_mode) establishes a passive \
grab on the keyboard."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGrabKey", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XGrabKey", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XGrabKey", "unsigned int");
  XEN_ASSERT_TYPE(XEN_Window_P(arg4), arg4, 4, "XGrabKey", "Window");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg5), arg5, 5, "XGrabKey", "Bool");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XGrabKey", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg7), arg7, 7, "XGrabKey", "int");
  return(C_TO_XEN_INT(XGrabKey(XEN_TO_C_Display(arg1), 
			       XEN_TO_C_INT(arg2), XEN_TO_C_ULONG(arg3), 
			       XEN_TO_C_Window(arg4), 
			       XEN_TO_C_BOOLEAN(arg5), XEN_TO_C_INT(arg6), XEN_TO_C_INT(arg7))));
}

static XEN gxm_XGrabButton(XEN args)
{
  #define H_XGrabButton "XGrabButton(display, button, modifiers, grab_window, owner_events, event_mask, pointer_mode, keyboard_mode, confine_to, cursor) \
establishes a passive grab."
  XEN arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10;
  arg1 = XEN_LIST_REF(args, 0);
  arg2 = XEN_LIST_REF(args, 1);
  arg3 = XEN_LIST_REF(args, 2);
  arg4 = XEN_LIST_REF(args, 3);
  arg5 = XEN_LIST_REF(args, 4);
  arg6 = XEN_LIST_REF(args, 5);
  arg7 = XEN_LIST_REF(args, 6);
  arg8 = XEN_LIST_REF(args, 7);
  arg9 = XEN_LIST_REF(args, 8);
  arg10 = XEN_LIST_REF(args, 9);
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGrabButton", "Display*");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XGrabButton", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XGrabButton", "unsigned int");
  XEN_ASSERT_TYPE(XEN_Window_P(arg4), arg4, 4, "XGrabButton", "Window");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg5), arg5, 5, "XGrabButton", "Bool");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg6), arg6, 6, "XGrabButton", "unsigned int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg7), arg7, 7, "XGrabButton", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg8), arg8, 8, "XGrabButton", "int");
  XEN_ASSERT_TYPE(XEN_Window_P(arg9), arg9, 9, "XGrabButton", "Window");
  XEN_ASSERT_TYPE(XEN_Cursor_P(arg10), arg10, 10, "XGrabButton", "Cursor");
  return(C_TO_XEN_INT(XGrabButton(XEN_TO_C_Display(arg1), 
				  XEN_TO_C_ULONG(arg2), XEN_TO_C_ULONG(arg3), 
				  XEN_TO_C_Window(arg4), XEN_TO_C_BOOLEAN(arg5), 
				  XEN_TO_C_ULONG(arg6), XEN_TO_C_INT(arg7), 
				  XEN_TO_C_INT(arg8), 
				  XEN_TO_C_Window(arg9), XEN_TO_C_Cursor(arg10))));
}

static XEN gxm_XGetWindowAttributes(XEN arg1, XEN arg2)
{ 
  #define H_XGetWindowAttributes "Status XGetWindowAttributes(display, w) returns the current attributes for the \
specified window to an XWindowAttributes structure."
  /* DIFF: XGetWindowAttributes omits and rtns arg3 
   */
  XWindowAttributes *w;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetWindowAttributes", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XGetWindowAttributes", "Window");
  w = (XWindowAttributes *)CALLOC(1, sizeof(XWindowAttributes));
  XGetWindowAttributes(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), w);
  return(C_TO_XEN_XWindowAttributes(w));
}

static XEN gxm_XGetWindowProperty(XEN args)
{
  #define H_XGetWindowProperty "int XGetWindowProperty(display, w, property, long_offset, long_length, delete, req_type) \
returns the actual type of the property; the actual format of the property; the \
number of 8-bit, 16-bit, or 32-bit items transferred; the number of bytes remaining to be read in the property; and a pointer to the data \
actually returned."
  /* DIFF: XGetWindowProperty omit trailing 5 args, rtn as list
   */
  XEN arg1, arg2, arg3, arg4, arg5, arg6, arg7; 
  XEN result = XEN_FALSE;
  Atom a;
  int ret, val;
  unsigned long len = 0, bytes;
  unsigned char *data[1];
  arg1 = XEN_LIST_REF(args, 0);
  arg2 = XEN_LIST_REF(args, 1);
  arg3 = XEN_LIST_REF(args, 2);
  arg4 = XEN_LIST_REF(args, 3);
  arg5 = XEN_LIST_REF(args, 4);
  arg6 = XEN_LIST_REF(args, 5);
  arg7 = XEN_LIST_REF(args, 6);
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetWindowProperty", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XGetWindowProperty", "Window");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg3), arg3, 3, "XGetWindowProperty", "Atom");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XGetWindowProperty", "long");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XGetWindowProperty", "long");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg6), arg6, 6, "XGetWindowProperty", "Bool");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg7), arg7, 7, "XGetWindowProperty", "Atom");
  val = XGetWindowProperty(XEN_TO_C_Display(arg1), 
			   XEN_TO_C_Window(arg2), 
			   XEN_TO_C_Atom(arg3), 
			   XEN_TO_C_INT(arg4), 
			   XEN_TO_C_INT(arg5), 
			   XEN_TO_C_BOOLEAN(arg6), 
			   XEN_TO_C_Atom(arg7), 
			   &a, &ret, &len, &bytes, (unsigned char **)data);
  if ((a != (Atom)None) && (len > 0))
    {
      if (a == XA_STRING)
	result = C_TO_XEN_STRING((char *)data[0]);
      else result = C_TO_XEN_STRINGN((char *)data[0], len * ret / 8); /* is this a good idea? -- perhaps a void pointer here? */
      if (data[0]) XFree(data[0]);
    }
  return(XEN_LIST_6(C_TO_XEN_INT(val),
		    C_TO_XEN_Atom(a),
		    C_TO_XEN_INT(ret),
		    C_TO_XEN_ULONG(len),
		    C_TO_XEN_ULONG(bytes),
		    result));
}

static XEN gxm_XGetTransientForHint(XEN arg1, XEN arg2)
{
  #define H_XGetTransientForHint "Status XGetTransientForHint(display, w) returns the WM_TRANSIENT_FOR property for the specified window."
  /* DIFF: XGetTransientForHint omit and rtn last arg
   */
  Window w;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetTransientForHint", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XGetTransientForHint", "Window");
  val = XGetTransientForHint(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), &w);
  return(XEN_LIST_2(C_TO_XEN_INT(val),
		    C_TO_XEN_Window(w)));
}

static XEN gxm_XGetScreenSaver(XEN arg1)
{
  #define H_XGetScreenSaver "XGetScreenSaver(display) gets the current screen saver values."
  /* DIFF: XGetScreenSaver omit and rtn last 4 args
   */
  int a, b, c ,d, val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetScreenSaver", "Display*");
  val = XGetScreenSaver(XEN_TO_C_Display(arg1), &a, &b, &c, &d);
  return(XEN_LIST_5(C_TO_XEN_INT(val),
		    C_TO_XEN_INT(a),
		    C_TO_XEN_INT(b),
		    C_TO_XEN_INT(c),
		    C_TO_XEN_INT(d)));
}

static XEN gxm_XGetPointerMapping(XEN arg1, XEN ignore, XEN arg3)
{
  #define H_XGetPointerMapping "int XGetPointerMapping(display, ignored, len) returns the current mapping of the pointer."
  /* DIFF: XGetPointerMapping ignores arg2, returns list
   * (XGetPointerMapping (XtDisplay (cadr (main-widgets))) 0 3)
   */
  int i, len, loc, rtn;
  unsigned char *map;
  XEN lst = XEN_EMPTY_LIST;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetPointerMapping", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XGetPointerMapping", "int");
  len = XEN_TO_C_INT(arg3);
  if (len <= 0) XEN_ASSERT_TYPE(0, arg3, 3, "XGetPointerMapping", "positive integer");
  map = (unsigned char *)CALLOC(len, sizeof(unsigned char));
  rtn = XGetPointerMapping(XEN_TO_C_Display(arg1), map, len);
  if (len > rtn) len = rtn;
  loc = xm_protect(lst);
  for (i = len - 1; i >= 0; i--)
    lst = XEN_CONS(C_TO_XEN_INT((int)(map[i])), lst);
  FREE(map);
  xm_unprotect_at(loc);
  return(lst);
}

static XEN gxm_XGetPointerControl(XEN arg1)
{
  #define H_XGetPointerControl "XGetPointerControl(display) \
returns the pointer's current acceleration multiplier and acceleration threshold."
  /* DIFF: XGetPointerControl omits and return last 3 args
   */
  int val, num, den, thresh;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetPointerControl", "Display*");
  val = XGetPointerControl(XEN_TO_C_Display(arg1), &num, &den, &thresh);
  return(XEN_LIST_4(C_TO_XEN_INT(val),
		    C_TO_XEN_INT(num),
		    C_TO_XEN_INT(den),
		    C_TO_XEN_INT(thresh)));
}

static XEN gxm_XGetKeyboardControl(XEN arg1)
{
  #define H_XGetKeyboardControl "XGetKeyboardControl(display) returns the current control values for the keyboard \
to the XKeyboardState structure."
  /* DIFF: XGetKeyboardControl omits arg2 and rtns list of fields
   */
  XKeyboardState ks;
  XEN v;
  int i, loc;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetKeyboardControl", "Display*");
  XGetKeyboardControl(XEN_TO_C_Display(arg1), &ks);
  v = XEN_MAKE_VECTOR(32, XEN_ZERO);
  loc = xm_protect(v);
  for (i = 0; i < 32; i++)
    XEN_VECTOR_SET(v, i, C_TO_XEN_INT((int)(ks.auto_repeats[i])));
  xm_unprotect_at(loc);
  return(XEN_LIST_7(C_TO_XEN_INT(ks.key_click_percent),
		    C_TO_XEN_INT(ks.bell_percent),
		    C_TO_XEN_INT(ks.bell_pitch),
		    C_TO_XEN_INT(ks.bell_duration),
		    C_TO_XEN_INT(ks.led_mask),
		    C_TO_XEN_INT(ks.global_auto_repeat),
		    v));
}

static XEN gxm_XGetInputFocus(XEN arg1)
{
  #define H_XGetInputFocus "XGetInputFocus(display) returns the focus window and the current focus state."
  /* DIFF: XGetInputFocus omit and rtn last 2 args
   */
  Window w;
  int r, val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetInputFocus", "Display*");
  val = XGetInputFocus(XEN_TO_C_Display(arg1), &w, &r);
  return(XEN_LIST_3(C_TO_XEN_INT(val),
		    C_TO_XEN_Window(w),
		    C_TO_XEN_INT(r)));
}

static XEN gxm_XGetIconName(XEN arg1, XEN arg2)
{
  #define H_XGetIconName "Status XGetIconName(display, w) returns the name to be displayed in the specified window's icon."
  /* DIFF: XGetIconName omits and returns arg3
   */
  char *str;
  int val;
  XEN res = XEN_FALSE;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetIconName", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XGetIconName", "Window");
  val = XGetIconName(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), &str);
  if (val != 0)
    {
      res = C_TO_XEN_STRING(str);
      XFree(str);
    }
  return(res);
}

static XEN gxm_XGetGeometry(XEN arg1, XEN arg2)
{
  #define H_XGetGeometry "Status XGetGeometry(display, d) returns the root window and the current geometry of the drawable."
  /* DIFF: XGetGeometry omits last 7 args and returns list
   */
  unsigned int wr, hr, br, dr;
  int xr, yr, val;
  Window root;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetGeometry", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XGetGeometry", "Drawable");
  val = XGetGeometry(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), 
		     &root, &xr, &yr, &wr, &hr, &br, &dr);
  return(XEN_LIST_8(C_TO_XEN_INT(val),
		    C_TO_XEN_Window(root),
		    C_TO_XEN_INT(xr),
		    C_TO_XEN_INT(yr),
		    C_TO_XEN_ULONG(wr),
		    C_TO_XEN_ULONG(hr),
		    C_TO_XEN_ULONG(br),
		    C_TO_XEN_ULONG(dr)));
}

static XEN gxm_XGetGCValues(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XGetGCValues "Status XGetGCValues(display, gc, valuemask) returns the components specified by valuemask for the specified GC."
  /* DIFF: XGetGCValues omits and returns last arg
   */
  XGCValues *val;
  int rtn;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetGCValues", "Display*");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XGetGCValues", "GC");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XGetGCValues", "ulong");
  val = (XGCValues *)CALLOC(1, sizeof(XGCValues));
  rtn = XGetGCValues(XEN_TO_C_Display(arg1), XEN_TO_C_GC(arg2), XEN_TO_C_ULONG(arg3), val);
  return(XEN_LIST_2(C_TO_XEN_INT(rtn),
		    C_TO_XEN_XGCValues(val)));
}

static XEN gxm_XGetFontProperty(XEN arg1, XEN arg2)
{
  #define H_XGetFontProperty "Bool XGetFontProperty(font_struct, atom) returns the value of the specified font property. "
  /* DIFF: XGetFontProperty omits and rtns last arg
   */
  Bool val = False;
  unsigned long prop = 0;
  XEN_ASSERT_TYPE(XEN_XFontStruct_P(arg1), arg1, 1, "XGetFontProperty", "XFontStruct*");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg2), arg2, 2, "XGetFontProperty", "Atom");
  val = XGetFontProperty(XEN_TO_C_XFontStruct(arg1), XEN_TO_C_Atom(arg2), &prop);
  return(XEN_LIST_2(C_TO_XEN_BOOLEAN(val),
		    C_TO_XEN_ULONG(prop)));
}

static XEN gxm_XGetErrorText(XEN arg1, XEN arg2, XEN ignore, XEN arg4)
{
  #define H_XGetErrorText "XGetErrorText(display, code, buffer_return, length) copies a null-terminated string describing the specified error \
code into the specified buffer."
  /* DIFF: XGetErrorText ignores arg3, returns text
   */
  char *buf;
  int len, val;
  XEN str;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetErrorText", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XGetErrorText", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XGetErrorText", "int");
  len = XEN_TO_C_INT(arg4);
  if (len <= 0) XEN_ASSERT_TYPE(0, arg4, 4, "XGetErrorText", "positive integer");
  buf = (char *)CALLOC(len, sizeof(char));
  val = XGetErrorText(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2), buf, len);
  str = C_TO_XEN_STRING(buf);
  FREE(buf);
  return(XEN_LIST_2(C_TO_XEN_INT(val),
		    str));
}

static XEN gxm_XGeometry(XEN args)
{
  #define H_XGeometry "int XGeometry(dpy, screen, position, default_position, bwidth, fwidth, fheight, xadder, yadder) calculates \
window geometry given user geometry string and default geometry"
  /* DIFF: XGetGeometry omits trailing 4 args and returns them
   */
  int x, y, w, h, val;
  XEN arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9;
  arg1 = XEN_LIST_REF(args, 0);
  arg2 = XEN_LIST_REF(args, 1);
  arg3 = XEN_LIST_REF(args, 2);
  arg4 = XEN_LIST_REF(args, 3);
  arg5 = XEN_LIST_REF(args, 4);
  arg6 = XEN_LIST_REF(args, 5);
  arg7 = XEN_LIST_REF(args, 6);
  arg8 = XEN_LIST_REF(args, 7);
  arg9 = XEN_LIST_REF(args, 8);
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGeometry", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XGeometry", "int");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3), arg3, 3, "XGeometry", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg4), arg4, 4, "XGeometry", "char*");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg5), arg5, 5, "XGeometry", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg6), arg6, 6, "XGeometry", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg7), arg7, 7, "XGeometry", "unsigned int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg8), arg8, 8, "XGeometry", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg9), arg9, 9, "XGeometry", "int");
  val = XGeometry(XEN_TO_C_Display(arg1), 
		  XEN_TO_C_INT(arg2), 
		  XEN_TO_C_STRING(arg3), 
		  XEN_TO_C_STRING(arg4), 
		  XEN_TO_C_ULONG(arg5), 
		  XEN_TO_C_ULONG(arg6), 
		  XEN_TO_C_ULONG(arg7), 
		  XEN_TO_C_INT(arg8), 
		  XEN_TO_C_INT(arg9), 
		  &x, &y, &w, &h);
  return(XEN_LIST_5(C_TO_XEN_INT(val),
		    C_TO_XEN_INT(x),
		    C_TO_XEN_INT(y),
		    C_TO_XEN_INT(w),
		    C_TO_XEN_INT(h)));
}

static XEN gxm_XFreePixmap(XEN arg1, XEN arg2)
{
  #define H_XFreePixmap "XFreePixmap(display, pixmap) first deletes the association between the pixmap ID and the pixmap."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XFreePixmap", "Display*");
  XEN_ASSERT_TYPE(XEN_Pixmap_P(arg2), arg2, 2, "XFreePixmap", "Pixmap");
  return(C_TO_XEN_INT(XFreePixmap(XEN_TO_C_Display(arg1), XEN_TO_C_Pixmap(arg2))));
}

static XEN gxm_XFreeModifiermap(XEN arg1)
{
  #define H_XFreeModifiermap "XFreeModifiermap(modmap) frees the specified XModifierKeymap structure."
  XEN_ASSERT_TYPE(XEN_XModifierKeymap_P(arg1), arg1, 1, "XFreeModifiermap", "XModifierKeymap*");
  return(C_TO_XEN_INT(XFreeModifiermap(XEN_TO_C_XModifierKeymap(arg1))));
}

static XEN gxm_XFreeGC(XEN arg1, XEN arg2)
{
  #define H_XFreeGC "XFreeGC(display, gc) destroys the specified GC as well as all the associated storage."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XFreeGC", "Display*");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XFreeGC", "GC");
  return(C_TO_XEN_INT(XFreeGC(XEN_TO_C_Display(arg1), XEN_TO_C_GC(arg2))));
}

static XEN gxm_XFreeFontPath(XEN ignore)
{
  #define H_XFreeFontPath "XFreeFontPath(list) frees the data allocated by XGetFontPath (a no-op in xm)."
  /* DIFF: XFreeFontPath is no-op
   */
  return(XEN_FALSE);
}

static XEN gxm_XFreeFontNames(XEN ignore)
{
  #define H_XFreeFontNames "XFreeFontNames(list) frees the array and strings returned by XListFonts or XListFontsWithInfo (a no-op in xm)."
  /* DIFF: XFreeFontNames is no-op
   */
  return(XEN_FALSE);
}

static XEN gxm_XFreeFontInfo(XEN ignore1, XEN ignore2, XEN ignore3)
{
  #define H_XFreeFontInfo "XFreeFontInfo(names, free_info, actual_count) frees a font structure or an array of font structures, and \
optionally an array of font names (a no-op in xm)."
  /* DIFF: XFreeFontInfo is a no-op 
   */
  return(XEN_FALSE);
}

static XEN gxm_XFreeFont(XEN arg1, XEN arg2)
{
  #define H_XFreeFont "XFreeFont(display, font_struct) deletes the association between the font resource ID and the specified font and \
frees the XFontStruct structure."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XFreeFont", "Display*");
  XEN_ASSERT_TYPE(XEN_XFontStruct_P(arg2), arg2, 2, "XFreeFont", "XFontStruct*");
  return(C_TO_XEN_INT(XFreeFont(XEN_TO_C_Display(arg1), XEN_TO_C_XFontStruct(arg2))));
}

static XEN gxm_XFreeExtensionList(XEN ignore)
{
  /* DIFF: XFreeExtensionList is a no-op
   */
  return(XEN_FALSE);
}

static XEN gxm_XFreeCursor(XEN arg1, XEN arg2)
{
  #define H_XFreeCursor "XFreeCursor(display, cursor) deletes the association between the cursor resource ID and the specified cursor."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XFreeCursor", "Display*");
  XEN_ASSERT_TYPE(XEN_Cursor_P(arg2), arg2, 2, "XFreeCursor", "Cursor");
  return(C_TO_XEN_INT(XFreeCursor(XEN_TO_C_Display(arg1), XEN_TO_C_Cursor(arg2))));
}

static XEN gxm_XFreeColors(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XFreeColors "XFreeColors(display, colormap, pixels, npixels, planes) frees the cells represented by pixels whose values are in the pixels array."
  /* DIFF: XFreeColors pixel array (arg3) is list of pixels
   */
  unsigned long *ps;
  int len, val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XFreeColors", "Display*");
  XEN_ASSERT_TYPE(XEN_Colormap_P(arg2), arg2, 2, "XFreeColors", "Colormap");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg3), arg3, 3, "XFreeColors", "list of pixel");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XFreeColors", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg5), arg5, 5, "XFreeColors", "ulong");
  len = XEN_TO_C_INT(arg4);
  if (len <= 0) return(XEN_FALSE);
  ps = XEN_TO_C_Pixels(arg3, len);
  val = XFreeColors(XEN_TO_C_Display(arg1), 
		    XEN_TO_C_Colormap(arg2), 
		    ps, len, 
		    XEN_TO_C_ULONG(arg5));
  FREE(ps);
  return(C_TO_XEN_INT(val));
}

static XEN gxm_XFreeColormap(XEN arg1, XEN arg2)
{
  #define H_XFreeColormap "XFreeColormap(display, colormap) deletes the association between the colormap resource ID and the colormap and \
frees the colormap storage."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XFreeColormap", "Display*");
  XEN_ASSERT_TYPE(XEN_Colormap_P(arg2), arg2, 2, "XFreeColormap", "Colormap");
  return(C_TO_XEN_INT(XFreeColormap(XEN_TO_C_Display(arg1), XEN_TO_C_Colormap(arg2))));
}

static XEN gxm_XFree(XEN arg1)
{
  #define H_XFree "XFree(data) is a general-purpose Xlib routine that frees the specified data."
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg1) || XEN_LIST_P(arg1), arg1, 1, "XFree", "void* or xm entity");
  if (XEN_LIST_P(arg1))
    XFree((void *)XEN_TO_C_ULONG(XEN_CADR(arg1)));
  else XFree((void *)XEN_TO_C_ULONG(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XForceScreenSaver(XEN arg1, XEN arg2)
{
  #define H_XForceScreenSaver "XForceScreenSaver(display, mode) activates the screen saver"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XForceScreenSaver", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XForceScreenSaver", "int");
  return(C_TO_XEN_INT(XForceScreenSaver(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XFlush(XEN arg1)
{
  #define H_XFlush "XFlush(display) flushes the output buffer."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XFlush", "Display*");
  return(C_TO_XEN_INT(XFlush(XEN_TO_C_Display(arg1))));
}


static XEN gxm_XFillRectangles(XEN arg1, XEN arg2, XEN arg3, XEN larg4, XEN arg5)
{
  #define H_XFillRectangles "XFillRectangles(display, d, gc, rectangles, nrectangles)"
  /* DIFF: XFillRectangles XRectangle* arg (arg 4) is list of XRectangles
   */
  XRectangle *pt;
  int i, len;
  XEN arg4;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XFillRectangles", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XFillRectangles", "Drawable");
  XEN_ASSERT_TYPE(XEN_GC_P(arg3), arg3, 3, "XFillRectangles", "GC");
  XEN_ASSERT_TYPE(XEN_LIST_P(larg4), larg4, 4, "XFillRectangles", "list of XRectangle");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XFillRectangles", "int");
  arg4 = XEN_COPY_ARG(larg4);
  len = XEN_TO_C_INT(arg5);
  if (len <= 0) XEN_ASSERT_TYPE(0, arg5, 5, "XFillRectangles", "positive integer");
  pt = (XRectangle *)CALLOC(len, sizeof(XRectangle));
  for (i = 0; (i < len) && (XEN_NOT_NULL_P(arg4)); i++, arg4 = XEN_CDR(arg4))
    {
      XRectangle *pt1;
      pt1 = XEN_TO_C_XRectangle(XEN_CAR(arg4));
      pt[i].x = pt1->x;
      pt[i].y = pt1->y;
      pt[i].width = pt1->width;
      pt[i].height = pt1->height;
    }
  XFillRectangles(XEN_TO_C_Display(arg1), 
		  XEN_TO_C_Window(arg2), 
		  XEN_TO_C_GC(arg3),
		  pt, len);
  FREE(pt);
  return(C_TO_XEN_INT(len));
}

static XEN gxm_XFillRectangle(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7)
{
  #define H_XFillRectangle "XFillRectangle(display, d, gc, x, y, width, height)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XFillRectangle", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XFillRectangle", "Drawable");
  XEN_ASSERT_TYPE(XEN_GC_P(arg3), arg3, 3, "XFillRectangle", "GC");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XFillRectangle", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XFillRectangle", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg6), arg6, 6, "XFillRectangle", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg7), arg7, 7, "XFillRectangle", "unsigned int");
  return(C_TO_XEN_INT(XFillRectangle(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), 
				     XEN_TO_C_GC(arg3), XEN_TO_C_INT(arg4), XEN_TO_C_INT(arg5), 
				     XEN_TO_C_ULONG(arg6), XEN_TO_C_ULONG(arg7))));
}

static XEN gxm_XFillPolygon(XEN arg1, XEN arg2, XEN arg3, XEN larg4, XEN arg5, XEN arg6, XEN arg7)
{
  #define H_XFillPolygon "XFillPolygon(display, d, gc, points, npoints, shape, mode)"
  /* DIFF: XFillPolygon Point* arg (arg 4) is list of XPoint
   */
  XPoint *pt, *pt1;
  int i, len;
  XEN arg4;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XFillPolygon", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XFillPolygon", "Drawable");
  XEN_ASSERT_TYPE(XEN_GC_P(arg3), arg3, 3, "XFillPolygon", "GC");
  XEN_ASSERT_TYPE(XEN_LIST_P(larg4), larg4, 4, "XFillPolygon", "list of XPoints");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XFillPolygon", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XFillPolygon", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg7), arg7, 7, "XFillPolygon", "int");
  arg4 = XEN_COPY_ARG(larg4);
  len = XEN_TO_C_INT(arg5);
  if (len <= 0) XEN_ASSERT_TYPE(0, arg5, 5, "XFillPolygon", "positive integer");
  pt = (XPoint *)CALLOC(len, sizeof(XPoint));
  for (i = 0; (i < len) && (XEN_NOT_NULL_P(arg4)); i++, arg4 = XEN_CDR(arg4))
    {
      XEN xp;
      xp = XEN_CAR(arg4);
      if (!(XEN_XPoint_P(xp))) XEN_ASSERT_TYPE(0, xp, i, "XFillRegion", "XPoint");
      pt1 = XEN_TO_C_XPoint(xp);
      pt[i].x = pt1->x;
      pt[i].y = pt1->y;
    }
  XFillPolygon(XEN_TO_C_Display(arg1), 
	       XEN_TO_C_Window(arg2), 
	       XEN_TO_C_GC(arg3), 
	       pt, len, 
	       XEN_TO_C_INT(arg6), 
	       XEN_TO_C_INT(arg7));
  FREE(pt);
  return(C_TO_XEN_INT(len));
}

static XEN gxm_XFillArcs(XEN arg1, XEN arg2, XEN arg3, XEN larg4, XEN arg5)
{
  #define H_XFillArcs "XFillArcs(display, d, gc, arcs, narcs)"
  /* DIFF: XFillArcs Arc* arg (arg 4) is list of XArcs
   */
  int i, len;
  Display *dpy;
  Drawable draw;
  GC gc;
  XEN arg4;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XFillArcs", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XFillArcs", "Drawable");
  XEN_ASSERT_TYPE(XEN_GC_P(arg3), arg3, 3, "XFillArcs", "GC");
  XEN_ASSERT_TYPE(XEN_LIST_P(larg4), larg4, 4, "XFillArcs", "list of XArcs");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XFillArcs", "int");
  arg4 = XEN_COPY_ARG(larg4);
  len = XEN_TO_C_INT(arg5);
  if (len <= 0) return(XEN_FALSE);
  dpy = XEN_TO_C_Display(arg1);
  draw = XEN_TO_C_Window(arg2);
  gc = XEN_TO_C_GC(arg3);
  for (i = 0; (i < len) && (XEN_NOT_NULL_P(arg4)); i++, arg4 = XEN_CDR(arg4))
    {
      XArc *arc;
      arc = XEN_TO_C_XArc(XEN_CAR(arg4));
      XFillArc(dpy, draw, gc, arc->x, arc->y, arc->width, arc->height, arc->angle1, arc->angle2);
    }
  return(C_TO_XEN_INT(len));
}

static XEN gxm_XFillArc(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7, XEN arg8, XEN arg9)
{
  #define H_XFillArc "XFillArc(display, d, gc, x, y, width, height, angle1, angle2) fills the region described by the specified arc."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XFillArc", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XFillArc", "Drawable");
  XEN_ASSERT_TYPE(XEN_GC_P(arg3), arg3, 3, "XFillArc", "GC");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XFillArc", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XFillArc", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg6), arg6, 6, "XFillArc", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg7), arg7, 7, "XFillArc", "unsigned int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg8), arg8, 8, "XFillArc", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg9), arg9, 9, "XFillArc", "int");
  return(C_TO_XEN_INT(XFillArc(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), 
			       XEN_TO_C_GC(arg3), XEN_TO_C_INT(arg4), XEN_TO_C_INT(arg5), 
			       XEN_TO_C_ULONG(arg6), XEN_TO_C_ULONG(arg7), 
			       XEN_TO_C_INT(arg8), XEN_TO_C_INT(arg9))));
}

static XEN gxm_XFetchName(XEN arg1, XEN arg2)
{
  #define H_XFetchName "Status XFetchName(display, w) returns the name of the specified window."
  /* DIFF: XFetchName omits and rtns arg3
   */
  char *name;
  int val;
  XEN str;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XFetchName", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XFetchName", "Window");
  val = XFetchName(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), &name);
  if (val == 0)
    return(XEN_FALSE);
  str = C_TO_XEN_STRING(name);
  free(name);
  return(str);
}

static XEN gxm_XEventsQueued(XEN arg1, XEN arg2)
{
  #define H_XEventsQueued "int XEventsQueued(display, mode)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XEventsQueued", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XEventsQueued", "int");
  return(C_TO_XEN_INT(XEventsQueued(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XEnableAccessControl(XEN arg1)
{
  #define H_XEnableAccessControl "XEnableAccessControl(display) enables the use of the access control list at each connection setup."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XEnableAccessControl", "Display*");
  return(C_TO_XEN_INT(XEnableAccessControl(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XDrawText(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7)
{
  #define H_XDrawText "XDrawText(display, d, gc, x, y, items, nitems) draws text"
  int i, len = 0, res;
  XTextItem *items;
  XEN lst;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDrawText", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XDrawText", "Drawable");
  XEN_ASSERT_TYPE(XEN_GC_P(arg3), arg3, 3, "XDrawText", "GC");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XDrawText", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XDrawText", "int");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg6), arg6, 6, "XDrawText", "list of XTextItem");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg7), arg7, 7, "XDrawText", "int");
  lst = XEN_COPY_ARG(arg6);
  if (XEN_INTEGER_P(arg7)) len = XEN_TO_C_INT(arg7); else len = XEN_LIST_LENGTH(arg6);
  items = (XTextItem *)CALLOC(len, sizeof(XTextItem));
  for (i = 0; (i < len) && (XEN_NOT_NULL_P(lst)); i++, lst = XEN_CDR(lst))
    {
      XTextItem *val;
      val = XEN_TO_C_XTextItem(XEN_CAR(lst));
      items[i].chars = val->chars;
      items[i].nchars = val->nchars;
      items[i].delta = val->delta;
      items[i].font = val->font;
    }
  res = XDrawText(XEN_TO_C_Display(arg1), 
		  XEN_TO_C_Window(arg2), 
		  XEN_TO_C_GC(arg3), 
		  XEN_TO_C_INT(arg4), XEN_TO_C_INT(arg5), 
		  items, len);
  FREE(items);
  return(C_TO_XEN_INT(res));
}

static XEN gxm_XDrawString(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7)
{
  #define H_XDrawString "XDrawString(display, d, gc, x, y, string, length)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDrawString", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XDrawString", "Drawable");
  XEN_ASSERT_TYPE(XEN_GC_P(arg3), arg3, 3, "XDrawString", "GC");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XDrawString", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XDrawString", "int");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg6), arg6, 6, "XDrawString", "char*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg7), arg7, 7, "XDrawString", "int");
  return(C_TO_XEN_INT(XDrawString(XEN_TO_C_Display(arg1), 
				  XEN_TO_C_Window(arg2), 
				  XEN_TO_C_GC(arg3), 
				  XEN_TO_C_INT(arg4), XEN_TO_C_INT(arg5), 
				  XEN_TO_C_STRING(arg6), XEN_TO_C_INT(arg7))));
}

static XEN gxm_XDrawSegments(XEN arg1, XEN arg2, XEN arg3, XEN larg4, XEN arg5)
{
  #define H_XDrawSegments "XDrawSegments(display, d, gc, segments, nsegments) draws multiple, unconnected lines. "
  /* DIFF: XDrawSegments XSegment* arg (arg 4) is list of XSegments
   */
  XSegment *pt;
  int i, len;
  XEN arg4;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDrawSegments", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XDrawSegments", "Drawable");
  XEN_ASSERT_TYPE(XEN_GC_P(arg3), arg3, 3, "XDrawSegments", "GC");
  XEN_ASSERT_TYPE(XEN_LIST_P(larg4), larg4, 4, "XDrawSegments", "list of XSegments");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XDrawSegments", "int");
  arg4 = XEN_COPY_ARG(larg4);
  len = XEN_TO_C_INT(arg5);
  if (len <= 0) XEN_ASSERT_TYPE(0, arg5, 5, "XDrawSegments", "positive integer");
  pt = (XSegment *)CALLOC(len, sizeof(XSegment));
  for (i = 0; (i < len) && (XEN_NOT_NULL_P(arg4)); i++, arg4 = XEN_CDR(arg4))
    {
      XSegment *pt1;
      pt1 = XEN_TO_C_XSegment(XEN_CAR(arg4));
      pt[i].x1 = pt1->x1;
      pt[i].y1 = pt1->y1;
      pt[i].x2 = pt1->x2;
      pt[i].y2 = pt1->y2;
    }
  XDrawSegments(XEN_TO_C_Display(arg1), 
		XEN_TO_C_Window(arg2), 
		XEN_TO_C_GC(arg3),
		pt, len);
  FREE(pt);
  return(C_TO_XEN_INT(len));
}

static XEN gxm_XDrawRectangles(XEN arg1, XEN arg2, XEN arg3, XEN larg4, XEN arg5)
{
  #define H_XDrawRectangles "XDrawRectangles(display, d, gc, rectangles, nrectangles) draws the outlines of the specified rectangles."
  /* DIFF: XDrawRectangles XRectangle* arg (arg 4) is list of XRectangles
   */
  XRectangle *pt;
  int i, len;
  XEN arg4;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDrawRectangles", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XDrawRectangles", "Drawable");
  XEN_ASSERT_TYPE(XEN_GC_P(arg3), arg3, 3, "XDrawRectangles", "GC");
  XEN_ASSERT_TYPE(XEN_LIST_P(larg4), larg4, 4, "XDrawRectangles", "list of XRectangles");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XDrawRectangles", "int");
  arg4 = XEN_COPY_ARG(larg4);
  len = XEN_TO_C_INT(arg5);
  if (len <= 0) XEN_ASSERT_TYPE(0, arg5, 5, "XDrawRectangles", "positive integer");
  pt = (XRectangle *)CALLOC(len, sizeof(XRectangle));
  for (i = 0; (i < len) && (XEN_NOT_NULL_P(arg4)); i++, arg4 = XEN_CDR(arg4))
    {
      XRectangle *pt1;
      pt1 = XEN_TO_C_XRectangle(XEN_CAR(arg4));
      pt[i].x = pt1->x;
      pt[i].y = pt1->y;
      pt[i].width = pt1->width;
      pt[i].height = pt1->height;
    }
  XDrawRectangles(XEN_TO_C_Display(arg1), 
		  XEN_TO_C_Window(arg2), 
		  XEN_TO_C_GC(arg3),
		  pt, len);
  FREE(pt);
  return(C_TO_XEN_INT(len));
}

static XEN gxm_XDrawRectangle(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7)
{
  #define H_XDrawRectangle "XDrawRectangle(display, d, gc, x, y, width, height) draws the outlines of the specified rectangle."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDrawRectangle", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XDrawRectangle", "Drawable");
  XEN_ASSERT_TYPE(XEN_GC_P(arg3), arg3, 3, "XDrawRectangle", "GC");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XDrawRectangle", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XDrawRectangle", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg6), arg6, 6, "XDrawRectangle", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg7), arg7, 7, "XDrawRectangle", "unsigned int");
  return(C_TO_XEN_INT(XDrawRectangle(XEN_TO_C_Display(arg1), 
				     XEN_TO_C_Window(arg2), 
				     XEN_TO_C_GC(arg3), 
				     XEN_TO_C_INT(arg4), XEN_TO_C_INT(arg5), XEN_TO_C_ULONG(arg6), XEN_TO_C_ULONG(arg7))));
}

static XEN gxm_XDrawPoints(XEN arg1, XEN arg2, XEN arg3, XEN larg4, XEN arg5, XEN arg6)
{
  #define H_XDrawPoints "XDrawPoints(display, d, gc, points, npoints, mode) draws multiple points."
  /* DIFF: XDrawPoints XPoint* arg (arg 4) is list of XPoints
   */
  XPoint *pt, *pt1;
  int i, len;
  XEN arg4;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDrawPoints", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XDrawPoints", "Drawable");
  XEN_ASSERT_TYPE(XEN_GC_P(arg3), arg3, 3, "XDrawPoints", "GC");
  XEN_ASSERT_TYPE(XEN_LIST_P(larg4), larg4, 4, "XDrawPoints", "list of XPoints");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XDrawPoints", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XDrawPoints", "int");
  arg4 = XEN_COPY_ARG(larg4);
  len = XEN_TO_C_INT(arg5);
  if (len <= 0) XEN_ASSERT_TYPE(0, arg5, 5, "XDrawPoints", "positive integer");
  pt = (XPoint *)CALLOC(len, sizeof(XPoint));
  for (i = 0; (i < len) && (XEN_NOT_NULL_P(arg4)); i++, arg4 = XEN_CDR(arg4))
    {
      XEN xp;
      xp = XEN_CAR(arg4);
      if (!(XEN_XPoint_P(xp))) XEN_ASSERT_TYPE(0, xp, i, "XDrawPoints", "XPoint");
      pt1 = XEN_TO_C_XPoint(xp);
      pt[i].x = pt1->x;
      pt[i].y = pt1->y;
    }
  XDrawPoints(XEN_TO_C_Display(arg1), 
	      XEN_TO_C_Window(arg2), 
	      XEN_TO_C_GC(arg3), 
	      pt, len, 
	      XEN_TO_C_INT(arg6));
  FREE(pt);
  return(C_TO_XEN_INT(len));
}

static XEN gxm_XDrawPoint(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XDrawPoint "XDrawPoint(display, d, gc, x, y) uses the foreground pixel and function components of the GC to draw a single \
point into the specified drawable."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDrawPoint", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XDrawPoint", "Drawable");
  XEN_ASSERT_TYPE(XEN_GC_P(arg3), arg3, 3, "XDrawPoint", "GC");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XDrawPoint", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XDrawPoint", "int");
  return(C_TO_XEN_INT(XDrawPoint(XEN_TO_C_Display(arg1), 
				 XEN_TO_C_Window(arg2), 
				 XEN_TO_C_GC(arg3), 
				 XEN_TO_C_INT(arg4), XEN_TO_C_INT(arg5))));
}

static XEN gxm_XDrawLines(XEN arg1, XEN arg2, XEN arg3, XEN larg4, XEN arg5, XEN arg6)
{
  #define H_XDrawLines "XDrawLines(display, d, gc, points, npoints, mode) uses the components of the specified GC to draw npoints lines \
between each pair of points (point[i], point[i+1]) in the array of XPoint structures."
  /* DIFF: XDrawLines XPoint* arg (arg 4) is list of XPoints
   */
  XPoint *pt, *pt1;
  int i, len;
  XEN arg4;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDrawLines", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XDrawLines", "Drawable");
  XEN_ASSERT_TYPE(XEN_GC_P(arg3), arg3, 3, "XDrawLines", "GC");
  XEN_ASSERT_TYPE(XEN_LIST_P(larg4), larg4, 4, "XDrawLines", "list of XPoints");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XDrawLines", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XDrawLines", "int");
  arg4 = XEN_COPY_ARG(larg4);
  len = XEN_TO_C_INT(arg5);
  if (len <= 0) XEN_ASSERT_TYPE(0, arg5, 5, "XDrawLines", "positive integer");
  pt = (XPoint *)CALLOC(len, sizeof(XPoint));
  for (i = 0; (i < len) && (XEN_NOT_NULL_P(arg4)); i++, arg4 = XEN_CDR(arg4))
    {
      XEN xp;
      xp = XEN_CAR(arg4);
      if (!(XEN_XPoint_P(xp))) XEN_ASSERT_TYPE(0, xp, i, "XDrawLines", "XPoint");
      pt1 = XEN_TO_C_XPoint(xp);
      pt[i].x = pt1->x;
      pt[i].y = pt1->y;
    }
  XDrawLines(XEN_TO_C_Display(arg1), 
	     XEN_TO_C_Window(arg2), 
	     XEN_TO_C_GC(arg3), 
	     pt, len, 
	     XEN_TO_C_INT(arg6));
  FREE(pt);
  return(C_TO_XEN_INT(len));
}

static XEN gxm_XDrawLinesDirect(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6)
{
  #define H_XDrawLinesDirect "XDrawLinesDirect is the same as XDrawLines but takes an (opaque) pointer to an XPoint array"
  XPoint *pt;
  int len;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDrawLinesDirect", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XDrawLinesDirect", "Drawable");
  XEN_ASSERT_TYPE(XEN_GC_P(arg3), arg3, 3, "XDrawLinesDirect", "GC");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg4), arg4, 4, "XDrawLinesDirect", "array of XPoints");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XDrawLines", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XDrawLines", "int");
  len = XEN_TO_C_INT(arg5);
  if (len <= 0) return(XEN_FALSE);
  pt = (XPoint *)XEN_TO_C_ULONG(arg4);
  XDrawLines(XEN_TO_C_Display(arg1), 
	     XEN_TO_C_Window(arg2), 
	     XEN_TO_C_GC(arg3), 
	     pt, len, 
	     XEN_TO_C_INT(arg6));
  return(C_TO_XEN_INT(len));
}

static XEN gxm_Vector2XPoints(XEN arg1)
{
  #define H_vector2XPoints "(vector->XPoints vect) packages point data in vect as (opaque) array of XPoints"
  int i, j, len;
  /* vector assumed to be sequence of x y pairs (not XPoints from local view)
   */
  XPoint *pt;
  XEN_ASSERT_TYPE(XEN_VECTOR_P(arg1), arg1, XEN_ONLY_ARG, "vector->XPoints", "vector of x,y values");
  len = XEN_VECTOR_LENGTH(arg1) / 2;
  if (len <= 0) XEN_ASSERT_TYPE(0, arg1, 1, "vector->XPoints", "positive integer");
  pt = (XPoint *)CALLOC(len, sizeof(XPoint));
  for (i = 0, j = 0; i < len; i++, j += 2)
    {
      pt[i].x = XEN_TO_C_INT(XEN_VECTOR_REF(arg1, j));
      pt[i].y = XEN_TO_C_INT(XEN_VECTOR_REF(arg1, j + 1));
    }
  return(C_TO_XEN_ULONG((unsigned long)pt));
}

static XEN gxm_FreeXPoints(XEN arg1)
{
  void *pts;
  #define H_freeXPoints "(freeXPoints vect) frees an (opaque) XPoint array created by vector->Xpoints"
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg1), arg1, XEN_ONLY_ARG, "freeXPoints", "opaque XPoint array");
  pts = (void *)(XEN_TO_C_ULONG(arg1));
  FREE(pts);
  return(XEN_FALSE);
}


static XEN gxm_XDrawLine(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7)
{
  #define H_XDrawLine "XDrawLine(display, d, gc, x1, y1, x2, y2) uses the components of the specified GC to draw a line between the \
specified set of points (x1, y1) and (x2, y2)."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDrawLine", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XDrawLine", "Drawable");
  XEN_ASSERT_TYPE(XEN_GC_P(arg3), arg3, 3, "XDrawLine", "GC");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XDrawLine", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XDrawLine", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XDrawLine", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg7), arg7, 7, "XDrawLine", "int");
  return(C_TO_XEN_INT(XDrawLine(XEN_TO_C_Display(arg1), 
				XEN_TO_C_Window(arg2), 
				XEN_TO_C_GC(arg3), 
				XEN_TO_C_INT(arg4), XEN_TO_C_INT(arg5), XEN_TO_C_INT(arg6), XEN_TO_C_INT(arg7))));
}

static XEN gxm_XDrawImageString(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7)
{
  #define H_XDrawImageString "XDrawImageString(display, d, gc, x, y, string, length)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDrawImageString", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XDrawImageString", "Drawable");
  XEN_ASSERT_TYPE(XEN_GC_P(arg3), arg3, 3, "XDrawImageString", "GC");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XDrawImageString", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XDrawImageString", "int");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg6), arg6, 6, "XDrawImageString", "char*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg7), arg7, 7, "XDrawImageString", "int");
  return(C_TO_XEN_INT(XDrawImageString(XEN_TO_C_Display(arg1), 
				       XEN_TO_C_Window(arg2), 
				       XEN_TO_C_GC(arg3), 
				       XEN_TO_C_INT(arg4), XEN_TO_C_INT(arg5), XEN_TO_C_STRING(arg6), XEN_TO_C_INT(arg7))));
}

static XEN gxm_XDrawArcs(XEN arg1, XEN arg2, XEN arg3, XEN larg4, XEN arg5)
{
  #define H_XDrawArcs "XDrawArcs(display, d, gc, arcs, narcs) draws multiple circular or elliptical arcs."
  /* DIFF: XDrawArcs Arc* arg (arg 4) is list of XArcs
   */
  int i, len;
  Display *dpy;
  Drawable draw;
  GC gc;
  XEN arg4;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDrawArcs", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XDrawArcs", "Drawable");
  XEN_ASSERT_TYPE(XEN_GC_P(arg3), arg3, 3, "XDrawArcs", "GC");
  XEN_ASSERT_TYPE(XEN_LIST_P(larg4), larg4, 4, "XDrawArcs", "list of XArcs");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XDrawArcs", "int");
  arg4 = XEN_COPY_ARG(larg4);
  len = XEN_TO_C_INT(arg5);
  dpy = XEN_TO_C_Display(arg1);
  draw = XEN_TO_C_Window(arg2);
  gc = XEN_TO_C_GC(arg3);
  for (i = 0; (i < len) && (XEN_NOT_NULL_P(arg4)); i++, arg4 = XEN_CDR(arg4))
    {
      XArc *arc;
      arc = XEN_TO_C_XArc(XEN_CAR(arg4));
      XDrawArc(dpy, draw, gc, arc->x, arc->y, arc->width, arc->height, arc->angle1, arc->angle2);
    }
  return(C_TO_XEN_INT(len));
}

static XEN gxm_XDrawArc(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7, XEN arg8, XEN arg9)
{
  #define H_XDrawArc "XDrawArc(display, d, gc, x, y, width, height, angle1, angle2) draws a single circular or elliptical arc."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDrawArc", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XDrawArc", "Drawable");
  XEN_ASSERT_TYPE(XEN_GC_P(arg3), arg3, 3, "XDrawArc", "GC");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XDrawArc", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XDrawArc", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg6), arg6, 6, "XDrawArc", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg7), arg7, 7, "XDrawArc", "unsigned int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg8), arg8, 8, "XDrawArc", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg9), arg9, 9, "XDrawArc", "int");
  return(C_TO_XEN_INT(XDrawArc(XEN_TO_C_Display(arg1), 
			       XEN_TO_C_Window(arg2), 
			       XEN_TO_C_GC(arg3), 
			       XEN_TO_C_INT(arg4), XEN_TO_C_INT(arg5), 
			       XEN_TO_C_ULONG(arg6), XEN_TO_C_ULONG(arg7), XEN_TO_C_INT(arg8), XEN_TO_C_INT(arg9))));
}

static XEN gxm_XDisplayWidthMM(XEN arg1, XEN arg2)
{
  #define H_DisplayWidthMM "DisplayWidthMM(display, screen_number) returns the width of the specified screen in millimeters."
  #define H_XDisplayWidthMM "XDisplayWidthMM(display, screen_number) returns the width of the specified screen in millimeters."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDisplayWidthMM", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XDisplayWidthMM", "int");
  return(C_TO_XEN_INT(XDisplayWidthMM(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XDisplayWidth(XEN arg1, XEN arg2)
{
  #define H_DisplayWidth "DisplayWidth(display, screen_number) returns the width of the screen in pixels."
  #define H_XDisplayWidth "XDisplayWidth(display, screen_number) returns the width of the screen in pixels."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDisplayWidth", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XDisplayWidth", "int");
  return(C_TO_XEN_INT(XDisplayWidth(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XDisplayPlanes(XEN arg1, XEN arg2)
{
  #define H_DisplayPlanes "DisplayPlanes(display, screen_number) returns the depth of the root window of the specified screen."
  #define H_XDisplayPlanes "XDisplayPlanes(display, screen_number) returns the depth of the root window of the specified screen."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDisplayPlanes", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XDisplayPlanes", "int");
  return(C_TO_XEN_INT(XDisplayPlanes(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XDisplayKeycodes(XEN arg1)
{
  #define H_XDisplayKeycodes "XDisplayKeycodes(display) returns the min-keycodes and max-keycodes supported by the specified display."
  /* DIFF: XDisplayKeycodes omit and rtn arg 2 and 3
   */
  int m1, m2, val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDisplayKeycodes", "Display*");
  val = XDisplayKeycodes(XEN_TO_C_Display(arg1), &m1, &m2);
  return(XEN_LIST_3(C_TO_XEN_INT(val),
		    C_TO_XEN_INT(m1),
		    C_TO_XEN_INT(m2)));
}

static XEN gxm_XDisplayHeightMM(XEN arg1, XEN arg2)
{
  #define H_DisplayHeightMM "DisplayHeightMM(display, screen_number) returns the height of the specified screen in millimeters."
  #define H_XDisplayHeightMM "XDisplayHeightMM(display, screen_number) returns the height of the specified screen in millimeters."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDisplayHeightMM", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XDisplayHeightMM", "int");
  return(C_TO_XEN_INT(XDisplayHeightMM(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XDisplayHeight(XEN arg1, XEN arg2)
{
  #define H_DisplayHeight "DisplayHeight(display, screen_number) returns the height of the specified screen in pixels."
  #define H_XDisplayHeight "XDisplayHeight(display, screen_number) returns the height of the specified screen in pixels."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDisplayHeight", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XDisplayHeight", "int");
  return(C_TO_XEN_INT(XDisplayHeight(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XDisplayCells(XEN arg1, XEN arg2)
{
  #define H_DisplayCells "DisplayCells(display, screen_number) returns the number of entries in the default colormap."
  #define H_XDisplayCells "XDisplayCells(display, screen_number) returns the number of entries in the default colormap."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDisplayCells", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XDisplayCells", "int");
  return(C_TO_XEN_INT(XDisplayCells(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XDisableAccessControl(XEN arg1)
{
  #define H_XDisableAccessControl "XDisableAccessControl(display) disables the use of the access control list at each connection setup."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDisableAccessControl", "Display*");
  return(C_TO_XEN_INT(XDisableAccessControl(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XDoesSaveUnders(XEN arg1)
{
  #define H_DoesSaveUnders "DoesSaveUnders(screen) returns a Boolean value indicating whether the screen supports save unders."
  #define H_XDoesSaveUnders "XDoesSaveUnders(screen) returns a Boolean value indicating whether the screen supports save unders."
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XDoesSaveUnders", "Screen*");
  return(C_TO_XEN_BOOLEAN(XDoesSaveUnders(XEN_TO_C_Screen(arg1))));
}

static XEN gxm_XDoesBackingStore(XEN arg1)
{
  #define H_DoesBackingStore "DoesBackingStore(screen) returns WhenMapped, NotUseful,or Always,which indicate whether the screen supports backing stores."
  #define H_XDoesBackingStore "XDoesBackingStore(screen) returns WhenMapped, NotUseful,or Always,which indicate whether the screen supports backing stores."
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XDoesBackingStore", "Screen*");
  return(C_TO_XEN_BOOLEAN(XDoesBackingStore(XEN_TO_C_Screen(arg1))));
}

static XEN gxm_XDestroySubwindows(XEN arg1, XEN arg2)
{
  #define H_XDestroySubwindows "XDestroySubwindows(display, w) destroys all inferior windows of the specified window, in bottom-to-top stacking order."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDestroySubwindows", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XDestroySubwindows", "Window");
  return(C_TO_XEN_INT(XDestroySubwindows(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2))));
}

static XEN gxm_XDestroyWindow(XEN arg1, XEN arg2)
{
  #define H_XDestroyWindow "XDestroyWindow(display, w) destroys the specified window as well as all of its subwindows and causes the X server \
to generate a DestroyNotify event for each window."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDestroyWindow", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XDestroyWindow", "Window");
  return(C_TO_XEN_INT(XDestroyWindow(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2))));
}

static XEN gxm_XDeleteProperty(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XDeleteProperty "XDeleteProperty(display, w, property) deletes the specified property only if the property was defined on the specified \
window and causes the X server to generate a PropertyNotify event on the window unless the property does not exist."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDeleteProperty", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XDeleteProperty", "Window");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg3), arg3, 3, "XDeleteProperty", "Atom");
  return(C_TO_XEN_INT(XDeleteProperty(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_Atom(arg3))));
}

static XEN gxm_XDefineCursor(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XDefineCursor "XDefineCursor(display, w, cursor)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDefineCursor", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XDefineCursor", "Window");
  XEN_ASSERT_TYPE(XEN_Cursor_P(arg3), arg3, 3, "XDefineCursor", "Cursor");
  return(C_TO_XEN_INT(XDefineCursor(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_Cursor(arg3))));
}

static XEN gxm_XDefaultScreen(XEN arg1)
{
  #define H_XDefaultScreen "XDefaultScreen(display)"
  #define H_XDefaultScreenOfDisplay "returns the default screen of the specified display."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDefaultScreen", "Display*");
  return(C_TO_XEN_INT(XDefaultScreen(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XDefaultDepthOfScreen(XEN arg1)
{
  #define H_DefaultDepthOfScreen "returns the default depth of the root window of the specified screen."
  #define H_XDefaultDepthOfScreen "returns the default depth of the root window of the specified screen."
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XDefaultDepthOfScreen", "Screen*");
  return(C_TO_XEN_INT(XDefaultDepthOfScreen(XEN_TO_C_Screen(arg1))));
}

static XEN gxm_XDefaultDepth(XEN arg1, XEN arg2)
{
  #define H_DefaultDepth "returns the depth (number of planes) of the default root window for the specified screen."
  #define H_XDefaultDepth "returns the depth (number of planes) of the default root window for the specified screen."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDefaultDepth", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XDefaultDepth", "int");
  return(C_TO_XEN_INT(XDefaultDepth(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XCopyPlane(XEN args)
{
  #define H_XCopyPlane "XCopyPlane(display, src, dest, gc, src_x, src_y, width, height, dest_x, dest_y, plane) uses a single bit plane of the \
specified source rectangle combined with the specified GC to modify the specified rectangle of dest."
  XEN arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11;
  arg1 = XEN_LIST_REF(args, 0);
  arg2 = XEN_LIST_REF(args, 1);
  arg3 = XEN_LIST_REF(args, 2);
  arg4 = XEN_LIST_REF(args, 3);
  arg5 = XEN_LIST_REF(args, 4);
  arg6 = XEN_LIST_REF(args, 5);
  arg7 = XEN_LIST_REF(args, 6);
  arg8 = XEN_LIST_REF(args, 7);
  arg9 = XEN_LIST_REF(args, 8);
  arg10 = XEN_LIST_REF(args, 9);
  arg11 = XEN_LIST_REF(args, 10);
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XCopyPlane", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XCopyPlane", "Drawable");
  XEN_ASSERT_TYPE(XEN_Window_P(arg3), arg3, 3, "XCopyPlane", "Drawable");
  XEN_ASSERT_TYPE(XEN_GC_P(arg4), arg4, 4, "XCopyPlane", "GC");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XCopyPlane", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XCopyPlane", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg7), arg7, 7, "XCopyPlane", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg8), arg8, 8, "XCopyPlane", "unsigned int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg9), arg9, 9, "XCopyPlane", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg10), arg10, 10, "XCopyPlane", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg11), arg11, 11, "XCopyPlane", "ulong");
  return(C_TO_XEN_INT(XCopyPlane(XEN_TO_C_Display(arg1), 
				 XEN_TO_C_Window(arg2), 
				 XEN_TO_C_Window(arg3), 
				 XEN_TO_C_GC(arg4), 
				 XEN_TO_C_INT(arg5), XEN_TO_C_INT(arg6), XEN_TO_C_ULONG(arg7), 
				 XEN_TO_C_ULONG(arg8), XEN_TO_C_INT(arg9), 
				 XEN_TO_C_INT(arg10), XEN_TO_C_ULONG(arg11))));
}

static XEN gxm_XCopyGC(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XCopyGC "XCopyGC(display, src, valuemask, dest) copies the specified components from the source GC to the destination GC."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XCopyGC", "Display*");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XCopyGC", "GC");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XCopyGC", "ulong");
  XEN_ASSERT_TYPE(XEN_GC_P(arg4), arg4, 4, "XCopyGC", "GC");
  return(C_TO_XEN_INT(XCopyGC(XEN_TO_C_Display(arg1), XEN_TO_C_GC(arg2), XEN_TO_C_ULONG(arg3), XEN_TO_C_GC(arg4))));
}

static XEN gxm_XCopyArea(XEN args)
{
  #define H_XCopyArea "XCopyArea(display, src, dest, gc, src_x, src_y, width, height, dest_x, dest_y) combines the specified rectangle of src \
with the specified rectangle of dest."
  XEN arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10;
  arg1 = XEN_LIST_REF(args, 0);
  arg2 = XEN_LIST_REF(args, 1);
  arg3 = XEN_LIST_REF(args, 2);
  arg4 = XEN_LIST_REF(args, 3);
  arg5 = XEN_LIST_REF(args, 4);
  arg6 = XEN_LIST_REF(args, 5);
  arg7 = XEN_LIST_REF(args, 6);
  arg8 = XEN_LIST_REF(args, 7);
  arg9 = XEN_LIST_REF(args, 8);
  arg10 = XEN_LIST_REF(args, 9);
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XCopyArea", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XCopyArea", "Drawable");
  XEN_ASSERT_TYPE(XEN_Window_P(arg3), arg3, 3, "XCopyArea", "Drawable");
  XEN_ASSERT_TYPE(XEN_GC_P(arg4), arg4, 4, "XCopyArea", "GC");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XCopyArea", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XCopyArea", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg7), arg7, 7, "XCopyArea", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg8), arg8, 8, "XCopyArea", "unsigned int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg9), arg9, 9, "XCopyArea", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg10), arg10, 10, "XCopyArea", "int");
  return(C_TO_XEN_INT(XCopyArea(XEN_TO_C_Display(arg1), 
				XEN_TO_C_Window(arg2), 
				XEN_TO_C_Window(arg3), 
				XEN_TO_C_GC(arg4), 
				XEN_TO_C_INT(arg5), XEN_TO_C_INT(arg6), XEN_TO_C_ULONG(arg7), 
				XEN_TO_C_ULONG(arg8), XEN_TO_C_INT(arg9), XEN_TO_C_INT(arg10))));
}

static XEN gxm_XConvertSelection(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6)
{
  #define H_XConvertSelection "void XConvertSelection(display, selection, target, property, requestor, time)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XConvertSelection", "Display*");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg2), arg2, 2, "XConvertSelection", "Atom");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg3), arg3, 3, "XConvertSelection", "Atom");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg4), arg4, 4, "XConvertSelection", "Atom");
  XEN_ASSERT_TYPE(XEN_Window_P(arg5), arg5, 5, "XConvertSelection", "Window");
  XEN_ASSERT_TYPE(XEN_Time_P(arg6), arg6, 6, "XConvertSelection", "Time");
  return(C_TO_XEN_INT(XConvertSelection(XEN_TO_C_Display(arg1), 
					XEN_TO_C_Atom(arg2), XEN_TO_C_Atom(arg3), XEN_TO_C_Atom(arg4), 
					XEN_TO_C_Window(arg5), XEN_TO_C_Time(arg6))));
}

static XEN gxm_XConnectionNumber(XEN arg1)
{
  #define H_XConnectionNumber "returns a connection number for the specified display."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XConnectionNumber", "Display*");
  return(C_TO_XEN_INT(XConnectionNumber(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XConfigureWindow(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XConfigureWindow "XConfigureWindow(display, w, value_mask, values) uses the values specified in the XWindowChanges structure to \
reconfigure a window's size, position, border, and stacking order."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XConfigureWindow", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XConfigureWindow", "Window");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XConfigureWindow", "unsigned int");
  XEN_ASSERT_TYPE(XEN_XWindowChanges_P(arg4), arg4, 4, "XConfigureWindow", "XWindowChanges*");
  return(C_TO_XEN_INT(XConfigureWindow(XEN_TO_C_Display(arg1), 
				       XEN_TO_C_Window(arg2), XEN_TO_C_ULONG(arg3), XEN_TO_C_XWindowChanges(arg4))));
}

static XEN gxm_XCloseDisplay(XEN arg1)
{
  #define H_XCloseDisplay "XCloseDisplay(display) closes the connection to the X server for the display specified in the Display structure and \
destroys all windows, resource IDs etc."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XCloseDisplay", "Display*");
  return(C_TO_XEN_INT(XCloseDisplay(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XClearWindow(XEN arg1, XEN arg2)
{
  #define H_XClearWindow "XClearWindow(display, w) clears the entire area in the specified window."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XClearWindow", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XClearWindow", "Window");
  return(C_TO_XEN_INT(XClearWindow(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2))));
}

static XEN gxm_XClearArea(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7)
{
  #define H_XClearArea "XClearArea(display, w, x, y, width, height, exposures) paints a rectangular area in the specified window according to the \
specified dimensions with the window's background pixel or pixmap."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XClearArea", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XClearArea", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XClearArea", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XClearArea", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg5), arg5, 5, "XClearArea", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg6), arg6, 6, "XClearArea", "unsigned int");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg7), arg7, 7, "XClearArea", "Bool");
  return(C_TO_XEN_INT(XClearArea(XEN_TO_C_Display(arg1), 
				 XEN_TO_C_Window(arg2), 
				 XEN_TO_C_INT(arg3), XEN_TO_C_INT(arg4), 
				 XEN_TO_C_ULONG(arg5), XEN_TO_C_ULONG(arg6), XEN_TO_C_BOOLEAN(arg7))));
}

static XEN gxm_XCirculateSubwindowsUp(XEN arg1, XEN arg2)
{
  #define H_XCirculateSubwindowsUp "XCirculateSubwindowsUp(display, w) raises the lowest mapped child of the specified window that is partially or \
completely occluded by another child."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XCirculateSubwindowsUp", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XCirculateSubwindowsUp", "Window");
  return(C_TO_XEN_INT(XCirculateSubwindowsUp(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2))));
}

static XEN gxm_XCirculateSubwindowsDown(XEN arg1, XEN arg2)
{
  #define H_XCirculateSubwindowsDown "XCirculateSubwindowsDown(display, w) lowers the highest mapped child of the specified window that partially or \
completely occludes another child."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XCirculateSubwindowsDown", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XCirculateSubwindowsDown", "Window");
  return(C_TO_XEN_INT(XCirculateSubwindowsDown(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2))));
}

static XEN gxm_XCirculateSubwindows(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XCirculateSubwindows "XCirculateSubwindows(display, w, direction) circulates children of the specified window in the specified direction."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XCirculateSubwindows", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XCirculateSubwindows", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XCirculateSubwindows", "int");
  return(C_TO_XEN_INT(XCirculateSubwindows(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_INT(arg3))));
}

static XEN gxm_XCheckWindowEvent(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XCheckWindowEvent "Bool XCheckWindowEvent(display, w, event_mask) searches the event queue and then the events available \
on the server connection for the first event that matches the specified window and event mask."
  /* DIFF: XCheckWindowEvent dpy win mask [ev] -> (list val ev)
   */
  XEvent *e;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XCheckWindowEvent", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XCheckWindowEvent", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XCheckWindowEvent", "long");
  e = (XEvent *)CALLOC(1, sizeof(XEvent));
  val = XCheckWindowEvent(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_INT(arg3), e);
  if (val)
    return(C_TO_XEN_XEvent_OBJ(e));
  else
    {
      FREE(e);
      return(XEN_FALSE);
    }
}

static XEN gxm_XCheckTypedWindowEvent(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XCheckTypedWindowEvent "Bool XCheckTypedWindowEvent(display, w, event_type) searches the event queue and then any events \
available on the server connection for the first event that matches the specified event mask"
  /* DIFF: XCheckTypedWindowEvent dpy win mask [ev] -> (list val ev)
   */
  XEvent *e;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XCheckTypedWindowEvent", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XCheckTypedWindowEvent", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XCheckTypedWindowEvent", "int");
  e = (XEvent *)CALLOC(1, sizeof(XEvent));
  val = XCheckTypedWindowEvent(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_INT(arg3), e);
  if (val)
    return(C_TO_XEN_XEvent_OBJ(e));
  else
    {
      FREE(e);
      return(XEN_FALSE);
    }
}

static XEN gxm_XCheckTypedEvent(XEN arg1, XEN arg2)
{
  #define H_XCheckTypedEvent "Bool XCheckTypedEvent(display, event_type) searches the event queue and then any events available  \
on the server connection for the first event that matches the specified type."
  /* DIFF: XCheckTypedEvent dpy mask [ev] -> (list val ev)
   */
  XEvent *e;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XCheckTypedEvent", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XCheckTypedEvent", "int");
  e = (XEvent *)CALLOC(1, sizeof(XEvent));
  val = XCheckTypedEvent(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2), e);
  if (val)
    return(C_TO_XEN_XEvent_OBJ(e));
  else
    {
      FREE(e);
      return(XEN_FALSE);
    }
}

static XEN gxm_XCheckMaskEvent(XEN arg1, XEN arg2)
{
  #define H_XCheckMaskEvent "Bool XCheckMaskEvent(display, event_mask) searches the event queue and then any events available on \
the server connection for the first event that matches the specified mask."
  /* DIFF: XCheckMaskEvent dpy mask [ev] -> (list val ev)
   */
  XEvent *e;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XCheckMaskEvent", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XCheckMaskEvent", "long");
  e = (XEvent *)CALLOC(1, sizeof(XEvent));
  val = XCheckMaskEvent(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2), e);
  if (val)
    return(C_TO_XEN_XEvent_OBJ(e));
  else
    {
      FREE(e);
      return(XEN_FALSE);
    }
}

static XEN gxm_XCheckIfEvent(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XCheckIfEvent "Bool XCheckIfEvent(display, predicate, arg)"
  /* DIFF: XCheckIfEvent dpy [ev] proc ptr -> (list val ev)
   */
  XEvent *e;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XCheckIfEvent", "Display*");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg2) && (XEN_REQUIRED_ARGS_OK(arg2, 3)), arg2, 2, "XCheckIfEvent", "(Bool_Proc dpy ev data)");
  e = (XEvent *)CALLOC(1, sizeof(XEvent));
  val = XCheckIfEvent(XEN_TO_C_Display(arg1), 
		      e, 
		      (Bool (*)(Display *d, XEvent *ev, char *p))gxm_XPeekIfEventProc, 
		      (char*)arg3);
  if (val)
    return(C_TO_XEN_XEvent_OBJ(e));
  else
    {
      FREE(e);
      return(XEN_FALSE);
    }
}

static XEN gxm_XChangeWindowAttributes(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XChangeWindowAttributes "XChangeWindowAttributes(display, w, valuemask, attributes) uses the window attributes in the XSetWindowAttributes \
structure to change the specified window attributes."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XChangeWindowAttributes", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XChangeWindowAttributes", "Window");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XChangeWindowAttributes", "ulong");
  XEN_ASSERT_TYPE(XEN_XSetWindowAttributes_P(arg4), arg4, 4, "XChangeWindowAttributes", "XSetWindowAttributes*");
  return(C_TO_XEN_INT(XChangeWindowAttributes(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_ULONG(arg3), 
					      XEN_TO_C_XSetWindowAttributes(arg4))));
}

static XEN gxm_XChangeProperty(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7, XEN arg8)
{
  #define H_XChangeProperty "XChangeProperty(display, w, property, type, format, mode, data, nelements) alters the property for the specified \
window and causes the X server to generate a PropertyNotify event on that window."
  unsigned char *command;
  int len;
  int *data = NULL;
  XEN rtn;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XChangeProperty", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XChangeProperty", "Window");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg3), arg3, 3, "XChangeProperty", "Atom");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg4), arg4, 4, "XChangeProperty", "Atom");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XChangeProperty", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XChangeProperty", "int");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg7) || XEN_LIST_P(arg7), arg7, 7, "XChangeProperty", "string or list of int");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg8), arg8, 8, "XChangeProperty", "int");
  if (XEN_STRING_P(arg7))
    {
      command = (unsigned char *)(XEN_TO_C_STRING(arg7));
      if (XEN_INTEGER_P(arg8)) len = XEN_TO_C_INT(arg8); else len = strlen((const char *)command) + 1;
    }
  else 
    {
      if (XEN_INTEGER_P(arg8)) len = XEN_TO_C_INT(arg8); else len = XEN_LIST_LENGTH(arg7);
      data = XEN_TO_C_Ints(arg7, len);
      command = (unsigned char *)data;
    }
  rtn = C_TO_XEN_INT(XChangeProperty(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), 
				     XEN_TO_C_Atom(arg3), XEN_TO_C_Atom(arg4), 
				     XEN_TO_C_INT(arg5), XEN_TO_C_INT(arg6), 
				     (const unsigned char *)command, len));
  if (data) FREE(data);
  return(xen_return_first(rtn, arg7));
}

static XEN gxm_XChangePointerControl(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6)
{
  #define H_XChangePointerControl "XChangePointerControl(display, do_accel, do_threshold, accel_numerator, accel_denominator, threshold) \
defines how the pointing device moves."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XChangePointerControl", "Display*");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg2), arg2, 2, "XChangePointerControl", "Bool");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg3), arg3, 3, "XChangePointerControl", "Bool");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XChangePointerControl", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XChangePointerControl", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XChangePointerControl", "int");
  return(C_TO_XEN_INT(XChangePointerControl(XEN_TO_C_Display(arg1), 
					    XEN_TO_C_BOOLEAN(arg2), XEN_TO_C_BOOLEAN(arg3), 
					    XEN_TO_C_INT(arg4), XEN_TO_C_INT(arg5), XEN_TO_C_INT(arg6))));
}

static XEN gxm_XChangeKeyboardMapping(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XChangeKeyboardMapping "XChangeKeyboardMapping(display, first_keycode, keysyms_per_keycode, keysyms, num_codes) defines the \
symbols for the specified number of KeyCodes starting with first_keycode."
  /* DIFF: XChangeKeyboardMapping takes list of KeySyms
   */
  KeySym *ks;
  int len, val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XChangeKeyboardMapping", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XChangeKeyboardMapping", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XChangeKeyboardMapping", "int");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg4), arg4, 4, "XChangeKeyboardMapping", "list of KeySym");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XChangeKeyboardMapping", "int");
  len = XEN_TO_C_INT(arg5);
  if (len <= 0) return(XEN_FALSE);
  ks = XEN_TO_C_KeySyms(arg4, len);
  val = XChangeKeyboardMapping(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_INT(arg3), ks, len);
  FREE(ks);
  return(C_TO_XEN_INT(val));
}

static XEN gxm_XChangeKeyboardControl(XEN arg1, XEN arg2, XEN larg3)
{
  #define H_XChangeKeyboardControl "XChangeKeyboardControl(display, value_mask, values) controls the keyboard characteristics defined by \
the XKeyboardControl structure."
  /* DIFF: XChangeKeyboardControl arg3 is list of XKeyboardControl fields
   */
  XEN arg3;
  XKeyboardControl kc;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XChangeKeyboardControl", "Display*");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XChangeKeyboardControl", "ulong");
  XEN_ASSERT_TYPE(XEN_LIST_P(larg3), larg3, 3, "XChangeKeyboardControl", "XKeyboardControl*");
  arg3 = XEN_COPY_ARG(larg3);
  kc.key_click_percent = XEN_TO_C_INT(XEN_CAR(arg3)); arg3 = XEN_CDR(arg3);
  if (!(XEN_NULL_P(arg3))) 
    {
      kc.bell_percent = XEN_TO_C_INT(XEN_CAR(arg3)); arg3 = XEN_CDR(arg3);
      if (!(XEN_NULL_P(arg3)))
	{
	  kc.bell_pitch = XEN_TO_C_INT(XEN_CAR(arg3)); arg3 = XEN_CDR(arg3);
	  if (!(XEN_NULL_P(arg3)))
	    {
	      kc.bell_duration = XEN_TO_C_INT(XEN_CAR(arg3)); arg3 = XEN_CDR(arg3);
	      if (!(XEN_NULL_P(arg3)))
		{
		  kc.led = XEN_TO_C_INT(XEN_CAR(arg3)); arg3 = XEN_CDR(arg3);
		  if (!(XEN_NULL_P(arg3)))
		    {
		      kc.led_mode = XEN_TO_C_INT(XEN_CAR(arg3)); arg3 = XEN_CDR(arg3);
		      if (!(XEN_NULL_P(arg3)))
			{
			  kc.key = XEN_TO_C_INT(XEN_CAR(arg3)); arg3 = XEN_CDR(arg3);
			  if (!(XEN_NULL_P(arg3)))
			    {
			      kc.auto_repeat_mode = XEN_TO_C_INT(XEN_CAR(arg3));
			    }}}}}}}
  return(C_TO_XEN_INT(XChangeKeyboardControl(XEN_TO_C_Display(arg1), XEN_TO_C_ULONG(arg2), &kc)));
}

static XEN gxm_XChangeGC(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XChangeGC "XChangeGC(display, gc, valuemask, values) changes the components specified by valuemask for the specified GC."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XChangeGC", "Display*");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XChangeGC", "GC");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XChangeGC", "ulong");
  XEN_ASSERT_TYPE(XEN_XGCValues_P(arg4), arg4, 4, "XChangeGC", "XGCValues*");
  return(C_TO_XEN_INT(XChangeGC(XEN_TO_C_Display(arg1), XEN_TO_C_GC(arg2), XEN_TO_C_ULONG(arg3), XEN_TO_C_XGCValues(arg4))));
}

static XEN gxm_XChangeActivePointerGrab(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XChangeActivePointerGrab "XChangeActivePointerGrab(display, event_mask, cursor, time) changes the specified dynamic parameters \
if the pointer is actively grabbed by the client and if the specified time is no earlier than the last-pointer-grab time and no later than \
the current X server time."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XChangeActivePointerGrab", "Display*");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XChangeActivePointerGrab", "unsigned int");
  XEN_ASSERT_TYPE(XEN_Cursor_P(arg3), arg3, 3, "XChangeActivePointerGrab", "Cursor");
  XEN_ASSERT_TYPE(XEN_Time_P(arg4), arg4, 4, "XChangeActivePointerGrab", "Time");
  return(C_TO_XEN_INT(XChangeActivePointerGrab(XEN_TO_C_Display(arg1), XEN_TO_C_ULONG(arg2), XEN_TO_C_Cursor(arg3), XEN_TO_C_Time(arg4))));
}

static XEN gxm_XCellsOfScreen(XEN arg1)
{
  #define H_CellsOfScreen "CellsOfScreen(screen) returns the number of colormap cells in the default colormap of the specified screen."
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XCellsOfScreen", "Screen*");
  return(C_TO_XEN_INT(XCellsOfScreen(XEN_TO_C_Screen(arg1))));
}

static XEN gxm_XBitmapUnit(XEN arg1)
{
  #define H_BitmapUnit "BitmapUnit(display) returns the size of a bitmap's scanline unit in bits."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XBitmapUnit", "Display*");
  return(C_TO_XEN_INT(XBitmapUnit(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XBitmapPad(XEN arg1)
{
  #define H_BitmapPad "BitmapPad(display) returns the number of bits that each scanline must be padded."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XBitmapPad", "Display*");
  return(C_TO_XEN_INT(XBitmapPad(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XBitmapBitOrder(XEN arg1)
{
  #define H_BitmapBitOrder "BitmapBitOrder(display) returns LSBFirst or MSBFirst to indicate whether the leftmost bit in the bitmap as \
displayed on the screen is the least or most significant bit in the unit."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XBitmapBitOrder", "Display*");
  return(C_TO_XEN_INT(XBitmapBitOrder(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XBell(XEN arg1, XEN arg2)
{
  #define H_XBell "XBell(display, percent) rings the bell on the keyboard on the specified display, if possible."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XBell", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XBell", "int");
  return(C_TO_XEN_INT(XBell(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XAutoRepeatOn(XEN arg1)
{
  #define H_XAutoRepeatOn "XAutoRepeatOn(display) turns on auto-repeat for the keyboard on the specified display."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XAutoRepeatOn", "Display*");
  return(C_TO_XEN_INT(XAutoRepeatOn(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XAutoRepeatOff(XEN arg1)
{
  #define H_XAutoRepeatOff "XAutoRepeatOff(display) turns off auto-repeat for the keyboard on the specified display."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XAutoRepeatOff", "Display*");
  return(C_TO_XEN_INT(XAutoRepeatOff(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XAllowEvents(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XAllowEvents "XAllowEvents(display, event_mode, time)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XAllowEvents", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XAllowEvents", "int");
  XEN_ASSERT_TYPE(XEN_Time_P(arg3), arg3, 3, "XAllowEvents", "Time");
  return(C_TO_XEN_INT(XAllowEvents(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_Time(arg3))));
}

static XEN gxm_XAllocNamedColor(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XAllocNamedColor "Status XAllocNamedColor(display, colormap, color_name, screen_def_return, exact_def_return) looks up the \
named color with respect to the screen that is associated with the specified colormap."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XAllocNamedColor", "Display*");
  XEN_ASSERT_TYPE(XEN_Colormap_P(arg2), arg2, 2, "XAllocNamedColor", "Colormap");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3), arg3, 3, "XAllocNamedColor", "char*");
  XEN_ASSERT_TYPE(XEN_XColor_P(arg4), arg4, 4, "XAllocNamedColor", "XColor");
  XEN_ASSERT_TYPE(XEN_XColor_P(arg5), arg5, 5, "XAllocNamedColor", "XColor");
  return(C_TO_XEN_INT(XAllocNamedColor(XEN_TO_C_Display(arg1), 
				       XEN_TO_C_Colormap(arg2), 
				       XEN_TO_C_STRING(arg3), 
				       XEN_TO_C_XColor(arg4), XEN_TO_C_XColor(arg5))));
}

static XEN gxm_XAllocColorPlanes(XEN args)
{
  #define H_XAllocColorPlanes "Status XAllocColorPlanes(display, colormap, contig, ncolors, nreds, ngreens, nblues)"
  /* DIFF: XAllocColorPlanes omits pixel array (arg4) and trailing 3 args, returns them and embedded list of pixels
   */
  unsigned long r,g,b;
  unsigned long *ps;
  int i, len, val;
  XEN lst = XEN_FALSE;
  XEN arg1, arg2, arg3, arg5, arg6, arg7, arg8;
  arg1 = XEN_LIST_REF(args, 0);
  arg2 = XEN_LIST_REF(args, 1);
  arg3 = XEN_LIST_REF(args, 2);
  arg5 = XEN_LIST_REF(args, 3);
  arg6 = XEN_LIST_REF(args, 4);
  arg7 = XEN_LIST_REF(args, 5);
  arg8 = XEN_LIST_REF(args, 6);
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XAllocColorPlanes", "Display*");
  XEN_ASSERT_TYPE(XEN_Colormap_P(arg2), arg2, 2, "XAllocColorPlanes", "Colormap");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg3), arg3, 3, "XAllocColorPlanes", "Bool");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XAllocColorPlanes", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XAllocColorPlanes", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg7), arg7, 7, "XAllocColorPlanes", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg8), arg8, 8, "XAllocColorPlanes", "int");
  len = XEN_TO_C_INT(arg5);
  if (len <= 0) XEN_ASSERT_TYPE(0, arg5, 5, "XAllocColorPlanes", "positive integer");
  ps = (unsigned long *)CALLOC(len, sizeof(unsigned long));
  val = XAllocColorPlanes(XEN_TO_C_Display(arg1), 
			  XEN_TO_C_Colormap(arg2), 
			  XEN_TO_C_BOOLEAN(arg3), 
			  ps, len, 
			  XEN_TO_C_INT(arg6), XEN_TO_C_INT(arg7), XEN_TO_C_INT(arg8), 
			  &r, &g, &b);
  if (val != 0)
    {
      XEN plist = XEN_EMPTY_LIST;
      int loc;
      loc = xm_protect(plist);
      for (i = len - 1; i >= 0; i--)
	plist = XEN_CONS(C_TO_XEN_ULONG(ps[i]), plist);
      xm_unprotect_at(loc);
      lst = XEN_LIST_5(C_TO_XEN_INT(val),
		       plist,
		       C_TO_XEN_ULONG(r),
		       C_TO_XEN_ULONG(g),
		       C_TO_XEN_ULONG(b));
    }
  FREE(ps);
  return(lst);
}

static XEN gxm_XAllocColorCells(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XAllocColorCells "Status XAllocColorCells(display, colormap, contig, nplanes, npixels) \
allocates read/write color cells."
  /* DIFF: XAllocColorCells arg 4 and 6 omitted and returned as (embedded) lists 
   */
  int mlen, plen, i, val;
  XEN mlst = XEN_EMPTY_LIST, plst = XEN_EMPTY_LIST;
  unsigned long *ms, *ps;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XAllocColorCells", "Display*");
  XEN_ASSERT_TYPE(XEN_Colormap_P(arg2), arg2, 2, "XAllocColorCells", "Colormap");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg3), arg3, 3, "XAllocColorCells", "Bool");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg4), arg4, 4, "XAllocColorCells", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg5), arg5, 5, "XAllocColorCells", "unsigned int");
  mlen = XEN_TO_C_INT(arg4);
  if (mlen <= 0) return(XEN_FALSE);
  plen = XEN_TO_C_INT(arg5);
  if (plen <= 0) return(XEN_FALSE);
  ms = (unsigned long *)CALLOC(mlen, sizeof(unsigned long));
  ps = (unsigned long *)CALLOC(plen, sizeof(unsigned long));
  val = XAllocColorCells(XEN_TO_C_Display(arg1), 
			 XEN_TO_C_Colormap(arg2), 
			 XEN_TO_C_BOOLEAN(arg3), 
			 ms, mlen, 
			 ps, plen);
  if (val != 0)
    {
      int loc1, loc2;
      loc1 = xm_protect(mlst);
      loc2 = xm_protect(plst);
      for (i = mlen - 1; i >= 0; i--) 
	mlst = XEN_CONS(C_TO_XEN_ULONG(ms[i]), mlst);
      for (i = plen - 1; i >= 0; i--) 
	mlst = XEN_CONS(C_TO_XEN_ULONG(ps[i]), plst);
      xm_unprotect_at(loc1);
      xm_unprotect_at(loc2);
    }
  FREE(ms);
  FREE(ps);
  if (val != 0)
    return(XEN_LIST_3(C_TO_XEN_INT(val),
		      mlst,
		      plst));
  return(XEN_FALSE);
}

static XEN gxm_XAllocColor(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XAllocColor "Status XAllocColor(display, colormap, screen_in_out) allocates a read-only colormap entry corresponding to the \
closest RGB value supported by the hardware."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XAllocColor", "Display*");
  XEN_ASSERT_TYPE(XEN_Colormap_P(arg2), arg2, 2, "XAllocColor", "Colormap");
  XEN_ASSERT_TYPE(XEN_XColor_P(arg3), arg3, 3, "XAllocColor", "XColor"); 
  return(C_TO_XEN_INT(XAllocColor(XEN_TO_C_Display(arg1), XEN_TO_C_Colormap(arg2), XEN_TO_C_XColor(arg3))));
}

static XEN gxm_XActivateScreenSaver(XEN arg1)
{
  #define H_XActivateScreenSaver "XActivateScreenSaver(display) activates the screen saver."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XActivateScreenSaver", "Display*");
  return(C_TO_XEN_INT(XActivateScreenSaver(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XSetTransientForHint(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XSetTransientForHint "XSetTransientForHint(display, w, prop_window) sets the WM_TRANSIENT_FOR property of the specified \
window to the specified prop_window."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetTransientForHint", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XSetTransientForHint", "Window");
  XEN_ASSERT_TYPE(XEN_Window_P(arg3), arg3, 3, "XSetTransientForHint", "Window");
  return(C_TO_XEN_INT(XSetTransientForHint(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_Window(arg3))));
}

static XEN gxm_XSetWMColormapWindows(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XSetWMColormapWindows "Status XSetWMColormapWindows(display, w, colormap_windows, count) replaces the WM_COLORMAP_WINDOWS property \
on the specified window with the list of windows specified by the colormap_windows argument."
  /* DIFF: XSetWMColormapWindows arg 3 is list of Windows
   */
  int len, rtn;
  Window *ws;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetWMColormapWindows", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XSetWMColormapWindows", "Window");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg3), arg3, 3, "XSetWMColormapWindows", "list of Windows");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XSetWMColormapWindows", "int");
  len = XEN_TO_C_INT(arg4);
  if (len <= 0) return(XEN_FALSE);
  ws = XEN_TO_C_Windows(arg3, len);
  rtn = XSetWMColormapWindows(XEN_TO_C_Display(arg1), 
			      XEN_TO_C_Window(arg2),
			      ws, len);
  FREE(ws);
  return(C_TO_XEN_INT(rtn));
}

static XEN gxm_XGetWMColormapWindows(XEN arg1, XEN arg2)
{
  #define H_XGetWMColormapWindows "Status XGetWMColormapWindows(display, w) returns the list of \
window identifiers stored in the WM_COLORMAP_WINDOWS property on the specified window."
  /* DIFF: XGetWMColormapWindows omit last 2 args, return list of windows
   */
  XEN lst = XEN_EMPTY_LIST;
  int i, len, rtn, loc;
  Window *ws;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetWMColormapWindows", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XGetWMColormapWindows", "Window");
  rtn = XGetWMColormapWindows(XEN_TO_C_Display(arg1), 
			      XEN_TO_C_Window(arg2), 
			      &ws, &len);
  if (rtn == 0)
    return(XEN_FALSE);
  loc = xm_protect(lst);
  for (i = len - 1; i >= 0; i--)
    lst = XEN_CONS(C_TO_XEN_Window(ws[i]), lst);
  xm_unprotect_at(loc);
  XFree(ws);
  return(lst);
}

static XEN gxm_XGetCommand(XEN arg1, XEN arg2)
{
  #define H_XGetCommand "Status XGetCommand(display, w) reads the WM_COMMAND property from the specified window \
and returns a string list."
  /* DIFF: XGetCommand omits last 2 args, returns list
   */
  char **argv;
  int argc;
  XEN lst = XEN_EMPTY_LIST;
  Status err;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetCommand", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XGetCommand", "Window");
  err = XGetCommand(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), &argv, &argc);
  if (err != 0)
    {
      int i, loc;
      loc = xm_protect(lst);
      for (i = argc - 1; i >= 0; i--)
	lst = XEN_CONS(C_TO_XEN_STRING(argv[i]), lst);
      XFreeStringList(argv);
      xm_unprotect_at(loc);
    }
  return(lst);
}

static XEN gxm_XWithdrawWindow(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XWithdrawWindow "Status XWithdrawWindow(display, w, screen_number) unmaps the specified window and sends a synthetic  \
UnmapNotify event to the root window of the specified screen."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XWithdrawWindow", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XWithdrawWindow", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XWithdrawWindow", "int");
  return(C_TO_XEN_INT(XWithdrawWindow(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_INT(arg3))));
}

static XEN gxm_XIconifyWindow(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XIconifyWindow "Status XIconifyWindow(display, w, screen_number) sends a WM_CHANGE_STATE  ClientMessage event with a format of \
32 and a first data element of IconicState to the root window of the specified screen with an event mask set to \
SubstructureNotifyMask | SubstructureRedirectMask."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XIconifyWindow", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XIconifyWindow", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XIconifyWindow", "int");
  return(C_TO_XEN_INT(XIconifyWindow(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_INT(arg3))));
}

static XEN gxm_XSetWMProtocols(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XSetWMProtocols "Status XSetWMProtocols(display, w, protocols, count) replaces the WM_PROTOCOLS property on the \
specified window with the list of atoms specified by the protocols argument."
  /* DIFF: XSetWMProtocols arg3 is list of atoms
   */
  Atom *outs;
  int val, len;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetWMProtocols", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XSetWMProtocols", "Window");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg3), arg3, 3, "XSetWMProtocols", "list of Atom");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XSetWMProtocols", "int");
  len = XEN_TO_C_INT(arg4);
  if (len <= 0) return(XEN_FALSE);
  outs = XEN_TO_C_Atoms(arg3, len);
  val = XSetWMProtocols(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), outs, len);
  FREE(outs);
  return(C_TO_XEN_INT(val));
}

static XEN gxm_XGetWMProtocols(XEN arg1, XEN arg2)
{
  #define H_XGetWMProtocols "Status XGetWMProtocols(display, w) returns the list of atoms stored in the \
WM_PROTOCOLS property on the specified window."
  /* DIFF: XGetWMProtocols omits last 2 args, returns list
   */
  Atom *ats;
  int len, i, val, loc;
  XEN lst = XEN_EMPTY_LIST;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetWMProtocols", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XGetWMProtocols", "Window");
  val = XGetWMProtocols(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), &ats, &len);
  if (val == 0)
    return(XEN_FALSE);
  loc = xm_protect(lst);
  for (i = len - 1; i >= 0; i--)
    lst = XEN_CONS(C_TO_XEN_Atom(ats[i]), lst);
  xm_unprotect_at(loc);
  XFree((void *)ats);
  return(lst);
}

static XEN gxm_XReconfigureWMWindow(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XReconfigureWMWindow "Status XReconfigureWMWindow(display, w, screen_number, value_mask, values) issues a  ConfigureWindow \
request on the specified top-level window."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XReconfigureWMWindow", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XReconfigureWMWindow", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XReconfigureWMWindow", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg4), arg4, 4, "XReconfigureWMWindow", "unsigned int");
  XEN_ASSERT_TYPE(XEN_XWindowChanges_P(arg5), arg5, 5, "XReconfigureWMWindow", "XWindowChanges*");
  return(C_TO_XEN_INT(XReconfigureWMWindow(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_INT(arg3), XEN_TO_C_ULONG(arg4), 
					   XEN_TO_C_XWindowChanges(arg5))));
}

static XEN gxm_XListDepths(XEN arg1, XEN arg2)
{
  #define H_XListDepths "int *XListDepths(display, screen_number) returns the array of depths that are available on the \
specified screen."
  /* DIFF: XListDepths omits last arg, returns list of depths
   */
  XEN lst = XEN_EMPTY_LIST;
  int i, len, loc;
  int *ds;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XListDepths", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XListDepths", "int");
  ds = XListDepths(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2), &len);
  loc = xm_protect(lst);
  for (i = len - 1; i >= 0; i--)
    lst = XEN_CONS(C_TO_XEN_INT(ds[i]), lst);
  XFree(ds);
  xm_unprotect_at(loc);
  return(lst);
}

static XEN gxm_XListPixmapFormats(XEN arg1)
{
  #define H_XListPixmapFormats "XPixmapFormatValues *XListPixmapFormats(display) returns an array of XPixmapFormatValues \
structures that describe the types of Z format images supported by the specified display."
  /* DIFF: XListPixmapFormats omits arg2, rtns list of lists, each holding XPixmapFormatValues data
   */
  XPixmapFormatValues *ps;
  int len, loc;
  XEN lst = XEN_EMPTY_LIST;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XListPixmapFormats", "Display*");
  ps = XListPixmapFormats(XEN_TO_C_Display(arg1), &len);
  loc = xm_protect(lst);
  if (ps)
    {
      int i;
      for (i = len - 1; i >= 0; i--)
	lst = XEN_CONS(XEN_LIST_3(C_TO_XEN_INT(ps[i].depth),
				  C_TO_XEN_INT(ps[i].bits_per_pixel),
				  C_TO_XEN_INT(ps[i].scanline_pad)),
		       lst);
      free(ps);
    }
  xm_unprotect_at(loc);
  return(lst);
}


static XEN xm_XIOErrorHandler = XEN_FALSE;
static int gxm_XIOErrorHandler(Display *dpy)
{
  XEN_CALL_1(xm_XIOErrorHandler, C_TO_XEN_Display(dpy), c__FUNCTION__);
  return(0); /* never happens */
}

static XEN gxm_XSetIOErrorHandler(XEN arg1)
{
  #define H_XSetIOErrorHandler "int (*XSetIOErrorHandler(handler))() sets the fatal I/O error handler. "
  XEN old_val;
  XEN_ASSERT_TYPE(XEN_FALSE_P(arg1) || XEN_PROCEDURE_P(arg1), arg1, XEN_ONLY_ARG, "XSetIOErrorHandler", PROC_FALSE "=null or function of 1 arg");
  xm_protect(arg1);
  old_val = xm_XIOErrorHandler;
  xm_XIOErrorHandler = arg1;
  if (XEN_FALSE_P(arg1))
    XSetIOErrorHandler(NULL);
  else XSetIOErrorHandler(gxm_XIOErrorHandler);
  if (XEN_PROCEDURE_P(old_val)) xm_unprotect(old_val); /* hmmm... what if we're gc'd on the way back? */
  return(old_val);
}

static XEN xm_XErrorHandler = XEN_FALSE;
static int gxm_XErrorHandler(Display *dpy, XErrorEvent *e)
{
  XEN_CALL_2(xm_XErrorHandler, C_TO_XEN_Display(dpy), C_TO_XEN_XErrorEvent((XErrorEvent *)e), c__FUNCTION__);
  return(0); /* never happens */
}

static XEN gxm_XSetErrorHandler(XEN arg1)
{
  #define H_XSetErrorHandler "XSetErrorHandler(proc) causes proc to be called if an error occurs"
  XEN old_val;
  XEN_ASSERT_TYPE(XEN_FALSE_P(arg1) || XEN_PROCEDURE_P(arg1), arg1, XEN_ONLY_ARG, "XSetErrorHandler", PROC_FALSE "=null or function of 2 args");
  xm_protect(arg1);
  old_val = xm_XErrorHandler;
  xm_XErrorHandler = arg1;
  if (XEN_FALSE_P(arg1))
    XSetErrorHandler(NULL);
  else XSetErrorHandler(gxm_XErrorHandler);
  if (XEN_PROCEDURE_P(old_val)) xm_unprotect(old_val); /* hmmm... what if we're gc'd on the way back? */
  return(old_val);
}

static XEN gxm_XScreenNumberOfScreen(XEN arg1)
{
  #define H_XScreenNumberOfScreen "int XScreenNumberOfScreen(screen) returns the screen index number of the specified screen."
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XScreenNumberOfScreen", "Screen*");
  return(C_TO_XEN_INT(XScreenNumberOfScreen(XEN_TO_C_Screen(arg1))));
}

static XEN gxm_XEventMaskOfScreen(XEN arg1)
{
  #define H_EventMaskOfScreen "EventMaskOfScreen(screen) returns the root event mask of the root window for the specified screen at connection setup."
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XEventMaskOfScreen", "Screen*");
  return(C_TO_XEN_ULONG(XEventMaskOfScreen(XEN_TO_C_Screen(arg1))));
}

static XEN gxm_XDefaultScreenOfDisplay(XEN arg1)
{
  /* #define DefaultScreenOfDisplay(display) */
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDefaultScreenOfDisplay", "Display*");
  return(C_TO_XEN_Screen(XDefaultScreenOfDisplay(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XScreenOfDisplay(XEN arg1, XEN arg2)
{
  #define H_ScreenOfDisplay "ScreenOfDisplay(display, screen_number) returns a pointer to the screen of the specified display."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XScreenOfDisplay", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XScreenOfDisplay", "int");
  return(C_TO_XEN_Screen(XScreenOfDisplay(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XDisplayOfScreen(XEN arg1)
{
  #define H_DisplayOfScreen "DisplayOfScreen(screen) returns the display of the specified screen."
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XDisplayOfScreen", "Screen*");
  return(C_TO_XEN_Display(XDisplayOfScreen(XEN_TO_C_Screen(arg1))));
}

static XEN gxm_XDefaultColormapOfScreen(XEN arg1)
{
  #define H_DefaultColormapOfScreen "DefaultColormapOfScreen(screen) returns the default colormap of the specified screen."
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XDefaultColormapOfScreen", "Screen*");
  return(C_TO_XEN_Colormap(XDefaultColormapOfScreen(XEN_TO_C_Screen(arg1))));
}

static XEN gxm_XDefaultColormap(XEN arg1, XEN arg2)
{
  #define H_DefaultColormap "DefaultColormap(display, screen_number) returns the default colormap ID for allocation on the specified screen."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDefaultColormap", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XDefaultColormap", "int");
  return(C_TO_XEN_Colormap(XDefaultColormap(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XDisplayString(XEN arg1)
{
  #define H_DisplayString "DisplayString(display) returns the string that was passed to XOpenDisplay when the current display was opened."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDisplayString", "Display*");
  return(C_TO_XEN_STRING(XDisplayString(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XServerVendor(XEN arg1)
{
  #define H_ServerVendor "ServerVendor(display) returns a pointer to a null-terminated string that provides some identification of the \
owner of the X server implementation."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XServerVendor", "Display*");
  return(C_TO_XEN_STRING(XServerVendor(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XLastKnownRequestProcessed(XEN arg1)
{
  #define H_LastKnownRequestProcessed "LastKnownRequestProcessed(display) extracts the full serial number of the last request known by Xlib \
to have been processed by the X server."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XLastKnownRequestProcessed", "Display*");
  return(C_TO_XEN_ULONG(XLastKnownRequestProcessed(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XNextRequest(XEN arg1)
{
  #define H_NextRequest "NextRequest(display) extracts the full serial number that is to be used for the next request."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XNextRequest", "Display*");
  return(C_TO_XEN_ULONG(XNextRequest(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XWhitePixelOfScreen(XEN arg1)
{
  #define H_WhitePixelOfScreen "WhitePixelOfScreen(screen) returns the white pixel value of the specified screen."
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XWhitePixelOfScreen", "Screen*");
  return(C_TO_XEN_Pixel(XWhitePixelOfScreen(XEN_TO_C_Screen(arg1))));
}

static XEN gxm_XBlackPixelOfScreen(XEN arg1)
{
  #define H_BlackPixelOfScreen "BlackPixelOfScreen(screen) returns the black pixel value of the specified screen."
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XBlackPixelOfScreen", "Screen*");
  return(C_TO_XEN_Pixel(XBlackPixelOfScreen(XEN_TO_C_Screen(arg1))));
}

static XEN gxm_XAllPlanes(void)
{
  #define H_AllPlanes "Allplanes() returns a value with all bits set to 1 suitable for use in a plane argument to a procedure."
  return(C_TO_XEN_ULONG(XAllPlanes()));
}

static XEN gxm_XWhitePixel(XEN arg1, XEN arg2)
{
  #define H_WhitePixel "WhitePixel(display, screen_number) returns the white pixel value for the specified screen."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XWhitePixel", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XWhitePixel", "int");
  return(C_TO_XEN_Pixel(XWhitePixel(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XBlackPixel(XEN arg1, XEN arg2)
{
  #define H_BlackPixel "BlackPixel(display, screen_number) returns the black pixel value for the specified screen."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XBlackPixel", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XBlackPixel", "int");
  return(C_TO_XEN_Pixel(XBlackPixel(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XDefaultGCOfScreen(XEN arg1)
{
  #define H_DefaultGCOfScreen "DefaultGCOfScreen(screen) returns the default GC of the specified screen, which has the same depth as the root \
window of the screen."
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XDefaultGCOfScreen", "Screen*");
  return(C_TO_XEN_GC(XDefaultGCOfScreen(XEN_TO_C_Screen(arg1))));
}

static XEN gxm_XDefaultGC(XEN arg1, XEN arg2)
{
  #define H_DefaultGC "DefaultGC(display, screen_number) returns the default GC for the root window of the "
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDefaultGC", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XDefaultGC", "int");
  return(C_TO_XEN_GC(XDefaultGC(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XDefaultVisualOfScreen(XEN arg1)
{
  #define H_DefaultVisualOfScreen "DefaultVisualOfScreen(screen) returns the default visual of the specified screen."
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XDefaultVisualOfScreen", "Screen*");
  return(C_TO_XEN_Visual(XDefaultVisualOfScreen(XEN_TO_C_Screen(arg1))));
}

static XEN gxm_XDefaultVisual(XEN arg1, XEN arg2)
{
  #define H_DefaultVisual "DefaultVisual(display, screen_number) returns the default visual type for the specified screen."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDefaultVisual", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XDefaultVisual", "int");
  return(C_TO_XEN_Visual(XDefaultVisual(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XRootWindowOfScreen(XEN arg1)
{
  #define H_RootWindowOfScreen "RootWindowOfScreen(screen) returns the root window of the specified screen."
  XEN_ASSERT_TYPE(XEN_Screen_P(arg1), arg1, 1, "XRootWindowOfScreen", "Screen*");
  return(C_TO_XEN_Window(XRootWindowOfScreen(XEN_TO_C_Screen(arg1))));
}

static XEN gxm_XDefaultRootWindow(XEN arg1)
{
  #define H_DefaultRootWindow "DefaultRootWindow(display) returns the root window for the default screen."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDefaultRootWindow", "Display*");
  return(C_TO_XEN_Window(XDefaultRootWindow(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XRootWindow(XEN arg1, XEN arg2)
{
  #define H_RootWindow "RootWindow(display, screen_number) returns the root window."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XRootWindow", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XRootWindow", "int");
  return(C_TO_XEN_Window(XRootWindow(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XVisualIDFromVisual(XEN arg1)
{
  #define H_XVisualIDFromVisual "VisualID XVisualIDFromVisual(visual) returns the visual ID for the specified visual type."
  XEN_ASSERT_TYPE(XEN_Visual_P(arg1), arg1, 1, "XVisualIDFromVisual", "Visual*");
  return(C_TO_XEN_ULONG(XVisualIDFromVisual(XEN_TO_C_Visual(arg1))));
}

static XEN gxm_XDisplayMotionBufferSize(XEN arg1)
{
  #define H_XDisplayMotionBufferSize "unsigned long XDisplayMotionBufferSize(display)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XDisplayMotionBufferSize", "Display*");
  return(C_TO_XEN_ULONG(XDisplayMotionBufferSize(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XExtendedMaxRequestSize(XEN arg1)
{
  #define H_XExtendedMaxRequestSize "long XExtendedMaxRequestSize(display) returns zero if the specified display does not support an \
extended-length protocol encoding; otherwise, it returns the maximum request size (in 4-byte units) supported by the server using the \
extended-length encoding."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XExtendedMaxRequestSize", "Display*");
  return(C_TO_XEN_INT(XExtendedMaxRequestSize(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XMaxRequestSize(XEN arg1)
{
  #define H_XMaxRequestSize "long XMaxRequestSize(display) returns the maximum request size (in 4-byte units) supported by the server \
without using an extended-length protocol encoding."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XMaxRequestSize", "Display*");
  return(C_TO_XEN_INT(XMaxRequestSize(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XStringToKeysym(XEN arg1)
{
  #define H_XStringToKeysym "KeySym XStringToKeysym(string)"
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XStringToKeysym", "char*");
  return(C_TO_XEN_KeySym(XStringToKeysym(XEN_TO_C_STRING(arg1))));
}

static XEN gxm_XGetKeyboardMapping(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XGetKeyboardMapping "KeySym *XGetKeyboardMapping(display, first_keycode, keycode_count) returns \
the symbols for the specified number of KeyCodes starting with first_keycode."
  /* DIFF: XGetKeyboardMapping omits last arg, returns list of keys
   */
  int n, i, len, count, loc;
  KeySym *keys;
  XEN lst = XEN_EMPTY_LIST;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetKeyboardMapping", "Display*");
  XEN_ASSERT_TYPE(XEN_KeyCode_P(arg2), arg2, 2, "XGetKeyboardMapping", "KeyCode");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XGetKeyboardMapping", "int");
  count = XEN_TO_C_INT(arg3);
  keys = XGetKeyboardMapping(XEN_TO_C_Display(arg1), XEN_TO_C_KeyCode(arg2), count, &n);
  len = count * n;
  loc = xm_protect(lst);
  for (i = len - 1; i >= 0; i--)
    lst = XEN_CONS(C_TO_XEN_KeySym(keys[i]), lst);
  XFree(keys);
  xm_unprotect_at(loc);
  return(lst);
}

static XEN gxm_XLookupKeysym(XEN arg1, XEN arg2)
{
  #define H_XLookupKeysym "KeySym XLookupKeysym(key_event, index) uses a given keyboard event and the index you specified to return \
the KeySym from the list that corresponds to the KeyCode member in the XKeyPressedEvent or XKeyReleasedEvent structure."
  XEN_ASSERT_TYPE(XEN_XKeyEvent_P(arg1), arg1, 1, "XLookupKeysym", "XKeyEvent*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XLookupKeysym", "int");
  return(C_TO_XEN_KeySym(XLookupKeysym(XEN_TO_C_XKeyEvent(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XKeycodeToKeysym(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XKeycodeToKeysym "KeySym XKeycodeToKeysym(display, keycode, index) uses internal Xlib tables and returns the KeySym defined \
for the specified KeyCode and the element of the KeyCode vector."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XKeycodeToKeysym", "Display*");
  XEN_ASSERT_TYPE(XEN_KeyCode_P(arg2), arg2, 2, "XKeycodeToKeysym", "KeyCode");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XKeycodeToKeysym", "int");
  return(C_TO_XEN_KeySym(XKeycodeToKeysym(XEN_TO_C_Display(arg1), XEN_TO_C_KeyCode(arg2), XEN_TO_C_INT(arg3))));
}

static XEN gxm_XListProperties(XEN arg1, XEN arg2)
{
  #define H_XListProperties "Atom *XListProperties(display, w) returns a pointer to an array of atom properties that \
are defined for the specified window or returns NULL if no properties were found."
  /* DIFF: XListProperties returns list, no arg3
   */
  int i, len, loc;
  XEN lst = XEN_EMPTY_LIST;
  Atom *ats;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XListProperties", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XListProperties", "Window");
  ats = XListProperties(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), &len);
  if (ats == NULL)
    return(XEN_FALSE);
  loc = xm_protect(lst);
  for (i = len - 1; i >= 0; i--)
    lst = XEN_CONS(C_TO_XEN_Atom(ats[i]), lst);
  xm_unprotect_at(loc);
  XFree(ats);
  return(lst);
}

static XEN gxm_XListExtensions(XEN arg1)
{
  #define H_XListExtensions "XListExtensions(dpy) -> list of strings describing available extensions"
  /* DIFF: XListExtensions omits arg2, returns list
   */
  int i, len, loc;
  XEN lst = XEN_EMPTY_LIST;
  char **str;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XListExtensions", "Display*");
  str = XListExtensions(XEN_TO_C_Display(arg1), &len);
  loc = xm_protect(lst);
  for (i = len - 1; i >= 0; i--)
    lst = XEN_CONS(C_TO_XEN_STRING(str[i]), lst);
  XFreeExtensionList(str);
  xm_unprotect_at(loc);
  return(lst);
}

static XEN gxm_XGetFontPath(XEN arg1)
{
  #define H_XGetFontPath "char **XGetFontPath(display) allocates and returns an array of strings containing the search path."
  /* DIFF: XGetFontPath omits arg2, returns list
   */
  int i, len, loc;
  XEN lst = XEN_EMPTY_LIST;
  char **str;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetFontPath", "Display*");
  str = XGetFontPath(XEN_TO_C_Display(arg1), &len);
  loc = xm_protect(lst);
  for (i = len - 1; i >= 0; i--)
    lst = XEN_CONS(C_TO_XEN_STRING(str[i]), lst);
  XFreeFontPath(str);
  xm_unprotect_at(loc);
  return(lst);
}

static XEN gxm_XListFontsWithInfo(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XListFontsWithInfo "char **XListFontsWithInfo(display, pattern, maxnames) returns a list of \
font names that match the specified pattern and their associated font information."
  /* DIFF: XListFontsWithInfo omit last 2 args, returns list of lists
   */
  int i, count, loc;
  XFontStruct *info;
  char **val;
  XEN lst = XEN_EMPTY_LIST;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XListFontsWithInfo", "Display*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XListFontsWithInfo", "char*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XListFontsWithInfo", "int");
  val = XListFontsWithInfo(XEN_TO_C_Display(arg1), XEN_TO_C_STRING(arg2), XEN_TO_C_INT(arg3), &count, &info);
  loc = xm_protect(lst);
  for (i = count - 1; i >= 0; i--)
    lst = XEN_CONS(XEN_LIST_2(C_TO_XEN_STRING(val[i]), 
			      C_TO_XEN_XFontStruct(&(info[i]))),
		   lst);
  XFreeFontInfo(val, info, count);
  /* XFreeFontNames(val); */
  xm_unprotect_at(loc);
  return(lst);
}

static XEN gxm_XListFonts(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XListFonts "char **XListFonts(display, pattern, maxnames) returns an array of available font names that match \
the string you passed to the pattern argument."
  /* DIFF: XListFonts omits arg4, returns list
   */
  int i, len, loc;
  XEN lst = XEN_EMPTY_LIST;
  char **str;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XListFonts", "Display*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XListFonts", "char*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XListFonts", "int");
  str = XListFonts(XEN_TO_C_Display(arg1), XEN_TO_C_STRING(arg2), XEN_TO_C_INT(arg3), &len);
  loc = xm_protect(lst);
  for (i = len - 1; i >= 0; i--)
    lst = XEN_CONS(C_TO_XEN_STRING(str[i]), lst);
  XFreeFontNames(str);
  xm_unprotect_at(loc);
  return(lst);
}

static XEN gxm_XListInstalledColormaps(XEN arg1, XEN arg2)
{
  #define H_XListInstalledColormaps "Colormap *XListInstalledColormaps(display, w) returns a list of the currently installed \
colormaps for the screen of the specified window."
  /* DIFF: XListInstalledColormaps omits last arg, rtns list of XColormaps
   */
  Colormap *cm;
  int i, len, loc;
  XEN lst = XEN_EMPTY_LIST;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XListInstalledColormaps", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XListInstalledColormaps", "Window");
  cm = XListInstalledColormaps(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), &len);
  loc = xm_protect(lst);
  for (i = len - 1; i >= 0; i--)
    lst = XEN_CONS(C_TO_XEN_Colormap(cm[i]), lst);
  free(cm);
  xm_unprotect_at(loc);
  return(lst);
}

static XEN gxm_XCreateWindow(XEN args)
{
  #define H_XCreateWindow "Window XCreateWindow(display, parent, x, y, width, height, border_width, depth, class, visual, valuemask, attributes) \
creates an unmapped subwindow for a specified parent window, returns the window ID of the created window, and causes the X server to generate \
a CreateNotify event."
  XEN arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12;
  arg1 = XEN_LIST_REF(args, 0);
  arg2 = XEN_LIST_REF(args, 1);
  arg3 = XEN_LIST_REF(args, 2);
  arg4 = XEN_LIST_REF(args, 3);
  arg5 = XEN_LIST_REF(args, 4);
  arg6 = XEN_LIST_REF(args, 5);
  arg7 = XEN_LIST_REF(args, 6);
  arg8 = XEN_LIST_REF(args, 7);
  arg9 = XEN_LIST_REF(args, 8);
  arg10 = XEN_LIST_REF(args, 9);
  arg11 = XEN_LIST_REF(args, 10);
  arg12 = XEN_LIST_REF(args, 11);
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XCreateWindow", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XCreateWindow", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XCreateWindow", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XCreateWindow", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg5), arg5, 5, "XCreateWindow", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg6), arg6, 6, "XCreateWindow", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg7), arg7, 7, "XCreateWindow", "unsigned int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg8), arg8, 8, "XCreateWindow", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg9), arg9, 9, "XCreateWindow", "unsigned int");
  XEN_ASSERT_TYPE(XEN_Visual_P(arg10), arg10, 10, "XCreateWindow", "Visual*");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg11), arg11, 11, "XCreateWindow", "ulong");
  XEN_ASSERT_TYPE(XEN_XSetWindowAttributes_P(arg12), arg12, 12, "XCreateWindow", "XSetWindowAttributes*");
  return(C_TO_XEN_Window(XCreateWindow(XEN_TO_C_Display(arg1), 
				       XEN_TO_C_Window(arg2), 
				       XEN_TO_C_INT(arg3), XEN_TO_C_INT(arg4), 
				       XEN_TO_C_ULONG(arg5), XEN_TO_C_ULONG(arg6), 
				       XEN_TO_C_ULONG(arg7), XEN_TO_C_INT(arg8), 
				       XEN_TO_C_ULONG(arg9), XEN_TO_C_Visual(arg10), 
				       XEN_TO_C_ULONG(arg11), 
				       XEN_TO_C_XSetWindowAttributes(arg12))));
}

static XEN gxm_XGetSelectionOwner(XEN arg1, XEN arg2)
{
  #define H_XGetSelectionOwner "Window XGetSelectionOwner(display, selection) returns the window ID associated with the window that \
currently owns the specified selection."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetSelectionOwner", "Display*");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg2), arg2, 2, "XGetSelectionOwner", "Atom");
  return(C_TO_XEN_Window(XGetSelectionOwner(XEN_TO_C_Display(arg1), XEN_TO_C_Atom(arg2))));
}

static XEN gxm_XCreateSimpleWindow(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7, XEN arg8, XEN arg9)
{
  #define H_XCreateSimpleWindow "Window XCreateSimpleWindow(display, parent, x, y, width, height, border_width, border, background) \
creates an unmapped InputOutput subwindow for a specified parent window, returns the window ID of the created window, and causes the X \
server to generate a CreateNotify event."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XCreateSimpleWindow", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XCreateSimpleWindow", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XCreateSimpleWindow", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XCreateSimpleWindow", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg5), arg5, 5, "XCreateSimpleWindow", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg6), arg6, 6, "XCreateSimpleWindow", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg7), arg7, 7, "XCreateSimpleWindow", "unsigned int");
  XEN_ASSERT_TYPE(XEN_Pixel_P(arg8), arg8, 8, "XCreateSimpleWindow", "Pixel");
  XEN_ASSERT_TYPE(XEN_Pixel_P(arg9), arg9, 9, "XCreateSimpleWindow", "Pixel");
  return(C_TO_XEN_Window(XCreateSimpleWindow(XEN_TO_C_Display(arg1), 
					     XEN_TO_C_Window(arg2), 
					     XEN_TO_C_INT(arg3), XEN_TO_C_INT(arg4), 
					     XEN_TO_C_ULONG(arg5), XEN_TO_C_ULONG(arg6), 
					     XEN_TO_C_ULONG(arg7), XEN_TO_C_Pixel(arg8), 
					     XEN_TO_C_Pixel(arg9))));
}

static XEN gxm_XCreatePixmapFromBitmapData(XEN arg1, XEN arg2, XEN larg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7, XEN arg8)
{
  #define H_XCreatePixmapFromBitmapData "Pixmap XCreatePixmapFromBitmapData(display, d, data, width, height, fg, bg, depth) creates a \
pixmap of the given depth and then does a bitmap-format XPutImage of the data into it."
  /* DIFF: XCreatePixmapFromBitmapData takes list of chars as arg3 (not char *)
   */
  char *bits;
  int i, len;
  Pixmap p;
  XEN arg3;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XCreatePixmapFromBitmapData", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XCreatePixmapFromBitmapData", "Drawable");
  XEN_ASSERT_TYPE(XEN_LIST_P(larg3), larg3, 3, "XCreatePixmapFromBitmapData", "list of char");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg4), arg4, 4, "XCreatePixmapFromBitmapData", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg5), arg5, 5, "XCreatePixmapFromBitmapData", "unsigned int");
  XEN_ASSERT_TYPE(XEN_Pixel_P(arg6), arg6, 6, "XCreatePixmapFromBitmapData", "pixel");
  XEN_ASSERT_TYPE(XEN_Pixel_P(arg7), arg7, 7, "XCreatePixmapFromBitmapData", "pixel");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg8), arg8, 8, "XCreatePixmapFromBitmapData", "unsigned int");
  len = XEN_LIST_LENGTH(larg3);
  if (len <= 0) XEN_ASSERT_TYPE(0, larg3, 3, "XCreatePixmapFromBitmapData", "positive integer");
  arg3 = XEN_COPY_ARG(larg3);
  bits = (char *)CALLOC(len, sizeof(char));
  for (i = 0; i < len; i++, arg3 = XEN_CDR(arg3))
    bits[i] = (char)XEN_TO_C_INT(XEN_CAR(arg3));
  p = XCreatePixmapFromBitmapData(XEN_TO_C_Display(arg1), 
				  XEN_TO_C_Window(arg2), 
				  bits,
				  XEN_TO_C_ULONG(arg4), XEN_TO_C_ULONG(arg5), 
				  XEN_TO_C_Pixel(arg6), XEN_TO_C_Pixel(arg7), 
				  XEN_TO_C_ULONG(arg8));
  FREE(bits);
  return(C_TO_XEN_Pixmap(p));
}

static XEN gxm_XCreateBitmapFromData(XEN arg1, XEN arg2, XEN larg3, XEN arg4, XEN arg5)
{
  #define H_XCreateBitmapFromData "Pixmap XCreateBitmapFromData(display, d, data, width, height) allows you to include in your C \
program a bitmap file that was written out by XWriteBitmapFile"
  /* DIFF: XCreateBitmapFromData takes list of chars as arg3 (not char *)
   */
  char *bits;
  int i, len;
  Pixmap p;
  XEN arg3;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XCreateBitmapFromData", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XCreateBitmapFromData", "Drawable");
  XEN_ASSERT_TYPE(XEN_LIST_P(larg3), larg3, 3, "XCreateBitmapFromData", "list of char");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg4), arg4, 4, "XCreateBitmapFromData", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg5), arg5, 5, "XCreateBitmapFromData", "unsigned int");
  len = XEN_LIST_LENGTH(larg3);
  if (len <= 0) XEN_ASSERT_TYPE(0, larg3, 3, "XCreateBitmapFromData", "positive integer");
  arg3 = XEN_COPY_ARG(larg3);
  bits = (char *)CALLOC(len, sizeof(char));
  for (i = 0; i < len; i++, arg3 = XEN_CDR(arg3))
    bits[i] = (char)XEN_TO_C_INT(XEN_CAR(arg3));
  p = XCreateBitmapFromData(XEN_TO_C_Display(arg1), 
			    XEN_TO_C_Window(arg2),
			    bits, 
			    XEN_TO_C_ULONG(arg4), 
			    XEN_TO_C_ULONG(arg5));
  FREE(bits);
  return(C_TO_XEN_Pixmap(p));
}

static XEN gxm_XCreatePixmap(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XCreatePixmap "Pixmap XCreatePixmap(display, d, width, height, depth)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XCreatePixmap", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XCreatePixmap", "Drawable");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XCreatePixmap", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg4), arg4, 4, "XCreatePixmap", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg5), arg5, 5, "XCreatePixmap", "unsigned int");
  return(C_TO_XEN_Pixmap(XCreatePixmap(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), 
				       XEN_TO_C_ULONG(arg3), XEN_TO_C_ULONG(arg4), XEN_TO_C_ULONG(arg5))));
}

static XEN gxm_XFlushGC(XEN arg1, XEN arg2)
{
  #define H_XFlushGC "XFlushGC(dpy, gc) forces cached GC changes to X server"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XFlushGC", "Display*");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XFlushGC", "GC");
  XFlushGC(XEN_TO_C_Display(arg1), XEN_TO_C_GC(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XCreateGC(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XCreateGC "GC XCreateGC(display, d, valuemask, values) creates a graphics context and returns a GC."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XCreateGC", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XCreateGC", "Drawable");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XCreateGC", "ulong");
  XEN_ASSERT_TYPE(XEN_XGCValues_P(arg4), arg4, 4, "XCreateGC", "XGCValues*");
  return(C_TO_XEN_GC(XCreateGC(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_ULONG(arg3), XEN_TO_C_XGCValues(arg4))));
}

static XEN gxm_XLoadFont(XEN arg1, XEN arg2)
{
  #define H_XLoadFont "Font XLoadFont(display, name) loads the specified font and returns its associated font ID."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XLoadFont", "Display*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XLoadFont", "char*");
  return(C_TO_XEN_Font(XLoadFont(XEN_TO_C_Display(arg1), XEN_TO_C_STRING(arg2))));
}

static XEN gxm_XCreateFontCursor(XEN arg1, XEN arg2)
{
  #define H_XCreateFontCursor "Cursor XCreateFontCursor(display, shape)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XCreateFontCursor", "Display*");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XCreateFontCursor", "unsigned int");
  return(C_TO_XEN_Cursor(XCreateFontCursor(XEN_TO_C_Display(arg1), XEN_TO_C_ULONG(arg2))));
}

static XEN gxm_XCreateGlyphCursor(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7)
{
  #define H_XCreateGlyphCursor "Cursor XCreateGlyphCursor(display, source_font, mask_font, source_char, mask_char, foreground_color, \
background_color) is similar to XCreatePixmapCursor except that the source and mask bitmaps are obtained from the specified font glyphs."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XCreateGlyphCursor", "Display*");
  XEN_ASSERT_TYPE(XEN_Font_P(arg2), arg2, 2, "XCreateGlyphCursor", "Font");
  XEN_ASSERT_TYPE(XEN_Font_P(arg3) || XEN_INTEGER_P(arg3) || XEN_FALSE_P(arg3), arg3, 3, "XCreateGlyphCursor", "Font");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg4), arg4, 4, "XCreateGlyphCursor", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg5), arg5, 5, "XCreateGlyphCursor", "unsigned int");
  XEN_ASSERT_TYPE(XEN_XColor_P(arg6), arg6, 6, "XCreateGlyphCursor", "XColor");
  XEN_ASSERT_TYPE(XEN_XColor_P(arg7), arg7, 7, "XCreateGlyphCursor", "XColor");
  return(C_TO_XEN_Cursor(XCreateGlyphCursor(XEN_TO_C_Display(arg1), XEN_TO_C_Font(arg2), 
					    (XEN_Font_P(arg3)) ? XEN_TO_C_Font(arg3) : None,
					    XEN_TO_C_ULONG(arg4),
					    XEN_TO_C_ULONG(arg5), 
					    XEN_TO_C_XColor(arg6), XEN_TO_C_XColor(arg7))));
}

static XEN gxm_XCreatePixmapCursor(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7)
{
  #define H_XCreatePixmapCursor "Cursor XCreatePixmapCursor(display, source, mask, foreground_color, background_color, x, y) creates \
a cursor and returns the cursor ID associated with it."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XCreatePixmapCursor", "Display*");
  XEN_ASSERT_TYPE(XEN_Pixmap_P(arg2), arg2, 2, "XCreatePixmapCursor", "Pixmap");
  XEN_ASSERT_TYPE(XEN_Pixmap_P(arg3) || XEN_INTEGER_P(arg3) || XEN_FALSE_P(arg3), arg3, 3, "XCreatePixmapCursor", "Pixmap");
  XEN_ASSERT_TYPE(XEN_XColor_P(arg4), arg4, 4, "XCreatePixmapCursor", "XColor");
  XEN_ASSERT_TYPE(XEN_XColor_P(arg5), arg5, 5, "XCreatePixmapCursor", "XColor");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg6), arg6, 6, "XCreatePixmapCursor", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg7), arg7, 7, "XCreatePixmapCursor", "unsigned int");
  return(C_TO_XEN_Cursor(XCreatePixmapCursor(XEN_TO_C_Display(arg1), 
					     XEN_TO_C_Pixmap(arg2), 
					     (XEN_Pixmap_P(arg3)) ? XEN_TO_C_Pixmap(arg3) : None,
					     XEN_TO_C_XColor(arg4), 
					     XEN_TO_C_XColor(arg5), 
					     XEN_TO_C_ULONG(arg6), XEN_TO_C_ULONG(arg7))));
}

static XEN gxm_XCreateColormap(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XCreateColormap "Colormap XCreateColormap(display, w, visual, alloc) creates a colormap of the specified visual type for \
the screen on which the specified window resides and returns the colormap ID associated with it."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XCreateColormap", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XCreateColormap", "Window");
  XEN_ASSERT_TYPE(XEN_Visual_P(arg3), arg3, 3, "XCreateColormap", "Visual*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XCreateColormap", "int");
  return(C_TO_XEN_Colormap(XCreateColormap(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_Visual(arg3), XEN_TO_C_INT(arg4))));
}

static XEN gxm_XCopyColormapAndFree(XEN arg1, XEN arg2)
{
  #define H_XCopyColormapAndFree "Colormap XCopyColormapAndFree(display, colormap) creates a colormap of the same visual type and \
for the same screen as the specified colormap and returns the new colormap ID."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XCopyColormapAndFree", "Display*");
  XEN_ASSERT_TYPE(XEN_Colormap_P(arg2), arg2, 2, "XCopyColormapAndFree", "Colormap");
  return(C_TO_XEN_Colormap(XCopyColormapAndFree(XEN_TO_C_Display(arg1), XEN_TO_C_Colormap(arg2))));
}

static XEN gxm_XInternAtom(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XInternAtom "Atom XInternAtom(display, atom_name, only_if_exists) returns the atom identifier associated with the specified atom_name string."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XInternAtom", "Display*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XInternAtom", "char*");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg3), arg3, 3, "XInternAtom", "Bool");
  return(C_TO_XEN_Atom(XInternAtom(XEN_TO_C_Display(arg1), XEN_TO_C_STRING(arg2), XEN_TO_C_BOOLEAN(arg3))));
}

static XEN xm_AfterFunction = XEN_FALSE;
static int default_after_function(Display *ignore) {return(0);}
static int gxm_AfterFunction(Display *dpy)
{
  return(XEN_TO_C_INT(XEN_CALL_1(xm_AfterFunction, 
				 C_TO_XEN_Display(dpy),
				 c__FUNCTION__)));
}

static XEN gxm_XSetAfterFunction(XEN arg1, XEN arg2)
{
  #define H_XSetAfterFunction "XSetAfterFunction(dpy, proc) sets a function (one arg: dpy) to be called after every X function call"
  XEN old_func;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSetAfterFunction", "Display*");
  xm_protect(arg2);
  old_func = xm_AfterFunction;
  xm_AfterFunction = arg2;
  if (XEN_PROCEDURE_P(arg2))
    XSetAfterFunction(XEN_TO_C_Display(arg1), gxm_AfterFunction);
  else XSetAfterFunction(XEN_TO_C_Display(arg1), default_after_function);
  if (XEN_PROCEDURE_P(old_func)) xm_unprotect(old_func);
  return(old_func);
}

static XEN gxm_XSynchronize(XEN arg1, XEN arg2)
{
  #define H_XSynchronize "int (*XSynchronize(display, onoff))() turns on/off synchronous behavior."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XSynchronize", "Display*");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg2), arg2, 2, "XSynchronize", "boolean");
  XSynchronize(XEN_TO_C_Display(arg1),
	       XEN_TO_C_BOOLEAN(arg2));
  return(xm_AfterFunction);
}

static XEN gxm_XKeysymToString(XEN arg1)
{
  #define H_XKeysymToString "char *XKeysymToString(keysym)"
  XEN_ASSERT_TYPE(XEN_KeySym_P(arg1), arg1, 1, "XKeysymToString", "KeySym");
  return(C_TO_XEN_STRING(XKeysymToString(XEN_TO_C_KeySym(arg1))));
}

static XEN gxm_XDisplayName(XEN arg1)
{
  #define H_XDisplayName "char *XDisplayName(string) returns the name of the display that  XOpenDisplay would attempt to use."
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XDisplayName", "char*");
  return(C_TO_XEN_STRING(XDisplayName(XEN_TO_C_STRING(arg1))));
}

static XEN gxm_XGetAtomName(XEN arg1, XEN arg2)
{
  #define H_XGetAtomName "char *XGetAtomName(display, atom) returns the name associated with the specified atom."
  char *str;
  XEN res;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetAtomName", "Display*");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg2), arg2, 2, "XGetAtomName", "Atom");
  str = XGetAtomName(XEN_TO_C_Display(arg1), XEN_TO_C_Atom(arg2));
  res = C_TO_XEN_STRING(str);
  XFree(str);
  return(res);
}

static XEN gxm_XFetchBuffer(XEN arg1, XEN arg2)
{
  #define H_XFetchBuffer "char *XFetchBuffer(display, buffer) returns #f if there \
is no data in the buffer or if an invalid buffer is specified, otherwise a string."
  int len = 0;
  char *buf;
  XEN lst = XEN_FALSE;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XFetchBuffer", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XFetchBuffer", "int");
  buf = XFetchBuffer(XEN_TO_C_Display(arg1), &len, XEN_TO_C_INT(arg2));
  if (len > 0) 
    {
      lst = C_TO_XEN_STRING(buf);
      free(buf);
    }
  return(lst);
}

static XEN gxm_XFetchBytes(XEN arg1)
{
  #define H_XFetchBytes "char *XFetchBytes(display) returns the string in cut buffer 0"
  /* DIFF: XFetchBytes returns string, omits arg2
   */
  int len = 0;
  char *buf;
  XEN lst = XEN_FALSE;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XFetchBytes", "Display*");
  buf = XFetchBytes(XEN_TO_C_Display(arg1), &len);
  if (len > 0) 
    {
      lst = C_TO_XEN_STRING(buf);
      free(buf);
    }
  return(lst);
}

static XEN gxm_XOpenDisplay(XEN arg1)
{
  #define H_XOpenDisplay "Display *XOpenDisplay(display_name) returns a Display structure that serves as the connection to the X server \
and that contains all the information about that X server."
  Display *dpy;
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1) || XEN_FALSE_P(arg1), arg1, 1, "XOpenDisplay", "char*");
  dpy = XOpenDisplay(XEN_FALSE_P(arg1) ? NULL : XEN_TO_C_STRING(arg1));
  if (dpy)
    return(C_TO_XEN_Display(dpy));
  return(XEN_FALSE);
}

static XEN gxm_XGetSubImage(XEN args)
{
  #define H_XGetSubImage "XImage *XGetSubImage(display, d, x, y, width, height, plane_mask, format, dest_image, dest_x, dest_y) updates \
dest_image with the specified subimage in the same manner as "
  XEN arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11;
  arg1 = XEN_LIST_REF(args, 0);
  arg2 = XEN_LIST_REF(args, 1);
  arg3 = XEN_LIST_REF(args, 2);
  arg4 = XEN_LIST_REF(args, 3);
  arg5 = XEN_LIST_REF(args, 4);
  arg6 = XEN_LIST_REF(args, 5);
  arg7 = XEN_LIST_REF(args, 6);
  arg8 = XEN_LIST_REF(args, 7);
  arg9 = XEN_LIST_REF(args, 8);
  arg10 = XEN_LIST_REF(args, 9);
  arg11 = XEN_LIST_REF(args, 10);
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetSubImage", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XGetSubImage", "Drawable");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XGetSubImage", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XGetSubImage", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg5), arg5, 5, "XGetSubImage", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg6), arg6, 6, "XGetSubImage", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg7), arg7, 7, "XGetSubImage", "ulong");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg8), arg8, 8, "XGetSubImage", "int");
  XEN_ASSERT_TYPE(XEN_XImage_P(arg9), arg9, 9, "XGetSubImage", "XImage*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg10), arg10, 10, "XGetSubImage", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg11), arg11, 11, "XGetSubImage", "int");
  return(C_TO_XEN_XImage(XGetSubImage(XEN_TO_C_Display(arg1),
				      XEN_TO_C_Window(arg2), 
				      XEN_TO_C_INT(arg3), XEN_TO_C_INT(arg4), 
				      XEN_TO_C_ULONG(arg5), XEN_TO_C_ULONG(arg6), 
				      XEN_TO_C_ULONG(arg7), XEN_TO_C_INT(arg8), 
				      XEN_TO_C_XImage(arg9), 
				      XEN_TO_C_INT(arg10), XEN_TO_C_INT(arg11))));
}

static XEN gxm_XGetImage(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7, XEN arg8)
{
  #define H_XGetImage "XImage *XGetImage(display, d, x, y, width, height, plane_mask, format) returns a pointer to an XImage structure."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetImage", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XGetImage", "Drawable");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XGetImage", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XGetImage", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg5), arg5, 5, "XGetImage", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg6), arg6, 6, "XGetImage", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg7), arg7, 7, "XGetImage", "ulong");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg8), arg8, 8, "XGetImage", "int");
  return(C_TO_XEN_XImage(XGetImage(XEN_TO_C_Display(arg1), 
				   XEN_TO_C_Window(arg2), 
				   XEN_TO_C_INT(arg3), XEN_TO_C_INT(arg4), 
				   XEN_TO_C_ULONG(arg5), XEN_TO_C_ULONG(arg6), 
				   XEN_TO_C_ULONG(arg7), XEN_TO_C_INT(arg8))));
}

static XEN gxm_XCreateImage(XEN args)
{
  #define H_XCreateImage "XImage *XCreateImage(display, visual, depth, format, offset, data, width, height, bitmap_pad, bytes_per_line) \
allocates the memory needed for an XImage structure for the specified display but does not allocate space for the image itself."
  XEN arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10;
  arg1 = XEN_LIST_REF(args, 0);
  arg2 = XEN_LIST_REF(args, 1);
  arg3 = XEN_LIST_REF(args, 2);
  arg4 = XEN_LIST_REF(args, 3);
  arg5 = XEN_LIST_REF(args, 4);
  arg6 = XEN_LIST_REF(args, 5);
  arg7 = XEN_LIST_REF(args, 6);
  arg8 = XEN_LIST_REF(args, 7);
  arg9 = XEN_LIST_REF(args, 8);
  arg10 = XEN_LIST_REF(args, 9);
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XCreateImage", "Display*");
  XEN_ASSERT_TYPE(XEN_Visual_P(arg2), arg2, 2, "XCreateImage", "Visual*");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XCreateImage", "unsigned int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XCreateImage", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XCreateImage", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg6), arg6, 6, "XCreateImage", "pointer");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg7), arg7, 7, "XCreateImage", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg8), arg8, 8, "XCreateImage", "unsigned int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg9), arg9, 9, "XCreateImage", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg10), arg10, 10, "XCreateImage", "int");
  return(C_TO_XEN_XImage(XCreateImage(XEN_TO_C_Display(arg1), 
				      XEN_TO_C_Visual(arg2), 
				      XEN_TO_C_ULONG(arg3), XEN_TO_C_INT(arg4), XEN_TO_C_INT(arg5), 
				      (char *)XEN_TO_C_ULONG(arg6),
				      XEN_TO_C_ULONG(arg7), XEN_TO_C_ULONG(arg8),
				      XEN_TO_C_INT(arg9), XEN_TO_C_INT(arg10))));
}

static XEN gxm_XNewModifiermap(XEN arg1)
{
  #define H_XNewModifiermap "XModifierKeymap *XNewModifiermap(max_keys_per_mod) returns a pointer to XModifierKeymap structure for later use."
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg1), arg1, 1, "XNewModifiermap", "int");
  return(C_TO_XEN_XModifierKeymap(XNewModifiermap(XEN_TO_C_INT(arg1))));
}

static XEN gxm_XInsertModifiermapEntry(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XInsertModifiermapEntry "XModifierKeymap *XInsertModifiermapEntry(modmap, keycode_entry, modifier) adds the specified KeyCode to \
the set that controls the specified modifier and returns the resulting XModifierKeymap structure (expanded as needed)."
  XEN_ASSERT_TYPE(XEN_XModifierKeymap_P(arg1), arg1, 1, "XInsertModifiermapEntry", "XModifierKeymap*");
  XEN_ASSERT_TYPE(XEN_KeyCode_P(arg2), arg2, 2, "XInsertModifiermapEntry", "KeyCode");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XInsertModifiermapEntry", "int");
  return(C_TO_XEN_XModifierKeymap(XInsertModifiermapEntry(XEN_TO_C_XModifierKeymap(arg1), XEN_TO_C_KeyCode(arg2), XEN_TO_C_INT(arg3))));
}

static XEN gxm_XGetModifierMapping(XEN arg1)
{
  #define H_XGetModifierMapping "XModifierKeymap *XGetModifierMapping(display) returns a pointer to a newly created XModifierKeymap structure \
that contains the keys being used as modifiers."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetModifierMapping", "Display*");
  return(C_TO_XEN_XModifierKeymap(XGetModifierMapping(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XDeleteModifiermapEntry(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XDeleteModifiermapEntry "XModifierKeymap *XDeleteModifiermapEntry(modmap, keycode_entry, modifier) deletes the specified KeyCode \
from the set that controls the specified modifier and returns a pointer to the resulting XModifierKeymap structure."
  XEN_ASSERT_TYPE(XEN_XModifierKeymap_P(arg1), arg1, 1, "XDeleteModifiermapEntry", "XModifierKeymap*");
  XEN_ASSERT_TYPE(XEN_KeyCode_P(arg2), arg2, 2, "XDeleteModifiermapEntry", "KeyCode");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XDeleteModifiermapEntry", "int");
  return(C_TO_XEN_XModifierKeymap(XDeleteModifiermapEntry(XEN_TO_C_XModifierKeymap(arg1), XEN_TO_C_KeyCode(arg2), XEN_TO_C_INT(arg3))));
}

static XEN gxm_XGetMotionEvents(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XGetMotionEvents "XTimeCoord *XGetMotionEvents(display, w, start, stop) returns all events in the motion history \
buffer that fall between the specified start and stop times, inclusive, and that have coordinates that lie within the specified window \
(including its borders) at its present placement."
  /* DIFF: XGetMotionEvents omits last arg, return time coords as list of lists
   */
  int n, i, loc;
  XTimeCoord *tcs;
  XEN lst = XEN_EMPTY_LIST;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XGetMotionEvents", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XGetMotionEvents", "Window");
  XEN_ASSERT_TYPE(XEN_Time_P(arg3), arg3, 3, "XGetMotionEvents", "Time");
  XEN_ASSERT_TYPE(XEN_Time_P(arg4), arg4, 4, "XGetMotionEvents", "Time");
  tcs = XGetMotionEvents(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), XEN_TO_C_Time(arg3), XEN_TO_C_Time(arg4), &n);
  loc = xm_protect(lst);
  for (i = n - 1; i > 0; i--)
    lst = XEN_CONS(XEN_LIST_3(C_TO_XEN_Time(tcs->time),
			      C_TO_XEN_INT((int)(tcs->x)),
			      C_TO_XEN_INT((int)(tcs->y))),
		   lst);
  XFree(tcs); /* free each as well? */
  xm_unprotect_at(loc);
  return(lst);
}

static XEN gxm_XQueryFont(XEN arg1, XEN arg2)
{
  #define H_XQueryFont "XFontStruct *XQueryFont(display, font) returns a pointer to the XFontStruct structure, which contains information \
associated with the font."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XQueryFont", "Display*");
  XEN_ASSERT_TYPE(XEN_Font_P(arg2), arg2, 2, "XQueryFont", "Font");
  return(C_TO_XEN_XFontStruct(XQueryFont(XEN_TO_C_Display(arg1), XEN_TO_C_Font(arg2))));
}

static XEN gxm_XLoadQueryFont(XEN arg1, XEN arg2)
{
  #define H_XLoadQueryFont "XFontStruct *XLoadQueryFont(display, name) provides the most common way for accessing a font. XLoadQueryFont \
both opens (loads) the specified font and returns a pointer to the appropriate XFontStruct structure."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XLoadQueryFont", "Display*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XLoadQueryFont", "char*");
  return(C_TO_XEN_XFontStruct(XLoadQueryFont(XEN_TO_C_Display(arg1), XEN_TO_C_STRING(arg2))));
}

static XEN gxm_DefaultScreen(XEN arg)
{
  #define H_DefaultScreen "returns the default screen number referenced in the XOpenDisplay routine."
  XEN_ASSERT_TYPE(XEN_Display_P(arg), arg, 0, "DefaultScreen", "Display*");
  return(C_TO_XEN_INT(DefaultScreen(XEN_TO_C_Display(arg))));
}

static XEN gxm_DefaultRootWindow(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg), arg, 0, "DefaultRootWindow", "Display*");
  return(C_TO_XEN_Window(DefaultRootWindow(XEN_TO_C_Display(arg))));
}

static XEN gxm_QLength(XEN arg)
{
  /* QLength(display) */
  XEN_ASSERT_TYPE(XEN_Display_P(arg), arg, 0, "QLength", "Display*");
  return(C_TO_XEN_INT(QLength(XEN_TO_C_Display(arg))));
}

static XEN gxm_ScreenCount(XEN arg1)
{
  /* ScreenCount(display) */
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "ScreenCount", "Display*");
  return(C_TO_XEN_INT(XScreenCount(XEN_TO_C_Display(arg1))));
}

static XEN gxm_ServerVendor(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg), arg, 0, "ServerVendor", "Display*");
  return(C_TO_XEN_STRING(ServerVendor(XEN_TO_C_Display(arg))));
}

static XEN gxm_ProtocolVersion(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg), arg, 0, "ProtocolVersion", "Display*");
  return(C_TO_XEN_INT(ProtocolVersion(XEN_TO_C_Display(arg))));
}

static XEN gxm_ProtocolRevision(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg), arg, 0, "ProtocolRevision", "Display*");
  return(C_TO_XEN_INT(ProtocolRevision(XEN_TO_C_Display(arg))));
}

static XEN gxm_VendorRelease(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg), arg, 0, "VendorRelease", "Display*");
  return(C_TO_XEN_INT(VendorRelease(XEN_TO_C_Display(arg))));
}

static XEN gxm_DisplayString(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg), arg, 0, "DisplayString", "Display*");
  return(C_TO_XEN_STRING(DisplayString(XEN_TO_C_Display(arg))));
}

static XEN gxm_BitmapUnit(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg), arg, 0, "BitmapUnit", "Display*");
  return(C_TO_XEN_INT(BitmapUnit(XEN_TO_C_Display(arg))));
}

static XEN gxm_BitmapBitOrder(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg), arg, 0, "BitmapBitOrder", "Display*");
  return(C_TO_XEN_INT(BitmapBitOrder(XEN_TO_C_Display(arg))));
}

static XEN gxm_BitmapPad(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg), arg, 0, "BitmapPad", "Display*");
  return(C_TO_XEN_INT(BitmapPad(XEN_TO_C_Display(arg))));
}

static XEN gxm_ImageByteOrder(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg), arg, 0, "ImageByteOrder", "Display*");
  return(C_TO_XEN_INT(ImageByteOrder(XEN_TO_C_Display(arg))));
}

static XEN gxm_NextRequest(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg), arg, 0, "NextRequest", "Display*");
  return(C_TO_XEN_ULONG(NextRequest(XEN_TO_C_Display(arg))));
}

static XEN gxm_LastKnownRequestProcessed(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg), arg, 0, "LastKnownRequestProcessed", "Display*");
  return(C_TO_XEN_ULONG(LastKnownRequestProcessed(XEN_TO_C_Display(arg))));
}

static XEN gxm_DefaultScreenOfDisplay(XEN arg)
{
  #define H_DefaultScreenOfDisplay "returns the default screen of the specified display."
  XEN_ASSERT_TYPE(XEN_Display_P(arg), arg, 0, "DefaultScreenOfDisplay", "Display");
  return(C_TO_XEN_Screen(DefaultScreenOfDisplay(XEN_TO_C_Display(arg))));
}

static XEN gxm_DisplayOfScreen(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Screen_P(arg), arg, 0, "DisplayOfScreen", "Screen");
  return(C_TO_XEN_Display(DisplayOfScreen(XEN_TO_C_Screen(arg))));
}

static XEN gxm_RootWindowOfScreen(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Screen_P(arg), arg, 0, "RootWindowOfScreen", "Screen");
  return(C_TO_XEN_Window(RootWindowOfScreen(XEN_TO_C_Screen(arg))));
}

static XEN gxm_BlackPixelOfScreen(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Screen_P(arg), arg, 0, "BlackPixelOfScreen", "Screen");
  return(C_TO_XEN_Pixel(BlackPixelOfScreen(XEN_TO_C_Screen(arg))));
}

static XEN gxm_WhitePixelOfScreen(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Screen_P(arg), arg, 0, "WhitePixelOfScreen", "Screen");
  return(C_TO_XEN_Pixel(WhitePixelOfScreen(XEN_TO_C_Screen(arg))));
}

static XEN gxm_DefaultColormapOfScreen(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Screen_P(arg), arg, 0, "DefaultColormapOfScreen", "Screen");
  return(C_TO_XEN_Colormap(DefaultColormapOfScreen(XEN_TO_C_Screen(arg))));
}

static XEN gxm_DefaultDepthOfScreen(XEN arg)
{
  /* DefaultDepthOfScreen(screen) */
  XEN_ASSERT_TYPE(XEN_Screen_P(arg), arg, 0, "DefaultDepthOfScreen", "Screen");
  return(C_TO_XEN_INT(DefaultDepthOfScreen(XEN_TO_C_Screen(arg))));
}

static XEN gxm_DefaultGCOfScreen(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Screen_P(arg), arg, 0, "DefaultGCOfScreen", "Screen");
  return(C_TO_XEN_GC(DefaultGCOfScreen(XEN_TO_C_Screen(arg))));
}

static XEN gxm_DefaultVisualOfScreen(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Screen_P(arg), arg, 0, "DefaultVisualOfScreen", "Screen");
  return(C_TO_XEN_Visual(DefaultVisualOfScreen(XEN_TO_C_Screen(arg))));
}

static XEN gxm_WidthOfScreen(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Screen_P(arg), arg, 0, "WidthOfScreen", "Screen");
  return(C_TO_XEN_INT(WidthOfScreen(XEN_TO_C_Screen(arg))));
}

static XEN gxm_HeightOfScreen(XEN arg)
{
  /* HeightOfScreen(screen) */
  XEN_ASSERT_TYPE(XEN_Screen_P(arg), arg, 0, "HeightOfScreen", "Screen");
  return(C_TO_XEN_INT(HeightOfScreen(XEN_TO_C_Screen(arg))));
}

static XEN gxm_WidthMMOfScreen(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Screen_P(arg), arg, 0, "WidthMMOfScreen", "Screen");
  return(C_TO_XEN_INT(WidthMMOfScreen(XEN_TO_C_Screen(arg))));
}

static XEN gxm_HeightMMOfScreen(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Screen_P(arg), arg, 0, "HeightMMOfScreen", "Screen");
  return(C_TO_XEN_INT(HeightMMOfScreen(XEN_TO_C_Screen(arg))));
}

static XEN gxm_PlanesOfScreen(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Screen_P(arg), arg, 0, "PlanesOfScreen", "Screen");
  return(C_TO_XEN_INT(PlanesOfScreen(XEN_TO_C_Screen(arg))));
}

static XEN gxm_CellsOfScreen(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Screen_P(arg), arg, 0, "CellsOfScreen", "Screen");
  return(C_TO_XEN_INT(CellsOfScreen(XEN_TO_C_Screen(arg))));
}

static XEN gxm_MinCmapsOfScreen(XEN arg)
{
  /* MinCmapsOfScreen(screen) */
  XEN_ASSERT_TYPE(XEN_Screen_P(arg), arg, 0, "MinCmapsOfScreen", "Screen");
  return(C_TO_XEN_INT(MinCmapsOfScreen(XEN_TO_C_Screen(arg))));
}

static XEN gxm_MaxCmapsOfScreen(XEN arg)
{
  /* MaxCmapsOfScreen(screen) */
  XEN_ASSERT_TYPE(XEN_Screen_P(arg), arg, 0, "MaxCmapsOfScreen", "Screen");
  return(C_TO_XEN_INT(MaxCmapsOfScreen(XEN_TO_C_Screen(arg))));
}

static XEN gxm_DoesSaveUnders(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Screen_P(arg), arg, 0, "DoesSaveUnders", "Screen");
  return(C_TO_XEN_BOOLEAN(DoesSaveUnders(XEN_TO_C_Screen(arg))));
}

static XEN gxm_DoesBackingStore(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Screen_P(arg), arg, 0, "DoesBackingStore", "Screen");
  return(C_TO_XEN_BOOLEAN(DoesBackingStore(XEN_TO_C_Screen(arg))));
}

static XEN gxm_EventMaskOfScreen(XEN arg)
{
  XEN_ASSERT_TYPE(XEN_Screen_P(arg), arg, 0, "EventMaskOfScreen", "Screen");
  return(C_TO_XEN_ULONG(EventMaskOfScreen(XEN_TO_C_Screen(arg))));
}

static XEN gxm_RootWindow(XEN arg1, XEN arg2)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "RootWindow", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "RootWindow", "int");
  return(C_TO_XEN_Window(RootWindow(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_DefaultVisual(XEN arg1, XEN arg2)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "DefaultVisual", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "DefaultVisual", "int");
  return(C_TO_XEN_Visual(DefaultVisual(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_DefaultGC(XEN arg1, XEN arg2)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "DefaultGC", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "DefaultGC", "int");
  return(C_TO_XEN_GC(DefaultGC(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_BlackPixel(XEN arg1, XEN arg2)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "BlackPixel", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "BlackPixel", "int");
  return(C_TO_XEN_Pixel(BlackPixel(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_WhitePixel(XEN arg1, XEN arg2)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "WhitePixel", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "WhitePixel", "int");
  return(C_TO_XEN_Pixel(WhitePixel(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_DisplayWidth(XEN arg1, XEN arg2)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "DisplayWidth", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "DisplayWidth", "int");
  return(C_TO_XEN_INT(DisplayWidth(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_DisplayHeight(XEN arg1, XEN arg2)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "DisplayHeight", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "DisplayHeight", "int");
  return(C_TO_XEN_INT(DisplayHeight(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_DisplayWidthMM(XEN arg1, XEN arg2)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "DisplayWidthMM", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "DisplayWidthMM", "int");
  return(C_TO_XEN_INT(DisplayWidthMM(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_DisplayHeightMM(XEN arg1, XEN arg2)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "DisplayHeightMM", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "DisplayHeightMM", "int");
  return(C_TO_XEN_INT(DisplayHeightMM(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_DisplayPlanes(XEN arg1, XEN arg2)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "DisplayPlanes", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "DisplayPlanes", "int");
  return(C_TO_XEN_INT(DisplayPlanes(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_DisplayCells(XEN arg1, XEN arg2)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "DisplayCells", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "DisplayCells", "int");
  return(C_TO_XEN_INT(DisplayCells(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_DefaultColormap(XEN arg1, XEN arg2)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "DefaultColormap", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "DefaultColormap", "int");
  return(C_TO_XEN_Colormap(DefaultColormap(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_ScreenOfDisplay(XEN arg1, XEN arg2)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "ScreenOfDisplay", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "ScreenOfDisplay", "int");
  return(C_TO_XEN_Screen(ScreenOfDisplay(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_DefaultDepth(XEN arg1, XEN arg2)
{
  /* DefaultDepth(display, screen_number) */
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "DefaultDepth", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "DefaultDepth", "int");
  return(C_TO_XEN_INT(DefaultDepth(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_IsKeypadKey(XEN arg)
{
  #define H_IsKeypadKey "IsKeypadKey(keysym) returns #t if the specified KeySym is a keypad key."
  XEN_ASSERT_TYPE(XEN_KeySym_P(arg), arg, 0, "IsKeypadKey", "KeySym");
  return(C_TO_XEN_BOOLEAN(IsKeypadKey(XEN_TO_C_KeySym(arg))));
}

static XEN gxm_IsPrivateKeypadKey(XEN arg)
{
  #define H_IsPrivateKeypadKey "IsPrivateKeypadKey(keysym) returns #t if the specified KeySym is a vendor-private keypad key."
  XEN_ASSERT_TYPE(XEN_KeySym_P(arg), arg, 0, "IsPrivateKeypadKey", "KeySym");
  return(C_TO_XEN_BOOLEAN(IsPrivateKeypadKey(XEN_TO_C_KeySym(arg))));
}

static XEN gxm_IsCursorKey(XEN arg)
{
  #define H_IsCursorKey "IsCursorKey(keysym) returns #t if the specified KeySym is a cursor key."
  XEN_ASSERT_TYPE(XEN_KeySym_P(arg), arg, 0, "IsCursorKey", "KeySym");
  return(C_TO_XEN_BOOLEAN(IsCursorKey(XEN_TO_C_KeySym(arg))));
}

static XEN gxm_IsPFKey(XEN arg)
{
  #define H_IsPFKey "IsPFKey(keysym) returns #t if the specified KeySym is a PF key."
  XEN_ASSERT_TYPE(XEN_KeySym_P(arg), arg, 0, "IsPFKey", "KeySym");
  return(C_TO_XEN_BOOLEAN(IsPFKey(XEN_TO_C_KeySym(arg))));
}

static XEN gxm_IsFunctionKey(XEN arg)
{
  #define H_IsFunctionKey "IsFunctionKey(keysym) returns #t if the KeySym is a function key."
  XEN_ASSERT_TYPE(XEN_KeySym_P(arg), arg, 0, "IsFunctionKey", "KeySym");
  return(C_TO_XEN_BOOLEAN(IsFunctionKey(XEN_TO_C_KeySym(arg))));
}

static XEN gxm_IsMiscFunctionKey(XEN arg)
{
  #define H_IsMiscFunctionKey "IsMiscFunctionKey(keysym) returns #t if the specified KeySym is a miscellaneous function key."
  XEN_ASSERT_TYPE(XEN_KeySym_P(arg), arg, 0, "IsMiscFunctionKey", "KeySym");
  return(C_TO_XEN_BOOLEAN(IsMiscFunctionKey(XEN_TO_C_KeySym(arg))));
}

static XEN gxm_IsModifierKey(XEN arg)
{
  #define H_IsModifierKey "IsModifierKey(keysym) returns #t if the specified KeySym is a modifier key."
  XEN_ASSERT_TYPE(XEN_KeySym_P(arg), arg, 0, "IsModifierKey", "KeySym");
  return(C_TO_XEN_BOOLEAN(IsModifierKey(XEN_TO_C_KeySym(arg))));
}

static XEN gxm_XAddPixel(XEN arg1, XEN arg2)
{
  #define H_XAddPixel "XAddPixel(ximage, value) adds a constant value to every pixel in an image."
  XEN_ASSERT_TYPE(XEN_XImage_P(arg1), arg1, 1, "XAddPixel", "XImage*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XAddPixel", "long");
  return(C_TO_XEN_INT(XAddPixel(XEN_TO_C_XImage(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XSubImage(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XSubImage "XImage *XSubImage(ximage, x, y, subimage_width, subimage_height) creates a new image that is a subsection of an existing one."
  XEN_ASSERT_TYPE(XEN_XImage_P(arg1), arg1, 1, "XSubImage", "XImage*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XSubImage", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XSubImage", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg4), arg4, 4, "XSubImage", "unsigned int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg5), arg5, 5, "XSubImage", "unsigned int");
  return(C_TO_XEN_XImage(XSubImage(XEN_TO_C_XImage(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_INT(arg3), XEN_TO_C_ULONG(arg4), XEN_TO_C_ULONG(arg5))));
}

static XEN gxm_XPutPixel(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XPutPixel "XPutPixel(ximage, x, y, pixel) overwrites the pixel in the named image with the specified pixel value."
  XEN_ASSERT_TYPE(XEN_XImage_P(arg1), arg1, 1, "XPutPixel", "XImage*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XPutPixel", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XPutPixel", "int");
  XEN_ASSERT_TYPE(XEN_Pixel_P(arg4), arg4, 4, "XPutPixel", "Pixel");
  return(C_TO_XEN_INT(XPutPixel(XEN_TO_C_XImage(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_INT(arg3), XEN_TO_C_Pixel(arg4))));
}

static XEN gxm_XGetPixel(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XGetPixel "Pixel XGetPixel(ximage, x, y) returns the specified pixel from the named image."
  XEN_ASSERT_TYPE(XEN_XImage_P(arg1), arg1, 1, "XGetPixel", "XImage*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XGetPixel", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XGetPixel", "int");
  return(C_TO_XEN_Pixel(XGetPixel(XEN_TO_C_XImage(arg1), XEN_TO_C_INT(arg2), XEN_TO_C_INT(arg3))));
}

static XEN gxm_XDestroyImage(XEN arg1)
{
  #define H_XDestroyImage "XDestroyImage(ximage) deallocates the memory associated with the XImage structure."
  XEN_ASSERT_TYPE(XEN_XImage_P(arg1), arg1, 1, "XDestroyImage", "XImage*");
  return(C_TO_XEN_INT(XDestroyImage(XEN_TO_C_XImage(arg1))));
}



/* ----------------------------------------------------------------------------------------------------
 *
 *                            *         *  ***********  *         *  ***********
 *                             *       *   *             *       *        *
 *                              *     *    *              *     *         *
 *                               *   *     *               *   *          *
 *                                * *      *                * *           *
 *                                 *       *******           *            *
 *                                * *      *                * *           *
 *                               *   *     *               *   *          *
 *                              *     *    *              *     *         *
 *                             *       *   *             *       *        *
 *                            *         *  ***********  *         *       *
 * ----------------------------------------------------------------------------------------------------
 */

#if HAVE_XSHAPEQUERYEXTENSION

/* thanks to Michael Scholz! */

static XEN gxm_XShapeQueryExtension(XEN dpy)
{
  #define H_XShapeQueryExtension "(XShapeQueryExtension dpy) returns list of (Bool event_base error_base)"
  /* DIFF: (proposal)
     [C] Bool XShapeQueryExtension(Display *dpy, int *event_base, int *error_base)
     [XEN] (XShapeQueryExtension dpy) -> (list Bool event_base error_base)
  */
  int event_base = 0, error_base = 0;
  Bool ret = False;
  XEN_ASSERT_TYPE(XEN_Display_P(dpy), dpy, XEN_ARG_1, "XShapeQueryExtension", "Display*");
  ret = XShapeQueryExtension(XEN_TO_C_Display(dpy), &event_base, &error_base);
  return(XEN_LIST_3(C_TO_XEN_BOOLEAN(ret), C_TO_XEN_INT(event_base), C_TO_XEN_INT(error_base)));
}

static XEN gxm_XShapeQueryVersion(XEN dpy)
{
  #define H_XShapeQueryVersion "(XShapeQueryVersion dpy) returns list of (Bool major_version minor_version)"
  int major = 0, minor = 0;
  Bool ret = False;
  XEN_ASSERT_TYPE(XEN_Display_P(dpy), dpy, XEN_ARG_1, "XShapeQueryVersion", "Display*");
  ret = XShapeQueryVersion(XEN_TO_C_Display(dpy), &major, &minor);
  return(XEN_LIST_3(C_TO_XEN_BOOLEAN(ret), C_TO_XEN_INT(major), C_TO_XEN_INT(minor)));
}

static XEN gxm_XShapeQueryExtents(XEN dpy, XEN win)
{
  #define H_XShapeQueryExtents "(XShapeQueryExtents dpy win) returns list of (status bounding_shaped x_bound y_bound w_bound \
h_bound clip_shaped x_clip y_clip w_clip h_clip"
  Bool bounding_shaped;
  int x_bounding;
  int y_bounding;
  unsigned int w_bounding;
  unsigned int h_bounding;
  Bool clip_shaped;
  int x_clip;
  int y_clip;
  unsigned int w_clip;
  unsigned int h_clip;
  Status ret;
  XEN_ASSERT_TYPE(XEN_Display_P(dpy), dpy, XEN_ARG_1, "XShapeQueryExtents", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(win), win, XEN_ARG_2, "XShapeQueryExtents", "Window");
  ret = XShapeQueryExtents(XEN_TO_C_Display(dpy), XEN_TO_C_Window(win),
			   &bounding_shaped, &x_bounding, &y_bounding, &w_bounding, &h_bounding,
			   &clip_shaped, &x_clip, &y_clip, &w_clip, &h_clip);
  return(XEN_CONS(C_TO_XEN_INT(ret),
		  XEN_CONS(C_TO_XEN_INT(bounding_shaped),
			   XEN_LIST_9(C_TO_XEN_INT(x_bounding),
				      C_TO_XEN_INT(y_bounding),
				      C_TO_XEN_INT(w_bounding),
				      C_TO_XEN_INT(h_bounding),
				      C_TO_XEN_INT(clip_shaped),
				      C_TO_XEN_INT(x_clip),
				      C_TO_XEN_INT(y_clip),
				      C_TO_XEN_INT(w_clip),
				      C_TO_XEN_INT(h_clip)))));
}

static XEN gxm_XShapeGetRectangles(XEN dpy, XEN win, XEN kind)
{
  #define H_XShapeGetRectangles "(XShapeGetRectangles dpy win kind) returns list of (xrectangles ordering)"
  int count = 0, ordering = 0;
  XRectangle *res;
  XEN_ASSERT_TYPE(XEN_Display_P(dpy), dpy, XEN_ARG_1, "XShapeGetRectangles", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(win), win, XEN_ARG_2, "XShapeGetRectangles", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(kind), kind, XEN_ARG_3, "XShapeGetRectangles", "int");
  res = XShapeGetRectangles(XEN_TO_C_Display(dpy), XEN_TO_C_Window(win), XEN_TO_C_INT(kind), &count, &ordering);
  return(XEN_LIST_2(C_TO_XEN_XRectangles(res, count), C_TO_XEN_INT(ordering)));
}

static XEN gxm_XShapeOffsetShape(XEN dpy, XEN win, XEN kind, XEN x, XEN y)
{
  #define H_XShapeOffsetShape "(XShapeOffsetShape dpy win kind x-off y-off)"
  XEN_ASSERT_TYPE(XEN_Display_P(dpy), dpy, XEN_ARG_1, "XShapeOffsetShape", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(win), win, XEN_ARG_2, "XShapeOffsetShape", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(kind), kind, XEN_ARG_3, "XShapeOffsetShape", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(x), x, XEN_ARG_4, "XShapeOffsetShape", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(y), y, XEN_ARG_5, "XShapeOffsetShape", "int");
  XShapeOffsetShape(XEN_TO_C_Display(dpy), XEN_TO_C_Window(win), 
		    XEN_TO_C_INT(kind), XEN_TO_C_INT(x), XEN_TO_C_INT(y));
  return(XEN_FALSE);
}

static XEN gxm_XShapeCombineRegion(XEN dpy, XEN win, XEN kind, XEN x, XEN y, XEN reg, XEN op)
{
  #define H_XShapeCombineRegion "(XShapeCombineRegion dpy win kind x-off y-off region op)"
  XEN_ASSERT_TYPE(XEN_Display_P(dpy), dpy, XEN_ARG_1, "XShapeCombineRegion", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(win), win, XEN_ARG_2, "XShapeCombineRegion", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(kind), kind, XEN_ARG_3, "XShapeCombineRegion", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(x), x, XEN_ARG_4, "XShapeCombineRegion", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(y), y, XEN_ARG_5, "XShapeCombineRegion", "int");
  XEN_ASSERT_TYPE(XEN_Region_P(reg), reg, XEN_ARG_6, "XShapeCombineRegion", "Region");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(op), op, XEN_ARG_6, "XShapeCombineRegion", "int");
  XShapeCombineRegion(XEN_TO_C_Display(dpy), XEN_TO_C_Window(win), 
		      XEN_TO_C_INT(kind), XEN_TO_C_INT(x), XEN_TO_C_INT(y),
		      XEN_TO_C_Region(reg),
		      XEN_TO_C_INT(op));
  return(XEN_FALSE);
}

static XEN gxm_XShapeCombineMask(XEN dpy, XEN win, XEN kind, XEN x, XEN y, XEN pix, XEN op)
{
  #define H_XShapeCombineMask "(XShapeCombineMask dpy win kind x-off y-off pixmap op)"
  XEN_ASSERT_TYPE(XEN_Display_P(dpy), dpy, XEN_ARG_1, "XShapeCombineMask", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(win), win, XEN_ARG_2, "XShapeCombineMask", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(kind), kind, XEN_ARG_3, "XShapeCombineMask", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(x), x, XEN_ARG_4, "XShapeCombineMask", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(y), y, XEN_ARG_5, "XShapeCombineMask", "int");
  XEN_ASSERT_TYPE(XEN_Pixmap_P(pix), pix, XEN_ARG_6, "XShapeCombineMask", "Pixmap");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(op), op, XEN_ARG_6, "XShapeCombineMask", "int");
  XShapeCombineMask(XEN_TO_C_Display(dpy), XEN_TO_C_Window(win), 
		    XEN_TO_C_INT(kind), XEN_TO_C_INT(x), XEN_TO_C_INT(y),
		    XEN_TO_C_Pixmap(pix),
		    XEN_TO_C_INT(op));
  return(XEN_FALSE);
}

static XEN gxm_XShapeCombineShape(XEN dpy, XEN win, XEN kind, XEN x, XEN y, XEN src, XEN src_kind, XEN op)
{
  #define H_XShapeCombineShape "(XShapeCombineShape dpy win kind x-off y-off src src_kind op)"
  XEN_ASSERT_TYPE(XEN_Display_P(dpy), dpy, XEN_ARG_1, "XShapeCombineShape", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(win), win, XEN_ARG_2, "XShapeCombineShape", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(kind), kind, XEN_ARG_3, "XShapeCombineShape", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(x), x, XEN_ARG_4, "XShapeCombineShape", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(y), y, XEN_ARG_5, "XShapeCombineShape", "int");
  XEN_ASSERT_TYPE(XEN_Window_P(src), src, XEN_ARG_6, "XShapeCombineShape", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(src_kind), src_kind, XEN_ARG_7, "XShapeCombineShape", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(op), op, XEN_ARG_8, "XShapeCombineShape", "int");
  XShapeCombineShape(XEN_TO_C_Display(dpy), XEN_TO_C_Window(win), 
		     XEN_TO_C_INT(kind), XEN_TO_C_INT(x), XEN_TO_C_INT(y),
		     XEN_TO_C_Window(src), XEN_TO_C_INT(src_kind),
		     XEN_TO_C_INT(op));
  return(XEN_FALSE);
}

static XEN gxm_XShapeCombineRectangles(XEN dpy, XEN win, XEN kind, XEN x, XEN y, XEN rects, XEN n_rects, XEN op, XEN ordering)
{
  #define H_XShapeCombineRectangles "(XShapeCombineRectangles dpy win kind x-off y-off rectangles n-rects op ordering)"
  XRectangle *cr = NULL;
  XEN_ASSERT_TYPE(XEN_Display_P(dpy), dpy, XEN_ARG_1, "XShapeCombineRectangles", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(win), win, XEN_ARG_2, "XShapeCombineRectangles", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(kind), kind, XEN_ARG_3, "XShapeCombineRectangles", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(x), x, XEN_ARG_4, "XShapeCombineRectangles", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(y), y, XEN_ARG_5, "XShapeCombineRectangles", "int");
  XEN_ASSERT_TYPE(XEN_LIST_P(rects), rects, XEN_ARG_6, "XShapeCombineRectangles", "list of XRectangles");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(n_rects), n_rects, XEN_ARG_7, "XShapeCombineRectangles", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(op), op, XEN_ARG_8, "XShapeCombineRectangles", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(ordering), ordering, XEN_ARG_9, "XShapeCombineRectangles", "int");
  cr = XEN_TO_C_XRectangles(rects, XEN_TO_C_INT(n_rects));
  XShapeCombineRectangles(XEN_TO_C_Display(dpy), XEN_TO_C_Window(win), 
			  XEN_TO_C_INT(kind), XEN_TO_C_INT(x), XEN_TO_C_INT(y),
			  cr, XEN_TO_C_INT(n_rects),
			  XEN_TO_C_INT(op), XEN_TO_C_INT(ordering));
  if (cr) FREE(cr);
  return(XEN_FALSE);
}
#endif



/* ----------------------------------------------------------------------------------------------------
 *
 *                            *         *  ***********
 *                             *       *        *
 *                              *     *         *
 *                               *   *          *
 *                                * *           *
 *                                 *            *
 *                                * *           *
 *                               *   *          *
 *                              *     *         *
 *                             *       *        *
 *                            *         *       *
 * ----------------------------------------------------------------------------------------------------
 */

#if HAVE_MOTIF

typedef enum {CANCEL_CONVERT, CONVERT, LOSE, DONE, CONVERT_INCR, LOSE_INCR, DONE_INCR} xm_selmap_t;
/* need a way to map from widget to selection proc */

typedef struct {
  Widget w;
  xm_selmap_t type;
  XEN proc;
} selmap;

static selmap *selmaps = NULL;
static int selmap_size = 0;
static int selmap_ctr = 0;
static void add_selmap(Widget w, xm_selmap_t type, XEN proc)
{
  if (selmap_size == 0)
    selmaps = (selmap *)CALLOC(8, sizeof(selmap));
  else
    {
      if (selmap_size == selmap_ctr)
	{
	  int i;
	  selmap_size += 8;
	  selmaps = (selmap *)REALLOC(selmaps, selmap_size * sizeof(selmap));
	  for (i = selmap_ctr; i < selmap_size; i++) selmaps[i].w = NULL;
	}
    }
  selmaps[selmap_ctr].w = w;
  selmaps[selmap_ctr].type = type;
  xm_protect(proc);
  selmaps[selmap_ctr++].proc = proc;
}

static XEN unselmap(Widget w, xm_selmap_t type)
{
  int i;
  for (i = 0; i < selmap_ctr; i++)
    if ((selmaps[i].w == w) &&
	(selmaps[i].type == type))
      return(selmaps[i].proc);
  return(XEN_FALSE);
}

static void gxm_XtCancelConvertSelectionProc(Widget w, Atom *a1, Atom *a2, XtRequestId *id, XtPointer x) 
{
  XEN proc;
  proc = unselmap(w, CANCEL_CONVERT);
  if (XEN_PROCEDURE_P(proc))
    XEN_CALL_5(proc,
	       C_TO_XEN_Widget(w),
	       C_TO_XEN_Atom(*a1),
	       C_TO_XEN_Atom(*a2),
	       C_TO_XEN_XtRequestId(*id),
	       (XEN)x,
	       "CancelConvert");
} 

static Boolean gxm_XtConvertSelectionProc(Widget w, Atom *a1, Atom *a2, Atom *a3, XtPointer* x, unsigned long *l, int *i) 
{
  XEN proc, val;
  proc = unselmap(w, CONVERT);
  if (XEN_PROCEDURE_P(proc))
    {
      val = XEN_CALL_3(proc,
		       C_TO_XEN_Widget(w),
		       C_TO_XEN_Atom(*a1),
		       C_TO_XEN_Atom(*a2),
		       "ConvertSelection");
      (*a3) = XEN_TO_C_Atom(XEN_LIST_REF(val, 1));
      (*x) = (XtPointer)(XEN_LIST_REF(val, 2));
      (*l) = XEN_TO_C_ULONG(XEN_LIST_REF(val, 3));
      (*i) = XEN_TO_C_INT(XEN_LIST_REF(val, 4));
      return(XEN_TO_C_BOOLEAN(XEN_CAR(val)));
    }
  return(0);
}

static void gxm_XtLoseSelectionIncrProc(Widget w, Atom *a, XtPointer x) 
{
  XEN proc;
  proc = unselmap(w, LOSE_INCR);
  if (XEN_PROCEDURE_P(proc))
    XEN_CALL_3(proc,
	       C_TO_XEN_Widget(w),
	       C_TO_XEN_Atom(*a),
	       (XEN)x,
	       "LoseSelectionIncr");
}

static void gxm_XtLoseSelectionProc(Widget w, Atom *a) 
{
  XEN proc;
  proc = unselmap(w, LOSE);
  if (XEN_PROCEDURE_P(proc))
    XEN_CALL_2(proc,
	       C_TO_XEN_Widget(w),
	       C_TO_XEN_Atom(*a),
	       "LoseSelection");
}

static void gxm_XtSelectionDoneProc(Widget w, Atom *a1, Atom *a2) 
{
  XEN proc;
  proc = unselmap(w, DONE);
  if (XEN_PROCEDURE_P(proc))
    XEN_CALL_3(proc,
	       C_TO_XEN_Widget(w),
	       C_TO_XEN_Atom(*a1),
	       C_TO_XEN_Atom(*a2),
	       "DoneSelection");
}

static void gxm_XtSelectionDoneIncrProc(Widget w, Atom *a1, Atom *a2, XtRequestId *i, XtPointer x) 
{
  XEN proc;
  proc = unselmap(w, DONE_INCR);
  if (XEN_PROCEDURE_P(proc))
    XEN_CALL_5(proc,
	       C_TO_XEN_Widget(w),
	       C_TO_XEN_Atom(*a1),
	       C_TO_XEN_Atom(*a2),
	       C_TO_XEN_XtRequestId(*i),
	       (XEN)x,
	       "DoneSelectionIncr");
}

static XEN gxm_XtAppUnlock(XEN arg1)
{
  #define H_XtAppUnlock "void XtAppUnlock(app_context) unlocks the application context."
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtAppUnlock", "XtAppContext");
  XtAppUnlock(XEN_TO_C_XtAppContext(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XtAppLock(XEN arg1)
{
  #define H_XtAppLock "void XtAppLock(app_context) locks the application context including all its related displays and widgets."
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtAppLock", "XtAppContext");
  XtAppLock(XEN_TO_C_XtAppContext(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XtToolkitThreadInitialize(void)
{
  #define H_XtToolkitThreadInitialize "Boolean XtToolkitThreadInitialize()"
  return(C_TO_XEN_BOOLEAN(XtToolkitThreadInitialize()));
}

static XEN gxm_XtGetDisplays(XEN arg1)
{
  #define H_XtGetDisplays "void XtGetDisplays(app_context) -> list of displays"
  /* DIFF: XtGetDisplays not arg2 arg3 returns list
   */
  unsigned int x;
  Display **ds;
  int i, loc;
  XEN lst = XEN_EMPTY_LIST;
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtGetDisplays", "XtAppContext");
  XtGetDisplays(XEN_TO_C_XtAppContext(arg1), &ds, &x);
  loc = xm_protect(lst);
  for (i = x - 1; i >= 0; i--)
    lst = XEN_CONS(C_TO_XEN_Display(ds[i]), lst);
  xm_unprotect_at(loc);
  return(lst);
}

static XEN gxm_XtGetApplicationNameAndClass(XEN arg1)
{
  #define H_XtGetApplicationNameAndClass "void XtGetApplicationNameAndClass(display) returns the application name \
and class passed to XtDisplayInitialize for the specified display."
  /* DIFF: XtGetApplicationNameAndClass omits and rtns args 2 and 3
   */
  char *name, *clas;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XtGetApplicationNameAndClass", "Display*");
  XtGetApplicationNameAndClass(XEN_TO_C_Display(arg1), &name, &clas);
  return(XEN_LIST_2(C_TO_XEN_STRING(name),
		    C_TO_XEN_STRING(clas)));
}

static XEN gxm_XtUngrabPointer(XEN arg1, XEN arg2)
{
  #define H_XtUngrabPointer "void XtUngrabPointer(widget, time) calls XUngrabPointer with the specified time."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtUngrabPointer", "Widget");
  XEN_ASSERT_TYPE(XEN_Time_P(arg2), arg2, 2, "XtUngrabPointer", "Time");
  XtUngrabPointer(XEN_TO_C_Widget(arg1), XEN_TO_C_Time(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XtGrabPointer(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7, XEN arg8)
{
  #define H_XtGrabPointer "int XtGrabPointer(widget, owner_events, event_mask, pointer_mode, keyboard_mode, confine_to, cursor, time) calls \
XGrabPointer specifying the widget's window as the grab window."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtGrabPointer", "Widget");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg2), arg2, 2, "XtGrabPointer", "boolean");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XtGrabPointer", "unsigned int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XtGrabPointer", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XtGrabPointer", "int");
  XEN_ASSERT_TYPE(XEN_Window_P(arg6), arg6, 6, "XtGrabPointer", "Window");
  XEN_ASSERT_TYPE(XEN_Cursor_P(arg7), arg7, 7, "XtGrabPointer", "Cursor");
  XEN_ASSERT_TYPE(XEN_Time_P(arg8), arg8, 8, "XtGrabPointer", "Time");
  return(C_TO_XEN_INT(XtGrabPointer(XEN_TO_C_Widget(arg1), 
				    XEN_TO_C_BOOLEAN(arg2), XEN_TO_C_ULONG(arg3), 
				    XEN_TO_C_INT(arg4), XEN_TO_C_INT(arg5), 
				    XEN_TO_C_Window(arg6), XEN_TO_C_Cursor(arg7), 
				    XEN_TO_C_Time(arg8))));
}

static XEN gxm_XtUngrabButton(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XtUngrabButton "void XtUngrabButton(widget, button, modifiers) calls XUngrabButton specifying the widget's window as the ungrab \
window if the widget is realized. "
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtUngrabButton", "Widget");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XtUngrabButton", "unsigned int");
  XEN_ASSERT_TYPE(XEN_Modifiers_P(arg3), arg3, 3, "XtUngrabButton", "Modifiers");
  XtUngrabButton(XEN_TO_C_Widget(arg1), XEN_TO_C_ULONG(arg2), XEN_TO_C_Modifiers(arg3));
  return(XEN_FALSE);
}

static XEN gxm_XtGrabButton(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7, XEN arg8, XEN arg9)
{
  #define H_XtGrabButton "void XtGrabButton(widget, button, modifiers, owner_events, event_mask, pointer_mode, keyboard_mode, confine_to, cursor) \
calls XGrabButton specifying the widget's window as the grab window if the widget is realized."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtGrabButton", "Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XtGrabButton", "int");
  XEN_ASSERT_TYPE(XEN_Modifiers_P(arg3), arg3, 3, "XtGrabButton", "Modifiers");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg4), arg4, 4, "XtGrabButton", "boolean");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg5), arg5, 5, "XtGrabButton", "unsigned int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XtGrabButton", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg7), arg7, 7, "XtGrabButton", "int");
  XEN_ASSERT_TYPE(XEN_Window_P(arg8), arg8, 8, "XtGrabButton", "Window");
  XEN_ASSERT_TYPE(XEN_Cursor_P(arg9), arg9, 9, "XtGrabButton", "Cursor");
  XtGrabButton(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2), 
	       XEN_TO_C_Modifiers(arg3), XEN_TO_C_BOOLEAN(arg4), XEN_TO_C_ULONG(arg5), XEN_TO_C_INT(arg6), XEN_TO_C_INT(arg7), 
	       XEN_TO_C_Window(arg8), XEN_TO_C_Cursor(arg9));
  return(XEN_FALSE);
}

static XEN gxm_XtUngrabKeyboard(XEN arg1, XEN arg2)
{
  #define H_XtUngrabKeyboard "void XtUngrabKeyboard(widget, time) calls XUngrabKeyboard with the specified time."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtUngrabKeyboard", "Widget");
  XEN_ASSERT_TYPE(XEN_Time_P(arg2), arg2, 2, "XtUngrabKeyboard", "Time");
  XtUngrabKeyboard(XEN_TO_C_Widget(arg1), XEN_TO_C_Time(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XtGrabKeyboard(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XtGrabKeyboard "int XtGrabKeyboard(widget, owner_events, pointer_mode, keyboard_mode, time)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtGrabKeyboard", "Widget");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg2), arg2, 2, "XtGrabKeyboard", "boolean");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XtGrabKeyboard", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XtGrabKeyboard", "int");
  XEN_ASSERT_TYPE(XEN_Time_P(arg5), arg5, 5, "XtGrabKeyboard", "Time");
  return(C_TO_XEN_INT(XtGrabKeyboard(XEN_TO_C_Widget(arg1), XEN_TO_C_BOOLEAN(arg2), XEN_TO_C_INT(arg3), XEN_TO_C_INT(arg4), XEN_TO_C_Time(arg5))));
}

static XEN gxm_XtUngrabKey(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XtUngrabKey "void XtUngrabKey(widget, keycode, modifiers) calls XUngrabKey specifying the widget's window as the ungrab window \
if the widget is realized."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtUngrabKey", "Widget");
  XEN_ASSERT_TYPE(XEN_KeyCode_P(arg2), arg2, 2, "XtUngrabKey", "KeyCode");
  XEN_ASSERT_TYPE(XEN_Modifiers_P(arg3), arg3, 3, "XtUngrabKey", "Modifiers");
  XtUngrabKey(XEN_TO_C_Widget(arg1), XEN_TO_C_KeyCode(arg2), XEN_TO_C_Modifiers(arg3));
  return(XEN_FALSE);
}

static XEN gxm_XtGrabKey(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6)
{
  #define H_XtGrabKey "void XtGrabKey(widget, keycode, modifiers, owner_events, pointer_mode, keyboard_mode) calls XGrabKey specifying the \
widget's window as the grab window if the widget is realized."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtGrabKey", "Widget");
  XEN_ASSERT_TYPE(XEN_KeyCode_P(arg2), arg2, 2, "XtGrabKey", "KeyCode");
  XEN_ASSERT_TYPE(XEN_Modifiers_P(arg3), arg3, 3, "XtGrabKey", "Modifiers");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg4), arg4, 4, "XtGrabKey", "boolean");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XtGrabKey", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XtGrabKey", "int");
  XtGrabKey(XEN_TO_C_Widget(arg1), XEN_TO_C_KeyCode(arg2), XEN_TO_C_Modifiers(arg3), XEN_TO_C_BOOLEAN(arg4), XEN_TO_C_INT(arg5), XEN_TO_C_INT(arg6));
  return(XEN_FALSE);
}

static XEN gxm_XtCancelSelectionRequest(XEN arg1, XEN arg2)
{
  #define H_XtCancelSelectionRequest "void XtCancelSelectionRequest(requestor, selection)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtCancelSelectionRequest", "Widget");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg2), arg2, 2, "XtCancelSelectionRequest", "Atom");
  XtCancelSelectionRequest(XEN_TO_C_Widget(arg1), XEN_TO_C_Atom(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XtSendSelectionRequest(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XtSendSelectionRequest "void XtSendSelectionRequest(requestor, selection, time)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtSendSelectionRequest", "Widget");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg2), arg2, 2, "XtSendSelectionRequest", "Atom");
  XEN_ASSERT_TYPE(XEN_Time_P(arg3), arg3, 3, "XtSendSelectionRequest", "Time");
  XtSendSelectionRequest(XEN_TO_C_Widget(arg1), XEN_TO_C_Atom(arg2), XEN_TO_C_Time(arg3));
  return(XEN_FALSE);
}

static XEN gxm_XtCreateSelectionRequest(XEN arg1, XEN arg2)
{
  #define H_XtCreateSelectionRequest "void XtCreateSelectionRequest(requestor, selection)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtCreateSelectionRequest", "Widget");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg2), arg2, 2, "XtCreateSelectionRequest", "Atom");
  XtCreateSelectionRequest(XEN_TO_C_Widget(arg1), XEN_TO_C_Atom(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XtGetSelectionValuesIncremental(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7)
{
  #define H_XtGetSelectionValuesIncremental "void XtGetSelectionValuesIncremental(w, selection, targets, count, callback, client_data, time) \
is similar to XtGetSelectionValueIncremental except that it takes a list of target types and a list of client data and obtains the current \
value of the selection converted to each of the targets."
  /* DIFF: XtGetSelectionValuesIncremental arg 3 is list of Atoms
   */
  Atom *outs;
  int len, loc;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtGetSelectionValuesIncremental", "Widget");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg2), arg2, 2, "XtGetSelectionValuesIncremental", "Atom");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg3), arg3, 3, "XtGetSelectionValuesIncremental", "list of Atom");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XtGetSelectionValuesIncremental", "int");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg5) && (XEN_REQUIRED_ARGS_OK(arg5, 7)), arg5, 5, "XtGetSelectionValuesIncremental", "XtSelectionCallbackProc");
  XEN_ASSERT_TYPE(XEN_Time_P(arg7), arg7, 7, "XtGetSelectionValuesIncremental", "Time");
  len = XEN_TO_C_INT(arg4);
  if (len <= 0) return(XEN_FALSE);
  outs = XEN_TO_C_Atoms(arg3, len);
  xm_XtSelectionCallback_Descr = XEN_LIST_2(arg5, arg6);
  loc = xm_protect(xm_XtSelectionCallback_Descr);
  XtGetSelectionValuesIncremental(XEN_TO_C_Widget(arg1), 
				  XEN_TO_C_Atom(arg2), outs, len, 
				  gxm_XtSelectionCallbackProc, 
				  (XtPointer *)arg6, XEN_TO_C_Time(arg7));
  xm_unprotect_at(loc);
  FREE(outs);
  return(XEN_FALSE);
}  

static XEN gxm_XtGetSelectionValueIncremental(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6)
{
  #define H_XtGetSelectionValueIncremental "void XtGetSelectionValueIncremental(w, selection, target, callback, client_data, time) is similar \
to XtGetSelectionValue except that the selection_callback procedure will be called repeatedly upon delivery of multiple segments of the selection value."
  int loc;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtGetSelectionValueIncremental", "Widget");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg2), arg2, 2, "XtGetSelectionValueIncremental", "Atom");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg3), arg3, 3, "XtGetSelectionValueIncremental", "Atom");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg4) && (XEN_REQUIRED_ARGS_OK(arg4, 7)), arg4, 4, "XtGetSelectionValueIncremental", "XtSelectionCallbackProc");
  XEN_ASSERT_TYPE(XEN_Time_P(arg6), arg6, 6, "XtGetSelectionValueIncremental", "Time");
  xm_XtSelectionCallback_Descr = XEN_LIST_2(arg4, arg5);
  loc = xm_protect(xm_XtSelectionCallback_Descr);
  XtGetSelectionValueIncremental(XEN_TO_C_Widget(arg1), 
				 XEN_TO_C_Atom(arg2), XEN_TO_C_Atom(arg3), 
				 gxm_XtSelectionCallbackProc, 
				 (XtPointer)arg5, XEN_TO_C_Time(arg6));
  xm_unprotect_at(loc);
  return(XEN_FALSE);
}

static XEN gxm_XtGetSelectionRequest(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XtGetSelectionRequest "XSelectionRequestEvent* XtGetSelectionRequest(w, selection, request_id)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtGetSelectionRequest", "Widget");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg2), arg2, 2, "XtGetSelectionRequest", "Atom");
  XEN_ASSERT_TYPE(XEN_XtRequestId_P(arg3), arg3, 3, "XtGetSelectionRequest", "XtRequestId");
  return(C_TO_XEN_XSelectionRequestEvent(XtGetSelectionRequest(XEN_TO_C_Widget(arg1), XEN_TO_C_Atom(arg2), XEN_TO_C_XtRequestId(arg3))));
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XtGetSelectionTimeout(void)
{
  #define H_XtGetSelectionTimeout "unsigned long XtGetSelectionTimeout() has been superseded by XtAppGetSelectionTimeout."
  return(C_TO_XEN_ULONG(XtGetSelectionTimeout()));
}

static XEN gxm_XtSetSelectionTimeout(XEN arg1)
{
  #define H_XtSetSelectionTimeout "void XtSetSelectionTimeout(timeout) has been superseded by XtAppSetSelectionTimeout."
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg1), arg1, 1, "XtSetSelectionTimeout", "ulong");
  XtSetSelectionTimeout(XEN_TO_C_ULONG(arg1));
  return(XEN_FALSE);
}
#endif

static XEN gxm_XtAppGetSelectionTimeout(XEN arg1)
{
  #define H_XtAppGetSelectionTimeout "unsigned long XtAppGetSelectionTimeout(app_context) returns the current selection timeout value, in milliseconds."
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtAppGetSelectionTimeout", "XtAppContext");
  return(C_TO_XEN_ULONG(XtAppGetSelectionTimeout(XEN_TO_C_XtAppContext(arg1))));
}

static XEN gxm_XtAppSetSelectionTimeout(XEN arg1, XEN arg2)
{
  #define H_XtAppSetSelectionTimeout "void XtAppSetSelectionTimeout(app_context, timeout) sets the app's selection timeout mechanism."
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtAppSetSelectionTimeout", "XtAppContext");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XtAppSetSelectionTimeout", "ulong");
  XtAppSetSelectionTimeout(XEN_TO_C_XtAppContext(arg1), XEN_TO_C_ULONG(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XtGetSelectionValues(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7)
{
  #define H_XtGetSelectionValues "void XtGetSelectionValues(w, selection, targets, count, callback, client_data, time) is similar to \
XtGetSelectionValue except that it takes a list of target types and a list of client data and obtains the current value of the selection \
converted to each of the targets."
  /* DIFF: XtGetSelectionValues arg 3 is list of Atoms
   */
  Atom *outs;
  int len, loc;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtGetSelectionValues", "Widget");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg2), arg2, 2, "XtGetSelectionValues", "Atom");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg3), arg3, 3, "XtGetSelectionValues", "list of Atom");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XtGetSelectionValues", "int");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg5) && (XEN_REQUIRED_ARGS_OK(arg5, 7)), arg5, 5, "XtGetSelectionValues", "XtSelectionCallbackProc");
  XEN_ASSERT_TYPE(XEN_Time_P(arg7), arg7, 7, "XtGetSelectionValues", "Time");
  len = XEN_TO_C_INT(arg4);
  if (len <= 0) return(XEN_FALSE);
  outs = XEN_TO_C_Atoms(arg3, len);
  xm_XtSelectionCallback_Descr = XEN_LIST_2(arg5, arg6);
  loc = xm_protect(xm_XtSelectionCallback_Descr);
  XtGetSelectionValues(XEN_TO_C_Widget(arg1), 
		       XEN_TO_C_Atom(arg2), outs, len, 
		       gxm_XtSelectionCallbackProc, 
		       (XtPointer *)arg6, XEN_TO_C_Time(arg7));
  xm_unprotect_at(loc);
  FREE(outs);
  return(XEN_FALSE);
}

static XEN gxm_XtGetSelectionValue(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6)
{
  #define H_XtGetSelectionValue "void XtGetSelectionValue(w, selection, target, callback, client_data, time) requests the value of the \
selection that has been converted to the target type. "
  int loc;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtGetSelectionValue", "Widget");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg2), arg2, 2, "XtGetSelectionValue", "Atom");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg3), arg3, 3, "XtGetSelectionValue", "Atom");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg4) && (XEN_REQUIRED_ARGS_OK(arg4, 7)), arg4, 4, "XtGetSelectionValue", "XtSelectionCallbackProc");
  XEN_ASSERT_TYPE(XEN_Time_P(arg6), arg6, 6, "XtGetSelectionValue", "Time");
  xm_XtSelectionCallback_Descr = XEN_LIST_2(arg4, arg5);
  loc = xm_protect(xm_XtSelectionCallback_Descr);
  XtGetSelectionValue(XEN_TO_C_Widget(arg1), 
		      XEN_TO_C_Atom(arg2), 
		      XEN_TO_C_Atom(arg3), 
		      gxm_XtSelectionCallbackProc, 
		      (XtPointer)arg5, XEN_TO_C_Time(arg6));
  xm_unprotect_at(loc);
  return(XEN_FALSE);
}

static XEN gxm_XtDisownSelection(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XtDisownSelection "void XtDisownSelection(w, selection, time) informs the selection mechanism that the specified widget is to \
lose ownership of the selection."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtDisownSelection", "Widget");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg2), arg2, 2, "XtDisownSelection", "Atom");
  XEN_ASSERT_TYPE(XEN_Time_P(arg3), arg3, 3, "XtDisownSelection", "Time");
  XtDisownSelection(XEN_TO_C_Widget(arg1), XEN_TO_C_Atom(arg2), XEN_TO_C_Time(arg3));
  return(XEN_FALSE);
}


/*-------- file predicate -------- */

/* a "Substitution" is a list '(char substitute), so pass a list of such lists below where a substitution array is required */

static XEN xm_filepredicate_proc;

static Boolean gxm_XtFilePredicate(String filename) 
{
  return(XEN_TO_C_BOOLEAN(XEN_CALL_1(xm_filepredicate_proc,
				     C_TO_XEN_STRING(filename),
				     c__FUNCTION__)));
}

static SubstitutionRec *gxm_make_subs(XEN lst_1)
{
  int len;
  SubstitutionRec *subs = NULL;
  len = XEN_LIST_LENGTH(lst_1);
  if (len > 0)
    {
      int i;
      XEN lst;
      lst = XEN_COPY_ARG(lst_1);
      subs = (SubstitutionRec *)CALLOC(len, sizeof(SubstitutionRec));
      for (i = 0; i < len; i++, lst = XEN_CDR(lst))
	{
	  if (!(XEN_LIST_P(XEN_CAR(lst))))
	    {
	      FREE(subs);
	      return(NULL);
	    }
	  subs[i].match = XEN_TO_C_CHAR(XEN_CAR(XEN_CAR(lst)));
	  subs[i].substitution = strdup(XEN_TO_C_STRING(XEN_CADR(XEN_CAR(lst))));
	}
    }
  return(subs);
}

/* (XtFindFile "/lib/%N:/usr/lib/%N:/usr/local/lib/%N" (list (list #\N "libxm.so")) 1 file-exists?) */

static XEN gxm_XtResolvePathname(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7, XEN arg8)
{
  #define H_XtResolvePathname "String XtResolvePathname(display, type, filename, suffix, path, substitutions, num_substitutions, predicate)"
  /* DIFF: XtResolvePathname args use #f for NULL
   *       (XtResolvePathname (XtDisplay (cadr (main-widgets))) "app-defaults" #f #f #f #f 0 #f)
   */
  int arg8_loc = -1;
  XEN res;
  char *str;
  SubstitutionRec *subs = NULL;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XtResolvePathname", "Display*");
  XEN_ASSERT_TYPE(XEN_FALSE_P(arg2) || XEN_STRING_P(arg2), arg2, 2, "XtResolvePathname", "char*");
  XEN_ASSERT_TYPE(XEN_FALSE_P(arg3) || XEN_STRING_P(arg3), arg3, 3, "XtResolvePathname", "char*");
  XEN_ASSERT_TYPE(XEN_FALSE_P(arg4) || XEN_STRING_P(arg4), arg4, 4, "XtResolvePathname", "char*");
  XEN_ASSERT_TYPE(XEN_FALSE_P(arg5) || XEN_STRING_P(arg5), arg5, 5, "XtResolvePathname", "char*");
  XEN_ASSERT_TYPE(XEN_FALSE_P(arg6) || XEN_LIST_P(arg6), arg6, 6, "XtResolvePathname", "Substitution list");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg7), arg7, 7, "XtResolvePathname", "int");
  XEN_ASSERT_TYPE(XEN_FALSE_P(arg8) || 
		  (XEN_PROCEDURE_P(arg8) && (XEN_REQUIRED_ARGS_OK(arg8, 1))), 
		  arg8, 8, "XtResolvePathname", "XtFilePredicate (takes 1 arg)");
  if (XEN_LIST_P(arg6)) 
    {
      subs = gxm_make_subs(XEN_COPY_ARG(arg6));
      if (subs == NULL) return(XEN_FALSE); /* type error? */
    }
  if (XEN_PROCEDURE_P(arg8))
    {
      arg8_loc = xm_protect(arg8);
      xm_filepredicate_proc = arg8;
    }
  str = XtResolvePathname(XEN_TO_C_Display(arg1), 
			  (XEN_FALSE_P(arg2)) ? NULL : XEN_TO_C_STRING(arg2), 
			  (XEN_FALSE_P(arg3)) ? NULL : XEN_TO_C_STRING(arg3), 
			  (XEN_FALSE_P(arg4)) ? NULL : XEN_TO_C_STRING(arg4), 
			  (XEN_FALSE_P(arg5)) ? NULL : XEN_TO_C_STRING(arg5), 
			  subs,
			  XEN_TO_C_INT(arg7), 
			  (XEN_FALSE_P(arg8)) ? NULL : gxm_XtFilePredicate);
  if (XEN_PROCEDURE_P(arg8)) xm_unprotect_at(arg8_loc);
  if (subs) 
    {
      int i, len;
      len = XEN_LIST_LENGTH(arg6);
      for (i = 0; i < len; i++)
	if (subs[i].substitution) free(subs[i].substitution);
      FREE(subs);
    }
  res = C_TO_XEN_STRING(str);
  if (str) XtFree(str);
  return(res);
}

static XEN gxm_XtFindFile(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XtFindFile "String XtFindFile(path, substitutions, num_substitutions, predicate) \
searches for a file using substitutions in the path list"
  char *str;
  XEN res;
  int arg4_loc = -1;
  SubstitutionRec *subs = NULL;
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XtFindFile", "char*");
  XEN_ASSERT_TYPE(XEN_FALSE_P(arg2) || XEN_LIST_P(arg2), arg2, 2, "XtFindFile", "Substitution list");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XtFindFile", "int");
  XEN_ASSERT_TYPE(XEN_FALSE_P(arg4) || 
		  (XEN_PROCEDURE_P(arg4) && (XEN_REQUIRED_ARGS_OK(arg4, 1))), 
		  arg4, 4, "XtFindFile", "XtFilePredicate (takes 1 arg)");
  if (XEN_LIST_P(arg2)) 
    {
      subs = gxm_make_subs(XEN_COPY_ARG(arg2));
      if (subs == NULL) return(XEN_FALSE); /* type error? */
    }
  if (XEN_PROCEDURE_P(arg4))
    {
      arg4_loc = xm_protect(arg4);
      xm_filepredicate_proc = arg4;
    }
  str = XtFindFile(XEN_TO_C_STRING(arg1), 
		   subs,
		   XEN_TO_C_INT(arg3),
		   (XEN_FALSE_P(arg4) ? NULL : gxm_XtFilePredicate));
  if (XEN_PROCEDURE_P(arg4)) xm_unprotect_at(arg4_loc);
  if (subs) 
    {
      int i, len;
      len = XEN_LIST_LENGTH(arg2);
      for (i = 0; i < len; i++)
	if (subs[i].substitution) free(subs[i].substitution);
      FREE(subs);
    }
  res = C_TO_XEN_STRING(str);
  if (str) XtFree(str);
  return(res);
}

static XEN gxm_XtReleaseGC(XEN arg1, XEN arg2)
{
  #define H_XtReleaseGC "void XtReleaseGC(w, gc) deallocate the specified shared GC."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtReleaseGC", "Widget");
  XEN_ASSERT_TYPE(XEN_GC_P(arg2), arg2, 2, "XtReleaseGC", "GC");
  XtReleaseGC(XEN_TO_C_Widget(arg1), XEN_TO_C_GC(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XtDestroyGC(XEN arg1)
{
  #define H_XtDestroyGC "XtDestroyGC(gc) is obsolete -- use XtReleaseGC"
  XEN_ASSERT_TYPE(XEN_GC_P(arg1), arg1, 1, "XtDestroyGC", "GC");
  XtDestroyGC(XEN_TO_C_GC(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XtAllocateGC(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6)
{
  #define H_XtAllocateGC "GC XtAllocateGC(w, depth, value_mask, values, dynamic_mask, unused_mask) returns a sharable GC that may be modified by the client."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtAllocateGC", "Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XtAllocateGC", "int");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XtAllocateGC", "XtGCMask");
  XEN_ASSERT_TYPE(XEN_XGCValues_P(arg4), arg4, 4, "XtAllocateGC", "XGCValues*");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg5), arg5, 5, "XtAllocateGC", "XtGCMask");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg6), arg6, 6, "XtAllocateGC", "XtGCMask");
  return(C_TO_XEN_GC(XtAllocateGC(XEN_TO_C_Widget(arg1), XEN_TO_C_INT(arg2), 
				  XEN_TO_C_ULONG(arg3), XEN_TO_C_XGCValues(arg4), 
				  XEN_TO_C_ULONG(arg5), XEN_TO_C_ULONG(arg6))));
}

static XEN gxm_XtGetGC(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XtGetGC "GC XtGetGC(w, value_mask, values) returns a sharable, read-only GC."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtGetGC", "Widget");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XtGetGC", "XtGCMask");
  XEN_ASSERT_TYPE(XEN_XGCValues_P(arg3), arg3, 3, "XtGetGC", "XGCValues*");
  return(C_TO_XEN_GC(XtGetGC(XEN_TO_C_Widget(arg1), XEN_TO_C_ULONG(arg2), XEN_TO_C_XGCValues(arg3))));
}


/* -------- background process -------- */

/* (80) XtWorkProc called (protected) until quits or removed explicitly */

#define C_TO_XEN_XM_Background(Code, Context) \
  XEN_LIST_5(C_STRING_TO_XEN_SYMBOL("Background"), Code, Context, XEN_ZERO, XEN_ZERO)
#define XM_Background_P(Arg) WRAP_P("Background", Arg)

static Boolean gxm_XtWorkProc(XtPointer cdata)
{
  /* if true, quits */
  int val;
  XEN descr = (XEN)cdata;
  /* (list 'Background function context gc-loc id) */
  val = XEN_TO_C_BOOLEAN(XEN_CALL_1(XEN_CADR(descr), 
				    XEN_CADDR(descr),
				    c__FUNCTION__));
  if (val) xm_unprotect_at(XEN_TO_C_INT(XEN_LIST_REF(descr, 3)));
  return(val);
}

static bool unprotect_workproc(XEN val, int loc, unsigned long id)
{
  if ((XM_Background_P(val)) &&
      ((XtWorkProcId)XEN_TO_C_ULONG(XEN_LIST_REF(val, 4)) == id))
    {
      xm_unprotect_at(loc);
      return(true);
    }
  return(false);
}

static XEN gxm_XtRemoveWorkProc(XEN arg1)
{
  #define H_XtRemoveWorkProc "void XtRemoveWorkProc(id) explicitly removes the specified background work procedure."
  XtWorkProcId id;
  XEN_ASSERT_TYPE(XEN_XtWorkProcId_P(arg1), arg1, 1, "XtRemoveWorkProc", "XtWorkProcId");
  id = XEN_TO_C_XtWorkProcId(arg1);
  XtRemoveWorkProc(id);
  map_over_protected_elements(unprotect_workproc, id);
  return(XEN_FALSE);
}

static XEN gxm_XtAppAddWorkProc(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XtAppAddWorkProc "XtWorkProcId XtAppAddWorkProc(app_context, proc, client_data) adds the specified work procedure for the \
application identified by app_context."
  XtWorkProcId id;
  int gc_loc;
  XEN descr;
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtAppAddWorkProc", "XtAppContext");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg2) && (XEN_REQUIRED_ARGS_OK(arg2, 1)), arg2, 2, "XtAppAddWorkProc", "(XtWorkProc data)");
  
  descr = C_TO_XEN_XM_Background(arg2, (XEN_BOUND_P(arg3)) ? arg3 : XEN_FALSE);
  gc_loc = xm_protect(descr);
  id = XtAppAddWorkProc(XEN_TO_C_XtAppContext(arg1), 
			gxm_XtWorkProc, 
			(XtPointer)descr);
  XEN_LIST_SET(descr, 3, C_TO_XEN_INT(gc_loc));
  XEN_LIST_SET(descr, 4, C_TO_XEN_ULONG(id));
  return(C_TO_XEN_XtWorkProcId(id));
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XtAddWorkProc(XEN arg1, XEN arg2)
{
  #define H_XtAddWorkProc "XtWorkProcId XtAddWorkProc(proc, client_data) has been replaced by XtAppAddWorkProc."
  XtWorkProcId id;
  int gc_loc;
  XEN descr;
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg1) && (XEN_REQUIRED_ARGS_OK(arg1, 1)), arg1, 1, "XtAddWorkProc", "(XtWorkProc data)");
  descr = C_TO_XEN_XM_Background(arg1, (XEN_BOUND_P(arg2)) ? arg2 : XEN_FALSE);
  gc_loc = xm_protect(descr);
  id = XtAddWorkProc(gxm_XtWorkProc, 
		     (XtPointer)descr);
  XEN_LIST_SET(descr, 3, C_TO_XEN_INT(gc_loc));
  XEN_LIST_SET(descr, 4, C_TO_XEN_ULONG(id));
  return(C_TO_XEN_XtWorkProcId(id));
}
#endif

/* the next 4 are needed where the caller allocates a block of memory, but X frees it (XCreateImage) --
 *   can't use Scheme-allocated memory here etc
 */
static XEN gxm_XtFree(XEN arg1)
{
  #define H_XtFree "void XtFree(ptr)"
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg1), arg1, 1, "XtFree", "pointer");
  XtFree((char *)XEN_TO_C_ULONG(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XtRealloc(XEN arg1, XEN arg2)
{
  #define H_XtRealloc "char *XtRealloc(ptr, num)"
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg1), arg1, 1, "XtRealloc", "pointer");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XtRealloc", "int");
  return(C_TO_XEN_ULONG(XtRealloc((char *)XEN_TO_C_ULONG(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XtCalloc(XEN arg1, XEN arg2)
{
  #define H_XtCalloc "char *XtCalloc(num, size)"
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg1), arg1, 1, "XtCalloc", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XtCalloc", "int");
  return(C_TO_XEN_ULONG(XtCalloc(XEN_TO_C_INT(arg1), XEN_TO_C_INT(arg2))));
}

static XEN gxm_XtMalloc(XEN arg1)
{
  #define H_XtMalloc "char *XtMalloc(size)"
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg1), arg1, 1, "XtMalloc", "int");
  return(C_TO_XEN_ULONG(XtMalloc(XEN_TO_C_INT(arg1))));
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XtWarning(XEN arg1)
{
  #define H_XtWarning "void XtWarning(message)"
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XtWarning", "char*");
  XtWarning(XEN_TO_C_STRING(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XtAppWarning(XEN arg1, XEN arg2)
{
  #define H_XtAppWarning "void XtAppWarning(app_context, message) calls the installed nonfatal error procedure and passes the specified message."
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtAppWarning", "XtAppContext");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XtAppWarning", "char*");
  XtAppWarning(XEN_TO_C_XtAppContext(arg1), XEN_TO_C_STRING(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XtError(XEN arg1)
{
  #define H_XtError "void XtError(message)"
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XtError", "char*");
  XtError(XEN_TO_C_STRING(arg1));
  return(XEN_FALSE);
}
#endif

static XEN xm_XtErrorHandler = XEN_FALSE;
static XEN xm_XtWarningHandler = XEN_FALSE;

static void gxm_XtErrorHandler(String msg)
{
  if (XEN_PROCEDURE_P(xm_XtErrorHandler))
    XEN_CALL_1(xm_XtErrorHandler, 
	       C_TO_XEN_STRING(msg), 
	       c__FUNCTION__);
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XtSetErrorHandler(XEN arg1)
{
  #define H_XtSetErrorHandler "void XtSetErrorHandler(handler) has been superseded by XtAppSetErrorHandler."
  XEN old_val;
  old_val = xm_XtErrorHandler;
  xm_protect(arg1);
  xm_XtErrorHandler = arg1;
  XtSetErrorHandler(gxm_XtErrorHandler);
  if (XEN_PROCEDURE_P(old_val)) xm_unprotect(old_val);
  return(old_val);
}
#endif

static XEN gxm_XtAppSetErrorHandler(XEN arg1, XEN arg2)
{
  #define H_XtAppSetErrorHandler "void XtAppSetErrorHandler(app_context, handler) registers the specified procedure, which is called when \
a fatal error condition occurs."
  XEN old_val;
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtAppSetErrorHandler", "XtAppContext");
  old_val = xm_XtErrorHandler;
  xm_protect(arg2);
  xm_XtErrorHandler = arg2;
  XtAppSetErrorHandler(XEN_TO_C_XtAppContext(arg1), gxm_XtErrorHandler);
  if (XEN_PROCEDURE_P(old_val)) xm_unprotect(old_val);
  return(old_val);
}

static void gxm_XtWarningHandler(String msg)
{
  if (XEN_PROCEDURE_P(xm_XtWarningHandler))
    XEN_CALL_1(xm_XtWarningHandler, 
	       C_TO_XEN_STRING(msg), 
	       c__FUNCTION__);
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XtSetWarningHandler(XEN arg1)
{
  #define H_XtSetWarningHandler "void XtSetWarningHandler(handler) has been superseded by XtAppSetWarningHandler."
  XEN old_val;
  old_val = xm_XtWarningHandler;
  xm_protect(arg1);
  xm_XtWarningHandler = arg1;
  XtSetWarningHandler(gxm_XtWarningHandler);
  if (XEN_PROCEDURE_P(old_val)) xm_unprotect(old_val);
  return(old_val);
}
#endif

static XEN gxm_XtAppSetWarningHandler(XEN arg1, XEN arg2)
{
  #define H_XtAppSetWarningHandler "void XtAppSetWarningHandler(app_context, handler) registers the specified procedure, which is called \
when a nonfatal error condition occurs."
  XEN old_val;
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtAppSetWarningHandler", "XtAppContext");
  old_val = xm_XtWarningHandler;
  xm_protect(arg2);
  xm_XtWarningHandler = arg2;
  XtAppSetWarningHandler(XEN_TO_C_XtAppContext(arg1), gxm_XtWarningHandler);
  if (XEN_PROCEDURE_P(old_val)) xm_unprotect(old_val);
  return(old_val);
}

static XEN gxm_XtAppError(XEN arg1, XEN arg2)
{
  #define H_XtAppError "void XtAppError(app_context, message) calls the installed error procedure and passes the specified message."
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtAppError", "XtAppContext");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XtAppError", "char*");
  XtAppError(XEN_TO_C_XtAppContext(arg1), XEN_TO_C_STRING(arg2));
  return(XEN_FALSE);
}


#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XtWarningMsg(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6)
{
  #define H_XtWarningMsg "void XtWarningMsg(name, type, class, default, params, num_params)"
  /* DIFF: XtWarningMsg takes final int not int*, arg5 is list of strings
   */
  int size;
  Cardinal csize;
  char **pars;
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XtWarningMsg", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XtWarningMsg", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3), arg3, 3, "XtWarningMsg", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg4), arg4, 4, "XtWarningMsg", "char*");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg5), arg5, 5, "XtWarningMsg", "list of String");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XtWarningMsg", "int");
  size = XEN_TO_C_INT(arg6);
  if (size <= 0) return(XEN_FALSE);
  pars = XEN_TO_C_Strings(arg5, size);
  csize = (Cardinal)size;
  XtWarningMsg(XEN_TO_C_STRING(arg1), XEN_TO_C_STRING(arg2), XEN_TO_C_STRING(arg3), XEN_TO_C_STRING(arg4), pars, &csize);
  FREE(pars);
  return(xen_return_first(XEN_FALSE, arg5));
}
#endif

static XEN gxm_XtAppWarningMsg(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7)
{
  #define H_XtAppWarningMsg "void XtAppWarningMsg(app_context, name, type, class, default, params, num_params) calls the high-level error \
handler and passes the specified information."
  /* DIFF: XtAppWarningMsg takes final int not int*, arg6 is list of strings
   */
  int size;
  Cardinal csize;
  char **pars;
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtAppWarningMsg", "XtAppContext");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XtAppWarningMsg", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3), arg3, 3, "XtAppWarningMsg", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg4), arg4, 4, "XtAppWarningMsg", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg5), arg5, 5, "XtAppWarningMsg", "char*");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg6), arg6, 6, "XtAppWarningMsg", "list of String");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg7), arg7, 7, "XtAppWarningMsg", "int");
  size = XEN_TO_C_INT(arg7);
  if (size <= 0) return(XEN_FALSE);
  pars = XEN_TO_C_Strings(arg6, size);
  csize = (Cardinal)size;
  XtAppWarningMsg(XEN_TO_C_XtAppContext(arg1), XEN_TO_C_STRING(arg2), 
		  XEN_TO_C_STRING(arg3), XEN_TO_C_STRING(arg4), XEN_TO_C_STRING(arg5), 
		  pars, &csize);
  FREE(pars);
  return(xen_return_first(XEN_FALSE, arg6));
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XtErrorMsg(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6)
{
  #define H_XtErrorMsg "void XtErrorMsg(name, type, class, default, params, num_params) has been superseded by XtAppErrorMsg."
  /* DIFF: XtErrorMsg takes final int not int*, arg5 is list of strings
   */
  int size;
  Cardinal csize;
  char **pars;
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XtErrorMsg", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XtErrorMsg", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3), arg3, 3, "XtErrorMsg", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg4), arg4, 4, "XtErrorMsg", "char*");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg5), arg5, 5, "XtErrorMsg", "list of String");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XtErrorMsg", "int");
  size = XEN_TO_C_INT(arg6);
  if (size <= 0) return(XEN_FALSE);
  pars = XEN_TO_C_Strings(arg5, size);
  csize = (Cardinal)size;
  XtErrorMsg(XEN_TO_C_STRING(arg1), XEN_TO_C_STRING(arg2), XEN_TO_C_STRING(arg3), XEN_TO_C_STRING(arg4), pars, &csize);
  FREE(pars);
  return(xen_return_first(XEN_FALSE, arg5));
}
#endif

static XEN gxm_XtAppErrorMsg(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7)
{
  #define H_XtAppErrorMsg "void XtAppErrorMsg(app_context, name, type, class, default, params, num_params) calls the high-level error \
handler and passes the specified information."
  /* DIFF: XtAppErrorMsg takes final int not int*, arg6 is list of strings
   */
  int size;
  Cardinal csize;
  char **pars;
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtAppErrorMsg", "XtAppContext");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XtAppErrorMsg", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3), arg3, 3, "XtAppErrorMsg", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg4), arg4, 4, "XtAppErrorMsg", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg5), arg5, 5, "XtAppErrorMsg", "char*");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg6), arg6, 6, "XtAppErrorMsg", "list of String");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg7), arg7, 7, "XtAppErrorMsg", "int");
  size = XEN_TO_C_INT(arg7);
  if (size <= 0) return(XEN_FALSE);
  pars = XEN_TO_C_Strings(arg6, size);
  csize = (Cardinal)size;
  XtAppErrorMsg(XEN_TO_C_XtAppContext(arg1), XEN_TO_C_STRING(arg2), 
		XEN_TO_C_STRING(arg3), XEN_TO_C_STRING(arg4), 
		XEN_TO_C_STRING(arg5), pars, &csize);
  FREE(pars);
  return(xen_return_first(XEN_FALSE, arg6));
}

static XEN xm_XtErrorMsgHandler = XEN_FALSE;
static XEN xm_XtWarningMsgHandler = XEN_FALSE;

static void gxm_XtErrorMsgHandler(String name, String type, String clas, String defp, String *pars, Cardinal *num)
{
  /* DIFF: XtErrorMsgHandler takes list of string pars
   */
  if ((XEN_PROCEDURE_P(xm_XtErrorMsgHandler)) && (num) && ((pars) || (*num == 0)))
    {
      XEN lst = XEN_EMPTY_LIST;
      int i, len, loc;
      loc = xm_protect(lst);
      len = (*num);
      for (i = len - 1; i >= 0; i--)
	lst = XEN_CONS(C_TO_XEN_STRING(pars[i]), lst);
      XEN_CALL_6(xm_XtErrorMsgHandler, 
		 C_TO_XEN_STRING(name),
		 C_TO_XEN_STRING(type),
		 C_TO_XEN_STRING(clas),
		 C_TO_XEN_STRING(defp),
		 lst,
		 C_TO_XEN_INT(*num),
		 c__FUNCTION__);
      xm_unprotect_at(loc);
    }
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XtSetErrorMsgHandler(XEN arg1)
{
  #define H_XtSetErrorMsgHandler "void XtSetErrorMsgHandler(msg_handler) has been superseded by XtAppSetErrorMsgHandler."
  XEN old_val;
  old_val = xm_XtErrorMsgHandler;
  xm_protect(arg1);
  xm_XtErrorMsgHandler = arg1;
  XtSetErrorMsgHandler(gxm_XtErrorMsgHandler);
  if (XEN_PROCEDURE_P(old_val)) xm_unprotect(old_val);
  return(old_val);
}
#endif

static XEN gxm_XtAppSetErrorMsgHandler(XEN arg1, XEN arg2)
{
  #define H_XtAppSetErrorMsgHandler "void XtAppSetErrorMsgHandler(app_context, msg_handler) registers the specified procedure, which is called \
when a fatal error occurs."
  XEN old_val;
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtAppSetErrorMsgHandler", "XtAppContext");
  old_val = xm_XtErrorMsgHandler;
  xm_protect(arg2);
  xm_XtErrorMsgHandler = arg2;
  XtAppSetErrorMsgHandler(XEN_TO_C_XtAppContext(arg1), gxm_XtErrorMsgHandler);
  if (XEN_PROCEDURE_P(old_val)) xm_unprotect(old_val);
  return(old_val);
}


static void gxm_XtWarningMsgHandler(String name, String type, String clas, String defp, String *pars, Cardinal *num)
{
  /* DIFF: XtWarningMsgHandler takes list of string pars
   */
  if ((XEN_PROCEDURE_P(xm_XtWarningMsgHandler)) && (num) && ((pars) || (*num == 0)))
    {
      XEN lst = XEN_EMPTY_LIST;
      int i, len, loc;
      loc = xm_protect(lst);
      len = (*num);
      for (i = len - 1; i >= 0; i--)
	lst = XEN_CONS(C_TO_XEN_STRING(pars[i]), lst);
      XEN_CALL_6(xm_XtWarningMsgHandler, 
		 C_TO_XEN_STRING(name),
		 C_TO_XEN_STRING(type),
		 C_TO_XEN_STRING(clas),
		 C_TO_XEN_STRING(defp),
		 lst,
		 C_TO_XEN_INT(*num),
		 c__FUNCTION__);
      xm_unprotect_at(loc);
    }
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XtSetWarningMsgHandler(XEN arg1)
{
  #define H_XtSetWarningMsgHandler "void XtSetWarningMsgHandler(msg_handler) has been superseded by XtAppSetWarningMsgHandler."
  XEN old_val;
  old_val = xm_XtWarningMsgHandler;
  xm_protect(arg1);
  xm_XtWarningMsgHandler = arg1;
  XtSetWarningMsgHandler(gxm_XtWarningMsgHandler);
  if (XEN_PROCEDURE_P(old_val)) xm_unprotect(old_val);
  return(old_val);
}
#endif

static XEN gxm_XtAppSetWarningMsgHandler(XEN arg1, XEN arg2)
{
  #define H_XtAppSetWarningMsgHandler "void XtAppSetWarningMsgHandler(app_context, msg_handler) registers the specified procedure, which \
is called when a nonfatal error condition occurs."
  XEN old_val;
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtAppSetWarningMsgHandler", "XtAppContext");
  old_val = xm_XtWarningMsgHandler;
  xm_protect(arg2);
  xm_XtWarningMsgHandler = arg2;
  XtAppSetWarningMsgHandler(XEN_TO_C_XtAppContext(arg1), gxm_XtWarningMsgHandler);
  if (XEN_PROCEDURE_P(old_val)) xm_unprotect(old_val);
  return(old_val);
}

static XEN gxm_XtGetValues(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XtGetValues "void XtGetValues(Widget w, ArgList args, Cardinal num_args) returns the values of the \
resources specified for the widget w.  In xm, 'args' is a list of resource names followed by a placeholder \
(normally 0), and the length of the arglist is optional.  For example, to get the current height and width \
of a widget, (" XM_PREFIX "XtGetValues" XM_POSTFIX " w (list " XM_PREFIX "XmNheight" XM_POSTFIX " 0 \
" XM_PREFIX "XmNwidth" XM_POSTFIX " 0)) which returns the list with the values filled in: (list height 123 \
width 321).  If the resource value is an array in C, it is returned as a list."

  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtGetValues", "Widget");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XtGetValues", "List");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg3), arg3, 3, "XtGetValues", "int");
  return(gxm_XtGetValues_1(arg1, arg2, XEN_TO_C_INT_DEF(arg3, arg2)));
}

static XEN gxm_XtVaGetValues(XEN arg1, XEN arg2)
{
  #define H_XtVaGetValues "void XtVaGetValues(w, ...) in xm is the same as XtGetValues."
  /* DIFF: XtVaGetValues -> returns original list with vals in place 
   */
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtVaGetValues", "Widget");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XtVaGetValues", "List");
  return(gxm_XtGetValues_1(arg1, arg2, XEN_LIST_LENGTH(arg2) / 2));
}

static XEN gxm_XtVaSetValues(XEN arg1, XEN arg2)
{
  #define H_XtVaSetValues "void XtVaSetValues(w, ...) in xm is the same as XtSetValues."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtVaSetValues", "Widget");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XtVaSetValues", "List");
  {
    Widget w;
    Arg *args;
    int arglen;
    args = XEN_TO_C_Args(arg2);
    w = XEN_TO_C_Widget(arg1);
    arglen = XEN_LIST_LENGTH(arg2) / 2;
    XtSetValues(w, args, arglen);
    if (args)
      {
	fixup_args(w, args, arglen);
	free_args(args, arglen);
      }
  }
  return(XEN_FALSE);
}

static XEN gxm_XtSetValues(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XtSetValues "void XtSetValues(Widget w, ArgList args, Cardinal num_args) sets the values of the \
resources specified for the widget w.  In xm, 'args' is a list of resource names followed by the new value, \
and the length of the arglist is optional.  For example, to set the current height and width \
of a widget, (" XM_PREFIX "XtSetValues" XM_POSTFIX " w (list " XM_PREFIX "XmNheight" XM_POSTFIX " 123 \
" XM_PREFIX "XmNwidth" XM_POSTFIX " 321)).  If the resource value in C is an array, it is a list in xm."

  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtSetValues", "Widget");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XtSetValues", "ArgList");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg3), arg3, 3, "XtSetValues", "int");
  {
    Arg *args;
    int arglen;
    Widget w;
    w = XEN_TO_C_Widget(arg1);
    args = XEN_TO_C_Args(arg2);
    arglen = XEN_TO_C_INT_DEF(arg3, arg2);
    XtSetValues(w, args, arglen);
    if (args)
      {
	fixup_args(w, args, arglen);
	free_args(args, arglen);
      }
  }
  return(XEN_FALSE);
}

static XEN gxm_XtCloseDisplay(XEN arg1)
{
  #define H_XtCloseDisplay "void XtCloseDisplay(display) closes the specified display as soon as it is safe to do so."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XtCloseDisplay", "Display*");
  XtCloseDisplay(XEN_TO_C_Display(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XtDisplayToApplicationContext(XEN arg1)
{
  #define H_XtDisplayToApplicationContext "XtAppContext XtDisplayToApplicationContext(dpy) returns the application context for the specified display."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XtDisplayToApplicationContext", "Display*");
  return(C_TO_XEN_XtAppContext(XtDisplayToApplicationContext(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XtWidgetToApplicationContext(XEN arg1)
{
  #define H_XtWidgetToApplicationContext "XtAppContext XtWidgetToApplicationContext(w) returns the application context for the specified widget."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtWidgetToApplicationContext", "Widget");
  return(C_TO_XEN_XtAppContext(XtWidgetToApplicationContext(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XtInitializeWidgetClass(XEN arg1)
{
  #define H_XtInitializeWidgetClass "void XtInitializeWidgetClass(object_class)"
  XEN_ASSERT_TYPE(XEN_WidgetClass_P(arg1), arg1, 1, "XtInitializeWidgetClass", "WidgetClass");
  XtInitializeWidgetClass(XEN_TO_C_WidgetClass(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XtDestroyApplicationContext(XEN arg1)
{
  #define H_XtDestroyApplicationContext "void XtDestroyApplicationContext(app_context) destroys the specified application context as soon as it is safe to do so."
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtDestroyApplicationContext", "XtAppContext");
  XtDestroyApplicationContext(XEN_TO_C_XtAppContext(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XtCreateApplicationContext(void)
{
  #define H_XtCreateApplicationContext "XtAppContext XtCreateApplicationContext()"
  return(C_TO_XEN_XtAppContext(XtCreateApplicationContext()));
}

static XEN gxm_argv_to_list(XEN lst, int argc, char **argv)
{
  int i, loc;
  if (argc == 0) return(lst);
  loc = xm_protect(lst);
  for (i = argc - 1; i >= 0; i--)
    lst = XEN_CONS(C_TO_XEN_STRING(argv[i]), lst);
  FREE(argv);
  xm_unprotect_at(loc);
  return(lst);
}

static XEN gxm_XtOpenDisplay(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg7, XEN arg8)
{
  #define H_XtOpenDisplay "Display *XtOpenDisplay(app_context, display_string, application_name, application_class, argc, argv) \
calls XOpenDisplay the specified display name."
  /* DIFF: XtOpenDisplay ignore arg5 6, argc is int, argv is list of strings, returns (list dpy argv ...)
   */
  char **argv = NULL;
  int argc;
  XEN lst = XEN_EMPTY_LIST;
  Display *dpy;
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtOpenDisplay", "XtAppContext");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2) || XEN_FALSE_P(arg2), arg2, 2, "XtOpenDisplay", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3), arg3, 3, "XtOpenDisplay", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg4), arg4, 4, "XtOpenDisplay", "char*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg7), arg7, 5, "XtOpenDisplay", "int");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg8), arg8, 6, "XtOpenDisplay", "list of char*");
  argc = XEN_TO_C_INT(arg7);
  if (XEN_LIST_LENGTH(arg8) != argc) return(XEN_FALSE); /* error? */
  if (argc > 0) argv = XEN_TO_C_Strings(arg8, argc);
  dpy = XtOpenDisplay(XEN_TO_C_XtAppContext(arg1), 
		      (XEN_FALSE_P(arg2)) ? NULL : XEN_TO_C_STRING(arg2), 
		      XEN_TO_C_STRING(arg3), 
		      XEN_TO_C_STRING(arg4), 
		      NULL, 0, &argc, argv);
  if (dpy)
    lst = XEN_CONS(C_TO_XEN_Display(dpy), lst);
  else lst = XEN_CONS(XEN_FALSE, lst);
  return(gxm_argv_to_list(lst, argc, argv));
}

#if (!XM_DISABLE_DEPRECATED) 
static XEN gxm_XtInitialize(XEN arg1, XEN arg2, XEN arg5, XEN arg6)
{
  #define H_XtInitialize "Widget XtInitialize(shell_name, application_class, argc, argv) calls XtToolkitInitialize \
followed by XtOpenDisplay with display_string NULL and application_name NULL, and finally calls XtAppCreateShell with appcation_name NULL, \
widget_class applicationShellWidgetClass , and the specified args and num_args and returns the created shell. "
  /* DIFF: XtInitialize ignore arg 3 4, argc is int, argv is list of strings
   */
  char **argv = NULL;
  int argc;
  Widget w;
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XtInitialize", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XtInitialize", "char*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 3, "XtInitialize", "int");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg6), arg6, 4, "XtInitialize", "list of char*");
  argc = XEN_TO_C_INT(arg5);
  if (XEN_LIST_LENGTH(arg6) != argc) return(XEN_FALSE); /* error? */
  if (argc > 0) argv = XEN_TO_C_Strings(arg6, argc);
  w = XtInitialize(XEN_TO_C_STRING(arg1), XEN_TO_C_STRING(arg2), NULL, 0, &argc, argv);
  return(gxm_argv_to_list(XEN_CONS(C_TO_XEN_Widget(w), XEN_EMPTY_LIST), argc, argv));
}
#endif

static XEN gxm_XtAppSetFallbackResources(XEN app, XEN specs)
{
  #define H_XtAppSetFallbackResources "XtAppSetFallbackResources(app, list-of-strings) sets the app's default resource values \
from the list of strings"
  char **fallbacks;
  int i, len;
  XEN lst;
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(app), app, 1, "XtAppSetFallbackResources", "XtAppContext");
  XEN_ASSERT_TYPE(XEN_LIST_P(specs), specs, 2, "XtAppSetFallbackResources", "list of char*");
  len = XEN_LIST_LENGTH(specs);
  lst = XEN_COPY_ARG(specs);
  fallbacks = (char **)CALLOC(len + 1, sizeof(char *)); /* +1 for null termination */
  for (i = 0; i < len; i++, lst = XEN_CDR(lst)) 
    fallbacks[i] = XEN_TO_C_STRING(XEN_CAR(lst));
  XtAppSetFallbackResources(XEN_TO_C_XtAppContext(app), fallbacks);
  FREE(fallbacks);
  return(xen_return_first(app, specs));
}

static XEN gxm_XtVaAppInitialize(XEN arg2, XEN arg5, XEN arg6, XEN arg8, XEN specs)
{
  #define H_XtVaAppInitialize "Widget XtVaAppInitialize(application_class, argc_in_out, argv_in_out, args, fallbacks) -- the order \
of the arguments is slightly different from the C Xt call.  The final arg is an (optional) list of strings."
  /* DIFF: XtVaAppInitialize [app] class {options numopts} {argc} argv resources -> (list widget app (new argv)), argc is int not int* options/num ignored
     Arg *args;
     app is returned not passed (list widget app) 
  */
  XtAppContext app;
  Arg *args;
  Widget res;
  int i, len = 0, argc, arglen;
  char **argv = NULL;
  char **fallbacks = NULL;
  XEN lst;
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 1, "XtVaAppInitialize", "char*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 2, "XtVaAppInitialize", "int");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg6), arg6, 3, "XtVaAppInitialize", "list of String");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg8), arg8, 4, "XtVaAppInitialize", "arg list");
  XEN_ASSERT_TYPE(XEN_LIST_P(specs) || XEN_NOT_BOUND_P(specs), specs, 5, "XtVaAppInitialize", "list of char*");
  argc = XEN_TO_C_INT(arg5);
  if (XEN_LIST_LENGTH(arg6) != argc) return(XEN_FALSE); /* error? */
  if (argc > 0) argv = XEN_TO_C_Strings(arg6, argc);
  if (XEN_LIST_P(specs))
    {
      int gcloc;
      len = XEN_LIST_LENGTH(specs);
      lst = XEN_COPY_ARG(specs);
      gcloc = xm_protect(lst);
      fallbacks = (char **)CALLOC(len + 1, sizeof(char *)); /* +1 for null termination */
      for (i = 0; i < len; i++, lst = XEN_CDR(lst)) 
	fallbacks[i] = strdup(XEN_TO_C_STRING(XEN_CAR(lst)));
      xm_unprotect_at(gcloc);
    }
  args = XEN_TO_C_Args(arg8);
  arglen = XEN_LIST_LENGTH(arg8) / 2;
  res = XtAppInitialize(&app, 
			XEN_TO_C_STRING(arg2), 
			NULL,
			0,
			&argc, 
			argv,
			fallbacks,
			args,
			arglen);
  if (args)
    {
      fixup_args(res, args, arglen);
      free_args(args, arglen);
    }
  if (fallbacks) 
    {
      for (i = 0; i < len; i++)
	if (fallbacks[i]) free(fallbacks[i]);
      FREE(fallbacks);
    }
  return(XEN_LIST_3(C_TO_XEN_Widget(res), 
		    C_TO_XEN_XtAppContext(app),
		    gxm_argv_to_list(XEN_EMPTY_LIST, argc, argv)));
}


static XEN gxm_XtAppInitialize(XEN arg2, XEN arg5, XEN arg6, XEN arg8, XEN arg9)
{
  #define H_XtAppInitialize "Widget XtAppInitialize(application_class, argc_in_out, argv_in_out, \
args, num_args) calls XtToolkitInitialize followed by XtCreateApplicationContext ,then calls XtOpenDisplay with \
display_string NULL and application_name NULL, and finally calls XtAppCreateShell with appcation_name NULL, widget_class applicationShellWidgetClass , \
and the specified args and num_args and returns the created shell.  The num_args argument can be list of strings = fallback resources"
  /* DIFF: XtAppInitialize [app] class {options numopts} {argc} argv resources args numargs -> (list widget app), argc is int not int* options/num ignored
     Arg *args;
     app is returned not passed (list widget app) 
  */
  XtAppContext app;
  Arg *args;
  Widget res;
  int argc, arglen;
  char **argv = NULL;
  char **fallbacks = NULL;
  int i, len = 0;
  XEN lst;
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 1, "XtAppInitialize", "char*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 2, "XtAppInitialize", "int");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg6), arg6, 3, "XtAppInitialize", "list of String*");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg8), arg8, 4, "XtAppInitialize", "ArgList");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg9) || XEN_LIST_P(arg9) || XEN_NOT_BOUND_P(arg9), arg9, 5, "XtAppInitialize", "int or list of strings"); /* num_args */
  argc = XEN_TO_C_INT(arg5);
  if (XEN_LIST_LENGTH(arg6) != argc) return(XEN_FALSE); /* error? */
  if (argc > 0) argv = XEN_TO_C_Strings(arg6, argc);
  args = XEN_TO_C_Args(arg8);
  if (XEN_INTEGER_P(arg9)) arglen = XEN_TO_C_INT(arg9); else arglen = XEN_LIST_LENGTH(arg8) / 2;
  if (XEN_LIST_P(arg9))
    {
      int gcloc;
      len = XEN_LIST_LENGTH(arg9);
      lst = XEN_COPY_ARG(arg9);
      gcloc = xm_protect(lst);
      fallbacks = (char **)CALLOC(len + 1, sizeof(char *)); /* +1 for null termination */
      for (i = 0; i < len; i++, lst = XEN_CDR(lst)) 
	fallbacks[i] = strdup(XEN_TO_C_STRING(XEN_CAR(lst)));
      xm_unprotect_at(gcloc);
    }
  res = XtAppInitialize(&app,
			XEN_TO_C_STRING(arg2), 
			NULL,
			0,
			&argc,
			argv,
			fallbacks,
			args,
			arglen);
  if (args)
    {
      fixup_args(res, args, arglen);
      free_args(args, arglen);
    }
  if (fallbacks) 
    {
      for (i = 0; i < len; i++)
	if (fallbacks[i]) free(fallbacks[i]);
      FREE(fallbacks);
    }
  return(XEN_LIST_3(C_TO_XEN_Widget(res), 
		    C_TO_XEN_XtAppContext(app),
		    gxm_argv_to_list(XEN_EMPTY_LIST, argc, argv)));
}

static XEN gxm_XtVaOpenApplication(XEN arg1, XEN arg4, XEN arg5, XEN arg7, XEN arg8, XEN specs)
{
  #define H_XtVaOpenApplication "Widget XtVaOpenApplication(application_class, argc_in_out, argv_in_out, widget_class, args, fallbacks)"
  /* DIFF: XtVaOpenApplication [app] name {options numopts} {argc} argv resources class args -> (list widget app), argc is int not int* options/num ignored
     Arg *args;
     app is returned not passed (list widget app) 
  */
  XtAppContext app;
  Arg *args;
  Widget res;
  int argc, arglen;
  char **argv = NULL;
  char **fallbacks = NULL;
  int i, len = 0;
  XEN lst;
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XtVaOpenApplication", "char*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 2, "XtVaOpenApplication", "int"); /* was arg3 by mistake, 11-Oct-02 */
  XEN_ASSERT_TYPE(XEN_LIST_P(arg5), arg5, 3, "XtVaOpenApplication", "list of String");
  XEN_ASSERT_TYPE(XEN_WidgetClass_P(arg7), arg7, 4, "XtVaOpenApplication", "WidgetClass");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg8), arg8, 5, "XtVaOpenApplication", "arg list");
  XEN_ASSERT_TYPE(XEN_LIST_P(specs) || XEN_NOT_BOUND_P(specs), specs, 5, "XtVaOpenApplication", "list of char*");
  argc = XEN_TO_C_INT(arg4);
  if (XEN_LIST_LENGTH(arg5) != argc) return(XEN_FALSE); /* error? */
  if (argc > 0) argv = XEN_TO_C_Strings(arg5, argc);
  if (XEN_LIST_P(specs))
    {
      int gcloc;
      len = XEN_LIST_LENGTH(specs);
      lst = XEN_COPY_ARG(specs);
      gcloc = xm_protect(lst);
      fallbacks = (char **)CALLOC(len + 1, sizeof(char *)); /* +1 for null termination */
      for (i = 0; i < len; i++, lst = XEN_CDR(lst)) 
	fallbacks[i] = strdup(XEN_TO_C_STRING(XEN_CAR(lst)));
      xm_unprotect_at(gcloc);
    }
  args = XEN_TO_C_Args(arg8);
  arglen = XEN_LIST_LENGTH(arg8) / 2;
  res = XtOpenApplication(&app, 
			  XEN_TO_C_STRING(arg1), 
			  NULL,
			  0,
			  &argc,
			  argv,
			  fallbacks,
			  XEN_TO_C_WidgetClass(arg7), 
			  args, 
			  arglen);
  if (args)
    {
      fixup_args(res, args, arglen);
      free_args(args, arglen);
    }
  if (fallbacks) 
    {
      for (i = 0; i < len; i++)
	if (fallbacks[i]) free(fallbacks[i]);
      FREE(fallbacks);
    }
  return(XEN_LIST_3(C_TO_XEN_Widget(res), 
		    C_TO_XEN_XtAppContext(app),
		    gxm_argv_to_list(XEN_EMPTY_LIST, argc, argv)));
}

static XEN gxm_XtOpenApplication(XEN arg1, XEN arg4, XEN arg5, XEN arg7, XEN arg8, XEN arg9)
{
  #define H_XtOpenApplication "Widget XtOpenApplication(application_class, argc_in_out, argv_in_out, \
widget_class, args, num_args) calls XtToolkitInitialize followed by XtCreateApplicationContext , then calls XtOpenDisplay \
with display_string NULL and application_name NULL, and finally calls XtAppCreateShell with appcation_name NULL, widget_class \
applicationShellWidgetClass ,and the specified args and num_args and returns the created shell.  num_args can also be a list \
of fallback resources."
  /* DIFF: XtOpenApplication [app] name {options numopts} {argc} argv resources class args argnum -> (list widget app), argc is int not int* options/num ignored
  */
  XtAppContext app;
  Arg *args;
  Widget res;
  int argc, arglen;
  char **argv;
  char **fallbacks = NULL;
  int i, len = 0;
  XEN lst;
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XtOpenApplication", "char*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 2, "XtOpenApplication", "int");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg5), arg5, 3, "XtOpenApplication", "list of String*");
  XEN_ASSERT_TYPE(XEN_WidgetClass_P(arg7), arg7, 4, "XtOpenApplication", "WidgetClass");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg8), arg8, 8, "XtOpenApplication", "ArgList");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg9) || XEN_LIST_P(arg9) || XEN_NOT_BOUND_P(arg9), arg9, 5, "XtOpenApplication", "int or list of strings"); /* num_args */
  argc = XEN_TO_C_INT(arg4);
  argv = XEN_TO_C_Strings(arg5, argc);
  args = XEN_TO_C_Args(arg8);
  if (XEN_INTEGER_P(arg9)) arglen = XEN_TO_C_INT(arg9); else arglen = XEN_LIST_LENGTH(arg8) / 2;
  if (XEN_LIST_P(arg9))
    {
      int gcloc;
      len = XEN_LIST_LENGTH(arg9);
      lst = XEN_COPY_ARG(arg9);
      gcloc = xm_protect(lst);
      fallbacks = (char **)CALLOC(len + 1, sizeof(char *)); /* +1 for null termination */
      for (i = 0; i < len; i++, lst = XEN_CDR(lst)) 
	fallbacks[i] = XEN_TO_C_STRING(XEN_CAR(lst));
      xm_unprotect_at(gcloc);
    }
  res = XtOpenApplication(&app, XEN_TO_C_STRING(arg1), 
			  NULL, 0, &argc,
			  argv, fallbacks, XEN_TO_C_WidgetClass(arg7), 
			  args, arglen);
  if (args)
    {
      fixup_args(res, args, arglen);
      free_args(args, arglen);
    }
  if (fallbacks) 
    {
      for (i = 0; i < len; i++)
	if (fallbacks[i]) free(fallbacks[i]);
      FREE(fallbacks);
    }
  return(XEN_LIST_3(C_TO_XEN_Widget(res), 
		    C_TO_XEN_XtAppContext(app),
		    gxm_argv_to_list(XEN_EMPTY_LIST, argc, argv)));
}

static XEN gxm_XtDisplayInitialize(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg7, XEN arg8)
{
  #define H_XtDisplayInitialize "void XtDisplayInitialize(app_context, display, application_name, application_class, argc, argv) \
builds the resource database, calls the Xlib XrmParseCommand to parse the command line, and performs other per display initialization."
  /* DIFF: XtDisplayInitialize arg 5 6 ignored, argc is normal int, argv is list of strings, returns argv
   */
  char **argv;
  int argc;
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtDisplayInitialize", "XtAppContext");
  XEN_ASSERT_TYPE(XEN_Display_P(arg2), arg2, 2, "XtDisplayInitialize", "Display*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3), arg3, 3, "XtDisplayInitialize", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg4), arg4, 4, "XtDisplayInitialize", "char*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg7), arg7, 5, "XtDisplayInitialize", "int");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg8), arg8, 6, "XtDisplayInitialize", "list of char*");
  argc = XEN_TO_C_INT(arg7);
  argv = XEN_TO_C_Strings(arg8, argc);
  XtDisplayInitialize(XEN_TO_C_XtAppContext(arg1), 
		      XEN_TO_C_Display(arg2), 
		      XEN_TO_C_STRING(arg3), 
		      XEN_TO_C_STRING(arg4), 
		      NULL, 0, 
		      &argc, argv);
  return(gxm_argv_to_list(XEN_EMPTY_LIST, argc, argv));
}

/* -------- XtLanguage callback -------- */
/* (456) a global */

static XEN xm_language_proc = XEN_FALSE;

static String gxm_XtLanguageProc(Display* d, String s, XtPointer context) 
{
  char *res;
  res = XEN_TO_C_STRING(XEN_CALL_3(xm_language_proc,
				   C_TO_XEN_Display(d),
				   C_TO_XEN_STRING(s),
				   (XEN)context,
				   c__FUNCTION__));
  if (res)
    return(strdup(res));
  return(NULL);
}

static XEN gxm_XtSetLanguageProc(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XtSetLanguageProc "Widget XtSetLanguageProc(app_context, proc, client_data)"
  /* arg can be null -> use default */
  /* DIFF: XtSetLanguageProc args1 and 2 use #f for NULL, return of #f means none was set
   */
  XEN previous_proc = XEN_FALSE;
  XEN_ASSERT_TYPE(XEN_FALSE_P(arg1) || XEN_XtAppContext_P(arg1), arg1, 1, "XtSetLanguageProc", "XtAppContext");
  XEN_ASSERT_TYPE(XEN_FALSE_P(arg2) || (XEN_PROCEDURE_P(arg2) && (XEN_REQUIRED_ARGS_OK(arg2, 3))), arg2, 2, "XtSetLanguageProc", "XtLanguageProc");
  previous_proc = xm_language_proc;
  if (XEN_PROCEDURE_P(previous_proc))
    xm_unprotect(previous_proc);
  if (XEN_PROCEDURE_P(arg2))
    xm_protect(arg2);
  if (XEN_FALSE_P(arg1))
    {
      if (XEN_FALSE_P(arg2))
	XtSetLanguageProc(NULL, NULL, NULL);
      else XtSetLanguageProc(NULL,
			     (XtLanguageProc)gxm_XtLanguageProc, 
			     (XtPointer)arg3);
    }
  else 
    {
      if (XEN_FALSE_P(arg2))
	XtSetLanguageProc(XEN_TO_C_XtAppContext(arg1), NULL, NULL);
      else  XtSetLanguageProc(XEN_TO_C_XtAppContext(arg1), 
			      (XtLanguageProc)gxm_XtLanguageProc, 
			      (XtPointer)arg3);
    }
  return(previous_proc);
}

static XEN gxm_XtToolkitInitialize(void)
{
  #define H_XtToolkitInitialize "void XtToolkitInitialize()"
  XtToolkitInitialize();
  return(XEN_FALSE);
}

static XEN gxm_XtVaAppCreateShell(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XtVaAppCreateShell "Widget XtVaAppCreateShell(application_name, application_class, widget_class, display, ...)"
  Arg *args;
  Widget w;
  int arglen;
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XtVaAppCreateShell", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XtVaAppCreateShell", "char*");
  XEN_ASSERT_TYPE(XEN_WidgetClass_P(arg3), arg3, 3, "XtVaAppCreateShell", "WidgetClass");
  XEN_ASSERT_TYPE(XEN_Display_P(arg4), arg4, 4, "XtVaAppCreateShell", "Display*");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg5), arg5, 5, "XtVaAppCreateShell", "List");
  args = XEN_TO_C_Args(arg5);
  arglen = XEN_LIST_LENGTH(arg5) / 2;
  w = XtAppCreateShell(XEN_TO_C_STRING(arg1), 
		       XEN_TO_C_STRING(arg2), 
		       XEN_TO_C_WidgetClass(arg3), 
		       XEN_TO_C_Display(arg4), 
		       args,
		       arglen);
  if (args)
    {
      fixup_args(w, args, arglen);
      free_args(args, arglen);
    }
  return(C_TO_XEN_Widget(w));
}

static XEN gxm_XtAppCreateShell(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6)
{
  #define H_XtAppCreateShell "Widget XtAppCreateShell(application_name, application_class, widget_class, display, args, num_args) saves \
the specified application name and application class for qualifying all widget resource specifiers."
  Arg *args;
  Widget w;
  int arglen;
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XtAppCreateShell", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XtAppCreateShell", "char*");
  XEN_ASSERT_TYPE(XEN_WidgetClass_P(arg3), arg3, 3, "XtAppCreateShell", "WidgetClass");
  XEN_ASSERT_TYPE(XEN_Display_P(arg4), arg4, 4, "XtAppCreateShell", "Display*");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg5), arg5, 5, "XtAppCreateShell", "ArgList");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg6), arg6, 6, "XtAppCreateShell", "int");
  args = XEN_TO_C_Args(arg5);
  arglen = XEN_TO_C_INT_DEF(arg6, arg5);
  w = XtAppCreateShell(XEN_TO_C_STRING(arg1), 
		       XEN_TO_C_STRING(arg2), 
		       XEN_TO_C_WidgetClass(arg3), 
		       XEN_TO_C_Display(arg4), 
		       args, 
		       arglen);
  if (args)
    {
      fixup_args(w, args, arglen);
      free_args(args, arglen);
    }
  return(C_TO_XEN_Widget(w));
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XtCreateApplicationShell(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XtCreateApplicationShell "Widget XtCreateApplicationShell(name, widget_class, args, num_args) calls XtAppCreateShell with the \
application NULL, the application class passed to XtInitialize , and the default application context created by XtInitialize. This \
routine has been replaced by XtAppCreateShell."
  Arg *args;
  Widget w;
  int arglen;
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XtCreateApplicationShell", "char*");
  XEN_ASSERT_TYPE(XEN_WidgetClass_P(arg2), arg2, 2, "XtCreateApplicationShell", "WidgetClass");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg3), arg3, 3, "XtCreateApplicationShell", "ArgList");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg4), arg4, 4, "XtCreateApplicationShell", "int");
  args = XEN_TO_C_Args(arg3);
  arglen = XEN_TO_C_INT_DEF(arg4, arg3);
  w = XtCreateApplicationShell(XEN_TO_C_STRING(arg1), 
			       XEN_TO_C_WidgetClass(arg2), 
			       args, arglen);
  if (args)
    {
      fixup_args(w, args, arglen);
      free_args(args, arglen);
    }
  return(C_TO_XEN_Widget(w));
}
#endif

static XEN gxm_XtVaCreateManagedWidget(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XtVaCreateManagedWidget "Widget XtVaCreateManagedWidget(name, widget_class, parent, ...)"
  Arg *args;
  Widget w;
  int arglen;
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XtVaCreateManagedWidget", "char*");
  XEN_ASSERT_TYPE(XEN_WidgetClass_P(arg2), arg2, 2, "XtVaCreateManagedWidget", "WidgetClass");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg3), arg3, 3, "XtVaCreateManagedWidget", "Widget");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg4), arg4, 4, "XtVaCreateManagedWidget", "List");
  args = XEN_TO_C_Args(arg4);
  arglen = XEN_LIST_LENGTH(arg4) / 2;
  w = XtCreateManagedWidget(XEN_TO_C_STRING(arg1),
			    XEN_TO_C_WidgetClass(arg2), 
			    XEN_TO_C_Widget(arg3), 
			    args,
			    arglen);
  if (args)
    {
      fixup_args(w, args, arglen);
      free_args(args, arglen);
    }
  return(C_TO_XEN_Widget(w));
}

static XEN gxm_XtVaCreateWidget(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XtVaCreateWidget "Widget XtVaCreateWidget(name, widget_class, parent, ...)"
  Arg *args;
  int arglen;
  Widget w;
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XtVaCreateWidget", "char*");
  XEN_ASSERT_TYPE(XEN_WidgetClass_P(arg2), arg2, 2, "XtVaCreateWidget", "WidgetClass");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg3), arg3, 3, "XtVaCreateWidget", "Widget");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg4), arg4, 4, "XtVaCreateWidget", "List");
  args = XEN_TO_C_Args(arg4);
  arglen = XEN_LIST_LENGTH(arg4) / 2;
  w = XtCreateWidget(XEN_TO_C_STRING(arg1), 
		     XEN_TO_C_WidgetClass(arg2), 
		     XEN_TO_C_Widget(arg3), 
		     args,
		     arglen);
  if (args)
    {
      fixup_args(w, args, arglen);
      free_args(args, arglen);
    }
  return(C_TO_XEN_Widget(w));
}

static XEN gxm_XtCreateManagedWidget(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XtCreateManagedWidget "Widget XtCreateManagedWidget(name, widget_class, parent, args, num_args) is a routine \
that calls XtCreateWidget and XtManageChild."
  Arg *args;
  Widget w;
  int arglen;
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XtCreateManagedWidget", "char*");
  XEN_ASSERT_TYPE(XEN_WidgetClass_P(arg2), arg2, 2, "XtCreateManagedWidget", "WidgetClass");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg3), arg3, 3, "XtCreateManagedWidget", "Widget");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg4), arg4, 4, "XtCreateManagedWidget", "ArgList");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg5), arg5, 5, "XtCreateManagedWidget", "int");
  args = XEN_TO_C_Args(arg4);
  arglen = XEN_TO_C_INT_DEF(arg5, arg4);
  w = XtCreateManagedWidget(XEN_TO_C_STRING(arg1), 
			    XEN_TO_C_WidgetClass(arg2), 
			    XEN_TO_C_Widget(arg3), 
			    args, arglen);
  if (args)
    {
      fixup_args(w, args, arglen);
      free_args(args, arglen);
    }
  return(C_TO_XEN_Widget(w));
}

static XEN gxm_XtCreateWidget(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XtCreateWidget "Widget XtCreateWidget(name, widget_class, parent, args, num_args) performs much of the boilerplate operations of widget creation."
  Arg *args;
  Widget w;
  int arglen;
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XtCreateWidget", "char*");
  XEN_ASSERT_TYPE(XEN_WidgetClass_P(arg2), arg2, 2, "XtCreateWidget", "WidgetClass");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg3), arg3, 3, "XtCreateWidget", "Widget");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg4), arg4, 4, "XtCreateWidget", "ArgList");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg5), arg5, 5, "XtCreateWidget", "int");
  args = XEN_TO_C_Args(arg4);
  arglen = XEN_TO_C_INT_DEF(arg5, arg4);
  w = XtCreateWidget(XEN_TO_C_STRING(arg1), 
		     XEN_TO_C_WidgetClass(arg2), 
		     XEN_TO_C_Widget(arg3), 
		     args, arglen);
  if (args)
    {
      fixup_args(w, args, arglen);
      free_args(args, arglen);
    }
  return(C_TO_XEN_Widget(w));
}

static XEN gxm_XtCallbackPopdown(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XtCallbackPopdown "void XtCallbackPopdown(w, client_data, call_data) calls XtPopdown with the specified shell_widget and then \
calls XtSetSensitive to resensitize the enable_widget."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtCallbackPopdown", "Widget");
  XtCallbackPopdown(XEN_TO_C_Widget(arg1), (XtPointer)arg2, (XtPointer)arg3);
  return(XEN_FALSE);
}

static XEN gxm_XtPopdown(XEN arg1)
{
  #define H_XtPopdown "void XtPopdown(popup_shell)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtPopdown", "Widget");
  XtPopdown(XEN_TO_C_Widget(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XtCallbackExclusive(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XtCallbackExclusive "void XtCallbackExclusive(w, client_data, call_data)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtCallbackExclusive", "Widget");
  XtCallbackExclusive(XEN_TO_C_Widget(arg1), (XtPointer)arg2, (XtPointer)arg3);
  return(XEN_FALSE);
}

static XEN gxm_XtCallbackNonexclusive(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XtCallbackNonexclusive "void XtCallbackNonexclusive(w, client_data, call_data)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtCallbackNonexclusive", "Widget");
  XtCallbackNonexclusive(XEN_TO_C_Widget(arg1), (XtPointer)arg2, (XtPointer)arg3);
  return(XEN_FALSE);
}

static XEN gxm_XtCallbackNone(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XtCallbackNone "void XtCallbackNone(w, client_data, call_data)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtCallbackNone", "Widget");
  XtCallbackNone(XEN_TO_C_Widget(arg1), (XtPointer)arg2, (XtPointer)arg3);
  return(XEN_FALSE);
}

static XEN gxm_XtPopupSpringLoaded(XEN arg1)
{
  #define H_XtPopupSpringLoaded "void XtPopupSpringLoaded(popup_shell)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtPopupSpringLoaded", "Widget");
  XtPopupSpringLoaded(XEN_TO_C_Widget(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XtPopup(XEN arg1, XEN arg2)
{
  #define H_XtPopup "void XtPopup(popup_shell, grab_kind)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtPopup", "Widget");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XtPopup", "XtGrabKind");
  XtPopup(XEN_TO_C_Widget(arg1), (XtGrabKind)XEN_TO_C_INT(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XtVaCreatePopupShell(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XtVaCreatePopupShell "Widget XtVaCreatePopupShell(name, widget_class, parent, ...)"
  Arg *args;
  int arglen;
  Widget w;
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XtVaCreatePopupShell", "char*");
  XEN_ASSERT_TYPE(XEN_WidgetClass_P(arg2), arg2, 2, "XtVaCreatePopupShell", "WidgetClass");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg3), arg3, 3, "XtVaCreatePopupShell", "Widget");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg4), arg4, 4, "XtVaCreatePopupShell", "List");
  args = XEN_TO_C_Args(arg4);
  arglen = XEN_LIST_LENGTH(arg4) / 2;
  w = XtCreatePopupShell(XEN_TO_C_STRING(arg1), 
			 XEN_TO_C_WidgetClass(arg2), 
			 XEN_TO_C_Widget(arg3),
			 args,
			 arglen);
  if (args)
    {
      fixup_args(w, args, arglen);
      free_args(args, arglen);
    }
  return(C_TO_XEN_Widget(w));
}

static XEN gxm_XtCreatePopupShell(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XtCreatePopupShell "Widget XtCreatePopupShell(name, widget_class, parent, args, num_args) ensures that the specified \
class is a subclass of Shell and, rather than using insert_child to attach the widget to the parent's children list, attaches the shell \
to the parent's pop-ups list directly."
  Widget w;
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XtCreatePopupShell", "char*");
  XEN_ASSERT_TYPE(XEN_WidgetClass_P(arg2), arg2, 2, "XtCreatePopupShell", "WidgetClass");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg3), arg3, 3, "XtCreatePopupShell", "Widget");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg4), arg4, 4, "XtCreatePopupShell", "ArgList");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg5), arg5, 5, "XtCreatePopupShell", "int");
  {
    Arg *args;
    int arglen;
    args = XEN_TO_C_Args(arg4);
    arglen = XEN_TO_C_INT_DEF(arg5, arg4);
    w = XtCreatePopupShell(XEN_TO_C_STRING(arg1), 
			   XEN_TO_C_WidgetClass(arg2), 
			   XEN_TO_C_Widget(arg3), 
			   args, arglen);
    if (args)
      {
	fixup_args(w, args, arglen);
	free_args(args, arglen);
      }
  }
  return(C_TO_XEN_Widget(w));
}

static XEN gxm_XtHasCallbacks(XEN arg1, XEN arg2)
{
  #define H_XtHasCallbacks "XtCallbackStatus XtHasCallbacks(w, callback_name) first checks to see if the widget has a callback \
list identified by callback_name; returns XtCallbackNoList or XtCallbackHasNone if none, else XtCallbackHasSome"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtHasCallbacks", "Widget");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XtHasCallbacks", "char*");
  return(C_TO_XEN_INT(XtHasCallbacks(XEN_TO_C_Widget(arg1), XEN_TO_C_STRING(arg2))));
}

static XEN gxm_XtCallCallbacks(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XtCallCallbacks "void XtCallCallbacks(w, callback_name, call_data) calls each procedure that is registered in the \
specified widget's callback list. The call_data arg is assumed to be a callback struct reference"
  XtPointer val = NULL;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtCallCallbacks", "Widget");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XtCallCallbacks", "char*");
  if (XEN_LIST_P(arg3)) val = (XtPointer)XEN_TO_C_ULONG(XEN_CADR(arg3));
  XtCallCallbacks(XEN_TO_C_Widget(arg1), XEN_TO_C_STRING(arg2), val);
  return(XEN_FALSE);
}

static XEN gxm_XtRemoveAllCallbacks(XEN arg1, XEN arg2)
{
  #define H_XtRemoveAllCallbacks "void XtRemoveAllCallbacks(w, callback_name) removes all the callback procedures from the specified widget's callback list."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtRemoveAllCallbacks", "Widget");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XtRemoveAllCallbacks", "char*");
  XtRemoveAllCallbacks(XEN_TO_C_Widget(arg1), XEN_TO_C_STRING(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XtRemoveCallback(XEN arg1, XEN arg2, XEN arg4)
{
  #define H_XtRemoveCallback "void XtRemoveCallback(w, callback_name, client_data) removes a callback"
  /* DIFF: XtRemoveCallback omits proc arg and is passed whatever XtAddCallback returned
   */
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtRemoveCallback", "Widget");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XtRemoveCallback", "char*"); 
  xm_unprotect_at(XEN_TO_C_INT(XEN_LIST_REF(arg4, CALLBACK_GC_LOC)));
  XtRemoveCallback(XEN_TO_C_Widget(arg1), XEN_TO_C_STRING(arg2), gxm_XtCallbackProc, (XtPointer)arg4);
  return(XEN_FALSE);
}

static XEN gxm_XtRemoveCallbacks(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XtRemoveCallbacks "void XtRemoveCallbacks(w, callback_name, callbacks) removes the specified callback procedures from the \
specified widget's callback list. (The 3rd arg is a list of descriptors returned by XtAddCallback)."
  /* DIFF: XtRemoveCallbacks takes list of descriptors as arg3
   */
  XEN lst;
  int i, len;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtRemoveCallbacks", "Widget");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XtRemoveCallbacks", "char*");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg3), arg3, 3, "XtRemoveCallbacks", "list of XtCallbacks");
  lst = XEN_COPY_ARG(arg3);
  len = XEN_LIST_LENGTH(lst);
  for (i = 0; i < len; i++, lst = XEN_CDR(lst))
    gxm_XtRemoveCallback(arg1, arg2, XEN_CAR(lst));
  return(XEN_FALSE);
}

/* need these for all callback proc types, and locations to store the list of them */

enum {
  GXM_Print, GXM_Any, GXM_Arrow, GXM_Combo, GXM_Command, GXM_Container_Outline, GXM_Container_Select,
  GXM_Convert, GXM_Destination, GXM_Display, GXM_Drag_Drop, GXM_Drag_Motion, GXM_Drag_Proc, GXM_Drag_Start,
  GXM_Drawing, GXM_Drawn, GXM_Drop_Finish, GXM_Drop_Proc, GXM_DropSite_Enter, GXM_DropSite_Leave, GXM_Drop_Start,
  GXM_File, GXM_List, GXM_Notebook, GXM_Operation, GXM_Popup, GXM_PushButton, GXM_RowColumn, GXM_Scale,
  GXM_ScrollBar, GXM_Selection, GXM_SpinBox, GXM_ToggleButton, GXM_TopLevel_Enter, GXM_TopLevel_Leave,
  GXM_Traverse, GXM_Verify, GXM_DataField, GXM_TabStack
};

static XEN wrap_callback_struct(int type, XtPointer info)
{
  switch (type)
    {
    case GXM_Any:               return(C_TO_XEN_XmAnyCallbackStruct((XmAnyCallbackStruct *)info));
    case GXM_Arrow:             return(C_TO_XEN_XmArrowButtonCallbackStruct((XmArrowButtonCallbackStruct *)info));
    case GXM_Command:           return(C_TO_XEN_XmCommandCallbackStruct((XmCommandCallbackStruct *)info));
    case GXM_Drag_Drop:         return(C_TO_XEN_XmDragDropFinishCallbackStruct((XmDragDropFinishCallbackStruct *)info));
    case GXM_Drag_Motion:       return(C_TO_XEN_XmDragMotionCallbackStruct((XmDragMotionCallbackStruct *)info));
    case GXM_Drag_Proc:         return(C_TO_XEN_XmDragProcCallbackStruct((XmDragProcCallbackStruct *)info));
    case GXM_Drawing:           return(C_TO_XEN_XmDrawingAreaCallbackStruct((XmDrawingAreaCallbackStruct *)info));
    case GXM_Drawn:             return(C_TO_XEN_XmDrawnButtonCallbackStruct((XmDrawnButtonCallbackStruct *)info));
    case GXM_Drop_Finish:       return(C_TO_XEN_XmDropFinishCallbackStruct((XmDropFinishCallbackStruct *)info));
    case GXM_Drop_Proc:         return(C_TO_XEN_XmDropProcCallbackStruct((XmDropProcCallbackStruct *)info));
    case GXM_DropSite_Enter:    return(C_TO_XEN_XmDropSiteEnterCallbackStruct((XmDropSiteEnterCallbackStruct *)info));
    case GXM_DropSite_Leave:    return(C_TO_XEN_XmDropSiteLeaveCallbackStruct((XmDropSiteLeaveCallbackStruct *)info));
    case GXM_Drop_Start:        return(C_TO_XEN_XmDropStartCallbackStruct((XmDropStartCallbackStruct *)info));
    case GXM_File:              return(C_TO_XEN_XmFileSelectionBoxCallbackStruct((XmFileSelectionBoxCallbackStruct *)info));
    case GXM_List:              return(C_TO_XEN_XmListCallbackStruct((XmListCallbackStruct *)info));
    case GXM_PushButton:        return(C_TO_XEN_XmPushButtonCallbackStruct((XmPushButtonCallbackStruct *)info));
    case GXM_RowColumn:         return(C_TO_XEN_XmRowColumnCallbackStruct((XmRowColumnCallbackStruct *)info));
    case GXM_Scale:             return(C_TO_XEN_XmScaleCallbackStruct((XmScaleCallbackStruct *)info));
    case GXM_ScrollBar:         return(C_TO_XEN_XmScrollBarCallbackStruct((XmScrollBarCallbackStruct *)info));
    case GXM_Selection:         return(C_TO_XEN_XmSelectionBoxCallbackStruct((XmSelectionBoxCallbackStruct *)info));
    case GXM_ToggleButton:      return(C_TO_XEN_XmToggleButtonCallbackStruct((XmToggleButtonCallbackStruct *)info));
    case GXM_Verify:            return(C_TO_XEN_XmTextVerifyCallbackStruct((XmTextVerifyCallbackStruct *)info));
    case GXM_Popup:             return(C_TO_XEN_XmPopupHandlerCallbackStruct((XmPopupHandlerCallbackStruct *)info));
    case GXM_Drag_Start:        return(C_TO_XEN_XmDragStartCallbackStruct((XmDragStartCallbackStruct *)info));
    case GXM_Convert:           return(C_TO_XEN_XmConvertCallbackStruct((XmConvertCallbackStruct *)info));
    case GXM_Container_Outline: return(C_TO_XEN_XmContainerOutlineCallbackStruct((XmContainerOutlineCallbackStruct *)info));
    case GXM_Container_Select:  return(C_TO_XEN_XmContainerSelectCallbackStruct((XmContainerSelectCallbackStruct *)info));
    case GXM_Destination:       return(C_TO_XEN_XmDestinationCallbackStruct((XmDestinationCallbackStruct *)info));
    case GXM_Display:           return(C_TO_XEN_XmDisplayCallbackStruct((XmDisplayCallbackStruct *)info));
    case GXM_Combo:             return(C_TO_XEN_XmComboBoxCallbackStruct((XmComboBoxCallbackStruct *)info));
    case GXM_Notebook:          return(C_TO_XEN_XmNotebookCallbackStruct((XmNotebookCallbackStruct *)info));
    case GXM_Operation:         return(C_TO_XEN_XmOperationChangedCallbackStruct((XmOperationChangedCallbackStruct *)info));
    case GXM_SpinBox:           return(C_TO_XEN_XmSpinBoxCallbackStruct((XmSpinBoxCallbackStruct *)info));
#if HAVE_XM_XP
    case GXM_Print:             return(C_TO_XEN_XmPrintShellCallbackStruct((XmPrintShellCallbackStruct *)info));
#endif
    case GXM_TopLevel_Enter:    return(C_TO_XEN_XmTopLevelEnterCallbackStruct((XmTopLevelEnterCallbackStruct *)info));
    case GXM_TopLevel_Leave:    return(C_TO_XEN_XmTopLevelLeaveCallbackStruct((XmTopLevelLeaveCallbackStruct *)info));
    case GXM_Traverse:          return(C_TO_XEN_XmTraverseObscuredCallbackStruct((XmTraverseObscuredCallbackStruct *)info));
#if HAVE_XmCreateDataField
    case GXM_DataField:         return(C_TO_XEN_XmDataFieldCallbackStruct((XmDataFieldCallbackStruct *)info));
#endif
#if HAVE_XmCreateTabStack
    case GXM_TabStack:          return(C_TO_XEN_XmTabStackCallbackStruct((XmTabStackCallbackStruct *)info));
#endif
    }
  return(XEN_FALSE);
}

static int callback_struct_type(Widget w, const char *name)
{
  if (strcmp(name, XmNdestinationCallback) == 0) return(GXM_Destination);
  if (strcmp(name, XmNpopupHandlerCallback) == 0) return (GXM_Popup);
  if (strcmp(name, XmNconvertCallback) == 0) return(GXM_Convert);
  if (strcmp(name, XmNdragStartCallback) == 0) return(GXM_Drag_Start);
  if (strcmp(name, XmNdropProc) == 0) return(GXM_Drop_Proc);      
  if (strcmp(name, XmNdragProc) == 0) return(GXM_Drag_Proc);      

  if (XmIsArrowButton(w)) return(GXM_Arrow);
  if (XmIsPushButton(w)) return(GXM_PushButton);
  if (XmIsScale(w)) return(GXM_Scale);
  if (XmIsRowColumn(w)) return(GXM_RowColumn);
  if (XmIsScrollBar(w)) return(GXM_ScrollBar);
  if (XmIsToggleButton(w)) return(GXM_ToggleButton);
  if (XmIsList(w)) return(GXM_List);
  if (XmIsFileSelectionBox(w)) return(GXM_File);
  if (XmIsDrawingArea(w)) return(GXM_Drawing);
  if (XmIsScrolledWindow(w)) return(GXM_Traverse);
  if (XmIsNotebook(w)) return(GXM_Notebook);
  if (XmIsComboBox(w)) return(GXM_Combo);
  if ((XmIsText(w)) || (XmIsTextField(w)))
    {
      if ((strcmp(name, XmNlosingFocusCallback) == 0) ||
	  (strcmp(name, XmNmodifyVerifyCallback) == 0) ||
	  (strcmp(name, XmNmotionVerifyCallback) == 0))
	return(GXM_Verify);
      return(GXM_Any);
    }
  if (XmIsContainer(w))
    {
      if (strcmp(name, XmNoutlineChangedCallback) == 0) return(GXM_Container_Outline);
      if ((strcmp(name, XmNselectionCallback) == 0) ||
	  (strcmp(name, XmNdefaultActionCallback) == 0))
	return(GXM_Container_Select);
      return(GXM_Destination); 
    }
  /* how to recognize a SpinBox? */
#if HAVE_XM_XP
  if (XmIsPrintShell(w)) return(GXM_Print);
#endif
  if (XmIsCommand(w)) return(GXM_Command);
  if (XmIsDisplay(w)) return(GXM_Display);
  if (XmIsSelectionBox(w)) return(GXM_Selection);
  if (XmIsDragContext(w))
    {
      if (strcmp(name, XmNdragDropFinishCallback) == 0) return(GXM_Drag_Drop);
      if (strcmp(name, XmNdropFinishCallback) == 0) return(GXM_Drop_Finish);
      if (strcmp(name, XmNdragMotionCallback) == 0) return(GXM_Drag_Motion);
      if (strcmp(name, XmNdropSiteEnterCallback) == 0) return(GXM_DropSite_Enter);
      if (strcmp(name, XmNdropSiteLeaveCallback) == 0) return(GXM_DropSite_Leave);
      if (strcmp(name, XmNdropStartCallback) == 0) return(GXM_Drop_Start);
      if (strcmp(name, XmNoperationChangedCallback) == 0) return(GXM_Operation);
      if (strcmp(name, XmNtopLevelEnterCallback) == 0) return(GXM_TopLevel_Enter);
      if (strcmp(name, XmNtopLevelLeaveCallback) == 0) return(GXM_TopLevel_Leave);
    }
  if (XmIsDrawnButton(w)) return(GXM_Drawn);
#if HAVE_XmCreateDataField
  if (XmIsDataField(w)) return(GXM_DataField);
#endif
  return(GXM_Any);
}

static XEN gxm_XtAddCallback(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XtAddCallback "void XtAddCallback(w, callback_name, callback, client_data) adds the specified callback procedure to \
the specified widget's callback list.  In xm, the client-data is optional, defaulting to #f. The callback procedure takes \
3 args: widget client-data callback-info. Returns a description of the callback suitable for use with XtRemoveCallback."
  /* DIFF: XtAddCallback returns the C-side "client-data" (for subsequent XtRemoveCallback)
   */
  char *name;
  Widget w;
  int gc_loc;
  XEN call_descr = XEN_EMPTY_LIST;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtAddCallback", "Widget");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XtAddCallback", "char*");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg3) && (XEN_REQUIRED_ARGS_OK(arg3, 3)), arg3, 3, "XtAddCallback", "(XtCallbackProc widget data callb)");
  w = XEN_TO_C_Widget(arg1);
  name = XEN_TO_C_STRING(arg2);
  call_descr = C_TO_XEN_XM_XtCallback(arg3, (XEN_BOUND_P(arg4)) ? arg4 : XEN_FALSE);
  gc_loc = xm_protect(call_descr);
  XEN_LIST_SET(call_descr, CALLBACK_GC_LOC, C_TO_XEN_INT(gc_loc));
  XEN_LIST_SET(call_descr, CALLBACK_STRUCT_TYPE, C_TO_XEN_INT(callback_struct_type(w, name)));
  XtAddCallback(w, name, gxm_XtCallbackProc, (XtPointer)call_descr);
  return(xen_return_first(call_descr, arg2));
}

static XEN gxm_XtAddCallbacks(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XtAddCallbacks "void XtAddCallbacks(w, callback_name, callbacks) add the specified list of callbacks to the specified widget's callback list. \
It returns a list of callback descriptors for use with XtRemoveCallback(s)."
  /* DIFF: XtAddCallbacks takes list of (func data) pairs as arg3
   */
  XEN res = XEN_EMPTY_LIST, lst;
  int i, len;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtAddCallbacks", "Widget");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XtAddCallbacks", "char*");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg3), arg3, 3, "XtAddCallbacks", "list of XtCallbacks");
  len = XEN_LIST_LENGTH(arg3);
  lst = XEN_COPY_ARG(arg3);
  for (i = len - 1; i >= 0; i--, lst = XEN_CDR(lst))
    res = XEN_CONS(gxm_XtAddCallback(arg1, arg2, XEN_CAR(XEN_CAR(lst)), XEN_CADR(XEN_CAR(lst))),
		   res);
  return(res);
}

static XEN gxm_XtParent(XEN arg1)
{
  #define H_XtParent "Widget XtParent(w) returns the widget's parent widget ID."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtParent", "Widget");
  return(C_TO_XEN_Widget(XtParent(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XtClass(XEN arg1)
{
  #define H_XtClass "WidgetClass XtClass(w)"
  #define H_XtSuperclass "WidgetClass XtSuperclass(w) returns a pointer to the widget's superclass class structure."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtClass", "Widget");
  return(C_TO_XEN_WidgetClass(XtClass(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XtSuperclass(XEN arg1)
{
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtSuperclass", "Widget");
  return(C_TO_XEN_WidgetClass(XtSuperclass(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XtName(XEN arg1)
{
  #define H_XtName "Widget XtName(w) returns the widget's name."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtName", "Widget");
  return(C_TO_XEN_STRING(XtName(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XtWindowOfObject(XEN arg1)
{
  #define H_XtWindowOfObject "Window XtWindowOfObject(object) returns the window of the specified object."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtWindowOfObject", "Widget");
  return(C_TO_XEN_Window(XtWindowOfObject(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XtWindow(XEN arg1)
{
  #define H_XtWindow "Window XtWindow(w) returns the window of the specified widget."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtWindow", "Widget");
  return(C_TO_XEN_Window(XtWindow(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XtScreenOfObject(XEN arg1)
{
  #define H_XtScreenOfObject "Screen *XtScreenOfObject(object) returns the screen pointer for the specified object."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtScreenOfObject", "Widget");
  return(C_TO_XEN_Screen(XtScreenOfObject(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XtScreen(XEN arg1)
{
  #define H_XtScreen "Screen* XtScreen(w) returns the screen pointer for the specified widget."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtScreen", "Widget");
  return(C_TO_XEN_Screen(XtScreen(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XtDisplayOfObject(XEN arg1)
{
  #define H_XtDisplayOfObject "Display *XtDisplayOfObject(object) returns the display pointer for the specified object."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtDisplayOfObject", "Widget");
  return(C_TO_XEN_Display(XtDisplayOfObject(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XtDisplay(XEN arg1)
{
  #define H_XtDisplay "Display* XtDisplay(w)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtDisplay", "Widget");
  return(C_TO_XEN_Display(XtDisplay(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XtVaCreateArgsList(XEN arg1, XEN ignore2)
{
  #define H_XtVaCreateArgsList "XtVarArgsList XtVaCreateArgsList(unused, ...) allocates memory and copies its arguments into a single \
list pointer, which may be used with XtVaNestedList."
  /* DIFF: XtVaCreateArgsList just returns its 1st arg
   */
  return(arg1);
}

static XEN gxm_XtMergeArgLists(XEN arg1, XEN ignore2, XEN arg3, XEN ignore4)
{
  #define H_XtMergeArgLists "ArgList XtMergeArgLists(args1, num_args1, args2, num_args2) allocates enough storage to hold the combined \
ArgList structures and copies them into it."
  /* just merges, not duplicate check, kinda dumb to drop into C for that */
  XEN_ASSERT_TYPE(XEN_LIST_P(arg1), arg1, 1, "XtMergeArgLists", "list");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg3), arg3, 3, "XtMergeArgLists", "list");
  return(XEN_APPEND(arg1, arg3));
}

static XEN gxm_XtWindowToWidget(XEN arg1, XEN arg2)
{
  #define H_XtWindowToWidget "Widget XtWindowToWidget(display, window) translates the specified window and display pointer into the appropriate widget instance."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XtWindowToWidget", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XtWindowToWidget", "Window");
  return(C_TO_XEN_Widget(XtWindowToWidget(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2))));
}

static XEN gxm_XtNameToWidget(XEN arg1, XEN arg2)
{
  #define H_XtNameToWidget "Widget XtNameToWidget(reference, names) looks for a widget whose name is the first component in the specified names"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtNameToWidget", "Widget");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XtNameToWidget", "char*");
  return(C_TO_XEN_Widget(XtNameToWidget(XEN_TO_C_Widget(arg1), XEN_TO_C_STRING(arg2))));
}

static XEN gxm_XtSetSensitive(XEN arg1, XEN arg2)
{
  #define H_XtSetSensitive "void XtSetSensitive(w, sensitive)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtSetSensitive", "Widget");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg2), arg2, 2, "XtSetSensitive", "boolean");
  XtSetSensitive(XEN_TO_C_Widget(arg1), XEN_TO_C_BOOLEAN(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XtDestroyWidget(XEN arg1)
{
  #define H_XtDestroyWidget "void XtDestroyWidget(w) provides the only method of destroying a widget, including widgets that need to destroy themselves."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtDestroyWidget", "Widget");
  XtDestroyWidget(XEN_TO_C_Widget(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XtUnrealizeWidget(XEN arg1)
{
  #define H_XtUnrealizeWidget "void XtUnrealizeWidget(w) destroys the windows of an existing widget and all of its children (recursively down the widget tree)."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtUnrealizeWidget", "Widget");
  XtUnrealizeWidget(XEN_TO_C_Widget(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XtRealizeWidget(XEN arg1)
{
  #define H_XtRealizeWidget "void XtRealizeWidget(w) maps the widget window."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtRealizeWidget", "Widget");
  XtRealizeWidget(XEN_TO_C_Widget(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XtAppPending(XEN arg1)
{
  #define H_XtAppPending "XtInputMask XtAppPending(app_context) returns a nonzero value if there are events pending from the X server, timer \
pending, or other input sources pending. "
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtAppPending", "XtAppContext");
  return(C_TO_XEN_ULONG(XtAppPending(XEN_TO_C_XtAppContext(arg1))));
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XtPending(void)
{
  #define H_XtPending "XtInputMask XtPending() has been replaced by XtAppPending."
  return(C_TO_XEN_BOOLEAN(XtPending()));
}
#endif

static XEN gxm_XtAppNextEvent(XEN arg1)
{
  #define H_XtAppNextEvent "void XtAppNextEvent(app_context) flushes the X output buffers of each Display in the application \
context and waits for an event while looking at the other input sources, timeout timeout values, and signal handlers and calling any callback \
procedures triggered by them -> event."
  /* DIFF: XtAppNextEvent app [ev] -> ev
   */
  XEvent *e;
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtAppNextEvent", "XtAppContext");
  e = (XEvent *)CALLOC(1, sizeof(XEvent));
  XtAppNextEvent(XEN_TO_C_XtAppContext(arg1), e);
  return(C_TO_XEN_XEvent_OBJ(e));
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XtNextEvent(void)
{
  #define H_XtNextEvent "void XtNextEvent() has been replaced by XtAppNextEvent."
  /* DIFF: XtNextEvent [ev] -> ev
   */
  XEvent *e;
  e = (XEvent *)CALLOC(1, sizeof(XEvent));
  XtNextEvent(e);
  return(C_TO_XEN_XEvent_OBJ(e));
}
#endif


/* -------- Input callback -------- */

/* (77) explicitly removed via XtRemoveInput */

#define C_TO_XEN_XM_Input(Code, Context) \
  XEN_LIST_5(C_STRING_TO_XEN_SYMBOL("Input"), Code, Context, XEN_ZERO, XEN_ZERO)
#define XM_Input_P(Arg) WRAP_P("Input", Arg)

static void gxm_XtInputCallbackProc(XtPointer cdata, int *fileno, XtInputId *id) 
{
  XEN descr = (XEN)cdata;
  /* (list 'Input function context gc-loc id) */
  XEN_CALL_3(XEN_CADR(descr), 
	     XEN_CADDR(descr), 
	     C_TO_XEN_ULONG(*fileno), 
	     C_TO_XEN_XtInputId(*id), 
	     c__FUNCTION__);
}

static bool unprotect_inputproc(XEN val, int loc, unsigned long id)
{
  if ((XM_Input_P(val)) &&
      ((XtInputId)XEN_TO_C_ULONG(XEN_LIST_REF(val, 4)) == id))
    {
      xm_unprotect_at(loc);
      return(true);
    }
  return(false);
}

static XEN gxm_XtRemoveInput(XEN arg1)
{
  #define H_XtRemoveInput "void XtRemoveInput(id) causes the read routine to stop watching for input from the input source."
  XtInputId id;
  XEN_ASSERT_TYPE(XEN_XtInputId_P(arg1), arg1, 1, "XtRemoveInput", "XtInputId");
  id = XEN_TO_C_XtInputId(arg1);
  XtRemoveInput(id);
  map_over_protected_elements(unprotect_inputproc, id);
  return(XEN_FALSE);
}

static XEN gxm_XtAppAddInput(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XtAppAddInput "XtInputId XtAppAddInput(app_context, source, condition, proc, client_data) registers with the read routine a \
new source of events, which is usually file input but can also be file output."
  XtInputId id;
  int gc_loc;
  XEN descr;
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtAppAddInput", "XtAppContext");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XtAppAddInput", "int");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg4) && (XEN_REQUIRED_ARGS_OK(arg4, 3)), arg4, 4, "XtAppAddInput", "(XtInputCallbackProc data fileno id)");
  descr = C_TO_XEN_XM_Input(arg4, (XEN_BOUND_P(arg5)) ? arg5 : XEN_FALSE);
  gc_loc = xm_protect(descr);
  id = XtAppAddInput(XEN_TO_C_XtAppContext(arg1), 
		     XEN_TO_C_INT(arg2), 
		     (XtPointer)arg3, 
		     gxm_XtInputCallbackProc, 
		     (XtPointer)descr);
  XEN_LIST_SET(descr, 3, C_TO_XEN_INT(gc_loc));
  XEN_LIST_SET(descr, 4, C_TO_XEN_ULONG(id));
  return(C_TO_XEN_XtInputId(id));
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XtAddInput(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XtAddInput "XtInputId XtAddInput(source, condition, proc, client_data) has been replaced by XtAppAddInput."
  XtInputId id;
  int gc_loc;
  XEN descr;
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg1), arg1, 1, "XtAddInput", "int");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg3) && (XEN_REQUIRED_ARGS_OK(arg3, 3)), arg3, 3, "XtAddInput", "(XtInputCallbackProc data fileno id)");
  descr = C_TO_XEN_XM_Input(arg3, (XEN_BOUND_P(arg4)) ? arg4 : XEN_FALSE);
  gc_loc = xm_protect(descr);
  id = XtAddInput(XEN_TO_C_INT(arg1), 
		  (XtPointer)arg2, 
		  gxm_XtInputCallbackProc, 
		  (XtPointer)descr);
  XEN_LIST_SET(descr, 3, C_TO_XEN_INT(gc_loc));
  XEN_LIST_SET(descr, 4, C_TO_XEN_ULONG(id));
  return(C_TO_XEN_XtInputId(id));
}
#endif

/* -------- Timer Callback -------- */
/* (79) protect the function, then unprotect after invocation */

#define C_TO_XEN_XM_TimeOut(Code, Context) \
  XEN_LIST_5(C_STRING_TO_XEN_SYMBOL("TimeOut"), Code, Context, XEN_ZERO, XEN_ZERO)
#define XM_TimeOut_P(Arg) WRAP_P("TimeOut", Arg)

static void gxm_XtTimerCallbackProc(XtPointer cdata, XtIntervalId* i) 
{
  XEN descr = (XEN)cdata;
  /* (list 'TimeOut function context gc-loc id) */
  int gc_loc;
  gc_loc = XEN_TO_C_INT(XEN_LIST_REF(descr, 3));
  XEN_CALL_2(XEN_CADR(descr), 
	     XEN_CADDR(descr),
	     C_TO_XEN_XtIntervalId(*i),
	     c__FUNCTION__);
  xm_unprotect_at(gc_loc);
}

static bool unprotect_timeoutproc(XEN val, int loc, unsigned long id)
{
  if ((XM_TimeOut_P(val)) &&
      ((XtIntervalId)XEN_TO_C_ULONG(XEN_LIST_REF(val, 4)) == id))
    {
      xm_unprotect_at(loc);
      return(true);
    }
  return(false);
}

static XEN gxm_XtRemoveTimeOut(XEN arg1)
{
  #define H_XtRemoveTimeOut "void XtRemoveTimeOut(timer) removes the timeout."
  XtIntervalId id;
  XEN_ASSERT_TYPE(XEN_XtIntervalId_P(arg1), arg1, 1, "XtRemoveTimeOut", "XtIntervalId");
  id = XEN_TO_C_XtIntervalId(arg1);
  XtRemoveTimeOut(id);
  map_over_protected_elements(unprotect_timeoutproc, id);
  return(XEN_FALSE);
}

static XEN gxm_XtAppAddTimeOut(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XtAppAddTimeOut "XtIntervalId XtAppAddTimeOut(app_context, interval, proc, client_data) creates a timeout and returns an identifier for it."
  XtIntervalId id;
  int gc_loc;
  XEN descr;
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtAppAddTimeOut", "XtAppContext");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XtAppAddTimeOut", "ulong");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg3) && (XEN_REQUIRED_ARGS_OK(arg3, 2)), arg3, 3, "XtAppAddTimeOut", "(XtTimerCallbackProc data id)");
  descr = C_TO_XEN_XM_TimeOut(arg3, (XEN_BOUND_P(arg4)) ? arg4 : XEN_FALSE);
  gc_loc = xm_protect(descr);
  id = XtAppAddTimeOut(XEN_TO_C_XtAppContext(arg1), 
		       XEN_TO_C_ULONG(arg2), 
		       gxm_XtTimerCallbackProc, 
		       (XtPointer)descr);
  XEN_LIST_SET(descr, 3, C_TO_XEN_INT(gc_loc));
  XEN_LIST_SET(descr, 4, C_TO_XEN_ULONG(id));
  return(C_TO_XEN_XtIntervalId(id));
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XtAddTimeOut(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XtAddTimeOut "XtIntervalId XtAddTimeOut(interval, proc, client_data) has been replaced by XtAppAddTimeOut."
  XtIntervalId id;
  int gc_loc;
  XEN descr;
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg1), arg1, 1, "XtAddTimeOut", "ulong");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg2) && (XEN_REQUIRED_ARGS_OK(arg2, 2)), arg2, 2, "XtAddTimeOut", "(XtTimerCallbackProc data id)");
  descr = C_TO_XEN_XM_TimeOut(arg2, (XEN_BOUND_P(arg3)) ? arg3 : XEN_FALSE);
  gc_loc = xm_protect(descr);
  id = XtAddTimeOut(XEN_TO_C_ULONG(arg1), 
		    gxm_XtTimerCallbackProc, 
		    (XtPointer)descr);
  XEN_LIST_SET(descr, 3, C_TO_XEN_INT(gc_loc));
  XEN_LIST_SET(descr, 4, C_TO_XEN_ULONG(id));
  return(C_TO_XEN_XtIntervalId(id));
}
#endif

static XEN gxm_XtLastTimestampProcessed(XEN arg1)
{
  #define H_XtLastTimestampProcessed "Time XtLastTimestampProcessed(display) returns the timestamp of the last event"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XtLastTimestampProcessed", "Display*");
  return(C_TO_XEN_Time(XtLastTimestampProcessed(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XtLastEventProcessed(XEN arg1)
{
  #define H_XtLastEventProcessed "XEvent* XtLastEventProcessed(display) returns the last event passed to XtDispatchEvent for the \
specified display and NULL if there has been no event. "
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XtLastEventProcessed", "Display*");
  return(C_TO_XEN_XEvent(XtLastEventProcessed(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XtGetKeyboardFocusWidget(XEN arg1)
{
  #define H_XtGetKeyboardFocusWidget "Widget XtGetKeyboardFocusWidget(widget) returns the widget that would be the end result of keyboard \
event forwarding for a keyboard event for the specified widget."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtGetKeyboardFocusWidget", "Widget");
  return(C_TO_XEN_Widget(XtGetKeyboardFocusWidget(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XtSetKeyboardFocus(XEN arg1, XEN arg2)
{
  #define H_XtSetKeyboardFocus "XtSetKeyboardFocus(subtree descendant) causes XtDispatchEvent to remap and send the event to the specified \
descendant widget."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtSetKeyboardFocus", "Widget");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg2), arg2, 2, "XtSetKeyboardFocus", "Widget");
  XtSetKeyboardFocus(XEN_TO_C_Widget(arg1), XEN_TO_C_Widget(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XtAddExposureToRegion(XEN arg1, XEN arg2)
{
  #define H_XtAddExposureToRegion "void XtAddExposureToRegion(event, region) computes the union of the rectangle defined by the exposure event \
and the specified region. Then, it stores the results back in region."
  XEN_ASSERT_TYPE(XEN_XEvent_P(arg1), arg1, 1, "XtAddExposureToRegion", "XEvent*");
  XEN_ASSERT_TYPE(XEN_Region_P(arg2), arg2, 2, "XtAddExposureToRegion", "Region");
  XtAddExposureToRegion(XEN_TO_C_XEvent(arg1), XEN_TO_C_Region(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XtAppMainLoop(XEN arg1)
{

  #define H_XtAppMainLoop "void XtAppMainLoop(app_context) first reads the next incoming X event by calling XtAppNextEvent and then it dispatches \
the event to the appropriate registered procedure by calling XtDispatchEvent."
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtAppMainLoop", "XtAppContext");
  XtAppMainLoop(XEN_TO_C_XtAppContext(arg1));
  return(XEN_FALSE);
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XtMainLoop(void)
{
  #define H_XtMainLoop "void XtMainLoop() has been replaced by XtAppMainLoop."
  XtMainLoop();
  return(XEN_FALSE);
}
#endif

static XEN gxm_XtAppProcessEvent(XEN arg1, XEN arg2)
{
  #define H_XtAppProcessEvent "void XtAppProcessEvent(app_context, mask) processes one timer, alternate input, signal source, or X event. \
If there is nothing of the appropriate type to process, XtAppProcessEvent blocks until there is."
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtAppProcessEvent", "XtAppContext");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XtAppProcessEvent", "XtInputMask");
  XtAppProcessEvent(XEN_TO_C_XtAppContext(arg1), XEN_TO_C_ULONG(arg2));
  return(XEN_FALSE);
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XtProcessEvent(XEN arg1)
{
  #define H_XtProcessEvent "void XtProcessEvent(mask) has been replaced by XtAppProcessEvent."
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg1), arg1, 1, "XtProcessEvent", "XtInputMask");
  XtProcessEvent(XEN_TO_C_ULONG(arg1));
  return(XEN_FALSE);
}
#endif

static XEN gxm_XtRemoveGrab(XEN arg1)
{
  #define H_XtRemoveGrab "void XtRemoveGrab(w) removes widgets from the modal cascade starting at the most recent widget up to and \
including the specified widget. "
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtRemoveGrab", "Widget");
  XtRemoveGrab(XEN_TO_C_Widget(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XtAddGrab(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XtAddGrab "void XtAddGrab(w, exclusive, spring_loaded) appends the widget (and associated parameters) to the modal cascade and \
checks that exclusive is #t if spring_loaded is #t."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtAddGrab", "Widget");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg2), arg2, 2, "XtAddGrab", "boolean");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg3), arg3, 3, "XtAddGrab", "boolean");
  XtAddGrab(XEN_TO_C_Widget(arg1), XEN_TO_C_BOOLEAN(arg2), XEN_TO_C_BOOLEAN(arg3));
  return(XEN_FALSE);
}

static XEN gxm_XtBuildEventMask(XEN arg1)
{
  #define H_XtBuildEventMask "EventMask XtBuildEventMask(w) -> widget's event mask"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtBuildEventMask", "Widget");
  return(C_TO_XEN_ULONG(XtBuildEventMask(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XtDispatchEventToWidget(XEN arg1, XEN arg2)
{
  #define H_XtDispatchEventToWidget "Boolean XtDispatchEventToWidget(widget, event) scans the list of registered event handlers for the \
specified widget and calls each handler that has been registered for the specified event type, subject to the continue_to_dispatch value \
returned by each handler."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtDispatchEventToWidget", "Widget");
  XEN_ASSERT_TYPE(XEN_XEvent_P(arg2), arg2, 2, "XtDispatchEventToWidget", "XEvent*");
  return(C_TO_XEN_BOOLEAN(XtDispatchEventToWidget(XEN_TO_C_Widget(arg1), XEN_TO_C_XEvent(arg2))));
}

enum {EVENT_HANDLER_TYPE, EVENT_HANDLER_FUNC, EVENT_HANDLER_DATA, EVENT_HANDLER_GC_LOC, EVENT_HANDLER_WIDGET, EVENT_HANDLER_MASK};

#define C_TO_XEN_XM_XtEventHandler(Code, Context, Widget, Mask) \
  XEN_LIST_6(C_STRING_TO_XEN_SYMBOL("XtEventHandler"), Code, Context, XEN_ZERO, Widget, Mask)
#define XM_XtEventHandler_P(Arg) WRAP_P("XtEventHandler", Arg)

static void gxm_XtEventHandler(Widget w, XtPointer context, XEvent *event, Boolean *flag)
{
  XEN result;
  XEN descr = (XEN)context;
  result = XEN_CALL_4(XEN_LIST_REF(descr, EVENT_HANDLER_FUNC),
		      C_TO_XEN_Widget(w),
		      XEN_LIST_REF(descr, EVENT_HANDLER_DATA),
		      C_TO_XEN_XEvent(event),
		      C_TO_XEN_BOOLEAN(*flag),
		      c__FUNCTION__);
  if ((XEN_SYMBOL_P(result)) && (strcmp("done", XEN_SYMBOL_TO_C_STRING(result)) == 0))
    (*flag) = false;
}

static bool find_xteventproc_1(XEN val, int loc, unsigned long wd)
{
  XEN lst = (XEN)wd;
  unsigned long w;
  XEN code;
  XEN data;
  w = XEN_TO_C_ULONG(XEN_CAR(lst));
  code = XEN_CADR(lst);
  data = XEN_CADDR(lst);
  return((XM_XtEventHandler_P(val)) &&
	 (XEN_Widget_P(XEN_LIST_REF(val, EVENT_HANDLER_WIDGET))) &&
	 (XEN_TO_C_ULONG(XEN_CADR(XEN_LIST_REF(val, EVENT_HANDLER_WIDGET))) == w) &&
	 (XEN_EQ_P(code, XEN_LIST_REF(val, EVENT_HANDLER_FUNC))) &&
	 (XEN_EQ_P(data, XEN_LIST_REF(val, EVENT_HANDLER_DATA))));
}

static XEN find_xteventproc(Widget w, XEN code, XEN data)
{
  /* here we again have to go by the widget */
  XEN lst;
  int i, loc;
  lst = XEN_LIST_3(C_TO_XEN_ULONG((unsigned long)w),code, data);
  loc = xm_protect(lst);
  i = map_over_protected_elements(find_xteventproc_1, (unsigned long)lst);
  xm_unprotect_at(loc);
  if (i >= 0)
    return(xm_protected_element(i));
  return(XEN_FALSE);
}

static XEN gxm_XtInsertRawEventHandler(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6)
{
  #define H_XtInsertRawEventHandler "void XtInsertRawEventHandler(w, event_mask, nonmaskable, proc, client_data, position) is similar to \
XtInsertEventHandler except that it does not modify the widget's event mask and never causes an XSelectInput for the specified events."
  XEN call_descr = XEN_EMPTY_LIST;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtInsertRawEventHandler", "Widget");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XtInsertRawEventHandler", "EventMask");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg3), arg3, 3, "XtInsertRawEventHandler", "boolean");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg4) && (XEN_REQUIRED_ARGS_OK(arg4, 4)), arg4, 4, "XtInsertRawEventHandler", "XtEventHandler");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XtInsertRawEventHandler", "XtListPosition");
  call_descr = C_TO_XEN_XM_XtEventHandler(arg4, (XEN_BOUND_P(arg5)) ? arg5 : XEN_FALSE, arg1, arg2);
  XEN_LIST_SET(call_descr, EVENT_HANDLER_GC_LOC, C_TO_XEN_INT(xm_protect(call_descr)));
  XtInsertRawEventHandler(XEN_TO_C_Widget(arg1), 
			  XEN_TO_C_ULONG(arg2), 
			  XEN_TO_C_BOOLEAN(arg3), 
			  gxm_XtEventHandler, 
			  (XtPointer)call_descr, 
			  (XtListPosition)XEN_TO_C_INT(arg6));
  return(XEN_FALSE);
}

static XEN gxm_XtInsertEventHandler(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6)
{
  #define H_XtInsertEventHandler "void XtInsertEventHandler(w, event_mask, nonmaskable, proc, client_data, position) is identical to \
XtAddEventHandler with the additional position argument. "
  XEN call_descr = XEN_EMPTY_LIST;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtInsertEventHandler", "Widget");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XtInsertEventHandler", "EventMask");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg3), arg3, 3, "XtInsertEventHandler", "boolean");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg4) && (XEN_REQUIRED_ARGS_OK(arg4, 4)), arg4, 4, "XtInsertEventHandler", "XtEventHandler");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg6), arg6, 6, "XtInsertEventHandler", "XtListPosition");
  call_descr = C_TO_XEN_XM_XtEventHandler(arg4, (XEN_BOUND_P(arg5)) ? arg5 : XEN_FALSE, arg1, arg2);
  XEN_LIST_SET(call_descr, EVENT_HANDLER_GC_LOC, C_TO_XEN_INT(xm_protect(call_descr)));
  XtInsertEventHandler(XEN_TO_C_Widget(arg1), 
		       XEN_TO_C_ULONG(arg2), 
		       XEN_TO_C_BOOLEAN(arg3), 
		       gxm_XtEventHandler, 
		       (XtPointer)call_descr, 
		       (XtListPosition)XEN_TO_C_INT(arg6));
  return(XEN_FALSE);
}

static XEN gxm_XtRemoveRawEventHandler(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XtRemoveRawEventHandler "void XtRemoveRawEventHandler(w, event_mask, nonmaskable, proc, client_data) stops the specified \
procedure from receiving the specified events."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtRemoveRawEventHandler", "Widget");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XtRemoveRawEventHandler", "EventMask");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg3), arg3, 3, "XtRemoveRawEventHandler", "boolean");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg4) && (XEN_REQUIRED_ARGS_OK(arg4, 4)), arg4, 4, "XtRemoveRawEventHandler", "XtEventHandler");
  XtRemoveRawEventHandler(XEN_TO_C_Widget(arg1), 
			  XEN_TO_C_ULONG(arg2), 
			  XEN_TO_C_BOOLEAN(arg3),
			  gxm_XtEventHandler, 
			  (XtPointer)find_xteventproc(XEN_TO_C_Widget(arg1), arg4, arg5));
  return(XEN_FALSE);
}

static XEN gxm_XtAddRawEventHandler(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XtAddRawEventHandler "void XtAddRawEventHandler(w, event_mask, nonmaskable, proc, client_data) is similar to XtAddEventHandler \
except that it does not affect the widget's mask and never causes an XSelectInput for its events."
  XEN call_descr = XEN_EMPTY_LIST;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtAddRawEventHandler", "Widget");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XtAddRawEventHandler", "EventMask");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg3), arg3, 3, "XtAddRawEventHandler", "boolean");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg4) && (XEN_REQUIRED_ARGS_OK(arg4, 4)), arg4, 4, "XtAddRawEventHandler", "XtEventHandler");
  call_descr = C_TO_XEN_XM_XtEventHandler(arg4, (XEN_BOUND_P(arg5)) ? arg5 : XEN_FALSE, arg1, arg2);
  XEN_LIST_SET(call_descr, EVENT_HANDLER_GC_LOC, C_TO_XEN_INT(xm_protect(call_descr)));
  XtAddRawEventHandler(XEN_TO_C_Widget(arg1), 
		       XEN_TO_C_ULONG(arg2), 
		       XEN_TO_C_BOOLEAN(arg3), 
		       gxm_XtEventHandler,
		       (XtPointer)call_descr);
  return(XEN_FALSE);
}

static XEN gxm_XtRemoveEventHandler(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XtRemoveEventHandler "XtRemoveEventHandler(w, event_mask, nonmaskable, proc, client_data)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtRemoveEventHandler", "Widget");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XtRemoveEventHandler", "EventMask");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg3), arg3, 3, "XtRemoveEventHandler", "boolean");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg4) && (XEN_REQUIRED_ARGS_OK(arg4, 4)), arg4, 4, "XtRemoveEventHandler", "XtEventHandler");
  XtRemoveEventHandler(XEN_TO_C_Widget(arg1), 
		       XEN_TO_C_ULONG(arg2), 
		       XEN_TO_C_BOOLEAN(arg3), 
		       gxm_XtEventHandler, 
		       (XtPointer)find_xteventproc(XEN_TO_C_Widget(arg1), arg4, arg5));
  return(XEN_FALSE);
}

static XEN gxm_XtAddEventHandler(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XtAddEventHandler "void XtAddEventHandler(w, event_mask, nonmaskable, proc, client_data) registers a procedure with the dispatch \
mechanism that is to be called when an event that matches the mask occurs on the specified widget.  To set the 'continue_to_dispatch' \
flag to 'false', return the symbol 'done from the event handler."
  XEN call_descr = XEN_EMPTY_LIST;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtAddEventHandler", "Widget");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg2), arg2, 2, "XtAddEventHandler", "EventMask");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg3), arg3, 3, "XtAddEventHandler", "boolean");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg4) && (XEN_REQUIRED_ARGS_OK(arg4, 4)), arg4, 4, "XtAddEventHandler", "XtEventHandler");
  call_descr = C_TO_XEN_XM_XtEventHandler(arg4, (XEN_BOUND_P(arg5)) ? arg5 : XEN_FALSE, arg1, arg2);
  XEN_LIST_SET(call_descr, EVENT_HANDLER_GC_LOC, C_TO_XEN_INT(xm_protect(call_descr)));
  XtAddEventHandler(XEN_TO_C_Widget(arg1), 
		    XEN_TO_C_ULONG(arg2), 
		    XEN_TO_C_BOOLEAN(arg3), 
		    gxm_XtEventHandler,
		    (XtPointer)call_descr);
  return(XEN_FALSE);
}

static XEN gxm_XtConvertCase(XEN arg1, XEN arg2)
{
  #define H_XtConvertCase "void XtConvertCase(display, keysym) calls the appropriate converter and returns the results."
  /* DIFF: XtConvertCase dpy keysym [k1 k2] -> (list k1 k2)
   */
  KeySym k1, k2;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XtConvertCase", "Display*");
  XEN_ASSERT_TYPE(XEN_KeySym_P(arg2), arg2, 2, "XtConvertCase", "KeySym");
  XtConvertCase(XEN_TO_C_Display(arg1), XEN_TO_C_KeySym(arg2), &k1, &k2);
  return(XEN_LIST_2(C_TO_XEN_KeySym(k1),
		    C_TO_XEN_KeySym(k2)));
}

/* -------- case converter -------- */

/* (424) convert case XtRegisterCaseConverter global */

static XEN xm_XtCaseProc = XEN_FALSE;
static void gxm_XtCaseProc(Display* d, KeySym k1, KeySym* k2, KeySym* k3)
{
  XEN val;
  int loc;
  val = XEN_CALL_2(xm_XtCaseProc,
		   C_TO_XEN_Display(d),
		   C_TO_XEN_KeySym(k1),
		   c__FUNCTION__);
  loc = xm_protect(val);
  if (XEN_LIST_P(val))
    {
      (*k2) = XEN_TO_C_KeySym(XEN_CAR(val));
      (*k3) = XEN_TO_C_KeySym(XEN_CADR(val));
    }
  xm_unprotect_at(loc);
}

static XEN gxm_XtRegisterCaseConverter(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XtRegisterCaseConverter "void XtRegisterCaseConverter(display, proc, start, stop) registers the specified case converter."
  /* DIFF: XtRegisterCaseConverter user XtCaseProc should return the new KeySyms as a list (not as ref args)
   */
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XtRegisterCaseConverter", "Display*");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg2) && (XEN_REQUIRED_ARGS_OK(arg2, 2)), arg2, 2, "XtRegisterCaseConverter", "(XtCaseProc dpy keysym)");
  XEN_ASSERT_TYPE(XEN_KeySym_P(arg3), arg3, 3, "XtRegisterCaseConverter", "KeySym");
  XEN_ASSERT_TYPE(XEN_KeySym_P(arg4), arg4, 4, "XtRegisterCaseConverter", "KeySym");
  if (XEN_PROCEDURE_P(xm_XtCaseProc)) xm_unprotect(xm_XtCaseProc);
  xm_protect(arg2);
  xm_XtCaseProc = arg2;
  XtRegisterCaseConverter(XEN_TO_C_Display(arg1), gxm_XtCaseProc, XEN_TO_C_KeySym(arg3), XEN_TO_C_KeySym(arg4));
  return(XEN_FALSE);
}


/* -------- keyproc -------- */
/* (454) XtSetKeyTranslator global */

static XEN xm_XtKeyProc = XEN_FALSE;
static void gxm_XtKeyProc(Display *dpy, KeyCode c, Modifiers m, Modifiers *mp, KeySym *sym)
{
  XEN val;
  int loc;
  val = XEN_CALL_3(xm_XtKeyProc,
		   C_TO_XEN_Display(dpy),
		   C_TO_XEN_KeyCode(c),
		   C_TO_XEN_Modifiers(m),
		   c__FUNCTION__);
  loc = xm_protect(val);
  if (XEN_LIST_P(val))
    {
      /* KeySym is long, Modifier(s) is int, so these can actually work, I guess */
      (*mp) = XEN_TO_C_Modifiers(XEN_CAR(val));
      (*sym) = XEN_TO_C_KeySym(XEN_CADR(val));
    }
  else XtTranslateKey(dpy, c, m, mp, sym);
  xm_unprotect_at(loc);
}

static XEN gxm_XtSetKeyTranslator(XEN arg1, XEN arg2)
{
  #define H_XtSetKeyTranslator "void XtSetKeyTranslator(display, proc) sets the specified procedure as the current key translator. "
  /* DIFF: XtSetKeyTranslator user XtKeyProc should return the new Modifiers and KeySym as a list (not as ref arg), set arg2 #f to get default proc
   */
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XtSetKeyTranslator", "Display*");
  XEN_ASSERT_TYPE(XEN_FALSE_P(arg2) || (XEN_PROCEDURE_P(arg2) && (XEN_REQUIRED_ARGS_OK(arg2, 3))), arg2, 2, "XtSetKeyTranslator", "(XtKeyProc dpy key mod)");
  if (XEN_PROCEDURE_P(xm_XtKeyProc)) xm_unprotect(xm_XtKeyProc);
  xm_XtKeyProc = arg2;
  if (XEN_FALSE_P(arg2))
    XtSetKeyTranslator(XEN_TO_C_Display(arg1), XtTranslateKey);
  else
    {
      xm_protect(arg2);
      XtSetKeyTranslator(XEN_TO_C_Display(arg1), (XtKeyProc)gxm_XtKeyProc);
    }
  return(XEN_FALSE);
}

static XEN gxm_XtTranslateKey(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XtTranslateKey "XtTranslateKey(Display *, XtKeyCode, Modifiers) -> modifiers and keysym"
  /* DIFF: XtTranslateKey omit and rtn last 2 args
   */
  Modifiers m;
  KeySym k;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XtTranslateKey", "Display*");
  XEN_ASSERT_TYPE(XEN_KeyCode_P(arg2), arg2, 2, "XtTranslateKey", "KeyCode");
  XEN_ASSERT_TYPE(XEN_Modifiers_P(arg3), arg3, 3, "XtTranslateKey", "Modifiers");
  XtTranslateKey(XEN_TO_C_Display(arg1), XEN_TO_C_KeyCode(arg2), XEN_TO_C_Modifiers(arg3), &m, &k);
  return(XEN_LIST_2(C_TO_XEN_Modifiers(m),
		    C_TO_XEN_KeySym(k)));
}

static XEN gxm_XtTranslateKeycode(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XtTranslateKeycode "void XtTranslateKeycode(display, keycode, modifiers) passes the specified \
arguments directly to the currently registered KeyCode to KeySym translator, returns (modifiers keysym)."
  /* DIFF: XtTranslateKeycode omit and rtn last 2 args
   */
  Modifiers m;
  KeySym k;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XtTranslateKeycode", "Display*");
  XEN_ASSERT_TYPE(XEN_KeyCode_P(arg2), arg2, 2, "XtTranslateKeycode", "KeyCode");
  XEN_ASSERT_TYPE(XEN_Modifiers_P(arg3), arg3, 3, "XtTranslateKeycode", "Modifiers");
  XtTranslateKeycode(XEN_TO_C_Display(arg1), XEN_TO_C_KeyCode(arg2), XEN_TO_C_Modifiers(arg3), &m, &k);
  return(XEN_LIST_2(C_TO_XEN_Modifiers(m),
		    C_TO_XEN_KeySym(k)));
}

static XEN gxm_XtGetActionKeysym(XEN arg1)
{
  #define H_XtGetActionKeysym "KeySym XtGetActionKeysym(event) -> (keysym modifiers)"
  /* DIFF: XtGetActionKeysym omit and rtn last arg
   */
  Modifiers m;
  KeySym k;
  XEN_ASSERT_TYPE(XEN_XEvent_P(arg1), arg1, 1, "XtGetActionKeysym", "XEvent*");
  k = XtGetActionKeysym(XEN_TO_C_XEvent(arg1), &m);
  return(XEN_LIST_2(C_TO_XEN_KeySym(k),
		    C_TO_XEN_Modifiers(m)));
}

static XEN gxm_XtGetResourceList(XEN widget_class)
{
  #define H_XtGetResourceList "XtGetResourceList(widget-class) returns the widget class's resource list"
  XEN lst = XEN_EMPTY_LIST;
  Cardinal len = 0;
  int i;
  XtResourceList resources;
  XEN_ASSERT_TYPE(XEN_WidgetClass_P(widget_class), widget_class, 1, "XtGetResourceList", "WidgetClass");
  XtGetResourceList(XEN_TO_C_WidgetClass(widget_class), &resources, &len);
  if (len > 0)
    {
      for (i = len - 1; i >= 0; i--)
	lst = XEN_CONS(XEN_LIST_7(C_TO_XEN_STRING(resources[i].resource_name),
				  C_TO_XEN_STRING(resources[i].resource_class),
				  C_TO_XEN_STRING(resources[i].resource_type),
				  C_TO_XEN_INT((int)(resources[i].resource_size)),
				  C_TO_XEN_INT((int)(resources[i].resource_offset)),
				  C_TO_XEN_STRING(resources[i].default_type),
				  C_TO_XEN_ULONG(resources[i].default_addr)),
		       lst);
      XtFree((char *)resources);
    }
  return(lst);
}

static XEN gxm_XtGetMultiClickTime(XEN arg1)
{
  #define H_XtGetMultiClickTime "int XtGetMultiClickTime(display) returns the time in milliseconds that the translation manager uses to \
determine if multiple events are to be interpreted as a repeated event "
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XtGetMultiClickTime", "Display*");
  return(C_TO_XEN_INT(XtGetMultiClickTime(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XtSetMultiClickTime(XEN arg1, XEN arg2)
{
  #define H_XtSetMultiClickTime "void XtSetMultiClickTime(display, time) sets the time interval used by the translation manager to determine \
when multiple events are interpreted as a repeated event."
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XtSetMultiClickTime", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XtSetMultiClickTime", "int");
  XtSetMultiClickTime(XEN_TO_C_Display(arg1), XEN_TO_C_INT(arg2));
  return(XEN_FALSE);
}

static XEN register_proc = XEN_FALSE;
static void gxm_XtRegisterGrabActionProc(Widget w, XEvent* e, String* s, Cardinal* c) 
{
  XEN_CALL_3(register_proc,
	     C_TO_XEN_Widget(w),
	     C_TO_XEN_XEvent(e),
	     C_TO_XEN_Strings(s, *c),
	     c__FUNCTION__);
}

static XEN gxm_XtRegisterGrabAction(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XtRegisterGrabAction "void XtRegisterGrabAction(action_proc, owner_events, event_mask, pointer_mode, keyboard_mode) adds the \
specified action_proc to a list known to the translation manager."
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg1) && (XEN_REQUIRED_ARGS_OK(arg1, 3)), arg1, 1, "XtRegisterGrabAction", "XtActionProc");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg2), arg2, 2, "XtRegisterGrabAction", "boolean");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XtRegisterGrabAction", "unsigned int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XtRegisterGrabAction", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XtRegisterGrabAction", "int");
  xm_protect(arg1);
  register_proc = arg1;
  XtRegisterGrabAction(gxm_XtRegisterGrabActionProc, XEN_TO_C_BOOLEAN(arg2), XEN_TO_C_ULONG(arg3), XEN_TO_C_INT(arg4), XEN_TO_C_INT(arg5));
  return(XEN_FALSE);
}

static XEN gxm_XtCallActionProc(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XtCallActionProc "void XtCallActionProc(widget, action, event, params, num_params) searches for the named action routine in the \
same manner and order as translation tables are bound. If found, the action routine is invoked with the specified widget, event pointer, \
and parameters."
  char **params = NULL;
  int i, len = 0;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtCallActionProc", "Widget");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XtCallActionProc", "char*");
  XEN_ASSERT_TYPE(XEN_XEvent_P(arg3) || XEN_FALSE_P(arg3), arg3, 3, "XtCallActionProc", "XEvent*");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg4) || XEN_FALSE_P(arg4), arg4, 4, "XtCallActionProc", "list of String");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg5), arg5, 5, "XtCallActionProc", "int");
  if (XEN_LIST_P(arg4))
    {
      if (XEN_INTEGER_P(arg5)) 
	len = XEN_TO_C_INT(arg5); 
      else len = XEN_LIST_LENGTH(arg4);
    }
  if (len > 0) 
    {
      params = (char **)CALLOC(len, sizeof(char *));
      for (i = 0; i < len; i++)
	params[i] = strdup(XEN_TO_C_STRING(XEN_LIST_REF(arg4, i)));
    }
  XtCallActionProc(XEN_TO_C_Widget(arg1), 
		   XEN_TO_C_STRING(arg2), 
		   (XEN_XEvent_P(arg3)) ? XEN_TO_C_XEvent(arg3) : NULL,
		   params, len);
  if (params)
    {
      for (i = 0; i < len; i++)
	if (params[i]) free(params[i]);
      FREE(params);
    }
  return(xen_return_first(XEN_FALSE, arg4));
}

static XEN gxm_XtGetActionList(XEN arg1)
{
  #define H_XtGetActionList "void XtGetActionList(widget_class) -> list of actions"
  /* DIFF: XtGetActionList omit arg2 and 3, return list of lists
   */
  unsigned int len;
  XtActionList act;
  XEN lst = XEN_EMPTY_LIST;
  XEN_ASSERT_TYPE(XEN_WidgetClass_P(arg1), arg1, 1, "XtGetActionList", "WidgetClass");
  XtGetActionList(XEN_TO_C_WidgetClass(arg1), &act, &len);
  if (len > 0)
    {
      int i;
      for (i = len - 1; i >= 0; i--)
	lst = XEN_CONS(XEN_LIST_2(C_TO_XEN_STRING(act[i].string),
				  C_TO_XEN_ULONG(act[i].proc)),
		       lst);
      free(act);
    }
  return(lst);
}

#define C_TO_XEN_XM_ActionHook(Code, Context) \
  XEN_LIST_5(C_STRING_TO_XEN_SYMBOL("ActionHook"), Code, Context, XEN_ZERO, XEN_ZERO)
#define XM_ActionHook_P(Arg) WRAP_P("ActionHook", Arg)

static bool unprotect_actionhook(XEN val, int loc, unsigned long id)
{
  if ((XM_ActionHook_P(val)) &&
      ((XtActionHookId)XEN_TO_C_ULONG(XEN_LIST_REF(val, 4)) == (XtActionHookId)id))
    {
      xm_unprotect_at(loc);
      return(true);
    }
  return(false);
}

static XEN gxm_XtRemoveActionHook(XEN arg1)
{
  #define H_XtRemoveActionHook "void XtRemoveActionHook(idP) removes the specified action hook procedure from the list in which it was registered."
  XtActionHookId id;
  XEN_ASSERT_TYPE(XEN_XtActionHookId_P(arg1), arg1, 1, "XtRemoveActionHook", "XtActionHookId");
  id = XEN_TO_C_XtActionHookId(arg1);
  XtRemoveActionHook(id);
  map_over_protected_elements(unprotect_actionhook, (unsigned long)id);
  return(XEN_FALSE);
}

static void gxm_XtActionHookProc(Widget w, XtPointer p, String s, XEvent* e, String* s1, Cardinal* c) 
{
  /* DIFF: XtActionHookProc takes 5 args (last is string list)
   */
  XEN descr = (XEN)p;
  /* (list 'ActionHook function context gc-loc id) */
  XEN_CALL_5(XEN_CADR(descr), 
	     C_TO_XEN_Widget(w),
	     XEN_CADDR(descr),
	     C_TO_XEN_STRING(s),
	     C_TO_XEN_XEvent(e),
	     C_TO_XEN_Strings(s1, *c),
	     c__FUNCTION__);
}

static XEN gxm_XtAppAddActionHook(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XtAppAddActionHook "XtActionHookId XtAppAddActionHook(app_context, proc, client_data) adds the specified procedure to the front of \
a list maintained in the application context."
  XtActionHookId id;
  int gc_loc;
  XEN descr;
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtAppAddActionHook", "XtAppContext");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg2) && (XEN_REQUIRED_ARGS_OK(arg2, 5)), arg2, 2, "XtAppAddActionHook", "XtActionHookProc");
  descr = C_TO_XEN_XM_ActionHook(arg2, (XEN_BOUND_P(arg3)) ? arg3 : XEN_FALSE);
  gc_loc = xm_protect(descr);
  id = XtAppAddActionHook(XEN_TO_C_XtAppContext(arg1), gxm_XtActionHookProc, (XtPointer)descr);
  XEN_LIST_SET(descr, 3, C_TO_XEN_INT(gc_loc));
  XEN_LIST_SET(descr, 4, C_TO_XEN_ULONG(id));
  return(C_TO_XEN_XtActionHookId(id));
}


/* (72) this is part of an actionrec */
/* this code is a horrible kludge, but what can I do? -- to vector to the procedure corresponding to
 *   the action that triggered the action proc, I need to have some way to find that procedure,
 *   and there's none I can see -- the args incoming (widget event args argn) give me no way to
 *   trace back to the caller, or even to save that data at declaration time via clientData or
 *   its equivalent -- I don't even get to see the affected widget.  By the time install|augment|override
 *   translations is called, my procedure info has been buried (or at least compiled into some unknown form).
 *
 *   XtAppContext->action_table is a list of ActionLists
 *   Widget struct has: XtTMRec tm:
 *     XtTranslations  translations;
 *     XtBoundActions  proc_table;  -- list of XtActionProcs		
 *     struct _XtStateRec *current_state;  
 */

static XEN xtactionprocs[9];
static void gxm_XtActionProc0(Widget w, XEvent *e, char **args, Cardinal *argn) 
{
  XEN_CALL_3(xtactionprocs[0], C_TO_XEN_Widget(w), C_TO_XEN_XEvent(e), C_TO_XEN_Strings(args, *argn), c__FUNCTION__);
}
static void gxm_XtActionProc1(Widget w, XEvent *e, char **args, Cardinal *argn) 
{
  XEN_CALL_3(xtactionprocs[1], C_TO_XEN_Widget(w), C_TO_XEN_XEvent(e), C_TO_XEN_Strings(args, *argn), c__FUNCTION__);
}
static void gxm_XtActionProc2(Widget w, XEvent *e, char **args, Cardinal *argn) 
{
  XEN_CALL_3(xtactionprocs[2], C_TO_XEN_Widget(w), C_TO_XEN_XEvent(e), C_TO_XEN_Strings(args, *argn), c__FUNCTION__);
}
static void gxm_XtActionProc3(Widget w, XEvent *e, char **args, Cardinal *argn) 
{
  XEN_CALL_3(xtactionprocs[3], C_TO_XEN_Widget(w), C_TO_XEN_XEvent(e), C_TO_XEN_Strings(args, *argn), c__FUNCTION__);
}
static void gxm_XtActionProc4(Widget w, XEvent *e, char **args, Cardinal *argn) 
{
  XEN_CALL_3(xtactionprocs[4], C_TO_XEN_Widget(w), C_TO_XEN_XEvent(e), C_TO_XEN_Strings(args, *argn), c__FUNCTION__);
}
static void gxm_XtActionProc5(Widget w, XEvent *e, char **args, Cardinal *argn) 
{
  XEN_CALL_3(xtactionprocs[5], C_TO_XEN_Widget(w), C_TO_XEN_XEvent(e), C_TO_XEN_Strings(args, *argn), c__FUNCTION__);
}
static void gxm_XtActionProc6(Widget w, XEvent *e, char **args, Cardinal *argn) 
{
  XEN_CALL_3(xtactionprocs[6], C_TO_XEN_Widget(w), C_TO_XEN_XEvent(e), C_TO_XEN_Strings(args, *argn), c__FUNCTION__);
}
static void gxm_XtActionProc7(Widget w, XEvent *e, char **args, Cardinal *argn) 
{
  XEN_CALL_3(xtactionprocs[7], C_TO_XEN_Widget(w), C_TO_XEN_XEvent(e), C_TO_XEN_Strings(args, *argn), c__FUNCTION__);
}
static void gxm_XtActionProc8(Widget w, XEvent *e, char **args, Cardinal *argn) 
{
  fprintf(stderr, "too many actions");
}
static int xm_action_ctr = 0;

static XtActionsRec *make_action_rec(int len, XEN larg2)
{
  int i, gcloc;
  XtActionsRec *act;
  XEN arg2;
  arg2 = XEN_COPY_ARG(larg2);
  gcloc = xm_protect(arg2);
  act = (XtActionsRec *)CALLOC(len, sizeof(XtActionsRec));
  for (i = 0; i < len; i++, arg2 = XEN_CDR(arg2))
    {
      XEN pair;
      pair = XEN_CAR(arg2);
      act[i].string = (String)strdup(XEN_TO_C_STRING(XEN_CAR(pair)));
      if (xm_action_ctr >= 8)
	{
	  fprintf(stderr,"too many actions...");
	  act[i].proc = (XtActionProc)gxm_XtActionProc8;
	  xm_protect(XEN_CADR(pair));
	  xtactionprocs[8] = XEN_CADR(pair);
	}
      else
	{
	  switch (xm_action_ctr)
	    {
	    case 0: act[i].proc = (XtActionProc)gxm_XtActionProc0; break;
	    case 1: act[i].proc = (XtActionProc)gxm_XtActionProc1; break;
	    case 2: act[i].proc = (XtActionProc)gxm_XtActionProc2; break;
	    case 3: act[i].proc = (XtActionProc)gxm_XtActionProc3; break;
	    case 4: act[i].proc = (XtActionProc)gxm_XtActionProc4; break;
	    case 5: act[i].proc = (XtActionProc)gxm_XtActionProc5; break;
	    case 6: act[i].proc = (XtActionProc)gxm_XtActionProc6; break;
	    case 7: act[i].proc = (XtActionProc)gxm_XtActionProc7; break;
	    }
	  xm_protect(XEN_CADR(pair));
	  xtactionprocs[xm_action_ctr++] = XEN_CADR(pair);
	}
    }
  xm_unprotect_at(gcloc);
  return(act);
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XtAddActions(XEN arg1)
{
  #define H_XtAddActions "void XtAddActions(actions, num_actions) has been replaced by XtAppAddActions."
  /* DIFF: XtAddActions takes list of lists for arg1 (name proc) pairs, not XtActionList, omits arg2 (pointless)
   *        and action proc itself takes 3 args (no need for trailing count)
   */
  XtActionsRec *act;
  int i, len;
  XEN_ASSERT_TYPE(XEN_LIST_P(arg1), arg1, 1, "XtAddActions", "list of XtActions");
  len = XEN_LIST_LENGTH(arg1);
  if (len <= 0) XEN_ASSERT_TYPE(0, arg1, 1, "XtAddActions", "positive integer");
  act = make_action_rec(len, arg1);
  XtAddActions(act, len);
  for (i = 0; i < len; i++)
    if (act[i].string) free(act[i].string);
  FREE(act);
  return(arg1);
}
#endif

static XEN gxm_XtAppAddActions(XEN arg1, XEN arg2)
{
  #define H_XtAppAddActions "void XtAppAddActions(app_context, actions, num_actions) adds the specified action table and registers it \
with the translation manager."
  /* DIFF: XtAddAppActions takes list of lists for arg2 (name proc) pairs, not XtActionList, omits arg3 (pointless)
   *        and action proc itself takes 3 args (no need for trailing count)
   */
  XtActionsRec *act;
  int i, len;
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtAppAddActions", "XtAppContext");
  XEN_ASSERT_TYPE(XEN_LIST_P(arg2), arg2, 2, "XtAppAddActions", "list of XtActions");
  len = XEN_LIST_LENGTH(arg2);
  if (len <= 0) XEN_ASSERT_TYPE(0, arg2, 2, "XtAppAddActions", "positive integer");
  act = make_action_rec(len, arg2);
  XtAppAddActions(XEN_TO_C_XtAppContext(arg1), act, len);
  for (i = 0; i < len; i++)
    if (act[i].string) free(act[i].string);
  FREE(act);
  return(arg1);
}

static XEN gxm_XtUninstallTranslations(XEN arg1)
{
  #define H_XtUninstallTranslations "void XtUninstallTranslations(w) causes the entire translation table for widget to be removed."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtUninstallTranslations", "Widget");
  XtUninstallTranslations(XEN_TO_C_Widget(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XtInstallAllAccelerators(XEN arg1, XEN arg2)
{
  #define H_XtInstallAllAccelerators "void XtInstallAllAccelerators(destination, source)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtInstallAllAccelerators", "Widget");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg2), arg2, 2, "XtInstallAllAccelerators", "Widget");
  XtInstallAllAccelerators(XEN_TO_C_Widget(arg1), XEN_TO_C_Widget(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XtInstallAccelerators(XEN arg1, XEN arg2)
{
  #define H_XtInstallAccelerators "void XtInstallAccelerators(destination, source) installs the accelerators from source onto destination by \
augmenting the destination translations with the source accelerators."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtInstallAccelerators", "Widget");
  XEN_ASSERT_TYPE(XEN_Widget_P(arg2), arg2, 2, "XtInstallAccelerators", "Widget");
  XtInstallAccelerators(XEN_TO_C_Widget(arg1), XEN_TO_C_Widget(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XtAugmentTranslations(XEN arg1, XEN arg2)
{
  #define H_XtAugmentTranslations "void XtAugmentTranslations(w, translations) nondestructively merges the new translations into the existing \
widget translations."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtAugmentTranslations", "Widget");
  XEN_ASSERT_TYPE(XEN_XtTranslations_P(arg2), arg2, 2, "XtAugmentTranslations", "XtTranslations");
  XtAugmentTranslations(XEN_TO_C_Widget(arg1), XEN_TO_C_XtTranslations(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XtOverrideTranslations(XEN arg1, XEN arg2)
{
  #define H_XtOverrideTranslations "void XtOverrideTranslations(w, translations) destructively merges the new translations into the existing \
widget translations."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtOverrideTranslations", "Widget");
  XEN_ASSERT_TYPE(XEN_XtTranslations_P(arg2), arg2, 2, "XtOverrideTranslations", "XtTranslations");
  XtOverrideTranslations(XEN_TO_C_Widget(arg1), XEN_TO_C_XtTranslations(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XtParseAcceleratorTable(XEN arg1)
{
  #define H_XtParseAcceleratorTable "XtAccelerators XtParseAcceleratorTable(const char *source) compiles source"
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XtParseAcceleratorTable", "char*");
  return(C_TO_XEN_ULONG(XtParseAcceleratorTable(XEN_TO_C_STRING(arg1))));
}

static XEN gxm_XtParseTranslationTable(XEN arg1)
{
  #define H_XtParseTranslationTable "XtTranslations XtParseTranslationTable(table) compiles the translation table into the opaque internal \
representation of type XtTranslations."
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XtParseTranslationTable", "char*");
  return(C_TO_XEN_XtTranslations(XtParseTranslationTable(XEN_TO_C_STRING(arg1))));
}

static XEN gxm_XtKeysymToKeycodeList(XEN arg1, XEN arg2)
{
  #define H_XtKeysymToKeycodeList "void XtKeysymToKeycodeList(display, keysym) procedure returns all the \
KeyCodes that have keysym in their entry for the keyboard mapping table associated with display -> (keycodes)."
  /* DIFF: XtKeysymToKeycodeList final 2 args omit, returns list
   */
  unsigned int len;
  KeyCode *kr;
  XEN lst = XEN_EMPTY_LIST;
  int loc;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XtKeysymToKeycodeList", "Display*");
  XEN_ASSERT_TYPE(XEN_KeySym_P(arg2), arg2, 2, "XtKeysymToKeycodeList", "KeySym");
  XtKeysymToKeycodeList(XEN_TO_C_Display(arg1), XEN_TO_C_KeySym(arg2), &kr, &len);
  loc = xm_protect(lst);
  if (len > 0)
    {
      int i;
      for (i = len - 1; i >= 0; i--)
	lst = XEN_CONS(C_TO_XEN_KeyCode(kr[i]), lst);
      free(kr);
    }
  xm_unprotect_at(loc);
  return(lst);
}

static XEN gxm_XtTranslateCoords(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XtTranslateCoords "void XtTranslateCoords(w, x, y) -> (root_x root_y)"
  /* DIFF: XtTranslateCoords omits and returns last 2 args
   */
  Position x, y;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtTranslateCoords", "Widget");
  XEN_ASSERT_TYPE(XEN_Position_P(arg2), arg2, 2, "XtTranslateCoords", "Position");
  XEN_ASSERT_TYPE(XEN_Position_P(arg3), arg3, 3, "XtTranslateCoords", "Position");
  XtTranslateCoords(XEN_TO_C_Widget(arg1), XEN_TO_C_Position(arg2), XEN_TO_C_Position(arg3), &x, &y);
  return(XEN_LIST_2(C_TO_XEN_Position(x),
		    C_TO_XEN_Position(y)));
}

static XEN gxm_XtMakeResizeRequest(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XtMakeResizeRequest "XtGeometryResult XtMakeResizeRequest(w, width, height) -> (res width height)"
  /* DIFF: XtMakeResizeRequest w wid hgt [rtnw rtn] -> (list res w h)
   */
  Dimension w, h;
  int val;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtMakeResizeRequest", "Widget");
  XEN_ASSERT_TYPE(XEN_Dimension_P(arg2), arg2, 2, "XtMakeResizeRequest", "Dimension");
  XEN_ASSERT_TYPE(XEN_Dimension_P(arg3), arg3, 3, "XtMakeResizeRequest", "Dimension");
  val = XtMakeResizeRequest(XEN_TO_C_Widget(arg1), 
			    XEN_TO_C_Dimension(arg2), 
			    XEN_TO_C_Dimension(arg3), 
			    &w, &h);
  return(XEN_LIST_3(C_TO_XEN_INT(val),
		    C_TO_XEN_Dimension(w),
		    C_TO_XEN_Dimension(h)));
}

static XEN gxm_XtOwnSelectionIncremental(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6, XEN arg7, XEN arg8)
{
  #define H_XtOwnSelectionIncremental "Boolean XtOwnSelectionIncremental(w, selection, time, convert_callback, lose_callback, \
done_callback, cancel_callback, client_data)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtOwnSelectionIncremental", "Widget");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg2), arg2, 2, "XtOwnSelectionIncremental", "Atom");
  XEN_ASSERT_TYPE(XEN_Time_P(arg3), arg3, 3, "XtOwnSelectionIncremental", "Time");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg4) && (XEN_REQUIRED_ARGS_OK(arg4, 10)), arg4, 4, "XtOwnSelectionIncremental", "XtConvertSelectionIncrProc");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg5) && (XEN_REQUIRED_ARGS_OK(arg5, 3)), arg5, 5, "XtOwnSelectionIncremental", "XtLoseSelectionIncrProc");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg6) && (XEN_REQUIRED_ARGS_OK(arg6, 5)), arg6, 6, "XtOwnSelectionIncremental", "XtSelectionDoneIncrProc");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg7) && (XEN_REQUIRED_ARGS_OK(arg7, 5)), arg7, 7, "XtOwnSelectionIncremental", "XtCancelConvertSelectionProc");
  add_selmap(XEN_TO_C_Widget(arg1), CONVERT_INCR, arg4);
  add_selmap(XEN_TO_C_Widget(arg1), LOSE_INCR, arg5);
  add_selmap(XEN_TO_C_Widget(arg1), DONE_INCR, arg6);
  add_selmap(XEN_TO_C_Widget(arg1), CANCEL_CONVERT, arg7);	     
  return(C_TO_XEN_BOOLEAN(XtOwnSelectionIncremental(XEN_TO_C_Widget(arg1), 
						    XEN_TO_C_Atom(arg2), 
						    XEN_TO_C_Time(arg3), 
						    (XtConvertSelectionIncrProc)gxm_XtConvertSelectionIncrProc, 
						    gxm_XtLoseSelectionIncrProc, 
						    gxm_XtSelectionDoneIncrProc, 
						    gxm_XtCancelConvertSelectionProc, 
						    (XtPointer)arg8)));
}

static XEN gxm_XtOwnSelection(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6)
{
  #define H_XtOwnSelection "Boolean XtOwnSelection(w, selection, time, convert_proc, lose_selection, done_proc) informs the selection \
mechanism that a widget believes it owns a selection."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtOwnSelection", "Widget");
  XEN_ASSERT_TYPE(XEN_Atom_P(arg2), arg2, 2, "XtOwnSelection", "Atom");
  XEN_ASSERT_TYPE(XEN_Time_P(arg3), arg3, 3, "XtOwnSelection", "Time");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg4) && (XEN_REQUIRED_ARGS_OK(arg4, 7)), arg4, 4, "XtOwnSelection", "XtConvertSelectionProc");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg5) && (XEN_REQUIRED_ARGS_OK(arg5, 2)), arg5, 5, "XtOwnSelection", "XtLoseSelectionProc");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg6) && (XEN_REQUIRED_ARGS_OK(arg6, 3)), arg6, 6, "XtOwnSelection", "XtSelectionDoneProc");
  add_selmap(XEN_TO_C_Widget(arg1), CONVERT, arg4);
  add_selmap(XEN_TO_C_Widget(arg1), LOSE, arg5);
  add_selmap(XEN_TO_C_Widget(arg1), DONE, arg6);	     
  return(C_TO_XEN_BOOLEAN(XtOwnSelection(XEN_TO_C_Widget(arg1), 
					 XEN_TO_C_Atom(arg2), 
					 XEN_TO_C_Time(arg3), 
					 (XtConvertSelectionProc)gxm_XtConvertSelectionProc, 
					 gxm_XtLoseSelectionProc, 
					 gxm_XtSelectionDoneProc)));
}

static XEN gxm_XtIsSensitive(XEN arg1)
{
  #define H_XtIsSensitive "Boolean XtIsSensitive(w) returns #t if user input events are being dispatched."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtIsSensitive", "Widget");
  return(C_TO_XEN_BOOLEAN(XtIsSensitive(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XtIsRealized(XEN arg1)
{
  #define H_XtIsRealized "Boolean XtIsRealized(w) returns #t if the widget has been realized,"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtIsRealized", "Widget");
  return(C_TO_XEN_BOOLEAN(XtIsRealized(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XtIsManaged(XEN arg1)
{
  #define H_XtIsManaged "Boolean XtIsManaged(widget) returns #t if the specified widget is of class RectObj or any subclass thereof and is managed."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtIsManaged", "Widget");
  return(C_TO_XEN_BOOLEAN(XtIsManaged(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XtIsObject(XEN arg1)
{
  #define H_XtIsObject "Boolean XtIsObject(w)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtIsObject", "Widget");
  return(C_TO_XEN_BOOLEAN(XtIsObject(XEN_TO_C_Widget(arg1))));
}

static XEN gxm_XtIsSubclass(XEN arg1, XEN arg2)
{
  #define H_XtIsSubclass "Boolean XtIsSubclass(w, widget_class) returns #t if the class of the specified widget is equal to or is a \
subclass of the specified class."
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtIsSubclass", "Widget");
  XEN_ASSERT_TYPE(XEN_WidgetClass_P(arg2), arg2, 2, "XtIsSubclass", "WidgetClass");
  return(C_TO_XEN_BOOLEAN(XtIsSubclass(XEN_TO_C_Widget(arg1), XEN_TO_C_WidgetClass(arg2))));
}

static XEN gxm_XtAppPeekEvent(XEN arg1)
{
  #define H_XtAppPeekEvent "Boolean XtAppPeekEvent(app_context) fills in the event and returns a nonzero value. If no X \
input is on the queue, XtAppPeekEvent flushes the output buffer and blocks until input is available."
  /* DIFF: XtAppPeekEvent app [ev] -> (list val ev)
   */
  XEvent *e;
  int val;
  XEN_ASSERT_TYPE(XEN_XtAppContext_P(arg1), arg1, 1, "XtAppPeekEvent", "XtAppContext");
  e = (XEvent *)CALLOC(1, sizeof(XEvent));
  val = XtAppPeekEvent(XEN_TO_C_XtAppContext(arg1), e);
  return(XEN_LIST_2(C_TO_XEN_BOOLEAN(val), C_TO_XEN_XEvent_OBJ(e)));
}

#if (!XM_DISABLE_DEPRECATED)
static XEN gxm_XtPeekEvent(void)
{
  #define H_XtPeekEvent "Boolean XtPeekEvent() has been replaced by XtAppPeekEvent."
  /* DIFF: XtPeekEvent [ev] -> (list val ev)
   */
  XEvent *e;
  int val;
  e = (XEvent *)CALLOC(1, sizeof(XEvent));
  val = XtPeekEvent(e);
  return(XEN_LIST_2(C_TO_XEN_BOOLEAN(val), C_TO_XEN_XEvent_OBJ(e)));
}
#endif

static XEN gxm_XtCallAcceptFocus(XEN arg1, XEN arg2)
{
  #define H_XtCallAcceptFocus "Boolean XtCallAcceptFocus(w, time) calls the specified widget's accept_focus procedure, passing it the \
specified widget and time, and returns what the accept_focus procedure returns."
  /* DIFF: XtCallAcceptFocus takes Time arg (not Time*)
   */
  Time tm;
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtCallAcceptFocus", "Widget");
  XEN_ASSERT_TYPE(XEN_Time_P(arg2), arg2, 2, "XtCallAcceptFocus", "Time");
  tm = XEN_TO_C_Time(arg2);
  return(C_TO_XEN_BOOLEAN(XtCallAcceptFocus(XEN_TO_C_Widget(arg1), &tm)));
}

static XEN gxm_XtDispatchEvent(XEN arg1)
{
  #define H_XtDispatchEvent "Boolean XtDispatchEvent(event) sends those events to the event handler functions that have been previously \
registered with the dispatch routine."
  XEN_ASSERT_TYPE(XEN_XEvent_P(arg1), arg1, 1, "XtDispatchEvent", "XEvent*");
  return(C_TO_XEN_BOOLEAN(XtDispatchEvent(XEN_TO_C_XEvent(arg1))));
}

static XEN gxm_XtUnmanageChild(XEN arg1)
{
  #define H_XtUnmanageChild "void XtUnmanageChild(child)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtUnmanageChild", "Widget");
  XtUnmanageChild(XEN_TO_C_Widget(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XtUnmanageChildren(XEN arg1, XEN arg2)
{
  #define H_XtUnmanageChildren "void XtUnmanageChildren(children, num_children)"
  /* DIFF: XtUnmanageChildren arg1 is list of widgets
   */
  int len;
  XEN_ASSERT_TYPE(XEN_LIST_P(arg1), arg1, 1, "XtUnmanageChildren", "WidgetList");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg2), arg2, 2, "XtUnmanageChildren", "int");
  if (XEN_INTEGER_P(arg2)) len = XEN_TO_C_INT(arg2); else len = XEN_LIST_LENGTH(arg1);
  if (len > 0)
    {
      if (len > XEN_LIST_LENGTH(arg1))
	XEN_OUT_OF_RANGE_ERROR("XmContainerReorder", 2, arg2, "len too large");
      else
	{
	  WidgetList ws1;
	  ws1 = XEN_TO_C_Widgets(arg1, len);
	  XtUnmanageChildren(ws1, len);
	  if (ws1) FREE(ws1);
	}
    }
  return(XEN_FALSE);
}

static XEN gxm_XtManageChild(XEN arg1)
{
  #define H_XtManageChild "void XtManageChild(child)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg1), arg1, 1, "XtManageChild", "Widget");
  XtManageChild(XEN_TO_C_Widget(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XtManageChildren(XEN arg1, XEN arg2)
{
  #define H_XtManageChildren "void XtManageChildren(children, num_children)"
  /* DIFF: XtManageChildren arg1 is list of widgets
   */
  int len;
  XEN_ASSERT_TYPE(XEN_LIST_P(arg1), arg1, 1, "XtManageChildren", "WidgetList");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(arg2), arg2, 2, "XtManageChildren", "int");
  if (XEN_INTEGER_P(arg2)) len = XEN_TO_C_INT(arg2); else len = XEN_LIST_LENGTH(arg1);
  if (len > 0)
    {
      if (len > XEN_LIST_LENGTH(arg1))
	XEN_OUT_OF_RANGE_ERROR("XmContainerReorder", 2, arg2, "len too large");
      else
	{
	  WidgetList ws1;
	  ws1 = XEN_TO_C_Widgets(arg1, len);
	  XtManageChildren(ws1, len);
	  if (ws1) FREE(ws1);
	}
    }
  return(XEN_FALSE);
}

static XEN gxm_XtIsRectObj(XEN arg)
{
  #define H_XtIsRectObj "Boolean XtIsRectObj(w)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XtIsRectObj", "Widget");
  return(C_TO_XEN_BOOLEAN(XtIsRectObj(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XtIsWidget(XEN arg)
{
  #define H_XtIsWidget "Boolean XtIsWidget(w)"
  return(C_TO_XEN_BOOLEAN(WRAP_P("Widget", arg) && 
			  (XtIsWidget(XEN_TO_C_Widget(arg)))));
}

static XEN gxm_XtIsComposite(XEN arg)
{
  #define H_XtIsComposite "Boolean XtIsComposite(w)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XtIsComposite", "Widget");
  return(C_TO_XEN_BOOLEAN(XtIsComposite(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XtIsConstraint(XEN arg)
{
  #define H_XtIsConstraint "Boolean XtIsConstraint(w)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XtIsConstraint", "Widget");
  return(C_TO_XEN_BOOLEAN(XtIsConstraint(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XtIsShell(XEN arg)
{
  #define H_XtIsShell "Boolean XtIsShell(w)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XtIsShell", "Widget");
  return(C_TO_XEN_BOOLEAN(XtIsShell(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XtIsOverrideShell(XEN arg)
{
  #define H_XtIsOverrideShell "Boolean XtIsOverrideShell(w)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XtIsOverrideShell", "Widget");
  return(C_TO_XEN_BOOLEAN(XtIsOverrideShell(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XtIsWMShell(XEN arg)
{
  #define H_XtIsWMShell "Boolean XtIsWMShell(w)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XtIsWMShell", "Widget");
  return(C_TO_XEN_BOOLEAN(XtIsWMShell(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XtIsVendorShell(XEN arg)
{
  #define H_XtIsVendorShell "Boolean XtIsVendorShell(w)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XtIsVendorShell", "Widget");
  return(C_TO_XEN_BOOLEAN(XtIsVendorShell(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XtIsTransientShell(XEN arg)
{
  #define H_XtIsTransientShell "Boolean XtIsTransientShell(w)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XtIsTransientShell", "Widget");
  return(C_TO_XEN_BOOLEAN(XtIsTransientShell(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XtIsTopLevelShell(XEN arg)
{
  #define H_XtIsTopLevelShell "Boolean XtIsTopLevelShell(w)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XtIsTopLevelShell", "Widget");
  return(C_TO_XEN_BOOLEAN(XtIsTopLevelShell(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XtIsApplicationShell(XEN arg)
{
  #define H_XtIsApplicationShell "Boolean XtIsApplicationShell(w)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XtIsApplicationShell", "Widget");
  return(C_TO_XEN_BOOLEAN(XtIsApplicationShell(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XtIsSessionShell(XEN arg)
{
  #define H_XtIsSessionShell "Boolean XtIsSessionShell(w)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XtIsSessionShell", "Widget");
  return(C_TO_XEN_BOOLEAN(XtIsSessionShell(XEN_TO_C_Widget(arg))));
}

static XEN gxm_XtMapWidget(XEN arg)
{
  #define H_XtMapWidget "XtMapWidget(w)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XtMapWidget", "Widget");
  XtMapWidget(XEN_TO_C_Widget(arg));
  return(XEN_FALSE);
}

static XEN gxm_XtUnmapWidget(XEN arg)
{
  #define H_XtUnmapWidget "XtUnmapWidget(w)"
  XEN_ASSERT_TYPE(XEN_Widget_P(arg), arg, 0, "XtUnmapWidget", "Widget");
  XtUnmapWidget(XEN_TO_C_Widget(arg));
  return(XEN_FALSE);
}

static XEN gxm_XtSetArg(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XtSetArg "XtSetArg in xm is useless -- it returns its arguments as a list"
  return(XEN_LIST_3(arg1, arg2, arg3));
}


#endif
/* end HAVE_MOTIF */


/* ---------------------------------------------------------------------------------------------------- */
#if HAVE_XM_XP
static XEN gxm_XpCancelPage(XEN arg1, XEN arg2)
{
  #define H_XpCancelPage "void XpCancelPage(Display *display,Bool discard)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpCancelPage", "Display*");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg2), arg2, 2, "XpCancelPage", "BOOLEAN");
  XpCancelPage(XEN_TO_C_Display(arg1), XEN_TO_C_BOOLEAN(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XpEndPage(XEN arg1)
{
  #define H_XpEndPage "void XpEndPage(Display *display)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpEndPage", "Display*");
  XpEndPage(XEN_TO_C_Display(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XpStartPage(XEN arg1, XEN arg2)
{
  #define H_XpStartPage "void XpStartPage(Display *display,Window window)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpStartPage", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XpStartPage", "Window");
  XpStartPage(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XpCancelDoc(XEN arg1, XEN arg2)
{
  #define H_XpCancelDoc "void XpCancelDoc(Display *display,Bool discard)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpCancelDoc", "Display*");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg2), arg2, 2, "XpCancelDoc", "BOOLEAN");
  XpCancelDoc(XEN_TO_C_Display(arg1), XEN_TO_C_BOOLEAN(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XpEndDoc(XEN arg1)
{
  #define H_XpEndDoc "void XpEndDoc(Display *display)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpEndDoc", "Display*");
  XpEndDoc(XEN_TO_C_Display(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XpStartDoc(XEN arg1, XEN arg2)
{
  #define H_XpStartDoc "void XpStartDoc(Display *display, XPDocumentType type)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpStartDoc", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XpStartDoc", "XPDocumentType");
  XpStartDoc(XEN_TO_C_Display(arg1), (XPDocumentType)XEN_TO_C_INT(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XpCancelJob(XEN arg1, XEN arg2)
{
  #define H_XpCancelJob "void XpCancelJob(Display *display,Bool discard)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpCancelJob", "Display*");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg2), arg2, 2, "XpCancelJob", "BOOLEAN");
  XpCancelJob(XEN_TO_C_Display(arg1), XEN_TO_C_BOOLEAN(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XpEndJob(XEN arg1)
{
  #define H_XpEndJob "void XpEndJob(Display *display)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpEndJob", "Display*");
  XpEndJob(XEN_TO_C_Display(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XpStartJob(XEN arg1, XEN arg2)
{
  #define H_XpStartJob "void XpStartJob(Display *display, XPSaveData save_data)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpStartJob", "Display*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg2), arg2, 2, "XpStartJob", "XPSaveData");
  XpStartJob(XEN_TO_C_Display(arg1), (XPSaveData)XEN_TO_C_INT(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XpRehashPrinterList(XEN arg1)
{
  #define H_XpRehashPrinterList "void XpRehashPrinterList(Display *display)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpRehashPrinterList", "Display*");
  XpRehashPrinterList(XEN_TO_C_Display(arg1));
  return(XEN_FALSE);
}

static XEN gxm_XpDestroyContext(XEN arg1, XEN arg2)
{
  #define H_XpDestroyContext "void XpDestroyContext(Display *display, XPContext print_context)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpDestroyContext", "Display*");
  XEN_ASSERT_TYPE(XEN_XPContext_P(arg2), arg2, 2, "XpDestroyContext", "XPContext");
  XpDestroyContext(XEN_TO_C_Display(arg1), XEN_TO_C_XPContext(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XpGetContext(XEN arg1)
{
  #define H_XpGetContext "XPContext XpGetContext(Display *display)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpGetContext", "Display*");
  return(C_TO_XEN_XPContext(XpGetContext(XEN_TO_C_Display(arg1))));
}

static XEN gxm_XpSetContext(XEN arg1, XEN arg2)
{
  #define H_XpSetContext "void XpSetContext(Display *display, XPContext print_context)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpSetContext", "Display*");
  XEN_ASSERT_TYPE(XEN_XPContext_P(arg2), arg2, 2, "XpSetContext", "XPContext");
  XpSetContext(XEN_TO_C_Display(arg1), XEN_TO_C_XPContext(arg2));
  return(XEN_FALSE);
}

static XEN gxm_XpCreateContext(XEN arg1, XEN arg2)
{
  #define H_XpCreateContext "XPContext XpCreateContext(Display *display,char *printer_name)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpCreateContext", "Display*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XpCreateContext", "char*");
  return(C_TO_XEN_XPContext(XpCreateContext(XEN_TO_C_Display(arg1), XEN_TO_C_STRING(arg2))));
}

static XEN gxm_XpNotifyPdm(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6)
{
  #define H_XpNotifyPdm "char *XpNotifyPdm(Display *print_display,Window print_window, XPContext print_context, \
Display *video_display,Window video_window,Bool auth_flag)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpNotifyPdm", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XpNotifyPdm", "Window");
  XEN_ASSERT_TYPE(XEN_XPContext_P(arg3), arg3, 3, "XpNotifyPdm", "XPContext");
  XEN_ASSERT_TYPE(XEN_Display_P(arg4), arg4, 4, "XpNotifyPdm", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg5), arg5, 5, "XpNotifyPdm", "Window");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg6), arg6, 6, "XpNotifyPdm", "BOOLEAN");
  return(C_TO_XEN_STRING(XpNotifyPdm(XEN_TO_C_Display(arg1), 
				     XEN_TO_C_Window(arg2), 
				     XEN_TO_C_XPContext(arg3), 
				     XEN_TO_C_Display(arg4), 
				     XEN_TO_C_Window(arg5), 
				     XEN_TO_C_BOOLEAN(arg6))));
}

static XEN gxm_XpGetLocaleNetString(void)
{
  #define H_XpGetLocaleNetString "char *XpGetLocaleNetString(void)"
  return(C_TO_XEN_STRING(XpGetLocaleNetString()));
}

static XEN gxm_XpSendAuth(XEN arg1, XEN arg2)
{
  #define H_XpSendAuth "Status XpSendAuth(Display *display,Window window)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpSendAuth", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XpSendAuth", "Window");
  return(C_TO_XEN_INT(XpSendAuth(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2))));
}

static XEN gxm_XpGetImageResolution(XEN arg1, XEN arg2)
{
  #define H_XpGetImageResolution "int XpGetImageResolution(Display *display, XPContext print_context)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpGetImageResolution", "Display*");
  XEN_ASSERT_TYPE(XEN_XPContext_P(arg2), arg2, 2, "XpGetImageResolution", "XPContext");
  return(C_TO_XEN_INT(XpGetImageResolution(XEN_TO_C_Display(arg1), XEN_TO_C_XPContext(arg2))));
}

static XEN gxm_XpGetOneAttribute(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XpGetOneAttribute "char *XpGetOneAttribute(Display *display, XPContext print_context, XPAttributes type,char *attribute_name)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpGetOneAttribute", "Display*");
  XEN_ASSERT_TYPE(XEN_XPContext_P(arg2), arg2, 2, "XpGetOneAttribute", "XPContext");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XpGetOneAttribute", "XPAttributes");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg4), arg4, 4, "XpGetOneAttribute", "char*");
  return(C_TO_XEN_STRING(XpGetOneAttribute(XEN_TO_C_Display(arg1), XEN_TO_C_XPContext(arg2), 
					   (XPAttributes)XEN_TO_C_INT(arg3), XEN_TO_C_STRING(arg4))));
}

static XEN gxm_XpSetAttributes(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XpSetAttributes "void XpSetAttributes(Display *display, XPContext print_context, XPAttributes type,char *pool, XPAttrReplacement replacement_rule)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpSetAttributes", "Display*");
  XEN_ASSERT_TYPE(XEN_XPContext_P(arg2), arg2, 2, "XpSetAttributes", "XPContext");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XpSetAttributes", "XPAttributes");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg4), arg4, 4, "XpSetAttributes", "char*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg5), arg5, 5, "XpSetAttributes", "XPAttrReplacement");
  XpSetAttributes(XEN_TO_C_Display(arg1), XEN_TO_C_XPContext(arg2), 
		  (XPAttributes)XEN_TO_C_INT(arg3), XEN_TO_C_STRING(arg4), 
		  (XPAttrReplacement)XEN_TO_C_INT(arg5));
  return(XEN_FALSE);
}

static XEN gxm_XpGetAttributes(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XpGetAttributes "char *XpGetAttributes(Display *display, XPContext print_context, XPAttributes type)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpGetAttributes", "Display*");
  XEN_ASSERT_TYPE(XEN_XPContext_P(arg2), arg2, 2, "XpGetAttributes", "XPContext");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XpGetAttributes", "XPAttributes");
  return(C_TO_XEN_STRING(XpGetAttributes(XEN_TO_C_Display(arg1), XEN_TO_C_XPContext(arg2), 
					 (XPAttributes)XEN_TO_C_INT(arg3))));
}

static XEN gxm_XpGetScreenOfContext(XEN arg1, XEN arg2)
{
  #define H_XpGetScreenOfContext "Screen *XpGetScreenOfContext(Display *display, XPContext print_context)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpGetScreenOfContext", "Display*");
  XEN_ASSERT_TYPE(XEN_XPContext_P(arg2), arg2, 2, "XpGetScreenOfContext", "XPContext");
  return(C_TO_XEN_Screen(XpGetScreenOfContext(XEN_TO_C_Display(arg1), XEN_TO_C_XPContext(arg2))));
}

static XEN gxm_XpSendOneTicket(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XpSendOneTicket "Status XpSendOneTicket(Display *display,Window window, Xauth *ticket,Bool more)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpSendOneTicket", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XpSendOneTicket", "Window");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XpSendOneTicket", "Xauth*"); /* opaque */
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(arg4), arg4, 4, "XpSendOneTicket", "BOOLEAN");
  return(C_TO_XEN_INT(XpSendOneTicket(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), 
				      (Xauth *)XEN_TO_C_ULONG(arg3), XEN_TO_C_BOOLEAN(arg4))));
}

static XEN gxm_XpGetAuthParams(XEN arg1, XEN arg2)
{
  #define H_XpGetAuthParams "Status XpGetAuthParams(Display *print_display,Display *video_display)"
  /* DIFF: XpGetAuthParams omits 3 ref args and returns them 
   */
  Atom a1, a2;
  Display *dp;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpGetAuthParams", "Display*");
  XEN_ASSERT_TYPE(XEN_Display_P(arg2), arg2, 2, "XpGetAuthParams", "Display*");
  val = XpGetAuthParams(XEN_TO_C_Display(arg1), XEN_TO_C_Display(arg2), &dp, &a1, &a2);
  return(XEN_LIST_4(C_TO_XEN_INT(val),
		    C_TO_XEN_Display(dp),
		    C_TO_XEN_Atom(a1),
		    C_TO_XEN_Atom(a2)));
}

static XEN gxm_XpGetPdmStartParams(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XpGetPdmStartParams "Status XpGetPdmStartParams(Display *print_display,Window print_window, XPContext print_context, \
Display *video_display,Window video_window)"
  /* DIFF: XpGetPdmStartParams trailing 6 ref args omitted and returned
   */
  int val, i1, i2;
  Atom a1, a2;
  Display *dp;
  unsigned char *pars;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpGetPdmStartParams", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XpGetPdmStartParams", "Window");
  XEN_ASSERT_TYPE(XEN_XPContext_P(arg3), arg3, 3, "XpGetPdmStartParams", "XPContext");
  XEN_ASSERT_TYPE(XEN_Display_P(arg4), arg4, 4, "XpGetPdmStartParams", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg5), arg5, 5, "XpGetPdmStartParams", "Window");
  val = XpGetPdmStartParams(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), 
			    XEN_TO_C_XPContext(arg3), XEN_TO_C_Display(arg4), 
			    XEN_TO_C_Window(arg5), 
			    &dp, &a1, &a2, &i1, &pars, &i2);
  return(XEN_LIST_7(C_TO_XEN_INT(val),
		    C_TO_XEN_Display(dp),
		    C_TO_XEN_Atom(a1),
		    C_TO_XEN_Atom(a2),
		    C_TO_XEN_INT(i1),
		    C_TO_XEN_STRING((const char *)pars),
		    C_TO_XEN_INT(i2)));
}

static XEN gxm_XpQueryScreens(XEN arg1)
{
  #define H_XpQueryScreens "Screen **XpQueryScreens(Display *display)"
  /* DIFF: XpQueryScreens omits last arg, returns list of Screens
   */
  int len, i, loc;
  Screen **val = NULL;
  XEN lst = XEN_EMPTY_LIST;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpQueryScreens", "Display*");
  val = XpQueryScreens(XEN_TO_C_Display(arg1), &len);
  loc = xm_protect(lst);
  if (val)
    {
      for (i = len - 1; i >= 0; i--)
	lst = XEN_CONS(C_TO_XEN_Screen(val[i]), lst);
    }
  xm_unprotect_at(loc);
  return(lst);
}

static XEN gxm_XpQueryExtension(XEN arg1)
{
  #define H_XpQueryExtension "Bool XpQueryExtension(Display *display)"
  /* DIFF: XpQueryExtension omits and rtns last 2 args
   */
  int val, i1, i2;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpQueryExtension", "Display*");
  val = (int)XpQueryExtension(XEN_TO_C_Display(arg1), &i1, &i2);
  return(XEN_LIST_3(C_TO_XEN_BOOLEAN(val),
		    C_TO_XEN_INT(i1),
		    C_TO_XEN_INT(i2)));
}

static XEN gxm_XpQueryVersion(XEN arg1)
{
  #define H_XpQueryVersion "Status XpQueryVersion(Display *display)"
  /* DIFF: XpQueryVersion omits and rtns last 2 args
   */
  int val;
  short i1, i2;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpQueryVersion", "Display*");
  val = XpQueryVersion(XEN_TO_C_Display(arg1), &i1, &i2);
  return(XEN_LIST_3(C_TO_XEN_INT(val),
		    C_TO_XEN_INT((int)i1),
		    C_TO_XEN_INT((int)i2)));
}

static XEN gxm_XpFreePrinterList(XEN arg1)
{
  #define H_XpFreePrinterList "void XpFreePrinterList(XPPrinterList printer_list)"
  /* DIFF: XpFreePrinterList is a no-op
   */
  return(XEN_FALSE);
}

static XEN gxm_XpGetPageDimensions(XEN arg1, XEN arg2)
{
  #define H_XpGetPageDimensions "Status XpGetPageDimensions(Display *display, XPContext print_context)"
  /* DIFF: XpGetPageDimensions omits and rtns last 3 args
   */
  unsigned short i1, i2;
  XRectangle *r;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpGetPageDimensions", "Display*");
  XEN_ASSERT_TYPE(XEN_XPContext_P(arg2), arg2, 2, "XpGetPageDimensions", "XPContext");
  r = (XRectangle *)CALLOC(1, sizeof(XRectangle));
  val = XpGetPageDimensions(XEN_TO_C_Display(arg1), XEN_TO_C_XPContext(arg2), &i1, &i2, r);
  return(XEN_LIST_4(C_TO_XEN_INT(val),
		    C_TO_XEN_INT((int)i1),
		    C_TO_XEN_INT((int)i2),
		    C_TO_XEN_XRectangle(r)));
}

static XEN gxm_XpSetImageResolution(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  #define H_XpSetImageResolution "Bool XpSetImageResolution(Display *display, XPContext print_context,int image_res,int *prev_res)"
  /* DIFF: XpSetImageResolution last arg is int, val is returned
   */
  int i, val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpSetImageResolution", "Display*");
  XEN_ASSERT_TYPE(XEN_XPContext_P(arg2), arg2, 2, "XpSetImageResolution", "XPContext");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg3), arg3, 3, "XpSetImageResolution", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XpSetImageResolution", "int*");
  val = XpSetImageResolution(XEN_TO_C_Display(arg1), XEN_TO_C_XPContext(arg2), XEN_TO_C_INT(arg3), &i);
  return(XEN_LIST_2(C_TO_XEN_BOOLEAN(val),
		    C_TO_XEN_INT(i)));
}

static XEN gxm_XpGetPrinterList(XEN arg1, XEN arg2)
{
  #define H_XpGetPrinterList "XPPrinterList XpGetPrinterList(Display *display,char *printer_name)"
  /* DIFF: XpGetPrinterList returns list of printers, omits arg 3
   */
  XPPrinterList xp;
  int len;
  XEN lst = XEN_EMPTY_LIST;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpGetPrinterList", "Display*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XpGetPrinterList", "char*");
  xp = XpGetPrinterList(XEN_TO_C_Display(arg1), XEN_TO_C_STRING(arg2), &len);
  if (xp)
    {
      int i, loc;
      loc = xm_protect(lst);
      for (i = len - 1; i >= 0; i--)
	lst = XEN_CONS(XEN_LIST_2(C_TO_XEN_STRING(xp[i].name),
				  C_TO_XEN_STRING(xp[i].desc)),
		       lst);
      XpFreePrinterList(xp);
      xm_unprotect_at(loc);
    }
  return(lst);
}

static XEN gxm_XpSelectInput(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XpSelectInput "void XpSelectInput(Display *display, XPContext print_context,unsigned long event_mask)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpSelectInput", "Display*");
  XEN_ASSERT_TYPE(XEN_XPContext_P(arg2), arg2, 2, "XpSelectInput", "XPContext");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XpSelectInput", "ulong");
  XpSelectInput(XEN_TO_C_Display(arg1), XEN_TO_C_XPContext(arg2), XEN_TO_C_ULONG(arg3));
  return(XEN_FALSE);
}

static XEN gxm_XpInputSelected(XEN arg1, XEN arg2, XEN arg3)
{
  #define H_XpInputSelected "unsigned long XpInputSelected(Display *display, XPContext print_context,unsigned long *all_events_mask)"
  /* DIFF: XpInputSelected arg3 is int, is returned
   */
  unsigned long val, i1;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpInputSelected", "Display*");
  XEN_ASSERT_TYPE(XEN_XPContext_P(arg2), arg2, 2, "XpInputSelected", "XPContext");
  XEN_ASSERT_TYPE(XEN_ULONG_P(arg3), arg3, 3, "XpInputSelected", "ulong*");
  i1 = XEN_TO_C_ULONG(arg3);
  val = XpInputSelected(XEN_TO_C_Display(arg1), XEN_TO_C_XPContext(arg2), &i1);
  return(XEN_LIST_2(C_TO_XEN_ULONG(val),
		    C_TO_XEN_ULONG(i1)));
}

static void gxm_XPSaveProc(Display *display, XPContext context, unsigned char *sdata, unsigned int data_len, XPointer client_data)
{
  XEN data = (XEN)client_data;
  XEN_CALL_5(XEN_CAR(data),
	     C_TO_XEN_Display(display),
	     C_TO_XEN_XPContext(context),
	     C_TO_XEN_STRING((const char *)sdata),
	     C_TO_XEN_INT(data_len),
	     XEN_CADDR(data),
	     c__FUNCTION__);
  xm_unprotect(data); /* not sure about this -- should it be deferred until the finish proc? */
}

static void gxm_XPFinishProc(Display *display, XPContext context, XPGetDocStatus status, XPointer client_data)
{
  XEN data = (XEN)client_data;
  XEN_CALL_4(XEN_CADR(data),
	     C_TO_XEN_Display(display),
	     C_TO_XEN_XPContext(context),
	     C_TO_XEN_INT(status),
	     XEN_CADDR(data),
	     c__FUNCTION__);
  xm_unprotect(data);
}

static XEN gxm_XpGetDocumentData(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  #define H_XpGetDocumentData "Status XpGetDocumentData(Display *display, XPContext context, XPSaveProc save_proc, XPFinishProc finish_proc, XPointer client_data)"
  XEN descr;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpGetDocumentData", "Display*");
  XEN_ASSERT_TYPE(XEN_XPContext_P(arg2), arg2, 2, "XpGetDocumentData", "XPContext");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg3) && (XEN_REQUIRED_ARGS_OK(arg3, 5)), arg3, 3, "XpGetDocumentData", "XPSaveProc");
  XEN_ASSERT_TYPE(XEN_PROCEDURE_P(arg4) && (XEN_REQUIRED_ARGS_OK(arg4, 4)), arg4, 4, "XpGetDocumentData", "XPFinishProc");
  descr = XEN_LIST_3(arg3, arg4, arg5);
  xm_protect(descr);
  return(C_TO_XEN_INT(XpGetDocumentData(XEN_TO_C_Display(arg1), XEN_TO_C_XPContext(arg2), 
					(XPSaveProc)gxm_XPSaveProc,
					(XPFinishProc)gxm_XPFinishProc,
					(char *)descr)));
}

static XEN gxm_XpPutDocumentData(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5, XEN arg6)
{
  #define H_XpPutDocumentData "void XpPutDocumentData(Display *display,Drawable drawable,unsigned char *data,int data_len,char *doc_fmt,char *options)"
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpPutDocumentData", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XpPutDocumentData", "Window");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3), arg3, 3, "XpPutDocumentData", "uchar*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(arg4), arg4, 4, "XpPutDocumentData", "int");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg5), arg5, 5, "XpPutDocumentData", "char*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg6), arg6, 6, "XpPutDocumentData", "char*");
  XpPutDocumentData(XEN_TO_C_Display(arg1), XEN_TO_C_Window(arg2), 
		    (unsigned char *)XEN_TO_C_STRING(arg3), 
		    XEN_TO_C_INT(arg4), XEN_TO_C_STRING(arg5), XEN_TO_C_STRING(arg6));
  return(XEN_FALSE);
}
#endif


/* ---------------------------------------------------------------------------------------------------- */
#if HAVE_XPM

XM_TYPE_PTR_NO_C2X(XpmImage, XpmImage *)
XM_TYPE_PTR_NO_C2X(XpmAttributes, XpmAttributes *) /* _OBJ?? */
XM_TYPE_PTR_NO_C2X(XpmColorSymbol, XpmColorSymbol *)

#if HAVE_XPM_CREATE_XPM_IMAGE_FROM_PIXMAP
static XEN gxm_XpmCreateXpmImageFromPixmap(XEN arg1, XEN arg2, XEN arg3, XEN arg5)
{
  XpmImage *image;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpmCreateXpmImageFromPixmap", "Display*");
  XEN_ASSERT_TYPE(XEN_Pixmap_P(arg2), arg2, 2, "XpmCreateXpmImageFromPixmap", "Pixmap");
  XEN_ASSERT_TYPE(XEN_Pixmap_P(arg3), arg3, 3, "XpmCreateXpmImageFromPixmap", "Pixmap");
  XEN_ASSERT_TYPE(XEN_XpmAttributes_P(arg5) || XEN_FALSE_P(arg5), arg5, 5, "XpmCreateXpmImageFromPixmap", "XpmAttributes*");
  image = (XpmImage *)CALLOC(1, sizeof(XpmImage));
  val = XpmCreateXpmImageFromPixmap(XEN_TO_C_Display(arg1), 
				    XEN_TO_C_Pixmap(arg2), 
				    XEN_TO_C_Pixmap(arg3), 
				    image,
				    (XEN_FALSE_P(arg5)) ? NULL : XEN_TO_C_XpmAttributes(arg5));
  if (val == XpmSuccess)
    return(WRAP_FOR_XEN_OBJ("XpmImage", image));
  FREE(image);
  return(C_TO_XEN_INT(val));
}

static XEN gxm_XpmCreatePixmapFromXpmImage(XEN arg1, XEN arg2, XEN arg3, XEN arg4)
{
  /* DIFF: XpmCreatePixmapFromXpmImage omits and returns pixmap args
   */
  Pixmap p1, p2;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpmCreatePixmapFromXpmImage", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XpmCreatePixmapFromXpmImage", "Drawable");
  XEN_ASSERT_TYPE(XEN_XpmImage_P(arg3), arg3, 3, "XpmCreatePixmapFromXpmImage", "XpmImage*");
  XEN_ASSERT_TYPE(XEN_XpmAttributes_P(arg4) || XEN_FALSE_P(arg4), arg4, 4, "XpmCreatePixmapFromXpmImage", "XpmAttributes*");
  val = XpmCreatePixmapFromXpmImage(XEN_TO_C_Display(arg1), 
				    XEN_TO_C_Window(arg2), 
				    XEN_TO_C_XpmImage(arg3), 
				    &p1, &p2,
				    (XEN_FALSE_P(arg4)) ? NULL : XEN_TO_C_XpmAttributes(arg4));
  return(XEN_LIST_3(C_TO_XEN_INT(val),
		    C_TO_XEN_Pixmap(p1),
		    C_TO_XEN_Pixmap(p2)));
}
#endif

static XEN gxm_XpmReadFileToPixmap(XEN arg1, XEN arg2, XEN arg3, XEN arg6)
{
  /* DIFF: XpmReadFileToPixmap omits and returns pixmap args
   */
  Pixmap p1, p2;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpmReadFileToPixmap", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XpmReadFileToPixmap", "Drawable");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg3), arg3, 3, "XpmReadFileToPixmap", "char*");
  XEN_ASSERT_TYPE(XEN_XpmAttributes_P(arg6) || XEN_FALSE_P(arg6), arg6, 6, "XpmReadFileToPixmap", "XpmAttributes*");
  val = XpmReadFileToPixmap(XEN_TO_C_Display(arg1), 
			    XEN_TO_C_Window(arg2), 
			    XEN_TO_C_STRING(arg3), 
			    &p1, &p2,
			    (XEN_FALSE_P(arg6)) ? NULL : XEN_TO_C_XpmAttributes(arg6));
  return(XEN_LIST_3(C_TO_XEN_INT(val),
		    C_TO_XEN_Pixmap(p1),
		    C_TO_XEN_Pixmap(p2)));
}

static XEN gxm_XpmReadFileToXpmImage(XEN arg1)
{
  int val;
  XpmImage *image;
  XEN_ASSERT_TYPE(XEN_STRING_P(arg1), arg1, 1, "XpmReadFileToXpmImage", "char*");
  image = (XpmImage *)CALLOC(1, sizeof(XpmImage));
  val = XpmReadFileToXpmImage(XEN_TO_C_STRING(arg1), image, NULL);
  if (val == XpmSuccess)
    return(WRAP_FOR_XEN_OBJ("XpmImage", image));
  FREE(image);
  return(C_TO_XEN_INT(val));
}

static XEN gxm_XpmCreatePixmapFromData(XEN arg1, XEN arg2, XEN larg3, XEN arg6)
{
  /* DIFF: XpmCreatePixmapFromData omits and returns pixmap args, arg3 (bits) is list of strings
   */
  Pixmap p1, p2;
  int val, i, len;
  char **bits;
  XEN arg3;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpmCreatePixmapFromData", "Display*");
  XEN_ASSERT_TYPE(XEN_Window_P(arg2), arg2, 2, "XpmCreatePixmapFromData", "Drawable");
  XEN_ASSERT_TYPE(XEN_LIST_P(larg3), larg3, 3, "XpmCreatePixmapFromData", "list of char*");
  XEN_ASSERT_TYPE(XEN_XpmAttributes_P(arg6) || XEN_FALSE_P(arg6), arg6, 6, "XpmCreatePixmapFromData", "XpmAttributes*");
  arg3 = XEN_COPY_ARG(larg3);
  len = XEN_LIST_LENGTH(arg3);
  if (len <= 0) XEN_ASSERT_TYPE(0, arg3, 3, "XpmCreatePixmapFromData", "positive integer");
  bits = (char **)CALLOC(len, sizeof(char *));
  for (i = 0; i < len; i++, arg3 = XEN_CDR(arg3))
    bits[i] = strdup(XEN_TO_C_STRING(XEN_CAR(arg3)));
  val = XpmCreatePixmapFromData(XEN_TO_C_Display(arg1), 
				XEN_TO_C_Window(arg2), 
				bits,
				&p1, &p2,
				(XEN_FALSE_P(arg6)) ? NULL : XEN_TO_C_XpmAttributes(arg6));
  for (i = 0; i < len; i++)
    if (bits[i]) free(bits[i]);
  FREE(bits);
  return(XEN_LIST_3(C_TO_XEN_INT(val),
		    C_TO_XEN_Pixmap(p1),
		    C_TO_XEN_Pixmap(p2)));
}

static XEN gxm_XpmWriteFileFromPixmap(XEN arg1, XEN arg2, XEN arg3, XEN arg4, XEN arg5)
{
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpmWriteFileFromPixmap", "Display*");
  XEN_ASSERT_TYPE(XEN_STRING_P(arg2), arg2, 2, "XpmWriteFileFromPixmap", "char*");
  XEN_ASSERT_TYPE(XEN_Pixmap_P(arg3), arg3, 3, "XpmWriteFileFromPixmap", "Pixmap");
  XEN_ASSERT_TYPE(XEN_Pixmap_P(arg4), arg4, 4, "XpmWriteFileFromPixmap", "Pixmap");
  XEN_ASSERT_TYPE(XEN_XpmAttributes_P(arg5) || XEN_FALSE_P(arg5), arg5, 5, "XpmWriteFileFromPixmap", "XpmAttributes*");
  return(C_TO_XEN_INT(XpmWriteFileFromPixmap(XEN_TO_C_Display(arg1), XEN_TO_C_STRING(arg2), 
					     XEN_TO_C_Pixmap(arg3), XEN_TO_C_Pixmap(arg4), 
					     (XEN_FALSE_P(arg5)) ? NULL : XEN_TO_C_XpmAttributes(arg5))));
}

static XEN gxm_XpmCreateDataFromPixmap(XEN arg1, XEN arg3, XEN arg4, XEN arg5)
{
  /* DIFF: XpmCreateDataFromPixmap arg2 omitted and rtn'd
   */
  char **buf = NULL;
  int val;
  XEN_ASSERT_TYPE(XEN_Display_P(arg1), arg1, 1, "XpmCreateDataFromPixmap", "Display*");
  XEN_ASSERT_TYPE(XEN_Pixmap_P(arg3), arg3, 3, "XpmCreateDataFromPixmap", "Pixmap");
  XEN_ASSERT_TYPE(XEN_Pixmap_P(arg4), arg4, 4, "XpmCreateDataFromPixmap", "Pixmap");
  XEN_ASSERT_TYPE(XEN_XpmAttributes_P(arg5) || XEN_FALSE_P(arg5), arg5, 5, "XpmCreateDataFromPixmap", "XpmAttributes*");
  val = XpmCreateDataFromPixmap(XEN_TO_C_Display(arg1), &buf, 
				XEN_TO_C_Pixmap(arg3), 
				XEN_TO_C_Pixmap(arg4), 
				(XEN_FALSE_P(arg5)) ? NULL : XEN_TO_C_XpmAttributes(arg5));
  return(XEN_LIST_2(C_TO_XEN_INT(val),
		    C_TO_XEN_ULONG(buf)));
}

#if HAVE_XPM_GET_ERROR_STRING
static XEN gxm_XpmGetErrorString(XEN err)
{
  #define H_XpmGetErrorString "(XpmGetErrorString err) -> string describing error"
  XEN_ASSERT_TYPE(XEN_INTEGER_P(err), err, XEN_ONLY_ARG, "XpmGetErrorString", "an Xpm status code");
  return(C_TO_XEN_STRING(XpmGetErrorString(XEN_TO_C_INT(err))));
}
#endif

static XEN gxm_XpmColorSymbol(XEN name, XEN value, XEN pixel)
{
  XpmColorSymbol *r;
  #define H_XpmColorSymbol "(XpmColorSymbol name val pix) -> new XpmColorSymbol struct"
  XEN_ASSERT_TYPE(XEN_STRING_P(name), name, 1, "XpmColorSymbol", "char*");
  XEN_ASSERT_TYPE(XEN_FALSE_P(value) || XEN_STRING_P(value), value, 2, "XpmColorSymbol", "char*");
  XEN_ASSERT_TYPE(XEN_Pixel_P(pixel), pixel, 3, "XpmColorSymbol", "Pixel");
  r = (XpmColorSymbol *)CALLOC(1, sizeof(XpmColorSymbol));
  r->name = XEN_TO_C_STRING(name);
  r->value = (XEN_FALSE_P(value)) ? NULL : XEN_TO_C_STRING(value);
  r->pixel = XEN_TO_C_Pixel(pixel);
  return(xen_return_first(WRAP_FOR_XEN_OBJ("XpmColorSymbol",r), name, value));
}

static XEN gxm_XpmImage(XEN width, XEN height, XEN cpp, XEN ncolors, XEN data)
{
  XpmImage *r;
  #define H_XpmImage "(XpmImage w h cpp n data) -> new XpmImage struct"
  XEN_ASSERT_TYPE(XEN_ULONG_P(width), width, 1, "XpmImage", "ulong");
  XEN_ASSERT_TYPE(XEN_ULONG_P(height), height, 2, "XpmImage", "ulong");
  XEN_ASSERT_TYPE(XEN_ULONG_P(cpp), cpp, 3, "XpmImage", "ulong");
  XEN_ASSERT_TYPE(XEN_ULONG_P(ncolors), ncolors, 4, "XpmImage", "ulong");
  XEN_ASSERT_TYPE(XEN_ULONG_P(data), data, 5, "XpmImage", "ulong");
  r = (XpmImage *)CALLOC(1, sizeof(XpmImage));
  r->width = XEN_TO_C_ULONG(width);
  r->height = XEN_TO_C_ULONG(height);
  r->cpp = XEN_TO_C_ULONG(cpp);
  r->ncolors = XEN_TO_C_ULONG(ncolors);
  r->data = (unsigned int *)XEN_TO_C_ULONG(data);
  return(WRAP_FOR_XEN_OBJ("XpmImage", r));
}

static XEN gxm_XpmAttributes(void)
{
  #define H_XpmAttributes "(XpmAttributes) -> new XpmAttributes struct"
  return(WRAP_FOR_XEN_OBJ("XpmAttributes", 
			  (XpmAttributes *)CALLOC(1, sizeof(XpmAttributes))));
}

static XEN gxm_cpp(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE((XEN_XpmImage_P(ptr)) || (XEN_XpmAttributes_P(ptr)), ptr, XEN_ONLY_ARG, "cpp", "XpmImage");
  if (XEN_XpmImage_P(ptr)) return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XpmImage(ptr))->cpp)));
  return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XpmAttributes(ptr))->cpp)));
}

static XEN gxm_set_cpp(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE((XEN_XpmImage_P(ptr)) || (XEN_XpmAttributes_P(ptr)), ptr, XEN_ARG_1, "cpp", "XpmImage");
  if (XEN_XpmImage_P(ptr)) (XEN_TO_C_XpmImage(ptr))->cpp = XEN_TO_C_ULONG(val);
  (XEN_TO_C_XpmAttributes(ptr))->cpp = XEN_TO_C_ULONG(val);
  return(val);
}

static XEN gxm_ncolors(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE((XEN_XpmImage_P(ptr)) || (XEN_XpmAttributes_P(ptr)), ptr, XEN_ONLY_ARG, "ncolors", "XpmImage");
  if (XEN_XpmImage_P(ptr)) return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XpmImage(ptr))->ncolors)));
  return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XpmAttributes(ptr))->ncolors)));
}

static XEN gxm_set_ncolors(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE((XEN_XpmImage_P(ptr)) || (XEN_XpmAttributes_P(ptr)), ptr, XEN_ARG_1, "ncolors", "XpmImage");
  if (XEN_XpmImage_P(ptr)) (XEN_TO_C_XpmImage(ptr))->ncolors = XEN_TO_C_ULONG(val);
  else (XEN_TO_C_XpmAttributes(ptr))->ncolors = XEN_TO_C_ULONG(val);
  return(val);
}

#if 0
static XEN gxm_set_data(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_XpmImage_P(ptr), ptr, XEN_ARG_1, "data", "XpmImage");
  (XEN_TO_C_XpmImage(ptr))->data = (unsigned int *)XEN_TO_C_ULONG(val);
  return(val);
}
#endif

static XEN gxm_valuemask(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XpmAttributes_P(ptr), ptr, XEN_ONLY_ARG, "valuemask", "XpmAttributes");
  return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XpmAttributes(ptr))->valuemask)));
}

static XEN gxm_set_valuemask(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_XpmAttributes_P(ptr), ptr, XEN_ARG_1, "valuemask", "XpmAttributes");
  (XEN_TO_C_XpmAttributes(ptr))->valuemask = XEN_TO_C_ULONG(val);
  return(val);
}

static XEN gxm_x_hotspot(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XpmAttributes_P(ptr), ptr, XEN_ONLY_ARG, "x_hotspot", "XpmAttributes");
  return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XpmAttributes(ptr))->x_hotspot)));
}

static XEN gxm_set_x_hotspot(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_XpmAttributes_P(ptr), ptr, XEN_ARG_1, "x_hotspot", "XpmAttributes");
  (XEN_TO_C_XpmAttributes(ptr))->x_hotspot = XEN_TO_C_ULONG(val);
  return(val);
}

static XEN gxm_y_hotspot(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XpmAttributes_P(ptr), ptr, XEN_ONLY_ARG, "y_hotspot", "XpmAttributes");
  return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XpmAttributes(ptr))->y_hotspot)));
}

static XEN gxm_set_y_hotspot(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_XpmAttributes_P(ptr), ptr, XEN_ARG_1, "y_hotspot", "XpmAttributes");
  (XEN_TO_C_XpmAttributes(ptr))->y_hotspot = XEN_TO_C_ULONG(val);
  return(val);
}

static XEN gxm_colorsymbols(XEN ptr)
{
  XpmAttributes *atr;
  int i, len;
  XEN lst = XEN_EMPTY_LIST;
  XM_FIELD_ASSERT_TYPE(XEN_XpmAttributes_P(ptr), ptr, XEN_ONLY_ARG, "colorsymbols", "XpmAttributes");
  atr = XEN_TO_C_XpmAttributes(ptr);
  len = atr->numsymbols;
  if (len > 0)
    {
      XpmColorSymbol *cols;
      cols = atr->colorsymbols;
      for (i = len - 1; i >= 0; i--)
	lst = XEN_CONS(WRAP_FOR_XEN("XpmColorSymbol", &(cols[i])), lst);
    }
  return(lst);
}

static XEN gxm_set_colorsymbols(XEN ptr, XEN vals)
{
  XpmAttributes *atr;
  int i, len;
  XEN lst;
  XM_SET_FIELD_ASSERT_TYPE(XEN_XpmAttributes_P(ptr), ptr, XEN_ARG_1, "colorsymbols", "XpmAttributes");
  XM_SET_FIELD_ASSERT_TYPE(XEN_LIST_P(vals), vals, XEN_ARG_2, "colorsymbols", "list of XpmColorSymbols");
  atr = XEN_TO_C_XpmAttributes(ptr);
  len = XEN_LIST_LENGTH(vals);
  if (len > 0)
    {
      XpmColorSymbol *cols = NULL, *cur;
      cols = (XpmColorSymbol *)CALLOC(len, sizeof(XpmColorSymbol));
      for (lst = XEN_COPY_ARG(vals), i = 0; i < len; i++, lst = XEN_CDR(lst))
	{
	  cur = XEN_TO_C_XpmColorSymbol(XEN_CAR(lst));
	  if (cur->name) cols[i].name = strdup(cur->name);
	  if (cur->value) cols[i].value = strdup(cur->value);
	  cols[i].pixel = cur->pixel;
	}
      atr->colorsymbols = cols;
    }
  return(vals);
}

static XEN gxm_numsymbols(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XpmAttributes_P(ptr), ptr, XEN_ONLY_ARG, "numsymbols", "XpmAttributes");
  return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XpmAttributes(ptr))->numsymbols)));
}

static XEN gxm_set_numsymbols(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_XpmAttributes_P(ptr), ptr, XEN_ARG_1, "numsymbols", "XpmAttributes");
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "numsymbols", "integer");
  (XEN_TO_C_XpmAttributes(ptr))->numsymbols = XEN_TO_C_INT(val);
  return(val);
}

/* pixels is the list -- not sure what good npixels is without pixels */
static XEN gxm_npixels(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XpmAttributes_P(ptr), ptr, XEN_ONLY_ARG, "npixels", "XpmAttributes");
  return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XpmAttributes(ptr))->npixels)));
}

static XEN gxm_set_npixels(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_XpmAttributes_P(ptr), ptr, XEN_ARG_1, "npixels", "XpmAttributes");
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "npixels", "integer");
  (XEN_TO_C_XpmAttributes(ptr))->npixels = XEN_TO_C_INT(val);
  return(val);
}

#endif
/* HAVE_XPM */

#if MUS_WITH_EDITRES
static XEN gxm_XEditResCheckMessages(XEN widget, XEN data, XEN event, XEN cont)
{
  Boolean flag;
  XEN_ASSERT_TYPE(XEN_Widget_P(widget), widget, XEN_ARG_1, "widget", "_XEditResCheckMessages");
  XEN_ASSERT_TYPE(XEN_XEvent_P(event), event, XEN_ARG_3, "XEvent", "_XEditResCheckMessages");
  XEN_ASSERT_TYPE(XEN_BOOLEAN_P(cont), cont, XEN_ARG_4, "boolean", "_XEditResCheckMessages");
  flag = XEN_TO_C_BOOLEAN(cont);
  _XEditResCheckMessages(XEN_TO_C_Widget(widget),
			 (XtPointer)data,
			 XEN_TO_C_XEvent(event),
			 &flag);
  return(XEN_FALSE);
}
#endif



/* -------------------------------- struct handlers -------------------------------- */

/* XRectangle */

static XEN gxm_XRectangle(XEN x, XEN y, XEN width, XEN height)
{
  #define H_XRectangle "(XRectangle x y width height) returns the given XRectangle"
  XRectangle *r;
  XEN_ASSERT_TYPE(XEN_INTEGER_P(x), x, 1, "XRectangle", "short");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(y), y, 2, "XRectangle", "short");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(width), width, 3, "XRectangle", "INT");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(height), height, 4, "XRectangle", "INT");
  r = (XRectangle *)CALLOC(1, sizeof(XRectangle));
  r->x = (short)XEN_TO_C_INT(x);
  r->y = (short)XEN_TO_C_INT(y);
  r->width = XEN_TO_C_INT(width);
  r->height = XEN_TO_C_INT(height);
  return(C_TO_XEN_XRectangle(r));
}

/* XSegment */

static XEN gxm_XSegment(XEN x1, XEN y1, XEN x2, XEN y2)
{
  XSegment *r;
#define H_XSegment "(XSegment x1 y1 x2 y2) -> new XSegment struct"
  XEN_ASSERT_TYPE(XEN_INTEGER_P(x1), x1, 1, "XSegment", "short");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(y1), y1, 2, "XSegment", "short");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(x2), x2, 3, "XSegment", "short");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(y2), y2, 4, "XSegment", "short");
  r = (XSegment *)CALLOC(1, sizeof(XSegment));
  r->x1 = (short)XEN_TO_C_INT(x1);
  r->y1 = (short)XEN_TO_C_INT(y1);
  r->x2 = (short)XEN_TO_C_INT(x2);
  r->y2 = (short)XEN_TO_C_INT(y2);
  return(C_TO_XEN_XSegment(r));
}

static XEN gxm_y2(XEN ptr)
{
  if (XEN_XSegment_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XSegment(ptr))->y2)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "y2", "XSegment");
  return(XEN_FALSE);
}

static XEN gxm_set_y2(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_1, "y2", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XSegment_P(ptr), ptr, XEN_ARG_2, "y2", "XSegment");
  (XEN_TO_C_XSegment(ptr))->y2 = (short)XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_x2(XEN ptr)
{
  if (XEN_XSegment_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XSegment(ptr))->x2)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "x2", "XSegment");
  return(XEN_FALSE);
}

static XEN gxm_set_x2(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_1, "x2", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XSegment_P(ptr), ptr, XEN_ARG_2, "x2", "XSegment");
  (XEN_TO_C_XSegment(ptr))->x2 = (short)XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_y1(XEN ptr)
{
  if (XEN_XSegment_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XSegment(ptr))->y1)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "y1", "XSegment");
  return(XEN_FALSE);
}

static XEN gxm_set_y1(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_1, "y1", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XSegment_P(ptr), ptr, XEN_ARG_2, "y1", "XSegment");
  (XEN_TO_C_XSegment(ptr))->y1 = (short)XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_x1(XEN ptr)
{
  if (XEN_XSegment_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XSegment(ptr))->x1)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "x1", "XSegment");
  return(XEN_FALSE);
}

static XEN gxm_set_x1(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_1, "x1", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XSegment_P(ptr), ptr, XEN_ARG_2, "x1", "XSegment");
  (XEN_TO_C_XSegment(ptr))->x1 = (short)XEN_TO_C_INT(val);
  return(val);
}

/* XPoint */

static XEN gxm_XPoint(XEN x, XEN y)
{
  XPoint *r;
  #define H_XPoint "(XPoint x y) -> new XPoint struct"
  XEN_ASSERT_TYPE(XEN_INTEGER_P(x), x, 1, "XPoint", "short");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(y), y, 2, "XPoint", "short");
  r = (XPoint *)CALLOC(1, sizeof(XPoint));
  r->x = (short)XEN_TO_C_INT(x);
  r->y = (short)XEN_TO_C_INT(y);
  return(C_TO_XEN_XPoint(r));
}

/* XArc */

static XEN gxm_XArc(XEN x, XEN y, XEN width, XEN height, XEN angle1, XEN angle2)
{
  XArc *r;
  #define H_XArc "(XArc x y w h ang1 ang2) -> new XArc struct"
  XEN_ASSERT_TYPE(XEN_INTEGER_P(x), x, 1, "XArc", "short");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(y), y, 2, "XArc", "short");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(width), width, 3, "XArc", "INT");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(height), height, 4, "XArc", "INT");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(angle1), angle1, 5, "XArc", "short");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(angle2), angle2, 6, "XArc", "short");
  r = (XArc *)CALLOC(1, sizeof(XArc));
  r->x = (short)XEN_TO_C_INT(x);
  r->y = (short)XEN_TO_C_INT(y);
  r->width = XEN_TO_C_INT(width);
  r->height = XEN_TO_C_INT(height);
  r->angle1 = (short)XEN_TO_C_INT(angle1);
  r->angle2 = (short)XEN_TO_C_INT(angle2);
  return(C_TO_XEN_XArc(r));
}

static XEN gxm_angle2(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XArc_P(ptr), ptr, XEN_ONLY_ARG, "angle2", "XArc");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XArc(ptr))->angle2)));
}

static XEN gxm_set_angle2(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_1, "angle2", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XArc_P(ptr), ptr, XEN_ARG_2, "angle2", "XArc");
  (XEN_TO_C_XArc(ptr))->angle2 = (short)XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_angle1(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XArc_P(ptr), ptr, XEN_ONLY_ARG, "angle1", "XArc");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XArc(ptr))->angle1)));
}

static XEN gxm_set_angle1(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_1, "angle1", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XArc_P(ptr), ptr, XEN_ARG_2, "angle1", "XArc");
  (XEN_TO_C_XArc(ptr))->angle1 = (short)XEN_TO_C_INT(val);
  return(val);
}

/* XColor */

static XEN gxm_XColor(XEN pixel, XEN red, XEN green, XEN blue, XEN flags, XEN pad)
{
  XColor *r;
  #define H_XColor "(XColor pixel red green blue flags pad) -> new XColor struct"
  XEN_ASSERT_TYPE(XEN_ULONG_P(pixel) || XEN_NOT_BOUND_P(pixel), pixel, 1, "XColor", "ulong");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(red), red, 2, "XColor", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(green), green, 3, "XColor", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(blue), blue, 4, "XColor", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(flags), flags, 5, "XColor", "char");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(pad), pad, 6, "XColor", "char");
  r = (XColor *)CALLOC(1, sizeof(XColor));
  if (XEN_BOUND_P(pixel)) r->pixel = XEN_TO_C_ULONG(pixel);
  if (XEN_BOUND_P(red)) r->red = XEN_TO_C_INT(red);
  if (XEN_BOUND_P(green)) r->green = XEN_TO_C_INT(green);
  if (XEN_BOUND_P(blue)) r->blue = XEN_TO_C_INT(blue);
  if (XEN_BOUND_P(flags)) r->flags = (char)XEN_TO_C_INT(flags);
  if (XEN_BOUND_P(pad)) r->pad = (char)XEN_TO_C_INT(pad);
  return(C_TO_XEN_XColor(r));
}

static XEN gxm_pad(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XColor_P(ptr), ptr, XEN_ONLY_ARG, "pad", "XColor");
  return(C_TO_XEN_char((char)((XEN_TO_C_XColor(ptr))->pad)));
}

static XEN gxm_set_pad(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_XColor_P(ptr), ptr, XEN_ARG_1, "pad", "XColor");
  XM_SET_FIELD_ASSERT_TYPE(XEN_char_P(val), val, XEN_ARG_2, "pad", "char");
  (XEN_TO_C_XColor(ptr))->pad = XEN_TO_C_char(val);
  return(val);
}

static XEN gxm_blue(XEN ptr)
{
  if (XEN_XColor_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XColor(ptr))->blue)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "blue", "XColor");
  return(XEN_FALSE);
}

static XEN gxm_set_blue(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "blue", "an integer");
  if (XEN_XColor_P(ptr)) (XEN_TO_C_XColor(ptr))->blue = XEN_TO_C_INT(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "blue", "XColor");
  return(val);
}

static XEN gxm_green(XEN ptr)
{
  if (XEN_XColor_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XColor(ptr))->green)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "green", "XColor");
  return(XEN_FALSE);
}

static XEN gxm_set_green(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "green", "an integer");
  if (XEN_XColor_P(ptr)) (XEN_TO_C_XColor(ptr))->green = XEN_TO_C_INT(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "green", "XColor");
  return(val);
}

static XEN gxm_red(XEN ptr)
{
  if (XEN_XColor_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XColor(ptr))->red)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "red", "XColor");
  return(XEN_FALSE);
}

static XEN gxm_set_red(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "red", "an integer");
  if (XEN_XColor_P(ptr)) (XEN_TO_C_XColor(ptr))->red = XEN_TO_C_INT(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "red", "XColor");
  return(val);
}

static XEN gxm_XWindowChanges(XEN x, XEN y, XEN width, XEN height, XEN border_width, XEN sibling, XEN stack_mode)
{
  XWindowChanges *r;
  #define H_XWindowChanges "(XWindowChanges x y w h border sib stack_mode) -> new XWindowChanges struct"
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(x), x, 1, "XWindowChanges", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(y), y, 2, "XWindowChanges", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(width), width, 3, "XWindowChanges", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(height), height, 4, "XWindowChanges", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(border_width), border_width, 5, "XWindowChanges", "int");
  XEN_ASSERT_TYPE(XEN_Window_P(sibling) || XEN_NOT_BOUND_P(sibling), sibling, 6, "XWindowChanges", "Window");
  XEN_ASSERT_TYPE(XEN_INTEGER_IF_BOUND_P(stack_mode), stack_mode, 7, "XWindowChanges", "int");
  r = (XWindowChanges *)CALLOC(1, sizeof(XWindowChanges));
  if (XEN_BOUND_P(x)) r->x = XEN_TO_C_INT(x);
  if (XEN_BOUND_P(y)) r->y = XEN_TO_C_INT(y);
  if (XEN_BOUND_P(width)) r->width = XEN_TO_C_INT(width);
  if (XEN_BOUND_P(height)) r->height = XEN_TO_C_INT(height);
  if (XEN_BOUND_P(border_width)) r->border_width = XEN_TO_C_INT(border_width);
  if (XEN_BOUND_P(sibling)) r->sibling = XEN_TO_C_Window(sibling);
  if (XEN_BOUND_P(stack_mode)) r->stack_mode = XEN_TO_C_INT(stack_mode);
  return(C_TO_XEN_XWindowChanges(r));
}

static XEN gxm_XSetWindowAttributes(XEN arglist)
{
  int len;
  XSetWindowAttributes *r;
  #define H_XSetWindowAttributes "(XSetWindowAttributes args) -> new XSetWindowAttributes struct (14 or more args!)"
  r = (XSetWindowAttributes *)CALLOC(1, sizeof(XSetWindowAttributes));
  len = XEN_LIST_LENGTH(arglist);
  if ((len > 0) && (XEN_Pixmap_P(XEN_LIST_REF(arglist, 0)))) r->background_pixmap = XEN_TO_C_Pixmap(XEN_LIST_REF(arglist, 0));
  if ((len > 1) && (XEN_Pixel_P(XEN_LIST_REF(arglist, 1)))) r->background_pixel = XEN_TO_C_Pixel(XEN_LIST_REF(arglist, 1));
  if ((len > 2) && (XEN_Pixmap_P(XEN_LIST_REF(arglist, 2)))) r->border_pixmap = XEN_TO_C_Pixmap(XEN_LIST_REF(arglist, 2));
  if ((len > 3) && (XEN_Pixel_P(XEN_LIST_REF(arglist, 3)))) r->border_pixel = XEN_TO_C_Pixel(XEN_LIST_REF(arglist, 3));
  if ((len > 4) && (XEN_INTEGER_P(XEN_LIST_REF(arglist, 4)))) r->bit_gravity = XEN_TO_C_INT(XEN_LIST_REF(arglist, 4));
  if ((len > 5) && (XEN_INTEGER_P(XEN_LIST_REF(arglist, 5)))) r->win_gravity = XEN_TO_C_INT(XEN_LIST_REF(arglist, 5));
  if ((len > 6) && (XEN_INTEGER_P(XEN_LIST_REF(arglist, 6)))) r->backing_store = XEN_TO_C_INT(XEN_LIST_REF(arglist, 6));
  if ((len > 7) && (XEN_ULONG_P(XEN_LIST_REF(arglist, 7)))) r->backing_planes = XEN_TO_C_ULONG(XEN_LIST_REF(arglist, 7));
  if ((len > 8) && (XEN_Pixel_P(XEN_LIST_REF(arglist, 8)))) r->backing_pixel = XEN_TO_C_Pixel(XEN_LIST_REF(arglist, 8));
  if ((len > 9) && (XEN_BOOLEAN_P(XEN_LIST_REF(arglist, 9)))) r->save_under = XEN_TO_C_BOOLEAN(XEN_LIST_REF(arglist, 9));
  if ((len > 10) && (XEN_INTEGER_P(XEN_LIST_REF(arglist, 10)))) r->event_mask = XEN_TO_C_INT(XEN_LIST_REF(arglist, 10));
  if ((len > 11) && (XEN_INTEGER_P(XEN_LIST_REF(arglist, 11)))) r->do_not_propagate_mask = XEN_TO_C_INT(XEN_LIST_REF(arglist, 11));
  if ((len > 12) && (XEN_BOOLEAN_P(XEN_LIST_REF(arglist, 12)))) r->override_redirect = XEN_TO_C_BOOLEAN(XEN_LIST_REF(arglist, 12));
  if ((len > 13) && (XEN_Colormap_P(XEN_LIST_REF(arglist, 13)))) r->colormap = XEN_TO_C_Colormap(XEN_LIST_REF(arglist, 13));
  if ((len > 14) && (XEN_Cursor_P(XEN_LIST_REF(arglist, 14)))) r->cursor = XEN_TO_C_Cursor(XEN_LIST_REF(arglist, 14));
  return(C_TO_XEN_XSetWindowAttributes(r));
}

static XEN gxm_stack_mode(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XWindowChanges_P(ptr), ptr, XEN_ONLY_ARG, "stack_mode", "XWindowChanges");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XWindowChanges(ptr))->stack_mode)));
}

static XEN gxm_sibling(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XWindowChanges_P(ptr), ptr, XEN_ONLY_ARG, "sibling", "XWindowChanges");
  return(C_TO_XEN_Window((Window)((XEN_TO_C_XWindowChanges(ptr))->sibling)));
}

static XEN gxm_obdata(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XImage_P(ptr), ptr, XEN_ONLY_ARG, "obdata", "XImage");
  return(C_TO_XEN_ULONG((XPointer)((XEN_TO_C_XImage(ptr))->obdata)));
}

static XEN gxm_bytes_per_line(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XImage_P(ptr), ptr, XEN_ONLY_ARG, "bytes_per_line", "XImage");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XImage(ptr))->bytes_per_line)));
}

static XEN gxm_bitmap_pad(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XImage_P(ptr), ptr, XEN_ONLY_ARG, "bitmap_pad", "XImage");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XImage(ptr))->bitmap_pad)));
}

static XEN gxm_bitmap_bit_order(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XImage_P(ptr), ptr, XEN_ONLY_ARG, "bitmap_bit_order", "XImage");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XImage(ptr))->bitmap_bit_order)));
}

static XEN gxm_bitmap_unit(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XImage_P(ptr), ptr, XEN_ONLY_ARG, "bitmap_unit", "XImage");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XImage(ptr))->bitmap_unit)));
}

static XEN gxm_byte_order(XEN ptr)
{
  if (XEN_XImage_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XImage(ptr))->byte_order)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "byte_order", "XImage");
  return(XEN_FALSE);
}

static XEN gxm_xoffset(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XImage_P(ptr), ptr, XEN_ONLY_ARG, "xoffset", "XImage");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XImage(ptr))->xoffset)));
}

static XEN gxm_screen(XEN ptr)
{
  if (XEN_XWindowAttributes_P(ptr)) return(C_TO_XEN_Screen((Screen *)((XEN_TO_C_XWindowAttributes(ptr))->screen)));
#if HAVE_MOTIF
  if (XEN_XmTopLevelEnterCallbackStruct_P(ptr)) return(C_TO_XEN_Screen((Screen *)((XEN_TO_C_XmTopLevelEnterCallbackStruct(ptr))->screen)));
  if (XEN_XmTopLevelLeaveCallbackStruct_P(ptr)) return(C_TO_XEN_Screen((Screen *)((XEN_TO_C_XmTopLevelLeaveCallbackStruct(ptr))->screen)));
#endif
  if (XEN_XVisualInfo_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XVisualInfo(ptr))->screen)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "screen", "a struct with a screen field");
  return(XEN_FALSE);
}

static XEN gxm_your_event_mask(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XWindowAttributes_P(ptr), ptr, XEN_ONLY_ARG, "your_event_mask", "XWindowAttributes");
  return(C_TO_XEN_INT((long)((XEN_TO_C_XWindowAttributes(ptr))->your_event_mask)));
}

static XEN gxm_all_event_masks(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XWindowAttributes_P(ptr), ptr, XEN_ONLY_ARG, "all_event_masks", "XWindowAttributes");
  return(C_TO_XEN_INT((long)((XEN_TO_C_XWindowAttributes(ptr))->all_event_masks)));
}

static XEN gxm_map_state(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XWindowAttributes_P(ptr), ptr, XEN_ONLY_ARG, "map_state", "XWindowAttributes");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XWindowAttributes(ptr))->map_state)));
}

static XEN gxm_map_installed(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XWindowAttributes_P(ptr), ptr, XEN_ONLY_ARG, "map_installed", "XWindowAttributes");
  return(C_TO_XEN_BOOLEAN((Bool)((XEN_TO_C_XWindowAttributes(ptr))->map_installed)));
}

static XEN gxm_set_visual(XEN ptr, XEN val)
{
#if HAVE_XPM
  XM_SET_FIELD_ASSERT_TYPE(XEN_Visual_P(val), val, XEN_ARG_2, "visual", "Visual");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XpmAttributes_P(ptr), ptr, XEN_ARG_1, "visual", "Visual");
  (XEN_TO_C_XpmAttributes(ptr))->visual = (Visual *)XEN_TO_C_Visual(val);
#endif
  return(val);
}

static XEN gxm_visual(XEN ptr)
{
  if (XEN_XWindowAttributes_P(ptr)) return(C_TO_XEN_Visual((Visual *)((XEN_TO_C_XWindowAttributes(ptr))->visual)));
#if HAVE_XPM
  if (XEN_XpmAttributes_P(ptr)) return(C_TO_XEN_Visual((Visual *)((XEN_TO_C_XpmAttributes(ptr))->visual)));
#endif
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "visual", "a struct with a visual field");
  return(XEN_FALSE);
}

static XEN gxm_cursor(XEN ptr)
{
  if (XEN_XSetWindowAttributes_P(ptr)) return(C_TO_XEN_Cursor((Cursor)((XEN_TO_C_XSetWindowAttributes(ptr))->cursor)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "cursor", "XSetWindowAttributes");
  return(XEN_FALSE);
}

static XEN gxm_set_cursor(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_XSetWindowAttributes_P(ptr), ptr, XEN_ARG_1, "cursor", "XSetWindowAttributes");
  XM_SET_FIELD_ASSERT_TYPE(XEN_Cursor_P(val), val, XEN_ARG_2, "cursor", "a Cursor");
  (XEN_TO_C_XSetWindowAttributes(ptr))->cursor = XEN_TO_C_Cursor(val);
  return(val);
}

static XEN gxm_do_not_propagate_mask(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XWindowAttributes_P(ptr) || XEN_XSetWindowAttributes_P(ptr), 
		       ptr, XEN_ONLY_ARG, "do_not_propagate_mask", "a struct with a do_not_propagate_mask field");
  if (XEN_XWindowAttributes_P(ptr)) return(C_TO_XEN_INT((long)((XEN_TO_C_XWindowAttributes(ptr))->do_not_propagate_mask)));
  return(C_TO_XEN_INT((long)((XEN_TO_C_XSetWindowAttributes(ptr))->do_not_propagate_mask)));
}

static XEN gxm_event_mask(XEN ptr)
{
  if (XEN_XSetWindowAttributes_P(ptr)) return(C_TO_XEN_INT((long)((XEN_TO_C_XSetWindowAttributes(ptr))->event_mask)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "event_mask", "XSetWindowAttributes");
  return(XEN_FALSE);
}

static XEN gxm_set_event_mask(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_XSetWindowAttributes_P(ptr), ptr, XEN_ARG_1, "event_mask", "XSetWindowAttributes");
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "event_mask", "an integer");
  (XEN_TO_C_XSetWindowAttributes(ptr))->event_mask = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_save_under(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XWindowAttributes_P(ptr) || XEN_XSetWindowAttributes_P(ptr), ptr, XEN_ONLY_ARG, "save_under", "a struct with a save_under field");
  if (XEN_XWindowAttributes_P(ptr)) return(C_TO_XEN_BOOLEAN((Bool)((XEN_TO_C_XWindowAttributes(ptr))->save_under)));
  return(C_TO_XEN_BOOLEAN((Bool)((XEN_TO_C_XSetWindowAttributes(ptr))->save_under)));
}

static XEN gxm_set_save_under(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_XWindowAttributes_P(ptr) || XEN_XSetWindowAttributes_P(ptr), ptr, XEN_ARG_1, "save_under", "a struct with a save_under field");
  XM_SET_FIELD_ASSERT_TYPE(XEN_BOOLEAN_P(val), val, XEN_ARG_2, "save_under", "a Boolean");
  if (XEN_XWindowAttributes_P(ptr))
      (XEN_TO_C_XWindowAttributes(ptr))->save_under = XEN_TO_C_BOOLEAN(val);
  else
      (XEN_TO_C_XSetWindowAttributes(ptr))->save_under = XEN_TO_C_BOOLEAN(val);
  return(val);
}

static XEN gxm_backing_pixel(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XWindowAttributes_P(ptr) || XEN_XSetWindowAttributes_P(ptr), ptr, XEN_ONLY_ARG, "backing_pixel", "a struct with a backing_pixel field");
  if (XEN_XWindowAttributes_P(ptr)) return(C_TO_XEN_Pixel((unsigned long)((XEN_TO_C_XWindowAttributes(ptr))->backing_pixel)));
  return(C_TO_XEN_Pixel((unsigned long)((XEN_TO_C_XSetWindowAttributes(ptr))->backing_pixel)));
}

static XEN gxm_backing_planes(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XWindowAttributes_P(ptr) || XEN_XSetWindowAttributes_P(ptr), ptr, XEN_ONLY_ARG, "backing_planes", "a struct with a backing_planes field");
  if (XEN_XWindowAttributes_P(ptr)) return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XWindowAttributes(ptr))->backing_planes)));
  return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XSetWindowAttributes(ptr))->backing_planes)));
}

static XEN gxm_win_gravity(XEN ptr)
{
  if (XEN_XWindowAttributes_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XWindowAttributes(ptr))->win_gravity)));
  if (XEN_XWindowAttributes_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XSetWindowAttributes(ptr))->win_gravity)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "win_gravity", "a struct with a win_gravity field");
  return(XEN_FALSE);
}

static XEN gxm_bit_gravity(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XWindowAttributes_P(ptr) || XEN_XSetWindowAttributes_P(ptr), ptr, XEN_ONLY_ARG, "bit_gravity", "a struct with a bit_gravity field");
  if (XEN_XWindowAttributes_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XWindowAttributes(ptr))->bit_gravity)));
  return(C_TO_XEN_INT((int)((XEN_TO_C_XSetWindowAttributes(ptr))->bit_gravity)));
}

static XEN gxm_set_bit_gravity(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_XWindowAttributes_P(ptr) || XEN_XSetWindowAttributes_P(ptr), ptr, XEN_ARG_1, "bit_gravity", "a struct with a bit_gravity field");
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "bit_gravity", "an integer");
  if (XEN_XWindowAttributes_P(ptr))
      (XEN_TO_C_XWindowAttributes(ptr))->bit_gravity = XEN_TO_C_INT(val);
  else
      (XEN_TO_C_XSetWindowAttributes(ptr))->bit_gravity = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_border_pixel(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XSetWindowAttributes_P(ptr), ptr, XEN_ONLY_ARG, "border_pixel", "XSetWindowAttributes");
  return(C_TO_XEN_Pixel((unsigned long)((XEN_TO_C_XSetWindowAttributes(ptr))->border_pixel)));
}

static XEN gxm_set_border_pixel(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_XSetWindowAttributes_P(ptr), ptr, XEN_ARG_1, "border_pixel", "XSetWindowAttributes");
  XM_SET_FIELD_ASSERT_TYPE(XEN_Pixel_P(val), val, XEN_ARG_2, "border_pixel", "a Pixel");
  (XEN_TO_C_XSetWindowAttributes(ptr))->border_pixel = XEN_TO_C_Pixel(val);
  return(val);
}

static XEN gxm_border_pixmap(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XSetWindowAttributes_P(ptr), ptr, XEN_ONLY_ARG, "border_pixmap", "XSetWindowAttributes");
  return(C_TO_XEN_Pixmap((Pixmap)((XEN_TO_C_XSetWindowAttributes(ptr))->border_pixmap)));
}

static XEN gxm_background_pixel(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XSetWindowAttributes_P(ptr), ptr, XEN_ONLY_ARG, "background_pixel", "XSetWindowAttributes");
  return(C_TO_XEN_Pixel((unsigned long)((XEN_TO_C_XSetWindowAttributes(ptr))->background_pixel)));
}

static XEN gxm_set_background_pixel(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_XSetWindowAttributes_P(ptr), ptr, XEN_ARG_1, "background_pixel", "XSetWindowAttributes");
  XM_SET_FIELD_ASSERT_TYPE(XEN_Pixel_P(val), val, XEN_ARG_2, "background_pixel", "a Pixel");
  (XEN_TO_C_XSetWindowAttributes(ptr))->background_pixel = XEN_TO_C_Pixel(val);
  return(val);
}

static XEN gxm_background_pixmap(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XSetWindowAttributes_P(ptr), ptr, XEN_ONLY_ARG, "background_pixmap", "XSetWindowAttributes");
  return(C_TO_XEN_Pixmap((Pixmap)((XEN_TO_C_XSetWindowAttributes(ptr))->background_pixmap)));
}

static XEN gxm_bits_per_pixel(XEN ptr)
{
  if (XEN_XImage_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XImage(ptr))->bits_per_pixel)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "bits_per_pixel", "XImage");
  return(XEN_FALSE);
}

static XEN gxm_visuals(XEN ptr)
{
  Depth *dps;
  Visual *vs;
  int i, len;
  XEN lst = XEN_EMPTY_LIST;
  XM_FIELD_ASSERT_TYPE(XEN_Depth_P(ptr), ptr, XEN_ONLY_ARG, "visuals", "Depth");
  dps = XEN_TO_C_Depth(ptr);
  len = dps->nvisuals;
  if (len > 0)
    {
      vs = dps->visuals;
      for (i = len - 1; i >= 0; i--)
	lst = XEN_CONS(WRAP_FOR_XEN("Visual", &(vs[i])), lst);
    }
  return(lst);
}

static XEN gxm_nvisuals(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_Depth_P(ptr), ptr, XEN_ONLY_ARG, "nvisuals", "Depth");
  return(C_TO_XEN_INT((int)((XEN_TO_C_Depth(ptr))->nvisuals)));
}

static XEN gxm_set_depth(XEN ptr, XEN val)
{
#if HAVE_XPM
  XM_SET_FIELD_ASSERT_TYPE(XEN_XpmAttributes_P(ptr), ptr, XEN_ARG_1, "depth", "XpmAttributes");
  (XEN_TO_C_XpmAttributes(ptr))->depth = XEN_TO_C_ULONG(val);
#endif
  return(val);
}

static XEN gxm_depth(XEN ptr)
{
  if (XEN_XImage_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XImage(ptr))->depth)));
  if (XEN_XWindowAttributes_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XWindowAttributes(ptr))->depth)));
  if (XEN_Depth_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_Depth(ptr))->depth)));
  if (XEN_XVisualInfo_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XVisualInfo(ptr))->depth)));
#if HAVE_XPM
  if (XEN_XpmAttributes_P(ptr)) return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XpmAttributes(ptr))->depth)));
#endif
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "depth", "a struct with a depth field");
  return(XEN_FALSE);
}

static XEN gxm_map_entries(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_Visual_P(ptr), ptr, XEN_ONLY_ARG, "map_entries", "Visual");
  return(C_TO_XEN_INT((int)((XEN_TO_C_Visual(ptr))->map_entries)));
}

static XEN gxm_bits_per_rgb(XEN ptr)
{
  if (XEN_XVisualInfo_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XVisualInfo(ptr))->bits_per_rgb)));
  if (XEN_Visual_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_Visual(ptr))->bits_per_rgb)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "bits_per_rgb", "Visual or XVisualInfo");
  return(XEN_FALSE);
}

static XEN gxm_blue_mask(XEN ptr)
{
  if (XEN_XImage_P(ptr)) return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XImage(ptr))->blue_mask)));
  if (XEN_XVisualInfo_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XVisualInfo(ptr))->blue_mask)));
  if (XEN_Visual_P(ptr)) return(C_TO_XEN_INT((long)((XEN_TO_C_Visual(ptr))->blue_mask)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "blue_mask", "a struct with a blue_mask field");
  return(XEN_FALSE);
}

static XEN gxm_green_mask(XEN ptr)
{
  if (XEN_XImage_P(ptr)) return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XImage(ptr))->green_mask)));
  if (XEN_XVisualInfo_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XVisualInfo(ptr))->green_mask)));
  if (XEN_Visual_P(ptr)) return(C_TO_XEN_INT((long)((XEN_TO_C_Visual(ptr))->green_mask)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "green_mask", "a struct with a green_mask field");
  return(XEN_FALSE);
}

static XEN gxm_red_mask(XEN ptr)
{
  if (XEN_XImage_P(ptr)) return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XImage(ptr))->red_mask)));
  if (XEN_XVisualInfo_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XVisualInfo(ptr))->red_mask)));
  if (XEN_Visual_P(ptr)) return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_Visual(ptr))->red_mask)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "red_mask", "a struct with a red_mask field");
  return(XEN_FALSE);
}

static XEN gxm_colormap_size(XEN ptr)
{
  if (XEN_XVisualInfo_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XVisualInfo(ptr))->colormap_size)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "colormap_size", "XVisualInfo*");
  return(XEN_FALSE);
}

static XEN gxm_class(XEN ptr)
{
#ifndef __cplusplus
  if (XEN_XWindowAttributes_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XWindowAttributes(ptr))->class)));
  if (XEN_Visual_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_Visual(ptr))->class)));
  if (XEN_XVisualInfo_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XVisualInfo(ptr))->class)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "class", "a struct with a class field");
#endif
  return(XEN_FALSE);
}

static XEN gxm_visualid(XEN ptr)
{
  if (XEN_Visual_P(ptr)) return(C_TO_XEN_ULONG((VisualID)((XEN_TO_C_Visual(ptr))->visualid)));
  if (XEN_XStandardColormap_P(ptr)) return(C_TO_XEN_ULONG((VisualID)((XEN_TO_C_XStandardColormap(ptr))->visualid)));
  if (XEN_XVisualInfo_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XVisualInfo(ptr))->visualid)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "visualid", "a struct with a visualid field");
  return(XEN_FALSE);
}

static XEN gxm_set_pixel(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_Pixel_P(val), val, XEN_ARG_2, "pixel", "a Pixel");  
  if (XEN_XColor_P(ptr)) (XEN_TO_C_XColor(ptr))->pixel = XEN_TO_C_Pixel(val);
#if HAVE_XPM
  else if (XEN_XpmColorSymbol_P(ptr)) (XEN_TO_C_XpmColorSymbol(ptr))->pixel = XEN_TO_C_Pixel(val);
#endif
  return(val);
}

static XEN gxm_pixel(XEN ptr)
{
  if (XEN_XColor_P(ptr)) return(C_TO_XEN_Pixel((Pixel)((XEN_TO_C_XColor(ptr))->pixel)));
#if HAVE_MOTIF
  if (XEN_XmScrollBarCallbackStruct_P(ptr)) return(C_TO_XEN_Pixel((Pixel)((XEN_TO_C_XmScrollBarCallbackStruct(ptr))->pixel)));
#endif
#if HAVE_XPM
  if (XEN_XpmColorSymbol_P(ptr)) return(C_TO_XEN_Pixel((Pixel)((XEN_TO_C_XpmColorSymbol(ptr))->pixel)));
#endif
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "pixel", "a struct with a pixel field");
  return(XEN_FALSE);
}

static XEN gxm_window_group(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XWMHints_P(ptr), ptr, XEN_ONLY_ARG, "window_group", "XWMHints");
  return(C_TO_XEN_ULONG((XID)((XEN_TO_C_XWMHints(ptr))->window_group)));
}

static XEN gxm_icon_mask(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XWMHints_P(ptr), ptr, XEN_ONLY_ARG, "icon_mask", "XWMHints");
  return(C_TO_XEN_Pixmap((Pixmap)((XEN_TO_C_XWMHints(ptr))->icon_mask)));
}

static XEN gxm_icon_y(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XWMHints_P(ptr), ptr, XEN_ONLY_ARG, "icon_y", "XWMHints");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XWMHints(ptr))->icon_y)));
}

static XEN gxm_icon_x(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XWMHints_P(ptr), ptr, XEN_ONLY_ARG, "icon_x", "XWMHints");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XWMHints(ptr))->icon_x)));
}

static XEN gxm_icon_window(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XWMHints_P(ptr), ptr, XEN_ONLY_ARG, "icon_window", "XWMHints");
  return(C_TO_XEN_Window((Window)((XEN_TO_C_XWMHints(ptr))->icon_window)));
}

static XEN gxm_icon_pixmap(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XWMHints_P(ptr), ptr, XEN_ONLY_ARG, "icon_pixmap", "XWMHints");
  return(C_TO_XEN_Pixmap((Pixmap)((XEN_TO_C_XWMHints(ptr))->icon_pixmap)));
}

static XEN gxm_initial_state(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XWMHints_P(ptr), ptr, XEN_ONLY_ARG, "initial_state", "XWMHints");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XWMHints(ptr))->initial_state)));
}

static XEN gxm_set_initial_state(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_XWMHints_P(ptr), ptr, XEN_ARG_1, "initial_state", "XWMHints");
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "initial_state", "an integer");
  (XEN_TO_C_XWMHints(ptr))->initial_state = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_input(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XWMHints_P(ptr), ptr, XEN_ONLY_ARG, "input", "XWMHints");
  return(C_TO_XEN_BOOLEAN((Bool)((XEN_TO_C_XWMHints(ptr))->input)));
}

static XEN gxm_set_input(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_XWMHints_P(ptr), ptr, XEN_ARG_1, "input", "XWMHints");
  XM_SET_FIELD_ASSERT_TYPE(XEN_BOOLEAN_P(val), val, XEN_ARG_2, "input", "a boolean");
  (XEN_TO_C_XWMHints(ptr))->input = XEN_TO_C_BOOLEAN(val);
  return(val);
}

static XEN gxm_flags(XEN ptr)
{
  if (XEN_XColor_P(ptr)) return(C_TO_XEN_char((char)((XEN_TO_C_XColor(ptr))->flags)));
#if HAVE_MOTIF
  if (XEN_XmSelectionCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmSelectionCallbackStruct(ptr))->flags)));
  if (XEN_XmDestinationCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDestinationCallbackStruct(ptr))->flags)));
  if (XEN_XmConvertCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmConvertCallbackStruct(ptr))->flags)));
#endif
  if (XEN_XWMHints_P(ptr)) return(C_TO_XEN_INT((long)((XEN_TO_C_XWMHints(ptr))->flags)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "flags", "a struct with a flags field");
  return(XEN_FALSE);
}

static XEN gxm_set_flags(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_XColor_P(ptr) || XEN_XWMHints_P(ptr), ptr, XEN_ARG_1, "flags", "XColor or XWMHints");
  XM_SET_FIELD_ASSERT_TYPE(XEN_char_P(val), val, XEN_ARG_2, "input", "a char (int)");
  if (XEN_XColor_P(ptr)) (XEN_TO_C_XColor(ptr))->flags = XEN_TO_C_char(val);
  else if (XEN_XWMHints_P(ptr)) (XEN_TO_C_XWMHints(ptr))->flags = XEN_TO_C_char(val);
  return(val);
}

static XEN gxm_per_char(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XFontStruct_P(ptr), ptr, XEN_ONLY_ARG, "per_char", "XFontStruct");
  return(C_TO_XEN_XCharStruct((XCharStruct *)((XEN_TO_C_XFontStruct(ptr))->per_char)));
}

static XEN gxm_max_bounds(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XFontStruct_P(ptr), ptr, XEN_ONLY_ARG, "max_bounds", "XFontStruct");
  return(C_TO_XEN_XCharStruct((XCharStruct *)(&(XEN_TO_C_XFontStruct(ptr))->max_bounds)));
}

static XEN gxm_min_bounds(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XFontStruct_P(ptr), ptr, XEN_ONLY_ARG, "min_bounds", "XFontStruct");
  return(C_TO_XEN_XCharStruct((XCharStruct *)(&(XEN_TO_C_XFontStruct(ptr))->min_bounds)));
}

static XEN gxm_min_height(XEN ptr)
{
  if (XEN_XIconSize_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XIconSize(ptr))->min_height)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "min_height", "XIconSize");
  return(XEN_FALSE);
}

static XEN gxm_min_width(XEN ptr)
{
  if (XEN_XIconSize_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XIconSize(ptr))->min_width)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "min_width", "XIconSize");
  return(XEN_FALSE);
}

static XEN gxm_max_height(XEN ptr)
{
  if (XEN_XIconSize_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XIconSize(ptr))->max_height)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "max_height", "XIconSize");
  return(XEN_FALSE);
}

static XEN gxm_max_width(XEN ptr)
{
  if (XEN_XIconSize_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XIconSize(ptr))->max_width)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "max_width", "XIconSize");
  return(XEN_FALSE);
}

static XEN gxm_height_inc(XEN ptr)
{
  if (XEN_XIconSize_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XIconSize(ptr))->height_inc)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "height_inc", "XIconSize");
  return(XEN_FALSE);
}

static XEN gxm_width_inc(XEN ptr)
{
  if (XEN_XIconSize_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XIconSize(ptr))->width_inc)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "width_inc", "XIconSize");
  return(XEN_FALSE);
}

static XEN gxm_properties(XEN ptr)
{
  int i, len;
  XFontStruct *fs;
  XFontProp *props;
  XEN lst = XEN_EMPTY_LIST;
  XM_FIELD_ASSERT_TYPE(XEN_XFontStruct_P(ptr), ptr, XEN_ONLY_ARG, "properties", "XFontStruct");
  fs = XEN_TO_C_XFontStruct(ptr);
  len = fs->n_properties;
  props = fs->properties;
  for (i = 0; i < len; i++)
    lst = XEN_CONS(C_TO_XEN_XFontProp(&(props[i])), lst);
  return(lst);
}

static XEN gxm_fid(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XFontStruct_P(ptr), ptr, XEN_ONLY_ARG, "fid", "XFontStruct");
  return(C_TO_XEN_Font((Font)((XEN_TO_C_XFontStruct(ptr))->fid)));
}

static XEN gxm_card32(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XFontProp_P(ptr), ptr, XEN_ONLY_ARG, "card32", "XFontProp");
  return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XFontProp(ptr))->card32)));
}

static XEN gxm_set_name(XEN ptr, XEN val)
{
#if HAVE_XPM
  XM_SET_FIELD_ASSERT_TYPE(XEN_STRING_P(val), val, XEN_ARG_2, "name", "a string");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XpmColorSymbol_P(ptr), ptr, XEN_ARG_1, "name", "XpmColorSymbol");
  (XEN_TO_C_XpmColorSymbol(ptr))->name = strdup(XEN_TO_C_STRING(val));
#endif
  return(val);
}

static XEN gxm_name(XEN ptr)
{
  if (XEN_XFontProp_P(ptr)) return(C_TO_XEN_Atom((Atom)((XEN_TO_C_XFontProp(ptr))->name)));
#if HAVE_XPM
  if (XEN_XpmColorSymbol_P(ptr)) return(C_TO_XEN_STRING((char *)((XEN_TO_C_XpmColorSymbol(ptr))->name)));
#endif
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "name", "a struct with a name field");
  return(XEN_FALSE);
}

static XEN gxm_attributes(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XCharStruct_P(ptr), ptr, XEN_ONLY_ARG, "attributes", "XCharStruct");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XCharStruct(ptr))->attributes)));
}

static XEN gxm_descent(XEN ptr)
{
  if (XEN_XFontStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XFontStruct(ptr))->descent)));
  if (XEN_XCharStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XCharStruct(ptr))->descent)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "descent", "a struct with a descent field");
  return(XEN_FALSE);
}

static XEN gxm_ascent(XEN ptr)
{
  if (XEN_XFontStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XFontStruct(ptr))->ascent)));
  if (XEN_XCharStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XCharStruct(ptr))->ascent)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "ascent", "a struct with an ascent field");
  return(XEN_FALSE);
}

static XEN gxm_rbearing(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XCharStruct_P(ptr), ptr, XEN_ONLY_ARG, "rbearing", "XCharStruct");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XCharStruct(ptr))->rbearing)));
}

static XEN gxm_lbearing(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XCharStruct_P(ptr), ptr, XEN_ONLY_ARG, "lbearing", "XCharStruct");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XCharStruct(ptr))->lbearing)));
}

static XEN gxm_request_code(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XErrorEvent_P(ptr), ptr, XEN_ONLY_ARG, "request_code", "XErrorEvent");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XErrorEvent(ptr))->request_code)));
}

static XEN gxm_set_request_code(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "request_code", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XErrorEvent_P(ptr), ptr, XEN_ARG_1, "request_code", "XErrorEvent");
  (XEN_TO_C_XErrorEvent(ptr))->request_code = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_error_code(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XErrorEvent_P(ptr), ptr, XEN_ONLY_ARG, "error_code", "XErrorEvent");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XErrorEvent(ptr))->error_code)));
}

static XEN gxm_set_error_code(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "error_code", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XErrorEvent_P(ptr), ptr, XEN_ARG_1, "error_code", "XErrorEvent");
  (XEN_TO_C_XErrorEvent(ptr))->error_code = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_resourceid(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XErrorEvent_P(ptr), ptr, XEN_ONLY_ARG, "resourceid", "XErrorEvent");
  return(C_TO_XEN_ULONG((XID)((XEN_TO_C_XErrorEvent(ptr))->resourceid)));
}

static XEN gxm_set_resourceid(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_ULONG_P(val), val, XEN_ARG_2, "resourceid", "an XID");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XErrorEvent_P(ptr), ptr, XEN_ARG_1, "resourceid", "XErrorEvent");
  (XEN_TO_C_XErrorEvent(ptr))->resourceid = (XID)XEN_TO_C_ULONG(val);
  return(val);
}

static XEN gxm_first_keycode(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XMappingEvent_P(ptr), ptr, XEN_ONLY_ARG, "first_keycode", "XMappingEvent");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XMappingEvent(ptr))->first_keycode)));
}

static XEN gxm_set_first_keycode(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "first_keycode", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XMappingEvent_P(ptr), ptr, XEN_ARG_1, "first_keycode", "XMappingEvent");
  (XEN_TO_C_XMappingEvent(ptr))->first_keycode = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_request(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XMappingEvent_P(ptr), ptr, XEN_ONLY_ARG, "request", "XMappingEvent");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XMappingEvent(ptr))->request)));
}

static XEN gxm_set_request(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "request", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XMappingEvent_P(ptr), ptr, XEN_ARG_1, "request", "XMappingEvent");
  (XEN_TO_C_XMappingEvent(ptr))->request = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_format(XEN ptr)
{
  if (XEN_XImage_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XImage(ptr))->format)));
#if HAVE_MOTIF
  if (XEN_XmSelectionCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmSelectionCallbackStruct(ptr))->format)));
  if (XEN_XmConvertCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmConvertCallbackStruct(ptr))->format)));
  if (XEN_XmTextBlock_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmTextBlock(ptr))->format)));
#endif
  if (XEN_XClientMessageEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XClientMessageEvent(ptr))->format)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "format", "XClientMessageEvent");
  return(XEN_FALSE);
}

static XEN gxm_set_format(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "format", "an integer");
  if (XEN_XClientMessageEvent_P(ptr)) (XEN_TO_C_XClientMessageEvent(ptr))->format = XEN_TO_C_INT(val);
#if HAVE_MOTIF
  else if (XEN_XmTextBlock_P(ptr)) (XEN_TO_C_XmTextBlock(ptr))->format = XEN_TO_C_INT(val);
#endif
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "format", "XClientMessageEvent or XmTextBlock");
  return(val);
}

static XEN gxm_message_type(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XClientMessageEvent_P(ptr), ptr, XEN_ONLY_ARG, "message_type", "XClientMessageEvent");
  return(C_TO_XEN_Atom((Atom)((XEN_TO_C_XClientMessageEvent(ptr))->message_type)));
}

static XEN gxm_set_message_type(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_Atom_P(val), val, XEN_ARG_2, "message_type", "an Atom");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XClientMessageEvent_P(ptr), ptr, XEN_ARG_1, "message_type", "XClientMessageEvent");
  (XEN_TO_C_XClientMessageEvent(ptr))->message_type = XEN_TO_C_Atom(val);
  return(val);
}

static XEN gxm_new(XEN ptr)
{
#ifndef __cplusplus
  XM_FIELD_ASSERT_TYPE(XEN_XColormapEvent_P(ptr), ptr, XEN_ONLY_ARG, "new", "XColormapEvent");
  return(C_TO_XEN_BOOLEAN((Bool)((XEN_TO_C_XColormapEvent(ptr))->new)));
#endif
  return(XEN_FALSE);
}

static XEN gxm_set_new(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_BOOLEAN_P(val), val, XEN_ARG_2, "new", "a boolean");
#ifndef __cplusplus
  if (XEN_XColormapEvent_P(ptr)) (XEN_TO_C_XColormapEvent(ptr))->new = XEN_TO_C_BOOLEAN(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "new", "XColormapEvent");
#endif
  return(val);
}

static XEN gxm_colormap(XEN ptr)
{
  if (XEN_XWindowAttributes_P(ptr)) return(C_TO_XEN_Colormap((Colormap)((XEN_TO_C_XWindowAttributes(ptr))->colormap)));
  if (XEN_XSetWindowAttributes_P(ptr)) return(C_TO_XEN_Colormap((Colormap)((XEN_TO_C_XSetWindowAttributes(ptr))->colormap)));
  if (XEN_XColormapEvent_P(ptr)) return(C_TO_XEN_Colormap((Colormap)((XEN_TO_C_XColormapEvent(ptr))->colormap)));
  if (XEN_XStandardColormap_P(ptr)) return(C_TO_XEN_Colormap((Colormap)((XEN_TO_C_XStandardColormap(ptr))->colormap)));
#if HAVE_XPM
  if (XEN_XpmAttributes_P(ptr)) return(C_TO_XEN_Colormap((Colormap)((XEN_TO_C_XpmAttributes(ptr))->colormap)));
#endif
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "colormap", "a struct with a colormap field");
  return(XEN_FALSE);
}

static XEN gxm_set_colormap(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_Colormap_P(val), val, XEN_ARG_2, "colormap", "a Colormap");
#if HAVE_XPM
  if (XEN_XpmAttributes_P(ptr)) (XEN_TO_C_XpmAttributes(ptr))->colormap = XEN_TO_C_Colormap(val);
  else 
#endif
    if (XEN_XColormapEvent_P(ptr)) (XEN_TO_C_XColormapEvent(ptr))->colormap = XEN_TO_C_Colormap(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "colormap", "XpmAttributes or XColormapEvent");
  return(val);
}

static XEN gxm_property(XEN ptr)
{
  if (XEN_XSelectionEvent_P(ptr)) return(C_TO_XEN_Atom((Atom)((XEN_TO_C_XSelectionEvent(ptr))->property)));
  if (XEN_XSelectionRequestEvent_P(ptr)) return(C_TO_XEN_Atom((Atom)((XEN_TO_C_XSelectionRequestEvent(ptr))->property)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "property", "a struct with a property field");
  return(XEN_FALSE);
}

static XEN gxm_set_property(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_Atom_P(val), val, XEN_ARG_2, "property", "an Atom");
  if (XEN_XSelectionEvent_P(ptr)) (XEN_TO_C_XSelectionEvent(ptr))->property = XEN_TO_C_Atom(val);
  else if (XEN_XSelectionRequestEvent_P(ptr)) (XEN_TO_C_XSelectionRequestEvent(ptr))->property = XEN_TO_C_Atom(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "property", "XSelection(Request)Event");
  return(val);
}

static XEN gxm_target(XEN ptr)
{
#if HAVE_MOTIF
  if (XEN_XmPopupHandlerCallbackStruct_P(ptr)) return(C_TO_XEN_Widget((Widget)((XEN_TO_C_XmPopupHandlerCallbackStruct(ptr))->target)));
  if (XEN_XmSelectionCallbackStruct_P(ptr)) return(C_TO_XEN_Atom((Atom)((XEN_TO_C_XmSelectionCallbackStruct(ptr))->target)));
  if (XEN_XmConvertCallbackStruct_P(ptr)) return(C_TO_XEN_Atom((Atom)((XEN_TO_C_XmConvertCallbackStruct(ptr))->target)));
#endif
  if (XEN_XSelectionEvent_P(ptr)) return(C_TO_XEN_Atom((Atom)((XEN_TO_C_XSelectionEvent(ptr))->target)));
  if (XEN_XSelectionRequestEvent_P(ptr)) return(C_TO_XEN_Atom((Atom)((XEN_TO_C_XSelectionRequestEvent(ptr))->target)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "target", "a struct with a target field");
  return(XEN_FALSE);
}

static XEN gxm_set_target(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_Atom_P(val), val, XEN_ARG_2, "target", "an Atom");
  if (XEN_XSelectionEvent_P(ptr)) (XEN_TO_C_XSelectionEvent(ptr))->target = XEN_TO_C_Atom(val);
  else if (XEN_XSelectionRequestEvent_P(ptr)) (XEN_TO_C_XSelectionRequestEvent(ptr))->target = XEN_TO_C_Atom(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "target", "XSelection(Request)Event");
  return(val);
}

static XEN gxm_requestor(XEN ptr)
{
  if (XEN_XSelectionEvent_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XSelectionEvent(ptr))->requestor)));
  if (XEN_XSelectionRequestEvent_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XSelectionRequestEvent(ptr))->requestor)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "requestor", "a struct with a requestor field");
  return(XEN_FALSE);
}

static XEN gxm_set_requestor(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_Window_P(val), val, XEN_ARG_2, "requestor", "a Window");
  if (XEN_XSelectionEvent_P(ptr)) (XEN_TO_C_XSelectionEvent(ptr))->requestor = XEN_TO_C_Window(val);
  else if (XEN_XSelectionRequestEvent_P(ptr)) (XEN_TO_C_XSelectionRequestEvent(ptr))->requestor = XEN_TO_C_Window(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "requestor", "XSelection(Request)Event");
  return(val);
}

static XEN gxm_owner(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XSelectionRequestEvent_P(ptr), ptr, XEN_ONLY_ARG, "owner", "XSelectionRequestEvent");
  return(C_TO_XEN_Window((Window)((XEN_TO_C_XSelectionRequestEvent(ptr))->owner)));
}

static XEN gxm_set_owner(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_Window_P(val), val, XEN_ARG_2, "owner", "a Window");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XSelectionRequestEvent_P(ptr), ptr, XEN_ARG_1, "owner", "XSelectionRequestEvent");
  (XEN_TO_C_XSelectionRequestEvent(ptr))->owner = XEN_TO_C_Window(val);
  return(val);
}

static XEN gxm_selection(XEN ptr)
{
#if HAVE_MOTIF
  if (XEN_XmTransferDoneCallbackStruct_P(ptr)) return(C_TO_XEN_Atom((Atom)((XEN_TO_C_XmTransferDoneCallbackStruct(ptr))->selection)));
  if (XEN_XmSelectionCallbackStruct_P(ptr)) return(C_TO_XEN_Atom((Atom)((XEN_TO_C_XmSelectionCallbackStruct(ptr))->selection)));
  if (XEN_XmDestinationCallbackStruct_P(ptr)) return(C_TO_XEN_Atom((Atom)((XEN_TO_C_XmDestinationCallbackStruct(ptr))->selection)));
  if (XEN_XmConvertCallbackStruct_P(ptr)) return(C_TO_XEN_Atom((Atom)((XEN_TO_C_XmConvertCallbackStruct(ptr))->selection)));
#endif
  if (XEN_XSelectionEvent_P(ptr)) return(C_TO_XEN_Atom((Atom)((XEN_TO_C_XSelectionEvent(ptr))->selection)));
  if (XEN_XSelectionRequestEvent_P(ptr)) return(C_TO_XEN_Atom((Atom)((XEN_TO_C_XSelectionRequestEvent(ptr))->selection)));
  if (XEN_XSelectionClearEvent_P(ptr)) return(C_TO_XEN_Atom((Atom)((XEN_TO_C_XSelectionClearEvent(ptr))->selection)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "selection", "a struct with a selection field");
  return(XEN_FALSE);
}

static XEN gxm_set_selection(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_Atom_P(val), val, XEN_ARG_2, "selection", "an Atom");
  if (XEN_XSelectionEvent_P(ptr)) (XEN_TO_C_XSelectionEvent(ptr))->selection = XEN_TO_C_Atom(val);
  else if (XEN_XSelectionRequestEvent_P(ptr)) (XEN_TO_C_XSelectionRequestEvent(ptr))->selection = XEN_TO_C_Atom(val);
  else if (XEN_XSelectionClearEvent_P(ptr)) (XEN_TO_C_XSelectionClearEvent(ptr))->selection = XEN_TO_C_Atom(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "selection", "XSelection(Request|Clear)Event");
  return(val);
}

static XEN gxm_atom(XEN ptr)
{
  if (XEN_XPropertyEvent_P(ptr)) return(C_TO_XEN_Atom((Atom)((XEN_TO_C_XPropertyEvent(ptr))->atom)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "atom", "XPropertyEvent");
  return(XEN_FALSE);
}

static XEN gxm_set_atom(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_Atom_P(val), val, XEN_ARG_2, "atom", "an Atom");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XPropertyEvent_P(ptr), ptr, XEN_ARG_1, "atom", "XPropertyEvent");
  (XEN_TO_C_XPropertyEvent(ptr))->atom = XEN_TO_C_Atom(val);
  return(val);
}

static XEN gxm_place(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XCirculateRequestEvent_P(ptr) || XEN_XCirculateEvent_P(ptr), ptr, XEN_ONLY_ARG, "place", "a struct with a place field");
  if (XEN_XCirculateRequestEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XCirculateRequestEvent(ptr))->place)));
  return(C_TO_XEN_INT((int)((XEN_TO_C_XCirculateEvent(ptr))->place)));
}

static XEN gxm_set_place(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "place", "an integer");
  if (XEN_XCirculateRequestEvent_P(ptr)) (XEN_TO_C_XCirculateRequestEvent(ptr))->place = XEN_TO_C_INT(val);
  else if (XEN_XCirculateEvent_P(ptr)) (XEN_TO_C_XCirculateEvent(ptr))->place = XEN_TO_C_INT(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "place", "a struct with a place field");
  return(val);
}

static XEN gxm_value_mask(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XConfigureRequestEvent_P(ptr), ptr, XEN_ONLY_ARG, "value_mask", "XConfigureRequestEvent");
  return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XConfigureRequestEvent(ptr))->value_mask)));
}

static XEN gxm_set_value_mask(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_ULONG_P(val), val, XEN_ARG_2, "value_mask", "an unsigned long");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XConfigureRequestEvent_P(ptr), ptr, XEN_ARG_1, "value_mask", "XConfigureRequestEvent");
  (XEN_TO_C_XConfigureRequestEvent(ptr))->value_mask = XEN_TO_C_ULONG(val);
  return(val);
}

static XEN gxm_above(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XConfigureRequestEvent_P(ptr) || XEN_XConfigureEvent_P(ptr), ptr, XEN_ONLY_ARG, "above", "a struct with an above field");
  if (XEN_XConfigureRequestEvent_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XConfigureRequestEvent(ptr))->above)));
  return(C_TO_XEN_Window((Window)((XEN_TO_C_XConfigureEvent(ptr))->above)));
}

static XEN gxm_set_above(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_Window_P(val), val, XEN_ARG_2, "above", "a Window");
  if (XEN_XConfigureRequestEvent_P(ptr)) (XEN_TO_C_XConfigureRequestEvent(ptr))->above = XEN_TO_C_Window(val);
  else if (XEN_XConfigureEvent_P(ptr)) (XEN_TO_C_XConfigureEvent(ptr))->above = XEN_TO_C_Window(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "above", "a struct with an above field");
  return(val);
}

static XEN gxm_from_configure(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XUnmapEvent_P(ptr), ptr, XEN_ONLY_ARG, "from_configure", "XUnmapEvent");
  return(C_TO_XEN_BOOLEAN((Bool)((XEN_TO_C_XUnmapEvent(ptr))->from_configure)));
}

static XEN gxm_set_from_configure(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_BOOLEAN_P(val), val, XEN_ARG_2, "from_configure", "a boolean");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XUnmapEvent_P(ptr), ptr, XEN_ARG_1, "from_configure", "XUnmapEvent");
  (XEN_TO_C_XUnmapEvent(ptr))->from_configure = XEN_TO_C_BOOLEAN(val);
  return(val);
}


static XEN gxm_event(XEN ptr)
{
  /* Xlib.h says event is a window in these cases -- kinda strange looking */
  if (XEN_XCirculateEvent_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XCirculateEvent(ptr))->event)));
  if (XEN_XGravityEvent_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XGravityEvent(ptr))->event)));
  if (XEN_XConfigureEvent_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XConfigureEvent(ptr))->event)));
  if (XEN_XReparentEvent_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XReparentEvent(ptr))->event)));
  if (XEN_XMapEvent_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XMapEvent(ptr))->event)));
  if (XEN_XUnmapEvent_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XUnmapEvent(ptr))->event)));
  if (XEN_XDestroyWindowEvent_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XDestroyWindowEvent(ptr))->event)));
#if HAVE_MOTIF
  if (XEN_AnyCallbackStruct_P(ptr)) return(C_TO_XEN_XEvent((XEvent *)((XEN_TO_C_XmAnyCallbackStruct(ptr))->event)));
#endif
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "event", "a struct with an event field");
  return(XEN_FALSE);
}

static XEN gxm_set_event(XEN ptr, XEN val)
{
  if (XEN_XCirculateEvent_P(ptr)) (XEN_TO_C_XCirculateEvent(ptr))->event = XEN_TO_C_Window(val); else
  if (XEN_XGravityEvent_P(ptr)) (XEN_TO_C_XGravityEvent(ptr))->event = XEN_TO_C_Window(val); else
  if (XEN_XConfigureEvent_P(ptr)) (XEN_TO_C_XConfigureEvent(ptr))->event = XEN_TO_C_Window(val); else
  if (XEN_XReparentEvent_P(ptr)) (XEN_TO_C_XReparentEvent(ptr))->event = XEN_TO_C_Window(val); else
  if (XEN_XMapEvent_P(ptr)) (XEN_TO_C_XMapEvent(ptr))->event = XEN_TO_C_Window(val); else
  if (XEN_XUnmapEvent_P(ptr)) (XEN_TO_C_XUnmapEvent(ptr))->event = XEN_TO_C_Window(val); else
  if (XEN_XDestroyWindowEvent_P(ptr)) (XEN_TO_C_XDestroyWindowEvent(ptr))->event = XEN_TO_C_Window(val); else
#if HAVE_MOTIF
  if (XEN_AnyCallbackStruct_P(ptr)) (XEN_TO_C_XmAnyCallbackStruct(ptr))->event = XEN_TO_C_XEvent(val); else
#endif
  XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "event", "a struct with an event field");
  return(val);
}

static XEN gxm_override_redirect(XEN ptr)
{
  if (XEN_XWindowAttributes_P(ptr)) return(C_TO_XEN_BOOLEAN((Bool)((XEN_TO_C_XWindowAttributes(ptr))->override_redirect)));
  if (XEN_XSetWindowAttributes_P(ptr)) return(C_TO_XEN_BOOLEAN((Bool)((XEN_TO_C_XSetWindowAttributes(ptr))->override_redirect)));
  if (XEN_XConfigureEvent_P(ptr)) return(C_TO_XEN_BOOLEAN((Bool)((XEN_TO_C_XConfigureEvent(ptr))->override_redirect)));
  if (XEN_XReparentEvent_P(ptr)) return(C_TO_XEN_BOOLEAN((Bool)((XEN_TO_C_XReparentEvent(ptr))->override_redirect)));
  if (XEN_XMapEvent_P(ptr)) return(C_TO_XEN_BOOLEAN((Bool)((XEN_TO_C_XMapEvent(ptr))->override_redirect)));
  if (XEN_XCreateWindowEvent_P(ptr)) return(C_TO_XEN_BOOLEAN((Bool)((XEN_TO_C_XCreateWindowEvent(ptr))->override_redirect)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "override_redirect", "a struct with an override_redirect field");
  return(XEN_FALSE);
}

static XEN gxm_set_override_redirect(XEN ptr, XEN val)
{
  Bool b;
  XM_SET_FIELD_ASSERT_TYPE(XEN_BOOLEAN_P(val), val, XEN_ARG_2, "override_redirect", "a boolean");
  b = (Bool)XEN_TO_C_BOOLEAN(val);
  if (XEN_XConfigureEvent_P(ptr)) (XEN_TO_C_XConfigureEvent(ptr))->override_redirect = b;
  else if (XEN_XReparentEvent_P(ptr)) (XEN_TO_C_XReparentEvent(ptr))->override_redirect = b;
  else if (XEN_XMapEvent_P(ptr)) (XEN_TO_C_XMapEvent(ptr))->override_redirect = b;
  else if (XEN_XCreateWindowEvent_P(ptr)) (XEN_TO_C_XCreateWindowEvent(ptr))->override_redirect = b;
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "override_redirect", "a struct with an override_redirect field");
  return(val);
}

static XEN gxm_border_width(XEN ptr)
{
  if (XEN_XWindowChanges_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XWindowChanges(ptr))->border_width)));
  if (XEN_XWindowAttributes_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XWindowAttributes(ptr))->border_width)));
  if (XEN_XConfigureRequestEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XConfigureRequestEvent(ptr))->border_width)));
  if (XEN_XConfigureEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XConfigureEvent(ptr))->border_width)));
  if (XEN_XCreateWindowEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XCreateWindowEvent(ptr))->border_width)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "border_width", "a struct with a border_width field");
  return(XEN_FALSE);
}

static XEN gxm_set_border_width(XEN ptr, XEN val)
{
  int wid;
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "border_width", "an integer");
  wid = XEN_TO_C_INT(val);
  if (XEN_XConfigureRequestEvent_P(ptr)) (XEN_TO_C_XConfigureRequestEvent(ptr))->border_width = wid;
  else if (XEN_XConfigureEvent_P(ptr)) (XEN_TO_C_XConfigureEvent(ptr))->border_width = wid;
  else if (XEN_XCreateWindowEvent_P(ptr)) (XEN_TO_C_XCreateWindowEvent(ptr))->border_width = wid;
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "border_width", "a struct with a border_width field");
  return(val);
}

static XEN gxm_parent(XEN ptr)
{
  if (XEN_XCirculateRequestEvent_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XCirculateRequestEvent(ptr))->parent)));
  if (XEN_XConfigureRequestEvent_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XConfigureRequestEvent(ptr))->parent)));
  if (XEN_XReparentEvent_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XReparentEvent(ptr))->parent)));
  if (XEN_XMapRequestEvent_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XMapRequestEvent(ptr))->parent)));
  if (XEN_XCreateWindowEvent_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XCreateWindowEvent(ptr))->parent)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "parent", "a struct with a parent field");
  return(XEN_FALSE);
}

static XEN gxm_set_parent(XEN ptr, XEN val)
{
  Window w;
  XM_SET_FIELD_ASSERT_TYPE(XEN_Window_P(val), val, XEN_ARG_2, "parent", "a Window");
  w = XEN_TO_C_Window(val);
  if (XEN_XCirculateRequestEvent_P(ptr)) (XEN_TO_C_XCirculateRequestEvent(ptr))->parent = w;
  else if (XEN_XConfigureRequestEvent_P(ptr)) (XEN_TO_C_XConfigureRequestEvent(ptr))->parent = w;
  else if (XEN_XReparentEvent_P(ptr)) (XEN_TO_C_XReparentEvent(ptr))->parent = w;
  else if (XEN_XMapRequestEvent_P(ptr)) (XEN_TO_C_XMapRequestEvent(ptr))->parent = w;
  else if (XEN_XCreateWindowEvent_P(ptr)) (XEN_TO_C_XCreateWindowEvent(ptr))->parent= w;
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "parent", "a struct with a parent field");
  return(val);
}

static XEN gxm_minor_code(XEN ptr)
{
  if (XEN_XErrorEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XErrorEvent(ptr))->minor_code)));
  if (XEN_XNoExposeEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XNoExposeEvent(ptr))->minor_code)));
  if (XEN_XGraphicsExposeEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XGraphicsExposeEvent(ptr))->minor_code)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "minor_code", "a struct with a minor_code field");
  return(XEN_FALSE);
}

static XEN gxm_set_minor_code(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "minor_code", "an integer");
  if (XEN_XErrorEvent_P(ptr)) (XEN_TO_C_XErrorEvent(ptr))->minor_code = XEN_TO_C_INT(val);
  else if (XEN_XNoExposeEvent_P(ptr)) (XEN_TO_C_XNoExposeEvent(ptr))->minor_code = XEN_TO_C_INT(val);
  else if (XEN_XGraphicsExposeEvent_P(ptr)) (XEN_TO_C_XGraphicsExposeEvent(ptr))->minor_code = XEN_TO_C_INT(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "minor_code", "a struct with a minor_code field");
  return(val);
}

static XEN gxm_major_code(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XNoExposeEvent_P(ptr) || XEN_XGraphicsExposeEvent_P(ptr), ptr, XEN_ONLY_ARG, "major_code", "a struct with a major_code field");
  if (XEN_XNoExposeEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XNoExposeEvent(ptr))->major_code)));
  return(C_TO_XEN_INT((int)((XEN_TO_C_XGraphicsExposeEvent(ptr))->major_code)));
}

static XEN gxm_set_major_code(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "major_code", "an integer");
  if (XEN_XNoExposeEvent_P(ptr)) (XEN_TO_C_XNoExposeEvent(ptr))->major_code = XEN_TO_C_INT(val);
  else if (XEN_XGraphicsExposeEvent_P(ptr)) (XEN_TO_C_XGraphicsExposeEvent(ptr))->major_code = XEN_TO_C_INT(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "major_code", "a struct with a major_code field");
  return(val);
}

static XEN gxm_drawable(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XNoExposeEvent_P(ptr) || XEN_XGraphicsExposeEvent_P(ptr), ptr, XEN_ONLY_ARG, "drawable", "a struct with a drawable field");
  if (XEN_XNoExposeEvent_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XNoExposeEvent(ptr))->drawable)));
  return(C_TO_XEN_Window((Window)((XEN_TO_C_XGraphicsExposeEvent(ptr))->drawable)));
}

static XEN gxm_set_drawable(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_Window_P(val), val, XEN_ARG_2, "drawable", "a Window");
  if (XEN_XNoExposeEvent_P(ptr)) (XEN_TO_C_XNoExposeEvent(ptr))->drawable = XEN_TO_C_Window(val);
  else if (XEN_XGraphicsExposeEvent_P(ptr)) (XEN_TO_C_XGraphicsExposeEvent(ptr))->drawable = XEN_TO_C_Window(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "drawable", "a struct with a drawable field");
  return(val);
}

static XEN gxm_count(XEN ptr)
{
  if (XEN_XMappingEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XMappingEvent(ptr))->count)));
  if (XEN_XGraphicsExposeEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XGraphicsExposeEvent(ptr))->count)));
  if (XEN_XExposeEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XExposeEvent(ptr))->count)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "count", "a struct with a count field");
  return(XEN_FALSE);
}

static XEN gxm_set_count(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "count", "an integer");
  if (XEN_XMappingEvent_P(ptr)) (XEN_TO_C_XMappingEvent(ptr))->count = XEN_TO_C_INT(val);
  else if (XEN_XGraphicsExposeEvent_P(ptr)) (XEN_TO_C_XGraphicsExposeEvent(ptr))->count = XEN_TO_C_INT(val);
  else if (XEN_XExposeEvent_P(ptr)) (XEN_TO_C_XExposeEvent(ptr))->count = XEN_TO_C_INT(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "count", "a struct with a count field");
  return(val);
}

static XEN gxm_key_vector(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XKeymapEvent_P(ptr), ptr, XEN_ONLY_ARG, "key_vector", "XKeymapEvent");
  return(C_TO_XEN_STRING((char *)((XEN_TO_C_XKeymapEvent(ptr))->key_vector)));
}

static XEN gxm_set_key_vector(XEN ptr, XEN val)
{
  char *keys;
  int i, lim = 0;
  XM_SET_FIELD_ASSERT_TYPE(XEN_STRING_P(val), val, XEN_ARG_2, "key_vector", "a string");
  keys = XEN_TO_C_STRING(val);
  if (keys) lim = strlen(keys);
  if (lim > 32) lim = 32;
  if (lim > 0)
    {
      if (XEN_XKeymapEvent_P(ptr))
	{
	  for (i = 0; i < lim; i++)
	    (XEN_TO_C_XKeymapEvent(ptr))->key_vector[i] = keys[i];
	}
      else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "key_vector", "XKeymapEvent");
    }
  return(val);
}

static XEN gxm_focus(XEN ptr)
{
  if (XEN_XCrossingEvent_P(ptr)) return(C_TO_XEN_BOOLEAN((Bool)((XEN_TO_C_XCrossingEvent(ptr))->focus)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "focus", "XCrossingEvent");
  return(XEN_FALSE);
}

static XEN gxm_set_focus(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_BOOLEAN_P(val), val, XEN_ARG_2, "focus", "a boolean");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XCrossingEvent_P(ptr), ptr, XEN_ARG_1, "focus", "XCrossingEvent");
  (XEN_TO_C_XCrossingEvent(ptr))->focus = (Bool)XEN_TO_C_BOOLEAN(val);
  return(val);
}

static XEN gxm_detail(XEN ptr)
{
#if HAVE_XM_XP
  if (XEN_XmPrintShellCallbackStruct_P(ptr)) return(C_TO_XEN_ULONG((XtPointer)((XEN_TO_C_XmPrintShellCallbackStruct(ptr))->detail)));
#endif
  if (XEN_XConfigureRequestEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XConfigureRequestEvent(ptr))->detail)));
  if (XEN_XFocusChangeEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XFocusChangeEvent(ptr))->detail)));
  if (XEN_XCrossingEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XCrossingEvent(ptr))->detail)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "detail", "a struct with a detail field");
  return(XEN_FALSE);
}

static XEN gxm_set_detail(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "detail", "an integer");
  if (XEN_XConfigureRequestEvent_P(ptr)) (XEN_TO_C_XConfigureRequestEvent(ptr))->detail = XEN_TO_C_INT(val);
  else if (XEN_XFocusChangeEvent_P(ptr)) (XEN_TO_C_XFocusChangeEvent(ptr))->detail = XEN_TO_C_INT(val);
  else if (XEN_XCrossingEvent_P(ptr)) (XEN_TO_C_XCrossingEvent(ptr))->detail = XEN_TO_C_INT(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "detail", "a struct with a detail field");
  return(val);
}

static XEN gxm_mode(XEN ptr)
{
  if (XEN_XFocusChangeEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XFocusChangeEvent(ptr))->mode)));
  if (XEN_XCrossingEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XCrossingEvent(ptr))->mode)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "mode", "a struct with a mode field");
  return(XEN_FALSE);
}

static XEN gxm_set_mode(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "mode", "an integer");
  if (XEN_XFocusChangeEvent_P(ptr)) (XEN_TO_C_XFocusChangeEvent(ptr))->mode = XEN_TO_C_INT(val);
  else if (XEN_XCrossingEvent_P(ptr)) (XEN_TO_C_XCrossingEvent(ptr))->mode  = XEN_TO_C_INT(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "mode", "a struct with a mode field");
  return(val);
}

static XEN gxm_is_hint(XEN ptr)
{
  if (XEN_XMotionEvent_P(ptr)) return(C_TO_XEN_char((char)((XEN_TO_C_XMotionEvent(ptr))->is_hint)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "is_hint", "XMotionEvent");
  return(XEN_FALSE);
}

static XEN gxm_set_is_hint(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "is_hint", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XMotionEvent_P(ptr), ptr, XEN_ARG_1, "is_hint", "XMotionEvent");
  (XEN_TO_C_XMotionEvent(ptr))->is_hint = (char)XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_button(XEN ptr)
{
  if (XEN_XButtonEvent_P(ptr)) return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XButtonEvent(ptr))->button)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "button", "XButtonEvent");
  return(XEN_FALSE);
}

static XEN gxm_set_button(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_ULONG_P(val), val, XEN_ARG_2, "button", "an unsigned long");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XButtonEvent_P(ptr), ptr, XEN_ARG_1, "button", "XButtonEvent");
  (XEN_TO_C_XButtonEvent(ptr))->button = XEN_TO_C_ULONG(val);
  return(val);
}

static XEN gxm_same_screen(XEN ptr)
{
  if (XEN_XCrossingEvent_P(ptr)) return(C_TO_XEN_BOOLEAN((Bool)((XEN_TO_C_XCrossingEvent(ptr))->same_screen)));
  if (XEN_XMotionEvent_P(ptr)) return(C_TO_XEN_BOOLEAN((Bool)((XEN_TO_C_XMotionEvent(ptr))->same_screen)));
  if (XEN_XButtonEvent_P(ptr)) return(C_TO_XEN_BOOLEAN((Bool)((XEN_TO_C_XButtonEvent(ptr))->same_screen)));
  if (XEN_XKeyEvent_P(ptr)) return(C_TO_XEN_BOOLEAN((Bool)((XEN_TO_C_XKeyEvent(ptr))->same_screen)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "same_screen", "a struct with a same_screen field");
  return(XEN_FALSE);
}

static XEN gxm_set_same_screen(XEN ptr, XEN val)
{
  Bool b;
  XM_SET_FIELD_ASSERT_TYPE(XEN_BOOLEAN_P(val), val, XEN_ARG_2, "same_screen", "a boolean");
  b = (Bool)XEN_TO_C_BOOLEAN(val);
  if (XEN_XCrossingEvent_P(ptr)) (XEN_TO_C_XCrossingEvent(ptr))->same_screen = b;
  else if (XEN_XMotionEvent_P(ptr)) (XEN_TO_C_XMotionEvent(ptr))->same_screen = b;
  else if (XEN_XButtonEvent_P(ptr)) (XEN_TO_C_XButtonEvent(ptr))->same_screen = b;
  else if (XEN_XKeyEvent_P(ptr)) (XEN_TO_C_XKeyEvent(ptr))->same_screen = b;
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "same_screen", "a struct with a same_screen field");
  return(val);
}

static XEN gxm_keycode(XEN ptr)
{
  if (XEN_XKeyEvent_P(ptr)) return(C_TO_XEN_KeyCode((XEN_TO_C_XKeyEvent(ptr))->keycode));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "keycode", "XKeyEvent");
  return(XEN_FALSE);
}

static XEN gxm_set_keycode(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_KeyCode_P(val), val, XEN_ARG_2, "keycode", "a KeyCode");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XKeyEvent_P(ptr), ptr, XEN_ARG_1, "keycode", "XKeyEvent");
  (XEN_TO_C_XKeyEvent(ptr))->keycode = XEN_TO_C_KeyCode(val);
  return(val);
}

static XEN gxm_state(XEN ptr)
{
  if (XEN_XColormapEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XColormapEvent(ptr))->state)));
  if (XEN_XPropertyEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XPropertyEvent(ptr))->state)));
  if (XEN_XVisibilityEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XVisibilityEvent(ptr))->state)));
  if (XEN_XCrossingEvent_P(ptr)) return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XCrossingEvent(ptr))->state)));
  if (XEN_XMotionEvent_P(ptr)) return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XMotionEvent(ptr))->state)));
  if (XEN_XButtonEvent_P(ptr)) return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XButtonEvent(ptr))->state)));
  if (XEN_XKeyEvent_P(ptr)) return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XKeyEvent(ptr))->state)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "state", "a struct with a state field");
  return(XEN_FALSE);
}

static XEN gxm_set_state(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val) || XEN_ULONG_P(val), val, XEN_ARG_2, "state", "an integer");
  if (XEN_XColormapEvent_P(ptr)) (XEN_TO_C_XColormapEvent(ptr))->state = XEN_TO_C_INT(val);
  else if (XEN_XPropertyEvent_P(ptr)) (XEN_TO_C_XPropertyEvent(ptr))->state = XEN_TO_C_INT(val);
  else if (XEN_XVisibilityEvent_P(ptr)) (XEN_TO_C_XVisibilityEvent(ptr))->state = XEN_TO_C_INT(val);
  else if (XEN_XCrossingEvent_P(ptr)) (XEN_TO_C_XCrossingEvent(ptr))->state = XEN_TO_C_ULONG(val);
  else if (XEN_XMotionEvent_P(ptr)) (XEN_TO_C_XMotionEvent(ptr))->state = XEN_TO_C_ULONG(val);
  else if (XEN_XButtonEvent_P(ptr)) (XEN_TO_C_XButtonEvent(ptr))->state = XEN_TO_C_ULONG(val);
  else if (XEN_XKeyEvent_P(ptr)) (XEN_TO_C_XKeyEvent(ptr))->state = XEN_TO_C_ULONG(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "state", "a struct with a state field");
  return(val);
}

static XEN gxm_y_root(XEN ptr)
{
  if (XEN_XCrossingEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XCrossingEvent(ptr))->y_root)));
  if (XEN_XMotionEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XMotionEvent(ptr))->y_root)));
  if (XEN_XButtonEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XButtonEvent(ptr))->y_root)));
  if (XEN_XKeyEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XKeyEvent(ptr))->y_root)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "y_root", "a struct with a y_root field");
  return(XEN_FALSE);
}

static XEN gxm_set_y_root(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "y_root", "an integer");
  if (XEN_XCrossingEvent_P(ptr)) (XEN_TO_C_XCrossingEvent(ptr))->y_root = XEN_TO_C_INT(val);
  else if (XEN_XMotionEvent_P(ptr)) (XEN_TO_C_XMotionEvent(ptr))->y_root = XEN_TO_C_INT(val);
  else if (XEN_XButtonEvent_P(ptr)) (XEN_TO_C_XButtonEvent(ptr))->y_root = XEN_TO_C_INT(val);
  else if (XEN_XKeyEvent_P(ptr)) (XEN_TO_C_XKeyEvent(ptr))->y_root = XEN_TO_C_INT(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "y_root", "a struct with a y_root field");
  return(val);
}

static XEN gxm_x_root(XEN ptr)
{
  if (XEN_XCrossingEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XCrossingEvent(ptr))->x_root)));
  if (XEN_XMotionEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XMotionEvent(ptr))->x_root)));
  if (XEN_XButtonEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XButtonEvent(ptr))->x_root)));
  if (XEN_XKeyEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XKeyEvent(ptr))->x_root)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "x_root", "a struct with an x_root field");
  return(XEN_FALSE);
}

static XEN gxm_set_x_root(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "x_root", "an integer");
  if (XEN_XCrossingEvent_P(ptr)) (XEN_TO_C_XCrossingEvent(ptr))->x_root = XEN_TO_C_INT(val);
  else if (XEN_XMotionEvent_P(ptr)) (XEN_TO_C_XMotionEvent(ptr))->x_root = XEN_TO_C_INT(val);
  else if (XEN_XButtonEvent_P(ptr)) (XEN_TO_C_XButtonEvent(ptr))->x_root = XEN_TO_C_INT(val);
  else if (XEN_XKeyEvent_P(ptr)) (XEN_TO_C_XKeyEvent(ptr))->x_root = XEN_TO_C_INT(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "x_root", "a struct with a x_root field");
  return(val);
}

static XEN gxm_set_x(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "x", "an integer");
  if (XEN_XRectangle_P(ptr)) (XEN_TO_C_XRectangle(ptr))->x = (short)XEN_TO_C_INT(val);
  else if (XEN_XPoint_P(ptr)) (XEN_TO_C_XPoint(ptr))->x = (short)XEN_TO_C_INT(val);
  else if (XEN_XArc_P(ptr)) (XEN_TO_C_XArc(ptr))->x = (short)XEN_TO_C_INT(val);
  else if (XEN_XConfigureRequestEvent_P(ptr)) (XEN_TO_C_XConfigureRequestEvent(ptr))->x = XEN_TO_C_INT(val);
  else if (XEN_XGravityEvent_P(ptr)) (XEN_TO_C_XGravityEvent(ptr))->x = XEN_TO_C_INT(val);
  else if (XEN_XConfigureEvent_P(ptr)) (XEN_TO_C_XConfigureEvent(ptr))->x = XEN_TO_C_INT(val);
  else if (XEN_XReparentEvent_P(ptr)) (XEN_TO_C_XReparentEvent(ptr))->x = XEN_TO_C_INT(val);
  else if (XEN_XCreateWindowEvent_P(ptr)) (XEN_TO_C_XCreateWindowEvent(ptr))->x = XEN_TO_C_INT(val);
  else if (XEN_XGraphicsExposeEvent_P(ptr)) (XEN_TO_C_XGraphicsExposeEvent(ptr))->x = XEN_TO_C_INT(val);
  else if (XEN_XExposeEvent_P(ptr)) (XEN_TO_C_XExposeEvent(ptr))->x = XEN_TO_C_INT(val);
  else if (XEN_XCrossingEvent_P(ptr)) (XEN_TO_C_XCrossingEvent(ptr))->x = XEN_TO_C_INT(val);
  else if (XEN_XMotionEvent_P(ptr)) (XEN_TO_C_XMotionEvent(ptr))->x = XEN_TO_C_INT(val);
  else if (XEN_XButtonEvent_P(ptr)) (XEN_TO_C_XButtonEvent(ptr))->x = XEN_TO_C_INT(val);
  else if (XEN_XKeyEvent_P(ptr)) (XEN_TO_C_XKeyEvent(ptr))->x = XEN_TO_C_INT(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "x", "a struct with an x field");
  return(val);
}

static XEN gxm_set_y(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "y", "an integer");
  if (XEN_XRectangle_P(ptr)) (XEN_TO_C_XRectangle(ptr))->y = (short)XEN_TO_C_INT(val);
  else if (XEN_XPoint_P(ptr)) (XEN_TO_C_XPoint(ptr))->y = (short)XEN_TO_C_INT(val);
  else if (XEN_XArc_P(ptr)) (XEN_TO_C_XArc(ptr))->y = (short)XEN_TO_C_INT(val);
  else if (XEN_XConfigureRequestEvent_P(ptr)) (XEN_TO_C_XConfigureRequestEvent(ptr))->y = XEN_TO_C_INT(val);
  else if (XEN_XGravityEvent_P(ptr)) (XEN_TO_C_XGravityEvent(ptr))->y = XEN_TO_C_INT(val);
  else if (XEN_XConfigureEvent_P(ptr)) (XEN_TO_C_XConfigureEvent(ptr))->y = XEN_TO_C_INT(val);
  else if (XEN_XReparentEvent_P(ptr)) (XEN_TO_C_XReparentEvent(ptr))->y = XEN_TO_C_INT(val);
  else if (XEN_XCreateWindowEvent_P(ptr)) (XEN_TO_C_XCreateWindowEvent(ptr))->y = XEN_TO_C_INT(val);
  else if (XEN_XGraphicsExposeEvent_P(ptr)) (XEN_TO_C_XGraphicsExposeEvent(ptr))->y = XEN_TO_C_INT(val);
  else if (XEN_XExposeEvent_P(ptr)) (XEN_TO_C_XExposeEvent(ptr))->y = XEN_TO_C_INT(val);
  else if (XEN_XCrossingEvent_P(ptr)) (XEN_TO_C_XCrossingEvent(ptr))->y = XEN_TO_C_INT(val);
  else if (XEN_XMotionEvent_P(ptr)) (XEN_TO_C_XMotionEvent(ptr))->y = XEN_TO_C_INT(val);
  else if (XEN_XButtonEvent_P(ptr)) (XEN_TO_C_XButtonEvent(ptr))->y = XEN_TO_C_INT(val);
  else if (XEN_XKeyEvent_P(ptr)) (XEN_TO_C_XKeyEvent(ptr))->y = XEN_TO_C_INT(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "y", "a struct with a y field");
  return(val);
}

static XEN gxm_y(XEN ptr)
{
  if (XEN_XRectangle_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XRectangle(ptr))->y)));
  if (XEN_XPoint_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XPoint(ptr))->y)));
  if (XEN_XArc_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XArc(ptr))->y)));
  if (XEN_XWindowChanges_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XWindowChanges(ptr))->y)));
  if (XEN_XWindowAttributes_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XWindowAttributes(ptr))->y)));
#if HAVE_MOTIF
  if (XEN_XmDropProcCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDropProcCallbackStruct(ptr))->y)));
  if (XEN_XmDragProcCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDragProcCallbackStruct(ptr))->y)));
  if (XEN_XmDropStartCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDropStartCallbackStruct(ptr))->y)));
  if (XEN_XmDragMotionCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDragMotionCallbackStruct(ptr))->y)));
  if (XEN_XmDropSiteEnterCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDropSiteEnterCallbackStruct(ptr))->y)));
  if (XEN_XmTopLevelEnterCallbackStruct_P(ptr)) return(C_TO_XEN_Position((Position)((XEN_TO_C_XmTopLevelEnterCallbackStruct(ptr))->y)));
#endif
  if (XEN_XConfigureRequestEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XConfigureRequestEvent(ptr))->y)));
  if (XEN_XGravityEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XGravityEvent(ptr))->y)));
  if (XEN_XConfigureEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XConfigureEvent(ptr))->y)));
  if (XEN_XReparentEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XReparentEvent(ptr))->y)));
  if (XEN_XCreateWindowEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XCreateWindowEvent(ptr))->y)));
  if (XEN_XGraphicsExposeEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XGraphicsExposeEvent(ptr))->y)));
  if (XEN_XExposeEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XExposeEvent(ptr))->y)));
  if (XEN_XCrossingEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XCrossingEvent(ptr))->y)));
  if (XEN_XMotionEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XMotionEvent(ptr))->y)));
  if (XEN_XButtonEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XButtonEvent(ptr))->y)));
  if (XEN_XKeyEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XKeyEvent(ptr))->y)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "y", "a struct with a y field");
  return(XEN_FALSE);
}

static XEN gxm_x(XEN ptr)
{
  if (XEN_XRectangle_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XRectangle(ptr))->x)));
  if (XEN_XPoint_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XPoint(ptr))->x)));
  if (XEN_XArc_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XArc(ptr))->x)));
  if (XEN_XWindowChanges_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XWindowChanges(ptr))->x)));
  if (XEN_XWindowAttributes_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XWindowAttributes(ptr))->x)));
#if HAVE_MOTIF
  if (XEN_XmDropProcCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDropProcCallbackStruct(ptr))->x)));
  if (XEN_XmDragProcCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDragProcCallbackStruct(ptr))->x)));
  if (XEN_XmDropStartCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDropStartCallbackStruct(ptr))->x)));
  if (XEN_XmDragMotionCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDragMotionCallbackStruct(ptr))->x)));
  if (XEN_XmDropSiteEnterCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDropSiteEnterCallbackStruct(ptr))->x)));
  if (XEN_XmTopLevelEnterCallbackStruct_P(ptr)) return(C_TO_XEN_Position((Position)((XEN_TO_C_XmTopLevelEnterCallbackStruct(ptr))->x)));
#endif
  if (XEN_XConfigureRequestEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XConfigureRequestEvent(ptr))->x)));
  if (XEN_XGravityEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XGravityEvent(ptr))->x)));
  if (XEN_XConfigureEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XConfigureEvent(ptr))->x)));
  if (XEN_XReparentEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XReparentEvent(ptr))->x)));
  if (XEN_XCreateWindowEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XCreateWindowEvent(ptr))->x)));
  if (XEN_XGraphicsExposeEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XGraphicsExposeEvent(ptr))->x)));
  if (XEN_XExposeEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XExposeEvent(ptr))->x)));
  if (XEN_XCrossingEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XCrossingEvent(ptr))->x)));
  if (XEN_XMotionEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XMotionEvent(ptr))->x)));
  if (XEN_XButtonEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XButtonEvent(ptr))->x)));
  if (XEN_XKeyEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XKeyEvent(ptr))->x)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "x", "a struct with an x field");
  return(XEN_FALSE);
}

static XEN gxm_time(XEN ptr)
{
#if HAVE_MOTIF
  if (XEN_XmDestinationCallbackStruct_P(ptr)) return(C_TO_XEN_Time((Time)((XEN_TO_C_XmDestinationCallbackStruct(ptr))->time)));
#endif
  if (XEN_XSelectionEvent_P(ptr)) return(C_TO_XEN_Time((Time)((XEN_TO_C_XSelectionEvent(ptr))->time)));
  if (XEN_XSelectionRequestEvent_P(ptr)) return(C_TO_XEN_Time((Time)((XEN_TO_C_XSelectionRequestEvent(ptr))->time)));
  if (XEN_XSelectionClearEvent_P(ptr)) return(C_TO_XEN_Time((Time)((XEN_TO_C_XSelectionClearEvent(ptr))->time)));
  if (XEN_XPropertyEvent_P(ptr)) return(C_TO_XEN_Time((Time)((XEN_TO_C_XPropertyEvent(ptr))->time)));
  if (XEN_XCrossingEvent_P(ptr)) return(C_TO_XEN_Time((Time)((XEN_TO_C_XCrossingEvent(ptr))->time)));
  if (XEN_XMotionEvent_P(ptr)) return(C_TO_XEN_Time((Time)((XEN_TO_C_XMotionEvent(ptr))->time)));
  if (XEN_XButtonEvent_P(ptr)) return(C_TO_XEN_Time((Time)((XEN_TO_C_XButtonEvent(ptr))->time)));
  if (XEN_XKeyEvent_P(ptr)) return(C_TO_XEN_Time((Time)((XEN_TO_C_XKeyEvent(ptr))->time)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "time", "a struct with a time field");
  return(XEN_FALSE);
}

static XEN gxm_set_time(XEN ptr, XEN val)
{
  Time tm;
  XM_SET_FIELD_ASSERT_TYPE(XEN_Time_P(val), val, XEN_ARG_2, "time", "Time");
  tm = XEN_TO_C_Time(val);
  if (XEN_XSelectionEvent_P(ptr)) (XEN_TO_C_XSelectionEvent(ptr))->time = tm;
  else if (XEN_XSelectionRequestEvent_P(ptr)) (XEN_TO_C_XSelectionRequestEvent(ptr))->time = tm;
  else if (XEN_XSelectionClearEvent_P(ptr)) (XEN_TO_C_XSelectionClearEvent(ptr))->time = tm;
  else if (XEN_XPropertyEvent_P(ptr)) (XEN_TO_C_XPropertyEvent(ptr))->time = tm;
  else if (XEN_XCrossingEvent_P(ptr)) (XEN_TO_C_XCrossingEvent(ptr))->time = tm;
  else if (XEN_XMotionEvent_P(ptr)) (XEN_TO_C_XMotionEvent(ptr))->time = tm;
  else if (XEN_XButtonEvent_P(ptr)) (XEN_TO_C_XButtonEvent(ptr))->time = tm;
  else if (XEN_XKeyEvent_P(ptr)) (XEN_TO_C_XKeyEvent(ptr))->time = tm;
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "time", "a struct with a time field");
  return(val);
}

static XEN gxm_subwindow(XEN ptr)
{
  if (XEN_XCrossingEvent_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XCrossingEvent(ptr))->subwindow)));
  if (XEN_XMotionEvent_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XMotionEvent(ptr))->subwindow)));
  if (XEN_XButtonEvent_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XButtonEvent(ptr))->subwindow)));
  if (XEN_XKeyEvent_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XKeyEvent(ptr))->subwindow)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "subwindow", "a struct with a subwindow field");
  return(XEN_FALSE);
}

static XEN gxm_set_subwindow(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_Window_P(val), val, XEN_ARG_2, "subwindow", "a Window");
  if (XEN_XCrossingEvent_P(ptr)) (XEN_TO_C_XCrossingEvent(ptr))->subwindow = XEN_TO_C_Window(val);
  else if (XEN_XMotionEvent_P(ptr)) (XEN_TO_C_XMotionEvent(ptr))->subwindow = XEN_TO_C_Window(val);
  else if (XEN_XButtonEvent_P(ptr)) (XEN_TO_C_XButtonEvent(ptr))->subwindow = XEN_TO_C_Window(val);
  else if (XEN_XKeyEvent_P(ptr)) (XEN_TO_C_XKeyEvent(ptr))->subwindow = XEN_TO_C_Window(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "subwindow", "a struct with a subwindow field");
  return(val);
}

static XEN gxm_window(XEN ptr)
{
#if HAVE_MOTIF
  if (XEN_XmDrawnButtonCallbackStruct_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XmDrawnButtonCallbackStruct(ptr))->window)));
  if (XEN_XmDrawingAreaCallbackStruct_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XmDrawingAreaCallbackStruct(ptr))->window)));
  if (XEN_XmDropStartCallbackStruct_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XmDropStartCallbackStruct(ptr))->window)));
  if (XEN_XmTopLevelEnterCallbackStruct_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XmTopLevelEnterCallbackStruct(ptr))->window)));
  if (XEN_XmTopLevelLeaveCallbackStruct_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XmTopLevelLeaveCallbackStruct(ptr))->window)));
#endif
  if (XEN_XEvent_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XAnyEvent(ptr))->window)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "window", "a struct with a window field");
  return(XEN_FALSE);
}

static XEN gxm_set_window(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_Window_P(val), val, XEN_ARG_2, "window", "a Window");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XEvent_P(ptr), ptr, XEN_ARG_1, "window", "XEvent");
  (XEN_TO_C_XAnyEvent(ptr))->window = XEN_TO_C_Window(val);
  return(val);
}

static XEN gxm_send_event(XEN ptr)
{
  if (XEN_XEvent_P(ptr)) return(C_TO_XEN_BOOLEAN((Bool)((XEN_TO_C_XAnyEvent(ptr))->send_event)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "send_event", "XEvent");
  return(XEN_FALSE);
}

static XEN gxm_set_send_event(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_BOOLEAN_P(val), val, XEN_ARG_2, "send_event", "a boolean");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XEvent_P(ptr), ptr, XEN_ARG_1, "send_event", "XEvent");
  (XEN_TO_C_XAnyEvent(ptr))->send_event = (Bool)XEN_TO_C_BOOLEAN(val);
  return(val);
}

static XEN gxm_serial(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XEvent_P(ptr), ptr, XEN_ONLY_ARG, "serial", "XEvent");
  return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XAnyEvent(ptr))->serial)));
}

static XEN gxm_set_serial(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_XEvent_P(ptr), ptr, XEN_ARG_1, "serial", "XEvent");
  (XEN_TO_C_XAnyEvent(ptr))->serial = XEN_TO_C_ULONG(val);
  return(val);
}

static XEN gxm_type(XEN ptr)
{
#if HAVE_MOTIF
  if (XEN_XmSelectionCallbackStruct_P(ptr)) return(C_TO_XEN_Atom((Atom)((XEN_TO_C_XmSelectionCallbackStruct(ptr))->type)));
  if (XEN_XmConvertCallbackStruct_P(ptr)) return(C_TO_XEN_Atom((Atom)((XEN_TO_C_XmConvertCallbackStruct(ptr))->type)));
#endif
  if (XEN_XEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XAnyEvent(ptr))->type)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "type", "a struct with a type field");
  return(XEN_FALSE);
}

static XEN gxm_set_type(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_XEvent_P(ptr), ptr, XEN_ARG_1, "type", "XEvent");
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "type", "integer");
  (XEN_TO_C_XAnyEvent(ptr))->type = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_root_input_mask(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_Screen_P(ptr), ptr, XEN_ONLY_ARG, "root_input_mask", "Screen");
  return(C_TO_XEN_INT((long)((XEN_TO_C_Screen(ptr))->root_input_mask)));
}

static XEN gxm_save_unders(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_Screen_P(ptr), ptr, XEN_ONLY_ARG, "save_unders", "Screen");
  return(C_TO_XEN_BOOLEAN((Bool)((XEN_TO_C_Screen(ptr))->save_unders)));
}

static XEN gxm_backing_store(XEN ptr)
{
  if (XEN_XWindowAttributes_P(ptr)) return(C_TO_XEN_BOOLEAN((int)((XEN_TO_C_XWindowAttributes(ptr))->backing_store)));
  if (XEN_XSetWindowAttributes_P(ptr)) return(C_TO_XEN_BOOLEAN((int)((XEN_TO_C_XSetWindowAttributes(ptr))->backing_store)));
  if (XEN_Screen_P(ptr)) return(C_TO_XEN_BOOLEAN((int)((XEN_TO_C_Screen(ptr))->backing_store)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "backing_store", "a struct with a backing_store field");
  return(XEN_FALSE);
}

static XEN gxm_set_backing_store(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_XSetWindowAttributes_P(ptr) || XEN_XWindowAttributes_P(ptr) || XEN_Screen_P(ptr), 
			   ptr, XEN_ARG_1, "backing_store", "a struct with a backing_store field");
  XM_SET_FIELD_ASSERT_TYPE(XEN_BOOLEAN_P(val), val, XEN_ARG_2, "backing_store", "a Boolean");
  if (XEN_XWindowAttributes_P(ptr))
      (XEN_TO_C_XWindowAttributes(ptr))->backing_store = XEN_TO_C_BOOLEAN(val);
  else if (XEN_XSetWindowAttributes_P(ptr))
      (XEN_TO_C_XSetWindowAttributes(ptr))->backing_store = XEN_TO_C_BOOLEAN(val);
  else if (XEN_Screen_P(ptr))
      (XEN_TO_C_Screen(ptr))->backing_store = XEN_TO_C_BOOLEAN(val);
  return(val);
}

static XEN gxm_min_maps(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_Screen_P(ptr), ptr, XEN_ONLY_ARG, "min_maps", "Screen");
  return(C_TO_XEN_INT((int)((XEN_TO_C_Screen(ptr))->min_maps)));
}

static XEN gxm_max_maps(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_Screen_P(ptr), ptr, XEN_ONLY_ARG, "max_maps", "Screen");
  return(C_TO_XEN_INT((int)((XEN_TO_C_Screen(ptr))->max_maps)));
}

static XEN gxm_black_pixel(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_Screen_P(ptr), ptr, XEN_ONLY_ARG, "black_pixel", "Screen");
  return(C_TO_XEN_Pixel((XEN_TO_C_Screen(ptr))->black_pixel));
}

static XEN gxm_white_pixel(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_Screen_P(ptr), ptr, XEN_ONLY_ARG, "white_pixel", "Screen");
  return(C_TO_XEN_Pixel((XEN_TO_C_Screen(ptr))->white_pixel));
}

static XEN gxm_cmap(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_Screen_P(ptr), ptr, XEN_ONLY_ARG, "cmap", "Screen");
  return(C_TO_XEN_Colormap((Colormap)((XEN_TO_C_Screen(ptr))->cmap)));
}

static XEN gxm_default_gc(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_Screen_P(ptr), ptr, XEN_ONLY_ARG, "default_gc", "Screen");
  return(C_TO_XEN_GC((GC)((XEN_TO_C_Screen(ptr))->default_gc)));
}

static XEN gxm_root_visual(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_Screen_P(ptr), ptr, XEN_ONLY_ARG, "root_visual", "Screen");
  return(C_TO_XEN_Visual((Visual *)((XEN_TO_C_Screen(ptr))->root_visual)));
}

static XEN gxm_root_depth(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_Screen_P(ptr), ptr, XEN_ONLY_ARG, "root_depth", "Screen");
  return(C_TO_XEN_INT((int)((XEN_TO_C_Screen(ptr))->root_depth)));
}

static XEN gxm_depths(XEN ptr)
{
  Depth *dps;
  Screen *scr;
  int i, len;
  XEN lst = XEN_EMPTY_LIST;
  XM_FIELD_ASSERT_TYPE(XEN_Screen_P(ptr), ptr, XEN_ONLY_ARG, "depths", "Screen");
  scr = XEN_TO_C_Screen(ptr);
  len = scr->ndepths;
  if (len > 0)
    {
      dps = scr->depths;
      for (i = len - 1; i >= 0; i--)
	lst = XEN_CONS(WRAP_FOR_XEN("Depth", &(dps[i])), lst);
    }
  return(lst);
}

static XEN gxm_ndepths(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_Screen_P(ptr), ptr, XEN_ONLY_ARG, "ndepths", "Screen");
  return(C_TO_XEN_INT((int)((XEN_TO_C_Screen(ptr))->ndepths)));
}

static XEN gxm_mheight(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_Screen_P(ptr), ptr, XEN_ONLY_ARG, "mheight", "Screen");
  return(C_TO_XEN_INT((int)((XEN_TO_C_Screen(ptr))->mheight)));
}

static XEN gxm_mwidth(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_Screen_P(ptr), ptr, XEN_ONLY_ARG, "mwidth", "Screen");
  return(C_TO_XEN_INT((int)((XEN_TO_C_Screen(ptr))->mwidth)));
}


static XEN gxm_set_height(XEN ptr, XEN val)
{
  if (XEN_XRectangle_P(ptr)) (XEN_TO_C_XRectangle(ptr))->height = XEN_TO_C_INT(val);
  else if (XEN_XArc_P(ptr)) (XEN_TO_C_XArc(ptr))->height = XEN_TO_C_INT(val);
#if HAVE_XPM
  else if (XEN_XpmImage_P(ptr)) (XEN_TO_C_XpmImage(ptr))->height = XEN_TO_C_ULONG(val);
  else if (XEN_XpmAttributes_P(ptr)) (XEN_TO_C_XpmAttributes(ptr))->height = XEN_TO_C_ULONG(val);
#endif
  else if (XEN_XConfigureRequestEvent_P(ptr)) (XEN_TO_C_XConfigureRequestEvent(ptr))->height = XEN_TO_C_INT(val);
  else if (XEN_XResizeRequestEvent_P(ptr)) (XEN_TO_C_XResizeRequestEvent(ptr))->height = XEN_TO_C_INT(val);
  else if (XEN_XConfigureEvent_P(ptr)) (XEN_TO_C_XConfigureEvent(ptr))->height = XEN_TO_C_INT(val);
  else if (XEN_XCreateWindowEvent_P(ptr)) (XEN_TO_C_XCreateWindowEvent(ptr))->height = XEN_TO_C_INT(val);
  else if (XEN_XGraphicsExposeEvent_P(ptr)) (XEN_TO_C_XGraphicsExposeEvent(ptr))->height = XEN_TO_C_INT(val);
  else if (XEN_XExposeEvent_P(ptr)) (XEN_TO_C_XExposeEvent(ptr))->height = XEN_TO_C_INT(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "height", "a struct with a height field");
  return(val);
}

static XEN gxm_set_width(XEN ptr, XEN val)
{
  if (XEN_XRectangle_P(ptr)) (XEN_TO_C_XRectangle(ptr))->width = XEN_TO_C_INT(val);
  else if (XEN_XArc_P(ptr)) (XEN_TO_C_XArc(ptr))->width = XEN_TO_C_INT(val);
#if HAVE_XPM
  else if (XEN_XpmImage_P(ptr)) (XEN_TO_C_XpmImage(ptr))->width = XEN_TO_C_ULONG(val);
  else if (XEN_XpmAttributes_P(ptr)) (XEN_TO_C_XpmAttributes(ptr))->width = XEN_TO_C_ULONG(val);
#endif
  else if (XEN_XConfigureRequestEvent_P(ptr)) (XEN_TO_C_XConfigureRequestEvent(ptr))->width = XEN_TO_C_INT(val);
  else if (XEN_XResizeRequestEvent_P(ptr)) (XEN_TO_C_XResizeRequestEvent(ptr))->width = XEN_TO_C_INT(val);
  else if (XEN_XConfigureEvent_P(ptr)) (XEN_TO_C_XConfigureEvent(ptr))->width = XEN_TO_C_INT(val);
  else if (XEN_XCreateWindowEvent_P(ptr)) (XEN_TO_C_XCreateWindowEvent(ptr))->width = XEN_TO_C_INT(val);
  else if (XEN_XGraphicsExposeEvent_P(ptr)) (XEN_TO_C_XGraphicsExposeEvent(ptr))->width = XEN_TO_C_INT(val);
  else if (XEN_XExposeEvent_P(ptr)) (XEN_TO_C_XExposeEvent(ptr))->width = XEN_TO_C_INT(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "width", "a struct with a width field");
  return(val);
}

static XEN gxm_height(XEN ptr)
{
  if (XEN_XRectangle_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XRectangle(ptr))->height)));
  if (XEN_XArc_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XArc(ptr))->height)));
  if (XEN_XWindowChanges_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XWindowChanges(ptr))->height)));
  if (XEN_XImage_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XImage(ptr))->height)));
  if (XEN_XWindowAttributes_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XWindowAttributes(ptr))->height)));
  if (XEN_XConfigureRequestEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XConfigureRequestEvent(ptr))->height)));
  if (XEN_XResizeRequestEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XResizeRequestEvent(ptr))->height)));
  if (XEN_XConfigureEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XConfigureEvent(ptr))->height)));
  if (XEN_XCreateWindowEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XCreateWindowEvent(ptr))->height)));
  if (XEN_XGraphicsExposeEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XGraphicsExposeEvent(ptr))->height)));
  if (XEN_XExposeEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XExposeEvent(ptr))->height)));
  if (XEN_Screen_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_Screen(ptr))->height)));
#if HAVE_XPM
  if (XEN_XpmImage_P(ptr)) return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XpmImage(ptr))->height)));
  if (XEN_XpmAttributes_P(ptr)) return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XpmAttributes(ptr))->height)));
#endif
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "height", "a struct with a height field");
  return(XEN_FALSE);
}

static XEN gxm_width(XEN ptr)
{
  if (XEN_XRectangle_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XRectangle(ptr))->width)));
  if (XEN_XArc_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XArc(ptr))->width)));
  if (XEN_XWindowChanges_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XWindowChanges(ptr))->width)));
  if (XEN_XImage_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XImage(ptr))->width)));
  if (XEN_XWindowAttributes_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XWindowAttributes(ptr))->width)));
  if (XEN_XCharStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XCharStruct(ptr))->width)));
  if (XEN_XConfigureRequestEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XConfigureRequestEvent(ptr))->width)));
  if (XEN_XResizeRequestEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XResizeRequestEvent(ptr))->width)));
  if (XEN_XConfigureEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XConfigureEvent(ptr))->width)));
  if (XEN_XCreateWindowEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XCreateWindowEvent(ptr))->width)));
  if (XEN_XGraphicsExposeEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XGraphicsExposeEvent(ptr))->width)));
  if (XEN_XExposeEvent_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XExposeEvent(ptr))->width)));
  if (XEN_Screen_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_Screen(ptr))->width)));
#if HAVE_XPM
  if (XEN_XpmImage_P(ptr)) return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XpmImage(ptr))->width)));
  if (XEN_XpmAttributes_P(ptr)) return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XpmAttributes(ptr))->width)));
#endif
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "width", "a struct with a width field");
  return(XEN_FALSE);
}

static XEN gxm_root(XEN ptr)
{
  if (XEN_XWindowAttributes_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XWindowAttributes(ptr))->root)));
  if (XEN_XCrossingEvent_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XCrossingEvent(ptr))->root)));
  if (XEN_XMotionEvent_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XMotionEvent(ptr))->root)));
  if (XEN_XButtonEvent_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XButtonEvent(ptr))->root)));
  if (XEN_XKeyEvent_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_XKeyEvent(ptr))->root)));
  if (XEN_Screen_P(ptr)) return(C_TO_XEN_Window((Window)((XEN_TO_C_Screen(ptr))->root)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "root", "a struct with a root field");
  return(XEN_FALSE);
}

static XEN gxm_set_root(XEN ptr, XEN val)
{
  Window w;
  XM_SET_FIELD_ASSERT_TYPE(XEN_Window_P(val), val, XEN_ARG_2, "root", "a Window");
  w = XEN_TO_C_Window(val);
  if (XEN_XWindowAttributes_P(ptr)) (XEN_TO_C_XWindowAttributes(ptr))->root = w;
  else if (XEN_XCrossingEvent_P(ptr)) (XEN_TO_C_XCrossingEvent(ptr))->root = w;
  else if (XEN_XMotionEvent_P(ptr)) (XEN_TO_C_XMotionEvent(ptr))->root = w;
  else if (XEN_XButtonEvent_P(ptr)) (XEN_TO_C_XButtonEvent(ptr))->root = w;
  else if (XEN_XKeyEvent_P(ptr)) (XEN_TO_C_XKeyEvent(ptr))->root = w;
  else if (XEN_Screen_P(ptr)) (XEN_TO_C_Screen(ptr))->root = w;
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "root", "a struct with a root field");
  return(val);
}

static XEN gxm_display(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XEvent_P(ptr) || XEN_Screen_P(ptr), ptr, XEN_ONLY_ARG, "display", "XEvent or Screen");
  if (XEN_XEvent_P(ptr)) return(C_TO_XEN_Display((Display *)((XEN_TO_C_XAnyEvent(ptr))->display)));
  return(C_TO_XEN_Display((Display *)((XEN_TO_C_Screen(ptr))->display)));
}

static XEN gxm_set_display(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_Display_P(val), val, XEN_ARG_2, "display", "a Display*");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XEvent_P(ptr), ptr, XEN_ARG_1, "display", "XEvent");
  (XEN_TO_C_XAnyEvent(ptr))->display = XEN_TO_C_Display(val);
  return(val);
}

static XEN gxm_function(XEN ptr)
{
  if (XEN_XGCValues_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XGCValues(ptr))->function)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "function", "XGCValues");
  return(XEN_FALSE);
}

static XEN gxm_set_function(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "function", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ARG_1, "function", "XGCValues");
  (XEN_TO_C_XGCValues(ptr))->function = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_plane_mask(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ONLY_ARG, "plane_mask", "XGCValues");
  return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XGCValues(ptr))->plane_mask)));
}

static XEN gxm_set_plane_mask(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ARG_1, "plane_mask", "XGCValues");
  (XEN_TO_C_XGCValues(ptr))->plane_mask = XEN_TO_C_ULONG(val);
  return(val);
}

static XEN gxm_foreground(XEN ptr)
{
  if (XEN_XGCValues_P(ptr)) return(C_TO_XEN_Pixel((Pixel)((XEN_TO_C_XGCValues(ptr))->foreground)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "foreground", "a struct with a foreground field");
  return(XEN_FALSE);
}

static XEN gxm_set_foreground(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_Pixel_P(val), val, XEN_ARG_2, "foreground", "a Pixel");  
  XM_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ARG_1, "foreground", "XGCValues");
  (XEN_TO_C_XGCValues(ptr))->foreground = XEN_TO_C_Pixel(val);
  return(val);
}

static XEN gxm_background(XEN ptr)
{
  if (XEN_XGCValues_P(ptr)) return(C_TO_XEN_Pixel((Pixel)((XEN_TO_C_XGCValues(ptr))->background)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "background", "a struct with a background field");
  return(XEN_FALSE);
}

static XEN gxm_set_background(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_Pixel_P(val), val, XEN_ARG_2, "background", "a Pixel");  
  XM_SET_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ARG_1, "background", "XGCValues");
  (XEN_TO_C_XGCValues(ptr))->background = XEN_TO_C_Pixel(val);
  return(val);
}

static XEN gxm_line_width(XEN ptr)
{
  if (XEN_XGCValues_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XGCValues(ptr))->line_width)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "line_width", "XGCValues");
  return(XEN_FALSE);
}

static XEN gxm_set_line_width(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "line_width", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ARG_1, "line_width", "XGCValues");
  (XEN_TO_C_XGCValues(ptr))->line_width = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_line_style(XEN ptr)
{
  if (XEN_XGCValues_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XGCValues(ptr))->line_style)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "line_style", "XGCValues");
  return(XEN_FALSE);
}

static XEN gxm_set_line_style(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "line_style", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ARG_1, "line_style", "XGCValues");
  (XEN_TO_C_XGCValues(ptr))->line_style = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_cap_style(XEN ptr)
{
  if (XEN_XGCValues_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XGCValues(ptr))->cap_style)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "cap_style", "XGCValues");
  return(XEN_FALSE);
}

static XEN gxm_set_cap_style(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "cap_style", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ARG_1, "cap_style", "XGCValues");
  (XEN_TO_C_XGCValues(ptr))->cap_style = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_join_style(XEN ptr)
{
  if (XEN_XGCValues_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XGCValues(ptr))->join_style)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "join_style", "XGCValues");
  return(XEN_FALSE);
}

static XEN gxm_set_join_style(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "join_style", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ARG_1, "join_style", "XGCValues");
  (XEN_TO_C_XGCValues(ptr))->join_style = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_fill_style(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ONLY_ARG, "fill_style", "XGCValues");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XGCValues(ptr))->fill_style)));
}

static XEN gxm_set_fill_style(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "fill_style", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ARG_1, "fill_style", "XGCValues");
  (XEN_TO_C_XGCValues(ptr))->fill_style = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_fill_rule(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ONLY_ARG, "fill_rule", "XGCValues");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XGCValues(ptr))->fill_rule)));
}

static XEN gxm_set_fill_rule(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "fill_rule", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ARG_1, "fill_rule", "XGCValues");
  (XEN_TO_C_XGCValues(ptr))->fill_rule = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_arc_mode(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ONLY_ARG, "arc_mode", "XGCValues");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XGCValues(ptr))->arc_mode)));
}

static XEN gxm_set_arc_mode(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "arc_mode", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ARG_1, "arc_mode", "XGCValues");
  (XEN_TO_C_XGCValues(ptr))->arc_mode = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_tile(XEN ptr)
{
  if (XEN_XGCValues_P(ptr)) return(C_TO_XEN_Pixmap((Pixmap)((XEN_TO_C_XGCValues(ptr))->tile)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "tile", "XGCValues");
  return(XEN_FALSE);
}

static XEN gxm_set_tile(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_Pixmap_P(val), val, XEN_ARG_2, "tile", "a Pixmap");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ARG_1, "tile", "XGCValues");
  (XEN_TO_C_XGCValues(ptr))->tile = XEN_TO_C_Pixmap(val);
  return(val);
}

static XEN gxm_stipple(XEN ptr)
{
  if (XEN_XGCValues_P(ptr)) return(C_TO_XEN_Pixmap((Pixmap)((XEN_TO_C_XGCValues(ptr))->stipple)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "stipple", "XGCValues");
  return(XEN_FALSE);
}

static XEN gxm_set_stipple(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_Pixmap_P(val), val, XEN_ARG_2, "stipple", "a Pixmap");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ARG_1, "stipple", "XGCValues");
  (XEN_TO_C_XGCValues(ptr))->stipple = XEN_TO_C_Pixmap(val);
  return(val);
}

static XEN gxm_ts_x_origin(XEN ptr)
{
  if (XEN_XGCValues_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XGCValues(ptr))->ts_x_origin)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "ts_x_origin", "XGCValues");
  return(XEN_FALSE);
}

static XEN gxm_set_ts_x_origin(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "ts_x_origin", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ARG_1, "ts_x_origin", "XGCValues");
  (XEN_TO_C_XGCValues(ptr))->ts_x_origin = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_ts_y_origin(XEN ptr)
{
  if (XEN_XGCValues_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XGCValues(ptr))->ts_y_origin)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "ts_y_origin", "XGCValues");
  return(XEN_FALSE);
}

static XEN gxm_set_ts_y_origin(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "ts_y_origin", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ARG_1, "ts_y_origin", "XGCValues");
  (XEN_TO_C_XGCValues(ptr))->ts_y_origin = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_font(XEN ptr)
{
  if (XEN_XGCValues_P(ptr)) return(C_TO_XEN_Font((Font)((XEN_TO_C_XGCValues(ptr))->font)));
  if (XEN_XTextItem_P(ptr)) return(C_TO_XEN_Font((Font)((XEN_TO_C_XTextItem(ptr))->font)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "font", "a struct with a font field");
  return(XEN_FALSE);
}

static XEN gxm_set_font(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_Font_P(val), val, XEN_ARG_2, "font", "a font");
  if (XEN_XGCValues_P(ptr)) (XEN_TO_C_XGCValues(ptr))->font = XEN_TO_C_Font(val);
  else if (XEN_XTextItem_P(ptr)) (XEN_TO_C_XTextItem(ptr))->font = XEN_TO_C_Font(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "font", "a struct with a font field");
  return(val);
}

static XEN gxm_subwindow_mode(XEN ptr)
{
  if (XEN_XGCValues_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XGCValues(ptr))->subwindow_mode)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "subwindow_mode", "XGCValues");
  return(XEN_FALSE);
}

static XEN gxm_set_subwindow_mode(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "subwindow_mode", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ARG_1, "subwindow_mode", "XGCValues");
  (XEN_TO_C_XGCValues(ptr))->subwindow_mode = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_graphics_exposures(XEN ptr)
{
  if (XEN_XGCValues_P(ptr)) return(C_TO_XEN_BOOLEAN((Bool)((XEN_TO_C_XGCValues(ptr))->graphics_exposures)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "graphics_exposures", "XGCValues");
  return(XEN_FALSE);
}

static XEN gxm_set_graphics_exposures(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_BOOLEAN_P(val), val, XEN_ARG_2, "graphics_exposures", "a boolean");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ARG_1, "graphics_exposure", "XGCValues");
  (XEN_TO_C_XGCValues(ptr))->graphics_exposures = XEN_TO_C_BOOLEAN(val);
  return(val);
}

static XEN gxm_clip_x_origin(XEN ptr)
{
  if (XEN_XGCValues_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XGCValues(ptr))->clip_x_origin)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "clip_x_origin", "XGCValues");
  return(XEN_FALSE);
}

static XEN gxm_set_clip_x_origin(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "clip_x_origin", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ARG_1, "clip_x_origin", "XGCValues");
  (XEN_TO_C_XGCValues(ptr))->clip_x_origin = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_clip_y_origin(XEN ptr)
{
  if (XEN_XGCValues_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XGCValues(ptr))->clip_y_origin)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "clip_y_origin", "XGCValues");
  return(XEN_FALSE);
}

static XEN gxm_set_clip_y_origin(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "clip_y_origin", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ARG_1, "clip_y_origin", "XGCValues");
  (XEN_TO_C_XGCValues(ptr))->clip_y_origin = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_clip_mask(XEN ptr)
{
  if (XEN_XGCValues_P(ptr)) return(C_TO_XEN_Pixmap((Pixmap)((XEN_TO_C_XGCValues(ptr))->clip_mask)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "clip_mask", "XGCValues");
  return(XEN_FALSE);
}

static XEN gxm_set_clip_mask(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_Pixmap_P(val), val, XEN_ARG_2, "clip_mask", "a Pixmap");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ARG_1, "clip_mask", "XGCValues");
  (XEN_TO_C_XGCValues(ptr))->clip_mask = XEN_TO_C_Pixmap(val);
  return(val);
}

static XEN gxm_dash_offset(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ONLY_ARG, "dash_offset", "XGCValues");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XGCValues(ptr))->dash_offset)));
}

static XEN gxm_set_dash_offset(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "dash_offset", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ARG_1, "dash_offset", "XGCValues");
  (XEN_TO_C_XGCValues(ptr))->dash_offset = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_dashes(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ONLY_ARG, "dashes", "XGCValues");
  return(C_TO_XEN_char((char)((XEN_TO_C_XGCValues(ptr))->dashes)));
}

static XEN gxm_set_dashes(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_XGCValues_P(ptr), ptr, XEN_ARG_1, "dashes", "XGCValues");
  (XEN_TO_C_XGCValues(ptr))->dashes = XEN_TO_C_char(val);
  return(val);
}


static XEN gxm_killid(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XStandardColormap_P(ptr), ptr, XEN_ONLY_ARG, "killid", "XStandardColormap");
  return(C_TO_XEN_INT((long)((XEN_TO_C_XStandardColormap(ptr))->killid)));
}

static XEN gxm_base_pixel(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XStandardColormap_P(ptr), ptr, XEN_ONLY_ARG, "base_pixel", "XStandardColormap");
  return(C_TO_XEN_Pixel((unsigned long)((XEN_TO_C_XStandardColormap(ptr))->base_pixel)));
}

static XEN gxm_blue_mult(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XStandardColormap_P(ptr), ptr, XEN_ONLY_ARG, "blue_mult", "XStandardColormap");
  return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XStandardColormap(ptr))->blue_mult)));
}

static XEN gxm_blue_max(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XStandardColormap_P(ptr), ptr, XEN_ONLY_ARG, "blue_max", "XStandardColormap");
  return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XStandardColormap(ptr))->blue_max)));
}

static XEN gxm_green_mult(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XStandardColormap_P(ptr), ptr, XEN_ONLY_ARG, "green_mult", "XStandardColormap");
  return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XStandardColormap(ptr))->green_mult)));
}

static XEN gxm_green_max(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XStandardColormap_P(ptr), ptr, XEN_ONLY_ARG, "green_max", "XStandardColormap");
  return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XStandardColormap(ptr))->green_max)));
}

static XEN gxm_red_mult(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XStandardColormap_P(ptr), ptr, XEN_ONLY_ARG, "red_mult", "XStandardColormap");
  return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XStandardColormap(ptr))->red_mult)));
}

static XEN gxm_red_max(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XStandardColormap_P(ptr), ptr, XEN_ONLY_ARG, "red_max", "XStandardColormap");
  return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XStandardColormap(ptr))->red_max)));
}

static XEN gxm_XTextItem(XEN chars, XEN nchars, XEN delta, XEN font)
{
  XTextItem *r;
  #define H_XTextItem "(XTextItem chars len delta font) -> new XTextItem struct"
  XEN_ASSERT_TYPE(XEN_STRING_P(chars), chars, 1, "XTextItem", "char*");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(nchars), nchars, 2, "XTextItem", "int");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(delta), delta, 3, "XTextItem", "int");
  XEN_ASSERT_TYPE(XEN_Font_P(font), font, 4, "XTextItem", "Font");
  r = (XTextItem *)CALLOC(1, sizeof(XTextItem));
  r->chars = XEN_TO_C_STRING(chars);
  r->nchars = XEN_TO_C_INT(nchars);
  r->delta = XEN_TO_C_INT(delta);
  r->font = XEN_TO_C_Font(font);
  return(xen_return_first(WRAP_FOR_XEN_OBJ("XTextItem", (XTextItem *)r), chars));
}

static XEN gxm_chars(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XTextItem_P(ptr), ptr, XEN_ONLY_ARG, "chars", "XTextItem");
  return(C_TO_XEN_STRING((char *)((XEN_TO_C_XTextItem(ptr))->chars)));
}

static XEN gxm_set_chars(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_STRING_P(val), val, XEN_ARG_2, "chars", "a string");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XTextItem_P(ptr), ptr, XEN_ARG_1, "chars", "XTextItem");
  (XEN_TO_C_XTextItem(ptr))->chars = strdup(XEN_TO_C_STRING(val));
  return(val);
}

static XEN gxm_nchars(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XTextItem_P(ptr), ptr, XEN_ONLY_ARG, "nchars", "XTextItem");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XTextItem(ptr))->nchars)));
}

static XEN gxm_set_nchars(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "nchars", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XTextItem_P(ptr), ptr, XEN_ARG_1, "nchars", "XTextItem");
  (XEN_TO_C_XTextItem(ptr))->nchars = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_delta(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XTextItem_P(ptr), ptr, XEN_ONLY_ARG, "delta", "XTextItem");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XTextItem(ptr))->delta)));
}

static XEN gxm_set_delta(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "delta", "an integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XTextItem_P(ptr), ptr, XEN_ARG_1, "delta", "XTextItem");
  (XEN_TO_C_XTextItem(ptr))->delta = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_data(XEN ptr)
{
  if (XEN_XImage_P(ptr)) return(C_TO_XEN_STRING((char *)((XEN_TO_C_XImage(ptr))->data)));
  if (XEN_XClientMessageEvent_P(ptr)) return(C_TO_XEN_STRING((char *)((XEN_TO_C_XClientMessageEvent(ptr))->data.b)));
#if HAVE_MOTIF
  if (XEN_XmRowColumnCallbackStruct_P(ptr)) return(C_TO_XEN_STRING((char *)((XEN_TO_C_XmRowColumnCallbackStruct(ptr))->data)));
#endif
#if HAVE_XPM
  if (XEN_XpmImage_P(ptr)) return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XpmImage(ptr))->data)));
#endif
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "data", "XpmImage");
  return(XEN_FALSE);
}

static XEN gxm_set_data(XEN ptr, XEN val)
{
  int i, len = 0;
  char *str;
  XM_SET_FIELD_ASSERT_TYPE(XEN_STRING_P(val) || XEN_LIST_P(val), val, XEN_ARG_2, "data", "a string or a list of longs");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XClientMessageEvent_P(ptr), ptr, XEN_ARG_1, "data", "XClientMessageEvent");
  if (XEN_STRING_P(val))
    {
      str = XEN_TO_C_STRING(val);
      if (str)
	len = strlen(str);
      if (len > 19) len = 19;
      for (i = 0; i < len; i++)
	(XEN_TO_C_XClientMessageEvent(ptr))->data.b[i] = str[i];
    }
  else
    {
      int i, len;
      len = XEN_LIST_LENGTH(val);
      if (len > 5) len = 5;  /* only room here for 5 ints */
      for (i = 0; i < len; i++)
	(XEN_TO_C_XClientMessageEvent(ptr))->data.l[i] = XEN_TO_C_INT(XEN_LIST_REF(val, i));
    }
  return(val);
}



/* -------------------------------------------------------------------------------- */
#if HAVE_MOTIF
static XEN gxm_text(XEN ptr)
{
  /* DIFF: TextVerifyCallbackStruct text field returns list (string format)
   */
  XmTextBlock tb;
  if (XEN_XmTextVerifyCallbackStruct_P(ptr)) 
    {
      tb = (XmTextBlock)(XEN_TO_C_XmTextVerifyCallbackStruct(ptr))->text;
      if ((tb) && (tb->length > 0))
	return(XEN_LIST_2(C_TO_XEN_STRING(tb->ptr),
			  C_TO_XEN_ULONG(tb->format)));
      return(XEN_FALSE);
    }
#if HAVE_XmCreateDataField
    else if (XEN_XmDataFieldCallbackStruct_P(ptr)) return(C_TO_XEN_STRING((XEN_TO_C_XmDataFieldCallbackStruct(ptr))->text));
#endif
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "text", "an XmTextVerifyCallbackStruct");
  return(XEN_FALSE);
}

#if HAVE_XmCreateDataField
static XEN gxm_w(XEN ptr)
{
  if (XEN_XmDataFieldCallbackStruct_P(ptr)) return(C_TO_XEN_Widget((Widget)((XEN_TO_C_XmDataFieldCallbackStruct(ptr))->w)));
  return(XEN_FALSE);
}
static XEN gxm_accept(XEN ptr)
{
  if (XEN_XmDataFieldCallbackStruct_P(ptr)) return(C_TO_XEN_BOOLEAN((XEN_TO_C_XmDataFieldCallbackStruct(ptr))->accept));
  return(XEN_FALSE);
}
#endif
#if HAVE_XmCreateTabStack
static XEN gxm_selected_child(XEN ptr)
{
  if (XEN_XmTabStackCallbackStruct_P(ptr)) return(C_TO_XEN_Widget((XEN_TO_C_XmTabStackCallbackStruct(ptr))->selected_child));
  return(XEN_FALSE);
}
#endif

static XEN gxm_endPos(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmTextVerifyCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "endPos", "XmTextVerifyCallbackStruct");
  return(C_TO_XEN_INT((long)((XEN_TO_C_XmTextVerifyCallbackStruct(ptr))->endPos)));
}

static XEN gxm_startPos(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmTextVerifyCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "startPos", "XmTextVerifyCallbackStruct");
  return(C_TO_XEN_INT((long)((XEN_TO_C_XmTextVerifyCallbackStruct(ptr))->startPos)));
}

static XEN gxm_newInsert(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmTextVerifyCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "newInsert", "XmTextVerifyCallbackStruct");
  return(C_TO_XEN_INT((long)((XEN_TO_C_XmTextVerifyCallbackStruct(ptr))->newInsert)));
}

static XEN gxm_currInsert(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmTextVerifyCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "currInsert", "XmTextVerifyCallbackStruct");
  return(C_TO_XEN_INT((long)((XEN_TO_C_XmTextVerifyCallbackStruct(ptr))->currInsert)));
}

static XEN gxm_crossed_boundary(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmSpinBoxCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "crossed_boundary", "XmSpinBoxCallbackStruct");
  return(C_TO_XEN_BOOLEAN((Boolean)((XEN_TO_C_XmSpinBoxCallbackStruct(ptr))->crossed_boundary)));
}

static XEN gxm_position(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmSpinBoxCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "position", "XmSpinBoxCallbackStruct");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XmSpinBoxCallbackStruct(ptr))->position)));
}

#if HAVE_XM_XP
static XEN gxm_last_page(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmPrintShellCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "last_page", "XmPrintShellCallbackStruct");
  return(C_TO_XEN_BOOLEAN((Boolean)((XEN_TO_C_XmPrintShellCallbackStruct(ptr))->last_page)));
}
#endif

static XEN gxm_tag(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmDisplayCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "tag", "XmDisplayCallbackStruct");
  return(C_TO_XEN_STRING((XmStringTag)((XEN_TO_C_XmDisplayCallbackStruct(ptr))->tag)));
}

static XEN gxm_render_table(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmDisplayCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "render_table", "XmDisplayCallbackStruct");
  return(C_TO_XEN_XmRenderTable((XmRenderTable)((XEN_TO_C_XmDisplayCallbackStruct(ptr))->render_table)));
}

static XEN gxm_font_name(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmDisplayCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "font_name", "XmDisplayCallbackStruct");
  return(C_TO_XEN_STRING((char *)((XEN_TO_C_XmDisplayCallbackStruct(ptr))->font_name)));
}

static XEN gxm_rendition(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmDisplayCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "rendition", "XmDisplayCallbackStruct");
  return(C_TO_XEN_XmRendition((XmRendition)((XEN_TO_C_XmDisplayCallbackStruct(ptr))->rendition)));
}

static XEN gxm_prev_page_widget(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmNotebookCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "prev_page_widget", "XmNotebookCallbackStruct");
  return(C_TO_XEN_Widget((Widget)((XEN_TO_C_XmNotebookCallbackStruct(ptr))->prev_page_widget)));
}

static XEN gxm_prev_page_number(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmNotebookCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "prev_page_number", "XmNotebookCallbackStruct");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XmNotebookCallbackStruct(ptr))->prev_page_number)));
}

static XEN gxm_new_outline_state(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmContainerOutlineCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "new_outline_state", "XmContainerOutlineCallbackStruct");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XmContainerOutlineCallbackStruct(ptr))->new_outline_state)));
}

static XEN gxm_postIt(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmPopupHandlerCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "postIt", "XmPopupHandlerCallbackStruct");
  return(C_TO_XEN_BOOLEAN((Boolean)((XEN_TO_C_XmPopupHandlerCallbackStruct(ptr))->postIt)));
}

static XEN gxm_menuToPost(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmPopupHandlerCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "menuToPost", "XmPopupHandlerCallbackStruct");
  return(C_TO_XEN_Widget((Widget)((XEN_TO_C_XmPopupHandlerCallbackStruct(ptr))->menuToPost)));
}

static XEN gxm_set_postIt(XEN ptr, XEN post)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_BOOLEAN_P(post), post, XEN_ARG_2, "postIt", "a boolean");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XmPopupHandlerCallbackStruct_P(ptr), ptr, XEN_ARG_1, "postIt", "XmPopupHandler");
  (XEN_TO_C_XmPopupHandlerCallbackStruct(ptr))->postIt = XEN_TO_C_BOOLEAN(post);
  return(post);
}

static XEN gxm_set_menuToPost(XEN ptr, XEN menu)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_Widget_P(menu), menu, XEN_ARG_2, "menuToPost", "a Widget");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XmPopupHandlerCallbackStruct_P(ptr), ptr, XEN_ARG_1, "menuToPost", "XmPopupHandler");
  (XEN_TO_C_XmPopupHandlerCallbackStruct(ptr))->menuToPost = (Widget)XEN_TO_C_Widget(menu);
  return(menu);
}

static XEN gxm_pattern_length(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmFileSelectionBoxCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "pattern_length", "XmFileSelectionBoxCallbackStruct");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XmFileSelectionBoxCallbackStruct(ptr))->pattern_length)));
}

static XEN gxm_pattern(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmFileSelectionBoxCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "pattern", "XmFileSelectionBoxCallbackStruct");
  return(C_TO_XEN_XmString((XmString)((XEN_TO_C_XmFileSelectionBoxCallbackStruct(ptr))->pattern)));
}

static XEN gxm_dir_length(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmFileSelectionBoxCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "dir_length", "XmFileSelectionBoxCallbackStruct");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XmFileSelectionBoxCallbackStruct(ptr))->dir_length)));
}

static XEN gxm_dir(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmFileSelectionBoxCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "dir", "XmFileSelectionBoxCallbackStruct");
  return(C_TO_XEN_XmString((XmString)((XEN_TO_C_XmFileSelectionBoxCallbackStruct(ptr))->dir)));
}

static XEN gxm_mask_length(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmFileSelectionBoxCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "mask_length", "XmFileSelectionBoxCallbackStruct");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XmFileSelectionBoxCallbackStruct(ptr))->mask_length)));
}

static XEN gxm_mask(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmFileSelectionBoxCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "mask", "XmFileSelectionBoxCallbackStruct");
  return(C_TO_XEN_XmString((XmString)((XEN_TO_C_XmFileSelectionBoxCallbackStruct(ptr))->mask)));
}

static XEN gxm_auto_selection_type(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmContainerSelectCallbackStruct_P(ptr) || XEN_XmListCallbackStruct_P(ptr), 
		  ptr, XEN_ONLY_ARG, "auto_selection_type", "a struct with an auto_selection_type field");
  if (XEN_XmContainerSelectCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmContainerSelectCallbackStruct(ptr))->auto_selection_type)));
  return(C_TO_XEN_char((char)((XEN_TO_C_XmListCallbackStruct(ptr))->auto_selection_type)));
}

static XEN gxm_selection_type(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmListCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "selection_type", "XmListCallbackStruct");
  return(C_TO_XEN_char((char)((XEN_TO_C_XmListCallbackStruct(ptr))->selection_type)));
}

static XEN gxm_selected_item_positions(XEN ptr)
{
  /* DIFF: selected_item_positions is a list of ints
   */
  if (XEN_XmListCallbackStruct_P(ptr)) 
    return(C_TO_XEN_Ints((int *)((XEN_TO_C_XmListCallbackStruct(ptr))->selected_item_positions),
			 ((int)((XEN_TO_C_XmListCallbackStruct(ptr))->selected_item_count))));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "selected_item_positions", "a struct with a selected_item_positions field");
  return(XEN_FALSE);
}

static XEN gxm_selected_item_count(XEN ptr)
{
  if (XEN_XmContainerSelectCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmContainerSelectCallbackStruct(ptr))->selected_item_count)));
  if (XEN_XmListCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmListCallbackStruct(ptr))->selected_item_count)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "selected_item_count", "XmListCallbackStruct");
  return(XEN_FALSE);
}

static XEN gxm_selected_items(XEN ptr)
{
  /* DIFF selected_items field returns list
   */
  if (XEN_XmContainerSelectCallbackStruct_P(ptr)) 
    return(C_TO_XEN_Widgets((WidgetList)((XEN_TO_C_XmContainerSelectCallbackStruct(ptr))->selected_items),
			    (XEN_TO_C_XmContainerSelectCallbackStruct(ptr))->selected_item_count));
  if (XEN_XmListCallbackStruct_P(ptr)) 
    return(C_TO_XEN_XmStringTable((XmStringTable)((XEN_TO_C_XmListCallbackStruct(ptr))->selected_items),
				  (XEN_TO_C_XmListCallbackStruct(ptr))->selected_item_count));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "selected_items", "a struct with a selected_items field");
  return(XEN_FALSE);
}

static XEN gxm_item_length(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmListCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "item_length", "XmListCallbackStruct");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XmListCallbackStruct(ptr))->item_length)));
}

static XEN gxm_item(XEN ptr)
{
  if (XEN_XmContainerOutlineCallbackStruct_P(ptr)) return(C_TO_XEN_Widget((Widget)((XEN_TO_C_XmContainerOutlineCallbackStruct(ptr))->item)));
  if (XEN_XmListCallbackStruct_P(ptr)) return(C_TO_XEN_XmString((XmString)((XEN_TO_C_XmListCallbackStruct(ptr))->item)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "item", "XmListCallbackStruct");
  return(XEN_FALSE);
}

/* in Motif 2, this field is an int: XmSET to XmINDETERMINATE -- should we change? */
static XEN gxm_set(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmToggleButtonCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "set", "XmToggleButtonCallbackStruct");
  return(C_TO_XEN_BOOLEAN((int)((XEN_TO_C_XmToggleButtonCallbackStruct(ptr))->set)));
}

static XEN gxm_set_set(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_BOOLEAN_P(val) || XEN_INTEGER_P(val), val, XEN_ARG_2, "set", "a boolean");
  XM_SET_FIELD_ASSERT_TYPE(XEN_XmToggleButtonCallbackStruct_P(ptr), ptr, XEN_ARG_1, "set", "XmToggleButtonCallbackStruct");
  (XEN_TO_C_XmToggleButtonCallbackStruct(ptr))->set = XEN_TO_C_BOOLEAN(val);
  return(val);
}

static XEN gxm_callbackstruct(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmRowColumnCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "callbackstruct", "XmRowColumnCallbackStruct");
  return(C_TO_XEN_STRING((char *)((XEN_TO_C_XmRowColumnCallbackStruct(ptr))->callbackstruct)));
}

static XEN gxm_item_position(XEN ptr)
{
  if (XEN_XmListCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmListCallbackStruct(ptr))->item_position)));
  if (XEN_XmComboBoxCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmComboBoxCallbackStruct(ptr))->item_position)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "item_position", "a struct with an item_position field");
  return(XEN_FALSE);
}

static XEN gxm_item_or_text(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmComboBoxCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "item_or_text", "XmComboBoxCallbackStruct");
  return(C_TO_XEN_XmString((XmString)((XEN_TO_C_XmComboBoxCallbackStruct(ptr))->item_or_text)));
}

static XEN gxm_doit(XEN ptr)
{
  if (XEN_XmTextVerifyCallbackStruct_P(ptr)) return(C_TO_XEN_BOOLEAN((Boolean)((XEN_TO_C_XmTextVerifyCallbackStruct(ptr))->doit)));
  if (XEN_XmSpinBoxCallbackStruct_P(ptr)) return(C_TO_XEN_BOOLEAN((Boolean)((XEN_TO_C_XmSpinBoxCallbackStruct(ptr))->doit)));
  if (XEN_XmDragStartCallbackStruct_P(ptr)) return(C_TO_XEN_BOOLEAN((Boolean)((XEN_TO_C_XmDragStartCallbackStruct(ptr))->doit)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "doit", "a struct with a doit field");
  return(XEN_FALSE);
}

static XEN gxm_set_doit(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_BOOLEAN_P(val), val, XEN_ARG_2, "doit", "a boolean");
  if (XEN_XmTextVerifyCallbackStruct_P(ptr)) (XEN_TO_C_XmTextVerifyCallbackStruct(ptr))->doit = XEN_TO_C_BOOLEAN(val);
  else if (XEN_XmSpinBoxCallbackStruct_P(ptr)) (XEN_TO_C_XmSpinBoxCallbackStruct(ptr))->doit = XEN_TO_C_BOOLEAN(val);
  else if (XEN_XmDragStartCallbackStruct_P(ptr)) (XEN_TO_C_XmDragStartCallbackStruct(ptr))->doit = XEN_TO_C_BOOLEAN(val);
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "doit", "a struct with a doit field");
  return(val);
}

static XEN gxm_widget(XEN ptr)
{
  if (XEN_XmSpinBoxCallbackStruct_P(ptr)) return(C_TO_XEN_Widget((Widget)((XEN_TO_C_XmSpinBoxCallbackStruct(ptr))->widget)));
  if (XEN_XmDragStartCallbackStruct_P(ptr)) return(C_TO_XEN_Widget((Widget)((XEN_TO_C_XmDragStartCallbackStruct(ptr))->widget)));
  if (XEN_XmRowColumnCallbackStruct_P(ptr)) return(C_TO_XEN_Widget((Widget)((XEN_TO_C_XmRowColumnCallbackStruct(ptr))->widget)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "widget", "a struct with a widget field");
  return(XEN_FALSE);
}

static XEN gxm_click_count(XEN ptr)
{
  if (XEN_XmPushButtonCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmPushButtonCallbackStruct(ptr))->click_count)));
  if (XEN_XmDrawnButtonCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDrawnButtonCallbackStruct(ptr))->click_count)));
  if (XEN_XmArrowButtonCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmArrowButtonCallbackStruct(ptr))->click_count)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "click_count", "a struct with a click_count field");
  return(XEN_FALSE);
}

static XEN gxm_set_click_count(XEN ptr, XEN val)
{
  int count;
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "click_count", "int");
  count = XEN_TO_C_INT(val);
  if (XEN_XmPushButtonCallbackStruct_P(ptr)) (XEN_TO_C_XmPushButtonCallbackStruct(ptr))->click_count = count;
  else if (XEN_XmDrawnButtonCallbackStruct_P(ptr)) (XEN_TO_C_XmDrawnButtonCallbackStruct(ptr))->click_count = count;
  else if (XEN_XmArrowButtonCallbackStruct_P(ptr)) (XEN_TO_C_XmArrowButtonCallbackStruct(ptr))->click_count = count;
  else XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "click_count", "a struct with a click_count field");
  return(val);
}

static XEN gxm_remaining(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmSelectionCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "remaining", "XmSelectionCallbackStruct");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XmSelectionCallbackStruct(ptr))->remaining)));
}

static XEN gxm_destination_data(XEN ptr)
{
  /* widget-class specific interpretation -- is it worth untangling? */
  XM_FIELD_ASSERT_TYPE(XEN_XmDestinationCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "destination_data", "XmDestinationCallbackStruct");
  return(C_TO_XEN_ULONG(((XEN_TO_C_XmDestinationCallbackStruct(ptr))->destination_data)));
}

static XEN gxm_transfer_id(XEN ptr)
{
  if (XEN_XmTransferDoneCallbackStruct_P(ptr)) return(C_TO_XEN_ULONG(((XEN_TO_C_XmTransferDoneCallbackStruct(ptr))->transfer_id)));
  if (XEN_XmSelectionCallbackStruct_P(ptr)) return(C_TO_XEN_ULONG(((XEN_TO_C_XmSelectionCallbackStruct(ptr))->transfer_id)));
  if (XEN_XmDestinationCallbackStruct_P(ptr)) return(C_TO_XEN_ULONG(((XEN_TO_C_XmDestinationCallbackStruct(ptr))->transfer_id)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "transfer_id", "a struct with a transfer_id field");
  return(XEN_FALSE);
}

static XEN gxm_length(XEN ptr)
{
  if (XEN_XmFileSelectionBoxCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmFileSelectionBoxCallbackStruct(ptr))->length)));
  if (XEN_XmCommandCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmCommandCallbackStruct(ptr))->length)));
  if (XEN_XmTextBlock_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmTextBlock(ptr))->length)));
  if (XEN_XmSelectionBoxCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmSelectionBoxCallbackStruct(ptr))->length)));
  if (XEN_XmSelectionCallbackStruct_P(ptr)) return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XmSelectionCallbackStruct(ptr))->length)));
  if (XEN_XmConvertCallbackStruct_P(ptr)) return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XmConvertCallbackStruct(ptr))->length)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "length", "a struct with a length field");
  return(XEN_FALSE);
}

static XEN gxm_set_length(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_XmTextBlock_P(ptr), ptr, XEN_ARG_1, "length", "XmTextBlock");
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "length", "int");
  (XEN_TO_C_XmTextBlock(ptr))->length = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_ptr(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmTextBlock_P(ptr), ptr, XEN_ARG_1, "ptr", "XmTextBlock");
  return(C_TO_XEN_STRING((XEN_TO_C_XmTextBlock(ptr))->ptr));
}

static XEN gxm_set_ptr(XEN pt, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_XmTextBlock_P(pt), pt, XEN_ARG_1, "ptr", "XmTextBlock");
  XM_SET_FIELD_ASSERT_TYPE(XEN_STRING_P(val), val, XEN_ARG_2, "length", "char*");
  (XEN_TO_C_XmTextBlock(pt))->ptr = strdup(XEN_TO_C_STRING(val));
  return(val);
}

static XEN gxm_value(XEN ptr)
{
  if (XEN_XmSpinBoxCallbackStruct_P(ptr)) return(C_TO_XEN_XmString((XmString)((XEN_TO_C_XmSpinBoxCallbackStruct(ptr))->value)));
  if (XEN_XmSelectionBoxCallbackStruct_P(ptr)) return(C_TO_XEN_XmString((XmString)((XEN_TO_C_XmSelectionBoxCallbackStruct(ptr))->value)));
  if (XEN_XmConvertCallbackStruct_P(ptr)) return(C_TO_XEN_ULONG((XtPointer)((XEN_TO_C_XmConvertCallbackStruct(ptr))->value)));
  if (XEN_XmSelectionCallbackStruct_P(ptr)) return(C_TO_XEN_ULONG((XtPointer)((XEN_TO_C_XmSelectionCallbackStruct(ptr))->value)));
  if (XEN_XmScaleCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmScaleCallbackStruct(ptr))->value)));
  if (XEN_XmFileSelectionBoxCallbackStruct_P(ptr)) return(C_TO_XEN_XmString((XmString)((XEN_TO_C_XmFileSelectionBoxCallbackStruct(ptr))->value)));
  if (XEN_XmCommandCallbackStruct_P(ptr)) return(C_TO_XEN_XmString((XmString)((XEN_TO_C_XmCommandCallbackStruct(ptr))->value)));
  if (XEN_XmScrollBarCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmScrollBarCallbackStruct(ptr))->value)));
#if HAVE_XPM
  if (XEN_XpmColorSymbol_P(ptr)) return(C_TO_XEN_STRING((char *)((XEN_TO_C_XpmColorSymbol(ptr))->value)));
#endif
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "value", "a struct with a value field");
  return(XEN_FALSE);
}

static XEN gxm_set_value(XEN ptr, XEN val)
{
#if HAVE_MOTIF
  if (XEN_XmScaleCallbackStruct_P(ptr)) (XEN_TO_C_XmScaleCallbackStruct(ptr))->value = XEN_TO_C_INT(val); else
  if (XEN_XmFileSelectionBoxCallbackStruct_P(ptr)) (XEN_TO_C_XmFileSelectionBoxCallbackStruct(ptr))->value = XEN_TO_C_XmString(val); else
  if (XEN_XmCommandCallbackStruct_P(ptr)) (XEN_TO_C_XmCommandCallbackStruct(ptr))->value = XEN_TO_C_XmString(val); else
  if (XEN_XmScrollBarCallbackStruct_P(ptr)) (XEN_TO_C_XmScrollBarCallbackStruct(ptr))->value = XEN_TO_C_INT(val); else
  if (XEN_XmConvertCallbackStruct_P(ptr)) (XEN_TO_C_XmConvertCallbackStruct(ptr))->value = (XtPointer)XEN_TO_C_ULONG(val); else
  if (XEN_XmSpinBoxCallbackStruct_P(ptr)) (XEN_TO_C_XmSpinBoxCallbackStruct(ptr))->value = XEN_TO_C_XmString(val); else
  if (XEN_XmSelectionBoxCallbackStruct_P(ptr)) (XEN_TO_C_XmSelectionBoxCallbackStruct(ptr))->value = XEN_TO_C_XmString(val); else
  if (XEN_XmSelectionCallbackStruct_P(ptr)) (XEN_TO_C_XmSelectionCallbackStruct(ptr))->value = (XtPointer)XEN_TO_C_ULONG(val); else
#endif    
#if HAVE_XPM
  if (XEN_XpmColorSymbol_P(ptr)) (XEN_TO_C_XpmColorSymbol(ptr))->value = strdup(XEN_TO_C_STRING(val)); else
#endif
  XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "value", "a struct with a value field");
  return(val);
}

static XEN gxm_status(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmTransferDoneCallbackStruct_P(ptr) || XEN_XmConvertCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "status", "a struct with a status field");
  if (XEN_XmTransferDoneCallbackStruct_P(ptr)) return(C_TO_XEN_INT((XmTransferStatus)((XEN_TO_C_XmTransferDoneCallbackStruct(ptr))->status)));
  return(C_TO_XEN_INT((int)((XEN_TO_C_XmConvertCallbackStruct(ptr))->status)));
}

static XEN gxm_parm_type(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmConvertCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "parm_type", "XmConvertCallbackStruct");
  return(C_TO_XEN_Atom((Atom)((XEN_TO_C_XmConvertCallbackStruct(ptr))->parm_type)));
}

static XEN gxm_parm_length(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmConvertCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "parm_length", "XmConvertCallbackStruct");
  return(C_TO_XEN_ULONG((unsigned long)((XEN_TO_C_XmConvertCallbackStruct(ptr))->parm_length)));
}

static XEN gxm_parm_format(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmConvertCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "parm_format", "XmConvertCallbackStruct");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XmConvertCallbackStruct(ptr))->parm_format)));
}

static XEN gxm_parm(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmConvertCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "parm", "XmConvertCallbackStruct");
  return(C_TO_XEN_ULONG((XtPointer)((XEN_TO_C_XmConvertCallbackStruct(ptr))->parm)));
}

static XEN gxm_location_data(XEN ptr)
{
  /* widget-class specific interpretation -- is it worth untangling? */
  XM_FIELD_ASSERT_TYPE(XEN_XmDestinationCallbackStruct_P(ptr) || XEN_XmConvertCallbackStruct_P(ptr), 
		  ptr, XEN_ONLY_ARG, "location_data", "a struct with a location_data field");
  if (XEN_XmDestinationCallbackStruct_P(ptr)) return(C_TO_XEN_ULONG((XtPointer)((XEN_TO_C_XmDestinationCallbackStruct(ptr))->location_data)));
  return(C_TO_XEN_ULONG((XtPointer)((XEN_TO_C_XmConvertCallbackStruct(ptr))->location_data)));
}

static XEN gxm_source_data(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmConvertCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "source_data", "XmConvertCallbackStruct");
  return(C_TO_XEN_ULONG((XtPointer)((XEN_TO_C_XmConvertCallbackStruct(ptr))->source_data)));
}

static XEN gxm_client_data(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmTransferDoneCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "client_data", "XmTransferDoneCallbackStruct");
  return(C_TO_XEN_ULONG((XtPointer)((XEN_TO_C_XmTransferDoneCallbackStruct(ptr))->client_data)));
}

static XEN gxm_animate(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmDragProcCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "animate", "XmDragProcCallbackStruct");
  return(C_TO_XEN_BOOLEAN((Boolean)((XEN_TO_C_XmDragProcCallbackStruct(ptr))->animate)));
}

static XEN gxm_dragContext(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmDropProcCallbackStruct_P(ptr) || XEN_XmDragProcCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "dragContext", "a struct with a dragContext field");
  if (XEN_XmDropProcCallbackStruct_P(ptr)) return(C_TO_XEN_Widget((Widget)((XEN_TO_C_XmDropProcCallbackStruct(ptr))->dragContext)));
  return(C_TO_XEN_Widget((Widget)((XEN_TO_C_XmDragProcCallbackStruct(ptr))->dragContext)));
}

static XEN gxm_completionStatus(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmDropFinishCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "completionStatus", "XmDropFinishCallbackStruct");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XmDropFinishCallbackStruct(ptr))->completionStatus)));
}

static XEN gxm_iccHandle(XEN ptr)
{
  if (XEN_XmDropStartCallbackStruct_P(ptr)) return(C_TO_XEN_Atom((Atom)((XEN_TO_C_XmDropStartCallbackStruct(ptr))->iccHandle)));
  if (XEN_XmTopLevelEnterCallbackStruct_P(ptr)) return(C_TO_XEN_Atom((Atom)((XEN_TO_C_XmTopLevelEnterCallbackStruct(ptr))->iccHandle)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "iccHandle", "a struct with an iccHandle field");
  return(XEN_FALSE);
}

static XEN gxm_dropAction(XEN ptr)
{
  if (XEN_XmDropProcCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDropProcCallbackStruct(ptr))->dropAction)));
  if (XEN_XmDropFinishCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDropFinishCallbackStruct(ptr))->dropAction)));
  if (XEN_XmDropStartCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDropStartCallbackStruct(ptr))->dropAction)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "dropAction", "a struct with a dropAction field");
  return(XEN_FALSE);
}

static XEN gxm_dropSiteStatus(XEN ptr)
{
  if (XEN_XmDropProcCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDropProcCallbackStruct(ptr))->dropSiteStatus)));
  if (XEN_XmDragProcCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDragProcCallbackStruct(ptr))->dropSiteStatus)));
  if (XEN_XmDropFinishCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDropFinishCallbackStruct(ptr))->dropSiteStatus)));
  if (XEN_XmDropStartCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDropStartCallbackStruct(ptr))->dropSiteStatus)));
  if (XEN_XmOperationChangedCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmOperationChangedCallbackStruct(ptr))->dropSiteStatus)));
  if (XEN_XmDragMotionCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDragMotionCallbackStruct(ptr))->dropSiteStatus)));
  if (XEN_XmDropSiteEnterCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDropSiteEnterCallbackStruct(ptr))->dropSiteStatus)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "dropSiteStatus", "a struct with a dropSiteStatus field");
  return(XEN_FALSE);
}

static XEN gxm_set_dropSiteStatus(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "dropSiteStatus", "an integer");
  if (XEN_XmDropProcCallbackStruct_P(ptr)) (XEN_TO_C_XmDropProcCallbackStruct(ptr))->dropSiteStatus = XEN_TO_C_INT(val); else
  if (XEN_XmDragProcCallbackStruct_P(ptr)) (XEN_TO_C_XmDragProcCallbackStruct(ptr))->dropSiteStatus = XEN_TO_C_INT(val); else
  if (XEN_XmDropFinishCallbackStruct_P(ptr)) (XEN_TO_C_XmDropFinishCallbackStruct(ptr))->dropSiteStatus = XEN_TO_C_INT(val); else
  if (XEN_XmDropStartCallbackStruct_P(ptr)) (XEN_TO_C_XmDropStartCallbackStruct(ptr))->dropSiteStatus = XEN_TO_C_INT(val); else
  if (XEN_XmOperationChangedCallbackStruct_P(ptr)) (XEN_TO_C_XmOperationChangedCallbackStruct(ptr))->dropSiteStatus = XEN_TO_C_INT(val); else
  if (XEN_XmDragMotionCallbackStruct_P(ptr)) (XEN_TO_C_XmDragMotionCallbackStruct(ptr))->dropSiteStatus = XEN_TO_C_INT(val); else
  if (XEN_XmDropSiteEnterCallbackStruct_P(ptr)) (XEN_TO_C_XmDropSiteEnterCallbackStruct(ptr))->dropSiteStatus = XEN_TO_C_INT(val); else
  XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "dropSiteStatus", "a struct with a dropSiteStatus field");
  return(val);
}

static XEN gxm_operations(XEN ptr)
{
  if (XEN_XmDropProcCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDropProcCallbackStruct(ptr))->operations)));
  if (XEN_XmDragProcCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDragProcCallbackStruct(ptr))->operations)));
  if (XEN_XmDropFinishCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDropFinishCallbackStruct(ptr))->operations)));
  if (XEN_XmDropStartCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDropStartCallbackStruct(ptr))->operations)));
  if (XEN_XmOperationChangedCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmOperationChangedCallbackStruct(ptr))->operations)));
  if (XEN_XmDragMotionCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDragMotionCallbackStruct(ptr))->operations)));
  if (XEN_XmDropSiteEnterCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDropSiteEnterCallbackStruct(ptr))->operations)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "operations", "a struct with an operations field");
  return(XEN_FALSE);
}

static XEN gxm_operation(XEN ptr)
{
  if (XEN_XmDestinationCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDestinationCallbackStruct(ptr))->operation)));
  if (XEN_XmDropProcCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDropProcCallbackStruct(ptr))->operation)));
  if (XEN_XmDragProcCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDragProcCallbackStruct(ptr))->operation)));
  if (XEN_XmDropFinishCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDropFinishCallbackStruct(ptr))->operation)));
  if (XEN_XmDropStartCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDropStartCallbackStruct(ptr))->operation)));
  if (XEN_XmOperationChangedCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmOperationChangedCallbackStruct(ptr))->operation)));
  if (XEN_XmDragMotionCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDragMotionCallbackStruct(ptr))->operation)));
  if (XEN_XmDropSiteEnterCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmDropSiteEnterCallbackStruct(ptr))->operation)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "operation", "a struct with an operation field");
  return(XEN_FALSE);
}

static XEN gxm_set_operation(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "operation", "an integer");
  if (XEN_XmDestinationCallbackStruct_P(ptr)) (XEN_TO_C_XmDestinationCallbackStruct(ptr))->operation = XEN_TO_C_INT(val); else
  if (XEN_XmDropProcCallbackStruct_P(ptr)) (XEN_TO_C_XmDropProcCallbackStruct(ptr))->operation = XEN_TO_C_INT(val); else
  if (XEN_XmDragProcCallbackStruct_P(ptr)) (XEN_TO_C_XmDragProcCallbackStruct(ptr))->operation = XEN_TO_C_INT(val); else
  if (XEN_XmDropFinishCallbackStruct_P(ptr)) (XEN_TO_C_XmDropFinishCallbackStruct(ptr))->operation = XEN_TO_C_INT(val); else
  if (XEN_XmDropStartCallbackStruct_P(ptr)) (XEN_TO_C_XmDropStartCallbackStruct(ptr))->operation = XEN_TO_C_INT(val); else
  if (XEN_XmOperationChangedCallbackStruct_P(ptr)) (XEN_TO_C_XmOperationChangedCallbackStruct(ptr))->operation = XEN_TO_C_INT(val); else
  if (XEN_XmDragMotionCallbackStruct_P(ptr)) (XEN_TO_C_XmDragMotionCallbackStruct(ptr))->operation = XEN_TO_C_INT(val); else
  if (XEN_XmDropSiteEnterCallbackStruct_P(ptr)) (XEN_TO_C_XmDropSiteEnterCallbackStruct(ptr))->operation = XEN_TO_C_INT(val); else
  XM_SET_FIELD_ASSERT_TYPE(0, ptr, XEN_ARG_1, "operation", "a struct with an operation field");
  return(val);
}

static XEN gxm_timeStamp(XEN ptr)
{
  if (XEN_XmDropProcCallbackStruct_P(ptr)) return(C_TO_XEN_Time((Time)((XEN_TO_C_XmDropProcCallbackStruct(ptr))->timeStamp)));
  if (XEN_XmDragProcCallbackStruct_P(ptr)) return(C_TO_XEN_Time((Time)((XEN_TO_C_XmDragProcCallbackStruct(ptr))->timeStamp)));
  if (XEN_XmDragDropFinishCallbackStruct_P(ptr)) return(C_TO_XEN_Time((Time)((XEN_TO_C_XmDragDropFinishCallbackStruct(ptr))->timeStamp)));
  if (XEN_XmDropFinishCallbackStruct_P(ptr)) return(C_TO_XEN_Time((Time)((XEN_TO_C_XmDropFinishCallbackStruct(ptr))->timeStamp)));
  if (XEN_XmDropStartCallbackStruct_P(ptr)) return(C_TO_XEN_Time((Time)((XEN_TO_C_XmDropStartCallbackStruct(ptr))->timeStamp)));
  if (XEN_XmOperationChangedCallbackStruct_P(ptr)) return(C_TO_XEN_Time((Time)((XEN_TO_C_XmOperationChangedCallbackStruct(ptr))->timeStamp)));
  if (XEN_XmDragMotionCallbackStruct_P(ptr)) return(C_TO_XEN_Time((Time)((XEN_TO_C_XmDragMotionCallbackStruct(ptr))->timeStamp)));
  if (XEN_XmDropSiteLeaveCallbackStruct_P(ptr)) return(C_TO_XEN_Time((Time)((XEN_TO_C_XmDropSiteLeaveCallbackStruct(ptr))->timeStamp)));
  if (XEN_XmDropSiteEnterCallbackStruct_P(ptr)) return(C_TO_XEN_Time((Time)((XEN_TO_C_XmDropSiteEnterCallbackStruct(ptr))->timeStamp)));
  if (XEN_XmTopLevelEnterCallbackStruct_P(ptr)) return(C_TO_XEN_Time((Time)((XEN_TO_C_XmTopLevelEnterCallbackStruct(ptr))->timeStamp)));
  if (XEN_XmTopLevelLeaveCallbackStruct_P(ptr)) return(C_TO_XEN_Time((Time)((XEN_TO_C_XmTopLevelLeaveCallbackStruct(ptr))->timeStamp)));
  XM_FIELD_ASSERT_TYPE(0, ptr, XEN_ONLY_ARG, "timeStamp", "a struct with a timeStamp field");
  return(XEN_FALSE);
}

static XEN gxm_reason(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_AnyCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "reason", "a callbackstruct");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XmAnyCallbackStruct(ptr))->reason)));
}

static XEN gxm_set_reason(XEN ptr, XEN val)
{
  XM_SET_FIELD_ASSERT_TYPE(XEN_INTEGER_P(val), val, XEN_ARG_2, "reason", "integer");
  XM_SET_FIELD_ASSERT_TYPE(XEN_AnyCallbackStruct_P(ptr), ptr, XEN_ARG_1, "reason", "a callbackstruct");
  (XEN_TO_C_XmAnyCallbackStruct(ptr))->reason = XEN_TO_C_INT(val);
  return(val);
}

static XEN gxm_direction(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmTraverseObscuredCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "direction", "XmTraverseObscuredCallbackStruct");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XmTraverseObscuredCallbackStruct(ptr))->direction)));
}

static XEN gxm_dragProtocolStyle(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmTopLevelEnterCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "dragProtocolStyle", "XmTopLevelEnterCallbackStruct");
  return(C_TO_XEN_INT((int)((XEN_TO_C_XmTopLevelEnterCallbackStruct(ptr))->dragProtocolStyle)));
}

static XEN gxm_traversal_destination(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmTraverseObscuredCallbackStruct_P(ptr), ptr, XEN_ONLY_ARG, "traversal_destination", "XmTraverseObscuredCallbackStruct");
  return(C_TO_XEN_Widget((Widget)((XEN_TO_C_XmTraverseObscuredCallbackStruct(ptr))->traversal_destination)));
}

static XEN gxm_minor_tab_widget(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmNotebookPageInfo_P(ptr), ptr, XEN_ONLY_ARG, "minor_tab_widget", "XmNotebookPageInfo");
  return(C_TO_XEN_Widget((Widget)((XEN_TO_C_XmNotebookPageInfo(ptr))->minor_tab_widget)));
}

static XEN gxm_major_tab_widget(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmNotebookPageInfo_P(ptr), ptr, XEN_ONLY_ARG, "major_tab_widget", "XmNotebookPageInfo");
  return(C_TO_XEN_Widget((Widget)((XEN_TO_C_XmNotebookPageInfo(ptr))->major_tab_widget)));
}

static XEN gxm_status_area_widget(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmNotebookPageInfo_P(ptr), ptr, XEN_ONLY_ARG, "status_area_widget", "XmNotebookPageInfo");
  return(C_TO_XEN_Widget((Widget)((XEN_TO_C_XmNotebookPageInfo(ptr))->status_area_widget)));
}

static XEN gxm_page_widget(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmNotebookCallbackStruct_P(ptr) || XEN_XmNotebookPageInfo_P(ptr), ptr, XEN_ONLY_ARG, "page_widget", "a struct with a page_widget field");
  if (XEN_XmNotebookCallbackStruct_P(ptr)) return(C_TO_XEN_Widget((Widget)((XEN_TO_C_XmNotebookCallbackStruct(ptr))->page_widget)));
  return(C_TO_XEN_Widget((Widget)((XEN_TO_C_XmNotebookPageInfo(ptr))->page_widget)));
}

static XEN gxm_page_number(XEN ptr)
{
  XM_FIELD_ASSERT_TYPE(XEN_XmNotebookCallbackStruct_P(ptr) || XEN_XmNotebookPageInfo_P(ptr), ptr, XEN_ONLY_ARG, "page_number", "a struct with a page_number field");
  if (XEN_XmNotebookCallbackStruct_P(ptr)) return(C_TO_XEN_INT((int)((XEN_TO_C_XmNotebookCallbackStruct(ptr))->page_number)));
  return(C_TO_XEN_INT((int)((XEN_TO_C_XmNotebookPageInfo(ptr))->page_number)));
}
#endif
/* HAVE_MOTIF */


#ifdef XEN_ARGIFY_1
#if HAVE_XM_XP
  XEN_NARGIFY_2(gxm_XpStartPage_w, gxm_XpStartPage)
  XEN_NARGIFY_1(gxm_XpEndPage_w, gxm_XpEndPage)
  XEN_NARGIFY_2(gxm_XpCancelPage_w, gxm_XpCancelPage)
  XEN_NARGIFY_2(gxm_XpStartJob_w, gxm_XpStartJob)
  XEN_NARGIFY_1(gxm_XpEndJob_w, gxm_XpEndJob)
  XEN_NARGIFY_2(gxm_XpCancelJob_w, gxm_XpCancelJob)
  XEN_NARGIFY_2(gxm_XpStartDoc_w, gxm_XpStartDoc)
  XEN_NARGIFY_1(gxm_XpEndDoc_w, gxm_XpEndDoc)
  XEN_NARGIFY_2(gxm_XpCancelDoc_w, gxm_XpCancelDoc)
  XEN_NARGIFY_1(gxm_XpRehashPrinterList_w, gxm_XpRehashPrinterList)
  XEN_NARGIFY_2(gxm_XpCreateContext_w, gxm_XpCreateContext)
  XEN_NARGIFY_2(gxm_XpSetContext_w, gxm_XpSetContext)
  XEN_NARGIFY_1(gxm_XpGetContext_w, gxm_XpGetContext)
  XEN_NARGIFY_2(gxm_XpDestroyContext_w, gxm_XpDestroyContext)
  XEN_NARGIFY_0(gxm_XpGetLocaleNetString_w, gxm_XpGetLocaleNetString)
  XEN_NARGIFY_6(gxm_XpNotifyPdm_w, gxm_XpNotifyPdm)
  XEN_NARGIFY_2(gxm_XpSendAuth_w, gxm_XpSendAuth)
  XEN_NARGIFY_2(gxm_XpGetImageResolution_w, gxm_XpGetImageResolution)
  XEN_NARGIFY_3(gxm_XpGetAttributes_w, gxm_XpGetAttributes)
  XEN_NARGIFY_5(gxm_XpSetAttributes_w, gxm_XpSetAttributes)
  XEN_NARGIFY_4(gxm_XpGetOneAttribute_w, gxm_XpGetOneAttribute)
  XEN_NARGIFY_2(gxm_XpGetScreenOfContext_w, gxm_XpGetScreenOfContext)
  XEN_NARGIFY_1(gxm_XpFreePrinterList_w, gxm_XpFreePrinterList)
  XEN_NARGIFY_1(gxm_XpQueryVersion_w, gxm_XpQueryVersion)
  XEN_NARGIFY_1(gxm_XpQueryExtension_w, gxm_XpQueryExtension)
  XEN_NARGIFY_1(gxm_XpQueryScreens_w, gxm_XpQueryScreens)
  XEN_NARGIFY_5(gxm_XpGetPdmStartParams_w, gxm_XpGetPdmStartParams)
  XEN_NARGIFY_2(gxm_XpGetAuthParams_w, gxm_XpGetAuthParams)
  XEN_NARGIFY_4(gxm_XpSendOneTicket_w, gxm_XpSendOneTicket)
  XEN_NARGIFY_2(gxm_XpGetPageDimensions_w, gxm_XpGetPageDimensions)
  XEN_NARGIFY_4(gxm_XpSetImageResolution_w, gxm_XpSetImageResolution)
  XEN_NARGIFY_2(gxm_XpGetPrinterList_w, gxm_XpGetPrinterList)
  XEN_NARGIFY_3(gxm_XpSelectInput_w, gxm_XpSelectInput)
  XEN_NARGIFY_3(gxm_XpInputSelected_w, gxm_XpInputSelected)
  XEN_NARGIFY_6(gxm_XpPutDocumentData_w, gxm_XpPutDocumentData)
  XEN_NARGIFY_5(gxm_XpGetDocumentData_w, gxm_XpGetDocumentData)
#endif
#if HAVE_MOTIF
#if (!XM_DISABLE_DEPRECATED)
  XEN_NARGIFY_1(gxm_XtWarning_w, gxm_XtWarning)
  XEN_NARGIFY_2(gxm_XtAppWarning_w, gxm_XtAppWarning)
  XEN_NARGIFY_1(gxm_XtSetWarningMsgHandler_w, gxm_XtSetWarningMsgHandler)
  XEN_NARGIFY_4(gxm_XtInitialize_w, gxm_XtInitialize)
  XEN_NARGIFY_1(gxm_XtSetWarningHandler_w, gxm_XtSetWarningHandler)
  XEN_NARGIFY_1(gxm_XtError_w, gxm_XtError)
  XEN_NARGIFY_6(gxm_XtErrorMsg_w, gxm_XtErrorMsg)
  XEN_NARGIFY_6(gxm_XtWarningMsg_w, gxm_XtWarningMsg)
  XEN_NARGIFY_1(gxm_XtSetErrorMsgHandler_w, gxm_XtSetErrorMsgHandler)
  XEN_NARGIFY_1(gxm_XtSetErrorHandler_w, gxm_XtSetErrorHandler)
  XEN_ARGIFY_4(gxm_XtCreateApplicationShell_w, gxm_XtCreateApplicationShell)
  XEN_NARGIFY_1(gxm_XtSetSelectionTimeout_w, gxm_XtSetSelectionTimeout)
  XEN_NARGIFY_0(gxm_XtGetSelectionTimeout_w, gxm_XtGetSelectionTimeout)
  XEN_NARGIFY_1(gxm_XtAddActions_w, gxm_XtAddActions)
  XEN_ARGIFY_4(gxm_XtAddInput_w, gxm_XtAddInput)
  XEN_ARGIFY_2(gxm_XtAddWorkProc_w, gxm_XtAddWorkProc)
  XEN_ARGIFY_3(gxm_XtAddTimeOut_w, gxm_XtAddTimeOut)
  XEN_NARGIFY_0(gxm_XtMainLoop_w, gxm_XtMainLoop)
  XEN_NARGIFY_1(gxm_XtProcessEvent_w, gxm_XtProcessEvent)
  XEN_NARGIFY_0(gxm_XtPending_w, gxm_XtPending)
  XEN_NARGIFY_0(gxm_XtNextEvent_w, gxm_XtNextEvent)
  XEN_NARGIFY_0(gxm_XtPeekEvent_w, gxm_XtPeekEvent)
#endif
  XEN_NARGIFY_3(gxm_XtSetArg_w, gxm_XtSetArg)
  XEN_ARGIFY_2(gxm_XtManageChildren_w, gxm_XtManageChildren)
  XEN_NARGIFY_1(gxm_XtManageChild_w, gxm_XtManageChild)
  XEN_ARGIFY_2(gxm_XtUnmanageChildren_w, gxm_XtUnmanageChildren)
  XEN_NARGIFY_1(gxm_XtUnmanageChild_w, gxm_XtUnmanageChild)
  XEN_NARGIFY_1(gxm_XtDispatchEvent_w, gxm_XtDispatchEvent)
  XEN_NARGIFY_2(gxm_XtCallAcceptFocus_w, gxm_XtCallAcceptFocus)
  XEN_NARGIFY_1(gxm_XtAppPeekEvent_w, gxm_XtAppPeekEvent)
  XEN_NARGIFY_2(gxm_XtIsSubclass_w, gxm_XtIsSubclass)
  XEN_NARGIFY_2(gxm_XtAppSetFallbackResources_w, gxm_XtAppSetFallbackResources)
  XEN_NARGIFY_1(gxm_XtIsObject_w, gxm_XtIsObject)
  XEN_NARGIFY_1(gxm_XtIsManaged_w, gxm_XtIsManaged)
  XEN_NARGIFY_1(gxm_XtIsRealized_w, gxm_XtIsRealized)
  XEN_NARGIFY_1(gxm_XtIsSensitive_w, gxm_XtIsSensitive)
  XEN_NARGIFY_6(gxm_XtOwnSelection_w, gxm_XtOwnSelection)
  XEN_NARGIFY_8(gxm_XtOwnSelectionIncremental_w, gxm_XtOwnSelectionIncremental)
  XEN_NARGIFY_3(gxm_XtMakeResizeRequest_w, gxm_XtMakeResizeRequest)
  XEN_NARGIFY_3(gxm_XtTranslateCoords_w, gxm_XtTranslateCoords)
  XEN_NARGIFY_2(gxm_XtKeysymToKeycodeList_w, gxm_XtKeysymToKeycodeList)
  XEN_NARGIFY_1(gxm_XtParseTranslationTable_w, gxm_XtParseTranslationTable)
  XEN_NARGIFY_1(gxm_XtParseAcceleratorTable_w, gxm_XtParseAcceleratorTable)
  XEN_NARGIFY_2(gxm_XtOverrideTranslations_w, gxm_XtOverrideTranslations)
  XEN_NARGIFY_2(gxm_XtAugmentTranslations_w, gxm_XtAugmentTranslations)
  XEN_NARGIFY_2(gxm_XtInstallAccelerators_w, gxm_XtInstallAccelerators)
  XEN_NARGIFY_2(gxm_XtInstallAllAccelerators_w, gxm_XtInstallAllAccelerators)
  XEN_NARGIFY_1(gxm_XtUninstallTranslations_w, gxm_XtUninstallTranslations)
  XEN_NARGIFY_2(gxm_XtAppAddActions_w, gxm_XtAppAddActions)
  XEN_ARGIFY_3(gxm_XtAppAddActionHook_w, gxm_XtAppAddActionHook)
  XEN_NARGIFY_1(gxm_XtRemoveActionHook_w, gxm_XtRemoveActionHook)
  XEN_NARGIFY_1(gxm_XtGetActionList_w, gxm_XtGetActionList)
  XEN_ARGIFY_5(gxm_XtCallActionProc_w, gxm_XtCallActionProc)
  XEN_NARGIFY_5(gxm_XtRegisterGrabAction_w, gxm_XtRegisterGrabAction)
  XEN_NARGIFY_2(gxm_XtSetMultiClickTime_w, gxm_XtSetMultiClickTime)
  XEN_NARGIFY_1(gxm_XtGetMultiClickTime_w, gxm_XtGetMultiClickTime)
  XEN_NARGIFY_1(gxm_XtGetResourceList_w, gxm_XtGetResourceList)
  XEN_NARGIFY_1(gxm_XtGetActionKeysym_w, gxm_XtGetActionKeysym)
  XEN_NARGIFY_3(gxm_XtTranslateKeycode_w, gxm_XtTranslateKeycode)
  XEN_NARGIFY_3(gxm_XtTranslateKey_w, gxm_XtTranslateKey)
  XEN_NARGIFY_2(gxm_XtSetKeyTranslator_w, gxm_XtSetKeyTranslator)
  XEN_NARGIFY_4(gxm_XtRegisterCaseConverter_w, gxm_XtRegisterCaseConverter)
  XEN_NARGIFY_2(gxm_XtConvertCase_w, gxm_XtConvertCase)
  XEN_ARGIFY_5(gxm_XtAddEventHandler_w, gxm_XtAddEventHandler)
  XEN_NARGIFY_5(gxm_XtRemoveEventHandler_w, gxm_XtRemoveEventHandler)
  XEN_NARGIFY_5(gxm_XtAddRawEventHandler_w, gxm_XtAddRawEventHandler)
  XEN_NARGIFY_5(gxm_XtRemoveRawEventHandler_w, gxm_XtRemoveRawEventHandler)
  XEN_NARGIFY_6(gxm_XtInsertEventHandler_w, gxm_XtInsertEventHandler)
  XEN_NARGIFY_6(gxm_XtInsertRawEventHandler_w, gxm_XtInsertRawEventHandler)
  XEN_NARGIFY_2(gxm_XtDispatchEventToWidget_w, gxm_XtDispatchEventToWidget)
  XEN_NARGIFY_1(gxm_XtBuildEventMask_w, gxm_XtBuildEventMask)
  XEN_NARGIFY_3(gxm_XtAddGrab_w, gxm_XtAddGrab)
  XEN_NARGIFY_1(gxm_XtRemoveGrab_w, gxm_XtRemoveGrab)
  XEN_NARGIFY_2(gxm_XtAppProcessEvent_w, gxm_XtAppProcessEvent)
  XEN_NARGIFY_1(gxm_XtAppMainLoop_w, gxm_XtAppMainLoop)
  XEN_NARGIFY_2(gxm_XtAddExposureToRegion_w, gxm_XtAddExposureToRegion)
  XEN_NARGIFY_2(gxm_XtSetKeyboardFocus_w, gxm_XtSetKeyboardFocus)
  XEN_NARGIFY_1(gxm_XtGetKeyboardFocusWidget_w, gxm_XtGetKeyboardFocusWidget)
  XEN_NARGIFY_1(gxm_XtLastEventProcessed_w, gxm_XtLastEventProcessed)
  XEN_NARGIFY_1(gxm_XtLastTimestampProcessed_w, gxm_XtLastTimestampProcessed)
  XEN_ARGIFY_4(gxm_XtAppAddTimeOut_w, gxm_XtAppAddTimeOut)
  XEN_NARGIFY_1(gxm_XtRemoveTimeOut_w, gxm_XtRemoveTimeOut)
  XEN_ARGIFY_5(gxm_XtAppAddInput_w, gxm_XtAppAddInput)
  XEN_NARGIFY_1(gxm_XtRemoveInput_w, gxm_XtRemoveInput)
  XEN_NARGIFY_1(gxm_XtAppNextEvent_w, gxm_XtAppNextEvent)
  XEN_NARGIFY_1(gxm_XtAppPending_w, gxm_XtAppPending)
  XEN_NARGIFY_1(gxm_XtRealizeWidget_w, gxm_XtRealizeWidget)
  XEN_NARGIFY_1(gxm_XtUnrealizeWidget_w, gxm_XtUnrealizeWidget)
  XEN_NARGIFY_1(gxm_XtDestroyWidget_w, gxm_XtDestroyWidget)
  XEN_NARGIFY_2(gxm_XtSetSensitive_w, gxm_XtSetSensitive)
  XEN_NARGIFY_2(gxm_XtNameToWidget_w, gxm_XtNameToWidget)
  XEN_NARGIFY_2(gxm_XtWindowToWidget_w, gxm_XtWindowToWidget)
  XEN_NARGIFY_4(gxm_XtMergeArgLists_w, gxm_XtMergeArgLists)
  XEN_NARGIFY_2(gxm_XtVaCreateArgsList_w, gxm_XtVaCreateArgsList)
  XEN_NARGIFY_1(gxm_XtDisplay_w, gxm_XtDisplay)
  XEN_NARGIFY_1(gxm_XtDisplayOfObject_w, gxm_XtDisplayOfObject)
  XEN_NARGIFY_1(gxm_XtScreen_w, gxm_XtScreen)
  XEN_NARGIFY_1(gxm_XtScreenOfObject_w, gxm_XtScreenOfObject)
  XEN_NARGIFY_1(gxm_XtWindow_w, gxm_XtWindow)
  XEN_NARGIFY_1(gxm_XtWindowOfObject_w, gxm_XtWindowOfObject)
  XEN_NARGIFY_1(gxm_XtName_w, gxm_XtName)
  XEN_NARGIFY_1(gxm_XtSuperclass_w, gxm_XtSuperclass)
  XEN_NARGIFY_1(gxm_XtClass_w, gxm_XtClass)
  XEN_NARGIFY_1(gxm_XtParent_w, gxm_XtParent)
  XEN_ARGIFY_4(gxm_XtAddCallback_w, gxm_XtAddCallback)
  XEN_NARGIFY_3(gxm_XtRemoveCallback_w, gxm_XtRemoveCallback)
  XEN_NARGIFY_3(gxm_XtAddCallbacks_w, gxm_XtAddCallbacks)
  XEN_NARGIFY_3(gxm_XtRemoveCallbacks_w, gxm_XtRemoveCallbacks)
  XEN_NARGIFY_2(gxm_XtRemoveAllCallbacks_w, gxm_XtRemoveAllCallbacks)
  XEN_NARGIFY_3(gxm_XtCallCallbacks_w, gxm_XtCallCallbacks)
  XEN_NARGIFY_2(gxm_XtHasCallbacks_w, gxm_XtHasCallbacks)
  XEN_ARGIFY_5(gxm_XtCreatePopupShell_w, gxm_XtCreatePopupShell)
  XEN_NARGIFY_4(gxm_XtVaCreatePopupShell_w, gxm_XtVaCreatePopupShell)
  XEN_NARGIFY_2(gxm_XtPopup_w, gxm_XtPopup)
  XEN_NARGIFY_1(gxm_XtPopupSpringLoaded_w, gxm_XtPopupSpringLoaded)
  XEN_NARGIFY_3(gxm_XtCallbackNone_w, gxm_XtCallbackNone)
  XEN_NARGIFY_3(gxm_XtCallbackNonexclusive_w, gxm_XtCallbackNonexclusive)
  XEN_NARGIFY_3(gxm_XtCallbackExclusive_w, gxm_XtCallbackExclusive)
  XEN_NARGIFY_1(gxm_XtPopdown_w, gxm_XtPopdown)
  XEN_NARGIFY_3(gxm_XtCallbackPopdown_w, gxm_XtCallbackPopdown)
  XEN_ARGIFY_5(gxm_XtCreateWidget_w, gxm_XtCreateWidget)
  XEN_ARGIFY_5(gxm_XtCreateManagedWidget_w, gxm_XtCreateManagedWidget)
  XEN_NARGIFY_4(gxm_XtVaCreateWidget_w, gxm_XtVaCreateWidget)
  XEN_NARGIFY_4(gxm_XtVaCreateManagedWidget_w, gxm_XtVaCreateManagedWidget)
  XEN_ARGIFY_6(gxm_XtAppCreateShell_w, gxm_XtAppCreateShell)
  XEN_NARGIFY_5(gxm_XtVaAppCreateShell_w, gxm_XtVaAppCreateShell)
  XEN_NARGIFY_0(gxm_XtToolkitInitialize_w, gxm_XtToolkitInitialize)
  XEN_NARGIFY_3(gxm_XtSetLanguageProc_w, gxm_XtSetLanguageProc)
  XEN_NARGIFY_6(gxm_XtDisplayInitialize_w, gxm_XtDisplayInitialize)
  XEN_ARGIFY_6(gxm_XtOpenApplication_w, gxm_XtOpenApplication)
  XEN_ARGIFY_6(gxm_XtVaOpenApplication_w, gxm_XtVaOpenApplication)
  XEN_ARGIFY_5(gxm_XtAppInitialize_w, gxm_XtAppInitialize)
  XEN_ARGIFY_5(gxm_XtVaAppInitialize_w, gxm_XtVaAppInitialize)
  XEN_NARGIFY_6(gxm_XtOpenDisplay_w, gxm_XtOpenDisplay)
  XEN_NARGIFY_0(gxm_XtCreateApplicationContext_w, gxm_XtCreateApplicationContext)
  XEN_NARGIFY_1(gxm_XtDestroyApplicationContext_w, gxm_XtDestroyApplicationContext)
  XEN_NARGIFY_1(gxm_XtInitializeWidgetClass_w, gxm_XtInitializeWidgetClass)
  XEN_NARGIFY_1(gxm_XtWidgetToApplicationContext_w, gxm_XtWidgetToApplicationContext)
  XEN_NARGIFY_1(gxm_XtDisplayToApplicationContext_w, gxm_XtDisplayToApplicationContext)
  XEN_NARGIFY_1(gxm_XtCloseDisplay_w, gxm_XtCloseDisplay)
  XEN_ARGIFY_3(gxm_XtSetValues_w, gxm_XtSetValues)
  XEN_NARGIFY_2(gxm_XtVaSetValues_w, gxm_XtVaSetValues)
  XEN_ARGIFY_3(gxm_XtGetValues_w, gxm_XtGetValues)
  XEN_NARGIFY_2(gxm_XtVaGetValues_w, gxm_XtVaGetValues)
  XEN_NARGIFY_2(gxm_XtAppSetErrorMsgHandler_w, gxm_XtAppSetErrorMsgHandler)
  XEN_NARGIFY_2(gxm_XtAppSetWarningMsgHandler_w, gxm_XtAppSetWarningMsgHandler)
  XEN_NARGIFY_7(gxm_XtAppErrorMsg_w, gxm_XtAppErrorMsg)
  XEN_NARGIFY_7(gxm_XtAppWarningMsg_w, gxm_XtAppWarningMsg)
  XEN_NARGIFY_2(gxm_XtAppSetErrorHandler_w, gxm_XtAppSetErrorHandler)
  XEN_NARGIFY_2(gxm_XtAppSetWarningHandler_w, gxm_XtAppSetWarningHandler)
  XEN_NARGIFY_2(gxm_XtAppError_w, gxm_XtAppError)
  XEN_NARGIFY_1(gxm_XtMalloc_w, gxm_XtMalloc)
  XEN_NARGIFY_2(gxm_XtCalloc_w, gxm_XtCalloc)
  XEN_NARGIFY_2(gxm_XtRealloc_w, gxm_XtRealloc)
  XEN_NARGIFY_1(gxm_XtFree_w, gxm_XtFree)
  XEN_ARGIFY_3(gxm_XtAppAddWorkProc_w, gxm_XtAppAddWorkProc)
  XEN_NARGIFY_1(gxm_XtRemoveWorkProc_w, gxm_XtRemoveWorkProc)
  XEN_NARGIFY_3(gxm_XtGetGC_w, gxm_XtGetGC)
  XEN_NARGIFY_6(gxm_XtAllocateGC_w, gxm_XtAllocateGC)
  XEN_NARGIFY_1(gxm_XtDestroyGC_w, gxm_XtDestroyGC)
  XEN_NARGIFY_2(gxm_XtReleaseGC_w, gxm_XtReleaseGC)
  XEN_NARGIFY_4(gxm_XtFindFile_w, gxm_XtFindFile)
  XEN_NARGIFY_8(gxm_XtResolvePathname_w, gxm_XtResolvePathname)
  XEN_NARGIFY_3(gxm_XtDisownSelection_w, gxm_XtDisownSelection)
  XEN_NARGIFY_6(gxm_XtGetSelectionValue_w, gxm_XtGetSelectionValue)
  XEN_NARGIFY_7(gxm_XtGetSelectionValues_w, gxm_XtGetSelectionValues)
  XEN_NARGIFY_2(gxm_XtAppSetSelectionTimeout_w, gxm_XtAppSetSelectionTimeout)
  XEN_NARGIFY_1(gxm_XtAppGetSelectionTimeout_w, gxm_XtAppGetSelectionTimeout)
  XEN_NARGIFY_3(gxm_XtGetSelectionRequest_w, gxm_XtGetSelectionRequest)
  XEN_NARGIFY_6(gxm_XtGetSelectionValueIncremental_w, gxm_XtGetSelectionValueIncremental)
  XEN_NARGIFY_7(gxm_XtGetSelectionValuesIncremental_w, gxm_XtGetSelectionValuesIncremental)
  XEN_NARGIFY_2(gxm_XtCreateSelectionRequest_w, gxm_XtCreateSelectionRequest)
  XEN_NARGIFY_3(gxm_XtSendSelectionRequest_w, gxm_XtSendSelectionRequest)
  XEN_NARGIFY_2(gxm_XtCancelSelectionRequest_w, gxm_XtCancelSelectionRequest)
  XEN_NARGIFY_6(gxm_XtGrabKey_w, gxm_XtGrabKey)
  XEN_NARGIFY_3(gxm_XtUngrabKey_w, gxm_XtUngrabKey)
  XEN_NARGIFY_5(gxm_XtGrabKeyboard_w, gxm_XtGrabKeyboard)
  XEN_NARGIFY_2(gxm_XtUngrabKeyboard_w, gxm_XtUngrabKeyboard)
  XEN_NARGIFY_9(gxm_XtGrabButton_w, gxm_XtGrabButton)
  XEN_NARGIFY_3(gxm_XtUngrabButton_w, gxm_XtUngrabButton)
  XEN_NARGIFY_8(gxm_XtGrabPointer_w, gxm_XtGrabPointer)
  XEN_NARGIFY_2(gxm_XtUngrabPointer_w, gxm_XtUngrabPointer)
  XEN_NARGIFY_1(gxm_XtGetApplicationNameAndClass_w, gxm_XtGetApplicationNameAndClass)
  XEN_NARGIFY_1(gxm_XtGetDisplays_w, gxm_XtGetDisplays)
  XEN_NARGIFY_0(gxm_XtToolkitThreadInitialize_w, gxm_XtToolkitThreadInitialize)
  XEN_NARGIFY_1(gxm_XtAppLock_w, gxm_XtAppLock)
  XEN_NARGIFY_1(gxm_XtAppUnlock_w, gxm_XtAppUnlock)
  XEN_NARGIFY_1(gxm_XtIsRectObj_w, gxm_XtIsRectObj)
  XEN_NARGIFY_1(gxm_XtIsWidget_w, gxm_XtIsWidget)
  XEN_NARGIFY_1(gxm_XtIsComposite_w, gxm_XtIsComposite)
  XEN_NARGIFY_1(gxm_XtIsConstraint_w, gxm_XtIsConstraint)
  XEN_NARGIFY_1(gxm_XtIsShell_w, gxm_XtIsShell)
  XEN_NARGIFY_1(gxm_XtIsOverrideShell_w, gxm_XtIsOverrideShell)
  XEN_NARGIFY_1(gxm_XtIsWMShell_w, gxm_XtIsWMShell)
  XEN_NARGIFY_1(gxm_XtIsVendorShell_w, gxm_XtIsVendorShell)
  XEN_NARGIFY_1(gxm_XtIsTransientShell_w, gxm_XtIsTransientShell)
  XEN_NARGIFY_1(gxm_XtIsTopLevelShell_w, gxm_XtIsTopLevelShell)
  XEN_NARGIFY_1(gxm_XtIsApplicationShell_w, gxm_XtIsApplicationShell)
  XEN_NARGIFY_1(gxm_XtIsSessionShell_w, gxm_XtIsSessionShell)
  XEN_NARGIFY_1(gxm_XtMapWidget_w, gxm_XtMapWidget)
  XEN_NARGIFY_1(gxm_XtUnmapWidget_w, gxm_XtUnmapWidget)
#endif
  XEN_NARGIFY_2(gxm_XLoadQueryFont_w, gxm_XLoadQueryFont)
  XEN_NARGIFY_2(gxm_XQueryFont_w, gxm_XQueryFont)
  XEN_NARGIFY_4(gxm_XGetMotionEvents_w, gxm_XGetMotionEvents)
  XEN_NARGIFY_3(gxm_XDeleteModifiermapEntry_w, gxm_XDeleteModifiermapEntry)
  XEN_NARGIFY_1(gxm_XGetModifierMapping_w, gxm_XGetModifierMapping)
  XEN_NARGIFY_3(gxm_XInsertModifiermapEntry_w, gxm_XInsertModifiermapEntry)
  XEN_NARGIFY_1(gxm_XNewModifiermap_w, gxm_XNewModifiermap)
  XEN_VARGIFY(gxm_XCreateImage_w, gxm_XCreateImage)
  XEN_NARGIFY_8(gxm_XGetImage_w, gxm_XGetImage)
  XEN_VARGIFY(gxm_XGetSubImage_w, gxm_XGetSubImage)
  XEN_NARGIFY_1(gxm_XOpenDisplay_w, gxm_XOpenDisplay)
  XEN_NARGIFY_1(gxm_XFetchBytes_w, gxm_XFetchBytes)
  XEN_NARGIFY_2(gxm_XFetchBuffer_w, gxm_XFetchBuffer)
  XEN_NARGIFY_2(gxm_XGetAtomName_w, gxm_XGetAtomName)
  XEN_NARGIFY_1(gxm_XDisplayName_w, gxm_XDisplayName)
  XEN_NARGIFY_1(gxm_XKeysymToString_w, gxm_XKeysymToString)
  XEN_NARGIFY_2(gxm_XSynchronize_w, gxm_XSynchronize)
  XEN_NARGIFY_2(gxm_XSetAfterFunction_w, gxm_XSetAfterFunction)
  XEN_NARGIFY_3(gxm_XInternAtom_w, gxm_XInternAtom)
  XEN_NARGIFY_2(gxm_XCopyColormapAndFree_w, gxm_XCopyColormapAndFree)
  XEN_NARGIFY_4(gxm_XCreateColormap_w, gxm_XCreateColormap)
  XEN_NARGIFY_7(gxm_XCreatePixmapCursor_w, gxm_XCreatePixmapCursor)
  XEN_NARGIFY_7(gxm_XCreateGlyphCursor_w, gxm_XCreateGlyphCursor)
  XEN_NARGIFY_2(gxm_XCreateFontCursor_w, gxm_XCreateFontCursor)
  XEN_NARGIFY_2(gxm_XLoadFont_w, gxm_XLoadFont)
  XEN_NARGIFY_4(gxm_XCreateGC_w, gxm_XCreateGC)
  XEN_NARGIFY_2(gxm_XFlushGC_w, gxm_XFlushGC)
  XEN_NARGIFY_5(gxm_XCreatePixmap_w, gxm_XCreatePixmap)
  XEN_NARGIFY_5(gxm_XCreateBitmapFromData_w, gxm_XCreateBitmapFromData)
  XEN_NARGIFY_8(gxm_XCreatePixmapFromBitmapData_w, gxm_XCreatePixmapFromBitmapData)
  XEN_NARGIFY_9(gxm_XCreateSimpleWindow_w, gxm_XCreateSimpleWindow)
  XEN_NARGIFY_2(gxm_XGetSelectionOwner_w, gxm_XGetSelectionOwner)
  XEN_VARGIFY(gxm_XCreateWindow_w, gxm_XCreateWindow)
  XEN_NARGIFY_2(gxm_XListInstalledColormaps_w, gxm_XListInstalledColormaps)
  XEN_NARGIFY_3(gxm_XListFonts_w, gxm_XListFonts)
  XEN_NARGIFY_3(gxm_XListFontsWithInfo_w, gxm_XListFontsWithInfo)
  XEN_NARGIFY_1(gxm_XGetFontPath_w, gxm_XGetFontPath)
  XEN_NARGIFY_1(gxm_XListExtensions_w, gxm_XListExtensions)
  XEN_NARGIFY_2(gxm_XListProperties_w, gxm_XListProperties)
  XEN_NARGIFY_3(gxm_XKeycodeToKeysym_w, gxm_XKeycodeToKeysym)
  XEN_NARGIFY_2(gxm_XLookupKeysym_w, gxm_XLookupKeysym)
  XEN_NARGIFY_3(gxm_XGetKeyboardMapping_w, gxm_XGetKeyboardMapping)
  XEN_NARGIFY_1(gxm_XStringToKeysym_w, gxm_XStringToKeysym)
  XEN_NARGIFY_1(gxm_XMaxRequestSize_w, gxm_XMaxRequestSize)
  XEN_NARGIFY_1(gxm_XExtendedMaxRequestSize_w, gxm_XExtendedMaxRequestSize)
  XEN_NARGIFY_1(gxm_XDisplayMotionBufferSize_w, gxm_XDisplayMotionBufferSize)
  XEN_NARGIFY_1(gxm_XVisualIDFromVisual_w, gxm_XVisualIDFromVisual)
  XEN_NARGIFY_2(gxm_XRootWindow_w, gxm_XRootWindow)
  XEN_NARGIFY_1(gxm_XDefaultRootWindow_w, gxm_XDefaultRootWindow)
  XEN_NARGIFY_1(gxm_XRootWindowOfScreen_w, gxm_XRootWindowOfScreen)
  XEN_NARGIFY_2(gxm_XDefaultVisual_w, gxm_XDefaultVisual)
  XEN_NARGIFY_1(gxm_XDefaultVisualOfScreen_w, gxm_XDefaultVisualOfScreen)
  XEN_NARGIFY_2(gxm_XDefaultGC_w, gxm_XDefaultGC)
  XEN_NARGIFY_1(gxm_XDefaultGCOfScreen_w, gxm_XDefaultGCOfScreen)
  XEN_NARGIFY_2(gxm_XBlackPixel_w, gxm_XBlackPixel)
  XEN_NARGIFY_2(gxm_XWhitePixel_w, gxm_XWhitePixel)
  XEN_NARGIFY_0(gxm_XAllPlanes_w, gxm_XAllPlanes)
  XEN_NARGIFY_1(gxm_XBlackPixelOfScreen_w, gxm_XBlackPixelOfScreen)
  XEN_NARGIFY_1(gxm_XWhitePixelOfScreen_w, gxm_XWhitePixelOfScreen)
  XEN_NARGIFY_1(gxm_XNextRequest_w, gxm_XNextRequest)
  XEN_NARGIFY_1(gxm_XLastKnownRequestProcessed_w, gxm_XLastKnownRequestProcessed)
  XEN_NARGIFY_1(gxm_XServerVendor_w, gxm_XServerVendor)
  XEN_NARGIFY_1(gxm_XDisplayString_w, gxm_XDisplayString)
  XEN_NARGIFY_2(gxm_XDefaultColormap_w, gxm_XDefaultColormap)
  XEN_NARGIFY_1(gxm_XDefaultColormapOfScreen_w, gxm_XDefaultColormapOfScreen)
  XEN_NARGIFY_1(gxm_XDisplayOfScreen_w, gxm_XDisplayOfScreen)
  XEN_NARGIFY_2(gxm_XScreenOfDisplay_w, gxm_XScreenOfDisplay)
  XEN_NARGIFY_1(gxm_XDefaultScreenOfDisplay_w, gxm_XDefaultScreenOfDisplay)
  XEN_NARGIFY_1(gxm_XEventMaskOfScreen_w, gxm_XEventMaskOfScreen)
  XEN_NARGIFY_1(gxm_XScreenNumberOfScreen_w, gxm_XScreenNumberOfScreen)
  XEN_NARGIFY_1(gxm_XSetErrorHandler_w, gxm_XSetErrorHandler)
  XEN_NARGIFY_1(gxm_XSetIOErrorHandler_w, gxm_XSetIOErrorHandler)
  XEN_NARGIFY_1(gxm_XListPixmapFormats_w, gxm_XListPixmapFormats)
  XEN_NARGIFY_2(gxm_XListDepths_w, gxm_XListDepths)
  XEN_NARGIFY_5(gxm_XReconfigureWMWindow_w, gxm_XReconfigureWMWindow)
  XEN_NARGIFY_2(gxm_XGetWMProtocols_w, gxm_XGetWMProtocols)
  XEN_NARGIFY_4(gxm_XSetWMProtocols_w, gxm_XSetWMProtocols)
  XEN_NARGIFY_3(gxm_XIconifyWindow_w, gxm_XIconifyWindow)
  XEN_NARGIFY_3(gxm_XWithdrawWindow_w, gxm_XWithdrawWindow)
  XEN_NARGIFY_2(gxm_XGetCommand_w, gxm_XGetCommand)
  XEN_NARGIFY_2(gxm_XGetWMColormapWindows_w, gxm_XGetWMColormapWindows)
  XEN_NARGIFY_4(gxm_XSetWMColormapWindows_w, gxm_XSetWMColormapWindows)
  XEN_NARGIFY_3(gxm_XSetTransientForHint_w, gxm_XSetTransientForHint)
  XEN_NARGIFY_1(gxm_XActivateScreenSaver_w, gxm_XActivateScreenSaver)
  XEN_NARGIFY_3(gxm_XAllocColor_w, gxm_XAllocColor)
  XEN_NARGIFY_5(gxm_XAllocColorCells_w, gxm_XAllocColorCells)
  XEN_VARGIFY(gxm_XAllocColorPlanes_w, gxm_XAllocColorPlanes)
  XEN_NARGIFY_5(gxm_XAllocNamedColor_w, gxm_XAllocNamedColor)
  XEN_NARGIFY_3(gxm_XAllowEvents_w, gxm_XAllowEvents)
  XEN_NARGIFY_1(gxm_XAutoRepeatOff_w, gxm_XAutoRepeatOff)
  XEN_NARGIFY_1(gxm_XAutoRepeatOn_w, gxm_XAutoRepeatOn)
  XEN_NARGIFY_2(gxm_XBell_w, gxm_XBell)
  XEN_NARGIFY_1(gxm_XBitmapBitOrder_w, gxm_XBitmapBitOrder)
  XEN_NARGIFY_1(gxm_XBitmapPad_w, gxm_XBitmapPad)
  XEN_NARGIFY_1(gxm_XBitmapUnit_w, gxm_XBitmapUnit)
  XEN_NARGIFY_1(gxm_XCellsOfScreen_w, gxm_XCellsOfScreen)
  XEN_NARGIFY_4(gxm_XChangeActivePointerGrab_w, gxm_XChangeActivePointerGrab)
  XEN_NARGIFY_4(gxm_XChangeGC_w, gxm_XChangeGC)
  XEN_NARGIFY_3(gxm_XChangeKeyboardControl_w, gxm_XChangeKeyboardControl)
  XEN_NARGIFY_5(gxm_XChangeKeyboardMapping_w, gxm_XChangeKeyboardMapping)
  XEN_NARGIFY_6(gxm_XChangePointerControl_w, gxm_XChangePointerControl)
  XEN_ARGIFY_8(gxm_XChangeProperty_w, gxm_XChangeProperty)
  XEN_NARGIFY_4(gxm_XChangeWindowAttributes_w, gxm_XChangeWindowAttributes)
  XEN_NARGIFY_3(gxm_XCheckIfEvent_w, gxm_XCheckIfEvent)
  XEN_NARGIFY_2(gxm_XCheckMaskEvent_w, gxm_XCheckMaskEvent)
  XEN_NARGIFY_2(gxm_XCheckTypedEvent_w, gxm_XCheckTypedEvent)
  XEN_NARGIFY_3(gxm_XCheckTypedWindowEvent_w, gxm_XCheckTypedWindowEvent)
  XEN_NARGIFY_3(gxm_XCheckWindowEvent_w, gxm_XCheckWindowEvent)
  XEN_NARGIFY_3(gxm_XCirculateSubwindows_w, gxm_XCirculateSubwindows)
  XEN_NARGIFY_2(gxm_XCirculateSubwindowsDown_w, gxm_XCirculateSubwindowsDown)
  XEN_NARGIFY_2(gxm_XCirculateSubwindowsUp_w, gxm_XCirculateSubwindowsUp)
  XEN_NARGIFY_7(gxm_XClearArea_w, gxm_XClearArea)
  XEN_NARGIFY_2(gxm_XClearWindow_w, gxm_XClearWindow)
  XEN_NARGIFY_1(gxm_XCloseDisplay_w, gxm_XCloseDisplay)
  XEN_NARGIFY_4(gxm_XConfigureWindow_w, gxm_XConfigureWindow)
  XEN_NARGIFY_1(gxm_XConnectionNumber_w, gxm_XConnectionNumber)
  XEN_NARGIFY_6(gxm_XConvertSelection_w, gxm_XConvertSelection)
  XEN_VARGIFY(gxm_XCopyArea_w, gxm_XCopyArea)
  XEN_NARGIFY_4(gxm_XCopyGC_w, gxm_XCopyGC)
  XEN_VARGIFY(gxm_XCopyPlane_w, gxm_XCopyPlane)
  XEN_NARGIFY_2(gxm_XDefaultDepth_w, gxm_XDefaultDepth)
  XEN_NARGIFY_1(gxm_XDefaultDepthOfScreen_w, gxm_XDefaultDepthOfScreen)
  XEN_NARGIFY_1(gxm_XDefaultScreen_w, gxm_XDefaultScreen)
  XEN_NARGIFY_3(gxm_XDefineCursor_w, gxm_XDefineCursor)
  XEN_NARGIFY_3(gxm_XDeleteProperty_w, gxm_XDeleteProperty)
  XEN_NARGIFY_2(gxm_XDestroyWindow_w, gxm_XDestroyWindow)
  XEN_NARGIFY_2(gxm_XDestroySubwindows_w, gxm_XDestroySubwindows)
  XEN_NARGIFY_1(gxm_XDoesBackingStore_w, gxm_XDoesBackingStore)
  XEN_NARGIFY_1(gxm_XDoesSaveUnders_w, gxm_XDoesSaveUnders)
  XEN_NARGIFY_1(gxm_XDisableAccessControl_w, gxm_XDisableAccessControl)
  XEN_NARGIFY_2(gxm_XDisplayCells_w, gxm_XDisplayCells)
  XEN_NARGIFY_2(gxm_XDisplayHeight_w, gxm_XDisplayHeight)
  XEN_NARGIFY_2(gxm_XDisplayHeightMM_w, gxm_XDisplayHeightMM)
  XEN_NARGIFY_1(gxm_XDisplayKeycodes_w, gxm_XDisplayKeycodes)
  XEN_NARGIFY_2(gxm_XDisplayPlanes_w, gxm_XDisplayPlanes)
  XEN_NARGIFY_2(gxm_XDisplayWidth_w, gxm_XDisplayWidth)
  XEN_NARGIFY_2(gxm_XDisplayWidthMM_w, gxm_XDisplayWidthMM)
  XEN_NARGIFY_9(gxm_XDrawArc_w, gxm_XDrawArc)
  XEN_NARGIFY_5(gxm_XDrawArcs_w, gxm_XDrawArcs)
  XEN_NARGIFY_7(gxm_XDrawImageString_w, gxm_XDrawImageString)
  XEN_NARGIFY_7(gxm_XDrawLine_w, gxm_XDrawLine)
  XEN_NARGIFY_6(gxm_XDrawLines_w, gxm_XDrawLines)
  XEN_NARGIFY_6(gxm_XDrawLinesDirect_w, gxm_XDrawLinesDirect)
  XEN_NARGIFY_1(gxm_FreeXPoints_w, gxm_FreeXPoints)
  XEN_NARGIFY_1(gxm_Vector2XPoints_w, gxm_Vector2XPoints)
  XEN_NARGIFY_5(gxm_XDrawPoint_w, gxm_XDrawPoint)
  XEN_NARGIFY_6(gxm_XDrawPoints_w, gxm_XDrawPoints)
  XEN_NARGIFY_7(gxm_XDrawRectangle_w, gxm_XDrawRectangle)
  XEN_NARGIFY_5(gxm_XDrawRectangles_w, gxm_XDrawRectangles)
  XEN_NARGIFY_5(gxm_XDrawSegments_w, gxm_XDrawSegments)
  XEN_NARGIFY_7(gxm_XDrawString_w, gxm_XDrawString)
  XEN_ARGIFY_7(gxm_XDrawText_w, gxm_XDrawText)
  XEN_NARGIFY_1(gxm_XEnableAccessControl_w, gxm_XEnableAccessControl)
  XEN_NARGIFY_2(gxm_XEventsQueued_w, gxm_XEventsQueued)
  XEN_NARGIFY_2(gxm_XFetchName_w, gxm_XFetchName)
  XEN_NARGIFY_9(gxm_XFillArc_w, gxm_XFillArc)
  XEN_NARGIFY_5(gxm_XFillArcs_w, gxm_XFillArcs)
  XEN_NARGIFY_7(gxm_XFillPolygon_w, gxm_XFillPolygon)
  XEN_NARGIFY_7(gxm_XFillRectangle_w, gxm_XFillRectangle)
  XEN_NARGIFY_5(gxm_XFillRectangles_w, gxm_XFillRectangles)
  XEN_NARGIFY_1(gxm_XFlush_w, gxm_XFlush)
  XEN_NARGIFY_2(gxm_XForceScreenSaver_w, gxm_XForceScreenSaver)
  XEN_NARGIFY_1(gxm_XFree_w, gxm_XFree)
  XEN_NARGIFY_2(gxm_XFreeColormap_w, gxm_XFreeColormap)
  XEN_NARGIFY_5(gxm_XFreeColors_w, gxm_XFreeColors)
  XEN_NARGIFY_2(gxm_XFreeCursor_w, gxm_XFreeCursor)
  XEN_NARGIFY_1(gxm_XFreeExtensionList_w, gxm_XFreeExtensionList)
  XEN_NARGIFY_2(gxm_XFreeFont_w, gxm_XFreeFont)
  XEN_NARGIFY_3(gxm_XFreeFontInfo_w, gxm_XFreeFontInfo)
  XEN_NARGIFY_1(gxm_XFreeFontNames_w, gxm_XFreeFontNames)
  XEN_NARGIFY_1(gxm_XFreeFontPath_w, gxm_XFreeFontPath)
  XEN_NARGIFY_2(gxm_XFreeGC_w, gxm_XFreeGC)
  XEN_NARGIFY_1(gxm_XFreeModifiermap_w, gxm_XFreeModifiermap)
  XEN_NARGIFY_2(gxm_XFreePixmap_w, gxm_XFreePixmap)
  XEN_VARGIFY(gxm_XGeometry_w, gxm_XGeometry)
  XEN_NARGIFY_4(gxm_XGetErrorText_w, gxm_XGetErrorText)
  XEN_NARGIFY_2(gxm_XGetFontProperty_w, gxm_XGetFontProperty)
  XEN_NARGIFY_3(gxm_XGetGCValues_w, gxm_XGetGCValues)
  XEN_NARGIFY_0(gxm_XGCValues_w, gxm_XGCValues)
  XEN_ARGIFY_1(gxm_XEvent_w, gxm_XEvent)
  XEN_NARGIFY_2(gxm_XGetGeometry_w, gxm_XGetGeometry)
  XEN_NARGIFY_2(gxm_XGetIconName_w, gxm_XGetIconName)
  XEN_NARGIFY_1(gxm_XGetInputFocus_w, gxm_XGetInputFocus)
  XEN_NARGIFY_1(gxm_XGetKeyboardControl_w, gxm_XGetKeyboardControl)
  XEN_NARGIFY_1(gxm_XGetPointerControl_w, gxm_XGetPointerControl)
  XEN_NARGIFY_3(gxm_XGetPointerMapping_w, gxm_XGetPointerMapping)
  XEN_NARGIFY_1(gxm_XGetScreenSaver_w, gxm_XGetScreenSaver)
  XEN_NARGIFY_2(gxm_XGetTransientForHint_w, gxm_XGetTransientForHint)
  XEN_VARGIFY(gxm_XGetWindowProperty_w, gxm_XGetWindowProperty)
  XEN_NARGIFY_2(gxm_XGetWindowAttributes_w, gxm_XGetWindowAttributes)
  XEN_VARGIFY(gxm_XGrabButton_w, gxm_XGrabButton)
  XEN_NARGIFY_7(gxm_XGrabKey_w, gxm_XGrabKey)
  XEN_NARGIFY_6(gxm_XGrabKeyboard_w, gxm_XGrabKeyboard)
  XEN_NARGIFY_9(gxm_XGrabPointer_w, gxm_XGrabPointer)
  XEN_NARGIFY_1(gxm_XGrabServer_w, gxm_XGrabServer)
  XEN_NARGIFY_1(gxm_XHeightMMOfScreen_w, gxm_XHeightMMOfScreen)
  XEN_NARGIFY_1(gxm_XHeightOfScreen_w, gxm_XHeightOfScreen)
  XEN_NARGIFY_3(gxm_XIfEvent_w, gxm_XIfEvent)
  XEN_NARGIFY_1(gxm_XImageByteOrder_w, gxm_XImageByteOrder)
  XEN_NARGIFY_2(gxm_XInstallColormap_w, gxm_XInstallColormap)
  XEN_NARGIFY_2(gxm_XKeysymToKeycode_w, gxm_XKeysymToKeycode)
  XEN_NARGIFY_2(gxm_XKillClient_w, gxm_XKillClient)
  XEN_NARGIFY_5(gxm_XLookupColor_w, gxm_XLookupColor)
  XEN_NARGIFY_2(gxm_XLowerWindow_w, gxm_XLowerWindow)
  XEN_NARGIFY_2(gxm_XMapRaised_w, gxm_XMapRaised)
  XEN_NARGIFY_2(gxm_XMapSubwindows_w, gxm_XMapSubwindows)
  XEN_NARGIFY_2(gxm_XMapWindow_w, gxm_XMapWindow)
  XEN_NARGIFY_2(gxm_XMaskEvent_w, gxm_XMaskEvent)
  XEN_NARGIFY_1(gxm_XMaxCmapsOfScreen_w, gxm_XMaxCmapsOfScreen)
  XEN_NARGIFY_1(gxm_XMinCmapsOfScreen_w, gxm_XMinCmapsOfScreen)
  XEN_NARGIFY_6(gxm_XMoveResizeWindow_w, gxm_XMoveResizeWindow)
  XEN_NARGIFY_4(gxm_XMoveWindow_w, gxm_XMoveWindow)
  XEN_NARGIFY_1(gxm_XNextEvent_w, gxm_XNextEvent)
  XEN_NARGIFY_1(gxm_XNoOp_w, gxm_XNoOp)
  XEN_NARGIFY_4(gxm_XParseColor_w, gxm_XParseColor)
  XEN_NARGIFY_1(gxm_XParseGeometry_w, gxm_XParseGeometry)
  XEN_NARGIFY_1(gxm_XPeekEvent_w, gxm_XPeekEvent)
  XEN_NARGIFY_3(gxm_XPeekIfEvent_w, gxm_XPeekIfEvent)
  XEN_NARGIFY_1(gxm_XPending_w, gxm_XPending)
  XEN_NARGIFY_1(gxm_XPlanesOfScreen_w, gxm_XPlanesOfScreen)
  XEN_NARGIFY_1(gxm_XProtocolRevision_w, gxm_XProtocolRevision)
  XEN_NARGIFY_1(gxm_XProtocolVersion_w, gxm_XProtocolVersion)
  XEN_NARGIFY_2(gxm_XPutBackEvent_w, gxm_XPutBackEvent)
  XEN_VARGIFY(gxm_XPutImage_w, gxm_XPutImage)
  XEN_NARGIFY_1(gxm_XQLength_w, gxm_XQLength)
  XEN_NARGIFY_4(gxm_XQueryBestCursor_w, gxm_XQueryBestCursor)
  XEN_NARGIFY_5(gxm_XQueryBestSize_w, gxm_XQueryBestSize)
  XEN_NARGIFY_4(gxm_XQueryBestStipple_w, gxm_XQueryBestStipple)
  XEN_NARGIFY_4(gxm_XQueryBestTile_w, gxm_XQueryBestTile)
  XEN_NARGIFY_3(gxm_XQueryColor_w, gxm_XQueryColor)
  XEN_ARGIFY_4(gxm_XQueryColors_w, gxm_XQueryColors)
  XEN_NARGIFY_2(gxm_XQueryExtension_w, gxm_XQueryExtension)
  XEN_NARGIFY_1(gxm_XQueryKeymap_w, gxm_XQueryKeymap)
  XEN_NARGIFY_2(gxm_XQueryPointer_w, gxm_XQueryPointer)
  XEN_NARGIFY_3(gxm_XQueryTextExtents_w, gxm_XQueryTextExtents)
  XEN_NARGIFY_2(gxm_XQueryTree_w, gxm_XQueryTree)
  XEN_NARGIFY_2(gxm_XRaiseWindow_w, gxm_XRaiseWindow)
  XEN_NARGIFY_3(gxm_XReadBitmapFile_w, gxm_XReadBitmapFile)
  XEN_NARGIFY_1(gxm_XReadBitmapFileData_w, gxm_XReadBitmapFileData)
  XEN_NARGIFY_6(gxm_XRebindKeysym_w, gxm_XRebindKeysym)
  XEN_NARGIFY_4(gxm_XRecolorCursor_w, gxm_XRecolorCursor)
  XEN_NARGIFY_1(gxm_XRefreshKeyboardMapping_w, gxm_XRefreshKeyboardMapping)
  XEN_NARGIFY_5(gxm_XReparentWindow_w, gxm_XReparentWindow)
  XEN_NARGIFY_1(gxm_XResetScreenSaver_w, gxm_XResetScreenSaver)
  XEN_NARGIFY_4(gxm_XResizeWindow_w, gxm_XResizeWindow)
  XEN_NARGIFY_3(gxm_XRestackWindows_w, gxm_XRestackWindows)
  XEN_NARGIFY_2(gxm_XRotateBuffers_w, gxm_XRotateBuffers)
  XEN_NARGIFY_5(gxm_XRotateWindowProperties_w, gxm_XRotateWindowProperties)
  XEN_NARGIFY_1(gxm_XScreenCount_w, gxm_XScreenCount)
  XEN_NARGIFY_3(gxm_XSelectInput_w, gxm_XSelectInput)
  XEN_NARGIFY_5(gxm_XSendEvent_w, gxm_XSendEvent)
  XEN_NARGIFY_2(gxm_XSetAccessControl_w, gxm_XSetAccessControl)
  XEN_NARGIFY_3(gxm_XSetArcMode_w, gxm_XSetArcMode)
  XEN_NARGIFY_3(gxm_XSetBackground_w, gxm_XSetBackground)
  XEN_NARGIFY_3(gxm_XSetClipMask_w, gxm_XSetClipMask)
  XEN_NARGIFY_4(gxm_XSetClipOrigin_w, gxm_XSetClipOrigin)
  XEN_NARGIFY_7(gxm_XSetClipRectangles_w, gxm_XSetClipRectangles)
  XEN_NARGIFY_2(gxm_XSetCloseDownMode_w, gxm_XSetCloseDownMode)
  XEN_NARGIFY_4(gxm_XSetCommand_w, gxm_XSetCommand)
  XEN_ARGIFY_5(gxm_XSetDashes_w, gxm_XSetDashes)
  XEN_NARGIFY_3(gxm_XSetFillRule_w, gxm_XSetFillRule)
  XEN_NARGIFY_3(gxm_XSetFillStyle_w, gxm_XSetFillStyle)
  XEN_NARGIFY_3(gxm_XSetFont_w, gxm_XSetFont)
  XEN_NARGIFY_3(gxm_XSetFontPath_w, gxm_XSetFontPath)
  XEN_NARGIFY_3(gxm_XSetForeground_w, gxm_XSetForeground)
  XEN_NARGIFY_3(gxm_XSetFunction_w, gxm_XSetFunction)
  XEN_NARGIFY_3(gxm_XSetGraphicsExposures_w, gxm_XSetGraphicsExposures)
  XEN_NARGIFY_3(gxm_XSetIconName_w, gxm_XSetIconName)
  XEN_NARGIFY_4(gxm_XSetInputFocus_w, gxm_XSetInputFocus)
  XEN_NARGIFY_6(gxm_XSetLineAttributes_w, gxm_XSetLineAttributes)
  XEN_NARGIFY_2(gxm_XSetModifierMapping_w, gxm_XSetModifierMapping)
  XEN_NARGIFY_3(gxm_XSetPlaneMask_w, gxm_XSetPlaneMask)
  XEN_ARGIFY_3(gxm_XSetPointerMapping_w, gxm_XSetPointerMapping)
  XEN_NARGIFY_5(gxm_XSetScreenSaver_w, gxm_XSetScreenSaver)
  XEN_NARGIFY_4(gxm_XSetSelectionOwner_w, gxm_XSetSelectionOwner)
  XEN_NARGIFY_6(gxm_XSetState_w, gxm_XSetState)
  XEN_NARGIFY_3(gxm_XSetStipple_w, gxm_XSetStipple)
  XEN_NARGIFY_3(gxm_XSetSubwindowMode_w, gxm_XSetSubwindowMode)
  XEN_NARGIFY_4(gxm_XSetTSOrigin_w, gxm_XSetTSOrigin)
  XEN_NARGIFY_3(gxm_XSetTile_w, gxm_XSetTile)
  XEN_NARGIFY_3(gxm_XSetWindowBackground_w, gxm_XSetWindowBackground)
  XEN_NARGIFY_3(gxm_XSetWindowBackgroundPixmap_w, gxm_XSetWindowBackgroundPixmap)
  XEN_NARGIFY_3(gxm_XSetWindowBorder_w, gxm_XSetWindowBorder)
  XEN_NARGIFY_3(gxm_XSetWindowBorderPixmap_w, gxm_XSetWindowBorderPixmap)
  XEN_NARGIFY_3(gxm_XSetWindowBorderWidth_w, gxm_XSetWindowBorderWidth)
  XEN_NARGIFY_3(gxm_XSetWindowColormap_w, gxm_XSetWindowColormap)
  XEN_NARGIFY_4(gxm_XStoreBuffer_w, gxm_XStoreBuffer)
  XEN_NARGIFY_3(gxm_XStoreBytes_w, gxm_XStoreBytes)
  XEN_NARGIFY_3(gxm_XStoreColor_w, gxm_XStoreColor)
  XEN_NARGIFY_4(gxm_XStoreColors_w, gxm_XStoreColors)
  XEN_NARGIFY_3(gxm_XStoreName_w, gxm_XStoreName)
  XEN_NARGIFY_5(gxm_XStoreNamedColor_w, gxm_XStoreNamedColor)
  XEN_NARGIFY_2(gxm_XSync_w, gxm_XSync)
  XEN_NARGIFY_3(gxm_XTextExtents_w, gxm_XTextExtents)
  XEN_NARGIFY_3(gxm_XTextWidth_w, gxm_XTextWidth)
  XEN_NARGIFY_5(gxm_XTranslateCoordinates_w, gxm_XTranslateCoordinates)
  XEN_NARGIFY_2(gxm_XUndefineCursor_w, gxm_XUndefineCursor)
  XEN_NARGIFY_4(gxm_XUngrabButton_w, gxm_XUngrabButton)
  XEN_NARGIFY_4(gxm_XUngrabKey_w, gxm_XUngrabKey)
  XEN_NARGIFY_2(gxm_XUngrabKeyboard_w, gxm_XUngrabKeyboard)
  XEN_NARGIFY_2(gxm_XUngrabPointer_w, gxm_XUngrabPointer)
  XEN_NARGIFY_1(gxm_XUngrabServer_w, gxm_XUngrabServer)
  XEN_NARGIFY_2(gxm_XUninstallColormap_w, gxm_XUninstallColormap)
  XEN_NARGIFY_2(gxm_XUnloadFont_w, gxm_XUnloadFont)
  XEN_NARGIFY_2(gxm_XUnmapSubwindows_w, gxm_XUnmapSubwindows)
  XEN_NARGIFY_2(gxm_XUnmapWindow_w, gxm_XUnmapWindow)
  XEN_NARGIFY_1(gxm_XVendorRelease_w, gxm_XVendorRelease)
  XEN_NARGIFY_9(gxm_XWarpPointer_w, gxm_XWarpPointer)
  XEN_NARGIFY_1(gxm_XWidthMMOfScreen_w, gxm_XWidthMMOfScreen)
  XEN_NARGIFY_1(gxm_XWidthOfScreen_w, gxm_XWidthOfScreen)
  XEN_NARGIFY_3(gxm_XWindowEvent_w, gxm_XWindowEvent)
  XEN_NARGIFY_7(gxm_XWriteBitmapFile_w, gxm_XWriteBitmapFile)
  XEN_NARGIFY_0(gxm_XSupportsLocale_w, gxm_XSupportsLocale)
  XEN_NARGIFY_1(gxm_XSetLocaleModifiers_w, gxm_XSetLocaleModifiers)
  XEN_NARGIFY_2(gxm_XCreateFontSet_w, gxm_XCreateFontSet)
  XEN_NARGIFY_2(gxm_XFreeFontSet_w, gxm_XFreeFontSet)
  XEN_NARGIFY_1(gxm_XFontsOfFontSet_w, gxm_XFontsOfFontSet)
  XEN_NARGIFY_1(gxm_XBaseFontNameListOfFontSet_w, gxm_XBaseFontNameListOfFontSet)
  XEN_NARGIFY_1(gxm_XLocaleOfFontSet_w, gxm_XLocaleOfFontSet)
  XEN_NARGIFY_1(gxm_XContextDependentDrawing_w, gxm_XContextDependentDrawing)
  XEN_NARGIFY_1(gxm_XDirectionalDependentDrawing_w, gxm_XDirectionalDependentDrawing)
  XEN_NARGIFY_1(gxm_XContextualDrawing_w, gxm_XContextualDrawing)
  XEN_NARGIFY_2(gxm_XFilterEvent_w, gxm_XFilterEvent)
  XEN_NARGIFY_0(gxm_XAllocIconSize_w, gxm_XAllocIconSize)
  XEN_NARGIFY_0(gxm_XAllocStandardColormap_w, gxm_XAllocStandardColormap)
  XEN_NARGIFY_0(gxm_XAllocWMHints_w, gxm_XAllocWMHints)
  XEN_NARGIFY_1(gxm_XClipBox_w, gxm_XClipBox)
  XEN_NARGIFY_0(gxm_XCreateRegion_w, gxm_XCreateRegion)
  XEN_NARGIFY_0(gxm_XDefaultString_w, gxm_XDefaultString)
  XEN_NARGIFY_3(gxm_XDeleteContext_w, gxm_XDeleteContext)
  XEN_NARGIFY_1(gxm_XDestroyRegion_w, gxm_XDestroyRegion)
  XEN_NARGIFY_1(gxm_XEmptyRegion_w, gxm_XEmptyRegion)
  XEN_NARGIFY_2(gxm_XEqualRegion_w, gxm_XEqualRegion)
  XEN_NARGIFY_3(gxm_XFindContext_w, gxm_XFindContext)
  XEN_NARGIFY_2(gxm_XGetIconSizes_w, gxm_XGetIconSizes)
  XEN_NARGIFY_3(gxm_XGetRGBColormaps_w, gxm_XGetRGBColormaps)
#if (!XM_DISABLE_DEPRECATED)
  XEN_NARGIFY_3(gxm_XGetStandardColormap_w, gxm_XGetStandardColormap)
#endif
  XEN_NARGIFY_3(gxm_XGetVisualInfo_w, gxm_XGetVisualInfo)
  XEN_NARGIFY_2(gxm_XGetWMHints_w, gxm_XGetWMHints)
  XEN_NARGIFY_3(gxm_XIntersectRegion_w, gxm_XIntersectRegion)
  XEN_NARGIFY_1(gxm_XConvertCase_w, gxm_XConvertCase)
  XEN_NARGIFY_1(gxm_XLookupString_w, gxm_XLookupString)
  XEN_NARGIFY_4(gxm_XMatchVisualInfo_w, gxm_XMatchVisualInfo)
  XEN_NARGIFY_3(gxm_XOffsetRegion_w, gxm_XOffsetRegion)
  XEN_NARGIFY_3(gxm_XPointInRegion_w, gxm_XPointInRegion)
  XEN_NARGIFY_3(gxm_XPolygonRegion_w, gxm_XPolygonRegion)
  XEN_NARGIFY_5(gxm_XRectInRegion_w, gxm_XRectInRegion)
  XEN_NARGIFY_4(gxm_XSaveContext_w, gxm_XSaveContext)
  XEN_NARGIFY_0(gxm_XUniqueContext_w, gxm_XUniqueContext)
  XEN_NARGIFY_5(gxm_XSetRGBColormaps_w, gxm_XSetRGBColormaps)
  XEN_NARGIFY_3(gxm_XSetWMHints_w, gxm_XSetWMHints)
  XEN_NARGIFY_3(gxm_XSetRegion_w, gxm_XSetRegion)
#if (!XM_DISABLE_DEPRECATED)
  XEN_NARGIFY_4(gxm_XSetStandardColormap_w, gxm_XSetStandardColormap)
  XEN_NARGIFY_8(gxm_XSetStandardProperties_w, gxm_XSetStandardProperties)
#endif
  XEN_NARGIFY_8(gxm_XSetWMProperties_w, gxm_XSetWMProperties)
  XEN_NARGIFY_3(gxm_XShrinkRegion_w, gxm_XShrinkRegion)
  XEN_NARGIFY_3(gxm_XSubtractRegion_w, gxm_XSubtractRegion)
  XEN_NARGIFY_3(gxm_XUnionRectWithRegion_w, gxm_XUnionRectWithRegion)
  XEN_NARGIFY_3(gxm_XUnionRegion_w, gxm_XUnionRegion)
  XEN_NARGIFY_3(gxm_XXorRegion_w, gxm_XXorRegion)

  XEN_NARGIFY_1(gxm_DefaultScreen_w, gxm_DefaultScreen)
  XEN_NARGIFY_1(gxm_DefaultRootWindow_w, gxm_DefaultRootWindow)
  XEN_NARGIFY_1(gxm_QLength_w, gxm_QLength)
  XEN_NARGIFY_1(gxm_ScreenCount_w, gxm_ScreenCount)
  XEN_NARGIFY_1(gxm_ServerVendor_w, gxm_ServerVendor)
  XEN_NARGIFY_1(gxm_ProtocolVersion_w, gxm_ProtocolVersion)
  XEN_NARGIFY_1(gxm_ProtocolRevision_w, gxm_ProtocolRevision)
  XEN_NARGIFY_1(gxm_VendorRelease_w, gxm_VendorRelease)
  XEN_NARGIFY_1(gxm_DisplayString_w, gxm_DisplayString)
  XEN_NARGIFY_1(gxm_BitmapUnit_w, gxm_BitmapUnit)
  XEN_NARGIFY_1(gxm_BitmapBitOrder_w, gxm_BitmapBitOrder)
  XEN_NARGIFY_1(gxm_BitmapPad_w, gxm_BitmapPad)
  XEN_NARGIFY_1(gxm_ImageByteOrder_w, gxm_ImageByteOrder)
  XEN_NARGIFY_1(gxm_NextRequest_w, gxm_NextRequest)
  XEN_NARGIFY_1(gxm_LastKnownRequestProcessed_w, gxm_LastKnownRequestProcessed)
  XEN_NARGIFY_1(gxm_DefaultScreenOfDisplay_w, gxm_DefaultScreenOfDisplay)
  XEN_NARGIFY_1(gxm_DisplayOfScreen_w, gxm_DisplayOfScreen)
  XEN_NARGIFY_1(gxm_RootWindowOfScreen_w, gxm_RootWindowOfScreen)
  XEN_NARGIFY_1(gxm_BlackPixelOfScreen_w, gxm_BlackPixelOfScreen)
  XEN_NARGIFY_1(gxm_WhitePixelOfScreen_w, gxm_WhitePixelOfScreen)
  XEN_NARGIFY_1(gxm_DefaultColormapOfScreen_w, gxm_DefaultColormapOfScreen)
  XEN_NARGIFY_1(gxm_DefaultDepthOfScreen_w, gxm_DefaultDepthOfScreen)
  XEN_NARGIFY_1(gxm_DefaultGCOfScreen_w, gxm_DefaultGCOfScreen)
  XEN_NARGIFY_1(gxm_DefaultVisualOfScreen_w, gxm_DefaultVisualOfScreen)
  XEN_NARGIFY_1(gxm_WidthOfScreen_w, gxm_WidthOfScreen)
  XEN_NARGIFY_1(gxm_HeightOfScreen_w, gxm_HeightOfScreen)
  XEN_NARGIFY_1(gxm_WidthMMOfScreen_w, gxm_WidthMMOfScreen)
  XEN_NARGIFY_1(gxm_HeightMMOfScreen_w, gxm_HeightMMOfScreen)
  XEN_NARGIFY_1(gxm_PlanesOfScreen_w, gxm_PlanesOfScreen)
  XEN_NARGIFY_1(gxm_CellsOfScreen_w, gxm_CellsOfScreen)
  XEN_NARGIFY_1(gxm_MinCmapsOfScreen_w, gxm_MinCmapsOfScreen)
  XEN_NARGIFY_1(gxm_MaxCmapsOfScreen_w, gxm_MaxCmapsOfScreen)
  XEN_NARGIFY_1(gxm_DoesSaveUnders_w, gxm_DoesSaveUnders)
  XEN_NARGIFY_1(gxm_DoesBackingStore_w, gxm_DoesBackingStore)
  XEN_NARGIFY_1(gxm_EventMaskOfScreen_w, gxm_EventMaskOfScreen)
  XEN_NARGIFY_2(gxm_RootWindow_w, gxm_RootWindow)
  XEN_NARGIFY_2(gxm_DefaultVisual_w, gxm_DefaultVisual)
  XEN_NARGIFY_2(gxm_DefaultGC_w, gxm_DefaultGC)
  XEN_NARGIFY_2(gxm_BlackPixel_w, gxm_BlackPixel)
  XEN_NARGIFY_2(gxm_WhitePixel_w, gxm_WhitePixel)
  XEN_NARGIFY_2(gxm_DisplayWidth_w, gxm_DisplayWidth)
  XEN_NARGIFY_2(gxm_DisplayHeight_w, gxm_DisplayHeight)
  XEN_NARGIFY_2(gxm_DisplayWidthMM_w, gxm_DisplayWidthMM)
  XEN_NARGIFY_2(gxm_DisplayHeightMM_w, gxm_DisplayHeightMM)
  XEN_NARGIFY_2(gxm_DisplayPlanes_w, gxm_DisplayPlanes)
  XEN_NARGIFY_2(gxm_DisplayCells_w, gxm_DisplayCells)
  XEN_NARGIFY_2(gxm_DefaultColormap_w, gxm_DefaultColormap)
  XEN_NARGIFY_2(gxm_ScreenOfDisplay_w, gxm_ScreenOfDisplay)
  XEN_NARGIFY_2(gxm_DefaultDepth_w, gxm_DefaultDepth)

  XEN_NARGIFY_1(gxm_IsKeypadKey_w, gxm_IsKeypadKey)
  XEN_NARGIFY_1(gxm_IsPrivateKeypadKey_w, gxm_IsPrivateKeypadKey)
  XEN_NARGIFY_1(gxm_IsCursorKey_w, gxm_IsCursorKey)
  XEN_NARGIFY_1(gxm_IsPFKey_w, gxm_IsPFKey)
  XEN_NARGIFY_1(gxm_IsFunctionKey_w, gxm_IsFunctionKey)
  XEN_NARGIFY_1(gxm_IsMiscFunctionKey_w, gxm_IsMiscFunctionKey)
  XEN_NARGIFY_1(gxm_IsModifierKey_w, gxm_IsModifierKey)

  XEN_NARGIFY_1(XEN_XButtonEvent_p_w, XEN_XButtonEvent_p)
  XEN_NARGIFY_1(XEN_XCirculateEvent_p_w, XEN_XCirculateEvent_p)
  XEN_NARGIFY_1(XEN_XCirculateRequestEvent_p_w, XEN_XCirculateRequestEvent_p)
  XEN_NARGIFY_1(XEN_XClientMessageEvent_p_w, XEN_XClientMessageEvent_p)
  XEN_NARGIFY_1(XEN_XColormapEvent_p_w, XEN_XColormapEvent_p)
  XEN_NARGIFY_1(XEN_XConfigureEvent_p_w, XEN_XConfigureEvent_p)
  XEN_NARGIFY_1(XEN_XConfigureRequestEvent_p_w, XEN_XConfigureRequestEvent_p)
  XEN_NARGIFY_1(XEN_XCreateWindowEvent_p_w, XEN_XCreateWindowEvent_p)
  XEN_NARGIFY_1(XEN_XCrossingEvent_p_w, XEN_XCrossingEvent_p)
  XEN_NARGIFY_1(XEN_XDestroyWindowEvent_p_w, XEN_XDestroyWindowEvent_p)
  XEN_NARGIFY_1(XEN_XErrorEvent_p_w, XEN_XErrorEvent_p)
  XEN_NARGIFY_1(XEN_XExposeEvent_p_w, XEN_XExposeEvent_p)
  XEN_NARGIFY_1(XEN_XFocusChangeEvent_p_w, XEN_XFocusChangeEvent_p)
  XEN_NARGIFY_1(XEN_XGraphicsExposeEvent_p_w, XEN_XGraphicsExposeEvent_p)
  XEN_NARGIFY_1(XEN_XGravityEvent_p_w, XEN_XGravityEvent_p)
  XEN_NARGIFY_1(XEN_XKeyEvent_p_w, XEN_XKeyEvent_p)
  XEN_NARGIFY_1(XEN_XKeymapEvent_p_w, XEN_XKeymapEvent_p)
  XEN_NARGIFY_1(XEN_XMapEvent_p_w, XEN_XMapEvent_p)
  XEN_NARGIFY_1(XEN_XMapRequestEvent_p_w, XEN_XMapRequestEvent_p)
  XEN_NARGIFY_1(XEN_XMappingEvent_p_w, XEN_XMappingEvent_p)
  XEN_NARGIFY_1(XEN_XMotionEvent_p_w, XEN_XMotionEvent_p)
  XEN_NARGIFY_1(XEN_XNoExposeEvent_p_w, XEN_XNoExposeEvent_p)
  XEN_NARGIFY_1(XEN_XPropertyEvent_p_w, XEN_XPropertyEvent_p)
  XEN_NARGIFY_1(XEN_XReparentEvent_p_w, XEN_XReparentEvent_p)
  XEN_NARGIFY_1(XEN_XResizeRequestEvent_p_w, XEN_XResizeRequestEvent_p)
  XEN_NARGIFY_1(XEN_XSelectionClearEvent_p_w, XEN_XSelectionClearEvent_p)
  XEN_NARGIFY_1(XEN_XSelectionEvent_p_w, XEN_XSelectionEvent_p)
  XEN_NARGIFY_1(XEN_XSelectionRequestEvent_p_w, XEN_XSelectionRequestEvent_p)
  XEN_NARGIFY_1(XEN_XSetWindowAttributes_p_w, XEN_XSetWindowAttributes_p)
  XEN_NARGIFY_1(XEN_XUnmapEvent_p_w, XEN_XUnmapEvent_p)
  XEN_NARGIFY_1(XEN_XVisibilityEvent_p_w, XEN_XVisibilityEvent_p)
  XEN_NARGIFY_1(XEN_XIconSize_p_w, XEN_XIconSize_p)

#if HAVE_MOTIF
  XEN_ARGIFY_4(gxm_XmCreateMessageBox_w, gxm_XmCreateMessageBox)
  XEN_ARGIFY_4(gxm_XmCreateMessageDialog_w, gxm_XmCreateMessageDialog)
  XEN_ARGIFY_4(gxm_XmCreateErrorDialog_w, gxm_XmCreateErrorDialog)
  XEN_ARGIFY_4(gxm_XmCreateInformationDialog_w, gxm_XmCreateInformationDialog)
  XEN_ARGIFY_4(gxm_XmCreateQuestionDialog_w, gxm_XmCreateQuestionDialog)
  XEN_ARGIFY_4(gxm_XmCreateWarningDialog_w, gxm_XmCreateWarningDialog)
  XEN_ARGIFY_4(gxm_XmCreateWorkingDialog_w, gxm_XmCreateWorkingDialog)
  XEN_ARGIFY_4(gxm_XmCreateTemplateDialog_w, gxm_XmCreateTemplateDialog)
  XEN_NARGIFY_2(gxm_XmMessageBoxGetChild_w, gxm_XmMessageBoxGetChild)
  XEN_ARGIFY_4(gxm_XmCreateArrowButtonGadget_w, gxm_XmCreateArrowButtonGadget)
  XEN_ARGIFY_4(gxm_XmCreateArrowButton_w, gxm_XmCreateArrowButton)
  XEN_ARGIFY_4(gxm_XmCreateNotebook_w, gxm_XmCreateNotebook)
  XEN_NARGIFY_2(gxm_XmNotebookGetPageInfo_w, gxm_XmNotebookGetPageInfo)
#if HAVE_XM_XP
  XEN_ARGIFY_5(gxm_XmPrintSetup_w, gxm_XmPrintSetup)
  XEN_NARGIFY_4(gxm_XmPrintToFile_w, gxm_XmPrintToFile)
  XEN_NARGIFY_2(gxm_XmPrintPopupPDM_w, gxm_XmPrintPopupPDM)
  XEN_NARGIFY_1(gxm_XmRedisplayWidget_w, gxm_XmRedisplayWidget)
#endif
  XEN_NARGIFY_5(gxm_XmTransferSetParameters_w, gxm_XmTransferSetParameters)
  XEN_NARGIFY_2(gxm_XmTransferDone_w, gxm_XmTransferDone)
  XEN_NARGIFY_5(gxm_XmTransferValue_w, gxm_XmTransferValue)
  XEN_NARGIFY_1(gxm_XmTransferStartRequest_w, gxm_XmTransferStartRequest)
  XEN_NARGIFY_2(gxm_XmTransferSendRequest_w, gxm_XmTransferSendRequest)
  XEN_ARGIFY_4(gxm_XmCreateComboBox_w, gxm_XmCreateComboBox)
  XEN_ARGIFY_4(gxm_XmCreateDropDownComboBox_w, gxm_XmCreateDropDownComboBox)
  XEN_ARGIFY_4(gxm_XmCreateDropDownList_w, gxm_XmCreateDropDownList)
  XEN_NARGIFY_4(gxm_XmComboBoxAddItem_w, gxm_XmComboBoxAddItem)
  XEN_NARGIFY_2(gxm_XmComboBoxDeletePos_w, gxm_XmComboBoxDeletePos)
  XEN_NARGIFY_2(gxm_XmComboBoxSelectItem_w, gxm_XmComboBoxSelectItem)
  XEN_NARGIFY_2(gxm_XmComboBoxSetItem_w, gxm_XmComboBoxSetItem)
  XEN_NARGIFY_1(gxm_XmComboBoxUpdate_w, gxm_XmComboBoxUpdate)
  XEN_ARGIFY_4(gxm_XmCreateContainer_w, gxm_XmCreateContainer)
  XEN_NARGIFY_2(gxm_XmContainerGetItemChildren_w, gxm_XmContainerGetItemChildren)
  XEN_NARGIFY_1(gxm_XmContainerRelayout_w, gxm_XmContainerRelayout)
  XEN_NARGIFY_3(gxm_XmContainerReorder_w, gxm_XmContainerReorder)
  XEN_NARGIFY_2(gxm_XmContainerCut_w, gxm_XmContainerCut)
  XEN_NARGIFY_2(gxm_XmContainerCopy_w, gxm_XmContainerCopy)
  XEN_NARGIFY_1(gxm_XmContainerPaste_w, gxm_XmContainerPaste)
  XEN_NARGIFY_2(gxm_XmContainerCopyLink_w, gxm_XmContainerCopyLink)
  XEN_NARGIFY_1(gxm_XmContainerPasteLink_w, gxm_XmContainerPasteLink)
  XEN_ARGIFY_4(gxm_XmCreateSpinBox_w, gxm_XmCreateSpinBox)
  XEN_NARGIFY_1(gxm_XmSpinBoxValidatePosition_w, gxm_XmSpinBoxValidatePosition)
  XEN_ARGIFY_4(gxm_XmCreateSimpleSpinBox_w, gxm_XmCreateSimpleSpinBox)
  XEN_NARGIFY_3(gxm_XmSimpleSpinBoxAddItem_w, gxm_XmSimpleSpinBoxAddItem)
  XEN_NARGIFY_2(gxm_XmSimpleSpinBoxDeletePos_w, gxm_XmSimpleSpinBoxDeletePos)
  XEN_NARGIFY_2(gxm_XmSimpleSpinBoxSetItem_w, gxm_XmSimpleSpinBoxSetItem)
  XEN_NARGIFY_1(gxm_XmDropSiteRegistered_w, gxm_XmDropSiteRegistered)
  XEN_NARGIFY_2(gxm_XmTextFieldCopyLink_w, gxm_XmTextFieldCopyLink)
  XEN_NARGIFY_1(gxm_XmTextFieldPasteLink_w, gxm_XmTextFieldPasteLink)
  XEN_NARGIFY_1(gxm_XmTextGetCenterline_w, gxm_XmTextGetCenterline)
  XEN_NARGIFY_3(gxm_XmToggleButtonGadgetSetValue_w, gxm_XmToggleButtonGadgetSetValue)
  XEN_ARGIFY_4(gxm_XmCreateIconGadget_w, gxm_XmCreateIconGadget)
  XEN_ARGIFY_4(gxm_XmCreateIconHeader_w, gxm_XmCreateIconHeader)
  XEN_NARGIFY_3(gxm_XmObjectAtPoint_w, gxm_XmObjectAtPoint)
  XEN_NARGIFY_4(gxm_XmConvertStringToUnits_w, gxm_XmConvertStringToUnits)
  XEN_ARGIFY_4(gxm_XmCreateGrabShell_w, gxm_XmCreateGrabShell)
  XEN_NARGIFY_3(gxm_XmToggleButtonSetValue_w, gxm_XmToggleButtonSetValue)
  XEN_NARGIFY_1(gxm_XmTextPasteLink_w, gxm_XmTextPasteLink)
  XEN_NARGIFY_2(gxm_XmTextCopyLink_w, gxm_XmTextCopyLink)
  XEN_NARGIFY_7(gxm_XmScaleSetTicks_w, gxm_XmScaleSetTicks)
  XEN_NARGIFY_3(gxm_XmInternAtom_w, gxm_XmInternAtom)
  XEN_NARGIFY_2(gxm_XmGetAtomName_w, gxm_XmGetAtomName)
  XEN_ARGIFY_4(gxm_XmCreatePanedWindow_w, gxm_XmCreatePanedWindow)
  XEN_ARGIFY_4(gxm_XmCreateBulletinBoard_w, gxm_XmCreateBulletinBoard)
  XEN_ARGIFY_4(gxm_XmCreateBulletinBoardDialog_w, gxm_XmCreateBulletinBoardDialog)
  XEN_ARGIFY_4(gxm_XmCreateCascadeButtonGadget_w, gxm_XmCreateCascadeButtonGadget)
  XEN_NARGIFY_2(gxm_XmCascadeButtonGadgetHighlight_w, gxm_XmCascadeButtonGadgetHighlight)
  XEN_ARGIFY_4(gxm_XmAddProtocols_w, gxm_XmAddProtocols)
  XEN_ARGIFY_4(gxm_XmRemoveProtocols_w, gxm_XmRemoveProtocols)
  XEN_NARGIFY_5(gxm_XmAddProtocolCallback_w, gxm_XmAddProtocolCallback)
  XEN_NARGIFY_5(gxm_XmRemoveProtocolCallback_w, gxm_XmRemoveProtocolCallback)
  XEN_NARGIFY_3(gxm_XmActivateProtocol_w, gxm_XmActivateProtocol)
  XEN_NARGIFY_3(gxm_XmDeactivateProtocol_w, gxm_XmDeactivateProtocol)
  XEN_NARGIFY_7(gxm_XmSetProtocolHooks_w, gxm_XmSetProtocolHooks)
  XEN_ARGIFY_4(gxm_XmCreateCascadeButton_w, gxm_XmCreateCascadeButton)
  XEN_NARGIFY_2(gxm_XmCascadeButtonHighlight_w, gxm_XmCascadeButtonHighlight)
  XEN_ARGIFY_4(gxm_XmCreatePushButtonGadget_w, gxm_XmCreatePushButtonGadget)
  XEN_ARGIFY_4(gxm_XmCreatePushButton_w, gxm_XmCreatePushButton)
  XEN_ARGIFY_4(gxm_XmCreateCommand_w, gxm_XmCreateCommand)
  XEN_NARGIFY_2(gxm_XmCommandGetChild_w, gxm_XmCommandGetChild)
  XEN_NARGIFY_2(gxm_XmCommandSetValue_w, gxm_XmCommandSetValue)
  XEN_NARGIFY_2(gxm_XmCommandAppendValue_w, gxm_XmCommandAppendValue)
  XEN_NARGIFY_2(gxm_XmCommandError_w, gxm_XmCommandError)
  XEN_ARGIFY_4(gxm_XmCreateCommandDialog_w, gxm_XmCreateCommandDialog)
  XEN_NARGIFY_2(gxm_XmMenuPosition_w, gxm_XmMenuPosition)
  XEN_ARGIFY_4(gxm_XmCreateRowColumn_w, gxm_XmCreateRowColumn)
  XEN_ARGIFY_4(gxm_XmCreateWorkArea_w, gxm_XmCreateWorkArea)
  XEN_ARGIFY_4(gxm_XmCreateRadioBox_w, gxm_XmCreateRadioBox)
  XEN_ARGIFY_4(gxm_XmCreateOptionMenu_w, gxm_XmCreateOptionMenu)
  XEN_NARGIFY_1(gxm_XmOptionLabelGadget_w, gxm_XmOptionLabelGadget)
  XEN_NARGIFY_1(gxm_XmOptionButtonGadget_w, gxm_XmOptionButtonGadget)
  XEN_ARGIFY_4(gxm_XmCreateMenuBar_w, gxm_XmCreateMenuBar)
  XEN_ARGIFY_4(gxm_XmCreatePopupMenu_w, gxm_XmCreatePopupMenu)
  XEN_ARGIFY_4(gxm_XmCreatePulldownMenu_w, gxm_XmCreatePulldownMenu)
  XEN_NARGIFY_1(gxm_XmGetPostedFromWidget_w, gxm_XmGetPostedFromWidget)
  XEN_NARGIFY_1(gxm_XmGetTearOffControl_w, gxm_XmGetTearOffControl)
#if (!XM_DISABLE_DEPRECATED)
  XEN_NARGIFY_2(gxm_XmAddToPostFromList_w, gxm_XmAddToPostFromList)
  XEN_NARGIFY_2(gxm_XmRemoveFromPostFromList_w, gxm_XmRemoveFromPostFromList)
#endif
  XEN_NARGIFY_2(gxm_XmScaleSetValue_w, gxm_XmScaleSetValue)
  XEN_NARGIFY_1(gxm_XmScaleGetValue_w, gxm_XmScaleGetValue)
  XEN_ARGIFY_4(gxm_XmCreateScale_w, gxm_XmCreateScale)
  XEN_NARGIFY_5(gxm_XmClipboardBeginCopy_w, gxm_XmClipboardBeginCopy)
  XEN_NARGIFY_6(gxm_XmClipboardStartCopy_w, gxm_XmClipboardStartCopy)
  XEN_NARGIFY_7(gxm_XmClipboardCopy_w, gxm_XmClipboardCopy)
  XEN_NARGIFY_3(gxm_XmClipboardEndCopy_w, gxm_XmClipboardEndCopy)
  XEN_NARGIFY_3(gxm_XmClipboardCancelCopy_w, gxm_XmClipboardCancelCopy)
  XEN_NARGIFY_3(gxm_XmClipboardWithdrawFormat_w, gxm_XmClipboardWithdrawFormat)
  XEN_NARGIFY_6(gxm_XmClipboardCopyByName_w, gxm_XmClipboardCopyByName)
  XEN_NARGIFY_2(gxm_XmClipboardUndoCopy_w, gxm_XmClipboardUndoCopy)
  XEN_NARGIFY_2(gxm_XmClipboardLock_w, gxm_XmClipboardLock)
  XEN_NARGIFY_3(gxm_XmClipboardUnlock_w, gxm_XmClipboardUnlock)
  XEN_NARGIFY_3(gxm_XmClipboardStartRetrieve_w, gxm_XmClipboardStartRetrieve)
  XEN_NARGIFY_2(gxm_XmClipboardEndRetrieve_w, gxm_XmClipboardEndRetrieve)
  XEN_NARGIFY_4(gxm_XmClipboardRetrieve_w, gxm_XmClipboardRetrieve)
  XEN_NARGIFY_2(gxm_XmClipboardInquireCount_w, gxm_XmClipboardInquireCount)
  XEN_NARGIFY_4(gxm_XmClipboardInquireFormat_w, gxm_XmClipboardInquireFormat)
  XEN_NARGIFY_3(gxm_XmClipboardInquireLength_w, gxm_XmClipboardInquireLength)
  XEN_NARGIFY_3(gxm_XmClipboardInquirePendingItems_w, gxm_XmClipboardInquirePendingItems)
  XEN_NARGIFY_3(gxm_XmClipboardRegisterFormat_w, gxm_XmClipboardRegisterFormat)
#if HAVE_XmToolTipGetLabel
  XEN_NARGIFY_1(gxm_XmToolTipGetLabel_w, gxm_XmToolTipGetLabel)
#endif
  XEN_NARGIFY_1(gxm_XmGetXmScreen_w, gxm_XmGetXmScreen)
#if HAVE_XmCreateFontSelector
    XEN_ARGIFY_4(gxm_XmCreateFontSelector_w, gxm_XmCreateFontSelector)
#endif
#if HAVE_XmCreateColorSelector
    XEN_ARGIFY_4(gxm_XmCreateColorSelector_w, gxm_XmCreateColorSelector)
#endif
  XEN_ARGIFY_4(gxm_XmCreateScrollBar_w, gxm_XmCreateScrollBar)
  XEN_NARGIFY_1(gxm_XmScrollBarGetValues_w, gxm_XmScrollBarGetValues)
  XEN_NARGIFY_6(gxm_XmScrollBarSetValues_w, gxm_XmScrollBarSetValues)
  XEN_ARGIFY_4(gxm_XmCreateDialogShell_w, gxm_XmCreateDialogShell)
  XEN_ARGIFY_4(gxm_XmCreateScrolledWindow_w, gxm_XmCreateScrolledWindow)
  XEN_NARGIFY_4(gxm_XmScrollVisible_w, gxm_XmScrollVisible)
  XEN_NARGIFY_2(gxm_XmGetDragContext_w, gxm_XmGetDragContext)
  XEN_NARGIFY_1(gxm_XmGetXmDisplay_w, gxm_XmGetXmDisplay)
  XEN_NARGIFY_2(gxm_XmSelectionBoxGetChild_w, gxm_XmSelectionBoxGetChild)
  XEN_ARGIFY_4(gxm_XmCreateSelectionBox_w, gxm_XmCreateSelectionBox)
  XEN_ARGIFY_4(gxm_XmCreateSelectionDialog_w, gxm_XmCreateSelectionDialog)
  XEN_ARGIFY_4(gxm_XmCreatePromptDialog_w, gxm_XmCreatePromptDialog)
  XEN_ARGIFY_4(gxm_XmDragStart_w, gxm_XmDragStart)
  XEN_NARGIFY_1(gxm_XmDragCancel_w, gxm_XmDragCancel)
  XEN_NARGIFY_5(gxm_XmTargetsAreCompatible_w, gxm_XmTargetsAreCompatible)
  XEN_ARGIFY_4(gxm_XmCreateSeparatorGadget_w, gxm_XmCreateSeparatorGadget)
  XEN_ARGIFY_4(gxm_XmCreateDragIcon_w, gxm_XmCreateDragIcon)
  XEN_ARGIFY_4(gxm_XmCreateSeparator_w, gxm_XmCreateSeparator)
  XEN_ARGIFY_4(gxm_XmCreateDrawingArea_w, gxm_XmCreateDrawingArea)
  XEN_ARGIFY_4(gxm_XmCreateDrawnButton_w, gxm_XmCreateDrawnButton)
  XEN_ARGIFY_3(gxm_XmDropSiteRegister_w, gxm_XmDropSiteRegister)
  XEN_NARGIFY_1(gxm_XmDropSiteUnregister_w, gxm_XmDropSiteUnregister)
  XEN_NARGIFY_1(gxm_XmDropSiteStartUpdate_w, gxm_XmDropSiteStartUpdate)
  XEN_ARGIFY_3(gxm_XmDropSiteUpdate_w, gxm_XmDropSiteUpdate)
  XEN_NARGIFY_1(gxm_XmDropSiteEndUpdate_w, gxm_XmDropSiteEndUpdate)
  XEN_ARGIFY_3(gxm_XmDropSiteRetrieve_w, gxm_XmDropSiteRetrieve)
  XEN_NARGIFY_1(gxm_XmDropSiteQueryStackingOrder_w, gxm_XmDropSiteQueryStackingOrder)
  XEN_NARGIFY_3(gxm_XmDropSiteConfigureStackingOrder_w, gxm_XmDropSiteConfigureStackingOrder)
  XEN_ARGIFY_3(gxm_XmDropTransferStart_w, gxm_XmDropTransferStart)
  XEN_NARGIFY_2(gxm_XmDropTransferAdd_w, gxm_XmDropTransferAdd)
  XEN_NARGIFY_1(gxm_XmTextFieldGetString_w, gxm_XmTextFieldGetString)
  XEN_NARGIFY_3(gxm_XmTextFieldGetSubstring_w, gxm_XmTextFieldGetSubstring)
  XEN_NARGIFY_1(gxm_XmTextFieldGetLastPosition_w, gxm_XmTextFieldGetLastPosition)
  XEN_NARGIFY_2(gxm_XmTextFieldSetString_w, gxm_XmTextFieldSetString)
  XEN_NARGIFY_4(gxm_XmTextFieldReplace_w, gxm_XmTextFieldReplace)
  XEN_NARGIFY_3(gxm_XmTextFieldInsert_w, gxm_XmTextFieldInsert)
  XEN_NARGIFY_2(gxm_XmTextFieldSetAddMode_w, gxm_XmTextFieldSetAddMode)
  XEN_NARGIFY_1(gxm_XmTextFieldGetAddMode_w, gxm_XmTextFieldGetAddMode)
  XEN_NARGIFY_1(gxm_XmTextFieldGetEditable_w, gxm_XmTextFieldGetEditable)
  XEN_NARGIFY_2(gxm_XmTextFieldSetEditable_w, gxm_XmTextFieldSetEditable)
  XEN_NARGIFY_1(gxm_XmTextFieldGetMaxLength_w, gxm_XmTextFieldGetMaxLength)
  XEN_NARGIFY_2(gxm_XmTextFieldSetMaxLength_w, gxm_XmTextFieldSetMaxLength)
  XEN_NARGIFY_1(gxm_XmTextFieldGetCursorPosition_w, gxm_XmTextFieldGetCursorPosition)
  XEN_NARGIFY_1(gxm_XmTextFieldGetInsertionPosition_w, gxm_XmTextFieldGetInsertionPosition)
  XEN_NARGIFY_2(gxm_XmTextFieldSetCursorPosition_w, gxm_XmTextFieldSetCursorPosition)
  XEN_NARGIFY_2(gxm_XmTextFieldSetInsertionPosition_w, gxm_XmTextFieldSetInsertionPosition)
  XEN_NARGIFY_1(gxm_XmTextFieldGetSelectionPosition_w, gxm_XmTextFieldGetSelectionPosition)
  XEN_NARGIFY_1(gxm_XmTextFieldGetSelection_w, gxm_XmTextFieldGetSelection)
  XEN_NARGIFY_1(gxm_XmTextFieldRemove_w, gxm_XmTextFieldRemove)
  XEN_NARGIFY_2(gxm_XmTextFieldCopy_w, gxm_XmTextFieldCopy)
  XEN_NARGIFY_2(gxm_XmTextFieldCut_w, gxm_XmTextFieldCut)
  XEN_NARGIFY_1(gxm_XmTextFieldPaste_w, gxm_XmTextFieldPaste)
  XEN_NARGIFY_2(gxm_XmTextFieldClearSelection_w, gxm_XmTextFieldClearSelection)
  XEN_NARGIFY_4(gxm_XmTextFieldSetSelection_w, gxm_XmTextFieldSetSelection)
  XEN_NARGIFY_3(gxm_XmTextFieldXYToPos_w, gxm_XmTextFieldXYToPos)
  XEN_NARGIFY_2(gxm_XmTextFieldPosToXY_w, gxm_XmTextFieldPosToXY)
  XEN_NARGIFY_2(gxm_XmTextFieldShowPosition_w, gxm_XmTextFieldShowPosition)
  XEN_NARGIFY_4(gxm_XmTextFieldSetHighlight_w, gxm_XmTextFieldSetHighlight)
  XEN_NARGIFY_1(gxm_XmTextFieldGetBaseline_w, gxm_XmTextFieldGetBaseline)
  XEN_ARGIFY_4(gxm_XmCreateTextField_w, gxm_XmCreateTextField)
  XEN_NARGIFY_2(gxm_XmFileSelectionBoxGetChild_w, gxm_XmFileSelectionBoxGetChild)
  XEN_NARGIFY_2(gxm_XmFileSelectionDoSearch_w, gxm_XmFileSelectionDoSearch)
  XEN_ARGIFY_4(gxm_XmCreateFileSelectionBox_w, gxm_XmCreateFileSelectionBox)
  XEN_ARGIFY_4(gxm_XmCreateFileSelectionDialog_w, gxm_XmCreateFileSelectionDialog)
  XEN_NARGIFY_4(gxm_XmTextSetHighlight_w, gxm_XmTextSetHighlight)
  XEN_ARGIFY_4(gxm_XmCreateScrolledText_w, gxm_XmCreateScrolledText)
  XEN_ARGIFY_4(gxm_XmCreateText_w, gxm_XmCreateText)
  XEN_NARGIFY_3(gxm_XmTextGetSubstring_w, gxm_XmTextGetSubstring)
  XEN_NARGIFY_1(gxm_XmTextGetString_w, gxm_XmTextGetString)
  XEN_NARGIFY_1(gxm_XmTextGetLastPosition_w, gxm_XmTextGetLastPosition)
  XEN_NARGIFY_2(gxm_XmTextSetString_w, gxm_XmTextSetString)
  XEN_NARGIFY_4(gxm_XmTextReplace_w, gxm_XmTextReplace)
  XEN_NARGIFY_3(gxm_XmTextInsert_w, gxm_XmTextInsert)
  XEN_NARGIFY_2(gxm_XmTextSetAddMode_w, gxm_XmTextSetAddMode)
  XEN_NARGIFY_1(gxm_XmTextGetAddMode_w, gxm_XmTextGetAddMode)
  XEN_NARGIFY_1(gxm_XmTextGetEditable_w, gxm_XmTextGetEditable)
  XEN_NARGIFY_2(gxm_XmTextSetEditable_w, gxm_XmTextSetEditable)
  XEN_NARGIFY_1(gxm_XmTextGetMaxLength_w, gxm_XmTextGetMaxLength)
  XEN_NARGIFY_2(gxm_XmTextSetMaxLength_w, gxm_XmTextSetMaxLength)
  XEN_NARGIFY_1(gxm_XmTextGetTopCharacter_w, gxm_XmTextGetTopCharacter)
  XEN_NARGIFY_2(gxm_XmTextSetTopCharacter_w, gxm_XmTextSetTopCharacter)
  XEN_NARGIFY_1(gxm_XmTextGetCursorPosition_w, gxm_XmTextGetCursorPosition)
  XEN_NARGIFY_1(gxm_XmTextGetInsertionPosition_w, gxm_XmTextGetInsertionPosition)
  XEN_NARGIFY_2(gxm_XmTextSetInsertionPosition_w, gxm_XmTextSetInsertionPosition)
  XEN_NARGIFY_2(gxm_XmTextSetCursorPosition_w, gxm_XmTextSetCursorPosition)
  XEN_NARGIFY_1(gxm_XmTextRemove_w, gxm_XmTextRemove)
  XEN_NARGIFY_2(gxm_XmTextCopy_w, gxm_XmTextCopy)
  XEN_NARGIFY_2(gxm_XmTextCut_w, gxm_XmTextCut)
  XEN_NARGIFY_1(gxm_XmTextPaste_w, gxm_XmTextPaste)
  XEN_NARGIFY_1(gxm_XmTextGetSelection_w, gxm_XmTextGetSelection)
  XEN_NARGIFY_4(gxm_XmTextSetSelection_w, gxm_XmTextSetSelection)
  XEN_NARGIFY_2(gxm_XmTextClearSelection_w, gxm_XmTextClearSelection)
  XEN_NARGIFY_1(gxm_XmTextGetSelectionPosition_w, gxm_XmTextGetSelectionPosition)
  XEN_NARGIFY_3(gxm_XmTextXYToPos_w, gxm_XmTextXYToPos)
  XEN_NARGIFY_2(gxm_XmTextPosToXY_w, gxm_XmTextPosToXY)
  XEN_NARGIFY_1(gxm_XmTextGetSource_w, gxm_XmTextGetSource)
  XEN_NARGIFY_4(gxm_XmTextSetSource_w, gxm_XmTextSetSource)
  XEN_NARGIFY_2(gxm_XmTextShowPosition_w, gxm_XmTextShowPosition)
  XEN_NARGIFY_2(gxm_XmTextScroll_w, gxm_XmTextScroll)
  XEN_NARGIFY_1(gxm_XmTextGetBaseline_w, gxm_XmTextGetBaseline)
  XEN_NARGIFY_1(gxm_XmTextDisableRedisplay_w, gxm_XmTextDisableRedisplay)
  XEN_NARGIFY_1(gxm_XmTextEnableRedisplay_w, gxm_XmTextEnableRedisplay)
  XEN_NARGIFY_4(gxm_XmTextFindString_w, gxm_XmTextFindString)
  XEN_ARGIFY_4(gxm_XmCreateForm_w, gxm_XmCreateForm)
  XEN_ARGIFY_4(gxm_XmCreateFormDialog_w, gxm_XmCreateFormDialog)
  XEN_ARGIFY_4(gxm_XmCreateFrame_w, gxm_XmCreateFrame)
  XEN_NARGIFY_1(gxm_XmToggleButtonGadgetGetState_w, gxm_XmToggleButtonGadgetGetState)
  XEN_NARGIFY_3(gxm_XmToggleButtonGadgetSetState_w, gxm_XmToggleButtonGadgetSetState)
  XEN_ARGIFY_4(gxm_XmCreateToggleButtonGadget_w, gxm_XmCreateToggleButtonGadget)
  XEN_NARGIFY_1(gxm_XmToggleButtonGetState_w, gxm_XmToggleButtonGetState)
  XEN_NARGIFY_3(gxm_XmToggleButtonSetState_w, gxm_XmToggleButtonSetState)
  XEN_ARGIFY_4(gxm_XmCreateToggleButton_w, gxm_XmCreateToggleButton)
  XEN_ARGIFY_4(gxm_XmCreateLabelGadget_w, gxm_XmCreateLabelGadget)
  XEN_ARGIFY_4(gxm_XmCreateLabel_w, gxm_XmCreateLabel)
  XEN_NARGIFY_1(gxm_XmIsMotifWMRunning_w, gxm_XmIsMotifWMRunning)
  XEN_NARGIFY_3(gxm_XmListAddItem_w, gxm_XmListAddItem)
  XEN_NARGIFY_4(gxm_XmListAddItems_w, gxm_XmListAddItems)
  XEN_NARGIFY_4(gxm_XmListAddItemsUnselected_w, gxm_XmListAddItemsUnselected)
  XEN_NARGIFY_3(gxm_XmListAddItemUnselected_w, gxm_XmListAddItemUnselected)
  XEN_NARGIFY_2(gxm_XmListDeleteItem_w, gxm_XmListDeleteItem)
  XEN_ARGIFY_3(gxm_XmListDeleteItems_w, gxm_XmListDeleteItems)
  XEN_ARGIFY_3(gxm_XmListDeletePositions_w, gxm_XmListDeletePositions)
  XEN_NARGIFY_2(gxm_XmListDeletePos_w, gxm_XmListDeletePos)
  XEN_NARGIFY_3(gxm_XmListDeleteItemsPos_w, gxm_XmListDeleteItemsPos)
  XEN_NARGIFY_1(gxm_XmListDeleteAllItems_w, gxm_XmListDeleteAllItems)
  XEN_NARGIFY_4(gxm_XmListReplaceItems_w, gxm_XmListReplaceItems)
  XEN_NARGIFY_4(gxm_XmListReplaceItemsPos_w, gxm_XmListReplaceItemsPos)
  XEN_NARGIFY_4(gxm_XmListReplaceItemsUnselected_w, gxm_XmListReplaceItemsUnselected)
  XEN_NARGIFY_4(gxm_XmListReplaceItemsPosUnselected_w, gxm_XmListReplaceItemsPosUnselected)
  XEN_NARGIFY_4(gxm_XmListReplacePositions_w, gxm_XmListReplacePositions)
  XEN_NARGIFY_3(gxm_XmListSelectItem_w, gxm_XmListSelectItem)
  XEN_NARGIFY_3(gxm_XmListSelectPos_w, gxm_XmListSelectPos)
  XEN_NARGIFY_2(gxm_XmListDeselectItem_w, gxm_XmListDeselectItem)
  XEN_NARGIFY_2(gxm_XmListDeselectPos_w, gxm_XmListDeselectPos)
  XEN_NARGIFY_1(gxm_XmListDeselectAllItems_w, gxm_XmListDeselectAllItems)
  XEN_NARGIFY_2(gxm_XmListSetPos_w, gxm_XmListSetPos)
  XEN_NARGIFY_2(gxm_XmListSetBottomPos_w, gxm_XmListSetBottomPos)
  XEN_NARGIFY_2(gxm_XmListSetItem_w, gxm_XmListSetItem)
  XEN_NARGIFY_2(gxm_XmListSetBottomItem_w, gxm_XmListSetBottomItem)
  XEN_NARGIFY_2(gxm_XmListSetAddMode_w, gxm_XmListSetAddMode)
  XEN_NARGIFY_2(gxm_XmListItemExists_w, gxm_XmListItemExists)
  XEN_NARGIFY_2(gxm_XmListItemPos_w, gxm_XmListItemPos)
  XEN_NARGIFY_1(gxm_XmListGetKbdItemPos_w, gxm_XmListGetKbdItemPos)
  XEN_NARGIFY_2(gxm_XmListSetKbdItemPos_w, gxm_XmListSetKbdItemPos)
  XEN_NARGIFY_2(gxm_XmListYToPos_w, gxm_XmListYToPos)
  XEN_NARGIFY_2(gxm_XmListPosToBounds_w, gxm_XmListPosToBounds)
  XEN_NARGIFY_2(gxm_XmListGetMatchPos_w, gxm_XmListGetMatchPos)
  XEN_NARGIFY_2(gxm_XmListSetHorizPos_w, gxm_XmListSetHorizPos)
  XEN_NARGIFY_1(gxm_XmListUpdateSelectedList_w, gxm_XmListUpdateSelectedList)
  XEN_NARGIFY_2(gxm_XmListPosSelected_w, gxm_XmListPosSelected)
  XEN_ARGIFY_4(gxm_XmCreateList_w, gxm_XmCreateList)
  XEN_ARGIFY_4(gxm_XmCreateScrolledList_w, gxm_XmCreateScrolledList)
  XEN_NARGIFY_3(gxm_XmTranslateKey_w, gxm_XmTranslateKey)
  XEN_ARGIFY_4(gxm_XmCreateMainWindow_w, gxm_XmCreateMainWindow)
  XEN_NARGIFY_2(gxm_XmInstallImage_w, gxm_XmInstallImage)
  XEN_NARGIFY_1(gxm_XmUninstallImage_w, gxm_XmUninstallImage)
  XEN_NARGIFY_4(gxm_XmGetPixmap_w, gxm_XmGetPixmap)
  XEN_NARGIFY_5(gxm_XmGetPixmapByDepth_w, gxm_XmGetPixmapByDepth)
  XEN_NARGIFY_2(gxm_XmDestroyPixmap_w, gxm_XmDestroyPixmap)
  XEN_NARGIFY_1(gxm_XmUpdateDisplay_w, gxm_XmUpdateDisplay)
  XEN_NARGIFY_1(gxm_XmWidgetGetBaselines_w, gxm_XmWidgetGetBaselines)
  XEN_NARGIFY_2(gxm_XmRegisterSegmentEncoding_w, gxm_XmRegisterSegmentEncoding)
  XEN_NARGIFY_1(gxm_XmMapSegmentEncoding_w, gxm_XmMapSegmentEncoding)
  XEN_NARGIFY_1(gxm_XmCvtCTToXmString_w, gxm_XmCvtCTToXmString)
  XEN_NARGIFY_1(gxm_XmCvtXmStringToCT_w, gxm_XmCvtXmStringToCT)
  XEN_NARGIFY_5(gxm_XmConvertUnits_w, gxm_XmConvertUnits)
  XEN_ARGIFY_4(gxm_XmCreateSimpleMenuBar_w, gxm_XmCreateSimpleMenuBar)
  XEN_ARGIFY_4(gxm_XmCreateSimplePopupMenu_w, gxm_XmCreateSimplePopupMenu)
  XEN_ARGIFY_4(gxm_XmCreateSimplePulldownMenu_w, gxm_XmCreateSimplePulldownMenu)
  XEN_ARGIFY_4(gxm_XmCreateSimpleOptionMenu_w, gxm_XmCreateSimpleOptionMenu)
  XEN_ARGIFY_4(gxm_XmCreateSimpleRadioBox_w, gxm_XmCreateSimpleRadioBox)
  XEN_ARGIFY_4(gxm_XmCreateSimpleCheckBox_w, gxm_XmCreateSimpleCheckBox)
  XEN_NARGIFY_3(gxm_XmVaCreateSimpleMenuBar_w, gxm_XmVaCreateSimpleMenuBar)
  XEN_NARGIFY_4(gxm_XmVaCreateSimplePopupMenu_w, gxm_XmVaCreateSimplePopupMenu)
  XEN_NARGIFY_5(gxm_XmVaCreateSimplePulldownMenu_w, gxm_XmVaCreateSimplePulldownMenu)
  XEN_NARGIFY_7(gxm_XmVaCreateSimpleOptionMenu_w, gxm_XmVaCreateSimpleOptionMenu)
  XEN_NARGIFY_5(gxm_XmVaCreateSimpleRadioBox_w, gxm_XmVaCreateSimpleRadioBox)
  XEN_NARGIFY_4(gxm_XmVaCreateSimpleCheckBox_w, gxm_XmVaCreateSimpleCheckBox)
  XEN_NARGIFY_3(gxm_XmTrackingEvent_w, gxm_XmTrackingEvent)
  XEN_NARGIFY_1(gxm_XmSetColorCalculation_w, gxm_XmSetColorCalculation)
  XEN_NARGIFY_0(gxm_XmGetColorCalculation_w, gxm_XmGetColorCalculation)
  XEN_NARGIFY_3(gxm_XmGetColors_w, gxm_XmGetColors)
  XEN_NARGIFY_2(gxm_XmChangeColor_w, gxm_XmChangeColor)
  XEN_NARGIFY_2(gxm_XmStringCreate_w, gxm_XmStringCreate)
  XEN_NARGIFY_1(gxm_XmStringCreateLocalized_w, gxm_XmStringCreateLocalized)
  XEN_NARGIFY_1(gxm_XmStringDirectionCreate_w, gxm_XmStringDirectionCreate)
  XEN_NARGIFY_0(gxm_XmStringSeparatorCreate_w, gxm_XmStringSeparatorCreate)
  XEN_NARGIFY_1(gxm_XmStringInitContext_w, gxm_XmStringInitContext)
  XEN_NARGIFY_1(gxm_XmStringFreeContext_w, gxm_XmStringFreeContext)
  XEN_NARGIFY_2(gxm_XmStringConcatAndFree_w, gxm_XmStringConcatAndFree)
  XEN_NARGIFY_1(gxm_XmStringIsVoid_w, gxm_XmStringIsVoid)
  XEN_NARGIFY_1(gxm_XmStringPeekNextTriple_w, gxm_XmStringPeekNextTriple)
  XEN_NARGIFY_1(gxm_XmStringGetNextTriple_w, gxm_XmStringGetNextTriple)
  XEN_NARGIFY_3(gxm_XmStringComponentCreate_w, gxm_XmStringComponentCreate)
  XEN_NARGIFY_7(gxm_XmStringUnparse_w, gxm_XmStringUnparse)
  XEN_NARGIFY_7(gxm_XmStringParseText_w, gxm_XmStringParseText)
  XEN_NARGIFY_2(gxm_XmStringToXmStringTable_w, gxm_XmStringToXmStringTable)
  XEN_NARGIFY_3(gxm_XmStringTableToXmString_w, gxm_XmStringTableToXmString)
  XEN_NARGIFY_8(gxm_XmStringTableUnparse_w, gxm_XmStringTableUnparse)
  XEN_NARGIFY_7(gxm_XmStringTableParseStringArray_w, gxm_XmStringTableParseStringArray)
  XEN_NARGIFY_1(gxm_XmDirectionToStringDirection_w, gxm_XmDirectionToStringDirection)
  XEN_NARGIFY_1(gxm_XmStringDirectionToDirection_w, gxm_XmStringDirectionToDirection)
  XEN_NARGIFY_4(gxm_XmStringGenerate_w, gxm_XmStringGenerate)
  XEN_NARGIFY_2(gxm_XmStringPutRendition_w, gxm_XmStringPutRendition)
  XEN_ARGIFY_2(gxm_XmParseMappingCreate_w, gxm_XmParseMappingCreate)
  XEN_ARGIFY_3(gxm_XmParseMappingSetValues_w, gxm_XmParseMappingSetValues)
  XEN_ARGIFY_3(gxm_XmParseMappingGetValues_w, gxm_XmParseMappingGetValues)
  XEN_NARGIFY_1(gxm_XmParseMappingFree_w, gxm_XmParseMappingFree)
  XEN_ARGIFY_2(gxm_XmParseTableFree_w, gxm_XmParseTableFree)
  XEN_NARGIFY_5(gxm_XmStringTableProposeTablist_w, gxm_XmStringTableProposeTablist)
  XEN_NARGIFY_2(gxm_XmTabSetValue_w, gxm_XmTabSetValue)
  XEN_NARGIFY_1(gxm_XmTabGetValues_w, gxm_XmTabGetValues)
  XEN_NARGIFY_1(gxm_XmTabFree_w, gxm_XmTabFree)
  XEN_NARGIFY_1(gxm_XmTabListFree_w, gxm_XmTabListFree)
  XEN_NARGIFY_5(gxm_XmTabCreate_w, gxm_XmTabCreate)
  XEN_NARGIFY_1(gxm_XmTabListTabCount_w, gxm_XmTabListTabCount)
  XEN_ARGIFY_3(gxm_XmTabListRemoveTabs_w, gxm_XmTabListRemoveTabs)
  XEN_ARGIFY_4(gxm_XmTabListReplacePositions_w, gxm_XmTabListReplacePositions)
  XEN_NARGIFY_2(gxm_XmTabListGetTab_w, gxm_XmTabListGetTab)
  XEN_NARGIFY_3(gxm_XmTabListCopy_w, gxm_XmTabListCopy)
  XEN_NARGIFY_4(gxm_XmTabListInsertTabs_w, gxm_XmTabListInsertTabs)
  XEN_NARGIFY_3(gxm_XmRenderTableCvtFromProp_w, gxm_XmRenderTableCvtFromProp)
  XEN_NARGIFY_2(gxm_XmRenderTableCvtToProp_w, gxm_XmRenderTableCvtToProp)
  XEN_ARGIFY_3(gxm_XmRenditionUpdate_w, gxm_XmRenditionUpdate)
  XEN_ARGIFY_3(gxm_XmRenditionRetrieve_w, gxm_XmRenditionRetrieve)
  XEN_NARGIFY_1(gxm_XmRenditionFree_w, gxm_XmRenditionFree)
  XEN_ARGIFY_4(gxm_XmRenditionCreate_w, gxm_XmRenditionCreate)
  XEN_ARGIFY_3(gxm_XmRenderTableGetRenditions_w, gxm_XmRenderTableGetRenditions)
  XEN_NARGIFY_2(gxm_XmRenderTableGetRendition_w, gxm_XmRenderTableGetRendition)
  XEN_NARGIFY_1(gxm_XmRenderTableGetTags_w, gxm_XmRenderTableGetTags)
  XEN_NARGIFY_1(gxm_XmRenderTableFree_w, gxm_XmRenderTableFree)
  XEN_ARGIFY_3(gxm_XmRenderTableCopy_w, gxm_XmRenderTableCopy)
  XEN_ARGIFY_3(gxm_XmRenderTableRemoveRenditions_w, gxm_XmRenderTableRemoveRenditions)
  XEN_NARGIFY_4(gxm_XmRenderTableAddRenditions_w, gxm_XmRenderTableAddRenditions)
  XEN_NARGIFY_2(gxm_XmStringConcat_w, gxm_XmStringConcat)
  XEN_NARGIFY_1(gxm_XmStringCopy_w, gxm_XmStringCopy)
  XEN_NARGIFY_2(gxm_XmStringCompare_w, gxm_XmStringCompare)
  XEN_NARGIFY_1(gxm_XmStringEmpty_w, gxm_XmStringEmpty)
  XEN_NARGIFY_2(gxm_XmStringHasSubstring_w, gxm_XmStringHasSubstring)
  XEN_NARGIFY_1(gxm_XmStringFree_w, gxm_XmStringFree)
  XEN_NARGIFY_2(gxm_XmStringBaseline_w, gxm_XmStringBaseline)
  XEN_NARGIFY_2(gxm_XmStringWidth_w, gxm_XmStringWidth)
  XEN_NARGIFY_2(gxm_XmStringHeight_w, gxm_XmStringHeight)
  XEN_NARGIFY_2(gxm_XmStringExtent_w, gxm_XmStringExtent)
  XEN_NARGIFY_1(gxm_XmStringLineCount_w, gxm_XmStringLineCount)
  XEN_VARGIFY(gxm_XmStringDraw_w, gxm_XmStringDraw)
  XEN_VARGIFY(gxm_XmStringDrawImage_w, gxm_XmStringDrawImage)
  XEN_VARGIFY(gxm_XmStringDrawUnderline_w, gxm_XmStringDrawUnderline)

  XEN_NARGIFY_1(gxm_XmGetDestination_w, gxm_XmGetDestination)
  XEN_NARGIFY_1(gxm_XmIsTraversable_w, gxm_XmIsTraversable)
  XEN_NARGIFY_1(gxm_XmGetVisibility_w, gxm_XmGetVisibility)
  XEN_NARGIFY_1(gxm_XmGetTabGroup_w, gxm_XmGetTabGroup)
  XEN_NARGIFY_1(gxm_XmGetFocusWidget_w, gxm_XmGetFocusWidget)
  XEN_NARGIFY_2(gxm_XmProcessTraversal_w, gxm_XmProcessTraversal)
  XEN_ARGIFY_4(gxm_XmCreateMenuShell_w, gxm_XmCreateMenuShell)

  XEN_NARGIFY_1(gxm_XmIsMessageBox_w, gxm_XmIsMessageBox)
  XEN_NARGIFY_1(gxm_XmIsArrowButtonGadget_w, gxm_XmIsArrowButtonGadget)
  XEN_NARGIFY_1(gxm_XmIsArrowButton_w, gxm_XmIsArrowButton)
  XEN_NARGIFY_1(gxm_XmCvtXmStringToByteStream_w, gxm_XmCvtXmStringToByteStream)
  XEN_NARGIFY_1(gxm_XmCvtByteStreamToXmString_w, gxm_XmCvtByteStreamToXmString)
  XEN_NARGIFY_1(gxm_XmStringByteStreamLength_w, gxm_XmStringByteStreamLength)
  XEN_NARGIFY_1(gxm_XmIsNotebook_w, gxm_XmIsNotebook)
#if HAVE_XM_XP
  XEN_NARGIFY_1(gxm_XmIsPrintShell_w, gxm_XmIsPrintShell)
#endif
  XEN_NARGIFY_1(gxm_XmIsComboBox_w, gxm_XmIsComboBox)
  XEN_NARGIFY_1(gxm_XmIsContainer_w, gxm_XmIsContainer)
  XEN_NARGIFY_1(gxm_XmIsGrabShell_w, gxm_XmIsGrabShell)
  XEN_NARGIFY_1(gxm_XmIsIconGadget_w, gxm_XmIsIconGadget)
  XEN_NARGIFY_1(gxm_XmIsIconHeader_w, gxm_XmIsIconHeader)
  XEN_NARGIFY_1(gxm_XmIsPanedWindow_w, gxm_XmIsPanedWindow)
  XEN_NARGIFY_1(gxm_XmIsBulletinBoard_w, gxm_XmIsBulletinBoard)
  XEN_NARGIFY_1(gxm_XmIsPrimitive_w, gxm_XmIsPrimitive)
  XEN_NARGIFY_1(gxm_XmIsCascadeButtonGadget_w, gxm_XmIsCascadeButtonGadget)
  XEN_NARGIFY_1(gxm_XmIsCascadeButton_w, gxm_XmIsCascadeButton)
  XEN_NARGIFY_1(gxm_XmIsPushButtonGadget_w, gxm_XmIsPushButtonGadget)
  XEN_NARGIFY_1(gxm_XmIsPushButton_w, gxm_XmIsPushButton)
  XEN_NARGIFY_1(gxm_XmIsCommand_w, gxm_XmIsCommand)
  XEN_NARGIFY_1(gxm_XmIsRowColumn_w, gxm_XmIsRowColumn)
  XEN_NARGIFY_1(gxm_XmIsScale_w, gxm_XmIsScale)
  XEN_NARGIFY_1(gxm_XmIsScreen_w, gxm_XmIsScreen)
  XEN_NARGIFY_1(gxm_XmIsScrollBar_w, gxm_XmIsScrollBar)
  XEN_NARGIFY_1(gxm_XmIsDialogShell_w, gxm_XmIsDialogShell)
  XEN_NARGIFY_1(gxm_XmIsScrolledWindow_w, gxm_XmIsScrolledWindow)
  XEN_NARGIFY_1(gxm_XmIsDisplay_w, gxm_XmIsDisplay)
  XEN_NARGIFY_1(gxm_XmIsSelectionBox_w, gxm_XmIsSelectionBox)
  XEN_NARGIFY_1(gxm_XmIsDragContext_w, gxm_XmIsDragContext)
  XEN_NARGIFY_1(gxm_XmIsSeparatorGadget_w, gxm_XmIsSeparatorGadget)
  XEN_NARGIFY_1(gxm_XmIsDragIconObjectClass_w, gxm_XmIsDragIconObjectClass)
  XEN_NARGIFY_1(gxm_XmIsSeparator_w, gxm_XmIsSeparator)
  XEN_NARGIFY_1(gxm_XmIsDrawingArea_w, gxm_XmIsDrawingArea)
  XEN_NARGIFY_1(gxm_XmIsDrawnButton_w, gxm_XmIsDrawnButton)
  XEN_NARGIFY_1(gxm_XmIsDropSiteManager_w, gxm_XmIsDropSiteManager)
  XEN_NARGIFY_1(gxm_XmIsDropTransfer_w, gxm_XmIsDropTransfer)
  XEN_NARGIFY_1(gxm_XmIsTextField_w, gxm_XmIsTextField)
  XEN_NARGIFY_1(gxm_XmIsFileSelectionBox_w, gxm_XmIsFileSelectionBox)
  XEN_NARGIFY_1(gxm_XmIsText_w, gxm_XmIsText)
  XEN_NARGIFY_1(gxm_XmIsForm_w, gxm_XmIsForm)
  XEN_NARGIFY_1(gxm_XmIsFrame_w, gxm_XmIsFrame)
  XEN_NARGIFY_1(gxm_XmIsGadget_w, gxm_XmIsGadget)
  XEN_NARGIFY_1(gxm_XmIsToggleButtonGadget_w, gxm_XmIsToggleButtonGadget)
  XEN_NARGIFY_1(gxm_XmIsToggleButton_w, gxm_XmIsToggleButton)
  XEN_NARGIFY_1(gxm_XmIsLabelGadget_w, gxm_XmIsLabelGadget)
  XEN_NARGIFY_1(gxm_XmIsLabel_w, gxm_XmIsLabel)
  XEN_NARGIFY_1(gxm_XmIsVendorShell_w, gxm_XmIsVendorShell)
  XEN_NARGIFY_1(gxm_XmIsList_w, gxm_XmIsList)
  XEN_NARGIFY_1(gxm_XmIsMainWindow_w, gxm_XmIsMainWindow)
  XEN_NARGIFY_1(gxm_XmIsManager_w, gxm_XmIsManager)
  XEN_NARGIFY_1(gxm_XmIsMenuShell_w, gxm_XmIsMenuShell)
  XEN_NARGIFY_1(gxm_XmListGetSelectedPos_w, gxm_XmListGetSelectedPos)
  XEN_NARGIFY_1(gxm_XmWidgetGetDisplayRect_w, gxm_XmWidgetGetDisplayRect)

#if HAVE_XmCreateButtonBox
  XEN_NARGIFY_1(gxm_XmIsButtonBox_w, gxm_XmIsButtonBox)
  XEN_ARGIFY_4(gxm_XmCreateButtonBox_w, gxm_XmCreateButtonBox)
#endif
#if HAVE_XmCreateTabStack
  XEN_ARGIFY_4(gxm_XmCreateTabStack_w, gxm_XmCreateTabStack)
  XEN_NARGIFY_1(gxm_XmIsTabStack_w, gxm_XmIsTabStack)
  XEN_NARGIFY_1(gxm_XmTabStackGetSelectedTab_w, gxm_XmTabStackGetSelectedTab)
  XEN_NARGIFY_2(gxm_XmTabStackSelectTab_w, gxm_XmTabStackSelectTab)
#if HAVE_XmTabStackXYToWidget
  XEN_NARGIFY_2(gxm_XmTabStackIndexToWidget_w, gxm_XmTabStackIndexToWidget)
  XEN_NARGIFY_3(gxm_XmTabStackXYToWidget_w, gxm_XmTabStackXYToWidget)
#endif
#endif
#if HAVE_XmCreateDataField
  XEN_NARGIFY_1(gxm_XmIsDataField_w, gxm_XmIsDataField)
  XEN_ARGIFY_4(gxm_XmCreateDataField_w, gxm_XmCreateDataField)
  XEN_NARGIFY_2(gxm_XmDataFieldSetString_w, gxm_XmDataFieldSetString)
  XEN_NARGIFY_1(gxm_XmDataFieldGetString_w, gxm_XmDataFieldGetString)
  XEN_NARGIFY_4(gxm_XmDataFieldSetHighlight_w, gxm_XmDataFieldSetHighlight)
  XEN_NARGIFY_2(gxm_XmDataFieldSetAddMode_w, gxm_XmDataFieldSetAddMode)
  XEN_NARGIFY_1(gxm_XmDataFieldGetSelection_w, gxm_XmDataFieldGetSelection)
  XEN_NARGIFY_4(gxm_XmDataFieldSetSelection_w, gxm_XmDataFieldSetSelection)
  XEN_NARGIFY_1(gxm_XmDataFieldGetSelectionPosition_w, gxm_XmDataFieldGetSelectionPosition)
  XEN_NARGIFY_3(gxm_XmDataFieldXYToPos_w, gxm_XmDataFieldXYToPos)
  XEN_NARGIFY_2(gxm_XmDataFieldShowPosition_w, gxm_XmDataFieldShowPosition)
  XEN_NARGIFY_2(gxm_XmDataFieldCut_w, gxm_XmDataFieldCut)
  XEN_NARGIFY_2(gxm_XmDataFieldCopy_w, gxm_XmDataFieldCopy)
  XEN_NARGIFY_1(gxm_XmDataFieldPaste_w, gxm_XmDataFieldPaste)
  XEN_NARGIFY_2(gxm_XmDataFieldSetEditable_w, gxm_XmDataFieldSetEditable)
  XEN_NARGIFY_2(gxm_XmDataFieldSetInsertionPosition_w, gxm_XmDataFieldSetInsertionPosition)
#endif
#if HAVE_XmCreateColumn
  XEN_ARGIFY_4(gxm_XmCreateColumn_w, gxm_XmCreateColumn)
  XEN_NARGIFY_1(gxm_XmIsColumn_w, gxm_XmIsColumn)
#if HAVE_XmColumnGetChildLabel
  XEN_NARGIFY_1(gxm_XmColumnGetChildLabel_w, gxm_XmColumnGetChildLabel)
#endif
#endif
#if HAVE_XmCreateDropDown
  XEN_NARGIFY_1(gxm_XmIsDropDown_w, gxm_XmIsDropDown)
  XEN_NARGIFY_1(gxm_XmDropDownGetValue_w, gxm_XmDropDownGetValue)
  XEN_NARGIFY_1(gxm_XmDropDownGetList_w, gxm_XmDropDownGetList)
  XEN_NARGIFY_1(gxm_XmDropDownGetText_w, gxm_XmDropDownGetText)
  XEN_NARGIFY_1(gxm_XmDropDownGetArrow_w, gxm_XmDropDownGetArrow)
  XEN_NARGIFY_1(gxm_XmDropDownGetLabel_w, gxm_XmDropDownGetLabel)
  XEN_ARGIFY_4(gxm_XmCreateDropDown_w, gxm_XmCreateDropDown)
#endif

#if (!XM_DISABLE_DEPRECATED)
  XEN_NARGIFY_1(gxm_XmStringLength_w, gxm_XmStringLength)
  XEN_NARGIFY_2(gxm_XmStringByteCompare_w, gxm_XmStringByteCompare)
  XEN_NARGIFY_4(gxm_XmScrolledWindowSetAreas_w, gxm_XmScrolledWindowSetAreas)
  XEN_NARGIFY_1(gxm_XmFontListEntryFree_w, gxm_XmFontListEntryFree)
  XEN_NARGIFY_1(gxm_XmFontListEntryGetFont_w, gxm_XmFontListEntryGetFont)
  XEN_NARGIFY_1(gxm_XmFontListEntryGetTag_w, gxm_XmFontListEntryGetTag)
  XEN_NARGIFY_2(gxm_XmFontListAppendEntry_w, gxm_XmFontListAppendEntry)
  XEN_NARGIFY_1(gxm_XmFontListNextEntry_w, gxm_XmFontListNextEntry)
  XEN_NARGIFY_2(gxm_XmFontListRemoveEntry_w, gxm_XmFontListRemoveEntry)
  XEN_NARGIFY_4(gxm_XmFontListEntryLoad_w, gxm_XmFontListEntryLoad)
  XEN_NARGIFY_2(gxm_XmFontListCreate_w, gxm_XmFontListCreate)
  XEN_NARGIFY_1(gxm_XmFontListFree_w, gxm_XmFontListFree)
  XEN_NARGIFY_3(gxm_XmFontListAdd_w, gxm_XmFontListAdd)
  XEN_NARGIFY_1(gxm_XmFontListCopy_w, gxm_XmFontListCopy)
  XEN_NARGIFY_1(gxm_XmFontListInitFontContext_w, gxm_XmFontListInitFontContext)
  XEN_NARGIFY_1(gxm_XmFontListGetNextFont_w, gxm_XmFontListGetNextFont)
  XEN_NARGIFY_1(gxm_XmFontListFreeFontContext_w, gxm_XmFontListFreeFontContext)
  XEN_NARGIFY_1(gxm_XmStringGetNextComponent_w, gxm_XmStringGetNextComponent)
  XEN_NARGIFY_1(gxm_XmStringPeekNextComponent_w, gxm_XmStringPeekNextComponent)
  XEN_NARGIFY_1(gxm_XmStringGetNextSegment_w, gxm_XmStringGetNextSegment)
  XEN_NARGIFY_2(gxm_XmStringGetLtoR_w, gxm_XmStringGetLtoR)
  XEN_NARGIFY_3(gxm_XmFontListEntryCreate_w, gxm_XmFontListEntryCreate)
  XEN_NARGIFY_1(gxm_XmStringCreateSimple_w, gxm_XmStringCreateSimple)
  XEN_NARGIFY_4(gxm_XmStringSegmentCreate_w, gxm_XmStringSegmentCreate)
  XEN_NARGIFY_2(gxm_XmStringCreateLtoR_w, gxm_XmStringCreateLtoR)
  XEN_NARGIFY_2(gxm_XmStringNCopy_w, gxm_XmStringNCopy)
  XEN_NARGIFY_3(gxm_XmStringNConcat_w, gxm_XmStringNConcat)
  XEN_NARGIFY_6(gxm_XmMainWindowSetAreas_w, gxm_XmMainWindowSetAreas)
  XEN_NARGIFY_1(gxm_XmMainWindowSep1_w, gxm_XmMainWindowSep1)
  XEN_NARGIFY_1(gxm_XmMainWindowSep2_w, gxm_XmMainWindowSep2)
  XEN_NARGIFY_1(gxm_XmMainWindowSep3_w, gxm_XmMainWindowSep3)
  XEN_NARGIFY_3(gxm_XmSetFontUnits_w, gxm_XmSetFontUnits)
  XEN_NARGIFY_2(gxm_XmSetFontUnit_w, gxm_XmSetFontUnit)
  XEN_NARGIFY_2(gxm_XmSetMenuCursor_w, gxm_XmSetMenuCursor)
  XEN_NARGIFY_1(gxm_XmGetMenuCursor_w, gxm_XmGetMenuCursor)
  XEN_NARGIFY_3(gxm_XmTrackingLocate_w, gxm_XmTrackingLocate)

  XEN_NARGIFY_1(XEN_XmFontList_p_w, XEN_XmFontList_p)
  XEN_NARGIFY_1(XEN_XmFontContext_p_w, XEN_XmFontContext_p)
  XEN_NARGIFY_1(XEN_XmFontListEntry_p_w, XEN_XmFontListEntry_p)
#endif

#endif

#if HAVE_XPM
  XEN_NARGIFY_4(gxm_XpmCreatePixmapFromData_w, gxm_XpmCreatePixmapFromData)
  XEN_NARGIFY_4(gxm_XpmCreateDataFromPixmap_w, gxm_XpmCreateDataFromPixmap)
  XEN_NARGIFY_4(gxm_XpmReadFileToPixmap_w, gxm_XpmReadFileToPixmap)
  XEN_NARGIFY_1(gxm_XpmReadFileToXpmImage_w, gxm_XpmReadFileToXpmImage)
  XEN_NARGIFY_5(gxm_XpmWriteFileFromPixmap_w, gxm_XpmWriteFileFromPixmap)
  XEN_NARGIFY_4(gxm_XpmCreatePixmapFromXpmImage_w, gxm_XpmCreatePixmapFromXpmImage)
  XEN_NARGIFY_4(gxm_XpmCreateXpmImageFromPixmap_w, gxm_XpmCreateXpmImageFromPixmap)
#if HAVE_XPM_GET_ERROR_STRING
  XEN_NARGIFY_1(gxm_XpmGetErrorString_w, gxm_XpmGetErrorString)
#endif
#endif
  XEN_NARGIFY_3(gxm_XGetPixel_w, gxm_XGetPixel)
  XEN_NARGIFY_1(gxm_XDestroyImage_w, gxm_XDestroyImage)
  XEN_NARGIFY_4(gxm_XPutPixel_w, gxm_XPutPixel)
  XEN_NARGIFY_5(gxm_XSubImage_w, gxm_XSubImage)
  XEN_NARGIFY_2(gxm_XAddPixel_w, gxm_XAddPixel)

#if HAVE_MOTIF
  XEN_NARGIFY_1(XEN_XtAppContext_p_w, XEN_XtAppContext_p)
  XEN_NARGIFY_1(XEN_XtRequestId_p_w, XEN_XtRequestId_p)
  XEN_NARGIFY_1(XEN_XtWorkProcId_p_w, XEN_XtWorkProcId_p)
  XEN_NARGIFY_1(XEN_XtInputId_p_w, XEN_XtInputId_p)
  XEN_NARGIFY_1(XEN_XtIntervalId_p_w, XEN_XtIntervalId_p)
#endif
  XEN_NARGIFY_1(XEN_Screen_p_w, XEN_Screen_p)
  XEN_NARGIFY_1(XEN_XEvent_p_w, XEN_XEvent_p)
  XEN_NARGIFY_1(XEN_XRectangle_p_w, XEN_XRectangle_p)
  XEN_NARGIFY_1(XEN_XArc_p_w, XEN_XArc_p)
  XEN_NARGIFY_1(XEN_XPoint_p_w, XEN_XPoint_p)
  XEN_NARGIFY_1(XEN_XSegment_p_w, XEN_XSegment_p)
  XEN_NARGIFY_1(XEN_XColor_p_w, XEN_XColor_p)
  XEN_NARGIFY_1(XEN_Atom_p_w, XEN_Atom_p)
  XEN_NARGIFY_1(XEN_Colormap_p_w, XEN_Colormap_p)
  XEN_NARGIFY_1(XEN_XModifierKeymap_p_w, XEN_XModifierKeymap_p)
  XEN_NARGIFY_1(XEN_Depth_p_w, XEN_Depth_p)
  XEN_NARGIFY_1(XEN_Display_p_w, XEN_Display_p)
  XEN_NARGIFY_1(XEN_Font_p_w, XEN_Font_p)
  XEN_NARGIFY_1(XEN_GC_p_w, XEN_GC_p)
  XEN_NARGIFY_1(XEN_KeySym_p_w, XEN_KeySym_p)
  XEN_NARGIFY_1(XEN_Pixel_p_w, XEN_Pixel_p)
  XEN_NARGIFY_1(XEN_Pixmap_p_w, XEN_Pixmap_p)
  XEN_NARGIFY_1(XEN_Region_p_w, XEN_Region_p)
  XEN_NARGIFY_1(XEN_Time_p_w, XEN_Time_p)
  XEN_NARGIFY_1(XEN_Visual_p_w, XEN_Visual_p)
  XEN_NARGIFY_1(XEN_Window_p_w, XEN_Window_p)
#if HAVE_MOTIF
  XEN_NARGIFY_1(XEN_Widget_p_w, XEN_Widget_p)
  XEN_NARGIFY_1(XEN_XmStringContext_p_w, XEN_XmStringContext_p)
#endif
  XEN_NARGIFY_1(XEN_XFontProp_p_w, XEN_XFontProp_p)
  XEN_NARGIFY_1(XEN_XFontSet_p_w, XEN_XFontSet_p)
  XEN_NARGIFY_1(XEN_XFontStruct_p_w, XEN_XFontStruct_p)
  XEN_NARGIFY_1(XEN_XGCValues_p_w, XEN_XGCValues_p)
  XEN_NARGIFY_1(XEN_XImage_p_w, XEN_XImage_p)
  XEN_NARGIFY_1(XEN_XVisualInfo_p_w, XEN_XVisualInfo_p)
  XEN_NARGIFY_1(XEN_XWMHints_p_w, XEN_XWMHints_p)
  XEN_NARGIFY_1(XEN_XWindowAttributes_p_w, XEN_XWindowAttributes_p)
  XEN_NARGIFY_1(XEN_XWindowChanges_p_w, XEN_XWindowChanges_p)
  XEN_NARGIFY_1(XEN_KeyCode_p_w, XEN_KeyCode_p)
  XEN_NARGIFY_1(XEN_XContext_p_w, XEN_XContext_p)
  XEN_NARGIFY_1(XEN_XCharStruct_p_w, XEN_XCharStruct_p)
  XEN_NARGIFY_1(XEN_XTextItem_p_w, XEN_XTextItem_p)
  XEN_NARGIFY_1(XEN_XStandardColormap_p_w, XEN_XStandardColormap_p)
  XEN_NARGIFY_1(XEN_Cursor_p_w, XEN_Cursor_p)
#if HAVE_XM_XP
  XEN_NARGIFY_1(XEN_XPContext_p_w, XEN_XPContext_p)
#endif
#if HAVE_MOTIF
  XEN_NARGIFY_1(XEN_WidgetClass_p_w, XEN_WidgetClass_p)
  XEN_NARGIFY_1(XEN_XmString_p_w, XEN_XmString_p)
  XEN_NARGIFY_1(XEN_XmTab_p_w, XEN_XmTab_p)
  XEN_NARGIFY_1(XEN_XmRendition_p_w, XEN_XmRendition_p)
  XEN_NARGIFY_1(XEN_XmRenderTable_p_w, XEN_XmRenderTable_p)
  XEN_NARGIFY_1(XEN_XmTabList_p_w, XEN_XmTabList_p)
  XEN_NARGIFY_1(XEN_XmParseMapping_p_w, XEN_XmParseMapping_p)
  XEN_NARGIFY_1(XEN_XmTextSource_p_w, XEN_XmTextSource_p)
#endif
#if HAVE_XPM
  XEN_NARGIFY_1(XEN_XpmAttributes_p_w, XEN_XpmAttributes_p)
  XEN_NARGIFY_1(XEN_XpmImage_p_w, XEN_XpmImage_p)
  XEN_NARGIFY_1(XEN_XpmColorSymbol_p_w, XEN_XpmColorSymbol_p)
#endif
#if MUS_WITH_EDITRES
  XEN_NARGIFY_4(gxm_XEditResCheckMessages_w, gxm_XEditResCheckMessages)
#endif

#if HAVE_XSHAPEQUERYEXTENSION
  XEN_NARGIFY_1(gxm_XShapeQueryExtension_w, gxm_XShapeQueryExtension)
  XEN_NARGIFY_1(gxm_XShapeQueryVersion_w, gxm_XShapeQueryVersion)
  XEN_NARGIFY_2(gxm_XShapeQueryExtents_w, gxm_XShapeQueryExtents)
  XEN_NARGIFY_3(gxm_XShapeGetRectangles_w, gxm_XShapeGetRectangles)
  XEN_NARGIFY_5(gxm_XShapeOffsetShape_w, gxm_XShapeOffsetShape)
  XEN_NARGIFY_7(gxm_XShapeCombineRegion_w, gxm_XShapeCombineRegion)
  XEN_NARGIFY_7(gxm_XShapeCombineMask_w, gxm_XShapeCombineMask)
  XEN_NARGIFY_8(gxm_XShapeCombineShape_w, gxm_XShapeCombineShape)
  XEN_NARGIFY_9(gxm_XShapeCombineRectangles_w, gxm_XShapeCombineRectangles)
#endif

  XEN_NARGIFY_4(gxm_XSegment_w, gxm_XSegment)
  XEN_NARGIFY_4(gxm_XRectangle_w, gxm_XRectangle)
  XEN_ARGIFY_6(gxm_XColor_w, gxm_XColor)
  XEN_NARGIFY_6(gxm_XArc_w, gxm_XArc)
  XEN_NARGIFY_7(gxm_XWindowChanges_w, gxm_XWindowChanges)
  XEN_VARGIFY(gxm_XSetWindowAttributes_w, gxm_XSetWindowAttributes)
  XEN_NARGIFY_2(gxm_XPoint_w, gxm_XPoint)
  XEN_NARGIFY_4(gxm_XTextItem_w, gxm_XTextItem)
  XEN_NARGIFY_1(gxm_pixel_w, gxm_pixel)
  XEN_NARGIFY_2(gxm_set_pixel_w, gxm_set_pixel)
  XEN_NARGIFY_1(gxm_red_w, gxm_red)
  XEN_NARGIFY_2(gxm_set_red_w, gxm_set_red)
  XEN_NARGIFY_1(gxm_green_w, gxm_green)
  XEN_NARGIFY_2(gxm_set_green_w, gxm_set_green)
  XEN_NARGIFY_1(gxm_blue_w, gxm_blue)
  XEN_NARGIFY_2(gxm_set_blue_w, gxm_set_blue)
  XEN_NARGIFY_1(gxm_flags_w, gxm_flags)
  XEN_NARGIFY_2(gxm_set_flags_w, gxm_set_flags)
  XEN_NARGIFY_1(gxm_pad_w, gxm_pad)
  XEN_NARGIFY_2(gxm_set_pad_w, gxm_set_pad)
  XEN_NARGIFY_1(gxm_x_w, gxm_x)
  XEN_NARGIFY_2(gxm_set_x_w, gxm_set_x)
  XEN_NARGIFY_1(gxm_y_w, gxm_y)
  XEN_NARGIFY_2(gxm_set_y_w, gxm_set_y)
  XEN_NARGIFY_1(gxm_width_w, gxm_width)
  XEN_NARGIFY_2(gxm_set_width_w, gxm_set_width)
  XEN_NARGIFY_1(gxm_height_w, gxm_height)
  XEN_NARGIFY_2(gxm_set_height_w, gxm_set_height)
  XEN_NARGIFY_1(gxm_angle1_w, gxm_angle1)
  XEN_NARGIFY_2(gxm_set_angle1_w, gxm_set_angle1)
  XEN_NARGIFY_1(gxm_angle2_w, gxm_angle2)
  XEN_NARGIFY_2(gxm_set_angle2_w, gxm_set_angle2)
  XEN_NARGIFY_1(gxm_x1_w, gxm_x1)
  XEN_NARGIFY_2(gxm_set_x1_w, gxm_set_x1)
  XEN_NARGIFY_1(gxm_y1_w, gxm_y1)
  XEN_NARGIFY_2(gxm_set_y1_w, gxm_set_y1)
  XEN_NARGIFY_1(gxm_x2_w, gxm_x2)
  XEN_NARGIFY_2(gxm_set_x2_w, gxm_set_x2)
  XEN_NARGIFY_1(gxm_y2_w, gxm_y2)
  XEN_NARGIFY_2(gxm_set_y2_w, gxm_set_y2)
  XEN_NARGIFY_1(gxm_dashes_w, gxm_dashes)
  XEN_NARGIFY_2(gxm_set_dashes_w, gxm_set_dashes)
  XEN_NARGIFY_1(gxm_dash_offset_w, gxm_dash_offset)
  XEN_NARGIFY_2(gxm_set_dash_offset_w, gxm_set_dash_offset)
  XEN_NARGIFY_1(gxm_clip_mask_w, gxm_clip_mask)
  XEN_NARGIFY_2(gxm_set_clip_mask_w, gxm_set_clip_mask)
  XEN_NARGIFY_1(gxm_clip_y_origin_w, gxm_clip_y_origin)
  XEN_NARGIFY_2(gxm_set_clip_y_origin_w, gxm_set_clip_y_origin)
  XEN_NARGIFY_1(gxm_clip_x_origin_w, gxm_clip_x_origin)
  XEN_NARGIFY_2(gxm_set_clip_x_origin_w, gxm_set_clip_x_origin)
  XEN_NARGIFY_1(gxm_graphics_exposures_w, gxm_graphics_exposures)
  XEN_NARGIFY_2(gxm_set_graphics_exposures_w, gxm_set_graphics_exposures)
  XEN_NARGIFY_1(gxm_subwindow_mode_w, gxm_subwindow_mode)
  XEN_NARGIFY_2(gxm_set_subwindow_mode_w, gxm_set_subwindow_mode)
  XEN_NARGIFY_1(gxm_font_w, gxm_font)
  XEN_NARGIFY_2(gxm_set_font_w, gxm_set_font)
  XEN_NARGIFY_1(gxm_ts_y_origin_w, gxm_ts_y_origin)
  XEN_NARGIFY_2(gxm_set_ts_y_origin_w, gxm_set_ts_y_origin)
  XEN_NARGIFY_1(gxm_ts_x_origin_w, gxm_ts_x_origin)
  XEN_NARGIFY_2(gxm_set_ts_x_origin_w, gxm_set_ts_x_origin)
  XEN_NARGIFY_1(gxm_stipple_w, gxm_stipple)
  XEN_NARGIFY_2(gxm_set_stipple_w, gxm_set_stipple)
  XEN_NARGIFY_1(gxm_tile_w, gxm_tile)
  XEN_NARGIFY_2(gxm_set_tile_w, gxm_set_tile)
  XEN_NARGIFY_1(gxm_arc_mode_w, gxm_arc_mode)
  XEN_NARGIFY_2(gxm_set_arc_mode_w, gxm_set_arc_mode)
  XEN_NARGIFY_1(gxm_fill_rule_w, gxm_fill_rule)
  XEN_NARGIFY_2(gxm_set_fill_rule_w, gxm_set_fill_rule)
  XEN_NARGIFY_1(gxm_fill_style_w, gxm_fill_style)
  XEN_NARGIFY_2(gxm_set_fill_style_w, gxm_set_fill_style)
  XEN_NARGIFY_1(gxm_join_style_w, gxm_join_style)
  XEN_NARGIFY_2(gxm_set_join_style_w, gxm_set_join_style)
  XEN_NARGIFY_1(gxm_cap_style_w, gxm_cap_style)
  XEN_NARGIFY_2(gxm_set_cap_style_w, gxm_set_cap_style)
  XEN_NARGIFY_1(gxm_line_style_w, gxm_line_style)
  XEN_NARGIFY_2(gxm_set_line_style_w, gxm_set_line_style)
  XEN_NARGIFY_1(gxm_line_width_w, gxm_line_width)
  XEN_NARGIFY_2(gxm_set_line_width_w, gxm_set_line_width)
  XEN_NARGIFY_1(gxm_background_w, gxm_background)
  XEN_NARGIFY_2(gxm_set_background_w, gxm_set_background)
  XEN_NARGIFY_1(gxm_foreground_w, gxm_foreground)
  XEN_NARGIFY_2(gxm_set_foreground_w, gxm_set_foreground)
  XEN_NARGIFY_1(gxm_plane_mask_w, gxm_plane_mask)
  XEN_NARGIFY_2(gxm_set_plane_mask_w, gxm_set_plane_mask)
  XEN_NARGIFY_1(gxm_function_w, gxm_function)
  XEN_NARGIFY_2(gxm_set_function_w, gxm_set_function)
  XEN_NARGIFY_1(gxm_delta_w, gxm_delta)
  XEN_NARGIFY_2(gxm_set_delta_w, gxm_set_delta)
  XEN_NARGIFY_1(gxm_nchars_w, gxm_nchars)
  XEN_NARGIFY_2(gxm_set_nchars_w, gxm_set_nchars)
  XEN_NARGIFY_1(gxm_chars_w, gxm_chars)
  XEN_NARGIFY_2(gxm_set_chars_w, gxm_set_chars)
  XEN_NARGIFY_1(gxm_name_w, gxm_name)
  XEN_NARGIFY_2(gxm_set_name_w, gxm_set_name)
  XEN_NARGIFY_1(gxm_depth_w, gxm_depth)
  XEN_NARGIFY_2(gxm_set_depth_w, gxm_set_depth)
  XEN_NARGIFY_1(gxm_visual_w, gxm_visual)
  XEN_NARGIFY_2(gxm_set_visual_w, gxm_set_visual)

  XEN_NARGIFY_1(gxm_display_w, gxm_display)
  XEN_NARGIFY_1(gxm_root_w, gxm_root)
  XEN_NARGIFY_1(gxm_mwidth_w, gxm_mwidth)
  XEN_NARGIFY_1(gxm_mheight_w, gxm_mheight)
  XEN_NARGIFY_1(gxm_ndepths_w, gxm_ndepths)
  XEN_NARGIFY_1(gxm_depths_w, gxm_depths)
  XEN_NARGIFY_1(gxm_root_depth_w, gxm_root_depth)
  XEN_NARGIFY_1(gxm_root_visual_w, gxm_root_visual)
  XEN_NARGIFY_1(gxm_default_gc_w, gxm_default_gc)
  XEN_NARGIFY_1(gxm_cmap_w, gxm_cmap)
  XEN_NARGIFY_1(gxm_white_pixel_w, gxm_white_pixel)
  XEN_NARGIFY_1(gxm_black_pixel_w, gxm_black_pixel)
  XEN_NARGIFY_1(gxm_max_maps_w, gxm_max_maps)
  XEN_NARGIFY_1(gxm_min_maps_w, gxm_min_maps)
  XEN_NARGIFY_1(gxm_backing_store_w, gxm_backing_store)
  XEN_NARGIFY_1(gxm_save_unders_w, gxm_save_unders)
  XEN_NARGIFY_1(gxm_root_input_mask_w, gxm_root_input_mask)
  XEN_NARGIFY_1(gxm_type_w, gxm_type)
  XEN_NARGIFY_1(gxm_serial_w, gxm_serial)
  XEN_NARGIFY_1(gxm_send_event_w, gxm_send_event)
  XEN_NARGIFY_1(gxm_window_w, gxm_window)
  XEN_NARGIFY_1(gxm_subwindow_w, gxm_subwindow)
  XEN_NARGIFY_1(gxm_time_w, gxm_time)
  XEN_NARGIFY_1(gxm_x_root_w, gxm_x_root)
  XEN_NARGIFY_1(gxm_y_root_w, gxm_y_root)
  XEN_NARGIFY_1(gxm_state_w, gxm_state)
  XEN_NARGIFY_1(gxm_keycode_w, gxm_keycode)
  XEN_NARGIFY_1(gxm_same_screen_w, gxm_same_screen)
  XEN_NARGIFY_1(gxm_button_w, gxm_button)
  XEN_NARGIFY_1(gxm_is_hint_w, gxm_is_hint)
  XEN_NARGIFY_1(gxm_mode_w, gxm_mode)
  XEN_NARGIFY_1(gxm_detail_w, gxm_detail)
  XEN_NARGIFY_1(gxm_focus_w, gxm_focus)
  XEN_NARGIFY_1(gxm_key_vector_w, gxm_key_vector)
  XEN_NARGIFY_1(gxm_count_w, gxm_count)
  XEN_NARGIFY_1(gxm_drawable_w, gxm_drawable)
  XEN_NARGIFY_1(gxm_major_code_w, gxm_major_code)
  XEN_NARGIFY_1(gxm_minor_code_w, gxm_minor_code)
  XEN_NARGIFY_1(gxm_parent_w, gxm_parent)
  XEN_NARGIFY_1(gxm_border_width_w, gxm_border_width)
  XEN_NARGIFY_1(gxm_override_redirect_w, gxm_override_redirect)
  XEN_NARGIFY_1(gxm_event_w, gxm_event)
  XEN_NARGIFY_1(gxm_from_configure_w, gxm_from_configure)
  XEN_NARGIFY_1(gxm_above_w, gxm_above)
  XEN_NARGIFY_1(gxm_value_mask_w, gxm_value_mask)
  XEN_NARGIFY_1(gxm_place_w, gxm_place)
  XEN_NARGIFY_1(gxm_atom_w, gxm_atom)
  XEN_NARGIFY_1(gxm_selection_w, gxm_selection)
  XEN_NARGIFY_1(gxm_owner_w, gxm_owner)
  XEN_NARGIFY_1(gxm_requestor_w, gxm_requestor)
  XEN_NARGIFY_1(gxm_target_w, gxm_target)
  XEN_NARGIFY_1(gxm_property_w, gxm_property)
  XEN_NARGIFY_1(gxm_new_w, gxm_new)
  XEN_NARGIFY_1(gxm_message_type_w, gxm_message_type)
  XEN_NARGIFY_1(gxm_format_w, gxm_format)
  XEN_NARGIFY_1(gxm_request_w, gxm_request)
  XEN_NARGIFY_1(gxm_first_keycode_w, gxm_first_keycode)
  XEN_NARGIFY_1(gxm_resourceid_w, gxm_resourceid)
  XEN_NARGIFY_1(gxm_error_code_w, gxm_error_code)
  XEN_NARGIFY_1(gxm_request_code_w, gxm_request_code)
  XEN_NARGIFY_1(gxm_lbearing_w, gxm_lbearing)
  XEN_NARGIFY_1(gxm_rbearing_w, gxm_rbearing)
  XEN_NARGIFY_1(gxm_ascent_w, gxm_ascent)
  XEN_NARGIFY_1(gxm_descent_w, gxm_descent)
  XEN_NARGIFY_1(gxm_attributes_w, gxm_attributes)
  XEN_NARGIFY_1(gxm_card32_w, gxm_card32)
  XEN_NARGIFY_1(gxm_fid_w, gxm_fid)
  XEN_NARGIFY_1(gxm_properties_w, gxm_properties)
  XEN_NARGIFY_1(gxm_min_bounds_w, gxm_min_bounds)
  XEN_NARGIFY_1(gxm_max_bounds_w, gxm_max_bounds)
  XEN_NARGIFY_1(gxm_per_char_w, gxm_per_char)
  XEN_NARGIFY_1(gxm_input_w, gxm_input)
  XEN_NARGIFY_1(gxm_initial_state_w, gxm_initial_state)
  XEN_NARGIFY_1(gxm_icon_pixmap_w, gxm_icon_pixmap)
  XEN_NARGIFY_1(gxm_icon_window_w, gxm_icon_window)
  XEN_NARGIFY_1(gxm_icon_x_w, gxm_icon_x)
  XEN_NARGIFY_1(gxm_icon_y_w, gxm_icon_y)
  XEN_NARGIFY_1(gxm_icon_mask_w, gxm_icon_mask)
  XEN_NARGIFY_1(gxm_window_group_w, gxm_window_group)
  XEN_NARGIFY_1(gxm_visualid_w, gxm_visualid)
  XEN_NARGIFY_1(gxm_class_w, gxm_class)
  XEN_NARGIFY_1(gxm_red_mask_w, gxm_red_mask)
  XEN_NARGIFY_1(gxm_green_mask_w, gxm_green_mask)
  XEN_NARGIFY_1(gxm_blue_mask_w, gxm_blue_mask)
  XEN_NARGIFY_1(gxm_bits_per_rgb_w, gxm_bits_per_rgb)
  XEN_NARGIFY_1(gxm_map_entries_w, gxm_map_entries)
  XEN_NARGIFY_1(gxm_colormap_size_w, gxm_colormap_size)
  XEN_NARGIFY_1(gxm_nvisuals_w, gxm_nvisuals)
  XEN_NARGIFY_1(gxm_visuals_w, gxm_visuals)
  XEN_NARGIFY_1(gxm_bits_per_pixel_w, gxm_bits_per_pixel)
  XEN_NARGIFY_1(gxm_background_pixmap_w, gxm_background_pixmap)
  XEN_NARGIFY_1(gxm_background_pixel_w, gxm_background_pixel)
  XEN_NARGIFY_1(gxm_border_pixmap_w, gxm_border_pixmap)
  XEN_NARGIFY_1(gxm_border_pixel_w, gxm_border_pixel)
  XEN_NARGIFY_1(gxm_bit_gravity_w, gxm_bit_gravity)
  XEN_NARGIFY_1(gxm_win_gravity_w, gxm_win_gravity)
  XEN_NARGIFY_1(gxm_backing_planes_w, gxm_backing_planes)
  XEN_NARGIFY_1(gxm_backing_pixel_w, gxm_backing_pixel)
  XEN_NARGIFY_1(gxm_save_under_w, gxm_save_under)
  XEN_NARGIFY_1(gxm_event_mask_w, gxm_event_mask)
  XEN_NARGIFY_1(gxm_do_not_propagate_mask_w, gxm_do_not_propagate_mask)
  XEN_NARGIFY_1(gxm_cursor_w, gxm_cursor)
  XEN_NARGIFY_1(gxm_map_installed_w, gxm_map_installed)
  XEN_NARGIFY_1(gxm_map_state_w, gxm_map_state)
  XEN_NARGIFY_1(gxm_all_event_masks_w, gxm_all_event_masks)
  XEN_NARGIFY_1(gxm_your_event_mask_w, gxm_your_event_mask)
  XEN_NARGIFY_1(gxm_screen_w, gxm_screen)
  XEN_NARGIFY_1(gxm_xoffset_w, gxm_xoffset)
  XEN_NARGIFY_1(gxm_byte_order_w, gxm_byte_order)
  XEN_NARGIFY_1(gxm_bitmap_unit_w, gxm_bitmap_unit)
  XEN_NARGIFY_1(gxm_bitmap_bit_order_w, gxm_bitmap_bit_order)
  XEN_NARGIFY_1(gxm_bitmap_pad_w, gxm_bitmap_pad)
  XEN_NARGIFY_1(gxm_bytes_per_line_w, gxm_bytes_per_line)
  XEN_NARGIFY_1(gxm_obdata_w, gxm_obdata)
  XEN_NARGIFY_1(gxm_sibling_w, gxm_sibling)
  XEN_NARGIFY_1(gxm_stack_mode_w, gxm_stack_mode)
 
  XEN_NARGIFY_1(gxm_red_max_w, gxm_red_max)
  XEN_NARGIFY_1(gxm_red_mult_w, gxm_red_mult)
  XEN_NARGIFY_1(gxm_green_max_w, gxm_green_max)
  XEN_NARGIFY_1(gxm_green_mult_w, gxm_green_mult)
  XEN_NARGIFY_1(gxm_blue_max_w, gxm_blue_max)
  XEN_NARGIFY_1(gxm_blue_mult_w, gxm_blue_mult)
  XEN_NARGIFY_1(gxm_base_pixel_w, gxm_base_pixel)
  XEN_NARGIFY_1(gxm_killid_w, gxm_killid)
  XEN_NARGIFY_1(gxm_data_w, gxm_data)

  XEN_NARGIFY_2(gxm_set_request_code_w, gxm_set_request_code)
  XEN_NARGIFY_2(gxm_set_error_code_w, gxm_set_error_code)
  XEN_NARGIFY_2(gxm_set_first_keycode_w, gxm_set_first_keycode)
  XEN_NARGIFY_2(gxm_set_request_w, gxm_set_request)
  XEN_NARGIFY_2(gxm_set_resourceid_w, gxm_set_resourceid)
  XEN_NARGIFY_2(gxm_set_format_w, gxm_set_format)
  XEN_NARGIFY_2(gxm_set_message_type_w, gxm_set_message_type)
  XEN_NARGIFY_2(gxm_set_new_w, gxm_set_new)
  XEN_NARGIFY_2(gxm_set_property_w, gxm_set_property)
  XEN_NARGIFY_2(gxm_set_display_w, gxm_set_display)
  XEN_NARGIFY_2(gxm_set_target_w, gxm_set_target)
  XEN_NARGIFY_2(gxm_set_requestor_w, gxm_set_requestor)
  XEN_NARGIFY_2(gxm_set_owner_w, gxm_set_owner)
  XEN_NARGIFY_2(gxm_set_selection_w, gxm_set_selection)
  XEN_NARGIFY_2(gxm_set_atom_w, gxm_set_atom)
  XEN_NARGIFY_2(gxm_set_place_w, gxm_set_place)
  XEN_NARGIFY_2(gxm_set_value_mask_w, gxm_set_value_mask)
  XEN_NARGIFY_2(gxm_set_above_w, gxm_set_above)
  XEN_NARGIFY_2(gxm_set_from_configure_w, gxm_set_from_configure)
  XEN_NARGIFY_2(gxm_set_event_w, gxm_set_event)
  XEN_NARGIFY_2(gxm_set_override_redirect_w, gxm_set_override_redirect)
  XEN_NARGIFY_2(gxm_set_border_width_w, gxm_set_border_width)
  XEN_NARGIFY_2(gxm_set_parent_w, gxm_set_parent)
  XEN_NARGIFY_2(gxm_set_minor_code_w, gxm_set_minor_code)
  XEN_NARGIFY_2(gxm_set_major_code_w, gxm_set_major_code)
  XEN_NARGIFY_2(gxm_set_drawable_w, gxm_set_drawable)
  XEN_NARGIFY_2(gxm_set_count_w, gxm_set_count)
  XEN_NARGIFY_2(gxm_set_key_vector_w, gxm_set_key_vector)
  XEN_NARGIFY_2(gxm_set_focus_w, gxm_set_focus)
  XEN_NARGIFY_2(gxm_set_detail_w, gxm_set_detail)
  XEN_NARGIFY_2(gxm_set_mode_w, gxm_set_mode)
  XEN_NARGIFY_2(gxm_set_is_hint_w, gxm_set_is_hint)
  XEN_NARGIFY_2(gxm_set_button_w, gxm_set_button)
  XEN_NARGIFY_2(gxm_set_same_screen_w, gxm_set_same_screen)
  XEN_NARGIFY_2(gxm_set_keycode_w, gxm_set_keycode)
  XEN_NARGIFY_2(gxm_set_state_w, gxm_set_state)
  XEN_NARGIFY_2(gxm_set_y_root_w, gxm_set_y_root)
  XEN_NARGIFY_2(gxm_set_x_root_w, gxm_set_x_root)
  XEN_NARGIFY_2(gxm_set_root_w, gxm_set_root)
  XEN_NARGIFY_2(gxm_set_time_w, gxm_set_time)
  XEN_NARGIFY_2(gxm_set_subwindow_w, gxm_set_subwindow)
  XEN_NARGIFY_2(gxm_set_window_w, gxm_set_window)
  XEN_NARGIFY_2(gxm_set_send_event_w, gxm_set_send_event)
  XEN_NARGIFY_2(gxm_set_serial_w, gxm_set_serial)
  XEN_NARGIFY_2(gxm_set_type_w, gxm_set_type)
  XEN_NARGIFY_1(gxm_colormap_w, gxm_colormap)
  XEN_NARGIFY_2(gxm_set_colormap_w, gxm_set_colormap)

  XEN_NARGIFY_2(gxm_set_input_w, gxm_set_input)
  XEN_NARGIFY_2(gxm_set_initial_state_w, gxm_set_initial_state)

  XEN_NARGIFY_1(gxm_min_height_w, gxm_min_height)
  XEN_NARGIFY_1(gxm_max_height_w, gxm_max_height)
  XEN_NARGIFY_1(gxm_min_width_w, gxm_min_width)
  XEN_NARGIFY_1(gxm_max_width_w, gxm_max_width)
  XEN_NARGIFY_1(gxm_height_inc_w, gxm_height_inc)
  XEN_NARGIFY_1(gxm_width_inc_w, gxm_width_inc)

  XEN_NARGIFY_2(gxm_set_data_w, gxm_set_data)
  XEN_NARGIFY_2(gxm_set_backing_store_w, gxm_set_backing_store)
  XEN_NARGIFY_2(gxm_set_background_pixel_w, gxm_set_background_pixel)
  XEN_NARGIFY_2(gxm_set_border_pixel_w, gxm_set_border_pixel)
  XEN_NARGIFY_2(gxm_set_bit_gravity_w, gxm_set_bit_gravity)
  XEN_NARGIFY_2(gxm_set_save_under_w, gxm_set_save_under)
  XEN_NARGIFY_2(gxm_set_event_mask_w, gxm_set_event_mask)
  XEN_NARGIFY_2(gxm_set_cursor_w, gxm_set_cursor)

#if HAVE_MOTIF
  XEN_NARGIFY_2(gxm_set_set_w, gxm_set_set)
  XEN_NARGIFY_2(gxm_set_click_count_w, gxm_set_click_count)
  XEN_NARGIFY_2(gxm_set_length_w, gxm_set_length)
  XEN_NARGIFY_1(gxm_ptr_w, gxm_ptr)
  XEN_NARGIFY_2(gxm_set_ptr_w, gxm_set_ptr)
  XEN_NARGIFY_2(gxm_set_reason_w, gxm_set_reason)
  XEN_NARGIFY_1(gxm_page_number_w, gxm_page_number)
  XEN_NARGIFY_1(gxm_page_widget_w, gxm_page_widget)
  XEN_NARGIFY_1(gxm_status_area_widget_w, gxm_status_area_widget)
  XEN_NARGIFY_1(gxm_major_tab_widget_w, gxm_major_tab_widget)
  XEN_NARGIFY_1(gxm_minor_tab_widget_w, gxm_minor_tab_widget)
  XEN_NARGIFY_1(gxm_source_data_w, gxm_source_data)
  XEN_NARGIFY_1(gxm_location_data_w, gxm_location_data)
  XEN_NARGIFY_1(gxm_parm_w, gxm_parm)
  XEN_NARGIFY_1(gxm_parm_format_w, gxm_parm_format)
  XEN_NARGIFY_1(gxm_parm_length_w, gxm_parm_length)
  XEN_NARGIFY_1(gxm_parm_type_w, gxm_parm_type)
  XEN_NARGIFY_1(gxm_transfer_id_w, gxm_transfer_id)
  XEN_NARGIFY_1(gxm_destination_data_w, gxm_destination_data)
  XEN_NARGIFY_1(gxm_remaining_w, gxm_remaining)
  XEN_NARGIFY_1(gxm_item_or_text_w, gxm_item_or_text)
  XEN_NARGIFY_1(gxm_auto_selection_type_w, gxm_auto_selection_type)
  XEN_NARGIFY_1(gxm_new_outline_state_w, gxm_new_outline_state)
  XEN_NARGIFY_1(gxm_prev_page_number_w, gxm_prev_page_number)
  XEN_NARGIFY_1(gxm_prev_page_widget_w, gxm_prev_page_widget)
  XEN_NARGIFY_1(gxm_rendition_w, gxm_rendition)
  XEN_NARGIFY_1(gxm_render_table_w, gxm_render_table)
#if HAVE_XM_XP
  XEN_NARGIFY_1(gxm_last_page_w, gxm_last_page)
#endif
  XEN_NARGIFY_1(gxm_crossed_boundary_w, gxm_crossed_boundary)
  XEN_NARGIFY_1(gxm_client_data_w, gxm_client_data)
  XEN_NARGIFY_1(gxm_status_w, gxm_status)
  XEN_NARGIFY_1(gxm_font_name_w, gxm_font_name)
  XEN_NARGIFY_1(gxm_tag_w, gxm_tag)
  XEN_NARGIFY_1(gxm_traversal_destination_w, gxm_traversal_destination)
  XEN_NARGIFY_1(gxm_dragProtocolStyle_w, gxm_dragProtocolStyle)
  XEN_NARGIFY_1(gxm_direction_w, gxm_direction)
  XEN_NARGIFY_1(gxm_reason_w, gxm_reason)
  XEN_NARGIFY_1(gxm_timeStamp_w, gxm_timeStamp)
  XEN_NARGIFY_1(gxm_operation_w, gxm_operation )
  XEN_NARGIFY_2(gxm_set_operation_w, gxm_set_operation)
  XEN_NARGIFY_1(gxm_operations_w, gxm_operations)
  XEN_NARGIFY_1(gxm_dropSiteStatus_w, gxm_dropSiteStatus )
  XEN_NARGIFY_2(gxm_set_dropSiteStatus_w, gxm_set_dropSiteStatus)
  XEN_NARGIFY_1(gxm_dropAction_w, gxm_dropAction)
  XEN_NARGIFY_1(gxm_iccHandle_w, gxm_iccHandle)
  XEN_NARGIFY_1(gxm_completionStatus_w, gxm_completionStatus)
  XEN_NARGIFY_1(gxm_dragContext_w, gxm_dragContext)
  XEN_NARGIFY_1(gxm_animate_w, gxm_animate)
  XEN_NARGIFY_1(gxm_length_w, gxm_length)
  XEN_NARGIFY_1(gxm_click_count_w, gxm_click_count)
  XEN_NARGIFY_1(gxm_widget_w, gxm_widget)
  XEN_NARGIFY_1(gxm_item_position_w, gxm_item_position)
  XEN_NARGIFY_1(gxm_callbackstruct_w, gxm_callbackstruct)
  XEN_NARGIFY_1(gxm_set_w, gxm_set)
  XEN_NARGIFY_1(gxm_item_w, gxm_item)
  XEN_NARGIFY_1(gxm_item_length_w, gxm_item_length)
  XEN_NARGIFY_1(gxm_selected_items_w, gxm_selected_items)
  XEN_NARGIFY_1(gxm_selected_item_count_w, gxm_selected_item_count)
  XEN_NARGIFY_1(gxm_selected_item_positions_w, gxm_selected_item_positions)
  XEN_NARGIFY_1(gxm_selection_type_w, gxm_selection_type)
  XEN_NARGIFY_1(gxm_mask_w, gxm_mask)
  XEN_NARGIFY_1(gxm_mask_length_w, gxm_mask_length)
  XEN_NARGIFY_1(gxm_dir_w, gxm_dir)
  XEN_NARGIFY_1(gxm_dir_length_w, gxm_dir_length)
  XEN_NARGIFY_1(gxm_pattern_w, gxm_pattern)
  XEN_NARGIFY_1(gxm_pattern_length_w, gxm_pattern_length)
  XEN_NARGIFY_1(gxm_position_w, gxm_position)
  XEN_NARGIFY_1(gxm_currInsert_w, gxm_currInsert)
  XEN_NARGIFY_1(gxm_newInsert_w, gxm_newInsert)
  XEN_NARGIFY_1(gxm_startPos_w, gxm_startPos)
  XEN_NARGIFY_1(gxm_endPos_w, gxm_endPos)
  XEN_NARGIFY_1(gxm_text_w, gxm_text)
  XEN_NARGIFY_1(gxm_value_w, gxm_value)
  XEN_NARGIFY_2(gxm_set_value_w, gxm_set_value)
  XEN_NARGIFY_1(gxm_doit_w, gxm_doit)
  XEN_NARGIFY_2(gxm_set_doit_w, gxm_set_doit)
  XEN_NARGIFY_1(gxm_menuToPost_w, gxm_menuToPost)
  XEN_NARGIFY_2(gxm_set_menuToPost_w, gxm_set_menuToPost)
  XEN_NARGIFY_1(gxm_postIt_w, gxm_postIt)
  XEN_NARGIFY_2(gxm_set_postIt_w, gxm_set_postIt)
#if HAVE_XmCreateDataField
  XEN_NARGIFY_1(gxm_w_w, gxm_w)
  XEN_NARGIFY_1(gxm_accept_w, gxm_accept)
#endif
#if HAVE_XmCreateTabStack
  XEN_NARGIFY_1(gxm_selected_child_w, gxm_selected_child)
#endif

#if HAVE_XPM
  XEN_NARGIFY_1(gxm_valuemask_w, gxm_valuemask)
  XEN_NARGIFY_2(gxm_set_valuemask_w, gxm_set_valuemask)
  XEN_NARGIFY_1(gxm_ncolors_w, gxm_ncolors)
  XEN_NARGIFY_2(gxm_set_ncolors_w, gxm_set_ncolors)
  XEN_NARGIFY_1(gxm_cpp_w, gxm_cpp)
  XEN_NARGIFY_2(gxm_set_cpp_w, gxm_set_cpp)
  XEN_NARGIFY_1(gxm_numsymbols_w, gxm_numsymbols)
  XEN_NARGIFY_2(gxm_set_numsymbols_w, gxm_set_numsymbols)
  XEN_NARGIFY_1(gxm_colorsymbols_w, gxm_colorsymbols)
  XEN_NARGIFY_2(gxm_set_colorsymbols_w, gxm_set_colorsymbols)
  XEN_NARGIFY_1(gxm_npixels_w, gxm_npixels)
  XEN_NARGIFY_2(gxm_set_npixels_w, gxm_set_npixels)
  XEN_NARGIFY_1(gxm_y_hotspot_w, gxm_y_hotspot)
  XEN_NARGIFY_2(gxm_set_y_hotspot_w, gxm_set_y_hotspot)
  XEN_NARGIFY_1(gxm_x_hotspot_w, gxm_x_hotspot)
  XEN_NARGIFY_2(gxm_set_x_hotspot_w, gxm_set_x_hotspot)

  XEN_NARGIFY_5(gxm_XpmImage_w, gxm_XpmImage)
  XEN_NARGIFY_3(gxm_XpmColorSymbol_w, gxm_XpmColorSymbol)
  XEN_NARGIFY_0(gxm_XpmAttributes_w, gxm_XpmAttributes)
#endif
#if HAVE_SCHEME
  XEN_NARGIFY_1(c_to_xen_string_w, c_to_xen_string)
  XEN_NARGIFY_2(c_to_xen_strings_w, c_to_xen_strings)
  XEN_NARGIFY_2(c_to_xen_ints_w, c_to_xen_ints)
  XEN_NARGIFY_2(c_to_xen_atoms_w, c_to_xen_atoms)
  XEN_NARGIFY_2(c_to_xen_xrectangles_w, c_to_xen_xrectangles)
#endif
#endif

#else

/* no argify */
#if HAVE_XM_XP
  #define gxm_XpStartPage_w gxm_XpStartPage
  #define gxm_XpEndPage_w gxm_XpEndPage
  #define gxm_XpCancelPage_w gxm_XpCancelPage
  #define gxm_XpStartJob_w gxm_XpStartJob
  #define gxm_XpEndJob_w gxm_XpEndJob
  #define gxm_XpCancelJob_w gxm_XpCancelJob
  #define gxm_XpStartDoc_w gxm_XpStartDoc
  #define gxm_XpEndDoc_w gxm_XpEndDoc
  #define gxm_XpCancelDoc_w gxm_XpCancelDoc
  #define gxm_XpRehashPrinterList_w gxm_XpRehashPrinterList
  #define gxm_XpCreateContext_w gxm_XpCreateContext
  #define gxm_XpSetContext_w gxm_XpSetContext
  #define gxm_XpGetContext_w gxm_XpGetContext
  #define gxm_XpDestroyContext_w gxm_XpDestroyContext
  #define gxm_XpGetLocaleNetString_w gxm_XpGetLocaleNetString
  #define gxm_XpNotifyPdm_w gxm_XpNotifyPdm
  #define gxm_XpSendAuth_w gxm_XpSendAuth
  #define gxm_XpGetImageResolution_w gxm_XpGetImageResolution
  #define gxm_XpGetAttributes_w gxm_XpGetAttributes
  #define gxm_XpSetAttributes_w gxm_XpSetAttributes
  #define gxm_XpGetOneAttribute_w gxm_XpGetOneAttribute
  #define gxm_XpGetScreenOfContext_w gxm_XpGetScreenOfContext
  #define gxm_XpFreePrinterList_w gxm_XpFreePrinterList
  #define gxm_XpQueryVersion_w gxm_XpQueryVersion
  #define gxm_XpQueryExtension_w gxm_XpQueryExtension
  #define gxm_XpQueryScreens_w gxm_XpQueryScreens
  #define gxm_XpGetPdmStartParams_w gxm_XpGetPdmStartParams
  #define gxm_XpGetAuthParams_w gxm_XpGetAuthParams
  #define gxm_XpSendOneTicket_w gxm_XpSendOneTicket
  #define gxm_XpGetPageDimensions_w gxm_XpGetPageDimensions
  #define gxm_XpSetImageResolution_w gxm_XpSetImageResolution
  #define gxm_XpGetPrinterList_w gxm_XpGetPrinterList
  #define gxm_XpSelectInput_w gxm_XpSelectInput
  #define gxm_XpInputSelected_w gxm_XpInputSelected
  #define gxm_XpPutDocumentData_w gxm_XpPutDocumentData
  #define gxm_XpGetDocumentData_w gxm_XpGetDocumentData
#endif
#if HAVE_MOTIF
#if (!XM_DISABLE_DEPRECATED)
  #define gxm_XtWarning_w gxm_XtWarning
  #define gxm_XtAppWarning_w gxm_XtAppWarning
  #define gxm_XtSetWarningMsgHandler_w gxm_XtSetWarningMsgHandler
  #define gxm_XtInitialize_w gxm_XtInitialize
  #define gxm_XtSetWarningHandler_w gxm_XtSetWarningHandler
  #define gxm_XtError_w gxm_XtError
  #define gxm_XtErrorMsg_w gxm_XtErrorMsg
  #define gxm_XtWarningMsg_w gxm_XtWarningMsg
  #define gxm_XtSetErrorMsgHandler_w gxm_XtSetErrorMsgHandler
  #define gxm_XtSetErrorHandler_w gxm_XtSetErrorHandler
  #define gxm_XtCreateApplicationShell_w gxm_XtCreateApplicationShell
  #define gxm_XtSetSelectionTimeout_w gxm_XtSetSelectionTimeout
  #define gxm_XtGetSelectionTimeout_w gxm_XtGetSelectionTimeout
  #define gxm_XtAddActions_w gxm_XtAddActions
  #define gxm_XtAddInput_w gxm_XtAddInput
  #define gxm_XtAddWorkProc_w gxm_XtAddWorkProc
  #define gxm_XtAddTimeOut_w gxm_XtAddTimeOut
  #define gxm_XtMainLoop_w gxm_XtMainLoop
  #define gxm_XtProcessEvent_w gxm_XtProcessEvent
  #define gxm_XtPending_w gxm_XtPending
  #define gxm_XtNextEvent_w gxm_XtNextEvent
  #define gxm_XtPeekEvent_w gxm_XtPeekEvent
#endif
  #define gxm_XtSetArg_w gxm_XtSetArg
  #define gxm_XtManageChildren_w gxm_XtManageChildren
  #define gxm_XtManageChild_w gxm_XtManageChild
  #define gxm_XtUnmanageChildren_w gxm_XtUnmanageChildren
  #define gxm_XtUnmanageChild_w gxm_XtUnmanageChild
  #define gxm_XtDispatchEvent_w gxm_XtDispatchEvent
  #define gxm_XtCallAcceptFocus_w gxm_XtCallAcceptFocus
  #define gxm_XtAppPeekEvent_w gxm_XtAppPeekEvent
  #define gxm_XtIsSubclass_w gxm_XtIsSubclass
  #define gxm_XtAppSetFallbackResources_w gxm_XtAppSetFallbackResources
  #define gxm_XtIsObject_w gxm_XtIsObject
  #define gxm_XtIsManaged_w gxm_XtIsManaged
  #define gxm_XtIsRealized_w gxm_XtIsRealized
  #define gxm_XtIsSensitive_w gxm_XtIsSensitive
  #define gxm_XtOwnSelection_w gxm_XtOwnSelection
  #define gxm_XtOwnSelectionIncremental_w gxm_XtOwnSelectionIncremental
  #define gxm_XtMakeResizeRequest_w gxm_XtMakeResizeRequest
  #define gxm_XtTranslateCoords_w gxm_XtTranslateCoords
  #define gxm_XtKeysymToKeycodeList_w gxm_XtKeysymToKeycodeList
  #define gxm_XtParseTranslationTable_w gxm_XtParseTranslationTable
  #define gxm_XtParseAcceleratorTable_w gxm_XtParseAcceleratorTable
  #define gxm_XtOverrideTranslations_w gxm_XtOverrideTranslations
  #define gxm_XtAugmentTranslations_w gxm_XtAugmentTranslations
  #define gxm_XtInstallAccelerators_w gxm_XtInstallAccelerators
  #define gxm_XtInstallAllAccelerators_w gxm_XtInstallAllAccelerators
  #define gxm_XtUninstallTranslations_w gxm_XtUninstallTranslations
  #define gxm_XtAppAddActions_w gxm_XtAppAddActions
  #define gxm_XtAppAddActionHook_w gxm_XtAppAddActionHook
  #define gxm_XtRemoveActionHook_w gxm_XtRemoveActionHook
  #define gxm_XtGetActionList_w gxm_XtGetActionList
  #define gxm_XtCallActionProc_w gxm_XtCallActionProc
  #define gxm_XtRegisterGrabAction_w gxm_XtRegisterGrabAction
  #define gxm_XtSetMultiClickTime_w gxm_XtSetMultiClickTime
  #define gxm_XtGetMultiClickTime_w gxm_XtGetMultiClickTime
  #define gxm_XtGetResourceList_w gxm_XtGetResourceList
  #define gxm_XtGetActionKeysym_w gxm_XtGetActionKeysym
  #define gxm_XtTranslateKeycode_w gxm_XtTranslateKeycode
  #define gxm_XtTranslateKey_w gxm_XtTranslateKey
  #define gxm_XtSetKeyTranslator_w gxm_XtSetKeyTranslator
  #define gxm_XtRegisterCaseConverter_w gxm_XtRegisterCaseConverter
  #define gxm_XtConvertCase_w gxm_XtConvertCase
  #define gxm_XtAddEventHandler_w gxm_XtAddEventHandler
  #define gxm_XtRemoveEventHandler_w gxm_XtRemoveEventHandler
  #define gxm_XtAddRawEventHandler_w gxm_XtAddRawEventHandler
  #define gxm_XtRemoveRawEventHandler_w gxm_XtRemoveRawEventHandler
  #define gxm_XtInsertEventHandler_w gxm_XtInsertEventHandler
  #define gxm_XtInsertRawEventHandler_w gxm_XtInsertRawEventHandler
  #define gxm_XtDispatchEventToWidget_w gxm_XtDispatchEventToWidget
  #define gxm_XtBuildEventMask_w gxm_XtBuildEventMask
  #define gxm_XtAddGrab_w gxm_XtAddGrab
  #define gxm_XtRemoveGrab_w gxm_XtRemoveGrab
  #define gxm_XtAppProcessEvent_w gxm_XtAppProcessEvent
  #define gxm_XtAppMainLoop_w gxm_XtAppMainLoop
  #define gxm_XtAddExposureToRegion_w gxm_XtAddExposureToRegion
  #define gxm_XtSetKeyboardFocus_w gxm_XtSetKeyboardFocus
  #define gxm_XtGetKeyboardFocusWidget_w gxm_XtGetKeyboardFocusWidget
  #define gxm_XtLastEventProcessed_w gxm_XtLastEventProcessed
  #define gxm_XtLastTimestampProcessed_w gxm_XtLastTimestampProcessed
  #define gxm_XtAppAddTimeOut_w gxm_XtAppAddTimeOut
  #define gxm_XtRemoveTimeOut_w gxm_XtRemoveTimeOut
  #define gxm_XtAppAddInput_w gxm_XtAppAddInput
  #define gxm_XtRemoveInput_w gxm_XtRemoveInput
  #define gxm_XtAppNextEvent_w gxm_XtAppNextEvent
  #define gxm_XtAppPending_w gxm_XtAppPending
  #define gxm_XtRealizeWidget_w gxm_XtRealizeWidget
  #define gxm_XtUnrealizeWidget_w gxm_XtUnrealizeWidget
  #define gxm_XtDestroyWidget_w gxm_XtDestroyWidget
  #define gxm_XtSetSensitive_w gxm_XtSetSensitive
  #define gxm_XtNameToWidget_w gxm_XtNameToWidget
  #define gxm_XtWindowToWidget_w gxm_XtWindowToWidget
  #define gxm_XtMergeArgLists_w gxm_XtMergeArgLists
  #define gxm_XtVaCreateArgsList_w gxm_XtVaCreateArgsList
  #define gxm_XtDisplay_w gxm_XtDisplay
  #define gxm_XtDisplayOfObject_w gxm_XtDisplayOfObject
  #define gxm_XtScreen_w gxm_XtScreen
  #define gxm_XtScreenOfObject_w gxm_XtScreenOfObject
  #define gxm_XtWindow_w gxm_XtWindow
  #define gxm_XtWindowOfObject_w gxm_XtWindowOfObject
  #define gxm_XtName_w gxm_XtName
  #define gxm_XtSuperclass_w gxm_XtSuperclass
  #define gxm_XtClass_w gxm_XtClass
  #define gxm_XtParent_w gxm_XtParent
  #define gxm_XtAddCallback_w gxm_XtAddCallback
  #define gxm_XtRemoveCallback_w gxm_XtRemoveCallback
  #define gxm_XtAddCallbacks_w gxm_XtAddCallbacks
  #define gxm_XtRemoveCallbacks_w gxm_XtRemoveCallbacks
  #define gxm_XtRemoveAllCallbacks_w gxm_XtRemoveAllCallbacks
  #define gxm_XtCallCallbacks_w gxm_XtCallCallbacks
  #define gxm_XtHasCallbacks_w gxm_XtHasCallbacks
  #define gxm_XtCreatePopupShell_w gxm_XtCreatePopupShell
  #define gxm_XtVaCreatePopupShell_w gxm_XtVaCreatePopupShell
  #define gxm_XtPopup_w gxm_XtPopup
  #define gxm_XtPopupSpringLoaded_w gxm_XtPopupSpringLoaded
  #define gxm_XtCallbackNone_w gxm_XtCallbackNone
  #define gxm_XtCallbackNonexclusive_w gxm_XtCallbackNonexclusive
  #define gxm_XtCallbackExclusive_w gxm_XtCallbackExclusive
  #define gxm_XtPopdown_w gxm_XtPopdown
  #define gxm_XtCallbackPopdown_w gxm_XtCallbackPopdown
  #define gxm_XtCreateWidget_w gxm_XtCreateWidget
  #define gxm_XtCreateManagedWidget_w gxm_XtCreateManagedWidget
  #define gxm_XtVaCreateWidget_w gxm_XtVaCreateWidget
  #define gxm_XtVaCreateManagedWidget_w gxm_XtVaCreateManagedWidget
  #define gxm_XtAppCreateShell_w gxm_XtAppCreateShell
  #define gxm_XtVaAppCreateShell_w gxm_XtVaAppCreateShell
  #define gxm_XtToolkitInitialize_w gxm_XtToolkitInitialize
  #define gxm_XtSetLanguageProc_w gxm_XtSetLanguageProc
  #define gxm_XtDisplayInitialize_w gxm_XtDisplayInitialize
  #define gxm_XtOpenApplication_w gxm_XtOpenApplication
  #define gxm_XtVaOpenApplication_w gxm_XtVaOpenApplication
  #define gxm_XtAppInitialize_w gxm_XtAppInitialize
  #define gxm_XtVaAppInitialize_w gxm_XtVaAppInitialize
  #define gxm_XtOpenDisplay_w gxm_XtOpenDisplay
  #define gxm_XtCreateApplicationContext_w gxm_XtCreateApplicationContext
  #define gxm_XtDestroyApplicationContext_w gxm_XtDestroyApplicationContext
  #define gxm_XtInitializeWidgetClass_w gxm_XtInitializeWidgetClass
  #define gxm_XtWidgetToApplicationContext_w gxm_XtWidgetToApplicationContext
  #define gxm_XtDisplayToApplicationContext_w gxm_XtDisplayToApplicationContext
  #define gxm_XtCloseDisplay_w gxm_XtCloseDisplay
  #define gxm_XtSetValues_w gxm_XtSetValues
  #define gxm_XtVaSetValues_w gxm_XtVaSetValues
  #define gxm_XtGetValues_w gxm_XtGetValues
  #define gxm_XtVaGetValues_w gxm_XtVaGetValues
  #define gxm_XtAppSetErrorMsgHandler_w gxm_XtAppSetErrorMsgHandler
  #define gxm_XtAppSetWarningMsgHandler_w gxm_XtAppSetWarningMsgHandler
  #define gxm_XtAppErrorMsg_w gxm_XtAppErrorMsg
  #define gxm_XtAppWarningMsg_w gxm_XtAppWarningMsg
  #define gxm_XtAppSetErrorHandler_w gxm_XtAppSetErrorHandler
  #define gxm_XtAppSetWarningHandler_w gxm_XtAppSetWarningHandler
  #define gxm_XtAppError_w gxm_XtAppError
  #define gxm_XtMalloc_w gxm_XtMalloc
  #define gxm_XtCalloc_w gxm_XtCalloc
  #define gxm_XtRealloc_w gxm_XtRealloc
  #define gxm_XtFree_w gxm_XtFree
  #define gxm_XtAppAddWorkProc_w gxm_XtAppAddWorkProc
  #define gxm_XtRemoveWorkProc_w gxm_XtRemoveWorkProc
  #define gxm_XtGetGC_w gxm_XtGetGC
  #define gxm_XtAllocateGC_w gxm_XtAllocateGC
  #define gxm_XtDestroyGC_w gxm_XtDestroyGC
  #define gxm_XtReleaseGC_w gxm_XtReleaseGC
  #define gxm_XtFindFile_w gxm_XtFindFile
  #define gxm_XtResolvePathname_w gxm_XtResolvePathname
  #define gxm_XtDisownSelection_w gxm_XtDisownSelection
  #define gxm_XtGetSelectionValue_w gxm_XtGetSelectionValue
  #define gxm_XtGetSelectionValues_w gxm_XtGetSelectionValues
  #define gxm_XtAppSetSelectionTimeout_w gxm_XtAppSetSelectionTimeout
  #define gxm_XtAppGetSelectionTimeout_w gxm_XtAppGetSelectionTimeout
  #define gxm_XtGetSelectionRequest_w gxm_XtGetSelectionRequest
  #define gxm_XtGetSelectionValueIncremental_w gxm_XtGetSelectionValueIncremental
  #define gxm_XtGetSelectionValuesIncremental_w gxm_XtGetSelectionValuesIncremental
  #define gxm_XtCreateSelectionRequest_w gxm_XtCreateSelectionRequest
  #define gxm_XtSendSelectionRequest_w gxm_XtSendSelectionRequest
  #define gxm_XtCancelSelectionRequest_w gxm_XtCancelSelectionRequest
  #define gxm_XtGrabKey_w gxm_XtGrabKey
  #define gxm_XtUngrabKey_w gxm_XtUngrabKey
  #define gxm_XtGrabKeyboard_w gxm_XtGrabKeyboard
  #define gxm_XtUngrabKeyboard_w gxm_XtUngrabKeyboard
  #define gxm_XtGrabButton_w gxm_XtGrabButton
  #define gxm_XtUngrabButton_w gxm_XtUngrabButton
  #define gxm_XtGrabPointer_w gxm_XtGrabPointer
  #define gxm_XtUngrabPointer_w gxm_XtUngrabPointer
  #define gxm_XtGetApplicationNameAndClass_w gxm_XtGetApplicationNameAndClass
  #define gxm_XtGetDisplays_w gxm_XtGetDisplays
  #define gxm_XtToolkitThreadInitialize_w gxm_XtToolkitThreadInitialize
  #define gxm_XtAppLock_w gxm_XtAppLock
  #define gxm_XtAppUnlock_w gxm_XtAppUnlock
  #define gxm_XtIsRectObj_w gxm_XtIsRectObj
  #define gxm_XtIsWidget_w gxm_XtIsWidget
  #define gxm_XtIsComposite_w gxm_XtIsComposite
  #define gxm_XtIsConstraint_w gxm_XtIsConstraint
  #define gxm_XtIsShell_w gxm_XtIsShell
  #define gxm_XtIsOverrideShell_w gxm_XtIsOverrideShell
  #define gxm_XtIsWMShell_w gxm_XtIsWMShell
  #define gxm_XtIsVendorShell_w gxm_XtIsVendorShell
  #define gxm_XtIsTransientShell_w gxm_XtIsTransientShell
  #define gxm_XtIsTopLevelShell_w gxm_XtIsTopLevelShell
  #define gxm_XtIsApplicationShell_w gxm_XtIsApplicationShell
  #define gxm_XtIsSessionShell_w gxm_XtIsSessionShell
  #define gxm_XtMapWidget_w gxm_XtMapWidget
  #define gxm_XtUnmapWidget_w gxm_XtUnmapWidget
#endif
  #define gxm_XLoadQueryFont_w gxm_XLoadQueryFont
  #define gxm_XQueryFont_w gxm_XQueryFont
  #define gxm_XGetMotionEvents_w gxm_XGetMotionEvents
  #define gxm_XDeleteModifiermapEntry_w gxm_XDeleteModifiermapEntry
  #define gxm_XGetModifierMapping_w gxm_XGetModifierMapping
  #define gxm_XInsertModifiermapEntry_w gxm_XInsertModifiermapEntry
  #define gxm_XNewModifiermap_w gxm_XNewModifiermap
  #define gxm_XCreateImage_w gxm_XCreateImage
  #define gxm_XGetImage_w gxm_XGetImage
  #define gxm_XGetSubImage_w gxm_XGetSubImage
  #define gxm_XOpenDisplay_w gxm_XOpenDisplay
  #define gxm_XFetchBytes_w gxm_XFetchBytes
  #define gxm_XFetchBuffer_w gxm_XFetchBuffer
  #define gxm_XGetAtomName_w gxm_XGetAtomName
  #define gxm_XDisplayName_w gxm_XDisplayName
  #define gxm_XKeysymToString_w gxm_XKeysymToString
  #define gxm_XSynchronize_w gxm_XSynchronize
  #define gxm_XSetAfterFunction_w gxm_XSetAfterFunction
  #define gxm_XInternAtom_w gxm_XInternAtom
  #define gxm_XCopyColormapAndFree_w gxm_XCopyColormapAndFree
  #define gxm_XCreateColormap_w gxm_XCreateColormap
  #define gxm_XCreatePixmapCursor_w gxm_XCreatePixmapCursor
  #define gxm_XCreateGlyphCursor_w gxm_XCreateGlyphCursor
  #define gxm_XCreateFontCursor_w gxm_XCreateFontCursor
  #define gxm_XLoadFont_w gxm_XLoadFont
  #define gxm_XCreateGC_w gxm_XCreateGC
  #define gxm_XFlushGC_w gxm_XFlushGC
  #define gxm_XCreatePixmap_w gxm_XCreatePixmap
  #define gxm_XCreateBitmapFromData_w gxm_XCreateBitmapFromData
  #define gxm_XCreatePixmapFromBitmapData_w gxm_XCreatePixmapFromBitmapData
  #define gxm_XCreateSimpleWindow_w gxm_XCreateSimpleWindow
  #define gxm_XGetSelectionOwner_w gxm_XGetSelectionOwner
  #define gxm_XCreateWindow_w gxm_XCreateWindow
  #define gxm_XListInstalledColormaps_w gxm_XListInstalledColormaps
  #define gxm_XListFonts_w gxm_XListFonts
  #define gxm_XListFontsWithInfo_w gxm_XListFontsWithInfo
  #define gxm_XGetFontPath_w gxm_XGetFontPath
  #define gxm_XListExtensions_w gxm_XListExtensions
  #define gxm_XListProperties_w gxm_XListProperties
  #define gxm_XKeycodeToKeysym_w gxm_XKeycodeToKeysym
  #define gxm_XLookupKeysym_w gxm_XLookupKeysym
  #define gxm_XGetKeyboardMapping_w gxm_XGetKeyboardMapping
  #define gxm_XStringToKeysym_w gxm_XStringToKeysym
  #define gxm_XMaxRequestSize_w gxm_XMaxRequestSize
  #define gxm_XExtendedMaxRequestSize_w gxm_XExtendedMaxRequestSize
  #define gxm_XDisplayMotionBufferSize_w gxm_XDisplayMotionBufferSize
  #define gxm_XVisualIDFromVisual_w gxm_XVisualIDFromVisual
  #define gxm_XRootWindow_w gxm_XRootWindow
  #define gxm_XDefaultRootWindow_w gxm_XDefaultRootWindow
  #define gxm_XRootWindowOfScreen_w gxm_XRootWindowOfScreen
  #define gxm_XDefaultVisual_w gxm_XDefaultVisual
  #define gxm_XDefaultVisualOfScreen_w gxm_XDefaultVisualOfScreen
  #define gxm_XDefaultGC_w gxm_XDefaultGC
  #define gxm_XDefaultGCOfScreen_w gxm_XDefaultGCOfScreen
  #define gxm_XBlackPixel_w gxm_XBlackPixel
  #define gxm_XWhitePixel_w gxm_XWhitePixel
  #define gxm_XAllPlanes_w gxm_XAllPlanes
  #define gxm_XBlackPixelOfScreen_w gxm_XBlackPixelOfScreen
  #define gxm_XWhitePixelOfScreen_w gxm_XWhitePixelOfScreen
  #define gxm_XNextRequest_w gxm_XNextRequest
  #define gxm_XLastKnownRequestProcessed_w gxm_XLastKnownRequestProcessed
  #define gxm_XServerVendor_w gxm_XServerVendor
  #define gxm_XDisplayString_w gxm_XDisplayString
  #define gxm_XDefaultColormap_w gxm_XDefaultColormap
  #define gxm_XDefaultColormapOfScreen_w gxm_XDefaultColormapOfScreen
  #define gxm_XDisplayOfScreen_w gxm_XDisplayOfScreen
  #define gxm_XScreenOfDisplay_w gxm_XScreenOfDisplay
  #define gxm_XDefaultScreenOfDisplay_w gxm_XDefaultScreenOfDisplay
  #define gxm_XEventMaskOfScreen_w gxm_XEventMaskOfScreen
  #define gxm_XScreenNumberOfScreen_w gxm_XScreenNumberOfScreen
  #define gxm_XSetErrorHandler_w gxm_XSetErrorHandler
  #define gxm_XSetIOErrorHandler_w gxm_XSetIOErrorHandler
  #define gxm_XListPixmapFormats_w gxm_XListPixmapFormats
  #define gxm_XListDepths_w gxm_XListDepths
  #define gxm_XReconfigureWMWindow_w gxm_XReconfigureWMWindow
  #define gxm_XGetWMProtocols_w gxm_XGetWMProtocols
  #define gxm_XSetWMProtocols_w gxm_XSetWMProtocols
  #define gxm_XIconifyWindow_w gxm_XIconifyWindow
  #define gxm_XWithdrawWindow_w gxm_XWithdrawWindow
  #define gxm_XGetCommand_w gxm_XGetCommand
  #define gxm_XGetWMColormapWindows_w gxm_XGetWMColormapWindows
  #define gxm_XSetWMColormapWindows_w gxm_XSetWMColormapWindows
  #define gxm_XSetTransientForHint_w gxm_XSetTransientForHint
  #define gxm_XActivateScreenSaver_w gxm_XActivateScreenSaver
  #define gxm_XAllocColor_w gxm_XAllocColor
  #define gxm_XAllocColorCells_w gxm_XAllocColorCells
  #define gxm_XAllocColorPlanes_w gxm_XAllocColorPlanes
  #define gxm_XAllocNamedColor_w gxm_XAllocNamedColor
  #define gxm_XAllowEvents_w gxm_XAllowEvents
  #define gxm_XAutoRepeatOff_w gxm_XAutoRepeatOff
  #define gxm_XAutoRepeatOn_w gxm_XAutoRepeatOn
  #define gxm_XBell_w gxm_XBell
  #define gxm_XBitmapBitOrder_w gxm_XBitmapBitOrder
  #define gxm_XBitmapPad_w gxm_XBitmapPad
  #define gxm_XBitmapUnit_w gxm_XBitmapUnit
  #define gxm_XCellsOfScreen_w gxm_XCellsOfScreen
  #define gxm_XChangeActivePointerGrab_w gxm_XChangeActivePointerGrab
  #define gxm_XChangeGC_w gxm_XChangeGC
  #define gxm_XChangeKeyboardControl_w gxm_XChangeKeyboardControl
  #define gxm_XChangeKeyboardMapping_w gxm_XChangeKeyboardMapping
  #define gxm_XChangePointerControl_w gxm_XChangePointerControl
  #define gxm_XChangeProperty_w gxm_XChangeProperty
  #define gxm_XChangeWindowAttributes_w gxm_XChangeWindowAttributes
  #define gxm_XCheckIfEvent_w gxm_XCheckIfEvent
  #define gxm_XCheckMaskEvent_w gxm_XCheckMaskEvent
  #define gxm_XCheckTypedEvent_w gxm_XCheckTypedEvent
  #define gxm_XCheckTypedWindowEvent_w gxm_XCheckTypedWindowEvent
  #define gxm_XCheckWindowEvent_w gxm_XCheckWindowEvent
  #define gxm_XCirculateSubwindows_w gxm_XCirculateSubwindows
  #define gxm_XCirculateSubwindowsDown_w gxm_XCirculateSubwindowsDown
  #define gxm_XCirculateSubwindowsUp_w gxm_XCirculateSubwindowsUp
  #define gxm_XClearArea_w gxm_XClearArea
  #define gxm_XClearWindow_w gxm_XClearWindow
  #define gxm_XCloseDisplay_w gxm_XCloseDisplay
  #define gxm_XConfigureWindow_w gxm_XConfigureWindow
  #define gxm_XConnectionNumber_w gxm_XConnectionNumber
  #define gxm_XConvertSelection_w gxm_XConvertSelection
  #define gxm_XCopyArea_w gxm_XCopyArea
  #define gxm_XCopyGC_w gxm_XCopyGC
  #define gxm_XCopyPlane_w gxm_XCopyPlane
  #define gxm_XDefaultDepth_w gxm_XDefaultDepth
  #define gxm_XDefaultDepthOfScreen_w gxm_XDefaultDepthOfScreen
  #define gxm_XDefaultScreen_w gxm_XDefaultScreen
  #define gxm_XDefineCursor_w gxm_XDefineCursor
  #define gxm_XDeleteProperty_w gxm_XDeleteProperty
  #define gxm_XDestroyWindow_w gxm_XDestroyWindow
  #define gxm_XDestroySubwindows_w gxm_XDestroySubwindows
  #define gxm_XDoesBackingStore_w gxm_XDoesBackingStore
  #define gxm_XDoesSaveUnders_w gxm_XDoesSaveUnders
  #define gxm_XDisableAccessControl_w gxm_XDisableAccessControl
  #define gxm_XDisplayCells_w gxm_XDisplayCells
  #define gxm_XDisplayHeight_w gxm_XDisplayHeight
  #define gxm_XDisplayHeightMM_w gxm_XDisplayHeightMM
  #define gxm_XDisplayKeycodes_w gxm_XDisplayKeycodes
  #define gxm_XDisplayPlanes_w gxm_XDisplayPlanes
  #define gxm_XDisplayWidth_w gxm_XDisplayWidth
  #define gxm_XDisplayWidthMM_w gxm_XDisplayWidthMM
  #define gxm_XDrawArc_w gxm_XDrawArc
  #define gxm_XDrawArcs_w gxm_XDrawArcs
  #define gxm_XDrawImageString_w gxm_XDrawImageString
  #define gxm_XDrawLine_w gxm_XDrawLine
  #define gxm_XDrawLines_w gxm_XDrawLines
  #define gxm_XDrawLinesDirect_w gxm_XDrawLinesDirect
  #define gxm_FreeXPoints_w gxm_FreeXPoints
  #define gxm_Vector2XPoints_w gxm_Vector2XPoints
  #define gxm_XDrawPoint_w gxm_XDrawPoint
  #define gxm_XDrawPoints_w gxm_XDrawPoints
  #define gxm_XDrawRectangle_w gxm_XDrawRectangle
  #define gxm_XDrawRectangles_w gxm_XDrawRectangles
  #define gxm_XDrawSegments_w gxm_XDrawSegments
  #define gxm_XDrawString_w gxm_XDrawString
  #define gxm_XDrawText_w gxm_XDrawText
  #define gxm_XEnableAccessControl_w gxm_XEnableAccessControl
  #define gxm_XEventsQueued_w gxm_XEventsQueued
  #define gxm_XFetchName_w gxm_XFetchName
  #define gxm_XFillArc_w gxm_XFillArc
  #define gxm_XFillArcs_w gxm_XFillArcs
  #define gxm_XFillPolygon_w gxm_XFillPolygon
  #define gxm_XFillRectangle_w gxm_XFillRectangle
  #define gxm_XFillRectangles_w gxm_XFillRectangles
  #define gxm_XFlush_w gxm_XFlush
  #define gxm_XForceScreenSaver_w gxm_XForceScreenSaver
  #define gxm_XFree_w gxm_XFree
  #define gxm_XFreeColormap_w gxm_XFreeColormap
  #define gxm_XFreeColors_w gxm_XFreeColors
  #define gxm_XFreeCursor_w gxm_XFreeCursor
  #define gxm_XFreeExtensionList_w gxm_XFreeExtensionList
  #define gxm_XFreeFont_w gxm_XFreeFont
  #define gxm_XFreeFontInfo_w gxm_XFreeFontInfo
  #define gxm_XFreeFontNames_w gxm_XFreeFontNames
  #define gxm_XFreeFontPath_w gxm_XFreeFontPath
  #define gxm_XFreeGC_w gxm_XFreeGC
  #define gxm_XFreeModifiermap_w gxm_XFreeModifiermap
  #define gxm_XFreePixmap_w gxm_XFreePixmap
  #define gxm_XGeometry_w gxm_XGeometry
  #define gxm_XGetErrorText_w gxm_XGetErrorText
  #define gxm_XGetFontProperty_w gxm_XGetFontProperty
  #define gxm_XGetGCValues_w gxm_XGetGCValues
  #define gxm_XGCValues_w gxm_XGCValues
  #define gxm_XEvent_w gxm_XEvent
  #define gxm_XGetGeometry_w gxm_XGetGeometry
  #define gxm_XGetIconName_w gxm_XGetIconName
  #define gxm_XGetInputFocus_w gxm_XGetInputFocus
  #define gxm_XGetKeyboardControl_w gxm_XGetKeyboardControl
  #define gxm_XGetPointerControl_w gxm_XGetPointerControl
  #define gxm_XGetPointerMapping_w gxm_XGetPointerMapping
  #define gxm_XGetScreenSaver_w gxm_XGetScreenSaver
  #define gxm_XGetTransientForHint_w gxm_XGetTransientForHint
  #define gxm_XGetWindowProperty_w gxm_XGetWindowProperty
  #define gxm_XGetWindowAttributes_w gxm_XGetWindowAttributes
  #define gxm_XGrabButton_w gxm_XGrabButton
  #define gxm_XGrabKey_w gxm_XGrabKey
  #define gxm_XGrabKeyboard_w gxm_XGrabKeyboard
  #define gxm_XGrabPointer_w gxm_XGrabPointer
  #define gxm_XGrabServer_w gxm_XGrabServer
  #define gxm_XHeightMMOfScreen_w gxm_XHeightMMOfScreen
  #define gxm_XHeightOfScreen_w gxm_XHeightOfScreen
  #define gxm_XIfEvent_w gxm_XIfEvent
  #define gxm_XImageByteOrder_w gxm_XImageByteOrder
  #define gxm_XInstallColormap_w gxm_XInstallColormap
  #define gxm_XKeysymToKeycode_w gxm_XKeysymToKeycode
  #define gxm_XKillClient_w gxm_XKillClient
  #define gxm_XLookupColor_w gxm_XLookupColor
  #define gxm_XLowerWindow_w gxm_XLowerWindow
  #define gxm_XMapRaised_w gxm_XMapRaised
  #define gxm_XMapSubwindows_w gxm_XMapSubwindows
  #define gxm_XMapWindow_w gxm_XMapWindow
  #define gxm_XMaskEvent_w gxm_XMaskEvent
  #define gxm_XMaxCmapsOfScreen_w gxm_XMaxCmapsOfScreen
  #define gxm_XMinCmapsOfScreen_w gxm_XMinCmapsOfScreen
  #define gxm_XMoveResizeWindow_w gxm_XMoveResizeWindow
  #define gxm_XMoveWindow_w gxm_XMoveWindow
  #define gxm_XNextEvent_w gxm_XNextEvent
  #define gxm_XNoOp_w gxm_XNoOp
  #define gxm_XParseColor_w gxm_XParseColor
  #define gxm_XParseGeometry_w gxm_XParseGeometry
  #define gxm_XPeekEvent_w gxm_XPeekEvent
  #define gxm_XPeekIfEvent_w gxm_XPeekIfEvent
  #define gxm_XPending_w gxm_XPending
  #define gxm_XPlanesOfScreen_w gxm_XPlanesOfScreen
  #define gxm_XProtocolRevision_w gxm_XProtocolRevision
  #define gxm_XProtocolVersion_w gxm_XProtocolVersion
  #define gxm_XPutBackEvent_w gxm_XPutBackEvent
  #define gxm_XPutImage_w gxm_XPutImage
  #define gxm_XQLength_w gxm_XQLength
  #define gxm_XQueryBestCursor_w gxm_XQueryBestCursor
  #define gxm_XQueryBestSize_w gxm_XQueryBestSize
  #define gxm_XQueryBestStipple_w gxm_XQueryBestStipple
  #define gxm_XQueryBestTile_w gxm_XQueryBestTile
  #define gxm_XQueryColor_w gxm_XQueryColor
  #define gxm_XQueryColors_w gxm_XQueryColors
  #define gxm_XQueryExtension_w gxm_XQueryExtension
  #define gxm_XQueryKeymap_w gxm_XQueryKeymap
  #define gxm_XQueryPointer_w gxm_XQueryPointer
  #define gxm_XQueryTextExtents_w gxm_XQueryTextExtents
  #define gxm_XQueryTree_w gxm_XQueryTree
  #define gxm_XRaiseWindow_w gxm_XRaiseWindow
  #define gxm_XReadBitmapFile_w gxm_XReadBitmapFile
  #define gxm_XReadBitmapFileData_w gxm_XReadBitmapFileData
  #define gxm_XRebindKeysym_w gxm_XRebindKeysym
  #define gxm_XRecolorCursor_w gxm_XRecolorCursor
  #define gxm_XRefreshKeyboardMapping_w gxm_XRefreshKeyboardMapping
  #define gxm_XReparentWindow_w gxm_XReparentWindow
  #define gxm_XResetScreenSaver_w gxm_XResetScreenSaver
  #define gxm_XResizeWindow_w gxm_XResizeWindow
  #define gxm_XRestackWindows_w gxm_XRestackWindows
  #define gxm_XRotateBuffers_w gxm_XRotateBuffers
  #define gxm_XRotateWindowProperties_w gxm_XRotateWindowProperties
  #define gxm_XScreenCount_w gxm_XScreenCount
  #define gxm_XSelectInput_w gxm_XSelectInput
  #define gxm_XSendEvent_w gxm_XSendEvent
  #define gxm_XSetAccessControl_w gxm_XSetAccessControl
  #define gxm_XSetArcMode_w gxm_XSetArcMode
  #define gxm_XSetBackground_w gxm_XSetBackground
  #define gxm_XSetClipMask_w gxm_XSetClipMask
  #define gxm_XSetClipOrigin_w gxm_XSetClipOrigin
  #define gxm_XSetClipRectangles_w gxm_XSetClipRectangles
  #define gxm_XSetCloseDownMode_w gxm_XSetCloseDownMode
  #define gxm_XSetCommand_w gxm_XSetCommand
  #define gxm_XSetDashes_w gxm_XSetDashes
  #define gxm_XSetFillRule_w gxm_XSetFillRule
  #define gxm_XSetFillStyle_w gxm_XSetFillStyle
  #define gxm_XSetFont_w gxm_XSetFont
  #define gxm_XSetFontPath_w gxm_XSetFontPath
  #define gxm_XSetForeground_w gxm_XSetForeground
  #define gxm_XSetFunction_w gxm_XSetFunction
  #define gxm_XSetGraphicsExposures_w gxm_XSetGraphicsExposures
  #define gxm_XSetIconName_w gxm_XSetIconName
  #define gxm_XSetInputFocus_w gxm_XSetInputFocus
  #define gxm_XSetLineAttributes_w gxm_XSetLineAttributes
  #define gxm_XSetModifierMapping_w gxm_XSetModifierMapping
  #define gxm_XSetPlaneMask_w gxm_XSetPlaneMask
  #define gxm_XSetPointerMapping_w gxm_XSetPointerMapping
  #define gxm_XSetScreenSaver_w gxm_XSetScreenSaver
  #define gxm_XSetSelectionOwner_w gxm_XSetSelectionOwner
  #define gxm_XSetState_w gxm_XSetState
  #define gxm_XSetStipple_w gxm_XSetStipple
  #define gxm_XSetSubwindowMode_w gxm_XSetSubwindowMode
  #define gxm_XSetTSOrigin_w gxm_XSetTSOrigin
  #define gxm_XSetTile_w gxm_XSetTile
  #define gxm_XSetWindowBackground_w gxm_XSetWindowBackground
  #define gxm_XSetWindowBackgroundPixmap_w gxm_XSetWindowBackgroundPixmap
  #define gxm_XSetWindowBorder_w gxm_XSetWindowBorder
  #define gxm_XSetWindowBorderPixmap_w gxm_XSetWindowBorderPixmap
  #define gxm_XSetWindowBorderWidth_w gxm_XSetWindowBorderWidth
  #define gxm_XSetWindowColormap_w gxm_XSetWindowColormap
  #define gxm_XStoreBuffer_w gxm_XStoreBuffer
  #define gxm_XStoreBytes_w gxm_XStoreBytes
  #define gxm_XStoreColor_w gxm_XStoreColor
  #define gxm_XStoreColors_w gxm_XStoreColors
  #define gxm_XStoreName_w gxm_XStoreName
  #define gxm_XStoreNamedColor_w gxm_XStoreNamedColor
  #define gxm_XSync_w gxm_XSync
  #define gxm_XTextExtents_w gxm_XTextExtents
  #define gxm_XTextWidth_w gxm_XTextWidth
  #define gxm_XTranslateCoordinates_w gxm_XTranslateCoordinates
  #define gxm_XUndefineCursor_w gxm_XUndefineCursor
  #define gxm_XUngrabButton_w gxm_XUngrabButton
  #define gxm_XUngrabKey_w gxm_XUngrabKey
  #define gxm_XUngrabKeyboard_w gxm_XUngrabKeyboard
  #define gxm_XUngrabPointer_w gxm_XUngrabPointer
  #define gxm_XUngrabServer_w gxm_XUngrabServer
  #define gxm_XUninstallColormap_w gxm_XUninstallColormap
  #define gxm_XUnloadFont_w gxm_XUnloadFont
  #define gxm_XUnmapSubwindows_w gxm_XUnmapSubwindows
  #define gxm_XUnmapWindow_w gxm_XUnmapWindow
  #define gxm_XVendorRelease_w gxm_XVendorRelease
  #define gxm_XWarpPointer_w gxm_XWarpPointer
  #define gxm_XWidthMMOfScreen_w gxm_XWidthMMOfScreen
  #define gxm_XWidthOfScreen_w gxm_XWidthOfScreen
  #define gxm_XWindowEvent_w gxm_XWindowEvent
  #define gxm_XWriteBitmapFile_w gxm_XWriteBitmapFile
  #define gxm_XSupportsLocale_w gxm_XSupportsLocale
  #define gxm_XSetLocaleModifiers_w gxm_XSetLocaleModifiers
  #define gxm_XCreateFontSet_w gxm_XCreateFontSet
  #define gxm_XFreeFontSet_w gxm_XFreeFontSet
  #define gxm_XFontsOfFontSet_w gxm_XFontsOfFontSet
  #define gxm_XBaseFontNameListOfFontSet_w gxm_XBaseFontNameListOfFontSet
  #define gxm_XLocaleOfFontSet_w gxm_XLocaleOfFontSet
  #define gxm_XContextDependentDrawing_w gxm_XContextDependentDrawing
  #define gxm_XDirectionalDependentDrawing_w gxm_XDirectionalDependentDrawing
  #define gxm_XContextualDrawing_w gxm_XContextualDrawing
  #define gxm_XFilterEvent_w gxm_XFilterEvent
  #define gxm_XAllocIconSize_w gxm_XAllocIconSize
  #define gxm_XAllocStandardColormap_w gxm_XAllocStandardColormap
  #define gxm_XAllocWMHints_w gxm_XAllocWMHints
  #define gxm_XClipBox_w gxm_XClipBox
  #define gxm_XCreateRegion_w gxm_XCreateRegion
  #define gxm_XDefaultString_w gxm_XDefaultString
  #define gxm_XDeleteContext_w gxm_XDeleteContext
  #define gxm_XDestroyRegion_w gxm_XDestroyRegion
  #define gxm_XEmptyRegion_w gxm_XEmptyRegion
  #define gxm_XEqualRegion_w gxm_XEqualRegion
  #define gxm_XFindContext_w gxm_XFindContext
  #define gxm_XGetIconSizes_w gxm_XGetIconSizes
  #define gxm_XGetRGBColormaps_w gxm_XGetRGBColormaps
#if (!XM_DISABLE_DEPRECATED)
  #define gxm_XGetStandardColormap_w gxm_XGetStandardColormap
#endif
  #define gxm_XGetVisualInfo_w gxm_XGetVisualInfo
  #define gxm_XGetWMHints_w gxm_XGetWMHints
  #define gxm_XIntersectRegion_w gxm_XIntersectRegion
  #define gxm_XConvertCase_w gxm_XConvertCase
  #define gxm_XLookupString_w gxm_XLookupString
  #define gxm_XMatchVisualInfo_w gxm_XMatchVisualInfo
  #define gxm_XOffsetRegion_w gxm_XOffsetRegion
  #define gxm_XPointInRegion_w gxm_XPointInRegion
  #define gxm_XPolygonRegion_w gxm_XPolygonRegion
  #define gxm_XRectInRegion_w gxm_XRectInRegion
  #define gxm_XSaveContext_w gxm_XSaveContext
  #define gxm_XUniqueContext_w gxm_XUniqueContext
  #define gxm_XSetRGBColormaps_w gxm_XSetRGBColormaps
  #define gxm_XSetWMHints_w gxm_XSetWMHints
  #define gxm_XSetRegion_w gxm_XSetRegion
#if (!XM_DISABLE_DEPRECATED)
  #define gxm_XSetStandardColormap_w gxm_XSetStandardColormap
  #define gxm_XSetStandardProperties_w gxm_XSetStandardProperties
#endif
  #define gxm_XSetWMProperties_w gxm_XSetWMProperties
  #define gxm_XShrinkRegion_w gxm_XShrinkRegion
  #define gxm_XSubtractRegion_w gxm_XSubtractRegion
  #define gxm_XUnionRectWithRegion_w gxm_XUnionRectWithRegion
  #define gxm_XUnionRegion_w gxm_XUnionRegion
  #define gxm_XXorRegion_w gxm_XXorRegion

  #define gxm_DefaultScreen_w gxm_DefaultScreen
  #define gxm_DefaultRootWindow_w gxm_DefaultRootWindow
  #define gxm_QLength_w gxm_QLength
  #define gxm_ScreenCount_w gxm_ScreenCount
  #define gxm_ServerVendor_w gxm_ServerVendor
  #define gxm_ProtocolVersion_w gxm_ProtocolVersion
  #define gxm_ProtocolRevision_w gxm_ProtocolRevision
  #define gxm_VendorRelease_w gxm_VendorRelease
  #define gxm_DisplayString_w gxm_DisplayString
  #define gxm_BitmapUnit_w gxm_BitmapUnit
  #define gxm_BitmapBitOrder_w gxm_BitmapBitOrder
  #define gxm_BitmapPad_w gxm_BitmapPad
  #define gxm_ImageByteOrder_w gxm_ImageByteOrder
  #define gxm_NextRequest_w gxm_NextRequest
  #define gxm_LastKnownRequestProcessed_w gxm_LastKnownRequestProcessed
  #define gxm_DefaultScreenOfDisplay_w gxm_DefaultScreenOfDisplay
  #define gxm_DisplayOfScreen_w gxm_DisplayOfScreen
  #define gxm_RootWindowOfScreen_w gxm_RootWindowOfScreen
  #define gxm_BlackPixelOfScreen_w gxm_BlackPixelOfScreen
  #define gxm_WhitePixelOfScreen_w gxm_WhitePixelOfScreen
  #define gxm_DefaultColormapOfScreen_w gxm_DefaultColormapOfScreen
  #define gxm_DefaultDepthOfScreen_w gxm_DefaultDepthOfScreen
  #define gxm_DefaultGCOfScreen_w gxm_DefaultGCOfScreen
  #define gxm_DefaultVisualOfScreen_w gxm_DefaultVisualOfScreen
  #define gxm_WidthOfScreen_w gxm_WidthOfScreen
  #define gxm_HeightOfScreen_w gxm_HeightOfScreen
  #define gxm_WidthMMOfScreen_w gxm_WidthMMOfScreen
  #define gxm_HeightMMOfScreen_w gxm_HeightMMOfScreen
  #define gxm_PlanesOfScreen_w gxm_PlanesOfScreen
  #define gxm_CellsOfScreen_w gxm_CellsOfScreen
  #define gxm_MinCmapsOfScreen_w gxm_MinCmapsOfScreen
  #define gxm_MaxCmapsOfScreen_w gxm_MaxCmapsOfScreen
  #define gxm_DoesSaveUnders_w gxm_DoesSaveUnders
  #define gxm_DoesBackingStore_w gxm_DoesBackingStore
  #define gxm_EventMaskOfScreen_w gxm_EventMaskOfScreen
  #define gxm_RootWindow_w gxm_RootWindow
  #define gxm_DefaultVisual_w gxm_DefaultVisual
  #define gxm_DefaultGC_w gxm_DefaultGC
  #define gxm_BlackPixel_w gxm_BlackPixel
  #define gxm_WhitePixel_w gxm_WhitePixel
  #define gxm_DisplayWidth_w gxm_DisplayWidth
  #define gxm_DisplayHeight_w gxm_DisplayHeight
  #define gxm_DisplayWidthMM_w gxm_DisplayWidthMM
  #define gxm_DisplayHeightMM_w gxm_DisplayHeightMM
  #define gxm_DisplayPlanes_w gxm_DisplayPlanes
  #define gxm_DisplayCells_w gxm_DisplayCells
  #define gxm_DefaultColormap_w gxm_DefaultColormap
  #define gxm_ScreenOfDisplay_w gxm_ScreenOfDisplay
  #define gxm_DefaultDepth_w gxm_DefaultDepth

  #define gxm_IsKeypadKey_w gxm_IsKeypadKey
  #define gxm_IsPrivateKeypadKey_w gxm_IsPrivateKeypadKey
  #define gxm_IsCursorKey_w gxm_IsCursorKey
  #define gxm_IsPFKey_w gxm_IsPFKey
  #define gxm_IsFunctionKey_w gxm_IsFunctionKey
  #define gxm_IsMiscFunctionKey_w gxm_IsMiscFunctionKey
  #define gxm_IsModifierKey_w gxm_IsModifierKey

  #define XEN_XButtonEvent_p_w XEN_XButtonEvent_p
  #define XEN_XCirculateEvent_p_w XEN_XCirculateEvent_p
  #define XEN_XCirculateRequestEvent_p_w XEN_XCirculateRequestEvent_p
  #define XEN_XClientMessageEvent_p_w XEN_XClientMessageEvent_p
  #define XEN_XColormapEvent_p_w XEN_XColormapEvent_p
  #define XEN_XConfigureEvent_p_w XEN_XConfigureEvent_p
  #define XEN_XConfigureRequestEvent_p_w XEN_XConfigureRequestEvent_p
  #define XEN_XCreateWindowEvent_p_w XEN_XCreateWindowEvent_p
  #define XEN_XCrossingEvent_p_w XEN_XCrossingEvent_p
  #define XEN_XDestroyWindowEvent_p_w XEN_XDestroyWindowEvent_p
  #define XEN_XErrorEvent_p_w XEN_XErrorEvent_p
  #define XEN_XExposeEvent_p_w XEN_XExposeEvent_p
  #define XEN_XFocusChangeEvent_p_w XEN_XFocusChangeEvent_p
  #define XEN_XGraphicsExposeEvent_p_w XEN_XGraphicsExposeEvent_p
  #define XEN_XGravityEvent_p_w XEN_XGravityEvent_p
  #define XEN_XKeyEvent_p_w XEN_XKeyEvent_p
  #define XEN_XKeymapEvent_p_w XEN_XKeymapEvent_p
  #define XEN_XMapEvent_p_w XEN_XMapEvent_p
  #define XEN_XMapRequestEvent_p_w XEN_XMapRequestEvent_p
  #define XEN_XMappingEvent_p_w XEN_XMappingEvent_p
  #define XEN_XMotionEvent_p_w XEN_XMotionEvent_p
  #define XEN_XNoExposeEvent_p_w XEN_XNoExposeEvent_p
  #define XEN_XPropertyEvent_p_w XEN_XPropertyEvent_p
  #define XEN_XReparentEvent_p_w XEN_XReparentEvent_p
  #define XEN_XResizeRequestEvent_p_w XEN_XResizeRequestEvent_p
  #define XEN_XSelectionClearEvent_p_w XEN_XSelectionClearEvent_p
  #define XEN_XSelectionEvent_p_w XEN_XSelectionEvent_p
  #define XEN_XSelectionRequestEvent_p_w XEN_XSelectionRequestEvent_p
  #define XEN_XSetWindowAttributes_p_w XEN_XSetWindowAttributes_p
  #define XEN_XUnmapEvent_p_w XEN_XUnmapEvent_p
  #define XEN_XVisibilityEvent_p_w XEN_XVisibilityEvent_p
  #define XEN_XIconSize_p_w XEN_XIconSize_p

#if HAVE_MOTIF
  #define gxm_XmCreateMessageBox_w gxm_XmCreateMessageBox
  #define gxm_XmCreateMessageDialog_w gxm_XmCreateMessageDialog
  #define gxm_XmCreateErrorDialog_w gxm_XmCreateErrorDialog
  #define gxm_XmCreateInformationDialog_w gxm_XmCreateInformationDialog
  #define gxm_XmCreateQuestionDialog_w gxm_XmCreateQuestionDialog
  #define gxm_XmCreateWarningDialog_w gxm_XmCreateWarningDialog
  #define gxm_XmCreateWorkingDialog_w gxm_XmCreateWorkingDialog
  #define gxm_XmCreateTemplateDialog_w gxm_XmCreateTemplateDialog
  #define gxm_XmMessageBoxGetChild_w gxm_XmMessageBoxGetChild
  #define gxm_XmCreateArrowButtonGadget_w gxm_XmCreateArrowButtonGadget
  #define gxm_XmCreateArrowButton_w gxm_XmCreateArrowButton
  #define gxm_XmCreateNotebook_w gxm_XmCreateNotebook
  #define gxm_XmNotebookGetPageInfo_w gxm_XmNotebookGetPageInfo
#if HAVE_XM_XP
  #define gxm_XmPrintSetup_w gxm_XmPrintSetup
  #define gxm_XmPrintToFile_w gxm_XmPrintToFile
  #define gxm_XmPrintPopupPDM_w gxm_XmPrintPopupPDM
  #define gxm_XmRedisplayWidget_w gxm_XmRedisplayWidget
#endif
  #define gxm_XmTransferSetParameters_w gxm_XmTransferSetParameters
  #define gxm_XmTransferDone_w gxm_XmTransferDone
  #define gxm_XmTransferValue_w gxm_XmTransferValue
  #define gxm_XmTransferStartRequest_w gxm_XmTransferStartRequest
  #define gxm_XmTransferSendRequest_w gxm_XmTransferSendRequest
  #define gxm_XmCreateComboBox_w gxm_XmCreateComboBox
  #define gxm_XmCreateDropDownComboBox_w gxm_XmCreateDropDownComboBox
  #define gxm_XmCreateDropDownList_w gxm_XmCreateDropDownList
  #define gxm_XmComboBoxAddItem_w gxm_XmComboBoxAddItem
  #define gxm_XmComboBoxDeletePos_w gxm_XmComboBoxDeletePos
  #define gxm_XmComboBoxSelectItem_w gxm_XmComboBoxSelectItem
  #define gxm_XmComboBoxSetItem_w gxm_XmComboBoxSetItem
  #define gxm_XmComboBoxUpdate_w gxm_XmComboBoxUpdate
  #define gxm_XmCreateContainer_w gxm_XmCreateContainer
  #define gxm_XmContainerGetItemChildren_w gxm_XmContainerGetItemChildren
  #define gxm_XmContainerRelayout_w gxm_XmContainerRelayout
  #define gxm_XmContainerReorder_w gxm_XmContainerReorder
  #define gxm_XmContainerCut_w gxm_XmContainerCut
  #define gxm_XmContainerCopy_w gxm_XmContainerCopy
  #define gxm_XmContainerPaste_w gxm_XmContainerPaste
  #define gxm_XmContainerCopyLink_w gxm_XmContainerCopyLink
  #define gxm_XmContainerPasteLink_w gxm_XmContainerPasteLink
  #define gxm_XmCreateSpinBox_w gxm_XmCreateSpinBox
  #define gxm_XmSpinBoxValidatePosition_w gxm_XmSpinBoxValidatePosition
  #define gxm_XmCreateSimpleSpinBox_w gxm_XmCreateSimpleSpinBox
  #define gxm_XmSimpleSpinBoxAddItem_w gxm_XmSimpleSpinBoxAddItem
  #define gxm_XmSimpleSpinBoxDeletePos_w gxm_XmSimpleSpinBoxDeletePos
  #define gxm_XmSimpleSpinBoxSetItem_w gxm_XmSimpleSpinBoxSetItem
  #define gxm_XmDropSiteRegistered_w gxm_XmDropSiteRegistered
  #define gxm_XmTextFieldCopyLink_w gxm_XmTextFieldCopyLink
  #define gxm_XmTextFieldPasteLink_w gxm_XmTextFieldPasteLink
  #define gxm_XmTextGetCenterline_w gxm_XmTextGetCenterline
  #define gxm_XmToggleButtonGadgetSetValue_w gxm_XmToggleButtonGadgetSetValue
  #define gxm_XmCreateIconGadget_w gxm_XmCreateIconGadget
  #define gxm_XmCreateIconHeader_w gxm_XmCreateIconHeader
  #define gxm_XmObjectAtPoint_w gxm_XmObjectAtPoint
  #define gxm_XmConvertStringToUnits_w gxm_XmConvertStringToUnits
  #define gxm_XmCreateGrabShell_w gxm_XmCreateGrabShell
  #define gxm_XmToggleButtonSetValue_w gxm_XmToggleButtonSetValue
  #define gxm_XmTextPasteLink_w gxm_XmTextPasteLink
  #define gxm_XmTextCopyLink_w gxm_XmTextCopyLink
  #define gxm_XmScaleSetTicks_w gxm_XmScaleSetTicks
  #define gxm_XmInternAtom_w gxm_XmInternAtom
  #define gxm_XmGetAtomName_w gxm_XmGetAtomName
  #define gxm_XmCreatePanedWindow_w gxm_XmCreatePanedWindow
  #define gxm_XmCreateBulletinBoard_w gxm_XmCreateBulletinBoard
  #define gxm_XmCreateBulletinBoardDialog_w gxm_XmCreateBulletinBoardDialog
  #define gxm_XmCreateCascadeButtonGadget_w gxm_XmCreateCascadeButtonGadget
  #define gxm_XmCascadeButtonGadgetHighlight_w gxm_XmCascadeButtonGadgetHighlight
  #define gxm_XmAddProtocols_w gxm_XmAddProtocols
  #define gxm_XmRemoveProtocols_w gxm_XmRemoveProtocols
  #define gxm_XmAddProtocolCallback_w gxm_XmAddProtocolCallback
  #define gxm_XmRemoveProtocolCallback_w gxm_XmRemoveProtocolCallback
  #define gxm_XmActivateProtocol_w gxm_XmActivateProtocol
  #define gxm_XmDeactivateProtocol_w gxm_XmDeactivateProtocol
  #define gxm_XmSetProtocolHooks_w gxm_XmSetProtocolHooks
  #define gxm_XmCreateCascadeButton_w gxm_XmCreateCascadeButton
  #define gxm_XmCascadeButtonHighlight_w gxm_XmCascadeButtonHighlight
  #define gxm_XmCreatePushButtonGadget_w gxm_XmCreatePushButtonGadget
  #define gxm_XmCreatePushButton_w gxm_XmCreatePushButton
  #define gxm_XmCreateCommand_w gxm_XmCreateCommand
  #define gxm_XmCommandGetChild_w gxm_XmCommandGetChild
  #define gxm_XmCommandSetValue_w gxm_XmCommandSetValue
  #define gxm_XmCommandAppendValue_w gxm_XmCommandAppendValue
  #define gxm_XmCommandError_w gxm_XmCommandError
  #define gxm_XmCreateCommandDialog_w gxm_XmCreateCommandDialog
  #define gxm_XmMenuPosition_w gxm_XmMenuPosition
  #define gxm_XmCreateRowColumn_w gxm_XmCreateRowColumn
  #define gxm_XmCreateWorkArea_w gxm_XmCreateWorkArea
  #define gxm_XmCreateRadioBox_w gxm_XmCreateRadioBox
  #define gxm_XmCreateOptionMenu_w gxm_XmCreateOptionMenu
  #define gxm_XmOptionLabelGadget_w gxm_XmOptionLabelGadget
  #define gxm_XmOptionButtonGadget_w gxm_XmOptionButtonGadget
  #define gxm_XmCreateMenuBar_w gxm_XmCreateMenuBar
  #define gxm_XmCreatePopupMenu_w gxm_XmCreatePopupMenu
  #define gxm_XmCreatePulldownMenu_w gxm_XmCreatePulldownMenu
  #define gxm_XmGetPostedFromWidget_w gxm_XmGetPostedFromWidget
  #define gxm_XmGetTearOffControl_w gxm_XmGetTearOffControl
#if (!XM_DISABLE_DEPRECATED)
  #define gxm_XmAddToPostFromList_w gxm_XmAddToPostFromList
  #define gxm_XmRemoveFromPostFromList_w gxm_XmRemoveFromPostFromList
#endif
  #define gxm_XmScaleSetValue_w gxm_XmScaleSetValue
  #define gxm_XmScaleGetValue_w gxm_XmScaleGetValue
  #define gxm_XmCreateScale_w gxm_XmCreateScale
  #define gxm_XmClipboardBeginCopy_w gxm_XmClipboardBeginCopy
  #define gxm_XmClipboardStartCopy_w gxm_XmClipboardStartCopy
  #define gxm_XmClipboardCopy_w gxm_XmClipboardCopy
  #define gxm_XmClipboardEndCopy_w gxm_XmClipboardEndCopy
  #define gxm_XmClipboardCancelCopy_w gxm_XmClipboardCancelCopy
  #define gxm_XmClipboardWithdrawFormat_w gxm_XmClipboardWithdrawFormat
  #define gxm_XmClipboardCopyByName_w gxm_XmClipboardCopyByName
  #define gxm_XmClipboardUndoCopy_w gxm_XmClipboardUndoCopy
  #define gxm_XmClipboardLock_w gxm_XmClipboardLock
  #define gxm_XmClipboardUnlock_w gxm_XmClipboardUnlock
  #define gxm_XmClipboardStartRetrieve_w gxm_XmClipboardStartRetrieve
  #define gxm_XmClipboardEndRetrieve_w gxm_XmClipboardEndRetrieve
  #define gxm_XmClipboardRetrieve_w gxm_XmClipboardRetrieve
  #define gxm_XmClipboardInquireCount_w gxm_XmClipboardInquireCount
  #define gxm_XmClipboardInquireFormat_w gxm_XmClipboardInquireFormat
  #define gxm_XmClipboardInquireLength_w gxm_XmClipboardInquireLength
  #define gxm_XmClipboardInquirePendingItems_w gxm_XmClipboardInquirePendingItems
  #define gxm_XmClipboardRegisterFormat_w gxm_XmClipboardRegisterFormat
#if HAVE_XmToolTipGetLabel
  #define gxm_XmToolTipGetLabel_w gxm_XmToolTipGetLabel
#endif
  #define gxm_XmGetXmScreen_w gxm_XmGetXmScreen
#if HAVE_XmCreateFontSelector
    #define gxm_XmCreateFontSelector_w gxm_XmCreateFontSelector
#endif
#if HAVE_XmCreateColorSelector
    #define gxm_XmCreateColorSelector_w gxm_XmCreateColorSelector
#endif
  #define gxm_XmCreateScrollBar_w gxm_XmCreateScrollBar
  #define gxm_XmScrollBarGetValues_w gxm_XmScrollBarGetValues
  #define gxm_XmScrollBarSetValues_w gxm_XmScrollBarSetValues
  #define gxm_XmCreateDialogShell_w gxm_XmCreateDialogShell
  #define gxm_XmCreateScrolledWindow_w gxm_XmCreateScrolledWindow
  #define gxm_XmScrollVisible_w gxm_XmScrollVisible
  #define gxm_XmGetDragContext_w gxm_XmGetDragContext
  #define gxm_XmGetXmDisplay_w gxm_XmGetXmDisplay
  #define gxm_XmSelectionBoxGetChild_w gxm_XmSelectionBoxGetChild
  #define gxm_XmCreateSelectionBox_w gxm_XmCreateSelectionBox
  #define gxm_XmCreateSelectionDialog_w gxm_XmCreateSelectionDialog
  #define gxm_XmCreatePromptDialog_w gxm_XmCreatePromptDialog
  #define gxm_XmDragStart_w gxm_XmDragStart
  #define gxm_XmDragCancel_w gxm_XmDragCancel
  #define gxm_XmTargetsAreCompatible_w gxm_XmTargetsAreCompatible
  #define gxm_XmCreateSeparatorGadget_w gxm_XmCreateSeparatorGadget
  #define gxm_XmCreateDragIcon_w gxm_XmCreateDragIcon
  #define gxm_XmCreateSeparator_w gxm_XmCreateSeparator
  #define gxm_XmCreateDrawingArea_w gxm_XmCreateDrawingArea
  #define gxm_XmCreateDrawnButton_w gxm_XmCreateDrawnButton
  #define gxm_XmDropSiteRegister_w gxm_XmDropSiteRegister
  #define gxm_XmDropSiteUnregister_w gxm_XmDropSiteUnregister
  #define gxm_XmDropSiteStartUpdate_w gxm_XmDropSiteStartUpdate
  #define gxm_XmDropSiteUpdate_w gxm_XmDropSiteUpdate
  #define gxm_XmDropSiteEndUpdate_w gxm_XmDropSiteEndUpdate
  #define gxm_XmDropSiteRetrieve_w gxm_XmDropSiteRetrieve
  #define gxm_XmDropSiteQueryStackingOrder_w gxm_XmDropSiteQueryStackingOrder
  #define gxm_XmDropSiteConfigureStackingOrder_w gxm_XmDropSiteConfigureStackingOrder
  #define gxm_XmDropTransferStart_w gxm_XmDropTransferStart
  #define gxm_XmDropTransferAdd_w gxm_XmDropTransferAdd
  #define gxm_XmTextFieldGetString_w gxm_XmTextFieldGetString
  #define gxm_XmTextFieldGetSubstring_w gxm_XmTextFieldGetSubstring
  #define gxm_XmTextFieldGetLastPosition_w gxm_XmTextFieldGetLastPosition
  #define gxm_XmTextFieldSetString_w gxm_XmTextFieldSetString
  #define gxm_XmTextFieldReplace_w gxm_XmTextFieldReplace
  #define gxm_XmTextFieldInsert_w gxm_XmTextFieldInsert
  #define gxm_XmTextFieldSetAddMode_w gxm_XmTextFieldSetAddMode
  #define gxm_XmTextFieldGetAddMode_w gxm_XmTextFieldGetAddMode
  #define gxm_XmTextFieldGetEditable_w gxm_XmTextFieldGetEditable
  #define gxm_XmTextFieldSetEditable_w gxm_XmTextFieldSetEditable
  #define gxm_XmTextFieldGetMaxLength_w gxm_XmTextFieldGetMaxLength
  #define gxm_XmTextFieldSetMaxLength_w gxm_XmTextFieldSetMaxLength
  #define gxm_XmTextFieldGetCursorPosition_w gxm_XmTextFieldGetCursorPosition
  #define gxm_XmTextFieldGetInsertionPosition_w gxm_XmTextFieldGetInsertionPosition
  #define gxm_XmTextFieldSetCursorPosition_w gxm_XmTextFieldSetCursorPosition
  #define gxm_XmTextFieldSetInsertionPosition_w gxm_XmTextFieldSetInsertionPosition
  #define gxm_XmTextFieldGetSelectionPosition_w gxm_XmTextFieldGetSelectionPosition
  #define gxm_XmTextFieldGetSelection_w gxm_XmTextFieldGetSelection
  #define gxm_XmTextFieldRemove_w gxm_XmTextFieldRemove
  #define gxm_XmTextFieldCopy_w gxm_XmTextFieldCopy
  #define gxm_XmTextFieldCut_w gxm_XmTextFieldCut
  #define gxm_XmTextFieldPaste_w gxm_XmTextFieldPaste
  #define gxm_XmTextFieldClearSelection_w gxm_XmTextFieldClearSelection
  #define gxm_XmTextFieldSetSelection_w gxm_XmTextFieldSetSelection
  #define gxm_XmTextFieldXYToPos_w gxm_XmTextFieldXYToPos
  #define gxm_XmTextFieldPosToXY_w gxm_XmTextFieldPosToXY
  #define gxm_XmTextFieldShowPosition_w gxm_XmTextFieldShowPosition
  #define gxm_XmTextFieldSetHighlight_w gxm_XmTextFieldSetHighlight
  #define gxm_XmTextFieldGetBaseline_w gxm_XmTextFieldGetBaseline
  #define gxm_XmCreateTextField_w gxm_XmCreateTextField
  #define gxm_XmFileSelectionBoxGetChild_w gxm_XmFileSelectionBoxGetChild
  #define gxm_XmFileSelectionDoSearch_w gxm_XmFileSelectionDoSearch
  #define gxm_XmCreateFileSelectionBox_w gxm_XmCreateFileSelectionBox
  #define gxm_XmCreateFileSelectionDialog_w gxm_XmCreateFileSelectionDialog
  #define gxm_XmTextSetHighlight_w gxm_XmTextSetHighlight
  #define gxm_XmCreateScrolledText_w gxm_XmCreateScrolledText
  #define gxm_XmCreateText_w gxm_XmCreateText
  #define gxm_XmTextGetSubstring_w gxm_XmTextGetSubstring
  #define gxm_XmTextGetString_w gxm_XmTextGetString
  #define gxm_XmTextGetLastPosition_w gxm_XmTextGetLastPosition
  #define gxm_XmTextSetString_w gxm_XmTextSetString
  #define gxm_XmTextReplace_w gxm_XmTextReplace
  #define gxm_XmTextInsert_w gxm_XmTextInsert
  #define gxm_XmTextSetAddMode_w gxm_XmTextSetAddMode
  #define gxm_XmTextGetAddMode_w gxm_XmTextGetAddMode
  #define gxm_XmTextGetEditable_w gxm_XmTextGetEditable
  #define gxm_XmTextSetEditable_w gxm_XmTextSetEditable
  #define gxm_XmTextGetMaxLength_w gxm_XmTextGetMaxLength
  #define gxm_XmTextSetMaxLength_w gxm_XmTextSetMaxLength
  #define gxm_XmTextGetTopCharacter_w gxm_XmTextGetTopCharacter
  #define gxm_XmTextSetTopCharacter_w gxm_XmTextSetTopCharacter
  #define gxm_XmTextGetCursorPosition_w gxm_XmTextGetCursorPosition
  #define gxm_XmTextGetInsertionPosition_w gxm_XmTextGetInsertionPosition
  #define gxm_XmTextSetInsertionPosition_w gxm_XmTextSetInsertionPosition
  #define gxm_XmTextSetCursorPosition_w gxm_XmTextSetCursorPosition
  #define gxm_XmTextRemove_w gxm_XmTextRemove
  #define gxm_XmTextCopy_w gxm_XmTextCopy
  #define gxm_XmTextCut_w gxm_XmTextCut
  #define gxm_XmTextPaste_w gxm_XmTextPaste
  #define gxm_XmTextGetSelection_w gxm_XmTextGetSelection
  #define gxm_XmTextSetSelection_w gxm_XmTextSetSelection
  #define gxm_XmTextClearSelection_w gxm_XmTextClearSelection
  #define gxm_XmTextGetSelectionPosition_w gxm_XmTextGetSelectionPosition
  #define gxm_XmTextXYToPos_w gxm_XmTextXYToPos
  #define gxm_XmTextPosToXY_w gxm_XmTextPosToXY
  #define gxm_XmTextGetSource_w gxm_XmTextGetSource
  #define gxm_XmTextSetSource_w gxm_XmTextSetSource
  #define gxm_XmTextShowPosition_w gxm_XmTextShowPosition
  #define gxm_XmTextScroll_w gxm_XmTextScroll
  #define gxm_XmTextGetBaseline_w gxm_XmTextGetBaseline
  #define gxm_XmTextDisableRedisplay_w gxm_XmTextDisableRedisplay
  #define gxm_XmTextEnableRedisplay_w gxm_XmTextEnableRedisplay
  #define gxm_XmTextFindString_w gxm_XmTextFindString
  #define gxm_XmCreateForm_w gxm_XmCreateForm
  #define gxm_XmCreateFormDialog_w gxm_XmCreateFormDialog
  #define gxm_XmCreateFrame_w gxm_XmCreateFrame
  #define gxm_XmToggleButtonGadgetGetState_w gxm_XmToggleButtonGadgetGetState
  #define gxm_XmToggleButtonGadgetSetState_w gxm_XmToggleButtonGadgetSetState
  #define gxm_XmCreateToggleButtonGadget_w gxm_XmCreateToggleButtonGadget
  #define gxm_XmToggleButtonGetState_w gxm_XmToggleButtonGetState
  #define gxm_XmToggleButtonSetState_w gxm_XmToggleButtonSetState
  #define gxm_XmCreateToggleButton_w gxm_XmCreateToggleButton
  #define gxm_XmCreateLabelGadget_w gxm_XmCreateLabelGadget
  #define gxm_XmCreateLabel_w gxm_XmCreateLabel
  #define gxm_XmIsMotifWMRunning_w gxm_XmIsMotifWMRunning
  #define gxm_XmListAddItem_w gxm_XmListAddItem
  #define gxm_XmListAddItems_w gxm_XmListAddItems
  #define gxm_XmListAddItemsUnselected_w gxm_XmListAddItemsUnselected
  #define gxm_XmListAddItemUnselected_w gxm_XmListAddItemUnselected
  #define gxm_XmListDeleteItem_w gxm_XmListDeleteItem
  #define gxm_XmListDeleteItems_w gxm_XmListDeleteItems
  #define gxm_XmListDeletePositions_w gxm_XmListDeletePositions
  #define gxm_XmListDeletePos_w gxm_XmListDeletePos
  #define gxm_XmListDeleteItemsPos_w gxm_XmListDeleteItemsPos
  #define gxm_XmListDeleteAllItems_w gxm_XmListDeleteAllItems
  #define gxm_XmListReplaceItems_w gxm_XmListReplaceItems
  #define gxm_XmListReplaceItemsPos_w gxm_XmListReplaceItemsPos
  #define gxm_XmListReplaceItemsUnselected_w gxm_XmListReplaceItemsUnselected
  #define gxm_XmListReplaceItemsPosUnselected_w gxm_XmListReplaceItemsPosUnselected
  #define gxm_XmListReplacePositions_w gxm_XmListReplacePositions
  #define gxm_XmListSelectItem_w gxm_XmListSelectItem
  #define gxm_XmListSelectPos_w gxm_XmListSelectPos
  #define gxm_XmListDeselectItem_w gxm_XmListDeselectItem
  #define gxm_XmListDeselectPos_w gxm_XmListDeselectPos
  #define gxm_XmListDeselectAllItems_w gxm_XmListDeselectAllItems
  #define gxm_XmListSetPos_w gxm_XmListSetPos
  #define gxm_XmListSetBottomPos_w gxm_XmListSetBottomPos
  #define gxm_XmListSetItem_w gxm_XmListSetItem
  #define gxm_XmListSetBottomItem_w gxm_XmListSetBottomItem
  #define gxm_XmListSetAddMode_w gxm_XmListSetAddMode
  #define gxm_XmListItemExists_w gxm_XmListItemExists
  #define gxm_XmListItemPos_w gxm_XmListItemPos
  #define gxm_XmListGetKbdItemPos_w gxm_XmListGetKbdItemPos
  #define gxm_XmListSetKbdItemPos_w gxm_XmListSetKbdItemPos
  #define gxm_XmListYToPos_w gxm_XmListYToPos
  #define gxm_XmListPosToBounds_w gxm_XmListPosToBounds
  #define gxm_XmListGetMatchPos_w gxm_XmListGetMatchPos
  #define gxm_XmListSetHorizPos_w gxm_XmListSetHorizPos
  #define gxm_XmListUpdateSelectedList_w gxm_XmListUpdateSelectedList
  #define gxm_XmListPosSelected_w gxm_XmListPosSelected
  #define gxm_XmCreateList_w gxm_XmCreateList
  #define gxm_XmCreateScrolledList_w gxm_XmCreateScrolledList
  #define gxm_XmTranslateKey_w gxm_XmTranslateKey
  #define gxm_XmCreateMainWindow_w gxm_XmCreateMainWindow
  #define gxm_XmInstallImage_w gxm_XmInstallImage
  #define gxm_XmUninstallImage_w gxm_XmUninstallImage
  #define gxm_XmGetPixmap_w gxm_XmGetPixmap
  #define gxm_XmGetPixmapByDepth_w gxm_XmGetPixmapByDepth
  #define gxm_XmDestroyPixmap_w gxm_XmDestroyPixmap
  #define gxm_XmUpdateDisplay_w gxm_XmUpdateDisplay
  #define gxm_XmWidgetGetBaselines_w gxm_XmWidgetGetBaselines
  #define gxm_XmRegisterSegmentEncoding_w gxm_XmRegisterSegmentEncoding
  #define gxm_XmMapSegmentEncoding_w gxm_XmMapSegmentEncoding
  #define gxm_XmCvtCTToXmString_w gxm_XmCvtCTToXmString
  #define gxm_XmCvtXmStringToCT_w gxm_XmCvtXmStringToCT
  #define gxm_XmConvertUnits_w gxm_XmConvertUnits
  #define gxm_XmCreateSimpleMenuBar_w gxm_XmCreateSimpleMenuBar
  #define gxm_XmCreateSimplePopupMenu_w gxm_XmCreateSimplePopupMenu
  #define gxm_XmCreateSimplePulldownMenu_w gxm_XmCreateSimplePulldownMenu
  #define gxm_XmCreateSimpleOptionMenu_w gxm_XmCreateSimpleOptionMenu
  #define gxm_XmCreateSimpleRadioBox_w gxm_XmCreateSimpleRadioBox
  #define gxm_XmCreateSimpleCheckBox_w gxm_XmCreateSimpleCheckBox
  #define gxm_XmVaCreateSimpleMenuBar_w gxm_XmVaCreateSimpleMenuBar
  #define gxm_XmVaCreateSimplePopupMenu_w gxm_XmVaCreateSimplePopupMenu
  #define gxm_XmVaCreateSimplePulldownMenu_w gxm_XmVaCreateSimplePulldownMenu
  #define gxm_XmVaCreateSimpleOptionMenu_w gxm_XmVaCreateSimpleOptionMenu
  #define gxm_XmVaCreateSimpleRadioBox_w gxm_XmVaCreateSimpleRadioBox
  #define gxm_XmVaCreateSimpleCheckBox_w gxm_XmVaCreateSimpleCheckBox
  #define gxm_XmTrackingEvent_w gxm_XmTrackingEvent
  #define gxm_XmSetColorCalculation_w gxm_XmSetColorCalculation
  #define gxm_XmGetColorCalculation_w gxm_XmGetColorCalculation
  #define gxm_XmGetColors_w gxm_XmGetColors
  #define gxm_XmChangeColor_w gxm_XmChangeColor
  #define gxm_XmStringCreate_w gxm_XmStringCreate
  #define gxm_XmStringCreateLocalized_w gxm_XmStringCreateLocalized
  #define gxm_XmStringDirectionCreate_w gxm_XmStringDirectionCreate
  #define gxm_XmStringSeparatorCreate_w gxm_XmStringSeparatorCreate
  #define gxm_XmStringInitContext_w gxm_XmStringInitContext
  #define gxm_XmStringFreeContext_w gxm_XmStringFreeContext
  #define gxm_XmStringConcatAndFree_w gxm_XmStringConcatAndFree
  #define gxm_XmStringIsVoid_w gxm_XmStringIsVoid
  #define gxm_XmStringPeekNextTriple_w gxm_XmStringPeekNextTriple
  #define gxm_XmStringGetNextTriple_w gxm_XmStringGetNextTriple
  #define gxm_XmStringComponentCreate_w gxm_XmStringComponentCreate
  #define gxm_XmStringUnparse_w gxm_XmStringUnparse
  #define gxm_XmStringParseText_w gxm_XmStringParseText
  #define gxm_XmStringToXmStringTable_w gxm_XmStringToXmStringTable
  #define gxm_XmStringTableToXmString_w gxm_XmStringTableToXmString
  #define gxm_XmStringTableUnparse_w gxm_XmStringTableUnparse
  #define gxm_XmStringTableParseStringArray_w gxm_XmStringTableParseStringArray
  #define gxm_XmDirectionToStringDirection_w gxm_XmDirectionToStringDirection
  #define gxm_XmStringDirectionToDirection_w gxm_XmStringDirectionToDirection
  #define gxm_XmStringGenerate_w gxm_XmStringGenerate
  #define gxm_XmStringPutRendition_w gxm_XmStringPutRendition
  #define gxm_XmParseMappingCreate_w gxm_XmParseMappingCreate
  #define gxm_XmParseMappingSetValues_w gxm_XmParseMappingSetValues
  #define gxm_XmParseMappingGetValues_w gxm_XmParseMappingGetValues
  #define gxm_XmParseMappingFree_w gxm_XmParseMappingFree
  #define gxm_XmParseTableFree_w gxm_XmParseTableFree
  #define gxm_XmStringTableProposeTablist_w gxm_XmStringTableProposeTablist
  #define gxm_XmTabSetValue_w gxm_XmTabSetValue
  #define gxm_XmTabGetValues_w gxm_XmTabGetValues
  #define gxm_XmTabFree_w gxm_XmTabFree
  #define gxm_XmTabListFree_w gxm_XmTabListFree
  #define gxm_XmTabCreate_w gxm_XmTabCreate
  #define gxm_XmTabListTabCount_w gxm_XmTabListTabCount
  #define gxm_XmTabListRemoveTabs_w gxm_XmTabListRemoveTabs
  #define gxm_XmTabListReplacePositions_w gxm_XmTabListReplacePositions
  #define gxm_XmTabListGetTab_w gxm_XmTabListGetTab
  #define gxm_XmTabListCopy_w gxm_XmTabListCopy
  #define gxm_XmTabListInsertTabs_w gxm_XmTabListInsertTabs
  #define gxm_XmRenderTableCvtFromProp_w gxm_XmRenderTableCvtFromProp
  #define gxm_XmRenderTableCvtToProp_w gxm_XmRenderTableCvtToProp
  #define gxm_XmRenditionUpdate_w gxm_XmRenditionUpdate
  #define gxm_XmRenditionRetrieve_w gxm_XmRenditionRetrieve
  #define gxm_XmRenditionFree_w gxm_XmRenditionFree
  #define gxm_XmRenditionCreate_w gxm_XmRenditionCreate
  #define gxm_XmRenderTableGetRenditions_w gxm_XmRenderTableGetRenditions
  #define gxm_XmRenderTableGetRendition_w gxm_XmRenderTableGetRendition
  #define gxm_XmRenderTableGetTags_w gxm_XmRenderTableGetTags
  #define gxm_XmRenderTableFree_w gxm_XmRenderTableFree
  #define gxm_XmRenderTableCopy_w gxm_XmRenderTableCopy
  #define gxm_XmRenderTableRemoveRenditions_w gxm_XmRenderTableRemoveRenditions
  #define gxm_XmRenderTableAddRenditions_w gxm_XmRenderTableAddRenditions
  #define gxm_XmStringConcat_w gxm_XmStringConcat
  #define gxm_XmStringCopy_w gxm_XmStringCopy
  #define gxm_XmStringCompare_w gxm_XmStringCompare
  #define gxm_XmStringEmpty_w gxm_XmStringEmpty
  #define gxm_XmStringHasSubstring_w gxm_XmStringHasSubstring
  #define gxm_XmStringFree_w gxm_XmStringFree
  #define gxm_XmStringBaseline_w gxm_XmStringBaseline
  #define gxm_XmStringWidth_w gxm_XmStringWidth
  #define gxm_XmStringHeight_w gxm_XmStringHeight
  #define gxm_XmStringExtent_w gxm_XmStringExtent
  #define gxm_XmStringLineCount_w gxm_XmStringLineCount
  #define gxm_XmStringDraw_w gxm_XmStringDraw
  #define gxm_XmStringDrawImage_w gxm_XmStringDrawImage
  #define gxm_XmStringDrawUnderline_w gxm_XmStringDrawUnderline

  #define gxm_XmGetDestination_w gxm_XmGetDestination
  #define gxm_XmIsTraversable_w gxm_XmIsTraversable
  #define gxm_XmGetVisibility_w gxm_XmGetVisibility
  #define gxm_XmGetTabGroup_w gxm_XmGetTabGroup
  #define gxm_XmGetFocusWidget_w gxm_XmGetFocusWidget
  #define gxm_XmProcessTraversal_w gxm_XmProcessTraversal
  #define gxm_XmCreateMenuShell_w gxm_XmCreateMenuShell

  #define gxm_XmIsMessageBox_w gxm_XmIsMessageBox
  #define gxm_XmIsArrowButtonGadget_w gxm_XmIsArrowButtonGadget
  #define gxm_XmIsArrowButton_w gxm_XmIsArrowButton
  #define gxm_XmCvtXmStringToByteStream_w gxm_XmCvtXmStringToByteStream
  #define gxm_XmCvtByteStreamToXmString_w gxm_XmCvtByteStreamToXmString
  #define gxm_XmStringByteStreamLength_w gxm_XmStringByteStreamLength
  #define gxm_XmIsNotebook_w gxm_XmIsNotebook
#if HAVE_XM_XP
  #define gxm_XmIsPrintShell_w gxm_XmIsPrintShell
#endif
  #define gxm_XmIsComboBox_w gxm_XmIsComboBox
  #define gxm_XmIsContainer_w gxm_XmIsContainer
  #define gxm_XmIsGrabShell_w gxm_XmIsGrabShell
  #define gxm_XmIsIconGadget_w gxm_XmIsIconGadget
  #define gxm_XmIsIconHeader_w gxm_XmIsIconHeader
  #define gxm_XmIsPanedWindow_w gxm_XmIsPanedWindow
  #define gxm_XmIsBulletinBoard_w gxm_XmIsBulletinBoard
  #define gxm_XmIsPrimitive_w gxm_XmIsPrimitive
  #define gxm_XmIsCascadeButtonGadget_w gxm_XmIsCascadeButtonGadget
  #define gxm_XmIsCascadeButton_w gxm_XmIsCascadeButton
  #define gxm_XmIsPushButtonGadget_w gxm_XmIsPushButtonGadget
  #define gxm_XmIsPushButton_w gxm_XmIsPushButton
  #define gxm_XmIsCommand_w gxm_XmIsCommand
  #define gxm_XmIsRowColumn_w gxm_XmIsRowColumn
  #define gxm_XmIsScale_w gxm_XmIsScale
  #define gxm_XmIsScreen_w gxm_XmIsScreen
  #define gxm_XmIsScrollBar_w gxm_XmIsScrollBar
  #define gxm_XmIsDialogShell_w gxm_XmIsDialogShell
  #define gxm_XmIsScrolledWindow_w gxm_XmIsScrolledWindow
  #define gxm_XmIsDisplay_w gxm_XmIsDisplay
  #define gxm_XmIsSelectionBox_w gxm_XmIsSelectionBox
  #define gxm_XmIsDragContext_w gxm_XmIsDragContext
  #define gxm_XmIsSeparatorGadget_w gxm_XmIsSeparatorGadget
  #define gxm_XmIsDragIconObjectClass_w gxm_XmIsDragIconObjectClass
  #define gxm_XmIsSeparator_w gxm_XmIsSeparator
  #define gxm_XmIsDrawingArea_w gxm_XmIsDrawingArea
  #define gxm_XmIsDrawnButton_w gxm_XmIsDrawnButton
  #define gxm_XmIsDropSiteManager_w gxm_XmIsDropSiteManager
  #define gxm_XmIsDropTransfer_w gxm_XmIsDropTransfer
  #define gxm_XmIsTextField_w gxm_XmIsTextField
  #define gxm_XmIsFileSelectionBox_w gxm_XmIsFileSelectionBox
  #define gxm_XmIsText_w gxm_XmIsText
  #define gxm_XmIsForm_w gxm_XmIsForm
  #define gxm_XmIsFrame_w gxm_XmIsFrame
  #define gxm_XmIsGadget_w gxm_XmIsGadget
  #define gxm_XmIsToggleButtonGadget_w gxm_XmIsToggleButtonGadget
  #define gxm_XmIsToggleButton_w gxm_XmIsToggleButton
  #define gxm_XmIsLabelGadget_w gxm_XmIsLabelGadget
  #define gxm_XmIsLabel_w gxm_XmIsLabel
  #define gxm_XmIsVendorShell_w gxm_XmIsVendorShell
  #define gxm_XmIsList_w gxm_XmIsList
  #define gxm_XmIsMainWindow_w gxm_XmIsMainWindow
  #define gxm_XmIsManager_w gxm_XmIsManager
  #define gxm_XmIsMenuShell_w gxm_XmIsMenuShell
  #define gxm_XmListGetSelectedPos_w gxm_XmListGetSelectedPos
  #define gxm_XmWidgetGetDisplayRect_w gxm_XmWidgetGetDisplayRect

#if HAVE_XmCreateButtonBox
  #define gxm_XmIsButtonBox_w gxm_XmIsButtonBox
  #define gxm_XmCreateButtonBox_w gxm_XmCreateButtonBox
#endif
#if HAVE_XmCreateTabStack
  #define gxm_XmCreateTabStack_w gxm_XmCreateTabStack
  #define gxm_XmIsTabStack_w gxm_XmIsTabStack
  #define gxm_XmTabStackGetSelectedTab_w gxm_XmTabStackGetSelectedTab
  #define gxm_XmTabStackSelectTab_w gxm_XmTabStackSelectTab
#if HAVE_XmTabStackXYToWidget
  #define gxm_XmTabStackIndexToWidget_w gxm_XmTabStackIndexToWidget
  #define gxm_XmTabStackXYToWidget_w gxm_XmTabStackXYToWidget
#endif
#endif
#if HAVE_XmCreateDataField
  #define gxm_XmIsDataField_w gxm_XmIsDataField
  #define gxm_XmCreateDataField_w gxm_XmCreateDataField
  #define gxm_XmDataFieldSetString_w gxm_XmDataFieldSetString
  #define gxm_XmDataFieldGetString_w gxm_XmDataFieldGetString
  #define gxm_XmDataFieldSetHighlight_w gxm_XmDataFieldSetHighlight
  #define gxm_XmDataFieldSetAddMode_w gxm_XmDataFieldSetAddMode
  #define gxm_XmDataFieldGetSelection_w gxm_XmDataFieldGetSelection
  #define gxm_XmDataFieldSetSelection_w gxm_XmDataFieldSetSelection
  #define gxm_XmDataFieldGetSelectionPosition_w gxm_XmDataFieldGetSelectionPosition
  #define gxm_XmDataFieldXYToPos_w gxm_XmDataFieldXYToPos
  #define gxm_XmDataFieldShowPosition_w gxm_XmDataFieldShowPosition
  #define gxm_XmDataFieldCut_w gxm_XmDataFieldCut
  #define gxm_XmDataFieldCopy_w gxm_XmDataFieldCopy
  #define gxm_XmDataFieldPaste_w gxm_XmDataFieldPaste
  #define gxm_XmDataFieldSetEditable_w gxm_XmDataFieldSetEditable
  #define gxm_XmDataFieldSetInsertionPosition_w gxm_XmDataFieldSetInsertionPosition
#endif
#if HAVE_XmCreateColumn
  #define gxm_XmCreateColumn_w gxm_XmCreateColumn
  #define gxm_XmIsColumn_w gxm_XmIsColumn
#if HAVE_XmColumnGetChildLabel
  #define gxm_XmColumnGetChildLabel_w gxm_XmColumnGetChildLabel
#endif
#endif
#if HAVE_XmCreateDropDown
  #define gxm_XmIsDropDown_w gxm_XmIsDropDown
  #define gxm_XmDropDownGetValue_w gxm_XmDropDownGetValue
  #define gxm_XmDropDownGetList_w gxm_XmDropDownGetList
  #define gxm_XmDropDownGetText_w gxm_XmDropDownGetText
  #define gxm_XmDropDownGetArrow_w gxm_XmDropDownGetArrow
  #define gxm_XmDropDownGetLabel_w gxm_XmDropDownGetLabel
  #define gxm_XmCreateDropDown_w gxm_XmCreateDropDown
#endif

#if (!XM_DISABLE_DEPRECATED)
  #define gxm_XmStringLength_w gxm_XmStringLength
  #define gxm_XmStringByteCompare_w gxm_XmStringByteCompare
  #define gxm_XmScrolledWindowSetAreas_w gxm_XmScrolledWindowSetAreas
  #define gxm_XmFontListEntryFree_w gxm_XmFontListEntryFree
  #define gxm_XmFontListEntryGetFont_w gxm_XmFontListEntryGetFont
  #define gxm_XmFontListEntryGetTag_w gxm_XmFontListEntryGetTag
  #define gxm_XmFontListAppendEntry_w gxm_XmFontListAppendEntry
  #define gxm_XmFontListNextEntry_w gxm_XmFontListNextEntry
  #define gxm_XmFontListRemoveEntry_w gxm_XmFontListRemoveEntry
  #define gxm_XmFontListEntryLoad_w gxm_XmFontListEntryLoad
  #define gxm_XmFontListCreate_w gxm_XmFontListCreate
  #define gxm_XmFontListFree_w gxm_XmFontListFree
  #define gxm_XmFontListAdd_w gxm_XmFontListAdd
  #define gxm_XmFontListCopy_w gxm_XmFontListCopy
  #define gxm_XmFontListInitFontContext_w gxm_XmFontListInitFontContext
  #define gxm_XmFontListGetNextFont_w gxm_XmFontListGetNextFont
  #define gxm_XmFontListFreeFontContext_w gxm_XmFontListFreeFontContext
  #define gxm_XmStringGetNextComponent_w gxm_XmStringGetNextComponent
  #define gxm_XmStringPeekNextComponent_w gxm_XmStringPeekNextComponent
  #define gxm_XmStringGetNextSegment_w gxm_XmStringGetNextSegment
  #define gxm_XmStringGetLtoR_w gxm_XmStringGetLtoR
  #define gxm_XmFontListEntryCreate_w gxm_XmFontListEntryCreate
  #define gxm_XmStringCreateSimple_w gxm_XmStringCreateSimple
  #define gxm_XmStringSegmentCreate_w gxm_XmStringSegmentCreate
  #define gxm_XmStringCreateLtoR_w gxm_XmStringCreateLtoR
  #define gxm_XmStringNCopy_w gxm_XmStringNCopy
  #define gxm_XmStringNConcat_w gxm_XmStringNConcat
  #define gxm_XmMainWindowSetAreas_w gxm_XmMainWindowSetAreas
  #define gxm_XmMainWindowSep1_w gxm_XmMainWindowSep1
  #define gxm_XmMainWindowSep2_w gxm_XmMainWindowSep2
  #define gxm_XmMainWindowSep3_w gxm_XmMainWindowSep3
  #define gxm_XmSetFontUnits_w gxm_XmSetFontUnits
  #define gxm_XmSetFontUnit_w gxm_XmSetFontUnit
  #define gxm_XmSetMenuCursor_w gxm_XmSetMenuCursor
  #define gxm_XmGetMenuCursor_w gxm_XmGetMenuCursor
  #define gxm_XmTrackingLocate_w gxm_XmTrackingLocate

  #define XEN_XmFontList_p_w XEN_XmFontList_p
  #define XEN_XmFontContext_p_w XEN_XmFontContext_p
  #define XEN_XmFontListEntry_p_w XEN_XmFontListEntry_p
#endif

#endif

#if HAVE_XPM
  #define gxm_XpmCreatePixmapFromData_w gxm_XpmCreatePixmapFromData
  #define gxm_XpmCreateDataFromPixmap_w gxm_XpmCreateDataFromPixmap
  #define gxm_XpmReadFileToPixmap_w gxm_XpmReadFileToPixmap
  #define gxm_XpmReadFileToXpmImage_w gxm_XpmReadFileToXpmImage
  #define gxm_XpmWriteFileFromPixmap_w gxm_XpmWriteFileFromPixmap
  #define gxm_XpmCreatePixmapFromXpmImage_w gxm_XpmCreatePixmapFromXpmImage
  #define gxm_XpmCreateXpmImageFromPixmap_w gxm_XpmCreateXpmImageFromPixmap
#if HAVE_XPM_GET_ERROR_STRING
  #define gxm_XpmGetErrorString_w gxm_XpmGetErrorString
#endif
#endif
  #define gxm_XGetPixel_w gxm_XGetPixel
  #define gxm_XDestroyImage_w gxm_XDestroyImage
  #define gxm_XPutPixel_w gxm_XPutPixel
  #define gxm_XSubImage_w gxm_XSubImage
  #define gxm_XAddPixel_w gxm_XAddPixel

#if HAVE_MOTIF
  #define XEN_XtAppContext_p_w XEN_XtAppContext_p
  #define XEN_XtRequestId_p_w XEN_XtRequestId_p
  #define XEN_XtWorkProcId_p_w XEN_XtWorkProcId_p
  #define XEN_XtInputId_p_w XEN_XtInputId_p
  #define XEN_XtIntervalId_p_w XEN_XtIntervalId_p
#endif
  #define XEN_Screen_p_w XEN_Screen_p
  #define XEN_XEvent_p_w XEN_XEvent_p
  #define XEN_XRectangle_p_w XEN_XRectangle_p
  #define XEN_XArc_p_w XEN_XArc_p
  #define XEN_XPoint_p_w XEN_XPoint_p
  #define XEN_XSegment_p_w XEN_XSegment_p
  #define XEN_XColor_p_w XEN_XColor_p
  #define XEN_Atom_p_w XEN_Atom_p
  #define XEN_Colormap_p_w XEN_Colormap_p
  #define XEN_XModifierKeymap_p_w XEN_XModifierKeymap_p
  #define XEN_Depth_p_w XEN_Depth_p
  #define XEN_Display_p_w XEN_Display_p
  #define XEN_Font_p_w XEN_Font_p
  #define XEN_GC_p_w XEN_GC_p
  #define XEN_KeySym_p_w XEN_KeySym_p
  #define XEN_Pixel_p_w XEN_Pixel_p
  #define XEN_Pixmap_p_w XEN_Pixmap_p
  #define XEN_Region_p_w XEN_Region_p
  #define XEN_Time_p_w XEN_Time_p
  #define XEN_Visual_p_w XEN_Visual_p
  #define XEN_Window_p_w XEN_Window_p
#if HAVE_MOTIF
  #define XEN_Widget_p_w XEN_Widget_p
  #define XEN_XmStringContext_p_w XEN_XmStringContext_p
#endif
  #define XEN_XFontProp_p_w XEN_XFontProp_p
  #define XEN_XFontSet_p_w XEN_XFontSet_p
  #define XEN_XFontStruct_p_w XEN_XFontStruct_p
  #define XEN_XGCValues_p_w XEN_XGCValues_p
  #define XEN_XImage_p_w XEN_XImage_p
  #define XEN_XVisualInfo_p_w XEN_XVisualInfo_p
  #define XEN_XWMHints_p_w XEN_XWMHints_p
  #define XEN_XWindowAttributes_p_w XEN_XWindowAttributes_p
  #define XEN_XWindowChanges_p_w XEN_XWindowChanges_p
  #define XEN_KeyCode_p_w XEN_KeyCode_p
  #define XEN_XContext_p_w XEN_XContext_p
  #define XEN_XCharStruct_p_w XEN_XCharStruct_p
  #define XEN_XTextItem_p_w XEN_XTextItem_p
  #define XEN_XStandardColormap_p_w XEN_XStandardColormap_p
  #define XEN_Cursor_p_w XEN_Cursor_p
#if HAVE_XM_XP
  #define XEN_XPContext_p_w XEN_XPContext_p
#endif
#if HAVE_MOTIF
  #define XEN_WidgetClass_p_w XEN_WidgetClass_p
  #define XEN_XmString_p_w XEN_XmString_p
  #define XEN_XmTab_p_w XEN_XmTab_p
  #define XEN_XmRendition_p_w XEN_XmRendition_p
  #define XEN_XmRenderTable_p_w XEN_XmRenderTable_p
  #define XEN_XmTabList_p_w XEN_XmTabList_p
  #define XEN_XmParseMapping_p_w XEN_XmParseMapping_p
  #define XEN_XmTextSource_p_w XEN_XmTextSource_p
#endif
#if HAVE_XPM
  #define XEN_XpmAttributes_p_w XEN_XpmAttributes_p
  #define XEN_XpmImage_p_w XEN_XpmImage_p
  #define XEN_XpmColorSymbol_p_w XEN_XpmColorSymbol_p
#endif
#if MUS_WITH_EDITRES
  #define gxm_XEditResCheckMessages_w gxm_XEditResCheckMessages
#endif

#if HAVE_XSHAPEQUERYEXTENSION
  #define gxm_XShapeQueryExtension_w gxm_XShapeQueryExtension
  #define gxm_XShapeQueryVersion_w gxm_XShapeQueryVersion
  #define gxm_XShapeQueryExtents_w gxm_XShapeQueryExtents
  #define gxm_XShapeGetRectangles_w gxm_XShapeGetRectangles
  #define gxm_XShapeOffsetShape_w gxm_XShapeOffsetShape
  #define gxm_XShapeCombineRegion_w gxm_XShapeCombineRegion
  #define gxm_XShapeCombineMask_w gxm_XShapeCombineMask
  #define gxm_XShapeCombineShape_w gxm_XShapeCombineShape
  #define gxm_XShapeCombineRectangles_w gxm_XShapeCombineRectangles
#endif

  #define gxm_XSegment_w gxm_XSegment
  #define gxm_XRectangle_w gxm_XRectangle
  #define gxm_XColor_w gxm_XColor
  #define gxm_XArc_w gxm_XArc
  #define gxm_XWindowChanges_w gxm_XWindowChanges
  #define gxm_XSetWindowAttributes_w gxm_XSetWindowAttributes
  #define gxm_XPoint_w gxm_XPoint
  #define gxm_XTextItem_w gxm_XTextItem
  #define gxm_pixel_w gxm_pixel
  #define gxm_set_pixel_w gxm_set_pixel
  #define gxm_red_w gxm_red
  #define gxm_set_red_w gxm_set_red
  #define gxm_green_w gxm_green
  #define gxm_set_green_w gxm_set_green
  #define gxm_blue_w gxm_blue
  #define gxm_set_blue_w gxm_set_blue
  #define gxm_flags_w gxm_flags
  #define gxm_set_flags_w gxm_set_flags
  #define gxm_pad_w gxm_pad
  #define gxm_set_pad_w gxm_set_pad
  #define gxm_x_w gxm_x
  #define gxm_set_x_w gxm_set_x
  #define gxm_y_w gxm_y
  #define gxm_set_y_w gxm_set_y
  #define gxm_width_w gxm_width
  #define gxm_set_width_w gxm_set_width
  #define gxm_height_w gxm_height
  #define gxm_set_height_w gxm_set_height
  #define gxm_angle1_w gxm_angle1
  #define gxm_set_angle1_w gxm_set_angle1
  #define gxm_angle2_w gxm_angle2
  #define gxm_set_angle2_w gxm_set_angle2
  #define gxm_x1_w gxm_x1
  #define gxm_set_x1_w gxm_set_x1
  #define gxm_y1_w gxm_y1
  #define gxm_set_y1_w gxm_set_y1
  #define gxm_x2_w gxm_x2
  #define gxm_set_x2_w gxm_set_x2
  #define gxm_y2_w gxm_y2
  #define gxm_set_y2_w gxm_set_y2
  #define gxm_dashes_w gxm_dashes
  #define gxm_set_dashes_w gxm_set_dashes
  #define gxm_dash_offset_w gxm_dash_offset
  #define gxm_set_dash_offset_w gxm_set_dash_offset
  #define gxm_clip_mask_w gxm_clip_mask
  #define gxm_set_clip_mask_w gxm_set_clip_mask
  #define gxm_clip_y_origin_w gxm_clip_y_origin
  #define gxm_set_clip_y_origin_w gxm_set_clip_y_origin
  #define gxm_clip_x_origin_w gxm_clip_x_origin
  #define gxm_set_clip_x_origin_w gxm_set_clip_x_origin
  #define gxm_graphics_exposures_w gxm_graphics_exposures
  #define gxm_set_graphics_exposures_w gxm_set_graphics_exposures
  #define gxm_subwindow_mode_w gxm_subwindow_mode
  #define gxm_set_subwindow_mode_w gxm_set_subwindow_mode
  #define gxm_font_w gxm_font
  #define gxm_set_font_w gxm_set_font
  #define gxm_ts_y_origin_w gxm_ts_y_origin
  #define gxm_set_ts_y_origin_w gxm_set_ts_y_origin
  #define gxm_ts_x_origin_w gxm_ts_x_origin
  #define gxm_set_ts_x_origin_w gxm_set_ts_x_origin
  #define gxm_stipple_w gxm_stipple
  #define gxm_set_stipple_w gxm_set_stipple
  #define gxm_tile_w gxm_tile
  #define gxm_set_tile_w gxm_set_tile
  #define gxm_arc_mode_w gxm_arc_mode
  #define gxm_set_arc_mode_w gxm_set_arc_mode
  #define gxm_fill_rule_w gxm_fill_rule
  #define gxm_set_fill_rule_w gxm_set_fill_rule
  #define gxm_fill_style_w gxm_fill_style
  #define gxm_set_fill_style_w gxm_set_fill_style
  #define gxm_join_style_w gxm_join_style
  #define gxm_set_join_style_w gxm_set_join_style
  #define gxm_cap_style_w gxm_cap_style
  #define gxm_set_cap_style_w gxm_set_cap_style
  #define gxm_line_style_w gxm_line_style
  #define gxm_set_line_style_w gxm_set_line_style
  #define gxm_line_width_w gxm_line_width
  #define gxm_set_line_width_w gxm_set_line_width
  #define gxm_background_w gxm_background
  #define gxm_set_background_w gxm_set_background
  #define gxm_foreground_w gxm_foreground
  #define gxm_set_foreground_w gxm_set_foreground
  #define gxm_plane_mask_w gxm_plane_mask
  #define gxm_set_plane_mask_w gxm_set_plane_mask
  #define gxm_function_w gxm_function
  #define gxm_set_function_w gxm_set_function
  #define gxm_delta_w gxm_delta
  #define gxm_set_delta_w gxm_set_delta
  #define gxm_nchars_w gxm_nchars
  #define gxm_set_nchars_w gxm_set_nchars
  #define gxm_chars_w gxm_chars
  #define gxm_set_chars_w gxm_set_chars
  #define gxm_name_w gxm_name
  #define gxm_set_name_w gxm_set_name
  #define gxm_depth_w gxm_depth
  #define gxm_set_depth_w gxm_set_depth
  #define gxm_visual_w gxm_visual
  #define gxm_set_visual_w gxm_set_visual

  #define gxm_display_w gxm_display
  #define gxm_root_w gxm_root
  #define gxm_mwidth_w gxm_mwidth
  #define gxm_mheight_w gxm_mheight
  #define gxm_ndepths_w gxm_ndepths
  #define gxm_depths_w gxm_depths
  #define gxm_root_depth_w gxm_root_depth
  #define gxm_root_visual_w gxm_root_visual
  #define gxm_default_gc_w gxm_default_gc
  #define gxm_cmap_w gxm_cmap
  #define gxm_white_pixel_w gxm_white_pixel
  #define gxm_black_pixel_w gxm_black_pixel
  #define gxm_max_maps_w gxm_max_maps
  #define gxm_min_maps_w gxm_min_maps
  #define gxm_backing_store_w gxm_backing_store
  #define gxm_save_unders_w gxm_save_unders
  #define gxm_root_input_mask_w gxm_root_input_mask
  #define gxm_type_w gxm_type
  #define gxm_serial_w gxm_serial
  #define gxm_send_event_w gxm_send_event
  #define gxm_window_w gxm_window
  #define gxm_subwindow_w gxm_subwindow
  #define gxm_time_w gxm_time
  #define gxm_x_root_w gxm_x_root
  #define gxm_y_root_w gxm_y_root
  #define gxm_state_w gxm_state
  #define gxm_keycode_w gxm_keycode
  #define gxm_same_screen_w gxm_same_screen
  #define gxm_button_w gxm_button
  #define gxm_is_hint_w gxm_is_hint
  #define gxm_mode_w gxm_mode
  #define gxm_detail_w gxm_detail
  #define gxm_focus_w gxm_focus
  #define gxm_key_vector_w gxm_key_vector
  #define gxm_count_w gxm_count
  #define gxm_drawable_w gxm_drawable
  #define gxm_major_code_w gxm_major_code
  #define gxm_minor_code_w gxm_minor_code
  #define gxm_parent_w gxm_parent
  #define gxm_border_width_w gxm_border_width
  #define gxm_override_redirect_w gxm_override_redirect
  #define gxm_event_w gxm_event
  #define gxm_from_configure_w gxm_from_configure
  #define gxm_above_w gxm_above
  #define gxm_value_mask_w gxm_value_mask
  #define gxm_place_w gxm_place
  #define gxm_atom_w gxm_atom
  #define gxm_selection_w gxm_selection
  #define gxm_owner_w gxm_owner
  #define gxm_requestor_w gxm_requestor
  #define gxm_target_w gxm_target
  #define gxm_property_w gxm_property
  #define gxm_new_w gxm_new
  #define gxm_message_type_w gxm_message_type
  #define gxm_format_w gxm_format
  #define gxm_request_w gxm_request
  #define gxm_first_keycode_w gxm_first_keycode
  #define gxm_resourceid_w gxm_resourceid
  #define gxm_error_code_w gxm_error_code
  #define gxm_request_code_w gxm_request_code
  #define gxm_lbearing_w gxm_lbearing
  #define gxm_rbearing_w gxm_rbearing
  #define gxm_ascent_w gxm_ascent
  #define gxm_descent_w gxm_descent
  #define gxm_attributes_w gxm_attributes
  #define gxm_card32_w gxm_card32
  #define gxm_fid_w gxm_fid
  #define gxm_properties_w gxm_properties
  #define gxm_min_bounds_w gxm_min_bounds
  #define gxm_max_bounds_w gxm_max_bounds
  #define gxm_per_char_w gxm_per_char
  #define gxm_input_w gxm_input
  #define gxm_initial_state_w gxm_initial_state
  #define gxm_icon_pixmap_w gxm_icon_pixmap
  #define gxm_icon_window_w gxm_icon_window
  #define gxm_icon_x_w gxm_icon_x
  #define gxm_icon_y_w gxm_icon_y
  #define gxm_icon_mask_w gxm_icon_mask
  #define gxm_window_group_w gxm_window_group
  #define gxm_visualid_w gxm_visualid
  #define gxm_class_w gxm_class
  #define gxm_red_mask_w gxm_red_mask
  #define gxm_green_mask_w gxm_green_mask
  #define gxm_blue_mask_w gxm_blue_mask
  #define gxm_bits_per_rgb_w gxm_bits_per_rgb
  #define gxm_map_entries_w gxm_map_entries
  #define gxm_colormap_size_w gxm_colormap_size
  #define gxm_nvisuals_w gxm_nvisuals
  #define gxm_visuals_w gxm_visuals
  #define gxm_bits_per_pixel_w gxm_bits_per_pixel
  #define gxm_background_pixmap_w gxm_background_pixmap
  #define gxm_background_pixel_w gxm_background_pixel
  #define gxm_border_pixmap_w gxm_border_pixmap
  #define gxm_border_pixel_w gxm_border_pixel
  #define gxm_bit_gravity_w gxm_bit_gravity
  #define gxm_win_gravity_w gxm_win_gravity
  #define gxm_backing_planes_w gxm_backing_planes
  #define gxm_backing_pixel_w gxm_backing_pixel
  #define gxm_save_under_w gxm_save_under
  #define gxm_event_mask_w gxm_event_mask
  #define gxm_do_not_propagate_mask_w gxm_do_not_propagate_mask
  #define gxm_cursor_w gxm_cursor
  #define gxm_map_installed_w gxm_map_installed
  #define gxm_map_state_w gxm_map_state
  #define gxm_all_event_masks_w gxm_all_event_masks
  #define gxm_your_event_mask_w gxm_your_event_mask
  #define gxm_screen_w gxm_screen
  #define gxm_xoffset_w gxm_xoffset
  #define gxm_byte_order_w gxm_byte_order
  #define gxm_bitmap_unit_w gxm_bitmap_unit
  #define gxm_bitmap_bit_order_w gxm_bitmap_bit_order
  #define gxm_bitmap_pad_w gxm_bitmap_pad
  #define gxm_bytes_per_line_w gxm_bytes_per_line
  #define gxm_obdata_w gxm_obdata
  #define gxm_sibling_w gxm_sibling
  #define gxm_stack_mode_w gxm_stack_mode
 
  #define gxm_red_max_w gxm_red_max
  #define gxm_red_mult_w gxm_red_mult
  #define gxm_green_max_w gxm_green_max
  #define gxm_green_mult_w gxm_green_mult
  #define gxm_blue_max_w gxm_blue_max
  #define gxm_blue_mult_w gxm_blue_mult
  #define gxm_base_pixel_w gxm_base_pixel
  #define gxm_killid_w gxm_killid
  #define gxm_data_w gxm_data

  #define gxm_set_request_code_w gxm_set_request_code
  #define gxm_set_error_code_w gxm_set_error_code
  #define gxm_set_first_keycode_w gxm_set_first_keycode
  #define gxm_set_request_w gxm_set_request
  #define gxm_set_resourceid_w gxm_set_resourceid
  #define gxm_set_format_w gxm_set_format
  #define gxm_set_message_type_w gxm_set_message_type
  #define gxm_set_new_w gxm_set_new
  #define gxm_set_property_w gxm_set_property
  #define gxm_set_display_w gxm_set_display
  #define gxm_set_target_w gxm_set_target
  #define gxm_set_requestor_w gxm_set_requestor
  #define gxm_set_owner_w gxm_set_owner
  #define gxm_set_selection_w gxm_set_selection
  #define gxm_set_atom_w gxm_set_atom
  #define gxm_set_place_w gxm_set_place
  #define gxm_set_value_mask_w gxm_set_value_mask
  #define gxm_set_above_w gxm_set_above
  #define gxm_set_from_configure_w gxm_set_from_configure
  #define gxm_set_event_w gxm_set_event
  #define gxm_set_override_redirect_w gxm_set_override_redirect
  #define gxm_set_border_width_w gxm_set_border_width
  #define gxm_set_parent_w gxm_set_parent
  #define gxm_set_minor_code_w gxm_set_minor_code
  #define gxm_set_major_code_w gxm_set_major_code
  #define gxm_set_drawable_w gxm_set_drawable
  #define gxm_set_count_w gxm_set_count
  #define gxm_set_key_vector_w gxm_set_key_vector
  #define gxm_set_focus_w gxm_set_focus
  #define gxm_set_detail_w gxm_set_detail
  #define gxm_set_mode_w gxm_set_mode
  #define gxm_set_is_hint_w gxm_set_is_hint
  #define gxm_set_button_w gxm_set_button
  #define gxm_set_same_screen_w gxm_set_same_screen
  #define gxm_set_keycode_w gxm_set_keycode
  #define gxm_set_state_w gxm_set_state
  #define gxm_set_y_root_w gxm_set_y_root
  #define gxm_set_x_root_w gxm_set_x_root
  #define gxm_set_root_w gxm_set_root
  #define gxm_set_time_w gxm_set_time
  #define gxm_set_subwindow_w gxm_set_subwindow
  #define gxm_set_window_w gxm_set_window
  #define gxm_set_send_event_w gxm_set_send_event
  #define gxm_set_serial_w gxm_set_serial
  #define gxm_set_type_w gxm_set_type
  #define gxm_colormap_w gxm_colormap
  #define gxm_set_colormap_w gxm_set_colormap

  #define gxm_set_input_w gxm_set_input
  #define gxm_set_initial_state_w gxm_set_initial_state

  #define gxm_min_height_w gxm_min_height
  #define gxm_max_height_w gxm_max_height
  #define gxm_min_width_w gxm_min_width
  #define gxm_max_width_w gxm_max_width
  #define gxm_height_inc_w gxm_height_inc
  #define gxm_width_inc_w gxm_width_inc

  #define gxm_set_data_w gxm_set_data
  #define gxm_set_backing_store_w gxm_set_backing_store
  #define gxm_set_background_pixel_w gxm_set_background_pixel
  #define gxm_set_border_pixel_w gxm_set_border_pixel
  #define gxm_set_bit_gravity_w gxm_set_bit_gravity
  #define gxm_set_save_under_w gxm_set_save_under
  #define gxm_set_event_mask_w gxm_set_event_mask
  #define gxm_set_cursor_w gxm_set_cursor

#if HAVE_MOTIF
  #define gxm_set_set_w gxm_set_set
  #define gxm_set_click_count_w gxm_set_click_count
  #define gxm_set_length_w gxm_set_length
  #define gxm_ptr_w gxm_ptr
  #define gxm_set_ptr_w gxm_set_ptr
  #define gxm_set_reason_w gxm_set_reason
  #define gxm_page_number_w gxm_page_number
  #define gxm_page_widget_w gxm_page_widget
  #define gxm_status_area_widget_w gxm_status_area_widget
  #define gxm_major_tab_widget_w gxm_major_tab_widget
  #define gxm_minor_tab_widget_w gxm_minor_tab_widget
  #define gxm_source_data_w gxm_source_data
  #define gxm_location_data_w gxm_location_data
  #define gxm_parm_w gxm_parm
  #define gxm_parm_format_w gxm_parm_format
  #define gxm_parm_length_w gxm_parm_length
  #define gxm_parm_type_w gxm_parm_type
  #define gxm_transfer_id_w gxm_transfer_id
  #define gxm_destination_data_w gxm_destination_data
  #define gxm_remaining_w gxm_remaining
  #define gxm_item_or_text_w gxm_item_or_text
  #define gxm_auto_selection_type_w gxm_auto_selection_type
  #define gxm_new_outline_state_w gxm_new_outline_state
  #define gxm_prev_page_number_w gxm_prev_page_number
  #define gxm_prev_page_widget_w gxm_prev_page_widget
  #define gxm_rendition_w gxm_rendition
  #define gxm_render_table_w gxm_render_table
#if HAVE_XM_XP
  #define gxm_last_page_w gxm_last_page
#endif
  #define gxm_crossed_boundary_w gxm_crossed_boundary
  #define gxm_client_data_w gxm_client_data
  #define gxm_status_w gxm_status
  #define gxm_font_name_w gxm_font_name
  #define gxm_tag_w gxm_tag
  #define gxm_traversal_destination_w gxm_traversal_destination
  #define gxm_dragProtocolStyle_w gxm_dragProtocolStyle
  #define gxm_direction_w gxm_direction
  #define gxm_reason_w gxm_reason
  #define gxm_timeStamp_w gxm_timeStamp
  #define gxm_operation_w gxm_operation 
  #define gxm_set_operation_w gxm_set_operation
  #define gxm_operations_w gxm_operations
  #define gxm_dropSiteStatus_w gxm_dropSiteStatus 
  #define gxm_set_dropSiteStatus_w gxm_set_dropSiteStatus
  #define gxm_dropAction_w gxm_dropAction
  #define gxm_iccHandle_w gxm_iccHandle
  #define gxm_completionStatus_w gxm_completionStatus
  #define gxm_dragContext_w gxm_dragContext
  #define gxm_animate_w gxm_animate
  #define gxm_length_w gxm_length
  #define gxm_click_count_w gxm_click_count
  #define gxm_widget_w gxm_widget
  #define gxm_item_position_w gxm_item_position
  #define gxm_callbackstruct_w gxm_callbackstruct
  #define gxm_set_w gxm_set
  #define gxm_item_w gxm_item
  #define gxm_item_length_w gxm_item_length
  #define gxm_selected_items_w gxm_selected_items
  #define gxm_selected_item_count_w gxm_selected_item_count
  #define gxm_selected_item_positions_w gxm_selected_item_positions
  #define gxm_selection_type_w gxm_selection_type
  #define gxm_mask_w gxm_mask
  #define gxm_mask_length_w gxm_mask_length
  #define gxm_dir_w gxm_dir
  #define gxm_dir_length_w gxm_dir_length
  #define gxm_pattern_w gxm_pattern
  #define gxm_pattern_length_w gxm_pattern_length
  #define gxm_position_w gxm_position
  #define gxm_currInsert_w gxm_currInsert
  #define gxm_newInsert_w gxm_newInsert
  #define gxm_startPos_w gxm_startPos
  #define gxm_endPos_w gxm_endPos
  #define gxm_text_w gxm_text
  #define gxm_value_w gxm_value
  #define gxm_set_value_w gxm_set_value
  #define gxm_doit_w gxm_doit
  #define gxm_set_doit_w gxm_set_doit
  #define gxm_menuToPost_w gxm_menuToPost
  #define gxm_set_menuToPost_w gxm_set_menuToPost
  #define gxm_postIt_w gxm_postIt
  #define gxm_set_postIt_w gxm_set_postIt
#if HAVE_XmCreateDataField
  #define gxm_w_w gxm_w
  #define gxm_accept_w gxm_accept
#endif
#if HAVE_XmCreateTabStack
  #define gxm_selected_child_w gxm_selected_child
#endif

#if HAVE_XPM
  #define gxm_valuemask_w gxm_valuemask
  #define gxm_set_valuemask_w gxm_set_valuemask
  #define gxm_ncolors_w gxm_ncolors
  #define gxm_set_ncolors_w gxm_set_ncolors
  #define gxm_cpp_w gxm_cpp
  #define gxm_set_cpp_w gxm_set_cpp
  #define gxm_numsymbols_w gxm_numsymbols
  #define gxm_set_numsymbols_w gxm_set_numsymbols
  #define gxm_colorsymbols_w gxm_colorsymbols
  #define gxm_set_colorsymbols_w gxm_set_colorsymbols
  #define gxm_npixels_w gxm_npixels
  #define gxm_set_npixels_w gxm_set_npixels
  #define gxm_y_hotspot_w gxm_y_hotspot
  #define gxm_set_y_hotspot_w gxm_set_y_hotspot
  #define gxm_x_hotspot_w gxm_x_hotspot
  #define gxm_set_x_hotspot_w gxm_set_x_hotspot

  #define gxm_XpmImage_w gxm_XpmImage
  #define gxm_XpmColorSymbol_w gxm_XpmColorSymbol
  #define gxm_XpmAttributes_w gxm_XpmAttributes
#endif
    /* HAVE_XPM */

#if HAVE_SCHEME
  #define c_to_xen_string_w c_to_xen_string
  #define c_to_xen_strings_w c_to_xen_strings
  #define c_to_xen_ints_w c_to_xen_ints
  #define c_to_xen_atoms_w c_to_xen_atoms
  #define c_to_xen_xrectangles_w c_to_xen_xrectangles
#endif

#endif
/* HAVE_MOTIF */
#endif
/* argify */


static void define_procedures(void)
{
  #define XM_DEFINE_PROCEDURE(Name, Value, A1, A2, A3, Help) XEN_DEFINE_PROCEDURE(XM_PREFIX #Name XM_POSTFIX, Value, A1, A2, A3, Help)

  xm_gc_table = XEN_MAKE_VECTOR(1, XEN_FALSE);
  XEN_PROTECT_FROM_GC(xm_gc_table);
  xm_protected_size = 512;
  xm_protected = XEN_MAKE_VECTOR(xm_protected_size, XEN_FALSE);
  XEN_VECTOR_SET(xm_gc_table, 0, xm_protected);

#if HAVE_XM_XP
  XM_DEFINE_PROCEDURE(XpStartPage, gxm_XpStartPage_w, 2, 0, 0, H_XpStartPage);
  XM_DEFINE_PROCEDURE(XpEndPage, gxm_XpEndPage_w, 1, 0, 0, H_XpEndPage);
  XM_DEFINE_PROCEDURE(XpCancelPage, gxm_XpCancelPage_w, 2, 0, 0, H_XpCancelPage);
  XM_DEFINE_PROCEDURE(XpStartJob, gxm_XpStartJob_w, 2, 0, 0, H_XpStartJob);
  XM_DEFINE_PROCEDURE(XpEndJob, gxm_XpEndJob_w, 1, 0, 0, H_XpEndJob);
  XM_DEFINE_PROCEDURE(XpCancelJob, gxm_XpCancelJob_w, 2, 0, 0, H_XpCancelJob);
  XM_DEFINE_PROCEDURE(XpStartDoc, gxm_XpStartDoc_w, 2, 0, 0, H_XpStartDoc);
  XM_DEFINE_PROCEDURE(XpEndDoc, gxm_XpEndDoc_w, 1, 0, 0, H_XpEndDoc);
  XM_DEFINE_PROCEDURE(XpCancelDoc, gxm_XpCancelDoc_w, 2, 0, 0, H_XpCancelDoc);
  XM_DEFINE_PROCEDURE(XpRehashPrinterList, gxm_XpRehashPrinterList_w, 1, 0, 0, H_XpRehashPrinterList);
  XM_DEFINE_PROCEDURE(XpCreateContext, gxm_XpCreateContext_w, 2, 0, 0, H_XpCreateContext);
  XM_DEFINE_PROCEDURE(XpSetContext, gxm_XpSetContext_w, 2, 0, 0, H_XpSetContext);
  XM_DEFINE_PROCEDURE(XpGetContext, gxm_XpGetContext_w, 1, 0, 0, H_XpGetContext);
  XM_DEFINE_PROCEDURE(XpDestroyContext, gxm_XpDestroyContext_w, 2, 0, 0, H_XpDestroyContext);
  XM_DEFINE_PROCEDURE(XpGetLocaleNetString, gxm_XpGetLocaleNetString_w, 0, 0, 0, H_XpGetLocaleNetString);
  XM_DEFINE_PROCEDURE(XpNotifyPdm, gxm_XpNotifyPdm_w, 6, 0, 0, H_XpNotifyPdm);
  XM_DEFINE_PROCEDURE(XpSendAuth, gxm_XpSendAuth_w, 2, 0, 0, H_XpSendAuth);
  XM_DEFINE_PROCEDURE(XpGetImageResolution, gxm_XpGetImageResolution_w, 2, 0, 0, H_XpGetImageResolution);
  XM_DEFINE_PROCEDURE(XpGetAttributes, gxm_XpGetAttributes_w, 3, 0, 0, H_XpGetAttributes);
  XM_DEFINE_PROCEDURE(XpSetAttributes, gxm_XpSetAttributes_w, 5, 0, 0, H_XpSetAttributes);
  XM_DEFINE_PROCEDURE(XpGetOneAttribute, gxm_XpGetOneAttribute_w, 4, 0, 0, H_XpGetOneAttribute);
  XM_DEFINE_PROCEDURE(XpGetScreenOfContext, gxm_XpGetScreenOfContext_w, 2, 0, 0, H_XpGetScreenOfContext);
  XM_DEFINE_PROCEDURE(XpFreePrinterList, gxm_XpFreePrinterList_w, 1, 0, 0, H_XpFreePrinterList);
  XM_DEFINE_PROCEDURE(XpQueryVersion, gxm_XpQueryVersion_w, 1, 0, 0, H_XpQueryVersion);
  XM_DEFINE_PROCEDURE(XpQueryExtension, gxm_XpQueryExtension_w, 1, 0, 0, H_XpQueryExtension);
  XM_DEFINE_PROCEDURE(XpQueryScreens, gxm_XpQueryScreens_w, 1, 0, 0, H_XpQueryScreens);
  XM_DEFINE_PROCEDURE(XpGetPdmStartParams, gxm_XpGetPdmStartParams_w, 5, 0, 0, H_XpGetPdmStartParams);
  XM_DEFINE_PROCEDURE(XpGetAuthParams, gxm_XpGetAuthParams_w, 2, 0, 0, H_XpGetAuthParams);
  XM_DEFINE_PROCEDURE(XpSendOneTicket, gxm_XpSendOneTicket_w, 4, 0, 0, H_XpSendOneTicket);
  XM_DEFINE_PROCEDURE(XpGetPageDimensions, gxm_XpGetPageDimensions_w, 2, 0, 0, H_XpGetPageDimensions);
  XM_DEFINE_PROCEDURE(XpSetImageResolution, gxm_XpSetImageResolution_w, 4, 0, 0, H_XpSetImageResolution);
  XM_DEFINE_PROCEDURE(XpGetPrinterList, gxm_XpGetPrinterList_w, 2, 0, 0, H_XpGetPrinterList);
  XM_DEFINE_PROCEDURE(XpSelectInput, gxm_XpSelectInput_w, 3, 0, 0, H_XpSelectInput);
  XM_DEFINE_PROCEDURE(XpInputSelected, gxm_XpInputSelected_w, 3, 0, 0, H_XpInputSelected);
  XM_DEFINE_PROCEDURE(XpPutDocumentData, gxm_XpPutDocumentData_w, 6, 0, 0, H_XpPutDocumentData);
  XM_DEFINE_PROCEDURE(XpGetDocumentData, gxm_XpGetDocumentData_w, 5, 0, 0, H_XpGetDocumentData);
#endif
#if HAVE_MOTIF
  XM_DEFINE_PROCEDURE(XtSetArg, gxm_XtSetArg_w, 3, 0, 0, H_XtSetArg);
  XM_DEFINE_PROCEDURE(XtManageChildren, gxm_XtManageChildren_w, 1, 1, 0, H_XtManageChildren);
  XM_DEFINE_PROCEDURE(XtManageChild, gxm_XtManageChild_w, 1, 0, 0, H_XtManageChild);
  XM_DEFINE_PROCEDURE(XtUnmanageChildren, gxm_XtUnmanageChildren_w, 1, 1, 0, H_XtUnmanageChildren);
  XM_DEFINE_PROCEDURE(XtUnmanageChild, gxm_XtUnmanageChild_w, 1, 0, 0, H_XtUnmanageChild);
  XM_DEFINE_PROCEDURE(XtDispatchEvent, gxm_XtDispatchEvent_w, 1, 0, 0, H_XtDispatchEvent);
  XM_DEFINE_PROCEDURE(XtCallAcceptFocus, gxm_XtCallAcceptFocus_w, 2, 0, 0, H_XtCallAcceptFocus);
  XM_DEFINE_PROCEDURE(XtAppPeekEvent, gxm_XtAppPeekEvent_w, 1, 0, 0, H_XtAppPeekEvent);
  XM_DEFINE_PROCEDURE(XtIsSubclass, gxm_XtIsSubclass_w, 2, 0, 0, H_XtIsSubclass);
  XM_DEFINE_PROCEDURE(XtIsObject, gxm_XtIsObject_w, 1, 0, 0, H_XtIsObject);
  XM_DEFINE_PROCEDURE(XtIsManaged, gxm_XtIsManaged_w, 1, 0, 0, H_XtIsManaged);
  XM_DEFINE_PROCEDURE(XtIsRealized, gxm_XtIsRealized_w, 1, 0, 0, H_XtIsRealized);
  XM_DEFINE_PROCEDURE(XtIsSensitive, gxm_XtIsSensitive_w, 1, 0, 0, H_XtIsSensitive);
  XM_DEFINE_PROCEDURE(XtOwnSelection, gxm_XtOwnSelection_w, 6, 0, 0, H_XtOwnSelection);
  XM_DEFINE_PROCEDURE(XtOwnSelectionIncremental, gxm_XtOwnSelectionIncremental_w, 8, 0, 0, H_XtOwnSelectionIncremental);
  XM_DEFINE_PROCEDURE(XtMakeResizeRequest, gxm_XtMakeResizeRequest_w, 3, 0, 0, H_XtMakeResizeRequest);
  XM_DEFINE_PROCEDURE(XtTranslateCoords, gxm_XtTranslateCoords_w, 3, 0, 0, H_XtTranslateCoords);
  XM_DEFINE_PROCEDURE(XtKeysymToKeycodeList, gxm_XtKeysymToKeycodeList_w, 2, 0, 0, H_XtKeysymToKeycodeList);
  XM_DEFINE_PROCEDURE(XtParseTranslationTable, gxm_XtParseTranslationTable_w, 1, 0, 0, H_XtParseTranslationTable);
  XM_DEFINE_PROCEDURE(XtParseAcceleratorTable, gxm_XtParseAcceleratorTable_w, 1, 0, 0, H_XtParseAcceleratorTable);
  XM_DEFINE_PROCEDURE(XtOverrideTranslations, gxm_XtOverrideTranslations_w, 2, 0, 0, H_XtOverrideTranslations);
  XM_DEFINE_PROCEDURE(XtAugmentTranslations, gxm_XtAugmentTranslations_w, 2, 0, 0, H_XtAugmentTranslations);
  XM_DEFINE_PROCEDURE(XtInstallAccelerators, gxm_XtInstallAccelerators_w, 2, 0, 0, H_XtInstallAccelerators);
  XM_DEFINE_PROCEDURE(XtInstallAllAccelerators, gxm_XtInstallAllAccelerators_w, 2, 0, 0, H_XtInstallAllAccelerators);
  XM_DEFINE_PROCEDURE(XtUninstallTranslations, gxm_XtUninstallTranslations_w, 1, 0, 0, H_XtUninstallTranslations);
  XM_DEFINE_PROCEDURE(XtAppAddActions, gxm_XtAppAddActions_w, 2, 0, 0, H_XtAppAddActions);
  XM_DEFINE_PROCEDURE(XtAppAddActionHook, gxm_XtAppAddActionHook_w, 2, 1, 0, H_XtAppAddActionHook);
  XM_DEFINE_PROCEDURE(XtRemoveActionHook, gxm_XtRemoveActionHook_w, 1, 0, 0, H_XtRemoveActionHook);
  XM_DEFINE_PROCEDURE(XtGetActionList, gxm_XtGetActionList_w, 1, 0, 0, H_XtGetActionList);
  XM_DEFINE_PROCEDURE(XtCallActionProc, gxm_XtCallActionProc_w, 4, 1, 0, H_XtCallActionProc);
  XM_DEFINE_PROCEDURE(XtRegisterGrabAction, gxm_XtRegisterGrabAction_w, 5, 0, 0, H_XtRegisterGrabAction);
  XM_DEFINE_PROCEDURE(XtSetMultiClickTime, gxm_XtSetMultiClickTime_w, 2, 0, 0, H_XtSetMultiClickTime);
  XM_DEFINE_PROCEDURE(XtGetMultiClickTime, gxm_XtGetMultiClickTime_w, 1, 0, 0, H_XtGetMultiClickTime);
  XM_DEFINE_PROCEDURE(XtGetResourceList, gxm_XtGetResourceList_w, 1, 0, 0, H_XtGetResourceList);
  XM_DEFINE_PROCEDURE(XtGetActionKeysym, gxm_XtGetActionKeysym_w, 1, 0, 0, H_XtGetActionKeysym);
  XM_DEFINE_PROCEDURE(XtTranslateKeycode, gxm_XtTranslateKeycode_w, 3, 0, 0, H_XtTranslateKeycode);
  XM_DEFINE_PROCEDURE(XtTranslateKey, gxm_XtTranslateKey_w, 3, 0, 0, H_XtTranslateKey);
  XM_DEFINE_PROCEDURE(XtSetKeyTranslator, gxm_XtSetKeyTranslator_w, 2, 0, 0, H_XtSetKeyTranslator);
  XM_DEFINE_PROCEDURE(XtRegisterCaseConverter, gxm_XtRegisterCaseConverter_w, 4, 0, 0, H_XtRegisterCaseConverter);
  XM_DEFINE_PROCEDURE(XtConvertCase, gxm_XtConvertCase_w, 2, 0, 0, H_XtConvertCase);
  XM_DEFINE_PROCEDURE(XtAddEventHandler, gxm_XtAddEventHandler_w, 4, 1, 0, H_XtAddEventHandler);
  XM_DEFINE_PROCEDURE(XtRemoveEventHandler, gxm_XtRemoveEventHandler_w, 5, 0, 0, H_XtRemoveEventHandler);
  XM_DEFINE_PROCEDURE(XtAddRawEventHandler, gxm_XtAddRawEventHandler_w, 5, 0, 0, H_XtAddRawEventHandler);
  XM_DEFINE_PROCEDURE(XtRemoveRawEventHandler, gxm_XtRemoveRawEventHandler_w, 5, 0, 0, H_XtRemoveRawEventHandler);
  XM_DEFINE_PROCEDURE(XtInsertEventHandler, gxm_XtInsertEventHandler_w, 6, 0, 0, H_XtInsertEventHandler);
  XM_DEFINE_PROCEDURE(XtInsertRawEventHandler, gxm_XtInsertRawEventHandler_w, 6, 0, 0, H_XtInsertRawEventHandler);
  XM_DEFINE_PROCEDURE(XtDispatchEventToWidget, gxm_XtDispatchEventToWidget_w, 2, 0, 0, H_XtDispatchEventToWidget);
  XM_DEFINE_PROCEDURE(XtBuildEventMask, gxm_XtBuildEventMask_w, 1, 0, 0, H_XtBuildEventMask);
  XM_DEFINE_PROCEDURE(XtAddGrab, gxm_XtAddGrab_w, 3, 0, 0, H_XtAddGrab);
  XM_DEFINE_PROCEDURE(XtRemoveGrab, gxm_XtRemoveGrab_w, 1, 0, 0, H_XtRemoveGrab);
  XM_DEFINE_PROCEDURE(XtAppProcessEvent, gxm_XtAppProcessEvent_w, 2, 0, 0, H_XtAppProcessEvent);
  XM_DEFINE_PROCEDURE(XtAppMainLoop, gxm_XtAppMainLoop_w, 1, 0, 0, H_XtAppMainLoop);
  XM_DEFINE_PROCEDURE(XtAddExposureToRegion, gxm_XtAddExposureToRegion_w, 2, 0, 0, H_XtAddExposureToRegion);
  XM_DEFINE_PROCEDURE(XtSetKeyboardFocus, gxm_XtSetKeyboardFocus_w, 2, 0, 0, H_XtSetKeyboardFocus);
  XM_DEFINE_PROCEDURE(XtGetKeyboardFocusWidget, gxm_XtGetKeyboardFocusWidget_w, 1, 0, 0, H_XtGetKeyboardFocusWidget);
  XM_DEFINE_PROCEDURE(XtLastEventProcessed, gxm_XtLastEventProcessed_w, 1, 0, 0, H_XtLastEventProcessed);
  XM_DEFINE_PROCEDURE(XtLastTimestampProcessed, gxm_XtLastTimestampProcessed_w, 1, 0, 0, H_XtLastTimestampProcessed);
  XM_DEFINE_PROCEDURE(XtAppAddTimeOut, gxm_XtAppAddTimeOut_w, 3, 1, 0, H_XtAppAddTimeOut);
  XM_DEFINE_PROCEDURE(XtRemoveTimeOut, gxm_XtRemoveTimeOut_w, 1, 0, 0, H_XtRemoveTimeOut);
  XM_DEFINE_PROCEDURE(XtAppAddInput, gxm_XtAppAddInput_w, 4, 1, 0, H_XtAppAddInput);
  XM_DEFINE_PROCEDURE(XtRemoveInput, gxm_XtRemoveInput_w, 1, 0, 0, H_XtRemoveInput);
  XM_DEFINE_PROCEDURE(XtAppNextEvent, gxm_XtAppNextEvent_w, 1, 0, 0, H_XtAppNextEvent);
  XM_DEFINE_PROCEDURE(XtAppPending, gxm_XtAppPending_w, 1, 0, 0, H_XtAppPending);
  XM_DEFINE_PROCEDURE(XtRealizeWidget, gxm_XtRealizeWidget_w, 1, 0, 0, H_XtRealizeWidget);
  XM_DEFINE_PROCEDURE(XtUnrealizeWidget, gxm_XtUnrealizeWidget_w, 1, 0, 0, H_XtUnrealizeWidget);
  XM_DEFINE_PROCEDURE(XtDestroyWidget, gxm_XtDestroyWidget_w, 1, 0, 0, H_XtDestroyWidget);
  XM_DEFINE_PROCEDURE(XtSetSensitive, gxm_XtSetSensitive_w, 2, 0, 0, H_XtSetSensitive);
  XM_DEFINE_PROCEDURE(XtNameToWidget, gxm_XtNameToWidget_w, 2, 0, 0, H_XtNameToWidget);
  XM_DEFINE_PROCEDURE(XtWindowToWidget, gxm_XtWindowToWidget_w, 2, 0, 0, H_XtWindowToWidget);
  XM_DEFINE_PROCEDURE(XtMergeArgLists, gxm_XtMergeArgLists_w, 4, 0, 0, H_XtMergeArgLists);
  XM_DEFINE_PROCEDURE(XtVaCreateArgsList, gxm_XtVaCreateArgsList_w, 2, 0, 0, H_XtVaCreateArgsList);
  XM_DEFINE_PROCEDURE(XtDisplay, gxm_XtDisplay_w, 1, 0, 0, H_XtDisplay);
  XM_DEFINE_PROCEDURE(XtDisplayOfObject, gxm_XtDisplayOfObject_w, 1, 0, 0, H_XtDisplayOfObject);
  XM_DEFINE_PROCEDURE(XtScreen, gxm_XtScreen_w, 1, 0, 0, H_XtScreen);
  XM_DEFINE_PROCEDURE(XtScreenOfObject, gxm_XtScreenOfObject_w, 1, 0, 0, H_XtScreenOfObject);
  XM_DEFINE_PROCEDURE(XtWindow, gxm_XtWindow_w, 1, 0, 0, H_XtWindow);
  XM_DEFINE_PROCEDURE(XtWindowOfObject, gxm_XtWindowOfObject_w, 1, 0, 0, H_XtWindowOfObject);
  XM_DEFINE_PROCEDURE(XtName, gxm_XtName_w, 1, 0, 0, H_XtName);
  XM_DEFINE_PROCEDURE(XtSuperclass, gxm_XtSuperclass_w, 1, 0, 0, H_XtSuperclass);
  XM_DEFINE_PROCEDURE(XtClass, gxm_XtClass_w, 1, 0, 0, H_XtClass);
  XM_DEFINE_PROCEDURE(XtParent, gxm_XtParent_w, 1, 0, 0, H_XtParent);
  XM_DEFINE_PROCEDURE(XtAddCallback, gxm_XtAddCallback_w, 3, 1, 0, H_XtAddCallback);
  XM_DEFINE_PROCEDURE(XtRemoveCallback, gxm_XtRemoveCallback_w, 3, 0, 0, H_XtRemoveCallback);
  XM_DEFINE_PROCEDURE(XtAddCallbacks, gxm_XtAddCallbacks_w, 3, 0, 0, H_XtAddCallbacks);
  XM_DEFINE_PROCEDURE(XtRemoveCallbacks, gxm_XtRemoveCallbacks_w, 3, 0, 0, H_XtRemoveCallbacks);
  XM_DEFINE_PROCEDURE(XtRemoveAllCallbacks, gxm_XtRemoveAllCallbacks_w, 2, 0, 0, H_XtRemoveAllCallbacks);
  XM_DEFINE_PROCEDURE(XtCallCallbacks, gxm_XtCallCallbacks_w, 3, 0, 0, H_XtCallCallbacks);
  XM_DEFINE_PROCEDURE(XtHasCallbacks, gxm_XtHasCallbacks_w, 2, 0, 0, H_XtHasCallbacks);
  XM_DEFINE_PROCEDURE(XtCreatePopupShell, gxm_XtCreatePopupShell_w, 4, 1, 0, H_XtCreatePopupShell);
  XM_DEFINE_PROCEDURE(XtVaCreatePopupShell, gxm_XtVaCreatePopupShell_w, 4, 0, 0, H_XtVaCreatePopupShell);
  XM_DEFINE_PROCEDURE(XtPopup, gxm_XtPopup_w, 2, 0, 0, H_XtPopup);
  XM_DEFINE_PROCEDURE(XtPopupSpringLoaded, gxm_XtPopupSpringLoaded_w, 1, 0, 0, H_XtPopupSpringLoaded);
  XM_DEFINE_PROCEDURE(XtCallbackNone, gxm_XtCallbackNone_w, 3, 0, 0, H_XtCallbackNone);
  XM_DEFINE_PROCEDURE(XtCallbackNonexclusive, gxm_XtCallbackNonexclusive_w, 3, 0, 0, H_XtCallbackNonexclusive);
  XM_DEFINE_PROCEDURE(XtCallbackExclusive, gxm_XtCallbackExclusive_w, 3, 0, 0, H_XtCallbackExclusive);
  XM_DEFINE_PROCEDURE(XtPopdown, gxm_XtPopdown_w, 1, 0, 0, H_XtPopdown);
  XM_DEFINE_PROCEDURE(XtCallbackPopdown, gxm_XtCallbackPopdown_w, 3, 0, 0, H_XtCallbackPopdown);
  XM_DEFINE_PROCEDURE(XtCreateWidget, gxm_XtCreateWidget_w, 4, 1, 0, H_XtCreateWidget);
  XM_DEFINE_PROCEDURE(XtCreateManagedWidget, gxm_XtCreateManagedWidget_w, 4, 1, 0, H_XtCreateManagedWidget);
  XM_DEFINE_PROCEDURE(XtVaCreateWidget, gxm_XtVaCreateWidget_w, 4, 0, 0, H_XtVaCreateWidget);
  XM_DEFINE_PROCEDURE(XtVaCreateManagedWidget, gxm_XtVaCreateManagedWidget_w, 4, 0, 0, H_XtVaCreateManagedWidget);
  XM_DEFINE_PROCEDURE(XtAppCreateShell, gxm_XtAppCreateShell_w, 5, 1, 0, H_XtAppCreateShell);
  XM_DEFINE_PROCEDURE(XtVaAppCreateShell, gxm_XtVaAppCreateShell_w, 5, 0, 0, H_XtVaAppCreateShell);
  XM_DEFINE_PROCEDURE(XtToolkitInitialize, gxm_XtToolkitInitialize_w, 0, 0, 0, H_XtToolkitInitialize);
  XM_DEFINE_PROCEDURE(XtSetLanguageProc, gxm_XtSetLanguageProc_w, 3, 0, 0, H_XtSetLanguageProc);
  XM_DEFINE_PROCEDURE(XtDisplayInitialize, gxm_XtDisplayInitialize_w, 6, 0, 0, H_XtDisplayInitialize);
  XM_DEFINE_PROCEDURE(XtOpenApplication, gxm_XtOpenApplication_w, 5, 1, 0, H_XtOpenApplication);
  XM_DEFINE_PROCEDURE(XtVaOpenApplication, gxm_XtVaOpenApplication_w, 5, 1, 0, H_XtVaOpenApplication);
  XM_DEFINE_PROCEDURE(XtAppInitialize, gxm_XtAppInitialize_w, 4, 1, 0, H_XtAppInitialize);
  XM_DEFINE_PROCEDURE(XtVaAppInitialize, gxm_XtVaAppInitialize_w, 4, 1, 0, H_XtVaAppInitialize);
  XM_DEFINE_PROCEDURE(XtOpenDisplay, gxm_XtOpenDisplay_w, 6, 0, 0, H_XtOpenDisplay);
  XM_DEFINE_PROCEDURE(XtCreateApplicationContext, gxm_XtCreateApplicationContext_w, 0, 0, 0, H_XtCreateApplicationContext);
  XM_DEFINE_PROCEDURE(XtDestroyApplicationContext, gxm_XtDestroyApplicationContext_w, 1, 0, 0, H_XtDestroyApplicationContext);
  XM_DEFINE_PROCEDURE(XtAppSetFallbackResources, gxm_XtAppSetFallbackResources_w, 2, 0, 0, H_XtAppSetFallbackResources);
  XM_DEFINE_PROCEDURE(XtInitializeWidgetClass, gxm_XtInitializeWidgetClass_w, 1, 0, 0, H_XtInitializeWidgetClass);
  XM_DEFINE_PROCEDURE(XtWidgetToApplicationContext, gxm_XtWidgetToApplicationContext_w, 1, 0, 0, H_XtWidgetToApplicationContext);
  XM_DEFINE_PROCEDURE(XtDisplayToApplicationContext, gxm_XtDisplayToApplicationContext_w, 1, 0, 0, H_XtDisplayToApplicationContext);
  XM_DEFINE_PROCEDURE(XtCloseDisplay, gxm_XtCloseDisplay_w, 1, 0, 0, H_XtCloseDisplay);
  XM_DEFINE_PROCEDURE(XtSetValues, gxm_XtSetValues_w, 2, 1, 0, H_XtSetValues);
  XM_DEFINE_PROCEDURE(XtVaSetValues, gxm_XtVaSetValues_w, 2, 0, 0, H_XtVaSetValues);
  XM_DEFINE_PROCEDURE(XtGetValues, gxm_XtGetValues_w, 2, 1, 0, H_XtGetValues);
  XM_DEFINE_PROCEDURE(XtVaGetValues, gxm_XtVaGetValues_w, 2, 0, 0, H_XtVaGetValues);
  XM_DEFINE_PROCEDURE(XtAppSetErrorMsgHandler, gxm_XtAppSetErrorMsgHandler_w, 2, 0, 0, H_XtAppSetErrorMsgHandler);
  XM_DEFINE_PROCEDURE(XtAppSetWarningMsgHandler, gxm_XtAppSetWarningMsgHandler_w, 2, 0, 0, H_XtAppSetWarningMsgHandler);
  XM_DEFINE_PROCEDURE(XtAppErrorMsg, gxm_XtAppErrorMsg_w, 7, 0, 0, H_XtAppErrorMsg);
  XM_DEFINE_PROCEDURE(XtAppWarningMsg, gxm_XtAppWarningMsg_w, 7, 0, 0, H_XtAppWarningMsg);
  XM_DEFINE_PROCEDURE(XtAppSetErrorHandler, gxm_XtAppSetErrorHandler_w, 2, 0, 0, H_XtAppSetErrorHandler);
  XM_DEFINE_PROCEDURE(XtAppSetWarningHandler, gxm_XtAppSetWarningHandler_w, 2, 0, 0, H_XtAppSetWarningHandler);
  XM_DEFINE_PROCEDURE(XtAppError, gxm_XtAppError_w, 2, 0, 0, H_XtAppError);
  XM_DEFINE_PROCEDURE(XtMalloc, gxm_XtMalloc_w, 1, 0, 0, H_XtMalloc);
  XM_DEFINE_PROCEDURE(XtCalloc, gxm_XtCalloc_w, 2, 0, 0, H_XtCalloc);
  XM_DEFINE_PROCEDURE(XtRealloc, gxm_XtRealloc_w, 2, 0, 0, H_XtRealloc);
  XM_DEFINE_PROCEDURE(XtFree, gxm_XtFree_w, 1, 0, 0, H_XtFree);
  XM_DEFINE_PROCEDURE(XtAppAddWorkProc, gxm_XtAppAddWorkProc_w, 2, 1, 0, H_XtAppAddWorkProc);
  XM_DEFINE_PROCEDURE(XtRemoveWorkProc, gxm_XtRemoveWorkProc_w, 1, 0, 0, H_XtRemoveWorkProc);
  XM_DEFINE_PROCEDURE(XtGetGC, gxm_XtGetGC_w, 3, 0, 0, H_XtGetGC);
  XM_DEFINE_PROCEDURE(XtAllocateGC, gxm_XtAllocateGC_w, 6, 0, 0, H_XtAllocateGC);
  XM_DEFINE_PROCEDURE(XtDestroyGC, gxm_XtDestroyGC_w, 1, 0, 0, H_XtDestroyGC);
  XM_DEFINE_PROCEDURE(XtReleaseGC, gxm_XtReleaseGC_w, 2, 0, 0, H_XtReleaseGC);
  XM_DEFINE_PROCEDURE(XtFindFile, gxm_XtFindFile_w, 4, 0, 0, H_XtFindFile);
  XM_DEFINE_PROCEDURE(XtResolvePathname, gxm_XtResolvePathname_w, 8, 0, 0, H_XtResolvePathname);
  XM_DEFINE_PROCEDURE(XtDisownSelection, gxm_XtDisownSelection_w, 3, 0, 0, H_XtDisownSelection);
  XM_DEFINE_PROCEDURE(XtGetSelectionValue, gxm_XtGetSelectionValue_w, 6, 0, 0, H_XtGetSelectionValue);
  XM_DEFINE_PROCEDURE(XtGetSelectionValues, gxm_XtGetSelectionValues_w, 7, 0, 0, H_XtGetSelectionValues);
  XM_DEFINE_PROCEDURE(XtAppSetSelectionTimeout, gxm_XtAppSetSelectionTimeout_w, 2, 0, 0, H_XtAppSetSelectionTimeout);
  XM_DEFINE_PROCEDURE(XtAppGetSelectionTimeout, gxm_XtAppGetSelectionTimeout_w, 1, 0, 0, H_XtAppGetSelectionTimeout);
  XM_DEFINE_PROCEDURE(XtGetSelectionRequest, gxm_XtGetSelectionRequest_w, 3, 0, 0, H_XtGetSelectionRequest);
  XM_DEFINE_PROCEDURE(XtGetSelectionValueIncremental, gxm_XtGetSelectionValueIncremental_w, 6, 0, 0, H_XtGetSelectionValueIncremental);
  XM_DEFINE_PROCEDURE(XtGetSelectionValuesIncremental, gxm_XtGetSelectionValuesIncremental_w, 7, 0, 0, H_XtGetSelectionValuesIncremental);
  XM_DEFINE_PROCEDURE(XtCreateSelectionRequest, gxm_XtCreateSelectionRequest_w, 2, 0, 0, H_XtCreateSelectionRequest);
  XM_DEFINE_PROCEDURE(XtSendSelectionRequest, gxm_XtSendSelectionRequest_w, 3, 0, 0, H_XtSendSelectionRequest);
  XM_DEFINE_PROCEDURE(XtCancelSelectionRequest, gxm_XtCancelSelectionRequest_w, 2, 0, 0, H_XtCancelSelectionRequest);
  XM_DEFINE_PROCEDURE(XtGrabKey, gxm_XtGrabKey_w, 6, 0, 0, H_XtGrabKey);
  XM_DEFINE_PROCEDURE(XtUngrabKey, gxm_XtUngrabKey_w, 3, 0, 0, H_XtUngrabKey);
  XM_DEFINE_PROCEDURE(XtGrabKeyboard, gxm_XtGrabKeyboard_w, 5, 0, 0, H_XtGrabKeyboard);
  XM_DEFINE_PROCEDURE(XtUngrabKeyboard, gxm_XtUngrabKeyboard_w, 2, 0, 0, H_XtUngrabKeyboard);
  XM_DEFINE_PROCEDURE(XtGrabButton, gxm_XtGrabButton_w, 9, 0, 0, H_XtGrabButton);
  XM_DEFINE_PROCEDURE(XtUngrabButton, gxm_XtUngrabButton_w, 3, 0, 0, H_XtUngrabButton);
  XM_DEFINE_PROCEDURE(XtGrabPointer, gxm_XtGrabPointer_w, 8, 0, 0, H_XtGrabPointer);
  XM_DEFINE_PROCEDURE(XtUngrabPointer, gxm_XtUngrabPointer_w, 2, 0, 0, H_XtUngrabPointer);
  XM_DEFINE_PROCEDURE(XtGetApplicationNameAndClass, gxm_XtGetApplicationNameAndClass_w, 1, 0, 0, H_XtGetApplicationNameAndClass);
  XM_DEFINE_PROCEDURE(XtGetDisplays, gxm_XtGetDisplays_w, 1, 0, 0, H_XtGetDisplays);
  XM_DEFINE_PROCEDURE(XtToolkitThreadInitialize, gxm_XtToolkitThreadInitialize_w, 0, 0, 0, H_XtToolkitThreadInitialize);
  XM_DEFINE_PROCEDURE(XtAppLock, gxm_XtAppLock_w, 1, 0, 0, H_XtAppLock);
  XM_DEFINE_PROCEDURE(XtAppUnlock, gxm_XtAppUnlock_w, 1, 0, 0, H_XtAppUnlock);
  XM_DEFINE_PROCEDURE(XtIsRectObj, gxm_XtIsRectObj_w, 1, 0, 0, H_XtIsRectObj);
  XM_DEFINE_PROCEDURE(XtIsWidget, gxm_XtIsWidget_w, 1, 0, 0, H_XtIsWidget);
  XM_DEFINE_PROCEDURE(XtIsComposite, gxm_XtIsComposite_w, 1, 0, 0, H_XtIsComposite);
  XM_DEFINE_PROCEDURE(XtIsConstraint, gxm_XtIsConstraint_w, 1, 0, 0, H_XtIsConstraint);
  XM_DEFINE_PROCEDURE(XtIsShell, gxm_XtIsShell_w, 1, 0, 0, H_XtIsShell);
  XM_DEFINE_PROCEDURE(XtIsOverrideShell, gxm_XtIsOverrideShell_w, 1, 0, 0, H_XtIsOverrideShell);
  XM_DEFINE_PROCEDURE(XtIsWMShell, gxm_XtIsWMShell_w, 1, 0, 0, H_XtIsWMShell);
  XM_DEFINE_PROCEDURE(XtIsVendorShell, gxm_XtIsVendorShell_w, 1, 0, 0, H_XtIsVendorShell);
  XM_DEFINE_PROCEDURE(XtIsTransientShell, gxm_XtIsTransientShell_w, 1, 0, 0, H_XtIsTransientShell);
  XM_DEFINE_PROCEDURE(XtIsTopLevelShell, gxm_XtIsTopLevelShell_w, 1, 0, 0, H_XtIsTopLevelShell);
  XM_DEFINE_PROCEDURE(XtIsApplicationShell, gxm_XtIsApplicationShell_w, 1, 0, 0, H_XtIsApplicationShell);
  XM_DEFINE_PROCEDURE(XtIsSessionShell, gxm_XtIsSessionShell_w, 1, 0, 0, H_XtIsSessionShell);
  XM_DEFINE_PROCEDURE(XtMapWidget, gxm_XtMapWidget_w, 1, 0, 0, H_XtMapWidget);
  XM_DEFINE_PROCEDURE(XtUnmapWidget, gxm_XtUnmapWidget_w, 1, 0, 0, H_XtUnmapWidget);
#endif
  XM_DEFINE_PROCEDURE(XUniqueContext, gxm_XUniqueContext_w, 0, 0, 0, H_XUniqueContext);
  XM_DEFINE_PROCEDURE(XLoadQueryFont, gxm_XLoadQueryFont_w, 2, 0, 0, H_XLoadQueryFont);
  XM_DEFINE_PROCEDURE(XQueryFont, gxm_XQueryFont_w, 2, 0, 0, H_XQueryFont);
  XM_DEFINE_PROCEDURE(XGetMotionEvents, gxm_XGetMotionEvents_w, 4, 0, 0, H_XGetMotionEvents);
  XM_DEFINE_PROCEDURE(XDeleteModifiermapEntry, gxm_XDeleteModifiermapEntry_w, 3, 0, 0, H_XDeleteModifiermapEntry);
  XM_DEFINE_PROCEDURE(XGetModifierMapping, gxm_XGetModifierMapping_w, 1, 0, 0, H_XGetModifierMapping);
  XM_DEFINE_PROCEDURE(XInsertModifiermapEntry, gxm_XInsertModifiermapEntry_w, 3, 0, 0, H_XInsertModifiermapEntry);
  XM_DEFINE_PROCEDURE(XNewModifiermap, gxm_XNewModifiermap_w, 1, 0, 0, H_XNewModifiermap);
  XM_DEFINE_PROCEDURE(XCreateImage, gxm_XCreateImage_w, 0, 0, 1, H_XCreateImage);
  XM_DEFINE_PROCEDURE(XGetImage, gxm_XGetImage_w, 8, 0, 0, H_XGetImage);
  XM_DEFINE_PROCEDURE(XGetSubImage, gxm_XGetSubImage_w, 0, 0, 1, H_XGetSubImage);
  XM_DEFINE_PROCEDURE(XOpenDisplay, gxm_XOpenDisplay_w, 1, 0, 0, H_XOpenDisplay);
  XM_DEFINE_PROCEDURE(XFetchBytes, gxm_XFetchBytes_w, 1, 0, 0, H_XFetchBytes);
  XM_DEFINE_PROCEDURE(XFetchBuffer, gxm_XFetchBuffer_w, 2, 0, 0, H_XFetchBuffer);
  XM_DEFINE_PROCEDURE(XGetAtomName, gxm_XGetAtomName_w, 2, 0, 0, H_XGetAtomName);
  XM_DEFINE_PROCEDURE(XDisplayName, gxm_XDisplayName_w, 1, 0, 0, H_XDisplayName);
  XM_DEFINE_PROCEDURE(XKeysymToString, gxm_XKeysymToString_w, 1, 0, 0, H_XKeysymToString);
  XM_DEFINE_PROCEDURE(XSynchronize, gxm_XSynchronize_w, 2, 0, 0, H_XSynchronize);
  XM_DEFINE_PROCEDURE(XSetAfterFunction, gxm_XSetAfterFunction_w, 2, 0, 0, H_XSetAfterFunction);
  XM_DEFINE_PROCEDURE(XInternAtom, gxm_XInternAtom_w, 3, 0, 0, H_XInternAtom);
  XM_DEFINE_PROCEDURE(XCopyColormapAndFree, gxm_XCopyColormapAndFree_w, 2, 0, 0, H_XCopyColormapAndFree);
  XM_DEFINE_PROCEDURE(XCreateColormap, gxm_XCreateColormap_w, 4, 0, 0, H_XCreateColormap);
  XM_DEFINE_PROCEDURE(XCreatePixmapCursor, gxm_XCreatePixmapCursor_w, 7, 0, 0, H_XCreatePixmapCursor);
  XM_DEFINE_PROCEDURE(XCreateGlyphCursor, gxm_XCreateGlyphCursor_w, 7, 0, 0, H_XCreateGlyphCursor);
  XM_DEFINE_PROCEDURE(XCreateFontCursor, gxm_XCreateFontCursor_w, 2, 0, 0, H_XCreateFontCursor);
  XM_DEFINE_PROCEDURE(XLoadFont, gxm_XLoadFont_w, 2, 0, 0, H_XLoadFont);
  XM_DEFINE_PROCEDURE(XCreateGC, gxm_XCreateGC_w, 4, 0, 0, H_XCreateGC);
  XM_DEFINE_PROCEDURE(XFlushGC, gxm_XFlushGC_w, 2, 0, 0, H_XFlushGC);
  XM_DEFINE_PROCEDURE(XCreatePixmap, gxm_XCreatePixmap_w, 5, 0, 0, H_XCreatePixmap);
  XM_DEFINE_PROCEDURE(XCreateBitmapFromData, gxm_XCreateBitmapFromData_w, 5, 0, 0, H_XCreateBitmapFromData);
  XM_DEFINE_PROCEDURE(XCreatePixmapFromBitmapData, gxm_XCreatePixmapFromBitmapData_w, 8, 0, 0, H_XCreatePixmapFromBitmapData);
  XM_DEFINE_PROCEDURE(XCreateSimpleWindow, gxm_XCreateSimpleWindow_w, 9, 0, 0, H_XCreateSimpleWindow);
  XM_DEFINE_PROCEDURE(XGetSelectionOwner, gxm_XGetSelectionOwner_w, 2, 0, 0, H_XGetSelectionOwner);
  XM_DEFINE_PROCEDURE(XCreateWindow, gxm_XCreateWindow_w, 0, 0, 1, H_XCreateWindow);
  XM_DEFINE_PROCEDURE(XListInstalledColormaps, gxm_XListInstalledColormaps_w, 2, 0, 0, H_XListInstalledColormaps);
  XM_DEFINE_PROCEDURE(XListFonts, gxm_XListFonts_w, 3, 0, 0, H_XListFonts);
  XM_DEFINE_PROCEDURE(XListFontsWithInfo, gxm_XListFontsWithInfo_w, 3, 0, 0, H_XListFontsWithInfo);
  XM_DEFINE_PROCEDURE(XGetFontPath, gxm_XGetFontPath_w, 1, 0, 0, H_XGetFontPath);
  XM_DEFINE_PROCEDURE(XListExtensions, gxm_XListExtensions_w, 1, 0, 0, H_XListExtensions);
  XM_DEFINE_PROCEDURE(XListProperties, gxm_XListProperties_w, 2, 0, 0, H_XListProperties);
  XM_DEFINE_PROCEDURE(XKeycodeToKeysym, gxm_XKeycodeToKeysym_w, 3, 0, 0, H_XKeycodeToKeysym);
  XM_DEFINE_PROCEDURE(XLookupKeysym, gxm_XLookupKeysym_w, 2, 0, 0, H_XLookupKeysym);
  XM_DEFINE_PROCEDURE(XGetKeyboardMapping, gxm_XGetKeyboardMapping_w, 3, 0, 0, H_XGetKeyboardMapping);
  XM_DEFINE_PROCEDURE(XStringToKeysym, gxm_XStringToKeysym_w, 1, 0, 0, H_XStringToKeysym);
  XM_DEFINE_PROCEDURE(XMaxRequestSize, gxm_XMaxRequestSize_w, 1, 0, 0, H_XMaxRequestSize);
  XM_DEFINE_PROCEDURE(XExtendedMaxRequestSize, gxm_XExtendedMaxRequestSize_w, 1, 0, 0, H_XExtendedMaxRequestSize);
  XM_DEFINE_PROCEDURE(XDisplayMotionBufferSize, gxm_XDisplayMotionBufferSize_w, 1, 0, 0, H_XDisplayMotionBufferSize);
  XM_DEFINE_PROCEDURE(XVisualIDFromVisual, gxm_XVisualIDFromVisual_w, 1, 0, 0, H_XVisualIDFromVisual);
  XM_DEFINE_PROCEDURE(XRootWindow, gxm_XRootWindow_w, 2, 0, 0, H_RootWindow);
  XM_DEFINE_PROCEDURE(XDefaultRootWindow, gxm_XDefaultRootWindow_w, 1, 0, 0, H_DefaultRootWindow);
  XM_DEFINE_PROCEDURE(XRootWindowOfScreen, gxm_XRootWindowOfScreen_w, 1, 0, 0, H_RootWindowOfScreen);
  XM_DEFINE_PROCEDURE(XDefaultVisual, gxm_XDefaultVisual_w, 2, 0, 0, H_DefaultVisual);
  XM_DEFINE_PROCEDURE(XDefaultVisualOfScreen, gxm_XDefaultVisualOfScreen_w, 1, 0, 0, H_DefaultVisualOfScreen);
  XM_DEFINE_PROCEDURE(XDefaultGC, gxm_XDefaultGC_w, 2, 0, 0, H_DefaultGC);
  XM_DEFINE_PROCEDURE(XDefaultGCOfScreen, gxm_XDefaultGCOfScreen_w, 1, 0, 0, H_DefaultGCOfScreen);
  XM_DEFINE_PROCEDURE(XBlackPixel, gxm_XBlackPixel_w, 2, 0, 0, H_BlackPixel);
  XM_DEFINE_PROCEDURE(XWhitePixel, gxm_XWhitePixel_w, 2, 0, 0, H_WhitePixel);
  XM_DEFINE_PROCEDURE(XAllPlanes, gxm_XAllPlanes_w, 0, 0, 0, H_AllPlanes);
  XM_DEFINE_PROCEDURE(XBlackPixelOfScreen, gxm_XBlackPixelOfScreen_w, 1, 0, 0, H_BlackPixelOfScreen);
  XM_DEFINE_PROCEDURE(XWhitePixelOfScreen, gxm_XWhitePixelOfScreen_w, 1, 0, 0, H_WhitePixelOfScreen);
  XM_DEFINE_PROCEDURE(XNextRequest, gxm_XNextRequest_w, 1, 0, 0, H_NextRequest);
  XM_DEFINE_PROCEDURE(XLastKnownRequestProcessed, gxm_XLastKnownRequestProcessed_w, 1, 0, 0, H_LastKnownRequestProcessed);
  XM_DEFINE_PROCEDURE(XServerVendor, gxm_XServerVendor_w, 1, 0, 0, H_ServerVendor);
  XM_DEFINE_PROCEDURE(XDisplayString, gxm_XDisplayString_w, 1, 0, 0, H_DisplayString);
  XM_DEFINE_PROCEDURE(XDefaultColormap, gxm_XDefaultColormap_w, 2, 0, 0, H_DefaultColormap);
  XM_DEFINE_PROCEDURE(XDefaultColormapOfScreen, gxm_XDefaultColormapOfScreen_w, 1, 0, 0, H_DefaultColormapOfScreen);
  XM_DEFINE_PROCEDURE(XDisplayOfScreen, gxm_XDisplayOfScreen_w, 1, 0, 0, H_DisplayOfScreen);
  XM_DEFINE_PROCEDURE(XScreenOfDisplay, gxm_XScreenOfDisplay_w, 2, 0, 0, H_ScreenOfDisplay);
  XM_DEFINE_PROCEDURE(XDefaultScreenOfDisplay, gxm_XDefaultScreenOfDisplay_w, 1, 0, 0, H_XDefaultScreenOfDisplay);
  XM_DEFINE_PROCEDURE(XEventMaskOfScreen, gxm_XEventMaskOfScreen_w, 1, 0, 0, H_EventMaskOfScreen);
  XM_DEFINE_PROCEDURE(XScreenNumberOfScreen, gxm_XScreenNumberOfScreen_w, 1, 0, 0, H_XScreenNumberOfScreen);
  XM_DEFINE_PROCEDURE(XSetErrorHandler, gxm_XSetErrorHandler_w, 1, 0, 0, H_XSetErrorHandler);
  XM_DEFINE_PROCEDURE(XSetIOErrorHandler, gxm_XSetIOErrorHandler_w, 1, 0, 0, H_XSetIOErrorHandler);
  XM_DEFINE_PROCEDURE(XListPixmapFormats, gxm_XListPixmapFormats_w, 1, 0, 0, H_XListPixmapFormats);
  XM_DEFINE_PROCEDURE(XListDepths, gxm_XListDepths_w, 2, 0, 0, H_XListDepths);
  XM_DEFINE_PROCEDURE(XReconfigureWMWindow, gxm_XReconfigureWMWindow_w, 5, 0, 0, H_XReconfigureWMWindow);
  XM_DEFINE_PROCEDURE(XGetWMProtocols, gxm_XGetWMProtocols_w, 2, 0, 0, H_XGetWMProtocols);
  XM_DEFINE_PROCEDURE(XSetWMProtocols, gxm_XSetWMProtocols_w, 4, 0, 0, H_XSetWMProtocols);
  XM_DEFINE_PROCEDURE(XIconifyWindow, gxm_XIconifyWindow_w, 3, 0, 0, H_XIconifyWindow);
  XM_DEFINE_PROCEDURE(XWithdrawWindow, gxm_XWithdrawWindow_w, 3, 0, 0, H_XWithdrawWindow);
  XM_DEFINE_PROCEDURE(XGetCommand, gxm_XGetCommand_w, 2, 0, 0, H_XGetCommand);
  XM_DEFINE_PROCEDURE(XGetWMColormapWindows, gxm_XGetWMColormapWindows_w, 2, 0, 0, H_XGetWMColormapWindows);
  XM_DEFINE_PROCEDURE(XSetWMColormapWindows, gxm_XSetWMColormapWindows_w, 4, 0, 0, H_XSetWMColormapWindows);
  XM_DEFINE_PROCEDURE(XSetTransientForHint, gxm_XSetTransientForHint_w, 3, 0, 0, H_XSetTransientForHint);
  XM_DEFINE_PROCEDURE(XActivateScreenSaver, gxm_XActivateScreenSaver_w, 1, 0, 0, H_XActivateScreenSaver);
  XM_DEFINE_PROCEDURE(XAllocColor, gxm_XAllocColor_w, 3, 0, 0, H_XAllocColor);
  XM_DEFINE_PROCEDURE(XAllocColorCells, gxm_XAllocColorCells_w, 5, 0, 0, H_XAllocColorCells);
  XM_DEFINE_PROCEDURE(XAllocColorPlanes, gxm_XAllocColorPlanes_w, 0, 0, 1, H_XAllocColorPlanes);
  XM_DEFINE_PROCEDURE(XAllocNamedColor, gxm_XAllocNamedColor_w, 5, 0, 0, H_XAllocNamedColor);
  XM_DEFINE_PROCEDURE(XAllowEvents, gxm_XAllowEvents_w, 3, 0, 0, H_XAllowEvents);
  XM_DEFINE_PROCEDURE(XAutoRepeatOff, gxm_XAutoRepeatOff_w, 1, 0, 0, H_XAutoRepeatOff);
  XM_DEFINE_PROCEDURE(XAutoRepeatOn, gxm_XAutoRepeatOn_w, 1, 0, 0, H_XAutoRepeatOn);
  XM_DEFINE_PROCEDURE(XBell, gxm_XBell_w, 2, 0, 0, H_XBell);
  XM_DEFINE_PROCEDURE(XBitmapBitOrder, gxm_XBitmapBitOrder_w, 1, 0, 0, H_BitmapBitOrder);
  XM_DEFINE_PROCEDURE(XBitmapPad, gxm_XBitmapPad_w, 1, 0, 0, H_BitmapPad);
  XM_DEFINE_PROCEDURE(XBitmapUnit, gxm_XBitmapUnit_w, 1, 0, 0, H_BitmapUnit);
  XM_DEFINE_PROCEDURE(XCellsOfScreen, gxm_XCellsOfScreen_w, 1, 0, 0, H_CellsOfScreen);
  XM_DEFINE_PROCEDURE(XChangeActivePointerGrab, gxm_XChangeActivePointerGrab_w, 4, 0, 0, H_XChangeActivePointerGrab);
  XM_DEFINE_PROCEDURE(XChangeGC, gxm_XChangeGC_w, 4, 0, 0, H_XChangeGC);
  XM_DEFINE_PROCEDURE(XChangeKeyboardControl, gxm_XChangeKeyboardControl_w, 3, 0, 0, H_XChangeKeyboardControl);
  XM_DEFINE_PROCEDURE(XChangeKeyboardMapping, gxm_XChangeKeyboardMapping_w, 5, 0, 0, H_XChangeKeyboardMapping);
  XM_DEFINE_PROCEDURE(XChangePointerControl, gxm_XChangePointerControl_w, 6, 0, 0, H_XChangePointerControl);
  XM_DEFINE_PROCEDURE(XChangeProperty, gxm_XChangeProperty_w, 7, 1, 0, H_XChangeProperty);
  XM_DEFINE_PROCEDURE(XChangeWindowAttributes, gxm_XChangeWindowAttributes_w, 4, 0, 0, H_XChangeWindowAttributes);
  XM_DEFINE_PROCEDURE(XCheckIfEvent, gxm_XCheckIfEvent_w, 3, 0, 0, H_XCheckIfEvent);
  XM_DEFINE_PROCEDURE(XCheckMaskEvent, gxm_XCheckMaskEvent_w, 2, 0, 0, H_XCheckMaskEvent);
  XM_DEFINE_PROCEDURE(XCheckTypedEvent, gxm_XCheckTypedEvent_w, 2, 0, 0, H_XCheckTypedEvent);
  XM_DEFINE_PROCEDURE(XCheckTypedWindowEvent, gxm_XCheckTypedWindowEvent_w, 3, 0, 0, H_XCheckTypedWindowEvent);
  XM_DEFINE_PROCEDURE(XCheckWindowEvent, gxm_XCheckWindowEvent_w, 3, 0, 0, H_XCheckWindowEvent);
  XM_DEFINE_PROCEDURE(XCirculateSubwindows, gxm_XCirculateSubwindows_w, 3, 0, 0, H_XCirculateSubwindows);
  XM_DEFINE_PROCEDURE(XCirculateSubwindowsDown, gxm_XCirculateSubwindowsDown_w, 2, 0, 0, H_XCirculateSubwindowsDown);
  XM_DEFINE_PROCEDURE(XCirculateSubwindowsUp, gxm_XCirculateSubwindowsUp_w, 2, 0, 0, H_XCirculateSubwindowsUp);
  XM_DEFINE_PROCEDURE(XClearArea, gxm_XClearArea_w, 7, 0, 0, H_XClearArea);
  XM_DEFINE_PROCEDURE(XClearWindow, gxm_XClearWindow_w, 2, 0, 0, H_XClearWindow);
  XM_DEFINE_PROCEDURE(XCloseDisplay, gxm_XCloseDisplay_w, 1, 0, 0, H_XCloseDisplay);
  XM_DEFINE_PROCEDURE(XConfigureWindow, gxm_XConfigureWindow_w, 4, 0, 0, H_XConfigureWindow);
  XM_DEFINE_PROCEDURE(XConnectionNumber, gxm_XConnectionNumber_w, 1, 0, 0, H_XConnectionNumber);
  XM_DEFINE_PROCEDURE(XConvertSelection, gxm_XConvertSelection_w, 6, 0, 0, H_XConvertSelection);
  XM_DEFINE_PROCEDURE(XCopyArea, gxm_XCopyArea_w, 0, 0, 1, H_XCopyArea);
  XM_DEFINE_PROCEDURE(XCopyGC, gxm_XCopyGC_w, 4, 0, 0, H_XCopyGC);
  XM_DEFINE_PROCEDURE(XCopyPlane, gxm_XCopyPlane_w, 0, 0, 1, H_XCopyPlane);
  XM_DEFINE_PROCEDURE(XDefaultDepth, gxm_XDefaultDepth_w, 2, 0, 0, H_XDefaultDepth);
  XM_DEFINE_PROCEDURE(XDefaultDepthOfScreen, gxm_XDefaultDepthOfScreen_w, 1, 0, 0, H_XDefaultDepthOfScreen);
  XM_DEFINE_PROCEDURE(XDefaultScreen, gxm_XDefaultScreen_w, 1, 0, 0, H_XDefaultScreen);
  XM_DEFINE_PROCEDURE(XDefineCursor, gxm_XDefineCursor_w, 3, 0, 0, H_XDefineCursor);
  XM_DEFINE_PROCEDURE(XDeleteProperty, gxm_XDeleteProperty_w, 3, 0, 0, H_XDeleteProperty);
  XM_DEFINE_PROCEDURE(XDestroyWindow, gxm_XDestroyWindow_w, 2, 0, 0, H_XDestroyWindow);
  XM_DEFINE_PROCEDURE(XDestroySubwindows, gxm_XDestroySubwindows_w, 2, 0, 0, H_XDestroySubwindows);
  XM_DEFINE_PROCEDURE(XDoesBackingStore, gxm_XDoesBackingStore_w, 1, 0, 0, H_XDoesBackingStore);
  XM_DEFINE_PROCEDURE(XDoesSaveUnders, gxm_XDoesSaveUnders_w, 1, 0, 0, H_XDoesSaveUnders);
  XM_DEFINE_PROCEDURE(XDisableAccessControl, gxm_XDisableAccessControl_w, 1, 0, 0, H_XDisableAccessControl);
  XM_DEFINE_PROCEDURE(XDisplayCells, gxm_XDisplayCells_w, 2, 0, 0, H_XDisplayCells);
  XM_DEFINE_PROCEDURE(XDisplayHeight, gxm_XDisplayHeight_w, 2, 0, 0, H_XDisplayHeight);
  XM_DEFINE_PROCEDURE(XDisplayHeightMM, gxm_XDisplayHeightMM_w, 2, 0, 0, H_XDisplayHeightMM);
  XM_DEFINE_PROCEDURE(XDisplayKeycodes, gxm_XDisplayKeycodes_w, 1, 0, 0, H_XDisplayKeycodes);
  XM_DEFINE_PROCEDURE(XDisplayPlanes, gxm_XDisplayPlanes_w, 2, 0, 0, H_XDisplayPlanes);
  XM_DEFINE_PROCEDURE(XDisplayWidth, gxm_XDisplayWidth_w, 2, 0, 0, H_XDisplayWidth);
  XM_DEFINE_PROCEDURE(XDisplayWidthMM, gxm_XDisplayWidthMM_w, 2, 0, 0, H_XDisplayWidthMM);
  XM_DEFINE_PROCEDURE(XDrawArc, gxm_XDrawArc_w, 9, 0, 0, H_XDrawArc);
  XM_DEFINE_PROCEDURE(XDrawArcs, gxm_XDrawArcs_w, 5, 0, 0, H_XDrawArcs);
  XM_DEFINE_PROCEDURE(XDrawImageString, gxm_XDrawImageString_w, 7, 0, 0, H_XDrawImageString);
  XM_DEFINE_PROCEDURE(XDrawLine, gxm_XDrawLine_w, 7, 0, 0, H_XDrawLine);
  XM_DEFINE_PROCEDURE(XDrawLines, gxm_XDrawLines_w, 6, 0, 0, H_XDrawLines);
  XM_DEFINE_PROCEDURE(XDrawLinesDirect, gxm_XDrawLinesDirect_w, 6, 0, 0, H_XDrawLinesDirect);
  XM_DEFINE_PROCEDURE(freeXPoints, gxm_FreeXPoints_w, 1, 0, 0, H_freeXPoints);
  XM_DEFINE_PROCEDURE(vector->XPoints, gxm_Vector2XPoints_w, 1, 0, 0, H_vector2XPoints);
  XM_DEFINE_PROCEDURE(XDrawPoint, gxm_XDrawPoint_w, 5, 0, 0, H_XDrawPoint);
  XM_DEFINE_PROCEDURE(XDrawPoints, gxm_XDrawPoints_w, 6, 0, 0, H_XDrawPoints);
  XM_DEFINE_PROCEDURE(XDrawRectangle, gxm_XDrawRectangle_w, 7, 0, 0, H_XDrawRectangle);
  XM_DEFINE_PROCEDURE(XDrawRectangles, gxm_XDrawRectangles_w, 5, 0, 0, H_XDrawRectangles);
  XM_DEFINE_PROCEDURE(XDrawSegments, gxm_XDrawSegments_w, 5, 0, 0, H_XDrawSegments);
  XM_DEFINE_PROCEDURE(XDrawString, gxm_XDrawString_w, 7, 0, 0, H_XDrawString);
  XM_DEFINE_PROCEDURE(XDrawText, gxm_XDrawText_w, 6, 1, 0, H_XDrawText);
  XM_DEFINE_PROCEDURE(XEnableAccessControl, gxm_XEnableAccessControl_w, 1, 0, 0, H_XEnableAccessControl);
  XM_DEFINE_PROCEDURE(XEventsQueued, gxm_XEventsQueued_w, 2, 0, 0, H_XEventsQueued);
  XM_DEFINE_PROCEDURE(XFetchName, gxm_XFetchName_w, 2, 0, 0, H_XFetchName);
  XM_DEFINE_PROCEDURE(XFillArc, gxm_XFillArc_w, 9, 0, 0, H_XFillArc);
  XM_DEFINE_PROCEDURE(XFillArcs, gxm_XFillArcs_w, 5, 0, 0, H_XFillArcs);
  XM_DEFINE_PROCEDURE(XFillPolygon, gxm_XFillPolygon_w, 7, 0, 0, H_XFillPolygon);
  XM_DEFINE_PROCEDURE(XFillRectangle, gxm_XFillRectangle_w, 7, 0, 0, H_XFillRectangle);
  XM_DEFINE_PROCEDURE(XFillRectangles, gxm_XFillRectangles_w, 5, 0, 0, H_XFillRectangles);
  XM_DEFINE_PROCEDURE(XFlush, gxm_XFlush_w, 1, 0, 0, H_XFlush);
  XM_DEFINE_PROCEDURE(XForceScreenSaver, gxm_XForceScreenSaver_w, 2, 0, 0, H_XForceScreenSaver);
  XM_DEFINE_PROCEDURE(XFree, gxm_XFree_w, 1, 0, 0, H_XFree);
  XM_DEFINE_PROCEDURE(XFreeColormap, gxm_XFreeColormap_w, 2, 0, 0, H_XFreeColormap);
  XM_DEFINE_PROCEDURE(XFreeColors, gxm_XFreeColors_w, 5, 0, 0, H_XFreeColors);
  XM_DEFINE_PROCEDURE(XFreeCursor, gxm_XFreeCursor_w, 2, 0, 0, H_XFreeCursor);
  XM_DEFINE_PROCEDURE(XFreeExtensionList, gxm_XFreeExtensionList_w, 1, 0, 0, "XFreeExtensionList(list) frees list (from XListExtensions)");
  XM_DEFINE_PROCEDURE(XFreeFont, gxm_XFreeFont_w, 2, 0, 0, H_XFreeFont);
  XM_DEFINE_PROCEDURE(XFreeFontInfo, gxm_XFreeFontInfo_w, 3, 0, 0, H_XFreeFontInfo);
  XM_DEFINE_PROCEDURE(XFreeFontNames, gxm_XFreeFontNames_w, 1, 0, 0, H_XFreeFontNames);
  XM_DEFINE_PROCEDURE(XFreeFontPath, gxm_XFreeFontPath_w, 1, 0, 0, H_XFreeFontPath);
  XM_DEFINE_PROCEDURE(XFreeGC, gxm_XFreeGC_w, 2, 0, 0, H_XFreeGC);
  XM_DEFINE_PROCEDURE(XFreeModifiermap, gxm_XFreeModifiermap_w, 1, 0, 0, H_XFreeModifiermap);
  XM_DEFINE_PROCEDURE(XFreePixmap, gxm_XFreePixmap_w, 2, 0, 0, H_XFreePixmap);
  XM_DEFINE_PROCEDURE(XGeometry, gxm_XGeometry_w, 0, 0, 1, H_XGeometry);
  XM_DEFINE_PROCEDURE(XGetErrorText, gxm_XGetErrorText_w, 4, 0, 0, H_XGetErrorText);
  XM_DEFINE_PROCEDURE(XGetFontProperty, gxm_XGetFontProperty_w, 2, 0, 0, H_XGetFontProperty);
  XM_DEFINE_PROCEDURE(XGetGCValues, gxm_XGetGCValues_w, 3, 0, 0, H_XGetGCValues);
  XM_DEFINE_PROCEDURE(XGCValues, gxm_XGCValues_w, 0, 0, 0, "XGCValues returns a new XGCValue struct");
  XM_DEFINE_PROCEDURE(XEvent, gxm_XEvent_w, 0, 1, 0, "XEvent returns a new XEvent struct");
  XM_DEFINE_PROCEDURE(XGetGeometry, gxm_XGetGeometry_w, 2, 0, 0, H_XGetGeometry);
  XM_DEFINE_PROCEDURE(XGetIconName, gxm_XGetIconName_w, 2, 0, 0, H_XGetIconName);
  XM_DEFINE_PROCEDURE(XGetInputFocus, gxm_XGetInputFocus_w, 1, 0, 0, H_XGetInputFocus);
  XM_DEFINE_PROCEDURE(XGetKeyboardControl, gxm_XGetKeyboardControl_w, 1, 0, 0, H_XGetKeyboardControl);
  XM_DEFINE_PROCEDURE(XGetPointerControl, gxm_XGetPointerControl_w, 1, 0, 0, H_XGetPointerControl);
  XM_DEFINE_PROCEDURE(XGetPointerMapping, gxm_XGetPointerMapping_w, 3, 0, 0, H_XGetPointerMapping);
  XM_DEFINE_PROCEDURE(XGetScreenSaver, gxm_XGetScreenSaver_w, 1, 0, 0, H_XGetScreenSaver);
  XM_DEFINE_PROCEDURE(XGetTransientForHint, gxm_XGetTransientForHint_w, 2, 0, 0, H_XGetTransientForHint);
  XM_DEFINE_PROCEDURE(XGetWindowProperty, gxm_XGetWindowProperty_w, 0, 0, 1, H_XGetWindowProperty);
  XM_DEFINE_PROCEDURE(XGetWindowAttributes, gxm_XGetWindowAttributes_w, 2, 0, 0, H_XGetWindowAttributes);
  XM_DEFINE_PROCEDURE(XGrabButton, gxm_XGrabButton_w, 0, 0, 1, H_XGrabButton);
  XM_DEFINE_PROCEDURE(XGrabKey, gxm_XGrabKey_w, 7, 0, 0, H_XGrabKey);
  XM_DEFINE_PROCEDURE(XGrabKeyboard, gxm_XGrabKeyboard_w, 6, 0, 0, H_XGrabKeyboard);
  XM_DEFINE_PROCEDURE(XGrabPointer, gxm_XGrabPointer_w, 9, 0, 0, H_XGrabPointer);
  XM_DEFINE_PROCEDURE(XGrabServer, gxm_XGrabServer_w, 1, 0, 0, H_XGrabServer);
  XM_DEFINE_PROCEDURE(XHeightMMOfScreen, gxm_XHeightMMOfScreen_w, 1, 0, 0, H_HeightMMOfScreen);
  XM_DEFINE_PROCEDURE(XHeightOfScreen, gxm_XHeightOfScreen_w, 1, 0, 0, H_HeightOfScreen);
  XM_DEFINE_PROCEDURE(XIfEvent, gxm_XIfEvent_w, 3, 0, 0, H_XIfEvent);
  XM_DEFINE_PROCEDURE(XImageByteOrder, gxm_XImageByteOrder_w, 1, 0, 0, H_ImageByteOrder);
  XM_DEFINE_PROCEDURE(XInstallColormap, gxm_XInstallColormap_w, 2, 0, 0, H_XInstallColormap);
  XM_DEFINE_PROCEDURE(XKeysymToKeycode, gxm_XKeysymToKeycode_w, 2, 0, 0, H_XKeysymToKeycode);
  XM_DEFINE_PROCEDURE(XKillClient, gxm_XKillClient_w, 2, 0, 0, H_XKillClient);
  XM_DEFINE_PROCEDURE(XLookupColor, gxm_XLookupColor_w, 5, 0, 0, H_XLookupColor);
  XM_DEFINE_PROCEDURE(XLowerWindow, gxm_XLowerWindow_w, 2, 0, 0, H_XLowerWindow);
  XM_DEFINE_PROCEDURE(XMapRaised, gxm_XMapRaised_w, 2, 0, 0, H_XMapRaised);
  XM_DEFINE_PROCEDURE(XMapSubwindows, gxm_XMapSubwindows_w, 2, 0, 0, H_XMapSubwindows);
  XM_DEFINE_PROCEDURE(XMapWindow, gxm_XMapWindow_w, 2, 0, 0, H_XMapWindow);
  XM_DEFINE_PROCEDURE(XMaskEvent, gxm_XMaskEvent_w, 2, 0, 0, H_XMaskEvent);
  XM_DEFINE_PROCEDURE(XMaxCmapsOfScreen, gxm_XMaxCmapsOfScreen_w, 1, 0, 0, H_MaxCmapsOfScreen);
  XM_DEFINE_PROCEDURE(XMinCmapsOfScreen, gxm_XMinCmapsOfScreen_w, 1, 0, 0, H_MinCmapsOfScreen);
  XM_DEFINE_PROCEDURE(XMoveResizeWindow, gxm_XMoveResizeWindow_w, 6, 0, 0, H_XMoveResizeWindow);
  XM_DEFINE_PROCEDURE(XMoveWindow, gxm_XMoveWindow_w, 4, 0, 0, H_XMoveWindow);
  XM_DEFINE_PROCEDURE(XNextEvent, gxm_XNextEvent_w, 1, 0, 0, H_XNextEvent);
  XM_DEFINE_PROCEDURE(XNoOp, gxm_XNoOp_w, 1, 0, 0, H_XNoOp);
  XM_DEFINE_PROCEDURE(XParseColor, gxm_XParseColor_w, 4, 0, 0, H_XParseColor);
  XM_DEFINE_PROCEDURE(XParseGeometry, gxm_XParseGeometry_w, 1, 0, 0, H_XParseGeometry);
  XM_DEFINE_PROCEDURE(XPeekEvent, gxm_XPeekEvent_w, 1, 0, 0, H_XPeekEvent);
  XM_DEFINE_PROCEDURE(XPeekIfEvent, gxm_XPeekIfEvent_w, 3, 0, 0, H_XPeekIfEvent);
  XM_DEFINE_PROCEDURE(XPending, gxm_XPending_w, 1, 0, 0, H_XPending);
  XM_DEFINE_PROCEDURE(XPlanesOfScreen, gxm_XPlanesOfScreen_w, 1, 0, 0, H_PlanesOfScreen);
  XM_DEFINE_PROCEDURE(XProtocolRevision, gxm_XProtocolRevision_w, 1, 0, 0, H_ProtocolRevision);
  XM_DEFINE_PROCEDURE(XProtocolVersion, gxm_XProtocolVersion_w, 1, 0, 0, H_ProtocolVersion);
  XM_DEFINE_PROCEDURE(XPutBackEvent, gxm_XPutBackEvent_w, 2, 0, 0, H_XPutBackEvent);
  XM_DEFINE_PROCEDURE(XPutImage, gxm_XPutImage_w, 0, 0, 1, H_XPutImage);
  XM_DEFINE_PROCEDURE(XQLength, gxm_XQLength_w, 1, 0, 0, H_QLength);
  XM_DEFINE_PROCEDURE(XQueryBestCursor, gxm_XQueryBestCursor_w, 4, 0, 0, H_XQueryBestCursor);
  XM_DEFINE_PROCEDURE(XQueryBestSize, gxm_XQueryBestSize_w, 5, 0, 0, H_XQueryBestSize);
  XM_DEFINE_PROCEDURE(XQueryBestStipple, gxm_XQueryBestStipple_w, 4, 0, 0, H_XQueryBestStipple);
  XM_DEFINE_PROCEDURE(XQueryBestTile, gxm_XQueryBestTile_w, 4, 0, 0, H_XQueryBestTile);
  XM_DEFINE_PROCEDURE(XQueryColor, gxm_XQueryColor_w, 3, 0, 0, H_XQueryColor);
  XM_DEFINE_PROCEDURE(XQueryColors, gxm_XQueryColors_w, 3, 1, 0, H_XQueryColors);
  XM_DEFINE_PROCEDURE(XQueryExtension, gxm_XQueryExtension_w, 2, 0, 0, H_XQueryExtension);
  XM_DEFINE_PROCEDURE(XQueryKeymap, gxm_XQueryKeymap_w, 1, 0, 0, H_XQueryKeymap);
  XM_DEFINE_PROCEDURE(XQueryPointer, gxm_XQueryPointer_w, 2, 0, 0, H_XQueryPointer);
  XM_DEFINE_PROCEDURE(XQueryTextExtents, gxm_XQueryTextExtents_w, 3, 0, 0, H_XQueryTextExtents);
  XM_DEFINE_PROCEDURE(XQueryTree, gxm_XQueryTree_w, 2, 0, 0, H_XQueryTree);
  XM_DEFINE_PROCEDURE(XRaiseWindow, gxm_XRaiseWindow_w, 2, 0, 0, H_XRaiseWindow);
  XM_DEFINE_PROCEDURE(XReadBitmapFile, gxm_XReadBitmapFile_w, 3, 0, 0, H_XReadBitmapFile);
  XM_DEFINE_PROCEDURE(XReadBitmapFileData, gxm_XReadBitmapFileData_w, 1, 0, 0, H_XReadBitmapFileData);
  XM_DEFINE_PROCEDURE(XRebindKeysym, gxm_XRebindKeysym_w, 6, 0, 0, H_XRebindKeysym);
  XM_DEFINE_PROCEDURE(XRecolorCursor, gxm_XRecolorCursor_w, 4, 0, 0, H_XRecolorCursor);
  XM_DEFINE_PROCEDURE(XRefreshKeyboardMapping, gxm_XRefreshKeyboardMapping_w, 1, 0, 0, H_XRefreshKeyboardMapping);
  XM_DEFINE_PROCEDURE(XReparentWindow, gxm_XReparentWindow_w, 5, 0, 0, H_XReparentWindow);
  XM_DEFINE_PROCEDURE(XResetScreenSaver, gxm_XResetScreenSaver_w, 1, 0, 0, H_XResetScreenSaver);
  XM_DEFINE_PROCEDURE(XResizeWindow, gxm_XResizeWindow_w, 4, 0, 0, H_XResizeWindow);
  XM_DEFINE_PROCEDURE(XRestackWindows, gxm_XRestackWindows_w, 3, 0, 0, H_XRestackWindows);
  XM_DEFINE_PROCEDURE(XRotateBuffers, gxm_XRotateBuffers_w, 2, 0, 0, H_XRotateBuffers);
  XM_DEFINE_PROCEDURE(XRotateWindowProperties, gxm_XRotateWindowProperties_w, 5, 0, 0, H_XRotateWindowProperties);
  XM_DEFINE_PROCEDURE(XScreenCount, gxm_XScreenCount_w, 1, 0, 0, H_ScreenCount);
  XM_DEFINE_PROCEDURE(XSelectInput, gxm_XSelectInput_w, 3, 0, 0, H_XSelectInput);
  XM_DEFINE_PROCEDURE(XSendEvent, gxm_XSendEvent_w, 5, 0, 0, H_XSendEvent);
  XM_DEFINE_PROCEDURE(XSetAccessControl, gxm_XSetAccessControl_w, 2, 0, 0, H_XSetAccessControl);
  XM_DEFINE_PROCEDURE(XSetArcMode, gxm_XSetArcMode_w, 3, 0, 0, H_XSetArcMode);
  XM_DEFINE_PROCEDURE(XSetBackground, gxm_XSetBackground_w, 3, 0, 0, H_XSetBackground);
  XM_DEFINE_PROCEDURE(XSetClipMask, gxm_XSetClipMask_w, 3, 0, 0, H_XSetClipMask);
  XM_DEFINE_PROCEDURE(XSetClipOrigin, gxm_XSetClipOrigin_w, 4, 0, 0, H_XSetClipOrigin);
  XM_DEFINE_PROCEDURE(XSetClipRectangles, gxm_XSetClipRectangles_w, 7, 0, 0, H_XSetClipRectangles);
  XM_DEFINE_PROCEDURE(XSetCloseDownMode, gxm_XSetCloseDownMode_w, 2, 0, 0, H_XSetCloseDownMode);
  XM_DEFINE_PROCEDURE(XSetCommand, gxm_XSetCommand_w, 4, 0, 0, H_XSetCommand);
  XM_DEFINE_PROCEDURE(XSetDashes, gxm_XSetDashes_w, 4, 1, 0, H_XSetDashes);
  XM_DEFINE_PROCEDURE(XSetFillRule, gxm_XSetFillRule_w, 3, 0, 0, H_XSetFillRule);
  XM_DEFINE_PROCEDURE(XSetFillStyle, gxm_XSetFillStyle_w, 3, 0, 0, H_XSetFillStyle);
  XM_DEFINE_PROCEDURE(XSetFont, gxm_XSetFont_w, 3, 0, 0, H_XSetFont);
  XM_DEFINE_PROCEDURE(XSetFontPath, gxm_XSetFontPath_w, 3, 0, 0, H_XSetFontPath);
  XM_DEFINE_PROCEDURE(XSetForeground, gxm_XSetForeground_w, 3, 0, 0, H_XSetForeground);
  XM_DEFINE_PROCEDURE(XSetFunction, gxm_XSetFunction_w, 3, 0, 0, H_XSetFunction);
  XM_DEFINE_PROCEDURE(XSetGraphicsExposures, gxm_XSetGraphicsExposures_w, 3, 0, 0, H_XSetGraphicsExposures);
  XM_DEFINE_PROCEDURE(XSetIconName, gxm_XSetIconName_w, 3, 0, 0, H_XSetIconName);
  XM_DEFINE_PROCEDURE(XSetInputFocus, gxm_XSetInputFocus_w, 4, 0, 0, H_XSetInputFocus);
  XM_DEFINE_PROCEDURE(XSetLineAttributes, gxm_XSetLineAttributes_w, 6, 0, 0, H_XSetLineAttributes);
  XM_DEFINE_PROCEDURE(XSetModifierMapping, gxm_XSetModifierMapping_w, 2, 0, 0, H_XSetModifierMapping);
  XM_DEFINE_PROCEDURE(XSetPlaneMask, gxm_XSetPlaneMask_w, 3, 0, 0, H_XSetPlaneMask);
  XM_DEFINE_PROCEDURE(XSetPointerMapping, gxm_XSetPointerMapping_w, 2, 1, 0, H_XSetPointerMapping);
  XM_DEFINE_PROCEDURE(XSetScreenSaver, gxm_XSetScreenSaver_w, 5, 0, 0, H_XSetScreenSaver);
  XM_DEFINE_PROCEDURE(XSetSelectionOwner, gxm_XSetSelectionOwner_w, 4, 0, 0, H_XSetSelectionOwner);
  XM_DEFINE_PROCEDURE(XSetState, gxm_XSetState_w, 6, 0, 0, H_XSetState);
  XM_DEFINE_PROCEDURE(XSetStipple, gxm_XSetStipple_w, 3, 0, 0, H_XSetStipple);
  XM_DEFINE_PROCEDURE(XSetSubwindowMode, gxm_XSetSubwindowMode_w, 3, 0, 0, H_XSetSubwindowMode);
  XM_DEFINE_PROCEDURE(XSetTSOrigin, gxm_XSetTSOrigin_w, 4, 0, 0, H_XSetTSOrigin);
  XM_DEFINE_PROCEDURE(XSetTile, gxm_XSetTile_w, 3, 0, 0, H_XSetTile);
  XM_DEFINE_PROCEDURE(XSetWindowBackground, gxm_XSetWindowBackground_w, 3, 0, 0, H_XSetWindowBackground);
  XM_DEFINE_PROCEDURE(XSetWindowBackgroundPixmap, gxm_XSetWindowBackgroundPixmap_w, 3, 0, 0, H_XSetWindowBackgroundPixmap);
  XM_DEFINE_PROCEDURE(XSetWindowBorder, gxm_XSetWindowBorder_w, 3, 0, 0, H_XSetWindowBorder);
  XM_DEFINE_PROCEDURE(XSetWindowBorderPixmap, gxm_XSetWindowBorderPixmap_w, 3, 0, 0, H_XSetWindowBorderPixmap);
  XM_DEFINE_PROCEDURE(XSetWindowBorderWidth, gxm_XSetWindowBorderWidth_w, 3, 0, 0, H_XSetWindowBorderWidth);
  XM_DEFINE_PROCEDURE(XSetWindowColormap, gxm_XSetWindowColormap_w, 3, 0, 0, H_XSetWindowColormap);
  XM_DEFINE_PROCEDURE(XStoreBuffer, gxm_XStoreBuffer_w, 4, 0, 0, H_XStoreBuffer);
  XM_DEFINE_PROCEDURE(XStoreBytes, gxm_XStoreBytes_w, 3, 0, 0, H_XStoreBytes);
  XM_DEFINE_PROCEDURE(XStoreColor, gxm_XStoreColor_w, 3, 0, 0, H_XStoreColor);
  XM_DEFINE_PROCEDURE(XStoreColors, gxm_XStoreColors_w, 4, 0, 0, H_XStoreColors);
  XM_DEFINE_PROCEDURE(XStoreName, gxm_XStoreName_w, 3, 0, 0, H_XStoreName);
  XM_DEFINE_PROCEDURE(XStoreNamedColor, gxm_XStoreNamedColor_w, 5, 0, 0, H_XStoreNamedColor);
  XM_DEFINE_PROCEDURE(XSync, gxm_XSync_w, 2, 0, 0, H_XSync);
  XM_DEFINE_PROCEDURE(XTextExtents, gxm_XTextExtents_w, 3, 0, 0, H_XTextExtents);
  XM_DEFINE_PROCEDURE(XTextWidth, gxm_XTextWidth_w, 3, 0, 0, H_XTextWidth);
  XM_DEFINE_PROCEDURE(XTranslateCoordinates, gxm_XTranslateCoordinates_w, 5, 0, 0, H_XTranslateCoordinates);
  XM_DEFINE_PROCEDURE(XUndefineCursor, gxm_XUndefineCursor_w, 2, 0, 0, H_XUndefineCursor);
  XM_DEFINE_PROCEDURE(XUngrabButton, gxm_XUngrabButton_w, 4, 0, 0, H_XUngrabButton);
  XM_DEFINE_PROCEDURE(XUngrabKey, gxm_XUngrabKey_w, 4, 0, 0, H_XUngrabKey);
  XM_DEFINE_PROCEDURE(XUngrabKeyboard, gxm_XUngrabKeyboard_w, 2, 0, 0, H_XUngrabKeyboard);
  XM_DEFINE_PROCEDURE(XUngrabPointer, gxm_XUngrabPointer_w, 2, 0, 0, H_XUngrabPointer);
  XM_DEFINE_PROCEDURE(XUngrabServer, gxm_XUngrabServer_w, 1, 0, 0, H_XUngrabServer);
  XM_DEFINE_PROCEDURE(XUninstallColormap, gxm_XUninstallColormap_w, 2, 0, 0, H_XUninstallColormap);
  XM_DEFINE_PROCEDURE(XUnloadFont, gxm_XUnloadFont_w, 2, 0, 0, H_XUnloadFont);
  XM_DEFINE_PROCEDURE(XUnmapSubwindows, gxm_XUnmapSubwindows_w, 2, 0, 0, H_XUnmapSubwindows);
  XM_DEFINE_PROCEDURE(XUnmapWindow, gxm_XUnmapWindow_w, 2, 0, 0, H_XUnmapWindow);
  XM_DEFINE_PROCEDURE(XVendorRelease, gxm_XVendorRelease_w, 1, 0, 0, H_VendorRelease);
  XM_DEFINE_PROCEDURE(XWarpPointer, gxm_XWarpPointer_w, 9, 0, 0, H_XWarpPointer);
  XM_DEFINE_PROCEDURE(XWidthMMOfScreen, gxm_XWidthMMOfScreen_w, 1, 0, 0, H_WidthMMOfScreen);
  XM_DEFINE_PROCEDURE(XWidthOfScreen, gxm_XWidthOfScreen_w, 1, 0, 0, H_WidthOfScreen);
  XM_DEFINE_PROCEDURE(XWindowEvent, gxm_XWindowEvent_w, 3, 0, 0, H_XWindowEvent);
  XM_DEFINE_PROCEDURE(XWriteBitmapFile, gxm_XWriteBitmapFile_w, 7, 0, 0, H_XWriteBitmapFile);
  XM_DEFINE_PROCEDURE(XSupportsLocale, gxm_XSupportsLocale_w, 0, 0, 0, H_XSupportsLocale);
  XM_DEFINE_PROCEDURE(XSetLocaleModifiers, gxm_XSetLocaleModifiers_w, 1, 0, 0, H_XSetLocaleModifiers);
  XM_DEFINE_PROCEDURE(XCreateFontSet, gxm_XCreateFontSet_w, 2, 0, 0, H_XCreateFontSet);
  XM_DEFINE_PROCEDURE(XFreeFontSet, gxm_XFreeFontSet_w, 2, 0, 0, H_XFreeFontSet);
  XM_DEFINE_PROCEDURE(XFontsOfFontSet, gxm_XFontsOfFontSet_w, 1, 0, 0, H_XFontsOfFontSet);
  XM_DEFINE_PROCEDURE(XBaseFontNameListOfFontSet, gxm_XBaseFontNameListOfFontSet_w, 1, 0, 0, H_XBaseFontNameListOfFontSet);
  XM_DEFINE_PROCEDURE(XLocaleOfFontSet, gxm_XLocaleOfFontSet_w, 1, 0, 0, H_XLocaleOfFontSet);
  XM_DEFINE_PROCEDURE(XContextDependentDrawing, gxm_XContextDependentDrawing_w, 1, 0, 0, H_XContextDependentDrawing);
  XM_DEFINE_PROCEDURE(XDirectionalDependentDrawing, gxm_XDirectionalDependentDrawing_w, 1, 0, 0, H_XDirectionalDependentDrawing);
  XM_DEFINE_PROCEDURE(XContextualDrawing, gxm_XContextualDrawing_w, 1, 0, 0, H_XContextualDrawing);
  XM_DEFINE_PROCEDURE(XFilterEvent, gxm_XFilterEvent_w, 2, 0, 0, H_XFilterEvent);
  XM_DEFINE_PROCEDURE(XAllocIconSize, gxm_XAllocIconSize_w, 0, 0, 0, H_XAllocIconSize);
  XM_DEFINE_PROCEDURE(XAllocStandardColormap, gxm_XAllocStandardColormap_w, 0, 0, 0, H_XAllocStandardColormap);
  XM_DEFINE_PROCEDURE(XAllocWMHints, gxm_XAllocWMHints_w, 0, 0, 0, H_XAllocWMHints);
  XM_DEFINE_PROCEDURE(XClipBox, gxm_XClipBox_w, 1, 0, 0, H_XClipBox);
  XM_DEFINE_PROCEDURE(XCreateRegion, gxm_XCreateRegion_w, 0, 0, 0, H_XCreateRegion);
  XM_DEFINE_PROCEDURE(XDefaultString, gxm_XDefaultString_w, 0, 0, 0, H_XDefaultString);
  XM_DEFINE_PROCEDURE(XDeleteContext, gxm_XDeleteContext_w, 3, 0, 0, H_XDeleteContext);
  XM_DEFINE_PROCEDURE(XDestroyRegion, gxm_XDestroyRegion_w, 1, 0, 0, H_XDestroyRegion);
  XM_DEFINE_PROCEDURE(XEmptyRegion, gxm_XEmptyRegion_w, 1, 0, 0, H_XEmptyRegion);
  XM_DEFINE_PROCEDURE(XEqualRegion, gxm_XEqualRegion_w, 2, 0, 0, H_XEqualRegion);
  XM_DEFINE_PROCEDURE(XFindContext, gxm_XFindContext_w, 3, 0, 0, H_XFindContext);
  XM_DEFINE_PROCEDURE(XGetIconSizes, gxm_XGetIconSizes_w, 2, 0, 0, H_XGetIconSizes);
  XM_DEFINE_PROCEDURE(XGetRGBColormaps, gxm_XGetRGBColormaps_w, 3, 0, 0, H_XGetRGBColormaps);
#if (!XM_DISABLE_DEPRECATED)
  XM_DEFINE_PROCEDURE(XGetStandardColormap, gxm_XGetStandardColormap_w, 3, 0, 0, H_XGetStandardColormap);
#endif
  XM_DEFINE_PROCEDURE(XGetVisualInfo, gxm_XGetVisualInfo_w, 3, 0, 0, H_XGetVisualInfo);
  XM_DEFINE_PROCEDURE(XGetWMHints, gxm_XGetWMHints_w, 2, 0, 0, H_XGetWMHints);
  XM_DEFINE_PROCEDURE(XIntersectRegion, gxm_XIntersectRegion_w, 3, 0, 0, H_XIntersectRegion);
  XM_DEFINE_PROCEDURE(XConvertCase, gxm_XConvertCase_w, 1, 0, 0, H_XConvertCase);
  XM_DEFINE_PROCEDURE(XLookupString, gxm_XLookupString_w, 1, 0, 0, H_XLookupString);
  XM_DEFINE_PROCEDURE(XMatchVisualInfo, gxm_XMatchVisualInfo_w, 4, 0, 0, H_XMatchVisualInfo);
  XM_DEFINE_PROCEDURE(XOffsetRegion, gxm_XOffsetRegion_w, 3, 0, 0, H_XOffsetRegion);
  XM_DEFINE_PROCEDURE(XPointInRegion, gxm_XPointInRegion_w, 3, 0, 0, H_XPointInRegion);
  XM_DEFINE_PROCEDURE(XPolygonRegion, gxm_XPolygonRegion_w, 3, 0, 0, H_XPolygonRegion);
  XM_DEFINE_PROCEDURE(XRectInRegion, gxm_XRectInRegion_w, 5, 0, 0, H_XRectInRegion);
  XM_DEFINE_PROCEDURE(XSaveContext, gxm_XSaveContext_w, 4, 0, 0, H_XSaveContext);
  XM_DEFINE_PROCEDURE(XSetRGBColormaps, gxm_XSetRGBColormaps_w, 5, 0, 0, H_XSetRGBColormaps);
  XM_DEFINE_PROCEDURE(XSetWMHints, gxm_XSetWMHints_w, 3, 0, 0, H_XSetWMHints);
  XM_DEFINE_PROCEDURE(XSetRegion, gxm_XSetRegion_w, 3, 0, 0, H_XSetRegion);
#if (!XM_DISABLE_DEPRECATED)
  XM_DEFINE_PROCEDURE(XSetStandardColormap, gxm_XSetStandardColormap_w, 4, 0, 0, H_XSetStandardColormap);
  XM_DEFINE_PROCEDURE(XSetStandardProperties, gxm_XSetStandardProperties_w, 8, 0, 0, H_XSetStandardProperties);
#endif
  XM_DEFINE_PROCEDURE(XSetWMProperties, gxm_XSetWMProperties_w, 8, 0, 0, H_XSetWMProperties);
  XM_DEFINE_PROCEDURE(XShrinkRegion, gxm_XShrinkRegion_w, 3, 0, 0, H_XShrinkRegion);
  XM_DEFINE_PROCEDURE(XSubtractRegion, gxm_XSubtractRegion_w, 3, 0, 0, H_XSubtractRegion);
  XM_DEFINE_PROCEDURE(XUnionRectWithRegion, gxm_XUnionRectWithRegion_w, 3, 0, 0, H_XUnionRectWithRegion);
  XM_DEFINE_PROCEDURE(XUnionRegion, gxm_XUnionRegion_w, 3, 0, 0, H_XUnionRegion);
  XM_DEFINE_PROCEDURE(XXorRegion, gxm_XXorRegion_w, 3, 0, 0, H_XXorRegion);

  XM_DEFINE_PROCEDURE(DefaultScreen, gxm_DefaultScreen_w, 1, 0, 0, H_DefaultScreen);
  XM_DEFINE_PROCEDURE(DefaultRootWindow, gxm_DefaultRootWindow_w, 1, 0, 0, H_DefaultRootWindow);
  XM_DEFINE_PROCEDURE(QLength, gxm_QLength_w, 1, 0, 0, H_QLength);
  XM_DEFINE_PROCEDURE(ScreenCount, gxm_ScreenCount_w, 1, 0, 0, H_ScreenCount);
  XM_DEFINE_PROCEDURE(ServerVendor, gxm_ServerVendor_w, 1, 0, 0, H_ServerVendor);
  XM_DEFINE_PROCEDURE(ProtocolVersion, gxm_ProtocolVersion_w, 1, 0, 0, H_ProtocolVersion);
  XM_DEFINE_PROCEDURE(ProtocolRevision, gxm_ProtocolRevision_w, 1, 0, 0, H_ProtocolRevision);
  XM_DEFINE_PROCEDURE(VendorRelease, gxm_VendorRelease_w, 1, 0, 0, H_VendorRelease);
  XM_DEFINE_PROCEDURE(DisplayString, gxm_DisplayString_w, 1, 0, 0, H_DisplayString);
  XM_DEFINE_PROCEDURE(BitmapUnit, gxm_BitmapUnit_w, 1, 0, 0, H_BitmapUnit);
  XM_DEFINE_PROCEDURE(BitmapBitOrder, gxm_BitmapBitOrder_w, 1, 0, 0, H_BitmapBitOrder);
  XM_DEFINE_PROCEDURE(BitmapPad, gxm_BitmapPad_w, 1, 0, 0, H_BitmapPad);
  XM_DEFINE_PROCEDURE(ImageByteOrder, gxm_ImageByteOrder_w, 1, 0, 0, H_ImageByteOrder);
  XM_DEFINE_PROCEDURE(NextRequest, gxm_NextRequest_w, 1, 0, 0, H_NextRequest);
  XM_DEFINE_PROCEDURE(LastKnownRequestProcessed, gxm_LastKnownRequestProcessed_w, 1, 0, 0, H_LastKnownRequestProcessed);
  XM_DEFINE_PROCEDURE(DefaultScreenOfDisplay, gxm_DefaultScreenOfDisplay_w, 1, 0, 0, H_DefaultScreenOfDisplay);
  XM_DEFINE_PROCEDURE(DisplayOfScreen, gxm_DisplayOfScreen_w, 1, 0, 0, H_DisplayOfScreen);
  XM_DEFINE_PROCEDURE(RootWindowOfScreen, gxm_RootWindowOfScreen_w, 1, 0, 0, H_RootWindowOfScreen);
  XM_DEFINE_PROCEDURE(BlackPixelOfScreen, gxm_BlackPixelOfScreen_w, 1, 0, 0, H_BlackPixelOfScreen);
  XM_DEFINE_PROCEDURE(WhitePixelOfScreen, gxm_WhitePixelOfScreen_w, 1, 0, 0, H_WhitePixelOfScreen);
  XM_DEFINE_PROCEDURE(DefaultColormapOfScreen, gxm_DefaultColormapOfScreen_w, 1, 0, 0, H_DefaultColormapOfScreen);
  XM_DEFINE_PROCEDURE(DefaultDepthOfScreen, gxm_DefaultDepthOfScreen_w, 1, 0, 0, H_DefaultDepthOfScreen);
  XM_DEFINE_PROCEDURE(DefaultGCOfScreen, gxm_DefaultGCOfScreen_w, 1, 0, 0, H_DefaultGCOfScreen);
  XM_DEFINE_PROCEDURE(DefaultVisualOfScreen, gxm_DefaultVisualOfScreen_w, 1, 0, 0, H_DefaultVisualOfScreen);
  XM_DEFINE_PROCEDURE(WidthOfScreen, gxm_WidthOfScreen_w, 1, 0, 0, H_WidthOfScreen);
  XM_DEFINE_PROCEDURE(HeightOfScreen, gxm_HeightOfScreen_w, 1, 0, 0, H_HeightOfScreen);
  XM_DEFINE_PROCEDURE(WidthMMOfScreen, gxm_WidthMMOfScreen_w, 1, 0, 0, H_WidthMMOfScreen);
  XM_DEFINE_PROCEDURE(HeightMMOfScreen, gxm_HeightMMOfScreen_w, 1, 0, 0, H_HeightMMOfScreen);
  XM_DEFINE_PROCEDURE(PlanesOfScreen, gxm_PlanesOfScreen_w, 1, 0, 0, H_PlanesOfScreen);
  XM_DEFINE_PROCEDURE(CellsOfScreen, gxm_CellsOfScreen_w, 1, 0, 0, H_CellsOfScreen);
  XM_DEFINE_PROCEDURE(MinCmapsOfScreen, gxm_MinCmapsOfScreen_w, 1, 0, 0, H_MinCmapsOfScreen);
  XM_DEFINE_PROCEDURE(MaxCmapsOfScreen, gxm_MaxCmapsOfScreen_w, 1, 0, 0, H_MaxCmapsOfScreen);
  XM_DEFINE_PROCEDURE(DoesSaveUnders, gxm_DoesSaveUnders_w, 1, 0, 0, H_DoesSaveUnders);
  XM_DEFINE_PROCEDURE(DoesBackingStore, gxm_DoesBackingStore_w, 1, 0, 0, H_DoesBackingStore);
  XM_DEFINE_PROCEDURE(EventMaskOfScreen, gxm_EventMaskOfScreen_w, 1, 0, 0, H_EventMaskOfScreen);
  XM_DEFINE_PROCEDURE(RootWindow, gxm_RootWindow_w, 2, 0, 0, H_RootWindow);
  XM_DEFINE_PROCEDURE(DefaultVisual, gxm_DefaultVisual_w, 2, 0, 0, H_DefaultVisual);
  XM_DEFINE_PROCEDURE(DefaultGC, gxm_DefaultGC_w, 2, 0, 0, H_DefaultGC);
  XM_DEFINE_PROCEDURE(BlackPixel, gxm_BlackPixel_w, 2, 0, 0, H_BlackPixel);
  XM_DEFINE_PROCEDURE(WhitePixel, gxm_WhitePixel_w, 2, 0, 0, H_WhitePixel);
  XM_DEFINE_PROCEDURE(DisplayWidth, gxm_DisplayWidth_w, 2, 0, 0, H_DisplayWidth);
  XM_DEFINE_PROCEDURE(DisplayHeight, gxm_DisplayHeight_w, 2, 0, 0, H_DisplayHeight);
  XM_DEFINE_PROCEDURE(DisplayWidthMM, gxm_DisplayWidthMM_w, 2, 0, 0, H_DisplayWidthMM);
  XM_DEFINE_PROCEDURE(DisplayHeightMM, gxm_DisplayHeightMM_w, 2, 0, 0, H_DisplayHeightMM);
  XM_DEFINE_PROCEDURE(DisplayPlanes, gxm_DisplayPlanes_w, 2, 0, 0, H_DisplayPlanes);
  XM_DEFINE_PROCEDURE(DisplayCells, gxm_DisplayCells_w, 2, 0, 0, H_DisplayCells);
  XM_DEFINE_PROCEDURE(DefaultColormap, gxm_DefaultColormap_w, 2, 0, 0, H_DefaultColormap);
  XM_DEFINE_PROCEDURE(ScreenOfDisplay, gxm_ScreenOfDisplay_w, 2, 0, 0, H_ScreenOfDisplay);
  XM_DEFINE_PROCEDURE(DefaultDepth, gxm_DefaultDepth_w, 2, 0, 0, H_DefaultDepth);

  XM_DEFINE_PROCEDURE(IsKeypadKey, gxm_IsKeypadKey_w, 1, 0, 0, H_IsKeypadKey);
  XM_DEFINE_PROCEDURE(IsPrivateKeypadKey, gxm_IsPrivateKeypadKey_w, 1, 0, 0, H_IsPrivateKeypadKey);
  XM_DEFINE_PROCEDURE(IsCursorKey, gxm_IsCursorKey_w, 1, 0, 0, H_IsCursorKey);
  XM_DEFINE_PROCEDURE(IsPFKey, gxm_IsPFKey_w, 1, 0, 0, H_IsPFKey);
  XM_DEFINE_PROCEDURE(IsFunctionKey, gxm_IsFunctionKey_w, 1, 0, 0, H_IsFunctionKey);
  XM_DEFINE_PROCEDURE(IsMiscFunctionKey, gxm_IsMiscFunctionKey_w, 1, 0, 0, H_IsMiscFunctionKey);
  XM_DEFINE_PROCEDURE(IsModifierKey, gxm_IsModifierKey_w, 1, 0, 0, H_IsModifierKey);

  XM_DEFINE_PROCEDURE(XButtonEvent?, XEN_XButtonEvent_p_w, 1, 0, 0, "#t if arg is a XButtonEvent");
  XM_DEFINE_PROCEDURE(XCirculateEvent?, XEN_XCirculateEvent_p_w, 1, 0, 0, "#t if arg is a XCirculateEvent");
  XM_DEFINE_PROCEDURE(XCirculateRequestEvent?, XEN_XCirculateRequestEvent_p_w, 1, 0, 0, "#t if arg is a XCirculateRequestEvent");
  XM_DEFINE_PROCEDURE(XClientMessageEvent?, XEN_XClientMessageEvent_p_w, 1, 0, 0, "#t if arg is a XClientMessageEvent");
  XM_DEFINE_PROCEDURE(XColormapEvent?, XEN_XColormapEvent_p_w, 1, 0, 0, "#t if arg is a XColormapEvent");
  XM_DEFINE_PROCEDURE(XConfigureEvent?, XEN_XConfigureEvent_p_w, 1, 0, 0, "#t if arg is a XConfigureEvent");
  XM_DEFINE_PROCEDURE(XConfigureRequestEvent?, XEN_XConfigureRequestEvent_p_w, 1, 0, 0, "#t if arg is a XConfigureRequestEvent");
  XM_DEFINE_PROCEDURE(XCreateWindowEvent?, XEN_XCreateWindowEvent_p_w, 1, 0, 0, "#t if arg is a XCreateWindowEvent");
  XM_DEFINE_PROCEDURE(XCrossingEvent?, XEN_XCrossingEvent_p_w, 1, 0, 0, "#t if arg is a XCrossingEvent");
  XM_DEFINE_PROCEDURE(XDestroyWindowEvent?, XEN_XDestroyWindowEvent_p_w, 1, 0, 0, "#t if arg is a XDestroyWindowEvent");
  XM_DEFINE_PROCEDURE(XErrorEvent?, XEN_XErrorEvent_p_w, 1, 0, 0, "#t if arg is a XErrorEvent");
  XM_DEFINE_PROCEDURE(XExposeEvent?, XEN_XExposeEvent_p_w, 1, 0, 0, "#t if arg is a XExposeEvent");
  XM_DEFINE_PROCEDURE(XFocusChangeEvent?, XEN_XFocusChangeEvent_p_w, 1, 0, 0, "#t if arg is a XFocusChangeEvent");
  XM_DEFINE_PROCEDURE(XGraphicsExposeEvent?, XEN_XGraphicsExposeEvent_p_w, 1, 0, 0, "#t if arg is a XGraphicsExposeEvent");
  XM_DEFINE_PROCEDURE(XGravityEvent?, XEN_XGravityEvent_p_w, 1, 0, 0, "#t if arg is a XGravityEvent");
  XM_DEFINE_PROCEDURE(XKeyEvent?, XEN_XKeyEvent_p_w, 1, 0, 0, "#t if arg is a XKeyEvent");
  XM_DEFINE_PROCEDURE(XKeymapEvent?, XEN_XKeymapEvent_p_w, 1, 0, 0, "#t if arg is a XKeymapEvent");
  XM_DEFINE_PROCEDURE(XMapEvent?, XEN_XMapEvent_p_w, 1, 0, 0, "#t if arg is a XMapEvent");
  XM_DEFINE_PROCEDURE(XMapRequestEvent?, XEN_XMapRequestEvent_p_w, 1, 0, 0, "#t if arg is a XMapRequestEvent");
  XM_DEFINE_PROCEDURE(XMappingEvent?, XEN_XMappingEvent_p_w, 1, 0, 0, "#t if arg is a XMappingEvent");
  XM_DEFINE_PROCEDURE(XMotionEvent?, XEN_XMotionEvent_p_w, 1, 0, 0, "#t if arg is a XMotionEvent");
  XM_DEFINE_PROCEDURE(XNoExposeEvent?, XEN_XNoExposeEvent_p_w, 1, 0, 0, "#t if arg is a XNoExposeEvent");
  XM_DEFINE_PROCEDURE(XPropertyEvent?, XEN_XPropertyEvent_p_w, 1, 0, 0, "#t if arg is a XPropertyEvent");
  XM_DEFINE_PROCEDURE(XReparentEvent?, XEN_XReparentEvent_p_w, 1, 0, 0, "#t if arg is a XReparentEvent");
  XM_DEFINE_PROCEDURE(XResizeRequestEvent?, XEN_XResizeRequestEvent_p_w, 1, 0, 0, "#t if arg is a XResizeRequestEvent");
  XM_DEFINE_PROCEDURE(XSelectionClearEvent?, XEN_XSelectionClearEvent_p_w, 1, 0, 0, "#t if arg is a XSelectionClearEvent");
  XM_DEFINE_PROCEDURE(XSelectionEvent?, XEN_XSelectionEvent_p_w, 1, 0, 0, "#t if arg is a XSelectionEvent");
  XM_DEFINE_PROCEDURE(XSelectionRequestEvent?, XEN_XSelectionRequestEvent_p_w, 1, 0, 0, "#t if arg is a XSelectionRequestEvent");
  XM_DEFINE_PROCEDURE(XSetWindowAttributes?, XEN_XSetWindowAttributes_p_w, 1, 0, 0, "#t if arg is a XSetWindowAttributes");
  XM_DEFINE_PROCEDURE(XUnmapEvent?, XEN_XUnmapEvent_p_w, 1, 0, 0, "#t if arg is a XUnmapEvent");
  XM_DEFINE_PROCEDURE(XVisibilityEvent?, XEN_XVisibilityEvent_p_w, 1, 0, 0, "#t if arg is a XVisibilityEvent");
  XM_DEFINE_PROCEDURE(XIconSize?, XEN_XIconSize_p_w, 1, 0, 0, "#t if arg is a XIconSize object");

#if HAVE_MOTIF
  XM_DEFINE_PROCEDURE(XmCreateMessageBox, gxm_XmCreateMessageBox_w, 3, 1, 0, H_XmCreateMessageBox);
  XM_DEFINE_PROCEDURE(XmCreateMessageDialog, gxm_XmCreateMessageDialog_w, 3, 1, 0, H_XmCreateMessageDialog);
  XM_DEFINE_PROCEDURE(XmCreateErrorDialog, gxm_XmCreateErrorDialog_w, 3, 1, 0, H_XmCreateErrorDialog);
  XM_DEFINE_PROCEDURE(XmCreateInformationDialog, gxm_XmCreateInformationDialog_w, 3, 1, 0, H_XmCreateInformationDialog);
  XM_DEFINE_PROCEDURE(XmCreateQuestionDialog, gxm_XmCreateQuestionDialog_w, 3, 1, 0, H_XmCreateQuestionDialog);
  XM_DEFINE_PROCEDURE(XmCreateWarningDialog, gxm_XmCreateWarningDialog_w, 3, 1, 0, H_XmCreateWarningDialog);
  XM_DEFINE_PROCEDURE(XmCreateWorkingDialog, gxm_XmCreateWorkingDialog_w, 3, 1, 0, H_XmCreateWorkingDialog);
  XM_DEFINE_PROCEDURE(XmCreateTemplateDialog, gxm_XmCreateTemplateDialog_w, 3, 1, 0, H_XmCreateTemplateDialog);
  XM_DEFINE_PROCEDURE(XmMessageBoxGetChild, gxm_XmMessageBoxGetChild_w, 2, 0, 0, H_XmMessageBoxGetChild);
  XM_DEFINE_PROCEDURE(XmCreateArrowButtonGadget, gxm_XmCreateArrowButtonGadget_w, 3, 1, 0, H_XmCreateArrowButtonGadget);
  XM_DEFINE_PROCEDURE(XmCreateArrowButton, gxm_XmCreateArrowButton_w, 3, 1, 0, H_XmCreateArrowButton);
#if HAVE_XmCreateFontSelector
  XM_DEFINE_PROCEDURE(XmCreateFontSelector, gxm_XmCreateFontSelector_w, 3, 1, 0, H_XmCreateFontSelector);
#endif
#if HAVE_XmCreateColorSelector
  XM_DEFINE_PROCEDURE(XmCreateColorSelector, gxm_XmCreateColorSelector_w, 3, 1, 0, H_XmCreateColorSelector);
#endif
#if HAVE_XmToolTipGetLabel
  XM_DEFINE_PROCEDURE(XmToolTipGetLabel, gxm_XmToolTipGetLabel_w, 1, 0, 0, H_XmToolTipGetLabel);
#endif
  XM_DEFINE_PROCEDURE(XmCreateNotebook, gxm_XmCreateNotebook_w, 3, 1, 0, H_XmCreateNotebook);
  XM_DEFINE_PROCEDURE(XmNotebookGetPageInfo, gxm_XmNotebookGetPageInfo_w, 2, 0, 0, H_XmNotebookGetPageInfo);
#if HAVE_XM_XP
  XM_DEFINE_PROCEDURE(XmPrintSetup, gxm_XmPrintSetup_w, 4, 1, 0, H_XmPrintSetup);
  XM_DEFINE_PROCEDURE(XmPrintToFile, gxm_XmPrintToFile_w, 4, 0, 0, H_XmPrintToFile);
  XM_DEFINE_PROCEDURE(XmPrintPopupPDM, gxm_XmPrintPopupPDM_w, 2, 0, 0, H_XmPrintPopupPDM);
  XM_DEFINE_PROCEDURE(XmRedisplayWidget, gxm_XmRedisplayWidget_w, 1, 0, 0, H_XmRedisplayWidget);
#endif
  XM_DEFINE_PROCEDURE(XmTransferSetParameters, gxm_XmTransferSetParameters_w, 5, 0, 0, H_XmTransferSetParameters);
  XM_DEFINE_PROCEDURE(XmTransferDone, gxm_XmTransferDone_w, 2, 0, 0, H_XmTransferDone);
  XM_DEFINE_PROCEDURE(XmTransferValue, gxm_XmTransferValue_w, 5, 0, 0, H_XmTransferValue);
  XM_DEFINE_PROCEDURE(XmTransferStartRequest, gxm_XmTransferStartRequest_w, 1, 0, 0, H_XmTransferStartRequest);
  XM_DEFINE_PROCEDURE(XmTransferSendRequest, gxm_XmTransferSendRequest_w, 2, 0, 0, H_XmTransferSendRequest);
  XM_DEFINE_PROCEDURE(XmCreateComboBox, gxm_XmCreateComboBox_w, 3, 1, 0, H_XmCreateComboBox);
  XM_DEFINE_PROCEDURE(XmCreateDropDownComboBox, gxm_XmCreateDropDownComboBox_w, 3, 1, 0, H_XmCreateDropDownComboBox);
  XM_DEFINE_PROCEDURE(XmCreateDropDownList, gxm_XmCreateDropDownList_w, 3, 1, 0, H_XmCreateDropDownList);
  XM_DEFINE_PROCEDURE(XmComboBoxAddItem, gxm_XmComboBoxAddItem_w, 4, 0, 0, H_XmComboBoxAddItem);
  XM_DEFINE_PROCEDURE(XmComboBoxDeletePos, gxm_XmComboBoxDeletePos_w, 2, 0, 0, H_XmComboBoxDeletePos);
  XM_DEFINE_PROCEDURE(XmComboBoxSelectItem, gxm_XmComboBoxSelectItem_w, 2, 0, 0, H_XmComboBoxSelectItem);
  XM_DEFINE_PROCEDURE(XmComboBoxSetItem, gxm_XmComboBoxSetItem_w, 2, 0, 0, H_XmComboBoxSetItem);
  XM_DEFINE_PROCEDURE(XmComboBoxUpdate, gxm_XmComboBoxUpdate_w, 1, 0, 0, H_XmComboBoxUpdate);
  XM_DEFINE_PROCEDURE(XmCreateContainer, gxm_XmCreateContainer_w, 3, 1, 0, H_XmCreateContainer);
  XM_DEFINE_PROCEDURE(XmContainerGetItemChildren, gxm_XmContainerGetItemChildren_w, 2, 0, 0, H_XmContainerGetItemChildren);
  XM_DEFINE_PROCEDURE(XmContainerRelayout, gxm_XmContainerRelayout_w, 1, 0, 0, H_XmContainerRelayout);
  XM_DEFINE_PROCEDURE(XmContainerReorder, gxm_XmContainerReorder_w, 3, 0, 0, H_XmContainerReorder);
  XM_DEFINE_PROCEDURE(XmContainerCut, gxm_XmContainerCut_w, 2, 0, 0, H_XmContainerCut);
  XM_DEFINE_PROCEDURE(XmContainerCopy, gxm_XmContainerCopy_w, 2, 0, 0, H_XmContainerCopy);
  XM_DEFINE_PROCEDURE(XmContainerPaste, gxm_XmContainerPaste_w, 1, 0, 0, H_XmContainerPaste);
  XM_DEFINE_PROCEDURE(XmContainerCopyLink, gxm_XmContainerCopyLink_w, 2, 0, 0, H_XmContainerCopyLink);
  XM_DEFINE_PROCEDURE(XmContainerPasteLink, gxm_XmContainerPasteLink_w, 1, 0, 0, H_XmContainerPasteLink);
  XM_DEFINE_PROCEDURE(XmCreateSpinBox, gxm_XmCreateSpinBox_w, 3, 1, 0, H_XmCreateSpinBox);
  XM_DEFINE_PROCEDURE(XmSpinBoxValidatePosition, gxm_XmSpinBoxValidatePosition_w, 1, 0, 0, H_XmSpinBoxValidatePosition);
  XM_DEFINE_PROCEDURE(XmCreateSimpleSpinBox, gxm_XmCreateSimpleSpinBox_w, 3, 1, 0, H_XmCreateSimpleSpinBox);
  XM_DEFINE_PROCEDURE(XmSimpleSpinBoxAddItem, gxm_XmSimpleSpinBoxAddItem_w, 3, 0, 0, H_XmSimpleSpinBoxAddItem);
  XM_DEFINE_PROCEDURE(XmSimpleSpinBoxDeletePos, gxm_XmSimpleSpinBoxDeletePos_w, 2, 0, 0, H_XmSimpleSpinBoxDeletePos);
  XM_DEFINE_PROCEDURE(XmSimpleSpinBoxSetItem, gxm_XmSimpleSpinBoxSetItem_w, 2, 0, 0, H_XmSimpleSpinBoxSetItem);
  XM_DEFINE_PROCEDURE(XmDropSiteRegistered, gxm_XmDropSiteRegistered_w, 1, 0, 0, H_XmDropSiteRegistered);
  XM_DEFINE_PROCEDURE(XmTextFieldCopyLink, gxm_XmTextFieldCopyLink_w, 2, 0, 0, H_XmTextFieldCopyLink);
  XM_DEFINE_PROCEDURE(XmTextFieldPasteLink, gxm_XmTextFieldPasteLink_w, 1, 0, 0, H_XmTextFieldPasteLink);
  XM_DEFINE_PROCEDURE(XmTextGetCenterline, gxm_XmTextGetCenterline_w, 1, 0, 0, H_XmTextGetCenterline);
  XM_DEFINE_PROCEDURE(XmToggleButtonGadgetSetValue, gxm_XmToggleButtonGadgetSetValue_w, 3, 0, 0, H_XmToggleButtonGadgetSetValue);
  XM_DEFINE_PROCEDURE(XmCreateIconGadget, gxm_XmCreateIconGadget_w, 3, 1, 0, H_XmCreateIconGadget);
  XM_DEFINE_PROCEDURE(XmCreateIconHeader, gxm_XmCreateIconHeader_w, 3, 1, 0, H_XmCreateIconHeader);
  XM_DEFINE_PROCEDURE(XmObjectAtPoint, gxm_XmObjectAtPoint_w, 3, 0, 0, H_XmObjectAtPoint);
  XM_DEFINE_PROCEDURE(XmConvertStringToUnits, gxm_XmConvertStringToUnits_w, 4, 0, 0, H_XmConvertStringToUnits);
  XM_DEFINE_PROCEDURE(XmCreateGrabShell, gxm_XmCreateGrabShell_w, 3, 1, 0, H_XmCreateGrabShell);
  XM_DEFINE_PROCEDURE(XmToggleButtonSetValue, gxm_XmToggleButtonSetValue_w, 3, 0, 0, H_XmToggleButtonSetValue);
  XM_DEFINE_PROCEDURE(XmTextPasteLink, gxm_XmTextPasteLink_w, 1, 0, 0, H_XmTextPasteLink);
  XM_DEFINE_PROCEDURE(XmTextCopyLink, gxm_XmTextCopyLink_w, 2, 0, 0, H_XmTextCopyLink);
  XM_DEFINE_PROCEDURE(XmScaleSetTicks, gxm_XmScaleSetTicks_w, 7, 0, 0, H_XmScaleSetTicks);
  XM_DEFINE_PROCEDURE(XmInternAtom, gxm_XmInternAtom_w, 3, 0, 0, H_XmInternAtom);
  XM_DEFINE_PROCEDURE(XmGetAtomName, gxm_XmGetAtomName_w, 2, 0, 0, H_XmGetAtomName);
  XM_DEFINE_PROCEDURE(XmCreatePanedWindow, gxm_XmCreatePanedWindow_w, 3, 1, 0, H_XmCreatePanedWindow);
  XM_DEFINE_PROCEDURE(XmCreateBulletinBoard, gxm_XmCreateBulletinBoard_w, 3, 1, 0, H_XmCreateBulletinBoard);
  XM_DEFINE_PROCEDURE(XmCreateBulletinBoardDialog, gxm_XmCreateBulletinBoardDialog_w, 3, 1, 0, H_XmCreateBulletinBoardDialog);
  XM_DEFINE_PROCEDURE(XmCreateCascadeButtonGadget, gxm_XmCreateCascadeButtonGadget_w, 3, 1, 0, H_XmCreateCascadeButtonGadget);
  XM_DEFINE_PROCEDURE(XmCascadeButtonGadgetHighlight, gxm_XmCascadeButtonGadgetHighlight_w, 2, 0, 0, H_XmCascadeButtonGadgetHighlight);
  XM_DEFINE_PROCEDURE(XmAddProtocols, gxm_XmAddProtocols_w, 3, 1, 0, H_XmAddProtocols);
  XM_DEFINE_PROCEDURE(XmRemoveProtocols, gxm_XmRemoveProtocols_w, 3, 1, 0, H_XmRemoveProtocols);
  XM_DEFINE_PROCEDURE(XmAddProtocolCallback, gxm_XmAddProtocolCallback_w, 5, 0, 0, H_XmAddProtocolCallback);
  XM_DEFINE_PROCEDURE(XmRemoveProtocolCallback, gxm_XmRemoveProtocolCallback_w, 5, 0, 0, H_XmRemoveProtocolCallback);
  XM_DEFINE_PROCEDURE(XmActivateProtocol, gxm_XmActivateProtocol_w, 3, 0, 0, H_XmActivateProtocol);
  XM_DEFINE_PROCEDURE(XmDeactivateProtocol, gxm_XmDeactivateProtocol_w, 3, 0, 0, H_XmDeactivateProtocol);
  XM_DEFINE_PROCEDURE(XmSetProtocolHooks, gxm_XmSetProtocolHooks_w, 7, 0, 0, H_XmSetProtocolHooks);
  XM_DEFINE_PROCEDURE(XmCreateCascadeButton, gxm_XmCreateCascadeButton_w, 3, 1, 0, H_XmCreateCascadeButton);
  XM_DEFINE_PROCEDURE(XmCascadeButtonHighlight, gxm_XmCascadeButtonHighlight_w, 2, 0, 0, H_XmCascadeButtonHighlight);
  XM_DEFINE_PROCEDURE(XmCreatePushButtonGadget, gxm_XmCreatePushButtonGadget_w, 3, 1, 0, H_XmCreatePushButtonGadget);
  XM_DEFINE_PROCEDURE(XmCreatePushButton, gxm_XmCreatePushButton_w, 3, 1, 0, H_XmCreatePushButton);
  XM_DEFINE_PROCEDURE(XmCreateCommand, gxm_XmCreateCommand_w, 3, 1, 0, H_XmCreateCommand);
  XM_DEFINE_PROCEDURE(XmCommandGetChild, gxm_XmCommandGetChild_w, 2, 0, 0, H_XmCommandGetChild);
  XM_DEFINE_PROCEDURE(XmCommandSetValue, gxm_XmCommandSetValue_w, 2, 0, 0, H_XmCommandSetValue);
  XM_DEFINE_PROCEDURE(XmCommandAppendValue, gxm_XmCommandAppendValue_w, 2, 0, 0, H_XmCommandAppendValue);
  XM_DEFINE_PROCEDURE(XmCommandError, gxm_XmCommandError_w, 2, 0, 0, H_XmCommandError);
  XM_DEFINE_PROCEDURE(XmCreateCommandDialog, gxm_XmCreateCommandDialog_w, 3, 1, 0, H_XmCreateCommandDialog);
  XM_DEFINE_PROCEDURE(XmMenuPosition, gxm_XmMenuPosition_w, 2, 0, 0, H_XmMenuPosition);
  XM_DEFINE_PROCEDURE(XmCreateRowColumn, gxm_XmCreateRowColumn_w, 3, 1, 0, H_XmCreateRowColumn);
  XM_DEFINE_PROCEDURE(XmCreateWorkArea, gxm_XmCreateWorkArea_w, 3, 1, 0, H_XmCreateWorkArea);
  XM_DEFINE_PROCEDURE(XmCreateRadioBox, gxm_XmCreateRadioBox_w, 3, 1, 0, H_XmCreateRadioBox);
  XM_DEFINE_PROCEDURE(XmCreateOptionMenu, gxm_XmCreateOptionMenu_w, 3, 1, 0, H_XmCreateOptionMenu);
  XM_DEFINE_PROCEDURE(XmOptionLabelGadget, gxm_XmOptionLabelGadget_w, 1, 0, 0, H_XmOptionLabelGadget);
  XM_DEFINE_PROCEDURE(XmOptionButtonGadget, gxm_XmOptionButtonGadget_w, 1, 0, 0, H_XmOptionButtonGadget);
  XM_DEFINE_PROCEDURE(XmCreateMenuBar, gxm_XmCreateMenuBar_w, 3, 1, 0, H_XmCreateMenuBar);
  XM_DEFINE_PROCEDURE(XmCreatePopupMenu, gxm_XmCreatePopupMenu_w, 3, 1, 0, H_XmCreatePopupMenu);
  XM_DEFINE_PROCEDURE(XmCreatePulldownMenu, gxm_XmCreatePulldownMenu_w, 3, 1, 0, H_XmCreatePulldownMenu);
  XM_DEFINE_PROCEDURE(XmGetPostedFromWidget, gxm_XmGetPostedFromWidget_w, 1, 0, 0, H_XmGetPostedFromWidget);
  XM_DEFINE_PROCEDURE(XmGetTearOffControl, gxm_XmGetTearOffControl_w, 1, 0, 0, H_XmGetTearOffControl);
#if (!XM_DISABLE_DEPRECATED)
  XM_DEFINE_PROCEDURE(XmAddToPostFromList, gxm_XmAddToPostFromList_w, 2, 0, 0, H_XmAddToPostFromList);
  XM_DEFINE_PROCEDURE(XmRemoveFromPostFromList, gxm_XmRemoveFromPostFromList_w, 2, 0, 0, H_XmRemoveFromPostFromList);
#endif
  XM_DEFINE_PROCEDURE(XmScaleSetValue, gxm_XmScaleSetValue_w, 2, 0, 0, H_XmScaleSetValue);
  XM_DEFINE_PROCEDURE(XmScaleGetValue, gxm_XmScaleGetValue_w, 1, 0, 0, H_XmScaleGetValue);
  XM_DEFINE_PROCEDURE(XmCreateScale, gxm_XmCreateScale_w, 3, 1, 0, H_XmCreateScale);
  XM_DEFINE_PROCEDURE(XmClipboardBeginCopy, gxm_XmClipboardBeginCopy_w, 5, 0, 0, H_XmClipboardBeginCopy);
  XM_DEFINE_PROCEDURE(XmWidgetGetDisplayRect, gxm_XmWidgetGetDisplayRect_w, 1, 0, 0, H_XmWidgetGetDisplayRect);
  XM_DEFINE_PROCEDURE(XmClipboardStartCopy, gxm_XmClipboardStartCopy_w, 6, 0, 0, H_XmClipboardStartCopy);
  XM_DEFINE_PROCEDURE(XmClipboardCopy, gxm_XmClipboardCopy_w, 7, 0, 0, H_XmClipboardCopy);
  XM_DEFINE_PROCEDURE(XmClipboardEndCopy, gxm_XmClipboardEndCopy_w, 3, 0, 0, H_XmClipboardEndCopy);
  XM_DEFINE_PROCEDURE(XmClipboardCancelCopy, gxm_XmClipboardCancelCopy_w, 3, 0, 0, H_XmClipboardCancelCopy);
  XM_DEFINE_PROCEDURE(XmClipboardWithdrawFormat, gxm_XmClipboardWithdrawFormat_w, 3, 0, 0, H_XmClipboardWithdrawFormat);
  XM_DEFINE_PROCEDURE(XmClipboardCopyByName, gxm_XmClipboardCopyByName_w, 6, 0, 0, H_XmClipboardCopyByName);
  XM_DEFINE_PROCEDURE(XmClipboardUndoCopy, gxm_XmClipboardUndoCopy_w, 2, 0, 0, H_XmClipboardUndoCopy);
  XM_DEFINE_PROCEDURE(XmClipboardLock, gxm_XmClipboardLock_w, 2, 0, 0, H_XmClipboardLock);
  XM_DEFINE_PROCEDURE(XmClipboardUnlock, gxm_XmClipboardUnlock_w, 3, 0, 0, H_XmClipboardUnlock);
  XM_DEFINE_PROCEDURE(XmClipboardStartRetrieve, gxm_XmClipboardStartRetrieve_w, 3, 0, 0, H_XmClipboardStartRetrieve);
  XM_DEFINE_PROCEDURE(XmClipboardEndRetrieve, gxm_XmClipboardEndRetrieve_w, 2, 0, 0, H_XmClipboardEndRetrieve);
  XM_DEFINE_PROCEDURE(XmClipboardRetrieve, gxm_XmClipboardRetrieve_w, 4, 0, 0, H_XmClipboardRetrieve);
  XM_DEFINE_PROCEDURE(XmClipboardInquireCount, gxm_XmClipboardInquireCount_w, 2, 0, 0, H_XmClipboardInquireCount);
  XM_DEFINE_PROCEDURE(XmClipboardInquireFormat, gxm_XmClipboardInquireFormat_w, 4, 0, 0, H_XmClipboardInquireFormat);
  XM_DEFINE_PROCEDURE(XmClipboardInquireLength, gxm_XmClipboardInquireLength_w, 3, 0, 0, H_XmClipboardInquireLength);
  XM_DEFINE_PROCEDURE(XmClipboardInquirePendingItems, gxm_XmClipboardInquirePendingItems_w, 3, 0, 0, H_XmClipboardInquirePendingItems);
  XM_DEFINE_PROCEDURE(XmClipboardRegisterFormat, gxm_XmClipboardRegisterFormat_w, 3, 0, 0, H_XmClipboardRegisterFormat);
  XM_DEFINE_PROCEDURE(XmGetXmScreen, gxm_XmGetXmScreen_w, 1, 0, 0, H_XmGetXmScreen);
  XM_DEFINE_PROCEDURE(XmCreateScrollBar, gxm_XmCreateScrollBar_w, 3, 1, 0, H_XmCreateScrollBar);
  XM_DEFINE_PROCEDURE(XmScrollBarGetValues, gxm_XmScrollBarGetValues_w, 1, 0, 0, H_XmScrollBarGetValues);
  XM_DEFINE_PROCEDURE(XmScrollBarSetValues, gxm_XmScrollBarSetValues_w, 6, 0, 0, H_XmScrollBarSetValues);
  XM_DEFINE_PROCEDURE(XmCreateDialogShell, gxm_XmCreateDialogShell_w, 3, 1, 0, H_XmCreateDialogShell);
  XM_DEFINE_PROCEDURE(XmCreateScrolledWindow, gxm_XmCreateScrolledWindow_w, 3, 1, 0, H_XmCreateScrolledWindow);
  XM_DEFINE_PROCEDURE(XmScrollVisible, gxm_XmScrollVisible_w, 4, 0, 0, H_XmScrollVisible);
  XM_DEFINE_PROCEDURE(XmGetDragContext, gxm_XmGetDragContext_w, 2, 0, 0, H_XmGetDragContext);
  XM_DEFINE_PROCEDURE(XmGetXmDisplay, gxm_XmGetXmDisplay_w, 1, 0, 0, H_XmGetXmDisplay);
  XM_DEFINE_PROCEDURE(XmSelectionBoxGetChild, gxm_XmSelectionBoxGetChild_w, 2, 0, 0, H_XmSelectionBoxGetChild);
  XM_DEFINE_PROCEDURE(XmCreateSelectionBox, gxm_XmCreateSelectionBox_w, 3, 1, 0, H_XmCreateSelectionBox);
  XM_DEFINE_PROCEDURE(XmCreateSelectionDialog, gxm_XmCreateSelectionDialog_w, 3, 1, 0, H_XmCreateSelectionDialog);
  XM_DEFINE_PROCEDURE(XmCreatePromptDialog, gxm_XmCreatePromptDialog_w, 3, 1, 0, H_XmCreatePromptDialog);
  XM_DEFINE_PROCEDURE(XmDragStart, gxm_XmDragStart_w, 3, 1, 0, H_XmDragStart);
  XM_DEFINE_PROCEDURE(XmDragCancel, gxm_XmDragCancel_w, 1, 0, 0, H_XmDragCancel);
  XM_DEFINE_PROCEDURE(XmTargetsAreCompatible, gxm_XmTargetsAreCompatible_w, 5, 0, 0, H_XmTargetsAreCompatible);
  XM_DEFINE_PROCEDURE(XmCreateSeparatorGadget, gxm_XmCreateSeparatorGadget_w, 3, 1, 0, H_XmCreateSeparatorGadget);
  XM_DEFINE_PROCEDURE(XmCreateDragIcon, gxm_XmCreateDragIcon_w, 3, 1, 0, H_XmCreateDragIcon);
  XM_DEFINE_PROCEDURE(XmCreateSeparator, gxm_XmCreateSeparator_w, 3, 1, 0, H_XmCreateSeparator);
  XM_DEFINE_PROCEDURE(XmCreateDrawingArea, gxm_XmCreateDrawingArea_w, 3, 1, 0, H_XmCreateDrawingArea);
  XM_DEFINE_PROCEDURE(XmCreateDrawnButton, gxm_XmCreateDrawnButton_w, 3, 1, 0, H_XmCreateDrawnButton);
  XM_DEFINE_PROCEDURE(XmDropSiteRegister, gxm_XmDropSiteRegister_w, 2, 1, 0, H_XmDropSiteRegister);
  XM_DEFINE_PROCEDURE(XmDropSiteUnregister, gxm_XmDropSiteUnregister_w, 1, 0, 0, H_XmDropSiteUnregister);
  XM_DEFINE_PROCEDURE(XmDropSiteStartUpdate, gxm_XmDropSiteStartUpdate_w, 1, 0, 0, H_XmDropSiteStartUpdate);
  XM_DEFINE_PROCEDURE(XmDropSiteUpdate, gxm_XmDropSiteUpdate_w, 2, 1, 0, H_XmDropSiteUpdate);
  XM_DEFINE_PROCEDURE(XmDropSiteEndUpdate, gxm_XmDropSiteEndUpdate_w, 1, 0, 0, H_XmDropSiteEndUpdate);
  XM_DEFINE_PROCEDURE(XmDropSiteRetrieve, gxm_XmDropSiteRetrieve_w, 2, 1, 0, H_XmDropSiteRetrieve);
  XM_DEFINE_PROCEDURE(XmDropSiteQueryStackingOrder, gxm_XmDropSiteQueryStackingOrder_w, 1, 0, 0, H_XmDropSiteQueryStackingOrder);
  XM_DEFINE_PROCEDURE(XmDropSiteConfigureStackingOrder, gxm_XmDropSiteConfigureStackingOrder_w, 3, 0, 0, H_XmDropSiteConfigureStackingOrder);
  XM_DEFINE_PROCEDURE(XmDropTransferStart, gxm_XmDropTransferStart_w, 2, 1, 0, H_XmDropTransferStart);
  XM_DEFINE_PROCEDURE(XmDropTransferAdd, gxm_XmDropTransferAdd_w, 2, 0, 0, H_XmDropTransferAdd);
  XM_DEFINE_PROCEDURE(XmTextFieldGetString, gxm_XmTextFieldGetString_w, 1, 0, 0, H_XmTextFieldGetString);
  XM_DEFINE_PROCEDURE(XmTextFieldGetSubstring, gxm_XmTextFieldGetSubstring_w, 3, 0, 0, H_XmTextFieldGetSubstring);
  XM_DEFINE_PROCEDURE(XmTextFieldGetLastPosition, gxm_XmTextFieldGetLastPosition_w, 1, 0, 0, H_XmTextFieldGetLastPosition);
  XM_DEFINE_PROCEDURE(XmTextFieldSetString, gxm_XmTextFieldSetString_w, 2, 0, 0, H_XmTextFieldSetString);
  XM_DEFINE_PROCEDURE(XmTextFieldReplace, gxm_XmTextFieldReplace_w, 4, 0, 0, H_XmTextFieldReplace);
  XM_DEFINE_PROCEDURE(XmTextFieldInsert, gxm_XmTextFieldInsert_w, 3, 0, 0, H_XmTextFieldInsert);
  XM_DEFINE_PROCEDURE(XmTextFieldSetAddMode, gxm_XmTextFieldSetAddMode_w, 2, 0, 0, H_XmTextFieldSetAddMode);
  XM_DEFINE_PROCEDURE(XmTextFieldGetAddMode, gxm_XmTextFieldGetAddMode_w, 1, 0, 0, H_XmTextFieldGetAddMode);
  XM_DEFINE_PROCEDURE(XmTextFieldGetEditable, gxm_XmTextFieldGetEditable_w, 1, 0, 0, H_XmTextFieldGetEditable);
  XM_DEFINE_PROCEDURE(XmTextFieldSetEditable, gxm_XmTextFieldSetEditable_w, 2, 0, 0, H_XmTextFieldSetEditable);
  XM_DEFINE_PROCEDURE(XmTextFieldGetMaxLength, gxm_XmTextFieldGetMaxLength_w, 1, 0, 0, H_XmTextFieldGetMaxLength);
  XM_DEFINE_PROCEDURE(XmTextFieldSetMaxLength, gxm_XmTextFieldSetMaxLength_w, 2, 0, 0, H_XmTextFieldSetMaxLength);
  XM_DEFINE_PROCEDURE(XmTextFieldGetCursorPosition, gxm_XmTextFieldGetCursorPosition_w, 1, 0, 0, H_XmTextFieldGetCursorPosition);
  XM_DEFINE_PROCEDURE(XmTextFieldGetInsertionPosition, gxm_XmTextFieldGetInsertionPosition_w, 1, 0, 0, H_XmTextFieldGetInsertionPosition);
  XM_DEFINE_PROCEDURE(XmTextFieldSetCursorPosition, gxm_XmTextFieldSetCursorPosition_w, 2, 0, 0, H_XmTextFieldSetCursorPosition);
  XM_DEFINE_PROCEDURE(XmTextFieldSetInsertionPosition, gxm_XmTextFieldSetInsertionPosition_w, 2, 0, 0, H_XmTextFieldSetInsertionPosition);
  XM_DEFINE_PROCEDURE(XmTextFieldGetSelectionPosition, gxm_XmTextFieldGetSelectionPosition_w, 1, 0, 0, H_XmTextFieldGetSelectionPosition);
  XM_DEFINE_PROCEDURE(XmTextFieldGetSelection, gxm_XmTextFieldGetSelection_w, 1, 0, 0, H_XmTextFieldGetSelection);
  XM_DEFINE_PROCEDURE(XmTextFieldRemove, gxm_XmTextFieldRemove_w, 1, 0, 0, H_XmTextFieldRemove);
  XM_DEFINE_PROCEDURE(XmTextFieldCopy, gxm_XmTextFieldCopy_w, 2, 0, 0, H_XmTextFieldCopy);
  XM_DEFINE_PROCEDURE(XmTextFieldCut, gxm_XmTextFieldCut_w, 2, 0, 0, H_XmTextFieldCut);
  XM_DEFINE_PROCEDURE(XmTextFieldPaste, gxm_XmTextFieldPaste_w, 1, 0, 0, H_XmTextFieldPaste);
  XM_DEFINE_PROCEDURE(XmTextFieldClearSelection, gxm_XmTextFieldClearSelection_w, 2, 0, 0, H_XmTextFieldClearSelection);
  XM_DEFINE_PROCEDURE(XmTextFieldSetSelection, gxm_XmTextFieldSetSelection_w, 4, 0, 0, H_XmTextFieldSetSelection);
  XM_DEFINE_PROCEDURE(XmTextFieldXYToPos, gxm_XmTextFieldXYToPos_w, 3, 0, 0, H_XmTextFieldXYToPos);
  XM_DEFINE_PROCEDURE(XmTextFieldPosToXY, gxm_XmTextFieldPosToXY_w, 2, 0, 0, H_XmTextFieldPosToXY);
  XM_DEFINE_PROCEDURE(XmTextFieldShowPosition, gxm_XmTextFieldShowPosition_w, 2, 0, 0, H_XmTextFieldShowPosition);
  XM_DEFINE_PROCEDURE(XmTextFieldSetHighlight, gxm_XmTextFieldSetHighlight_w, 4, 0, 0, H_XmTextFieldSetHighlight);
  XM_DEFINE_PROCEDURE(XmTextFieldGetBaseline, gxm_XmTextFieldGetBaseline_w, 1, 0, 0, H_XmTextFieldGetBaseline);
  XM_DEFINE_PROCEDURE(XmCreateTextField, gxm_XmCreateTextField_w, 3, 1, 0, H_XmCreateTextField);
  XM_DEFINE_PROCEDURE(XmFileSelectionBoxGetChild, gxm_XmFileSelectionBoxGetChild_w, 2, 0, 0, H_XmFileSelectionBoxGetChild);
  XM_DEFINE_PROCEDURE(XmFileSelectionDoSearch, gxm_XmFileSelectionDoSearch_w, 2, 0, 0, H_XmFileSelectionDoSearch);
  XM_DEFINE_PROCEDURE(XmCreateFileSelectionBox, gxm_XmCreateFileSelectionBox_w, 3, 1, 0, H_XmCreateFileSelectionBox);
  XM_DEFINE_PROCEDURE(XmCreateFileSelectionDialog, gxm_XmCreateFileSelectionDialog_w, 3, 1, 0, H_XmCreateFileSelectionDialog);
  XM_DEFINE_PROCEDURE(XmTextSetHighlight, gxm_XmTextSetHighlight_w, 4, 0, 0, H_XmTextSetHighlight);
  XM_DEFINE_PROCEDURE(XmCreateScrolledText, gxm_XmCreateScrolledText_w, 3, 1, 0, H_XmCreateScrolledText);
  XM_DEFINE_PROCEDURE(XmCreateText, gxm_XmCreateText_w, 3, 1, 0, H_XmCreateText);
  XM_DEFINE_PROCEDURE(XmTextGetSubstring, gxm_XmTextGetSubstring_w, 3, 0, 0, H_XmTextGetSubstring);
  XM_DEFINE_PROCEDURE(XmTextGetString, gxm_XmTextGetString_w, 1, 0, 0, H_XmTextGetString);
  XM_DEFINE_PROCEDURE(XmTextGetLastPosition, gxm_XmTextGetLastPosition_w, 1, 0, 0, H_XmTextGetLastPosition);
  XM_DEFINE_PROCEDURE(XmTextSetString, gxm_XmTextSetString_w, 2, 0, 0, H_XmTextSetString);
  XM_DEFINE_PROCEDURE(XmTextReplace, gxm_XmTextReplace_w, 4, 0, 0, H_XmTextReplace);
  XM_DEFINE_PROCEDURE(XmTextInsert, gxm_XmTextInsert_w, 3, 0, 0, H_XmTextInsert);
  XM_DEFINE_PROCEDURE(XmTextSetAddMode, gxm_XmTextSetAddMode_w, 2, 0, 0, H_XmTextSetAddMode);
  XM_DEFINE_PROCEDURE(XmTextGetAddMode, gxm_XmTextGetAddMode_w, 1, 0, 0, H_XmTextGetAddMode);
  XM_DEFINE_PROCEDURE(XmTextGetEditable, gxm_XmTextGetEditable_w, 1, 0, 0, H_XmTextGetEditable);
  XM_DEFINE_PROCEDURE(XmTextSetEditable, gxm_XmTextSetEditable_w, 2, 0, 0, H_XmTextSetEditable);
  XM_DEFINE_PROCEDURE(XmTextGetMaxLength, gxm_XmTextGetMaxLength_w, 1, 0, 0, H_XmTextGetMaxLength);
  XM_DEFINE_PROCEDURE(XmTextSetMaxLength, gxm_XmTextSetMaxLength_w, 2, 0, 0, H_XmTextSetMaxLength);
  XM_DEFINE_PROCEDURE(XmTextGetTopCharacter, gxm_XmTextGetTopCharacter_w, 1, 0, 0, H_XmTextGetTopCharacter);
  XM_DEFINE_PROCEDURE(XmTextSetTopCharacter, gxm_XmTextSetTopCharacter_w, 2, 0, 0, H_XmTextSetTopCharacter);
  XM_DEFINE_PROCEDURE(XmTextGetCursorPosition, gxm_XmTextGetCursorPosition_w, 1, 0, 0, H_XmTextGetCursorPosition);
  XM_DEFINE_PROCEDURE(XmTextGetInsertionPosition, gxm_XmTextGetInsertionPosition_w, 1, 0, 0, H_XmTextGetInsertionPosition);
  XM_DEFINE_PROCEDURE(XmTextSetInsertionPosition, gxm_XmTextSetInsertionPosition_w, 2, 0, 0, H_XmTextSetInsertionPosition);
  XM_DEFINE_PROCEDURE(XmTextSetCursorPosition, gxm_XmTextSetCursorPosition_w, 2, 0, 0, H_XmTextSetCursorPosition);
  XM_DEFINE_PROCEDURE(XmTextRemove, gxm_XmTextRemove_w, 1, 0, 0, H_XmTextRemove);
  XM_DEFINE_PROCEDURE(XmTextCopy, gxm_XmTextCopy_w, 2, 0, 0, H_XmTextCopy);
  XM_DEFINE_PROCEDURE(XmTextCut, gxm_XmTextCut_w, 2, 0, 0, H_XmTextCut);
  XM_DEFINE_PROCEDURE(XmTextPaste, gxm_XmTextPaste_w, 1, 0, 0, H_XmTextPaste);
  XM_DEFINE_PROCEDURE(XmTextGetSelection, gxm_XmTextGetSelection_w, 1, 0, 0, H_XmTextGetSelection);
  XM_DEFINE_PROCEDURE(XmTextSetSelection, gxm_XmTextSetSelection_w, 4, 0, 0, H_XmTextSetSelection);
  XM_DEFINE_PROCEDURE(XmTextClearSelection, gxm_XmTextClearSelection_w, 2, 0, 0, H_XmTextClearSelection);
  XM_DEFINE_PROCEDURE(XmTextGetSelectionPosition, gxm_XmTextGetSelectionPosition_w, 1, 0, 0, H_XmTextGetSelectionPosition);
  XM_DEFINE_PROCEDURE(XmTextXYToPos, gxm_XmTextXYToPos_w, 3, 0, 0, H_XmTextXYToPos);
  XM_DEFINE_PROCEDURE(XmTextPosToXY, gxm_XmTextPosToXY_w, 2, 0, 0, H_XmTextPosToXY);
  XM_DEFINE_PROCEDURE(XmTextGetSource, gxm_XmTextGetSource_w, 1, 0, 0, H_XmTextGetSource);
  XM_DEFINE_PROCEDURE(XmTextSetSource, gxm_XmTextSetSource_w, 4, 0, 0, H_XmTextSetSource);
  XM_DEFINE_PROCEDURE(XmTextShowPosition, gxm_XmTextShowPosition_w, 2, 0, 0, H_XmTextShowPosition);
  XM_DEFINE_PROCEDURE(XmTextScroll, gxm_XmTextScroll_w, 2, 0, 0, H_XmTextScroll);
  XM_DEFINE_PROCEDURE(XmTextGetBaseline, gxm_XmTextGetBaseline_w, 1, 0, 0, H_XmTextGetBaseline);
  XM_DEFINE_PROCEDURE(XmTextDisableRedisplay, gxm_XmTextDisableRedisplay_w, 1, 0, 0, H_XmTextDisableRedisplay);
  XM_DEFINE_PROCEDURE(XmTextEnableRedisplay, gxm_XmTextEnableRedisplay_w, 1, 0, 0, H_XmTextEnableRedisplay);
  XM_DEFINE_PROCEDURE(XmTextFindString, gxm_XmTextFindString_w, 4, 0, 0, H_XmTextFindString);
  XM_DEFINE_PROCEDURE(XmCreateForm, gxm_XmCreateForm_w, 3, 1, 0, H_XmCreateForm);
  XM_DEFINE_PROCEDURE(XmCreateFormDialog, gxm_XmCreateFormDialog_w, 3, 1, 0, H_XmCreateFormDialog);
  XM_DEFINE_PROCEDURE(XmCreateFrame, gxm_XmCreateFrame_w, 3, 1, 0, H_XmCreateFrame);
  XM_DEFINE_PROCEDURE(XmToggleButtonGadgetGetState, gxm_XmToggleButtonGadgetGetState_w, 1, 0, 0, H_XmToggleButtonGadgetGetState);
  XM_DEFINE_PROCEDURE(XmToggleButtonGadgetSetState, gxm_XmToggleButtonGadgetSetState_w, 3, 0, 0, H_XmToggleButtonGadgetSetState);
  XM_DEFINE_PROCEDURE(XmCreateToggleButtonGadget, gxm_XmCreateToggleButtonGadget_w, 3, 1, 0, H_XmCreateToggleButtonGadget);
  XM_DEFINE_PROCEDURE(XmToggleButtonGetState, gxm_XmToggleButtonGetState_w, 1, 0, 0, H_XmToggleButtonGetState);
  XM_DEFINE_PROCEDURE(XmToggleButtonSetState, gxm_XmToggleButtonSetState_w, 3, 0, 0, H_XmToggleButtonSetState);
  XM_DEFINE_PROCEDURE(XmCreateToggleButton, gxm_XmCreateToggleButton_w, 3, 1, 0, H_XmCreateToggleButton);
  XM_DEFINE_PROCEDURE(XmCreateLabelGadget, gxm_XmCreateLabelGadget_w, 3, 1, 0, H_XmCreateLabelGadget);
  XM_DEFINE_PROCEDURE(XmCreateLabel, gxm_XmCreateLabel_w, 3, 1, 0, H_XmCreateLabel);
  XM_DEFINE_PROCEDURE(XmIsMotifWMRunning, gxm_XmIsMotifWMRunning_w, 1, 0, 0, H_XmIsMotifWMRunning);
  XM_DEFINE_PROCEDURE(XmListAddItem, gxm_XmListAddItem_w, 3, 0, 0, H_XmListAddItem);
  XM_DEFINE_PROCEDURE(XmListAddItems, gxm_XmListAddItems_w, 4, 0, 0, H_XmListAddItems);
  XM_DEFINE_PROCEDURE(XmListAddItemsUnselected, gxm_XmListAddItemsUnselected_w, 4, 0, 0, H_XmListAddItemsUnselected);
  XM_DEFINE_PROCEDURE(XmListAddItemUnselected, gxm_XmListAddItemUnselected_w, 3, 0, 0, H_XmListAddItemUnselected);
  XM_DEFINE_PROCEDURE(XmListDeleteItem, gxm_XmListDeleteItem_w, 2, 0, 0, H_XmListDeleteItem);
  XM_DEFINE_PROCEDURE(XmListDeleteItems, gxm_XmListDeleteItems_w, 2, 1, 0, H_XmListDeleteItems);
  XM_DEFINE_PROCEDURE(XmListDeletePositions, gxm_XmListDeletePositions_w, 2, 1, 0, H_XmListDeletePositions);
  XM_DEFINE_PROCEDURE(XmListDeletePos, gxm_XmListDeletePos_w, 2, 0, 0, H_XmListDeletePos);
  XM_DEFINE_PROCEDURE(XmListDeleteItemsPos, gxm_XmListDeleteItemsPos_w, 3, 0, 0, H_XmListDeleteItemsPos);
  XM_DEFINE_PROCEDURE(XmListDeleteAllItems, gxm_XmListDeleteAllItems_w, 1, 0, 0, H_XmListDeleteAllItems);
  XM_DEFINE_PROCEDURE(XmListReplaceItems, gxm_XmListReplaceItems_w, 4, 0, 0, H_XmListReplaceItems);
  XM_DEFINE_PROCEDURE(XmListReplaceItemsPos, gxm_XmListReplaceItemsPos_w, 4, 0, 0, H_XmListReplaceItemsPos);
  XM_DEFINE_PROCEDURE(XmListReplaceItemsUnselected, gxm_XmListReplaceItemsUnselected_w, 4, 0, 0, H_XmListReplaceItemsUnselected);
  XM_DEFINE_PROCEDURE(XmListReplaceItemsPosUnselected, gxm_XmListReplaceItemsPosUnselected_w, 4, 0, 0, H_XmListReplaceItemsPosUnselected);
  XM_DEFINE_PROCEDURE(XmListReplacePositions, gxm_XmListReplacePositions_w, 4, 0, 0, H_XmListReplacePositions);
  XM_DEFINE_PROCEDURE(XmListSelectItem, gxm_XmListSelectItem_w, 3, 0, 0, H_XmListSelectItem);
  XM_DEFINE_PROCEDURE(XmListSelectPos, gxm_XmListSelectPos_w, 3, 0, 0, H_XmListSelectPos);
  XM_DEFINE_PROCEDURE(XmListDeselectItem, gxm_XmListDeselectItem_w, 2, 0, 0, H_XmListDeselectItem);
  XM_DEFINE_PROCEDURE(XmListDeselectPos, gxm_XmListDeselectPos_w, 2, 0, 0, H_XmListDeselectPos);
  XM_DEFINE_PROCEDURE(XmListDeselectAllItems, gxm_XmListDeselectAllItems_w, 1, 0, 0, H_XmListDeselectAllItems);
  XM_DEFINE_PROCEDURE(XmListSetPos, gxm_XmListSetPos_w, 2, 0, 0, H_XmListSetPos);
  XM_DEFINE_PROCEDURE(XmListSetBottomPos, gxm_XmListSetBottomPos_w, 2, 0, 0, H_XmListSetBottomPos);
  XM_DEFINE_PROCEDURE(XmListSetItem, gxm_XmListSetItem_w, 2, 0, 0, H_XmListSetItem);
  XM_DEFINE_PROCEDURE(XmListSetBottomItem, gxm_XmListSetBottomItem_w, 2, 0, 0, H_XmListSetBottomItem);
  XM_DEFINE_PROCEDURE(XmListSetAddMode, gxm_XmListSetAddMode_w, 2, 0, 0, H_XmListSetAddMode);
  XM_DEFINE_PROCEDURE(XmListItemExists, gxm_XmListItemExists_w, 2, 0, 0, H_XmListItemExists);
  XM_DEFINE_PROCEDURE(XmListItemPos, gxm_XmListItemPos_w, 2, 0, 0, H_XmListItemPos);
  XM_DEFINE_PROCEDURE(XmListGetKbdItemPos, gxm_XmListGetKbdItemPos_w, 1, 0, 0, H_XmListGetKbdItemPos);
  XM_DEFINE_PROCEDURE(XmListSetKbdItemPos, gxm_XmListSetKbdItemPos_w, 2, 0, 0, H_XmListSetKbdItemPos);
  XM_DEFINE_PROCEDURE(XmListYToPos, gxm_XmListYToPos_w, 2, 0, 0, H_XmListYToPos);
  XM_DEFINE_PROCEDURE(XmListPosToBounds, gxm_XmListPosToBounds_w, 2, 0, 0, H_XmListPosToBounds);
  XM_DEFINE_PROCEDURE(XmListGetMatchPos, gxm_XmListGetMatchPos_w, 2, 0, 0, H_XmListGetMatchPos);
  XM_DEFINE_PROCEDURE(XmListSetHorizPos, gxm_XmListSetHorizPos_w, 2, 0, 0, H_XmListSetHorizPos);
  XM_DEFINE_PROCEDURE(XmListUpdateSelectedList, gxm_XmListUpdateSelectedList_w, 1, 0, 0, H_XmListUpdateSelectedList);
  XM_DEFINE_PROCEDURE(XmListPosSelected, gxm_XmListPosSelected_w, 2, 0, 0, H_XmListPosSelected);
  XM_DEFINE_PROCEDURE(XmCreateList, gxm_XmCreateList_w, 3, 1, 0, H_XmCreateList);
  XM_DEFINE_PROCEDURE(XmCreateScrolledList, gxm_XmCreateScrolledList_w, 3, 1, 0, H_XmCreateScrolledList);
  XM_DEFINE_PROCEDURE(XmTranslateKey, gxm_XmTranslateKey_w, 3, 0, 0, H_XmTranslateKey);
  XM_DEFINE_PROCEDURE(XmCreateMainWindow, gxm_XmCreateMainWindow_w, 3, 1, 0, H_XmCreateMainWindow);
  XM_DEFINE_PROCEDURE(XmInstallImage, gxm_XmInstallImage_w, 2, 0, 0, H_XmInstallImage);
  XM_DEFINE_PROCEDURE(XmUninstallImage, gxm_XmUninstallImage_w, 1, 0, 0, H_XmUninstallImage);
  XM_DEFINE_PROCEDURE(XmGetPixmap, gxm_XmGetPixmap_w, 4, 0, 0, H_XmGetPixmap);
  XM_DEFINE_PROCEDURE(XmGetPixmapByDepth, gxm_XmGetPixmapByDepth_w, 5, 0, 0, H_XmGetPixmapByDepth);
  XM_DEFINE_PROCEDURE(XmDestroyPixmap, gxm_XmDestroyPixmap_w, 2, 0, 0, H_XmDestroyPixmap);
  XM_DEFINE_PROCEDURE(XmUpdateDisplay, gxm_XmUpdateDisplay_w, 1, 0, 0, H_XmUpdateDisplay);
  XM_DEFINE_PROCEDURE(XmWidgetGetBaselines, gxm_XmWidgetGetBaselines_w, 1, 0, 0, H_XmWidgetGetBaselines);
  XM_DEFINE_PROCEDURE(XmRegisterSegmentEncoding, gxm_XmRegisterSegmentEncoding_w, 2, 0, 0, H_XmRegisterSegmentEncoding);
  XM_DEFINE_PROCEDURE(XmMapSegmentEncoding, gxm_XmMapSegmentEncoding_w, 1, 0, 0, H_XmMapSegmentEncoding);
  XM_DEFINE_PROCEDURE(XmCvtCTToXmString, gxm_XmCvtCTToXmString_w, 1, 0, 0, H_XmCvtCTToXmString);
  XM_DEFINE_PROCEDURE(XmCvtXmStringToCT, gxm_XmCvtXmStringToCT_w, 1, 0, 0, H_XmCvtXmStringToCT);
  XM_DEFINE_PROCEDURE(XmConvertUnits, gxm_XmConvertUnits_w, 5, 0, 0, H_XmConvertUnits);
  XM_DEFINE_PROCEDURE(XmCreateSimpleMenuBar, gxm_XmCreateSimpleMenuBar_w, 3, 1, 0, H_XmCreateSimpleMenuBar);
  XM_DEFINE_PROCEDURE(XmCreateSimplePopupMenu, gxm_XmCreateSimplePopupMenu_w, 3, 1, 0, H_XmCreateSimplePopupMenu);
  XM_DEFINE_PROCEDURE(XmCreateSimplePulldownMenu, gxm_XmCreateSimplePulldownMenu_w, 3, 1, 0, H_XmCreateSimplePulldownMenu);
  XM_DEFINE_PROCEDURE(XmCreateSimpleOptionMenu, gxm_XmCreateSimpleOptionMenu_w, 3, 1, 0, H_XmCreateSimpleOptionMenu);
  XM_DEFINE_PROCEDURE(XmCreateSimpleRadioBox, gxm_XmCreateSimpleRadioBox_w, 3, 1, 0, H_XmCreateSimpleRadioBox);
  XM_DEFINE_PROCEDURE(XmCreateSimpleCheckBox, gxm_XmCreateSimpleCheckBox_w, 3, 1, 0, H_XmCreateSimpleCheckBox);
  XM_DEFINE_PROCEDURE(XmVaCreateSimpleMenuBar, gxm_XmVaCreateSimpleMenuBar_w, 3, 0, 0, H_XmVaCreateSimpleMenuBar);
  XM_DEFINE_PROCEDURE(XmVaCreateSimplePopupMenu, gxm_XmVaCreateSimplePopupMenu_w, 4, 0, 0, H_XmVaCreateSimplePopupMenu);
  XM_DEFINE_PROCEDURE(XmVaCreateSimplePulldownMenu, gxm_XmVaCreateSimplePulldownMenu_w, 5, 0, 0, H_XmVaCreateSimplePulldownMenu);
  XM_DEFINE_PROCEDURE(XmVaCreateSimpleOptionMenu, gxm_XmVaCreateSimpleOptionMenu_w, 7, 0, 0, H_XmVaCreateSimpleOptionMenu);
  XM_DEFINE_PROCEDURE(XmVaCreateSimpleRadioBox, gxm_XmVaCreateSimpleRadioBox_w, 5, 0, 0, H_XmVaCreateSimpleRadioBox);
  XM_DEFINE_PROCEDURE(XmVaCreateSimpleCheckBox, gxm_XmVaCreateSimpleCheckBox_w, 4, 0, 0, H_XmVaCreateSimpleCheckBox);
  XM_DEFINE_PROCEDURE(XmTrackingEvent, gxm_XmTrackingEvent_w, 3, 0, 0, H_XmTrackingEvent);
  XM_DEFINE_PROCEDURE(XmSetColorCalculation, gxm_XmSetColorCalculation_w, 1, 0, 0, H_XmSetColorCalculation);
  XM_DEFINE_PROCEDURE(XmGetColorCalculation, gxm_XmGetColorCalculation_w, 0, 0, 0, H_XmGetColorCalculation);
  XM_DEFINE_PROCEDURE(XmGetColors, gxm_XmGetColors_w, 3, 0, 0, H_XmGetColors);
  XM_DEFINE_PROCEDURE(XmChangeColor, gxm_XmChangeColor_w, 2, 0, 0, H_XmChangeColor);
  XM_DEFINE_PROCEDURE(XmStringCreate, gxm_XmStringCreate_w, 2, 0, 0, H_XmStringCreate);
  XM_DEFINE_PROCEDURE(XmStringCreateLocalized, gxm_XmStringCreateLocalized_w, 1, 0, 0, H_XmStringCreateLocalized);
  XM_DEFINE_PROCEDURE(XmStringDirectionCreate, gxm_XmStringDirectionCreate_w, 1, 0, 0, H_XmStringDirectionCreate);
  XM_DEFINE_PROCEDURE(XmStringSeparatorCreate, gxm_XmStringSeparatorCreate_w, 0, 0, 0, H_XmStringSeparatorCreate);
  XM_DEFINE_PROCEDURE(XmStringInitContext, gxm_XmStringInitContext_w, 1, 0, 0, H_XmStringInitContext);
  XM_DEFINE_PROCEDURE(XmStringFreeContext, gxm_XmStringFreeContext_w, 1, 0, 0, H_XmStringFreeContext);
  XM_DEFINE_PROCEDURE(XmCvtXmStringToByteStream, gxm_XmCvtXmStringToByteStream_w, 1, 0, 0, H_XmCvtXmStringToByteStream);
  XM_DEFINE_PROCEDURE(XmCvtByteStreamToXmString, gxm_XmCvtByteStreamToXmString_w, 1, 0, 0, H_XmCvtByteStreamToXmString);
  XM_DEFINE_PROCEDURE(XmStringByteStreamLength, gxm_XmStringByteStreamLength_w, 1, 0, 0, H_XmStringByteStreamLength);
  XM_DEFINE_PROCEDURE(XmStringConcatAndFree, gxm_XmStringConcatAndFree_w, 2, 0, 0, H_XmStringConcatAndFree);
  XM_DEFINE_PROCEDURE(XmStringIsVoid, gxm_XmStringIsVoid_w, 1, 0, 0, H_XmStringIsVoid);
  XM_DEFINE_PROCEDURE(XmStringPeekNextTriple, gxm_XmStringPeekNextTriple_w, 1, 0, 0, H_XmStringPeekNextTriple);
  XM_DEFINE_PROCEDURE(XmStringGetNextTriple, gxm_XmStringGetNextTriple_w, 1, 0, 0, H_XmStringGetNextTriple);
  XM_DEFINE_PROCEDURE(XmStringComponentCreate, gxm_XmStringComponentCreate_w, 3, 0, 0, H_XmStringComponentCreate);
  XM_DEFINE_PROCEDURE(XmStringUnparse, gxm_XmStringUnparse_w, 7, 0, 0, H_XmStringUnparse);
  XM_DEFINE_PROCEDURE(XmStringParseText, gxm_XmStringParseText_w, 7, 0, 0, H_XmStringParseText);
  XM_DEFINE_PROCEDURE(XmStringToXmStringTable, gxm_XmStringToXmStringTable_w, 2, 0, 0, H_XmStringToXmStringTable);
  XM_DEFINE_PROCEDURE(XmStringTableToXmString, gxm_XmStringTableToXmString_w, 3, 0, 0, H_XmStringTableToXmString);
  XM_DEFINE_PROCEDURE(XmStringTableUnparse, gxm_XmStringTableUnparse_w, 8, 0, 0, H_XmStringTableUnparse);
  XM_DEFINE_PROCEDURE(XmStringTableParseStringArray, gxm_XmStringTableParseStringArray_w, 7, 0, 0, H_XmStringTableParseStringArray);
  XM_DEFINE_PROCEDURE(XmDirectionToStringDirection, gxm_XmDirectionToStringDirection_w, 1, 0, 0, H_XmDirectionToStringDirection);
  XM_DEFINE_PROCEDURE(XmStringDirectionToDirection, gxm_XmStringDirectionToDirection_w, 1, 0, 0, H_XmStringDirectionToDirection);
  XM_DEFINE_PROCEDURE(XmStringGenerate, gxm_XmStringGenerate_w, 4, 0, 0, H_XmStringGenerate);
  XM_DEFINE_PROCEDURE(XmStringPutRendition, gxm_XmStringPutRendition_w, 2, 0, 0, H_XmStringPutRendition);
  XM_DEFINE_PROCEDURE(XmParseMappingCreate, gxm_XmParseMappingCreate_w, 1, 1, 0, H_XmParseMappingCreate);
  XM_DEFINE_PROCEDURE(XmParseMappingSetValues, gxm_XmParseMappingSetValues_w, 2, 1, 0, H_XmParseMappingSetValues);
  XM_DEFINE_PROCEDURE(XmParseMappingGetValues, gxm_XmParseMappingGetValues_w, 2, 1, 0, H_XmParseMappingGetValues);
  XM_DEFINE_PROCEDURE(XmParseMappingFree, gxm_XmParseMappingFree_w, 1, 0, 0, H_XmParseMappingFree);
  XM_DEFINE_PROCEDURE(XmParseTableFree, gxm_XmParseTableFree_w, 1, 1, 0, H_XmParseTableFree);
  XM_DEFINE_PROCEDURE(XmStringTableProposeTablist, gxm_XmStringTableProposeTablist_w, 5, 0, 0, H_XmStringTableProposeTablist);
  XM_DEFINE_PROCEDURE(XmTabSetValue, gxm_XmTabSetValue_w, 2, 0, 0, H_XmTabSetValue);
  XM_DEFINE_PROCEDURE(XmTabGetValues, gxm_XmTabGetValues_w, 1, 0, 0, H_XmTabGetValues);
  XM_DEFINE_PROCEDURE(XmTabFree, gxm_XmTabFree_w, 1, 0, 0, H_XmTabFree);
  XM_DEFINE_PROCEDURE(XmTabListFree, gxm_XmTabListFree_w, 1, 0, 0, H_XmTabListFree);
  XM_DEFINE_PROCEDURE(XmTabCreate, gxm_XmTabCreate_w, 5, 0, 0, H_XmTabCreate);
  XM_DEFINE_PROCEDURE(XmTabListTabCount, gxm_XmTabListTabCount_w, 1, 0, 0, H_XmTabListTabCount);
  XM_DEFINE_PROCEDURE(XmTabListRemoveTabs, gxm_XmTabListRemoveTabs_w, 2, 1, 0, H_XmTabListRemoveTabs);
  XM_DEFINE_PROCEDURE(XmTabListReplacePositions, gxm_XmTabListReplacePositions_w, 3, 1, 0, H_XmTabListReplacePositions);
  XM_DEFINE_PROCEDURE(XmTabListGetTab, gxm_XmTabListGetTab_w, 2, 0, 0, H_XmTabListGetTab);
  XM_DEFINE_PROCEDURE(XmTabListCopy, gxm_XmTabListCopy_w, 3, 0, 0, H_XmTabListCopy);
  XM_DEFINE_PROCEDURE(XmTabListInsertTabs, gxm_XmTabListInsertTabs_w, 4, 0, 0, H_XmTabListInsertTabs);
  XM_DEFINE_PROCEDURE(XmRenderTableCvtFromProp, gxm_XmRenderTableCvtFromProp_w, 3, 0, 0, H_XmRenderTableCvtFromProp);
  XM_DEFINE_PROCEDURE(XmRenderTableCvtToProp, gxm_XmRenderTableCvtToProp_w, 2, 0, 0, H_XmRenderTableCvtToProp);
  XM_DEFINE_PROCEDURE(XmRenditionUpdate, gxm_XmRenditionUpdate_w, 2, 1, 0, H_XmRenditionUpdate);
  XM_DEFINE_PROCEDURE(XmRenditionRetrieve, gxm_XmRenditionRetrieve_w, 2, 1, 0, H_XmRenditionRetrieve);
  XM_DEFINE_PROCEDURE(XmRenditionFree, gxm_XmRenditionFree_w, 1, 0, 0, H_XmRenditionFree);
  XM_DEFINE_PROCEDURE(XmRenditionCreate, gxm_XmRenditionCreate_w, 3, 1, 0, H_XmRenditionCreate);
  XM_DEFINE_PROCEDURE(XmRenderTableGetRenditions, gxm_XmRenderTableGetRenditions_w, 0, 3, 0, H_XmRenderTableGetRenditions);
  XM_DEFINE_PROCEDURE(XmRenderTableGetRendition, gxm_XmRenderTableGetRendition_w, 2, 0, 0, H_XmRenderTableGetRendition);
  XM_DEFINE_PROCEDURE(XmRenderTableGetTags, gxm_XmRenderTableGetTags_w, 1, 0, 0, H_XmRenderTableGetTags);
  XM_DEFINE_PROCEDURE(XmRenderTableFree, gxm_XmRenderTableFree_w, 1, 0, 0, H_XmRenderTableFree);
  XM_DEFINE_PROCEDURE(XmRenderTableCopy, gxm_XmRenderTableCopy_w, 0, 3, 0, H_XmRenderTableCopy);
  XM_DEFINE_PROCEDURE(XmRenderTableRemoveRenditions, gxm_XmRenderTableRemoveRenditions_w, 0, 3, 0, H_XmRenderTableRemoveRenditions);
  XM_DEFINE_PROCEDURE(XmRenderTableAddRenditions, gxm_XmRenderTableAddRenditions_w, 4, 0, 0, H_XmRenderTableAddRenditions);
  XM_DEFINE_PROCEDURE(XmStringConcat, gxm_XmStringConcat_w, 2, 0, 0, H_XmStringConcat);
  XM_DEFINE_PROCEDURE(XmStringCopy, gxm_XmStringCopy_w, 1, 0, 0, H_XmStringCopy);
  XM_DEFINE_PROCEDURE(XmStringCompare, gxm_XmStringCompare_w, 2, 0, 0, H_XmStringCompare);
  XM_DEFINE_PROCEDURE(XmStringEmpty, gxm_XmStringEmpty_w, 1, 0, 0, H_XmStringEmpty);
  XM_DEFINE_PROCEDURE(XmStringHasSubstring, gxm_XmStringHasSubstring_w, 2, 0, 0, H_XmStringHasSubstring);
  XM_DEFINE_PROCEDURE(XmStringFree, gxm_XmStringFree_w, 1, 0, 0, H_XmStringFree);
  XM_DEFINE_PROCEDURE(XmStringBaseline, gxm_XmStringBaseline_w, 2, 0, 0, H_XmStringBaseline);
  XM_DEFINE_PROCEDURE(XmStringWidth, gxm_XmStringWidth_w, 2, 0, 0, H_XmStringWidth);
  XM_DEFINE_PROCEDURE(XmStringHeight, gxm_XmStringHeight_w, 2, 0, 0, H_XmStringHeight);
  XM_DEFINE_PROCEDURE(XmStringExtent, gxm_XmStringExtent_w, 2, 0, 0, H_XmStringExtent);
  XM_DEFINE_PROCEDURE(XmStringLineCount, gxm_XmStringLineCount_w, 1, 0, 0, H_XmStringLineCount);
  XM_DEFINE_PROCEDURE(XmStringDraw, gxm_XmStringDraw_w, 0, 0, 1, H_XmStringDraw);
  XM_DEFINE_PROCEDURE(XmStringDrawImage, gxm_XmStringDrawImage_w, 0, 0, 1, H_XmStringDrawImage);
  XM_DEFINE_PROCEDURE(XmStringDrawUnderline, gxm_XmStringDrawUnderline_w, 0, 0, 1, H_XmStringDrawUnderline);
  XM_DEFINE_PROCEDURE(XmGetDestination, gxm_XmGetDestination_w, 1, 0, 0, H_XmGetDestination);
  XM_DEFINE_PROCEDURE(XmIsTraversable, gxm_XmIsTraversable_w, 1, 0, 0, H_XmIsTraversable);
  XM_DEFINE_PROCEDURE(XmGetVisibility, gxm_XmGetVisibility_w, 1, 0, 0, H_XmGetVisibility);
  XM_DEFINE_PROCEDURE(XmGetTabGroup, gxm_XmGetTabGroup_w, 1, 0, 0, H_XmGetTabGroup);
  XM_DEFINE_PROCEDURE(XmGetFocusWidget, gxm_XmGetFocusWidget_w, 1, 0, 0, H_XmGetFocusWidget);
  XM_DEFINE_PROCEDURE(XmProcessTraversal, gxm_XmProcessTraversal_w, 2, 0, 0, H_XmProcessTraversal);
  XM_DEFINE_PROCEDURE(XmCreateMenuShell, gxm_XmCreateMenuShell_w, 3, 1, 0, H_XmCreateMenuShell);

  XM_DEFINE_PROCEDURE(XmIsMessageBox, gxm_XmIsMessageBox_w, 1, 0, 0, H_XmIsMessageBox);
  XM_DEFINE_PROCEDURE(XmIsArrowButtonGadget, gxm_XmIsArrowButtonGadget_w, 1, 0, 0, H_XmIsArrowButtonGadget);
  XM_DEFINE_PROCEDURE(XmIsArrowButton, gxm_XmIsArrowButton_w, 1, 0, 0, H_XmIsArrowButton);
  XM_DEFINE_PROCEDURE(XmIsNotebook, gxm_XmIsNotebook_w, 1, 0, 0, H_XmIsNotebook);
#if HAVE_XM_XP
  XM_DEFINE_PROCEDURE(XmIsPrintShell, gxm_XmIsPrintShell_w, 1, 0, 0, H_XmIsPrintShell);
#endif
  XM_DEFINE_PROCEDURE(XmIsComboBox, gxm_XmIsComboBox_w, 1, 0, 0, H_XmIsComboBox);
  XM_DEFINE_PROCEDURE(XmIsContainer, gxm_XmIsContainer_w, 1, 0, 0, H_XmIsContainer);
  XM_DEFINE_PROCEDURE(XmIsGrabShell, gxm_XmIsGrabShell_w, 1, 0, 0, H_XmIsGrabShell);
  XM_DEFINE_PROCEDURE(XmIsIconGadget, gxm_XmIsIconGadget_w, 1, 0, 0, H_XmIsIconGadget);
  XM_DEFINE_PROCEDURE(XmIsIconHeader, gxm_XmIsIconHeader_w, 1, 0, 0, H_XmIsIconHeader);
  XM_DEFINE_PROCEDURE(XmIsPanedWindow, gxm_XmIsPanedWindow_w, 1, 0, 0, H_XmIsPanedWindow);
  XM_DEFINE_PROCEDURE(XmIsBulletinBoard, gxm_XmIsBulletinBoard_w, 1, 0, 0, H_XmIsBulletinBoard);
  XM_DEFINE_PROCEDURE(XmIsPrimitive, gxm_XmIsPrimitive_w, 1, 0, 0, H_XmIsPrimitive);
  XM_DEFINE_PROCEDURE(XmIsCascadeButtonGadget, gxm_XmIsCascadeButtonGadget_w, 1, 0, 0, H_XmIsCascadeButtonGadget);
  XM_DEFINE_PROCEDURE(XmIsCascadeButton, gxm_XmIsCascadeButton_w, 1, 0, 0, H_XmIsCascadeButton);
  XM_DEFINE_PROCEDURE(XmIsPushButtonGadget, gxm_XmIsPushButtonGadget_w, 1, 0, 0, H_XmIsPushButtonGadget);
  XM_DEFINE_PROCEDURE(XmIsPushButton, gxm_XmIsPushButton_w, 1, 0, 0, H_XmIsPushButton);
  XM_DEFINE_PROCEDURE(XmIsCommand, gxm_XmIsCommand_w, 1, 0, 0, H_XmIsCommand);
  XM_DEFINE_PROCEDURE(XmIsRowColumn, gxm_XmIsRowColumn_w, 1, 0, 0, H_XmIsRowColumn);
  XM_DEFINE_PROCEDURE(XmIsScale, gxm_XmIsScale_w, 1, 0, 0, H_XmIsScale);
  XM_DEFINE_PROCEDURE(XmIsScreen, gxm_XmIsScreen_w, 1, 0, 0, H_XmIsScreen);
  XM_DEFINE_PROCEDURE(XmIsScrollBar, gxm_XmIsScrollBar_w, 1, 0, 0, H_XmIsScrollBar);
  XM_DEFINE_PROCEDURE(XmIsDialogShell, gxm_XmIsDialogShell_w, 1, 0, 0, H_XmIsDialogShell);
  XM_DEFINE_PROCEDURE(XmIsScrolledWindow, gxm_XmIsScrolledWindow_w, 1, 0, 0, H_XmIsScrolledWindow);
  XM_DEFINE_PROCEDURE(XmIsDisplay, gxm_XmIsDisplay_w, 1, 0, 0, H_XmIsDisplay);
  XM_DEFINE_PROCEDURE(XmIsSelectionBox, gxm_XmIsSelectionBox_w, 1, 0, 0, H_XmIsSelectionBox);
  XM_DEFINE_PROCEDURE(XmIsDragContext, gxm_XmIsDragContext_w, 1, 0, 0, H_XmIsDragContext);
  XM_DEFINE_PROCEDURE(XmIsSeparatorGadget, gxm_XmIsSeparatorGadget_w, 1, 0, 0, H_XmIsSeparatorGadget);
  XM_DEFINE_PROCEDURE(XmIsDragIconObjectClass, gxm_XmIsDragIconObjectClass_w, 1, 0, 0, H_XmIsDragIconObjectClass);
  XM_DEFINE_PROCEDURE(XmIsSeparator, gxm_XmIsSeparator_w, 1, 0, 0, H_XmIsSeparator);
  XM_DEFINE_PROCEDURE(XmIsDrawingArea, gxm_XmIsDrawingArea_w, 1, 0, 0, H_XmIsDrawingArea);
  XM_DEFINE_PROCEDURE(XmIsDrawnButton, gxm_XmIsDrawnButton_w, 1, 0, 0, H_XmIsDrawnButton);
  XM_DEFINE_PROCEDURE(XmIsDropSiteManager, gxm_XmIsDropSiteManager_w, 1, 0, 0, H_XmIsDropSiteManager);
  XM_DEFINE_PROCEDURE(XmIsDropTransfer, gxm_XmIsDropTransfer_w, 1, 0, 0, H_XmIsDropTransfer);
  XM_DEFINE_PROCEDURE(XmIsTextField, gxm_XmIsTextField_w, 1, 0, 0, H_XmIsTextField);
  XM_DEFINE_PROCEDURE(XmIsFileSelectionBox, gxm_XmIsFileSelectionBox_w, 1, 0, 0, H_XmIsFileSelectionBox);
  XM_DEFINE_PROCEDURE(XmIsText, gxm_XmIsText_w, 1, 0, 0, H_XmIsText);
  XM_DEFINE_PROCEDURE(XmIsForm, gxm_XmIsForm_w, 1, 0, 0, H_XmIsForm);
  XM_DEFINE_PROCEDURE(XmIsFrame, gxm_XmIsFrame_w, 1, 0, 0, H_XmIsFrame);
  XM_DEFINE_PROCEDURE(XmIsGadget, gxm_XmIsGadget_w, 1, 0, 0, H_XmIsGadget);
  XM_DEFINE_PROCEDURE(XmIsToggleButtonGadget, gxm_XmIsToggleButtonGadget_w, 1, 0, 0, H_XmIsToggleButtonGadget);
  XM_DEFINE_PROCEDURE(XmIsToggleButton, gxm_XmIsToggleButton_w, 1, 0, 0, H_XmIsToggleButton);
  XM_DEFINE_PROCEDURE(XmIsLabelGadget, gxm_XmIsLabelGadget_w, 1, 0, 0, H_XmIsLabelGadget);
  XM_DEFINE_PROCEDURE(XmIsLabel, gxm_XmIsLabel_w, 1, 0, 0, H_XmIsLabel);
  XM_DEFINE_PROCEDURE(XmIsVendorShell, gxm_XmIsVendorShell_w, 1, 0, 0, H_XmIsVendorShell);
  XM_DEFINE_PROCEDURE(XmIsList, gxm_XmIsList_w, 1, 0, 0, H_XmIsList);
  XM_DEFINE_PROCEDURE(XmIsMainWindow, gxm_XmIsMainWindow_w, 1, 0, 0, H_XmIsMainWindow);
  XM_DEFINE_PROCEDURE(XmIsManager, gxm_XmIsManager_w, 1, 0, 0, H_XmIsManager);
  XM_DEFINE_PROCEDURE(XmIsMenuShell, gxm_XmIsMenuShell_w, 1, 0, 0, H_XmIsMenuShell);
  XM_DEFINE_PROCEDURE(XmListGetSelectedPos, gxm_XmListGetSelectedPos_w, 1, 0, 0, H_XmListGetSelectedPos);
#endif
#if HAVE_XmCreateButtonBox
  XM_DEFINE_PROCEDURE(XmIsButtonBox, gxm_XmIsButtonBox_w, 1, 0, 0, H_XmIsButtonBox);
  XM_DEFINE_PROCEDURE(XmCreateButtonBox, gxm_XmCreateButtonBox_w, 3, 1, 0, H_XmCreateButtonBox);
#endif
#if HAVE_XmCreateDataField
  XM_DEFINE_PROCEDURE(XmIsDataField, gxm_XmIsDataField_w, 1, 0, 0, H_XmIsDataField);
  XM_DEFINE_PROCEDURE(XmCreateDataField, gxm_XmCreateDataField_w, 3, 1, 0, H_XmCreateDataField);
  XM_DEFINE_PROCEDURE(XmDataFieldSetString, gxm_XmDataFieldSetString_w, 2, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XmDataFieldGetString, gxm_XmDataFieldGetString_w, 1, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XmDataFieldSetHighlight, gxm_XmDataFieldSetHighlight_w, 4, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XmDataFieldSetAddMode, gxm_XmDataFieldSetAddMode_w, 2, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XmDataFieldGetSelection, gxm_XmDataFieldGetSelection_w, 1, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XmDataFieldSetSelection, gxm_XmDataFieldSetSelection_w, 4, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XmDataFieldGetSelectionPosition, gxm_XmDataFieldGetSelectionPosition_w, 1, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XmDataFieldXYToPos, gxm_XmDataFieldXYToPos_w, 3, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XmDataFieldShowPosition, gxm_XmDataFieldShowPosition_w, 2, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XmDataFieldCut, gxm_XmDataFieldCut_w, 2, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XmDataFieldCopy, gxm_XmDataFieldCopy_w, 2, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XmDataFieldPaste, gxm_XmDataFieldPaste_w, 1, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XmDataFieldSetEditable, gxm_XmDataFieldSetEditable_w, 2, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XmDataFieldSetInsertionPosition, gxm_XmDataFieldSetInsertionPosition_w, 2, 0, 0, NULL);
#endif
#if HAVE_XmCreateTabStack
  XM_DEFINE_PROCEDURE(XmIsTabStack, gxm_XmIsTabStack_w, 1, 0, 0, H_XmIsTabStack);
  XM_DEFINE_PROCEDURE(XmTabStackGetSelectedTab, gxm_XmTabStackGetSelectedTab_w, 1, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XmTabStackSelectTab, gxm_XmTabStackSelectTab_w, 2, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XmCreateTabStack, gxm_XmCreateTabStack_w, 3, 1, 0, H_XmCreateTabStack);
#if HAVE_XmTabStackXYToWidget
  XM_DEFINE_PROCEDURE(XmTabStackIndexToWidget, gxm_XmTabStackIndexToWidget_w, 2, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XmTabStackXYToWidget, gxm_XmTabStackXYToWidget_w, 3, 0, 0, NULL);
#endif
#endif
#if HAVE_XmCreateColumn
  XM_DEFINE_PROCEDURE(XmCreateColumn, gxm_XmCreateColumn_w, 3, 1, 0, H_XmCreateColumn);
  XM_DEFINE_PROCEDURE(XmIsColumn, gxm_XmIsColumn_w, 1, 0, 0, H_XmIsColumn);
#if HAVE_XmColumnGetChildLabel
  XM_DEFINE_PROCEDURE(XmColumnGetChildLabel, gxm_XmColumnGetChildLabel_w, 1, 0, 0, NULL);
#endif
#endif
#if HAVE_XmCreateDropDown
  XM_DEFINE_PROCEDURE(XmIsDropDown, gxm_XmIsDropDown_w, 1, 0, 0, H_XmIsDropDown);
  XM_DEFINE_PROCEDURE(XmDropDownGetValue, gxm_XmDropDownGetValue_w, 1, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XmDropDownGetList, gxm_XmDropDownGetList_w, 1, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XmDropDownGetText, gxm_XmDropDownGetText_w, 1, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XmDropDownGetArrow, gxm_XmDropDownGetArrow_w, 1, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XmDropDownGetLabel, gxm_XmDropDownGetLabel_w, 1, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XmCreateDropDown, gxm_XmCreateDropDown_w, 3, 1, 0, H_XmCreateDropDown);
#endif
#if HAVE_XmCreateButtonBox
  XM_DEFINE_PROCEDURE(XmButtonBox?, gxm_XmIsButtonBox_w, 1, 0, 0, H_XmIsButtonBox);
#endif
#if HAVE_XmCreateTabStack
  XM_DEFINE_PROCEDURE(XmTabStack?, gxm_XmIsTabStack_w, 1, 0, 0, H_XmIsTabStack);
#endif
#if HAVE_XmCreateDataField
  XM_DEFINE_PROCEDURE(XmDataField?, gxm_XmIsDataField_w, 1, 0, 0, H_XmIsDataField);
#endif
#if HAVE_XmCreateDropDown
  XM_DEFINE_PROCEDURE(XmDropDown?, gxm_XmIsDropDown_w, 1, 0, 0, H_XmIsDropDown);
#endif
#if HAVE_XmCreateColumn
  XM_DEFINE_PROCEDURE(XmColumn?, gxm_XmIsColumn_w, 1, 0, 0, H_XmIsColumn);
#endif

#if HAVE_MOTIF
#if (!XM_DISABLE_DEPRECATED)
  XM_DEFINE_PROCEDURE(XtWarning, gxm_XtWarning_w, 1, 0, 0, H_XtWarning);
  XM_DEFINE_PROCEDURE(XtAppWarning, gxm_XtAppWarning_w, 2, 0, 0, H_XtAppWarning);
  XM_DEFINE_PROCEDURE(XtSetWarningMsgHandler, gxm_XtSetWarningMsgHandler_w, 1, 0, 0, H_XtSetWarningMsgHandler);
  XM_DEFINE_PROCEDURE(XtSetWarningHandler, gxm_XtSetWarningHandler_w, 1, 0, 0, H_XtSetWarningHandler);
  XM_DEFINE_PROCEDURE(XtWarningMsg, gxm_XtWarningMsg_w, 6, 0, 0, H_XtWarningMsg);
  XM_DEFINE_PROCEDURE(XtErrorMsg, gxm_XtErrorMsg_w, 6, 0, 0, H_XtErrorMsg);
  XM_DEFINE_PROCEDURE(XtError, gxm_XtError_w, 1, 0, 0, H_XtError);
  XM_DEFINE_PROCEDURE(XtSetErrorMsgHandler, gxm_XtSetErrorMsgHandler_w, 1, 0, 0, H_XtSetErrorMsgHandler);
  XM_DEFINE_PROCEDURE(XtSetErrorHandler, gxm_XtSetErrorHandler_w, 1, 0, 0, H_XtSetErrorHandler);
  XM_DEFINE_PROCEDURE(XtInitialize, gxm_XtInitialize_w, 4, 0, 0, H_XtInitialize);
  XM_DEFINE_PROCEDURE(XtCreateApplicationShell, gxm_XtCreateApplicationShell_w, 3, 1, 0, H_XtCreateApplicationShell);
  XM_DEFINE_PROCEDURE(XtSetSelectionTimeout, gxm_XtSetSelectionTimeout_w, 1, 0, 0, H_XtSetSelectionTimeout);
  XM_DEFINE_PROCEDURE(XtGetSelectionTimeout, gxm_XtGetSelectionTimeout_w, 0, 0, 0, H_XtGetSelectionTimeout);
  XM_DEFINE_PROCEDURE(XtAddActions, gxm_XtAddActions_w, 1, 0, 0, H_XtAddActions);
  XM_DEFINE_PROCEDURE(XtAddInput, gxm_XtAddInput_w, 3, 1, 0, H_XtAddInput);
  XM_DEFINE_PROCEDURE(XtAddWorkProc, gxm_XtAddWorkProc_w, 1, 1, 0, H_XtAddWorkProc);
  XM_DEFINE_PROCEDURE(XtAddTimeOut, gxm_XtAddTimeOut_w, 2, 1, 0, H_XtAddTimeOut);
  XM_DEFINE_PROCEDURE(XtMainLoop, gxm_XtMainLoop_w, 0, 0, 0, H_XtMainLoop);
  XM_DEFINE_PROCEDURE(XtProcessEvent, gxm_XtProcessEvent_w, 1, 0, 0, H_XtProcessEvent);
  XM_DEFINE_PROCEDURE(XtPending, gxm_XtPending_w, 0, 0, 0, H_XtPending);
  XM_DEFINE_PROCEDURE(XtNextEvent, gxm_XtNextEvent_w, 0, 0, 0, H_XtNextEvent);
  XM_DEFINE_PROCEDURE(XtPeekEvent, gxm_XtPeekEvent_w, 0, 0, 0, H_XtPeekEvent);

  XM_DEFINE_PROCEDURE(XmFontListEntryCreate, gxm_XmFontListEntryCreate_w, 3, 0, 0, H_XmFontListEntryCreate);
  XM_DEFINE_PROCEDURE(XmFontListEntryFree, gxm_XmFontListEntryFree_w, 1, 0, 0, H_XmFontListEntryFree);
  XM_DEFINE_PROCEDURE(XmFontListEntryGetFont, gxm_XmFontListEntryGetFont_w, 1, 0, 0, H_XmFontListEntryGetFont);
  XM_DEFINE_PROCEDURE(XmFontListEntryGetTag, gxm_XmFontListEntryGetTag_w, 1, 0, 0, H_XmFontListEntryGetTag);
  XM_DEFINE_PROCEDURE(XmFontListAppendEntry, gxm_XmFontListAppendEntry_w, 2, 0, 0, H_XmFontListAppendEntry);
  XM_DEFINE_PROCEDURE(XmFontListNextEntry, gxm_XmFontListNextEntry_w, 1, 0, 0, H_XmFontListNextEntry);
  XM_DEFINE_PROCEDURE(XmFontListRemoveEntry, gxm_XmFontListRemoveEntry_w, 2, 0, 0, H_XmFontListRemoveEntry);
  XM_DEFINE_PROCEDURE(XmFontListEntryLoad, gxm_XmFontListEntryLoad_w, 4, 0, 0, H_XmFontListEntryLoad);
  XM_DEFINE_PROCEDURE(XmFontListFree, gxm_XmFontListFree_w, 1, 0, 0, H_XmFontListFree);
  XM_DEFINE_PROCEDURE(XmFontListCopy, gxm_XmFontListCopy_w, 1, 0, 0, H_XmFontListCopy);
  XM_DEFINE_PROCEDURE(XmFontListInitFontContext, gxm_XmFontListInitFontContext_w, 1, 0, 0, H_XmFontListInitFontContext);
  XM_DEFINE_PROCEDURE(XmFontListFreeFontContext, gxm_XmFontListFreeFontContext_w, 1, 0, 0, H_XmFontListFreeFontContext);

  XM_DEFINE_PROCEDURE(XmFontContext?, XEN_XmFontContext_p_w, 1, 0, 0, "#t if arg is a XmFontContext");
  XM_DEFINE_PROCEDURE(XmFontListEntry?, XEN_XmFontListEntry_p_w, 1, 0, 0, "#t if arg is a XmFontListEntry");
  XM_DEFINE_PROCEDURE(XmFontList?, XEN_XmFontList_p_w, 1, 0, 0, "#t if arg is a XmFontList");
  XM_DEFINE_PROCEDURE(XmFontListCreate, gxm_XmFontListCreate_w, 2, 0, 0, H_XmFontListCreate);
  XM_DEFINE_PROCEDURE(XmTrackingLocate, gxm_XmTrackingLocate_w, 3, 0, 0, H_XmTrackingLocate);
  XM_DEFINE_PROCEDURE(XmFontListGetNextFont, gxm_XmFontListGetNextFont_w, 1, 0, 0, H_XmFontListGetNextFont);
  XM_DEFINE_PROCEDURE(XmStringByteCompare, gxm_XmStringByteCompare_w, 2, 0, 0, H_XmStringByteCompare);
  XM_DEFINE_PROCEDURE(XmStringCreateLtoR, gxm_XmStringCreateLtoR_w, 2, 0, 0, H_XmStringCreateLtoR);
  XM_DEFINE_PROCEDURE(XmStringCreateSimple, gxm_XmStringCreateSimple_w, 1, 0, 0, H_XmStringCreateSimple);
  XM_DEFINE_PROCEDURE(XmStringGetLtoR, gxm_XmStringGetLtoR_w, 2, 0, 0, H_XmStringGetLtoR);
  XM_DEFINE_PROCEDURE(XmStringGetNextSegment, gxm_XmStringGetNextSegment_w, 1, 0, 0, H_XmStringGetNextSegment);
  XM_DEFINE_PROCEDURE(XmStringSegmentCreate, gxm_XmStringSegmentCreate_w, 4, 0, 0, H_XmStringSegmentCreate);
  XM_DEFINE_PROCEDURE(XmStringPeekNextComponent, gxm_XmStringPeekNextComponent_w, 1, 0, 0, H_XmStringPeekNextComponent);
  XM_DEFINE_PROCEDURE(XmStringGetNextComponent, gxm_XmStringGetNextComponent_w, 1, 0, 0, H_XmStringGetNextComponent);
  XM_DEFINE_PROCEDURE(XmFontListAdd, gxm_XmFontListAdd_w, 3, 0, 0, H_XmFontListAdd);
  XM_DEFINE_PROCEDURE(XmStringLength, gxm_XmStringLength_w, 1, 0, 0, H_XmStringLength);
  XM_DEFINE_PROCEDURE(XmStringNConcat, gxm_XmStringNConcat_w, 3, 0, 0, H_XmStringNConcat);
  XM_DEFINE_PROCEDURE(XmStringNCopy, gxm_XmStringNCopy_w, 2, 0, 0, H_XmStringNCopy);
  XM_DEFINE_PROCEDURE(XmScrolledWindowSetAreas, gxm_XmScrolledWindowSetAreas_w, 4, 0, 0, H_XmScrolledWindowSetAreas);
  XM_DEFINE_PROCEDURE(XmSetFontUnits, gxm_XmSetFontUnits_w, 3, 0, 0, H_XmSetFontUnits);
  XM_DEFINE_PROCEDURE(XmSetFontUnit, gxm_XmSetFontUnit_w, 2, 0, 0, H_XmSetFontUnit);
  XM_DEFINE_PROCEDURE(XmGetMenuCursor, gxm_XmGetMenuCursor_w, 1, 0, 0, H_XmGetMenuCursor);
  XM_DEFINE_PROCEDURE(XmSetMenuCursor, gxm_XmSetMenuCursor_w, 2, 0, 0, H_XmSetMenuCursor);
  XM_DEFINE_PROCEDURE(XmMainWindowSetAreas, gxm_XmMainWindowSetAreas_w, 6, 0, 0, H_XmMainWindowSetAreas);
  XM_DEFINE_PROCEDURE(XmMainWindowSep1, gxm_XmMainWindowSep1_w, 1, 0, 0, H_XmMainWindowSep1);
  XM_DEFINE_PROCEDURE(XmMainWindowSep2, gxm_XmMainWindowSep2_w, 1, 0, 0, H_XmMainWindowSep2);
  XM_DEFINE_PROCEDURE(XmMainWindowSep3, gxm_XmMainWindowSep3_w, 1, 0, 0, H_XmMainWindowSep3);
#endif
#endif

#if HAVE_XPM
  XM_DEFINE_PROCEDURE(XpmCreatePixmapFromData, gxm_XpmCreatePixmapFromData_w, 4, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XpmCreateDataFromPixmap, gxm_XpmCreateDataFromPixmap_w, 4, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XpmReadFileToPixmap, gxm_XpmReadFileToPixmap_w, 4, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XpmReadFileToXpmImage, gxm_XpmReadFileToXpmImage_w, 1, 0, 0, NULL);
#if HAVE_XPM_GET_ERROR_STRING
  XM_DEFINE_PROCEDURE(XpmGetErrorString, gxm_XpmGetErrorString_w, 1, 0, 0, H_XpmGetErrorString);
#endif
  XM_DEFINE_PROCEDURE(XpmReadPixmapFile, gxm_XpmReadFileToPixmap_w, 4, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XpmWriteFileFromPixmap, gxm_XpmWriteFileFromPixmap_w, 5, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XpmWritePixmapFile, gxm_XpmWriteFileFromPixmap_w, 5, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XpmCreatePixmapFromXpmImage, gxm_XpmCreatePixmapFromXpmImage_w, 4, 0, 0, NULL);
  XM_DEFINE_PROCEDURE(XpmCreateXpmImageFromPixmap, gxm_XpmCreateXpmImageFromPixmap_w, 4, 0, 0, NULL);
#endif
  XM_DEFINE_PROCEDURE(XGetPixel, gxm_XGetPixel_w, 3, 0, 0, H_XGetPixel);
  XM_DEFINE_PROCEDURE(XDestroyImage, gxm_XDestroyImage_w, 1, 0, 0, H_XDestroyImage);
  XM_DEFINE_PROCEDURE(XPutPixel, gxm_XPutPixel_w, 4, 0, 0, H_XPutPixel);
  XM_DEFINE_PROCEDURE(XSubImage, gxm_XSubImage_w, 5, 0, 0, H_XSubImage);
  XM_DEFINE_PROCEDURE(XAddPixel, gxm_XAddPixel_w, 2, 0, 0, H_XAddPixel);

#if HAVE_MOTIF
  XM_DEFINE_PROCEDURE(XtAppContext?, XEN_XtAppContext_p_w, 1, 0, 0, "#t if arg is a XtAppContext");
  XM_DEFINE_PROCEDURE(XtRequestId?, XEN_XtRequestId_p_w, 1, 0, 0, "#t if arg is a XtRequestId");
  XM_DEFINE_PROCEDURE(XtWorkProcId?, XEN_XtWorkProcId_p_w, 1, 0, 0, "#t if arg is a XtWorkProcId");
  XM_DEFINE_PROCEDURE(XtInputId?, XEN_XtInputId_p_w, 1, 0, 0, "#t if arg is a XtInputId");
  XM_DEFINE_PROCEDURE(XtIntervalId?, XEN_XtIntervalId_p_w, 1, 0, 0, "#t if arg is a XtIntervalId");
#endif
  XM_DEFINE_PROCEDURE(Screen?, XEN_Screen_p_w, 1, 0, 0, "#t if arg is a Screen");
  XM_DEFINE_PROCEDURE(XEvent?, XEN_XEvent_p_w, 1, 0, 0, "#t if arg is a XEvent");
  XM_DEFINE_PROCEDURE(XRectangle?, XEN_XRectangle_p_w, 1, 0, 0, "#t if arg is a XRectangle");
  XM_DEFINE_PROCEDURE(XArc?, XEN_XArc_p_w, 1, 0, 0, "#t if arg is a XArc");
  XM_DEFINE_PROCEDURE(XPoint?, XEN_XPoint_p_w, 1, 0, 0, "#t if arg is a XPoint");
  XM_DEFINE_PROCEDURE(XSegment?, XEN_XSegment_p_w, 1, 0, 0, "#t if arg is a XSegment");
  XM_DEFINE_PROCEDURE(XColor?, XEN_XColor_p_w, 1, 0, 0, "#t if arg is a XColor");
  XM_DEFINE_PROCEDURE(Atom?, XEN_Atom_p_w, 1, 0, 0, "#t if arg is an Atom");
  XM_DEFINE_PROCEDURE(Colormap?, XEN_Colormap_p_w, 1, 0, 0, "#t if arg is a Colormap");
  XM_DEFINE_PROCEDURE(XModifierKeymap?, XEN_XModifierKeymap_p_w, 1, 0, 0, "#t if arg is a XModifierKeymap");
  XM_DEFINE_PROCEDURE(Depth?, XEN_Depth_p_w, 1, 0, 0, "#t if arg is a Depth");
  XM_DEFINE_PROCEDURE(Display?, XEN_Display_p_w, 1, 0, 0, "#t if arg is a Display");
  XM_DEFINE_PROCEDURE(Drawable?, XEN_Window_p_w, 1, 0, 0, "#t if arg is a Drawable");
  XM_DEFINE_PROCEDURE(Font?, XEN_Font_p_w, 1, 0, 0, "#t if arg is a Font");
  XM_DEFINE_PROCEDURE(GC?, XEN_GC_p_w, 1, 0, 0, "#t if arg is a GC");
  XM_DEFINE_PROCEDURE(KeySym?, XEN_KeySym_p_w, 1, 0, 0, "#t if arg is a KeySym");
  XM_DEFINE_PROCEDURE(Pixel?, XEN_Pixel_p_w, 1, 0, 0, "#t if arg is a Pixel");
  XM_DEFINE_PROCEDURE(Pixmap?, XEN_Pixmap_p_w, 1, 0, 0, "#t if arg is a Pixmap");
  XM_DEFINE_PROCEDURE(Region?, XEN_Region_p_w, 1, 0, 0, "#t if arg is a Region");
  XM_DEFINE_PROCEDURE(Time?, XEN_Time_p_w, 1, 0, 0, "#t if arg is a Time");
  XM_DEFINE_PROCEDURE(Visual?, XEN_Visual_p_w, 1, 0, 0, "#t if arg is a Visual");
  XM_DEFINE_PROCEDURE(Window?, XEN_Window_p_w, 1, 0, 0, "#t if arg is a Window");
#if HAVE_MOTIF
  XM_DEFINE_PROCEDURE(Widget?, XEN_Widget_p_w, 1, 0, 0, "#t if arg is a Widget");
  XM_DEFINE_PROCEDURE(XmStringContext?, XEN_XmStringContext_p_w, 1, 0, 0, "#t if arg is a XmStringContext");
#endif
  XM_DEFINE_PROCEDURE(XFontProp?, XEN_XFontProp_p_w, 1, 0, 0, "#t if arg is a XFontProp");
  XM_DEFINE_PROCEDURE(XFontSet?, XEN_XFontSet_p_w, 1, 0, 0, "#t if arg is a XFontSet");
  XM_DEFINE_PROCEDURE(XFontStruct?, XEN_XFontStruct_p_w, 1, 0, 0, "#t if arg is a XFontStruct");
  XM_DEFINE_PROCEDURE(XGCValues?, XEN_XGCValues_p_w, 1, 0, 0, "#t if arg is a XGCValues");
  XM_DEFINE_PROCEDURE(XImage?, XEN_XImage_p_w, 1, 0, 0, "#t if arg is a XImage");
  XM_DEFINE_PROCEDURE(XVisualInfo?, XEN_XVisualInfo_p_w, 1, 0, 0, "#t if arg is a XVisualInfo");
  XM_DEFINE_PROCEDURE(XWMHints?, XEN_XWMHints_p_w, 1, 0, 0, "#t if arg is a XWMHints");
  XM_DEFINE_PROCEDURE(XWindowAttributes?, XEN_XWindowAttributes_p_w, 1, 0, 0, "#t if arg is a XWindowAttributes");
  XM_DEFINE_PROCEDURE(XWindowChanges?, XEN_XWindowChanges_p_w, 1, 0, 0, "#t if arg is a XWindowChanges");
  XM_DEFINE_PROCEDURE(KeyCode?, XEN_KeyCode_p_w, 1, 0, 0, "#t if arg is a KeyCode");
  XM_DEFINE_PROCEDURE(XContext?, XEN_XContext_p_w, 1, 0, 0, "#t if arg is a XContext");
  XM_DEFINE_PROCEDURE(XCharStruct?, XEN_XCharStruct_p_w, 1, 0, 0, "#t if arg is a XCharStruct");
  XM_DEFINE_PROCEDURE(XTextItem?, XEN_XTextItem_p_w, 1, 0, 0, "#t if arg is a XTextItem");
  XM_DEFINE_PROCEDURE(XStandardColormap?, XEN_XStandardColormap_p_w, 1, 0, 0, "#t if arg is a XStandardColormap");
  XM_DEFINE_PROCEDURE(Cursor?, XEN_Cursor_p_w, 1, 0, 0, "#t if arg is a Cursor");
#if HAVE_XM_XP
  XM_DEFINE_PROCEDURE(XPContext?, XEN_XPContext_p_w, 1, 0, 0, "#t if arg is a XPContext");
#endif
#if HAVE_MOTIF
  XM_DEFINE_PROCEDURE(WidgetClass?, XEN_WidgetClass_p_w, 1, 0, 0, "#t if arg is a WidgetClass");
  XM_DEFINE_PROCEDURE(XmString?, XEN_XmString_p_w, 1, 0, 0, "#t if arg is a XmString");
  XM_DEFINE_PROCEDURE(XmToggleButton?, gxm_XmIsToggleButton_w, 1, 0, 0, H_XmIsToggleButton);
  XM_DEFINE_PROCEDURE(XmDrawingArea?, gxm_XmIsDrawingArea_w, 1, 0, 0, H_XmIsDrawingArea);
  XM_DEFINE_PROCEDURE(XmPushButton?, gxm_XmIsPushButton_w, 1, 0, 0, H_XmIsPushButton);
  XM_DEFINE_PROCEDURE(XmTextField?, gxm_XmIsTextField_w, 1, 0, 0, H_XmIsTextField);
  XM_DEFINE_PROCEDURE(XmFileSelectionBox?, gxm_XmIsFileSelectionBox_w, 1, 0, 0, H_XmIsFileSelectionBox);
  XM_DEFINE_PROCEDURE(XmText?, gxm_XmIsText_w, 1, 0, 0, H_XmIsText);
  XM_DEFINE_PROCEDURE(XmFrame?, gxm_XmIsFrame_w, 1, 0, 0, H_XmIsFrame);
  XM_DEFINE_PROCEDURE(XmLabel?, gxm_XmIsLabel_w, 1, 0, 0, H_XmIsLabel);
  XM_DEFINE_PROCEDURE(XmList?, gxm_XmIsList_w, 1, 0, 0, H_XmIsList);
  XM_DEFINE_PROCEDURE(XmArrowButton?, gxm_XmIsArrowButton_w, 1, 0, 0, H_XmIsArrowButton);
  XM_DEFINE_PROCEDURE(XmScrollBar?, gxm_XmIsScrollBar_w, 1, 0, 0, H_XmIsScrollBar);
  XM_DEFINE_PROCEDURE(XmCommand?, gxm_XmIsCommand_w, 1, 0, 0, H_XmIsCommand);
  XM_DEFINE_PROCEDURE(XmScale?, gxm_XmIsScale_w, 1, 0, 0, H_XmIsScale);
  XM_DEFINE_PROCEDURE(XmRowColumn?, gxm_XmIsRowColumn_w, 1, 0, 0, H_XmIsRowColumn);
  XM_DEFINE_PROCEDURE(XmTab?, XEN_XmTab_p_w, 1, 0, 0, "#t if arg is a Tab");
  XM_DEFINE_PROCEDURE(XmNotebook?, gxm_XmIsNotebook_w, 1, 0, 0, H_XmIsNotebook);
#if HAVE_XM_XP
  XM_DEFINE_PROCEDURE(XmPrintShell?, gxm_XmIsPrintShell_w, 1, 0, 0, H_XmIsPrintShell);
#endif
  XM_DEFINE_PROCEDURE(XmComboBox?, gxm_XmIsComboBox_w, 1, 0, 0, H_XmIsComboBox);
  XM_DEFINE_PROCEDURE(XmContainer?, gxm_XmIsContainer_w, 1, 0, 0, H_XmIsContainer);
  XM_DEFINE_PROCEDURE(XmIconHeader?, gxm_XmIsIconHeader_w, 1, 0, 0, H_XmIsIconHeader);
  XM_DEFINE_PROCEDURE(XmGrabShell?, gxm_XmIsGrabShell_w, 1, 0, 0, H_XmIsGrabShell);
  XM_DEFINE_PROCEDURE(XmRendition?, XEN_XmRendition_p_w, 1, 0, 0, "#t if arg is a Rendition");
  XM_DEFINE_PROCEDURE(XmRenderTable?, XEN_XmRenderTable_p_w, 1, 0, 0, "#t if arg is a RenderTable");
  XM_DEFINE_PROCEDURE(XmIconGadget?, gxm_XmIsIconGadget_w, 1, 0, 0, H_XmIsIconGadget);
  XM_DEFINE_PROCEDURE(XmTabList?, XEN_XmTabList_p_w, 1, 0, 0, "#t if arg is a TabList");
  XM_DEFINE_PROCEDURE(XmParseMapping?, XEN_XmParseMapping_p_w, 1, 0, 0, "#t if arg is a ParseMapping");
  XM_DEFINE_PROCEDURE(XmPanedWindow?, gxm_XmIsPanedWindow_w, 1, 0, 0, H_XmIsPanedWindow);
  XM_DEFINE_PROCEDURE(XmScrolledWindow?, gxm_XmIsScrolledWindow_w, 1, 0, 0, H_XmIsScrolledWindow);
  XM_DEFINE_PROCEDURE(XmCascadeButton?, gxm_XmIsCascadeButton_w, 1, 0, 0, H_XmIsCascadeButton);
  XM_DEFINE_PROCEDURE(XmForm?, gxm_XmIsForm_w, 1, 0, 0, H_XmIsForm);
  XM_DEFINE_PROCEDURE(XmBulletinBoard?, gxm_XmIsBulletinBoard_w, 1, 0, 0, H_XmIsBulletinBoard);
  XM_DEFINE_PROCEDURE(XmScreen?, gxm_XmIsScreen_w, 1, 0, 0, H_XmIsScreen);
  XM_DEFINE_PROCEDURE(XmDialogShell?, gxm_XmIsDialogShell_w, 1, 0, 0, H_XmIsDialogShell);
  XM_DEFINE_PROCEDURE(XmDisplay?, gxm_XmIsDisplay_w, 1, 0, 0, H_XmIsDisplay);
  XM_DEFINE_PROCEDURE(XmSelectionBox?, gxm_XmIsSelectionBox_w, 1, 0, 0, H_XmIsSelectionBox);
  XM_DEFINE_PROCEDURE(XmDragContext?, gxm_XmIsDragContext_w, 1, 0, 0, H_XmIsDragContext);
  XM_DEFINE_PROCEDURE(XmDragIconObjectClass?, gxm_XmIsDragIconObjectClass_w, 1, 0, 0, H_XmIsDragIconObjectClass);
  XM_DEFINE_PROCEDURE(XmSeparator?, gxm_XmIsSeparator_w, 1, 0, 0, H_XmIsSeparator);
  XM_DEFINE_PROCEDURE(XmDropSiteManager?, gxm_XmIsDropSiteManager_w, 1, 0, 0, H_XmIsDropSiteManager);
  XM_DEFINE_PROCEDURE(XmDropTransfer?, gxm_XmIsDropTransfer_w, 1, 0, 0, H_XmIsDropTransfer);
  XM_DEFINE_PROCEDURE(XmVendorShell?, gxm_XmIsVendorShell_w, 1, 0, 0, H_XmIsVendorShell);
  XM_DEFINE_PROCEDURE(XmMainWindow?, gxm_XmIsMainWindow_w, 1, 0, 0, H_XmIsMainWindow);
  XM_DEFINE_PROCEDURE(XmMessageBox?, gxm_XmIsMessageBox_w, 1, 0, 0, H_XmIsMessageBox);
  XM_DEFINE_PROCEDURE(XmManager?, gxm_XmIsManager_w, 1, 0, 0, H_XmIsManager);
  XM_DEFINE_PROCEDURE(XmMenuShell?, gxm_XmIsMenuShell_w, 1, 0, 0, H_XmIsMenuShell);
  XM_DEFINE_PROCEDURE(XmLabelGadget?, gxm_XmIsLabelGadget_w, 1, 0, 0, H_XmIsLabelGadget);
  XM_DEFINE_PROCEDURE(XmPushButtonGadget?, gxm_XmIsPushButtonGadget_w, 1, 0, 0, H_XmIsPushButtonGadget);
  XM_DEFINE_PROCEDURE(XmSeparatorGadget?, gxm_XmIsSeparatorGadget_w, 1, 0, 0, H_XmIsSeparatorGadget);
  XM_DEFINE_PROCEDURE(XmArrowButtonGadget?, gxm_XmIsArrowButtonGadget_w, 1, 0, 0, H_XmIsArrowButtonGadget);
  XM_DEFINE_PROCEDURE(XmCascadeButtonGadget?, gxm_XmIsCascadeButtonGadget_w, 1, 0, 0, H_XmIsCascadeButtonGadget);
  XM_DEFINE_PROCEDURE(XmToggleButtonGadget?, gxm_XmIsToggleButtonGadget_w, 1, 0, 0, H_XmIsToggleButtonGadget);
  XM_DEFINE_PROCEDURE(XmDrawnButton?, gxm_XmIsDrawnButton_w, 1, 0, 0, H_XmIsDrawnButton);
  XM_DEFINE_PROCEDURE(XmPrimitive?, gxm_XmIsPrimitive_w, 1, 0, 0, H_XmIsPrimitive);
  XM_DEFINE_PROCEDURE(XmTextSource?, XEN_XmTextSource_p_w, 1, 0, 0, "#t if arg is a TextSource");
#endif

#if HAVE_XPM
  XM_DEFINE_PROCEDURE(XpmAttributes?, XEN_XpmAttributes_p_w, 1, 0, 0, "#t if arg is a XpmAttributes");
  XM_DEFINE_PROCEDURE(XpmImage?, XEN_XpmImage_p_w, 1, 0, 0, "#t if arg is a XpmImage");
  XM_DEFINE_PROCEDURE(XpmColorSymbol?, XEN_XpmColorSymbol_p_w, 1, 0, 0, "#t if arg is a XpmColorSymbol");
#endif
#if HAVE_SCHEME && HAVE_MOTIF
  XEN_DEFINE_PROCEDURE("->string", c_to_xen_string_w, 1, 0, 0, H_to_string);
  XEN_DEFINE_PROCEDURE("->strings", c_to_xen_strings_w, 2, 0, 0, H_to_strings);
  XEN_DEFINE_PROCEDURE("->ints", c_to_xen_ints_w, 2, 0, 0, H_to_ints);
  XEN_DEFINE_PROCEDURE("->Atoms", c_to_xen_atoms_w, 2, 0, 0, H_to_Atoms);
  XEN_DEFINE_PROCEDURE("->XRectangles", c_to_xen_xrectangles_w, 2, 0, 0, H_to_XRectangles);
#endif
#if MUS_WITH_EDITRES
  XM_DEFINE_PROCEDURE(_XEditResCheckMessages, gxm_XEditResCheckMessages_w, 4, 0, 0, NULL);
#endif

#if HAVE_XSHAPEQUERYEXTENSION
  XM_DEFINE_PROCEDURE(XShapeQueryExtension, gxm_XShapeQueryExtension_w, 1, 0, 0, H_XShapeQueryExtension);
  XM_DEFINE_PROCEDURE(XShapeQueryVersion, gxm_XShapeQueryVersion_w, 1, 0, 0, H_XShapeQueryVersion);
  XM_DEFINE_PROCEDURE(XShapeQueryExtents, gxm_XShapeQueryExtents_w, 2, 0, 0, H_XShapeQueryExtents);
  XM_DEFINE_PROCEDURE(XShapeGetRectangles, gxm_XShapeGetRectangles_w, 3, 0, 0, H_XShapeGetRectangles);
  XM_DEFINE_PROCEDURE(XShapeOffsetShape, gxm_XShapeOffsetShape_w, 5, 0, 0, H_XShapeOffsetShape);
  XM_DEFINE_PROCEDURE(XShapeCombineRegion, gxm_XShapeCombineRegion_w, 7, 0, 0, H_XShapeCombineRegion);
  XM_DEFINE_PROCEDURE(XShapeCombineMask, gxm_XShapeCombineMask_w, 7, 0, 0, H_XShapeCombineMask);
  XM_DEFINE_PROCEDURE(XShapeCombineShape, gxm_XShapeCombineShape_w, 8, 0, 0, H_XShapeCombineShape);
  XM_DEFINE_PROCEDURE(XShapeCombineRectangles, gxm_XShapeCombineRectangles_w, 9, 0, 0, H_XShapeCombineRectangles);
#endif

}

static void define_structs(void)
{
  #define XM_DEFINE_ACCESSOR(Name, Value, SetName, SetValue, A1, A2, A3, A4) \
     XEN_DEFINE_PROCEDURE_WITH_SETTER(XM_FIELD_PREFIX #Name XM_POSTFIX, Value, #Name " field accessor", XM_FIELD_PREFIX #SetName XM_POSTFIX, SetValue, A1, A2, A3, A4)
  #define XM_DEFINE_READER(Name, Value, A1, A2, A3) XEN_DEFINE_PROCEDURE(XM_FIELD_PREFIX #Name XM_POSTFIX, Value, A1, A2, A3, #Name " field reader")

  XM_DEFINE_ACCESSOR(pixel, gxm_pixel_w, set_pixel, gxm_set_pixel_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(red, gxm_red_w, set_red, gxm_set_red_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(green, gxm_green_w, set_green, gxm_set_green_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(blue, gxm_blue_w, set_blue, gxm_set_blue_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(flags, gxm_flags_w, set_flags, gxm_set_flags_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(pad, gxm_pad_w, set_pad, gxm_set_pad_w, 1, 0, 2, 0);
  XM_DEFINE_PROCEDURE(XColor, gxm_XColor_w, 0, 6, 0, H_XColor);
  XM_DEFINE_ACCESSOR(x, gxm_x_w, set_x, gxm_set_x_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(y, gxm_y_w, set_y, gxm_set_y_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(width, gxm_width_w, set_width, gxm_set_width_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(height, gxm_height_w, set_height, gxm_set_height_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(angle1, gxm_angle1_w, set_angle1, gxm_set_angle1_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(angle2, gxm_angle2_w, set_angle2, gxm_set_angle2_w, 1, 0, 2, 0);
  XM_DEFINE_PROCEDURE(XArc, gxm_XArc_w, 6, 0, 0, H_XArc);
  XM_DEFINE_PROCEDURE(XWindowChanges, gxm_XWindowChanges_w, 7, 0, 0, H_XWindowChanges);
  XM_DEFINE_PROCEDURE(XSetWindowAttributes, gxm_XSetWindowAttributes_w, 0, 0, 1, H_XSetWindowAttributes);
  XM_DEFINE_PROCEDURE(XPoint, gxm_XPoint_w, 2, 0, 0, H_XPoint);
  XM_DEFINE_ACCESSOR(x1, gxm_x1_w, set_x1, gxm_set_x1_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(y1, gxm_y1_w, set_y1, gxm_set_y1_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(x2, gxm_x2_w, set_x2, gxm_set_x2_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(y2, gxm_y2_w, set_y2, gxm_set_y2_w, 1, 0, 2, 0);
  XM_DEFINE_PROCEDURE(XSegment, gxm_XSegment_w, 4, 0, 0, H_XSegment);
  XM_DEFINE_PROCEDURE(XRectangle, gxm_XRectangle_w, 4, 0, 0, H_XRectangle);
  XM_DEFINE_ACCESSOR(dashes, gxm_dashes_w, set_dashes, gxm_set_dashes_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(dash_offset, gxm_dash_offset_w, set_dash_offset, gxm_set_dash_offset_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(clip_mask, gxm_clip_mask_w, set_clip_mask, gxm_set_clip_mask_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(clip_y_origin, gxm_clip_y_origin_w, set_clip_y_origin, gxm_set_clip_y_origin_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(clip_x_origin, gxm_clip_x_origin_w, set_clip_x_origin, gxm_set_clip_x_origin_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(graphics_exposures, gxm_graphics_exposures_w, set_graphics_exposures, gxm_set_graphics_exposures_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(subwindow_mode, gxm_subwindow_mode_w, set_subwindow_mode, gxm_set_subwindow_mode_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(font, gxm_font_w, set_font, gxm_set_font_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(ts_y_origin, gxm_ts_y_origin_w, set_ts_y_origin, gxm_set_ts_y_origin_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(ts_x_origin, gxm_ts_x_origin_w, set_ts_x_origin, gxm_set_ts_x_origin_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(stipple, gxm_stipple_w, set_stipple, gxm_set_stipple_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(tile, gxm_tile_w, set_tile, gxm_set_tile_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(arc_mode, gxm_arc_mode_w, set_arc_mode, gxm_set_arc_mode_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(fill_rule, gxm_fill_rule_w, set_fill_rule, gxm_set_fill_rule_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(fill_style, gxm_fill_style_w, set_fill_style, gxm_set_fill_style_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(join_style, gxm_join_style_w, set_join_style, gxm_set_join_style_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(cap_style, gxm_cap_style_w, set_cap_style, gxm_set_cap_style_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(line_style, gxm_line_style_w, set_line_style, gxm_set_line_style_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(line_width, gxm_line_width_w, set_line_width, gxm_set_line_width_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(background, gxm_background_w, set_background, gxm_set_background_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(foreground, gxm_foreground_w, set_foreground, gxm_set_foreground_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(plane_mask, gxm_plane_mask_w, set_plane_mask, gxm_set_plane_mask_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(function, gxm_function_w, set_function, gxm_set_function_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(delta, gxm_delta_w, set_delta, gxm_set_delta_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(nchars, gxm_nchars_w, set_nchars, gxm_set_nchars_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(chars, gxm_chars_w, set_chars, gxm_set_chars_w, 1, 0, 2, 0);
  XM_DEFINE_PROCEDURE(XTextItem, gxm_XTextItem_w, 4, 0, 0, H_XTextItem);
  XM_DEFINE_ACCESSOR(name, gxm_name_w, set_name, gxm_set_name_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(depth, gxm_depth_w, set_depth, gxm_set_depth_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(visual, gxm_visual_w, set_visual, gxm_set_visual_w, 1, 0, 2, 0);

  XM_DEFINE_READER(mwidth, gxm_mwidth_w, 1, 0, 0);
  XM_DEFINE_READER(mheight, gxm_mheight_w, 1, 0, 0);
  XM_DEFINE_READER(ndepths, gxm_ndepths_w, 1, 0, 0);
  XM_DEFINE_READER(depths, gxm_depths_w, 1, 0, 0);
  XM_DEFINE_READER(root_depth, gxm_root_depth_w, 1, 0, 0);
  XM_DEFINE_READER(root_visual, gxm_root_visual_w, 1, 0, 0);
  XM_DEFINE_READER(default_gc, gxm_default_gc_w, 1, 0, 0);
  XM_DEFINE_READER(cmap, gxm_cmap_w, 1, 0, 0);
  XM_DEFINE_READER(white_pixel, gxm_white_pixel_w, 1, 0, 0);
  XM_DEFINE_READER(black_pixel, gxm_black_pixel_w, 1, 0, 0);
  XM_DEFINE_READER(max_maps, gxm_max_maps_w, 1, 0, 0);
  XM_DEFINE_READER(min_maps, gxm_min_maps_w, 1, 0, 0);
  XM_DEFINE_ACCESSOR(backing_store, gxm_backing_store_w, set_backing_store, gxm_set_backing_store_w, 1, 0, 2, 0);
  XM_DEFINE_READER(save_unders, gxm_save_unders_w, 1, 0, 0);
  XM_DEFINE_READER(root_input_mask, gxm_root_input_mask_w, 1, 0, 0);
  XM_DEFINE_READER(lbearing, gxm_lbearing_w, 1, 0, 0);
  XM_DEFINE_READER(rbearing, gxm_rbearing_w, 1, 0, 0);
  XM_DEFINE_READER(ascent, gxm_ascent_w, 1, 0, 0);
  XM_DEFINE_READER(descent, gxm_descent_w, 1, 0, 0);
  XM_DEFINE_READER(attributes, gxm_attributes_w, 1, 0, 0);
  XM_DEFINE_READER(card32, gxm_card32_w, 1, 0, 0);
  XM_DEFINE_READER(fid, gxm_fid_w, 1, 0, 0);
  XM_DEFINE_READER(properties, gxm_properties_w, 1, 0, 0);
  XM_DEFINE_READER(min_bounds, gxm_min_bounds_w, 1, 0, 0);
  XM_DEFINE_READER(max_bounds, gxm_max_bounds_w, 1, 0, 0);
  XM_DEFINE_READER(per_char, gxm_per_char_w, 1, 0, 0);

  XM_DEFINE_ACCESSOR(input, gxm_input_w, set_input, gxm_set_input_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(initial_state, gxm_initial_state_w, set_initial_state, gxm_set_initial_state_w, 1, 0, 2, 0);

  XM_DEFINE_READER(icon_pixmap, gxm_icon_pixmap_w, 1, 0, 0);
  XM_DEFINE_READER(icon_window, gxm_icon_window_w, 1, 0, 0);
  XM_DEFINE_READER(icon_x, gxm_icon_x_w, 1, 0, 0);
  XM_DEFINE_READER(icon_y, gxm_icon_y_w, 1, 0, 0);
  XM_DEFINE_READER(icon_mask, gxm_icon_mask_w, 1, 0, 0);
  XM_DEFINE_READER(window_group, gxm_window_group_w, 1, 0, 0);
  XM_DEFINE_READER(visualid, gxm_visualid_w, 1, 0, 0);
  XM_DEFINE_READER(class, gxm_class_w, 1, 0, 0);
  XM_DEFINE_READER(red_mask, gxm_red_mask_w, 1, 0, 0);
  XM_DEFINE_READER(green_mask, gxm_green_mask_w, 1, 0, 0);
  XM_DEFINE_READER(blue_mask, gxm_blue_mask_w, 1, 0, 0);
  XM_DEFINE_READER(bits_per_rgb, gxm_bits_per_rgb_w, 1, 0, 0);
  XM_DEFINE_READER(colormap_size, gxm_colormap_size_w, 1, 0, 0);
  XM_DEFINE_READER(map_entries, gxm_map_entries_w, 1, 0, 0);
  XM_DEFINE_READER(nvisuals, gxm_nvisuals_w, 1, 0, 0);
  XM_DEFINE_READER(visuals, gxm_visuals_w, 1, 0, 0);
  XM_DEFINE_READER(bits_per_pixel, gxm_bits_per_pixel_w, 1, 0, 0);
  XM_DEFINE_READER(background_pixmap, gxm_background_pixmap_w, 1, 0, 0);
  XM_DEFINE_ACCESSOR(background_pixel, gxm_background_pixel_w, set_background_pixel, gxm_set_background_pixel_w, 1, 0, 2, 0);
  XM_DEFINE_READER(border_pixmap, gxm_border_pixmap_w, 1, 0, 0);
  XM_DEFINE_ACCESSOR(border_pixel, gxm_border_pixel_w, set_border_pixel, gxm_set_border_pixel_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(bit_gravity, gxm_bit_gravity_w, set_bit_gravity, gxm_set_bit_gravity_w, 1, 0, 2, 0);
  XM_DEFINE_READER(win_gravity, gxm_win_gravity_w, 1, 0, 0);
  XM_DEFINE_READER(backing_planes, gxm_backing_planes_w, 1, 0, 0);
  XM_DEFINE_READER(backing_pixel, gxm_backing_pixel_w, 1, 0, 0);
  XM_DEFINE_ACCESSOR(save_under, gxm_save_under_w, set_save_under, gxm_set_save_under_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(event_mask, gxm_event_mask_w, set_event_mask, gxm_set_event_mask_w, 1, 0, 2, 0);
  XM_DEFINE_READER(do_not_propagate_mask, gxm_do_not_propagate_mask_w, 1, 0, 0);
  XM_DEFINE_ACCESSOR(cursor, gxm_cursor_w, set_cursor, gxm_set_cursor_w, 1, 0, 2, 0);
  XM_DEFINE_READER(map_installed, gxm_map_installed_w, 1, 0, 0);
  XM_DEFINE_READER(map_state, gxm_map_state_w, 1, 0, 0);
  XM_DEFINE_READER(all_event_masks, gxm_all_event_masks_w, 1, 0, 0);
  XM_DEFINE_READER(your_event_mask, gxm_your_event_mask_w, 1, 0, 0);
  XM_DEFINE_READER(screen, gxm_screen_w, 1, 0, 0);
  XM_DEFINE_READER(xoffset, gxm_xoffset_w, 1, 0, 0);
  XM_DEFINE_READER(byte_order, gxm_byte_order_w, 1, 0, 0);
  XM_DEFINE_READER(bitmap_unit, gxm_bitmap_unit_w, 1, 0, 0);
  XM_DEFINE_READER(bitmap_bit_order, gxm_bitmap_bit_order_w, 1, 0, 0);
  XM_DEFINE_READER(bitmap_pad, gxm_bitmap_pad_w, 1, 0, 0);
  XM_DEFINE_READER(bytes_per_line, gxm_bytes_per_line_w, 1, 0, 0);
  XM_DEFINE_READER(obdata, gxm_obdata_w, 1, 0, 0);
  XM_DEFINE_READER(sibling, gxm_sibling_w, 1, 0, 0);
  XM_DEFINE_READER(stack_mode, gxm_stack_mode_w, 1, 0, 0);
 
  XM_DEFINE_READER(red_max, gxm_red_max_w, 1, 0, 0);
  XM_DEFINE_READER(red_mult, gxm_red_mult_w, 1, 0, 0);
  XM_DEFINE_READER(green_max, gxm_green_max_w, 1, 0, 0);
  XM_DEFINE_READER(green_mult, gxm_green_mult_w, 1, 0, 0);
  XM_DEFINE_READER(blue_max, gxm_blue_max_w, 1, 0, 0);
  XM_DEFINE_READER(blue_mult, gxm_blue_mult_w, 1, 0, 0);
  XM_DEFINE_READER(base_pixel, gxm_base_pixel_w, 1, 0, 0);
  XM_DEFINE_READER(killid, gxm_killid_w, 1, 0, 0);

  XM_DEFINE_READER(min_height, gxm_min_height_w, 1, 0, 0);
  XM_DEFINE_READER(max_height, gxm_max_height_w, 1, 0, 0);
  XM_DEFINE_READER(min_width, gxm_min_width_w, 1, 0, 0);
  XM_DEFINE_READER(max_width, gxm_max_width_w, 1, 0, 0);
  XM_DEFINE_READER(height_inc, gxm_height_inc_w, 1, 0, 0);
  XM_DEFINE_READER(width_inc, gxm_width_inc_w, 1, 0, 0);

#if HAVE_MOTIF
  XM_DEFINE_READER(page_number, gxm_page_number_w, 1, 0, 0);
  XM_DEFINE_READER(page_widget, gxm_page_widget_w, 1, 0, 0);
  XM_DEFINE_READER(status_area_widget, gxm_status_area_widget_w, 1, 0, 0);
  XM_DEFINE_READER(major_tab_widget, gxm_major_tab_widget_w, 1, 0, 0);
  XM_DEFINE_READER(minor_tab_widget, gxm_minor_tab_widget_w, 1, 0, 0);
  XM_DEFINE_READER(source_data, gxm_source_data_w, 1, 0, 0);
  XM_DEFINE_READER(location_data, gxm_location_data_w, 1, 0, 0);
  XM_DEFINE_READER(parm, gxm_parm_w, 1, 0, 0);
  XM_DEFINE_READER(parm_format, gxm_parm_format_w, 1, 0, 0);
  XM_DEFINE_READER(parm_length, gxm_parm_length_w, 1, 0, 0);
  XM_DEFINE_READER(parm_type, gxm_parm_type_w, 1, 0, 0);
  XM_DEFINE_READER(transfer_id, gxm_transfer_id_w, 1, 0, 0);
  XM_DEFINE_READER(destination_data, gxm_destination_data_w, 1, 0, 0);
  XM_DEFINE_READER(remaining, gxm_remaining_w, 1, 0, 0);
  XM_DEFINE_READER(item_or_text, gxm_item_or_text_w, 1, 0, 0);
  XM_DEFINE_READER(auto_selection_type, gxm_auto_selection_type_w, 1, 0, 0);
  XM_DEFINE_READER(new_outline_state, gxm_new_outline_state_w, 1, 0, 0);
  XM_DEFINE_READER(prev_page_number, gxm_prev_page_number_w, 1, 0, 0);
  XM_DEFINE_READER(prev_page_widget, gxm_prev_page_widget_w, 1, 0, 0);
  XM_DEFINE_READER(rendition, gxm_rendition_w, 1, 0, 0);
  XM_DEFINE_READER(render_table, gxm_render_table_w, 1, 0, 0);
#if HAVE_XM_XP
  XM_DEFINE_READER(last_page, gxm_last_page_w, 1, 0, 0);
#endif
  XM_DEFINE_READER(crossed_boundary, gxm_crossed_boundary_w, 1, 0, 0);
  XM_DEFINE_READER(client_data, gxm_client_data_w, 1, 0, 0);
  XM_DEFINE_READER(status, gxm_status_w, 1, 0, 0);
  XM_DEFINE_READER(font_name, gxm_font_name_w, 1, 0, 0);
  XM_DEFINE_READER(tag, gxm_tag_w, 1, 0, 0);
  XM_DEFINE_READER(traversal_destination, gxm_traversal_destination_w, 1, 0, 0);
  XM_DEFINE_READER(dragProtocolStyle, gxm_dragProtocolStyle_w, 1, 0, 0);
  XM_DEFINE_READER(direction, gxm_direction_w, 1, 0, 0);
  XM_DEFINE_READER(position, gxm_position_w, 1, 0, 0);
  XM_DEFINE_ACCESSOR(menuToPost, gxm_menuToPost_w, set_menuToPost, gxm_set_menuToPost_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(postIt, gxm_postIt_w, set_postIt, gxm_set_postIt_w, 1, 0, 2, 0);
  XM_DEFINE_READER(timeStamp, gxm_timeStamp_w, 1, 0, 0);
  XM_DEFINE_ACCESSOR(operation, gxm_operation_w, set_operation, gxm_set_operation_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(reason, gxm_reason_w, set_reason, gxm_set_reason_w, 1, 0, 2, 0);
  XM_DEFINE_READER(operations, gxm_operations_w, 1, 0, 0);
  XM_DEFINE_ACCESSOR(dropSiteStatus, gxm_dropSiteStatus_w, set_dropSiteStatus, gxm_set_dropSiteStatus_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(set, gxm_set_w, set_set, gxm_set_set_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(click_count, gxm_click_count_w, set_click_count, gxm_set_click_count_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(length, gxm_length_w, set_length, gxm_set_length_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(ptr, gxm_ptr_w, set_ptr, gxm_set_ptr_w, 1, 0, 2, 0);
  XM_DEFINE_READER(dropAction, gxm_dropAction_w, 1, 0, 0);
  XM_DEFINE_READER(iccHandle, gxm_iccHandle_w, 1, 0, 0);
  XM_DEFINE_READER(completionStatus, gxm_completionStatus_w, 1, 0, 0);
  XM_DEFINE_READER(dragContext, gxm_dragContext_w, 1, 0, 0);
  XM_DEFINE_READER(animate, gxm_animate_w, 1, 0, 0);
  XM_DEFINE_READER(widget, gxm_widget_w, 1, 0, 0);
  XM_DEFINE_READER(item_position, gxm_item_position_w, 1, 0, 0);
  XM_DEFINE_READER(callbackstruct, gxm_callbackstruct_w, 1, 0, 0);
  XM_DEFINE_READER(item, gxm_item_w, 1, 0, 0);
  XM_DEFINE_READER(item_length, gxm_item_length_w, 1, 0, 0);
  XM_DEFINE_READER(selected_items, gxm_selected_items_w, 1, 0, 0);
  XM_DEFINE_READER(selected_item_count, gxm_selected_item_count_w, 1, 0, 0);
  XM_DEFINE_READER(selected_item_positions, gxm_selected_item_positions_w, 1, 0, 0);
  XM_DEFINE_READER(selection_type, gxm_selection_type_w, 1, 0, 0);
  XM_DEFINE_READER(mask, gxm_mask_w, 1, 0, 0);
  XM_DEFINE_READER(mask_length, gxm_mask_length_w, 1, 0, 0);
  XM_DEFINE_READER(dir, gxm_dir_w, 1, 0, 0);
  XM_DEFINE_READER(dir_length, gxm_dir_length_w, 1, 0, 0);
  XM_DEFINE_READER(pattern, gxm_pattern_w, 1, 0, 0);
  XM_DEFINE_READER(pattern_length, gxm_pattern_length_w, 1, 0, 0);
  XM_DEFINE_READER(currInsert, gxm_currInsert_w, 1, 0, 0);
  XM_DEFINE_READER(newInsert, gxm_newInsert_w, 1, 0, 0);
  XM_DEFINE_READER(startPos, gxm_startPos_w, 1, 0, 0);
  XM_DEFINE_READER(endPos, gxm_endPos_w, 1, 0, 0);
  XM_DEFINE_READER(text, gxm_text_w, 1, 0, 0);
  XM_DEFINE_ACCESSOR(value, gxm_value_w, set_value, gxm_set_value_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(doit, gxm_doit_w, set_doit, gxm_set_doit_w, 1, 0, 2, 0); 
#if HAVE_XmCreateDataField
  XM_DEFINE_READER(w, gxm_w_w, 1, 0, 0);
  XM_DEFINE_READER(accept, gxm_accept_w, 1, 0, 0);
#endif
#if HAVE_XmCreateTabStack
  XM_DEFINE_READER(selected_child, gxm_selected_child_w, 1, 0, 0);
#endif
#if HAVE_XPM
  XM_DEFINE_ACCESSOR(valuemask, gxm_valuemask_w, set_valuemask, gxm_set_valuemask_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(ncolors, gxm_ncolors_w, set_ncolors, gxm_set_ncolors_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(cpp, gxm_cpp_w, set_cpp, gxm_set_cpp_w, 1, 0, 2, 0);
  XM_DEFINE_PROCEDURE(XpmImage, gxm_XpmImage_w, 5, 0, 0, H_XpmImage);
  XM_DEFINE_ACCESSOR(numsymbols, gxm_numsymbols_w, set_numsymbols, gxm_set_numsymbols_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(colorsymbols, gxm_colorsymbols_w, set_colorsymbols, gxm_set_colorsymbols_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(npixels, gxm_npixels_w, set_npixels, gxm_set_npixels_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(y_hotspot, gxm_y_hotspot_w, set_y_hotspot, gxm_set_y_hotspot_w, 1, 0, 2, 0);
  XM_DEFINE_ACCESSOR(x_hotspot, gxm_x_hotspot_w, set_x_hotspot, gxm_set_x_hotspot_w, 1, 0, 2, 0);
  XM_DEFINE_PROCEDURE(XpmColorSymbol, gxm_XpmColorSymbol_w, 3, 0, 0, H_XpmColorSymbol);
  XM_DEFINE_PROCEDURE(XpmAttributes, gxm_XpmAttributes_w, 0, 0, 0, H_XpmAttributes);
#endif
#endif

  XM_DEFINE_ACCESSOR(request_code, gxm_request_code_w, set_request_code, gxm_set_request_code_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(error_code, gxm_error_code_w, set_error_code, gxm_set_error_code_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(first_keycode, gxm_first_keycode_w, set_first_keycode, gxm_set_first_keycode_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(request, gxm_request_w, set_request, gxm_set_request_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(resourceid, gxm_resourceid_w, set_resourceid, gxm_set_resourceid_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(format, gxm_format_w, set_format, gxm_set_format_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(data, gxm_data_w, set_data, gxm_set_data_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(message_type, gxm_message_type_w, set_message_type, gxm_set_message_type_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(new, gxm_new_w, set_new, gxm_set_new_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(property, gxm_property_w, set_property, gxm_set_property_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(display, gxm_display_w, set_display, gxm_set_display_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(target, gxm_target_w, set_target, gxm_set_target_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(requestor, gxm_requestor_w, set_requestor, gxm_set_requestor_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(owner, gxm_owner_w, set_owner, gxm_set_owner_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(selection, gxm_selection_w, set_selection, gxm_set_selection_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(atom, gxm_atom_w, set_atom, gxm_set_atom_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(place, gxm_place_w, set_place, gxm_set_place_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(value_mask, gxm_value_mask_w, set_value_mask, gxm_set_value_mask_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(above, gxm_above_w, set_above, gxm_set_above_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(from_configure, gxm_from_configure_w, set_from_configure, gxm_set_from_configure_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(event, gxm_event_w, set_event, gxm_set_event_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(override_redirect, gxm_override_redirect_w, set_override_redirect, gxm_set_override_redirect_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(border_width, gxm_border_width_w, set_border_width, gxm_set_border_width_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(parent, gxm_parent_w, set_parent, gxm_set_parent_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(minor_code, gxm_minor_code_w, set_minor_code, gxm_set_minor_code_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(major_code, gxm_major_code_w, set_major_code, gxm_set_major_code_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(drawable, gxm_drawable_w, set_drawable, gxm_set_drawable_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(count, gxm_count_w, set_count, gxm_set_count_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(key_vector, gxm_key_vector_w, set_key_vector, gxm_set_key_vector_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(focus, gxm_focus_w, set_focus, gxm_set_focus_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(detail, gxm_detail_w, set_detail, gxm_set_detail_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(mode, gxm_mode_w, set_mode, gxm_set_mode_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(is_hint, gxm_is_hint_w, set_is_hint, gxm_set_is_hint_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(button, gxm_button_w, set_button, gxm_set_button_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(same_screen, gxm_same_screen_w, set_same_screen, gxm_set_same_screen_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(keycode, gxm_keycode_w, set_keycode, gxm_set_keycode_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(state, gxm_state_w, set_state, gxm_set_state_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(y_root, gxm_y_root_w, set_y_root, gxm_set_y_root_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(x_root, gxm_x_root_w, set_x_root, gxm_set_x_root_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(root, gxm_root_w, set_root, gxm_set_root_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(time, gxm_time_w, set_time, gxm_set_time_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(subwindow, gxm_subwindow_w, set_subwindow, gxm_set_subwindow_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(window, gxm_window_w, set_window, gxm_set_window_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(send_event, gxm_send_event_w, set_send_event, gxm_set_send_event_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(serial, gxm_serial_w, set_serial, gxm_set_serial_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(type, gxm_type_w, set_type, gxm_set_type_w, 1, 0, 2, 0); 
  XM_DEFINE_ACCESSOR(colormap, gxm_colormap_w, set_colormap, gxm_set_colormap_w, 1, 0, 2, 0);
}


#if HAVE_MOTIF
/* -------------------------------- string constants -------------------------------- */

/* can't get hcreate in glibc to work so... */

typedef struct {
  char *name;
  xm_resource_t type;
} hdata;

static int alphabet_compare(const void *a, const void *b)
{
  hdata *d1 = *(hdata **)a;
  hdata *d2 = *(hdata **)b;
  return(strcmp(d1->name, d2->name));
}

#define XM_HASH_SIZE 750
/* 616 resources predefined */

static hdata **xm_hash = NULL;
static int hd_ctr = 0;
#define LINKS_SIZE 27
static int hd_links[LINKS_SIZE];

static void hash_resource(char *name, xm_resource_t type)
{
  xm_hash[hd_ctr] = (hdata *)malloc(sizeof(hdata));
  xm_hash[hd_ctr]->name = name;
  xm_hash[hd_ctr++]->type = type;
  if (hd_ctr >= XM_HASH_SIZE) fprintf(stderr, "overflowed hash table!");
}

static xm_resource_t resource_type(char *name)
{
  int i, start, end, ind;
  ind = (int)(name[0]) - 97; 
  /* all the resource names are supposed to start with a lower case alphabetic char */
  /* (char->integer #\a) -> 97 */
  /* unfortunately, we have names like 100DPIString in the newer Motif widgets... */
  if ((ind < 0) || (ind >= LINKS_SIZE))
    {
#if MUS_DEBUGGING
      fprintf(stderr, "link %d for %s?\n", ind, name);
      abort();
#endif
      return(XM_ULONG);
    }
  start = hd_links[ind];
  if (start < 0)
    return(XM_ULONG);
  end = hd_links[ind + 1];
  for (i = start; i < end; i++)
    if (strcmp(name, xm_hash[i]->name) == 0)
      return(xm_hash[i]->type);
  return(XM_ULONG);
}

static void define_strings(void)
{
  #define DEFINE_STRING(Name) XEN_DEFINE(XM_PREFIX #Name XM_POSTFIX, C_TO_XEN_STRING(Name))
  #define DEFINE_RESOURCE(Name, Type) \
            XEN_DEFINE(XM_PREFIX #Name XM_POSTFIX, C_TO_XEN_STRING(Name)); \
            hash_resource(Name, Type)

  xm_hash = (hdata **)calloc(XM_HASH_SIZE, sizeof(hdata *));

  DEFINE_STRING(XmSTRING_DEFAULT_CHARSET);
  DEFINE_STRING(XmFONTLIST_DEFAULT_TAG);
  DEFINE_STRING(XmFONTLIST_DEFAULT_TAG_STRING);

  /* these define special XmVaCreateSimple... arg possibilities */
  DEFINE_STRING(XmVaCASCADEBUTTON);
  DEFINE_STRING(XmVaCHECKBUTTON);
  DEFINE_STRING(XmVaDOUBLE_SEPARATOR);
  DEFINE_STRING(XmVaPUSHBUTTON);
  DEFINE_STRING(XmVaRADIOBUTTON);
  DEFINE_STRING(XmVaSEPARATOR);
  DEFINE_STRING(XmVaSINGLE_SEPARATOR);
  DEFINE_STRING(XmVaTOGGLEBUTTON);
  DEFINE_STRING(XmVaTITLE);
#if 0
  DEFINE_STRING(XtVaNestedList);
  DEFINE_STRING(XtVaTypedArg);
#endif

  /* XM_CALLBACK is used where the resource type is XtCallbackList */

  DEFINE_RESOURCE(XmNaccelerator, XM_STRING);
  DEFINE_RESOURCE(XmNacceleratorText, XM_XMSTRING);
  DEFINE_RESOURCE(XmNaccelerators, XM_ULONG);
  DEFINE_RESOURCE(XmNactivateCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNadjustLast, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNadjustMargin, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNalignment, XM_UCHAR);
  DEFINE_RESOURCE(XmNallowOverlap, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNallowResize, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNallowShellResize, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNancestorSensitive, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNanimationMask, XM_PIXMAP);
  DEFINE_RESOURCE(XmNanimationPixmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNanimationPixmapDepth, XM_INT);
  DEFINE_RESOURCE(XmNanimationStyle, XM_UCHAR);
  DEFINE_RESOURCE(XmNapplyCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNapplyLabelString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNargc, XM_INT);
  DEFINE_RESOURCE(XmNargv, XM_STRING_LIST);
  DEFINE_RESOURCE(XmNarmCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNarmColor, XM_PIXEL);
  DEFINE_RESOURCE(XmNarmPixmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNarrowDirection, XM_UCHAR);
  DEFINE_RESOURCE(XmNattachment, XM_UCHAR);
  DEFINE_RESOURCE(XmNaudibleWarning, XM_UCHAR);
  DEFINE_RESOURCE(XmNautoShowCursorPosition, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNautoUnmanage, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNautomaticSelection, XM_UCHAR);
  DEFINE_RESOURCE(XmNbackground, XM_PIXEL);
  DEFINE_RESOURCE(XmNbackgroundPixmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNbaseHeight, XM_INT);
  DEFINE_RESOURCE(XmNbaseWidth, XM_INT);
  DEFINE_RESOURCE(XmNbitmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNblendModel, XM_ULONG);
  DEFINE_RESOURCE(XmNblinkRate, XM_INT);
  /* DEFINE_RESOURCE(XmNborder, XM_ULONG); */
  DEFINE_RESOURCE(XmNborderColor, XM_PIXEL);
  DEFINE_RESOURCE(XmNborderPixmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNborderWidth, XM_DIMENSION);
  DEFINE_RESOURCE(XmNbottomAttachment, XM_UCHAR);
  DEFINE_RESOURCE(XmNbottomOffset, XM_INT);
  DEFINE_RESOURCE(XmNbottomPosition, XM_INT);
  DEFINE_RESOURCE(XmNbottomShadowColor, XM_PIXEL);
  DEFINE_RESOURCE(XmNbottomShadowPixmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNbottomWidget, XM_WIDGET);
  DEFINE_RESOURCE(XmNbrowseSelectionCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNbuttonAcceleratorText, XM_STRING_TABLE);
  DEFINE_RESOURCE(XmNbuttonAccelerators, XM_STRING_TABLE);
  DEFINE_RESOURCE(XmNbuttonCount, XM_INT);
  DEFINE_RESOURCE(XmNbuttonMnemonicCharSets, XM_CHARSET_TABLE);
  DEFINE_RESOURCE(XmNbuttonMnemonics, XM_KEYSYM_TABLE);
  DEFINE_RESOURCE(XmNbuttonSet, XM_INT);
  DEFINE_RESOURCE(XmNbuttonType, XM_ULONG);
  DEFINE_RESOURCE(XmNbuttons, XM_STRING_TABLE);
  DEFINE_RESOURCE(XmNcancelButton, XM_WIDGET);
  DEFINE_RESOURCE(XmNcancelCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNcancelLabelString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNcascadePixmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNcascadingCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNchildHorizontalAlignment, XM_UCHAR);
  DEFINE_RESOURCE(XmNchildHorizontalSpacing, XM_DIMENSION);
  DEFINE_RESOURCE(XmNchildPlacement, XM_UCHAR);
  DEFINE_RESOURCE(XmNchildVerticalAlignment, XM_UCHAR);
  DEFINE_RESOURCE(XmNchildren, XM_WIDGET_LIST);
  DEFINE_RESOURCE(XmNclientData, XM_ULONG);
  DEFINE_RESOURCE(XmNclipWindow, XM_WIDGET);
  DEFINE_RESOURCE(XmNcolormap, XM_COLORMAP);
  DEFINE_RESOURCE(XmNcolumns, XM_SHORT);
  DEFINE_RESOURCE(XmNcommand, XM_XMSTRING);
  DEFINE_RESOURCE(XmNcommandChangedCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNcommandEnteredCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNcommandWindow, XM_WIDGET);
  DEFINE_RESOURCE(XmNcommandWindowLocation, XM_UCHAR);
  DEFINE_RESOURCE(XmNconvertProc, XM_CONVERT_CALLBACK);
  DEFINE_RESOURCE(XmNcreatePopupChildProc, XM_POPUP_CALLBACK);
  DEFINE_RESOURCE(XmNcursorBackground, XM_PIXEL);
  DEFINE_RESOURCE(XmNcursorForeground, XM_PIXEL);
  DEFINE_RESOURCE(XmNcursorPosition, XM_INT);
  DEFINE_RESOURCE(XmNcursorPositionVisible, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNdarkThreshold, XM_INT);
  DEFINE_RESOURCE(XmNdecimalPoints, XM_SHORT);
  DEFINE_RESOURCE(XmNdecrementCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNdefaultActionCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNdefaultButton, XM_WIDGET);
  DEFINE_RESOURCE(XmNdefaultButtonShadowThickness, XM_DIMENSION);
  DEFINE_RESOURCE(XmNdefaultButtonType, XM_UCHAR);
  DEFINE_RESOURCE(XmNdefaultCopyCursorIcon, XM_WIDGET);
  DEFINE_RESOURCE(XmNdefaultInvalidCursorIcon, XM_WIDGET);
  DEFINE_RESOURCE(XmNdefaultLinkCursorIcon, XM_WIDGET);
  DEFINE_RESOURCE(XmNdefaultMoveCursorIcon, XM_WIDGET);
  DEFINE_RESOURCE(XmNdefaultNoneCursorIcon, XM_WIDGET);
  DEFINE_RESOURCE(XmNdefaultPosition, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNdefaultSourceCursorIcon, XM_WIDGET);
  DEFINE_RESOURCE(XmNdefaultValidCursorIcon, XM_WIDGET);
  DEFINE_RESOURCE(XmNdeleteResponse, XM_UCHAR);
  DEFINE_RESOURCE(XmNdepth, XM_INT);
  DEFINE_RESOURCE(XmNdestroyCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNdialogStyle, XM_UCHAR);
  DEFINE_RESOURCE(XmNdialogTitle, XM_XMSTRING);
  DEFINE_RESOURCE(XmNdialogType, XM_UCHAR);
  DEFINE_RESOURCE(XmNdirListItemCount, XM_INT);
  DEFINE_RESOURCE(XmNdirListItems, XM_STRING_TABLE);
  DEFINE_RESOURCE(XmNdirListLabelString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNdirMask, XM_XMSTRING);
  DEFINE_RESOURCE(XmNdirSearchProc, XM_SEARCH_CALLBACK);
  DEFINE_RESOURCE(XmNdirSpec, XM_XMSTRING);
  DEFINE_RESOURCE(XmNdirectory, XM_XMSTRING);
  DEFINE_RESOURCE(XmNdirectoryValid, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNdisarmCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNdoubleClickInterval, XM_INT);
  DEFINE_RESOURCE(XmNdragCallback, XM_CALLBACK); /* scale slider etc */
  DEFINE_RESOURCE(XmNdragDropFinishCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNdragInitiatorProtocolStyle, XM_UCHAR);
  DEFINE_RESOURCE(XmNdragMotionCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNdragOperations, XM_UCHAR);
  DEFINE_RESOURCE(XmNdragProc, XM_DRAG_CALLBACK); /* drag and drop, not scale drag */
  DEFINE_RESOURCE(XmNdragReceiverProtocolStyle, XM_UCHAR);
  DEFINE_RESOURCE(XmNdropFinishCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNdropProc, XM_DROP_CALLBACK);
  DEFINE_RESOURCE(XmNdropRectangles, XM_RECTANGLE_LIST);
  DEFINE_RESOURCE(XmNdropSiteActivity, XM_UCHAR);
  DEFINE_RESOURCE(XmNdropSiteEnterCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNdropSiteLeaveCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNdropSiteOperations, XM_UCHAR);
  DEFINE_RESOURCE(XmNdropSiteType, XM_UCHAR);
  DEFINE_RESOURCE(XmNdropStartCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNdropTransfers, XM_TRANSFER_ENTRY_LIST);
  DEFINE_RESOURCE(XmNeditMode, XM_INT);
  DEFINE_RESOURCE(XmNeditable, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNentryAlignment, XM_UCHAR);
  DEFINE_RESOURCE(XmNentryBorder, XM_DIMENSION);
  DEFINE_RESOURCE(XmNentryCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNentryClass, XM_WIDGET_CLASS);
  DEFINE_RESOURCE(XmNentryVerticalAlignment, XM_UCHAR);
  DEFINE_RESOURCE(XmNexportTargets, XM_ATOM_LIST);
  DEFINE_RESOURCE(XmNexposeCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNextendedSelectionCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNfileListItemCount, XM_INT);
  DEFINE_RESOURCE(XmNfileListItems, XM_STRING_TABLE);
  DEFINE_RESOURCE(XmNfileListLabelString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNfileSearchProc, XM_SEARCH_CALLBACK);
  DEFINE_RESOURCE(XmNfileTypeMask, XM_UCHAR);
  DEFINE_RESOURCE(XmNfillOnArm, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNfillOnSelect, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNfilterLabelString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNfocusCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNfont, XM_XFONTSTRUCT);
  DEFINE_RESOURCE(XmNforeground, XM_PIXEL);
  DEFINE_RESOURCE(XmNforegroundThreshold, XM_INT);
  DEFINE_RESOURCE(XmNfractionBase, XM_INT);
  DEFINE_RESOURCE(XmNgainPrimaryCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNgeometry, XM_STRING);
  DEFINE_RESOURCE(XmNheight, XM_DIMENSION);
  DEFINE_RESOURCE(XmNheightInc, XM_INT);
  DEFINE_RESOURCE(XmNhelpCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNhelpLabelString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNhighlightColor, XM_PIXEL);
  DEFINE_RESOURCE(XmNhighlightOnEnter, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNhighlightPixmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNhighlightThickness, XM_DIMENSION);
  DEFINE_RESOURCE(XmNhistoryItemCount, XM_INT);
  DEFINE_RESOURCE(XmNhistoryItems, XM_STRING_TABLE);
  DEFINE_RESOURCE(XmNhistoryMaxItems, XM_INT);
  DEFINE_RESOURCE(XmNhistoryVisibleItemCount, XM_INT);
  DEFINE_RESOURCE(XmNhorizontalFontUnit, XM_INT);
  DEFINE_RESOURCE(XmNhorizontalScrollBar, XM_WIDGET);
  DEFINE_RESOURCE(XmNhorizontalSpacing, XM_DIMENSION);
  DEFINE_RESOURCE(XmNhotX, XM_POSITION);
  DEFINE_RESOURCE(XmNhotY, XM_POSITION);
  DEFINE_RESOURCE(XmNiconMask, XM_PIXMAP);
  DEFINE_RESOURCE(XmNiconName, XM_STRING);
  DEFINE_RESOURCE(XmNiconNameEncoding, XM_ATOM);
  DEFINE_RESOURCE(XmNiconPixmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNiconWindow, XM_WIDGET);
  DEFINE_RESOURCE(XmNiconX, XM_INT);
  DEFINE_RESOURCE(XmNiconY, XM_INT);
  DEFINE_RESOURCE(XmNiconic, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNimportTargets, XM_ATOM_LIST);
  DEFINE_RESOURCE(XmNincrement, XM_INT);
  DEFINE_RESOURCE(XmNincrementCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNincremental, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNindicatorOn, XM_INT);
  DEFINE_RESOURCE(XmNindicatorSize, XM_DIMENSION);
  DEFINE_RESOURCE(XmNindicatorType, XM_UCHAR);
  DEFINE_RESOURCE(XmNinitialDelay, XM_INT);
  DEFINE_RESOURCE(XmNinitialFocus, XM_WIDGET);
  DEFINE_RESOURCE(XmNinitialResourcesPersistent, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNinitialState, XM_INT);
  DEFINE_RESOURCE(XmNinput, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNinputCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNinputMethod, XM_STRING);
  DEFINE_RESOURCE(XmNinsertPosition, XM_ORDER_CALLBACK);
  DEFINE_RESOURCE(XmNinvalidCursorForeground, XM_PIXEL);
  DEFINE_RESOURCE(XmNisAligned, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNisHomogeneous, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNitemCount, XM_INT);
  DEFINE_RESOURCE(XmNitems, XM_STRING_TABLE);
  DEFINE_RESOURCE(XmNkeyboardFocusPolicy, XM_UCHAR);
  DEFINE_RESOURCE(XmNlabelInsensitivePixmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNlabelPixmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNlabelString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNlabelType, XM_UCHAR);
  DEFINE_RESOURCE(XmNleftAttachment, XM_UCHAR);
  DEFINE_RESOURCE(XmNleftOffset, XM_INT);
  DEFINE_RESOURCE(XmNleftPosition, XM_INT);
  DEFINE_RESOURCE(XmNleftWidget, XM_WIDGET);
  DEFINE_RESOURCE(XmNlightThreshold, XM_INT);
  DEFINE_RESOURCE(XmNlistItemCount, XM_INT);
  DEFINE_RESOURCE(XmNlistItems, XM_STRING_TABLE);
  DEFINE_RESOURCE(XmNlistLabelString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNlistMarginHeight, XM_DIMENSION);
  DEFINE_RESOURCE(XmNlistMarginWidth, XM_DIMENSION);
  DEFINE_RESOURCE(XmNlistSizePolicy, XM_UCHAR);
  DEFINE_RESOURCE(XmNlistSpacing, XM_DIMENSION);
  DEFINE_RESOURCE(XmNlistUpdated, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNlistVisibleItemCount, XM_INT);
  DEFINE_RESOURCE(XmNlosePrimaryCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNlosingFocusCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNmainWindowMarginHeight, XM_DIMENSION);
  DEFINE_RESOURCE(XmNmainWindowMarginWidth, XM_DIMENSION);
  DEFINE_RESOURCE(XmNmapCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNmappedWhenManaged, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNmappingDelay, XM_INT);
  DEFINE_RESOURCE(XmNmargin, XM_DIMENSION);
  DEFINE_RESOURCE(XmNmarginBottom, XM_DIMENSION);
  DEFINE_RESOURCE(XmNmarginHeight, XM_DIMENSION);
  DEFINE_RESOURCE(XmNmarginLeft, XM_DIMENSION);
  DEFINE_RESOURCE(XmNmarginRight, XM_DIMENSION);
  DEFINE_RESOURCE(XmNmarginTop, XM_DIMENSION);
  DEFINE_RESOURCE(XmNmarginWidth, XM_DIMENSION);
  DEFINE_RESOURCE(XmNmask, XM_PIXMAP);
  DEFINE_RESOURCE(XmNmaxAspectX, XM_INT);
  DEFINE_RESOURCE(XmNmaxAspectY, XM_INT);
  DEFINE_RESOURCE(XmNmaxHeight, XM_INT);
  DEFINE_RESOURCE(XmNmaxLength, XM_INT);
  DEFINE_RESOURCE(XmNmaxWidth, XM_INT);
  DEFINE_RESOURCE(XmNmaximum, XM_INT);
  DEFINE_RESOURCE(XmNmenuAccelerator, XM_STRING);
  DEFINE_RESOURCE(XmNmenuBar, XM_WIDGET);
  DEFINE_RESOURCE(XmNmenuCursor, XM_STRING);
  DEFINE_RESOURCE(XmNmenuHelpWidget, XM_WIDGET);
  DEFINE_RESOURCE(XmNmenuHistory, XM_WIDGET);
  DEFINE_RESOURCE(XmNmenuPost, XM_STRING);
  DEFINE_RESOURCE(XmNmessageAlignment, XM_UCHAR);
  DEFINE_RESOURCE(XmNmessageString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNmessageWindow, XM_WIDGET);
  DEFINE_RESOURCE(XmNminAspectX, XM_INT);
  DEFINE_RESOURCE(XmNminAspectY, XM_INT);
  DEFINE_RESOURCE(XmNminHeight, XM_INT);
  DEFINE_RESOURCE(XmNminWidth, XM_INT);
  DEFINE_RESOURCE(XmNminimizeButtons, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNminimum, XM_INT);
  DEFINE_RESOURCE(XmNmnemonic, XM_KEYSYM);
  DEFINE_RESOURCE(XmNmnemonicCharSet, XM_STRING);
  DEFINE_RESOURCE(XmNmodifyVerifyCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNmotionVerifyCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNmoveOpaque, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNmultiClick, XM_UCHAR);
  DEFINE_RESOURCE(XmNmultipleSelectionCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNmustMatch, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNmwmDecorations, XM_INT);
  DEFINE_RESOURCE(XmNmwmFunctions, XM_INT);
  DEFINE_RESOURCE(XmNmwmInputMode, XM_INT);
  DEFINE_RESOURCE(XmNmwmMenu, XM_STRING);
  DEFINE_RESOURCE(XmNnavigationType, XM_UCHAR);
  DEFINE_RESOURCE(XmNnoMatchCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNnoMatchString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNnoResize, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNnoneCursorForeground, XM_PIXEL);
  DEFINE_RESOURCE(XmNnumChildren, XM_INT);
  DEFINE_RESOURCE(XmNnumColumns, XM_SHORT);
  DEFINE_RESOURCE(XmNnumDropRectangles, XM_INT);
  DEFINE_RESOURCE(XmNnumDropTransfers, XM_INT);
  DEFINE_RESOURCE(XmNnumExportTargets, XM_INT);
  DEFINE_RESOURCE(XmNnumImportTargets, XM_INT);
  DEFINE_RESOURCE(XmNoffsetX, XM_POSITION);
  DEFINE_RESOURCE(XmNoffsetY, XM_POSITION);
  DEFINE_RESOURCE(XmNokCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNokLabelString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNoperationChangedCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNoperationCursorIcon, XM_WIDGET);
  DEFINE_RESOURCE(XmNoptionLabel, XM_XMSTRING);
  DEFINE_RESOURCE(XmNoptionMnemonic, XM_KEYSYM);
  DEFINE_RESOURCE(XmNorientation, XM_UCHAR);
  DEFINE_RESOURCE(XmNoverrideRedirect, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNpacking, XM_UCHAR);
  DEFINE_RESOURCE(XmNpageDecrementCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNpageIncrement, XM_INT);
  DEFINE_RESOURCE(XmNpageIncrementCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNpaneMaximum, XM_DIMENSION);
  DEFINE_RESOURCE(XmNpaneMinimum, XM_DIMENSION);
  DEFINE_RESOURCE(XmNpattern, XM_STRING_OR_XMSTRING);
  DEFINE_RESOURCE(XmNpendingDelete, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNpixmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNpopdownCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNpopupCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNpopupEnabled, XM_INT); /* docs say boolean, but that is incorrect -- see rowcolumn docs */
  DEFINE_RESOURCE(XmNpositionIndex, XM_SHORT);
  DEFINE_RESOURCE(XmNpostFromButton, XM_INT);
  DEFINE_RESOURCE(XmNpreeditType, XM_STRING);
  DEFINE_RESOURCE(XmNprocessingDirection, XM_UCHAR);
  DEFINE_RESOURCE(XmNpromptString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNpushButtonEnabled, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNqualifySearchDataProc, XM_QUALIFY_CALLBACK);
  DEFINE_RESOURCE(XmNradioAlwaysOne, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNradioBehavior, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNrecomputeSize, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNrefigureMode, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNrepeatDelay, XM_INT);
  DEFINE_RESOURCE(XmNresizable, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNresizeCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNresizeHeight, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNresizePolicy, XM_UCHAR);
  DEFINE_RESOURCE(XmNresizeWidth, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNrightAttachment, XM_UCHAR);
  DEFINE_RESOURCE(XmNrightOffset, XM_INT);
  DEFINE_RESOURCE(XmNrightPosition, XM_INT);
  DEFINE_RESOURCE(XmNrightWidget, XM_WIDGET);
  DEFINE_RESOURCE(XmNrowColumnType, XM_UCHAR);
  DEFINE_RESOURCE(XmNrows, XM_SHORT);
  DEFINE_RESOURCE(XmNrubberPositioning, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNsashHeight, XM_DIMENSION);
  DEFINE_RESOURCE(XmNsashIndent, XM_POSITION);
  DEFINE_RESOURCE(XmNsashShadowThickness, XM_DIMENSION);
  DEFINE_RESOURCE(XmNsashWidth, XM_DIMENSION);
  DEFINE_RESOURCE(XmNsaveUnder, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNscaleHeight, XM_DIMENSION);
  DEFINE_RESOURCE(XmNscaleMultiple, XM_INT);
  DEFINE_RESOURCE(XmNscaleWidth, XM_DIMENSION);
  DEFINE_RESOURCE(XmNscreen, XM_SCREEN);
  DEFINE_RESOURCE(XmNscrollBarDisplayPolicy, XM_UCHAR);
  DEFINE_RESOURCE(XmNscrollBarPlacement, XM_UCHAR);
  DEFINE_RESOURCE(XmNscrollHorizontal, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNscrollLeftSide, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNscrollTopSide, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNscrollVertical, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNscrolledWindowMarginHeight, XM_DIMENSION);
  DEFINE_RESOURCE(XmNscrolledWindowMarginWidth, XM_DIMENSION);
  DEFINE_RESOURCE(XmNscrollingPolicy, XM_UCHAR);
  DEFINE_RESOURCE(XmNselectColor, XM_PIXEL);
  DEFINE_RESOURCE(XmNselectInsensitivePixmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNselectPixmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNselectThreshold, XM_INT);
  DEFINE_RESOURCE(XmNselectedItemCount, XM_INT);
  DEFINE_RESOURCE(XmNselectedItems, XM_STRING_TABLE);
  DEFINE_RESOURCE(XmNselectionArray, XM_INT_TABLE);
  DEFINE_RESOURCE(XmNselectionArrayCount, XM_INT);
  DEFINE_RESOURCE(XmNselectionLabelString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNselectionPolicy, XM_UCHAR);
  DEFINE_RESOURCE(XmNsensitive, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNseparatorOn, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNseparatorType, XM_UCHAR);
  DEFINE_RESOURCE(XmNset, XM_UCHAR);
  DEFINE_RESOURCE(XmNshadowThickness, XM_DIMENSION);
  DEFINE_RESOURCE(XmNshadowType, XM_UCHAR);
  DEFINE_RESOURCE(XmNshowArrows, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNshowAsDefault, XM_DIMENSION);
  DEFINE_RESOURCE(XmNshowSeparator, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNshowValue, XM_BOOLEAN_OR_INT); /* should be int, but that's incompatible with tons of existing code */
  DEFINE_RESOURCE(XmNsimpleCallback, XM_CALLBACK);
  /* doc p905 calls this an XtCallbackProc (not list), but next pages says it's a list, Motif sources appear to treat it as a proc */
  DEFINE_RESOURCE(XmNsingleSelectionCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNskipAdjust, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNsliderSize, XM_INT);
  DEFINE_RESOURCE(XmNsliderVisual, XM_INT);
  DEFINE_RESOURCE(XmNslidingMode, XM_INT);
  DEFINE_RESOURCE(XmNsource, XM_TEXT_SOURCE);
  DEFINE_RESOURCE(XmNsourceCursorIcon, XM_WIDGET);
  DEFINE_RESOURCE(XmNsourcePixmapIcon, XM_WIDGET);
  DEFINE_RESOURCE(XmNspacing, XM_DIMENSION);
  DEFINE_RESOURCE(XmNspotLocation, XM_INT);
  DEFINE_RESOURCE(XmNstateCursorIcon, XM_WIDGET);
  DEFINE_RESOURCE(XmNsubMenuId, XM_WIDGET);
  DEFINE_RESOURCE(XmNsymbolPixmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNtearOffMenuActivateCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNtearOffMenuDeactivateCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNtearOffModel, XM_UCHAR);
  DEFINE_RESOURCE(XmNtextAccelerators, XM_ULONG);
  DEFINE_RESOURCE(XmNtextColumns, XM_SHORT);
  DEFINE_RESOURCE(XmNtextString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNtextTranslations, XM_CALLBACK);
  DEFINE_RESOURCE(XmNtitle, XM_STRING);
  DEFINE_RESOURCE(XmNtitleEncoding, XM_ATOM);
  DEFINE_RESOURCE(XmNtitleString, XM_XMSTRING);
#ifdef XmNtoolTipString
  DEFINE_RESOURCE(XmNtoolTipString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNtoolTipPostDelay, XM_INT);
  DEFINE_RESOURCE(XmNtoolTipPostDuration, XM_INT);
  DEFINE_RESOURCE(XmNtoolTipEnable, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNanimate, XM_BOOLEAN);
#endif
  DEFINE_RESOURCE(XmNtoBottomCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNtoTopCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNtopAttachment, XM_UCHAR);
  DEFINE_RESOURCE(XmNtopCharacter, XM_INT);
  DEFINE_RESOURCE(XmNtopItemPosition, XM_INT);
  DEFINE_RESOURCE(XmNtopLevelEnterCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNtopLevelLeaveCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNtopOffset, XM_INT);
  DEFINE_RESOURCE(XmNtopPosition, XM_INT);
  DEFINE_RESOURCE(XmNtopShadowColor, XM_PIXEL);
  DEFINE_RESOURCE(XmNtopShadowPixmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNtopWidget, XM_WIDGET);
  DEFINE_RESOURCE(XmNtransferProc, XM_TRANSFER_CALLBACK);
  DEFINE_RESOURCE(XmNtransferStatus, XM_UCHAR);
  DEFINE_RESOURCE(XmNtransient, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNtransientFor, XM_WIDGET);
  DEFINE_RESOURCE(XmNtranslations, XM_CALLBACK);
  DEFINE_RESOURCE(XmNtraversalOn, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNtraverseObscuredCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNtroughColor, XM_PIXEL);
  DEFINE_RESOURCE(XmNunitType, XM_UCHAR);
  DEFINE_RESOURCE(XmNunmapCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNunpostBehavior, XM_UCHAR);
  DEFINE_RESOURCE(XmNuseAsyncGeometry, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNuserData, XM_ULONG);
  DEFINE_RESOURCE(XmNvalidCursorForeground, XM_PIXEL);
  DEFINE_RESOURCE(XmNvalue, XM_STRING_OR_INT);
  DEFINE_RESOURCE(XmNvalueChangedCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNverifyBell, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNverticalFontUnit, XM_INT);
  DEFINE_RESOURCE(XmNverticalScrollBar, XM_WIDGET);
  DEFINE_RESOURCE(XmNverticalSpacing, XM_DIMENSION);
  DEFINE_RESOURCE(XmNvisibleItemCount, XM_INT);
  DEFINE_RESOURCE(XmNvisibleWhenOff, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNvisual, XM_VISUAL);
  DEFINE_RESOURCE(XmNvisualPolicy, XM_UCHAR);
  DEFINE_RESOURCE(XmNwidth, XM_DIMENSION);
  DEFINE_RESOURCE(XmNwidthInc, XM_INT);
  DEFINE_RESOURCE(XmNwinGravity, XM_INT);
  DEFINE_RESOURCE(XmNwindow, XM_WIDGET);
  DEFINE_RESOURCE(XmNwindowGroup, XM_WINDOW);
  DEFINE_RESOURCE(XmNwmTimeout, XM_INT);
  DEFINE_RESOURCE(XmNwordWrap, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNworkWindow, XM_WIDGET);
  DEFINE_RESOURCE(XmNx, XM_POSITION);
  DEFINE_RESOURCE(XmNy, XM_POSITION);
  DEFINE_RESOURCE(XmNarrowLayout, XM_UCHAR);
  DEFINE_RESOURCE(XmNarrowOrientation, XM_UCHAR);
  DEFINE_RESOURCE(XmNarrowSensitivity, XM_UCHAR);
  DEFINE_RESOURCE(XmNarrowSize, XM_INT);
  DEFINE_RESOURCE(XmNarrowSpacing, XM_INT);
  DEFINE_RESOURCE(XmNautoDragModel, XM_INT);
  DEFINE_RESOURCE(XmNbackPageBackground, XM_PIXEL);
  DEFINE_RESOURCE(XmNbackPageForeground, XM_PIXEL);
  DEFINE_RESOURCE(XmNbackPageNumber, XM_INT);
  DEFINE_RESOURCE(XmNbackPagePlacement, XM_UCHAR);
  DEFINE_RESOURCE(XmNbackPageSize, XM_DIMENSION);
  DEFINE_RESOURCE(XmNbindingPixmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNbindingType, XM_UCHAR);
  DEFINE_RESOURCE(XmNbindingWidth, XM_INT);
  DEFINE_RESOURCE(XmNbitmapConversionModel, XM_INT);
  DEFINE_RESOURCE(XmNbuttonRenderTable, XM_RENDER_TABLE);
  DEFINE_RESOURCE(XmNcollapsedStatePixmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNcolorAllocationProc, XM_ALLOC_COLOR_CALLBACK);
  DEFINE_RESOURCE(XmNcolorCalculationProc, XM_SCREEN_COLOR_CALLBACK);
  DEFINE_RESOURCE(XmNcomboBoxType, XM_UCHAR);
  DEFINE_RESOURCE(XmNconvertCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNcurrentPageNumber, XM_INT);
  DEFINE_RESOURCE(XmNdecimal, XM_STRING);
  DEFINE_RESOURCE(XmNdefaultArrowSensitivity, XM_UCHAR);
  DEFINE_RESOURCE(XmNdefaultButtonEmphasis, XM_INT);
  DEFINE_RESOURCE(XmNdefaultVirtualBindings, XM_STRING);
  DEFINE_RESOURCE(XmNdestinationCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNdetail, XM_STRING_TABLE);
  DEFINE_RESOURCE(XmNdetailColumnHeading, XM_INT);
  DEFINE_RESOURCE(XmNdetailColumnHeadingCount, XM_INT);
  DEFINE_RESOURCE(XmNdetailCount, XM_INT);
  DEFINE_RESOURCE(XmNdetailOrder, XM_INT_TABLE);
  DEFINE_RESOURCE(XmNdetailOrderCount, XM_INT);
  DEFINE_RESOURCE(XmNdetailShadowThickness, XM_INT);
  DEFINE_RESOURCE(XmNdetailTabList, XM_TAB_LIST);
  DEFINE_RESOURCE(XmNdirTextLabelString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNdragStartCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNenableBtn1Transfer, XM_INT);
  DEFINE_RESOURCE(XmNenableButtonTab, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNenableDragIcon, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNenableEtchedInMenu, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNenableMultiKeyBindings, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNenableThinThickness, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNenableToggleColor, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNenableToggleVisual, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNenableUnselectableDrag, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNenableWarp, XM_INT);
#if HAVE_XP
  DEFINE_RESOURCE(XmNendJobCallback, XM_CALLBACK);
#endif
  DEFINE_RESOURCE(XmNentryParent, XM_WIDGET);
  DEFINE_RESOURCE(XmNentryViewType, XM_UCHAR);
  DEFINE_RESOURCE(XmNexpandedStatePixmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNfileFilterStyle, XM_INT);
  DEFINE_RESOURCE(XmNfirstPageNumber, XM_INT);
  DEFINE_RESOURCE(XmNfontName, XM_STRING);
  DEFINE_RESOURCE(XmNfontType, XM_UCHAR);
  DEFINE_RESOURCE(XmNframeBackground, XM_PIXEL);
  DEFINE_RESOURCE(XmNframeChildType, XM_UCHAR);
  DEFINE_RESOURCE(XmNframeShadowThickness, XM_DIMENSION);
  DEFINE_RESOURCE(XmNgrabStyle, XM_INT);
  DEFINE_RESOURCE(XmNincludeStatus, XM_INT);
  DEFINE_RESOURCE(XmNincrementValue, XM_INT);
  DEFINE_RESOURCE(XmNindeterminateInsensitivePixmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNindeterminatePixmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNinnerMarginHeight, XM_DIMENSION);
  DEFINE_RESOURCE(XmNinnerMarginWidth, XM_DIMENSION);
  DEFINE_RESOURCE(XmNinputPolicy, XM_ULONG);
  DEFINE_RESOURCE(XmNinsensitiveStippleBitmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNinvokeParseProc, XM_PARSE_CALLBACK);
  DEFINE_RESOURCE(XmNlabelRenderTable, XM_RENDER_TABLE);
  DEFINE_RESOURCE(XmNlargeCellHeight, XM_DIMENSION);
  DEFINE_RESOURCE(XmNlargeCellWidth, XM_DIMENSION);
  DEFINE_RESOURCE(XmNlargeIconMask, XM_PIXMAP);
  DEFINE_RESOURCE(XmNlargeIconPixmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNlargeIconX, XM_FLOAT);
  DEFINE_RESOURCE(XmNlargeIconY, XM_FLOAT);
  DEFINE_RESOURCE(XmNlastPageNumber, XM_INT);
  DEFINE_RESOURCE(XmNlayoutDirection, XM_UCHAR);
  DEFINE_RESOURCE(XmNlayoutType, XM_UCHAR);
  DEFINE_RESOURCE(XmNlist, XM_WIDGET);
  DEFINE_RESOURCE(XmNloadModel, XM_UCHAR);
  DEFINE_RESOURCE(XmNmajorTabSpacing, XM_DIMENSION);
  DEFINE_RESOURCE(XmNmatchBehavior, XM_UCHAR);
#if HAVE_XP
  DEFINE_RESOURCE(XmNmaxX, XM_DIMENSION);
  DEFINE_RESOURCE(XmNmaxY, XM_DIMENSION);
  DEFINE_RESOURCE(XmNminX, XM_DIMENSION);
  DEFINE_RESOURCE(XmNminY, XM_DIMENSION);
#endif
  DEFINE_RESOURCE(XmNmaximumValue, XM_INT);
  DEFINE_RESOURCE(XmNminimumValue, XM_INT);
  DEFINE_RESOURCE(XmNminorTabSpacing, XM_DIMENSION);
  DEFINE_RESOURCE(XmNmotifVersion, XM_INT);
  DEFINE_RESOURCE(XmNnoFontCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNnoRenditionCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNnotebookChildType, XM_UCHAR);
  DEFINE_RESOURCE(XmNnumValues, XM_INT);
  DEFINE_RESOURCE(XmNoutlineButtonPolicy, XM_UCHAR);
  DEFINE_RESOURCE(XmNoutlineChangedCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNoutlineColumnWidth, XM_DIMENSION);
  DEFINE_RESOURCE(XmNoutlineIndentation, XM_DIMENSION);
  DEFINE_RESOURCE(XmNoutlineLineStyle, XM_UCHAR);
  DEFINE_RESOURCE(XmNoutlineState, XM_UCHAR);
  DEFINE_RESOURCE(XmNpageChangedCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNpageNumber, XM_INT);
#if HAVE_XP
  DEFINE_RESOURCE(XmNpageSetupCallback, XM_CALLBACK);
#endif
  DEFINE_RESOURCE(XmNpathMode, XM_INT);
  DEFINE_RESOURCE(XmNpatternType, XM_UCHAR);
#if HAVE_XP
  DEFINE_RESOURCE(XmNpdmNotificationCallback, XM_CALLBACK);
#endif
  DEFINE_RESOURCE(XmNpopupHandlerCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNposition, XM_INT);
  DEFINE_RESOURCE(XmNpositionMode, XM_INT);
  DEFINE_RESOURCE(XmNpositionType, XM_UCHAR);
  DEFINE_RESOURCE(XmNprimaryOwnership, XM_UCHAR);
  DEFINE_RESOURCE(XmNrenderTable, XM_RENDER_TABLE);
  DEFINE_RESOURCE(XmNrenditionBackground, XM_PIXEL);
  DEFINE_RESOURCE(XmNrenditionForeground, XM_PIXEL);
  DEFINE_RESOURCE(XmNscrolledWindowChildType, XM_UCHAR);
  DEFINE_RESOURCE(XmNselectedItem, XM_XMSTRING);
  DEFINE_RESOURCE(XmNselectedObjectCount, XM_INT);
  DEFINE_RESOURCE(XmNselectedObjects, XM_WIDGET_LIST);
  DEFINE_RESOURCE(XmNselectedPosition, XM_INT);
  DEFINE_RESOURCE(XmNselectedPositionCount, XM_INT);
  DEFINE_RESOURCE(XmNselectedPositions, XM_INT_TABLE);
  DEFINE_RESOURCE(XmNselectionCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNselectionMode, XM_UCHAR);
  DEFINE_RESOURCE(XmNselectionTechnique, XM_UCHAR);
  DEFINE_RESOURCE(XmNsliderMark, XM_INT);
  DEFINE_RESOURCE(XmNsmallCellHeight, XM_DIMENSION);
  DEFINE_RESOURCE(XmNsmallCellWidth, XM_DIMENSION);
  DEFINE_RESOURCE(XmNsmallIconMask, XM_PIXMAP);
  DEFINE_RESOURCE(XmNsmallIconPixmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNsmallIconX, XM_FLOAT);
  DEFINE_RESOURCE(XmNsmallIconY, XM_FLOAT);
  DEFINE_RESOURCE(XmNsnapBackMultiple, XM_SHORT);
  DEFINE_RESOURCE(XmNspatialIncludeModel, XM_UCHAR);
  DEFINE_RESOURCE(XmNspatialResizeModel, XM_UCHAR);
  DEFINE_RESOURCE(XmNspatialSnapModel, XM_UCHAR);
  DEFINE_RESOURCE(XmNspatialStyle, XM_UCHAR);
  DEFINE_RESOURCE(XmNspinBoxChildType, XM_UCHAR);
#if HAVE_XP
  DEFINE_RESOURCE(XmNstartJobCallback, XM_CALLBACK);
#endif
  DEFINE_RESOURCE(XmNstrikethruType, XM_UCHAR);
  DEFINE_RESOURCE(XmNsubstitute, XM_XMSTRING);
  DEFINE_RESOURCE(XmNtabList, XM_TAB_LIST);
  DEFINE_RESOURCE(XmNtag, XM_STRING);
  DEFINE_RESOURCE(XmNtearOffTitle, XM_XMSTRING);
  DEFINE_RESOURCE(XmNtextField, XM_WIDGET);
  DEFINE_RESOURCE(XmNtextRenderTable, XM_RENDER_TABLE);
  DEFINE_RESOURCE(XmNtoggleMode, XM_UCHAR);
  DEFINE_RESOURCE(XmNunderlineType, XM_UCHAR);
  DEFINE_RESOURCE(XmNunselectColor, XM_PIXEL);

  DEFINE_RESOURCE(XmNtabValue, XM_FLOAT);
  DEFINE_RESOURCE(XmNoffsetModel, XM_INT);
  DEFINE_RESOURCE(XmNcallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNwaitForWm, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNuseColorObj, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNvalues, XM_STRING_TABLE);
  /* DEFINE_RESOURCE(XmNverifyPreedit, XM_BOOLEAN); */
  DEFINE_RESOURCE(XmNviewType, XM_UCHAR);
  DEFINE_RESOURCE(XmNvisualEmphasis, XM_UCHAR);
  DEFINE_RESOURCE(XmNwrap, XM_BOOLEAN);

#if HAVE_XM_XP
  DEFINE_STRING(XP_PRINTNAME);
#endif
#if (!XM_DISABLE_DEPRECATED)
  DEFINE_RESOURCE(XmNlabelFontList, XM_FONTLIST);
  DEFINE_RESOURCE(XmNbuttonFontList, XM_FONTLIST);
  DEFINE_RESOURCE(XmNtextFontList, XM_FONTLIST);
  DEFINE_RESOURCE(XmNwhichButton, XM_WIDGET);
  DEFINE_RESOURCE(XmNchildType, XM_UCHAR);
  DEFINE_RESOURCE(XmNstringDirection, XM_UCHAR);
  DEFINE_RESOURCE(XmNfontList, XM_FONTLIST);
  DEFINE_RESOURCE(XmNdefaultFontList, XM_FONTLIST);
  DEFINE_RESOURCE(XmNshellUnitType, XM_UCHAR);
#endif
#if HAVE_XmCreateFontSelector
  /* presumably in a "correct" setup these would be defined in Xm/XmStrDefs.h */
  #ifndef XmNcurrentFont
  /* see comment under resource definition above
    #define XmN100DPIstring "100DPIstring"
    #define XmN75DPIstring "75DPIstring"
  */
    #define XmNanyLowerString "anyLowerString"
    #define XmNanyString "anyString"
    #define XmNboldString "boldString"
    #define XmNbothString "bothString"
    #define XmNcurrentFont "currentFont"
    #define XmNdefaultEncodingString "defaultEncodingString"
    #define XmNencodingList "encodingList"
    #define XmNencodingString "encodingString"
    #define XmNfamilyString "familyString"
    #define XmNitalicString "italicString"
    #define XmNmonoSpaceString "monoSpaceString"
    #define XmNoptionString "optionString"
    #define XmNotherString "otherString"
    #define XmNpropSpaceString "propSpaceString"
    #define XmNsampleText "sampleText"
    #define XmNscalingString "scalingString"
    #define XmNshowFontName "showFontName"
    #define XmNshowNameString "showNameString"
    #define XmNsizeString "sizeString"
    #define XmNtextRows "textRows"
    #define XmNuseScaling "useScaling"
    #define XmNxlfdString "xlfdString"
  #endif
  /*
  DEFINE_RESOURCE(XmN100DPIstring, XM_XMSTRING);
  DEFINE_RESOURCE(XmN75DPIstring, XM_XMSTRING);
  */
  DEFINE_RESOURCE(XmNanyLowerString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNanyString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNboldString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNbothString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNcurrentFont, XM_STRING);
  DEFINE_RESOURCE(XmNdefaultEncodingString, XM_STRING);
  DEFINE_RESOURCE(XmNencodingList, XM_STRING_TABLE);
  DEFINE_RESOURCE(XmNencodingString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNfamilyString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNitalicString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNmonoSpaceString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNoptionString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNotherString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNpropSpaceString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNsampleText, XM_XMSTRING);
  DEFINE_RESOURCE(XmNscalingString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNshowFontName, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNshowNameString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNsizeString, XM_XMSTRING);
  DEFINE_RESOURCE(XmNtextRows, XM_DIMENSION);
  DEFINE_RESOURCE(XmNuseScaling, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNxlfdString, XM_XMSTRING);
#endif
#if HAVE_XmCreateColorSelector
  #ifndef XmNblueSliderLabel
    #define XmNblueSliderLabel "blueSliderLabel"
    #define XmNcolorListTogLabel "colorListTogLabel"
    #define XmNcolorMode "colorMode"
    #define XmNcolorName "colorName"
    #define XmNfileReadError "fileReadError"
    #define XmNgreenSliderLabel "greenSliderLabel"
    #define XmNnoCellError "noCellError"
    #define XmNredSliderLabel "redSliderLabel"
    #define XmNrgbFile "rgbFile"
    #define XmNsliderTogLabel "sliderTogLabel"
  #endif
  DEFINE_RESOURCE(XmNblueSliderLabel, XM_XMSTRING);
  DEFINE_RESOURCE(XmNcolorListTogLabel, XM_XMSTRING);
  DEFINE_RESOURCE(XmNcolorName, XM_STRING);
  DEFINE_RESOURCE(XmNfileReadError, XM_XMSTRING);
  DEFINE_RESOURCE(XmNgreenSliderLabel, XM_XMSTRING);
  DEFINE_RESOURCE(XmNnoCellError, XM_XMSTRING);
  DEFINE_RESOURCE(XmNredSliderLabel, XM_XMSTRING);
  DEFINE_RESOURCE(XmNrgbFile, XM_STRING);
  DEFINE_RESOURCE(XmNsliderTogLabel, XM_XMSTRING);
#endif
#if HAVE_XmCreateButtonBox
  #ifndef XmNequalSize
    #define XmNequalSize "equalSize"
    #define XmNfillOption "fillOption"
  #endif
  DEFINE_RESOURCE(XmNequalSize, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNfillOption, XM_INT);
#endif
#ifdef XmNdefaultEntryLabelRenderTable
  DEFINE_RESOURCE(XmNdefaultEntryLabelRenderTable, XM_RENDER_TABLE);
#endif
#ifdef XmNentryLabelRenderTable
  DEFINE_RESOURCE(XmNentryLabelRenderTable, XM_RENDER_TABLE);
#endif
#ifdef XmNpixmapPlacement
  DEFINE_RESOURCE(XmNpixmapPlacement, XM_INT);
#endif
#ifdef XmNpixmapTextPadding
  DEFINE_RESOURCE(XmNpixmapTextPadding, XM_INT);
#endif
#if HAVE_XmCreateDataField
  #ifndef XmNautoFill
    #define XmNautoFill "autoFill"
    #define XmNpicture "picture"
    #define XmNpictureErrorCallback "pictureErrorCallback"
    #define XmNvalidateCallback "validateCallback"
  #endif
  DEFINE_RESOURCE(XmNautoFill, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNpicture, XM_STRING);
  DEFINE_RESOURCE(XmNpictureErrorCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNvalidateCallback, XM_CALLBACK);
#endif
#if HAVE_XmCreateColumn
  #ifndef XmNdefaultEntryLabelAlignment
    #define XmNdefaultEntryLabelAlignment "defaultEntryLabelAlignment"
    #define XmNdefaultEntryLabelFontList "defaultEntryLabelFontList"
    #define XmNdefaultFillStyle "defaultFillStyle"
    #define XmNdistribution "distribution"
    #define XmNitemSpacing "itemSpacing"
    #define XmNlabelSpacing "labelSpacing"
    #define XmNentryLabelAlignment "entryLabelAlignment"
    #define XmNentryLabelFontList "entryLabelFontList"
    #define XmNentryLabelPixmap "entryLabelPixmap"
    #define XmNentryLabelString "entryLabelString"
    #define XmNentryLabelType "entryLabelType"
    #define XmNfillStyle "fillStyle"
    #define XmNshowEntryLabel "showEntryLabel"
    #define XmNstretchable "stretchable"
  #endif
  DEFINE_RESOURCE(XmNdefaultEntryLabelAlignment, XM_INT);
  DEFINE_RESOURCE(XmNdefaultEntryLabelFontList, XM_FONTLIST);
  DEFINE_RESOURCE(XmNdefaultFillStyle, XM_INT);
  DEFINE_RESOURCE(XmNdistribution, XM_INT);
  DEFINE_RESOURCE(XmNitemSpacing, XM_INT);
  DEFINE_RESOURCE(XmNlabelSpacing, XM_INT);
  DEFINE_RESOURCE(XmNentryLabelAlignment, XM_INT);
  DEFINE_RESOURCE(XmNentryLabelFontList, XM_FONTLIST);
  DEFINE_RESOURCE(XmNentryLabelPixmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNentryLabelString, XM_XMSTRING); /* ? */
  DEFINE_RESOURCE(XmNentryLabelType, XM_INT);
  DEFINE_RESOURCE(XmNfillStyle, XM_INT);
  DEFINE_RESOURCE(XmNshowEntryLabel, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNstretchable, XM_BOOLEAN);
#endif
#if HAVE_XmCreateDropDown
  #ifndef XmNpopupCursor
    #define XmNcustomizedCombinationBox "customizedCombinationBox"
    #define XmNhorizontalMargin "horizontalMargin"
    #define XmNpopupCursor "popupCursor"
    #define XmNpopupOffset "popupOffset"
    #define XmNpopupShellWidget "popupShellWidget"
    #define XmNshowLabel "showLabel"
    #define XmNupdateShellCallback "updateShellCallback"
    #define XmNupdateTextCallback "updateTextCallback"
    #define XmNuseTextField "useTextField"
    #define XmNverify "verify"
    #define XmNverifyTextCallback "verifyTextCallback"
    #define XmNverticalMargin "verticalMargin"
  #endif
  DEFINE_RESOURCE(XmNcustomizedCombinationBox, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNhorizontalMargin, XM_DIMENSION);
  DEFINE_RESOURCE(XmNpopupCursor, XM_CURSOR);
  DEFINE_RESOURCE(XmNpopupOffset, XM_INT);
  DEFINE_RESOURCE(XmNpopupShellWidget, XM_WIDGET);
  DEFINE_RESOURCE(XmNshowLabel, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNupdateShellCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNupdateTextCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNuseTextField, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNverify, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNverifyTextCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNverticalMargin, XM_DIMENSION);
#endif
#if HAVE_XmCreateTabStack
  #ifndef XmNstackedEffect
    #define XmNstackedEffect "stackedEffect"
    #define XmNtabAutoSelect "tabAutoSelect"
    #define XmNtabCornerPercent "tabCornerPercent"
    #define XmNtabLabelSpacing "tabLabelSpacing"
    #define XmNtabMarginHeight "tabMarginHeight"
    #define XmNtabMarginWidth "tabMarginWidth"
    #define XmNtabMode "tabMode"
    #define XmNtabOffset "tabOffset"
    #define XmNtabOrientation "tabOrientation"
    #define XmNtabSelectColor "tabSelectColor"
    #define XmNtabSelectedCallback "tabSelectedCallback"
    #define XmNtabSelectPixmap "tabSelectPixmap"
    #define XmNtabSide "tabSide"
    #define XmNtabStyle "tabStyle"
    #define XmNuniformTabSize "uniformTabSize"
    #define XmNuseImageCache "useImageCache"
  #endif
  DEFINE_RESOURCE(XmNstackedEffect, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNtabAutoSelect, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNtabCornerPercent, XM_INT);
  DEFINE_RESOURCE(XmNtabLabelSpacing, XM_DIMENSION);
  DEFINE_RESOURCE(XmNtabMarginHeight, XM_DIMENSION);
  DEFINE_RESOURCE(XmNtabMarginWidth, XM_DIMENSION);
  DEFINE_RESOURCE(XmNtabMode, XM_INT);
  DEFINE_RESOURCE(XmNtabOffset, XM_DIMENSION);
  DEFINE_RESOURCE(XmNtabOrientation, XM_INT);
  DEFINE_RESOURCE(XmNtabSelectColor, XM_PIXEL);
  DEFINE_RESOURCE(XmNtabSelectedCallback, XM_CALLBACK);
  DEFINE_RESOURCE(XmNtabSelectPixmap, XM_PIXMAP);
  DEFINE_RESOURCE(XmNtabSide, XM_INT);
  DEFINE_RESOURCE(XmNtabStyle, XM_INT);
  DEFINE_RESOURCE(XmNuniformTabSize, XM_BOOLEAN);
  DEFINE_RESOURCE(XmNuseImageCache, XM_BOOLEAN);
#endif             

  qsort((void *)xm_hash, hd_ctr, sizeof(hdata *), alphabet_compare);
  {
    int i, n;
    for (i = 0; i < LINKS_SIZE; i++) hd_links[i] = hd_ctr;
    for (i = 0; i < hd_ctr; i++)
      {
	n = (int)(xm_hash[i]->name[0]) - 97; /* (char->integer #\a) */
#if MUS_DEBUGGING
	if ((n < 0) || (n >= LINKS_SIZE)) 
	  {
	    fprintf(stderr, "index %s at %d\n", xm_hash[i]->name, n);
	    abort();
	  }
#endif
	if (hd_links[n] > i)
	  hd_links[n] = i;
      }
  }
}
#endif

#if HAVE_MOTIF
#define S_add_resource "add-resource"

static XEN g_add_resource(XEN nam, XEN typ)
{
  #define H_add_resource "(" S_add_resource " name type) adds the resource 'name' with the libxm type 'type'. \
The types are defined in xm.c around line 679.  To add XmNhiho as an integer: \n\
    (define XmNhiho (add-resource \"hiho\" 0))"

  XEN_ASSERT_TYPE(XEN_STRING_P(nam), nam, XEN_ARG_1, S_add_resource, "a string");
  XEN_ASSERT_TYPE(XEN_INTEGER_P(typ), typ, XEN_ARG_2, S_add_resource, "an integer");
  hash_resource(XEN_TO_C_STRING(nam), (xm_resource_t)XEN_TO_C_INT(typ));
  return(nam);
}

#ifdef XEN_ARGIFY_1
  XEN_NARGIFY_2(g_add_resource_w, g_add_resource)
#else
  #define g_add_resource_w g_add_resource
#endif
#endif


/* -------------------------------- integer constants -------------------------------- */

static void define_integers(void)
{
  #define DEFINE_INTEGER(Name) XEN_DEFINE(XM_PREFIX #Name XM_POSTFIX, C_TO_XEN_INT(Name))
  #define DEFINE_ULONG(Name) XEN_DEFINE(XM_PREFIX #Name XM_POSTFIX, C_TO_XEN_ULONG(Name))
  
  DEFINE_ULONG(AllPlanes);
  DEFINE_INTEGER(XC_num_glyphs);
  DEFINE_INTEGER(XC_X_cursor);
  DEFINE_INTEGER(XC_arrow);
  DEFINE_INTEGER(XC_based_arrow_down);
  DEFINE_INTEGER(XC_based_arrow_up);
  DEFINE_INTEGER(XC_boat);
  DEFINE_INTEGER(XC_bogosity);
  DEFINE_INTEGER(XC_bottom_left_corner);
  DEFINE_INTEGER(XC_bottom_right_corner);
  DEFINE_INTEGER(XC_bottom_side);
  DEFINE_INTEGER(XC_bottom_tee);
  DEFINE_INTEGER(XC_box_spiral);
  DEFINE_INTEGER(XC_center_ptr);
  DEFINE_INTEGER(XC_circle);
  DEFINE_INTEGER(XC_clock);
  DEFINE_INTEGER(XC_coffee_mug);
  DEFINE_INTEGER(XC_cross);
  DEFINE_INTEGER(XC_cross_reverse);
  DEFINE_INTEGER(XC_crosshair);
  DEFINE_INTEGER(XC_diamond_cross);
  DEFINE_INTEGER(XC_dot);
  DEFINE_INTEGER(XC_dotbox);
  DEFINE_INTEGER(XC_double_arrow);
  DEFINE_INTEGER(XC_draft_large);
  DEFINE_INTEGER(XC_draft_small);
  DEFINE_INTEGER(XC_draped_box);
  DEFINE_INTEGER(XC_exchange);
  DEFINE_INTEGER(XC_fleur);
  DEFINE_INTEGER(XC_gobbler);
  DEFINE_INTEGER(XC_gumby);
  DEFINE_INTEGER(XC_hand1);
  DEFINE_INTEGER(XC_hand2);
  DEFINE_INTEGER(XC_heart);
  DEFINE_INTEGER(XC_icon);
  DEFINE_INTEGER(XC_iron_cross);
  DEFINE_INTEGER(XC_left_ptr);
  DEFINE_INTEGER(XC_left_side);
  DEFINE_INTEGER(XC_left_tee);
  DEFINE_INTEGER(XC_leftbutton);
  DEFINE_INTEGER(XC_ll_angle);
  DEFINE_INTEGER(XC_lr_angle);
  DEFINE_INTEGER(XC_man);
  DEFINE_INTEGER(XC_middlebutton);
  DEFINE_INTEGER(XC_mouse);
  DEFINE_INTEGER(XC_pencil);
  DEFINE_INTEGER(XC_pirate);
  DEFINE_INTEGER(XC_plus);
  DEFINE_INTEGER(XC_question_arrow);
  DEFINE_INTEGER(XC_right_ptr);
  DEFINE_INTEGER(XC_right_side);
  DEFINE_INTEGER(XC_right_tee);
  DEFINE_INTEGER(XC_rightbutton);
  DEFINE_INTEGER(XC_rtl_logo);
  DEFINE_INTEGER(XC_sailboat);
  DEFINE_INTEGER(XC_sb_down_arrow);
  DEFINE_INTEGER(XC_sb_h_double_arrow);
  DEFINE_INTEGER(XC_sb_left_arrow);
  DEFINE_INTEGER(XC_sb_right_arrow);
  DEFINE_INTEGER(XC_sb_up_arrow);
  DEFINE_INTEGER(XC_sb_v_double_arrow);
  DEFINE_INTEGER(XC_shuttle);
  DEFINE_INTEGER(XC_sizing);
  DEFINE_INTEGER(XC_spider);
  DEFINE_INTEGER(XC_spraycan);
  DEFINE_INTEGER(XC_star);
  DEFINE_INTEGER(XC_target);
  DEFINE_INTEGER(XC_tcross);
  DEFINE_INTEGER(XC_top_left_arrow);
  DEFINE_INTEGER(XC_top_left_corner);
  DEFINE_INTEGER(XC_top_right_corner);
  DEFINE_INTEGER(XC_top_side);
  DEFINE_INTEGER(XC_top_tee);
  DEFINE_INTEGER(XC_trek);
  DEFINE_INTEGER(XC_ul_angle);
  DEFINE_INTEGER(XC_umbrella);
  DEFINE_INTEGER(XC_ur_angle);
  DEFINE_INTEGER(XC_watch);
  DEFINE_INTEGER(XC_xterm);
  DEFINE_INTEGER(None);
  DEFINE_INTEGER(ParentRelative);
  DEFINE_INTEGER(CopyFromParent);
  DEFINE_INTEGER(PointerWindow);
  DEFINE_INTEGER(InputFocus);
  DEFINE_INTEGER(PointerRoot);
  DEFINE_INTEGER(AnyPropertyType);
  DEFINE_INTEGER(AnyKey);
  DEFINE_INTEGER(AnyButton);
  DEFINE_INTEGER(AllTemporary);
  DEFINE_INTEGER(CurrentTime);
  DEFINE_INTEGER(NoSymbol);
  DEFINE_INTEGER(NoEventMask);
  DEFINE_INTEGER(KeyPressMask);
  DEFINE_INTEGER(KeyReleaseMask);
  DEFINE_INTEGER(ButtonPressMask);
  DEFINE_INTEGER(ButtonReleaseMask);
  DEFINE_INTEGER(EnterWindowMask);
  DEFINE_INTEGER(LeaveWindowMask);
  DEFINE_INTEGER(PointerMotionMask);
  DEFINE_INTEGER(PointerMotionHintMask);
  DEFINE_INTEGER(Button1MotionMask);
  DEFINE_INTEGER(Button2MotionMask);
  DEFINE_INTEGER(Button3MotionMask);
  DEFINE_INTEGER(Button4MotionMask);
  DEFINE_INTEGER(Button5MotionMask);
  DEFINE_INTEGER(ButtonMotionMask);
  DEFINE_INTEGER(KeymapStateMask);
  DEFINE_INTEGER(ExposureMask);
  DEFINE_INTEGER(VisibilityChangeMask);
  DEFINE_INTEGER(StructureNotifyMask);
  DEFINE_INTEGER(ResizeRedirectMask);
  DEFINE_INTEGER(SubstructureNotifyMask);
  DEFINE_INTEGER(SubstructureRedirectMask);
  DEFINE_INTEGER(FocusChangeMask);
  DEFINE_INTEGER(PropertyChangeMask);
  DEFINE_INTEGER(ColormapChangeMask);
  DEFINE_INTEGER(OwnerGrabButtonMask);
  DEFINE_INTEGER(KeyPress);
  DEFINE_INTEGER(KeyRelease);
  DEFINE_INTEGER(ButtonPress);
  DEFINE_INTEGER(ButtonRelease);
  DEFINE_INTEGER(MotionNotify);
  DEFINE_INTEGER(EnterNotify);
  DEFINE_INTEGER(LeaveNotify);
  DEFINE_INTEGER(FocusIn);
  DEFINE_INTEGER(FocusOut);
  DEFINE_INTEGER(KeymapNotify);
  DEFINE_INTEGER(Expose);
  DEFINE_INTEGER(GraphicsExpose);
  DEFINE_INTEGER(NoExpose);
  DEFINE_INTEGER(VisibilityNotify);
  DEFINE_INTEGER(CreateNotify);
  DEFINE_INTEGER(DestroyNotify);
  DEFINE_INTEGER(UnmapNotify);
  DEFINE_INTEGER(MapNotify);
  DEFINE_INTEGER(MapRequest);
  DEFINE_INTEGER(ReparentNotify);
  DEFINE_INTEGER(ConfigureNotify);
  DEFINE_INTEGER(ConfigureRequest);
  DEFINE_INTEGER(GravityNotify);
  DEFINE_INTEGER(ResizeRequest);
  DEFINE_INTEGER(CirculateNotify);
  DEFINE_INTEGER(CirculateRequest);
  DEFINE_INTEGER(PropertyNotify);
  DEFINE_INTEGER(SelectionClear);
  DEFINE_INTEGER(SelectionRequest);
  DEFINE_INTEGER(SelectionNotify);
  DEFINE_INTEGER(ColormapNotify);
  DEFINE_INTEGER(ClientMessage);
  DEFINE_INTEGER(MappingNotify);
  DEFINE_INTEGER(ShiftMask);
  DEFINE_INTEGER(LockMask);
  DEFINE_INTEGER(ControlMask);
  DEFINE_INTEGER(Mod1Mask);
  DEFINE_INTEGER(Mod2Mask);
  DEFINE_INTEGER(Mod3Mask);
  DEFINE_INTEGER(Mod4Mask);
  DEFINE_INTEGER(Mod5Mask);
  DEFINE_INTEGER(ShiftMapIndex);
  DEFINE_INTEGER(LockMapIndex);
  DEFINE_INTEGER(ControlMapIndex);
  DEFINE_INTEGER(Mod1MapIndex);
  DEFINE_INTEGER(Mod2MapIndex);
  DEFINE_INTEGER(Mod3MapIndex);
  DEFINE_INTEGER(Mod4MapIndex);
  DEFINE_INTEGER(Mod5MapIndex);
  DEFINE_INTEGER(Button1Mask);
  DEFINE_INTEGER(Button2Mask);
  DEFINE_INTEGER(Button3Mask);
  DEFINE_INTEGER(Button4Mask);
  DEFINE_INTEGER(Button5Mask);
  DEFINE_INTEGER(AnyModifier);
  DEFINE_INTEGER(Button1);
  DEFINE_INTEGER(Button2);
  DEFINE_INTEGER(Button3);
  DEFINE_INTEGER(Button4);
  DEFINE_INTEGER(Button5);
  DEFINE_INTEGER(NotifyNormal);
  DEFINE_INTEGER(NotifyGrab);
  DEFINE_INTEGER(NotifyUngrab);
  DEFINE_INTEGER(NotifyWhileGrabbed);
  DEFINE_INTEGER(NotifyHint);
  DEFINE_INTEGER(NotifyAncestor);
  DEFINE_INTEGER(NotifyVirtual);
  DEFINE_INTEGER(NotifyInferior);
  DEFINE_INTEGER(NotifyNonlinear);
  DEFINE_INTEGER(NotifyNonlinearVirtual);
  DEFINE_INTEGER(NotifyPointer);
  DEFINE_INTEGER(NotifyPointerRoot);
  DEFINE_INTEGER(NotifyDetailNone);
  DEFINE_INTEGER(VisibilityUnobscured);
  DEFINE_INTEGER(VisibilityPartiallyObscured);
  DEFINE_INTEGER(VisibilityFullyObscured);
  DEFINE_INTEGER(PlaceOnTop);
  DEFINE_INTEGER(PlaceOnBottom);
  DEFINE_INTEGER(FamilyInternet);
  DEFINE_INTEGER(FamilyDECnet);
  DEFINE_INTEGER(FamilyChaos);
  DEFINE_INTEGER(PropertyNewValue);
  DEFINE_INTEGER(PropertyDelete);
  DEFINE_INTEGER(ColormapUninstalled);
  DEFINE_INTEGER(ColormapInstalled);
  DEFINE_INTEGER(GrabModeSync);
  DEFINE_INTEGER(GrabModeAsync);
  DEFINE_INTEGER(GrabSuccess);
  DEFINE_INTEGER(AlreadyGrabbed);
  DEFINE_INTEGER(GrabInvalidTime);
  DEFINE_INTEGER(GrabNotViewable);
  DEFINE_INTEGER(GrabFrozen);
  DEFINE_INTEGER(AsyncPointer);
  DEFINE_INTEGER(SyncPointer);
  DEFINE_INTEGER(ReplayPointer);
  DEFINE_INTEGER(AsyncKeyboard);
  DEFINE_INTEGER(SyncKeyboard);
  DEFINE_INTEGER(ReplayKeyboard);
  DEFINE_INTEGER(AsyncBoth);
  DEFINE_INTEGER(SyncBoth);
  DEFINE_INTEGER(RevertToNone);
  DEFINE_INTEGER(RevertToPointerRoot);
  DEFINE_INTEGER(RevertToParent);
  DEFINE_INTEGER(Success);
  DEFINE_INTEGER(BadRequest);
  DEFINE_INTEGER(BadValue);
  DEFINE_INTEGER(BadWindow);
  DEFINE_INTEGER(BadPixmap);
  DEFINE_INTEGER(BadAtom);
  DEFINE_INTEGER(BadCursor);
  DEFINE_INTEGER(BadFont);
  DEFINE_INTEGER(BadMatch);
  DEFINE_INTEGER(BadDrawable);
  DEFINE_INTEGER(BadAccess);
  DEFINE_INTEGER(BadAlloc);
  DEFINE_INTEGER(BadColor);
  DEFINE_INTEGER(BadGC);
  DEFINE_INTEGER(BadIDChoice);
  DEFINE_INTEGER(BadName);
  DEFINE_INTEGER(BadLength);
  DEFINE_INTEGER(BadImplementation);
  DEFINE_INTEGER(InputOutput);
  DEFINE_INTEGER(InputOnly);
  DEFINE_INTEGER(UnmapGravity);
  DEFINE_INTEGER(NotUseful);
  DEFINE_INTEGER(WhenMapped);
  DEFINE_INTEGER(Always);
  DEFINE_INTEGER(IsUnmapped);
  DEFINE_INTEGER(IsUnviewable);
  DEFINE_INTEGER(IsViewable);
  DEFINE_INTEGER(SetModeInsert);
  DEFINE_INTEGER(SetModeDelete);
  DEFINE_INTEGER(DestroyAll);
  DEFINE_INTEGER(RetainPermanent);
  DEFINE_INTEGER(RetainTemporary);
  DEFINE_INTEGER(CWBackPixmap);
  DEFINE_INTEGER(CWBackPixel);
  DEFINE_INTEGER(CWBorderPixmap);
  DEFINE_INTEGER(CWBorderPixel);
  DEFINE_INTEGER(CWBitGravity);
  DEFINE_INTEGER(CWWinGravity);
  DEFINE_INTEGER(CWBackingStore);
  DEFINE_INTEGER(CWBackingPlanes);
  DEFINE_INTEGER(CWBackingPixel);
  DEFINE_INTEGER(CWOverrideRedirect);
  DEFINE_INTEGER(CWSaveUnder);
  DEFINE_INTEGER(CWEventMask);
  DEFINE_INTEGER(CWDontPropagate);
  DEFINE_INTEGER(CWColormap);
  DEFINE_INTEGER(CWCursor);
  DEFINE_INTEGER(CWX);
  DEFINE_INTEGER(CWY);
  DEFINE_INTEGER(CWWidth);
  DEFINE_INTEGER(CWHeight);
  DEFINE_INTEGER(CWBorderWidth);
  DEFINE_INTEGER(CWSibling);
  DEFINE_INTEGER(CWStackMode);
  DEFINE_INTEGER(ForgetGravity);
  DEFINE_INTEGER(NorthWestGravity);
  DEFINE_INTEGER(NorthGravity);
  DEFINE_INTEGER(NorthEastGravity);
  DEFINE_INTEGER(WestGravity);
  DEFINE_INTEGER(CenterGravity);
  DEFINE_INTEGER(EastGravity);
  DEFINE_INTEGER(SouthWestGravity);
  DEFINE_INTEGER(SouthGravity);
  DEFINE_INTEGER(SouthEastGravity);
  DEFINE_INTEGER(StaticGravity);
  DEFINE_INTEGER(Above);
  DEFINE_INTEGER(Below);
  DEFINE_INTEGER(TopIf);
  DEFINE_INTEGER(BottomIf);
  DEFINE_INTEGER(Opposite);
  DEFINE_INTEGER(RaiseLowest);
  DEFINE_INTEGER(LowerHighest);
  DEFINE_INTEGER(PropModeReplace);
  DEFINE_INTEGER(PropModePrepend);
  DEFINE_INTEGER(PropModeAppend);
  DEFINE_INTEGER(KBKeyClickPercent);
  DEFINE_INTEGER(KBBellPercent);
  DEFINE_INTEGER(KBBellPitch);
  DEFINE_INTEGER(KBBellDuration);
  DEFINE_INTEGER(KBLed);
  DEFINE_INTEGER(KBLedMode);
  DEFINE_INTEGER(KBKey);
  DEFINE_INTEGER(KBAutoRepeatMode);
  DEFINE_INTEGER(AutoRepeatModeOff);
  DEFINE_INTEGER(AutoRepeatModeOn);
  DEFINE_INTEGER(AutoRepeatModeDefault);
  DEFINE_INTEGER(LedModeOff);
  DEFINE_INTEGER(LedModeOn);
  DEFINE_INTEGER(GXclear);
  DEFINE_INTEGER(GXand);
  DEFINE_INTEGER(GXandReverse);
  DEFINE_INTEGER(GXcopy);
  DEFINE_INTEGER(GXandInverted);
  DEFINE_INTEGER(GXnoop);
  DEFINE_INTEGER(GXxor);
  DEFINE_INTEGER(GXor);
  DEFINE_INTEGER(GXnor);
  DEFINE_INTEGER(GXequiv);
  DEFINE_INTEGER(GXinvert);
  DEFINE_INTEGER(GXorReverse);
  DEFINE_INTEGER(GXcopyInverted);
  DEFINE_INTEGER(GXorInverted);
  DEFINE_INTEGER(GXnand);
  DEFINE_INTEGER(GXset);
  DEFINE_INTEGER(LineSolid);
  DEFINE_INTEGER(LineOnOffDash);
  DEFINE_INTEGER(LineDoubleDash);
  DEFINE_INTEGER(CapNotLast);
  DEFINE_INTEGER(CapButt);
  DEFINE_INTEGER(CapRound);
  DEFINE_INTEGER(CapProjecting);
  DEFINE_INTEGER(JoinMiter);
  DEFINE_INTEGER(JoinRound);
  DEFINE_INTEGER(JoinBevel);
  DEFINE_INTEGER(FillSolid);
  DEFINE_INTEGER(FillTiled);
  DEFINE_INTEGER(FillStippled);
  DEFINE_INTEGER(FillOpaqueStippled);
  DEFINE_INTEGER(EvenOddRule);
  DEFINE_INTEGER(WindingRule);
  DEFINE_INTEGER(ClipByChildren);
  DEFINE_INTEGER(IncludeInferiors);
  DEFINE_INTEGER(Unsorted);
  DEFINE_INTEGER(YSorted);
  DEFINE_INTEGER(YXSorted);
  DEFINE_INTEGER(YXBanded);
  DEFINE_INTEGER(CoordModeOrigin);
  DEFINE_INTEGER(CoordModePrevious);
  DEFINE_INTEGER(Complex);
  DEFINE_INTEGER(Nonconvex);
  DEFINE_INTEGER(Convex);
  DEFINE_INTEGER(ArcChord);
  DEFINE_INTEGER(ArcPieSlice);
  DEFINE_INTEGER(GCFunction);
  DEFINE_INTEGER(GCPlaneMask);
  DEFINE_INTEGER(GCForeground);
  DEFINE_INTEGER(GCBackground);
  DEFINE_INTEGER(GCLineWidth);
  DEFINE_INTEGER(GCLineStyle);
  DEFINE_INTEGER(GCCapStyle);
  DEFINE_INTEGER(GCJoinStyle);
  DEFINE_INTEGER(GCFillStyle);
  DEFINE_INTEGER(GCFillRule);
  DEFINE_INTEGER(GCTile);
  DEFINE_INTEGER(GCStipple);
  DEFINE_INTEGER(GCTileStipXOrigin);
  DEFINE_INTEGER(GCTileStipYOrigin);
  DEFINE_INTEGER(GCFont);
  DEFINE_INTEGER(GCSubwindowMode);
  DEFINE_INTEGER(GCGraphicsExposures);
  DEFINE_INTEGER(GCClipXOrigin);
  DEFINE_INTEGER(GCClipYOrigin);
  DEFINE_INTEGER(GCClipMask);
  DEFINE_INTEGER(GCDashOffset);
  DEFINE_INTEGER(GCDashList);
  DEFINE_INTEGER(GCArcMode);
  DEFINE_INTEGER(GCLastBit);
  DEFINE_INTEGER(FontLeftToRight);
  DEFINE_INTEGER(FontRightToLeft);
  DEFINE_INTEGER(FontChange);
  DEFINE_INTEGER(XYBitmap);
  DEFINE_INTEGER(XYPixmap);
  DEFINE_INTEGER(ZPixmap);
  DEFINE_INTEGER(AllocNone);
  DEFINE_INTEGER(AllocAll);
  DEFINE_INTEGER(DoRed);
  DEFINE_INTEGER(DoGreen);
  DEFINE_INTEGER(DoBlue);
  DEFINE_INTEGER(CursorShape);
  DEFINE_INTEGER(TileShape);
  DEFINE_INTEGER(StippleShape);
  DEFINE_INTEGER(MappingSuccess);
  DEFINE_INTEGER(MappingBusy);
  DEFINE_INTEGER(MappingFailed);
  DEFINE_INTEGER(MappingModifier);
  DEFINE_INTEGER(MappingKeyboard);
  DEFINE_INTEGER(MappingPointer);

  DEFINE_INTEGER(DontPreferBlanking);
  DEFINE_INTEGER(PreferBlanking);
  DEFINE_INTEGER(DefaultBlanking);
  DEFINE_INTEGER(DisableScreenSaver);
  DEFINE_INTEGER(DisableScreenInterval);
  DEFINE_INTEGER(DontAllowExposures);
  DEFINE_INTEGER(AllowExposures);
  DEFINE_INTEGER(DefaultExposures);
  DEFINE_INTEGER(ScreenSaverReset);
  DEFINE_INTEGER(ScreenSaverActive);

  DEFINE_INTEGER(StaticGray);
  DEFINE_INTEGER(GrayScale);
  DEFINE_INTEGER(StaticColor);
  DEFINE_INTEGER(PseudoColor);
  DEFINE_INTEGER(TrueColor);
  DEFINE_INTEGER(DirectColor);

#if HAVE_MOTIF
  DEFINE_INTEGER(XtInputNoneMask);
  DEFINE_INTEGER(XtInputReadMask);
  DEFINE_INTEGER(XtInputWriteMask);
  DEFINE_INTEGER(XtInputExceptMask);

  /* XtAllEvents is unsigned long EventMask: #define XtAllEvents ((EventMask) -1L)
   *   which I assume should be positive
   */
#if 0
  DEFINE_INTEGER(XtAllEvents);
#else
  DEFINE_ULONG(XtAllEvents);
#endif

  DEFINE_INTEGER(XtIMXEvent);
  DEFINE_INTEGER(XtIMTimer);
  DEFINE_INTEGER(XtIMAlternateInput);
  DEFINE_INTEGER(XtIMSignal);
  DEFINE_INTEGER(XtIMAll);
  DEFINE_INTEGER(XtUnspecifiedPixmap);
  DEFINE_INTEGER(XtUnspecifiedShellInt);
  DEFINE_INTEGER(XtUnspecifiedWindow);
  DEFINE_INTEGER(XtUnspecifiedWindowGroup);
  DEFINE_INTEGER(XT_CONVERT_FAIL);
#endif
  DEFINE_INTEGER(XlibSpecificationRelease);
  DEFINE_INTEGER(QueuedAlready);
  DEFINE_INTEGER(QueuedAfterReading);
  DEFINE_INTEGER(QueuedAfterFlush);
  DEFINE_INTEGER(XBufferOverflow);
  DEFINE_INTEGER(XLookupNone);
  DEFINE_INTEGER(XLookupChars);
  DEFINE_INTEGER(XLookupKeySym);
  DEFINE_INTEGER(XLookupBoth);
  DEFINE_INTEGER(XK_VoidSymbol);
  DEFINE_INTEGER(XK_BackSpace);
  DEFINE_INTEGER(XK_Tab);
  DEFINE_INTEGER(XK_Linefeed);
  DEFINE_INTEGER(XK_Clear);
  DEFINE_INTEGER(XK_Return);
  DEFINE_INTEGER(XK_Pause);
  DEFINE_INTEGER(XK_Scroll_Lock);
  DEFINE_INTEGER(XK_Sys_Req);
  DEFINE_INTEGER(XK_Escape);
  DEFINE_INTEGER(XK_Delete);
  DEFINE_INTEGER(XK_Home);
  DEFINE_INTEGER(XK_Left);
  DEFINE_INTEGER(XK_Up);
  DEFINE_INTEGER(XK_Right);
  DEFINE_INTEGER(XK_Down);
  DEFINE_INTEGER(XK_Prior);
  DEFINE_INTEGER(XK_Page_Up);
  DEFINE_INTEGER(XK_Next);
  DEFINE_INTEGER(XK_Page_Down);
  DEFINE_INTEGER(XK_End);
  DEFINE_INTEGER(XK_Begin);
  DEFINE_INTEGER(XK_Select);
  DEFINE_INTEGER(XK_Print);
  DEFINE_INTEGER(XK_Execute);
  DEFINE_INTEGER(XK_Insert);
  DEFINE_INTEGER(XK_Undo);
  DEFINE_INTEGER(XK_Redo);
  DEFINE_INTEGER(XK_Menu);
  DEFINE_INTEGER(XK_Find);
  DEFINE_INTEGER(XK_Cancel);
  DEFINE_INTEGER(XK_Help);
  DEFINE_INTEGER(XK_Break);
  DEFINE_INTEGER(XK_Mode_switch);
  DEFINE_INTEGER(XK_script_switch);
  DEFINE_INTEGER(XK_Num_Lock);
  DEFINE_INTEGER(XK_KP_Space);
  DEFINE_INTEGER(XK_KP_Tab);
  DEFINE_INTEGER(XK_KP_Enter);
  DEFINE_INTEGER(XK_KP_F1);
  DEFINE_INTEGER(XK_KP_F2);
  DEFINE_INTEGER(XK_KP_F3);
  DEFINE_INTEGER(XK_KP_F4);
  DEFINE_INTEGER(XK_KP_Home);
  DEFINE_INTEGER(XK_KP_Left);
  DEFINE_INTEGER(XK_KP_Up);
  DEFINE_INTEGER(XK_KP_Right);
  DEFINE_INTEGER(XK_KP_Down);
  DEFINE_INTEGER(XK_KP_Prior);
  DEFINE_INTEGER(XK_KP_Page_Up);
  DEFINE_INTEGER(XK_KP_Next);
  DEFINE_INTEGER(XK_KP_Page_Down);
  DEFINE_INTEGER(XK_KP_End);
  DEFINE_INTEGER(XK_KP_Begin);
  DEFINE_INTEGER(XK_KP_Insert);
  DEFINE_INTEGER(XK_KP_Delete);
  DEFINE_INTEGER(XK_KP_Equal);
  DEFINE_INTEGER(XK_KP_Multiply);
  DEFINE_INTEGER(XK_KP_Add);
  DEFINE_INTEGER(XK_KP_Separator);
  DEFINE_INTEGER(XK_KP_Subtract);
  DEFINE_INTEGER(XK_KP_Decimal);
  DEFINE_INTEGER(XK_KP_Divide);
  DEFINE_INTEGER(XK_KP_0);
  DEFINE_INTEGER(XK_KP_1);
  DEFINE_INTEGER(XK_KP_2);
  DEFINE_INTEGER(XK_KP_3);
  DEFINE_INTEGER(XK_KP_4);
  DEFINE_INTEGER(XK_KP_5);
  DEFINE_INTEGER(XK_KP_6);
  DEFINE_INTEGER(XK_KP_7);
  DEFINE_INTEGER(XK_KP_8);
  DEFINE_INTEGER(XK_KP_9);
  DEFINE_INTEGER(XK_F1);
  DEFINE_INTEGER(XK_F2);
  DEFINE_INTEGER(XK_F3);
  DEFINE_INTEGER(XK_F4);
  DEFINE_INTEGER(XK_F5);
  DEFINE_INTEGER(XK_F6);
  DEFINE_INTEGER(XK_F7);
  DEFINE_INTEGER(XK_F8);
  DEFINE_INTEGER(XK_F9);
  DEFINE_INTEGER(XK_F10);
  DEFINE_INTEGER(XK_F11);
  DEFINE_INTEGER(XK_L1);
  DEFINE_INTEGER(XK_F12);
  DEFINE_INTEGER(XK_L2);
  DEFINE_INTEGER(XK_F13);
  DEFINE_INTEGER(XK_L3);
  DEFINE_INTEGER(XK_F14);
  DEFINE_INTEGER(XK_L4);
  DEFINE_INTEGER(XK_F15);
  DEFINE_INTEGER(XK_L5);
  DEFINE_INTEGER(XK_F16);
  DEFINE_INTEGER(XK_L6);
  DEFINE_INTEGER(XK_F17);
  DEFINE_INTEGER(XK_L7);
  DEFINE_INTEGER(XK_F18);
  DEFINE_INTEGER(XK_L8);
  DEFINE_INTEGER(XK_F19);
  DEFINE_INTEGER(XK_L9);
  DEFINE_INTEGER(XK_F20);
  DEFINE_INTEGER(XK_L10);
  DEFINE_INTEGER(XK_F21);
  DEFINE_INTEGER(XK_R1);
  DEFINE_INTEGER(XK_F22);
  DEFINE_INTEGER(XK_R2);
  DEFINE_INTEGER(XK_F23);
  DEFINE_INTEGER(XK_R3);
  DEFINE_INTEGER(XK_F24);
  DEFINE_INTEGER(XK_R4);
  DEFINE_INTEGER(XK_F25);
  DEFINE_INTEGER(XK_R5);
  DEFINE_INTEGER(XK_F26);
  DEFINE_INTEGER(XK_R6);
  DEFINE_INTEGER(XK_F27);
  DEFINE_INTEGER(XK_R7);
  DEFINE_INTEGER(XK_F28);
  DEFINE_INTEGER(XK_R8);
  DEFINE_INTEGER(XK_F29);
  DEFINE_INTEGER(XK_R9);
  DEFINE_INTEGER(XK_F30);
  DEFINE_INTEGER(XK_R10);
  DEFINE_INTEGER(XK_F31);
  DEFINE_INTEGER(XK_R11);
  DEFINE_INTEGER(XK_F32);
  DEFINE_INTEGER(XK_R12);
  DEFINE_INTEGER(XK_F33);
  DEFINE_INTEGER(XK_R13);
  DEFINE_INTEGER(XK_F34);
  DEFINE_INTEGER(XK_R14);
  DEFINE_INTEGER(XK_F35);
  DEFINE_INTEGER(XK_R15);
  DEFINE_INTEGER(XK_Shift_L);
  DEFINE_INTEGER(XK_Shift_R);
  DEFINE_INTEGER(XK_Control_L);
  DEFINE_INTEGER(XK_Control_R);
  DEFINE_INTEGER(XK_Caps_Lock);
  DEFINE_INTEGER(XK_Shift_Lock);
  DEFINE_INTEGER(XK_Meta_L);
  DEFINE_INTEGER(XK_Meta_R);
  DEFINE_INTEGER(XK_Alt_L);
  DEFINE_INTEGER(XK_Alt_R);
  DEFINE_INTEGER(XK_Super_L);
  DEFINE_INTEGER(XK_Super_R);
  DEFINE_INTEGER(XK_Hyper_L);
  DEFINE_INTEGER(XK_Hyper_R);
  DEFINE_INTEGER(XK_space);
  DEFINE_INTEGER(XK_exclam);
  DEFINE_INTEGER(XK_quotedbl);
  DEFINE_INTEGER(XK_numbersign);
  DEFINE_INTEGER(XK_dollar);
  DEFINE_INTEGER(XK_percent);
  DEFINE_INTEGER(XK_ampersand);
  DEFINE_INTEGER(XK_apostrophe);
  DEFINE_INTEGER(XK_quoteright);
  DEFINE_INTEGER(XK_parenleft);
  DEFINE_INTEGER(XK_parenright);
  DEFINE_INTEGER(XK_asterisk);
  DEFINE_INTEGER(XK_plus);
  DEFINE_INTEGER(XK_comma);
  DEFINE_INTEGER(XK_minus);
  DEFINE_INTEGER(XK_period);
  DEFINE_INTEGER(XK_slash);
  DEFINE_INTEGER(XK_0);
  DEFINE_INTEGER(XK_1);
  DEFINE_INTEGER(XK_2);
  DEFINE_INTEGER(XK_3);
  DEFINE_INTEGER(XK_4);
  DEFINE_INTEGER(XK_5);
  DEFINE_INTEGER(XK_6);
  DEFINE_INTEGER(XK_7);
  DEFINE_INTEGER(XK_8);
  DEFINE_INTEGER(XK_9);
  DEFINE_INTEGER(XK_colon);
  DEFINE_INTEGER(XK_semicolon);
  DEFINE_INTEGER(XK_less);
  DEFINE_INTEGER(XK_equal);
  DEFINE_INTEGER(XK_greater);
  DEFINE_INTEGER(XK_question);
  DEFINE_INTEGER(XK_at);
  DEFINE_INTEGER(XK_A);
  DEFINE_INTEGER(XK_B);
  DEFINE_INTEGER(XK_C);
  DEFINE_INTEGER(XK_D);
  DEFINE_INTEGER(XK_E);
  DEFINE_INTEGER(XK_F);
  DEFINE_INTEGER(XK_G);
  DEFINE_INTEGER(XK_H);
  DEFINE_INTEGER(XK_I);
  DEFINE_INTEGER(XK_J);
  DEFINE_INTEGER(XK_K);
  DEFINE_INTEGER(XK_L);
  DEFINE_INTEGER(XK_M);
  DEFINE_INTEGER(XK_N);
  DEFINE_INTEGER(XK_O);
  DEFINE_INTEGER(XK_P);
  DEFINE_INTEGER(XK_Q);
  DEFINE_INTEGER(XK_R);
  DEFINE_INTEGER(XK_S);
  DEFINE_INTEGER(XK_T);
  DEFINE_INTEGER(XK_U);
  DEFINE_INTEGER(XK_V);
  DEFINE_INTEGER(XK_W);
  DEFINE_INTEGER(XK_X);
  DEFINE_INTEGER(XK_Y);
  DEFINE_INTEGER(XK_Z);
  DEFINE_INTEGER(XK_bracketleft);
  DEFINE_INTEGER(XK_backslash);
  DEFINE_INTEGER(XK_bracketright);
  DEFINE_INTEGER(XK_asciicircum);
  DEFINE_INTEGER(XK_underscore);
  DEFINE_INTEGER(XK_grave);
  DEFINE_INTEGER(XK_quoteleft);
  DEFINE_INTEGER(XK_a);
  DEFINE_INTEGER(XK_b);
  DEFINE_INTEGER(XK_c);
  DEFINE_INTEGER(XK_d);
  DEFINE_INTEGER(XK_e);
  DEFINE_INTEGER(XK_f);
  DEFINE_INTEGER(XK_g);
  DEFINE_INTEGER(XK_h);
  DEFINE_INTEGER(XK_i);
  DEFINE_INTEGER(XK_j);
  DEFINE_INTEGER(XK_k);
  DEFINE_INTEGER(XK_l);
  DEFINE_INTEGER(XK_m);
  DEFINE_INTEGER(XK_n);
  DEFINE_INTEGER(XK_o);
  DEFINE_INTEGER(XK_p);
  DEFINE_INTEGER(XK_q);
  DEFINE_INTEGER(XK_r);
  DEFINE_INTEGER(XK_s);
  DEFINE_INTEGER(XK_t);
  DEFINE_INTEGER(XK_u);
  DEFINE_INTEGER(XK_v);
  DEFINE_INTEGER(XK_w);
  DEFINE_INTEGER(XK_x);
  DEFINE_INTEGER(XK_y);
  DEFINE_INTEGER(XK_z);
  DEFINE_INTEGER(XK_braceleft);
  DEFINE_INTEGER(XK_bar);
  DEFINE_INTEGER(XK_braceright);
  DEFINE_INTEGER(XK_asciitilde);
  DEFINE_INTEGER(XK_nobreakspace);
  DEFINE_INTEGER(XK_exclamdown);
  DEFINE_INTEGER(XK_cent);
  DEFINE_INTEGER(XK_sterling);
  DEFINE_INTEGER(XK_currency);
  DEFINE_INTEGER(XK_yen);
  DEFINE_INTEGER(XK_brokenbar);
  DEFINE_INTEGER(XK_section);
  DEFINE_INTEGER(XK_diaeresis);
  DEFINE_INTEGER(XK_copyright);
  DEFINE_INTEGER(XK_ordfeminine);
  DEFINE_INTEGER(XK_guillemotleft);
  DEFINE_INTEGER(XK_notsign);
  DEFINE_INTEGER(XK_hyphen);
  DEFINE_INTEGER(XK_registered);
  DEFINE_INTEGER(XK_macron);
  DEFINE_INTEGER(XK_degree);
  DEFINE_INTEGER(XK_plusminus);
  DEFINE_INTEGER(XK_twosuperior);
  DEFINE_INTEGER(XK_threesuperior);
  DEFINE_INTEGER(XK_acute);
  DEFINE_INTEGER(XK_mu);
  DEFINE_INTEGER(XK_paragraph);
  DEFINE_INTEGER(XK_periodcentered);
  DEFINE_INTEGER(XK_cedilla);
  DEFINE_INTEGER(XK_onesuperior);
  DEFINE_INTEGER(XK_masculine);
  DEFINE_INTEGER(XK_guillemotright);
  DEFINE_INTEGER(XK_onequarter);
  DEFINE_INTEGER(XK_onehalf);
  DEFINE_INTEGER(XK_threequarters);
  DEFINE_INTEGER(XK_questiondown);
  DEFINE_INTEGER(XK_Agrave);
  DEFINE_INTEGER(XK_Aacute);
  DEFINE_INTEGER(XK_Acircumflex);
  DEFINE_INTEGER(XK_Atilde);
  DEFINE_INTEGER(XK_Adiaeresis);
  DEFINE_INTEGER(XK_Aring);
  DEFINE_INTEGER(XK_AE);
  DEFINE_INTEGER(XK_Ccedilla);
  DEFINE_INTEGER(XK_Egrave);
  DEFINE_INTEGER(XK_Eacute);
  DEFINE_INTEGER(XK_Ecircumflex);
  DEFINE_INTEGER(XK_Ediaeresis);
  DEFINE_INTEGER(XK_Igrave);
  DEFINE_INTEGER(XK_Iacute);
  DEFINE_INTEGER(XK_Icircumflex);
  DEFINE_INTEGER(XK_Idiaeresis);
  DEFINE_INTEGER(XK_ETH);
  DEFINE_INTEGER(XK_Eth);
  DEFINE_INTEGER(XK_Ntilde);
  DEFINE_INTEGER(XK_Ograve);
  DEFINE_INTEGER(XK_Oacute);
  DEFINE_INTEGER(XK_Ocircumflex);
  DEFINE_INTEGER(XK_Otilde);
  DEFINE_INTEGER(XK_Odiaeresis);
  DEFINE_INTEGER(XK_multiply);
  DEFINE_INTEGER(XK_Ooblique);
  DEFINE_INTEGER(XK_Ugrave);
  DEFINE_INTEGER(XK_Uacute);
  DEFINE_INTEGER(XK_Ucircumflex);
  DEFINE_INTEGER(XK_Udiaeresis);
  DEFINE_INTEGER(XK_Yacute);
  DEFINE_INTEGER(XK_THORN);
  DEFINE_INTEGER(XK_Thorn);
  DEFINE_INTEGER(XK_ssharp);
  DEFINE_INTEGER(XK_agrave);
  DEFINE_INTEGER(XK_aacute);
  DEFINE_INTEGER(XK_acircumflex);
  DEFINE_INTEGER(XK_atilde);
  DEFINE_INTEGER(XK_adiaeresis);
  DEFINE_INTEGER(XK_aring);
  DEFINE_INTEGER(XK_ae);
  DEFINE_INTEGER(XK_ccedilla);
  DEFINE_INTEGER(XK_egrave);
  DEFINE_INTEGER(XK_eacute);
  DEFINE_INTEGER(XK_ecircumflex);
  DEFINE_INTEGER(XK_ediaeresis);
  DEFINE_INTEGER(XK_igrave);
  DEFINE_INTEGER(XK_iacute);
  DEFINE_INTEGER(XK_icircumflex);
  DEFINE_INTEGER(XK_idiaeresis);
  DEFINE_INTEGER(XK_eth);
  DEFINE_INTEGER(XK_ntilde);
  DEFINE_INTEGER(XK_ograve);
  DEFINE_INTEGER(XK_oacute);
  DEFINE_INTEGER(XK_ocircumflex);
  DEFINE_INTEGER(XK_otilde);
  DEFINE_INTEGER(XK_odiaeresis);
  DEFINE_INTEGER(XK_division);
  DEFINE_INTEGER(XK_oslash);
  DEFINE_INTEGER(XK_ugrave);
  DEFINE_INTEGER(XK_uacute);
  DEFINE_INTEGER(XK_ucircumflex);
  DEFINE_INTEGER(XK_udiaeresis);
  DEFINE_INTEGER(XK_yacute);
  DEFINE_INTEGER(XK_thorn);
  DEFINE_INTEGER(XK_ydiaeresis);
#if HAVE_XPM
  DEFINE_INTEGER(XpmFormat);
  DEFINE_INTEGER(XpmVersion);
  DEFINE_INTEGER(XpmRevision);
  DEFINE_INTEGER(XpmIncludeVersion);
  DEFINE_INTEGER(XpmColorError);
  DEFINE_INTEGER(XpmSuccess);
  DEFINE_INTEGER(XpmOpenFailed);
  DEFINE_INTEGER(XpmFileInvalid);
  DEFINE_INTEGER(XpmNoMemory);
  DEFINE_INTEGER(XpmColorFailed);
  DEFINE_INTEGER(XpmVisual);
  DEFINE_INTEGER(XpmColormap);
  DEFINE_INTEGER(XpmDepth);
  DEFINE_INTEGER(XpmSize);
  DEFINE_INTEGER(XpmHotspot);
  DEFINE_INTEGER(XpmCharsPerPixel);
  DEFINE_INTEGER(XpmColorSymbols);
  DEFINE_INTEGER(XpmRgbFilename);
  DEFINE_INTEGER(XpmInfos);
  DEFINE_INTEGER(XpmReturnInfos);
  DEFINE_INTEGER(XpmReturnPixels);
  DEFINE_INTEGER(XpmExtensions);
  DEFINE_INTEGER(XpmReturnExtensions);
  DEFINE_INTEGER(XpmExactColors);
  DEFINE_INTEGER(XpmCloseness);
  DEFINE_INTEGER(XpmRGBCloseness);
  DEFINE_INTEGER(XpmColorKey);
  DEFINE_INTEGER(XpmColorTable);
  DEFINE_INTEGER(XpmReturnColorTable);
#ifdef XpmReturnAllocPixels
  DEFINE_INTEGER(XpmReturnAllocPixels);
  DEFINE_INTEGER(XpmAllocCloseColors);
  DEFINE_INTEGER(XpmBitmapFormat);
  DEFINE_INTEGER(XpmAllocColor);
  DEFINE_INTEGER(XpmFreeColors);
  DEFINE_INTEGER(XpmColorClosure);
#endif
  DEFINE_INTEGER(XpmComments);
  DEFINE_INTEGER(XpmReturnComments);
  DEFINE_INTEGER(XpmUndefPixel);
#endif
  DEFINE_INTEGER(NoValue);
  DEFINE_INTEGER(XValue);
  DEFINE_INTEGER(YValue);
  DEFINE_INTEGER(WidthValue);
  DEFINE_INTEGER(HeightValue);
  DEFINE_INTEGER(AllValues);
  DEFINE_INTEGER(XNegative);
  DEFINE_INTEGER(YNegative);
  DEFINE_INTEGER(InputHint);
  DEFINE_INTEGER(StateHint);
  DEFINE_INTEGER(IconPixmapHint);
  DEFINE_INTEGER(IconWindowHint);
  DEFINE_INTEGER(IconPositionHint);
  DEFINE_INTEGER(IconMaskHint);
  DEFINE_INTEGER(WindowGroupHint);
  DEFINE_INTEGER(AllHints);
  DEFINE_INTEGER(XUrgencyHint);
  DEFINE_INTEGER(WithdrawnState);
  DEFINE_INTEGER(NormalState);
  DEFINE_INTEGER(IconicState);
  DEFINE_INTEGER(DontCareState);
  DEFINE_INTEGER(ZoomState);
  DEFINE_INTEGER(InactiveState);
  DEFINE_INTEGER(XNoMemory);
  DEFINE_INTEGER(XLocaleNotSupported);
  DEFINE_INTEGER(XConverterNotFound);
  DEFINE_INTEGER(RectangleOut);
  DEFINE_INTEGER(RectangleIn);
  DEFINE_INTEGER(RectanglePart);
  DEFINE_INTEGER(VisualNoMask);
  DEFINE_INTEGER(VisualIDMask);
  DEFINE_INTEGER(VisualScreenMask);
  DEFINE_INTEGER(VisualDepthMask);
  DEFINE_INTEGER(VisualClassMask);
  DEFINE_INTEGER(VisualRedMaskMask);
  DEFINE_INTEGER(VisualGreenMaskMask);
  DEFINE_INTEGER(VisualBlueMaskMask);
  DEFINE_INTEGER(VisualColormapSizeMask);
  DEFINE_INTEGER(VisualBitsPerRGBMask);
  DEFINE_INTEGER(VisualAllMask);
  DEFINE_INTEGER(ReleaseByFreeingColormap);
  DEFINE_INTEGER(BitmapSuccess);
  DEFINE_INTEGER(BitmapOpenFailed);
  DEFINE_INTEGER(BitmapFileInvalid);
  DEFINE_INTEGER(BitmapNoMemory);
#if HAVE_MOTIF
  DEFINE_INTEGER(MWM_HINTS_FUNCTIONS);
  DEFINE_INTEGER(MWM_HINTS_DECORATIONS);
  DEFINE_INTEGER(MWM_HINTS_INPUT_MODE);
  DEFINE_INTEGER(MWM_HINTS_STATUS);
  DEFINE_INTEGER(MWM_FUNC_ALL);
  DEFINE_INTEGER(MWM_FUNC_RESIZE);
  DEFINE_INTEGER(MWM_FUNC_MOVE);
  DEFINE_INTEGER(MWM_FUNC_MINIMIZE);
  DEFINE_INTEGER(MWM_FUNC_MAXIMIZE);
  DEFINE_INTEGER(MWM_FUNC_CLOSE);
  DEFINE_INTEGER(MWM_DECOR_ALL);
  DEFINE_INTEGER(MWM_DECOR_BORDER);
  DEFINE_INTEGER(MWM_DECOR_RESIZEH);
  DEFINE_INTEGER(MWM_DECOR_TITLE);
  DEFINE_INTEGER(MWM_DECOR_MENU);
  DEFINE_INTEGER(MWM_DECOR_MINIMIZE);
  DEFINE_INTEGER(MWM_DECOR_MAXIMIZE);
#ifdef XmCR_WM_PROTOCOLS
  DEFINE_INTEGER(XmCR_WM_PROTOCOLS);
#endif
  DEFINE_INTEGER(MWM_INPUT_MODELESS);
  DEFINE_INTEGER(MWM_INPUT_PRIMARY_APPLICATION_MODAL);
  DEFINE_INTEGER(MWM_INPUT_SYSTEM_MODAL);
  DEFINE_INTEGER(MWM_INPUT_FULL_APPLICATION_MODAL);
  DEFINE_INTEGER(MWM_TEAROFF_WINDOW);
  DEFINE_INTEGER(MWM_INPUT_APPLICATION_MODAL);
  DEFINE_INTEGER(MWM_INFO_STARTUP_STANDARD);
  DEFINE_INTEGER(MWM_INFO_STARTUP_CUSTOM);
  DEFINE_INTEGER(PROP_MOTIF_WM_HINTS_ELEMENTS);
  DEFINE_INTEGER(PROP_MWM_HINTS_ELEMENTS);
  DEFINE_INTEGER(PROP_MOTIF_WM_INFO_ELEMENTS);
  DEFINE_INTEGER(PROP_MWM_INFO_ELEMENTS);
  DEFINE_INTEGER(ClipboardFail);
  DEFINE_INTEGER(ClipboardSuccess);
  DEFINE_INTEGER(ClipboardTruncate);
  DEFINE_INTEGER(ClipboardLocked);
  DEFINE_INTEGER(ClipboardBadFormat);
  DEFINE_INTEGER(ClipboardNoData);
  DEFINE_INTEGER(XmHELP);
  DEFINE_INTEGER(XmDROP_NOOP);
  DEFINE_INTEGER(XmDROP_MOVE);
  DEFINE_INTEGER(XmDROP_COPY);
  DEFINE_INTEGER(XmDROP_LINK);
  DEFINE_INTEGER(XmCR_DROP_SITE_LEAVE_MESSAGE);
  DEFINE_INTEGER(XmCR_DROP_SITE_ENTER_MESSAGE);
  DEFINE_INTEGER(XmCR_DROP_SITE_MOTION_MESSAGE);
  DEFINE_INTEGER(XmCR_DROP_MESSAGE);
  DEFINE_INTEGER(XmNO_DROP_SITE);
  DEFINE_INTEGER(XmINVALID_DROP_SITE);
  DEFINE_INTEGER(XmVALID_DROP_SITE);
  DEFINE_INTEGER(XmDROP_SITE_INVALID);
  DEFINE_INTEGER(XmDROP_SITE_VALID);
  DEFINE_INTEGER(XmTRANSFER_FAILURE);
  DEFINE_INTEGER(XmTRANSFER_SUCCESS);
  DEFINE_INTEGER(XmUNSPECIFIED_ICON_SIZE);
  DEFINE_INTEGER(XmLARGE_ICON_SIZE);
  DEFINE_INTEGER(XmMEDIUM_ICON_SIZE);
  DEFINE_INTEGER(XmSMALL_ICON_SIZE);
  DEFINE_INTEGER(XmTINY_ICON_SIZE);
  DEFINE_INTEGER(XmUNSPECIFIED_POSITION);
  DEFINE_INTEGER(XmINVALID_POSITION);
  DEFINE_INTEGER(XmINDICATOR_3D_BOX);
  DEFINE_INTEGER(XmINDICATOR_FLAT_BOX);
  DEFINE_INTEGER(XmINDICATOR_CHECK_GLYPH);
  DEFINE_INTEGER(XmINDICATOR_CROSS_GLYPH);
  DEFINE_INTEGER(XmINITIAL);
  DEFINE_INTEGER(XmADDITION);
  DEFINE_INTEGER(XmMODIFICATION);
  DEFINE_INTEGER(XmVERSION);
  DEFINE_INTEGER(XmREVISION);
  DEFINE_INTEGER(XmUPDATE_LEVEL);
  DEFINE_INTEGER(XmVersion);
  DEFINE_INTEGER(XmUNSPECIFIED_PIXMAP);
  DEFINE_INTEGER(XmCOPY_FAILED);
  DEFINE_INTEGER(XmCOPY_SUCCEEDED);
  DEFINE_INTEGER(XmCOPY_TRUNCATED);
  DEFINE_INTEGER(XmDIALOG_HISTORY_LIST);
  DEFINE_INTEGER(XmDIALOG_PROMPT_LABEL);
  DEFINE_INTEGER(XmDIALOG_VALUE_TEXT);
  DEFINE_INTEGER(XmDIALOG_COMMAND_TEXT);
  DEFINE_INTEGER(XmDIALOG_FILE_LIST);
  DEFINE_INTEGER(XmDIALOG_FILE_LIST_LABEL);
  DEFINE_INTEGER(XmDIALOG_APPLICATION_MODAL);
  DEFINE_INTEGER(XmFILE_DIRECTORY);
  DEFINE_INTEGER(XmFILE_REGULAR);
  DEFINE_INTEGER(XmFILE_ANY_TYPE);
  DEFINE_INTEGER(XmCHECKBUTTON);
#endif  
  /* enums */

#if HAVE_MOTIF  
  DEFINE_INTEGER(XtCallbackNoList);
  DEFINE_INTEGER(XtCallbackHasNone);
  DEFINE_INTEGER(XtCallbackHasSome);
  DEFINE_INTEGER(XtGeometryYes);
  DEFINE_INTEGER(XtGeometryNo);
  DEFINE_INTEGER(XtGeometryAlmost);
  DEFINE_INTEGER(XtGeometryDone);
  DEFINE_INTEGER(XtGrabNone);
  DEFINE_INTEGER(XtGrabNonexclusive);
  DEFINE_INTEGER(XtGrabExclusive);
  DEFINE_INTEGER(XtListHead);
  DEFINE_INTEGER(XtListTail);
#endif
  DEFINE_INTEGER(XStringStyle);
  DEFINE_INTEGER(XCompoundTextStyle);
  DEFINE_INTEGER(XTextStyle);
  DEFINE_INTEGER(XStdICCTextStyle);
#if HAVE_MOTIF
  DEFINE_INTEGER(XmClipboardFail);
  DEFINE_INTEGER(XmClipboardSuccess);
  DEFINE_INTEGER(XmClipboardTruncate);
  DEFINE_INTEGER(XmClipboardLocked);
  DEFINE_INTEGER(XmClipboardBadFormat);
  DEFINE_INTEGER(XmClipboardNoData);
  DEFINE_INTEGER(XmDRAG_NONE);
  DEFINE_INTEGER(XmDRAG_DROP_ONLY);
  DEFINE_INTEGER(XmDRAG_PREFER_PREREGISTER);
  DEFINE_INTEGER(XmDRAG_PREREGISTER);
  DEFINE_INTEGER(XmDRAG_PREFER_DYNAMIC);
  DEFINE_INTEGER(XmDRAG_DYNAMIC);
  DEFINE_INTEGER(XmDRAG_PREFER_RECEIVER);
  DEFINE_INTEGER(XmTOP_LEVEL_ENTER);
  DEFINE_INTEGER(XmTOP_LEVEL_LEAVE);
  DEFINE_INTEGER(XmDRAG_MOTION);
  DEFINE_INTEGER(XmDROP_SITE_ENTER);
  DEFINE_INTEGER(XmDROP_SITE_LEAVE);
  DEFINE_INTEGER(XmDROP_START);
  DEFINE_INTEGER(XmDROP_FINISH);
  DEFINE_INTEGER(XmDRAG_DROP_FINISH);
  DEFINE_INTEGER(XmOPERATION_CHANGED);
  DEFINE_INTEGER(XmDROP);
  DEFINE_INTEGER(XmDROP_HELP);
  DEFINE_INTEGER(XmDROP_CANCEL);
  DEFINE_INTEGER(XmDROP_INTERRUPT);
  DEFINE_INTEGER(XmBLEND_ALL);
  DEFINE_INTEGER(XmBLEND_STATE_SOURCE);
  DEFINE_INTEGER(XmBLEND_JUST_SOURCE);
  DEFINE_INTEGER(XmBLEND_NONE);
  DEFINE_INTEGER(XmDROP_FAILURE);
  DEFINE_INTEGER(XmDROP_SUCCESS);
  DEFINE_INTEGER(XmCR_TOP_LEVEL_ENTER);
  DEFINE_INTEGER(XmCR_TOP_LEVEL_LEAVE);
  DEFINE_INTEGER(XmCR_DRAG_MOTION);
  DEFINE_INTEGER(XmCR_DROP_SITE_ENTER);
  DEFINE_INTEGER(XmCR_DROP_SITE_LEAVE);
  DEFINE_INTEGER(XmCR_DROP_START);
  DEFINE_INTEGER(XmCR_DROP_FINISH);
  DEFINE_INTEGER(XmCR_DRAG_DROP_FINISH);
  DEFINE_INTEGER(XmCR_OPERATION_CHANGED);
  DEFINE_INTEGER(XmATTACH_NORTH_WEST);
  DEFINE_INTEGER(XmATTACH_NORTH);
  DEFINE_INTEGER(XmATTACH_NORTH_EAST);
  DEFINE_INTEGER(XmATTACH_EAST);
  DEFINE_INTEGER(XmATTACH_SOUTH_EAST);
  DEFINE_INTEGER(XmATTACH_SOUTH);
  DEFINE_INTEGER(XmATTACH_SOUTH_WEST);
  DEFINE_INTEGER(XmATTACH_WEST);
  DEFINE_INTEGER(XmATTACH_CENTER);
  DEFINE_INTEGER(XmATTACH_HOT);
  DEFINE_INTEGER(XmDRAG_UNDER_NONE);
  DEFINE_INTEGER(XmDRAG_UNDER_PIXMAP);
  DEFINE_INTEGER(XmDRAG_UNDER_SHADOW_IN);
  DEFINE_INTEGER(XmDRAG_UNDER_SHADOW_OUT);
  DEFINE_INTEGER(XmDRAG_UNDER_HIGHLIGHT);
  DEFINE_INTEGER(XmDROP_SITE_SIMPLE);
  DEFINE_INTEGER(XmDROP_SITE_COMPOSITE);
  DEFINE_INTEGER(XmDROP_SITE_SIMPLE_CLIP_ONLY);
  DEFINE_INTEGER(XmDROP_SITE_COMPOSITE_CLIP_ONLY);
  DEFINE_INTEGER(XmABOVE);
  DEFINE_INTEGER(XmBELOW);
  DEFINE_INTEGER(XmDROP_SITE_ACTIVE);
  DEFINE_INTEGER(XmDROP_SITE_INACTIVE);
  DEFINE_INTEGER(XmFONT_IS_FONT);
  DEFINE_INTEGER(XmFONT_IS_FONTSET);
  DEFINE_INTEGER(XmSTRING_DIRECTION_L_TO_R);
  DEFINE_INTEGER(XmSTRING_DIRECTION_R_TO_L);
  DEFINE_INTEGER(XmSTRING_DIRECTION_DEFAULT);
  DEFINE_INTEGER(XmSTRING_COMPONENT_UNKNOWN);
  DEFINE_INTEGER(XmSTRING_COMPONENT_TEXT);
  DEFINE_INTEGER(XmSTRING_COMPONENT_DIRECTION);
  DEFINE_INTEGER(XmSTRING_COMPONENT_SEPARATOR);
  DEFINE_INTEGER(XmSTRING_COMPONENT_LOCALE_TEXT);
  DEFINE_INTEGER(XmSTRING_COMPONENT_END);
#if (!XM_DISABLE_DEPRECATED)
  DEFINE_INTEGER(XmSTRING_COMPONENT_CHARSET);
  DEFINE_INTEGER(XmSTRING_COMPONENT_FONTLIST_ELEMENT_TAG);
#endif
  DEFINE_INTEGER(XmPAGE_FOUND);
  DEFINE_INTEGER(XmPAGE_INVALID);
  DEFINE_INTEGER(XmPAGE_EMPTY);
  DEFINE_INTEGER(XmPAGE_DUPLICATED);
  DEFINE_INTEGER(XmMOVE);
  DEFINE_INTEGER(XmCOPY);
  DEFINE_INTEGER(XmLINK);
  DEFINE_INTEGER(XmOTHER);
  DEFINE_INTEGER(XmDROP_SITE_IGNORE);
  DEFINE_INTEGER(XmTRANSFER_DONE_SUCCEED);
  DEFINE_INTEGER(XmTRANSFER_DONE_FAIL);
  DEFINE_INTEGER(XmTRANSFER_DONE_CONTINUE);
  DEFINE_INTEGER(XmTRANSFER_DONE_DEFAULT);
  DEFINE_INTEGER(XmSELECTION_DEFAULT);
  DEFINE_INTEGER(XmSELECTION_INCREMENTAL);
  DEFINE_INTEGER(XmSELECTION_PERSIST);
  DEFINE_INTEGER(XmSELECTION_SNAPSHOT);
  DEFINE_INTEGER(XmSELECTION_TRANSACT);
  DEFINE_INTEGER(XmCONVERTING_NONE);
  DEFINE_INTEGER(XmCONVERTING_SAME);
  DEFINE_INTEGER(XmCONVERTING_TRANSACT);
  DEFINE_INTEGER(XmCONVERTING_PARTIAL);
  DEFINE_INTEGER(XmCONVERT_DEFAULT);
  DEFINE_INTEGER(XmCONVERT_MORE);
  DEFINE_INTEGER(XmCONVERT_MERGE);
  DEFINE_INTEGER(XmCONVERT_REFUSE);
  DEFINE_INTEGER(XmCONVERT_DONE);
  DEFINE_INTEGER(XmSTRING_DIRECTION_UNSET);
  DEFINE_INTEGER(XmSTRING_COMPONENT_LOCALE);
  DEFINE_INTEGER(XmSTRING_COMPONENT_WIDECHAR_TEXT);
  DEFINE_INTEGER(XmSTRING_COMPONENT_LAYOUT_PUSH);
  DEFINE_INTEGER(XmSTRING_COMPONENT_LAYOUT_POP);
  DEFINE_INTEGER(XmSTRING_COMPONENT_RENDITION_BEGIN);
  DEFINE_INTEGER(XmSTRING_COMPONENT_RENDITION_END);
  DEFINE_INTEGER(XmSTRING_COMPONENT_TAB);
  DEFINE_INTEGER(XmSTRING_COMPONENT_TAG);
  DEFINE_INTEGER(XmCHARSET_TEXT);
  DEFINE_INTEGER(XmMULTIBYTE_TEXT);
  DEFINE_INTEGER(XmWIDECHAR_TEXT);
  DEFINE_INTEGER(XmNO_TEXT);
  DEFINE_INTEGER(XmOUTPUT_ALL);
  DEFINE_INTEGER(XmOUTPUT_BETWEEN);
  DEFINE_INTEGER(XmOUTPUT_BEGINNING);
  DEFINE_INTEGER(XmOUTPUT_END);
  DEFINE_INTEGER(XmOUTPUT_BOTH);
  DEFINE_INTEGER(XmINSERT);
  DEFINE_INTEGER(XmTERMINATE);
  DEFINE_INTEGER(XmINVOKE);
  DEFINE_INTEGER(XmSTYLE_STRING);
  DEFINE_INTEGER(XmSTYLE_COMPOUND_TEXT);
  DEFINE_INTEGER(XmSTYLE_TEXT);
  DEFINE_INTEGER(XmSTYLE_STANDARD_ICC_TEXT);
  DEFINE_INTEGER(XmSTYLE_LOCALE);
  DEFINE_INTEGER(XmSTYLE_COMPOUND_STRING);
  DEFINE_INTEGER(XmABSOLUTE);
  DEFINE_INTEGER(XmRELATIVE);
  DEFINE_INTEGER(XmSKIP);
  DEFINE_INTEGER(XmMERGE_REPLACE);
  DEFINE_INTEGER(XmMERGE_OLD);
  DEFINE_INTEGER(XmMERGE_NEW);
  DEFINE_INTEGER(XmDUPLICATE);
  DEFINE_INTEGER(XmAS_IS);
  DEFINE_INTEGER(XmFORCE_COLOR);

  /* the next 4 are dependent on (Pixel)(~0) which is unsigned long in X terminology, but we then subtract from it --
   *    that is, XmHIGHLIGHT_COLOR is: ((Pixel)(~0)) - 2, which I assume is intended to be a positive number
   */
#if 0
  DEFINE_INTEGER(XmUNSPECIFIED_PIXEL);
  DEFINE_INTEGER(XmDEFAULT_SELECT_COLOR);
  DEFINE_INTEGER(XmREVERSED_GROUND_COLORS);
  DEFINE_INTEGER(XmHIGHLIGHT_COLOR);
#else
  DEFINE_ULONG(XmUNSPECIFIED_PIXEL);
  DEFINE_ULONG(XmDEFAULT_SELECT_COLOR);
  DEFINE_ULONG(XmREVERSED_GROUND_COLORS);
  DEFINE_ULONG(XmHIGHLIGHT_COLOR);
#endif

  DEFINE_INTEGER(XmUNSPECIFIED_LOAD_MODEL);
  DEFINE_INTEGER(XmLOAD_DEFERRED);
  DEFINE_INTEGER(XmLOAD_IMMEDIATE);
  DEFINE_INTEGER(XmCHANGE_ALL);
  DEFINE_INTEGER(XmCHANGE_NONE);
  DEFINE_INTEGER(XmCHANGE_WIDTH);
  DEFINE_INTEGER(XmCHANGE_HEIGHT);
  DEFINE_INTEGER(XmDYNAMIC_DEFAULT_TAB_GROUP);
  DEFINE_INTEGER(XmPIXELS);
  DEFINE_INTEGER(Xm100TH_MILLIMETERS);
  DEFINE_INTEGER(Xm1000TH_INCHES);
  DEFINE_INTEGER(Xm100TH_POINTS);
  DEFINE_INTEGER(Xm100TH_FONT_UNITS);
  DEFINE_INTEGER(XmDESTROY);
  DEFINE_INTEGER(XmUNMAP);
  DEFINE_INTEGER(XmDO_NOTHING);
  DEFINE_INTEGER(XmEXPLICIT);
  DEFINE_INTEGER(XmPOINTER);
  DEFINE_INTEGER(XmNONE);
  DEFINE_INTEGER(XmTAB_GROUP);
  DEFINE_INTEGER(XmSTICKY_TAB_GROUP);
  DEFINE_INTEGER(XmEXCLUSIVE_TAB_GROUP);
  DEFINE_INTEGER(XmBELL);
  DEFINE_INTEGER(XmNO_ORIENTATION);
  DEFINE_INTEGER(XmVERTICAL);
  DEFINE_INTEGER(XmHORIZONTAL);
  DEFINE_INTEGER(XmWORK_AREA);
  DEFINE_INTEGER(XmMENU_BAR);
  DEFINE_INTEGER(XmMENU_PULLDOWN);
  DEFINE_INTEGER(XmMENU_POPUP);
  DEFINE_INTEGER(XmMENU_OPTION);
  DEFINE_INTEGER(XmNO_PACKING);
  DEFINE_INTEGER(XmPACK_TIGHT);
  DEFINE_INTEGER(XmPACK_COLUMN);
  DEFINE_INTEGER(XmPACK_NONE);
  DEFINE_INTEGER(XmALIGNMENT_CONTENTS_TOP);
  DEFINE_INTEGER(XmALIGNMENT_CONTENTS_BOTTOM);
  DEFINE_INTEGER(XmTEAR_OFF_ENABLED);
  DEFINE_INTEGER(XmTEAR_OFF_DISABLED);
  DEFINE_INTEGER(XmUNPOST);
  DEFINE_INTEGER(XmUNPOST_AND_REPLAY);
  DEFINE_INTEGER(XmLAST_POSITION);
  DEFINE_INTEGER(XmFIRST_POSITION);
  DEFINE_INTEGER(XmINCHES);
  DEFINE_INTEGER(XmCENTIMETERS);
  DEFINE_INTEGER(XmMILLIMETERS);
  DEFINE_INTEGER(XmPOINTS);
  DEFINE_INTEGER(XmFONT_UNITS);
  DEFINE_INTEGER(XmPER_SHELL);
  DEFINE_INTEGER(XmPER_WIDGET);
  DEFINE_INTEGER(XmINHERIT_POLICY);
  DEFINE_INTEGER(XmPOPUP_DISABLED);
  DEFINE_INTEGER(XmPOPUP_KEYBOARD);
  DEFINE_INTEGER(XmPOPUP_AUTOMATIC);
  DEFINE_INTEGER(XmPOPUP_AUTOMATIC_RECURSIVE);
  DEFINE_INTEGER(XmCOMBO_BOX);
  DEFINE_INTEGER(XmDROP_DOWN_COMBO_BOX);
  DEFINE_INTEGER(XmDROP_DOWN_LIST);
  DEFINE_INTEGER(XmQUICK_NAVIGATE);
  DEFINE_INTEGER(XmINVALID_MATCH_BEHAVIOR);
  DEFINE_INTEGER(XmZERO_BASED);
  DEFINE_INTEGER(XmONE_BASED);
  DEFINE_INTEGER(XmALIGNMENT_CHILD_TOP);
  DEFINE_INTEGER(XmALIGNMENT_CHILD_BOTTOM);
  DEFINE_INTEGER(XmONE_OF_MANY_ROUND);
  DEFINE_INTEGER(XmONE_OF_MANY_DIAMOND);
  DEFINE_INTEGER(XmALIGNMENT_BEGINNING);
  DEFINE_INTEGER(XmALIGNMENT_CENTER);
  DEFINE_INTEGER(XmALIGNMENT_END);
  DEFINE_INTEGER(XmALIGNMENT_BASELINE_TOP);
  DEFINE_INTEGER(XmALIGNMENT_BASELINE_BOTTOM);
  DEFINE_INTEGER(XmALIGNMENT_WIDGET_TOP);
  DEFINE_INTEGER(XmALIGNMENT_WIDGET_BOTTOM);
#ifdef XmALIGNMENT_UNSPECIFIED
  DEFINE_INTEGER(XmALIGNMENT_UNSPECIFIED);
#endif
  DEFINE_INTEGER(XmFRAME_GENERIC_CHILD);
  DEFINE_INTEGER(XmFRAME_WORKAREA_CHILD);
  DEFINE_INTEGER(XmFRAME_TITLE_CHILD);
  DEFINE_INTEGER(XmN_OF_MANY);
  DEFINE_INTEGER(XmONE_OF_MANY);
  DEFINE_INTEGER(XmATTACH_NONE);
  DEFINE_INTEGER(XmATTACH_FORM);
  DEFINE_INTEGER(XmATTACH_OPPOSITE_FORM);
  DEFINE_INTEGER(XmATTACH_WIDGET);
  DEFINE_INTEGER(XmATTACH_OPPOSITE_WIDGET);
  DEFINE_INTEGER(XmATTACH_POSITION);
  DEFINE_INTEGER(XmATTACH_SELF);
  DEFINE_INTEGER(XmRESIZE_NONE);
  DEFINE_INTEGER(XmRESIZE_GROW);
  DEFINE_INTEGER(XmRESIZE_ANY);
  DEFINE_INTEGER(XmCR_NONE);
  DEFINE_INTEGER(XmCR_HELP);
  DEFINE_INTEGER(XmCR_VALUE_CHANGED);
  DEFINE_INTEGER(XmCR_INCREMENT);
  DEFINE_INTEGER(XmCR_DECREMENT);
  DEFINE_INTEGER(XmCR_PAGE_INCREMENT);
  DEFINE_INTEGER(XmCR_PAGE_DECREMENT);
  DEFINE_INTEGER(XmCR_TO_TOP);
  DEFINE_INTEGER(XmCR_TO_BOTTOM);
  DEFINE_INTEGER(XmCR_DRAG);
  DEFINE_INTEGER(XmCR_ACTIVATE);
  DEFINE_INTEGER(XmCR_ARM);
  DEFINE_INTEGER(XmCR_DISARM);
  DEFINE_INTEGER(XmCR_MAP);
  DEFINE_INTEGER(XmCR_UNMAP);
  DEFINE_INTEGER(XmCR_FOCUS);
  DEFINE_INTEGER(XmCR_LOSING_FOCUS);
  DEFINE_INTEGER(XmCR_MODIFYING_TEXT_VALUE);
  DEFINE_INTEGER(XmCR_MOVING_INSERT_CURSOR);
  DEFINE_INTEGER(XmCR_EXECUTE);
  DEFINE_INTEGER(XmCR_SINGLE_SELECT);
  DEFINE_INTEGER(XmCR_MULTIPLE_SELECT);
  DEFINE_INTEGER(XmCR_EXTENDED_SELECT);
  DEFINE_INTEGER(XmCR_BROWSE_SELECT);
  DEFINE_INTEGER(XmCR_DEFAULT_ACTION);
  DEFINE_INTEGER(XmCR_CLIPBOARD_DATA_REQUEST);
  DEFINE_INTEGER(XmCR_CLIPBOARD_DATA_DELETE);
  DEFINE_INTEGER(XmCR_CASCADING);
  DEFINE_INTEGER(XmCR_OK);
  DEFINE_INTEGER(XmCR_CANCEL);
  DEFINE_INTEGER(XmCR_APPLY);
  DEFINE_INTEGER(XmCR_NO_MATCH);
  DEFINE_INTEGER(XmCR_COMMAND_ENTERED);
  DEFINE_INTEGER(XmCR_COMMAND_CHANGED);
  DEFINE_INTEGER(XmCR_EXPOSE);
  DEFINE_INTEGER(XmCR_RESIZE);
  DEFINE_INTEGER(XmCR_INPUT);
  DEFINE_INTEGER(XmCR_GAIN_PRIMARY);
  DEFINE_INTEGER(XmCR_LOSE_PRIMARY);
  DEFINE_INTEGER(XmCR_CREATE);
  DEFINE_INTEGER(XmCR_TEAR_OFF_ACTIVATE);
  DEFINE_INTEGER(XmCR_TEAR_OFF_DEACTIVATE);
  DEFINE_INTEGER(XmCR_OBSCURED_TRAVERSAL);
  DEFINE_INTEGER(XmCR_FOCUS_MOVED);
  DEFINE_INTEGER(XmCR_REPOST);
  DEFINE_INTEGER(XmCR_COLLAPSED);
  DEFINE_INTEGER(XmCR_EXPANDED);
  DEFINE_INTEGER(XmCR_SELECT);
  DEFINE_INTEGER(XmCR_DRAG_START);
  DEFINE_INTEGER(XmCR_NO_FONT);
  DEFINE_INTEGER(XmCR_NO_RENDITION);
  DEFINE_INTEGER(XmCR_POST);
  DEFINE_INTEGER(XmCR_SPIN_NEXT);
  DEFINE_INTEGER(XmCR_SPIN_PRIOR);
  DEFINE_INTEGER(XmCR_SPIN_FIRST);
  DEFINE_INTEGER(XmCR_SPIN_LAST);
  DEFINE_INTEGER(XmCR_PAGE_SCROLLER_INCREMENT);
  DEFINE_INTEGER(XmCR_PAGE_SCROLLER_DECREMENT);
  DEFINE_INTEGER(XmCR_MAJOR_TAB);
  DEFINE_INTEGER(XmCR_MINOR_TAB);
  DEFINE_INTEGER(XmCR_START_JOB);
  DEFINE_INTEGER(XmCR_END_JOB);
  DEFINE_INTEGER(XmCR_PAGE_SETUP);
  DEFINE_INTEGER(XmCR_PDM_NONE);
  DEFINE_INTEGER(XmCR_PDM_UP);
  DEFINE_INTEGER(XmCR_PDM_START_ERROR);
  DEFINE_INTEGER(XmCR_PDM_START_VXAUTH);
  DEFINE_INTEGER(XmCR_PDM_START_PXAUTH);
  DEFINE_INTEGER(XmCR_PDM_OK);
  DEFINE_INTEGER(XmCR_PDM_CANCEL);
  DEFINE_INTEGER(XmCR_PDM_EXIT_ERROR);
  DEFINE_INTEGER(XmCR_PROTOCOLS);
  DEFINE_INTEGER(XmEACH_SIDE);
  DEFINE_INTEGER(XmMAX_SIDE);
  DEFINE_INTEGER(XmMIN_SIDE);
  DEFINE_INTEGER(XmBACKGROUND_COLOR);
  DEFINE_INTEGER(XmFOREGROUND_COLOR);
  DEFINE_INTEGER(XmTROUGH_COLOR);
  DEFINE_INTEGER(XmSHADOWED_BACKGROUND);
  DEFINE_INTEGER(XmTHUMB_MARK);
  DEFINE_INTEGER(XmROUND_MARK);
  DEFINE_INTEGER(XmNEAR_SLIDER);
  DEFINE_INTEGER(XmNEAR_BORDER);
  DEFINE_INTEGER(XmHOR_SCROLLBAR);
  DEFINE_INTEGER(XmVERT_SCROLLBAR);
  DEFINE_INTEGER(XmCOMMAND_WINDOW);
  DEFINE_INTEGER(XmMESSAGE_WINDOW);
  DEFINE_INTEGER(XmSCROLL_HOR);
  DEFINE_INTEGER(XmSCROLL_VERT);
  DEFINE_INTEGER(XmNO_SCROLL);
  DEFINE_INTEGER(XmCLIP_WINDOW);
  DEFINE_INTEGER(XmGENERIC_CHILD);
  DEFINE_INTEGER(XmAUTO_DRAG_ENABLED);
  DEFINE_INTEGER(XmAUTO_DRAG_DISABLED);
  DEFINE_INTEGER(XmENABLE_WARP_ON);
  DEFINE_INTEGER(XmENABLE_WARP_OFF);
  DEFINE_INTEGER(XmOFF);
  DEFINE_INTEGER(XmBUTTON2_ADJUST);
  DEFINE_INTEGER(XmBUTTON2_TRANSFER);
  DEFINE_INTEGER(XmAUTO_UNSET);
  DEFINE_INTEGER(XmAUTO_BEGIN);
  DEFINE_INTEGER(XmAUTO_MOTION);
  DEFINE_INTEGER(XmAUTO_CANCEL);
  DEFINE_INTEGER(XmAUTO_NO_CHANGE);
  DEFINE_INTEGER(XmAUTO_CHANGE);
  DEFINE_INTEGER(XmDRAG_WINDOW);
  DEFINE_INTEGER(XmSLIDER);
  DEFINE_INTEGER(XmTHERMOMETER);
  DEFINE_INTEGER(XmETCHED_LINE);
  DEFINE_INTEGER(XmMULTICLICK_DISCARD);
  DEFINE_INTEGER(XmMULTICLICK_KEEP);
  DEFINE_INTEGER(XmSHADOW_IN);
  DEFINE_INTEGER(XmSHADOW_OUT);
  DEFINE_INTEGER(XmARROW_UP);
  DEFINE_INTEGER(XmARROW_DOWN);
  DEFINE_INTEGER(XmARROW_LEFT);
  DEFINE_INTEGER(XmARROW_RIGHT);
  DEFINE_INTEGER(XmNO_LINE);
  DEFINE_INTEGER(XmSINGLE_LINE);
  DEFINE_INTEGER(XmDOUBLE_LINE);
  DEFINE_INTEGER(XmSINGLE_DASHED_LINE);
  DEFINE_INTEGER(XmDOUBLE_DASHED_LINE);
  DEFINE_INTEGER(XmSHADOW_ETCHED_IN);
  DEFINE_INTEGER(XmSHADOW_ETCHED_OUT);
  DEFINE_INTEGER(XmSHADOW_ETCHED_IN_DASH);
  DEFINE_INTEGER(XmSHADOW_ETCHED_OUT_DASH);
  DEFINE_INTEGER(XmINVALID_SEPARATOR_TYPE);
  DEFINE_INTEGER(XmPIXMAP);
  DEFINE_INTEGER(XmSTRING);
  DEFINE_INTEGER(XmWINDOW);
  DEFINE_INTEGER(XmCURSOR);
  DEFINE_INTEGER(XmMAX_ON_TOP);
  DEFINE_INTEGER(XmMAX_ON_BOTTOM);
  DEFINE_INTEGER(XmMAX_ON_LEFT);
  DEFINE_INTEGER(XmMAX_ON_RIGHT);
  DEFINE_INTEGER(XmSINGLE_SELECT);
  DEFINE_INTEGER(XmMULTIPLE_SELECT);
  DEFINE_INTEGER(XmEXTENDED_SELECT);
  DEFINE_INTEGER(XmBROWSE_SELECT);
  DEFINE_INTEGER(XmSTATIC);
  DEFINE_INTEGER(XmDYNAMIC);
  DEFINE_INTEGER(XmNORMAL_MODE);
  DEFINE_INTEGER(XmADD_MODE);
  DEFINE_INTEGER(XmNO_AUTO_SELECT);
  DEFINE_INTEGER(XmAUTO_SELECT);
  DEFINE_INTEGER(XmSINGLE);
  DEFINE_INTEGER(XmANY_ICON);
  DEFINE_INTEGER(XmAPPEND);
  DEFINE_INTEGER(XmCLOSEST);
  DEFINE_INTEGER(XmFIRST_FIT);
  DEFINE_INTEGER(XmOUTLINE);
  DEFINE_INTEGER(XmSPATIAL);
  DEFINE_INTEGER(XmDETAIL);
  DEFINE_INTEGER(XmOUTLINE_BUTTON_PRESENT);
  DEFINE_INTEGER(XmOUTLINE_BUTTON_ABSENT);
  DEFINE_INTEGER(XmGRID);
  DEFINE_INTEGER(XmCELLS);
  DEFINE_INTEGER(XmOWN_NEVER);
  DEFINE_INTEGER(XmOWN_ALWAYS);
  DEFINE_INTEGER(XmOWN_MULTIPLE);
  DEFINE_INTEGER(XmOWN_POSSIBLE_MULTIPLE);
  DEFINE_INTEGER(XmGROW_MINOR);
  DEFINE_INTEGER(XmGROW_MAJOR);
  DEFINE_INTEGER(XmGROW_BALANCED);
  DEFINE_INTEGER(XmMARQUEE);
  DEFINE_INTEGER(XmMARQUEE_EXTEND_START);
  DEFINE_INTEGER(XmMARQUEE_EXTEND_BOTH);
  DEFINE_INTEGER(XmTOUCH_ONLY);
  DEFINE_INTEGER(XmTOUCH_OVER);
  DEFINE_INTEGER(XmSNAP_TO_GRID);
  DEFINE_INTEGER(XmCENTER);
  DEFINE_INTEGER(XmCOLLAPSED);
  DEFINE_INTEGER(XmEXPANDED);
  DEFINE_INTEGER(XmLARGE_ICON);
  DEFINE_INTEGER(XmSMALL_ICON);
  DEFINE_INTEGER(XmSELECTED);
  DEFINE_INTEGER(XmNOT_SELECTED);
  DEFINE_INTEGER(XmSOLID);
  DEFINE_INTEGER(XmSPIRAL);
  DEFINE_INTEGER(XmPIXMAP_OVERLAP_ONLY);
  DEFINE_INTEGER(XmPAGE);
  DEFINE_INTEGER(XmMAJOR_TAB);
  DEFINE_INTEGER(XmMINOR_TAB);
  DEFINE_INTEGER(XmSTATUS_AREA);
  DEFINE_INTEGER(XmPAGE_SCROLLER);
  DEFINE_INTEGER(XmARROWS_VERTICAL);
  DEFINE_INTEGER(XmARROWS_HORIZONTAL);
  DEFINE_INTEGER(XmARROWS_END);
  DEFINE_INTEGER(XmARROWS_BEGINNING);
  DEFINE_INTEGER(XmARROWS_SPLIT);
  DEFINE_INTEGER(XmARROWS_FLAT_END);
  DEFINE_INTEGER(XmARROWS_FLAT_BEGINNING);
  DEFINE_INTEGER(XmARROWS_INSENSITIVE);
  DEFINE_INTEGER(XmARROWS_INCREMENT_SENSITIVE);
  DEFINE_INTEGER(XmARROWS_DECREMENT_SENSITIVE);
  DEFINE_INTEGER(XmARROWS_SENSITIVE);
  DEFINE_INTEGER(XmARROWS_DEFAULT_SENSITIVITY);
  DEFINE_INTEGER(XmPOSITION_INDEX);
  DEFINE_INTEGER(XmPOSITION_VALUE);
  DEFINE_INTEGER(XmNUMERIC);
  DEFINE_INTEGER(XmVALID_VALUE);
  DEFINE_INTEGER(XmCURRENT_VALUE);
  DEFINE_INTEGER(XmMAXIMUM_VALUE);
  DEFINE_INTEGER(XmMINIMUM_VALUE);
  DEFINE_INTEGER(XmINCREMENT_VALUE);
  DEFINE_INTEGER(XmSELECT_OUT_LINE);
  DEFINE_INTEGER(XmSEE_DETAIL);
  DEFINE_INTEGER(XmVARIABLE);
  DEFINE_INTEGER(XmCONSTANT);
  DEFINE_INTEGER(XmRESIZE_IF_POSSIBLE);
  DEFINE_INTEGER(XmAUTOMATIC);
  DEFINE_INTEGER(XmAPPLICATION_DEFINED);
  DEFINE_INTEGER(XmAS_NEEDED);
  DEFINE_INTEGER(XmCOMMAND_ABOVE_WORKSPACE);
  DEFINE_INTEGER(XmCOMMAND_BELOW_WORKSPACE);
  DEFINE_INTEGER(XmMULTI_LINE_EDIT);
  DEFINE_INTEGER(XmSINGLE_LINE_EDIT);
  DEFINE_INTEGER(XmTEXT_FORWARD);
  DEFINE_INTEGER(XmTEXT_BACKWARD);
  DEFINE_INTEGER(XmSELECT_POSITION);
  DEFINE_INTEGER(XmSELECT_WHITESPACE);
  DEFINE_INTEGER(XmSELECT_WORD);
  DEFINE_INTEGER(XmSELECT_LINE);
  DEFINE_INTEGER(XmSELECT_ALL);
  DEFINE_INTEGER(XmSELECT_PARAGRAPH);
  DEFINE_INTEGER(XmHIGHLIGHT_NORMAL);
  DEFINE_INTEGER(XmHIGHLIGHT_SELECTED);
  DEFINE_INTEGER(XmHIGHLIGHT_SECONDARY_SELECTED);
  DEFINE_INTEGER(XmDIALOG_NONE);
  DEFINE_INTEGER(XmDIALOG_APPLY_BUTTON);
  DEFINE_INTEGER(XmDIALOG_CANCEL_BUTTON);
  DEFINE_INTEGER(XmDIALOG_DEFAULT_BUTTON);
  DEFINE_INTEGER(XmDIALOG_OK_BUTTON);
  DEFINE_INTEGER(XmDIALOG_FILTER_LABEL);
  DEFINE_INTEGER(XmDIALOG_FILTER_TEXT);
  DEFINE_INTEGER(XmDIALOG_HELP_BUTTON);
  DEFINE_INTEGER(XmDIALOG_LIST);
  DEFINE_INTEGER(XmDIALOG_LIST_LABEL);
  DEFINE_INTEGER(XmDIALOG_MESSAGE_LABEL);
  DEFINE_INTEGER(XmDIALOG_SELECTION_LABEL);
  DEFINE_INTEGER(XmDIALOG_SYMBOL_LABEL);
  DEFINE_INTEGER(XmDIALOG_TEXT);
  DEFINE_INTEGER(XmDIALOG_SEPARATOR);
  DEFINE_INTEGER(XmDIALOG_DIR_LIST);
  DEFINE_INTEGER(XmDIALOG_DIR_LIST_LABEL);
  DEFINE_INTEGER(XmDIALOG_MODELESS);
  DEFINE_INTEGER(XmDIALOG_PRIMARY_APPLICATION_MODAL);
  DEFINE_INTEGER(XmDIALOG_FULL_APPLICATION_MODAL);
  DEFINE_INTEGER(XmDIALOG_SYSTEM_MODAL);
  DEFINE_INTEGER(XmPLACE_TOP);
  DEFINE_INTEGER(XmPLACE_ABOVE_SELECTION);
  DEFINE_INTEGER(XmPLACE_BELOW_SELECTION);
  DEFINE_INTEGER(XmDIALOG_WORK_AREA);
  DEFINE_INTEGER(XmDIALOG_PROMPT);
  DEFINE_INTEGER(XmDIALOG_SELECTION);
  DEFINE_INTEGER(XmDIALOG_COMMAND);
  DEFINE_INTEGER(XmDIALOG_FILE_SELECTION);
  DEFINE_INTEGER(XmDIALOG_TEMPLATE);
  DEFINE_INTEGER(XmDIALOG_ERROR);
  DEFINE_INTEGER(XmDIALOG_INFORMATION);
  DEFINE_INTEGER(XmDIALOG_MESSAGE);
  DEFINE_INTEGER(XmDIALOG_QUESTION);
  DEFINE_INTEGER(XmDIALOG_WARNING);
  DEFINE_INTEGER(XmDIALOG_WORKING);
  DEFINE_INTEGER(XmVISIBILITY_UNOBSCURED);
  DEFINE_INTEGER(XmVISIBILITY_PARTIALLY_OBSCURED);
  DEFINE_INTEGER(XmVISIBILITY_FULLY_OBSCURED);
  DEFINE_INTEGER(XmTRAVERSE_CURRENT);
  DEFINE_INTEGER(XmTRAVERSE_NEXT);
  DEFINE_INTEGER(XmTRAVERSE_PREV);
  DEFINE_INTEGER(XmTRAVERSE_HOME);
  DEFINE_INTEGER(XmTRAVERSE_NEXT_TAB_GROUP);
  DEFINE_INTEGER(XmTRAVERSE_PREV_TAB_GROUP);
  DEFINE_INTEGER(XmTRAVERSE_UP);
  DEFINE_INTEGER(XmTRAVERSE_DOWN);
  DEFINE_INTEGER(XmTRAVERSE_LEFT);
  DEFINE_INTEGER(XmTRAVERSE_RIGHT);
  DEFINE_INTEGER(XmPUSHBUTTON);
  DEFINE_INTEGER(XmTOGGLEBUTTON);
  DEFINE_INTEGER(XmRADIOBUTTON);
  DEFINE_INTEGER(XmCASCADEBUTTON);
  DEFINE_INTEGER(XmSEPARATOR);
  DEFINE_INTEGER(XmDOUBLE_SEPARATOR);
  DEFINE_INTEGER(XmTITLE);
  DEFINE_INTEGER(XmBOTTOM_RIGHT);
  DEFINE_INTEGER(XmBOTTOM_LEFT);
  DEFINE_INTEGER(XmTOP_RIGHT);
  DEFINE_INTEGER(XmTOP_LEFT);
  DEFINE_INTEGER(XmTRAVERSE_GLOBALLY_FORWARD);
  DEFINE_INTEGER(XmTRAVERSE_GLOBALLY_BACKWARD);
  DEFINE_INTEGER(XmMATCH_DEPTH);
  DEFINE_INTEGER(XmDYNAMIC_DEPTH);
  DEFINE_INTEGER(XmPDM_NOTIFY_FAIL);
  DEFINE_INTEGER(XmPDM_NOTIFY_SUCCESS);
  DEFINE_INTEGER(XmINDICATOR_NONE);
  DEFINE_INTEGER(XmINDICATOR_FILL);
  DEFINE_INTEGER(XmINDICATOR_BOX);
  DEFINE_INTEGER(XmINDICATOR_CHECK);
  DEFINE_INTEGER(XmINDICATOR_CHECK_BOX);
  DEFINE_INTEGER(XmINDICATOR_CROSS);
  DEFINE_INTEGER(XmINDICATOR_CROSS_BOX);
  DEFINE_INTEGER(XmUNSET);
  DEFINE_INTEGER(XmSET);
  DEFINE_INTEGER(XmINDETERMINATE);
  DEFINE_INTEGER(XmTOGGLE_BOOLEAN);
  DEFINE_INTEGER(XmTOGGLE_INDETERMINATE);
  DEFINE_INTEGER(XmPATH_MODE_FULL);
  DEFINE_INTEGER(XmPATH_MODE_RELATIVE);
  DEFINE_INTEGER(XmFILTER_NONE);
  DEFINE_INTEGER(XmFILTER_HIDDEN_FILES);
#if HAVE_XmCreateColorSelector
  DEFINE_INTEGER(XmScaleMode);
  DEFINE_INTEGER(XmListMode);
#endif
#endif
#if HAVE_XM_XP
  DEFINE_INTEGER(XP_DONT_CHECK);
  DEFINE_INTEGER(XP_INITIAL_RELEASE);
  DEFINE_INTEGER(XP_PROTO_MAJOR);
  DEFINE_INTEGER(XP_PROTO_MINOR);
  DEFINE_INTEGER(XP_MAJOR_VERSION);
  DEFINE_INTEGER(XP_MINOR_VERSION);
  DEFINE_INTEGER(XP_ABSENT);
  DEFINE_INTEGER(XP_PRESENT);
  DEFINE_INTEGER(XP_ERRORS);
  DEFINE_INTEGER(XPBadContext);
  DEFINE_INTEGER(XPBadSequence);
  DEFINE_INTEGER(XPBadResourceID);
  DEFINE_INTEGER(XP_EVENTS);
  DEFINE_INTEGER(XPNoEventMask);
  DEFINE_INTEGER(XPPrintMask);
  DEFINE_INTEGER(XPAttributeMask);
  DEFINE_INTEGER(XPPrintNotify);
  DEFINE_INTEGER(XPAttributeNotify);
  DEFINE_INTEGER(XPStartJobNotify);
  DEFINE_INTEGER(XPEndJobNotify);
  DEFINE_INTEGER(XPStartDocNotify);
  DEFINE_INTEGER(XPEndDocNotify);
  DEFINE_INTEGER(XPStartPageNotify);
  DEFINE_INTEGER(XPEndPageNotify);
  DEFINE_INTEGER(XP_ATTRIBUTES);
  DEFINE_INTEGER(XPJobAttr);
  DEFINE_INTEGER(XPDocAttr);
  DEFINE_INTEGER(XPPageAttr);
  DEFINE_INTEGER(XPPrinterAttr);
  DEFINE_INTEGER(XPServerAttr);
  DEFINE_INTEGER(XPMediumAttr);
  DEFINE_INTEGER(XPFontAttr);
  DEFINE_INTEGER(XPResAttr);
  DEFINE_INTEGER(XPTransAttr);
  DEFINE_INTEGER(XPDelAttr);
  DEFINE_INTEGER(XPAuxSPkg);
  DEFINE_INTEGER(XPAuxS);
  DEFINE_INTEGER(XPFinishAttr);
  DEFINE_INTEGER(XPOutputAttr);
  DEFINE_INTEGER(XPImpAttr);
  DEFINE_INTEGER(XPSchedAttr);
  DEFINE_INTEGER(XPIntJobAttr);
  DEFINE_INTEGER(XPIntDocAttr);
  DEFINE_INTEGER(XPResConAttr);
  DEFINE_INTEGER(XPAttrReplace);
  DEFINE_INTEGER(XPAttrMerge);
  DEFINE_INTEGER(XPGetDocFinished);
  DEFINE_INTEGER(XPGetDocSecondConsumer);
  DEFINE_INTEGER(XPGetDocError);
  DEFINE_INTEGER(XPSpool);
  DEFINE_INTEGER(XPGetData);
  DEFINE_INTEGER(XPDocNormal);
  DEFINE_INTEGER(XPDocRaw);
#endif

#if HAVE_XSHAPEQUERYEXTENSION
  DEFINE_INTEGER(ShapeSet);
  DEFINE_INTEGER(ShapeUnion);
  DEFINE_INTEGER(ShapeIntersect);
  DEFINE_INTEGER(ShapeSubtract);
  DEFINE_INTEGER(ShapeInvert);
  DEFINE_INTEGER(ShapeBounding);
  DEFINE_INTEGER(ShapeClip);
#endif

#if HAVE_XmCreateButtonBox
  DEFINE_INTEGER(XmFillNone); 
  DEFINE_INTEGER(XmFillMajor);
  DEFINE_INTEGER(XmFillMinor);
  DEFINE_INTEGER(XmFillAll);
  DEFINE_INTEGER(XmIconTop);
  DEFINE_INTEGER(XmIconLeft);
  DEFINE_INTEGER(XmIconRight);
  DEFINE_INTEGER(XmIconBottom);
  DEFINE_INTEGER(XmIconOnly);
  DEFINE_INTEGER(XmIconNone);
#endif

#if HAVE_XmCreateColumn
  DEFINE_INTEGER(XmDISTRIBUTE_SPREAD);
  DEFINE_INTEGER(XmDISTRIBUTE_TIGHT);
  DEFINE_INTEGER(XmFILL_RAGGED);
  DEFINE_INTEGER(XmFILL_FLUSH);
  DEFINE_INTEGER(XmFILL_UNSPECIFIED);

  /*assume this goes with the others */
  /* DEFINE_INTEGER(XmPIXMAP_AND_STRING); */
#endif

#if HAVE_XmTabStack
  DEFINE_INTEGER(XmTABS_SQUARED);
  DEFINE_INTEGER(XmTABS_ROUNDED);
  DEFINE_INTEGER(XmTABS_BEVELED);
  DEFINE_INTEGER(XmTABS_BASIC);
  DEFINE_INTEGER(XmTABS_STACKED);
  DEFINE_INTEGER(XmTABS_STACKED_STATIC);
  DEFINE_INTEGER(XmTABS_SCROLLED);
  DEFINE_INTEGER(XmTABS_OVERLAYED);
  DEFINE_INTEGER(XmTAB_ORIENTATION_DYNAMIC);
  DEFINE_INTEGER(XmTABS_RIGHT_TO_LEFT);
  DEFINE_INTEGER(XmTABS_LEFT_TO_RIGHT);
  DEFINE_INTEGER(XmTABS_TOP_TO_BOTTOM);
  DEFINE_INTEGER(XmTABS_BOTTOM_TO_TOP);
  DEFINE_INTEGER(XmTAB_EDGE_TOP_LEFT);
  DEFINE_INTEGER(XmTAB_EDGE_BOTTOM_RIGHT);
  DEFINE_INTEGER(XmTAB_ARROWS_ON_RIGHT);
  DEFINE_INTEGER(XmTAB_ARROWS_ON_LEFT);
  DEFINE_INTEGER(XmTAB_ARROWS_SPLIT);
  DEFINE_INTEGER(XmCR_TAB_SELECTED);
  DEFINE_INTEGER(XmCR_TAB_UNSELECTED);
  DEFINE_INTEGER(XmTABS_ON_TOP);
  DEFINE_INTEGER(XmTABS_ON_BOTTOM);
  DEFINE_INTEGER(XmTABS_ON_RIGHT);
  DEFINE_INTEGER(XmTABS_ON_LEFT);
  DEFINE_INTEGER(XmPIXMAP_TOP);
  DEFINE_INTEGER(XmPIXMAP_BOTTOM);
  DEFINE_INTEGER(XmPIXMAP_RIGHT);
  DEFINE_INTEGER(XmPIXMAP_LEFT);
  DEFINE_INTEGER(XmPIXMAP_NONE);
  DEFINE_INTEGER(XmPIXMAP_ONLY);
  DEFINE_INTEGER(XmTAB_VALUE_COPY);
  DEFINE_INTEGER(XmTAB_VALUE_SHARE);
  DEFINE_INTEGER(XmTAB_CMP_VISUAL);
  DEFINE_INTEGER(XmTAB_CMP_SIZE);
  DEFINE_INTEGER(XmTAB_CMP_EQUAL);
#endif

}



/* -------------------------------- pointer constants -------------------------------- */

static void define_pointers(void)
{
#if HAVE_MOTIF

  #define DEFINE_POINTER(Name) XEN_DEFINE(XM_PREFIX #Name XM_POSTFIX, C_TO_XEN_WidgetClass(Name))

  DEFINE_POINTER(compositeWidgetClass);
  DEFINE_POINTER(constraintWidgetClass);
  DEFINE_POINTER(coreWidgetClass);
  DEFINE_POINTER(widgetClass);
  DEFINE_POINTER(objectClass);
  DEFINE_POINTER(rectObjClass);
  DEFINE_POINTER(shellWidgetClass);
  DEFINE_POINTER(overrideShellWidgetClass);
  DEFINE_POINTER(wmShellWidgetClass);
  DEFINE_POINTER(transientShellWidgetClass);
  DEFINE_POINTER(topLevelShellWidgetClass);
  DEFINE_POINTER(applicationShellWidgetClass);
  DEFINE_POINTER(sessionShellWidgetClass);
  DEFINE_POINTER(vendorShellWidgetClass);
  DEFINE_POINTER(xmArrowButtonGadgetClass);
  DEFINE_POINTER(xmArrowButtonWidgetClass);
  DEFINE_POINTER(xmBulletinBoardWidgetClass);
  DEFINE_POINTER(xmCascadeButtonGadgetClass);
  DEFINE_POINTER(xmCascadeButtonWidgetClass);
  DEFINE_POINTER(xmCommandWidgetClass);
  DEFINE_POINTER(xmDialogShellWidgetClass);
  DEFINE_POINTER(xmDragContextClass);
  DEFINE_POINTER(xmDragIconObjectClass);
  DEFINE_POINTER(xmDragOverShellWidgetClass);
  DEFINE_POINTER(xmDrawingAreaWidgetClass);
  DEFINE_POINTER(xmDrawnButtonWidgetClass);
  DEFINE_POINTER(xmDropSiteManagerObjectClass);
  DEFINE_POINTER(xmDropTransferObjectClass);
  DEFINE_POINTER(xmFileSelectionBoxWidgetClass);
  DEFINE_POINTER(xmFormWidgetClass);
  DEFINE_POINTER(xmFrameWidgetClass);
  DEFINE_POINTER(xmGadgetClass);
  DEFINE_POINTER(xmLabelGadgetClass);
  DEFINE_POINTER(xmLabelWidgetClass);
  DEFINE_POINTER(xmListWidgetClass);
  DEFINE_POINTER(xmMainWindowWidgetClass);
  DEFINE_POINTER(xmManagerWidgetClass);
  DEFINE_POINTER(xmMenuShellWidgetClass);
  DEFINE_POINTER(xmMessageBoxWidgetClass);
  DEFINE_POINTER(xmPanedWindowWidgetClass);
  DEFINE_POINTER(xmPrimitiveWidgetClass);
  DEFINE_POINTER(xmPushButtonGadgetClass);
  DEFINE_POINTER(xmPushButtonWidgetClass);
  DEFINE_POINTER(xmRowColumnWidgetClass);
  DEFINE_POINTER(xmScaleWidgetClass);
  DEFINE_POINTER(xmScrollBarWidgetClass);
  DEFINE_POINTER(xmScrolledWindowWidgetClass);
  DEFINE_POINTER(xmSelectionBoxWidgetClass);
  DEFINE_POINTER(xmSeparatorGadgetClass);
  DEFINE_POINTER(xmSeparatorWidgetClass);
  DEFINE_POINTER(xmTextFieldWidgetClass);
  DEFINE_POINTER(xmTextWidgetClass);
  DEFINE_POINTER(xmToggleButtonGadgetClass);
  DEFINE_POINTER(xmToggleButtonWidgetClass);
  DEFINE_POINTER(xmContainerWidgetClass);
  DEFINE_POINTER(xmComboBoxWidgetClass);
  DEFINE_POINTER(xmGrabShellWidgetClass);
  DEFINE_POINTER(xmNotebookWidgetClass);
  DEFINE_POINTER(xmIconGadgetClass);
#if HAVE_XM_XP
  DEFINE_POINTER(xmPrintShellWidgetClass);
#endif
#if HAVE_XmCreateButtonBox
  DEFINE_POINTER(xmButtonBoxWidgetClass);
#endif
#if HAVE_XmCreateDataField
  DEFINE_POINTER(xmDataFieldWidgetClass);
#endif
#if HAVE_XmCreateTabStack
  DEFINE_POINTER(xmTabStackWidgetClass);
#endif

  /*
  DEFINE_POINTER(xmHierarchyWidgetClass);
  */

#if HAVE_XmCreateDropDown
  DEFINE_POINTER(xmDropDownWidgetClass);
#endif
#if HAVE_XmCreateColumn
  DEFINE_POINTER(xmColumnWidgetClass);
#endif
#if HAVE_XmCreateFontSelector
  DEFINE_POINTER(xmFontSelectorWidgetClass);
#endif
#if HAVE_XmCreateColorSelector
  DEFINE_POINTER(xmColorSelectorWidgetClass);
#endif
  DEFINE_POINTER(xmSpinBoxWidgetClass);
  DEFINE_POINTER(xmSimpleSpinBoxWidgetClass);
#endif
}
  
/* -------------------------------- predefined Atoms -------------------------------- */

static void define_Atoms(void)
{
  #define DEFINE_ATOM(Name) XEN_DEFINE(XM_PREFIX #Name XM_POSTFIX, C_TO_XEN_Atom(Name))

  DEFINE_ATOM(XA_PRIMARY);
  DEFINE_ATOM(XA_SECONDARY);
  DEFINE_ATOM(XA_ARC);
  DEFINE_ATOM(XA_ATOM);
  DEFINE_ATOM(XA_BITMAP);
  DEFINE_ATOM(XA_CARDINAL);
  DEFINE_ATOM(XA_COLORMAP);
  DEFINE_ATOM(XA_CURSOR);
  DEFINE_ATOM(XA_CUT_BUFFER0);
  DEFINE_ATOM(XA_CUT_BUFFER1);
  DEFINE_ATOM(XA_CUT_BUFFER2);
  DEFINE_ATOM(XA_CUT_BUFFER3);
  DEFINE_ATOM(XA_CUT_BUFFER4);
  DEFINE_ATOM(XA_CUT_BUFFER5);
  DEFINE_ATOM(XA_CUT_BUFFER6);
  DEFINE_ATOM(XA_CUT_BUFFER7);
  DEFINE_ATOM(XA_DRAWABLE);
  DEFINE_ATOM(XA_FONT);
  DEFINE_ATOM(XA_INTEGER);
  DEFINE_ATOM(XA_PIXMAP);
  DEFINE_ATOM(XA_POINT);
  DEFINE_ATOM(XA_RECTANGLE);
  DEFINE_ATOM(XA_RESOURCE_MANAGER);
  DEFINE_ATOM(XA_RGB_COLOR_MAP);
  DEFINE_ATOM(XA_RGB_BEST_MAP);
  DEFINE_ATOM(XA_RGB_BLUE_MAP);
  DEFINE_ATOM(XA_RGB_DEFAULT_MAP);
  DEFINE_ATOM(XA_RGB_GRAY_MAP);
  DEFINE_ATOM(XA_RGB_GREEN_MAP);
  DEFINE_ATOM(XA_RGB_RED_MAP);
  DEFINE_ATOM(XA_STRING);
  DEFINE_ATOM(XA_VISUALID);
  DEFINE_ATOM(XA_WINDOW);
  DEFINE_ATOM(XA_WM_COMMAND);
  DEFINE_ATOM(XA_WM_HINTS);
  DEFINE_ATOM(XA_WM_CLIENT_MACHINE);
  DEFINE_ATOM(XA_WM_ICON_NAME);
  DEFINE_ATOM(XA_WM_ICON_SIZE);
  DEFINE_ATOM(XA_WM_NAME);
  DEFINE_ATOM(XA_WM_NORMAL_HINTS);
  DEFINE_ATOM(XA_WM_SIZE_HINTS);
  DEFINE_ATOM(XA_WM_ZOOM_HINTS);
  DEFINE_ATOM(XA_MIN_SPACE);
  DEFINE_ATOM(XA_NORM_SPACE);
  DEFINE_ATOM(XA_MAX_SPACE);
  DEFINE_ATOM(XA_END_SPACE);
  DEFINE_ATOM(XA_SUPERSCRIPT_X);
  DEFINE_ATOM(XA_SUPERSCRIPT_Y);
  DEFINE_ATOM(XA_SUBSCRIPT_X);
  DEFINE_ATOM(XA_SUBSCRIPT_Y);
  DEFINE_ATOM(XA_UNDERLINE_POSITION);
  DEFINE_ATOM(XA_UNDERLINE_THICKNESS);
  DEFINE_ATOM(XA_STRIKEOUT_ASCENT);
  DEFINE_ATOM(XA_STRIKEOUT_DESCENT);
  DEFINE_ATOM(XA_ITALIC_ANGLE);
  DEFINE_ATOM(XA_X_HEIGHT);
  DEFINE_ATOM(XA_QUAD_WIDTH);
  DEFINE_ATOM(XA_WEIGHT);
  DEFINE_ATOM(XA_POINT_SIZE);
  DEFINE_ATOM(XA_RESOLUTION);
  DEFINE_ATOM(XA_COPYRIGHT);
  DEFINE_ATOM(XA_NOTICE);
  DEFINE_ATOM(XA_FONT_NAME);
  DEFINE_ATOM(XA_FAMILY_NAME);
  DEFINE_ATOM(XA_FULL_NAME);
  DEFINE_ATOM(XA_CAP_HEIGHT);
  DEFINE_ATOM(XA_WM_CLASS);
  DEFINE_ATOM(XA_WM_TRANSIENT_FOR);
}


/* -------------------------------- initialization -------------------------------- */

static bool xm_already_inited = false;

void Init_libxm(void);
void Init_libxm(void)
{
  /* perhaps nicer here to check the features list for 'xm */
  if (!xm_already_inited)
    {
      define_xm_obj();
#if HAVE_MOTIF  
      define_makes();
      define_strings();
#endif
      define_Atoms();
      define_integers();
      define_pointers();
      define_procedures();
      define_structs();
#if HAVE_MOTIF
#if HAVE_SCHEME
      XEN_EVAL_C_STRING("(define (XmAddWMProtocols s p n) \
                           (XmAddProtocols s (XInternAtom (XtDisplay s) \"WM_PROTOCOLS\" #f) p n))");
      XEN_EVAL_C_STRING("(define (XmRemoveWMProtocols s p n) \
                           (XmRemoveProtocols s (XInternAtom (XtDisplay s) \"WM_PROTOCOLS\" #f) p n))");
      XEN_EVAL_C_STRING("(define (XmAddWMProtocolCallback s p c cl) \
                           (XmAddProtocolCallback s (XInternAtom (XtDisplay s) \"WM_PROTOCOLS\" #f) p c cl))");
      XEN_EVAL_C_STRING("(define (XmRemoveWMProtocolCallback s p c cl) \
                           (XmRemoveProtocolCallback s (XInternAtom (XtDisplay s) \"WM_PROTOCOLS\" #f) p c cl))");
      XEN_EVAL_C_STRING("(define (XmActivateWMProtocol s p) \
                           (XmActivateProtocol s (XInternAtom (XtDisplay s) \"WM_PROTOCOLS\" #f) p))");
      XEN_EVAL_C_STRING("(define (XmDeactivateWMProtocol s p) \
                           (XmDeactivateProtocol s (XInternAtom (XtDisplay s) \"WM_PROTOCOLS\" #f) p))");
      XEN_EVAL_C_STRING("(define (XmSetWMProtocolHooks s p preh prec posth postc) \
                           (XmSetProtocolHooks s (XInternAtom (XtDisplay s) \"WM_PROTOCOLS\" #f) p preh prec posth postc))");
#endif
#if HAVE_RUBY
      XEN_EVAL_C_STRING("def RXmAddWMProtocols(s, p, n) \
                            RXmAddProtocols(s, RXInternAtom(RXtDisplay(s), \"WM_PROTOCOLS\", false), p, n); end");
      XEN_EVAL_C_STRING("def RXmRemoveWMProtocols(s, p, n) \
                            RXmRemoveProtocols(s, RXInternAtom(RXtDisplay(s), \"WM_PROTOCOLS\", false), p, n); end");
      XEN_EVAL_C_STRING("def RXmAddWMProtocolCallback(s, p, c, cl) \
                            RXmAddProtocolCallback(s, RXInternAtom(RXtDisplay(s), \"WM_PROTOCOLS\", false), p, c, cl); end");
      XEN_EVAL_C_STRING("def RXmRemoveWMProtocolCallback(s, p, c, cl) \
                            RXmRemoveProtocolCallback(s, RXInternAtom(RXtDisplay(s), \"WM_PROTOCOLS\", false), p, c, cl); end");
      XEN_EVAL_C_STRING("def RXmActivateWMProtocol(s, p) \
                            RXmActivateProtocol(s, RXInternAtom(RXtDisplay(s), \"WM_PROTOCOLS\", false), p); end");
      XEN_EVAL_C_STRING("def RXmDeactivateWMProtocol(s, p) \
                            RXmDeactivateProtocol(s, RXInternAtom(RXtDisplay(s), \"WM_PROTOCOLS\", false), p); end");
      XEN_EVAL_C_STRING("def RXmSetWMProtocolHooks(s, p, preh, prec, posth, postc) \
                            RXmSetProtocolHooks(s, RXInternAtom(RXtDisplay(s), \"WM_PROTOCOLS\", false), p, preh, prec, posth, postc); end");
#endif
#if HAVE_FORTH
      XEN_EVAL_C_STRING("\
: wm-protocols-intern-atom ( wid -- atom )\n\
  FXtDisplay \"WM_PROTOCOLS\" #f FXInternAtom\n\
;\n\
: FXmAddWMProtocols ( s p n -- x ) { s p n }\n\
  s dup wm-protocols-intern-atom p n FXmAddProtocols\n\
;\n\
: FXmRemoveWMProtocols ( s p n -- x ) { s p n }\n\
  s dup wm-protocols-intern-atom p n FXmRemoveProtocols\n\
;\n\
: FXmAddWMProtocolCallback ( s p c cl -- x ) { s p c cl }\n\
  s dup wm-protocols-intern-atom p c cl FXmAddProtocolCallback\n\
;\n\
: FXmRemoveWMProtocolCallback  ( s p c cl -- x ) { s p c cl }\n\
  s dup wm-protocols-intern-atom p c cl FXmRemoveProtocolCallback\n\
;\n\
: FXmActivateWMProtocol ( s p -- x ) { s p }\n\
  s dup wm-protocols-intern-atom p FXmActivateProtocol\n\
;\n\
: FXmDeactivateWMProtocol ( s p -- x ) { s p }\n\
  s dup wm-protocols-intern-atom p FXmDeactivateProtocol\n\
;\n\
: FXmSetWMProtocolHooks ( s p preh prec posth postc -- x ) { s p preh prec posth postc }\n\
  s dup wm-protocols-intern-atom p preh prec posth postc FXmSetProtocolHooks\n\
;\n");
#endif
      XEN_DEFINE_PROCEDURE(S_add_resource, g_add_resource_w, 2, 0, 0, H_add_resource);
#endif
#if HAVE_XM_XP
      XEN_YES_WE_HAVE("Xp");
#endif
      XEN_YES_WE_HAVE("xm");
      XEN_DEFINE("xm-version", C_TO_XEN_STRING(XM_DATE));
      xm_already_inited = true;
    }
}

#else
void Init_libxm(void);
void Init_libxm(void)
{
}
#endif
/* end HAVE_EXTENSION_LANGUAGE */

