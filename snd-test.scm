;;; Snd tests
;;;
;;;  test 0: constants                          [376]
;;;  test 1: defaults                           [1021]
;;;  test 2: headers                            [1374]
;;;  test 3: variables                          [1688]
;;;  test 4: sndlib                             [2240]
;;;  test 5: simple overall checks              [3979]
;;;  test 6: float-vectors                      [8589]
;;;  test 7: colors                             [8849]
;;;  test 8: clm                                [9338]
;;;  test 9: mix                                [21111]
;;;  test 10: marks                             [22830]
;;;  test 11: dialogs                           [23748]
;;;  test 12: extensions                        [23907]
;;;  test 13: menus, edit lists, hooks, etc     [24144]
;;;  test 14: all together now                  [25451]
;;;  test 15: chan-local vars                   [26255]
;;;  test 16: regularized funcs                 [27917]
;;;  test 17: dialogs and graphics              [31411]
;;;  test 18: save and restore                  [31514]
;;;  test 19: transforms                        [33154]
;;;  test 20: new stuff                         [35203]
;;;  test 21: optimizer                         [36373]
;;;  test 22: with-sound                        [38211]
;;;  test 23: errors                            [40971]
;;;  test 24: s7                                [42369]
;;;  test all done                              [42502]

;;; (set! (hook-functions *load-hook*) (list (lambda (hook) (format *stderr* "loading ~S...~%" (hook 'name)))))

;(set! (*s7* 'gc-stats) #t)
(set! (*s7* 'heap-size) 1024000) ; bigger is slower here
(set! (*s7* 'print-length) 12345)

(when (provided? 'pure-s7)
  (define (make-polar mag ang)
    (if (and (real? mag) (real? ang))
	(complex (* mag (cos ang)) (* mag (sin ang)))
	(error 'wrong-type-arg "make-polar args should be real"))))

(unless (defined? 'most-positive-fixnum)
  (define-constant most-positive-fixnum (*s7* 'most-positive-fixnum))
  (define-constant most-negative-fixnum (*s7* 'most-negative-fixnum)))

(define tests 1)
(define keep-going #f)
(define all-args #f)
(define test-at-random 0)
(define hooked #f)
(define base-length 1000)

(if (<= tests 0) (set! tests 1))

(define (copy-file source dest) (system (string-append "cp " source " " dest)))

(define-expansion (fill-float-vector v body)
  `(let ((len (length ,v)))
     (do ((i 0 (+ i 1)))
	 ((= i len) ,v)
       (float-vector-set! ,v i ,body))))

(define-expansion (outa->fv v body) 
  `(let ((len (length ,v)))
     (set! *output* ,v) 
     (do ((i 0 (+ i 1)))
	 ((= i len) (set! *output* #f) ,v)
       (outa i ,body))))

(if (not (defined? 'snd-test)) (define snd-test -1))
(define full-test (< snd-test 0))
(define total-tests 24)
(if (not (defined? 'with-exit)) (define with-exit (< snd-test 0)))
(define test-number -1)

(define-expansion (snd-display . args)
  `(format *stderr* "~%~A: ~8T;~A" ,(port-line-number) (format #f ,@args)))

(define-expansion (check-edit-tree tree vals name)
  `(check-edit-tree-1 ,tree ,vals ,name ,(port-line-number)))

(define with-big-file #f)
(define big-file-name "/home/bil/zap/sounds/bigger.snd")
(when with-big-file 
  (set! with-big-file (file-exists? big-file-name))
  (if (not with-big-file) (snd-display "no big file")))
(define big-file-framples 0)

(define original-save-dir (or *save-dir* "~/zap/snd"))
(define original-temp-dir (or *temp-dir* "~/zap/tmp"))
(define original-sound-file-extensions (sound-file-extensions))

(unbind-key #\c 4 #t)
;;; clear out old junk!
(if (file-exists? original-save-dir) 
    (system (format #f "rm ~A/snd_*" original-save-dir)))
(if (file-exists? original-temp-dir) 
    (system (format #f "rm ~A/snd_*" original-temp-dir)))
(if (file-exists? "/tmp")
    (begin ; -noinit possibly
      (system "rm /tmp/snd_*")
      (system "rm /tmp/*.snd")))
(if (file-exists? "/var/tmp")
    (begin ; -noinit possibly
      (system "rm /var/tmp/snd_*")
      (system "rm /var/tmp/*.snd")))

(define home-dir (getenv "HOME"))
(define sf-dir "/sf1")

(cond ((file-exists? (string-append home-dir "/cl/oboe.snd")))
      ((file-exists? "/export/home/bil/cl/oboe.snd") (set! home-dir "/export/home/bil"))
      ((file-exists? "/Users/bil/cl/oboe.snd")       (set! home-dir "/Users/bil"))
      ((file-exists? "/users/b/bil/cl/oboe.snd")     (set! home-dir "/users/b/bil"))
      ((file-exists? "/usr/home/bil/cl/oboe.snd")    (set! home-dir "/usr/home/bil")))

(define cwd (string-append (getcwd) "/"))

(define sf-dir1 (string-append home-dir sf-dir "/"))
(unless (file-exists? (string-append sf-dir1 "alaw.wav"))
  (set! sf-dir "/sf")
  (set! sf-dir1 (string-append home-dir sf-dir "/"))
  (unless (file-exists? (string-append sf-dir1 "alaw.wav"))
    (snd-display "can't find sf directory!")
    (set! sf-dir1 #f)))
(set! sf-dir sf-dir1)

(if (not (string=? (getcwd) (string-append home-dir "/cl")))
    (for-each
     (lambda (file)
       (unless (file-exists? file)
	 (format () "copying ~A~%" file)
	 (copy-file (string-append home-dir "/cl/" file) (string-append (getcwd) "/" file))))
     '("4.aiff" "2.snd" "obtest.snd" "oboe.snd" "pistol.snd" "1a.snd" "now.snd" "fyow.snd"
       "storm.snd" "z.snd" "1.snd" "cardinal.snd" "now.snd.scm" "2a.snd" "4a.snd" "zero.snd"
       "loop.scm" "cmn-glyphs.lisp" "bullet.xpm" "mb.snd" "funcs.scm" "trumpet.snd" "1234.snd")))

(for-each mus-sound-preload '("4.aiff" "2.snd" "obtest.snd" "oboe.snd" "pistol.snd" "1a.snd" "now.snd" 
			      "fyow.snd" "storm.snd" "1.snd" "cardinal.snd" "2a.snd"))

;;(setlocale LC_ALL "de_DE")
(set! *with-background-processes* #f)

;; try to get a different random number sequence on each run
(set! (mus-rand-seed) (current-time))

(set! (hook-functions bad-header-hook) ())
(hook-push bad-header-hook (lambda (hook) (set! (hook 'result) #t)))

(define with-motif (provided? 'snd-motif))

(define with-gui (or (provided? 'snd-gtk)
		     (provided? 'snd-motif)))

(if (not with-gui)
    (define y-bounds (dilambda
		      (lambda* (snd chn axis) (list -1.0 1.0))
		      (lambda* (snd-chan axis value) (list -1.0 1.0)))))

(if (not with-gui)
    (define x-bounds (dilambda
		      (lambda* (snd chn axis) (list 0.0 0.1))
		      (lambda* (snd chn axis value) (list 0.0 0.1)))))

(define real-time get-internal-real-time)
(define (hundred n) (round (* 100 n)))
(define times ())
(define-macro (time a) 
  `(let ((start (real-time))) 
     ,a 
     (let ((val (hundred (- (real-time) start))))
       (set! times (cons (list ',a val) times)))))

(define original-prompt *listener-prompt*)
(set! (show-listener) #t)
(set! (window-x) 600)
(set! (window-y) 10)


(define-expansion (fneq a b)
  `(> (magnitude (- ,a ,b)) .001))

(define-expansion (ffneq a b)
  `(> (magnitude (- ,a ,b)) .01))

(define-expansion (fffneq a b) 
  `(> (magnitude (- ,a ,b)) .1))

(define (cneq a b)
  (> (magnitude (- a b)) .001))

(define-constant (feql a b)
  (let-temporarily (((*s7* 'equivalent-float-epsilon) .001))
    (equivalent? a b)))

(define-constant (ffeql a b)
  (let-temporarily (((*s7* 'equivalent-float-epsilon) .1))
    (equivalent? a b)))

(define* (mus-arrays-equal? x y (err .001))
  (let-temporarily (((*s7* 'equivalent-float-epsilon) err))
    (equivalent? x y)))

(define (mus-arrays-equal?1 v0 v1)
  (mus-arrays-equal? v0 v1 .01))

(define (vmus-arrays-equal? v0 v1)
  (mus-arrays-equal? v0 v1 .00002))

(define (within-.01? b) (< (abs (- 1.0 b)) .01))
(define (very-close? a b) (< (abs (- a b)) .01))

(define (clean-up-sound ind)
   (let ((new-file-name (file-name ind)))
     (close-sound ind)
     (if (file-exists? new-file-name)
	 (delete-file new-file-name))))

(define dismiss-all-dialogs
  (let ((+documentation+ "(dismiss-all-dialogs) hides all dialogs"))
    (lambda ()
      (if (or (provided? 'xm)
	      (provided? 'xg))
	  (for-each
	   (lambda (dialog)
	     (if dialog
		 (if (symbol? (car dialog))
		     (if (provided? 'snd-motif)
			 (if ((*motif* 'XtIsManaged) dialog)
			     ((*motif* 'XtUnmanageChild) dialog))
			 (if (provided? 'snd-gtk)
			     ((*gtk* 'gtk_widget_hide) dialog)))
		     (for-each
		      (lambda (d)
			(if (symbol? (car d))
			    (if (provided? 'snd-motif)
				(if ((*motif* 'XtIsManaged) d)
				    ((*motif* 'XtUnmanageChild) d))
				(if (provided? 'snd-gtk)
				    ((*gtk* 'gtk_widget_hide) d)))))
		      dialog))))
	   (dialog-widgets))))))

(define safe-color (make-color 1 0 0))
(define make-color-with-catch 
  (let ((+documentation+ "make-color but catch 'no-such-color"))
    (lambda (c1 c2 c3)
      (catch 'no-such-color
	(lambda () (make-color c1 c2 c3))
	(lambda args safe-color)))))

(define safe-display-edits 
  (let ((+documentation+ "display-edits but catch all errors"))
    (lambda* (snd chn edpos)
      (catch #t
	(lambda () (display-edits snd chn edpos))
	(lambda args (snd-display "display-edits error: ~A" args))))))

(define timings (make-vector (+ total-tests 1) 0))
(define default-srate *clm-srate*)

(snd-display "~A" (snd-version))
(if (not (defined? 'before-test-hook)) (define before-test-hook (make-hook 'n)))
(if (not (defined? 'after-test-hook)) (define after-test-hook (make-hook 'n)))
(set! (hook-functions before-test-hook) ())
(hook-push before-test-hook (lambda (hook)
			      (let ((n (hook 'n)))
				(set! *clm-srate* default-srate)
				(dismiss-all-dialogs)
				(set! *clipping* #f)
				(set! (mus-clipping) #f) ; this cost me a morning of confusion!
				(set! test-number n)
				(if (> (length timings) n)
				    (set! (timings n) (real-time)))
				(snd-display "test ~D" n))))

(define (clear-save-state-files)
  (for-each forget-region (regions))
  (system (format #f "rm -f ~A/snd_*" (or *save-dir* original-save-dir)))
  (if (file-exists? "/var/tmp") 
      (system "rm -f /var/tmp/snd_save_*"))
  (if (file-exists? "/tmp") 
      (system "rm -f /tmp/snd_save_*"))
  (mus-sound-prune))

(set! (hook-functions after-test-hook) ())
(hook-push after-test-hook
	   (lambda (hook)
	     (let ((n (hook 'n)))
	       (clear-save-state-files)
	       (clear-listener)
	       (set! *ask-about-unsaved-edits* #f)
	       (when (pair? (sounds))
		 (snd-display "end test ~D: open sounds: ~A" n (map short-file-name (sounds)))
		 (for-each close-sound (sounds)))
	       (if (number? (vector-ref timings n))
		   (set! (timings n) (hundred (- (real-time) (vector-ref timings n))))))))

(define overall-start-time (real-time))
(snd-display "~A~%" (strftime "%d-%b %H:%M %Z" (localtime (current-time))))

(define (log-mem tst) 
  (if (> tests 1) (snd-display "test ~D:~D " test-number (+ 1 tst))))

(define-macro (without-errors . func)
  `(catch #t ; but this also squelches syntax errors!
     (lambda ()
       ,@func)
     (lambda args 
       (car args))))

(require snd-hooks.scm snd-ws.scm)

(define* (scale-sound-by scl beg dur snd chn edpos)
  (if (integer? chn)
      (scale-channel scl beg dur snd chn edpos)
      (do ((i 0 (+ i 1)))
	  ((= i (channels snd)))
	(scale-channel scl beg dur snd i))))

(define* (scale-sound-to norm beg dur snd chn)
  (if (integer? chn)
      (let ((mx (maxamp snd chn)))
	(if (not (or (= mx 0.0)
		     (= mx norm)))
	    (scale-channel (/ norm mx) beg dur snd chn)))
      (let ((mx (apply max (maxamp snd #t))))
	(if (not (or (= mx 0.0)
		     (= mx norm)))
	    (do ((nmx (/ norm mx))
		 (i 0 (+ i 1)))
		((= i (channels snd)))
	      (scale-channel nmx beg dur snd i))))))

(define (file->floats file) (samples 0 (framples file) file))

(define* (floats->file v file (srate 22050) (comment ""))
  (if (float-vector? v)
      (begin
	(array->file file v (length v) srate 1)
	file)
      (error 'wrong-type-arg "file->floats: ~A" v)))


(when (and (> (length (script-args)) 0)
	   (> (script-arg) 0))
  (let ((arg (script-arg))
	(args (script-args)))
    (if (not (string=? (args (- arg 1)) "-l")) 
	(snd-display "script-args[~A]: ~A (~A)?" (- arg 1) (args (- arg 1)) args))
    (if (not (string=? (args arg) "snd-test")) 
	(snd-display "script-args[~A]: ~A (~A)?" arg (args arg) args))
    (when (> (length args) (+ 1 arg))
      ;; test-number tests
      (set! snd-test (string->number (args (+ 1 arg))))
      (set! test-at-random 0)
      (set! full-test (< snd-test 0))
      (set! with-exit #t)
      (set! (script-arg) (+ 1 arg))
      (when (> (length (script-args)) (+ arg 2))
	(set! tests (string->number (args (+ arg 2))))
	(set! (script-arg) (+ arg 2))))))

(if (and (provided? 'snd-motif)
	 (provided? 'xm))
    (require snd-snd-motif.scm)
    (if (and (provided? 'snd-gtk)
	     (provided? 'xg))
	(require snd-snd-gtk.scm)))


(define default-file-buffer-size *clm-file-buffer-size*)
					;(set! *clm-file-buffer-size* default-file-buffer-size)

;;; ---------------- test 0: constants ----------------

(define (snd_test_0)
  (if (or (pair? (sounds))
	  (pair? (mixes))
	  (pair? (marks))
	  (pair? (regions)))
      (snd-display "start up: ~A ~A ~A ~A" (sounds) (mixes) (marks) (regions)))
  (do ((lst '(bartlett-hann-window 21
	      bartlett-window 4 
	      blackman10-window 29
	      blackman2-window 6 
	      blackman3-window 7 
	      blackman4-window 8
	      blackman5-window 24
	      blackman6-window 25
	      blackman7-window 26
	      blackman8-window 27
	      blackman9-window 28
	      bohman-window 22
	      cauchy-window 12 
	      channels-combined 1 
	      channels-separate 0 
	      channels-superimposed 2
	      connes-window 18
	      copy-context 0
	      cursor-context 3
	      cursor-cross 0
	      cursor-in-middle 3
	      cursor-in-view 0 
	      cursor-line 1
	      cursor-on-left 1 
	      cursor-on-right 2 
	      dolph-chebyshev-window 16
	      dont-normalize 0
	      dpss-window 35
	      enved-add-point 0
	      enved-amplitude 0 
	      enved-delete-point 1
	      enved-move-point 2
	      enved-spectrum 1
	      enved-srate 2 
	      envelope-exponential 1
	      envelope-linear 0
	      exponential-window 9 
	      flat-top-window 23
	      gaussian-window 14 
	      graph-as-sonogram 1
	      graph-as-spectrogram 2 
	      graph-as-wavogram 3
	      graph-dots 1
	      graph-dots-and-lines 3 
	      graph-filled 2 
	      graph-lines 0 
	      graph-lollipops 4
	      graph-once 0
	      graph-once 0 
	      hamming-window 5
	      hann-poisson-window 17
	      hann-window 1
	      kaiser-window 11 
	      keyboard-no-action 4
	      lisp-graph 2
	      mark-context 4
	      mlt-sine-window 33
	      normalize-by-channel 1
	      normalize-by-sound 2
	      normalize-globally 3
	      papoulis-window 34
	      parzen-window 3
	      poisson-window 13
	      rectangular-window 0 
	      riemann-window 10 
	      rv2-window 30
	      rv3-window 31
	      rv4-window 32
	      samaraki-window 19
	      selection-context 2
	      show-all-axes 1
	      show-all-axes-unlabelled 3
	      show-bare-x-axis 5
	      show-no-axes 0
	      show-x-axis 2
	      show-x-axis-unlabelled 4
	      sinc-window 36
	      speed-control-as-float 0 
	      speed-control-as-ratio 1 
	      speed-control-as-semitone 2 
	      sync-all 1
	      sync-by-sound 2
	      sync-none 0
	      time-graph 0
	      transform-graph 1
	      tukey-window 15 
	      ultraspherical-window 20
	      welch-window 2 
	      x-axis-as-clock 5
	      x-axis-as-percentage 2
	      x-axis-in-beats 3
	      x-axis-in-measures 4
	      x-axis-in-samples 1 
	      x-axis-in-seconds 0 
	      zoom-focus-active 2
	      zoom-focus-left 0
	      zoom-focus-middle 3
	      zoom-focus-right 1 
		  
	      ;; sndlib constants
	      mus-aifc 2
	      mus-aiff 49
	      mus-bicsf 5
	      mus-caff 60
	      mus-ircam 15
	      mus-next 1
	      mus-nist 6
	      mus-raw 12
	      mus-rf64 4
	      mus-riff 3
	      mus-soundfont 26
	      mus-svx 9
	      mus-unknown-header 0
	      mus-voc 10
		  
	      mus-interp-all-pass 3
	      mus-interp-bezier 5
	      mus-interp-hermite 6
	      mus-interp-lagrange 4
	      mus-interp-linear 1
	      mus-interp-none 0
	      mus-interp-sinusoidal 2
		  
	      mus-chebyshev-first-kind 1
	      mus-chebyshev-second-kind 2
		  
	      mus-alaw 6
	      mus-b24int 8
	      mus-bdouble 9
	      mus-bdouble-unscaled 21
	      mus-bfloat 4
	      mus-bfloat-unscaled 19
	      mus-bint 5
	      mus-bintn 17
	      mus-bshort 1
	      mus-byte 3
	      mus-l24int 16
	      mus-ldouble 13
	      mus-ldouble-unscaled 22
	      mus-lfloat 12
	      mus-lfloat-unscaled 20
	      mus-lint 11
	      mus-lintn 18
	      mus-lshort 10
	      mus-mulaw 2
	      mus-ubshort 14
	      mus-ubyte 7
	      mus-ulshort 15
	      mus-unknown-sample 0)
	    (cddr lst)))
      ((null? lst))
    (if (not (= (symbol->value (car lst)) (cadr lst)))
	(snd-display "~A is not ~A (~A)~%" (car lst) (cadr lst) (symbol->value (car lst)))))
  
  (if (not (equal? *region-graph-style* graph-lines))
      (snd-display "region-graph-style set default: ~A" *region-graph-style*))
  (if *ask-about-unsaved-edits*
      (snd-display "ask-about-unsaved-edits set default: ~A" *ask-about-unsaved-edits*))
  (if (not (boolean? *show-full-duration*))
      (snd-display "show-full-duration set default: ~A" *show-full-duration*))
  (if *show-full-range*
      (snd-display "show-full-range set default: ~A" *show-full-range*))
  (if (fneq *initial-beg* 0.0)
      (snd-display "initial-beg set default: ~A" *initial-beg*))
  (if (fneq *initial-dur* 0.1)
      (snd-display "initial-dur set default: ~A" *initial-dur*))
  (if *ask-before-overwrite*
      (snd-display "ask-before-overwrite set default: ~A" *ask-before-overwrite*))
  (if (not *auto-resize*)
      (snd-display "auto-resize set default: ~A" *auto-resize*))
  (if *auto-update*
      (snd-display "auto-update set default: ~A" *auto-update*))
  (if (not (eqv? *channel-style* 1)) 
      (snd-display "channel-style set default: ~A" *channel-style*))
  (if (and (fneq *color-cutoff* 0.003) (fneq *color-cutoff* 0.001))
      (snd-display "color-cutoff set default: ~A" *color-cutoff*))
  (if (not *color-inverted*)
      (snd-display "color-inverted set default: ~A" *color-inverted*))
  (if (fneq *color-scale* 1.0)
      (snd-display "color-scale set default: ~A" *color-scale*))
  (if (fneq *auto-update-interval* 60.0)
      (snd-display "auto-update-interval set default: ~A" *auto-update-interval*))
  (if (fneq *cursor-update-interval* 0.05)
      (snd-display "cursor-update-interval set default: ~A" *cursor-update-interval*))
  (if (not (= *cursor-location-offset* 0))
      (snd-display "cursor-location-offset set default: ~A" *cursor-location-offset*))
  (if (not *dac-combines-channels*)
      (snd-display "dac-combines-channels set default: ~A" *dac-combines-channels*))
  (if (not (eqv? *dac-size* 256)) 
      (snd-display "dac-size set default: ~A" *dac-size*))
  (if *clipping*
      (snd-display "clipping set default: ~A" *clipping*))
  (if (not (eqv? *default-output-chans* 1)) 
      (snd-display "default-output-chans set default: ~A" *default-output-chans*))
  (if (not (or (equal? *default-output-sample-type* mus-bdouble)
	       (equal? *default-output-sample-type* mus-ldouble)))
      (snd-display "default-output-sample-type set default: ~A" *default-output-sample-type*))
  (if (not (eqv? *default-output-srate* 44100)) 
      (snd-display "default-output-srate set default: ~A" *default-output-srate*))
  (if (not (equal? *default-output-header-type* mus-next)) 
      (snd-display "default-output-header-type set default: ~A" *default-output-header-type*))
  (if (not (eqv? *dot-size* 1)) 
      (snd-display "dot-size set default: ~A" *dot-size*))
  (if (not (eqv? *cursor-size* 15)) 
      (snd-display "cursor-size set default: ~A" *cursor-size*))
  (if (not (equal? *cursor-style* cursor-cross)) 
      (snd-display "cursor-style set default: ~A" *cursor-style*))
  (if (not (equal? *tracking-cursor-style* cursor-line)) 
      (snd-display "tracking-cursor-style set default: ~A" *tracking-cursor-style*))
  (if (fneq *enved-base* 1.0)
      (snd-display "enved-base set default: ~A" *enved-base*))
  (if (not (enved-clip?))
      (snd-display "enved-clip? set default: ~A" (enved-clip?)))
  (if (not (enved-filter))
      (snd-display "enved-filter set default: ~A" (enved-filter)))
  (if (not (eqv? *enved-filter-order* 40)) 
      (snd-display "enved-filter-order set default: ~A" *enved-filter-order*))
  (if (enved-in-dB)
      (snd-display "enved-in-dB set default: ~A" (enved-in-dB)))
  (if (not (equal? *enved-style* envelope-linear)) 
      (snd-display "enved-style set default: ~A" *enved-style*))
  (if (fneq *enved-power* 3.0)
      (snd-display "enved-power set default: ~A" *enved-power*))
  (if (not (eqv? *enved-target* 0)) 
      (snd-display "enved-target set default: ~A" *enved-target*))
  (if *enved-wave?*
      (snd-display "enved-wave? set default: ~A" *enved-wave?*))
  (if (and with-gui
	   (pair? (enved-envelope)))
      (snd-display "enved-envelope set default: ~A" (enved-envelope)))
  (if (not (equal? *eps-file* "snd.eps")) 
      (snd-display "eps-file set default: ~A" *eps-file*))
  (if (fneq *eps-bottom-margin* 0.0)
      (snd-display "eps-bottom-margin set default: ~A" *eps-bottom-margin*))
  (if (fneq *eps-left-margin* 0.0)
      (snd-display "eps-left-margin set default: ~A" *eps-left-margin*))
  (if (fneq *eps-size* 1.0)
      (snd-display "eps-size set default: ~A" *eps-size*))
  (if (fneq *fft-window-alpha* 0.0)
      (snd-display "fft-window-alpha set default: ~A" *fft-window-alpha*))
  (if (fneq *fft-window-beta* 0.0)
      (snd-display "fft-window-beta set default: ~A" *fft-window-beta*))
  (if *fft-log-frequency*
      (snd-display "fft-log-frequency set default: ~A" *fft-log-frequency*))
  (if *fft-log-magnitude*
      (snd-display "fft-log-magnitude set default: ~A" *fft-log-magnitude*))
  (if *fft-with-phases*
      (snd-display "fft-with-phases set default: ~A" *fft-with-phases*))
  (if (not (memv *transform-size* '(1024 4096)))
      (snd-display "transform-size set default: ~A" *transform-size*))
  (if (not (equal? *transform-graph-type* graph-once))
      (snd-display "transform-graph-type set default: ~A" *transform-graph-type*))
  (if (not (eqv? *fft-window* 6)) 
      (snd-display "fft-window set default: ~A" *fft-window*))
  (if (not (eqv? *graph-cursor* 34)) 
      (snd-display "graph-cursor set default: ~A" *graph-cursor*))
  (if (not (equal? *graph-style* graph-lines)) 
      (snd-display "graph-style set default: ~A" *graph-style*))
  (if (not *graphs-horizontal*)
      (snd-display "graphs-horizontal set default: ~A" *graphs-horizontal*))
  (if (not (equal? *html-dir* ".")) 
      (snd-display "html-dir set default: ~A" *html-dir*))
  (if (not (equal? *html-program* "firefox")) 
      (snd-display "html-program set default: ~A" *html-program*))
  (if (not *just-sounds*) 
      (snd-display "just-sounds set default: ~A" *just-sounds*))
  (if (not (string? *listener-prompt*)) 
      (snd-display "listener-prompt set default: ~A" *listener-prompt*))
  (if (not (string? *stdin-prompt*)) 
      (snd-display "stdin-prompt set default: ~A" *stdin-prompt*))
  (unless (eqv? *max-transform-peaks* 100)
    (snd-display "max-transform-peaks set default: ~A" *max-transform-peaks*))
  (if (not (eqv? *max-regions* 16)) 
      (snd-display "max-regions set default: ~A" *max-regions*))
  (if (fneq *min-dB* -60.0)
      (snd-display "min-dB set default: ~A" *min-dB*))
  (if (fneq *log-freq-start* 32.0)
      (snd-display "log-freq-start set default: ~A" *log-freq-start*))
  (if (not *selection-creates-region*) 
      (snd-display "selection-creates-region set default: ~A" *selection-creates-region*))
  (if (not (equal? *transform-normalization* normalize-by-channel)) 
      (snd-display "transform-normalization set default: ~A" *transform-normalization*))
  
  (if (and with-motif 
	   (not (eqv? (view-files-sort) 0))) 
      (snd-display "view-files-sort set default: ~A" (view-files-sort)))
  
  (if (not (memv *print-length* '(12 32)))
      (snd-display "print-length set default: ~A" *print-length*))
  (if (not (eqv? *play-arrow-size* 10)) 
      (snd-display "play-arrow-size set default: ~A" *play-arrow-size*))
  (if (not (equal? *save-state-file* "saved-snd.scm")) 
      (snd-display "save-state-file set default: ~A" *save-state-file*))
  (if (not (eqv? *show-axes* 1)) 
      (snd-display "show-axes set default: ~A" *show-axes*))
  (if (not (boolean? *show-transform-peaks*)) 
      (snd-display "show-transform-peaks set default: ~A" *show-transform-peaks*))
  (if (not (boolean? *show-indices*)) 
      (snd-display "show-indices set default: ~A" *show-indices*))
  (if (not *show-marks*)
      (snd-display "show-marks set default: ~A" *show-marks*))
  (if (not *show-mix-waveforms*) 
      (snd-display "show-mix-waveforms set default: ~A" *show-mix-waveforms*))
  (if *show-selection-transform*
      (snd-display "show-selection-transform set default: ~A" *show-selection-transform*))
  (if *show-y-zero*
      (snd-display "show-y-zero set default: ~A" *show-y-zero*))
  (if *show-grid*
      (snd-display "show-grid set default: ~A" *show-grid*))
  (if (fneq *grid-density* 1.0)
      (snd-display "grid-density set default: ~A" *grid-density*))
  (if *show-sonogram-cursor* 
      (snd-display "show-sonogram-cursor set default: ~A" *show-sonogram-cursor*))
  (if (not (eqv? *sinc-width* 10)) 
      (snd-display "sinc-width set default: ~A" *sinc-width*))
  (if (fneq *spectrum-end* 1.0)
      (snd-display "spectrum-end set default: ~A" *spectrum-end*))
  (if (not (eqv? *spectro-hop* 4)) 
      (snd-display "spectro-hop set default: ~A" *spectro-hop*))
  (if (fneq *spectrum-start* 0.0)
      (snd-display "spectrum-start set default: ~A" *spectrum-start*))
  (if (fneq *spectro-x-angle* (if (provided? 'gl) 300.0 90.0))
      (snd-display "spectro-x-angle set default: ~A" *spectro-x-angle*))
  (if (fneq *spectro-x-scale* (if (provided? 'gl) 1.5 1.0))
      (snd-display "spectro-x-scale set default: ~A" *spectro-x-scale*))
  (if (fneq *spectro-y-angle* (if (provided? 'gl) 320.0 0.0))
      (snd-display "spectro-y-angle set default: ~A" *spectro-y-angle*))
  (if (fneq *spectro-y-scale* 1.0)
      (snd-display "spectro-y-scale set default: ~A" *spectro-y-scale*))
  (if (fneq *spectro-z-angle* (if (provided? 'gl) 0.0 358.0))
      (snd-display "spectro-z-angle set default: ~A" *spectro-z-angle*))
  (if (fneq *spectro-z-scale* (if (provided? 'gl) 1.0 0.1))
      (snd-display "spectro-z-scale set default: ~A" *spectro-z-scale*))
  (if (and *temp-dir* (not (equal? *temp-dir* "/home/bil/zap/tmp")))
      (snd-display "temp-dir set default: ~A" *temp-dir*))
  (if (not (equal? *ladspa-dir* "")) 
      (snd-display "ladspa-dir set default: ~A" *ladspa-dir*))
  (if (and *peak-env-dir* (not (equal? *peak-env-dir* "/home/bil/peaks")))
      (snd-display "peak-env-dir set default: ~A" *peak-env-dir*))
  (if (not (member *tiny-font* '("6x12" "Sans 8")))
      (snd-display "tiny-font set default: ~A" *tiny-font*))
  (if (not (equal? *transform-type* fourier-transform)) 
      (snd-display "transform-type set default: ~A" *transform-type*))
  (if (not (eq? *with-file-monitor* #t)) 
      (snd-display "with-file-monitor set default: ~A" *with-file-monitor*))
  (if (not (eqv? *clm-table-size* 512)) 
      (snd-display "clm-table-size set default: ~A" *clm-table-size*))
  (if (not (boolean? *with-verbose-cursor*)) 
      (snd-display "with-verbose-cursor set default: ~A" *with-verbose-cursor*))
  (if (not (boolean? *with-inset-graph*))
      (snd-display "with-inset-graph set default: ~A" *with-inset-graph*))
  (if (not *with-interrupts*)
      (snd-display "with-interrupts set default: ~A" *with-interrupts*))
  (if *remember-sound-state*
      (snd-display "remember-sound-state set default: ~A" *remember-sound-state*))
  (if *with-smpte-label*
      (snd-display "with-smpte-label set default: ~A" *with-smpte-label*))
  (if (not (eq? *with-toolbar* (provided? 'snd-gtk)))
      (snd-display "with-toolbar set default: ~A" *with-toolbar*))
  (if (not *with-tooltips*)
      (snd-display "with-tooltips set default: ~A" *with-tooltips*))
  (if (not (boolean? *with-menu-icons*))
      (snd-display "with-menu-icons set default: ~A" *with-menu-icons*))
  (if *save-as-dialog-src*
      (snd-display "save-as-dialog-src set default: ~A" *save-as-dialog-src*))
  (if *save-as-dialog-auto-comment*
      (snd-display "save-as-dialog-auto-comment set default: ~A" *save-as-dialog-auto-comment*))
  (if (not (boolean? *with-pointer-focus*)) 
      (snd-display "with-pointer-focus set default: ~A" *with-pointer-focus*))
  (if (not (eqv? *wavelet-type* 0)) 
      (snd-display "wavelet-type set default: ~A" *wavelet-type*))
  (if (not (equal? *time-graph-type* graph-once)) 
      (snd-display "time-graph-type set default: ~A" *time-graph-type*))
  (if (not (eqv? *wavo-hop* 3)) 
      (snd-display "wavo-hop set default: ~A" *wavo-hop*))
  (if (not (eqv? *wavo-trace* 64)) 
      (snd-display "wavo-trace set default: ~A" *wavo-trace*))
  (if (not (eqv? *x-axis-style* 0)) 
      (snd-display "x-axis-style set default: ~A" *x-axis-style*))
  (if (fneq *beats-per-minute* 60.0)
      (snd-display "beats-per-minute set default: ~A" *beats-per-minute*))
  (if (not (= *beats-per-measure* 4))
      (snd-display "beats-per-measure set default: ~A" *beats-per-measure*))
  (if (not (eqv? *zero-pad* 0)) 
      (snd-display "zero-pad set default: ~A" *zero-pad*))
  (if (not (null? (zero-pad #t #t)))
      (snd-display "zero-pad #t: ~A" (zero-pad #t #t)))
  (if (not (eqv? *zoom-focus-style* 2)) 
      (snd-display "zoom-focus-style set default: ~A" *zoom-focus-style*))
  (if (not (equal? *sync-style* sync-by-sound)) 
      (snd-display "sync-style set default: ~A" *sync-style*))    
  (if (not (eqv? *mix-waveform-height* 20)) 
      (snd-display "mix-waveform-height set default: ~A" *mix-waveform-height*))
  (if (not (eqv? *mix-tag-width* 6)) 
      (snd-display "mix-tag-width set default: ~A" *mix-tag-width*))
  (if (not (eqv? *mix-tag-height* 14)) 
      (snd-display "mix-tag-height set default: ~A" *mix-tag-height*))
  (if (not (eqv? *mark-tag-width* 10)) 
      (snd-display "mark-tag-width set default: ~A" *mark-tag-width*))
  (if (not (eqv? *mark-tag-height* 4)) 
      (snd-display "mark-tag-height set default: ~A" *mark-tag-height*))
  
  (if (not (equal? *region-graph-style* graph-lines))
      (snd-display "* region-graph-style set default: ~A" *region-graph-style*))
  (if *ask-about-unsaved-edits*
      (snd-display "* ask-about-unsaved-edits set default: ~A" *ask-about-unsaved-edits*))
  (if *show-full-range*
      (snd-display "* show-full-range set default: ~A" *show-full-range*))
  (if (fneq *initial-beg* 0.0)
      (snd-display "* initial-beg set default: ~A" *initial-beg*))
  (if (fneq *initial-dur* 0.1)
      (snd-display "* initial-dur set default: ~A" *initial-dur*))
  (if *ask-before-overwrite*
      (snd-display "* ask-before-overwrite set default: ~A" *ask-before-overwrite*))
  (if (not *auto-resize*) 
      (snd-display "* auto-resize set default: ~A" *auto-resize*))
  (if *auto-update*
      (snd-display "* auto-update set default: ~A" *auto-update*))
  (if (not (eqv? *channel-style* 1)) 
      (snd-display "* channel-style set default: ~A" *channel-style*))
  (if (and (fneq *color-cutoff* 0.003) (fneq *color-cutoff* 0.001))
      (snd-display "* color-cutoff set default: ~A" *color-cutoff*))
  (if (not (eq? *color-inverted* #t)) 
      (snd-display "* color-inverted set default: ~A" *color-inverted*))
  (if (fneq *color-scale* 1.0)
      (snd-display "* color-scale set default: ~A" *color-scale*))
  (if (fneq *auto-update-interval* 60.0)
      (snd-display "* auto-update-interval set default: ~A" *auto-update-interval*))
  (if (fneq *cursor-update-interval* 0.05)
      (snd-display "* cursor-update-interval set default: ~A" *cursor-update-interval*))
  (if (not (= *cursor-location-offset* 0))
      (snd-display "* cursor-location-offset set default: ~A" *cursor-location-offset*))
  (if (not (eq? *dac-combines-channels* #t)) 
      (snd-display "* dac-combines-channels set default: ~A" *dac-combines-channels*))
  (if (not (eqv? *dac-size* 256)) 
      (snd-display "* dac-size set default: ~A" *dac-size*))
  (if *clipping*
      (snd-display "* clipping set default: ~A" *clipping*))
  (if (not (eqv? *default-output-chans* 1)) 
      (snd-display "* default-output-chans set default: ~A" *default-output-chans*))
  (if (not (or (equal? *default-output-sample-type* mus-bdouble)
	       (equal? *default-output-sample-type* mus-ldouble)))
      (snd-display "* default-output-sample-type set default: ~A" *default-output-sample-type*))
  (if (not (eqv? *default-output-srate* 44100)) 
      (snd-display "* default-output-srate set default: ~A" *default-output-srate*))
  (if (not (equal? *default-output-header-type* mus-next)) 
      (snd-display "* default-output-header-type set default: ~A" *default-output-header-type*))
  (if (not (eqv? *dot-size* 1)) 
      (snd-display "* dot-size set default: ~A" *dot-size*))
  (if (not (eqv? *cursor-size* 15)) 
      (snd-display "* cursor-size set default: ~A" *cursor-size*))
  (if (not (equal? *cursor-style* cursor-cross)) 
      (snd-display "* cursor-style set default: ~A" *cursor-style*))
  (if (not (equal? *tracking-cursor-style* cursor-line)) 
      (snd-display "* tracking-cursor-style set default: ~A" *tracking-cursor-style*))
  (if (fneq *enved-base* 1.0)
      (snd-display "* enved-base set default: ~A" *enved-base*))
  (if (not (eqv? *enved-filter-order* 40)) 
      (snd-display "* enved-filter-order set default: ~A" *enved-filter-order*))
  (if (not (equal? *enved-style* envelope-linear)) 
      (snd-display "* enved-style set default: ~A" *enved-style*))
  (if (fneq *enved-power* 3.0)
      (snd-display "* enved-power set default: ~A" *enved-power*))
  (if (not (eqv? *enved-target* 0)) 
      (snd-display "* enved-target set default: ~A" *enved-target*))
  (if *enved-wave?*
      (snd-display "* enved-wave? set default: ~A" *enved-wave?*))
  (if (not (equal? *eps-file* "snd.eps")) 
      (snd-display "* eps-file set default: ~A" *eps-file*))
  (if (fneq *eps-bottom-margin* 0.0)
      (snd-display "* eps-bottom-margin set default: ~A" *eps-bottom-margin*))
  (if (fneq *eps-left-margin* 0.0)
      (snd-display "* eps-left-margin set default: ~A" *eps-left-margin*))
  (if (fneq *eps-size* 1.0)
      (snd-display "* eps-size set default: ~A" *eps-size*))
  (if (fneq *fft-window-alpha* 0.0)
      (snd-display "* fft-window-alpha set default: ~A" *fft-window-alpha*))
  (if (fneq *fft-window-beta* 0.0)
      (snd-display "* fft-window-beta set default: ~A" *fft-window-beta*))
  (if *fft-log-frequency*
      (snd-display "* fft-log-frequency set default: ~A" *fft-log-frequency*))
  (if *fft-log-magnitude*
      (snd-display "* fft-log-magnitude set default: ~A" *fft-log-magnitude*))
  (if *fft-with-phases*
      (snd-display "* fft-with-phases set default: ~A" *fft-with-phases*))
  (if (not (memv *transform-size* '(1024 4096)))
      (snd-display "* transform-size set default: ~A" *transform-size*))
  (if (not (equal? *transform-graph-type* graph-once))
      (snd-display "* transform-graph-type set default: ~A" *transform-graph-type*))
  (if (not (eqv? *fft-window* 6)) 
      (snd-display "* fft-window set default: ~A" *fft-window*))
  (if (not (eqv? *graph-cursor* 34)) 
      (snd-display "* graph-cursor set default: ~A" *graph-cursor*))
  (if (not (equal? *graph-style* graph-lines)) 
      (snd-display "* graph-style set default: ~A" *graph-style*))
  (if (not *graphs-horizontal*) 
      (snd-display "* graphs-horizontal set default: ~A" *graphs-horizontal*))
  (if (not (equal? *html-dir* ".")) 
      (snd-display "* html-dir set default: ~A" *html-dir*))
  (if (not (equal? *html-program* "firefox")) 
      (snd-display "* html-program set default: ~A" *html-program*))
  (if (not *just-sounds*) 
      (snd-display "* just-sounds set default: ~A" *just-sounds*))
  (if (not (eqv? *max-transform-peaks* 100)) 
      (snd-display "* max-transform-peaks set default: ~A" *max-transform-peaks*))
  (if (not (eqv? *max-regions* 16)) 
      (snd-display "* max-regions set default: ~A" *max-regions*))
  (if (fneq *min-dB* -60.0)
      (snd-display "* min-dB set default: ~A" *min-dB*))
  (if (fneq *log-freq-start* 32.0)
      (snd-display "* log-freq-start set default: ~A" *log-freq-start*))
  (if (not (eq? *selection-creates-region* #t)) 
      (snd-display "* selection-creates-region set default: ~A" *selection-creates-region*))
  (if (not (equal? *transform-normalization* normalize-by-channel)) 
      (snd-display "* transform-normalization set default: ~A" *transform-normalization*))
  
  (if (and with-motif 
	   (not (eqv? *view-files-sort* 0)))
      (snd-display "* view-files-sort set default: ~A" *view-files-sort*))
  
  (if (not (eqv? *play-arrow-size* 10)) 
      (snd-display "* play-arrow-size set default: ~A" *play-arrow-size*))
  (if (not (equal? *save-state-file* "saved-snd.scm")) 
      (snd-display "* save-state-file set default: ~A" *save-state-file*))
  (if (not (eqv? *show-axes* 1)) 
      (snd-display "* show-axes set default: ~A" *show-axes*))
  (if (not *show-marks*) 
      (snd-display "* show-marks set default: ~A" *show-marks*))
  (if (not *show-mix-waveforms*) 
      (snd-display "* show-mix-waveforms set default: ~A" *show-mix-waveforms*))
  (if *show-selection-transform*
      (snd-display "* show-selection-transform set default: ~A" *show-selection-transform*))
  (if *show-y-zero*
      (snd-display "* show-y-zero set default: ~A" *show-y-zero*))
  (if *show-grid*
      (snd-display "* show-grid set default: ~A" *show-grid*))
  (if (fneq *grid-density* 1.0)
      (snd-display "* grid-density set default: ~A" *grid-density*))
  (if *show-sonogram-cursor*
      (snd-display "* show-sonogram-cursor set default: ~A" *show-sonogram-cursor*))
  (if (not (eqv? *sinc-width* 10)) 
      (snd-display "* sinc-width set default: ~A" *sinc-width*))
  (if (fneq *spectrum-end* 1.0)
      (snd-display "* spectrum-end set default: ~A" *spectrum-end*))
  (if (not (eqv? *spectro-hop* 4)) 
      (snd-display "* spectro-hop set default: ~A" *spectro-hop*))
  (if (fneq *spectrum-start* 0.0)
      (snd-display "* spectrum-start set default: ~A" *spectrum-start*))
  (if (fneq *spectro-x-angle* (if (provided? 'gl) 300.0 90.0))
      (snd-display "* spectro-x-angle set default: ~A" *spectro-x-angle*))
  (if (fneq *spectro-x-scale* (if (provided? 'gl) 1.5 1.0))
      (snd-display "* spectro-x-scale set default: ~A" *spectro-x-scale*))
  (if (fneq *spectro-y-angle* (if (provided? 'gl) 320.0 0.0))
      (snd-display "* spectro-y-angle set default: ~A" *spectro-y-angle*))
  (if (fneq *spectro-y-scale* 1.0)
      (snd-display "* spectro-y-scale set default: ~A" *spectro-y-scale*))
  (if (fneq *spectro-z-angle* (if (provided? 'gl) 0.0 358.0))
      (snd-display "* spectro-z-angle set default: ~A" *spectro-z-angle*))
  (if (fneq *spectro-z-scale* (if (provided? 'gl) 1.0 0.1))
      (snd-display "* spectro-z-scale set default: ~A" *spectro-z-scale*))
  (if (not (member *tiny-font* '("6x12" "Sans 8")))
      (snd-display "* tiny-font set default: ~A" *tiny-font*))
  (if (not *with-file-monitor*) 
      (snd-display "* with-file-monitor set default: ~A" *with-file-monitor*))
  (if (not *with-interrupts*)
      (snd-display "* with-interrupts set default: ~A" *with-interrupts*))
  (if *remember-sound-state*
      (snd-display "* remember-sound-state set default: ~A" *remember-sound-state*))
  (if *with-smpte-label*
      (snd-display "* with-smpte-label set default: ~A" *with-smpte-label*))
  (if (not (eq? *with-toolbar* (provided? 'snd-gtk)))
      (snd-display "* with-toolbar set default: ~A" *with-toolbar*))
  (if (not *with-tooltips*)
      (snd-display "* with-tooltips set default: ~A" *with-tooltips*))
  (if *save-as-dialog-src*
      (snd-display "* save-as-dialog-src set default: ~A" *save-as-dialog-src*))
  (if *save-as-dialog-auto-comment*
      (snd-display "* save-as-dialog-auto-comment set default: ~A" *save-as-dialog-auto-comment*))
  (if (not (eqv? *wavelet-type* 0)) 
      (snd-display "* wavelet-type set default: ~A" *wavelet-type*))
  (if (not (equal? *time-graph-type* graph-once)) 
      (snd-display "* time-graph-type set default: ~A" *time-graph-type*))
  (if (not (eqv? *wavo-hop* 3)) 
      (snd-display "* wavo-hop set default: ~A" *wavo-hop*))
  (if (not (eqv? *wavo-trace* 64)) 
      (snd-display "* wavo-trace set default: ~A" *wavo-trace*))
  (if (not (eqv? *x-axis-style* 0)) 
      (snd-display "* x-axis-style set default: ~A" *x-axis-style*))
  (if (fneq *beats-per-minute* 60.0)
      (snd-display "* beats-per-minute set default: ~A" *beats-per-minute*))
  (if (not (= *beats-per-measure* 4))
      (snd-display "* beats-per-measure set default: ~A" *beats-per-measure*))
  (if (not (eqv? *zero-pad* 0)) 
      (snd-display "* zero-pad set default: ~A" *zero-pad*))
  (if (not (eqv? *zoom-focus-style* 2)) 
      (snd-display "* zoom-focus-style set default: ~A" *zoom-focus-style*))
  (if (not (equal? *sync-style* sync-by-sound)) 
      (snd-display "* sync-style set default: ~A" *sync-style*))    
  (if (not (eqv? *mix-waveform-height* 20)) 
      (snd-display "* mix-waveform-height set default: ~A" *mix-waveform-height*))
  (if (not (eqv? *mix-tag-width* 6)) 
      (snd-display "* mix-tag-width set default: ~A" *mix-tag-width*))
  (if (not (eqv? *mix-tag-height* 14)) 
      (snd-display "* mix-tag-height set default: ~A" *mix-tag-height*))
  (if (not (eqv? *mark-tag-width* 10)) 
      (snd-display "* mark-tag-width set default: ~A" *mark-tag-width*))
  (if (not (eqv? *mark-tag-height* 4)) 
      (snd-display "* mark-tag-height set default: ~A" *mark-tag-height*))
  
  (if (and with-motif
	   (not (= (view-files-sort) 0)))
      (snd-display "view-files-sort def: ~A" (view-files-sort)))
  
  (let-temporarily ((*mus-max-malloc* (expt 2 36)))
    (if (not (= *mus-max-malloc* (expt 2 36)))
	(snd-display "mus-max-malloc as bignum: ~A" *mus-max-malloc*)))
  
  (let-temporarily ((*mus-max-table-size* (expt 2 36)))
    (if (not (= *mus-max-table-size* (expt 2 36)))
	(snd-display "mus-max-table-size as bignum: ~A" *mus-max-table-size*)))
  
  (if (not (provided? 'snd-gtk))
      (for-each
       (lambda (func name)
	 (let ((val (func)))
	   (set! (func) "8x123")
	   (if (not (and (string? (func))
			 (string=? val (func))))
	       (snd-display "set ~A to bogus value: ~A ~A" name val (func)))))
       (list axis-label-font axis-numbers-font tiny-font peaks-font bold-peaks-font)
       '(axis-label-font axis-numbers-font tiny-font peaks-font bold-peaks-font)))
  
  (set! *ask-about-unsaved-edits* #f)
  (set! *remember-sound-state* #f))



;;; ---------------- test 1: defaults ----------------

(define good-colormap hot-colormap)
(define better-colormap black-and-white-colormap)
(if (and with-gui
	 (not (colormap? good-colormap)))
    (set! good-colormap
	  (call-with-exit
	   (lambda (return)
	     (do ((i 1 (+ i 1)))
		 ((= i 20))
	       (if (colormap? (integer->colormap i))
		   (return (integer->colormap i))))))))
(if (and with-gui
	 (not (colormap? better-colormap)))
    (set! better-colormap
	  (call-with-exit
	   (lambda (return)
	     (do ((i good-colormap (+ i 1)))
		 ((= i 20))
	       (if (colormap? (integer->colormap i))
		   (return (integer->colormap i))))))))

(define (snd_test_1)
  (when with-gui
    (letrec ((test-defaults
	      (lambda (lst)
		(when (pair? lst)
		  (if (and (not (or (equal? (cadr lst) (caddr lst))
				    (and (pair? (caddr lst))
					 (member (cadr lst) (caddr lst)))))
			   (or (not (number? (caddr lst)))
			       (rational? (caddr lst))
			       (fneq (cadr lst) (caddr lst)))) ; right! not my fault!
		      (snd-display "~A is not ~A (~A)" (car lst) (caddr lst) (cadr lst)))
		  (test-defaults (cdddr lst))))))
      
      (for-each close-sound (sounds)) ; in case others opened elsewhere
      (test-defaults
       (list
	'amp-control (without-errors (amp-control)) 'no-such-sound
	'amp-control-bounds (cadr (amp-control-bounds)) 8.0
	'ask-about-unsaved-edits *ask-about-unsaved-edits* #f 
	'ask-before-overwrite *ask-before-overwrite* #f 
	'auto-resize *auto-resize* #t 
	'auto-update *auto-update* #f
	'auto-update-interval *auto-update-interval* 60.0 
	'beats-per-measure *beats-per-measure* 4
	'beats-per-minute *beats-per-minute* 60.0
	'channel-style *channel-style* 1
	'clipping *clipping* #f 
	'clm-table-size *clm-table-size* 512
	'color-cutoff *color-cutoff* '(0.003 0.001)
	'color-inverted *color-inverted* #t
	'color-scale *color-scale* 1.0 
	'colormap *colormap* (list hot-colormap jet-colormap)
	'contrast-control (without-errors (contrast-control)) 'no-such-sound
	'contrast-control-amp *contrast-control-amp* 1.0
	'contrast-control-bounds (cadr (contrast-control-bounds)) 10.0
	'contrast-control? (without-errors (contrast-control?)) 'no-such-sound
	'cursor-location-offset *cursor-location-offset* 0
	'cursor-size *cursor-size* 15
	'cursor-style *cursor-style* cursor-cross
	'cursor-update-interval *cursor-update-interval* 0.05
	'dac-combines-channels *dac-combines-channels* #t
	'dac-size *dac-size* 256 
	'default-output-chans *default-output-chans* 1 
	'default-output-sample-type *default-output-sample-type* mus-ldouble
	'default-output-header-type *default-output-header-type* mus-next
	'default-output-srate *default-output-srate* 44100
	'dot-size *dot-size* 1 
	'enved-base *enved-base* 1.0 
	'enved-clip? (enved-clip?) #t
	'enved-envelope (enved-envelope) ()
	'enved-filter (enved-filter) #t
	'enved-filter-order *enved-filter-order* 40
	'enved-in-dB (enved-in-dB) #f 
	'enved-power *enved-power* 3.0
	'enved-style *enved-style* envelope-linear
	'enved-target *enved-target* 0 
	'enved-wave? *enved-wave?* #f 
	'eps-bottom-margin *eps-bottom-margin* 0.0
	'eps-file *eps-file* "snd.eps" 
	'eps-left-margin *eps-left-margin* 0.0
	'eps-size *eps-size* 1.0
	'expand-control (without-errors (expand-control)) 'no-such-sound
	'expand-control-bounds (cadr (expand-control-bounds)) 20.0
	'expand-control-hop *expand-control-hop* 0.05
	'expand-control-jitter *expand-control-jitter* 0.1
	'expand-control-length *expand-control-length* 0.15
	'expand-control-ramp *expand-control-ramp* 0.4
	'expand-control? (without-errors (expand-control?)) 'no-such-sound
	'fft-log-frequency *fft-log-frequency* #f 
	'fft-log-magnitude *fft-log-magnitude* #f 
	'fft-with-phases *fft-with-phases* #f 
	'fft-window *fft-window* 6 
	'fft-window-alpha *fft-window-alpha* 0.0 
	'fft-window-beta *fft-window-beta* 0.0 
	'filter-control-coeffs (without-errors (filter-control-coeffs)) 'no-such-sound
	'filter-control-envelope (without-errors (filter-control-envelope)) 'no-such-sound
	'filter-control-in-dB *filter-control-in-dB* #f
	'filter-control-in-hz *filter-control-in-hz* #f
	'filter-control-order *filter-control-order* 20
	'filter-control? (without-errors (filter-control?)) 'no-such-sound
	'graph-cursor *graph-cursor* 34
	'graph-style *graph-style* graph-lines
	'graphs-horizontal *graphs-horizontal* #t
	'grid-density *grid-density* 1.0
	'html-dir *html-dir* "."
	'html-program *html-program* "firefox"
	'initial-beg *initial-beg* 0.0
	'initial-dur *initial-dur* 0.1
	'just-sounds *just-sounds* #t
	'ladspa-dir *ladspa-dir* ""
	'peak-env-dir *peak-env-dir* (list "" "/home/bil/peaks")
	'lisp-graph? (without-errors (lisp-graph?)) 'no-such-sound
	'log-freq-start *log-freq-start* 32.0	
	'mark-tag-height *mark-tag-height* 4
	'mark-tag-width *mark-tag-width* 10
	'max-regions *max-regions* 16 
	'max-transform-peaks *max-transform-peaks* 100
	'min-dB *min-dB* -60.0 
	'mix-tag-height *mix-tag-height* 14
	'mix-tag-width *mix-tag-width* 6
	'mix-waveform-height *mix-waveform-height* 20 
	'mus-array-print-length *mus-array-print-length* 8
	'mus-clipping (mus-clipping) #f
	'mus-float-equal-fudge-factor *mus-float-equal-fudge-factor* .0000001
	'play-arrow-size *play-arrow-size* 10
	'print-length *print-length* '(12 32)
	'read-only (without-errors (read-only)) 'no-such-sound
	'region-graph-style *region-graph-style* graph-lines
	'remember-sound-state *remember-sound-state* #f
	'reverb-control-feedback *reverb-control-feedback* 1.09
	'reverb-control-length (without-errors (reverb-control-length)) 'no-such-sound
	'reverb-control-length-bounds (cadr (reverb-control-length-bounds)) 5.0
	'reverb-control-lowpass *reverb-control-lowpass* 0.7
	'reverb-control-scale (without-errors (reverb-control-scale)) 'no-such-sound
	'reverb-control-scale-bounds (cadr (reverb-control-scale-bounds)) 4.0
	'reverb-control? (without-errors (reverb-control?)) 'no-such-sound
	'save-as-dialog-auto-comment *save-as-dialog-auto-comment* #f
	'save-as-dialog-src *save-as-dialog-src* #f
	'save-state-file *save-state-file* "saved-snd.scm" 
	'selection-creates-region *selection-creates-region* #t 
	'show-axes *show-axes* 1
	'show-controls *show-controls* #f
	'show-full-duration *show-full-duration* '(#f #t)
	'show-full-range *show-full-range* #f 
	'show-grid *show-grid* #f 
	'show-indices *show-indices* '(#f #t)
	'show-marks *show-marks* #t 
	'show-mix-waveforms *show-mix-waveforms* #t
	'show-selection-transform *show-selection-transform* #f 
	'show-sonogram-cursor *show-sonogram-cursor* #f 
	'show-transform-peaks *show-transform-peaks* '(#f #t)
	'show-y-zero *show-y-zero* #f 
	'sinc-width *sinc-width* 10 
	'spectrum-end *spectrum-end* 1.0
	'spectro-hop *spectro-hop* 4 
	'spectrum-start *spectrum-start* 0.0 
	'spectro-x-angle *spectro-x-angle* (if (provided? 'gl) 300.0 90.0)
	'spectro-x-scale *spectro-x-scale* (if (provided? 'gl) 1.5 1.0)
	'spectro-y-angle *spectro-y-angle* (if (provided? 'gl) 320.0 0.0)
	'spectro-y-scale *spectro-y-scale* 1.0 
	'spectro-z-angle *spectro-z-angle* (if (provided? 'gl) 0.0 358.0)
	'spectro-z-scale *spectro-z-scale* (if (provided? 'gl) 1.0 0.1)
	'speed-control (without-errors (speed-control)) 'no-such-sound
	'speed-control-bounds (cadr (speed-control-bounds)) 20.0
	'sync (without-errors (sync)) 'no-such-sound
	'sync-style *sync-style* sync-by-sound
	'temp-dir *temp-dir* (list "" "/home/bil/zap/tmp")
	'time-graph-type *time-graph-type* graph-once
	'time-graph? (without-errors (time-graph?)) 'no-such-sound
	'tiny-font *tiny-font* (if (provided? 'snd-motif) "6x12" "Sans 8")
	'tracking-cursor-style *tracking-cursor-style* cursor-line
	'transform-graph-type *transform-graph-type* graph-once
	'transform-graph? (without-errors (transform-graph?)) 'no-such-sound
	'transform-normalization *transform-normalization* normalize-by-channel
	'transform-size *transform-size* *transform-size*
	'transform-type *transform-type* fourier-transform
	'wavelet-type *wavelet-type* 0 
	'wavo-hop *wavo-hop* 3 
	'wavo-trace *wavo-trace* 64 
	'with-mix-tags *with-mix-tags* #t
	'with-relative-panes *with-relative-panes* #t
	'with-verbose-cursor *with-verbose-cursor* '(#f #t)
	'with-inset-graph *with-inset-graph* '(#f #t)
	'with-interrupts *with-interrupts* #t
	'with-smpte-label *with-smpte-label* #f
	'with-toolbar *with-toolbar* '(#f #t)
	'with-tooltips *with-tooltips* #t
	'with-menu-icons *with-menu-icons* '(#f #t)
	'with-pointer-focus *with-pointer-focus* '(#f #t)
	'x-axis-style *x-axis-style* 0 
	'zero-pad *zero-pad* 0
	'zoom-focus-style *zoom-focus-style* 2))
      (if *snd-opened-sound* (snd-display "*snd-opened-sound*: ~A" *snd-opened-sound*))

      (let ((s (open-sound "oboe.snd")))
	(letrec ((test-vars
		  (lambda (lst)
		    (when (pair? lst)
		      (let* ((args (car lst))
			     (name (args 0))
			     (getfnc (symbol->value name))
			     (setfnc (lambda (val) (set! (getfnc) val)))
			     (initval (args 1))
			     (newval (args 2))
			     (star-name (symbol "*" (symbol->string name) "*")))
			(setfnc newval)
			(let ((nowval (symbol->value star-name)))
			  (if (and (not (or (equal? newval nowval)
					    (and (list? newval)
						 (feql newval nowval))))
				   (or (not (number? newval))
				       (rational? newval)
				       (> (abs (- newval nowval)) 0.01)))
			      (snd-display "~A is not ~A (~A)" star-name newval nowval))
			  ;(eval `(set! ,star-name ,initval))
			  (apply set! star-name initval ())
			  (if (not (equivalent? (getfnc) initval))
			      (snd-display "* ~A is not ~A" name initval))
			  (eval `(set! ,star-name ,newval))
			  (let ((nowval (getfnc)))
			    (if (and (not (or (equal? newval nowval)
					      (and (list? newval)
						   (feql newval nowval))))
				     (or (not (number? newval))
					 (rational? newval)
					 (> (abs (- newval nowval)) 0.01)))
				(snd-display "set! ~A is not ~A (~A)" star-name newval nowval))
			    (setfnc initval))
			  (test-vars (cdr lst))))))))
	  (test-vars 
	   (list
	    (list 'ask-about-unsaved-edits #f #t)
	    (list 'ask-before-overwrite #f #t)
	    (list 'auto-resize #t #f)
	    (list 'auto-update #f #t)
	    (list 'auto-update-interval 60.0 120.0)
	    (list 'beats-per-measure 1 120)
	    (list 'beats-per-minute 30.0 120.0)
	    (list 'channel-style 0 1)
	    (list 'clipping #f #t)
	    (list 'color-cutoff 0.003 0.01)
	    (list 'color-inverted #t #f)
	    (list 'color-scale 1.0 0.5)
	    (list 'contrast-control-amp 1.0 0.5)
	    (list 'cursor-location-offset 0 32768)
	    (list 'cursor-size 15 30)
	    (list 'cursor-style cursor-cross cursor-line)
	    (list 'cursor-update-interval 0.05 0.10)
	    (list 'dac-combines-channels #t #f)
	    (list 'dac-size 256 512)
	    (list 'default-output-chans 1 2)
	    (list 'default-output-header-type mus-next mus-aifc)
	    (list 'default-output-sample-type 1 1)
	    (list 'default-output-srate 22050 44100)
	    (list 'dot-size 1 4)
	    (list 'enved-base 1.0  1.5)
	    (list 'enved-filter-order 40 20)
	    (list 'enved-power 3.0 3.5)
	    (list 'enved-style envelope-linear envelope-exponential)
	    (list 'enved-target 0 1)
	    (list 'enved-wave? #f #t)
	    (list 'eps-bottom-margin 0.0 36.0)
	    (list 'eps-file "snd.eps" "snd-1.eps")
	    (list 'eps-left-margin 0.0 72.0)
	    (list 'eps-size 1.0 2.0)
	    (list 'expand-control-hop 0.05 0.1)
	    (list 'expand-control-jitter 0.1 0.2)
	    (list 'expand-control-length 0.15 0.2)
	    (list 'expand-control-ramp 0.4 0.2)
	    (list 'fft-log-frequency #f #t)
	    (list 'fft-log-magnitude #f #t)
	    (list 'fft-window 6 5)
	    (list 'fft-window-alpha 0.0  1.0)
	    (list 'fft-window-beta 0.0  0.5)
	    (list 'fft-with-phases #f #t)
	    (list 'filter-control-in-dB #f #t)
	    (list 'filter-control-in-hz #f #t)
	    (list 'filter-control-order 20 40)
	    (list 'graph-style 0 1)
	    (list 'grid-density 1.0 0.5)
	    (list 'initial-beg 0.0 1.0)
	    (list 'initial-dur 0.1 1.0)
	    (list 'just-sounds #f #t)
	    (list 'listener-prompt ">" ":")
	    (list 'log-freq-start 32.0 10.0)
	    (list 'mark-tag-height 4 20)
	    (list 'mark-tag-width 10 20)
	    (list 'max-regions 16 6)
	    (list 'max-transform-peaks 100 10)
	    (list 'min-dB -60.0 -90.0)
	    (list 'mix-tag-height 14 20)
	    (list 'mix-tag-width 6 20)
	    (list 'mix-waveform-height 20 40)
	    (list 'play-arrow-size 10 16)
	    (list 'print-length 12 16)
	    (list 'region-graph-style graph-lines graph-lollipops)
	    (list 'reverb-control-decay 1.0 2.0)
	    (list 'reverb-control-feedback 1.09 1.6)
	    (list 'reverb-control-lowpass 0.7 0.9)
	    (list 'selection-creates-region #t #f)
	    (list 'show-axes 1 0)
	    (list 'show-full-duration #f #t)
	    (list 'show-full-range #f #t)
	    (list 'show-grid #f #t)
	    (list 'show-indices #f #t)
	    (list 'show-marks #t #f)
	    (list 'show-mix-waveforms #t #f)
	    (list 'show-selection-transform #f #t)
	    (list 'show-sonogram-cursor #f #t)
	    (list 'show-transform-peaks #f #t)
	    (list 'show-y-zero #f #t)
	    (list 'sinc-width 10 40)
	    (list 'spectro-hop 4 10)
	    (list 'spectro-x-angle (if (provided? 'gl) 300.0 90.0) 60.0)
	    (list 'spectro-x-scale (if (provided? 'gl) 1.5 1.0) 2.0)
	    (list 'spectro-y-angle (if (provided? 'gl) 320.0 0.0) 60.0)
	    (list 'spectro-y-scale 1.0 2.0)
	    (list 'spectro-z-angle (if (provided? 'gl) 0.0 358.0) 60.0)
	    (list 'spectro-z-scale (if (provided? 'gl) 1.0 0.1) 0.2)
	    (list 'spectrum-end 1.0 0.7)
	    (list 'spectrum-start 0.0 0.1)
	    (list 'speed-control-style 0 1)
	    (list 'speed-control-tones 12 18)
	    (list 'stdin-prompt ">" "")
	    (list 'sync-style sync-by-sound sync-all)
	    (list 'time-graph-type graph-once graph-as-wavogram)
	    (list 'tiny-font (if (provided? 'snd-gtk) (values "Sans 8" "Monospace 10") (values "6x12" "9x15")))
	    (list 'tracking-cursor-style cursor-line cursor-cross)
	    (list 'transform-graph-type graph-once graph-as-sonogram)
	    (list 'transform-normalization normalize-by-channel dont-normalize)
	    (list 'transform-size 512 1024)
	    (list 'wavelet-type 0 1)
	    (list 'wavo-hop 3 6)
	    (list 'wavo-trace 64 128)
	    (list 'with-gl (provided? 'gl) #f)
	    (list 'with-relative-panes #t #f)
	    (list 'with-verbose-cursor #f #t)
	    (list 'x-axis-style 0 1)
	    (list 'zero-pad 0 1)
	    (list 'zoom-focus-style 2 1))))
	(close-sound s)))

    (set! *ask-about-unsaved-edits* #f)
    (set! *remember-sound-state* #f)))

(set! (with-mix-tags) #t) ; assumed in test 16(!)
(set! *default-output-sample-type* mus-ldouble)


;;; ---------------- test 2: headers ----------------
(define (snd_test_2)
  (when (string? sf-dir)
    (letrec ((test-headers
	      (lambda (base-files)
		(when (pair? base-files)
		  (let* ((testf (car base-files))
			 (file (string-append sf-dir (testf 0))))
		    (if (not (file-exists? file))
			(snd-display "~A missing?" file)
			(begin
			  (if (not (eqv? (mus-sound-chans file) (testf 1)))
			      (snd-display "~A: chans ~A is not ~A" 
					   (testf 0) 
					   (mus-sound-chans file) 
					   (testf 1)))
			  (if (not (eqv? (mus-sound-srate file) (testf 2)))
			      (snd-display "~A: srate ~A is not ~A" 
					   (testf 0) 
					   (mus-sound-srate file) 
					   (testf 2)))
			  (if (fneq (mus-sound-duration file) (testf 3))
			      (snd-display "~A: duration ~A is not ~A" 
					   (testf 0)
					   (mus-sound-duration file) 
					   (testf 3)))
			  (if (not (or (= (mus-sound-sample-type file) mus-unknown-sample)
				       (= (mus-sound-header-type file) 27)
				       (>= (+ (mus-sound-length file) 1)
					   (* (mus-sound-datum-size file) (mus-sound-duration file) (mus-sound-srate file)
					      (mus-sound-chans file)))))
			      (snd-display "mus-sound-length ~A: ~A (~A)" file
					   (mus-sound-length file)
					   (* (mus-sound-duration file) (mus-sound-srate file) 
					      (mus-sound-chans file) (mus-sound-datum-size file))))
			  (if (fneq (/ (mus-sound-framples file) (mus-sound-srate file)) (mus-sound-duration file))
			      (snd-display "mus-sound-framples ~A: ~A (~A ~A)" file
					   (mus-sound-framples file)
					   (mus-sound-duration file)
					   (/ (mus-sound-framples file) (mus-sound-srate file))))
			  (if (> (abs (- (mus-sound-framples file) (/ (mus-sound-samples file) (mus-sound-chans file)))) 1)
			      (snd-display "mus-sound-samples ~A: ~A ~A" file
					   (mus-sound-samples file)
					   (* (mus-sound-framples file) (mus-sound-chans file))))
			  (if (not (equal? (mus-header-type-name (mus-sound-header-type file)) (testf 4)))
			      (snd-display "~A: type ~A is not ~A" 
					   (testf 0) 
					   (mus-header-type-name (mus-sound-header-type file))
					   (testf 4)))
			  (if (not (equal? (mus-sample-type-name (mus-sound-sample-type file)) (testf 5)))
			      (snd-display "~A: type ~A is not ~A"
					   (testf 0) 
					   (mus-sample-type-name (mus-sound-sample-type file)) 
					   (testf 5)))
			  (let ((lst (mus-sound-loop-info file)))
			    (if (> (length testf) 6)
				(begin
				  (if (not (equal? (car lst) (testf 6))) 
				      (snd-display "~A: loop start: ~A" (car lst) (testf 6)))
				  (if (not (equal? (cadr lst) (testf 7))) 
				      (snd-display "~A: loop end: ~A" (cadr lst) (testf 7))))
				(if (pair? lst)
				    (snd-display "~A thinks it has loop info: ~A" file lst))))
			  (mus-sound-forget file)))
		    (test-headers (cdr base-files)))))))
      
      ;; need to make sure raw defaults are consistent with following tests
      (let ((ind (open-raw-sound :file (string-append sf-dir "addf8.nh") :channels 2 :srate 44100 :sample-type mus-bshort)))
	(if (sound? ind) (close-sound ind)))
      (catch #t
	(lambda ()
	  (if (not (= (mus-sound-header-type (string-append sf-dir "midi60.mid")) -1)) (snd-display "midi60?")))
	(lambda args args))
      (test-headers
       (list
	(list "5_secs.aiff" 1 44100 5.303107 "AIFF" "big endian short (16 bits)")
	(list "8svx-8.snd" 1 22050 1.88766443729401 "SVX8" "signed byte (8 bits)")
	(list "Fnonull.aif" 1 8000 0.00112499995157123 "AIFC" "mulaw (8 bits)")
	(list "Pmiscck.aif" 1 8000 0.00112499995157123 "AIFC" "mulaw (8 bits)")
	(list "Pmiscck.wav" 1 8000 0.00112499995157123 "RIFF" "mulaw (8 bits)")
					;	    (list "Pnossnd.aif" 1 8000 0.0 "AIFC" "mulaw (8 bits)")
	(list "Poffset.aif" 1 8000 0.00112499995157123 "AIFC" "mulaw (8 bits)")
	(list "Porder.aif" 1 8000 0.00112499995157123 "AIFC" "mulaw (8 bits)")
	(list "Ptjunk.aif" 1 8000 0.00112499995157123 "AIFC" "mulaw (8 bits)")
	(list "Ptjunk.wav" 1 8000 0.00112499995157123 "RIFF" "mulaw (8 bits)")
	(list "SINE24-S.WAV" 2 44100 2.0 "RIFF" "little endian int (24 bits)")
	(list "a1.asf" 1 16000 3.73656249046326 "asf" "unknown")
	(list "a2.asf" 1 8000 4.63062477111816 "asf" "unknown")
	(list "addf8.afsp" 1 8000 2.9760000705719 "Sun/Next" "big endian short (16 bits)")
	(list "addf8.d" 1 8000 2.9760000705719 "SPPACK" "big endian short (16 bits)")
	(list "addf8.dwd" 1 8000 2.9760000705719 "DiamondWare" "little endian short (16 bits)")
	(list "addf8.nh" 2 44100 0.269931972026825 "raw (no header)" "big endian short (16 bits)")
	(list "addf8.sd" 1 8000 2.9760000705719 "ESPS" "big endian short (16 bits)")
	(list "addf8.sf_mipseb" 1 8000 2.9760000705719 "IRCAM" "big endian short (16 bits)")
	(list "addf8.sf_sun" 1 8000 2.9760000705719 "IRCAM" "big endian short (16 bits)")
	(list "addf8.sf_vax_b" 1 8000 2.9760000705719 "IRCAM" "big endian short (16 bits)")
	(list "addf8.wav" 1 8000 2.9760000705719 "RIFF" "little endian short (16 bits)")
	(list "aebass.krz" 1 44100 3.0 "Kurzweil 2000" "big endian short (16 bits)")
	(list "aiff-16.snd" 2 44100 0.746666669845581 "AIFF" "big endian short (16 bits)")
	(list "aiff-8.snd" 2 44100 0.746666669845581 "AIFF" "signed byte (8 bits)")
	(list "alaw.aifc" 1 44100 0.0367800444364548 "AIFC" "alaw (8 bits)")
	(list "alaw.wav" 1 11025 8.70666694641113 "RIFF" "alaw (8 bits)")
	(list "astor_basia.mp2" 2 44100 1.02179133892059 "raw (no header)" "big endian short (16 bits)")
	(list "c.asf" 1 8000 21.3681259155273 "asf" "unknown")
	(list "ce-c3.w02" 1 33000 3.88848495483398 "TX-16W" "unknown")
	(list "ce-c4.w03" 1 33000 2.91618180274963 "TX-16W" "unknown")
	(list "ce-d2.w01" 1 33000 3.46439385414124 "TX-16W" "unknown")
	(list "clbonef.wav" 1 22050 2.57832193374634 "RIFF" "little endian float (32 bits)")
	(list "cranker.krz" 1 44100 3.48267579078674 "Kurzweil 2000" "big endian short (16 bits)")
	(list "d40130.aif" 1 10000 0.100000001490116 "AIFF" "big endian short (16 bits)")
	(list "d40130.au" 1 10000 0.100000001490116 "Sun/Next" "big endian short (16 bits)")
	(list "d40130.dsf" 1 8000 0.125 "Delusion" "little endian short (16 bits)")
	(list "d40130.fsm" 1 8000 0.125249996781349 "Farandole" "little endian short (16 bits)")
	(list "d40130.iff" 1 10000 0.100000001490116 "SVX8" "signed byte (8 bits)")
	(list "d40130.pat" 1 10000 0.100000001490116 "Gravis Ultrasound patch" "little endian short (16 bits)")
	(list "d40130.sds" 1 10000 0.100000001490116 "MIDI sample dump" "unknown")
	(list "d40130.sdx" 1 10000 0.100000001490116 "Sample dump" "unsigned little endian short (16 bits)")
	(list "d40130.sf" 1 10000 0.100000001490116 "IRCAM" "little endian short (16 bits)")
	(list "d40130.smp" 1 8000 0.125 "SMP" "little endian short (16 bits)")
	(list "d40130.sou" 1 8000 0.125 "SBStudioII" "little endian short (16 bits)")
	(list "d40130.st3" 1 8000 0.125 "Digiplayer ST3" "unsigned little endian short (16 bits)")
	(list "d40130.uwf" 1 8000 0.125249996781349 "Ultratracker" "little endian short (16 bits)")
	(list "d40130.voc" 1 10000 0.100100003182888 "VOC" "unsigned byte (8 bits)")
	(list "d40130.w00" 1 16000 0.0625 "TX-16W" "unknown")
	(list "d40130.wav" 1 10000 0.100000001490116 "RIFF" "little endian short (16 bits)")
	(list "d43.wav" 1 10000 0.100000001490116 "RIFF" "little endian short (16 bits)")
	(list "digit0v0.aiff" 1 8000 0.560000002384186 "AIFC" "big endian short (16 bits)")
	(list "esps-16.snd" 1 8000 3.09737491607666 "ESPS" "big endian short (16 bits)")
	(list "forest.aiff" 2 44100 3.907143 "AIFF" "big endian short (16 bits)" 24981 144332)
					;	  (list "g721.au" 1 11025 4.35328817367554 "Sun/Next" "unknown")
					;	  (list "g722.aifc" 1 44100 0.0184353739023209 "AIFC" "unknown")
	(list "gong.wve" 1 8000 3.96799993515015 "PSION" "alaw (8 bits)")
	(list "gsm610.wav" 1 11025 1.7687075138092 "RIFF" "unknown")
	(list "inrs-16.snd" 1 8000 2.46399998664856 "INRS" "little endian short (16 bits)")
	(list "kirk.wve" 1 8000 1.40799999237061 "PSION" "alaw (8 bits)")
	(list "loop.aiff" 1 44100 0.0367120169103146 "AIFC" "big endian short (16 bits)" 12 23)
	(list "m.asf" 1 8000 64.9646224975586 "asf" "unknown")
	(list "mary-sun4.sig" 1 8000 4.47612476348877 "Comdisco SPW signal" "big endian double (64 bits)")
	(list "mocksong.wav" 1 11025 7.86956930160522 "RIFF" "little endian short (16 bits)")
	(list "mono24.wav" 1 22050 1.98997735977173 "RIFF" "little endian int (24 bits)")
	(list "msadpcm.wav" 1 11025 4.43501138687134 "RIFF" "unknown")
	(list "n8.snd" 1 44100 0.0367800444364548 "Sun/Next" "signed byte (8 bits)")
	(list "nasahal.aif" 1 11025 9.89841270446777 "AIFF" "signed byte (8 bits)")
	(list "nasahal.avi" 1 11025 10.4327440261841 "AVI" "little endian short (16 bits)")
	(list "nasahal.dig" 1 11025 9.89841270446777 "Sound Designer 1" "big endian short (16 bits)")
	(list "nasahal.ivc" 2 44100 0.449002265930176 "raw (no header)" "big endian short (16 bits)")
	(list "nasahal.pat" 1 11025 3.95410442352295 "Gravis Ultrasound patch" "unsigned byte (8 bits)")
	(list "nasahal.snd" 1 11025 9.89841270446777 "SNDT" "unsigned byte (8 bits)")
	(list "nasahal.svx" 1 11025 9.89841270446777 "SVX8" "signed byte (8 bits)")
	(list "nasahal.v8" 1 8000 13.6412496566772 "Covox V8" "unsigned byte (8 bits)")
	(list "nasahal.voc" 1 11025 9.89941024780273 "VOC" "unsigned byte (8 bits)")
	(list "nasahal.vox" 2 44100 0.224444448947906 "raw (no header)" "big endian short (16 bits)")
	(list "nasahal8.wav" 1 11025 9.89841270446777 "RIFF" "unsigned byte (8 bits)")
	(list "nasahalad.smp" 1 11025 4.94920635223389 "Goldwave sample" "little endian short (16 bits)")
	(list "next-16.snd" 1 22050 1.00004529953003 "Sun/Next" "big endian short (16 bits)")
	(list "next-8.snd" 1 22050 0.226757362484932 "Sun/Next" "signed byte (8 bits)")
	(list "next-dbl.snd" 1 22050 0.226757362484932 "Sun/Next" "big endian double (64 bits)")
	(list "oboe.ldbl" 1 22050 2.30512475967407 "RIFF" "little endian double (64 bits)")
	(list "next-flt.snd" 1 22050 0.226757362484932 "Sun/Next" "big endian float (32 bits)")
	(list "aifc-float.snd" 1 22050 0.226757362484932 "AIFC" "big endian float (32 bits)")
	(list "next-mulaw.snd" 1 8012 2.03295063972473 "Sun/Next" "mulaw (8 bits)")
	(list "next24.snd" 1 44100 0.0367800444364548 "Sun/Next" "big endian int (24 bits)")
	(list "nist-01.wav" 1 16000 2.26912498474121 "NIST" "little endian short (16 bits)")
	(list "nist-10.wav" 1 16000 2.26912498474121 "NIST" "big endian short (16 bits)")
	(list "nist-16.snd" 1 16000 1.02400004863739 "NIST" "big endian short (16 bits)")
	(list "nist-shortpack.wav" 1 16000 4.53824996948242 "NIST" "unknown")
	(list "none.aifc" 1 44100 0.0367800444364548 "AIFC" "big endian short (16 bits)")
	(list "nylon2.wav" 2 22050 1.14376413822174 "RIFF" "unknown")
	(list "o2.adf" 1 44100 0.036780 "CSRE adf" "little endian short (16 bits)")
	(list "o2.avr" 1 44100 0.0183900222182274 "AVR" "big endian short (16 bits)")
	(list "o2.bicsf" 1 44100 0.0367800444364548 "IRCAM" "big endian short (16 bits)")
	(list "o2.mpeg1" 2 44100 0.00709750549867749 "raw (no header)" "big endian short (16 bits)")
	(list "o2.sd2" 2 44100 0.0183900222182274 "raw (no header)" "big endian short (16 bits)")
	(list "o2.sf2" 1 44100 0.0367800444364548 "SoundFont" "little endian short (16 bits)")
	(list "o2.smp" 1 8000 0.202749997377396 "SMP" "little endian short (16 bits)")
	(list "o2.voc" 1 44100 0.0368934236466885 "VOC" "little endian short (16 bits)")
	(list "o2.wave" 1 44100 0.0367800444364548 "RIFF" "little endian short (16 bits)")
	(list "o2_12bit.aiff" 1 44100 0.0367800444364548 "AIFF" "big endian short (16 bits)")
	(list "o2_18bit.aiff" 1 44100 0.0367800444364548 "AIFF" "big endian int (24 bits)")
					;	  (list "o2_711u.wave" 1 44100 0.0367800444364548 "RIFF" "mulaw (8 bits)")
					;	  (list "o2_722.snd" 1 44100 0.0183900222182274 "Sun/Next" "unknown")
					;	  (list "o2_726.aiff" 1 8000 0.0367499999701977 "AIFC" "unknown")
					;	  (list "o2_726.snd" 1 44100 0.0230158735066652 "Sun/Next" "unknown")
					;	  (list "o2_728.aiff" 1 8000 0.0367499999701977 "AIFC" "unknown")
	(list "o2_8.iff" 1 44100 0.0367800444364548 "SVX8" "signed byte (8 bits)")
	(list "o2_8.voc" 1 44100 0.0370294786989689 "VOC" "unsigned byte (8 bits)")
	(list "o2_dvi.wave" 1 44100 0.0232199542224407 "RIFF" "unknown")
	(list "o2_float.bicsf" 1 44100 0.0367800444364548 "IRCAM" "big endian float (32 bits)")
	(list "o2_gsm.aiff" 1 8000 0.0367499999701977 "AIFC" "unknown")
	(list "o2_u8.avr" 1 44100 0.0367800444364548 "AVR" "unsigned byte (8 bits)")
	(list "o2_u8.wave" 1 44100 0.0367800444364548 "RIFF" "unsigned byte (8 bits)")
	(list "o28.mpc" 1 44100 0.036780 "AKAI 4" "little endian short (16 bits)")
					;	  (list "oboe.g721" 1 22050 1.15287983417511 "Sun/Next" "unknown")
					;	  (list "oboe.g723_24" 1 22050 0.864761888980865 "Sun/Next" "unknown")
					;	  (list "oboe.g723_40" 1 22050 1.44126987457275 "Sun/Next" "unknown")
	(list "oboe.kts" 1 22050 2.305125 "Korg" "big endian short (16 bits)")
	(list "oboe.its" 1 22050 2.305125 "Impulse Tracker" "little endian short (16 bits)")
	(list "oboe.sf2" 1 22050 2.30512475967407 "SoundFont" "little endian short (16 bits)")
	(list "oboe.paf" 1 22050 2.305125 "Ensoniq Paris" "big endian short (16 bits)")
	(list "oboe.pf1" 1 22050 2.305125 "Ensoniq Paris" "little endian short (16 bits)")
	(list "oboe.smp" 1 22050 2.305125 "snack SMP" "little endian short (16 bits)")
	(list "oboe.rf64" 1 22050 2.305125 "rf64" "little endian short (16 bits)")
	(list "oboe-be32.caf" 1 22050 2.305125 "caff" "normalized big endian int (32 bits)")
	(list "oboe-bf64.caf" 1 22050 2.305125 "caff" "big endian double (64 bits)")
	(list "oboe-lf32.caf" 1 22050 2.305125 "caff" "little endian float (32 bits)")
	(list "oboe-ulaw.caf" 1 22050 2.305125 "caff" "mulaw (8 bits)")
	(list "oboe.nsp" 1 22050 2.305125 "CSL" "little endian short (16 bits)")
					;	  (list "oboe.nvf" 1 8000 6.353500 "Creative NVF" "unknown")
	(list "oboe-ulaw.voc" 1 22050 2.305669 "VOC" "mulaw (8 bits)")
	(list "oboe-lf32.sf" 1 22050 2.305669 "IRCAM" "little endian float (32 bits)")
	(list "oboe.wfp" 1 22050 2.305125 "Turtle Beach" "little endian short (16 bits)")
	(list "oboe.sox" 1 22050 2.305125 "Sox" "normalized little endian int (32 bits)")
	(list "oki.snd" 2 44100 0.0041950112208724 "raw (no header)" "big endian short (16 bits)")
	(list "oki.wav" 1 44100 0.016780 "RIFF" "unknown")
	(list "orv-dvi-adpcm.wav" 1 44100 1.92725622653961 "RIFF" "unknown")
	(list "riff-16.snd" 1 22050 1.88766443729401 "RIFF" "little endian short (16 bits)")
	(list "riff-8-u.snd" 1 11025 0.506848096847534 "RIFF" "unsigned byte (8 bits)")
	(list "rooster.wve" 1 8000 2.04800009727478 "PSION" "alaw (8 bits)")
	(list "sd1-16.snd" 1 44100 0.400544226169586 "Sound Designer 1" "big endian short (16 bits)")
					;	    (list "segfault.snd" 16777216 576061440 1.24986669902682e-7 "Sun/Next" "unknown")
	(list "sf-16.snd" 1 22050 1.88766443729401 "IRCAM" "big endian short (16 bits)")
	(list "si654.adc" 1 16000 6.71362495422363 "ADC/OGI" "big endian short (16 bits)")
	(list "smp-16.snd" 1 8000 5.2028751373291 "SMP" "little endian short (16 bits)")
	(list "sound.pat" 1 8000 1.95050001144409 "Gravis Ultrasound patch" "unsigned little endian short (16 bits)")
	(list "sound.sap" 1 8000 1.95050001144409 "Goldwave sample" "little endian short (16 bits)")
	(list "sound.sds" 1 8000 1.95050001144409 "MIDI sample dump" "unknown")
	(list "sound.sfr" 1 8000 1.95050001144409 "SRFS" "little endian short (16 bits)")
	(list "sound.v8" 1 8000 1.95050001144409 "Covox V8" "unsigned byte (8 bits)")
	(list "sound.vox" 2 44100 0.044217687100172 "raw (no header)" "big endian short (16 bits)")
	(list "step.omf" 1 11025 8.70666694641113 "OMF" "signed byte (8 bits)")
	(list "step.qt" 1 11025 8.70630359649658 "Quicktime" "unsigned byte (8 bits)")
	(list "sun-16-afsp.snd" 1 8000 2.9760000705719 "Sun/Next" "big endian short (16 bits)")
	(list "sun-mulaw.snd" 1 8000 4.61950016021729 "Sun/Next" "mulaw (8 bits)")
	(list "sw1038t_short.wav" 2 8000 6.0 "NIST" "mulaw (8 bits)")
	(list "swirl.pat" 1 22050 1.0619500875473 "Gravis Ultrasound patch" "unsigned little endian short (16 bits)")
	(list "sy85.snd" 1 8000 5.05600023269653 "Sy-85" "big endian short (16 bits)")
	(list "sy99.snd" 1 8000 4.54400014877319 "Sy-99" "big endian short (16 bits)")
	(list "telephone.wav" 1 16000 2.27881240844727 "NIST" "little endian short (16 bits)")
	(list "trumps22.adp" 1 22050 3.092880 "RIFF" "unknown")
	(list "truspech.wav" 1 8000 1.1599999666214 "RIFF" "unknown")
	(list "ulaw.aifc" 1 44100 0.0367800444364548 "AIFC" "mulaw (8 bits)")
	(list "voc-8-u.snd" 1 8000 1.49937498569489 "VOC" "unsigned byte (8 bits)")
	(list "o28.voc" 1 44100 0.036893 "VOC" "little endian short (16 bits)")
	(list "voxware.wav" 1 8000 0.324000000953674 "RIFF" "unknown")
	(list "wd.w00" 1 8000 0.202749997377396 "Sy-99" "big endian short (16 bits)")
	(list "wd1.smp" 1 8000 0.202749997377396 "SMP" "little endian short (16 bits)")
	(list "wd1.wav" 1 44100 0.0367800444364548 "RIFF" "little endian short (16 bits)")
	(list "wheel.mat" 2 44100 0.145646259188652 "raw (no header)" "big endian short (16 bits)")
	(list "b8.pvf" 1 44100 0.036803 "Portable Voice Format" "signed byte (8 bits)")
	(list "b16.pvf" 1 44100 0.036803 "Portable Voice Format" "big endian short (16 bits)")
	(list "b32.pvf" 1 44100 0.036803 "Portable Voice Format" "big endian int (32 bits)")
	(list "water.voc" 2 32000 42.3463897705078 "VOC" "little endian short (16 bits)")
	(list "wood.dsf" 1 8000 0.202749997377396 "Delusion" "little endian short (16 bits)")
	(list "wood.dvi" 1 22100 0.0278733037412167 "RIFF" "unknown")
	(list "wood.dwd" 1 22100 0.0733936652541161 "DiamondWare" "signed byte (8 bits)")
	(list "wood.fsm" 1 8000 0.202999994158745 "Farandole" "little endian short (16 bits)")
	(list "wood.mad" 1 22100 0.0372398197650909 "RIFF" "unknown")
	(list "wood.maud" 1 44100 0.0183900222182274 "MAUD" "big endian short (16 bits)")
	(list "wood.pat" 1 22100 0.0733936652541161 "Gravis Ultrasound patch" "little endian short (16 bits)")
	(list "wood.riff" 1 44100 0.0367800444364548 "RIFF" "little endian short (16 bits)")
	(list "wood.rifx" 1 44100 0.0367800444364548 "RIFF" "big endian short (16 bits)")
	(list "wood.sds" 1 22100 0.0733936652541161 "MIDI sample dump" "unknown")
	(list "wood.sdx" 1 22100 0.0733936652541161 "Sample dump" "unsigned little endian short (16 bits)")
	(list "wood.sf" 1 44100 0.0367800444364548 "IRCAM" "big endian short (16 bits)")
	(list "wood.sndr" 2 44100 0.0092290248721838 "raw (no header)" "big endian short (16 bits)")
	(list "wood.sndt" 1 44100 0.0367800444364548 "SNDT" "unsigned byte (8 bits)")
	(list "wood.st3" 1 8000 0.202749997377396 "Digiplayer ST3" "unsigned little endian short (16 bits)")
	(list "wood.uwf" 1 8000 0.202999994158745 "Ultratracker" "little endian short (16 bits)")
	(list "wood.w00" 1 16000 0.101374998688698 "TX-16W" "unknown")
	(list "wood12.aiff" 1 44100 0.0367800444364548 "AIFF" "big endian short (16 bits)")
	(list "wood16.dwd" 2 44100 0.0367800444364548 "DiamondWare" "little endian short (16 bits)")
	(list "wood16.wav" 2 44100 0.0367800444364548 "RIFF" "little endian short (16 bits)")
	(list "wood16.nsp" 2 44100 0.0367800444364548 "CSL" "little endian short (16 bits)")
	(list "wood16.smp" 2 44100 0.0367800444364548 "snack SMP" "little endian short (16 bits)")
	(list "wood24.aiff" 1 44100 0.0367800444364548 "AIFF" "big endian int (24 bits)")
	(list "woodblock.aiff" 1 44100 0.0367800444364548 "AIFF" "big endian short (16 bits)")
	(list "woodflt.snd" 1 44100 0.0367800444364548 "Sun/Next" "big endian float (32 bits)")
	(list "RealDrums.sf2" 1 44100 6.39725637435913 "SoundFont" "little endian short (16 bits)")
	(list "32bit.sf" 1 44100 4.6 "IRCAM" "little endian float (32 bits, unscaled)")
	(list "PCM_48_8bit_m.w64" 1 48000 0.375 "SoundForge" "unsigned byte (8 bits)")
	(list "oboe.sf6" 1 22050 2.305125 "SoundForge" "little endian short (16 bits)")
	(list "addf8.24we" 1 8000 2.976000 "RIFF" "little endian int (24 bits)")
	(list "hybrid.snd" 1 44100 4.600000 "BICSF" "big endian float (32 bits)")
	(list "litmanna.sf" 1 44100 .533 "IRCAM" "little endian short (16 bits)")
	(list "M1F1-float64C-AFsp.aif" 2 8000 2.9366 "AIFC" "big endian double (64 bits)")
	(list "MacBoing.wav" 1 11127 0.696 "RIFF" "unsigned byte (8 bits)")
	(list "t15.aiff" 2 44100 135.00 "AIFC" "little endian short (16 bits)")
	(list "tomf8.aud" 1 8000 2.016000 "INRS" "little endian short (16 bits)")
	(list "Xhs001x.nsp" 1 10000 6.017400 "CSL" "little endian short (16 bits)")
	(list "zulu_a4.w11" 1 33000 1.21987879276276 "TX-16W" "unknown" 23342 40042)))
      
      (for-each (lambda (in-name real-name)
		  (if (not (string=? (mus-expand-filename in-name) real-name))
		      (snd-display "mus-expand-filename ~A -> ~A" in-name (mus-expand-filename in-name)))
		  (if (file-exists? "/home/bil/./sf1/o2.voc")
		      (let ((ind (open-sound in-name)))
			(if (not (sound? ind))
			    (snd-display "can't open ~A" in-name)
			    (begin
			      (if (not (string=? (file-name ind) real-name))
				  (snd-display "expand file name ~A: ~A" in-name (file-name ind)))
			      (close-sound ind))))))
		'("/home/bil/./sf1/o2.voc" "~/./sf1/o2.voc" "~/cl/../sf1/o2.voc" "/home/bil/cl/../sf1/o2.voc")
		'("/home/bil/sf1/o2.voc" "/home/bil/sf1/o2.voc" "/home/bil/sf1/o2.voc" "/home/bil/sf1/o2.voc"))
      
      (let ((lst (mus-sound-mark-info (string-append sf-dir "forest.aiff"))))
	(if (not (equal? lst '((4 0) (3 0) (2 144332) (1 24981))))
	    (snd-display "mus-sound-mark-info forest: ~A" lst)))
      (let ((lst (mus-sound-mark-info (string-append sf-dir "traffic.aiff"))))
	(if (not (equal? lst '((4 1) (3 0) (2 171931) (1 99461))))
	    (snd-display "mus-sound-mark-info traffic: ~A" lst))))))



;;; ---------------- test 3: variables ----------------

(define (snd_test_3)
  (let ((ind (open-sound "oboe.snd")))
    (if (and (file-exists? "funcs.scm") 
	     (not (defined? 'swellf)))
	(load "funcs.scm"))
    (let ((td *temp-dir*))
      (catch #t
	     (lambda ()
	       (set! *temp-dir* (string-append home-dir "/test"))
	       (if (not (string=? *temp-dir* (string-append home-dir "/test")))
		   (snd-display "set temp-dir: ~A?" *temp-dir*)))
	     (lambda args args))
	  (set! *temp-dir* (or td "")))
    (if (fneq (sample 1000) 0.0328) (snd-display "sample: ~A?" (sample 1000)))
    
    (when with-gui
      (set! *show-controls* #t)
      
      (let ((wid (enved-dialog) ))
	(if (not (equal? wid ((dialog-widgets) 1)))
	    (snd-display "enved-dialog -> ~A ~A" wid ((dialog-widgets) 1))))
					;(if (not ((dialog-widgets) 1)) (snd-display "enved-dialog?"))
      (set! (enved-envelope) '(0.0 0.0 1.0 1.0 2.0 0.0))
      (if (not (equal? (enved-envelope) '(0.0 0.0 1.0 1.0 2.0 0.0)))
	  (snd-display "set enved-envelope to self: ~A?" (enved-envelope)))
      
      (letrec ((test-vars
		(lambda (lst)
		  (when (pair? lst)
		    (let* ((arg (car lst))
			   (name (car arg))
			   (getfnc (symbol->value name))
			   (setfnc (lambda (val) (set! (getfnc) val))))
		      (let ((initval (cadr arg))
			    (newval (caddr arg)))
			(setfnc newval)
			(let ((nowval (getfnc)))
			  (if (and (not (or (equal? newval nowval)
					    (and (list? newval)
						 (feql newval nowval))))
				   (or (not (number? newval))
				       (rational? newval)
				       (> (abs (- newval nowval)) 0.01)))
			      (snd-display "~A is not ~A (~A)" name newval nowval))
			  (setfnc initval)
			  (set! (getfnc) newval)
			  (let ((nowval (getfnc)))
			    (if (and (not (or (equal? newval nowval)
					      (and (list? newval)
						   (feql newval nowval))))
				     (or (not (number? newval))
					 (rational? newval)
					 (> (abs (- newval nowval)) 0.01)))
				(snd-display "set! ~A is not ~A (~A)" name newval nowval))
			    (setfnc initval))
			  (test-vars (cdr lst)))))))))
	(test-vars 
	 (list

	  (list 'amp-control 1.0 0.5)
	  (list 'amp-control-bounds (list 0.0 8.0) (list 1.0 5.0))
	  (list 'ask-about-unsaved-edits #f #t)
	  (list 'ask-before-overwrite #f #t)
	  (list 'auto-resize #t #f)
	  (list 'auto-update #f #t)
	  (list 'auto-update-interval 60.0 120.0)
	  (list 'beats-per-measure 1 120)
	  (list 'beats-per-minute 30.0 120.0)
	  (list 'channel-style 0 1)
	  (list 'clipping #f #t)
	  (list 'color-cutoff 0.003 0.01)
	  (list 'color-inverted #t #f)
	  (list 'color-scale 1.0 0.5)
	  (list 'colormap good-colormap better-colormap)
	  (list 'contrast-control 0.0 0.5)
	  (list 'contrast-control-amp 1.0 0.5)
	  (list 'contrast-control-bounds (list 0.0 10.0) (list 1.0 5.0))
	  (list 'contrast-control? #f #t)
	  (list 'cursor-location-offset 0 32768)
	  (list 'cursor-size 15 30)
	  (list 'cursor-style cursor-cross cursor-line)
	  (list 'cursor-update-interval 0.05 0.10)
	  (list 'dac-combines-channels #t #f)
	  (list 'dac-size 256 512)
	  (list 'default-output-chans 1 2)
	  (list 'default-output-header-type mus-next mus-aifc)
	  (list 'default-output-sample-type 1 1)
	  (list 'default-output-srate 22050 44100)
	  (list 'dot-size 1 4)
	  (list 'enved-base 1.0  1.5)
	  (list 'enved-clip? #f #t)
	  (list 'enved-filter #t #f)
	  (list 'enved-filter-order 40 20)
	  (list 'enved-in-dB #f #t)
	  (list 'enved-power 3.0 3.5)
	  (list 'enved-style envelope-linear envelope-exponential)
	  (list 'enved-target 0 1)
	  (list 'enved-wave? #f #t)
	  (list 'eps-bottom-margin 0.0 36.0)
	  (list 'eps-file "snd.eps" "snd-1.eps")
	  (list 'eps-left-margin 0.0 72.0)
	  (list 'eps-size 1.0 2.0)
	  (list 'expand-control 1.0 2.0)
	  (list 'expand-control-bounds (list .001 20.0) (list 1.0 2.0))
	  (list 'expand-control-hop 0.05 0.1)
	  (list 'expand-control-jitter 0.1 0.2)
	  (list 'expand-control-length 0.15 0.2)
	  (list 'expand-control-ramp 0.4 0.2)
	  (list 'expand-control? #f #t)
	  (list 'fft-log-frequency #f #t)
	  (list 'fft-log-magnitude #f #t)
	  (list 'fft-window 6 5)
	  (list 'fft-window-alpha 0.0  1.0)
	  (list 'fft-window-beta 0.0  0.5)
	  (list 'fft-with-phases #f #t)
	  (list 'filter-control-envelope (list 0.0 1.0 1.0 1.0) (list 0.0 1.0 1.0 0.0))
	  (list 'filter-control-in-dB #f #t)
	  (list 'filter-control-in-hz #f #t)
	  (list 'filter-control-order 20 40)
	  (list 'filter-control? #f #t)
	  (list 'graph-cursor 34 32)
	  (list 'graph-style 0 1)
	  (list 'grid-density 1.0 0.5)
	  (list 'initial-beg 0.0 1.0)
	  (list 'initial-dur 0.1 1.0)
	  (list 'just-sounds #f #t)
	  (list 'listener-prompt ">" ":")
	  (list 'log-freq-start 32.0 10.0)
	  (list 'mark-tag-height 4 20)
	  (list 'mark-tag-width 10 20)
	  (list 'max-regions 16 6)
	  (list 'max-transform-peaks 100 10)
	  (list 'min-dB -60.0 -90.0)
	  (list 'mix-tag-height 14 20)
	  (list 'mix-tag-width 6 20)
	  (list 'mix-waveform-height 20 40)
	  (list 'mus-clipping #f #t)
	  (list 'play-arrow-size 10 16)
	  (list 'print-length 12 16)
	  (list 'region-graph-style graph-lines graph-lollipops)
	  (list 'reverb-control-decay 1.0 2.0)
	  (list 'reverb-control-feedback 1.09 1.6)
	  (list 'reverb-control-length 1.0 2.0)
	  (list 'reverb-control-length-bounds (list 0.0 5.0) (list 1.0 2.0))
	  (list 'reverb-control-lowpass 0.7 0.9)
	  (list 'reverb-control-scale 0.0 0.2)
	  (list 'reverb-control-scale-bounds (list 0.0 4.0) (list 0.0 0.2))
	  (list 'reverb-control? #f #t)
	  (list 'selection-creates-region #t #f)
	  (list 'show-axes 1 0)
	  (list 'show-full-duration #f #t)
	  (list 'show-full-range #f #t)
	  (list 'show-grid #f #t)
	  (list 'show-indices #f #t)
	  (list 'show-marks #t #f)
	  (list 'show-mix-waveforms #t #f)
	  (list 'show-selection-transform #f #t)
	  (list 'show-sonogram-cursor #f #t)
	  (list 'show-transform-peaks #f #t)
	  (list 'show-y-zero #f #t)
	  (list 'sinc-width 10 40)
	  (list 'spectro-hop 4 10)
	  (list 'spectro-x-angle (if (provided? 'gl) 300.0 90.0) 60.0)
	  (list 'spectro-x-scale (if (provided? 'gl) 1.5 1.0) 2.0)
	  (list 'spectro-y-angle (if (provided? 'gl) 320.0 0.0) 60.0)
	  (list 'spectro-y-scale 1.0 2.0)
	  (list 'spectro-z-angle (if (provided? 'gl) 0.0 358.0) 60.0)
	  (list 'spectro-z-scale (if (provided? 'gl) 1.0 0.1) 0.2)
	  (list 'spectrum-end 1.0 0.7)
	  (list 'spectrum-start 0.0 0.1)
	  (list 'speed-control 1.0 0.5)
	  (list 'speed-control-bounds (list 0.05 20.0) (list 1.0 5.0))
	  (list 'speed-control-style 0 1)
	  (list 'speed-control-tones 12 18)
	  (list 'stdin-prompt "" ">")
	  (list 'sync 0 1)
	  (list 'sync-style sync-by-sound sync-all)
	  (list 'time-graph-type graph-once graph-as-wavogram)
	  (list 'time-graph? #f #t)
	  (list 'tiny-font (if (provided? 'snd-gtk) (values "Sans 8" "Monospace 10") (values "6x12" "9x15")))
	  (list 'tracking-cursor-style cursor-line cursor-cross)
	  (list 'transform-graph-type graph-once graph-as-sonogram)
	  (list 'transform-graph? #f #t)
	  (list 'transform-normalization normalize-by-channel dont-normalize)
	  (list 'transform-size 512 1024)
	  (list 'transform-type fourier-transform autocorrelation)
	  (list 'wavelet-type 0 1)
	  (list 'wavo-hop 3 6)
	  (list 'wavo-trace 64 128)
	  (list 'with-gl (provided? 'gl) #f)
	  (list 'with-mix-tags #t #f)
	  (list 'with-relative-panes #t #f)
	  (list 'with-tracking-cursor #f #t)
	  (list 'with-verbose-cursor #f #t)
	  (list 'x-axis-style 0 1)
	  (list 'zero-pad 0 1)
	  (list 'zoom-focus-style 2 1))))
      
      (set! *ask-about-unsaved-edits* #f)    
      (letrec ((test-bad-args
		(lambda (lst)
		  (if (pair? lst)
		      (let* ((name ((car lst) 0))
			     (getfnc ((car lst) 1))
			     (setfnc (lambda (val) (set! (getfnc) val)))
			     (initval ((car lst) 2))
			     (newvals ((car lst) 3)))
			(for-each
			 (lambda (n)
			   (catch #t 
			     (lambda ()
			       (setfnc n))
			     (lambda args (car args)))
			   (let ((nowval (getfnc)))
			     (if (equal? n nowval)
				 (snd-display "(bad set) ~A = ~A (~A)" name n initval))
			     (setfnc initval)))
			 newvals)
			(test-bad-args (cdr lst)))))))
	(test-bad-args
	 (list
	  (list 'amp-control amp-control 1.0 '(-1.0 123.123))
	  (list 'amp-control-bounds amp-control-bounds (list 0.0 8.0) (list #f (list 0.0) (list 1.0 0.0) 2.0))
	  (list 'channel-style channel-style 0 '(32 -1 1.0))
	  (list 'colormap colormap good-colormap '(321 -123))
	  (list 'color-cutoff color-cutoff 0.003 '(-1.0 123.123))
	  (list 'color-scale color-scale 1.0 '(-32.0 2000.0))
	  (list 'contrast-control contrast-control 0.0 '(-123.123 123.123))
	  (list 'contrast-control-bounds contrast-control-bounds (list 0.0 10.0) (list #f (list 0.0) (list 1.0 0.0) 2.0))
	  (list 'cursor-size cursor-size 15 '(1.123 -2.5))
	  (list 'dac-size dac-size 256 '(-1 0 -123))
	  (list 'dot-size dot-size 1 '(0 -1 -123))
	  (list 'enved-target enved-target 0 '(123 -321))
	  (list 'expand-control expand-control 1.0 '(-1.0 0.0))
	  (list 'expand-control-bounds expand-control-bounds (list 0.001 20.0) (list #f (list 0.0) (list 1.0 0.0) 2.0))
	  (list 'expand-control-hop expand-control-hop 0.05 '(-1.0))
	  (list 'expand-control-length expand-control-length 0.15 '(-1.0 0.0))
	  (list 'expand-control-ramp expand-control-ramp 0.4 '(-1.0 1.0 123.123))
	  (list 'fft-window-alpha fft-window-alpha 0.0  '(-1.0 123.123))
	  (list 'fft-window-beta fft-window-beta 0.0  '(-1.0 123.123))
	  (list 'transform-size transform-size 512 '(-1 0))
	  (list 'zero-pad zero-pad 0 '(-1 -123))
	  (list 'cursor-style cursor-style cursor-cross '(-1))
	  (list 'cursor-style cursor-style cursor-line '(2 123))
	  (list 'tracking-cursor-style tracking-cursor-style cursor-line '(-1))
	  (list 'tracking-cursor-style tracking-cursor-style cursor-line '(2 123))
	  (list 'transform-graph-type transform-graph-type graph-once '(-1 123))
	  (list 'fft-window fft-window 6 '(-1 123))
	  (list 'enved-filter-order enved-filter-order 40 '(-1 0))
	  (list 'filter-control-order filter-control-order 20 '(-10 -1 0))
	  (list 'max-transform-peaks max-transform-peaks 100 '(-1))
	  (list 'max-regions max-regions 16 '(-1 -123))
	  (list 'reverb-control-length reverb-control-length 1.0 '(-1.0))
	  (list 'show-axes show-axes 1 '(-1 123))
	  (list 'sinc-width sinc-width 10 '(-10))
	  (list 'spectrum-end spectrum-end 1.0 '(-1.0))
	  (list 'spectro-hop spectro-hop 4 '(-10 -1 0))
	  (list 'spectrum-start spectrum-start 0.0 '(-1.0))
	  (list 'speed-control speed-control 1.0 '(0.0))
	  (list 'speed-control-bounds speed-control-bounds (list 0.05 20.0) (list #f (list 0.0) (list 1.0 0.0) 2.0))
	  (list 'speed-control-style speed-control-style 0 '(-1 10))
	  (list 'sync-style sync-style sync-by-sound '(-1 123))
	  (list 'transform-type transform-type fourier-transform (list (integer->transform -1) (integer->transform 123)))
	  (list 'wavelet-type wavelet-type 0 '(-1 123))
	  (list 'wavo-hop wavo-hop 1 '(0 -123))
	  (list 'wavo-trace wavo-trace 1 '(0 -123))
	  (list 'x-axis-style x-axis-style 0 '(-1 123))
	  (list 'zoom-focus-style zoom-focus-style 2 '(-1 123)))))
      
      (set! *sync-style* sync-none)
      
      (set! (window-width) 300)
      (set! (window-height) 300)
      (if (<= (window-width) 30)
	  (snd-display "window width: ~A is not 300?" (window-width)))
      (if (<= (window-height) 30)
	  (snd-display "window height: ~A is not 300?" (window-height)))
      (set! *color-scale* 100.0)
      (if (fneq *color-scale* 100.0) (snd-display "color-scale to 100: ~A" *color-scale*))
      
      (if (procedure? (search-procedure))
	  (snd-display "global search procedure: ~A?" (search-procedure)))
      (set! (search-procedure) (lambda (y) (> y .1)))
      (if (not (procedure? (search-procedure)))
	  (snd-display "set global search procedure: ~A?" (search-procedure)))
      (if (not ((search-procedure) .2))
	  (snd-display "search > .1 .2"))
      (if ((search-procedure) .02)
	  (snd-display "search > .1 .02"))
      (set! (search-procedure) (lambda (y) (< y 0.0)))
      (if ((search-procedure) .02)
	  (snd-display "search < 0.0 .02"))
      (set! (search-procedure) #f)
      (if (procedure? (search-procedure))
	  (snd-display "global search procedure after reset: ~A?" (search-procedure)))
      (set! (search-procedure) (lambda (y) (> y .1)))
      (if (not (procedure? (search-procedure)))
	  (snd-display "set global search procedure: ~A?" (search-procedure)))
      
      (set! *enved-filter-order* 5)
      (if (not (= *enved-filter-order* 6)) (snd-display "set enved-filter-order 5: ~A" *enved-filter-order*))
      (when with-gui
	(set! (enved-envelope) 'zero_to_one) ; funcs.scm above
	(if (not (feql (enved-envelope) zero_to_one)) (snd-display "set symbol enved-envelope: ~A ~A" (enved-envelope) zero_to_one))
	(set! (enved-envelope) "mod_down")
	(if (not (feql (enved-envelope) mod_down)) (snd-display "set string enved-envelope: ~A ~A" (enved-envelope) mod_down)))
      (dismiss-all-dialogs))
    (close-sound ind) 
      
    (let ((undef ())
	  (names '(*snd-opened-sound* abort add-colormap add-mark
		       add-player add-sound-file-extension add-source-file-extension add-to-main-menu add-to-menu
		       add-transform after-apply-controls-hook after-edit-hook after-graph-hook after-lisp-graph-hook
		       after-open-hook after-save-as-hook after-save-state-hook after-transform-hook all-pass
		       all-pass? amp-control amp-control-bounds amplitude-modulate
		       apply-controls array->file array-interp as-one-edit ask-about-unsaved-edits
		       ask-before-overwrite asymmetric-fm asymmetric-fm? 
		       auto-resize auto-update auto-update-interval autocorrelate autocorrelation
		       axis-color axis-info axis-label-font axis-numbers-font
		       bad-header-hook bartlett-window bartlett-hann-window basic-color beats-per-measure beats-per-minute
		       before-close-hook before-exit-hook before-save-as-hook before-save-state-hook before-transform-hook
		       bind-key blackman2-window blackman3-window blackman4-window 
		       blackman5-window blackman6-window blackman7-window blackman8-window blackman9-window blackman10-window 
		       bohman-window bold-peaks-font cauchy-window mlt-sine-window
		       cepstrum change-samples-with-origin channel->float-vector channel-amp-envs 
		       channel-properties channel-property channel-style channel-widgets channels channels-combined
		       channels-separate channels-superimposed chans clear-listener
		       clip-hook clipping clm-channel 
		       clm-table-size close-hook close-sound color->list
		       color-cutoff color-orientation-dialog color-hook color-inverted color-scale
		       color? colormap colormap-name colormap-ref colormap-size
		       colormap? comb comb? combined-data-color comment connes-window
		       continue-frample->file continue-sample->file contrast-control contrast-control-amp contrast-control-bounds
		       contrast-control? contrast-enhancement controls->channel convolution convolve
		       convolve-files convolve-selection-with convolve-with convolve? copy-context
		       copy-sampler current-edit-position
		       current-font cursor cursor-color cursor-context cursor-cross
		       cursor-in-middle cursor-in-view cursor-line cursor-location-offset cursor-on-left
		       cursor-on-right cursor-position cursor-size cursor-style cursor-update-interval
		       dac-combines-channels dac-size data-color sample-type
		       data-location data-size db->linear default-output-chans default-output-sample-type
		       default-output-header-type default-output-srate define-envelope degrees->radians delay
		       delay-tick delay? delete-colormap
		       delete-mark delete-marks delete-sample delete-samples delete-samples-and-smooth
		       delete-selection delete-selection-and-smooth delete-transform dialog-widgets disk-kspace
		       display-edits dolph-chebyshev-window dont-normalize
		       dot-product dot-size draw-axes draw-dot draw-dots
		       draw-line draw-lines draw-mark-hook draw-mix-hook draw-string drop-hook
		       during-open-hook edit-fragment edit-header-dialog edit-hook edit-list->function
		       edit-position edit-tree edits edot-product env
		       env-channel env-channel-with-base env-interp env-selection env-sound
		       env? enved-add-point enved-amplitude enved-base enved-clip?
		       enved-delete-point enved-dialog enved-envelope enved-filter enved-filter-order
		       enved-hook enved-in-dB enved-move-point enved-power enved-spectrum
		       enved-srate enved-style enved-target enved-wave? enved-waveform-color
		       envelope-exponential envelope-linear eps-bottom-margin eps-file
		       eps-left-margin eps-size even-multiple even-weight exit exit-hook
		       expand-control expand-control-bounds expand-control-hop expand-control-jitter expand-control-length
		       expand-control-ramp expand-control? exponential-window fft fft-log-frequency
		       fft-log-magnitude fft-window fft-window-alpha fft-window-beta fft-with-phases file->array
		       file->frample file->frample? file->sample file->sample? file->string
		       file-name file-write-date fill-polygon fill-rectangle filter
		       filtered-comb filtered-comb?
		       filter-channel filter-control-coeffs filter-control-envelope filter-control-in-dB filter-control-in-hz
		       filter-control-order filter-control-waveform-color filter-control? filter-selection filter-sound
		       filter? find-dialog find-mark find-sound
		       finish-progress-report fir-filter fir-filter? flat-top-window focus-widget foreground-color
		       forget-region formant formant-bank formant-bank? formant? firmant firmant? 
		       comb-bank comb-bank? all-pass-bank all-pass-bank? filtered-comb-bank filtered-comb-bank?
		       make-comb-bank make-all-pass-bank make-filtered-comb-bank
		       fourier-transform
		       free-player free-sampler gaussian-window gc-off gc-on
		       ;gl-graph->ps glSpectrogram 
		       goto-listener-end granulate granulate?
		       graph graph->ps graph-as-sonogram graph-as-spectrogram graph-as-wavogram
		       graph-color graph-cursor graph-data graph-dots graph-dots-and-lines
		       graph-filled graph-hook graph-lines graph-lollipops graph-once
		       graph-style graphs-horizontal grid-density haar-transform hamming-window
		       hann-poisson-window hann-window header-type help-dialog
		       help-hook hide-widget highlight-color html-dir html-program
		       hz->radians iir-filter iir-filter? in in-any
		       ina inb info-dialog initial-graph-hook
		       insert-file-dialog insert-region insert-sample insert-samples insert-samples-with-origin
		       insert-selection insert-silence insert-sound just-sounds kaiser-window
		       key key-binding key-press-hook keyboard-no-action  peak-env-dir
;		       ladspa-activate ladspa-cleanup ladspa-connect-port ladspa-deactivate ladspa-descriptor ladspa-dir
;		       ladspa-instantiate ladspa-run ladspa-run-adding ladspa-set-run-adding-gain list-ladspa init-ladspa apply-ladspa analyse-ladspa
		       left-sample
		       linear->db lisp-graph lisp-graph-hook lisp-graph-style lisp-graph?
		       listener-click-hook listener-color listener-font
		       listener-prompt listener-selection listener-text-color little-endian? locsig
		       locsig-ref locsig-reverb-ref locsig-reverb-set! locsig-set! locsig-type
		       locsig? log-freq-start main-menu main-widgets make-all-pass
		       make-asymmetric-fm make-moving-average make-moving-max make-moving-norm make-bezier make-color make-comb make-filtered-comb
		       make-convolve make-delay make-env make-fft-window make-file->frample
		       make-file->sample make-filter make-fir-coeffs make-fir-filter make-formant make-firmant make-formant-bank
		       make-granulate make-graph-data make-iir-filter
		       make-locsig make-mix-sampler make-move-sound make-notch make-one-pole make-one-pole-all-pass
		       make-one-zero make-oscil make-phase-vocoder make-player make-polyshape make-polywave
		       make-pulse-train make-rand make-rand-interp make-readin
		       make-region make-region-sampler make-sample->file make-sampler make-sawtooth-wave
		       make-nrxysin make-nrxycos make-rxyk!cos make-rxyk!sin 
		       make-snd->sample make-square-wave
		       make-src make-ssb-am make-ncos make-nsin make-table-lookup
		       make-triangle-wave make-two-pole make-two-zero
		       make-variable-graph make-float-vector make-wave-train 
		       map-channel mark-click-hook mark-color mark-context
		       mark-drag-hook mark-home mark-hook mark-name mark-properties mark-property
		       mark-sample mark-sync mark-sync-max mark-tag-height mark-tag-width
		       mark? marks max-regions max-transform-peaks maxamp
		       maxamp-position menu-widgets min-dB mix
		       mix-amp mix-amp-env mix-click-hook mix-color
		       mix-dialog-mix mix-drag-hook mix-file-dialog mix-length mix-home
		       mix-name mix-position mix-properties mix-property mix-region mix-release-hook mix-sync mix-sync-max
		       mix-sampler? mix-selection mix-speed mix-tag-height
		       mix-tag-width mix-tag-y
		       mix-float-vector mix-waveform-height mix?
		       mixes mouse-click-hook mouse-drag-hook mouse-enter-graph-hook
		       mouse-enter-label-hook mouse-enter-listener-hook mouse-enter-text-hook mouse-leave-graph-hook mouse-leave-label-hook
		       mouse-leave-listener-hook mouse-leave-text-hook mouse-press-hook move-locsig move-sound move-sound? 
		       moving-average moving-average? moving-max moving-max? moving-norm moving-norm?
		       mus-aifc mus-aiff mus-alaw mus-alsa-buffer-size mus-alsa-buffers
		       mus-alsa-capture-device mus-alsa-device mus-alsa-playback-device mus-alsa-squelch-warning mus-apply
		       mus-array-print-length mus-float-equal-fudge-factor 
		       mus-b24int mus-bdouble mus-bdouble-unscaled
		       mus-bfloat mus-bfloat-unscaled mus-bicsf mus-bint mus-bintn
		       mus-bshort mus-byte mus-bytes-per-sample mus-caff mus-channel mus-channels
		       mus-chebyshev-first-kind mus-chebyshev-second-kind mus-clipping mus-close
		       mus-data mus-sample-type->string mus-sample-type-name mus-describe mus-error-hook
		       mus-error-type->string mus-expand-filename mus-feedback mus-feedforward mus-fft
		       mus-file-buffer-size mus-file-clipping mus-file-name
		       mus-frequency mus-generator? mus-header-raw-defaults mus-header-type->string mus-header-type-name
		       mus-hop mus-increment mus-input? mus-interp-all-pass mus-interp-bezier
		       mus-interp-hermite mus-interp-lagrange mus-interp-linear mus-interp-none mus-interp-sinusoidal
		       mus-interp-type mus-interpolate mus-ircam mus-l24int mus-ldouble
		       mus-ldouble-unscaled mus-length mus-lfloat mus-lfloat-unscaled mus-lint
		       mus-lintn mus-location mus-lshort mus-max-malloc mus-max-table-size
		       mus-file-mix mus-mulaw mus-name 
		       mus-next mus-nist mus-offset mus-order mus-oss-set-buffers
		       mus-out-format mus-output? mus-phase mus-ramp
		       mus-rand-seed mus-random mus-raw mus-reset mus-riff
		       mus-run mus-scaler mus-set-formant-radius-and-frequency mus-sound-chans 
		       mus-sound-comment mus-sound-sample-type mus-sound-data-location mus-sound-datum-size
		       mus-sound-duration mus-sound-forget mus-sound-framples mus-sound-header-type mus-sound-length
		       mus-sound-loop-info mus-sound-mark-info mus-sound-maxamp mus-sound-maxamp-exists? mus-sound-path
		       mus-sound-prune mus-sound-report-cache mus-sound-samples
		       mus-sound-srate mus-sound-type-specifier mus-sound-write-date
		       mus-soundfont mus-srate mus-svx mus-ubshort
		       mus-ubyte mus-ulshort mus-unknown-sample mus-unknown-header mus-voc
		       mus-width mus-xcoeff mus-xcoeffs mus-ycoeff mus-ycoeffs
		       name-click-hook new-sound new-sound-dialog new-sound-hook new-widget-hook
		       next-sample normalize-by-channel normalize-by-sound normalize-channel normalize-globally
		       notch notch? odd-multiple odd-weight one-pole one-pole? one-pole-all-pass one-pole-all-pass? 
		       one-zero one-zero? open-file-dialog open-file-dialog-directory open-hook open-raw-sound open-raw-sound-hook
		       open-sound
		       orientation-hook oscil oscil? out-any outa
		       outb outc outd output-comment-hook
		       override-samples-with-origin pad-channel partials->polynomial partials->wave
		       parzen-window pausing peaks peaks-font
		       phase-partials->wave phase-vocoder phase-vocoder-amp-increments phase-vocoder-amps phase-vocoder-freqs
		       phase-vocoder-phase-increments phase-vocoder-phases phase-vocoder? play play-arrow-size
		       play-hook player-home player? players
		       playing poisson-window polar->rectangular polynomial polyshape polywave
		       polyshape? polywave? position->x position->y position-color preferences-dialog
		       previous-sample print-dialog print-length progress-report
		       pulse-train
		       pulse-train? radians->degrees radians->hz
		       ramp-channel rand rand-interp rand-interp? rand?
		       read-mix-sample read-only read-region-sample
		       read-sample readin readin? 
		       rectangular->magnitudes rectangular->polar rectangular-window redo redo-edit
		       region->float-vector region-chans region-home region-framples region-graph-style region-maxamp
		       region-maxamp-position region-position region-sample region-sampler? region-srate
		       region? regions remember-sound-state remove-from-menu status-report
		       reset-controls reset-listener-cursor restore-controls restore-region
		       reverb-control-decay reverb-control-feedback reverb-control-length reverb-control-length-bounds reverb-control-lowpass
		       reverb-control-scale reverb-control-scale-bounds reverb-control? reverse-channel reverse-selection
		       reverse-sound revert-sound riemann-window right-sample ring-modulate
		       rv2-window rv3-window rv4-window 
		       samaraki-window sample sample->file
		       sample->file? sampler-at-end? sampler-home sampler-position
		       sampler? samples samples->seconds sash-color
		       save-controls save-dir save-edit-history save-envelopes save-hook
		       save-listener save-marks save-region save-region-dialog
		       save-selection save-selection-dialog save-sound save-sound-as save-sound-dialog
		       save-state save-state-file save-state-hook sawtooth-wave sawtooth-wave?
		       scale-by scale-channel scale-selection-by scale-selection-to scale-to
		       scan-channel script-arg script-args search-procedure
		       seconds->samples select-all select-channel select-channel-hook select-sound
		       select-sound-hook selected-channel selected-data-color selected-graph-color selected-sound
		       selection-chans selection-color selection-context selection-creates-region
		       selection-framples selection-maxamp selection-maxamp-position selection-member? selection-position
		       selection-srate selection?
		       short-file-name show-all-axes show-all-axes-unlabelled show-bare-x-axis
		       show-axes show-controls show-grid show-indices show-full-duration show-full-range initial-beg initial-dur
		       show-listener show-marks show-mix-waveforms show-no-axes show-selection show-selection-transform
		       show-sonogram-cursor show-transform-peaks show-widget show-x-axis show-x-axis-unlabelled
		       show-y-zero sinc-width nrxysin nrxysin? nrxycos nrxycos? rxyk!cos rxyk!cos? rxyk!sin rxyk!sin? 
		       smooth-channel smooth-selection smooth-sound snd->sample snd->sample?
		       snd-error snd-error-hook snd-gcs snd-help snd-font snd-color
		       snd-print snd-spectrum snd-tempnam snd-url
		       snd-urls snd-version snd-warning snd-warning-hook 
		       sound-file-extensions sound-file? sound-files-in-directory
		       sound-loop-info sound-properties sound-property sound-widgets sound? soundfont-info
		       sounds spectrum-end spectro-hop spectrum-start spectro-x-angle
		       spectro-x-scale spectro-y-angle spectro-y-scale spectro-z-angle spectro-z-scale
		       spectrum speed-control speed-control-as-float speed-control-as-ratio speed-control-as-semitone
		       speed-control-bounds speed-control-style speed-control-tones square-wave square-wave?
		       squelch-update srate src src-channel src-selection
		       src-sound src? ssb-am ssb-am?
		       start-playing start-playing-hook start-playing-selection-hook start-progress-report stdin-prompt
		       stop-player stop-playing stop-playing-hook stop-playing-selection-hook ncos
		       ncos? nsin nsin? swap-channels sync sync-style sync-none sync-all sync-by-sound
		       sync-max syncd-marks table-lookup table-lookup? tap tap?
		       temp-dir text-focus-color time-graph time-graph-style
		       time-graph-type time-graph? tiny-font 
		       tracking-cursor-style transform->float-vector
		       transform-dialog transform-framples transform-graph transform-graph-style transform-graph-type
		       transform-graph? transform-normalization transform-sample transform-size transform-type
		       transform? triangle-wave triangle-wave? tukey-window
		       two-pole two-pole? two-zero two-zero? ultraspherical-window
		       unbind-key  undo undo-edit undo-hook unselect-all update-hook update-lisp-graph
		       update-sound update-time-graph update-transform-graph variable-graph? float-vector
		       float-vector* float-vector+ float-vector->channel
		       float-vector->string float-vector-add!
		       length float-vector-max float-vector-min float-vector-move!
		       float-vector-multiply! float-vector-offset! float-vector-peak float-vector-ref reverse!
		       float-vector-scale! float-vector-set! float-vector-subseq float-vector-subtract! float-vector?
		       walsh-transform
		       wave-train wave-train? wavelet-transform wavelet-type
		       wavo-hop wavo-trace welch-window widget-position
		       widget-size widget-text window-height
		       window-width window-x window-y with-background-processes with-file-monitor with-gl
		       with-mix-tags with-relative-panes with-tracking-cursor with-verbose-cursor 
		       with-inset-graph with-interrupts with-pointer-focus with-smpte-label with-toolbar with-tooltips with-menu-icons
		       save-as-dialog-src save-as-dialog-auto-comment
		       x->position x-axis-as-clock x-axis-as-percentage x-axis-in-beats x-axis-in-measures
		       x-axis-in-samples x-axis-in-seconds x-axis-label x-axis-style x-bounds
		       x-position-slider x-zoom-slider xramp-channel y->position y-axis-label
		       y-bounds y-position-slider y-zoom-slider zero-pad zoom-color
		       zoom-focus-active zoom-focus-left zoom-focus-middle zoom-focus-right zoom-focus-style)))
      (for-each
       (lambda (n)
	 (if (not (defined? n))
	     (set! undef (cons n undef))))
       names)
      (if (pair? undef)
	  (snd-display "undefined: ~A" undef)))))


;;; ---------------- test 4: sndlib ----------------

(if (or (not (provided? 'snd-examp.scm))
	(and (defined? 'ramp) ; why this? protection against funcs?
	     (list? ramp)))
    (load "examp.scm"))

(require snd-mix.scm snd-env.scm)

(define (snd_test_4)
  
  (do ((clmtest 0 (+ 1 clmtest))) 
      ((= clmtest tests)) 
    (log-mem clmtest)
    (clear-listener)

    (let ((mz (mus-sound-maxamp "z.snd")))
      (if (or (not (= (car mz) 0))
	      (fneq (cadr mz) 0.0))
	  (snd-display "mus-sound-maxamp z.snd: ~A (~A ~A)" mz (not (= (car mz) 0)) (fneq (cadr mz) 0.0))))
    (let ((formats (list mus-bshort mus-lshort mus-mulaw mus-alaw mus-byte mus-ubyte mus-bfloat mus-lfloat
			 mus-bint mus-lint mus-bintn mus-lintn mus-b24int mus-l24int mus-bdouble mus-ldouble
			 mus-ubshort mus-ulshort mus-bdouble-unscaled mus-ldouble-unscaled mus-bfloat-unscaled 
			 mus-lfloat-unscaled))
	  (sizes (list 2 2 1 1 1 1 4 4 
		       4 4 4 4 3 3 8 8
		       2 2 8 8 4
		       4)))
      (for-each
       (lambda (frm siz)
	 (if (not (= (mus-bytes-per-sample frm) siz))
	     (snd-display "mus-bytes-per-sample ~A: ~A" (mus-sample-type-name frm) siz)))
       formats
       sizes))
    (if (not (string=? (mus-sample-type->string mus-bshort) "mus-bshort"))
	(snd-display "mus-sample-type->string: ~A" (mus-sample-type->string mus-bshort)))
    (if (not (string=? (mus-header-type->string mus-aifc) "mus-aifc"))
	(snd-display "mus-header-type->string: ~A" (mus-header-type->string mus-aifc)))
    (mus-sound-report-cache "hiho.tmp")
    (let* ((p (open-input-file "hiho.tmp"))
	   (line (read-line p)))
      (if (not (member line '("sound table:" "sound table:\n")))
	  (snd-display "print-cache 1: ~A?" line))
      (close-input-port p)
      (delete-file "hiho.tmp"))
    (let ((chns (mus-sound-chans "oboe.snd")))
      (if (not (= chns 1)) (snd-display "oboe: mus-sound-chans ~D?" chns)))
    (if (= clmtest 0)
	(let ((m1 (mus-sound-maxamp-exists? "oboe.snd")))
	  (if (and m1 (= clmtest 0)) (snd-display "oboe: mus-sound-maxamp-exists before maxamp: ~A" m1))
	  (let ((mal (mus-sound-maxamp "oboe.snd")))
	    (if (fneq (cadr mal) .14724) (snd-display "oboe: mus-sound-maxamp ~F?" (cadr mal)))
	    (if (not (= (car mal) 24971)) (snd-display "oboe: mus-sound-maxamp at ~D?" (car mal))))
	  (if (not (mus-sound-maxamp-exists? "oboe.snd")) 
	      (snd-display "oboe: not mus-sound-maxamp-exists after maxamp: ~A" (mus-sound-maxamp-exists? "oboe.snd")))))
    (let ((dl (mus-sound-data-location "oboe.snd")))
      (if (not (= dl 28)) (snd-display "oboe: mus-sound-data-location ~D (~A)?" dl (= dl 28))))
    (let ((fr (mus-sound-framples "oboe.snd")))
      (if (not (= fr 50828)) (snd-display "oboe: mus-sound-framples ~D?" fr)))
    (let ((smps (mus-sound-samples "oboe.snd")))
      (if (not (= smps 50828)) (snd-display "oboe: mus-sound-samples ~D?" smps)))
    (let ((len (mus-sound-length "oboe.snd")))
      (if (not (= len 101684)) (snd-display "oboe: mus-sound-length ~D?" len)))
    (let ((size (mus-sound-datum-size "oboe.snd")))
      (if (not (= size 2)) (snd-display "oboe: mus-sound-datum-size ~D?" size)))
    (let ((bytes (mus-bytes-per-sample (mus-sound-sample-type "oboe.snd"))))
      (if (not (= bytes 2)) (snd-display "oboe: sound-bytes ~D?" bytes)))
    (let ((sr (mus-sound-srate "oboe.snd")))
      (if (not (= sr 22050)) (snd-display "oboe: mus-sound-srate ~D?" sr)))
    
    (if (= clmtest 0)
	(let ((vals (mus-header-raw-defaults)))
	  (if (not (and (pair? vals)
			(= (length vals) 3)))
	      (snd-display "mus-header-raw-defaults: ~A" vals)
	      (let ((sr (car vals))
		    (chns (cadr vals))
		    (frm (caddr vals)))
		(if (not (= sr 44100)) (snd-display "mus-header-raw-defaults srate: ~A" sr))
		(if (not (= chns 2)) (snd-display "mus-header-raw-defaults chns: ~A" chns))
		(if (not (= frm mus-bshort)) (snd-display "mus-header-raw-defaults format: ~A: ~A" frm (mus-sample-type-name frm)))))))
    (set! (mus-header-raw-defaults) (list 12345 3 mus-bdouble-unscaled))
    (let ((vals (mus-header-raw-defaults)))
      (if (not (and (pair? vals)
		    (= (length vals) 3)))
	  (snd-display "set mus-header-raw-defaults: ~A" vals)
	  (let ((sr (car vals))
		(chns (cadr vals))
		(frm (caddr vals)))
	    (if (not (= sr 12345)) (snd-display "set mus-header-raw-defaults srate: ~A" sr))
	    (if (not (= chns 3)) (snd-display "set mus-header-raw-defaults chns: ~A" chns))
	    (if (not (= frm mus-bdouble-unscaled)) (snd-display "set mus-header-raw-defaults format: ~A: ~A" frm (mus-sample-type-name frm))))))
    (set! (mus-header-raw-defaults) (list 44100 2 mus-bshort))
    
    (let ((str (strftime "%d-%b %H:%M %Z" (localtime (mus-sound-write-date "oboe.snd")))))
      (if (not (string=? str "23-Nov 06:56 PST"))
	  (snd-display "mus-sound-write-date oboe.snd: ~A?" str)))
    (let ((str (strftime "%d-%b %H:%M %Z" (localtime (mus-sound-write-date "pistol.snd")))))
      (if (not (string=? str "23-Nov 06:56 PST"))
	  (snd-display "mus-sound-write-date pistol.snd: ~A?" str)))
    
    (let ((long-file-name (do ((name "test" (string-append name "-test"))
			       (i 0 (+ i 1)))
			      ((= i 10)
			       (string-append name ".snd")))))
      (let ((index (open-sound "oboe.snd")))
	(if (variable-graph? index) (snd-display "variable-graph thinks anything is a graph..."))
	(if (player? index) (snd-display "player? thinks anything is a player..."))
	(if (not (sound? index)) (snd-display "~A is not a sound?" index))
	(if (sound? #f) (snd-display "sound? #f -> #t?"))
	(if (sound? #t) (snd-display "sound? #t -> #t?"))
	(save-sound-as long-file-name index)
	(close-sound index))
      (let ((index (open-sound long-file-name)))
	(if (not (sound? index)) (snd-display "can't find test...snd"))
	(if (or (< (length (file-name index)) (length long-file-name))
		(< (length (short-file-name index)) (length long-file-name)))
	    (snd-display "file-name lengths: ~A ~A ~A"
			 (length (file-name index))
			 (length (short-file-name index))
			 (length long-file-name)))
	(close-sound index))
      (mus-sound-forget long-file-name)
      (delete-file long-file-name))
		       
    (let ((new-path (if (provided? 'osx) "/Users/bil/sf1" "/home/bil/sf1")))
      (let-temporarily ((*mus-sound-path* (list new-path)))
	(let ((ind (catch #t (lambda () (open-sound "o2.bicsf")) (lambda args #f))))
	  (if (not (sound? ind))
	      (snd-display "*mus-sound-path*: ~A~%" ind)
	      (begin
		(close-sound ind)
		(set! (mus-sound-path) (list new-path))
		(set! ind (catch #t (lambda () (open-sound "o2.bicsf")) (lambda args #f)))
		(if (sound? ind)
		    (close-sound ind)
		    (snd-display "(mus-sound-path): ~A~%" ind)))))))
    
    (let ((fsnd (string-append sf-dir "forest.aiff")))
      (when (file-exists? fsnd)
	(system (format #f "cp ~A fmv.snd" fsnd))
	(let ((index (open-sound "fmv.snd")))
	  (if (not (equal? (sound-loop-info index) (mus-sound-loop-info fsnd)))
	      (snd-display "loop-info: ~A ~A" (sound-loop-info index) (mus-sound-loop-info fsnd)))
	  (set! (sound-loop-info index) (list 12000 14000 1 2 3 4))
	  (if (not (equal? (sound-loop-info index) '(12000 14000 1 2 3 4 1 1)))
	      (snd-display "set loop-info: ~A" (sound-loop-info index)))
	  (save-sound-as "fmv1.snd" index :header-type mus-aifc)
	  (close-sound index)
	  (if (not (equal? (mus-sound-loop-info "fmv1.snd") '(12000 14000 1 2 3 4 1 1)))
	      (snd-display "saved loop-info: ~A" (mus-sound-loop-info "fmv1.snd"))))))
    (let ((index (open-sound "oboe.snd")))
      (save-sound-as "fmv.snd" index :header-type mus-aifc)
      (close-sound index))
    (let ((index (open-sound "fmv.snd")))
      (if (not (null? (sound-loop-info index)))
	  (snd-display "null loop-info: ~A" (sound-loop-info index)))
      (set! (sound-loop-info index) (list 1200 1400 4 3 2 1))
      (if (not (equal? (sound-loop-info index) '(1200 1400 4 3 2 1 1 1)))
	  (snd-display "set null loop-info: ~A" (sound-loop-info index)))
      (save-sound-as "fmv1.snd" :sound index :header-type mus-aifc)
      (close-sound index)
      (if (not (equal? (mus-sound-loop-info "fmv1.snd") '(1200 1400 4 3 2 1 1 1)))
	  (snd-display "saved null loop-info: ~A" (mus-sound-loop-info "fmv1.snd"))))
    (let ((index (open-sound "fmv.snd")))
      (set! (sound-loop-info) (list 1200 1400 4 3 2 1 1 0))
      (if (not (equal? (sound-loop-info index) '(1200 1400 0 0 2 1 1 0)))
	  (snd-display "set null loop-info (no mode1): ~A" (sound-loop-info index)))
      (save-sound-as "fmv1.snd" index :header-type mus-aifc)
      (close-sound index)
      (if (not (equal? (mus-sound-loop-info "fmv1.snd") '(1200 1400 0 0 2 1 1 0)))
	  (snd-display "saved null loop-info (no mode1): ~A" (mus-sound-loop-info "fmv1.snd"))))
    
    (for-each 
     (lambda (file&comment)
       (let ((file (car file&comment))
	     (comment (cadr file&comment)))
	 (let ((fsnd (string-append sf-dir file)))
	   (when (file-exists? fsnd)
	     (let ((com (mus-sound-comment fsnd)))
	       (if (not (equal? com comment))
		   (snd-display "mus-sound-comment ~S -> ~A?" file com)))))))
     '(("oboe.snd" "")
       ("nasahal8.wav" "ICRD: 1997-02-22\nIENG: Paul R. Roger\nISFT: Sound Forge 4.0\n")
       ("8svx-8.snd" "File created by Sound Exchange  ") 
       ("sun-16-afsp.snd" "AFspdate:1981/02/11 23:03:34 UTC")
       ("smp-16.snd" "Converted using Sox.                                        ")
       ("d40130.au" "1994 Jesus Villena")
       ("wood.maud" "file written by SOX MAUD-export ")
       ("addf8.sf_mipseb" "date=\"Feb 11 18:03:34 1981\" info=\"Original recorded at 20 kHz, 15-bit D/A, digitally filtered and resampled\" speaker=\"AMK female\" text=\"Add the sum to the product of these three.\" ")
       ("mary-sun4.sig" "MARY HAD A LITTLE LAMB\n")
       ("nasahal.pat" "This patch saved with Sound Forge 3.0.")
       ("next-16.snd" ";Written on Mon 1-Jul-91 at 12:10 PDT  at localhost (NeXT) using Allegro CL and clm of 25-June-91")
       ("wood16.nsp" "Created by Snack   ") 
       ("wood.sdx" "1994 Jesus Villena")
       ("clmcom.aif" "this is a comment") 
       ("anno.aif" "1994 Jesus Villena\n")
       ("telephone.wav" "sample_byte_format -s2 01\nchannel_count -i 1\nsample_count -i 36461\nsample_rate -i 16000\nsample_n_bytes -i 2\nsample_sig_bits -i 16\n")))
    
    (if (not (string? (mus-sound-comment (string-append sf-dir "traffic.aiff"))))
	(snd-display "mus-sound-comment traffic: ~A" (mus-sound-comment (string-append sf-dir "traffic.aiff"))))
    
    (if (not (member (mus-sound-type-specifier "oboe.snd") '(#x646e732e #x2e736e64) =))
	(snd-display "oboe: mus-sound-type-specifier: ~X?" (mus-sound-type-specifier "oboe.snd")))
    (if (not (string=? (strftime "%d-%b-%Y %H:%M" (localtime (file-write-date "oboe.snd"))) "23-Nov-2012 06:56"))
	(snd-display "oboe: file-write-date: ~A?" (strftime "%d-%b-%Y %H:%M" (localtime (file-write-date "oboe.snd")))))
    
    (let ((lasth (do ((i 1 (+ i 1)))
		     ((string=? (mus-header-type-name i) "unknown") i))))
      (if (< lasth 50) (snd-display "header-type[~A] = ~A" lasth (mus-header-type-name lasth))))
    (let ((lasth (do ((i 1 (+ i 1)))
		     ((string=? (mus-sample-type-name i) "unknown") i))))
      (if (< lasth 10) (snd-display "sample-type[~A] = ~A" lasth (mus-sample-type-name lasth))))
    
    (when with-gui
      (set! *transform-normalization* dont-normalize)
      (if (not (= *transform-normalization* dont-normalize))
	  (snd-display "set-transform-normalization none -> ~A" *transform-normalization*))
      (set! *transform-normalization* normalize-globally)
      (if (not (= *transform-normalization* normalize-globally))
	  (snd-display "set-transform-normalization globally -> ~A" *transform-normalization*))
      (set! *transform-normalization* normalize-by-channel)
      (if (not (= *transform-normalization* normalize-by-channel))
	  (snd-display "set-transform-normalization channel -> ~A" *transform-normalization*)))
    
    (let ((ind (new-sound "fmv.snd" 1 22050 mus-ldouble mus-next "set-samples test" 100)))
      (set! (samples 10 3) (make-float-vector 3 .1))
      (if (not (mus-arrays-equal? (channel->float-vector 0 20 ind 0) #r(0 0 0 0 0 0 0 0 0 0 .1 .1 .1 0 0 0 0 0 0 0)))
	  (snd-display "1 set samples 0 for .1: ~A" (channel->float-vector 0 20 ind 0)))
      (set! (samples 20 3 ind 0) (make-float-vector 3 .1))
      (if (not (mus-arrays-equal? (channel->float-vector 10 20 ind 0) #r(.1 .1 .1 0 0 0 0 0 0 0 .1 .1 .1 0 0 0 0 0 0 0)))
	  (snd-display "2 set samples 10 for .1: ~A" (channel->float-vector 10 20 ind 0)))
      (set! (samples 30 3 ind 0 #f "a name") (make-float-vector 3 .1))
      (if (not (mus-arrays-equal? (channel->float-vector 20 20 ind 0) #r(.1 .1 .1 0 0 0 0 0 0 0 .1 .1 .1 0 0 0 0 0 0 0)))
	  (snd-display "3 set samples 20 for .1: ~A" (channel->float-vector 20 20 ind 0)))
      (set! (samples 0 3 ind 0 #f "a name" 0 1) (make-float-vector 3 .2))
      (if (not (mus-arrays-equal? (channel->float-vector 0 20 ind 0) #r(.2 .2 .2 0 0 0 0 0 0 0 .1 .1 .1 0 0 0 0 0 0 0)))
	  (snd-display "4 set samples 0 at 1 for .1: ~A" (channel->float-vector 0 20 ind 0)))
      (if (not (mus-arrays-equal? (channel->float-vector 20 20 ind 0) (make-float-vector 20)))
	  (snd-display "5 set samples 20 at 1 for .1: ~A" (channel->float-vector 0 20 ind 0)))
      (let ((nd (new-sound "fmv1.snd" :channels 2)))
	(float-vector->channel (make-float-vector 10 .5) 0 10 nd 0)
	(float-vector->channel (make-float-vector 10 .3) 0 10 nd 1)
	(save-sound-as "fmv1.snd" nd)
	(close-sound nd))
      (if (not (file-exists? "fmv1.snd")) (snd-display "fmv1 not saved??"))
      (set! (samples 0 10 ind 0 #f "another name" 1) "fmv1.snd")
      (if (not (mus-arrays-equal? (channel->float-vector 0 20 ind 0) #r(.3 .3 .3 .3 .3 .3 .3 .3 .3 .3 .1 .1 .1 0 0 0 0 0 0 0)))
	  (snd-display "6 set samples 0 at 1 for .1: ~A" (channel->float-vector 0 20 ind 0)))
      (set! (samples 5 6 ind 0 #f "another name 7" 0) "fmv1.snd")
      (if (not (mus-arrays-equal? (channel->float-vector 0 20 ind 0) #r(.3 .3 .3 .3 .3 .5 .5 .5 .5 .5 .5 .1 .1 0 0 0 0 0 0 0)))
	  (snd-display "7 set samples 0 at 1 for .1: ~A" (channel->float-vector 0 20 ind 0)))
      (revert-sound ind)
      (set! (samples 0 10 ind 0 #f "another name 8" 1 0 #f) "fmv1.snd")
      (if (not (mus-arrays-equal? (channel->float-vector 0 20 ind 0) #r(.3 .3 .3 .3 .3 .3 .3 .3 .3 .3 0 0 0 0 0 0 0 0 0 0)))
	  (snd-display "8 set samples 0 at 1 for .1: ~A" (channel->float-vector 0 20 ind 0)))
      (set! (samples 10 10 ind 0 #f "another name 9" 0 0) "fmv1.snd")
      (if (not (mus-arrays-equal? (channel->float-vector 0 20 ind 0) #r(0 0 0 0 0 0 0 0 0 0 .5 .5 .5 .5 .5 .5 .5 .5 .5 .5)))
	  (snd-display "9 set samples 0 at 1 for .1: ~A" (channel->float-vector 0 20 ind 0)))
      (set! (samples 20 10) "fmv1.snd")
      (if (not (mus-arrays-equal? (channel->float-vector 10 20 ind 0) (make-float-vector 20 .5)))
	  (snd-display "10 set samples 0 at 1 for .1: ~A" (channel->float-vector 10 20 ind 0)))
      (revert-sound ind)
      (set! (samples 0 10 ind 0 #t "another name" 1 0 #f) "fmv1.snd")
      (if (not (= (framples ind 0) 10)) (snd-display "11 set-samples truncate to ~A" (framples ind 0)))
      (revert-sound ind)
      (delete-file "fmv1.snd")
      
      ;; now try to confuse it
      (let ((tag (catch #t 
		   (lambda () (set! (samples 0 10 ind 0) "fmv1.snd") #f)
		   (lambda args (car args)))))
	(if (not (eq? tag 'no-such-file)) (snd-display "set-samples, no such file: ~A" tag)))
      (let ((nd (new-sound "fmv1.snd" :channels 1)))
	(float-vector->channel (make-float-vector 10 .5) 0 10 nd 0)
	(save-sound-as "fmv1.snd" nd)
	(close-sound nd))
      (let ((tag (catch #t
		   (lambda () (set! (samples 0 10 ind 0 #f "another name" 1) "fmv1.snd") #f) ; chan 1 does not exist
		   (lambda args (car args)))))
	(if (not (eq? tag 'no-such-channel)) (snd-display "set-samples no such channel: ~A" tag)))
      (let ((tag (catch #t
		   (lambda () (set! (samples 0 10 ind 0 #f "another name" -1) "fmv1.snd") #f)
		   (lambda args (car args)))))
	(if (not (eq? tag 'no-such-channel)) (snd-display "set-samples no such channel (-1): ~A" tag)))
      (let ((tag (catch #t
		   (lambda () (set! (samples 0 -10) "fmv1.snd") #f)
		   (lambda args (car args)))))
	(if (not (eq? tag 'wrong-type-arg)) (snd-display "set-samples (-10): ~A" tag)))
      (let ((tag (catch #t
		   (lambda () (set! (samples -10 10) "fmv1.snd") #f)
		   (lambda args (car args)))))
	(if (not (eq? tag 'no-such-sample)) (snd-display "set-samples (beg -10): ~A" tag)))
      (close-sound ind))
    
    (let ((len 100))
      (for-each
       (lambda (type allowed-diff)
	 (let ((v (make-float-vector len)))
	   (copy #r(0.999 -1.0 .1 -.1 .001 -.001 0.0) v)
	   (do ((i 7 (+ i 1)))
	       ((= i len))
	     (let ((val (random 1.9999)))
	       (if (not (>= 2.0 val 0.0))
		   (snd-display "random 2.0 -> ~A?" val))
	       (set! (v i) (- 1.0 val))))
	   (let ((ind (new-sound "test.snd" 1 22050 mus-ldouble mus-next)))
	     (float-vector->channel v 0 len ind 0)
	     (save-sound-as "test1.snd" ind :header-type mus-next :sample-type type)
	     (close-sound ind))
	   (let* ((ind (open-sound "test1.snd"))
		  (v1 (channel->float-vector 0 len ind 0)))
	     (do ((maxdiff 0.0)
		  (maxpos #f)
		  (i 0 (+ i 1)))
		 ((= i len)
		  (if (> maxdiff allowed-diff)
		      (snd-display "[line 2841] ~A: ~A at ~A (~A ~A)" 
				   (mus-sample-type-name type) 
				   maxdiff maxpos 
				   (v maxpos) (v1 maxpos))))
	       (let ((diff (abs (- (v i) (v1 i)))))
		 (when (> diff maxdiff)
		   (set! maxdiff diff)
		   (set! maxpos i))))
	     (close-sound ind))))
       (list mus-bshort   mus-lshort   mus-mulaw   mus-alaw   mus-byte  
	     mus-lfloat   mus-bint     mus-lint    mus-b24int mus-l24int
	     mus-ubshort  mus-ulshort  mus-ubyte   mus-bfloat mus-bdouble 
	     mus-ldouble)
       (list (expt 2 -15) (expt 2 -15) 0.02 0.02 (expt 2 -7)
	     (expt 2 -23) (expt 2 -23) (expt 2 -23) (expt 2 -23) (expt 2 -23) ; assuming sndlib bits=24 here (if int)
	     (expt 2 -15) (expt 2 -15) (expt 2 -7) (expt 2 -23) (expt 2 -23)
	     (expt 2 -23))))
    
    (let* ((ob (view-sound "oboe.snd"))
	   (samp (sample 1000 ob)))
      (let ((old-comment (mus-sound-comment "oboe.snd")))
	(let ((str (string-append "written " 
				  (strftime "%a %d-%b-%Y %H:%M %Z" 
					    (localtime (current-time))))))
	  (set! (comment ob) str)
	  (let ((tag (catch #t
		       (lambda ()
			 (save-sound-as "test.snd" ob :header-type mus-aifc :sample-type mus-bdouble))
		       (lambda args (car args)))))
	    (if (eq? tag 'cannot-save) (snd-display "save-sound-as test.snd write trouble")))
	  (set! *filter-control-in-hz* #t)
	  (let ((ab (open-sound "test.snd")))
	    (if (not (= (header-type ab) mus-aifc)) 
		(snd-display "save-as aifc -> ~A?" (mus-header-type-name (header-type ab))))
	    (if (not (= (mus-sound-header-type "test.snd") mus-aifc)) 
		(snd-display "saved-as aifc -> ~A?" (mus-header-type-name (mus-sound-header-type "test.snd"))))
	    (if (fneq (sample 1000 ab) samp) (snd-display "aifc[1000] = ~A?" (sample 1000 ab)))
	    (if (not (equal? (mus-sound-comment "test.snd") str))
		(snd-display "output-comment: ~A ~A" (mus-sound-comment "test.snd") str))
	    (if (not (equal? (comment ab) str))
		(snd-display "output-comment (comment): ~A ~A" (comment ab) str))
	    (close-sound ab)))
	(if (not (equal? old-comment (mus-sound-comment "oboe.snd")))
	    (snd-display "set-comment overwrote current ~A ~A" old-comment (mus-sound-comment "oboe.snd"))))
      (set! *filter-control-in-hz* #f)
      (save-sound-as "test.snd" ob :header-type mus-raw)
      (let ((ab (open-raw-sound "test.snd" 1 22050 mus-bshort)))
	(if (not (= (header-type ab) mus-raw)) 
	    (snd-display "save-as raw -> ~A?" (mus-header-type-name (header-type ab))))
	(if (not (= (mus-sound-header-type "test.snd") mus-raw)) 
	    (snd-display "saved-as raw -> ~A?" (mus-header-type-name (mus-sound-header-type "test.snd"))))
	(if (fneq (sample 1000 ab) samp) (snd-display "raw[1000] = ~A?" (sample 1000 ab)))
	(close-sound ab))
      (save-sound-as "test.snd" ob :header-type mus-nist :sample-type mus-bint)
      (let ((ab (open-sound "test.snd")))
	(if (not (= (header-type ab) mus-nist)) 
	    (snd-display "save-as nist -> ~A?" (mus-header-type-name (header-type ab))))
	(if (not (= (mus-sound-header-type "test.snd") mus-nist)) 
	    (snd-display "saved-as nist -> ~A?" (mus-header-type-name (mus-sound-header-type "test.snd"))))
	(if (not (= (sample-type ab) mus-bint)) 
	    (snd-display "save-as int -> ~A?" (mus-sample-type-name (sample-type ab))))
	(if (not (= (mus-sound-sample-type "test.snd") mus-bint)) 
	    (snd-display "saved-as int -> ~A?" (mus-sample-type-name (mus-sound-sample-type "test.snd"))))
	(if (fneq (sample 1000 ab) samp) (snd-display "nist[1000] = ~A?" (sample 1000 ab)))
	(close-sound ab))
      (set! (hook-functions output-comment-hook) ())
      (hook-push output-comment-hook
		 (lambda (hook) 
		   (set! (hook 'result) (string-append (hook 'comment) " [written by me]"))))
      (save-sound-as :file "test.snd" :sound ob :header-type mus-riff :sample-type mus-lfloat)
      (set! (hook-functions output-comment-hook) ())
      (let ((ab (open-sound "test.snd")))
	(if (not (= (header-type ab) mus-riff)) 
	    (snd-display "save-as riff -> ~A?" (mus-header-type-name (header-type ab))))
	(if (not (= (mus-sound-header-type "test.snd") mus-riff)) 
	    (snd-display "saved-as riff -> ~A?" (mus-header-type-name (mus-sound-header-type "test.snd"))))
	(if (not (= (sample-type ab) mus-lfloat)) 
	    (snd-display "save-as float -> ~A?" (mus-sample-type-name (sample-type ab))))
	(if (not (= (mus-sound-sample-type "test.snd") mus-lfloat)) 
	    (snd-display "saved-as float -> ~A?" (mus-sample-type-name (mus-sound-sample-type "test.snd"))))
	(if (fneq (sample 1000 ab) samp) (snd-display "riff[1000] = ~A?" (sample 1000 ab)))
	(if (not (equal? (comment ab) 
			 (string-append "written " 
					(strftime "%a %d-%b-%Y %H:%M %Z" (localtime (current-time)))
					" [written by me]")))
	    (snd-display "output-comment-hook: ~A~%(~A)" (comment ab) (mus-sound-comment "test.snd")))
	(close-sound ab))
      (save-sound-as "test.snd" ob :header-type mus-aiff :sample-type mus-b24int)
      (let ((ab (open-sound "test.snd")))
	(if (not (= (header-type ab) mus-aiff)) 
	    (snd-display "save-as aiff -> ~A?" (mus-header-type-name (header-type ab))))
	(if (not (= (mus-sound-header-type "test.snd") mus-aiff)) 
	    (snd-display "saved-as aiff -> ~A?" (mus-header-type-name (mus-sound-header-type "test.snd"))))
	(if (not (= (sample-type ab) mus-b24int))
	    (snd-display "save-as 24-bit -> ~A?" (mus-sample-type-name (sample-type ab))))
	(if (not (= (mus-sound-sample-type "test.snd") mus-b24int))
	    (snd-display "saved-as 24-bit -> ~A?" (mus-sample-type-name (mus-sound-sample-type "test.snd"))))
	(if (fneq (sample 1000 ab) samp) (snd-display "aiff[1000] = ~A?" (sample 1000 ab)))
	(close-sound ab))
      (save-sound-as "test.snd" ob :header-type mus-ircam :sample-type mus-mulaw)
      (let ((ab (open-sound "test.snd")))
	(if (not (= (header-type ab) mus-ircam)) 
	    (snd-display "save-as ircam -> ~A?" (mus-header-type-name (header-type ab))))
	(if (not (= (mus-sound-header-type "test.snd") mus-ircam)) 
	    (snd-display "saved-as ircam -> ~A?" (mus-header-type-name (mus-sound-header-type "test.snd"))))
	(if (not (= (sample-type ab) mus-mulaw))
	    (snd-display "save-as mulaw -> ~A?" (mus-sample-type-name (sample-type ab))))
	(if (not (= (mus-sound-sample-type "test.snd") mus-mulaw))
	    (snd-display "saved-as mulaw -> ~A?" (mus-sample-type-name (mus-sound-sample-type "test.snd"))))
	(if (fneq (sample 1000 ab) samp) (snd-display "ircam[1000] = ~A?" (sample 1000 ab)))
	(close-sound ab))
      (save-sound-as "test.snd" ob :header-type mus-next :sample-type mus-alaw)
      (let ((ab (open-sound "test.snd")))
	(if (not (= (header-type ab) mus-next)) 
	    (snd-display "save-as next -> ~A?" (mus-header-type-name (header-type ab))))
	(if (not (= (mus-sound-header-type "test.snd") mus-next)) 
	    (snd-display "saved-as next -> ~A?" (mus-header-type-name (mus-sound-header-type "test.snd"))))
	(if (not (= (sample-type ab) mus-alaw)) 
	    (snd-display "save-as alaw -> ~A?" (mus-sample-type-name (sample-type ab))))
	(if (not (= (mus-sound-sample-type "test.snd") mus-alaw)) 
	    (snd-display "saved-as alaw -> ~A?" (mus-sample-type-name (mus-sound-sample-type "test.snd"))))
	(if (fneq (sample 1000 ab) samp) (snd-display "next (alaw)[1000] = ~A?" (sample 1000 ab)))
	(close-sound ab))
      (save-sound-as "test.snd" ob :header-type mus-next :sample-type mus-ldouble)
      (let ((ab (open-sound "test.snd")))
	(if (not (= (header-type ab) mus-next)) 
	    (snd-display "save-as dbl next -> ~A?" (mus-header-type-name (header-type ab))))
	(if (not (= (sample-type ab) mus-ldouble)) 
	    (snd-display "save-as dbl -> ~A?" (mus-sample-type-name (sample-type ab))))
	(if (fneq (sample 1000 ab) samp) (snd-display "next (dbl)[1000] = ~A?" (sample 1000 ab)))
	(close-sound ab))
      (save-sound-as "test.snd" ob :header-type mus-next :sample-type mus-bshort)
      (let ((ab (open-sound "test.snd")))
	(if (not (= (header-type ab) mus-next)) 
	    (snd-display "save-as next -> ~A?" (mus-header-type-name (header-type ab))))
	(if (not (= (mus-sound-header-type "test.snd") mus-next)) 
	    (snd-display "saved-as next -> ~A?" (mus-header-type-name (mus-sound-header-type "test.snd"))))
	(if (not (= (sample-type ab) mus-bshort)) 
	    (snd-display "save-as short -> ~A?" (mus-sample-type-name (sample-type ab))))
	(if (not (= (mus-sound-sample-type "test.snd") mus-bshort)) 
	    (snd-display "saved-as short -> ~A?" (mus-sample-type-name (mus-sound-sample-type "test.snd"))))
	(if (fneq (sample 1000 ab) samp) (snd-display "next (short)[1000] = ~A?" (sample 1000 ab)))
	(set! (hook-functions update-hook) ())
	(set! (y-bounds ab 0) (list -3.0 3.0))
	(set! (sample-type ab) mus-lshort)
	(if (not (equal? ab (find-sound "test.snd"))) (set! ab (find-sound "test.snd"))) ; these set!'s can change the index via update-sound
	(if (not (= (sample-type ab) mus-lshort)) (snd-display "set sample-type: ~A?" (mus-sample-type-name (sample-type ab))))
	(when (and with-gui
		   (not (equal? (y-bounds ab 0) '(-3.0 3.0))))
	  (snd-display "set sample type y-bounds: ~A?" (y-bounds ab 0)))
	(set! (y-bounds ab 0) (list 2.0))
	(when (and with-gui
		   (not (equal? (y-bounds ab 0) '(-2.0 2.0))))
	  (snd-display "set sample type y-bounds 1: ~A?" (y-bounds ab 0)))
	(set! (y-bounds ab 0) (list -2.0))
	(when (and with-gui
		   (not (equal? (y-bounds ab 0) '(-2.0 2.0))))
	  (snd-display "set sample type y-bounds -2: ~A?" (y-bounds ab 0)))
	(set! (header-type ab) mus-aifc)
	(if (not (equal? ab (find-sound "test.snd"))) (set! ab (find-sound "test.snd")))
	(if (not (= (header-type ab) mus-aifc)) (snd-display "set header-type: ~A?" (mus-header-type-name (header-type ab))))
	(set! (channels ab) 3)
	(if (not (equal? ab (find-sound "test.snd"))) (set! ab (find-sound "test.snd")))
	(if (not (= (channels ab) 3)) (snd-display "set chans: ~A?" (channels ab)))
	(set! (data-location ab) 1234)
	(if (not (equal? ab (find-sound "test.snd"))) (set! ab (find-sound "test.snd")))
	(if (not (= (data-location ab) 1234)) (snd-display "set data-location: ~A?" (data-location ab)))
	(let-temporarily (((data-size ab) 1234))
	  (if (not (equal? ab (find-sound "test.snd"))) (set! ab (find-sound "test.snd")))
	  (if (not (= (data-size ab) 1234)) (snd-display "set data-size: ~A?" (data-size ab))))
	(set! (srate ab) 12345)
	(if (not (equal? ab (find-sound "test.snd"))) (set! ab (find-sound "test.snd")))
	(if (not (= (srate ab) 12345)) (snd-display "set srate: ~A?" (srate ab)))
	(close-sound ab))
      (save-sound-as "test.snd" ob :header-type mus-next :sample-type mus-bfloat)
      (let ((ab (open-sound "test.snd")))
	(if (not (= (header-type ab) mus-next)) 
	    (snd-display "save-as next -> ~A?" (mus-header-type-name (header-type ab))))
	(if (not (= (mus-sound-header-type "test.snd") mus-next)) 
	    (snd-display "saved-as next -> ~A?" (mus-header-type-name (mus-sound-header-type "test.snd"))))
	(if (not (= (sample-type ab) mus-bfloat)) 
	    (snd-display "save-as float -> ~A?" (mus-sample-type-name (sample-type ab))))
	(if (not (= (mus-sound-sample-type "test.snd") mus-bfloat)) 
	    (snd-display "saved-as float -> ~A?" (mus-sample-type-name (mus-sound-sample-type "test.snd"))))
	(if (fneq (sample 1000 ab) samp) (snd-display "next (float)[1000] = ~A?" (sample 1000 ab)))
	(close-sound ab))
      (save-sound-as "test.snd" ob :header-type mus-next :sample-type mus-ldouble)
      (close-sound ob)
      (let ((ab (open-sound "test.snd")))
	(set! (sample-type) mus-lshort)
	(if (not (equal? ab (find-sound "test.snd"))) (set! ab (find-sound "test.snd")))
	(if (not (= (sample-type) mus-lshort)) (snd-display "set sample-type: ~A?" (mus-sample-type-name (sample-type))))
	(set! (header-type) mus-aifc)
	(if (not (equal? ab (find-sound "test.snd"))) (set! ab (find-sound "test.snd")))
	(if (not (= (header-type) mus-aifc)) (snd-display "set header-type: ~A?" (mus-header-type-name (header-type))))
	(set! (channels) 3)
	(if (not (equal? ab (find-sound "test.snd"))) (set! ab (find-sound "test.snd")))
	(if (not (= (channels) 3)) (snd-display "set chans: ~A?" (channels)))
	(set! (data-location) 1234)
	(if (not (equal? ab (find-sound "test.snd"))) (set! ab (find-sound "test.snd")))
	(if (not (= (data-location) 1234)) (snd-display "set data-location: ~A?" (data-location)))
	(set! (srate) 12345)
	(if (not (equal? ab (find-sound "test.snd"))) (set! ab (find-sound "test.snd")))
	(if (not (= (srate) 12345)) (snd-display "set srate: ~A?" (srate)))
	(close-sound ab)))
    
    (let ((ind (open-sound "2a.snd")))
      (save-sound-as "test.snd" :sample-type mus-l24int :header-type mus-riff :channel 0)
      (let ((ind0 (open-sound "test.snd")))
	(if (not (= (channels ind0) 1)) 
	    (snd-display "save-sound-as :channel 0 chans: ~A" (channels ind0)))
	(if (not (= (sample-type ind0) mus-l24int)) 
	    (snd-display "save-sound-as :channel 0 sample-type: ~A ~A" (sample-type ind0) (mus-sample-type-name (sample-type ind0))))
	(if (not (= (header-type ind0) mus-riff))
	    (snd-display "save-sound-as :channel 0 header-type: ~A ~A" (header-type ind0) (mus-header-type-name (header-type ind0))))
	(if (not (= (srate ind0) (srate ind)))
	    (snd-display "save-sound-as :channel 0 srates: ~A ~A" (srate ind0) (srate ind)))    
	(if (not (= (framples ind0) (framples ind 0)))
	    (snd-display "save-sound-as :channel 0 framples: ~A ~A" (framples ind0) (framples ind 0)))
	(if (fneq (maxamp ind0 0) (maxamp ind 0))
	    (snd-display "save-sound-as :channel 0 maxamps: ~A ~A" (maxamp ind0 0) (maxamp ind 0)))
	(close-sound ind0))
      (save-sound-as "test.snd" :sample-type mus-l24int :header-type mus-riff)
      (let ((ind0 (open-sound "test.snd")))
	(if (not (= (channels ind0) 2)) 
	    (snd-display "save-sound-as chans: ~A" (channels ind0)))
	(if (not (= (sample-type ind0) mus-l24int)) 
	    (snd-display "save-sound-as sample-type: ~A ~A" (sample-type ind0) (mus-sample-type-name (sample-type ind0))))
	(if (not (= (header-type ind0) mus-riff))
	    (snd-display "save-sound-as header-type: ~A ~A" (header-type ind0) (mus-header-type-name (header-type ind0))))
	(if (not (= (srate ind0) (srate ind)))
	    (snd-display "save-sound-as srates: ~A ~A" (srate ind0) (srate ind)))    
	(if (not (= (framples ind0) (framples ind 0)))
	    (snd-display "save-sound-as framples: ~A ~A" (framples ind0) (framples ind 0)))
	(if (fneq (maxamp ind0 0) (maxamp ind 0))
	    (snd-display "save-sound-as maxamps: ~A ~A" (maxamp ind0 0) (maxamp ind 0)))
	(close-sound ind0))
      (save-sound-as "test.snd" :sample-type mus-b24int :header-type mus-aiff)
      (let ((ind0 (open-sound "test.snd")))
	(if (not (= (channels ind0) 2)) 
	    (snd-display "save-sound-as chans: ~A" (channels ind0)))
	(if (not (= (sample-type ind0) mus-b24int)) 
	    (snd-display "save-sound-as sample-type: ~A ~A" (sample-type ind0) (mus-sample-type-name (sample-type ind0))))
	(if (not (= (header-type ind0) mus-aiff))
	    (snd-display "save-sound-as header-type: ~A ~A" (header-type ind0) (mus-header-type-name (header-type ind0))))
	(if (not (= (srate ind0) (srate ind)))
	    (snd-display "save-sound-as srates: ~A ~A" (srate ind0) (srate ind)))    
	(if (not (= (framples ind0) (framples ind 0)))
	    (snd-display "save-sound-as framples: ~A ~A" (framples ind0) (framples ind 0)))
	(if (fneq (maxamp ind0 0) (maxamp ind 0))
	    (snd-display "save-sound-as maxamps: ~A ~A" (maxamp ind0 0) (maxamp ind 0)))
	(close-sound ind0))
      (save-sound-as "test.snd" :sample-type mus-bfloat :header-type mus-aifc :channel 1 :srate 12345)
      (let ((ind0 (open-sound "test.snd")))
	(if (not (= (channels ind0) 1)) 
	    (snd-display "save-sound-as :channel 1 chans: ~A" (channels ind0)))
	(if (not (= (sample-type ind0) mus-bfloat)) 
	    (snd-display "save-sound-as :channel 1 sample-type: ~A ~A" (sample-type ind0) (mus-sample-type-name (sample-type ind0))))
	(if (not (= (header-type ind0) mus-aifc))
	    (snd-display "save-sound-as :channel 1 header-type: ~A ~A" (header-type ind0) (mus-header-type-name (header-type ind0))))
	(if (not (= (srate ind0) 12345))
	    (snd-display "save-sound-as :channel 1 srates: ~A ~A" (srate ind0) (srate ind)))    
	(if (not (= (framples ind0) (framples ind 1)))
	    (snd-display "save-sound-as :channel 1 framples: ~A ~A" (framples ind0) (framples ind 1)))
	(if (fneq (maxamp ind0 0) (maxamp ind 1))
	    (snd-display "save-sound-as :channel 1 maxamps: ~A ~A" (maxamp ind0 0) (maxamp ind 1)))
	(close-sound ind0))
      (save-sound-as "test.snd" :channel 1 :comment "this is a test")
      (let ((ind0 (open-sound "test.snd")))
	(if (not (= (channels ind0) 1)) 
	    (snd-display "save-sound-as :channel 1 (1) chans: ~A" (channels ind0)))
	(if (not (= (sample-type ind0) (sample-type ind)))
	    (snd-display "save-sound-as :channel 1 (1) sample-type: ~A ~A" (sample-type ind0) (mus-sample-type-name (sample-type ind0))))
	(if (not (= (header-type ind0) (header-type ind)))
	    (snd-display "save-sound-as :channel 1 (1) header-type: ~A ~A" (header-type ind0) (mus-header-type-name (header-type ind0))))
	(if (not (= (srate ind0) (srate ind)))
	    (snd-display "save-sound-as :channel 1 (1) srates: ~A ~A" (srate ind0) (srate ind)))    
	(if (not (= (framples ind0) (framples ind 1)))
	    (snd-display "save-sound-as :channel 1 (1) framples: ~A ~A" (framples ind0) (framples ind 1)))
	(if (fneq (maxamp ind0 0) (maxamp ind 1))
	    (snd-display "save-sound-as :channel 1 (1) maxamps: ~A ~A" (maxamp ind0 0) (maxamp ind 1)))
	(if (not (string=? (comment ind0) "this is a test"))
	    (snd-display "save-sound-as :channel 0 (1) comment: ~A" (comment ind0)))
	(close-sound ind0))
      (close-sound ind))
    
    (let ((fsnd (string-append sf-dir "t15.aiff")))
      (if (file-exists? fsnd)
	  (let ((ind (open-sound fsnd)))
	    (if (or (fneq (sample 132300 ind 0) .148)
		    (fneq (sample 132300 ind 1) .126))
		(snd-display "aifc sowt trouble: ~A ~A" (sample 132300 ind 0) (sample 132300 ind 1)))
	    (close-sound ind))))
    (let ((fsnd (string-append sf-dir "M1F1-float64C-AFsp.aif")))
      (if (file-exists? fsnd)
	  (let ((ind (open-sound fsnd)))
	    (if (or (fneq (sample 8000 ind 0) -0.024)
		    (fneq (sample 8000 ind 1) 0.021))
		(snd-display "aifc fl64 trouble: ~A ~A" (sample 8000 ind 0) (sample 8000 ind 1)))
	    (close-sound ind))))
    
    (for-each (lambda (n vals)
		(let ((val (catch #t (lambda () 
				       (list (mus-sound-chans n)
					     (mus-sound-srate n)
					     (mus-sound-framples n)))
				  (lambda args (car args)))))
		  (if (not (or (equal? val vals)
			       (eq? val 'mus-error)))
		      (snd-display "~A: ~A ~A" n val vals))))
	      (list (string-append sf-dir "bad_chans.snd")
		    (string-append sf-dir "bad_srate.snd")
		    (string-append sf-dir "bad_data_format.snd")
		    (string-append sf-dir "bad_chans.aifc")
		    (string-append sf-dir "bad_srate.aifc")
		    (string-append sf-dir "bad_length.aifc")
		    (string-append sf-dir "bad_chans.riff")
		    (string-append sf-dir "bad_srate.riff")
		    (string-append sf-dir "bad_chans.nist")
		    (string-append sf-dir "bad_srate.nist")
		    (string-append sf-dir "bad_length.nist"))
	      '((0 22050 0) 
		(1 0 0) 
		(1 22050 4411) 
		(0 22050 0) 
		(1 0 0) 
		(1 22050 -10) 
		(0 22050 0) 
		(1 0 0) 
		(0 22050 0) 
		(1 0 0) 
		(1 22050 -10)))
    
    (let ((ind (open-sound (string-append "/usr/include/sys/" home-dir "/cl/oboe.snd"))))
      (if (not (and (sound? ind)
		    (string=? (short-file-name ind) "oboe.snd")))
	  (snd-display "open-sound with slashes: ~A ~A" ind (and (sound? ind) (short-file-name ind))))
      (hook-push bad-header-hook (lambda (hook) (set! (hook 'result) #t)))
      (for-each (lambda (n)
		  (catch #t (lambda () 
			      (insert-sound n))
			 (lambda args (car args)))
		  (catch #t (lambda () 
			      (convolve-with n))
			 (lambda args (car args)))
		  (catch #t (lambda () 
			      (mix n))
			 (lambda args (car args)))
		  (catch #t (lambda () 
			      (let ((ind (open-sound n)))
				(if (and (number? ind)
					 (sound? ind))
				    (close-sound ind))))
			 (lambda args (car args))))
		(list (string-append sf-dir "bad_chans.snd")
		      (string-append sf-dir "bad_srate.snd")
		      (string-append sf-dir "bad_chans.aifc")
		      (string-append sf-dir "bad_srate.aifc")
		      (string-append sf-dir "bad_length.aifc")
		      (string-append sf-dir "bad_chans.riff")
		      (string-append sf-dir "bad_srate.riff")
		      (string-append sf-dir "bad_chans.nist")
		      (string-append sf-dir "bad_location.nist")
		      (string-append sf-dir "bad_field.nist")
		      (string-append sf-dir "bad_srate.nist")
		      (string-append sf-dir "bad_length.nist")))
      (close-sound ind))
    
    (for-each close-sound (sounds))
    
    (if (selected-sound)
	(snd-display "selected-sound ~A ~A" (selected-sound) (sounds)))
    
    (if (file-exists? (string-append (or sf-dir "") "a.sf2"))
	(let ((fil (open-sound (string-append (or sf-dir "") "a.sf2"))))
	  (if fil
	      (let ((loops (and fil (soundfont-info))))
		(if (or (null? loops)
			(not (= (caddar loops) 65390))
			(not (= (cadadr loops) 65490)))
		    (snd-display "soundfont-info: ~A?" loops))
		(close-sound fil)))))
    
    (if (file-exists? "fmv5.snd") (delete-file "fmv5.snd"))
    (set! *print-length* 12)
    
    (for-each
     (lambda (file)
       (let ((tag (catch #t
		    (lambda () (open-sound (string-append sf-dir file)))
		    (lambda args args))))
	 (if (not (eq? (car tag) 'mus-error))
	     (snd-display "open-sound ~A: ~A" file tag))))
     '("trunc.snd" "trunc.aiff" "trunc.wav" "trunc.sf" "trunc.voc" "trunc.nist" "bad.wav" 
       "trunc1.aiff" "badform.aiff"))
    
    (hook-push open-raw-sound-hook (lambda (hook) (set! (hook 'result) (list 1 22050 mus-bshort))))
    (let ((ind (open-sound (string-append sf-dir "empty.snd"))))
      (if (not (and (= (sample-type ind) mus-bshort)
		    (= (chans ind) 1)
		    (= (srate ind) 22050)
		    (= (data-location ind) 0)
		    (= (framples ind) 0)))
	  (snd-display "open raw: ~A ~A ~A ~A ~A" (sample-type ind) (chans ind) (srate ind) (data-location ind) (framples ind)))
      (set! (hook-functions open-raw-sound-hook) ())
      (close-sound ind))
    
    (let ((sd (make-float-vector '(1 1))))
      (if (fneq (sd 0 0) 0.0) (snd-display "vector2 ref: ~A" (sd 0 0)))
      (set! (sd 0 0) 1.0)
      (if (fneq (sd 0 0) 1.0) (snd-display "vector2 set: ~A" (sd 0 0)))
      (if (not (equivalent? sd (let ((sd1 (make-float-vector '(1 1)))) (float-vector-set! sd1 0 0 1.0) sd1)))
	  (snd-display "vector2 set not equal: ~A" sd)))
    
    (let ((sd (make-float-vector '(2 3))))
      (if (fneq (sd 0 0) 0.0) (snd-display "vector2 ref (1): ~A" (sd 0 0)))
      (set! (sd 1 0) 1.0)
      (if (fneq (sd 1 0) 1.0) (snd-display "vector2 set (1 0): ~A" (sd 1 0)))
      (set! (sd 1 2) 2.0)
      (if (fneq (sd 1 2) 2.0) (snd-display "vector2 set (1 2): ~A" (sd 1 2)))
      (if (not (equivalent? sd (let ((sd1 (make-float-vector '(2 3))))
				    (float-vector-set! sd1 1 0 1.0)
				    (float-vector-set! sd1 1 2 2.0)
				    sd1)))
	  (snd-display "vector2 set (3) not equal: ~A" sd)))
    
    ;; check clipping choices
    (let ((ind (view-sound "oboe.snd")))
      (set! *clipping* #f)
      (scale-channel 10.0)
      (save-sound-as "test.snd" ind :header-type mus-next :sample-type mus-ldouble)
      (undo 1 ind 0)
      (let ((ind1 (open-sound "test.snd")))
	(if (fneq (maxamp ind1 0) (* 10 (maxamp ind 0)))
	    (snd-display "clipping 0: ~A ~A" (maxamp ind1 0) (maxamp ind 0)))
	(close-sound ind1))
      (delete-file "test.snd")
      (set! *clipping* #t)
      (map-channel (lambda (y) (* y 10.0)) 0 #f ind 0)
      (save-sound-as "test.snd" ind :header-type mus-next :sample-type mus-lshort)
      (undo 1 ind 0)
      (let ((ind1 (open-sound "test.snd")))
	(if (fneq (maxamp ind1 0) 1.0)
	    (snd-display "clipping 1: ~A ~A" (maxamp ind1 0) (maxamp ind 0)))
	(close-sound ind1))
      (delete-file "test.snd")
      (set! *clipping* #f)
      (let ((sub (- 1.001 (maxamp ind))))
	(map-channel (lambda (y) (+ y sub)) 0 #f ind 0))
      (save-sound-as "test.snd" ind :header-type mus-next :sample-type mus-lfloat)
      (let ((ind1 (open-sound "test.snd"))
	    (baddy (scan-channel (lambda (y) (< y 0.0)))))
	(if baddy
	    (snd-display "clipping 2: ~A" baddy))
	(close-sound ind1))
      (delete-file "test.snd")
      (set! *clipping* #t)
      (save-sound-as "test.snd" ind :header-type mus-next :sample-type mus-ldouble)
      (let ((ind1 (open-sound "test.snd"))
	    (baddy (scan-channel (lambda (y) (< y 0.0)))))
	(if baddy
	    (snd-display "clipping 3: ~A ~A" baddy (sample baddy)))
	(close-sound ind1))
      (delete-file "test.snd")
      (set! *clipping* #f)
      (close-sound ind))
    (delete-file "fmv.snd")
    
    (set! *clipping* #f)
    (let ((snd (new-sound "test.snd" :sample-type mus-lshort)))
      (pad-channel 0 10)
      (set! (sample 1) 1.0)
      (set! (sample 2) -1.0)
      (set! (sample 3) 0.9999)
      (set! (sample 4) 2.0)
      (set! (sample 5) -2.0)
      (set! (sample 6) 1.3)
      (set! (sample 7) -1.3)
      (set! (sample 8) 1.8)
      (set! (sample 9) -1.8)
      (save-sound snd)
      (close-sound snd))
    (let ((snd (open-sound "test.snd")))
      (let ((data (channel->float-vector 0 10)))
	(if (not (mus-arrays-equal? data #r(0.0 1.0 -1.0 1.0 0.0 0.0 -0.700 0.700 -0.200 0.200)))
	    (snd-display "unclipped 1: ~A" data)))
      (close-sound snd))
    (mus-sound-forget "test.snd")
    
    (set! *clipping* #t)
    (let ((snd (new-sound "test.snd" :sample-type mus-lshort)))
      (pad-channel 0 10)
      (set! (sample 1) 1.0)
      (set! (sample 2) -1.0)
      (set! (sample 3) 0.9999)
      (set! (sample 4) 2.0)
      (set! (sample 5) -2.0)
      (set! (sample 6) 1.3)
      (set! (sample 7) -1.3)
      (set! (sample 8) 1.8)
      (set! (sample 9) -1.8)
      (save-sound snd)
      (close-sound snd))
    (let ((snd (open-sound "test.snd")))
      (let ((data (channel->float-vector 0 10)))
	(if (not (mus-arrays-equal? data #r(0.0 1.0 -1.0 1.0 1.0 -1.0 1.0 -1.0 1.0 -1.000)))
	    (snd-display "clipped: ~A" data)))
      (close-sound snd))
    (set! *clipping* #f)
    
    (let ((test-data (lambda (file beg dur data)
		       (catch #t
			 (lambda ()
			   (let* ((ind (open-sound file))
				  (ndata (channel->float-vector beg dur ind 0)))
			     (if (not (mus-arrays-equal? data ndata))
				 (snd-display "~A: ~A != ~A" file data ndata))
			     (close-sound ind)))
			 (lambda args args)))))
      (test-data (string-append sf-dir "next-dbl.snd") 10 10 #r(0.475 0.491 0.499 0.499 0.492 0.476 0.453 0.423 0.387 0.344))
      (test-data (string-append sf-dir "oboe.ldbl") 1000 10 #r(0.033 0.035 0.034 0.031 0.026 0.020 0.013 0.009 0.005 0.004))
      
      (test-data (string-append sf-dir "next-flt.snd") 10 10 #r(0.475 0.491 0.499 0.499 0.492 0.476 0.453 0.423 0.387 0.344))
      (test-data (string-append sf-dir "clbonef.wav") 1000 10 #r(0.111 0.101 0.070 0.032 -0.014 -0.060 -0.085 -0.108 -0.129 -0.152))
      
      (test-data (string-append sf-dir "next-8.snd") 10 10 #r(0.898 0.945 0.977 0.992 0.992 0.977 0.945 0.906 0.844 0.773))
      (test-data (string-append sf-dir "o2_u8.wave") 1000 10 #r(-0.164 -0.219 -0.258 -0.242 -0.180 -0.102 -0.047 0.0 0.039 0.055))
      
      (test-data (string-append sf-dir "next-16.snd") 1000 10 #r(-0.026 -0.022 -0.024 -0.030 -0.041 -0.048 -0.050 -0.055 -0.048 -0.033))
      (test-data (string-append sf-dir "o2.wave") 1000 10 #r(-0.160 -0.216 -0.254 -0.239 -0.175 -0.102 -0.042 0.005 0.041 0.059))
      
      (test-data (string-append sf-dir "o2_18bit.aiff") 1000 10 #r(-0.160 -0.216 -0.254 -0.239 -0.175 -0.102 -0.042 0.005 0.041 0.059))
      (test-data (string-append sf-dir "o2_12bit.aiff") 1000 10 #r(-0.160 -0.216 -0.254 -0.239 -0.175 -0.102 -0.042 0.005 0.041 0.059))
      
      (test-data (string-append sf-dir "next24.snd") 1000 10 #r(-0.160 -0.216 -0.254 -0.239 -0.175 -0.102 -0.042 0.005 0.041 0.059))
      (test-data (string-append sf-dir "mono24.wav") 1000 10 #r(0.005 0.010 0.016 0.008 -0.007 -0.018 -0.025 -0.021 -0.005 0.001))
      
      (test-data (string-append sf-dir "o2_711u.wave") 1000 10 #r(-0.164 -0.219 -0.254 -0.242 -0.172 -0.103 -0.042 0.005 0.042 0.060))
      (test-data (string-append sf-dir "alaw.wav") 1000 10 #r(-0.024 -0.048 -0.024 0.0 0.008 0.008 0.0 -0.040 -0.064 -0.024))
      
      ;; it is not a bug if these don't match if MUS_SAMPLE_BITS is not 24
      (test-data (string-append sf-dir "b32.pvf") 1000 10 #r(-0.160 -0.216 -0.254 -0.239 -0.175 -0.102 -0.042 0.005 0.041 0.059))
      (test-data (string-append sf-dir "b32.wave") 1000 10 #r(-0.160 -0.216 -0.254 -0.239 -0.175 -0.102 -0.042 0.005 0.041 0.059))
      (test-data (string-append sf-dir "b32.snd") 1000 10 #r(-0.160 -0.216 -0.254 -0.239 -0.175 -0.102 -0.042 0.005 0.041 0.059))
      (test-data (string-append sf-dir "32bit.sf") 1000 10 #r(0.016 0.014 0.013 0.011 0.010 0.010 0.010 0.010 0.012 0.014))
      
      (test-data (string-append sf-dir "nist-shortpack.wav") 10000 10 #r(0.021 0.018 0.014 0.009 0.004 -0.001 -0.004 -0.006 -0.007 -0.008))
      (test-data (string-append sf-dir "wood.sds") 1000 10 #r(-0.160 -0.216 -0.254 -0.239 -0.175 -0.102 -0.042 0.005 0.041 0.059))
      (test-data (string-append sf-dir "mus10.snd") 10000 10 #r(0.004 0.001 0.005 0.009 0.017 0.015 0.008 0.011 0.009 0.012))
      (test-data (string-append sf-dir "ieee-text-16.snd") 1000 10 #r(-0.052 -0.056 -0.069 -0.077 -0.065 -0.049 -0.054 -0.062 -0.066 -0.074))
      (test-data (string-append sf-dir "hcom-16.snd") 10000 10 #r(0.0 0.0 0.0 0.008 0.0 -0.016 -0.016 -0.016 -0.008 0.000))
      (test-data (string-append sf-dir "ce-c3.w02") 1000 10 #r(0.581 0.598 0.596 0.577 0.552 0.530 0.508 0.479 0.449 0.425))
      (test-data (string-append sf-dir "nasahal.avi") 20000 10 #r(0.390 0.120 -0.399 -0.131 0.464 0.189 -0.458 -0.150 0.593 0.439))
      (test-data (string-append sf-dir "oki.wav") 100 10 #r(0.396 0.564 0.677 0.779 0.761 0.540 0.209 -0.100 -0.301 -0.265))
      
      (test-data (string-append sf-dir "trumps22.adp") 5000 10 #r(0.267 0.278 0.309 0.360 0.383 0.414 0.464 0.475 0.486 0.495)))
    
    (let ((errs (list "no error" "no frequency method" "no phase method" "null gen arg to method" "no length method"
		      "no describe method" "no data method" "no scaler method"
		      "memory allocation failed" 
		      "can't open file" "no sample input" "no sample output"
		      "no such channel" "no file name provided" "no location method" "no channel method"
		      "no such fft window" "unknown sample type" "header read failed"
		      "unknown header type" "file descriptors not initialized" "not a sound file" "file closed" "write error"
		      "header write failed" "can't open temp file" "interrupted" "bad envelope"
		      "audio channels not available" "audio srate not available" "audio sample type not available"
		      "no audio input available" "audio configuration not available" 
		      "audio write error" "audio size not available" "audio device not available"
		      "can't close audio" "can't open audio" "audio read error"
		      "can't write audio" "can't read audio" "no audio read permission" 
		      "can't close file" "arg out of range" 
		      "no channels method" "no hop method" "no width method" "no file-name method" "no ramp method" "no run method"
		      "no increment method" "no offset method"
		      "no xcoeff method" "no ycoeff method" "no xcoeffs method" "no ycoeffs method" "no reset" "bad size" "can't convert"
		      "read error"
		      "no feedforward method" "no feedback method" "no interp-type method" "no position method" "no order method" "no copy method"
		      "can't translate"
		      )))
      (do ((len (length errs))
	   (i 0 (+ i 1)))
	    ((or (= i len)
		 (not (string=? (errs i) (mus-error-type->string i))))
	     (if (not (= i len))
		 (snd-display "mus-error-type->string ~D: ~A ~A" i (errs i) (mus-error-type->string i))))))

    (let ((cur-srate (mus-sound-srate "oboe.snd"))
	  (cur-chans (mus-sound-chans "oboe.snd"))
	  (cur-format (mus-sound-sample-type "oboe.snd"))
	  (cur-type (mus-sound-header-type "oboe.snd"))
	  (cur-loc (mus-sound-data-location "oboe.snd"))
	  (cur-samps (mus-sound-samples "oboe.snd")))
      (set! (mus-sound-srate "oboe.snd") (* cur-srate 2))
      (if (not (= (* cur-srate 2) (mus-sound-srate "oboe.snd"))) 
	  (snd-display "set mus-sound-srate: ~A -> ~A" cur-srate (mus-sound-srate "oboe.snd")))
      (set! (mus-sound-samples "oboe.snd") (* cur-samps 2))
      (if (not (= (* cur-samps 2) (mus-sound-samples "oboe.snd"))) 
	  (snd-display "set mus-sound-samples: ~A -> ~A" cur-samps (mus-sound-samples "oboe.snd")))
      (set! (mus-sound-chans "oboe.snd") (* cur-chans 2))
      (if (not (= (* cur-chans 2) (mus-sound-chans "oboe.snd"))) 
	  (snd-display "set mus-sound-chans: ~A -> ~A" cur-chans (mus-sound-chans "oboe.snd")))
      (set! (mus-sound-data-location "oboe.snd") (* cur-loc 2))
      (if (not (= (* cur-loc 2) (mus-sound-data-location "oboe.snd"))) 
	  (snd-display "set mus-sound-data-location: ~A -> ~A" cur-loc (mus-sound-data-location "oboe.snd")))
      (set! (mus-sound-header-type "oboe.snd") mus-nist)
      (if (not (= mus-nist (mus-sound-header-type "oboe.snd"))) 
	  (snd-display "set mus-sound-header-type: ~A -> ~A" cur-type (mus-sound-header-type "oboe.snd")))
      (set! (mus-sound-sample-type "oboe.snd") mus-lintn)
      (if (not (= mus-lintn (mus-sound-sample-type "oboe.snd"))) 
	  (snd-display "set mus-sound-sample-type: ~A -> ~A" cur-format (mus-sound-sample-type "oboe.snd")))
      (set! (mus-sound-srate "oboe.snd") cur-srate)
      (set! (mus-sound-samples "oboe.snd") cur-samps)
      (set! (mus-sound-chans "oboe.snd") cur-chans)
      (set! (mus-sound-data-location "oboe.snd") cur-loc)
      (set! (mus-sound-header-type "oboe.snd") cur-type)
      (set! (mus-sound-sample-type "oboe.snd") cur-format))
    
    (let ((ind (open-sound "oboe.snd")))
      (save-sound-as "test.wave" ind :header-type mus-riff)
      (save-sound-as "test.rf64" ind :header-type mus-rf64)
      (save-sound-as "test.aifc" ind :header-type mus-aifc)
      (close-sound ind)
      
      (for-each
       (lambda (file)
	 (let ((cur-srate (mus-sound-srate file))
	       (cur-chans (mus-sound-chans file))
	       (cur-format (mus-sound-sample-type file))
	       (cur-type (mus-sound-header-type file))
	       (cur-loc (mus-sound-data-location file))
	       (cur-samps (mus-sound-samples file)))
	   (set! (mus-sound-srate file) (* cur-srate 2))
	   (if (not (= (* cur-srate 2) (mus-sound-srate file))) 
	       (snd-display "~A: set mus-sound-srate: ~A -> ~A" file cur-srate (mus-sound-srate file)))
	   (set! (mus-sound-samples file) (* cur-samps 2))
	   (if (not (= (* cur-samps 2) (mus-sound-samples file))) 
	       (snd-display "~A: set mus-sound-samples: ~A -> ~A" file cur-samps (mus-sound-samples file)))
	   (set! (mus-sound-chans file) (* cur-chans 2))
	   (if (not (= (* cur-chans 2) (mus-sound-chans file))) 
	       (snd-display "~A: set mus-sound-chans: ~A -> ~A" file cur-chans (mus-sound-chans file)))
	   (set! (mus-sound-data-location file) (* cur-loc 2))
	   (if (not (= (* cur-loc 2) (mus-sound-data-location file))) 
	       (snd-display "~A: set mus-sound-data-location: ~A -> ~A" file cur-loc (mus-sound-data-location file)))
	   (set! (mus-sound-header-type file) mus-nist)
	   (if (not (= mus-nist (mus-sound-header-type file))) 
	       (snd-display "~A: set mus-sound-header-type: ~A -> ~A" file cur-type (mus-sound-header-type file)))
	   (set! (mus-sound-sample-type file) mus-lintn)
	   (if (not (= mus-lintn (mus-sound-sample-type file))) 
	       (snd-display "~A: set mus-sound-sample-type: ~A -> ~A" file cur-format (mus-sound-sample-type file)))
	   (set! (mus-sound-srate file) cur-srate)
	   (set! (mus-sound-samples file) cur-samps)
	   (set! (mus-sound-chans file) cur-chans)
	   (set! (mus-sound-data-location file) cur-loc)
	   (set! (mus-sound-header-type file) cur-type)
	   (set! (mus-sound-sample-type file) cur-format)))
       '("test.wave" "test.rf64" "test.aifc"))
      
      (for-each 
       (lambda (file)
	 (let ((ind (open-sound file)))
	   (let ((cur-srate (srate ind))
		 (cur-chans (chans ind))
		 (cur-format (sample-type ind))
		 (cur-type (header-type ind))
		 (cur-loc (data-location ind))
		 (cur-samps (framples ind)))
	     (set! (srate ind) (* cur-srate 2))
	     (if (not (= (* cur-srate 2) (srate ind))) 
		 (snd-display "~A: set srate: ~A -> ~A" file cur-srate (srate ind)))
	     (set! (framples ind) (* cur-samps 2))
	     (if (not (= (* cur-samps 2) (framples ind))) 
		 (snd-display "~A: set framples: ~A -> ~A" file cur-samps (framples ind)))
	     (set! (chans ind) (* cur-chans 2)) ; this can change the index
	     (let ((xind (find-sound file)))
	       (if (not (equal? ind xind))
		   (set! ind xind)))
	     (if (not (= (* cur-chans 2) (chans ind))) 
		 (snd-display "~A: set chans: ~A -> ~A" file cur-chans (chans ind)))
	     (set! (data-location ind) (* cur-loc 2))
	     (if (not (= (* cur-loc 2) (data-location ind))) 
		 (snd-display "~A: set data-location: ~A -> ~A" file cur-loc (data-location ind)))
	     (set! (header-type ind) mus-nist)
	     (if (not (= mus-nist (header-type ind))) 
		 (snd-display "~A: set header-type: ~A -> ~A" file cur-type (header-type ind)))
	     (set! (sample-type ind) mus-lintn)
	     (if (not (= mus-lintn (sample-type ind))) 
		 (snd-display "~A: set sample-type: ~A -> ~A" file cur-format (sample-type ind)))
	     (set! (srate ind) cur-srate)
	     (set! (framples ind) cur-samps)
	     (set! (chans ind) cur-chans)
	     (set! (data-location ind) cur-loc)
	     (set! (header-type ind) cur-type)
	     (set! (sample-type ind) cur-format))
	   (close-sound ind))
	 (if (file-exists? file)
	     (delete-file file)))
       '("test.wave" "test.rf64" "test.aifc")))
    
    ;;	  (with-sound (big-file-name :srate 44100 :play #f)
    ;;	    (do ((i 0 (+ i 1))) ((= i 72000))
    ;;	      (fm-violin i .1 440 (+ .01 (* (/ i 72000.0) .9)))))
    
    (when with-big-file
      (let ((probable-framples (floor (* (floor *clm-srate*) 71999.1)))) ; silence as last .9 secs, so it probably wasn't written
	(if (not (= (mus-sound-samples big-file-name) 3175160310))
	    (snd-display "bigger samples: ~A" (mus-sound-samples big-file-name)))
	(if (not (= (mus-sound-framples big-file-name) 3175160310))
	    (snd-display "bigger framples: ~A" (mus-sound-framples big-file-name)))
	(if (not (= (mus-sound-framples big-file-name) probable-framples))
	    (snd-display "bigger framples: ~A (probable: ~A)" (mus-sound-framples big-file-name) probable-framples))
	(if (not (= (mus-sound-length big-file-name) 6350320648))
	    (snd-display "bigger bytes: ~A" (mus-sound-length big-file-name)))
	(if (fneq (mus-sound-duration big-file-name) 71999.1015)
	    (snd-display "bigger dur: ~A" (mus-sound-duration big-file-name)))
	(let ((ind (open-sound big-file-name)))
	  (if (not (= (framples ind) 3175160310)) (snd-display "bigger framples: ~A" (framples ind)))
	  (set! big-file-framples (framples ind))
	  (if (not (= (framples ind) probable-framples)) (snd-display "bigger framples: ~A (probable: ~A)" (framples ind) probable-framples))
	  (if (not (= (framples ind 0 0) big-file-framples)) (snd-display "bigger edpos-framples: ~A" (framples ind)))
	  (let ((m1 (add-mark (* (floor *clm-srate*) 50000) ind)))
	    (if (not (= (mark-sample m1) (* (floor *clm-srate*) 50000))) (snd-display "bigger mark at: ~A" (mark-sample m1)))
	    (set! (mark-sample m1) (* (floor *clm-srate*) 66000))
	    (if (not (= (mark-sample m1) (* (floor *clm-srate*) 66000))) (snd-display "bigger mark to: ~A" (mark-sample m1))))
	  (let ((mx (mix-sound "oboe.snd" (* (floor *clm-srate*) 60000))))
	    (if (not (mix? mx))
		(snd-display "no mix tag from mix-sound")
		(begin
		  (if (not (= (mix-position mx) (* (floor *clm-srate*) 60000))) (snd-display "bigger mix at: ~A" (mix-position mx)))
		  (set! (mix-position mx) (* (floor *clm-srate*) 61000))
		  (if (not (= (mix-position mx) (* (floor *clm-srate*) 61000))) (snd-display "bigger mix to: ~A" (mix-position mx)))))
	    (undo 2))
	  (let ((res (scan-channel (lambda (y) (> (abs y) 0.0)))))
	    (if (or (not (pair? res))
		    (> (cadr res) 100))
		(snd-display "bigger find not 0.0: ~A" res)))
	  (let-temporarily ((*selection-creates-region* #f))
	    (select-all ind)
	    (if (not (= (selection-framples) (framples ind))) (snd-display "bigger select all: ~A ~A" (selection-framples) (framples)))
	    (set! (selection-position) (* (floor *clm-srate*) 50000))
	    (if (not (= (selection-position) (* (floor *clm-srate*) 50000))) (snd-display "bigger select pos: ~A" (selection-position)))
	    (set! (selection-position) 0)
	    (set! (selection-framples) (* (floor *clm-srate*) 65000))
	    (if (not (= (selection-framples) (* (floor *clm-srate*) 65000))) (snd-display "bigger select len: ~A" (selection-framples))))
	  (let ((size 2260597782))   ;(* 44123 51234))
	    (set! (cursor ind) (* (floor *clm-srate*) 50000))
	    (if (not (= (cursor ind) (* (floor *clm-srate*) 50000))) (snd-display "bigger cursor: ~A" (cursor ind)))
	    (let ((m1 (add-mark size ind)))
	      (if (not (= (mark-sample m1) size)) (snd-display "bigger mark at: ~A" (mark-sample m1)))
	      (let ((mid (find-mark size)))
		(if (not (and (number? mid) (= mid m1))) (snd-display "bigger mark seach: ~A ~A" mid m1))))
	    (let* ((msize 2701827782) ;(* 44123 61234)
		   (mx (mix-sound "oboe.snd" msize))
		   (mxd (find-mix msize)))
	      (if (not (and (number? mxd) (= mxd mx))) (snd-display "bigger find-mix ~A ~A" mxd mx)))
	    (set! (cursor ind) size)
	    (if (not (= (cursor ind) size)) (snd-display "bigger cursor 123: ~A" (cursor ind))))
	  (close-sound ind))))
    
    (let ((ind (new-sound "tmp.snd" 1 22050 mus-l24int mus-riff :size 100000)))
      (let-temporarily ((*selection-creates-region* #t))
	(let ((incr (/ 1.0 (framples)))
	      (data (make-float-vector (framples))))
	  (outa->fv data (- (* i incr) 0.5))
	  (float-vector->channel data))
	(save-sound)
	(close-sound ind)))

    (let ((ind (open-sound "tmp.snd")))
      (let ((reg (select-all))
	    (v1 (make-float-vector 100000)))
	(save-selection "tmp1.snd" 22050 mus-l24int mus-next)
	(let ((ind1 (open-sound "tmp1.snd")))
	  (let ((incr (/ 1.0 (framples))))
	    (outa->fv v1 (- (* i incr) 0.5))
	    (let ((v0 (samples 0 100000 ind1 0)))
	      (if (not (mus-arrays-equal? v0 v1))
		  (snd-display "l24 (next) selection not saved correctly? ~A" v0))))
	  (close-sound ind1))
	  
	(save-selection "tmp1.snd" 22050 mus-l24int mus-aifc)
	(let ((ind1 (open-sound "tmp1.snd")))
	  (let ((v0 (samples 0 100000 ind1 0)))
	    (if (not (mus-arrays-equal? v0 v1))
		(snd-display "l24 (aifc) selection not saved correctly? ~A" v0)))
	  (close-sound ind1))
	
	(save-region reg "tmp1.snd" mus-l24int mus-next)
	(let ((ind1 (open-sound "tmp1.snd")))
	  (let ((v0 (samples 0 100000 ind1 0)))
	    (if (not (mus-arrays-equal? v0 v1))
		(snd-display "l24 (next) region not saved correctly? ~A" v0)))
	  (close-sound ind1))
	(delete-file "tmp1.snd")
	(close-sound ind)
	(delete-file "tmp.snd")))
    
    (let ((ind (new-sound "tmp.snd" 1 22050 mus-ldouble mus-next :size 10 :comment #f)))
      (map-channel (lambda (y) 1.0))
      (env-channel '(0 0 .1 .1 .2 .2 .3 .3 .4 .4 .5 .5 .6 .6 .7 .7 .8 .8 .9  .9))
      (if (not (mus-arrays-equal? (channel->float-vector) #r(0.0 0.100 0.200 0.300 0.400 0.500 0.600 0.700 0.800 0.900)))
	  (snd-display "ramp env by .1: ~A" (channel->float-vector)))
      (close-sound ind)))
  
  (set! (hook-functions open-raw-sound-hook) ())
  (hook-push open-raw-sound-hook (lambda (hook) (set! (hook 'result) #t)))
  (set! (hook-functions bad-header-hook) ())
  (hook-push bad-header-hook (lambda (hook) (set! (hook 'result) #t)))
  (if (null? (hook-functions open-raw-sound-hook)) (snd-display "add hook open-raw-sound-hook failed??"))
  (if (null? (hook-functions bad-header-hook)) (snd-display "add hook bad-header-hook failed??"))
  (let ((magic-words (vector ".snd" "FORM" "AIFF" "AIFC" "COMM" "COMT" "INFO" "INST" "inst" "MARK" "SSND"
			     "FVER" "NONE" "ULAW" "ulaw" "ima4" "raw " "sowt" "in32" "in24" "ni23" "fl32"
			     "FL32" "fl64" "twos" "ALAW" "alaw" "APPL" "CLM " "RIFF" "RIFX" "WAVE" "fmt "
			     "data" "fact" "clm " "NIST" "8SVX" "16SV" "Crea" "tive" "SOUN" "D SA" "MPLE"
			     "BODY" "VHDR" "CHAN" "ANNO" "NAME" "2BIT" "HCOM" "FSSD" "%//\n" "%---" "ALaw"
			     "Soun" "MAUD" "MHDR" "MDAT" "mdat" "MThd" "sfbk" "sdta" "shdr" "pdta"
			     "LIST" "GF1P" "ATCH" "$SIG" "NAL_" "GOLD" " SAM" "SRFS" "Diam" "ondW" "CSRE"
			     "SND " "SNIN" "SNDT" "DDSF" "FSMu" "UWFD" "LM89" "SY80" "SY85" "SCRS" "DSPL"
			     "AVI " "strf" "movi" "PRAM" " paf" "fap " "DS16" "HEDR" "HDR8" "SDA_" "SDAB"
			     "SD_B" "NOTE" "file" "=sam" "SU7M" "SU7R" "PVF1" "PVF2" "AUTH" "riff" "TWIN"
			     "IMPS" "SMP1" "Maui" "SDIF")))
    (let ((len (length magic-words))
	  (ctr 0))
      (for-each
       (lambda (magic)
	 (if (null? (hook-functions open-raw-sound-hook)) (snd-display "open-raw-sound-hook cleared??"))
	 (if (null? (hook-functions bad-header-hook)) (snd-display "bad-header-hook cleared??"))
	 (if (file-exists? "test.snd")
	     (delete-file "test.snd"))
	 (mus-sound-forget "test.snd")
	 ;; try random garbage
	 (with-output-to-file "test.snd"
	   (lambda ()
	     (display magic)
	     (do ((i 0 (+ i 1)))
		 ((= i 128))
	       (write (random 1.0)))))
	 (let ((tag (catch #t
		      (lambda ()
			(open-sound "test.snd"))
		      (lambda args (car args)))))
	   (when (and (number? tag)
		      (sound? tag))
	     (snd-display "open-sound garbage ~A: ~A -> ~A?" magic tag (file->string "test.snd"))
	     (if (sound? tag) (close-sound tag))))
	 (delete-file "test.snd")
	 (mus-sound-forget "test.snd")
	 ;; try plausible garbage
	 (with-output-to-file "test.snd"
	   (lambda ()
	     (display magic)
	     (do ((i 0 (+ i 1)))
		 ((= i 128))
	       (write (random 128)))))
	 (let ((tag (catch #t
		      (lambda ()
			(open-sound "test.snd"))
		      (lambda args (car args)))))
	   (when (and (number? tag)
		      (sound? tag))
	     (snd-display "open-sound plausible garbage ~A: ~A?" magic tag)
	     (if (sound? tag) (close-sound tag))))
	 (delete-file "test.snd")
	 (mus-sound-forget "test.snd")
	 ;; write very plausible garbage
	 (with-output-to-file "test.snd"
	   (lambda ()
	     (display magic)
	     (do ((i 1 (+ i 1)))
		 ((= i 12))
	       (display (magic-words (if (< (+ ctr i) len) (+ ctr i) i))))))
	 (let ((tag (catch #t
		      (lambda ()
			(open-sound "test.snd"))
		      (lambda args (car args)))))
	   (when (and (number? tag)
		      (sound? tag))
	     (snd-display "open-sound very plausible garbage ~A: ~A?" magic tag)
	     (if (sound? tag) (close-sound tag))))
	 (set! ctr (+ ctr 1)))
       magic-words)))
  (if (file-exists? "test.snd") (delete-file "test.snd"))
  (mus-sound-forget "test.snd")
  
  (with-output-to-file "test.snd"
    (lambda ()
      (display ".snd")
      (for-each write-byte '(0 0 0 28 0 1 141 24 0 0 0 18 0 0 86 34 0 0 0 1 0 0 0 0 0 1))))
  (if (not (= (mus-sound-sample-type "test.snd") mus-bshort))
      (snd-display "next 18: ~A" (mus-sound-sample-type "test.snd")))
  (delete-file "test.snd")
  (mus-sound-forget "test.snd")
  (with-output-to-file "test.snd"
    (lambda ()
      (display ".snd")
      (for-each write-byte '(0 0 0 4 0 1 141 24 0 0 0 18 0 0 86 34 0 0 0 1 0 0 0 0 0 1))))
  (let ((tag (catch #t
	       (lambda ()
		 (open-sound "test.snd"))
	       (lambda args (car args)))))
    (when (and (number? tag)
	       (sound? tag))
      (snd-display "open-sound next bad location ~A: ~A?" (data-location tag) tag)
      (close-sound tag)))
  (delete-file "test.snd")
  (mus-sound-forget "test.snd")
  
  (let ((make-aifc-file 
	 (lambda (len auth-lo bits)
	   (with-output-to-file "test.aif"
	     (lambda ()
	       (display "FORM")
	       (for-each write-byte '(0 0 0 102))
	       (display "AIFCFVER")
	       (for-each write-byte '(0 0 0 4 162 128 81 64))
	       (display "COMM")
	       (for-each write-byte (list 0 0 0 38 0 1 0 0 0 len 0 bits 64 14 172 68 0 0 0 0 0 0))
	       ;; srate as 80-bit float (sheesh)
	       (display "NONE") ; compression
	       (write-byte #o016) ; pascal string len
	       (display "not compressed")
	       (write-byte #o000)
	       (display "AUTH")
	       (for-each write-byte (list 0 0 0 auth-lo))
	       (display "bil")
	       (write-byte #o000)
	       (display "SSND")
	       (for-each write-byte '(0 0 0 12 0 0 0 0 0 0 0 0 0 65 0 64)))))))
    (if (file-exists? "test.aif") (delete-file "test.aif"))
    (mus-sound-forget "test.aif")
    ;; correct (make-aifc-file #o002 #o004 #o020)
    (make-aifc-file #o102 #o004 #o020)
    
    (catch #t
      (lambda ()
	(let ((ind (open-sound "test.aif")))
	  (if (not (= (framples ind) 2)) (snd-display "bad framples in header: ~A" (framples ind)))
	  (close-sound ind)))
      (lambda args (snd-display "~S" args)))
    (delete-file "test.aif")
    (mus-sound-forget "test.aif")
    (make-aifc-file #o002 #o150 #o020)
    (let ((tag (catch #t
		 (lambda ()
		   (open-sound "test.aif"))
		 (lambda args (car args)))))
      (when (and (number? tag)
		 (sound? tag))
	(snd-display "open-sound aifc no ssnd chunk ~A: ~A?" (data-location tag) tag)
	(close-sound tag)))
    (delete-file "test.aif")
    (mus-sound-forget "test.aif")
    (make-aifc-file #o002 #o000 #o020)
    
    (let ((tag (catch #t
		 (lambda ()
		   (open-sound "test.aif"))
		 (lambda args (car args)))))
      (when (and (number? tag)
		 (sound? tag))
	(snd-display "open-sound aifc 0-len auth chunk ~A: ~A?" (data-location tag) tag)
	(close-sound tag)))
    (delete-file "test.aif")
    (mus-sound-forget "test.aif")
    (make-aifc-file #o002 #o150 #o120)
    (let ((tag (catch #t
		 (lambda ()
		   (open-sound "test.aif"))
		 (lambda args (car args)))))
      (when (and (number? tag)
		 (sound? tag))
	(snd-display "open-sound bits 80 ~A: ~A?" (sample-type tag) tag)
	(close-sound tag)))
    (delete-file "test.aif")
    (mus-sound-forget "test.aif"))
  
  (with-output-to-file "test.aif"
    (lambda ()
      (display "FORM")
      (for-each write-byte '(0 0 0 126))
      (display "AIFCFVER")
      (for-each write-byte '(0 0 0 4 162 128 81 64))
      (display "COMM")
      (for-each write-byte '(0 0 0 38 0 1 0 0 0 2 0 16 64 14 172 68 0 0 0 0 0 0))
      (display "NONE") ; compression
      (write-byte #o016) ; pascal string len
      (display "not compressed")
      (write-byte #o000)
      (display "AUTH")
      (for-each write-byte '(0 0 0 4))
      (display "bil")
      (write-byte #o000)
      (display "ANNO")
      (for-each write-byte '(0 0 0 4))
      (display "cat")
      (write-byte #o000)
      (display "NAME")
      (for-each write-byte '(0 0 0 4))
      (display "dog")
      (write-byte #o000)
      (display "SSND")
      (for-each write-byte '(0 0 0 12 0 0 0 0 0 0 0 0 0 65 0 64))))
  (catch #t
    (lambda ()
      (if (not (= (length (mus-sound-comment "test.aif")) 15))
	  (snd-display "aifc 3 aux comments: ~A?" (mus-sound-comment "test.aif"))))
    (lambda args (snd-display "~S" args)))
  (delete-file "test.aif")
  (mus-sound-forget "test.aif")
  (with-output-to-file "test.aif"
    (lambda ()
      (display "FORM")
      (for-each write-byte '(0 0 0 98))
      (display "AIFC")
      (display "SSND")
      (for-each write-byte '(0 0 0 12 0 0 0 0 0 0 0 0 0 65 0 64))
      (display "COMM")
      (for-each write-byte '(0 0 0 38 0 1 0 0 0 2 0 16 64 14 172 68 0 0 0 0 0 0))
      (display "NONE") ; compression
      (write-byte #o016) ; pascal string len
      (display "not compressed")
      (write-byte #o000)
      (display "COMT")
      (for-each write-byte '(0 0 0 12 0 0 0 0 0 0 0 0))
      (display "bil")
      (write-byte #o000)))
  
  (catch #t
    (lambda ()
      (if (not (string=? (substring (mus-sound-comment "test.aif") 0 3) "bil"))
	  (snd-display "aifc trailing comt comment: ~A?" (mus-sound-comment "test.aif"))))
    (lambda args (snd-display "~S" args)))
  (if (not (= (mus-sound-framples "test.aif") 2))
      (snd-display "aifc trailing comt framples: ~A?" (mus-sound-framples "test.aif")))
  (catch #t
    (lambda ()
      (let ((ind (open-sound "test.aif")))
	(if (or (fneq (sample 0) 0.00198)
		(fneq (sample 1) 0.00195)
		(fneq (sample 2) 0.0)
		(fneq (sample 3) 0.0))
	    (snd-display "aifc trailing comt samps: ~A ~A ~A ~A" (sample 0) (sample 1) (sample 2) (sample 3)))
	(close-sound ind)))
    (lambda args (snd-display "~S" args)))
  (delete-file "test.aif")
  (mus-sound-forget "test.aif")
  (with-output-to-file "test.aif"
    (lambda ()
      (display "FORM")
      (for-each write-byte '(0 0 0 98))
      (display "AIFC")
      (display "SSND")
      (for-each write-byte '(0 0 0 12 0 0 0 0 0 0 0 0 0 65 0 64))
      (display "COMM")
      (for-each write-byte '(0 0 0 38 0 1 0 0 64 66 0 16 64 14 172 68 0 0 0 0 0 0))
      (display "NONE") ; compression
      (write-byte #o016) ; pascal string len
      (display "not compressed")
      (write-byte #o000)
      (display "COMT")
      (for-each write-byte '(0 0 0 12 0 0 0 0 0 0 0 0))
      (display "bil")
      (write-byte #o000)))
  (if (not (and (string? (mus-sound-comment "test.aif"))
		(string=? (substring (mus-sound-comment "test.aif") 0 3) "bil")))
      (snd-display "aifc trailing comt comment: ~A?" (mus-sound-comment "test.aif")))
  (if (not (= (mus-sound-framples "test.aif") 2))
      (snd-display "aifc trailing comt (bogus) framples: ~A?" (mus-sound-framples "test.aif")))
  (catch #t
    (lambda ()
      (let ((ind (open-sound "test.aif")))
	(if (or (fneq (sample 0) 0.00198)
		(fneq (sample 1) 0.00195)
		(fneq (sample 2) 0.0)
		(fneq (sample 3) 0.0))
	    (snd-display "aifc trailing comt samps (bogus frame setting): ~A ~A ~A ~A" (sample 0) (sample 1) (sample 2) (sample 3)))
	(close-sound ind)))
    (lambda args (snd-display "~S" args)))
  (delete-file "test.aif")
  (mus-sound-forget "test.aif")
  (with-output-to-file "test.aif"
    (lambda ()
      (display "FORM")
      (for-each write-byte '(0 0 0 98))
      (display "AIFC")
      (display "SSND")
      (for-each write-byte '(0 0 0 12 0 0 0 0 0 0 0 0 0 65 0 64))
      (display "COMM")
      (for-each write-byte '(0 0 0 38 0 1 0 0 64 66 0 16 64 14 172 68 0 0 0 0 0 0))
      (display "NONE") ; compression
      (write-byte #o016) ; pascal string len
      (display "not compressed")
      (write-byte #o000)
      (display "SSND")
      (for-each write-byte '(0 0 0 12 0 0 0 0 0 0 0 0 0 65 0 64))))
  
  (let ((tag (catch #t
	       (lambda ()
		 (open-sound "test.aif"))
	       (lambda args (car args)))))
    (when (and (number? tag)
	       (sound? tag))
      (snd-display "open-sound aifc 2 ssnd chunks ~A: ~A?" (data-location tag) tag)
      (close-sound tag)))
  (delete-file "test.aif")
  (mus-sound-forget "test.aif")
  
  (with-output-to-file "test.aif"
    (lambda ()
      (display "FORM")
      (for-each write-byte '(0 0 0 32))
      (display "AIFC")
      (display "SSND")
      (for-each write-byte '(0 0 0 12 0 0 0 0 0 0 0 0 0 65 0 64))))
  (let ((tag (catch #t
	       (lambda ()
		 (open-sound "test.aif"))
	       (lambda args (car args)))))
    (unless (eq? tag 'mus-error)
      (snd-display "open-sound aifc no comm chunk ~A?" tag)
      (if (and (number? tag)
	       (sound? tag))
	  (close-sound tag))))
  (delete-file "test.aif")
  (mus-sound-forget "test.aif")
  
  (with-output-to-file "test.aif"
    (lambda ()
					;write AIFC with trailing chunks to try to confuse file->sample
      (display "FORM")
      (for-each write-byte '(0 0 0 126))
      (display "AIFCFVER")
      (for-each write-byte '(0 0 0 4 162 128 81 64))
      (display "COMM")
      (for-each write-byte '(0 0 0 38 0 1 0 0 0 2 0 16 64 14 172 68 0 0 0 0 0 0))
      (display "NONE") ; compression
      (write-byte #o016) ; pascal string len
      (display "not compressed")
      (write-byte #o000)
      (display "SSND")
      (for-each write-byte '(0 0 0 12 0 0 0 0 0 0 0 0 120 65 64 64))
      (display "AUTH")
      (for-each write-byte '(0 0 0 4))
      (display "bil")
      (write-byte #o000)
      (display "ANNO")
      (for-each write-byte '(0 0 0 4))
      (display "cat")
      (write-byte #o000)
      (display "NAME")
      (for-each write-byte '(0 0 0 4))
      (display "dog")
      (write-byte #o000)))
  (catch #t
    (lambda ()
      (let ((gen (make-file->sample "test.aif")))
	(if (fneq (gen 0) 0.93948) (snd-display "file->sample chunked 0: ~A" (gen 0)))
	(if (fneq (gen 1) 0.50195) (snd-display "file->sample chunked 1: ~A" (gen 1)))
	(if (fneq (gen 2) 0.0) (snd-display "file->sample chunked eof: ~A" (gen 2)))
	(if (fneq (gen 3) 0.0) (snd-display "file->sample chunked eof+1: ~A" (gen 3))))
      (let ((file (open-sound "test.aif")))
	(if (not (= (framples file) 2)) (snd-display "chunked framples: ~A" (framples file)))
	(if (fneq (sample 0) 0.93948) (snd-display "file chunked 0: ~A" (sample 0)))
	(if (fneq (sample 1) 0.50195) (snd-display "file chunked 1: ~A" (sample 1)))
	(if (fneq (sample 2) 0.0) (snd-display "file chunked eof: ~A" (sample 2)))
	(if (fneq (sample 3) 0.0) (snd-display "file chunked eof+1: ~A" (sample 3)))
	(close-sound file)))
    (lambda args (snd-display "~S" args)))
  (catch #t
    (lambda ()
      (if (not (= (mus-sound-framples "test.aif") 2)) (snd-display "chunked mus-sound-framples: ~A" (mus-sound-framples "test.aif"))))
    (lambda args (snd-display "~S" args)))
  (delete-file "test.aif")
  (mus-sound-forget "test.aif")
  
  (with-output-to-file "test.aif"
    (lambda ()
					;write AIFC with trailing chunks to try to confuse file->sample
      (display "FORM")
      (for-each write-byte '(0 0 0 126))
      (display "AIFCFVER")
      (for-each write-byte '(0 0 0 4 162 128 81 64))
      (display "SSND")
      (for-each write-byte '(0 0 0 12 0 0 0 0 0 0 0 0 120 65 64 64))
      (display "COMM")
      (for-each write-byte '(0 0 0 38 0 1 0 0 0 2 0 16 64 14 172 68 0 0 0 0 0 0))
      (display "NONE") ; compression
      (write-byte #o016) ; pascal string len
      (display "not compressed")
      (write-byte #o000)
      (display "APPL")
      (for-each write-byte (list 0 0 0 (char->integer #\h)))
      (display "CLM ;Written Mon 02-Nov-98 01:44 CST by root at ockeghem (Linux/X86) using Allegro CL, clm of 20-Oct-98")
      (write-byte #o000)))
  (catch #t
    (lambda ()
      (let ((gen (make-file->sample "test.aif")))
	(if (fneq (gen 0) 0.93948) (snd-display "file->sample chunked 0: ~A" (gen 0)))
	(if (fneq (gen 1) 0.50195) (snd-display "file->sample chunked 1: ~A" (gen 1)))
	(if (fneq (gen 2) 0.0) (snd-display "file->sample chunked eof: ~A" (gen 2)))
	(if (fneq (gen 3) 0.0) (snd-display "file->sample chunked eof+1: ~A" (gen 3))))
      (let ((file (open-sound "test.aif")))
	(if (not (= (framples file) 2)) (snd-display "chunked framples: ~A" (framples file)))
	(if (fneq (sample 0) 0.93948) (snd-display "file chunked 0: ~A" (sample 0)))
	(if (fneq (sample 1) 0.50195) (snd-display "file chunked 1: ~A" (sample 1)))
	(if (fneq (sample 2) 0.0) (snd-display "file chunked eof: ~A" (sample 2)))
	(if (fneq (sample 3) 0.0) (snd-display "file chunked eof+1: ~A" (sample 3)))
	(if (not (equal? (comment) ";Written Mon 02-Nov-98 01:44 CST by root at ockeghem (Linux/X86) using Allegro CL, clm of 20-Oct-98"))
	    (snd-display "chunked appl comment: ~A" (comment)))
	(close-sound file)))
    (lambda args (snd-display "~S" args)))
  (delete-file "test.aif")
  (mus-sound-forget "test.aif")
  
  (with-output-to-file "test.aif"
    (lambda ()
					;write AIFC with trailing chunks to try to confuse file->sample
      (display "FORM")
      (for-each write-byte '(0 0 0 126))
      (display "AIFCFVER")
      (for-each write-byte '(0 0 0 4 162 128 81 64))
      (display "SSND")
      (for-each write-byte '(0 0 0 12 0 0 0 0 0 0 0 0 120 65 64 64))
      (display "COMM")
      (for-each write-byte '(0 0 0 38 0 2 0 0 0 1 0 16 64 14 172 68 0 0 0 0 0 0))
      (display "NONE") ; compression
      (write-byte #o016) ; pascal string len
      (display "not compressed")
      (write-byte #o000)
      (display "APPL")
      (for-each write-byte (list 0 0 0 (char->integer #\h)))
      (display "CLM ;Written Mon 02-Nov-98 01:44 CST by root at ockeghem (Linux/X86) using Allegro CL, clm of 20-Oct-98")
      (write-byte #o000)))
  (catch #t
    (lambda ()
      (let ((gen (make-file->sample "test.aif")))
	(if (fneq (gen 0 0) 0.93948) (snd-display "file->sample chunked 0 0: ~A" (gen 0 0)))
	(if (fneq (gen 0 1) 0.50195) (snd-display "file->sample chunked 0 1: ~A" (gen 0 1)))
	(if (fneq (gen 1 0) 0.0) (snd-display "file->sample chunked eof(stereo): ~A" (gen 1 0)))
	(if (fneq (gen 1 1) 0.0) (snd-display "file->sample chunked eof+1 (stereo): ~A" (gen 1 1))))
      (let ((file (open-sound "test.aif")))
	(if (not (= (framples file) 1)) (snd-display "chunked framples (1): ~A" (framples file)))
	(if (fneq (sample 0 file 0) 0.93948) (snd-display "file chunked 0 0: ~A" (sample 0 file 0)))
	(if (fneq (sample 0 file 1) 0.50195) (snd-display "file chunked 0 1: ~A" (sample 0 file 1)))
	(if (fneq (sample 1 file 0) 0.0) (snd-display "file chunked eof (stereo): ~A" (sample 1 file 0)))
	(if (fneq (sample 1 file 1) 0.0) (snd-display "file chunked eof+1 (stereo): ~A" (sample 1 file 1)))
	(if (not (equal? (comment) ";Written Mon 02-Nov-98 01:44 CST by root at ockeghem (Linux/X86) using Allegro CL, clm of 20-Oct-98"))
	    (snd-display "chunked appl comment (stereo): ~A" (comment)))
	(close-sound file)))
    (lambda args (snd-display "~S" args)))
  (delete-file "test.aif")
  (mus-sound-forget "test.aif")
  
  (let ((files (sound-files-in-directory cwd)))
    (if (null? files) (snd-display "no sound files in ~A?" cwd))
    (let ((files1 (sound-files-in-directory)))
      (if (not (equal? files files1)) (snd-display "different sound files in ~A and default?~%    ~A~%    ~A~%" cwd files files1))
      (let ((files2 (sound-files-in-directory "."))
	    
	    (difference (lambda (a b)
			  (let ((diffs ()))
			    (for-each
			     (lambda (f)
			       (if (not (member f b)) (set! diffs (cons f diffs))))
			     a)
			    (for-each
			     (lambda (f)
			       (if (not (member f a)) (set! diffs (cons f diffs))))
			     b)
			    diffs))))
	
	(if (not (and (equal? files1 files2)
		      (equal? files files2)))
	    (snd-display "sound-files-in-directory dot: ~A~%    ~A~% but ~A" (difference files2 files) files2 files)))))
  
  (set! (hook-functions bad-header-hook) ())
  (set! (hook-functions open-raw-sound-hook) ())
  (if (pair? (sounds)) (for-each close-sound (sounds)))
  
  (let ((ind (new-sound :size 0)))
    (if (not (= (framples ind) 0)) (snd-display "new-sound :size 0 -> ~A framples" (framples ind)))
    (if (fneq (sample 0) 0.0) (snd-display "new-sound :size 0 sample 0: ~A" (sample 0)))
    (clean-up-sound ind))
  (let ((ind (new-sound :size 1)))
    (if (not (= (framples ind) 1)) (snd-display "new-sound :size 1 -> ~A framples" (framples ind)))
    (if (fneq (sample 0) 0.0) (snd-display "new-sound :size 1 sample 0: ~A" (sample 0)))
    (clean-up-sound ind))
  (let ((tag (catch #t
	       (lambda () (new-sound :size -1))
	       (lambda args (car args)))))
    (unless (eq? tag 'out-of-range)
      (snd-display "new-sound :size -1: ~A" tag)
      (if (pair? (sounds)) (for-each close-sound (sounds)))))
  
  (let ((ind (read-ascii (string-append sf-dir "caruso.asc"))))
    (if (not (sound? ind)) 
	(snd-display "read-ascii can't find ~A (~A)" (string-append sf-dir "caruso.asc") (map file-name (sounds)))
	(begin
	  (if (fneq (maxamp ind 0) 0.723) (snd-display "read-ascii maxamp: ~A" (maxamp ind 0)))
	  (if (not (= (framples ind 0) 50000)) (snd-display "read-ascii framples: ~A" (framples ind 0)))
	  (if (not (= (srate ind) 44100)) (snd-display "read-ascii srate: ~A" (srate ind)))
	  (set! (srate ind) 8000)
	  (if (or (not (= (framples ind 0) 50000))
		  (fneq (maxamp ind 0) .723))
	      (snd-display "set srate clobbered new sound: ~A ~A (~A)" (framples ind 0) (maxamp ind 0) (srate ind)))
	  
	  (close-sound ind))))
  
  (let ((ind (open-sound "oboe.snd")))
    (save-sound-as "test space.snd")
    (close-sound ind)
    (set! ind (open-sound "test space.snd"))
    (if (not (string=? (short-file-name ind) "test space.snd"))
	(snd-display "file name with space: ~A" (short-file-name ind)))
    (let ((len (framples ind))
	  (slen (mus-sound-framples "test space.snd")))
      (if (not (= len slen)) (snd-display "spaced filename framples: ~A ~A" len slen)))
    (add-mark 1234 ind 0)
    (save-marks ind) ; should write "test space.marks"
    (close-sound ind))
  (let ((ind (open-sound "test space.snd")))
    (load (string-append cwd "test space.marks"))
    (if (not (find-mark 1234 ind))
	(snd-display "space file name save marks: ~A" (marks ind)))
    (let ((rdf (mus-file-name (make-readin :file "test space.snd"))))
      (if (not (string=? rdf "test space.snd"))
	  (snd-display "file name with space readin: ~A" rdf)))
    (close-sound ind))
  (if (file-exists? "test space.snd")
      (delete-file "test space.snd"))
  (if (file-exists? "test space.marks")
      (delete-file "test space.marks"))
  
  (if (directory? "oboe.snd") (snd-display "directory? oboe.snd!"))
  (if (not (directory? ".")) (snd-display "directory? . #f!"))
  (if (string=? "" (getenv "PATH")) (snd-display "getenv: no PATH?"))
  (if (not (number? (getpid))) (snd-display "getpid: ~A" (getpid)))
  
  (unless (provided? 'gmp)
    (let ((LONG_MAX 2147483647)
	  (LONG_MIN -2147483648))
      (let ((ints (vector 0 1 -1 10 -10 1234 -1234 LONG_MAX LONG_MIN 65536 -65536))
	    (shorts (vector 0 1 -1 10 -10 1234 -1234 32767 -32768 8191 -8191))
	    (longs (vector 0 1 -1 11 -11 LONG_MAX LONG_MIN most-positive-fixnum most-negative-fixnum 1000 -1000))
	    (floats (vector 0.0 1.0 -1.0 0.1 -0.1 10.0 -10.0 1234.0 65536.0 -1234.0 -0.003))
	    (doubles (vector 0.0 1.0 -1.0 0.1 -0.1 10.0 -10.0 1234.0 65536.0 -1234.0 -0.003)))
	(load "binary-io.scm")
	
	(let ((lst (read-aif-header "4.aiff")))
	  (if (not (equal? lst '("AIFF" 44 6758392 16 22050 4)))
	      (snd-display "read-aif-header: ~S" lst)))
	(let ((lst (read-au-header "oboe.snd")))
	  (if (not (equal? lst '(".snd" 28 101656 3 22050 1 "")))
	      (snd-display "read-au-header: ~S" lst)))

	(with-output-to-file "idf1.data"
	  (lambda ()
	    
	    (write-lint32 123)
	    (write-bint32 321)
	    
	    (do ((i 0 (+ i 1)))
		((= i 11))
	      (write-lint32 (ints i))
	      (write-bint32 (ints i)))
	    
	    (do ((i 0 (+ i 1)))
		((= i 11))
	      (write-lint16 (shorts i))
	      (write-bint16 (shorts i)))
	    
	    (do ((i 0 (+ i 1)))
		((= i 11))
	      (write-lint64 (longs i))
	      (write-bint64 (longs i)))
	    
	    (do ((i 0 (+ i 1)))
		((= i 11))
	      (write-lfloat32 (floats i))
	      (write-bfloat32 (floats i)))
	    
	    (do ((i 0 (+ i 1)))
		((= i 11))
	      (write-lfloat64 (doubles i))
	      (write-bfloat64 (doubles i)))))
	
	(with-input-from-file "idf1.data" 
	  (let ((testf (lambda (val1 val2 name)
			 (if (not (= val1 val2))
			     (if (not (memq name '(lfloat32 bfloat32)))
				 (snd-display "testf ~A: ~A != ~A~%" name val1 val2)
				 (if (> (abs (- val1 val2)) 1.0e-6)
				     (snd-display "testf ~A: ~A != ~A (~A)~%" name val1 val2 (abs (- val1 val2)))))))))
	    (lambda ()
	      (testf (read-lint32) 123 'lint32)
	      (testf (read-bint32) 321 'bint32)
	      
	      (do ((i 0 (+ i 1)))
		  ((= i 11))
		(testf (read-lint32) (ints i) 'lint32)
		(testf (read-bint32) (ints i) 'bint32))
	      
	      (do ((i 0 (+ i 1)))
		  ((= i 11))
		(testf (read-lint16) (shorts i) 'lint16)
		(testf (read-bint16) (shorts i) 'bint16))
	      
	      (do ((i 0 (+ i 1)))
		  ((= i 11))
		(testf (read-lint64) (longs i) 'lint64)
		(testf (read-bint64) (longs i) 'bint64))
	      
	      (do ((i 0 (+ i 1)))
		  ((= i 11))
		(testf (read-lfloat32) (floats i) 'lfloat32)
		(testf (read-bfloat32) (floats i) 'bfloat32))
	      
	      (do ((i 0 (+ i 1)))
		  ((= i 11))
		(testf (read-lfloat64) (doubles i) 'lfloat64)
		(testf (read-bfloat64) (doubles i) 'bfloat64)))))))))



;;; ---------------- test 5: simple overall checks ----------------

(require snd-selection.scm snd-extensions.scm snd-selection.scm snd-dsp.scm snd-pvoc.scm)
(if with-gui (require snd-edit-menu.scm))

(define (snd_test_5)
  
  (define (string-=? a b)
    (or (string=? a b)
	(and (or (char-position #\- a) 
		 (char-position #\- b))
	     (let ((alen (length a))
		   (blen (length b))
		   (j 0)
		   (happy #t))
	       (do ((b7 (- blen 7))
		    (a7 (- alen 7))
		    (i 0 (+ i 1)))
		   ((or (not happy) 
			(= i alen))
		    (and happy 
			 (= j blen)))
		 (let ((ac (a i))
		       (bc (b j)))
		   (if (char=? ac bc)
		       (set! j (+ j 1))
		       (if (not (and (char=? ac #\-)	
				     (<= i a7)
				     (string=? (substring a i (+ i 6)) "-0.000")))
			   (if (and (char=? bc #\-)
				    (<= j b7)
				    (string=? (substring b j (+ j 6)) "-0.000"))
			       (begin
				 (set! j (+ j 1))
				 (if (not (char=? ac (b j)))
				     (set! happy #f)
				     (set! j (+ j 1))))
			       (set! happy #f))))))))))
    
  (if (playing) (snd-display "dac is running??"))
  (do ((clmtest 0 (+ 1 clmtest))) 
      ((= clmtest tests)) 
    (log-mem clmtest)
    
    (let ((ind (open-sound "oboe.snd")))
      (set! (transform-graph? ind 0) #t)
      (set! (transform-graph-type ind 0) graph-as-sonogram)
      (catch 'no-such-axis
	(lambda ()
	  (set! (y-axis-label ind 0 1) "hiho") #f)
	(lambda args
	  (snd-display "no fft axis: ~A" args)))
      (set! (fft-log-frequency ind 0) #t) ; segfault here originally
      (update-transform-graph ind 0)
      (close-sound ind))
    
    (let ((ind (new-sound "test.snd" :size 10)))
      (float-vector->channel (make-float-vector 10 1.0))
      (env-channel '(0 0 1 1 2 0))
      (let ((data (channel->float-vector)))
	(if (not (mus-arrays-equal? data #r(0.0 0.200 0.400 0.600 0.800 1.0 0.750 0.500 0.250 0.000)))
	    (snd-display "pyr 10: ~A" data)))
      (undo)
      (env-channel '((0 0) (1 1) (2 0)))
      (let ((data (channel->float-vector)))
	(if (not (mus-arrays-equal? data #r(0.0 0.200 0.400 0.600 0.800 1.0 0.750 0.500 0.250 0.000)))
	    (snd-display "pyr 10: ~A" data)))
      (undo)
      (env-channel (make-env '(0 0 1 1 2 0) :length 10))
      (let ((data (channel->float-vector)))
	(if (not (mus-arrays-equal? data #r(0.0 0.200 0.400 0.600 0.800 1.0 0.750 0.500 0.250 0.000)))
	    (snd-display "pyr 10: ~A" data)))
      (undo)
      (close-sound ind))
    
    (for-each
     (lambda (size)
       (let ((ind (new-sound "test.snd" :size size))
	     (incr (/ 1.0 (- size 1)))
	     (e (make-env '(0 0 1 1) :length size)))
	 (float-vector->channel (make-float-vector size 1.0))
	 
	 (ramp-channel 0.0 1.0)
	 (let ((data (channel->float-vector)))
	   (if (or (fneq (data 0) 0.0)
		   (fneq (data (- size 1)) 1.0))
	       (snd-display "ramp-channel ~A end points: ~A ~A" size (data 0) (data (- size 1))))
	   (do ((i 0 (+ i 1)))
	       ((= i size))
	     (let ((val (envelope-interp (* i incr) '(0.0 0.0 1.0 1.0)))
		   (segval (env e)))
	       (if (or (fneq segval val)
		       (fneq (data i) val))
		   (snd-display "ramp-channel ~A of ~A: ramp: ~A, interp: ~A, env: ~A" i size (data i) val segval)))))
	 (undo)
	 (xramp-channel 0.0 1.0 32.0)
	 (let* ((e (make-env '(0 0 1 1) :length size :base 32.0))
		(data (channel->float-vector)))
	   (if (or (fneq (data 0) 0.0)
		   (fneq (data (- size 1)) 1.0))
	       (snd-display "xramp-channel 32 ~A end points: ~A ~A" size (data 0) (data (- size 1))))
	   (do ((i 0 (+ i 1)))
	       ((= i size))
	     (let ((val (envelope-interp (* i incr) '(0.0 0.0 1.0 1.0) 32.0))
		   (segval (env e)))
	       (if (or (fneq segval val)
		       (fneq (data i) val))
		   (snd-display "xramp-channel 32 ~A of ~A: ramp: ~A, interp: ~A, env: ~A" i size (data i) val segval)))))
	 (undo)
	 (xramp-channel 0.0 1.0 0.4)
	 (let* ((e (make-env '(0 0 1 1) :length size :base 0.4))
		(data (channel->float-vector)))
	   (if (or (fneq (data 0) 0.0)
		   (fneq (data (- size 1)) 1.0))
	       (snd-display "xramp-channel .4 ~A end points: ~A ~A" size (data 0) (data (- size 1))))
	   (do ((i 0 (+ i 1)))
	       ((= i size))
	     (let ((val (envelope-interp (* i incr) '(0.0 0.0 1.0 1.0) 0.4))
		   (segval (env e)))
	       (if (or (fneq segval val)
		       (fneq (data i) val))
		   (snd-display "xramp-channel .4 ~A of ~A: ramp: ~A, interp: ~A, env: ~A" i size (data i) val segval)))))
	 (undo)
	 (xramp-channel 1.0 -1.0 8.0)
	 (let* ((e (make-env '(0 1 1 -1) :length size :base 8.0))
		(data (channel->float-vector)))
	   (if (or (fneq (data 0) 1.0)
		   (fneq (data (- size 1)) -1.0))
	       (snd-display "xramp-channel 1 -1 8 ~A end points: ~A ~A" size (data 0) (data (- size 1))))
	   (do ((i 0 (+ i 1)))
	       ((= i size))
	     (let ((segval (env e)))
	       (if (fneq segval (data i))
		   (snd-display "xramp-channel 1 -1 8 ~A of ~A: ramp: ~A, env: ~A" i size (data i) segval)))))
	 (undo)
	 (close-sound ind)))
     '(10 100 1000))
    
    ;; basic edit tree cases
    (let ((ind (new-sound "test.snd")))
      (if (not (= (redo) 0)) (snd-display "redo with no ops: ~A" (redo)))
      (if (not (= (undo) 0)) (snd-display "undo with no ops: ~A" (undo)))
      
      (if (not (string-=? (display-edits) (string-append "
EDITS: 0

 (begin) [0:2]:
   (at 0, cp->sounds[0][0:0, 0.000]) [file: " cwd "test.snd[0]]
   (at 1, end_mark)
")))
	  (snd-display "new 0: ~A" (display-edits)))
      (insert-samples 10 10 (make-float-vector 10))
      (if (not (= (framples) 20)) (snd-display "new 1 framples: ~A" (framples)))
      (if (not (string-=? (display-edits) (string-append "
EDITS: 1

 (begin) [0:2]:
   (at 0, cp->sounds[0][0:0, 0.000]) [file: " cwd "test.snd[0]]
   (at 1, end_mark)

 (insert 1 20) ; insert-samples [1:4]:
   (at 0, cp->sounds[0][0:0, 0.000]) [file: " cwd "test.snd[0]]
   (at 1, cp->sounds[-1][0:8, 0.000])
   (at 10, cp->sounds[1][0:9, 1.000]) [buf: 10] 
   (at 20, end_mark)
")))
	  (snd-display "new 1: ~A" (display-edits)))
      (undo)
      (insert-samples 0 10 (make-float-vector 10))
      (if (not (= (framples) 11)) (snd-display "new 2 framples: ~A" (framples))) ; 11 because there was 1 sample when new-sound created 
      (if (not (string-=? (display-edits) (string-append "
EDITS: 1

 (begin) [0:2]:
   (at 0, cp->sounds[0][0:0, 0.000]) [file: " cwd "test.snd[0]]
   (at 1, end_mark)

 (insert 0 10) ; insert-samples [1:3]:
   (at 0, cp->sounds[1][0:9, 1.000]) [buf: 10] 
   (at 10, cp->sounds[0][0:0, 0.000]) [file: " cwd "test.snd[0]]
   (at 11, end_mark)
")))
	  (snd-display "new 2: ~A" (display-edits)))
      (let ((eds (undo 2)))
	(if (not (= eds 2)) (snd-display "new 3 undo: ~A" eds)))
      (insert-samples 0 10 (make-float-vector 10))
      (if (not (= (framples) 11)) (snd-display "new 3 framples: ~A" (framples)))
      (if (not (string-=? (display-edits) (string-append "
EDITS: 1

 (begin) [0:2]:
   (at 0, cp->sounds[0][0:0, 0.000]) [file: " cwd "test.snd[0]]
   (at 1, end_mark)

 (insert 0 10) ; insert-samples [1:3]:
   (at 0, cp->sounds[1][0:9, 1.000]) [buf: 10] 
   (at 10, cp->sounds[0][0:0, 0.000]) [file: " cwd "test.snd[0]]
   (at 11, end_mark)
")))
	  (snd-display "new 3: ~A" (display-edits)))
      (undo)
      (set! (sample 0) .5)
      (if (not (= (framples) 1)) (snd-display "new 4 framples: ~A" (framples)))
      (if (not (string-=? (display-edits) (string-append "
EDITS: 1

 (begin) [0:2]:
   (at 0, cp->sounds[0][0:0, 0.000]) [file: " cwd "test.snd[0]]
   (at 1, end_mark)

 (set 0 1) ; set-sample 0 0.5000 [1:2]:
   (at 0, cp->sounds[1][0:0, 1.000]) [buf: 1] 
   (at 1, end_mark)
")))
	  (snd-display "new 4: ~A" (display-edits)))      
      (undo)
      
      (set! (samples 0 10) (make-float-vector 10))
      (if (not (= (framples) 10)) (snd-display "new 5 framples: ~A" (framples)))
      (if (not (string-=? (display-edits) (string-append "
EDITS: 1

 (begin) [0:2]:
   (at 0, cp->sounds[0][0:0, 0.000]) [file: " cwd "test.snd[0]]
   (at 1, end_mark)

 (set 0 10) ; set-samples [1:2]:
   (at 0, cp->sounds[1][0:9, 1.000]) [buf: 10] 
   (at 10, end_mark)
")))
	  (snd-display "new 5: ~A" (display-edits)))
      
      (delete-samples 3 4)
      (if (not (= (framples) 6)) (snd-display "new 6 framples: ~A" (framples)))
      (if (not (string-=? (safe-display-edits ind 0 2) "
 (delete 3 4) ; delete-samples 3 4 [2:3]:
   (at 0, cp->sounds[1][0:2, 1.000]) [buf: 10] 
   (at 3, cp->sounds[1][7:9, 1.000]) [buf: 10] 
   (at 6, end_mark)
"))
	  (snd-display "new 6: ~A" (safe-display-edits ind 0 2)))
      
      (set! (samples 1 4) (make-float-vector 4))
      (if (not (= (framples) 6)) (snd-display "new 7 framples: ~A" (framples)))
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (set 1 4) ; set-samples [3:4]:
   (at 0, cp->sounds[1][0:0, 1.000]) [buf: 10] 
   (at 1, cp->sounds[2][0:3, 1.000]) [buf: 4] 
   (at 5, cp->sounds[1][9:9, 1.000]) [buf: 10] 
   (at 6, end_mark)
"))
	  (snd-display "new 7: ~A" (safe-display-edits ind 0 3)))
      (undo 2)
      (insert-samples 2 3 (make-float-vector 3))
      (insert-samples 2 1 (make-float-vector 1))
      (insert-samples 4 1 (make-float-vector 1))
      (insert-samples 15 1 (make-float-vector 1))
      (if (not (= (framples) 16)) (snd-display "new 8 framples: ~A" (framples)))
      (if (not (string-=? (display-edits) (string-append "
EDITS: 5

 (begin) [0:2]:
   (at 0, cp->sounds[0][0:0, 0.000]) [file: " cwd "test.snd[0]]
   (at 1, end_mark)

 (set 0 10) ; set-samples [1:2]:
   (at 0, cp->sounds[1][0:9, 1.000]) [buf: 10] 
   (at 10, end_mark)

 (insert 2 3) ; insert-samples [2:4]:
   (at 0, cp->sounds[1][0:1, 1.000]) [buf: 10] 
   (at 2, cp->sounds[2][0:2, 1.000]) [buf: 3] 
   (at 5, cp->sounds[1][2:9, 1.000]) [buf: 10] 
   (at 13, end_mark)

 (insert 2 1) ; insert-samples [3:5]:
   (at 0, cp->sounds[1][0:1, 1.000]) [buf: 10] 
   (at 2, cp->sounds[3][0:0, 1.000]) [buf: 1] 
   (at 3, cp->sounds[2][0:2, 1.000]) [buf: 3] 
   (at 6, cp->sounds[1][2:9, 1.000]) [buf: 10] 
   (at 14, end_mark)

 (insert 4 1) ; insert-samples [4:7]:
   (at 0, cp->sounds[1][0:1, 1.000]) [buf: 10] 
   (at 2, cp->sounds[3][0:0, 1.000]) [buf: 1] 
   (at 3, cp->sounds[2][0:0, 1.000]) [buf: 3] 
   (at 4, cp->sounds[4][0:0, 1.000]) [buf: 1] 
   (at 5, cp->sounds[2][1:2, 1.000]) [buf: 3] 
   (at 7, cp->sounds[1][2:9, 1.000]) [buf: 10] 
   (at 15, end_mark)

 (insert 15 1) ; insert-samples [5:8]:
   (at 0, cp->sounds[1][0:1, 1.000]) [buf: 10] 
   (at 2, cp->sounds[3][0:0, 1.000]) [buf: 1] 
   (at 3, cp->sounds[2][0:0, 1.000]) [buf: 3] 
   (at 4, cp->sounds[4][0:0, 1.000]) [buf: 1] 
   (at 5, cp->sounds[2][1:2, 1.000]) [buf: 3] 
   (at 7, cp->sounds[1][2:9, 1.000]) [buf: 10] 
   (at 15, cp->sounds[5][0:0, 1.000]) [buf: 1] 
   (at 16, end_mark)
")))
	  (snd-display "new 8: ~A" (display-edits)))
      (delete-samples 2 1)
      (if (not (string-=? (safe-display-edits ind 0 6) "
 (delete 2 1) ; delete-samples 2 1 [6:7]:
   (at 0, cp->sounds[1][0:1, 1.000]) [buf: 10] 
   (at 2, cp->sounds[2][0:0, 1.000]) [buf: 3] 
   (at 3, cp->sounds[4][0:0, 1.000]) [buf: 1] 
   (at 4, cp->sounds[2][1:2, 1.000]) [buf: 3] 
   (at 6, cp->sounds[1][2:9, 1.000]) [buf: 10] 
   (at 14, cp->sounds[5][0:0, 1.000]) [buf: 1] 
   (at 15, end_mark)
"))
	  (snd-display "new 9: ~A" (safe-display-edits ind 0 6)))
      (delete-samples 0 5)
      (if (not (string-=? (safe-display-edits ind 0 7) "
 (delete 0 5) ; delete-samples 0 5 [7:4]:
   (at 0, cp->sounds[2][2:2, 1.000]) [buf: 3] 
   (at 1, cp->sounds[1][2:9, 1.000]) [buf: 10] 
   (at 9, cp->sounds[5][0:0, 1.000]) [buf: 1] 
   (at 10, end_mark)
"))
	  (snd-display "new 10: ~A" (safe-display-edits ind 0 7)))
      (delete-samples 6 4)
      (if (not (string-=? (safe-display-edits ind 0 8) "
 (delete 6 4) ; delete-samples 6 4 [8:3]:
   (at 0, cp->sounds[2][2:2, 1.000]) [buf: 3] 
   (at 1, cp->sounds[1][2:6, 1.000]) [buf: 10] 
   (at 6, end_mark)
"))
	  (snd-display "new 11: ~A" (safe-display-edits ind 0 8)))
      (delete-samples 0 1)
      (if (not (string-=? (safe-display-edits ind 0 9) "
 (delete 0 1) ; delete-samples 0 1 [9:2]:
   (at 0, cp->sounds[1][2:6, 1.000]) [buf: 10] 
   (at 5, end_mark)
"))
	  (snd-display "new 12: ~A" (safe-display-edits ind 0 9)))
      
      (delete-samples 0 5)
      (if (not (string-=? (safe-display-edits ind 0 10) "
 (delete 0 5) ; delete-samples 0 5 [10:1]:
   (at 0, end_mark)
"))
	  (snd-display "new 13: ~A" (safe-display-edits ind 0 10)))
      (delete-samples 0 10)
      (if (not (= (edit-position) 10))
	  (snd-display "no-op delete deleted something! ~A" (display-edits)))
      (insert-samples 0 3 (make-float-vector 3))
      (if (not (string-=? (safe-display-edits ind 0 11) "
 (insert 0 3) ; insert-samples [11:2]:
   (at 0, cp->sounds[6][0:2, 1.000]) [buf: 3] 
   (at 3, end_mark)
"))
	  (snd-display "new 14: ~A" (safe-display-edits ind 0 11)))
      (delete-samples 2 1)
      (if (not (string-=? (safe-display-edits ind 0 12) "
 (delete 2 1) ; delete-samples 2 1 [12:2]:
   (at 0, cp->sounds[6][0:1, 1.000]) [buf: 3] 
   (at 2, end_mark)
"))
	  (snd-display "new 15: ~A" (safe-display-edits ind 0 12)))
      (set! (sample 0) .5)
      (if (not (string-=? (safe-display-edits ind 0 13) "
 (set 0 1) ; set-sample 0 0.5000 [13:3]:
   (at 0, cp->sounds[7][0:0, 1.000]) [buf: 1] 
   (at 1, cp->sounds[6][1:1, 1.000]) [buf: 3] 
   (at 2, end_mark)
"))
	  (snd-display "new 16: ~A" (safe-display-edits ind 0 13)))
      (set! (sample 1) .5)
      (if (not (string-=? (safe-display-edits ind 0 14) "
 (set 1 1) ; set-sample 1 0.5000 [14:3]:
   (at 0, cp->sounds[7][0:0, 1.000]) [buf: 1] 
   (at 1, cp->sounds[8][0:0, 1.000]) [buf: 1] 
   (at 2, end_mark)
"))
	  (snd-display "new 17: ~A" (safe-display-edits ind 0 14)))  
      (map-channel (lambda (y) 1.0) 0 10)
      (if (not (string-=? (safe-display-edits ind 0 15) "
 (set 0 10) ; map-channel [15:2]:
   (at 0, cp->sounds[9][0:9, 1.000]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "new 18: ~A" (safe-display-edits ind 0 15)))  
      (insert-samples 0 10 (make-float-vector 10))
      (if (not (string-=? (safe-display-edits ind 0 16) "
 (insert 0 10) ; insert-samples [16:3]:
   (at 0, cp->sounds[10][0:9, 1.000]) [buf: 10] 
   (at 10, cp->sounds[9][0:9, 1.000]) [buf: 10] 
   (at 20, end_mark)
"))
	  (snd-display "new 19: ~A" (safe-display-edits ind 0 16)))
      (set! (samples 2 3) (make-float-vector 3))
      (if (not (string-=? (safe-display-edits ind 0 17) "
 (set 2 3) ; set-samples [17:5]:
   (at 0, cp->sounds[10][0:1, 1.000]) [buf: 10] 
   (at 2, cp->sounds[11][0:2, 1.000]) [buf: 3] 
   (at 5, cp->sounds[10][5:9, 1.000]) [buf: 10] 
   (at 10, cp->sounds[9][0:9, 1.000]) [buf: 10] 
   (at 20, end_mark)
"))
	  (snd-display "new 20: ~A" (safe-display-edits ind 0 17)))
      (set! (samples 0 12) (make-float-vector 12))
      (if (not (string-=? (safe-display-edits ind 0 18) "
 (set 0 12) ; set-samples [18:3]:
   (at 0, cp->sounds[12][0:11, 1.000]) [buf: 12] 
   (at 12, cp->sounds[9][2:9, 1.000]) [buf: 10] 
   (at 20, end_mark)
"))
	  (snd-display "new 21: ~A" (safe-display-edits ind 0 18)))
      (set! (samples 30 10) (make-float-vector 10))
      (if (not (string-=? (safe-display-edits ind 0 19) "
 (set 20 21) ; set-samples [19:5]:
   (at 0, cp->sounds[12][0:11, 1.000]) [buf: 12] 
   (at 12, cp->sounds[9][2:9, 1.000]) [buf: 10] 
   (at 20, cp->sounds[-1][0:9, 0.000])
   (at 30, cp->sounds[13][0:9, 1.000]) [buf: 10] 
   (at 40, end_mark)
"))
	  (snd-display "new 21: ~A" (safe-display-edits ind 0 19)))
      (close-sound ind))
    
    ;; scale/ramp
    (let ((ind (new-sound "test.snd")))
      (map-channel (lambda (y) 1.0) 0 10)
      (scale-channel 0.5)
      (if (not (string-=? (safe-display-edits ind 0 2) "
 (scale 0 10) ; scale-channel 0.500 0 #f [2:2]:
   (at 0, cp->sounds[1][0:9, 0.500]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "scl 0: ~A" (safe-display-edits ind 0 2)))
      (undo)
      (scale-channel 0.5 0 3)
      (if (not (string-=? (safe-display-edits ind 0 2) "
 (scale 0 3) ; scale-channel 0.500 0 3 [2:3]:
   (at 0, cp->sounds[1][0:2, 0.500]) [buf: 10] 
   (at 3, cp->sounds[1][3:9, 1.000]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "scl 1: ~A" (safe-display-edits ind 0 2)))
      (undo)
      (scale-channel 0.5 5 5)
      (if (not (string-=? (safe-display-edits ind 0 2) "
 (scale 5 5) ; scale-channel 0.500 5 5 [2:3]:
   (at 0, cp->sounds[1][0:4, 1.000]) [buf: 10] 
   (at 5, cp->sounds[1][5:9, 0.500]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "scl 2: ~A" (safe-display-edits ind 0 2)))
      (undo)
      (scale-channel 0.5 2 4)
      (if (not (string-=? (safe-display-edits ind 0 2) "
 (scale 2 4) ; scale-channel 0.500 2 4 [2:4]:
   (at 0, cp->sounds[1][0:1, 1.000]) [buf: 10] 
   (at 2, cp->sounds[1][2:5, 0.500]) [buf: 10] 
   (at 6, cp->sounds[1][6:9, 1.000]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "scl 2a: ~A" (safe-display-edits ind 0 2)))
      (undo)
      (scale-channel 0.5 10 10)
      (if (not (= (edit-position) 1))
	  (snd-display "scale beyond end edited? ~A" (display-edits)))
      (scale-channel 0.5 100 10)
      (if (not (= (edit-position) 1))
	  (snd-display "scale way beyond end edited? ~A" (display-edits)))
      (scale-channel 0.5 5 10)
      (if (not (string-=? (safe-display-edits ind 0 2) "
 (scale 5 5) ; scale-channel 0.500 5 5 [2:3]:
   (at 0, cp->sounds[1][0:4, 1.000]) [buf: 10] 
   (at 5, cp->sounds[1][5:9, 0.500]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "scl 3: ~A" (safe-display-edits ind 0 2)))
      (undo)
      (set! (sample 4) .5)
      (if (not (string-=? (safe-display-edits ind 0 2) "
 (set 4 1) ; set-sample 4 0.5000 [2:4]:
   (at 0, cp->sounds[1][0:3, 1.000]) [buf: 10] 
   (at 4, cp->sounds[2][0:0, 1.000]) [buf: 1] 
   (at 5, cp->sounds[1][5:9, 1.000]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "scl 4: ~A" (safe-display-edits ind 0 2)))
      (scale-channel 0.5 0 4)
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (scale 0 4) ; scale-channel 0.500 0 4 [3:4]:
   (at 0, cp->sounds[1][0:3, 0.500]) [buf: 10] 
   (at 4, cp->sounds[2][0:0, 1.000]) [buf: 1] 
   (at 5, cp->sounds[1][5:9, 1.000]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "scl 5: ~A" (safe-display-edits ind 0 3)))
      (scale-channel 0.5 4 1)
      (if (not (string-=? (safe-display-edits ind 0 4) "
 (scale 4 1) ; scale-channel 0.500 4 1 [4:4]:
   (at 0, cp->sounds[1][0:3, 0.500]) [buf: 10] 
   (at 4, cp->sounds[2][0:0, 0.500]) [buf: 1] 
   (at 5, cp->sounds[1][5:9, 1.000]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "scl 6: ~A" (safe-display-edits ind 0 4)))
      (scale-channel 0.5 0 7)
      (if (not (string-=? (safe-display-edits ind 0 5) "
 (scale 0 7) ; scale-channel 0.500 0 7 [5:5]:
   (at 0, cp->sounds[1][0:3, 0.250]) [buf: 10] 
   (at 4, cp->sounds[2][0:0, 0.250]) [buf: 1] 
   (at 5, cp->sounds[1][5:6, 0.500]) [buf: 10] 
   (at 7, cp->sounds[1][7:9, 1.000]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "scl 7: ~A" (safe-display-edits ind 0 5)))
      (scale-channel 0.5 1 4)
      (if (not (string-=? (safe-display-edits ind 0 6) "
 (scale 1 4) ; scale-channel 0.500 1 4 [6:6]:
   (at 0, cp->sounds[1][0:0, 0.250]) [buf: 10] 
   (at 1, cp->sounds[1][1:3, 0.125]) [buf: 10] 
   (at 4, cp->sounds[2][0:0, 0.125]) [buf: 1] 
   (at 5, cp->sounds[1][5:6, 0.500]) [buf: 10] 
   (at 7, cp->sounds[1][7:9, 1.000]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "scl 8: ~A" (safe-display-edits ind 0 6)))
      (undo 4)
      (scale-channel 0.5 1 8)
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (scale 1 8) ; scale-channel 0.500 1 8 [3:6]:
   (at 0, cp->sounds[1][0:0, 1.000]) [buf: 10] 
   (at 1, cp->sounds[1][1:3, 0.500]) [buf: 10] 
   (at 4, cp->sounds[2][0:0, 0.500]) [buf: 1] 
   (at 5, cp->sounds[1][5:8, 0.500]) [buf: 10] 
   (at 9, cp->sounds[1][9:9, 1.000]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "scl 9: ~A" (safe-display-edits ind 0 3)))
      (undo 2)
      
      (ramp-channel 0.0 1.0)
      (if (not (string-=? (safe-display-edits ind 0 2) "
 (ramp 0 10) ; ramp-channel 0.000 1.000 0 #f [2:2]:
   (at 0, cp->sounds[1][0:9, 1.000, [1]-0.000 -> 1.000]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "ramp 0: ~A" (safe-display-edits ind 0 2)))
      (scale-channel 0.5)
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (scale 0 10) ; scale-channel 0.500 0 #f [3:2]:
   (at 0, cp->sounds[1][0:9, 0.500, [1]-0.000 -> 1.000]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "ramp 1: ~A" (safe-display-edits ind 0 3)))
      (undo)
      (scale-channel 0.5 0 5)
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (scale 0 5) ; scale-channel 0.500 0 5 [3:3]:
   (at 0, cp->sounds[1][0:4, 0.500, [1]-0.000 -> 0.444]) [buf: 10] 
   (at 5, cp->sounds[1][5:9, 1.000, [1]0.556 -> 1.000]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "ramp 2: ~A" (safe-display-edits ind 0 3)))
      (undo)
      (scale-channel 0.5 2 4)
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (scale 2 4) ; scale-channel 0.500 2 4 [3:4]:
   (at 0, cp->sounds[1][0:1, 1.000, [1]-0.000 -> 0.111]) [buf: 10] 
   (at 2, cp->sounds[1][2:5, 0.500, [1]0.222 -> 0.556]) [buf: 10] 
   (at 6, cp->sounds[1][6:9, 1.000, [1]0.667 -> 1.000]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "ramp 3: ~A" (safe-display-edits ind 0 3)))
      (undo)
      (scale-channel 0.5 5 5)
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (scale 5 5) ; scale-channel 0.500 5 5 [3:3]:
   (at 0, cp->sounds[1][0:4, 1.000, [1]-0.000 -> 0.444]) [buf: 10] 
   (at 5, cp->sounds[1][5:9, 0.500, [1]0.556 -> 1.000]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "ramp 4: ~A" (safe-display-edits ind 0 3)))
      (undo 2)
      (ramp-channel .2 .6 2 6)
      (if (not (string-=? (safe-display-edits ind 0 2) "
 (ramp 2 6) ; ramp-channel 0.200 0.600 2 6 [2:4]:
   (at 0, cp->sounds[1][0:1, 1.000]) [buf: 10] 
   (at 2, cp->sounds[1][2:7, 1.000, [1]0.200 -> 0.600]) [buf: 10] 
   (at 8, cp->sounds[1][8:9, 1.000]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "ramp 5: ~A" (safe-display-edits ind 0 2)))
      (scale-channel 0.5 0 5)
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (scale 0 5) ; scale-channel 0.500 0 5 [3:5]:
   (at 0, cp->sounds[1][0:1, 0.500]) [buf: 10] 
   (at 2, cp->sounds[1][2:4, 0.500, [1]0.200 -> 0.360]) [buf: 10] 
   (at 5, cp->sounds[1][5:7, 1.000, [1]0.440 -> 0.600]) [buf: 10] 
   (at 8, cp->sounds[1][8:9, 1.000]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "ramp 6: ~A" (safe-display-edits ind 0 3)))
      (undo)
      (scale-channel 0.5 2 6)
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (scale 2 6) ; scale-channel 0.500 2 6 [3:4]:
   (at 0, cp->sounds[1][0:1, 1.000]) [buf: 10] 
   (at 2, cp->sounds[1][2:7, 0.500, [1]0.200 -> 0.600]) [buf: 10] 
   (at 8, cp->sounds[1][8:9, 1.000]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "ramp 7: ~A" (safe-display-edits ind 0 3)))
      (undo)
      (scale-channel 0.5 5 4)
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (scale 5 4) ; scale-channel 0.500 5 4 [3:6]:
   (at 0, cp->sounds[1][0:1, 1.000]) [buf: 10] 
   (at 2, cp->sounds[1][2:4, 1.000, [1]0.200 -> 0.360]) [buf: 10] 
   (at 5, cp->sounds[1][5:7, 0.500, [1]0.440 -> 0.600]) [buf: 10] 
   (at 8, cp->sounds[1][8:8, 0.500]) [buf: 10] 
   (at 9, cp->sounds[1][9:9, 1.000]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "ramp 8: ~A" (safe-display-edits ind 0 3)))
      (undo)
      (set! (sample 4) .5)
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (set 4 1) ; set-sample 4 0.5000 [3:6]:
   (at 0, cp->sounds[1][0:1, 1.000]) [buf: 10] 
   (at 2, cp->sounds[1][2:3, 1.000, [1]0.200 -> 0.280]) [buf: 10] 
   (at 4, cp->sounds[2][0:0, 1.000]) [buf: 1] 
   (at 5, cp->sounds[1][5:7, 1.000, [1]0.440 -> 0.600]) [buf: 10] 
   (at 8, cp->sounds[1][8:9, 1.000]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "ramp 9: ~A" (safe-display-edits ind 0 3)))
      (undo)
      (scale-channel 0.5 4 1)
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (scale 4 1) ; scale-channel 0.500 4 1 [3:6]:
   (at 0, cp->sounds[1][0:1, 1.000]) [buf: 10] 
   (at 2, cp->sounds[1][2:3, 1.000, [1]0.200 -> 0.280]) [buf: 10] 
   (at 4, cp->sounds[1][4:4, 0.500, [1]0.360 -> 0.360]) [buf: 10] 
   (at 5, cp->sounds[1][5:7, 1.000, [1]0.440 -> 0.600]) [buf: 10] 
   (at 8, cp->sounds[1][8:9, 1.000]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "ramp 10: ~A" (safe-display-edits ind 0 3)))
      (undo)
      (delete-sample 4)
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (delete 4 1) ; delete-samples 4 1 [3:5]:
   (at 0, cp->sounds[1][0:1, 1.000]) [buf: 10] 
   (at 2, cp->sounds[1][2:3, 1.000, [1]0.200 -> 0.280]) [buf: 10] 
   (at 4, cp->sounds[1][5:7, 1.000, [1]0.440 -> 0.600]) [buf: 10] 
   (at 7, cp->sounds[1][8:9, 1.000]) [buf: 10] 
   (at 9, end_mark)
"))
	  (snd-display "ramp 11: ~A" (safe-display-edits ind 0 3)))
      (undo)
      (delete-samples 4 2)
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (delete 4 2) ; delete-samples 4 2 [3:5]:
   (at 0, cp->sounds[1][0:1, 1.000]) [buf: 10] 
   (at 2, cp->sounds[1][2:3, 1.000, [1]0.200 -> 0.280]) [buf: 10] 
   (at 4, cp->sounds[1][6:7, 1.000, [1]0.520 -> 0.600]) [buf: 10] 
   (at 6, cp->sounds[1][8:9, 1.000]) [buf: 10] 
   (at 8, end_mark)
"))
	  (snd-display "ramp 12: ~A" (safe-display-edits ind 0 3)))
      (undo)
      (delete-samples 4 3)
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (delete 4 3) ; delete-samples 4 3 [3:5]:
   (at 0, cp->sounds[1][0:1, 1.000]) [buf: 10] 
   (at 2, cp->sounds[1][2:3, 1.000, [1]0.200 -> 0.280]) [buf: 10] 
   (at 4, cp->sounds[1][7:7, 1.000, [1]0.600 -> 0.600]) [buf: 10] 
   (at 5, cp->sounds[1][8:9, 1.000]) [buf: 10] 
   (at 7, end_mark)
"))
	  (snd-display "ramp 13: ~A" (safe-display-edits ind 0 3)))
      (undo)
      (delete-samples 4 4)
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (delete 4 4) ; delete-samples 4 4 [3:4]:
   (at 0, cp->sounds[1][0:1, 1.000]) [buf: 10] 
   (at 2, cp->sounds[1][2:3, 1.000, [1]0.200 -> 0.280]) [buf: 10] 
   (at 4, cp->sounds[1][8:9, 1.000]) [buf: 10] 
   (at 6, end_mark)
"))
	  (snd-display "ramp 14: ~A" (safe-display-edits ind 0 3)))
      (undo)
      (delete-samples 4 5)
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (delete 4 5) ; delete-samples 4 5 [3:4]:
   (at 0, cp->sounds[1][0:1, 1.000]) [buf: 10] 
   (at 2, cp->sounds[1][2:3, 1.000, [1]0.200 -> 0.280]) [buf: 10] 
   (at 4, cp->sounds[1][9:9, 1.000]) [buf: 10] 
   (at 5, end_mark)
"))
	  (snd-display "ramp 15: ~A" (safe-display-edits ind 0 3)))
      (undo)
      (scale-channel 0.5 4 2)
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (scale 4 2) ; scale-channel 0.500 4 2 [3:6]:
   (at 0, cp->sounds[1][0:1, 1.000]) [buf: 10] 
   (at 2, cp->sounds[1][2:3, 1.000, [1]0.200 -> 0.280]) [buf: 10] 
   (at 4, cp->sounds[1][4:5, 0.500, [1]0.360 -> 0.440]) [buf: 10] 
   (at 6, cp->sounds[1][6:7, 1.000, [1]0.520 -> 0.600]) [buf: 10] 
   (at 8, cp->sounds[1][8:9, 1.000]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "ramp 16: ~A" (safe-display-edits ind 0 3)))
      (undo)
      (pad-channel 4 1)
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (silence 4 1) ; pad-channel [3:6]:
   (at 0, cp->sounds[1][0:1, 1.000]) [buf: 10] 
   (at 2, cp->sounds[1][2:3, 1.000, [1]0.200 -> 0.280]) [buf: 10] 
   (at 4, cp->sounds[-1][0:0, 0.000])
   (at 5, cp->sounds[1][4:7, 1.000, [1]0.360 -> 0.600]) [buf: 10] 
   (at 9, cp->sounds[1][8:9, 1.000]) [buf: 10] 
   (at 11, end_mark)
"))
	  (snd-display "ramp 17: ~A" (safe-display-edits ind 0 3)))
      (close-sound ind))
    
    ;; xramp
    (let ((ind (new-sound "test.snd"))) ; second main let
      (map-channel (lambda (y) 1.0) 0 10)
      (xramp-channel 0.0 1.0 32.0)
      (if (not (string-=? (safe-display-edits ind 0 2) "
 (ramp 0 10) ; xramp-channel 0.000 1.000 32.000 0 #f [2:2]:
   (at 0, cp->sounds[1][0:9, 1.000, [1]0.000 -> 1.000, off: -0.032, scl: 0.032]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "xramp 1: ~A" (safe-display-edits ind 0 2)))
      (undo)
      (xramp-channel 0.0 1.0 0.325)
      (if (not (string-=? (safe-display-edits ind 0 2) "
 (ramp 0 10) ; xramp-channel 0.000 1.000 0.325 0 #f [2:2]:
   (at 0, cp->sounds[1][0:9, 1.000, [1]0.000 -> 1.000, off: 1.481, scl: -1.481]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "xramp 2: ~A" (safe-display-edits ind 0 2)))
      (undo)
      (xramp-channel 0.0 1.0 0.0)
      (if (not (string-=? (safe-display-edits ind 0 2) (string-append "
 (scale 0 10) ; scale-channel 0.000 0 #f [2:2]:
   (at 0, cp->sounds[0][0:9, 0.000]) [file: " (getcwd) "/test.snd[0]]
   (at 10, end_mark)
")))
	  (snd-display "xramp 3: ~A" (safe-display-edits ind 0 2)))
      (undo)
      (xramp-channel 0.0 1.0 1.0)
      (if (not (string-=? (safe-display-edits ind 0 2) "
 (ramp 0 10) ; ramp-channel 0.000 1.000 0 #f [2:2]:
   (at 0, cp->sounds[1][0:9, 1.000, [1]-0.000 -> 1.000]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "xramp 4: ~A" (safe-display-edits ind 0 2)))
      (undo)
      (xramp-channel 0.5 1.5 32.0)
      (if (not (string-=? (safe-display-edits ind 0 2) "
 (ramp 0 10) ; xramp-channel 0.500 1.500 32.000 0 #f [2:2]:
   (at 0, cp->sounds[1][0:9, 1.000, [1]0.500 -> 1.500, off: 0.468, scl: 0.032]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "xramp 5: ~A" (safe-display-edits ind 0 2)))
      (if (or (fneq (maxamp) 1.5) (fneq (sample 0) 0.5))
	  (snd-display "xramp 5 vals: ~A ~A" (maxamp) (sample 0)))
      (undo)
      (xramp-channel -0.5 1.5 32.0)
      (if (not (string-=? (safe-display-edits ind 0 2) "
 (ramp 0 10) ; xramp-channel -0.500 1.500 32.000 0 #f [2:2]:
   (at 0, cp->sounds[1][0:9, 1.000, [1]-0.500 -> 1.500, off: -0.565, scl: 0.065]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "xramp 6: ~A" (safe-display-edits ind 0 2)))
      (if (or (fneq (maxamp) 1.5) (fneq (sample 0) -0.5))
	  (snd-display "xramp 6 vals: ~A ~A" (maxamp) (sample 0)))
      (undo)
      (xramp-channel 0.0 1.0 32.0)
      (let ((vals (channel->float-vector)))
	(scale-channel 0.5)
	(if (not (string-=? (safe-display-edits ind 0 3) "
 (scale 0 10) ; scale-channel 0.500 0 #f [3:2]:
   (at 0, cp->sounds[1][0:9, 0.500, [1]0.000 -> 1.000, off: -0.032, scl: 0.032]) [buf: 10] 
   (at 10, end_mark)
"))
	    (snd-display "xramp 7: ~A" (safe-display-edits ind 0 3)))
	(let ((baddy (scan-channel (let ((p (make-one-pole 1.0 -1.0)))
				     (lambda (y) 
				       (fneq y (* 0.5 (float-vector-ref vals (floor (- (one-pole p 1.0) 1.0))))))))))
	  (if baddy (snd-display "trouble in xramp 7: ~A" baddy)))
	(undo)
	(delete-sample 0)
	(if (not (string-=? (safe-display-edits ind 0 3) "
 (delete 0 1) ; delete-samples 0 1 [3:2]:
   (at 0, cp->sounds[1][1:9, 1.000, [1]0.015 -> 1.000, off: -0.032, scl: 0.032]) [buf: 10] 
   (at 9, end_mark)
"))
	    (snd-display "xramp 8: ~A" (safe-display-edits ind 0 3)))
	(let ((baddy (scan-channel (let ((p (make-one-pole 1.0 -1.0)))
				     (lambda (y) 
				       (fneq y (float-vector-ref vals (floor (one-pole p 1.0)))))))))
	  (if baddy (snd-display "trouble in xramp 8: ~A" baddy)))
	(undo)
	(delete-samples 0 2)
	(if (not (string-=? (safe-display-edits ind 0 3) "
 (delete 0 2) ; delete-samples 0 2 [3:2]:
   (at 0, cp->sounds[1][2:9, 1.000, [1]0.037 -> 1.000, off: -0.032, scl: 0.032]) [buf: 10] 
   (at 8, end_mark)
"))
	    (snd-display "xramp 9: ~A" (safe-display-edits ind 0 3)))
	(let ((p (make-one-pole 1.0 -1.0)))
	  (one-pole p 1.0)
	  (let ((baddy (scan-channel (lambda (y) (fneq y (float-vector-ref vals (floor (one-pole p 1.0))))))))
	    (if baddy (snd-display "trouble in xramp 9: ~A" baddy)))))
      (undo)
      (delete-sample 0)
      (delete-sample 0)
      (if (not (string-=? (safe-display-edits ind 0 4) "
 (delete 0 1) ; delete-samples 0 1 [4:2]:
   (at 0, cp->sounds[1][2:9, 1.000, [1]0.037 -> 1.000, off: -0.032, scl: 0.032]) [buf: 10] 
   (at 8, end_mark)
"))
	  (snd-display "xramp 10: ~A" (safe-display-edits ind 0 4)))
      (undo 2)
      (delete-sample 4)
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (delete 4 1) ; delete-samples 4 1 [3:3]:
   (at 0, cp->sounds[1][0:3, 1.000, [1]0.000 -> 0.070, off: -0.032, scl: 0.032]) [buf: 10] 
   (at 4, cp->sounds[1][5:9, 1.000, [1]0.189 -> 1.000, off: -0.032, scl: 0.032]) [buf: 10] 
   (at 9, end_mark)
"))
	  (snd-display "xramp 11: ~A" (safe-display-edits ind 0 3)))
      (undo)
      (delete-samples 4 2)
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (delete 4 2) ; delete-samples 4 2 [3:3]:
   (at 0, cp->sounds[1][0:3, 1.000, [1]0.000 -> 0.070, off: -0.032, scl: 0.032]) [buf: 10] 
   (at 4, cp->sounds[1][6:9, 1.000, [1]0.293 -> 1.000, off: -0.032, scl: 0.032]) [buf: 10] 
   (at 8, end_mark)
"))
	  (snd-display "xramp 12: ~A" (safe-display-edits ind 0 3)))
      (undo)
      (scale-channel 0.5 4 2)
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (scale 4 2) ; scale-channel 0.500 4 2 [3:4]:
   (at 0, cp->sounds[1][0:3, 1.000, [1]0.000 -> 0.070, off: -0.032, scl: 0.032]) [buf: 10] 
   (at 4, cp->sounds[1][4:5, 0.500, [1]0.118 -> 0.189, off: -0.032, scl: 0.032]) [buf: 10] 
   (at 6, cp->sounds[1][6:9, 1.000, [1]0.293 -> 1.000, off: -0.032, scl: 0.032]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "xramp 13: ~A" (safe-display-edits ind 0 3)))
      (undo)
      (scale-channel 0.5 0 2)
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (scale 0 2) ; scale-channel 0.500 0 2 [3:3]:
   (at 0, cp->sounds[1][0:1, 0.500, [1]0.000 -> 0.015, off: -0.032, scl: 0.032]) [buf: 10] 
   (at 2, cp->sounds[1][2:9, 1.000, [1]0.037 -> 1.000, off: -0.032, scl: 0.032]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "xramp 14: ~A" (safe-display-edits ind 0 3)))
      (undo)
      (pad-channel 4 2)
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (silence 4 2) ; pad-channel [3:4]:
   (at 0, cp->sounds[1][0:3, 1.000, [1]0.000 -> 0.070, off: -0.032, scl: 0.032]) [buf: 10] 
   (at 4, cp->sounds[-1][0:1, 0.000])
   (at 6, cp->sounds[1][4:9, 1.000, [1]0.118 -> 1.000, off: -0.032, scl: 0.032]) [buf: 10] 
   (at 12, end_mark)
"))
	  (snd-display "xramp 15: ~A" (safe-display-edits ind 0 3)))
      (undo)
      (set! (sample 4) 1.0)
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (set 4 1) ; set-sample 4 1.0000 [3:4]:
   (at 0, cp->sounds[1][0:3, 1.000, [1]0.000 -> 0.070, off: -0.032, scl: 0.032]) [buf: 10] 
   (at 4, cp->sounds[2][0:0, 1.000]) [buf: 1] 
   (at 5, cp->sounds[1][5:9, 1.000, [1]0.189 -> 1.000, off: -0.032, scl: 0.032]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "xramp 16: ~A" (safe-display-edits ind 0 3)))
      (undo)
      (set! (samples 4 2) (make-float-vector 2))
      (if (not (string-=? (safe-display-edits ind 0 3) "
 (set 4 2) ; set-samples [3:4]:
   (at 0, cp->sounds[1][0:3, 1.000, [1]0.000 -> 0.070, off: -0.032, scl: 0.032]) [buf: 10] 
   (at 4, cp->sounds[2][0:1, 1.000]) [buf: 2] 
   (at 6, cp->sounds[1][6:9, 1.000, [1]0.293 -> 1.000, off: -0.032, scl: 0.032]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "xramp 17: ~A" (safe-display-edits ind 0 3)))
      (undo)
      (scale-channel 0.5)
      (set! (samples 4 2) (make-float-vector 2))
      (if (not (string-=? (safe-display-edits ind 0 4) "
 (set 4 2) ; set-samples [4:4]:
   (at 0, cp->sounds[1][0:3, 0.500, [1]0.000 -> 0.070, off: -0.032, scl: 0.032]) [buf: 10] 
   (at 4, cp->sounds[2][0:1, 1.000]) [buf: 2] 
   (at 6, cp->sounds[1][6:9, 0.500, [1]0.293 -> 1.000, off: -0.032, scl: 0.032]) [buf: 10] 
   (at 10, end_mark)
"))
	  (snd-display "xramp 18: ~A" (safe-display-edits ind 0 4)))
      (close-sound ind))

    (let ((ind (new-sound "test.snd"))) ; third
      (map-channel (lambda (y) 1.0) 0 100)
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(scale-channel 0.5 (* i 10) 10))
      (ramp-channel 0.0 1.0)
      (if (not (string=? (safe-display-edits ind 0 12) "
 (ramp 0 100) ; ramp-channel 0.000 1.000 0 #f [12:11]:
   (at 0, cp->sounds[1][0:9, 0.500, [1]0.000 -> 0.091]) [buf: 100] 
   (at 10, cp->sounds[1][10:19, 0.500, [1]0.101 -> 0.192]) [buf: 100] 
   (at 20, cp->sounds[1][20:29, 0.500, [1]0.202 -> 0.293]) [buf: 100] 
   (at 30, cp->sounds[1][30:39, 0.500, [1]0.303 -> 0.394]) [buf: 100] 
   (at 40, cp->sounds[1][40:49, 0.500, [1]0.404 -> 0.495]) [buf: 100] 
   (at 50, cp->sounds[1][50:59, 0.500, [1]0.505 -> 0.596]) [buf: 100] 
   (at 60, cp->sounds[1][60:69, 0.500, [1]0.606 -> 0.697]) [buf: 100] 
   (at 70, cp->sounds[1][70:79, 0.500, [1]0.707 -> 0.798]) [buf: 100] 
   (at 80, cp->sounds[1][80:89, 0.500, [1]0.808 -> 0.899]) [buf: 100] 
   (at 90, cp->sounds[1][90:99, 0.500, [1]0.909 -> 1.000]) [buf: 100] 
   (at 100, end_mark)
"))
	  (snd-display "multi-ramp 1: ~A" (safe-display-edits ind 0 12)))
      (if (fneq (maxamp) 0.5) (snd-display "multi ramp 1 maxamp: ~A" (maxamp)))
      (undo)
      (ramp-channel 0.1 1.0 10 90)
      (if (not (string=? (safe-display-edits ind 0 12) "
 (ramp 10 90) ; ramp-channel 0.100 1.000 10 90 [12:11]:
   (at 0, cp->sounds[1][0:9, 0.500]) [buf: 100] 
   (at 10, cp->sounds[1][10:19, 0.500, [1]0.100 -> 0.191]) [buf: 100] 
   (at 20, cp->sounds[1][20:29, 0.500, [1]0.201 -> 0.292]) [buf: 100] 
   (at 30, cp->sounds[1][30:39, 0.500, [1]0.302 -> 0.393]) [buf: 100] 
   (at 40, cp->sounds[1][40:49, 0.500, [1]0.403 -> 0.494]) [buf: 100] 
   (at 50, cp->sounds[1][50:59, 0.500, [1]0.504 -> 0.596]) [buf: 100] 
   (at 60, cp->sounds[1][60:69, 0.500, [1]0.606 -> 0.697]) [buf: 100] 
   (at 70, cp->sounds[1][70:79, 0.500, [1]0.707 -> 0.798]) [buf: 100] 
   (at 80, cp->sounds[1][80:89, 0.500, [1]0.808 -> 0.899]) [buf: 100] 
   (at 90, cp->sounds[1][90:99, 0.500, [1]0.909 -> 1.000]) [buf: 100] 
   (at 100, end_mark)
"))
	  (snd-display "multi-ramp 2: ~A" (safe-display-edits ind 0 12)))
      (if (fneq (maxamp) 0.5) (snd-display "multi ramp 2 maxamp: ~A" (maxamp)))
      (undo)
      (ramp-channel 0.0 0.9 0 90)
      (if (not (string=? (safe-display-edits ind 0 12) "
 (ramp 0 90) ; ramp-channel 0.000 0.900 0 90 [12:11]:
   (at 0, cp->sounds[1][0:9, 0.500, [1]0.000 -> 0.091]) [buf: 100] 
   (at 10, cp->sounds[1][10:19, 0.500, [1]0.101 -> 0.192]) [buf: 100] 
   (at 20, cp->sounds[1][20:29, 0.500, [1]0.202 -> 0.293]) [buf: 100] 
   (at 30, cp->sounds[1][30:39, 0.500, [1]0.303 -> 0.394]) [buf: 100] 
   (at 40, cp->sounds[1][40:49, 0.500, [1]0.404 -> 0.496]) [buf: 100] 
   (at 50, cp->sounds[1][50:59, 0.500, [1]0.506 -> 0.597]) [buf: 100] 
   (at 60, cp->sounds[1][60:69, 0.500, [1]0.607 -> 0.698]) [buf: 100] 
   (at 70, cp->sounds[1][70:79, 0.500, [1]0.708 -> 0.799]) [buf: 100] 
   (at 80, cp->sounds[1][80:89, 0.500, [1]0.809 -> 0.900]) [buf: 100] 
   (at 90, cp->sounds[1][90:99, 0.500]) [buf: 100] 
   (at 100, end_mark)
"))
	  (snd-display "multi-ramp 3: ~A" (safe-display-edits ind 0 12)))
      (if (fneq (maxamp) 0.5) (snd-display "multi ramp 3 maxamp: ~A" (maxamp)))
      (if (fneq (sample 89) 0.45) (snd-display "multi ramp 3 sample 89: ~A" (sample 89)))
      (if (fneq (sample 90) 0.5) (snd-display "multi ramp 3 sample 90: ~A" (sample 90)))
      (undo)
      (ramp-channel 0.1 0.9 10 80)
      (if (not (string=? (safe-display-edits ind 0 12) "
 (ramp 10 80) ; ramp-channel 0.100 0.900 10 80 [12:11]:
   (at 0, cp->sounds[1][0:9, 0.500]) [buf: 100] 
   (at 10, cp->sounds[1][10:19, 0.500, [1]0.100 -> 0.191]) [buf: 100] 
   (at 20, cp->sounds[1][20:29, 0.500, [1]0.201 -> 0.292]) [buf: 100] 
   (at 30, cp->sounds[1][30:39, 0.500, [1]0.303 -> 0.394]) [buf: 100] 
   (at 40, cp->sounds[1][40:49, 0.500, [1]0.404 -> 0.495]) [buf: 100] 
   (at 50, cp->sounds[1][50:59, 0.500, [1]0.505 -> 0.596]) [buf: 100] 
   (at 60, cp->sounds[1][60:69, 0.500, [1]0.606 -> 0.697]) [buf: 100] 
   (at 70, cp->sounds[1][70:79, 0.500, [1]0.708 -> 0.799]) [buf: 100] 
   (at 80, cp->sounds[1][80:89, 0.500, [1]0.809 -> 0.900]) [buf: 100] 
   (at 90, cp->sounds[1][90:99, 0.500]) [buf: 100] 
   (at 100, end_mark)
"))
	  (snd-display "multi-ramp 4: ~A" (safe-display-edits ind 0 12)))
      (revert-sound)
      (map-channel (lambda (y) 1.0) 0 100)
      (ramp-channel 0.0 1.0)
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(scale-channel 0.5 (* i 10) 10))
      (if (not (string=? (safe-display-edits ind 0 12) "
 (scale 90 10) ; scale-channel 0.500 90 10 [12:11]:
   (at 0, cp->sounds[1][0:9, 0.500, [1]0.000 -> 0.091]) [buf: 100] 
   (at 10, cp->sounds[1][10:19, 0.500, [1]0.101 -> 0.192]) [buf: 100] 
   (at 20, cp->sounds[1][20:29, 0.500, [1]0.202 -> 0.293]) [buf: 100] 
   (at 30, cp->sounds[1][30:39, 0.500, [1]0.303 -> 0.394]) [buf: 100] 
   (at 40, cp->sounds[1][40:49, 0.500, [1]0.404 -> 0.495]) [buf: 100] 
   (at 50, cp->sounds[1][50:59, 0.500, [1]0.505 -> 0.596]) [buf: 100] 
   (at 60, cp->sounds[1][60:69, 0.500, [1]0.606 -> 0.697]) [buf: 100] 
   (at 70, cp->sounds[1][70:79, 0.500, [1]0.707 -> 0.798]) [buf: 100] 
   (at 80, cp->sounds[1][80:89, 0.500, [1]0.808 -> 0.899]) [buf: 100] 
   (at 90, cp->sounds[1][90:99, 0.500, [1]0.909 -> 1.000]) [buf: 100] 
   (at 100, end_mark)
"))
	  (snd-display "multi-ramp 5: ~A" (safe-display-edits ind 0 12)))
      (close-sound ind))
    
    (let ((ind (open-sound "oboe.snd")))
      (if (not (= (redo 1 ind 0) 0)) (snd-display "open redo with no ops: ~A" (redo)))
      (if (not (= (undo 1 ind 0) 0)) (snd-display "open undo with no ops: ~A" (undo)))
      (set! (cursor) 1000)
      (delete-sample 321)
      (if (not (= (cursor) 999)) (snd-display "delete-sample before cursor: ~A" (cursor)))
      (if (not (= (cursor ind 0 0) 1000)) (snd-display "delete-sample before cursor (0): ~A" (cursor ind 0 0)))
      (undo)
      (if (not (= (cursor) 1000)) (snd-display "delete-sample after cursor undo: ~A" (cursor)))
      (undo -1)
      (if (not (= (cursor) 999)) (snd-display "delete-sample before cursor redo: ~A" (cursor)))
      (redo -1)
      (delete-sample 1321)
      (if (not (= (cursor) 1000)) (snd-display "delete-sample after cursor: ~A" (cursor)))
      (undo)
      (delete-samples 0 100)
      (if (not (= (cursor) 900)) (snd-display "delete-samples before cursor: ~A" (cursor)))
      (undo)
      (delete-samples 1100 100)
      (if (not (= (cursor) 1000)) (snd-display "delete-samples after cursor: ~A" (cursor)))
      (undo)
      (insert-samples 100 100 (make-float-vector 100))
      (if (not (= (cursor) 1100)) (snd-display "insert-samples before cursor: ~A" (cursor)))
      (undo)
      (insert-samples 1100 100 (make-float-vector 100))
      (if (not (= (cursor) 1000)) (snd-display "insert-samples after cursor: ~A" (cursor)))
      (undo)
      (set! (samples 0 100) (make-float-vector 100))
      (if (not (= (cursor) 1000)) (snd-display "set-samples cursor: ~A" (cursor)))
      (set! (show-axes ind 0) show-x-axis-unlabelled)
      (update-time-graph)
      (set! (show-axes ind 0) show-all-axes-unlabelled)
      (update-time-graph)
      (close-sound ind))
    
    (let ((ind (new-sound "test.snd" :size 100)))
      (float-vector->channel (make-float-vector 3 1.0) 10 8)
      (if (fneq (maxamp ind 0) 1.0)
	  (snd-display "float-vector->channel size mismatch maxamp: ~A" (maxamp ind 0)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 20 ind 0)
				  #r(0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 1.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0)))
	  (snd-display "float-vector->channel size mismatch: ~A" (channel->float-vector 0 20 ind 0)))
      (revert-sound ind)
      (set! (samples 10 5) (make-float-vector 3 1.0))
      (if (fneq (maxamp ind 0) 1.0)
	  (snd-display "set samples size mismatch maxamp: ~A" (maxamp ind 0)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 20 ind 0)
				  #r(0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 1.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0)))
	  (snd-display "set samples size mismatch: ~A" (channel->float-vector 0 20 ind 0)))
      (revert-sound ind)
      (insert-samples 10 8 (make-float-vector 3 1.0) ind 0)
      (if (fneq (maxamp ind 0) 1.0)
	  (snd-display "insert samples size mismatch maxamp: ~A" (maxamp ind 0)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 20 ind 0)
				  #r(0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 1.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0)))
	  (snd-display "insert samples size mismatch: ~A" (channel->float-vector 0 20 ind 0)))
      (close-sound ind))
    
    (let ((index (open-sound "oboe.snd")))
      (if (not (string=? (snd-completion " open-so") " open-sound"))
	  (snd-display "completion: ~A" (snd-completion " open-so")))
					;	(if (not (string=? (snd-completion " open-sound") " open-sound"))
					;	    (snd-display "completion: ~A" (snd-completion " open-so")))
      (if (not (string=? (snd-completion " zoom-focus-r") " zoom-focus-right"))
	  (snd-display "completion: ~A" (snd-completion " zoom-focus-r")))
      (play "oboe.snd" :wait #t)
      (play "oboe.snd" :start 12000 :wait #t)
      (play "oboe.snd" :start 12000 :end 15000 :wait #t)
      (play :edit-position (- (edit-position) 1) :wait #t)
      (let-temporarily (((speed-control index) -2.0)
			(*speed-control-style* speed-control-as-semitone)
			((show-controls index) #t))
	(play index :start 12345 :wait #t)
	(set! (speed-control index) 0.5)
	(set! *speed-control-style* speed-control-as-ratio)
	(set! (speed-control index) 0.25))
      (if (<= (disk-kspace "oboe.snd") 0)
	  (snd-display "disk-kspace = ~A" (disk-kspace "oboe.snd")))
      (if (not (= (disk-kspace "/baddy/hiho") -1))
	  (snd-display "disk-kspace of bogus file = ~A" (disk-kspace "/baddy/hiho")))
      (if (not (= (transform-framples) 0)) (snd-display "transform-framples ~A?" (transform-framples)))
      (set! *transform-size* 512)
      
      (set! (transform-graph?) #t)
      (set! (time-graph?) #t)
      
      (when with-gui
	(catch #t
	  (lambda ()
	    (if (not (string=? (x-axis-label) "time")) 
		(snd-display "def time x-axis-label: ~A" (x-axis-label)))
	    (set! (x-axis-label index 0 time-graph) "no time")
	    (if (not (string=? (x-axis-label) "no time")) 
		(snd-display "time x-axis-label: ~A" (x-axis-label index 0 time-graph)))
	    
	    (update-transform-graph)
	    (if (not (string=? (x-axis-label index 0 transform-graph) "frequency")) 
		(snd-display "get fft x-axis-label: ~A" (x-axis-label index 0 transform-graph)))
	    (set! (x-axis-label index 0 transform-graph) "hiho")
	    (update-transform-graph)
	    (if (not (string=? (x-axis-label index 0 transform-graph) "hiho")) 
		(snd-display "set fft x-axis-label: ~A" (x-axis-label index 0 transform-graph)))
	    (set! (x-axis-label index 0 transform-graph) "frequency") ; for later test
	    
	    (graph '(0 0 1 1 2 0) "lisp")
	    (update-lisp-graph)
	    (if (not (string=? (x-axis-label index 0 lisp-graph) "lisp")) 
		(snd-display "def lisp x-axis-label: ~A" (x-axis-label index 0 lisp-graph)))
	    (set! (x-axis-label index 0 lisp-graph) "no lisp")
	    (if (not (string=? (x-axis-label index 0 lisp-graph) "no lisp")) 
		(snd-display "lisp x-axis-label: ~A" (x-axis-label index 0 lisp-graph)))
	    
	    (set! (y-axis-label index 0 time-graph) "no amp")
	    (if (not (string=? (y-axis-label) "no amp"))
		(snd-display "time y-axis-label: ~A" (y-axis-label index 0 time-graph)))
	    (set! (y-axis-label index 0 lisp-graph) "no lamp")
	    (if (not (string=? (y-axis-label index 0 lisp-graph) "no lamp")) 
		(snd-display "lisp y-axis-label: ~A" (y-axis-label index 0 lisp-graph)))
	    (set! (y-axis-label) #f)
	    (set! (y-axis-label index 0) "no amp")
	    (if (not (string=? (y-axis-label) "no amp")) 
		(snd-display "time y-axis-label (time): ~A" (y-axis-label index 0 time-graph)))
	    (set! (y-axis-label index) #f))
	  (lambda args (snd-display "axis label error: ~A" args)))
	
	(when (provided? 'snd-motif)
	  (graph-data (make-float-vector 4) index 0 copy-context #f #f graph-lines #f)
	  (update-lisp-graph))
	(graph #r(0 0 1 1 2 0))
	(do ((i 0 (+ i 1))) 
	    ((= i 32)) 
	  (graph #r(0 1 2)) 
	  (graph (list #r(0 1 2) #r(3 2 1) #r(1 2 3)))
	  (graph (list #r(0 1 2) #r(3 2 1))))
	(set! (x-bounds) (list 0.0 0.01))
	(let ((data (make-graph-data)))
	  (if (float-vector? data)
	      (let ((mid (round (* .5 (length data)))))
		(if (not (= (length data) (- (+ (right-sample) 1) (left-sample))))
		    (snd-display "make-graph-data bounds: ~A ~A -> ~A" (left-sample) (right-sample) (length data)))
		(if (fneq (data mid)
			  (sample (+ (left-sample) mid)))
		    (snd-display "make-graph-data[~D]: ~A ~A" mid (data mid) (sample (+ (left-sample) mid)))))))
	(let ((data (make-graph-data index 0 0 100 199)))
	  (when (float-vector? data)
	    (if (not (= (length data) 100))
		(snd-display "make-graph-data 100:199: ~A" (length data)))
	    (if (fneq (data 50) (sample 50))
		(snd-display "make-graph-data 50: ~A ~A" (data 50) (sample 50)))))
	(set! (x-bounds) (list 0.0 0.1))
	(update-transform-graph)
	(catch 'no-such-axis
	  (lambda ()
	    (if (not (string=? (x-axis-label index 0 transform-graph) "frequency")) 
		(snd-display "def fft x-axis-label: ~A" (x-axis-label index 0 transform-graph)))
	    (set! (x-axis-label index 0 transform-graph) "fourier")
	    (if (not (string=? (x-axis-label index 0 transform-graph) "fourier")) 
		(snd-display "fft x-axis-label: ~A" (x-axis-label index 0 transform-graph)))
	    (set! (x-axis-label) "hiho")
	    
	    (set! (y-axis-label index 0 transform-graph) "spectra")
	    (let ((val (y-axis-label index 0 transform-graph)))
	      (if (not (equal? val "spectra"))
		  (snd-display "fft y-axis-label: ~A" val)))
	    (set! (y-axis-label) "hiho") 
	    #f)
	  (lambda args (snd-display "transform axis not displayed?"))))
      
      (if (and (number? (transform-framples))
	       (= (transform-framples) 0))
	  (snd-display "transform-graph? transform-framples ~A?" (transform-framples)))
      (update-transform-graph)
      (let ((tag (catch #t (lambda () (peaks "/baddy/hiho")) (lambda args (car args)))))
	(if (not (eq? tag 'cant-open-file)) (snd-display "peaks bad file: ~A" tag)))
      (peaks "tmp.peaks")
      (let* ((p (open-input-file "tmp.peaks"))
	     (line (read-line p)))
	(if (not (string=? "Snd: fft peaks" (substring line 0 14)))
	    (snd-display "peaks 1: ~A?" line))
	(read-line p)
	(set! line (read-line p))
	(if (not (member line '(#<eof> "oboe.snd, fft 512 points beginning at sample 0 (0.000 secs), Blackman2"
				       "oboe.snd, fft 512 points beginning at sample 0 (0.000 secs), Blackman2\n")))
	    (snd-display "peaks 2: ~A?" line))
	(close-input-port p))
      (delete-file "tmp.peaks")
      (peaks)
      (if (and (provided? 'xm) 
	       (not (and ((dialog-widgets) 15)
			 ((*motif* 'XtIsManaged) ((dialog-widgets) 15)))))
	  (snd-display "peaks but no help?"))
      (dismiss-all-dialogs)
      (let ((num-transforms 6)
	    (num-transform-graph-types 3))
	(set! (transform-graph? index 0) #t)
	(set! (transform-size index 0) 64)
	(do ((i 0 (+ i 1)))
	    ((= i num-transforms))
	  (set! *transform-type* (integer->transform i))
	  (if (not (transform? (integer->transform i))) (snd-display "transform? ~A?" i))
	  (do ((j 0 (+ j 1)))
	      ((= j num-transform-graph-types))
	    (set! (transform-graph-type index 0) j)
	    (update-transform-graph index 0))))
      (set! *transform-type* fourier-transform)
      (if (not (transform? *transform-type*)) (snd-display "transform? ~A ~A?" *transform-type* fourier-transform))
      (if (not (transform? autocorrelation)) (snd-display "transform? autocorrelation"))
      
      (if (read-only index) (snd-display "read-only open-sound: ~A?" (read-only index)))
      (set! (read-only index) #t)
      (if (not (read-only index)) (snd-display "set-read-only: ~A?" (read-only index)))
      (when with-gui
	(let ((a-ctr 0))
	  (bind-key #\a 0 (lambda () (set! a-ctr 3)))
	  (key (char->integer #\a) 0)
	  (if (not (= a-ctr 3)) (snd-display "bind-key: ~A?" a-ctr))
	  (let ((str (object->string (procedure-source (key-binding (char->integer #\a) 0)) #f)))
	    (if (not (string=? str "(lambda () (set! a-ctr 3))"))
		(snd-display "key-binding: ~A?" str)))
	  (unbind-key (char->integer #\a) 0))
	(key (char->integer #\a) 0))
      (do ((i 0 (+ i 1)))
	  ((= i 5))
	(when (string? *eps-file*)
	  (if (file-exists? *eps-file*)
	      (delete-file *eps-file*))
	  (set! *graph-style* i)
	  (graph->ps)
	  (if (file-exists? *eps-file*)
	      (delete-file *eps-file*)
	      (snd-display "graph->ps: ~A?" *eps-file*))))
      (let ((err (catch 'cannot-print 
		   (lambda () 
		     (graph->ps "/bad/bad.eps"))
		   (lambda args 12345))))
	(if (not (= err 12345)) (snd-display "graph->ps err: ~A?" err)))
      (when with-gui
	(let ((n2 (or (open-sound "2.snd") (open-sound "4.aiff"))))
	  (set! (transform-graph? n2) #t)
	  (set! (channel-style n2) channels-superimposed)
	  (if (not (= (channel-style n2) channels-superimposed)) (snd-display "channel-style->~D: ~A?" channels-superimposed (channel-style n2)))
	  (graph->ps "aaa.eps")
	  (set! (channel-style n2) channels-combined)
	  (if (not (= (channel-style n2) channels-combined)) (snd-display "channel-style->~D: ~A?" channels-combined (channel-style n2)))
	  (graph->ps "aaa.eps")
	  (set! (channel-style n2) channels-separate)
	  (if (not (= (channel-style n2) channels-separate)) (snd-display "channel-style->~D: ~A?" channels-separate (channel-style n2)))
	  (graph->ps "aaa.eps")
	  (close-sound n2)))
      
      (let ((xp (x-position-slider))
	    (yp (y-position-slider))
	    (xz (x-zoom-slider))
	    (yz (y-zoom-slider))
	    (bnds (x-bounds index)))
	(when (= (channels index) 1)
	  (set! (channel-style index) channels-superimposed)
	  (if (not (= (channel-style index) channels-separate)) (snd-display "channel-style[0]->~D: ~A?" channels-separate (channel-style index))))
	(set! (sync index) 32)
	(if (not (= (sync index) 32)) (snd-display "sync->32: ~A?" (sync index)))
	(if (< (sync-max) 32) (snd-display "sync-max 32: ~A" (sync-max)))
	(set! (sync index) 0)
	(set! (channel-sync index 0) 12)
	(if (not (= (channel-sync index 0) 12)) (snd-display "sync-chn->12: ~A?" (channel-sync index 0)))
	(set! (channel-sync index 0) 0)
	(if (fneq xp 0.0) (snd-display "x-position-slider: ~A?" xp))
	(if (fneq yp 0.0) (snd-display "y-position-slider: ~A?" yp))
	(if (and (fneq xz 0.04338) (fneq xz 1.0)) (snd-display "x-zoom-slider: ~A?" xz))
	(if (fneq yz 1.0) (snd-display "y-zoom-slider: ~A?" yz))
	(if (or (fneq (car bnds) 0.0) (and (fneq (cadr bnds) 0.1) (fneq (cadr bnds) 2.305)))
	    (snd-display "x-bounds: ~A?" bnds)))
      
      (if (not (equal? (find-sound "oboe.snd") index)) (snd-display "oboe: index ~D is not ~D?" (find-sound "oboe.snd") index))
      (if (not (sound? index)) (snd-display "oboe: ~D not ok?" index))
      (if (not (= (chans index) 1)) (snd-display "oboe: chans ~D?" (chans index)))
      (if (not (= (channels index) 1)) (snd-display "oboe: channels ~D?" (channels index)))
      (if (not (= (framples index) 50828)) (snd-display "oboe: framples ~D?" (framples index)))
      (if (not (= (srate index) 22050)) (snd-display "oboe: srate ~D?" (srate index)))
      (if (not (= (data-location index) 28)) (snd-display "oboe: location ~D?" (data-location index)))
      (if (not (= (data-size index) 101656)) (snd-display "oboe: size ~D?" (data-size index)))
      (if (not (= (sample-type index) mus-bshort)) (snd-display "oboe: format ~A?" (sample-type index)))
      (if (fneq (maxamp index) .14724) (snd-display "oboe: maxamp ~F?" (maxamp index)))
      (if (not (= (maxamp-position index) 24971)) (snd-display "oboe: maxamp-position ~A?" (maxamp-position index)))
      (if (> (length (comment index)) 0) (snd-display "oboe: comment ~A?" (comment index)))
      (if (not (string=? (short-file-name index) "oboe.snd")) (snd-display "oboe short name: ~S?" (short-file-name index)))
      (let ((matches (count-matches (lambda (a) (> a .125)))))
	(if (not (= matches 1313)) (snd-display "count-matches: ~A?" matches)))
      (let ((spot (scan-channel (lambda (a) (> a .13)))))
	(if (not (eqv? spot 8862)) (snd-display "find: ~A?" spot)))
      (set! (right-sample) 3000) 
      (let ((samp (right-sample)))
	(if (> (abs (- samp 3000)) 1) (snd-display "right-sample: ~A?" samp)))
      (set! (left-sample) 1000) 
      (let ((samp (left-sample)))
	(if (> (abs (- samp 1000)) 1) (snd-display "left-sample: ~A?" samp)))
      (let ((eds (edits)))
	(if (not (= (car eds) 0 (cadr eds)))
	    (snd-display "edits: ~A?" eds))
	(if (not (= (edit-position) (car eds)))
	    (snd-display "edit-position: ~A ~A?" (edit-position) eds)))
      (play index :channel 0 :wait #t)
      
      (if (not *selection-creates-region*) (set! *selection-creates-region* #t))
      (select-all index 0) 
      (let ((r0 (car (regions)))
	    (sel (selection)))
	(if (not (selection?)) (snd-display "selection?"))
	(if (not (selection? sel)) (snd-display "selection? sel"))
	(if (not (region? r0)) (snd-display "region?"))
	(if (not (= (selection-chans) 1)) (snd-display "selection-chans(1): ~A" (selection-chans)))
	(if (not (= (channels sel) 1)) (snd-display "generic selection-chans(1): ~A" (channels sel)))
	(if (not (= (selection-srate) (srate index))) (snd-display "selection-srate: ~A ~A" (selection-srate) (srate index)))
	(if (not (= (srate sel) (srate index))) (snd-display "generic selection-srate: ~A ~A" (srate sel) (srate index)))
	(if (fneq (region-maxamp r0) (maxamp index)) (snd-display "region-maxamp (1): ~A?" (region-maxamp r0)))
	(if (not (= (region-maxamp-position r0) (maxamp-position index)))
	    (snd-display "region-maxamp-position (1): ~A ~A?" (region-maxamp-position r0) (maxamp-position index)))
	(if (fneq (selection-maxamp index 0) (maxamp index)) (snd-display "selection-maxamp (1): ~A?" (selection-maxamp index 0)))
	(if (fneq (maxamp sel index 0) (maxamp index)) (snd-display "generic selection-maxamp (1): ~A?" (maxamp sel index 0)))
	(if (not (= (selection-maxamp-position index 0) (maxamp-position index)))
	    (snd-display "selection-maxamp-position (1): ~A ~A?" (selection-maxamp-position index 0) (maxamp-position index)))
	(save-region r0 "temp.dat")
	(if (file-exists? "temp.dat")
	    (delete-file "temp.dat")
	    (snd-display "save-region file disappeared?"))
	(play r0 :wait #t) ;needs to be #t here or it never gets run
	(if (not (= (length (regions)) 1)) (snd-display "regions: ~A?" (regions)))
	(if (not (selection-member? index)) (snd-display "selection-member?: ~A" (selection-member? index)))
	(if (not (= (region-srate r0) 22050)) (snd-display "region-srate: ~A?" (region-srate r0)))
	(if (not (= (region-chans r0) 1)) (snd-display "region-chans: ~A?" (region-chans r0)))
	(if (not (equal? (region-home r0) '("oboe.snd" 0 50828))) (snd-display "region-home: ~A" (region-home r0))) ; region-home docs say length
	(if (not (= (region-framples r0) 50828)) (snd-display "region-framples: ~A?" (region-framples r0)))
	(if (not (= (selection-framples) 50828)) (snd-display "selection-framples: ~A?" (selection-framples 0)))
	(if (not (= (framples sel) 50828)) (snd-display "generic selection-framples: ~A?" (framples sel)))
	(if (not (= (length sel) 50828)) (snd-display "generic length selection-framples: ~A?" (length sel)))
	(if (not (= (selection-position) 0)) (snd-display "selection-position: ~A?" (selection-position)))
	(if (not (= (region-position r0 0) 0)) (snd-display "region-position: ~A?" (region-position r0 0)))
	(if (fneq (region-maxamp r0) (maxamp index)) (snd-display "region-maxamp: ~A?" (region-maxamp r0)))
	(if (fneq (selection-maxamp index 0) (maxamp index)) (snd-display "selection-maxamp: ~A?" (selection-maxamp index 0)))
	(let ((samps1 (channel->float-vector 0 50827 index 0))
	      (samps2 (region->float-vector r0 0 50828 0))
	      (vr (make-sampler 0 index 0 1)))
	  (if (not (sampler? vr)) (snd-display "~A not sampler?" vr))
	  (if (not (= (sampler-position vr) 0)) (snd-display "initial sampler-position: ~A" (sampler-position vr)))
	  (if (not (equal? (sampler-home vr) (list index 0))) 
	      (snd-display "sampler-home: ~A ~A?" (sampler-home vr) (list index 0)))
	  (if (sampler-at-end? vr) (snd-display "~A init at end?" vr))
	  (let ((err (catch #t
		       (lambda ()
			 (region->float-vector r0 -1 1233))
		       (lambda args (car args)))))
	    (if (not (eq? err 'no-such-sample)) (snd-display "region->float-vector -1: ~A" err)))
	  (let ((err (catch #t
		       (lambda ()
			 (region->float-vector r0 12345678 1))
		       (lambda args (car args)))))
	    ;; should this return 'no-such-sample?
	    (if err (snd-display "region->float-vector 12345678: ~A" err)))
	  (let ((reader-string (object->string vr #f)))
	    (if (not (string=? reader-string "#<sampler: oboe.snd[0: 0] from 0, at 0, forward>"))
		(snd-display "sampler actually got: [~S]" reader-string)))
	  (catch 'break
	    (lambda ()
	      (do ((i 0 (+ i 1)))
		  ((= i 50827))
		(unless (= ((if (odd? i) next-sample read-sample) vr) (samps1 i) (samps2 i))
		  (snd-display "readers disagree at ~D" i)
		  (throw 'break))))
	    (lambda args (car args)))
	  (free-sampler vr)))
      (let ((var (catch #t (lambda () (make-sampler 0 index -1)) (lambda args args))))
	(if (not (eq? (car var) 'no-such-channel))
	    (snd-display "make-sampler bad chan (-1): ~A" var)))
      (let ((var (catch #t (lambda () (make-sampler 0 index 1)) (lambda args args))))
	(if (not (eq? (car var) 'no-such-channel))
	    (snd-display "make-sampler bad chan (1): ~A, ~A" var index)))
      (let ((fd (make-sampler 0)))
	(if (mix-sampler? fd) (snd-display "sampler: mix ~A" fd))
	(if (region-sampler? fd) (snd-display "sampler: region ~A" fd))
	(if (not (sampler? fd)) (snd-display "sampler: normal ~A" fd))
	(if (not (= (sampler-position fd) 0)) (snd-display "sampler: position: ~A" fd))
	(free-sampler fd)
	(let ((str (object->string fd #f)))
	  (if (not (string=? (substring str (- (length str) 16)) "at eof or freed>"))
	      (snd-display "freed sampler: ~A [~A]?" str (substring str (- (length str) 16))))))
      (let* ((reg (car (regions)))
	     (var (catch #t (lambda () (make-region-sampler reg 0 (+ (region-chans reg) 1))) (lambda args args))))
	(if (not (eq? (car var) 'no-such-channel))
	    (snd-display "make-region-sampler bad chan (2): ~A ~A" var (regions)))
	(let ((tag (catch #t (lambda () (make-region-sampler reg 0 0 -2)) (lambda args args))))
	  (if (not (eq? (car tag) 'no-such-direction))
	      (snd-display "make-region-sampler bad dir (-2): ~A" tag))))
      
      (revert-sound index)
      (insert-sample 100 .5 index) 
      (let ((var (catch #t (lambda () (insert-sound "oboe.snd" 0 1)) (lambda args args))))
	(if (not (eq? (car var) 'no-such-channel))
	    (snd-display "insert-sound bad chan (1): ~A" var)))
      (let ((var (catch #t (lambda () (insert-sample -12 1.0)) (lambda args args))))
	(if (not (eq? (car var) 'no-such-sample))
	    (snd-display "insert-sample bad pos: ~A" var)))
      (set! (show-axes index 0) show-no-axes)
      (update-transform-graph index) 
      (update-time-graph index) 
      (if (or (fneq (sample 100) .5)
	      (not (= (framples index) 50829)))
	  (snd-display "insert-sample: ~A ~A?" (sample 100) (framples index)))
      (let ((v0 (make-vector 3 .25))
	    (v1 (make-float-vector 3 .75)))
	(insert-samples 200 3 v0 index) 
	(insert-samples 300 3 v1 index) 
	(if (or (fneq (sample 201) .25)
		(fneq (sample 301) .75)
		(not (= (framples index) 50835)))
	    (snd-display "insert-samples: ~A ~A ~A?" (sample 201) (sample 301) (framples index))))
      (save-sound-as "hiho.snd" index 22050 mus-ldouble mus-next)
      (let ((nindex (view-sound "hiho.snd")))
	(if (fneq (sample 101 nindex) (sample 101 index))
	    (snd-display "save-sound-as: ~A ~A?" (sample 101 nindex) (sample 101 index)))
	(if (not (read-only nindex)) (snd-display "read-only view-sound: ~A?" (read-only nindex)))
	
	(set! (speed-control-style nindex) speed-control-as-semitone)
	(if (not (= (speed-control-style nindex) speed-control-as-semitone))
	    (snd-display "speed-control-style set semi: ~A" (speed-control-style nindex)))
	(set! (speed-control-tones nindex) -8)
	(if (not (= (speed-control-tones nindex) 12))
	    (snd-display "speed-control-tones -8: ~A" (speed-control-tones nindex)))
	(set! (speed-control-tones nindex) 18)
	(if (not (= (speed-control-tones nindex) 18))
	    (snd-display "speed-control-tones 18: ~A" (speed-control-tones nindex)))
	(graph->ps "aaa.eps")
	(close-sound nindex))
      (revert-sound index)
      (set! (sample 50 index) .5) 
      (if (fneq (sample 50) .5) (snd-display "set-sample: ~A?" (sample 50)))
      (let ((v0 (make-vector 3 0.25)))
	(set! (samples 60 3 index) v0) 
	(if (or (fneq (sample 60) .25) (fneq (sample 61) .25))
	    (snd-display "set-samples: ~A ~A ~A?" (sample 60) (sample 61) (sample 62))))
      (set! (samples 10 3 index) (list 0.1 0.2 0.3))
      (if (not (mus-arrays-equal? (channel->float-vector 10 3 index) #r(0.1 0.2 0.3)))
	  (snd-display "set-samples via list: ~A" (channel->float-vector 10 3 index)))
      (revert-sound index)
      (save-sound-as "temporary.snd" index)
      (set! (samples 100000 20000 index) "temporary.snd")
      (if (not (mus-arrays-equal? (channel->float-vector 110000 10) (channel->float-vector 10000 10)))
	  (snd-display "set samples to self: ~A ~A" (channel->float-vector 110000 10) (channel->float-vector 10000 10)))
      (revert-sound index)
      (delete-sample 100 index) 
      (if (not (file-exists? "temporary.snd"))
	  (snd-display "set-samples temp deleted?"))
      (delete-file "temporary.snd")
      (if (not (= (framples index) 50827)) (snd-display "delete-sample: ~A?" (framples index)))
      (delete-samples 0 100 index) 
      (if (not (= (framples index) 50727)) (snd-display "delete-samples: ~A?" (framples index)))
      (revert-sound index)
      (let ((maxa (* 2.0 (maxamp index))))
	(scale-to .5 index) 
	(let ((newmaxa (maxamp index)))
	  (if (fneq newmaxa .5) (snd-display "scale-to: ~A?" newmaxa))
	  (undo 1 index) 
	  (scale-by 2.0 index))
	(let ((newmaxa (maxamp index)))
	  (if (fneq newmaxa maxa) (snd-display "scale-by: ~A?" newmaxa)))
	(revert-sound index)
	(scale-by -1 index)
	(mix "oboe.snd")
	(if (fneq (maxamp index 0) 0.0) (snd-display "invert+mix->~A" (maxamp)))
	(revert-sound index)
	(select-all index) 
	(if (not (= (length (regions)) 2)) (snd-display "regions(2): ~A?" (regions)))
	(scale-selection-to .5)
	(let ((newmaxa (maxamp index)))
	  (if (fneq newmaxa .5) (snd-display "scale-selection-to: ~A?" newmaxa)))
	(revert-sound index)
	(select-all index) 
	(scale-selection-by 2.0)
	(let ((newmaxa (maxamp index)))
	  (if (fneq newmaxa maxa) (snd-display "scale-selection-by: ~A?" newmaxa))
	  (revert-sound index)
	  (with-temporary-selection (lambda () (scale-selection-by 2.0)) 0 (framples) index 0))
	(let ((newmaxa (maxamp index)))
	  (if (fneq newmaxa maxa) (snd-display "with-temporary-selection: ~A?" newmaxa))))
      (revert-sound index)
      (let ((samp999 (sample 999 index 0))
	    (samp1001 (sample 1001 index 0)))
	(with-temporary-selection (lambda () (scale-selection-to 2.0)) 1000 1 index 0)
	(if (fneq (sample 1000 index 0) 2.0) (snd-display "with-temporary-selection 1000: ~A" (sample 1000 index 0)))
	(if (fneq (sample 999 index 0) samp999) (snd-display "with-temporary-selection 999: ~A from ~A" (sample 999 index 0) samp999))
	(if (fneq (sample 1001 index 0) samp1001) (snd-display "with-temporary-selection 1001: ~A from ~A" (sample 1001 index 0) samp1001)))
      (revert-sound index)
      (make-selection 100 199 index 0)
      (let ((old-start (selection-position index 0))
	    (old-len (selection-framples index 0)))
	(with-temporary-selection (lambda () (scale-selection-to 2.0)) 1000 1 index 0)
	(if (not (selection?)) (snd-display "with-temporary-selection restore?"))
	(if (not (selection-member? index 0)) (snd-display "with-temporary-selection not member?"))
	(if (not (= (selection-position index 0) old-start)) (snd-display "with-temporary-selection start: ~A" (selection-position index 0)))
	(if (not (= (selection-framples index 0) old-len)) (snd-display "with-temporary-selection len: ~A" (selection-framples index 0))))
      (unselect-all)
      (if (selection-member? index 0) (snd-display "unselect all ~D 0?" index))
      (revert-sound index)
      (select-all index) 
      (let ((rread (make-region-sampler (car (regions)) 0))
	    (sread (make-sampler 0 index)))
	(let ((rvect (region->float-vector (car (regions)) 0 100))
	      (svect (samples 0 100 index)))
	  (if (fneq (rvect 1) (region-sample (car (regions)) 1))
	      (snd-display "region-sample: ~A ~A?" (region-sample (car (regions)) 1) (rvect 1)))
	  (do ((i 0 (+ i 1)))
	      ((= i 100))
	    (let ((rval (next-sample rread))
		  (sval (next-sample sread)))
	      (if (fneq rval sval) (snd-display "sample-read: ~A ~A?" rval sval))
	      (if (fneq rval (rvect i)) (snd-display "region-samples: ~A ~A?" rval (rvect i)))
	      (if (fneq sval (svect i)) (snd-display "samples: ~A ~A?" sval (svect i))))))
	(free-sampler rread) 
	(let ((val0 (next-sample sread)))
	  (if (sampler-at-end? sread) (snd-display "premature end?"))
	  (previous-sample sread)
	  (let ((val1 (previous-sample sread)))
	    (if (fneq val0 val1) (snd-display "previous-sample: ~A ~A?" val0 val1))))
	(free-sampler sread))
      (revert-sound index)
      (let ((s100 (sample 100))
	    (s40 (sample 40))
	    (len (framples))
	    (addlen (mus-sound-framples "fyow.snd")))
	(set! *cursor-style* cursor-line)
	(set! *cursor-size* 25)
	(set! (cursor index) 50) 
	(if (not (= *cursor-style* cursor-line))
	    (snd-display "cursor-style: ~A? " *cursor-style*))
	(if (not (= *cursor-size* 25))
	    (snd-display "cursor-size: ~A? " *cursor-size*))
	(set! *cursor-style* cursor-cross)
	(set! *cursor-size* 15)
	(set! (cursor index 0) 30) 
	(set! *cursor-style* cursor-line)
	(set! (cursor index 0) 20) 
	(when (and with-gui
		   (provided? 'snd-motif))
	  (set! (cursor-style index 0)
		(lambda (snd chn ax)
		  (let ((point (cursor-position)))
		    (let ((x (car point))
			  (y (cadr point))
			  (size (floor (/ *cursor-size* 2))))
		      (draw-line (- x size) (- y size) (+ x size) (+ y size) snd chn cursor-context #f)    
		      (draw-line (- x size) (+ y size) (+ x size) (- y size) snd chn cursor-context #f)))))
	  (if (not (procedure? (cursor-style index 0))) (snd-display "set cursor-style to proc: ~A" (cursor-style index 0))))
	(set! (cursor index) 50)
	(insert-sound "fyow.snd" (cursor) 0 index 0) 
	(if (or (fneq (sample 40) s40) (not (fneq (sample 100) s100)) (fneq (sample 100) 0.001831))
	    (snd-display "insert-sound: ~A?" (sample 100)))
	(if (not (= (framples) (+ len addlen))) (snd-display "insert-sound len: ~A?" (framples)))
	(save-sound-as "not-temporary.snd")
	(insert-samples 0 100 "not-temporary.snd")
	(set! (cursor index 0 0) (- (framples index 0 0) 2))
	(revert-sound)
	(if (not (= (cursor index 0) (- (framples index 0) 2)))
	    (snd-display "set edpos cursor: ~A ~A ~A" (cursor) (cursor index 0 0) (- (framples index 0 0) 2)))
	(if (file-exists? "not-temporary.snd")
	    (delete-file "not-temporary.snd")
	    (snd-display "insert-samples deleted its file?"))
	(let ((id (make-region 0 99)))
	  (insert-region id 60 index) 
	  (if (not (= (framples) (+ len 100))) (snd-display "insert-region len: ~A?" (framples)))
	  (if (fneq (sample 100) s40) (snd-display "insert-region: ~A ~A?" (sample 100) s40))
	  (save-region id "fmv.snd")
	  (if (not (= (mus-sound-header-type "fmv.snd") mus-next))
	      (snd-display "save-region header: ~A?" (mus-header-type-name (mus-sound-header-type "fmv.snd"))))
	  (if (not (= (mus-sound-sample-type "fmv.snd") mus-out-format))
	      (snd-display "save-region format: ~A?" (mus-sample-type-name (mus-sound-sample-type "fmv.snd"))))
	  (if (not (= (mus-sound-srate "fmv.snd") (region-srate id)))
	      (snd-display "save-region srate: ~A (~A)" (mus-sound-srate "fmv.snd") (region-srate id)))
	  (if (not (= (mus-sound-chans "fmv.snd") (region-chans id)))
	      (snd-display "save-region chans: ~A (~A)" (mus-sound-chans "fmv.snd") (region-chans id)))
	  (if (not (= (mus-sound-framples "fmv.snd") (region-framples id)))
	      (snd-display "save-region length: ~A (~A)" (mus-sound-framples "fmv.snd") (region-framples id)))
	  (if (not (= (region-position id 0) 0))
	      (snd-display "save-region position: ~A" (region-position id 0)))
	  (delete-file "fmv.snd")
	  (save-region id "fmv.snd" mus-lshort mus-riff "this is a comment")
	  (if (not (= (mus-sound-header-type "fmv.snd") mus-riff))
	      (snd-display "save-region riff header: ~A?" (mus-header-type-name (mus-sound-header-type "fmv.snd"))))
	  (if (not (= (mus-sound-sample-type "fmv.snd") mus-lshort))
	      (snd-display "save-region lshort format: ~A?" (mus-sample-type-name (mus-sound-sample-type "fmv.snd"))))
	  (if (not (= (mus-sound-framples "fmv.snd") (region-framples id)))
	      (snd-display "save-region length: ~A (~A)" (mus-sound-framples "fmv.snd") (region-framples id)))
	  (if (not (string=? (mus-sound-comment "fmv.snd") "this is a comment"))
	      (snd-display "save-region comment: ~A" (mus-sound-comment "fmv.snd")))
	  (delete-file "fmv.snd")
	  (save-region id :file "fmv.snd" :header-type mus-riff :sample-type mus-lshort :comment "this is a comment")
	  (if (not (= (mus-sound-header-type "fmv.snd") mus-riff))
	      (snd-display "save-region opt riff header: ~A?" (mus-header-type-name (mus-sound-header-type "fmv.snd"))))
	  (if (not (= (mus-sound-sample-type "fmv.snd") mus-lshort))
	      (snd-display "save-region opt lshort format: ~A?" (mus-sample-type-name (mus-sound-sample-type "fmv.snd"))))
	  (if (not (= (mus-sound-framples "fmv.snd") (region-framples id)))
	      (snd-display "save-region opt length: ~A (~A)" (mus-sound-framples "fmv.snd") (region-framples id)))
	  (if (not (string=? (mus-sound-comment "fmv.snd") "this is a comment"))
	      (snd-display "save-region opt comment: ~A" (mus-sound-comment "fmv.snd")))
	  (delete-file "fmv.snd")
	  (save-region id :comment "this is a comment" :file "fmv.snd" :sample-type mus-lshort :header-type mus-riff)
	  (if (not (= (mus-sound-header-type "fmv.snd") mus-riff))
	      (snd-display "save-region opt1 riff header: ~A?" (mus-header-type-name (mus-sound-header-type "fmv.snd"))))
	  (if (not (= (mus-sound-sample-type "fmv.snd") mus-lshort))
	      (snd-display "save-region opt1 lshort format: ~A?" (mus-sample-type-name (mus-sound-sample-type "fmv.snd"))))
	  (if (not (= (mus-sound-framples "fmv.snd") (region-framples id)))
	      (snd-display "save-region opt1 length: ~A (~A)" (mus-sound-framples "fmv.snd") (region-framples id)))
	  (if (not (string=? (mus-sound-comment "fmv.snd") "this is a comment"))
	      (snd-display "save-region opt1 comment: ~A" (mus-sound-comment "fmv.snd")))
	  (delete-file "fmv.snd")
	  (save-region id "fmv.snd" :sample-type mus-bshort)
	  (if (not (= (mus-sound-header-type "fmv.snd") mus-next))
	      (snd-display "save-region opt2 next header: ~A?" (mus-header-type-name (mus-sound-header-type "fmv.snd"))))
	  (if (not (= (mus-sound-sample-type "fmv.snd") mus-bshort))
	      (snd-display "save-region opt2 bshort format: ~A?" (mus-sample-type-name (mus-sound-sample-type "fmv.snd"))))
	  (delete-file "fmv.snd")))
      (close-sound index))
    (let ((var (catch #t (lambda () (new-sound "hi.snd" :channels 0)) (lambda args args))))
      (if (not (and (pair? var)
		    (eq? (car var) 'out-of-range)))
	  (snd-display "new-sound bad chan: ~A" var)))
    (let ((index (new-sound "fmv.snd" 2 22050 mus-ldouble mus-next "unequal lens")))
      (set! (sync index) 0) ; might be set by choice of graphs
      (insert-silence 0 1000 index 1)
      (if (not (and (= (framples index 0) 1)
		    (= (framples index 1) 1001)))
	  (snd-display "silence 1: ~A ~A" (framples index 0) (framples index 1)))
      (save-sound index)
      (if (not (= (framples index 0) 1001 (framples index 1)))
	  (snd-display "saved silence 1: ~A ~A" (framples index 0) (framples index 1)))
      (if (not (= (mus-sound-framples "fmv.snd") 1001))
	  (snd-display "saved framers silence 1: ~A" (mus-sound-framples "fmv.snd")))
      (let ((v0 (float-vector-peak (channel->float-vector 0 1000 index 0)))
	    (v1 (float-vector-peak (channel->float-vector 0 1000 index 1))))
	(if (fneq v0 0.0)
	    (snd-display "auto-pad 0: ~A" v0))
	(if (fneq v1 0.0)
	    (snd-display "silence 0: ~A" v1)))
      (close-sound index))
    (delete-file "fmv.snd")
    
    (let ((index (new-sound "fmv.snd" 2 22050 mus-ldouble mus-next "unequal lens")))
      (pad-channel 0 1000 index 1)
      (if (not (and (= (framples index 0) 1)
		    (= (framples index 1) 1001)))
	  (snd-display "pad-channel 1: ~A ~A" (framples index 0) (framples index 1)))
      (let ((v0 (float-vector-peak (channel->float-vector 0 1000 index 0)))
	    (v1 (float-vector-peak (channel->float-vector 0 1000 index 1))))
	(if (fneq v0 0.0)
	    (snd-display "pad 0: ~A" v0))
	(if (fneq v1 0.0)
	    (snd-display "pad 1: ~A" v1)))
      (map-channel (lambda (n) 1.0) 0 2 index 0)
      (map-channel (lambda (n) 1.0) 0 1002 index 1)
      (pad-channel 0 1000 index 0 1)
      (if (not (= (framples index 1) 1002))
	  (snd-display "pad-channel ed 1: ~A ~A" (framples index 0) (framples index 1)))
      (close-sound index)
      (delete-file "fmv.snd")
      
      (let ((ind (open-sound "1a.snd")))
	(scale-to 1.0 ind 0)
	(make-selection 1000 2000 ind 0)
	(filter-selection-and-smooth .01 #r(.25 .5 .5 .5 .25))
	(revert-sound ind)
	(close-sound ind)))
    
    (let ((index (new-sound "fmv.snd" 1 22050 mus-bshort mus-ircam "this is a comment")))
      (let ((v0 (make-float-vector 128)))
	(set! (v0 64) .5)
	(set! (v0 127) .5)
	(float-vector->channel v0 0 128 index 0)
	(make-selection 0 126) 
	(smooth-selection)) 
      
      (let ((v0 (channel->float-vector 0 128 index 0)))
	(if (or (fneq (sample 127) .5) (fneq (sample 120) .4962) (fneq (sample 32) 0.07431) (fneq (sample 64) 0.25308))
	    (snd-display "smooth-selection: ~A?" v0))
	(revert-sound index)
	(fill! v0 0.0)
	(set! (v0 10) .5)
	(float-vector->channel v0)
	(select-all) 
	(let-temporarily ((*sinc-width* 40))
	  (src-selection 0.5)))
      
      (let ((v0 (channel->float-vector 0 128 index 0)))
	(if (or (fneq (sample 20) .5) (fneq (sample 30) 0.0) (fneq (sample 17) -.1057) )
	    (snd-display "src-selection: ~A?" v0))
	(unselect-all)
	(if (selection-member?) (snd-display "unselect-all but still a selection?"))
	(unselect-all)
	(revert-sound index)
	(fill! v0 0.0)
	(set! (v0 10) .5)
	(float-vector->channel v0 0)
	(select-all) 
	(filter-selection '(0 0 .1 1 1 0) 40))
      
      (let ((v0 (channel->float-vector 0 128 index 0)))
	(if (or (fneq (sample 29) .1945) (fneq (sample 39) -.0137) (fneq (sample 24) -0.01986))
	    (snd-display "filter-selection: ~A?" v0))
	(revert-sound index)
	(fill! v0 1.0)
	(float-vector->channel v0 0 128 index 0) 
	(select-all) 
	(filter-selection (make-one-zero :a0 .5 :a1 0.0)))
      
      (let ((v0 (channel->float-vector 0 128 index 0)))
	(if (or (fneq (sample 29) .5) (fneq (sample 39) .5) (fneq (sample 24) 0.5))
	    (snd-display "filter-selection one-zero: ~A?" v0))
	(revert-sound index)
	(fill! v0 1.0)
	(float-vector->channel v0 0 128 index 0) 
	(if (file-exists? "fmv5.snd") (delete-file "fmv5.snd"))
	(select-all) 
	(env-selection '(0 0 1 1 2 0) 1.0))
      
      (let ((v0 (channel->float-vector 0 128 index 0)))
	(if (or (fneq (sample 64) 1.0) (fneq (sample 20) .3125) (fneq (sample 119) 0.127))
	    (snd-display "env-selection [len: ~A]: ~A ~A ~A ~A?" (selection-framples) (sample 64) (sample 20) (sample 119) v0))
	(save-selection "fmv5.snd" 22050 mus-bint mus-next "") ;1.0->-1.0 if short
	(revert-sound index)
	(let ((tag (catch #t (lambda () (file->array "/baddy/hiho" 0 0 128 v0)) (lambda args (car args)))))
	  (if (not (eq? tag 'no-such-file)) (snd-display "file->array w/o file: ~A" tag)))
	(let ((tag (catch #t (lambda () (file->array "fmv5.snd" 123 0 128 v0)) (lambda args (car args)))))
	  (if (not (eq? tag 'no-such-channel)) (snd-display "file->array w/o channel: ~A" tag)))
	(file->array "fmv5.snd" 0 0 128 v0) 
	(if (or (fneq (v0 64) 1.0) (fneq (v0 20) .3125) (fneq (v0 119) 0.127))
	    (snd-display "save-selection: ~A ~A ~A ~A?" (v0 64) (v0 20) (v0 119) v0))
	(if (not (= (mus-sound-header-type "fmv5.snd") mus-next))
	    (snd-display "save-selection type: ~A?" (mus-header-type-name (mus-sound-header-type "fmv5.snd"))))
	(if (not (= (mus-sound-sample-type "fmv5.snd") mus-bint))
	    (snd-display "save-selection format: ~A?" (mus-sample-type-name (mus-sound-sample-type "fmv5.snd"))))
	(if (not (= (mus-sound-srate "fmv5.snd") 22050))
	    (snd-display "save-selection srate: ~A?" (mus-sound-srate "fmv5.snd")))
	(fill! v0 0.0)
	(set! (v0 100) .5)
	(set! (v0 2) -.5)
	(float-vector->channel v0 0 128 index 0) 
	(select-all) 
	(without-errors (reverse-selection)) 
	(save-selection "fmv4.snd" 44100 mus-lfloat mus-riff "this is a comment"))
      
      (let ((v0 (channel->float-vector 0 128 index 0)))
	(if (or (fneq (sample 27) 0.5) (fneq (sample 125) -.5))
	    (snd-display "reverse-selection: ~A?" v0))
	(file->array "fmv4.snd" 0 0 128 v0) 
	(if (or (fneq (sample 27) 0.5) (fneq (sample 125) -.5))
	    (snd-display "save reverse-selection: ~A?" v0))
	(if (not (= (mus-sound-header-type "fmv4.snd") mus-riff))
	    (snd-display "save-selection type 1: ~A?" (mus-header-type-name (mus-sound-header-type "fmv4.snd"))))
	(if (not (= (mus-sound-sample-type "fmv4.snd") mus-lfloat))
	    (snd-display "save-selection format 1: ~A?" (mus-sample-type-name (mus-sound-sample-type "fmv4.snd"))))
	(if (not (= (mus-sound-srate "fmv4.snd") 44100))
	    (snd-display "save-selection srate 1: ~A?" (mus-sound-srate "fmv4.snd")))
	(if (not (string=? (mus-sound-comment "fmv4.snd") "this is a comment"))
	    (snd-display "save-selection comment: ~A?" (mus-sound-comment "fmv4.snd")))
	(delete-file "fmv4.snd")
	(save-selection :file "fmv4.snd" :header-type mus-riff :sample-type mus-lfloat :srate 44100 :comment "this is a comment")
	(if (not (= (mus-sound-header-type "fmv4.snd") mus-riff))
	    (snd-display "save-selection opt type 1: ~A?" (mus-header-type-name (mus-sound-header-type "fmv4.snd"))))
	(if (not (= (mus-sound-sample-type "fmv4.snd") mus-lfloat))
	    (snd-display "save-selection opt format 1: ~A?" (mus-sample-type-name (mus-sound-sample-type "fmv4.snd"))))
	(if (not (= (mus-sound-srate "fmv4.snd") 44100))
	    (snd-display "save-selection opt srate 1: ~A?" (mus-sound-srate "fmv4.snd")))
	(if (not (string=? (mus-sound-comment "fmv4.snd") "this is a comment"))
	    (snd-display "save-selection opt comment: ~A?" (mus-sound-comment "fmv4.snd")))
	(delete-file "fmv4.snd")
	(save-selection :file "fmv4.snd" :sample-type mus-bfloat :channel 0)
	(if (not (or (= (mus-sound-header-type "fmv4.snd") mus-next)
		     (= (mus-sound-header-type "fmv4.snd") mus-ircam)))
	    (snd-display "save-selection opt1 type 1: ~A?" (mus-header-type-name (mus-sound-header-type "fmv4.snd"))))
	(if (not (= (mus-sound-sample-type "fmv4.snd") mus-bfloat))
	    (snd-display "save-selection opt1 format 1: ~A?" (mus-sample-type-name (mus-sound-sample-type "fmv4.snd"))))
	(if (not (= (mus-sound-chans "fmv4.snd") 1))
	    (snd-display "save-selection opt1 chans: ~A?" (mus-sound-chans "fmv4.snd")))
	(delete-file "fmv4.snd")
	(revert-sound index)
	(fill! v0 0.0)
	(set! (v0 2) 1.0)
	(let ((v1 (make-float-vector 256)))
	  (copy v0 v1 0 128)
	  (float-vector->channel v1 0 128 index 0))
	(select-all)
	(if (mus-clipping) (set! (mus-clipping) #f))
	(if *clipping* (set! *clipping* #f))
	(convolve-selection-with "fmv5.snd" .5))
      
      (let ((v0 (channel->float-vector 0 128 index 0)))
	(if (fneq (sample 66) -.5) (snd-display "convolve-selection-with: ~A ~A ~A?" (v0 66) (sample 66) v0))
	(close-sound index))
      
      (let ((obind (open-sound "oboe.snd")))
	(when with-gui
	  (let ((vol (maxamp obind))
		(dur (framples)))
	    (set! (amp-control obind) 2.0)
	    (if (fffneq (amp-control obind) 2.0) (snd-display "set amp-control ~A" (amp-control obind)))
	    (reset-controls obind)
	    (if (ffneq (amp-control obind) 1.0) (snd-display "reset amp-control ~A" (amp-control obind)))
	    (set! (amp-control-bounds obind) (list 0.0 4.0))
	    (if (not (equal? (amp-control-bounds obind) '(0.0 4.0))) (snd-display "amp-control-bounds: ~A" (amp-control-bounds)))
	    (set! (amp-control obind) 2.0)
	    (if (eq? (without-errors (apply-controls obind)) 'no-such-sound) (snd-display "apply-controls can't find oboe.snd?"))
	    (let ((newamp (maxamp obind)))
	      (if (> (abs (- (* 2.0 vol) newamp)) .05) (snd-display "apply amp: ~A -> ~A?" vol newamp)))
	    (set! (amp-control-bounds obind) (list 0.0 8.0))
	    (set! (speed-control-bounds obind) (list 1.0 5.0))
	    (if (not (equal? (speed-control-bounds obind) '(1.0 5.0))) (snd-display "speed-control-bounds: ~A" (speed-control-bounds)))
	    (set! (speed-control obind) 0.5)
	    (set! (speed-control-bounds obind) (list .05 20.0))
	    (add-mark 1234)
	    (apply-controls obind)
	    (let ((newdur (framples obind)))
	      (set! (speed-control obind) 1.0)
	      (if (>= (- newdur (* 2.0 dur)) 256) (snd-display "apply speed: ~A -> ~A?" dur newdur))
	      ;; within 256 which is apply's buffer size (it always flushes full buffers) 
	      (set! (contrast-control? obind) #t)
	      (set! (contrast-control-bounds obind) (list 0.5 2.5))
	      (if (not (equal? (contrast-control-bounds obind) '(0.5 2.5))) (snd-display "contrast-control-bounds: ~A" (contrast-control-bounds)))
	      (set! (contrast-control obind) 1.0)
	      (apply-controls obind)
	      (set! (contrast-control-bounds obind) (list 0.0 10.0))
	      (if (not (equal? (contrast-control-bounds obind) '(0.0 10.0))) (snd-display "contrast-control-bounds (2): ~A" (contrast-control-bounds)))
	      (let ((secamp (maxamp obind))
		    (secdur (framples obind)))
		(if (fneq secamp .989) (snd-display "apply contrast: ~A?" secamp))
		(if (not (= secdur newdur)) (snd-display "apply contrast length: ~A -> ~A?" newdur secdur)))))
	  (undo 3 obind)
	  (set! (reverb-control? obind) #t)
	  (set! (reverb-control-scale-bounds obind) (list 0.0 1.0))
	  (if (not (equal? (reverb-control-scale-bounds obind) '(0.0 1.0))) 
	      (snd-display "reverb-control-scale-bounds: ~A" (reverb-control-scale-bounds)))
	  (set! (reverb-control-length-bounds obind) (list 0.0 2.0))
	  (if (not (equal? (reverb-control-length-bounds obind) '(0.0 2.0))) 
	      (snd-display "reverb-control-length-bounds: ~A" (reverb-control-length-bounds)))
	  (set! (reverb-control-scale obind) .2)
	  (let ((nowamp (maxamp obind)))
	    (apply-controls obind)
	    (let ((revamp (maxamp obind))
		  (revdur (framples obind)))
	      (if (ffneq revamp .214) 
		  (snd-display "apply reverb scale: ~A at ~A, scale: ~A previous max: ~A?" 
			       revamp (maxamp-position obind) (reverb-control-scale obind) nowamp))
	      (if (>= (- revdur 50828 (round (* *reverb-control-decay* 22050))) 256) 
		  (snd-display "apply reverb length: ~A?" revdur))))
	  (undo 1 obind)
	  (set! (expand-control? obind) #t)
	  (set! (expand-control-bounds obind) (list 1.0 3.0))
	  (if (not (equal? (expand-control-bounds obind) '(1.0 3.0))) (snd-display "expand-control-bounds: ~A" (expand-control-bounds)))
	  (set! (expand-control obind) 1.5)
	  (apply-controls obind)
	  (let ((expamp (maxamp obind))
		(expdur (framples obind)))
	    (if (> (abs (- expamp .152)) .05) (snd-display "apply expand-control scale: ~A?" expamp))
	    (if (<= expdur (* 1.25 50828)) (snd-display "apply expand-control length: ~A?" expdur))
	    (set! (expand-control-bounds obind) (list 0.001 20.0)))
	  (undo 1 obind)
	  (set! (filter-control? obind) #t)
	  (set! (filter-control-order obind) 40)
	  (set! (filter-control-envelope obind) '(0 0 1 .5 2 0))
	  (apply-controls obind)
	  (let ((fltamp (maxamp obind))
		(fltdur (framples obind)))
	    (if (> (abs (- fltamp .02)) .005) (snd-display "apply filter scale: ~A?" fltamp))
	    (if (> fltdur 51124) (snd-display "apply filter length: ~A?" fltdur))
	    (undo 1 obind)))
	
	(revert-sound obind)
	(make-selection 1000 1000)
	(scale-selection-to .1)
	(scale-selection-by 2.0)
	(make-selection 2000 2001)
	(scale-selection-by 2.0)
	(scale-selection-to .5)
	(make-selection 1000 2001)
	(scale-selection-to .5)
	(scale-selection-by .5)
	(make-selection 2000 2000)
	(scale-selection-by 2.0)
	(scale-selection-to .5)
	(make-selection 1000 1001)
	(scale-selection-to .1)
	(scale-selection-by 2.0)
	(make-selection 999 2002)
	(scale-selection-to 1.0)
	(scale-selection-by .5)
	(let ((tree (edit-tree))
	      (true-tree #((0 0 0 998 1.0 0.0 0.0 0) 
			   (999 0 999 999 0.999969720840454 0.0 0.0 0) 
			   (1000 0 1000 1000 6.09052181243896 0.0 0.0 0) 
			   (1001 0 1001 1001 0.999969720840454 0.0 0.0 0) 
			   (1002 0 1002 1999 0.499984979629517 0.0 0.0 0) 
			   (2000 0 2000 2000 7.54652404785156 0.0 0.0 0) 
			   (2001 0 2001 2001 3.7732629776001 0.0 0.0 0) 
			   (2002 0 2002 2002 0.999969720840454 0.0 0.0 0) 
			   (2003 0 2003 50827 1.0 0.0 0.0 0) 
			   (50828 -2 0 0 0.0 0.0 0.0 0))))
	  (if (not (= (length tree) (length true-tree)))
	      (snd-display "edit trees are not same length: ~A ~A?" (length tree) (length true-tree))
	      (do ((len (length tree))
		   (i 0 (+ i 1)))
		  ((= i len))
		(let ((branch (tree i))
		      (true-branch (true-tree i)))
		  (if (not (and (= (car branch) (car true-branch))
				(= (cadr branch) (cadr true-branch))
				(= (caddr branch) (caddr true-branch))
				(= (cadddr branch) (cadddr true-branch))
				(<= (magnitude (- (branch 4) (true-branch 4))) .001)))
		      (snd-display "edit trees disagree at ~D: ~A ~A" i branch true-branch))))))
	(insert-silence 1001 8)
	(insert-silence 900 50)
	(insert-silence 2005 1)
	(insert-silence 999 2)
	(let ((tree (edit-tree))
	      (true-tree #((0 0 0 899 1.0 0.0 0.0 0) 
			   (900 -1 0 49 0.0 0.0 0.0 0) 
			   (950 0 900 948 1.0 0.0 0.0 0) 
			   (999 -1 0 1 0.0 0.0 0.0 0) 
			   (1001 0 949 998 1.0 0.0 0.0 0) 
			   (1051 0 999 999 0.999969720840454 0.0 0.0 0) 
			   (1052 0 1000 1000 6.09052181243896 0.0 0.0 0) 
			   (1053 -1 0 7 0.0 0.0 0.0 0) 
			   (1061 0 1001 1001 0.999969720840454 0.0 0.0 0)
			   (1062 0 1002 1946 0.499984979629517 0.0 0.0 0) 
			   (2007 -1 0 0 0.0 0.0 0.0 0) 
			   (2008 0 1947 1999 0.499984979629517 0.0 0.0 0) 
			   (2061 0 2000 2000 7.54652404785156 0.0 0.0 0) 
			   (2062 0 2001 2001 3.7732629776001 0.0 0.0 0) 
			   (2063 0 2002 2002 0.999969720840454 0.0 0.0 0) 
			   (2064 0 2003 50827 1.0 0.0 0.0 0) 
			   (50889 -2 0 0 0.0 0.0 0.0 0))))
	  (if (not (= (length tree) (length true-tree)))
	      (snd-display "silenced edit trees are not same length: ~A ~A?" (length tree) (length true-tree))
	      (do ((len (length tree))
		   (i 0 (+ i 1)))
		  ((= i len))
		(let ((branch (tree i))
		      (true-branch (true-tree i)))
		  (if (not (and (= (car branch) (car true-branch))
				(= (cadr branch) (cadr true-branch))
				(= (caddr branch) (caddr true-branch))
				(= (cadddr branch) (cadddr true-branch))
				(<= (magnitude (- (branch 4) (true-branch 4))) .001)))
		      (snd-display "silenced edit trees disagree at ~D: ~A ~A" i branch true-branch))))))
	(if (or (fneq (sample 998) -.03)
		(fneq (sample 999) 0.0)
		(fneq (sample 1000) 0.0)
		(fneq (sample 1001) -.03))
	    (snd-display "insert-silence [999 for 2]: ~A ~A ~A ~A?" (sample 998) (sample 999) (sample 1000) (sample 1001) ))
	(if (or (fneq (sample 2006) -.033)
		(fneq (sample 2007) 0.0)
		(fneq (sample 2008) -.033))
	    (snd-display "insert-silence [2007 for 1]: ~A ~A ~A?" (sample 2006) (sample 2007) (sample 2008)))
	(revert-sound obind)
	(add-mark 1200 obind 0)
	(let ((mark-num (length (marks obind 0))))
	  (scale-by 2.0 obind 0)
	  (let ((mark-now (length (marks obind 0))))
	    (if (not (= mark-num mark-now))
		(snd-display "mark lost after scaling?")))
	  (set! (selection-position) 0)
	  (set! (selection-framples) 100)
	  (scale-selection-to .5)
	  (if (not (= mark-num (length (marks obind 0))))
	      (snd-display "mark lost after selection scaling?")))
	(let ((m1 (add-mark 1000)))
	  (set! (cursor obind 0) 100)
	  (key (char->integer #\u) 4 obind)
	  (key (char->integer #\1) 0 obind)
	  (key (char->integer #\0) 0 obind)
	  (key (char->integer #\0) 0 obind)
	  (key (char->integer #\o) 4 obind)
	  (if (and with-gui (not (= (mark-sample m1) 1100)))
	      (snd-display "mark after zeros: ~D (1100)? " (mark-sample m1))))
	(set! (cursor obind) 0)
	(key (char->integer #\j) 4 obind)
	(if (and with-gui (not (= (cursor obind) 1100))) (snd-display "c-j to ~A" (cursor obind)))
	(add-mark 100)
	(set! (cursor obind) 0)
	(key (char->integer #\u) 4 obind)
	(key (char->integer #\2) 0 obind)
	(key (char->integer #\j) 4 obind)
	(if (and with-gui (not (= (cursor obind) 1100))) (snd-display "c-u 2 c-j ~A" (cursor obind)))
	(key (char->integer #\-) 4 obind)
	(key (char->integer #\j) 4 obind)
	(if (and with-gui (not (= (cursor obind) 100))) (snd-display "c-- c-j ~A" (cursor obind)))
	(revert-sound obind)
	(let ((frs (framples obind)))
	  (make-region 0 999 obind 0)
	  (if (not (selection?)) (snd-display "make-region but no selection? ~A" (selection?)))
	  (delete-selection)
	  (if (not (= (framples obind) (- frs 1000)))
	      (snd-display "delete-selection: ~A?" (framples obind)))
	  (let ((val (sample 0 obind 0)))
	    (undo)
	    (if (fneq (sample 1000) val)
		(snd-display "delete-selection val: ~A ~A" val (sample 1000)))
	    (insert-selection)
	    (let ((var (catch #t (lambda () (insert-selection 0 obind 123)) (lambda args args))))
	      (if (not (eq? (car var) 'no-such-channel))
		  (snd-display "insert-selection bad chan: ~A" var)))
	    (let ((var (catch #t (lambda () (mix-selection 0 obind 123)) (lambda args args))))
	      (if (not (eq? (car var) 'no-such-channel))
		  (snd-display "mix-selection bad chan: ~A" var)))
	    (if (not (= (framples obind) (+ frs 1000)))
		(snd-display "insert-selection: ~A?" (framples obind)))
	    (if (fneq (sample 2000) val)
		(snd-display "insert-selection val: ~A ~A" val (sample 2000))))
	  (let ((val (* 2 (sample 900))))
	    (mix-selection)
	    (if (fneq (sample 900) val)
		(snd-display "mix-selection val: ~A ~A" val (sample 900)))
	    (if (not (= (framples obind) (+ frs 1000)))
		(snd-display "mix-selection len: ~A?" (framples obind)))))
	(close-sound obind))
      
      (let ((ind (open-sound "2.snd")))
	(let ((apply-to-sound 0)
	      (apply-to-selection 2)
	      (len (framples ind)))
	  (set! (sync ind) 1)
	  (set! (speed-control ind) .5)
	  (apply-controls ind apply-to-sound) ; temp 1
	  (if (> (abs (- (framples) (* 2 len))) 256)
	      (snd-display "apply srate .5: ~A ~A" (framples) (* 2 len)))
	  (make-selection 0 (framples))
	  (set! (speed-control ind) .5)
	  (apply-controls ind apply-to-selection) ; temp 2
	  (if (> (abs (- (framples) (* 4 len))) 256)
	      (snd-display "apply srate .5 to selection: ~A ~A" (framples) (* 4 len)))
	  (env-sound '(0 0 1 1) 0 (framples) 32.0) ; temp 3
	  (let ((reg (select-all))) ; make multi-channel region
	    (insert-region reg 0) ; temp 4
	    (insert-selection 0))  ; temp 5
	  (revert-sound ind)
	  (set! (speed-control) .5)
	  (set! (sync ind) 0)
	  (set! (selected-channel ind) 1)
	  (apply-controls ind 1)  ; 1=apply-to-channel
	  (if (> (abs (- (framples ind 1) (* 2 len))) 256)
	      (snd-display "apply srate .5 to chan 1: ~A ~A" (framples ind 1) (* 2 len)))
	  (if (not (= (framples ind 0) len))
	      (snd-display "apply srate .5 but chan 0: ~A ~A" (framples ind 0) len))
	  (set! (speed-control ind) .5)
	  (apply-controls ind apply-to-sound 1000)
	  (make-selection 2000 4000)
	  (set! (speed-control ind) .5)
	  (apply-controls ind apply-to-selection)
	  (set! (selected-channel ind) #f)
	  (if (selected-channel ind) (snd-display "selected-channel #f: ~A" (selected-channel ind)))
	  (close-sound ind))
	
	(let ((ind1 (open-sound "oboe.snd"))
	      (ind2 (open-sound "2.snd")))
	  (let ((mx1 (maxamp ind1 0))
		(mx20 (maxamp ind2 0))
		(mx21 (maxamp ind2 1)))
	    (select-sound ind1)
	    (scale-sound-by 2.0)
	    (let ((nmx (maxamp ind1 0)))
	      (if (fneq (* 2 mx1) nmx) (snd-display "scale-sound-by 2.0: ~A ~A?" mx1 nmx))
	      (if (not (equal? (edit-fragment 1 ind1 0) '("scale-channel 2.000 0 #f" "scale" 0 50828)))
		  (snd-display "scale-sound-by: ~A?" (edit-fragment 1 ind1 0))))
	    (scale-sound-to 0.5)
	    (let ((nmx (maxamp ind1 0)))
	      (if (fneq nmx 0.5) (snd-display "scale-sound-to 0.5: ~A?" nmx))
	      (if (not (equal? (edit-fragment 2 ind1 0) '("scale-channel 1.698 0 #f" "scale" 0 50828)))
		  (snd-display "scale-sound-to: ~A?" (edit-fragment 2 ind1 0))))
	    (scale-sound-by 0.0 0 1000 ind1 0)
	    (let ((nmx (maxamp ind1 0)))
	      (if (fneq 0.5 nmx) (snd-display "scale-sound-by 0.0: ~A ~A?" mx1 nmx))
	      (if (not (equal? (edit-fragment 3 ind1 0) '("scale-channel 0.000 0 1000" "scale" 0 1000)))
		  (snd-display "scale-sound-by 0.0: ~A?" (edit-fragment 3 ind1 0))))
	    (let ((pk (float-vector-peak (channel->float-vector 0 1000 ind1 0))))
	      (if (fneq pk 0.0) (snd-display "scale-sound-by 0.0 [0:1000]: ~A?" pk)))
	    (revert-sound ind1)
	    (let ((oldv (channel->float-vector 12000 10 ind1 0)))
	      (scale-sound-by 2.0 12000 10 ind1 0)
	      (let ((newv (channel->float-vector 12000 10 ind1 0)))
		(do ((i 0 (+ i 1)))
		    ((= i 10))
		  (if (fneq (* 2.0 (oldv i)) (newv i))
		      (snd-display "scale ~D: ~A ~A?" i (oldv i) (newv i)))))
	      (if (not (equal? (edit-fragment 1 ind1 0) '("scale-channel 2.000 12000 10" "scale" 12000 10)))
		  (snd-display "scale-sound-by 2.0 [12000:10]: ~A?" (edit-fragment 1 ind1 0))))
	    (revert-sound ind1)
	    (select-sound ind2)
	    (scale-sound-by 2.0)
	    (let ((nmx (maxamp ind2 0)))
	      (if (fneq (* 2 mx20) nmx) (snd-display "2:0 scale-sound-by 2.0: ~A ~A?" mx20 nmx)))
	    (let ((nmx (maxamp ind2 1)))
	      (if (fneq (* 2 mx21) nmx) (snd-display "2:1 scale-sound-by 2.0: ~A ~A?" mx21 nmx)))
	    (scale-sound-to 0.5)
	    (let ((nmx (max (maxamp ind2 0) (maxamp ind2 1))))
	      (if (fneq nmx 0.5) (snd-display "2 scale-sound-to 0.5: ~A (~A)?" nmx (maxamp ind2))))
	    (scale-sound-by 0.0 0 1000 ind2 1)
	    (if (not (equal? (edit-fragment 3 ind2 1) '("scale-channel 0.000 0 1000" "scale" 0 1000)))
		(snd-display "2:1 scale-sound-by 0.0: ~A?" (edit-fragment 3 ind2 1)))
	    (let ((pk (float-vector-peak (channel->float-vector 0 1000 ind2 1))))
	      (if (fneq pk 0.0) (snd-display "2:1 scale-sound-by 0.0 [0:1000]: ~A?" pk)))
	    (revert-sound ind2)
	    (let ((oldv (channel->float-vector 12000 10 ind2 0)))
	      (scale-sound-by 2.0 12000 10 ind2 0)
	      (let ((newv (channel->float-vector 12000 10 ind2 0)))
		(do ((i 0 (+ i 1)))
		    ((= i 10))
		  (if (fneq (* 2.0 (oldv i)) (newv i))
		      (snd-display "2 scale ~D: ~A ~A?" i (oldv i) (newv i))))))
	    (revert-sound ind2)
	    (set! (sync ind2) 3)
	    (set! (sync ind1) 3)
	    (scale-sound-by 2.0)
	    (let ((nmx (maxamp ind1 0)))
	      (if (fneq mx1 nmx) (snd-display "sync scale-sound-by 2.0: ~A ~A?" mx1 nmx)))
	    (let ((nmx (maxamp ind2 0)))
	      (if (fneq (* 2 mx20) nmx) (snd-display "2:0 sync scale-sound-by 2.0: ~A ~A?" mx20 nmx)))
	    (let ((nmx (maxamp ind2 1)))
	      (if (fneq (* 2 mx21) nmx) (snd-display "2:1 sync scale-sound-by 2.0: ~A ~A?" mx21 nmx)))
	    (scale-sound-to 1.0 20000 40000 ind2 1)
	    (let ((nmx (maxamp ind1 0)))
	      (if (fneq mx1 nmx) (snd-display "sync scale-sound-to 1.0: ~A ~A?" mx1 nmx)))
	    (let ((nmx (maxamp ind2 0)))
	      (if (fneq (* 2 mx20) nmx) (snd-display "2:0 sync scale-sound-to 1.0: ~A ~A?" mx20 nmx)))
	    (let ((nmx (maxamp ind2 1)))
	      (if (fneq nmx 1.0) (snd-display "2:1 sync scale-sound-to 1.0: ~A?" nmx)))
	    
	    (close-sound ind1)
	    (close-sound ind2))))
      
      (let ((ind (open-sound "now.snd")))
	(set! (amp-control ind) .5)
	(if (ffneq (amp-control ind) .5) (snd-display "amp-control (.5): ~A?" (amp-control ind)))
	(set! (amp-control ind 0) .25)
	(if (ffneq (amp-control ind) .5) (snd-display "amp-control after local set (.5): ~A?" (amp-control ind)))
	(if (ffneq (amp-control ind 0) .25) (snd-display "amp-control 0 (.25): ~A?" (amp-control ind 0)))
	(set! (amp-control ind) 1.0)
	(if (ffneq (amp-control ind) 1.0) (snd-display "amp-control (1.0): ~A?" (amp-control ind)))
	(if (ffneq (amp-control ind 0) .25) (snd-display "amp-control 0 after set (.25): ~A?" (amp-control ind 0)))
	(set! (transform-graph? ind 0) #t)
	(set! (transform-graph-type ind 0) graph-as-sonogram)
	(update-transform-graph ind 0)
	(when with-motif
	  (let ((val (transform-framples ind 0)))
	    (if (or (not (pair? val))
		    (fneq (car val) 1.0)
		    (not (= (caddr val) 256)))
		(snd-display "transform-framples: ~A (~A)" val (transform-size ind 0)))))
	(close-sound ind))
      
      (let ((ind (open-sound "4.aiff")))
	(if (ffneq (amp-control ind) 1.0) (snd-display "amp-control upon open (1.0): ~A?" (amp-control ind)))
	(if (ffneq (amp-control ind 2) 1.0) (snd-display "amp-control 2 upon open (1.0): ~A?" (amp-control ind 2)))
	(set! (amp-control ind) .5)
	(if (ffneq (amp-control ind 2) .5) (snd-display "amp-control 2 after global set (.5): ~A?" (amp-control ind 2)))
	(set! (amp-control ind 2) .25)
	(if (ffneq (amp-control ind 2) .25) (snd-display "amp-control 2 (.25): ~A?" (amp-control ind 2)))
	(if (ffneq (amp-control ind 1) .5) (snd-display "amp-control 1 after local set (.5): ~A?" (amp-control ind 1)))
	(let ((after-ran #f))
	  (set! (hook-functions after-apply-controls-hook) ())
	  (hook-push after-apply-controls-hook (lambda (hook) (set! after-ran (hook 'snd))))
	  (apply-controls ind)
	  (if (not (equal? ind after-ran)) (snd-display "after-apply-controls-hook: ~A?" after-ran))
	  (set! (hook-functions after-apply-controls-hook) ()))
	(revert-sound ind)
	(set! (sync ind) 1)
	(scale-to #r(.1 .2))
	(let ((mx (maxamp ind #t)))
	  (if (or (fneq (mx 0) .1)
		  (fneq (mx 1) .2)
		  (fneq (mx 2) .2)
		  (fneq (mx 3) .2))
	      (snd-display "scale to with vector: ~A" mx)))
	(set! (filter-control-envelope ind) '(0 0 1 1))
	(if (not (feql '(0.0 0.0 1.0 1.0) (filter-control-envelope ind))) 
	    (snd-display "set filter-control-envelope: ~A?" (filter-control-envelope ind)))
	(set! (filter-control-order ind) 20)
	(if (not (mus-arrays-equal? (filter-control-coeffs ind)
				    #r(-0.007 0.010 -0.025 0.029 -0.050 0.055 -0.096 0.109 -0.268 0.241 
						  0.241 -0.268 0.109 -0.096 0.055 -0.050 0.029 -0.025 0.010 -0.007)))
	    (snd-display "highpass coeffs: ~A" (filter-control-coeffs ind)))
	(set! (filter-control-envelope ind) '(0 1 1 0))
	(if (not (mus-arrays-equal? (filter-control-coeffs ind)
				    #r(0.003 0.002 0.004 0.002 0.007 0.003 0.014 0.012 0.059 0.394 
						  0.394 0.059 0.012 0.014 0.003 0.007 0.002 0.004 0.002 0.003)))
	    (snd-display "lowpass coeffs: ~A" (filter-control-coeffs ind)))
	(close-sound ind))
      
      (let* ((obind (open-sound "4.aiff"))
	     (amps (maxamp obind #t)))
	(let ((times (maxamp-position obind #t)))
	  (if (not (equal? times '(810071 810071 810071 810071)))
	      (snd-display "4.aiff times: ~A" times)))
	(set! (window-width) (max (window-width) 600))
	(set! (window-height) (max (window-height) 600))
	(set! (x-bounds obind 0) (list 0.0 0.1))
	(set! (show-axes obind 0) show-x-axis)
	(update-time-graph)
	(set! (amp-control obind) 0.1)
	(select-channel 2)
	(if (eq? (without-errors (apply-controls obind 1)) 'no-such-sound) (snd-display "apply-controls can't find 4.aiff?"))
	(let ((newamps (maxamp obind #t)))
	  (if (or (fneq (car amps) (car newamps))
		  (fneq (cadr amps) (cadr newamps))
		  (> (abs (- (* 0.1 (caddr amps)) (caddr newamps))) .05)
		  (fneq (cadddr amps) (cadddr newamps)))
	      (snd-display "apply amps:~%  ~A ->~%  ~A?" amps newamps))
	  (undo 1 obind 2)
	  (set! (amp-control obind) 0.1)
	  (make-region 0 (framples obind) obind 1)
	  (without-errors (apply-controls obind 2))
	  (set! newamps (maxamp obind #t))
	  (if (or (fneq (car amps) (car newamps))
		  (> (abs (- (* 0.1 (cadr amps)) (cadr newamps))) .05)
		  (fneq (caddr amps) (caddr newamps))
		  (fneq (cadddr amps) (cadddr newamps)))
	      (snd-display "apply selection amp:~%  ~A ->~%  ~A?" amps newamps))
	  (when with-gui
	    (let ((axinfo (axis-info obind 0 time-graph)))
	      (let ((losamp (car axinfo))
		    (hisamp (cadr axinfo))
		    (x0 (axinfo 2))
		    (y0 (axinfo 3))
		    (x1 (axinfo 4))
		    (y1 (axinfo 5)))
		(let ((xpos (+ x0 (* .5 (- x1 x0))))
		      (ypos (+ y0 (* .75 (- y1 y0))))
		      (cp-x (lambda (x)
			      (floor (+ (axinfo 10) 
					(* (- x x0) (/ (- (axinfo 12) (axinfo 10)) 
						       (- x1 x0)))))))
		      (cp-y (lambda (y) 
			      (floor (+ (axinfo 13) 
					(* (- y1 y) (/ (- (axinfo 11) (axinfo 13)) 
						       (- y1 y0)))))))
		      (our-x->position 
		       (lambda (ind x) 
			 (let ((ax (axis-info ind 0)))
			   (list
			    (+ (ax 10) 
			       (/ (* (- x (ax 2))
				     (- (ax 12) (ax 10)))
				  (- (ax 4) (ax 2))))
			    (x->position x ind))))))
		  (select-channel 0)
		  (set! (cursor obind) 100)
		  (let ((xy (car (cursor-position obind))))
		    (if (fneq (position->x xy) (/ (cursor obind) (srate obind)))
			(snd-display "cursor-position: ~A ~A ~A?" xy (position->x xy) (/ (cursor obind) (srate obind)))))
		  (if (fneq (position->x (x->position xpos)) xpos)
		      (snd-display "x<->position: ~A ~A?" (position->x (x->position xpos)) xpos))
		  (if (> (abs (- (position->y (y->position ypos)) ypos)) .5)
		      (snd-display "y<->position: ~A ~A?" (position->y (y->position ypos)) ypos))
		  (if (not (= losamp (left-sample obind 0)))
		      (snd-display "axis-info[0 losamp]: ~A ~A?" losamp (left-sample obind 0)))
		  (if (not (= hisamp (right-sample obind 0)))
		      (snd-display "axis-info[1 hisamp]: ~A ~A?" hisamp (right-sample obind 0)))
		  (if (fneq (axinfo 6) 0.0)
		      (snd-display "axis-info[6 xmin]: ~A?" (axinfo 6)))
		  (if (fneq (axinfo 7) -1.0)
		      (snd-display "axis-info[7 ymin]: ~A?" (axinfo 7)))
		  (if (fneq (axinfo 9) 1.0)
		      (snd-display "axis-info[9 ymax]: ~A?" (axinfo 9)))
		  (if (> (abs (apply - (our-x->position obind x0))) 1) 
		      (snd-display "x0->position: ~A?" (our-x->position obind x0)))
		  (if (> (abs (apply - (our-x->position obind x1))) 1) 
		      (snd-display "x1->position: ~A?" (our-x->position obind x1)))
		  (if (> (abs (apply - (our-x->position obind (* 0.5 (+ x0 x1))))) 1)
		      (snd-display "xmid->position: ~A?" (our-x->position obind (* 0.5 (+ x0 x1)))))
		  (unless full-test
		    (if (> (abs (- (x->position xpos) (cp-x xpos))) 1)
			(snd-display "cp-x .5: ~A ~A?" (x->position xpos) (cp-x xpos)))
		    (if (> (abs (- (y->position ypos) (cp-y ypos))) 1)
			(snd-display "cp-y .75: ~A ~A?" (y->position ypos) (cp-y ypos)))
		    (do ((xrange (- x1 x0))
			 (yrange (- y1 y0))
			 (i 0 (+ i 1)))
			((= i 10))
		      (let ((xpos (+ x0 (random xrange)))
			    (ypos (+ y0 (random yrange))))
			(if (> (abs (- (x->position xpos) (cp-x xpos))) 1)
			    (snd-display "cp-x[~A] ~A: ~A ~A?" i xpos (x->position xpos) (cp-x xpos)))
			(if (> (abs (- (y->position ypos) (cp-y ypos))) 1)
			    (snd-display "cp-y[~A] ~A: ~A ~A?" i ypos (y->position ypos) (cp-y ypos)))
			(if (fneq (position->x (cp-x xpos)) xpos)
			    (snd-display "x->position cp-x ~A ~A" xpos (position->x (cp-x xpos))))
			(if (fffneq (position->y (cp-y ypos)) ypos)
			    (snd-display "y->position cp-y ~A ~A" ypos (position->y (cp-y ypos)))))))
		  (set! (left-sample obind 0) 1234)
		  (let ((axob (axis-info obind 0)))
		    (if (not (= 1234 (car axob)))
			(snd-display "axis-info[0 losamp at 1234]: ~A ~A?" (car axob) (left-sample obind 0)))
		    (set! axinfo axob))
		  (set! x0 (axinfo 2))
		  (set! x1 (axinfo 4))
		  (if (> (abs (apply - (our-x->position obind x0))) 1) 
		      (snd-display "x0a->position: ~A?" (our-x->position obind x0)))
		  (if (> (abs (apply - (our-x->position obind x1))) 1) 
		      (snd-display "x1a->position: ~A?" (our-x->position obind x1)))
		  (if (> (abs (apply - (our-x->position obind (* 0.5 (+ x0 x1))))) 1)
		      (snd-display "xmida->position: ~A?" (our-x->position obind (* 0.5 (+ x0 x1)))))
		  (set! (y-bounds obind 0) (list -2.0 3.0))
		  (let ((axob (axis-info obind 0)))
		    (if (fneq (axob 7) -2.0)
			(snd-display "axis-info[7 ymin -2.0]: ~A?" (axob 7)))
		    (if (fneq (axob 9) 3.0)
			(snd-display "axis-info[9 ymax 3.0]: ~A?" (axob 9)))))))
	    (close-sound obind))))
      
      (let* ((ind1 (open-sound "oboe.snd"))
	     (test-orig (lambda (func0 func1 func-name ind1)
			  (let ((v0 (channel->float-vector 12000 10 ind1 0)))
			    (func0)
			    (let ((v1 (channel->float-vector 12000 10 ind1 0)))
			      (if (mus-arrays-equal?1 v0 v1)
				  (snd-display "~A (orig: 0) no change! ~A ~A" func-name v0 v1))
			      (func1)
			      (let ((v2 (channel->float-vector 12000 10 ind1 0)))
				(if (not (mus-arrays-equal?1 v0 v2))
				    (snd-display "~A (orig: 1) ~A ~A" func-name v0 v2))))
			    (revert-sound ind1)))))
  
	(test-orig (lambda () (src-sound 2.0 1.0 ind1)) (lambda () (src-sound 0.5 1.0 ind1)) 'src-sound ind1)
	(test-orig (lambda () (src-channel 2.0)) (lambda () (src-channel 0.5)) 'src-channel ind1)
	(test-orig (lambda () (scale-by 2.0 ind1)) (lambda () (scale-by 0.5 ind1)) 'scale-by ind1)
	(test-orig (lambda () (scale-channel 2.0)) (lambda () (scale-channel 0.5)) 'scale-channel ind1)
	(test-orig (lambda () (reverse-sound ind1)) (lambda () (reverse-sound ind1)) 'reverse-sound ind1)
	(test-orig reverse-channel reverse-channel 'reverse-channel ind1)
	(test-orig (lambda () (env-sound '(0 1.0 1 2.0))) (lambda () (env-sound '(0 1.0 1 0.5))) 'env-sound ind1)
	(test-orig (lambda () (env-sound '(0 1.0 1 2.0 2 1.0))) (lambda () (env-sound '(0 1.0 1 0.5 2 1.0))) 'env-sound ind1)
	(test-orig (lambda () (env-channel (make-env :envelope '(0 1.0 1 2.0) :length (framples))))
		   (lambda () (env-channel (make-env :envelope '((0 1.0) (1 0.5)) :length (framples)))) 'env-channel ind1)
	(test-orig (lambda () (env-channel '(0 1.0 1 2.0)))
		   (lambda () (env-channel '(0 1.0 1 0.5))) 'env-channel ind1)
	(test-orig (lambda () (env-channel (make-env :envelope '(0 2 1 2 2 0.5 3 0.5) :base 0 :length (framples))))
		   (lambda () (env-channel (make-env :envelope '(0 0.5 1 0.5 2 2 3 2) :base 0 :length (framples)))) 'env-channel ind1)
	(test-orig (lambda () (map-channel (lambda (n) (* n 2.0)))) (lambda () (map-channel (lambda (n) (* n 0.5)))) 'map-channel ind1)
	(test-orig (lambda () (map-channel (lambda (n) (* n 2.0)) 1234)) (lambda () (map-channel (lambda (n) (* n 0.5)) 1234)) 'map-channel ind1)
	(test-orig (lambda () (map-channel (lambda (n) (* n 2.0)) 12005 10)) (lambda () (map-channel (lambda (n) (* n 0.5)) 12005 10)) 'map-channel ind1)
	(test-orig (lambda () 
		     (map-channel 
		      (let ((vect (make-float-vector 2))) 
			(lambda (y) 
			  (float-vector-set! vect 0 (float-vector-set! vect 1 (* y 2)))
			  vect))))
		   (lambda () 
		     (map-channel
		      (let ((outp #f))
			(lambda (y) 
			  (and (set! outp (not outp)) (* y 0.5))))))
		   'map-channel ind1)
	(test-orig (lambda () (map-channel (lambda (n) (* n 2.0)))) (lambda () (map-channel (lambda (n) (* n 0.5)))) 'map-channel ind1)
	(test-orig (lambda () (pad-channel 1000 2000 ind1)) (lambda () (delete-samples 1000 2000 ind1)) 'pad-channel ind1)
	(test-orig (lambda () (clm-channel (make-one-zero :a0 2.0 :a1 0.0)))
		   (lambda () (clm-channel (make-one-zero :a0 0.5 :a1 0.0))) 'clm-channel ind1)
	(test-orig (lambda () (clm-channel (make-one-pole :a0 2.0 :b1 0.0)))
		   (lambda () (clm-channel (make-one-pole :a0 0.5 :b1 0.0))) 'clm-channel ind1)
	(test-orig (lambda () (filter-sound (make-one-zero :a0 2.0 :a1 0.0) 2 ind1 0)) 
		   (lambda () (filter-sound (make-one-zero :a0 0.5 :a1 0.0) 2 ind1 0)) 'filter-sound ind1)
	
	(let ((var (catch #t (lambda () (src-sound '(0 0 1 1))) (lambda args args))))
	  (if (not (eq? (car var) 'out-of-range))
	      (snd-display "src-sound env at 0: ~A" var)))
	(let ((var (catch #t (lambda () (src-sound '(0 1 1 -1))) (lambda args args))))
	  (if (not (eq? (car var) 'out-of-range))
	      (snd-display "src-sound env through 0: ~A" var)))
	
	(scale-to 1.0 ind1)
	(let ((v1 (channel->float-vector 12000 10 ind1 0)))
	  (let ((v0 (make-float-vector 10)))
	    (set! (v0 0) 1.0)
	    (array->file "fmv3.snd" v0 10 22050 1))
	  (copy-file "oboe.snd" "fmv4.snd")
	  (convolve-with "fmv3.snd" 1.0 ind1)
	  (convolve-files "fmv4.snd" "fmv3.snd" 1.0 "fmv5.snd")
	  (let ((v2 (channel->float-vector 12000 10 ind1 0)))
	    (if (not (mus-arrays-equal?1 v1 v2))
		(snd-display "~A (orig: 0) ~A ~A" 'convolve-with v1 v2))
	    (file->array "fmv5.snd" 0 12000 10 v2)
	    (if (not (mus-arrays-equal?1 v1 v2))
		(snd-display "convolve-files: (orig: 0) ~A ~A" v1 v2)))
	  (delete-file "fmv3.snd")
	  (delete-file "fmv5.snd"))
	(convolve-files "2.snd" "oboe.snd" 0.5 "fmv5.snd")
	(if (or (fneq (cadr (mus-sound-maxamp "fmv5.snd")) 0.25)
		(fneq (cadddr (mus-sound-maxamp "fmv5.snd")) 0.5))
	    (snd-display "convolve-files stereo: ~A" (mus-sound-maxamp "fmv5.snd")))
	(delete-file "fmv5.snd")
	(scale-to .25 ind1)
	(set! (y-bounds ind1) ())
	(if (and with-gui (not (equal? (y-bounds ind1) '(-.25 .25))))
	    (snd-display "y-bounds (): ~A?" (y-bounds ind1)))
	(revert-sound ind1)
	
	(scale-to 1.0 ind1)
	(let ((v1 (channel->float-vector 12000 10 ind1 0)))
	  (let ((v0 (make-float-vector 10)))
	    (set! (v0 5) 1.0)
	    (array->file "fmv3.snd" v0 10 22050 1))
	  (convolve-with "fmv3.snd" 1.0 ind1)
	  (convolve-files "fmv4.snd" "fmv3.snd" 1.0 "fmv5.snd")
	  (let ((v2 (channel->float-vector 12005 10 ind1 0)))
	    (if (not (mus-arrays-equal?1 v1 v2))
		(snd-display "~A (orig: 2) ~A ~A" 'convolve-with v1 v2))
	    (file->array "fmv5.snd" 0 12005 10 v2)
	    (if (not (mus-arrays-equal?1 v1 v2))
		(snd-display "convolve-files: (orig: 2) ~A ~A" v1 v2)))
	  (delete-file "fmv3.snd")
	  (delete-file "fmv4.snd")
	  (delete-file "fmv5.snd"))
	
	(revert-sound ind1)
	(let-temporarily ((*selection-creates-region* #f))
	  (let ((old-regions (regions)))
	    (select-all ind1)
	    (if (not (equal? old-regions (regions)))
		(snd-display "selection-create-region: ~A -> ~A?" old-regions (regions)))))
	(convolve-selection-with "pistol.snd" (maxamp))
	(let ((data (channel->float-vector 12000 10 ind1 0)))
	  (convolve-with "pistol.snd" (maxamp ind1 0 0) ind1 0 0)
	  (let ((new-data (channel->float-vector 12000 10 ind1 0)))
	    (if (not (mus-arrays-equal?1 data new-data))
		(snd-display "convolve-selection-with: ~A ~A?" data new-data))))
	(revert-sound ind1)
	(make-selection 1000 2000 ind1)
	(let ((ma (maxamp ind1)))
	  (convolve-selection-with "pistol.snd" ma)
	  (if (fneq (maxamp ind1) ma) (snd-display "convolve-selection-with 1000: ~A ~A?" ma (maxamp ind1))))
	(make-selection 1000 2000 ind1)
	(let ((id (make-region)))
	  (if (not (region? id))
	      (snd-display "make-region argless: ~A" id))
	  (if (not (= (region-framples id 0) (selection-framples)))
	      (snd-display "region/selection-framples: ~A ~A (~A)?" (region-framples id 0) (selection-framples) (region-framples id)))
	  (if (fneq (region-sample id 0) (sample 1000 ind1))
	      (snd-display "region-sample from make-region: ~A ~A?" (region-sample id 0) (sample 1000 ind1))))
	(close-sound ind1))
      (let* ((ind (open-sound "2.snd"))
	     (reg (make-region 0 100 ind #t)))
	(if (not (equal? (region-home reg) '("2.snd" 0 101))) 
	    (snd-display "make + region-home: ~A" (region-home reg)))
	(if (not (= (region-chans reg) 2))
	    (snd-display "make-region chan #t: ~A" (region-chans reg)))
	(close-sound ind))
      
      (let ((ind1 (open-sound "2.snd")))
	(let ((v0 (channel->float-vector 12000 10 ind1 0))
	      (v1 (channel->float-vector 12000 10 ind1 1)))
	  (swap-channels ind1)
	  (let ((v2 (channel->float-vector 12000 10 ind1 0))
		(v3 (channel->float-vector 12000 10 ind1 1)))
	    (if (or (mus-arrays-equal? v0 v2)
		    (mus-arrays-equal? v1 v3))
		(snd-display "swap-channels 0: no change! ~A ~A ~A ~A" v0 v2 v1 v3)))
	  (swap-channels ind1)
	  (let ((v2 (channel->float-vector 12000 10 ind1 0))
		(v3 (channel->float-vector 12000 10 ind1 1)))
	    (if (not (and (mus-arrays-equal? v0 v2)
			  (mus-arrays-equal? v1 v3)))
		(snd-display "swap-channels 1: ~A ~A ~A ~A" v0 v2 v1 v3))))
	;; as long as we're here...
	(set! (sync ind1) 0)
	(set! (cursor ind1 0) 100)
	(set! (cursor ind1 1) 200)
	(if (not (and (= (cursor ind1 0) 100)
		      (= (cursor ind1 1) 200)))
	    (snd-display "cursor: ~A ~A?" (cursor ind1 0) (cursor ind1 1)))
	(set! (sync ind1) 1)
	(scale-by '(.5 .25) ind1)
	(scale-by #r(2.0 4.0) ind1)
	(revert-sound ind1)
	(let ((amps (maxamp ind1 #t)))
	  (swap-channels ind1 0 ind1)
	  (let ((newamps (maxamp ind1 #t)))
	    (if (or (fneq (car amps) (cadr newamps))
		    (fneq (cadr amps) (car newamps)))
		(snd-display "swap-channels with cp def: ~A ~A" amps newamps)))
	  (swap-channels ind1 1)
	  (let ((newamps (maxamp ind1 #t)))
	    (if (or (fneq (car amps) (car newamps))
		    (fneq (cadr amps) (cadr newamps)))
		(snd-display "swap-channels with cp def 0: ~A ~A" amps newamps))))
	(close-sound ind1))
      
      (let ((ind1 (open-sound "oboe.snd"))
	    (ind2 (open-sound "2.snd")))
	(let ((ups1 (count-matches (lambda (n) (> n .1)) 0 ind1 0))
	      (ups2 (let ((count 0)
			  (len (framples ind1))
			  (reader (make-sampler 0 ind1)))
		      (do ((i 0 (+ i 1)))
			  ((= i len) count)
			(if (> (next-sample reader) .1)
			    (set! count (+ count 1)))))))
	  (if (not (= ups1 ups2))
	      (snd-display "scan-chan: ~A ~A?" ups1 ups2))
	  (set! ups1 (count-matches (lambda (n) (> n .03)) 0 ind2 0))
	  (set! ups2 (count-matches (lambda (n) (> n .03)) 0 ind2 1))
	  (let ((ups3 (let ((count 0)
			    (len (framples ind2))
			    (reader (make-sampler 0 ind2 0)))
			(do ((i 0 (+ i 1)))
			    ((= i len) count)
			  (if (> (next-sample reader) .03)
			      (set! count (+ count 1))))))
		(ups4 (let ((count 0)
			    (len (framples ind2))
			    (reader (make-sampler 0 ind2 1)))
			(do ((i 0 (+ i 1)))
			    ((= i len) count)
			  (if (> (next-sample reader) .03)
			      (set! count (+ count 1)))))))
	    (if (not (= ups1 ups3))
		(snd-display "2[0] scan-chan: ~A ~A?" ups1 ups3))
	    (if (not (= ups2 ups4))
		(snd-display "2[1] scan-chan: ~A ~A?" ups2 ups4))))
	(close-sound ind1)
	(close-sound ind2))
      
      (let ((ind1 (open-sound "oboe.snd")))
	(let ((len (framples ind1)))
	  (let ((ctr #f))
	    (map-channel (lambda (n)
			   (and (set! ctr (not ctr))
				(* n 2.0))))
	    (if (> (framples ind1) (+ (/ len 2) 1))
		(snd-display "map-channel cut: ~A ~A?" len (framples ind1)))
	    (revert-sound ind1)
	    (set! ctr 0)
	    (map-channel (lambda (n)
			   (or (> (set! ctr (+ ctr 1)) 3) n)))
	    (if (> ctr 4)
		(snd-display "map-channel no-edit count: ~A?" ctr)))
	  (revert-sound ind1)
	  (let ((v1 (make-float-vector 2)))
	    (map-channel (lambda (n)
			   (set! (v1 0) n)
			   (set! (v1 1) (* n 3))
			   v1)))
	  (if (> (abs (- (framples ind1) (* len 2))) 3)
	      (snd-display "map-channel double: ~A ~A?" len (framples ind1))))
	(revert-sound ind1)
	(let ((otime (maxamp-position ind1)))
	  (set! (sample 1234) .9)
	  (let ((ntime (maxamp-position ind1))
		(nval (maxamp ind1))
		(npos (edit-position ind1 0)))
	    (if (not (= ntime 1234)) (snd-display "maxamp-position 1234: ~A" ntime))
	    (let ((ootime (maxamp-position ind1 0 0)))
	      (if (not (= ootime otime)) (snd-display "maxamp-position edpos 0: ~A ~A" otime ootime)))
	    (let ((nntime (maxamp-position ind1 0 npos)))
	      (if (not (= nntime ntime)) (snd-display "maxamp-position edpos ~D: ~A ~A" npos ntime nntime)))
	    (if (fneq nval .9) (snd-display "maxamp .9: ~A" nval)))
	  (set! (sample 1234) 0.0)
	  (env-channel '(0 0 1 1))
	  (if (not (= (maxamp-position) 35062)) (snd-display "env-channel maxamp-position: ~A" (maxamp-position)))
	  (let ((ootime (maxamp-position ind1 0 0)))
	    (if (not (= ootime otime)) (snd-display "maxamp-position edpos 0(1): ~A ~A" otime ootime)))
	  (let ((nntime (maxamp-position ind1 0 1)))
	    (if (not (= nntime 1234)) (snd-display "maxamp-position edpos 1(1): ~A ~A" 1234 nntime)))
	  (let ((nntime (maxamp-position ind1 0 current-edit-position)))
	    (if (not (= nntime 35062)) (snd-display "maxamp-position edpos current: ~A ~A" 35062 nntime))))
	(revert-sound ind1)
	(make-selection 24000 25000)
	(if (not (= (selection-maxamp-position) 971))
	    (snd-display "selection maxamp position: ~A" (selection-maxamp-position)))
	(let ((regp (region-maxamp-position (make-region 24000 25000))))
	  (if (not (= regp 971))
	      (snd-display "region maxamp position: ~A" regp)))
	(close-sound ind1))
      (let ((ind1 (open-sound "oboe.snd"))
	    (test-edpos (lambda (test-func func-name change-thunk ind1)
			  (let ((fr1 (test-func ind1 0))
				(fr2 (test-func ind1 0 0))
				(fr3 (test-func ind1 0 current-edit-position)))
			    (if (not (= fr1 fr2 fr3))
				(snd-display "initial ~A: ~A ~A ~A?" func-name fr1 fr2 fr3))
			    (change-thunk)
			    (let ((fr5 (test-func ind1 0))
				  (fr6 (test-func ind1 0 1))
				  (fr7 (test-func ind1 0 current-edit-position)))
			      (if (not (= fr5 fr6 fr7))
				  (snd-display "~A (edpos 1): ~A ~A ~A?" func-name fr5 fr6 fr7))))
			  (revert-sound ind1))))
	(test-edpos maxamp 'maxamp (lambda () (scale-by 2.0 ind1 0)) ind1)
	(test-edpos framples 'framples (lambda () (src-sound 2.0 1.0 ind1 0)) ind1)
	(let ((ef (lambda* ((snd 0) (chn 0) (edpos current-edit-position))
		    (count-matches (lambda (n1) (> n1 .1)) 0 snd chn edpos))))
	  (test-edpos ef 'count-matches (lambda () (scale-by 2.0 ind1 0)) ind1))
	(let ((ef (lambda* ((snd 0) (chn 0) (edpos current-edit-position))
		    (scan-channel (lambda (n2) (> n2 .1)) 0 #f snd chn edpos))))
	  (test-edpos ef 'find (lambda () (delete-samples 0 100 ind1 0)) ind1))
	(let ((ef (lambda* ((snd 0) (chn 0) (edpos current-edit-position)) 
		    (let ((p (make-one-pole 1.0 -1.0)))
		      (scan-channel (lambda (n3) 
				      (or (> n3 .1) 
					  (not (one-pole p 1.0))))
				    0 (framples snd chn) snd chn edpos)
		      (floor (one-pole p 0.0))))))
	  (test-edpos ef 'scan-chan (lambda () (delete-samples 0 100 ind1 0)) ind1))
	(src-sound 2.0 1.0 ind1 0)
	(undo 1 ind1 0)
	
	(delete-samples 0 10000 ind1 0)
	(save-sound-as "fmv.snd" ind1 :edit-position 0)
	(save-sound-as "fmv1.snd" ind1 :edit-position 1)
	(let ((var (catch #t (lambda () (save-sound-as "fmv2.snd" ind1 :channel 1234)) (lambda args args))))
	  (if (not (eq? (car var) 'no-such-channel))
	      (snd-display "save-sound-as bad chan: ~A" var)))
	(if (not (= (mus-sound-framples "fmv.snd") (framples ind1 0 0)))
	    (snd-display "save-sound-as (edpos): ~A ~A?" (mus-sound-framples "fmv.snd") (framples ind1 0 0)))
	(if (not (= (mus-sound-framples "fmv1.snd") (framples ind1 0 1)))
	    (snd-display "save-sound-as (edpos 1): ~A ~A?" (mus-sound-framples "fmv.snd") (framples ind1 0 1)))
	(if (= (mus-sound-framples "fmv.snd") (framples ind1 0 1))
	    (snd-display "save-sound-as (edpos 1)(2): ~A ~A?" (mus-sound-framples "fmv.snd") (framples ind1 0 1)))
	(let ((ind2 (open-sound "fmv.snd"))
	      (ind3 (open-sound "fmv1.snd")))
	  (if (not (mus-arrays-equal? (channel->float-vector 12000 10 ind1 0 0) (channel->float-vector 12000 10 ind2 0)))
	      (snd-display "save-sound-as (edpos 3): ~A ~A?" (channel->float-vector 12000 10 ind1 0 0) (channel->float-vector 12000 10 ind2 0)))
	  (if (not (mus-arrays-equal? (channel->float-vector 12000 10 ind1 0 1) (channel->float-vector 12000 10 ind3 0)))
	      (snd-display "save-sound-as (edpos 4): ~A ~A?" (channel->float-vector 12000 10 ind1 0 1) (channel->float-vector 12000 10 ind3 0)))
	  (if (mus-arrays-equal? (channel->float-vector 12000 10 ind2 0) (channel->float-vector 12000 10 ind3 0))
	      (snd-display "save-sound-as (edpos 5): ~A ~A?" (channel->float-vector 12000 10 ind2 0) (channel->float-vector 12000 10 ind3 0)))
	  (select-sound ind3)
	  (set! (comment) "hiho")
	  (if (not (string=? (comment) "hiho")) (snd-display "set! comment no index: ~A" (comment)))
	  (close-sound ind2)
	  (close-sound ind3))
	(delete-file "fmv.snd")
	(delete-file "fmv1.snd")
	
  	(let ((test-edpos-1
	       (lambda (test-func func-name ind1)
		 (let ((v0 (channel->float-vector 12000 10 ind1 0)))
		   (test-func ind1 0)
		   (let ((v1 (channel->float-vector 12000 10 ind1 0)))
		     (if (mus-arrays-equal? v0 v1)
			 (snd-display "~A (0) no change! ~A ~A" func-name v0 v1))
		     (test-func ind1 0)
		     (let ((v2 (channel->float-vector 12000 10 ind1 0)))
		       (if (not (mus-arrays-equal? v1 v2))
			   (snd-display "~A (1) ~A ~A" func-name v1 v2)))))
		 (revert-sound ind1))))
	  (test-edpos-1 (lambda (snd pos) (reverse-sound snd 0 pos)) 'reverse-sound ind1)
	  (test-edpos-1 (lambda (snd pos) (env-sound '(0 0 1 1 2 0) 0 20000 1.0 snd 0 pos)) 'env-sound ind1)
	  (test-edpos-1 (lambda (snd pos) (src-sound 0.5 1.0 snd 0 pos)) 'src-sound ind1)
	  (test-edpos-1 (lambda (snd pos) (filter-sound (make-fir-filter 6 #r(.1 .2 .3 .3 .2 .1)) 6 snd 0 pos)) 'filter-sound ind1)
	  (test-edpos-1 (lambda (snd pos) (convolve-with "pistol.snd" .5 snd 0 pos)) 'convolve-with ind1))
	
	(let ((ind (new-sound "fmv.snd")))
	  (let ((v (make-float-vector 2000))
		(e (make-env (list 0.0 0.0 1.0 (* 2000 0.2 pi)) :length 2001)))
	    (fill-float-vector v (sin (env e)))
	    (float-vector->channel v 0 2000 ind 0))
	  (filter-sound '(0 0 .09 0 .1 1 .11 0 1 0) 1024)
	  (if (> (maxamp) .025) (snd-display "filter-sound maxamp 1: ~A" (maxamp)))
	  (undo)
	  (filter-sound '(0 0 .19 0 .2 1 .21 0 1 0) 1024)  
	  (if (< (maxamp) .9) (snd-display "filter-sound maxamp 2: ~A" (maxamp)))
	  (undo)
	  (filter-sound '(0 0 .29 0 .3 1 .31 0 1 0) 1024)  
	  (if (> (maxamp) .02) (snd-display "filter-sound maxamp 3: ~A" (maxamp)))
	  
	  (set! *show-sonogram-cursor* #t) 
	  (set! *with-tracking-cursor* #t) 
	  (if (not *with-tracking-cursor*) (snd-display "with-tracking-cursor set to #t: ~A" *with-tracking-cursor*))
	  
	  (set! *transform-graph-type* graph-as-sonogram) 
	  (play :wait #t)
	  (set! (transform-graph?) #t) 
	  
	  (close-sound ind))
	(close-sound ind1))
      
      (let ((ind (open-sound "1a.snd"))) ; from Anders Vinjar
	(set! (with-tracking-cursor) :track-and-return) 
	(set! (cursor) 2000) 
	(let ((here (cursor))) 
	  (play :start (cursor)) 
	  (if (not (= here 2000 (cursor)))
	      (snd-display "with-tracking-cursor set to :track-and-return: start: ~A, end: ~A" here (cursor))))
	
	(set! (zoom-focus-style) zoom-focus-middle) 
	(when with-motif
	  (set! (x-zoom-slider) .5)
	  (if (fneq (x-position-slider) 0.25) (snd-display "zoom focus middle .5: ~A" (x-position-slider)))
	  (set! (x-zoom-slider) .1)
	  (if (fneq (x-position-slider) 0.45) (snd-display "zoom focus middle .1: ~A" (x-position-slider)))
	  (set! (x-zoom-slider) .9)
	  (if (fneq (x-position-slider) 0.05) (snd-display "zoom focus middle .9: ~A" (x-position-slider)))
	  (set! (zoom-focus-style) zoom-focus-left) 
	  (set! (x-zoom-slider) .1)
	  (if (fneq (x-position-slider) 0.05) (snd-display "zoom focus left .1: ~A" (x-position-slider))))
	
	(close-sound ind))
      
      (let ((ind (open-sound "oboe.snd"))
	    (peak-env-equal? 
	     (lambda (name index e diff)
	       (let ((reader (make-sampler 0 index 0))
		     (e-size (length (car e))))
		 (let ((samps-per-bin (ceiling (/ (framples index) e-size)))
		       (mins (car e))
		       (maxs (cadr e))
		       (happy #t)
		       (data #f))
		   (set! data (make-float-vector samps-per-bin))
		   (do ((e-bin 0 (+ e-bin 1)))
		       ((or (not happy) 
			    (= e-bin e-size))
			happy)
		     (do ((k 0 (+ k 1)))
			 ((= k samps-per-bin))
		       (float-vector-set! data k (next-sample reader)))
		     
		     (let ((mx (float-vector-max data))
			   (mn (float-vector-min data)))
		       (let ((mxdiff (abs (- mx (maxs e-bin))))
			     (mndiff (abs (- mn (mins e-bin)))))
			 (when (or (> mxdiff diff)
				   (> mndiff diff))
			   (snd-display "~A: peak-env-equal? [bin ~D of ~D]: (~,4F to ~,4F), diff: ~,5F" 
					name
					e-bin e-size
					mn mx
					(max mxdiff mndiff))
			   (set! happy #f))))))))))
	
	(let ((mx (maxamp ind 0))
	      (e0 (channel-amp-envs ind 0)))
	  (if (null? e0)
	      (snd-display "no amp env data")
	      (let ((mx1 (float-vector-peak (car e0)))
		    (mx2 (float-vector-peak (cadr e0))))
		(if (fneq mx (max mx1 mx2))
		    (snd-display "amp env max: ~A ~A ~A" mx mx1 mx2))
		(peak-env-equal? "straight peak" ind e0 .0001)
		(scale-by 3.0)
		(let ((e1 (channel-amp-envs ind 0 1)))
		  (let ((mx3 (float-vector-peak (car e1)))
			(mx4 (float-vector-peak (cadr e1))))
		    (if (or (fneq (* 3.0 mx1) mx3)
			    (fneq (* 3.0 mx2) mx4))
			(snd-display "3.0 amp env max: ~A ~A ~A ~A" mx1 mx2 mx3 mx4)))
		  (peak-env-equal? "scaled peak" ind e1 .0001))
		(if (fneq (maxamp ind 0) (* 3 mx)) 
		    (snd-display "maxamp after scale: ~A ~A" mx (maxamp ind 0)))
		(undo)
		(set! (selection-member? #t) #f)
		(set! (selection-member? ind 0) #t)
		(set! (selection-position ind 0) 20000)
		(set! (selection-framples ind 0) 12000)
		(scale-selection-by 3.0)
		(let ((e1 (channel-amp-envs ind 0 1)))
		  (let ((mx3 (float-vector-peak (car e1)))
			(mx4 (float-vector-peak (cadr e1))))
		    (if (or (fneq (* 3.0 mx1) mx3)
			    (fneq (* 3.0 mx2) mx4))
			(snd-display "selection 3.0 amp env max: ~A ~A ~A ~A" mx1 mx2 mx3 mx4))
		    (if (fneq (maxamp ind 0) (* 3 mx)) 
			(snd-display "maxamp after selection scale: ~A ~A" mx (maxamp ind 0))))
		  (peak-env-equal? "selection peak" ind e1 .0001))
		(map-channel abs)
		(let ((e1 (channel-amp-envs ind 0 2)))
		  (let ((mx3 (float-vector-peak (car e1)))
			(mx4 (float-vector-peak (cadr e1))))
		    (if (fneq (* 3.0 mx2) mx4)
			(snd-display "abs selection 3.0 amp env max: ~A ~A ~A ~A" mx1 mx2 mx3 mx4))
		    (if (fneq (maxamp ind 0) (* 3 mx)) 
			(snd-display "maxamp after abs selection scale: ~A ~A" mx (maxamp ind 0)))
		    (if (ffneq mx3 0.03)
			(snd-display "abs max: ~A ~A" mx3 mx4)))
		  (peak-env-equal? "map-channel peak" ind e1 .0001))
		(delete-samples 10000 5000)
		(let ((e1 (channel-amp-envs ind 0)))
		  (let ((mx3 (float-vector-peak (car e1)))
			(mx4 (float-vector-peak (cadr e1))))
		    (if (fneq (* 3.0 mx2) mx4)
			(snd-display "abs selection 3.0 amp env max: ~A ~A ~A ~A" mx1 mx2 mx3 mx4))
		    (if (fneq (maxamp ind 0) (* 3 mx)) 
			(snd-display "maxamp after abs selection scale: ~A ~A" mx (maxamp ind 0)))
		    (if (ffneq mx3 0.03)
			(snd-display "abs max: ~A ~A" mx3 mx4)))
		  (peak-env-equal? "delete peak" ind e1 .0001))
		(scale-selection-by -.333)
		(let ((e1 (channel-amp-envs ind 0 4)))
		  (let ((mx3 (float-vector-peak (car e1))))
		    (if (fneq (maxamp ind 0) mx)
			(snd-display "maxamp after minus abs selection scale: ~A ~A" mx (maxamp ind 0)))
		    (if (fneq (maxamp ind 0) mx3)
			(snd-display "mx3 maxamp after minus abs selection scale: ~A ~A" mx mx3)))
		  (peak-env-equal? "scale-selection peak" ind e1 .0001)))))
	
	(revert-sound ind)
	(ramp-channel 0.0 1.0)
	(peak-env-equal? "ramp-channel peak" ind (channel-amp-envs ind 0 1) .001)
	(undo)
	(env-channel '(0 0 1 1 2 0))
	(peak-env-equal? "env-channel peak" ind (channel-amp-envs ind 0 1) .002)
	(undo)
	(env-channel (make-env '(0 0 1 1 2 0) :scaler 0.5 :length (framples)))
	(peak-env-equal? "scaled env-channel peak" ind (channel-amp-envs ind 0 1) .002)
	(undo)
	(env-channel (make-env '(0 0 1 1 2 0) 0.5 :length (framples)))
	(peak-env-equal? "scaled nokey env-channel peak" ind (channel-amp-envs ind 0 1) .001)
	(undo)
	(env-channel (make-env '(0 0 1 1 2 0) :scaler 0.5 :offset 0.5 :length (framples)))
	(peak-env-equal? "scaled and offset env-channel peak" ind (channel-amp-envs ind 0 1) .001)
	(undo)
	(env-channel (make-env '(0 0 1 1 2 .5 3 0) :base 0.0 :length (framples)))
	(peak-env-equal? "env-channel base 0.0 peak" ind (channel-amp-envs ind 0 1) .001)
	(undo)
	(xramp-channel 0.0 1.0 32.0)
	(peak-env-equal? "xramp 32.0 peak" ind (channel-amp-envs ind 0 1) .008)
	(undo)
	(xramp-channel 0.0 1.0 .032)
	(peak-env-equal? "xramp .032 peak" ind (channel-amp-envs ind 0 1) .004)
	(undo)
	(env-channel (make-env '(0 0 1 1 2 .5 3 0) :base 10.0 :length (framples)))
	(peak-env-equal? "env-channel base 10.0 peak" ind (channel-amp-envs ind 0 1) .003)
	(undo)
	(env-channel (make-env '(0 0 1 1 2 0) :base .10 :length (framples)))
	(peak-env-equal? "env-channel base .1 peak" ind (channel-amp-envs ind 0 1) .003)
	(undo)
	(revert-sound ind)
	(ramp-channel 0.0 1.0)
	(ramp-channel 1.0 0.0)
	(peak-env-equal? "ramp2 peak" ind (channel-amp-envs ind 0 2) .002)
	
	(revert-sound ind)
	(env-channel '(0 0 1 1))
	(env-channel '(0 0 1 1 2 0))
	(peak-env-equal? "env ramp2 peak" ind (channel-amp-envs ind 0 2) .002)
	
	(revert-sound ind)
	(ramp-channel 0.0 1.0 12000 5000)
	(peak-env-equal? "ramp-channel peak" ind (channel-amp-envs ind 0 1) .002)
	(undo)
	(env-channel '(0 0 1 1 2 0) 12000 5000)
	(peak-env-equal? "env-channel peak" ind (channel-amp-envs ind 0 1) .003)
	(undo)
	(env-channel (make-env '(0 0 1 1 2 0) :scaler 0.5 :length 5000) 12000 5000)
	(peak-env-equal? "scaled env-channel peak" ind (channel-amp-envs ind 0 1) .004)
	(undo)
	(env-channel (make-env '(0 0 1 1 2 0) 0.5 :length 5000) 12000 5000)
	(peak-env-equal? "scaled nokey env-channel peak" ind (channel-amp-envs ind 0 1) .004)
	(undo)
	(env-channel (make-env '(0 0 1 1 2 0) :scaler 0.5 :offset 0.5 :length 5000) 12000 5000)
	(peak-env-equal? "scaled and offset env-channel peak" ind (channel-amp-envs ind 0 1) .002)
	(undo)
	(xramp-channel 0.0 1.0 32.0 2000 1000)
	(peak-env-equal? "xramp 32.0 peak (1)" ind (channel-amp-envs ind 0 1) .009)
	(undo)
	(xramp-channel 0.0 1.0 .032 2000 1000)
	(peak-env-equal? "xramp .032 peak (1)" ind (channel-amp-envs ind 0 1) .009)
	(undo)
	(env-channel (make-env '(0 0 1 1 2 .5 3 0) :base 10.0 :length 5000) 12000 5000)
	(peak-env-equal? "env-channel base 10.0 peak" ind (channel-amp-envs ind 0 1) .1)
	;; this can be way off because the envelope is not very closely sampled in this case
	(revert-sound ind)
	(ramp-channel 0.0 1.0)
	(ramp-channel 1.0 0.0 2000 1000)
	(peak-env-equal? "ramp2 peak" ind (channel-amp-envs ind 0 2) .002)
	
	(revert-sound ind)
	(env-channel '(0 0 1 1))
	(env-channel '(0 0 1 1 2 0) 2000 1000)
	(peak-env-equal? "env ramp2 peak" ind (channel-amp-envs ind 0 2) .002)
	
	(revert-sound ind)
	(env-channel '(0 0 1 1))
	(env-channel '(0 0 1 1 2 0))
	(env-channel '(0 0 1 1) 12000 5000)
	(peak-env-equal? "env ramp3 peak" ind (channel-amp-envs ind 0 3) .01)
	
	(revert-sound ind)
	(close-sound ind))
      
      (let ((ind (new-sound "test.snd")))
	(map-channel (lambda (y) 1.0) 0 50001)
	(ramp-channel 0.5 1.0 1000 4000)
	(let ((peaks (channel-amp-envs ind 0)))
	  (let ((mx (cadr peaks))
		(mn (car peaks)))
	    (call-with-exit
	     (lambda (break)
	       (do ((ln (- (length mn) 4))
		    (i 0 (+ i 1)))
		   ((= i ln))
		 (when (< (mn i) 0.5) (snd-display "peak min: ~A ~A" (mn i) i) (break #f))
		 (when (< (mx i) 0.5) (snd-display "peak max: ~A ~A" (mx i) i) (break #f)))))))
	(undo 2)
	(map-channel (lambda (y) -1.0) 0 50001)
	(ramp-channel 0.5 1.0 1000 4000)
	(let ((peaks (channel-amp-envs ind 0)))
	  (let ((mx (cadr peaks))
		(mn (car peaks))
		(happy #t))
	    (do ((ln (- (length mn) 4))
		 (i 0 (+ i 1)))
		((or (not happy) 
		     (= i ln)))
	      (when (> (mn i) -0.5) (snd-display "1 peak min: ~A ~A" (mn i) i) (set! happy #f))
	      (when (> (mx i) -0.5) (snd-display "1 peak max: ~A ~A" (mx i) i) (set! happy #f)))))
	(close-sound ind))
      
      (let ((index (new-sound "fmv.snd" 2 22050 mus-ldouble mus-next "channel tests")))
	(define (test-channel-func func val-func init-val)
	  (do ((len (framples index))
	       (chns (chans index))
	       (val #f)
	       (g-init-val init-val)
	       (k 0 (+ k 1)))
	      ((= k 2))
	    (set! val (val-func len))
	    (set! (sync index) k)
	    (do ((i 0 (+ i 1)))
		((= i chns))
	      (map-channel (lambda (n) 0.0) 0 len index i)
	      (if (scan-channel (lambda (n) (> (abs n) .001)) 0 len index i)
		  (snd-display "init scan: ~A?" (scan-channel (lambda (n) (> (abs n) 0.001))))))
	    ;; now it's cleared
	    (do ((i 0 (+ i 1)))
		((= i chns))
	      (map-channel (lambda (n) g-init-val) 0 len index i)
	      (func 0 len index i)
	      (do ((j 0 (+ j 1)))
		  ((= j chns))
		(let ((vi (channel->float-vector 0 len index j)))
		  (if (= j i)
		      (if (not (mus-arrays-equal? vi val))
			  (snd-display "chan func: ~A ~A" vi val))
		      (if (scan-channel (lambda (n) (> (abs n) .001)) 0 len index j)
			  (snd-display "chan func leaks? ~A ~A: ~A" i j (scan-channel (lambda (n) (> (abs n) 0.001)) 0 len index j))))))
	      (map-channel (lambda (n) 0.0) 0 len index i))
	    (do ((i 0 (+ i 1)))
		((= i chns))
	      (map-channel (lambda (n) g-init-val) 0 len index i)
	      (let ((ed (edit-position index i)))
		(map-channel (lambda (n) (+ g-init-val 1.0)) 0 len index i)
		(func 0 len index i ed)
		(do ((j 0 (+ j 1)))
		    ((= j chns))
		  (let ((vi (channel->float-vector 0 len index j)))
		    (if (= j i)
			(if (not (mus-arrays-equal? vi val))
			    (snd-display "ed chan func: ~A ~A" vi val))
			(if (scan-channel (lambda (n) (> (abs n) 0.001)) 0 len index j)
			    (snd-display "ed chan func leaks? ~A ~A ~A: ~A" i j ed (scan-channel (lambda (n) (> (abs n) 0.001)) 0 len index j))))))
		(map-channel (lambda (n) 0.0) 0 len index i)))
	    (let* ((beg (floor (/ len 3)))
		   (dur beg)
		   (nv (val-func dur)))
	      (fill! val 0.0)
	      (do ((i beg (+ i 1))
		   (j 0 (+ j 1)))
		  ((= j dur))
		(set! (val i) (nv j)))
	      (do ((i 0 (+ i 1)))
		  ((= i chns))
		(map-channel (lambda (n) g-init-val) beg dur index i)
		(func beg dur index i)
		(add-mark beg index i)
		(do ((j 0 (+ j 1)))
		    ((= j chns))
		  (let ((vi (channel->float-vector 0 len index j)))
		    (if (= j i)
			(if (not (mus-arrays-equal? vi val))
			    (snd-display "chan func n: ~A ~A" vi val))
			(if (scan-channel (lambda (n) (> (abs n) 0.001)) 0 len index j)
			    (snd-display "dur chan func leaks? ~A ~A: ~A" i j (scan-channel (lambda (n) (> (abs n) 0.001)) 0 len index j))))))
		(map-channel (lambda (n) 0.0) 0 len index i)))))
	
	(insert-silence 0 10 index 0)
	(insert-silence 0 10 index 1)
	
	(test-channel-func (lambda* (beg dur index chan edpos)
			     (clm-channel (make-env :envelope '(0 0 1 1) :length dur) beg dur index chan edpos))
			   (lambda (dur)
			     (do ((e (make-env :envelope '(0 0 1 1) :length dur))
				  (v (make-float-vector dur))
				  (i 0 (+ i 1)))
				 ((= i dur) v)
			       (set! (v i) (env e))))
			   0.0)
	
	(test-channel-func (lambda* (beg dur index chan edpos)
			     (clm-channel (make-oscil :frequency 0.0 :initial-phase (/ pi 2)) beg dur index chan edpos))
			   (lambda (dur)
			     (make-float-vector dur 1.0))
			   0.0)
	
	(test-channel-func (lambda* (beg dur index chan edpos)
			     (scale-channel 0.5 beg dur index chan edpos))
			   (lambda (dur)
			     (make-float-vector dur .5))
			   1.0)
	
	(test-channel-func (lambda* (beg dur index chan edpos)
			     (env-channel (make-env :envelope '(0 0 1 1) :length dur) beg dur index chan edpos))
			   (lambda (dur)
			     (do ((e (make-env :envelope '(0 0 1 1) :length dur))
				  (v (make-float-vector dur))
				  (i 0 (+ i 1)))
				 ((= i dur) v)
			       (set! (v i) (env e))))
			   1.0)
	
	(test-channel-func (lambda* (beg dur index chan edpos)
			     (env-channel '(0 0 1 1) beg dur index chan edpos))
			   (lambda (dur)
			     (do ((e (make-env :envelope '(0 0 1 1) :length dur))
				  (v (make-float-vector dur))
				  (i 0 (+ i 1)))
				 ((= i dur) v)
			       (set! (v i) (env e))))
			   1.0)
	
	(test-channel-func (lambda* (beg dur index chan edpos)
			     (float-vector->channel (make-float-vector dur -1.0) beg dur index chan))
			   (lambda (dur)
			     (make-float-vector dur -1.0))
			   1.0)
	
	(test-channel-func (lambda* (beg dur index chan edpos)
			     (delete-samples beg dur index chan edpos)
			     (pad-channel beg dur index chan edpos))
			   make-float-vector
			   1.0)
	
	(test-channel-func (lambda* (beg dur index chan edpos)
			     (delete-samples beg dur index chan edpos)
			     (insert-samples beg dur (make-float-vector dur -1.0) index chan edpos))
			   (lambda (dur)
			     (make-float-vector dur -1.0))
			   1.0)
	
	(test-channel-func (lambda* (beg dur index chan edpos)
			     (set! (samples beg dur index chan #f "test-channel" 0 edpos) (make-float-vector dur -1.0)))
			   (lambda (dur)
			     (make-float-vector dur -1.0))
			   1.0)
	
	(test-channel-func (lambda* (beg dur index chan edpos)
			     (env-channel (make-env :envelope '(0 0 1 1) :length dur) beg dur index chan edpos)
			     (reverse-channel beg dur index chan))
			   (lambda (dur)
			     (do ((e (make-env :envelope '(0 1 1 0) :length dur))
				  (v (make-float-vector dur))
				  (i 0 (+ i 1)))
				 ((= i dur) v)
			       (set! (v i) (env e))))
			   1.0)
	
	(test-channel-func (lambda* (beg dur index chan edpos)
			     (env-channel (make-env :envelope '(0 0 1 1) :length dur) beg dur index chan edpos)
			     (set! (sample (+ beg dur) index chan) 1.0)
			     (smooth-channel beg dur index chan)
			     (if (not (= beg 0))
				 (set! (sample (+ beg dur) index chan) 0.0)))
			   (lambda (dur)
			     (do ((v (make-float-vector dur))
				  (ipi (/ pi dur))
				  (i 0 (+ i 1)))
				 ((= i dur) v)
			       (set! (v i) (+ 0.5 (* 0.5 (cos (+ pi (* ipi i))))))))
			   1.0)
	
	(let ((old-max (maxamp index #t))
	      (regdata (map (lambda (n)
			      (catch #t
				(lambda ()
				  (region->float-vector n 0 10))
				(lambda args (float-vector))))
			    (regions)))
	      ;; (old-pos0 (edit-position index 0))
	      ;; (old-pos1 (edit-position index 1))
	      (old-reglen (map region-framples (regions))))
	  (hook-push save-state-hook
		     (lambda (hook)
		       (if (not (string? (hook 'name))) (format *stderr* "save-state-hook name: ~S~%" (hook 'name)))))
	  (if (file-exists? "s61.scm") (delete-file "s61.scm"))
	  (save-state "s61.scm")
	  (close-sound index)
	  (for-each forget-region (regions))
	  (load (string-append cwd "s61.scm"))
	  (if (not (equal? old-reglen (map region-framples (regions))))
	      (snd-display "region-framples after save: ~A ~A" old-reglen (map region-framples (regions))))
	  (catch #t
	    (lambda ()
	      (for-each (lambda (n data)
			  (if (not (mus-arrays-equal? data (region->float-vector n 0 10)))
			      (snd-display "region after save ~A: ~A ~A" n data (region->float-vector n 0 10))))
			(regions)
			regdata))
	    (lambda args (snd-display "region->float-vector: ~A" args)))
	  (set! index (find-sound "fmv.snd"))
	  (if (not (equal? (maxamp index #t) old-max))
	      (snd-display "maxes: ~A ~A" (maxamp index #t) old-max))
	  (if (not (member (edits index) '((275 0) (276 0))))
	      (snd-display "saved channel edits: ~A" (edits index)))
	  
	  (do ((i 0 (+ i 1)))
	      ((= i 10))
	    (let ((pos (random (car (edits index)))))
	      (scale-channel (random 2.0) (random 5) (random 5) index 0 pos)
	      (set! (edit-position index) (floor (* (car (edits index)) .7)))))
	  
	  (close-sound index)
	  (for-each forget-region (regions))
	  (delete-file "s61.scm")
	  (set! (hook-functions save-state-hook) ())))
      
      (let ((index (new-sound "fmv.snd" 2 22050 mus-ldouble mus-next "channel tests"))
	    (v (make-float-vector 10)))
	(let-temporarily ((*sinc-width* 10))
	  (set! (v 0) 1.0)
	  (float-vector->channel v 0 10 index 0)
	  (src-channel 0.5 0 10 index 0)
	  (let ((v (make-float-vector 10))
		(s (make-src :srate 0.5
			     :input (let ((val 1.0))
				      (lambda (dir)
					(let ((rtn val))
					  (set! val 0.0)
					  rtn))))))
	    (set! (v 0) (src s))
	    (do ((i 1 (+ i 1)))
		((= i 10))
	      (set! (v i) (src s)))
	    (if (not (mus-arrays-equal? v (channel->float-vector 0 10 index 0)))
		(snd-display "src-channel: ~A ~A" v (channel->float-vector 0 10 index 0)))
	    (if (not (mus-arrays-equal? (make-float-vector 10) (channel->float-vector 0 10 index 1)))
		(snd-display "src-channel leaks: ~A" (channel->float-vector 0 10 index 1))))
	  (let ((tag (catch #t (lambda () (src-channel 120000.0)) (lambda args args))))
	    (if (not (eq? (car tag) 'mus-error)) (snd-display "src-channel crazy srate: ~A" tag)))
	  (let ((tag (catch #t (lambda () (filter-sound (make-snd->sample))) (lambda args args))))
	    (if (not (eq? (car tag) 'mus-error)) (snd-display "filter-sound + un-run gen: ~A" tag)))
	  (revert-sound index)
	  (float-vector->channel v 0 10 index 1)
	  (float-vector->channel v 10 10 index 1)
	  (src-channel (make-env :envelope '(1 1 2 2) :length 21) 0 20 index 1)
	  (if (not (mus-arrays-equal? (channel->float-vector 0 10 index 1) #r(1.000 -0.000 -0.048 0.068 -0.059 0.022 0.030 -0.100 0.273 0.606)))
	      (snd-display "src-channel env: ~A" (channel->float-vector 0 10 index 1)))
	  (if (not (mus-arrays-equal? (make-float-vector 10) (channel->float-vector 0 10 index 0)))
	      (snd-display "src-channel env leaks: ~A" (channel->float-vector 0 10 index 0)))
	  (revert-sound index)
	  (float-vector->channel v 0 10 index 1)
	  (float-vector->channel v 10 10 index 1)
	  (src-channel '(1 1 2 2) 0 20 index 1) ; end is off above -- should be 19 I think
	  (if (not (mus-arrays-equal? (channel->float-vector 0 10 index 1) #r(1.000 -0.000 -0.051 0.069 -0.056 0.015 0.042 -0.117 0.320 0.568)))
	      (snd-display "src-channel lst: ~A" (channel->float-vector 0 10 index 1)))
	  (if (not (mus-arrays-equal? (make-float-vector 10) (channel->float-vector 0 10 index 0)))
	      (snd-display "src-channel lst leaks: ~A" (channel->float-vector 0 10 index 0)))
	  (close-sound index)))
      
      (let ((ind (new-sound :size 100)))
	(for-each
	 (lambda (sr)
	   (revert-sound ind)
	   (set! (sample 50) .5)
	   (set! (sample 51) -.5)
	   (src-channel sr)
	   (let ((v1 (channel->float-vector)))
	     (revert-sound ind)
	     (set! (sample 50) .5)
	     (set! (sample 51) -.5)
	     (src-channel (+ sr .00001))
	     (let ((v2 (channel->float-vector)))
	       (float-vector-abs! (float-vector-subtract! v1 v2))
	       (do ((sum 0.0)
		    (len (min (length v1) (length v2)))
		    (mx (float-vector-peak v1))
		    (i 0 (+ i 1)))
		   ((= i len)
		    (if (or (> sum .01) ; depends on sinc-width I think
			    (> mx .002))
			(snd-display "src-channel ~A: diff: ~A ~A~%" sr sum mx)))
		 (set! sum (+ sum (float-vector-ref v1 i)))))))
	 '(0.5 0.75 1.0 1.5 2.0))
	(close-sound ind))
      
      (set! *max-regions* (max *max-regions* 8))
      (let ((region2float-vector 
	     (lambda (r c len)
	       (region->float-vector r 0 len c)))
	    (region-to-float-vector 
	     (lambda (r c len)
	       (let ((rs (make-region-sampler r 0 c))
		     (v (make-float-vector len)))
		 (outa->fv v (next-sample rs))))))
	(let* ((ind (open-sound "oboe.snd"))
	       (rid0 (make-region 2000 2020 ind 0))
	       (rid0-data (region2float-vector rid0 0 20)))
	  (scale-sound-by 2.0)
	  (play rid0 :wait #t)
	  (let ((nv (region2float-vector rid0 0 20)))
	    (if (not (mus-arrays-equal? rid0-data nv)) (snd-display "deferred region after scaling:~%  ~A~%  ~A" rid0-data nv)))
	  (let ((nv (region-to-float-vector rid0 0 20)))
	    (if (not (mus-arrays-equal? rid0-data nv)) (snd-display "deferred region after scaling (rs):~%  ~A~%  ~A" rid0-data nv)))
	  (undo)
	  (scale-by 4.0)
	  (play rid0 :wait #t)
	  (let ((nv (region2float-vector rid0 0 20)))
	    (if (not (mus-arrays-equal? rid0-data nv)) (snd-display "file region after scaling:~%  ~A~%  ~A" rid0-data nv)))
	  (let ((nv (region-to-float-vector rid0 0 20)))
	    (if (not (mus-arrays-equal? rid0-data nv)) (snd-display "file region after scaling (rs):~%  ~A~%  ~A" rid0-data nv)))
	  (let* ((rid1 (make-region 2000 2020 ind 0))
		 (rid1-data (region2float-vector rid1 0 20)))
	    (scale-to .5)
	    (let ((nv (region2float-vector rid1 0 20)))
	      (if (not (mus-arrays-equal? rid1-data nv)) (snd-display "deferred region after scale-to:~%  ~A~%  ~A" rid1-data nv)))
	    (close-sound ind)
	    (play rid0 :wait #t)
	    (play rid1 :wait #t)
	    (let ((nv (region2float-vector rid1 0 20)))
	      (if (not (mus-arrays-equal? rid1-data nv)) (snd-display "deferred region after close:~%  ~A~%  ~A" rid1-data nv)))
	    (let ((nv (region2float-vector rid0 0 20)))
	      (if (not (mus-arrays-equal? rid0-data nv)) (snd-display "file region after close:~%  ~A~%  ~A" rid0-data nv))))
	  
	  (for-each
	   (lambda (s1 L1 s2 L2)
	     (set! ind (open-sound "2.snd"))
	     (set! (selection-member? #t) #f)
	     (set! (selection-member? ind 0) #t)
	     (set! (selection-position ind 0) s1)
	     (set! (selection-framples ind 0) L1)
	     (set! (selection-member? ind 1) #t)
	     (set! (selection-position ind 1) s2)
	     (set! (selection-framples ind 1) L2)
	     (let* ((rid2 (make-region))
		    (rid20-data (region2float-vector rid2 0 L1))
		    (rid21-data (region2float-vector rid2 1 L2)))
	       (if (not (= (region-chans rid2) 2)) (snd-display "region-chans of sync'd sound: ~A?" (region-chans rid2)))
	       (swap-channels ind 0 ind 1)
	       (let ((nv (region2float-vector rid2 0 L1)))
		 (if (not (mus-arrays-equal? rid20-data nv)) (snd-display "deferred region after scaling (20):~%  ~A~%  ~A" rid20-data nv)))
	       (let ((nv (region-to-float-vector rid2 0 L1)))
		 (if (not (mus-arrays-equal? rid20-data nv)) (snd-display "deferred region after scaling (20 rs):~%  ~A~%  ~A" rid20-data nv)))
	       (let ((nv (region2float-vector rid2 1 L2)))
		 (if (not (mus-arrays-equal? rid21-data nv)) (snd-display "deferred region after scaling (21):~%  ~A~%  ~A" rid21-data nv)))
	       (let ((nv (region-to-float-vector rid2 1 L2)))
		 (if (not (mus-arrays-equal? rid21-data nv)) (snd-display "deferred region after scaling (21 rs):~%  ~A~%  ~A" rid21-data nv)))
	       (close-sound ind)
	       (let ((nv (region2float-vector rid2 0 L1)))
		 (if (not (mus-arrays-equal? rid20-data nv)) (snd-display "deferred region after scaling (20):~%  ~A~%  ~A" rid20-data nv)))
	       (let ((nv (region-to-float-vector rid2 0 L1)))
		 (if (not (mus-arrays-equal? rid20-data nv)) (snd-display "deferred region after scaling (20 rs):~%  ~A~%  ~A" rid20-data nv)))
	       (let ((nv (region2float-vector rid2 1 L2)))
		 (if (not (mus-arrays-equal? rid21-data nv)) (snd-display "deferred region after scaling (21):~%  ~A~%  ~A" rid21-data nv)))
	       (let ((nv (region-to-float-vector rid2 1 L2)))
		 (if (not (mus-arrays-equal? rid21-data nv)) (snd-display "deferred region after scaling (21 rs):~%  ~A~%  ~A" rid21-data nv)))
	       ))
	   '(2000 2000 2000 0 2000 0 2000)
	   '(20 10 20 20 20 10 20)
	   '(2000 2000 2000 2000 0 2000 0)
	   '(20 20 10 20 20 20 10))))
      
      (let ((ind (open-sound "obtest.snd")))
	(set! (read-only ind) #t)
	(delete-samples 0 1000 ind 0)
	(let ((val (catch #t
		     (lambda ()
		       (save-sound ind))
		     (lambda args args))))
	  (if (sound? val) (snd-display "save-sound read-only: ~A" val))
	  ;(if (not (equal? (edits ind) '(1 0))) (snd-display "read-only ignored? ~A" (edits ind)))
	  )
	(set! (read-only ind) #f)
	(revert-sound ind)
	(let ((tag (catch #t
		     (lambda () (save-sound ind))
		     (lambda args args))))
	  (if (not (sound? tag)) (snd-display "save-sound read-write: ~A" tag)))
	(for-each (lambda (arg) (key arg 4)) (vector (char->integer #\j) (char->integer #\-) (char->integer #\j) 
						     (char->integer #\j) (char->integer #\x)))
	(key (char->integer #\c) 0)
	(catch #t (lambda () (add-mark 123)) (lambda args #f))
	(for-each (lambda (arg) (key arg 4)) (vector (char->integer #\u) (char->integer #\6) (char->integer #\j) 
						     (char->integer #\u) (char->integer #\6) (char->integer #\x)))
	(key (char->integer #\c) 0)
	(close-sound ind))
      
      (let ((ns (new-sound)))
	(unselect-all)
	(do ((v (make-float-vector 1000))
	     (i 0 (+ i 1))
	     (x 0.0 (+ x .001)))
	    ((= i 1000)
	     (float-vector->channel v 0 1000 ns 0))   
	  (set! (v i) x))
	(set! (selection-member? ns 0) #t)
	(set! (selection-position ns 0) 200)
	(set! (selection-framples ns 0) 300)
	(delete-selection-and-smooth)
	(if (not (= (framples ns 0) 700))
	    (snd-display "delete-selection-and-smooth framples: ~A" (framples ns 0)))
	(if (fneq (sample 167 ns 0) 0.167) 
	    (snd-display "delete-selection-and-smooth 167: ~A" (sample 167 ns 0)))
	(if (fneq (sample 234 ns 0) 0.534) 
	    (snd-display "delete-selection-and-smooth 234: ~A" (sample 234 ns 0)))
	(if (fneq (sample 210 ns 0) 0.406) 
	    (snd-display "delete-selection-and-smooth 210: ~A" (sample 210 ns 0)))
	(let ((v1 (channel->float-vector)))
	  (let ((maxdiff 0.0)
		(mindiff 10.0)
		(ls (v1 0)))
	    (do ((i 1 (+ i 1)))
		((= i 700))
	      (let ((diff (- (v1 i) ls)))
		(set! ls (v1 i))
		(set! maxdiff (max maxdiff diff))
		(set! mindiff (min mindiff diff))))
	    (if (< mindiff .0009)
		(snd-display "delete-selection-and-smooth min diff: ~A" mindiff))
	    (if (> maxdiff .007)
		(snd-display "delete-selection-and-smooth max diff: ~A" maxdiff))))
	(close-sound ns))
      
      (let ((ns (new-sound)))
	(do ((v (make-float-vector 1000))
	     (i 0 (+ i 1))
	     (x 0.0 (+ x .001)))
	    ((= i 1000) 
	     (float-vector->channel v 0 1000 ns 0))
	  (set! (v i) x))
	(delete-samples-and-smooth 200 300 ns 0)
	(if (not (= (framples ns 0) 700))
	    (snd-display "delete-samples-and-smooth framples: ~A" (framples ns 0)))
	(if (fneq (sample 167 ns 0) 0.167) 
	    (snd-display "delete-samples-and-smooth 167: ~A" (sample 167 ns 0)))
	(if (fneq (sample 234 ns 0) 0.534) 
	    (snd-display "delete-samples-and-smooth 234: ~A" (sample 234 ns 0)))
	(if (fneq (sample 210 ns 0) 0.406) 
	    (snd-display "delete-samples-and-smooth 210: ~A" (sample 210 ns 0)))
	(let ((v1 (channel->float-vector)))
	  (let ((maxdiff 0.0)
		(mindiff 10.0)
		(ls (v1 0)))
	    (do ((i 1 (+ i 1)))
		((= i 700))
	      (let ((diff (- (v1 i) ls)))
		(set! ls (v1 i))
		(set! maxdiff (max maxdiff diff))
		(set! mindiff (min mindiff diff))))
	    (if (< mindiff .0009)
		(snd-display "delete-samples-and-smooth min diff: ~A" mindiff))
	    (if (> maxdiff .007)
		(snd-display "delete-samples-and-smooth max diff: ~A" maxdiff))))
	(close-sound ns))
      
      (let-temporarily (((hook-functions initial-graph-hook) ())
			(*show-full-duration* #t))
	(let ((ns (open-sound "1.snd")))
	  (let ((ls (left-sample ns 0))
		(rs (right-sample ns 0))
		(fr (framples ns 0)))
	    (when (and with-gui
		       (not (equal? (list fr ls rs) '(220501 0 220501))))
	      (snd-display "show-full-duration 1: ~A" (list fr ls rs)))
	    (close-sound ns)))
	(set! *show-full-duration* #t)
	(let-temporarily ((*initial-beg* 0.0)
			  (*initial-dur* 0.2))
	  (let ((ns (open-sound "1.snd")))
	    (let ((ls (left-sample ns 0))
		  (rs (right-sample ns 0))
		  (fr (framples ns 0)))
	      (when (and with-gui
			 (not (equal? (list fr ls rs) '(220501 0 220501))))
		(snd-display "show-full-duration 2: ~A" (list fr ls rs)))
	      (close-sound ns)))
	  (set! *show-full-duration* #f)
	  (set! *initial-beg* 0.0)
	  (set! *initial-dur* 0.2)
	  (let ((ns (open-sound "1.snd")))
	    (let ((ls (left-sample ns 0))
		  (rs (right-sample ns 0))
		  (fr (framples ns 0)))
	      (if (not (equal? (list fr ls rs) '(220501 0 4410)))
		  (snd-display "show-full-duration 3: ~A" (list fr ls rs)))
	      (close-sound ns)))
	  (set! *initial-beg* 2.0)
	  (set! *initial-dur* 1.0)
	  (let ((ns (open-sound "1.snd")))
	    (let ((ls (left-sample ns 0))
		  (rs (right-sample ns 0))
		  (fr (framples ns 0)))
	      (if (not (equal? (list fr ls rs) '(220501 44100 66150)))
		  (snd-display "show-full-duration 4: ~A" (list fr ls rs)))	  
	      (close-sound ns)))))
      
      (set! *show-full-range* #t)
      (let ((ns (open-sound "1a.snd")))
	(if (or (fneq (car (y-bounds ns 0)) -1.0)
		(fneq (cadr (y-bounds ns 0)) 1.0))
	    (snd-display "show-full-range 1a: ~A" (y-bounds ns 0)))
	(close-sound ns))
      (with-sound ("test.snd" :clipped #f :to-snd #f)
	(fm-violin 0 1 440 3.5))
      (let ((ns (open-sound "test.snd")))
	(when (and with-gui
		   (or (fneq (car (y-bounds ns 0)) -3.5)
		       (fneq (cadr (y-bounds ns 0)) 3.5)))
	  (snd-display "show-full-range 3.5 test: ~A" (y-bounds ns 0)))
	(with-sound ("test.snd" :clipped #f :to-snd #f)
	  (fm-violin 0 1 440 1.5))
	(update-sound ns)
	(when (and with-gui
		   (or (fneq (car (y-bounds ns 0)) -1.5)
		       (fneq (cadr (y-bounds ns 0)) 1.5)))
	  (snd-display "show-full-range 1.5 test: ~A" (y-bounds ns 0)))
	(close-sound ns))
      (set! *show-full-range* #f)
      
      (let-temporarily ((*sync-style* sync-none))
	(let ((ns (open-sound "2.snd")))
	  (if (not (= (sync ns) 0))
	      (snd-display "sync-none open: ~A" (sync ns)))
	  (set! (sync ns) 1)
	  (set! *sync-style* sync-by-sound)
	  (let ((ns1 (open-sound "1a.snd")))
	    (if (or ;(= (sync ns1) 0) ; this default changed 12.9
		 (= (sync ns1) 1)
		 (not (= (sync ns) 1)))
		(snd-display "sync-by-sound open: ~A" (list (sync ns) (sync ns1))))
	    (close-sound ns1))
	  (close-sound ns)))
      
      (let ((ind (view-sound "obtest.snd")))
	(delete-samples 0 1000 ind 0)
	(let ((tag (catch #t
		     (lambda () (save-sound ind))
		     (lambda args args))))
	  (if (integer? tag) (snd-display "save-viewed-sound: ~A" tag))
	  ;(if (not (equal? (edits ind) '(1 0))) (snd-display "view read-only ignored? ~A" (edits ind)))
	  )
	(close-sound ind))
      
      (let ((ind (new-sound "test.snd" 1 22050 mus-ldouble mus-next)))
	(insert-silence 0 150000)
	(map-channel (lambda (y) 0.5))
	(env-sound '(0 0 1 1 2 0))
	(fp 1.0 0.3 20)
	(let-temporarily ((*with-tracking-cursor* #t))
	  (play :wait #t))
	(close-sound ind))
      (let ((ind (new-sound "test.snd" 1 22050 mus-ldouble mus-next)))
	(for-each
	 (lambda (dur)
	   (insert-silence 0 dur)
	   (map-channel (lambda (y) 1.0))
	   (env-sound '(0 0 1 1 2 0))
	   (let ((reader (make-sampler (- (framples) 1) ind 0 -1)))
	     (if (not (= (sampler-position reader) (- (framples) 1))) (snd-display "sampler-position: ~A" (sampler-position reader)))
	     (map-channel (lambda (y) (read-sample reader))))
	   (let ((e (make-env '(0 0 1 1 2 0) :length (+ 1 dur)))
		 (len (framples)))
	     (let ((v0 (make-float-vector len))
		   (v1 (samples 0 len ind 0)))
	       (outa->fv v0 (env e))
	       (if (not (mus-arrays-equal? v0 v1))
		   (snd-display "~%;trouble in reverse read ~A ~A" v0 v1))))
	   (revert-sound))
	 '(150 1500 150000))
	(close-sound ind))
      (let ((ind (new-sound "test.snd" 1 22050 mus-ldouble mus-next)))
	(insert-silence 0 1000)
	(map-channel (lambda (y) 1.0))
	(env-sound '(0 0 1 1 2 0))
	(scale-channel 0.0 100 200)
	(let ((reader (make-sampler (- (framples) 1) ind 0 -1)))
	  (map-channel (lambda (y) (read-sample reader))))
	(let ((e (make-env '(0 0 1 1 2 0) :length 1001))
	      (new-reader (make-sampler 0 ind 0))
	      (len (framples)))
	  (call-with-exit
	   (lambda (quit)
	     (do ((old (env e) (env e))
		  (new (read-sample new-reader) (read-sample new-reader))
		  (i 0 (+ i 1)))
		 ((= i len))
	       (when (or (and (or (> i 900) (<= i 700))
			      (fneq old new))
			 (and (> i 700) (<= i 900)
			      (fneq new 0.0)))
		 (format () "~%;trouble in reverse read 2 at ~D ~A ~A" i old new)
		 (quit))))))
	(close-sound ind))
      (let ((ind (new-sound "test.snd" 1 22050 mus-ldouble mus-next)))
	(insert-silence 0 150000)
	(map-channel (lambda (y) 1.0))
	(let ((edpos (edit-position)))
	  (do ((i 0 (+ i 1)))
	      ((= i 7))
	    (if (= i 5)
		(scale-channel 0.5 1000 12345))
	    (env-sound '(0 0 1 1 2.5 0 3 1 4 0))
	    (case i
	      ((1) (delete-samples 50 100))
	      ((2) (insert-samples 300 100 (make-float-vector 100 0.5)))
	      ((3) (scale-channel 0.0 1000 1000))
	      ((4) (float-vector->channel (make-float-vector 100 0.5) 500 100))
	      ((6) (env-sound '(0 1 1 0) 10000 2000)))
	    (let ((reader (make-sampler (- (framples) 1) ind 0 -1)))
	      (map-channel (lambda (y) (read-sample reader))))
	    (let ((reader (make-sampler (- (framples) 1) ind 0 -1)))
	      (map-channel (lambda (y) (read-sample reader))))
	    (let ((len (framples)))
	      (let ((v0 (samples 0 len ind 0 (- (edit-position ind 0) 2)))
		    (v1 (samples 0 len ind 0)))
		(if (not (mus-arrays-equal? v0 v1))
		    (snd-display "~%;trouble in reverse read ~A ~A" v0 v1))))
	    (set! (edit-position ind 0) edpos)))
	(close-sound ind))
      (let ((reader #f)
	    (last-proc #f))
	(define (scan-again)
	  (and (not (sampler-at-end? reader))
	       (let ((val (last-proc (reader))))
		 (if val 
		     (list val (- (sampler-position reader) 1))
		     (scan-again)))))
	(define* (my-scan-channel proc)
	  (when proc 
	    (set! last-proc proc)
	    (set! reader (make-sampler 0)))
	  (scan-again))
	(let ((ind (open-sound "oboe.snd"))
	      (val #f))
	  (let ((samp (sample 1000)))
	    (set! (cursor ind 0) 1000)
	    (if (fneq (sample) samp)
		(snd-display "sample no args: ~A ~A" (sample) samp)))
	  (set! val (my-scan-channel (lambda (y) (> y .1))))
	  (if (not (equal? val '(#t 4423)))
	      (snd-display "my-scan-chan: ~A" val))
	  (set! val (scan-again))
	  (if (not (equal? val '(#t 4463)))
	      (snd-display "scan-again: ~A" val))
	  (set! (cursor) 1000)
	  (set! (sample) .5)
	  (if (fneq (sample 1000) .5)
	      (snd-display "set sample no arg: ~A ~A" (sample 1000) (sample 0)))
	  (close-sound ind)))
      
      ;; edit-menu.scm tests
      (when (defined? 'selection->new)
	(let ((ind (view-sound "oboe.snd")))
	  (make-selection 1000 1999 ind 0)
	  (let ((newsnd (selection->new)))
	    (if (not (sound? newsnd)) (snd-display "selection->new -> ~A" newsnd))
	    (if (not (= (framples newsnd 0) 1000)) (snd-display "selection->new framples: ~A" (framples newsnd 0)))
	    (if (not (equal? (edits ind 0) '(0 0))) (snd-display "selection->new edited original? ~A" (edits ind 0)))
	    (let ((newfile (file-name newsnd)))
	      (close-sound newsnd)
	      (delete-file newfile)
	      (mus-sound-forget newfile)))
	  (make-selection 1000 1999 ind 0)
	  (let ((newsnd (cut-selection->new)))
	    (if (not (sound? newsnd)) (snd-display "cut-selection->new -> ~A" newsnd))
	    (if (not (= (framples newsnd 0) 1000)) (snd-display "cut-selection->new framples: ~A" (framples newsnd 0)))
	    (if (not (equal? (edits ind 0) '(1 0))) (snd-display "cut-selection->new did not edit original? ~A" (edits ind 0)))
	    (if (not (= (framples ind 0) (- (framples ind 0 0) 1000))) 
		(snd-display "cut-selection->new cut: ~A ~A" (framples ind 0) (- (framples ind 0 0) 1000)))
	    (undo 1 ind 0)
	    (let ((newfile (file-name newsnd)))
	      (close-sound newsnd)
	      (delete-file newfile)
	      (mus-sound-forget newfile)))
	  (make-selection 1000 1999 ind 0)
	  (append-selection)
	  (if (not (= (framples ind 0) (+ (framples ind 0 0) 1000)))
	      (snd-display "append-selection: ~A ~A" (framples ind 0) (framples ind 0 0)))
	  (let ((append-sound (lambda (filename)
				(insert-sound filename (framples)))))
	    (append-sound "oboe.snd")
	    (if (not (= (framples ind 0) (+ (* 2 (framples ind 0 0)) 1000)))
		(snd-display "append-sound: ~A ~A" (framples ind 0) (framples ind 0 0))))
	  (revert-sound ind)
	  (let ((m1 (add-mark 1000))
		(m2 (add-mark 12000)))
	    (trim-front)
	    (if (not (equal? (edits ind 0) '(1 0))) (snd-display "time-front did not edit original? ~A" (edits ind 0)))
	    (if (not (= (framples ind 0) (- (framples ind 0 0) 1000))) 
		(snd-display "trim-front: ~A ~A" (framples ind 0) (- (framples ind 0 0) 1000)))
	    (if (not (= (mark-sample m2) 11000)) (snd-display "trim-front m2: ~A" (mark-sample m2)))
	    (undo 1 ind 0)
	    (trim-back)
	    (if (not (equal? (edits ind 0) '(1 0))) (snd-display "time-back did not edit original? ~A" (edits ind 0)))
	    (if (not (= (framples ind 0) 12001)) (snd-display "trim-back: ~A" (framples ind 0)))
	    (if (not (= (mark-sample m1) 1000)) (snd-display "trim-back m1: ~A" (mark-sample m1))))
	  (undo 1 ind 0)
	  (add-mark 22000)
	  (crop)
	  (if (not (equal? (edits ind 0) '(1 0))) (snd-display "crop did not edit original? ~A" (edits ind 0)))
	  (if (not (= (framples ind 0) 21001)) (snd-display "crop: ~A" (framples ind 0)))
	  (undo 1 ind 0)
	  (close-sound ind)))
      
      (let ((ind (new-sound "test.snd"))
	    (check-maxamp 
	     (lambda (caller-line ind val name)
	       (if (fneq (maxamp ind 0) val) (snd-display "maxamp amp-env ~A: ~A should be ~A" name (maxamp ind) val))
	       (let ((pos (scan-channel (lambda (y) (>= (abs y) (- val .0001)))))
		     (maxpos (maxamp-position ind 0)))
		 (if (not pos) 
		     (snd-display "actual maxamp ~A vals not right" name)
		     (if (not (= maxpos pos))
			 (snd-display "~A: find and maxamp-position disagree: ~A (~A) ~A (~A)" 
				      name pos (sample pos ind 0) maxpos (sample maxpos ind 0))))
		 (let ((info (float-vector-peak-and-location (samples 0 (framples ind) ind))))
		   (let ((mpos (cadr info))
			 (mx (car info)))
		     (if (not (= mpos maxpos))
			 (snd-display "(~D) scan and maxamp-position disagree: ~A ~A" caller-line mpos maxpos))
		     (if (fneq mx val) (snd-display "(~D) actual ~A max: ~A (correct: ~A)" caller-line name mx val))))))))
	(map-channel (lambda (y) 1.0) 0 1001)
	(env-channel (make-env '(0 1 1 1) :scaler .5 :length 1001))
	(check-maxamp 0 ind .5 "simple scaler")

	(let ((check-env-vals 
	       (lambda (name gen)
		 (let ((len (framples))
		       (reader (make-sampler)))
		   (do ((i 0 (+ i 1)))
		       ((or (= i len)
			    (let ((val (env gen))
				  (y (next-sample reader)))
			      (and (fneq val y)
				   (or (snd-display "~%;check-env-vals ~A at ~D: ~A ~A" name i val y)
				       #t))))))))))
	  (check-env-vals "simple scaler" (make-env '(0 1 1 1) :scaler .5 :length 1001))
	  (if (= (edit-position) 2)
	      (undo)
	      (snd-display "env+scl was no-op"))
	  (env-channel (make-env '(0 1 1 1) :offset .5 :length 1001))
	  (check-maxamp 1 ind 1.5 "simple offset")
	  (check-env-vals "simple offset" (make-env '(0 1 1 1) :offset .5 :length 1001))
	  (if (= (edit-position) 2)
	      (undo)
	      (snd-display "env+offset was no-op"))
	  (env-channel (make-env '(0 0 1 1 2 0) :offset .5 :scaler 2.0 :length 1001))
	  (check-maxamp 2 ind 2.5 "off+scl")
	  (check-env-vals "off+scl" (make-env '(0 0 1 1 2 0) :offset .5 :scaler 2.0 :length 1001))
	  (undo)
	  (env-channel (make-env '(0 -0.5 1 0 2 -1) :offset .5 :scaler 2.0 :length 1001))
	  (check-maxamp 3 ind 1.5 "off+scl #2")
	  (let ((mx -12.0))
	    (scan-channel (lambda (y) (not (set! mx (max mx y)))))
	    (if (fneq mx 0.5) (snd-display "non abs max: ~A (correct: 0.5)" mx)))
	  (check-env-vals "off+scl #2" (make-env '(0 -0.5 1 0 2 -1) :offset .5 :scaler 2.0 :length 1001))
	  (undo)
	  (env-sound '(0 .5 1 .75 2 .25) 0 (framples) 32.0)
	  (check-maxamp 4 ind 0.75 "xramp")
	  (check-env-vals "xramp" (make-env '(0 .5 1 .75 2 .25) :base 32.0 :length 1001))
	  (undo)
	  (env-channel-with-base '(0 .5 1 .75 2 .25) 32.0)
	  (check-maxamp 5 ind 0.75 "xramp1")
	  (check-env-vals "xramp1" (make-env '(0 .5 1 .75 2 .25) :base 32.0 :length 1001)))
	(close-sound ind))
      
      (let ((hlb (make-hilbert-transform 8))
	    (data (make-float-vector 20)))
	(do ((i 0 (+ i 1)))
	    ((= i 20))
	  (set! (data i) (hilbert-transform hlb (if (= i 0) 1.0 0.0))))
	(if (not (mus-arrays-equal? data #r(0.0 -0.010 0.0 -0.046 0.0 -0.152 0.0 -0.614 0.0 0.614 0.0 0.152 0.0 0.046 0.0 0.010 0.0 0.0 0.0 0.0)))
	    (snd-display "hilbert-transform 8 impulse response: ~A" data)))
      
      (let ((hlb (make-hilbert-transform 7))
	    (data (make-float-vector 20)))
	(do ((i 0 (+ i 1)))
	    ((= i 20))
	  (set! (data i) (hilbert-transform hlb (if (= i 0) 1.0 0.0))))
	(if (not (mus-arrays-equal? data #r(-0.007 0.0 -0.032 0.0 -0.136 0.0 -0.608 0.0 0.608 0.0 0.136 0.0 0.032 0.0 0.007 0.0 0.0 0.0 0.0 0.0)))
	    (snd-display "hilbert-transform 7 impulse response: ~A" data)))
      
      (let ((ind (new-sound "test.snd")))
	(pad-channel 0 1000)
	(set! (sample 100) 1.0)
	
	(let ((h (make-hilbert-transform 100)))
	  (do ((i 0 (+ i 1))) ((= i 4)) (map-channel (lambda (y) (hilbert-transform h y)))))
	;; now ideally we'd be back to an impulse
	(if (> (abs (- (sample 500) .98)) .01)
	    (snd-display "hilbert impulse: ~A" (sample 500)))
	(set! (sample 500) 0.0)
	(if (> (maxamp ind 0) .02)
	    (snd-display "hilbert sidelobes: ~A" (maxamp ind 0)))
	(scale-channel 0.0)
	(set! (sample 100) 1.0)
	
	(let ((h (make-hilbert-transform 101)))
	  (do ((i 0 (+ i 1))) ((= i 4)) (map-channel (lambda (y) (hilbert-transform h y)))))
	(if (> (abs (- (sample 504) .98)) .01)
	    (snd-display "hilbert 101 impulse: ~A: ~A" (sample 504) (channel->float-vector 498 10)))
	(set! (sample 504) 0.0)
	(if (> (maxamp ind 0) .02)
	    (snd-display "hilbert 101 sidelobes: ~A" (maxamp ind 0)))
	(revert-sound)
	
	(pad-channel 0 1000)
	(set! (sample 100) 1.0)
	(let ((lo (make-lowpass (* .1 pi) 20))
	      (hi (make-highpass (* .1 pi) 20)))
	  (map-channel (lambda (y) (+ (lowpass lo y) (highpass hi y)))))
	(if (fneq (sample 120) 1.0)
	    (snd-display "lowpass+highpass impulse: ~A" (sample 120)))
	(set! (sample 120) 0.0)
	(if (fneq (maxamp ind 0) 0.0)
	    (snd-display "lowpass+highpass sidelobes: ~A" (maxamp ind 0)))
	(undo 2)
	(let ((lo (make-bandpass (* .1 pi) (* .2 pi) 20))
	      (hi (make-bandstop (* .1 pi) (* .2 pi) 20)))
	  (map-channel (lambda (y) (+ (bandpass lo y) (bandstop hi y)))))
	(if (fneq (sample 120) 1.0)
	    (snd-display "bandpass+bandstop impulse: ~A" (sample 120)))
	(set! (sample 120) 0.0)
	(if (fneq (maxamp ind 0) 0.0)
	    (snd-display "bandpass+bandstop sidelobes: ~A" (maxamp ind 0)))
	(close-sound ind))
      
      (let ((ind (new-sound "test.snd"))
	    (make-bandpass-2 
	     (lambda* (flo1 fhi1 flo2 fhi2 (len 30))
	       (let ((f1 (make-bandpass flo1 fhi1 len))
		     (f2 (make-bandpass flo2 fhi2 len)))
		 (float-vector-add! (mus-xcoeffs f1) (mus-xcoeffs f2))
		 f1))))
	(map-channel (lambda (y) (mus-random 1.0)) 0 10000)
	(let ((f2 (make-bandpass-2 (* .12 pi) (* .15 pi) (* .22 pi) (* .25 pi) 100)))
	  (map-channel (lambda (y) (fir-filter f2 y)))
	  (let ((data (channel->float-vector)))
	    (undo)
	    (let ((f1 (make-bandpass (* .12 pi) (* .15 pi) 100))
		  (f2 (make-bandpass (* .22 pi) (* .25 pi) 100)))
	      (map-channel (lambda (y) (+ (fir-filter f1 y) (fir-filter f2 y))))
	      (let ((data1 (channel->float-vector)))
		(float-vector-subtract! data data1)
		(if (> (float-vector-peak data) .00001)
		    (snd-display "fir-filter 2: ~A" (float-vector-peak data))))
	      (undo))))
	(close-sound ind))
      
      (reset-all-hooks)
      
      (let ((ind (new-sound  "test.snd" 1 22050 mus-ldouble mus-next "first ramp re-order tests" 100)))
	(map-channel (lambda (y) 1.0))
	(for-each
	 (lambda (lst)
	   (let ((name (car lst))
		 (try-scale (cadr lst))
		 (f1 (caddr lst))
		 (f2 (cadddr lst))
		 (edpos (edit-position ind 0)))
	     (f1)
	     (let ((v1 (channel->float-vector 0 100 ind 0)))
	       (set! (edit-position ind 0) edpos)
	       (f2)
	       (let ((v2 (channel->float-vector 0 100 ind 0)))
		 (if (not (mus-arrays-equal? v1 v2))
		     (snd-display "env reordering test ~A:~%; ~A~%; ~A" name v1 v2))
		 (set! (edit-position ind 0) edpos)))
	     (if try-scale
		 (begin
		   (scale-by 2.0)
		   (f1)
		   (let ((v1 (channel->float-vector 0 100 ind 0)))
		     (set! (edit-position ind 0) edpos)
		     (f2)
		     (scale-by 2.0)
		     (let ((v2 (channel->float-vector 0 100 ind 0)))
		       (if (not (mus-arrays-equal? v1 v2))
			   (snd-display "scaled (2) env reordering test ~A:~%; ~A~%; ~A" name v1 v2))
		       (set! (edit-position ind 0) edpos)))
		   (f1)
		   (scale-by .5)
		   (let ((v1 (channel->float-vector 0 100 ind 0)))
		     (set! (edit-position ind 0) edpos)
		     (scale-by .5)
		     (f2)
		     (let ((v2 (channel->float-vector 0 100 ind 0)))
		       (if (not (mus-arrays-equal? v1 v2))
			   (snd-display "scaled (.5) env reordering test ~A:~%; ~A~%; ~A" name v1 v2))
		       (set! (edit-position ind 0) edpos)))))))
	 
	 (list (list "ramp-xramp" #t
		     (lambda ()
		       (env-sound '(0 0 1 1 2 0))
		       (env-sound '(0 0 1 1) 0 100 2.0))
		     (lambda ()
		       (env-sound '(0 0 1 1) 0 100 2.0)
		       (env-sound '(0 0 1 1 2 0))))
	       (list "ramp2-xramp (1)" #t
		     (lambda ()
		       (env-sound '(0 0 1 1 2 0))
		       (env-sound '(0 0 1 1 3 0))
		       (env-sound '(0 0 1 1) 0 100 2.0))
		     (lambda ()
		       (env-sound '(0 0 1 1 2 0))
		       (env-sound '(0 0 1 1) 0 100 2.0)
		       (env-sound '(0 0 1 1 3 0))))
	       (list "ramp2-xramp (2)" #t
		     (lambda ()
		       (env-sound '(0 0 1 1 2 0))
		       (env-sound '(0 0 1 1))
		       (env-sound '(0 0 1 1 3 0) 0 100 2.0))
		     (lambda ()
		       (env-sound '(0 0 1 1 3 0) 0 100 2.0)
		       (env-sound '(0 0 1 1 2 0))
		       (env-sound '(0 0 1 1))))
	       (list "xramp2-ramp (1)" #t
		     (lambda ()
		       (env-sound '(0 0 1 1 2 0) 0 100 2.0)
		       (env-sound '(0 0 1 1))
		       (env-sound '(0 0 1 1 3 0) 0 100 3.0))
		     (lambda ()
		       (env-sound '(0 0 1 1 2 0) 0 100 2.0)
		       (env-sound '(0 0 1 1 3 0) 0 100 3.0)
		       (env-sound '(0 0 1 1))))
	       (list "xramp2-ramp (2)" #t
		     (lambda ()
		       (env-sound '(0 0 1 1 2 0) 0 100 2.0)
		       (env-sound '(0 0 1 1 3 0))
		       (env-sound '(0 0 1 1) 0 100 3.0))
		     (lambda ()
		       (env-sound '(0 0 1 1 3 0))
		       (env-sound '(0 0 1 1 2 0) 0 100 2.0)
		       (env-sound '(0 0 1 1) 0 100 3.0)))
	       ))
	(close-sound ind))
      )) ; end of clm-test do loop I think
  
  (let ((ind (open-sound "oboe.snd")))
    ;; simple cases
    
    (as-one-edit
     (lambda ()
       (set! (sample 10) 1.0)))
    (if (fneq (sample 10) 1.0) (snd-display "as-one-edit 1: ~A" (sample 10)))
    (if (not (= (edit-position ind 0) 1)) 
	(snd-display "as-one-edit 1 edpos: ~A" (edit-position ind 0))
	(begin
	  (if (not (equal? (edit-fragment 1 ind 0) '("set-sample 10 1.0000" "set" 10 1)))
	      (snd-display "as-one-edit 1 edlist: ~A" (edit-fragment 1 ind 0)))
	  (if (not (equal? (edit-fragment 0 ind 0) '("" "init" 0 50828)))
	      (snd-display "as-one-edit 1 original edlist: ~A" (edit-fragment 0 ind 0)))))
    
    (revert-sound ind)
    (as-one-edit
     (lambda ()
       (set! (sample 10) 1.0)
       (map-channel (lambda (y) (* y 2.0)) 0 20 ind 0 #f "map-channel as-one-edit")
       (if (not (= (edit-position ind 0) 2)) (snd-display "as-one-edit 2 edpos internal: ~A" (edit-position ind 0))))
     "as-one-edit test-2")
    (if (fneq (sample 10) 2.0) (snd-display "as-one-edit 2: ~A" (sample 10)))
    (if (not (= (edit-position ind 0) 1)) 
	(snd-display "as-one-edit 2 edpos: ~A" (edit-position ind 0))
	(if (not (equal? (edit-fragment 0 ind 0) '("" "init" 0 50828)))
	    (snd-display "as-one-edit 2 original edlist: ~A" (edit-fragment 0 ind 0))))
    
    (revert-sound ind)
    (let ((ind2 (open-sound "2a.snd")))
      (set! (sample 1 ind2 0) 1.0)
      (set! (sample 2 ind2 1) 0.5)
      (set! (selected-sound) ind)
      
      (as-one-edit
       (lambda ()
	 (set! (sample 10 ind 0) 1.0)))
      (if (fneq (sample 10 ind 0) 1.0) (snd-display "as-one-edit 3: ~A" (sample 10 ind 0)))
      (if (not (= (edit-position ind 0) 1)) (snd-display "as-one-edit 3 edpos: ~A" (edit-position ind 0)))
      (if (not (= (edit-position ind2 0) 1)) (snd-display "as-one-edit 3 2 edpos: ~A" (edit-position ind2 0)))
      (if (not (= (edit-position ind2 1) 1)) (snd-display "as-one-edit 3 2 1 edpos: ~A" (edit-position ind2 1)))
      (if (not (equal? (edit-fragment 1 ind 0) '("set-sample 10 1.0000" "set" 10 1)))
	  (snd-display "as-one-edit 3 edlist: ~A" (edit-fragment 1 ind 0)))
      (if (not (equal? (edit-fragment 1 ind2 0) '("set-sample 1 1.0000" "set" 1 1)))
	  (snd-display "as-one-edit 3 2 edlist: ~A" (edit-fragment 1 ind2 0)))
      (if (not (equal? (edit-fragment 1 ind2 1) '("set-sample 2 0.5000" "set" 2 1)))
	  (snd-display "as-one-edit 3 2 1 edlist: ~A" (edit-fragment 1 ind2 1)))
      
      (revert-sound ind)
      
      (as-one-edit    
       (lambda ()
	 (set! (sample 10 ind 0) 1.0)
	 (map-channel (lambda (y) (* y 2.0)) 0 20 ind 0 #f "map-channel as-one-edit 2")
	 (if (not (= (edit-position ind 0) 2)) (snd-display "as-one-edit 4 edpos internal: ~A" (edit-position ind 0))))
       "as-one-edit test-4")
      (if (fneq (sample 10) 2.0) (snd-display "as-one-edit 4: ~A" (sample 10 ind 0)))
      (if (not (= (edit-position ind 0) 1)) 
	  (snd-display "as-one-edit 4 edpos: ~A" (edit-position ind 0)))
      (if (not (equal? (edit-fragment 1 ind2 0) '("set-sample 1 1.0000" "set" 1 1)))
	  (snd-display "as-one-edit 3 2 edlist: ~A" (edit-fragment 1 ind2 0)))
      (if (not (equal? (edit-fragment 1 ind2 1) '("set-sample 2 0.5000" "set" 2 1)))
	  (snd-display "as-one-edit 3 2 1 edlist: ~A" (edit-fragment 1 ind2 1)))
      
      (revert-sound ind)
      (set! (sample 3 ind 0) 1.0)
      
      (as-one-edit
       (lambda ()
	 (set! (sample 10 ind 0) 1.0)
	 (set! (sample 10 ind2 0) 0.5)
	 (set! (sample 10 ind2 1) 0.4)))
      (if (fneq (sample 3 ind 0) 1.0) (snd-display "as-one-edit 5 (3): ~A" (sample 3 ind 0)))
      (if (fneq (sample 10 ind 0) 1.0) (snd-display "as-one-edit 5 (10): ~A" (sample 10 ind 0)))
      (if (fneq (sample 10 ind2 0) 0.5) (snd-display "as-one-edit 5 (2 10): ~A" (sample 10 ind2 0)))
      (if (fneq (sample 10 ind2 1) 0.4) (snd-display "as-one-edit 5 (2 1 10): ~A" (sample 10 ind2 1)))
      (if (not (= (edit-position ind 0) 2)) (snd-display "as-one-edit 5 edpos: ~A" (edit-position ind 0)))
      (if (not (= (edit-position ind2 0) 2)) (snd-display "as-one-edit 5 2 edpos: ~A" (edit-position ind2 0)))
      (if (not (= (edit-position ind2 1) 2)) (snd-display "as-one-edit 5 2 1 edpos: ~A" (edit-position ind2 1)))
      
      (if (not (equal? (edit-fragment 2 ind 0) '("set-sample 10 1.0000" "set" 10 1)))
	  (snd-display "as-one-edit 5 edlist 2: ~A" (edit-fragment 1 ind 0)))
      (if (not (equal? (edit-fragment 1 ind 0) '("set-sample 3 1.0000" "set" 3 1)))
	  (snd-display "as-one-edit 5 edlist 1: ~A" (edit-fragment 1 ind 0)))
      (if (not (equal? (edit-fragment 0 ind 0) '("" "init" 0 50828)))
	  (snd-display "as-one-edit 5 original edlist: ~A" (edit-fragment 0 ind 0)))
      (if (not (equal? (edit-fragment 2 ind2 0) '("set-sample 10 0.5000" "set" 10 1)))
	  (snd-display "as-one-edit 5 edlist 2 1: ~A" (edit-fragment 1 ind2 0)))
      
      (as-one-edit
       (lambda ()
	 (map-channel (lambda (y) (* y 2.0)) 0 20 ind 0 #f "map-channel as-one-edit 6")
	 (map-channel (lambda (y) (* y 2.0)) 0 20 ind2 1 #f "map-channel as-one-edit 6 2 1"))
       "as-one-edit test-6")
      
      
      (if (fneq (sample 3 ind 0) 2.0) (snd-display "as-one-edit 6 (3): ~A" (sample 3 ind 0)))
      (if (fneq (sample 10 ind 0) 2.0) (snd-display "as-one-edit 6 (10): ~A" (sample 10 ind 0)))
      (if (fneq (sample 10 ind2 0) 0.5) (snd-display "as-one-edit 6 (2 10): ~A" (sample 10 ind2 0)))
      (if (fneq (sample 10 ind2 1) 0.8) (snd-display "as-one-edit 6 (2 1 10): ~A" (sample 10 ind2 1)))
      (if (not (= (edit-position ind 0) 3)) (snd-display "as-one-edit 6 edpos: ~A" (edit-position ind 0)))
      (if (not (= (edit-position ind2 0) 2)) (snd-display "as-one-edit 6 2 edpos: ~A" (edit-position ind2 0)))
      (if (not (= (edit-position ind2 1) 3)) (snd-display "as-one-edit 6 2 1 edpos: ~A" (edit-position ind2 1)))
      
      (if (not (equal? (edit-fragment 2 ind 0) '("set-sample 10 1.0000" "set" 10 1)))
	  (snd-display "as-one-edit 5 edlist 2: ~A" (edit-fragment 1 ind 0)))
      (if (not (equal? (edit-fragment 2 ind2 0) '("set-sample 10 0.5000" "set" 10 1)))
	  (snd-display "as-one-edit 5 edlist 2 1: ~A" (edit-fragment 1 ind2 0)))
      (close-sound ind2))
    
    ;; nested cases
    (revert-sound ind)
    
    (as-one-edit
     (lambda ()
       (set! (sample 100) .9)
       (as-one-edit
	(lambda ()
	  (set! (sample 200) .8)
	  (set! (sample 300) .7)))
       (set! (sample 300) .6)))
    (if (or (fneq (sample 100) .9)
	    (fneq (sample 200) .8)
	    (fneq (sample 300) .6))
	(snd-display "nested as-one-edit 7: ~A ~A ~A" (sample 100) (sample 200) (sample 300)))
    (if (not (= (edit-position ind 0) 1))
	(snd-display "nested as-one-edit 7 edpos: ~A" (edit-position ind 0)))
    (when (squelch-update ind 0)
      (snd-display "nested as-one-edit 7 squelch is on")
      (set! (squelch-update) #f))
    (if (not (equal? (edit-fragment 1 ind 0) '("set-sample 300 0.6000" "set" 100 204)))
	(snd-display "as-one-edit 7 edlist: ~A" (edit-fragment 1 ind 0)))
    
    (revert-sound ind)
    (as-one-edit
     (lambda ()
       (set! (sample 100) .9)
       (as-one-edit
	(lambda ()
	  (set! (sample 200) .8)
	  (set! (sample 300) .7)))
       (set! (sample 300) .6))
     "as-one-edit test-8")
    (if (or (fneq (sample 100) .9)
	    (fneq (sample 200) .8)
	    (fneq (sample 300) .6))
	(snd-display "nested as-one-edit 8: ~A ~A ~A" (sample 100) (sample 200) (sample 300)))
    (if (not (= (edit-position ind 0) 1))
	(snd-display "nested as-one-edit 8 edpos: ~A" (edit-position ind 0)))
    (if (not (equal? (edit-fragment 1 ind 0) '("as-one-edit test-8" "set" 100 204)))
	(snd-display "as-one-edit 8 edlist: ~A" (edit-fragment 1 ind 0)))
    
    (revert-sound ind)
    (as-one-edit
     (lambda ()
       (set! (sample 100) .9)
       (as-one-edit
	(lambda ()
	  (set! (sample 200) .8)
	  (set! (sample 300) .7))
	"as-one-edit 9 internal")
       (set! (sample 300) .6))
     "as-one-edit test-9")
    (if (or (fneq (sample 100) .9)
	    (fneq (sample 200) .8)
	    (fneq (sample 300) .6))
	(snd-display "nested as-one-edit 9: ~A ~A ~A" (sample 100) (sample 200) (sample 300)))
    (if (not (= (edit-position ind 0) 1))
	(snd-display "nested as-one-edit 9 edpos: ~A" (edit-position ind 0)))
    (if (not (equal? (edit-fragment 1 ind 0) '("as-one-edit test-9" "set" 100 204)))
	(snd-display "as-one-edit 9 edlist: ~A" (edit-fragment 1 ind 0)))
    
    (revert-sound ind)
    (as-one-edit
     (lambda ()
       (set! (sample 100) .9)
       (as-one-edit
	(lambda ()
	  (set! (sample 200) .8)
	  (as-one-edit
	   (lambda ()
	     (set! (sample 400) .3))
	   "not a name")
	  (set! (sample 300) .7))
	"as-one-edit 10 internal")
       (set! (sample 300) .6))
     "as-one-edit test-10")
    (if (or (fneq (sample 100) .9)
	    (fneq (sample 200) .8)
	    (fneq (sample 300) .6)
	    (fneq (sample 400) .3))
	(snd-display "nested as-one-edit 10: ~A ~A ~A ~A" (sample 100) (sample 200) (sample 300) (sample 400)))
    (if (not (= (edit-position ind 0) 1))
	(snd-display "nested as-one-edit 10 edpos: ~A" (edit-position ind 0)))
    (if (not (equal? (edit-fragment 1 ind 0) '("as-one-edit test-10" "set" 100 305)))
	(snd-display "as-one-edit 10 edlist: ~A" (edit-fragment 1 ind 0)))
    
    ;; try implicit as-one-edits nested
    (revert-sound ind)
    (env-channel-with-base '(0 0 1 1 2 .5 3 .25 4 0) 0.0 0 #f ind 0)
    (if (not (= (edit-position ind 0) 1)) (snd-display "as-one-edit 11 edpos: ~A" (edit-position ind 0)))
    (if (not (equal? (edit-fragment 1 ind 0) 
		     '("env-channel-with-base '(0.000 0.000 1.000 1.000 2.000 0.500 3.000 0.250 4.000 0.000) 0.0000 0 #f" "scale" 0 50830)))
	(snd-display "as-one-edit 11: ~A" (edit-fragment 1 ind 0)))
    
    (revert-sound ind)
    (as-one-edit
     (lambda ()
       (env-channel-with-base '(0 0 1 1 2 .5 3 .25 4 0) 0.0 0 #f ind 0))
     "as-one-edit 12")
    (if (not (= (edit-position ind 0) 1)) (snd-display "as-one-edit 12 edpos: ~A" (edit-position ind 0)))
    (if (not (equal? (edit-fragment 1 ind 0) '("as-one-edit 12" "scale" 0 50830)))
	(snd-display "as-one-edit 12: ~A" (edit-fragment 1 ind 0)))
    
    (revert-sound ind)
    (let ((m1 #f)
	  (m2 #f)
	  (m3 #f)
	  (m4 #f))
      (as-one-edit
       (lambda ()
	 (set! m1 (add-mark 1234 ind 0))
	 (set! (sample 1236 ind 0) .6)
	 (as-one-edit
	  (lambda ()
	    (set! (sample 123 ind 0) .3)
	    (set! m2 (add-mark 1235 ind 0)))
	  "as-one-edit inner 1")
	 (if (not (mark? m1)) (snd-display "as-one-edit stepped on m1: ~A" m1))
	 (if (not (mark? m2)) (snd-display "as-one-edit stepped on m2: ~A" m2))
	 (as-one-edit
	  (lambda ()
	    (set! m3 (add-mark 1238 ind 0))
	    (set! (sample 1238 ind 0) .8))
	  "as-one-edit inner 2")
	 (set! (sample 1239 ind 0) .9)
	 (set! m4 (add-mark 1237 ind 0)))
       "outer as-one-edit")
      (if (not (mark? m1)) (snd-display "second as-one-edit stepped on m1: ~A" m1))
      (if (not (mark? m2)) (snd-display "second as-one-edit stepped on m2: ~A" m2))
      (if (not (mark? m3)) (snd-display "second as-one-edit stepped on m3: ~A" m3))
      (if (not (mark? m4)) (snd-display "second as-one-edit stepped on m4: ~A" m4))
      (if (not (= (mark-sample m1) 1234)) (snd-display "as-one-edit m1 sample: ~A (1234)" (mark-sample m1)))
      (if (not (= (mark-sample m2) 1235)) (snd-display "as-one-edit m2 sample: ~A (1235)" (mark-sample m2)))
      (if (not (= (mark-sample m3) 1238)) (snd-display "as-one-edit m3 sample: ~A (1238)" (mark-sample m3)))
      (if (not (= (mark-sample m4) 1237)) (snd-display "as-one-edit m4 sample: ~A (1237)" (mark-sample m4))))
    (if (not (string=? (display-edits ind 0) (string-append "
EDITS: 1

 (begin) [0:2]:
   (at 0, cp->sounds[0][0:50827, 1.000]) [file: " cwd "oboe.snd[0]]
   (at 50828, end_mark)

 (set 123 1120) ; outer as-one-edit [1:9]:
   (at 0, cp->sounds[0][0:122, 1.000]) [file: " cwd "oboe.snd[0]]
   (at 123, cp->sounds[2][0:0, 1.000]) [buf: 1] 
   (at 124, cp->sounds[0][124:1235, 1.000]) [file: " cwd "oboe.snd[0]]
   (at 1236, cp->sounds[1][0:0, 1.000]) [buf: 1] 
   (at 1237, cp->sounds[0][1237:1237, 1.000]) [file: " cwd "oboe.snd[0]]
   (at 1238, cp->sounds[3][0:0, 1.000]) [buf: 1] 
   (at 1239, cp->sounds[4][0:0, 1.000]) [buf: 1] 
   (at 1240, cp->sounds[0][1240:50827, 1.000]) [file: " cwd "oboe.snd[0]]
   (at 50828, end_mark)
")))
	(snd-display "as-one-edit edits: ~A" (display-edits ind 0)))
    (revert-sound ind)
    
    (let ((m4 #f))
      (let ((m3 #f))
	(let ((m2 #f))
	  (let ((m1 #f))
	    (as-one-edit
	     (lambda ()
	       (set! m1 (mix-float-vector #r(.1 .2 .3) 1234 ind 0))
	       (set! (sample 1236 ind 0) .6)
	       (as-one-edit
		(lambda ()
		  (set! (sample 123 ind 0) .3)
		  (set! m2 (mix-float-vector #r(.1 .2 .3) 1235 ind 0)))
		"as-one-edit inner 1")
	       (if (not (mix? m1)) (snd-display "as-one-edit stepped on m1: ~A" m1))
	       (if (not (mix? m2)) (snd-display "as-one-edit stepped on m2: ~A" m2))
	       (as-one-edit
		(lambda ()
		  (set! m3 (mix-float-vector #r(.1 .2 .3) 1238 ind 0))
		  (set! (sample 1238 ind 0) .8))
		"as-one-edit inner 2")
	       (set! (sample 1239 ind 0) .9)
	       (set! m4 (mix-float-vector #r(.1 .2 .3) 1237 ind 0)))
	     "outer as-one-edit")
	    (if (not (mix? m1)) (snd-display "second as-one-edit stepped on mx1: ~A" m1)))
	  (if (not (mix? m2)) (snd-display "second as-one-edit stepped on mx2: ~A" m2)))
	(if (not (mix? m3)) (snd-display "second as-one-edit stepped on mx3: ~A" m3)))
      (if (not (mix? m4)) (snd-display "second as-one-edit stepped on mx4: ~A" m4))
      (revert-sound ind))
    
    (let ((ind2 #f))
      (as-one-edit
       (lambda ()
	 (set! ind2 (open-sound "pistol.snd"))
	 (set! (sample 100 ind 0) .5)
	 (set! (sample 200 ind2 0) .6))
       "as-one-edit+open")
      (if (not (sound? ind2)) (snd-display "as-one-edit didn't open sound? ~A ~A" ind2 (sounds)))
      (if (not (= (edit-position ind2 0) 1)) (snd-display "edpos as-one-edit opened sound: ~A" (edit-position ind2 0)))
      (if (not (= (edit-position ind 0) 1)) (snd-display "edpos as-one-edit original sound: ~A" (edit-position ind 0)))
      (if (not (equal? (edit-fragment 1 ind 0) '("as-one-edit+open" "set" 100 1)))
	  (snd-display "as-one-edit open sound edlist orig: ~A" (edit-fragment 1 ind 0)))
      (if (not (equal? (edit-fragment 1 ind2 0) '("set-sample 200 0.6000" "set" 200 1)))
	  (snd-display "as-one-edit open sound edlist new: ~A" (edit-fragment 1 ind2 0)))
      
      (as-one-edit
       (lambda ()
	 (set! (sample 200 ind 0) .7)
	 (close-sound ind2))
       "as-one-edit+close")
      (when (sound? ind2) 
	(snd-display "as-one-edit didn't close sound? ~A ~A" ind2 (sounds))
	(close-sound ind2))
      (if (not (= (edit-position ind 0) 2)) (snd-display "edpos as-one-edit close original sound: ~A" (edit-position ind 0)))
      (if (not (string=? (display-edits ind 0) (string-append "
EDITS: 2

 (begin) [0:2]:
   (at 0, cp->sounds[0][0:50827, 1.000]) [file: " cwd "oboe.snd[0]]
   (at 50828, end_mark)

 (set 100 1) ; as-one-edit+open [1:4]:
   (at 0, cp->sounds[0][0:99, 1.000]) [file: " cwd "oboe.snd[0]]
   (at 100, cp->sounds[1][0:0, 1.000]) [buf: 1] 
   (at 101, cp->sounds[0][101:50827, 1.000]) [file: " cwd "oboe.snd[0]]
   (at 50828, end_mark)

 (set 200 1) ; as-one-edit+close [2:6]:
   (at 0, cp->sounds[0][0:99, 1.000]) [file: " cwd "oboe.snd[0]]
   (at 100, cp->sounds[1][0:0, 1.000]) [buf: 1] 
   (at 101, cp->sounds[0][101:199, 1.000]) [file: " cwd "oboe.snd[0]]
   (at 200, cp->sounds[2][0:0, 1.000]) [buf: 1] 
   (at 201, cp->sounds[0][201:50827, 1.000]) [file: " cwd "oboe.snd[0]]
   (at 50828, end_mark)
")))
	  (snd-display "as-one-edit open+close: ~A" (display-edits ind 0))))
    
    (close-sound ind))  
  
  (let ((ind1 (open-sound "oboe.snd"))
	(ind2 #f))
    (as-one-edit 
     (lambda ()
       (set! (sample 100 ind1 0) .5)
       (set! ind2 (open-sound "pistol.snd"))
       (as-one-edit
	(lambda ()
	  (set! (sample 200 ind2 0) .5)
	  (close-sound ind1))
	"inner edit")
       (set! (sample 300 ind2 0) .6))
     "outer edit")
    (if (sound? ind1) (snd-display "as-one-edit close inner: ~A ~A" ind1 (sounds)))
    (if (not (sound? ind2)) (snd-display "as-one-edit open inner: ~A ~A" ind2 (sounds)))
    
    (revert-sound ind2)
    (as-one-edit
     (lambda ()
       (set! ind1 (open-sound "oboe.snd"))
       (as-one-edit
	(lambda ()
	  (set! (sample 200 ind1 0) .5))
	"inner edit")
       (set! (sample 100 ind2 0) .4))
     "outer edit")
    (close-sound ind1)
    (close-sound ind2))
  
  (let ((ind (open-sound "oboe.snd")))
    (let ((tag (catch #t
		 (lambda () (as-one-edit (lambda (oops) #f)))
		 (lambda args (car args)))))
      (if (not (eq? tag 'bad-arity))
	  (snd-display "lambda as-one-edit arg? ~A" tag)))
    (close-sound ind))
  (let ((ind (new-sound  "test.snd" 1 22050 mus-ldouble mus-next "more tests" 10)))
    ;; offset-channel
    (offset-channel .1)
    (if (not (mus-arrays-equal? (channel->float-vector 0 10) (make-float-vector 10 .1)))
	(snd-display "offset-channel (.1): ~A" (channel->float-vector 0 10)))
    (offset-channel -.2 5 5)
    (if (not (mus-arrays-equal? (channel->float-vector 0 10) #r(.1 .1 .1 .1 .1 -.1 -.1 -.1 -.1 -.1)))
	(snd-display "offset-channel (-.1): ~A" (channel->float-vector 0 10)))
    (undo)
    (offset-channel .9 0 10 ind 0)
    (if (not (mus-arrays-equal? (channel->float-vector 0 10) (make-float-vector 10 1.0)))
	(snd-display "offset-channel (1): ~A" (channel->float-vector 0 10)))
    ;; sine-env and sine-ramp...
    (revert-sound ind)
    (map-channel (lambda (y) 1.0))
    (sine-ramp 0.0 1.0)
    (if (not (mus-arrays-equal? (channel->float-vector) #r(0.000 0.024 0.095 0.206 0.345 0.500 0.655 0.794 0.905 0.976)))
	(snd-display "sine-ramp 0 1: ~A" (channel->float-vector)))
    (revert-sound ind)
    (offset-channel 1.0)
    (sine-ramp 1.0 0.0)
    (if (not (mus-arrays-equal? (channel->float-vector) #r(1.000 0.976 0.905 0.794 0.655 0.500 0.345 0.206 0.095 0.024)))
	(snd-display "sine-ramp 1 0: ~A" (channel->float-vector)))
    (close-sound ind))
  (let ((ind (new-sound  "test.snd" 1 22050 mus-ldouble mus-next "sine-env tests" 100)))
    (map-channel (lambda (y) 1.0))
    (sine-env-channel '(0 0 1 1 2 -.5 3 1))
    (if (not (= (edit-position ind 0) 2)) (snd-display "as-one-edit sine-env-channel: ~A" (edit-position ind 0)))
    (revert-sound ind)
    (offset-channel -1.0)
    (sine-env-channel '(0 0 1 1 2 1 3 0) 40 20)
    (if (not (and (mus-arrays-equal? (channel->float-vector 40 20) #r(-0.000 -0.050 -0.188 -0.389 -0.611 -0.812 -0.950 -1.000 -1.000 -1.000
								      -1.000 -1.000 -1.000 -1.000 -1.000 -0.950 -0.812 -0.611 -0.389 -0.188))
		  (mus-arrays-equal? (channel->float-vector 30 10) (make-float-vector 10 -1.0))))
	(snd-display "off+sine-env: ~A ~A" (channel->float-vector 40 20) (channel->float-vector 30 10)))
    (revert-sound ind)
    (scale-by 0.0)
    (dither-channel)
    (let ((mx (maxamp)))
      (if (not (<= 3e-05 mx 0.0001))
	  (snd-display "dithering: ~A" mx)))
    (revert-sound ind)
    (map-channel (ring-mod 10 (list 0 0 1 (hz->radians 100))))
    (osc-formants .99 #r(400.0 800.0 1200.0) #r(400.0 800.0 1200.0) #r(4.0 2.0 3.0))
    (map-channel (zecho .5 .75 6 10.0))
    (map-channel (flecho .5 .9))
    (filtered-env '(0 0 1 1 2 0))
    (map-channel (formant-filter .99 2400))
    (map-channel (comb-filter .8 32))
    (map-channel (zcomb .8 32 '(0 0 1 10)))
    (map-channel (notch-filter .8 32))
    (let ((ind1 (open-sound "now.snd")))
      (select-sound ind1)
      (if (fneq (maxamp) .309) (snd-display "squelch-vowels init: ~A" (maxamp)))
      (squelch-vowels)
      (if (fneq (maxamp) .047) (snd-display "squelch-vowels maxamp: ~A" (maxamp)))
      (select-sound ind)
      (map-channel (cross-synthesis ind1 .5 128 6.0))
      (revert-sound ind1)
      (fft-edit 40 8000)
      (fft-squelch .1)
      (close-sound ind)
      (revert-sound ind1)
      (scramble-channel .01)
      (revert-sound ind1)
      (close-sound ind1)))
  
  (let ((ind (new-sound  "test.snd" 1 22050 mus-ldouble mus-next "special env tests" 100)))
    (map-channel (lambda (y) 1.0))
    
    (blackman4-ramp 0.0 1.0)
    (let ((vals (channel->float-vector)))
      (undo)
      (blackman4-env-channel '(0 0 1 1))
      (let ((new-vals (channel->float-vector)))
	(if (not (mus-arrays-equal? vals new-vals))
	    (snd-display "blackman4-env-channel/ramp: ~A ~A" vals new-vals))))
    (undo)
    (blackman4-ramp 0.0 1.0 0 50)
    (let ((vals (channel->float-vector)))
      (undo)
      (blackman4-env-channel '(0 0 1 1 2 1))
      (let ((new-vals (channel->float-vector)))
	(if (not (mus-arrays-equal? vals new-vals))
	    (snd-display "blackman4-env-channel/ramp 1: ~A ~A" vals new-vals))))
    (undo)
    (blackman4-env-channel '(0 0 1 1 2 -.5 3 0))
    (if (not (mus-arrays-equal? (channel->float-vector 60 10) #r(-0.109 -0.217 -0.313 -0.392 -0.451 -0.488 -0.499 -0.499 -0.499 -0.499)))
	(snd-display "blackman4 to -.5: ~A" (channel->float-vector 60 10)))
    (undo)
      
    (ramp-squared 0.0 1.0)
    (let ((vals (channel->float-vector)))
      (undo)
      (env-squared-channel '(0 0 1 1))
      (let ((new-vals (channel->float-vector)))
	(if (not (mus-arrays-equal? vals new-vals))
	    (snd-display "env-squared/ramp: ~A ~A" vals new-vals))))
    (undo)
    (ramp-squared 0.0 1.0 #t 0 50)
    (let ((vals (channel->float-vector)))
      (undo)
      (env-squared-channel '(0 0 1 1 2 1))
      (let ((new-vals (channel->float-vector)))
	(if (not (mus-arrays-equal? vals new-vals))
	    (snd-display "env-squared/ramp 1: ~A ~A" vals new-vals))))
    (undo)
    (env-squared-channel '(0 0 1 1 2 -.5 3 0))
    (if (not (mus-arrays-equal? (channel->float-vector 60 10) #r(-0.450 -0.466 -0.478 -0.488 -0.494 -0.499 -0.500 -0.500 -0.498 -0.496)))
	(snd-display "env-squared to -.5: ~A" (channel->float-vector 60 10)))
    (undo)
    (env-squared-channel '(0 0 1 1 2 -.5 3 0) #f)
    (if (not (mus-arrays-equal? (channel->float-vector 60 10) #r(-0.004 -0.080 -0.158 -0.240 -0.324 -0.410 -0.500 -0.500 -0.498 -0.496)))
	(snd-display "env-squared unsymmetric to -.5: ~A" (channel->float-vector 60 10)))
    (undo)
      
    (ramp-squared 0.0 1.0)
    (let ((vals (channel->float-vector)))
      (undo)
      (env-expt-channel '(0 0 1 1) 2)
      (let ((new-vals (channel->float-vector)))
	(if (not (mus-arrays-equal? vals new-vals))
	    (snd-display "env-expt2/ramp: ~A ~A" vals new-vals))))
    (undo)
    (env-squared-channel '(0 0 1 1 2 -.5 3 0))
    (let ((vals (channel->float-vector)))
      (undo)
      (env-expt-channel '(0 0 1 1 2 -.5 3 0) 2.0)
      (let ((new-vals (channel->float-vector)))
	(if (not (mus-arrays-equal? vals new-vals))
	    (snd-display "env-expt2/env-squared: ~A ~A" vals new-vals))))
    (undo)
    (env-squared-channel '(0 0 1 1 2 -.5 3 0) #f)
    (let ((vals (channel->float-vector)))
      (undo)
      (env-expt-channel '(0 0 1 1 2 -.5 3 0) 2.0 #f)
      (let ((new-vals (channel->float-vector)))
	(if (not (mus-arrays-equal? vals new-vals))
	    (snd-display "env-expt2/env-squared unsymmetric: ~A ~A" vals new-vals))))
    (undo)
      
    (ramp-expt 0.0 1.0 32.0)
    (let ((vals (channel->float-vector)))
      (undo)
      (env-expt-channel '(0 0 1 1) 32.0)
      (let ((new-vals (channel->float-vector)))
	(if (not (mus-arrays-equal? vals new-vals))
	    (snd-display "env-expt/ramp 32: ~A ~A" vals new-vals))))
    (undo)
    (ramp-expt 0.0 1.0 32.0 #f 0 50)
    (let ((vals (channel->float-vector)))
      (undo)
      (env-expt-channel '(0 0 1 1 2 1) 32.0)
      (let ((new-vals (channel->float-vector)))
	(if (not (mus-arrays-equal? vals new-vals))
	    (snd-display "env-expt/ramp 1 32: ~A ~A" vals new-vals))))
    (undo)
    (ramp-expt 0.0 1.0 .1)
    (let ((vals (channel->float-vector)))
      (undo)
      (env-expt-channel '(0 0 1 1) .1)
      (let ((new-vals (channel->float-vector)))
	(if (not (mus-arrays-equal? vals new-vals))
	    (snd-display "env-expt/ramp .1: ~A ~A" vals new-vals))))
    (undo)
      
    (env-expt-channel '(0 0 1 1 2 -.5 3 0) 12.0)
    (if (not (mus-arrays-equal? (channel->float-vector 30 10) #r(0.319 0.472 0.691 1.000 0.537 0.208 -0.022 -0.182 -0.291 -0.365)))
	(snd-display "env-expt to -.5 12.0: ~A" (channel->float-vector 30 10)))
    (undo)
    (env-expt-channel '(0 0 1 1 2 -.5 3 0) 12.0 #f)
    (if (not (mus-arrays-equal? (channel->float-vector 30 10) #r(0.319 0.472 0.691 1.000 1.000 1.000 1.000 1.000 1.000 1.000)))
	(snd-display "env-expt to -.5 12.0 unsymmetric: ~A" (channel->float-vector 30 10)))
    (undo)
    (close-sound ind))
  
  (let ((ind (new-sound  "test.snd" 1 22050 mus-ldouble mus-next "third ramp re-order tests" 101)))
    (offset-channel 1.0)
    (env-sound '(0 0 1 1))
    (contrast-channel 1.0)
    (let ((reader (make-sampler 0)))
      (do ((i 0 (+ i 1))
	   (val 0.0 (+ val .01)))
	  ((or (= i 100)
	       (let ((y (reader))
		     (ny (sin (+ (* val 0.5 pi) (* 1.0 (sin (* val 2.0 pi)))))))
		 (and (fneq y ny)
		      (or (snd-display "contrast-channel: ~A ~A ~A" val y ny)
			  #t)))))))
    (close-sound ind))
  
  (let ((ind0 (open-sound "oboe.snd"))
	(ind1 (open-sound "pistol.snd")))
    
    (let ((clip (channel-clipped? ind0 0)))
      (if clip (snd-display "channel-clipped? oboe.snd -> ~A" clip)))
    (scale-to 1.5 ind0 0)
    (let ((clip (channel-clipped? ind0 0)))
      (if (not (memv clip '(4502 4503))) (snd-display "channel-clipped after scale: ~A" clip)))
    (revert-sound ind0)
    
    (do ((i 0 (+ i 1))) ((= i 4)) (ramp-channel 0.0 1.0 0 #f ind1 0))
    (make-selection 1000 2000 ind1 0)
    (set! (sync ind0) 1)
    (set! (selected-sound) ind0)
    (env-selection '(0 0 1 1))
    (if (not (and (= (edit-position ind0 0) 0)
		  (= (edit-position ind1 0) 5)))
	(snd-display "selection override of sync field: ~A ~A" (edit-position ind0 0) (edit-position ind1 0)))
    (env-sound '(0 0 1 1 2 0))
    (if (not (and (= (edit-position ind0 0) 1)
		  (= (edit-position ind1 0) 5)))
	(snd-display "sync field over selection: ~A ~A" (edit-position ind0 0) (edit-position ind1 0)))
    
    (close-sound ind1)
    (revert-sound ind0)
    (close-sound ind0))
  
  (let ((s1 (open-sound "oboe.snd")))
    (let ((s2 (copy s1)))
      (if (not (sound? s2))
	  (snd-display "copy sound oboe -> ~A" s2)
	  (begin
	    (if (not (= (srate s1) (srate s2))) (snd-display "copy sounds srates: ~A ~A" (srate s1) (srate s2)))
	    (if (not (= (framples s1) (framples s2))) (snd-display "copy sounds framples: ~A ~A" (framples s1) (framples s2)))
	    (if (not (= (chans s1) (chans s2) 1)) (snd-display "copy sounds chans: ~A ~A" (chans s1) (chans s2)))
	    (let ((d1 (channel->float-vector 0 #f s1))
		  (d2 (channel->float-vector 0 #f s2)))
	      (if (not (mus-arrays-equal? d1 d2))
		  (snd-display "copied sound not equal? ~A?" (float-vector-peak (float-vector-subtract! d0 d1)))))
	    (close-sound s2))))
    (fill! s1 0.0)
    (if (fneq (maxamp s1) 0.0) (snd-display "fill 1 with 0: ~A" (maxamp s1)))
    (fill! s1 0.3)
    (if (fneq (maxamp s1) 0.3) (snd-display "fill 1 with 0.3: ~A" (maxamp s1)))
    (close-sound s1))
  
  (let ((s1 (open-sound "2a.snd")))
    (let ((s2 (copy s1)))
      (if (not (sound? s2))
	  (snd-display "copy sound 2a -> ~A" s2)
	  (begin
	    (if (not (= (srate s1) (srate s2))) (snd-display "copy sounds srates 2: ~A ~A" (srate s1) (srate s2)))
	    (if (not (= (framples s1) (framples s2))) (snd-display "copy sounds framples 2: ~A ~A" (framples s1) (framples s2)))
	    (if (not (= (chans s1) (chans s2) 2)) (snd-display "copy sounds chans 2: ~A ~A" (chans s1) (chans s2)))
	    (let ((d10 (channel->float-vector 0 #f s1 0))
		  (d11 (channel->float-vector 0 #f s1 1))
		  (d20 (channel->float-vector 0 #f s2 0))
		  (d21 (channel->float-vector 0 #f s2 1)))
	      (if (not (mus-arrays-equal? d10 d20))
		  (snd-display "copied sound 2 (0) not equal? ~A?" (float-vector-peak (float-vector-subtract! d10 d20))))
	      (if (not (mus-arrays-equal? d11 d21))
		  (snd-display "copied sound 2 (1) not equal? ~A?" (float-vector-peak (float-vector-subtract! d11 d21)))))
	    (close-sound s2))))
    (fill! s1 0.0)
    (if (fneq (maxamp s1) 0.0) (snd-display "fill 2 with 0: ~A" (maxamp s1)))
    (fill! s1 0.3)
    (if (fneq (maxamp s1) 0.3) (snd-display "fill 2 with 0.3: ~A" (maxamp s1)))
    (close-sound s1))
  
  (for-each close-sound (sounds))
  (unselect-all)
  (let ((snd (open-sound "oboe.snd")))
    (make-selection 1000 2000 snd 0)
    (if (not (selection?)) (snd-display "make-selection for copy failed?"))
    (copy (selection))
    (let ((r1 (channel->float-vector 1000 1000 snd 0)))
      (let* ((snds (sounds))
	     (sel ((if (equal? (car snds) snd) cadr car) snds))
	     (r2 (channel->float-vector 0 1000 sel 0)))
	(if (equal? sel snd)
	    (snd-display "very weird: ~A equal? ~A from ~A (~A ~A ~A)" sel snd snds (car snds) (cadr snds) (equal? (car snds) snd)))
	(if (not (mus-arrays-equal? r1 r2))
	    (snd-display "copied selection not equal? ~A?" (float-vector-peak (float-vector-subtract! r1 r2))))
	(close-sound sel))
      (if (not (selection?))
	  (snd-display "copy selection unselected? ~A" (sounds))
	  (begin
	    (fill! (selection) 0.0)
	    (let ((r1 (float-vector-peak (channel->float-vector 1000 1000 snd 0))))
	      (if (> r1 0.0)
		  (snd-display "fill! selection not 0.0? ~A" r1)))
	    (revert-sound snd)
	    (if (not (selection?))
		(snd-display "revert-sound selection unselected?")
		(begin
		  (fill! (selection) 0.3)
		  (let ((r1 (channel->float-vector 1000 1000 snd 0)))
		    (if (not (and (equivalent? (float-vector-max r1) 0.3)
				  (equivalent? (float-vector-min r1) 0.3)))
			(snd-display "fill! selection not 0.3? ~A ~A" (float-vector-min r1) (float-vector-max r1)))))))))
    (for-each close-sound (sounds)))
  
  (let ((snd (open-sound "oboe.snd")))
    (make-selection 1000 2000 snd 0)
    (if (not (selection?)) 
	(snd-display "make-selection failed?")
	(let ((sel-max (maxamp (selection)))
	      (sel-len (length (selection))))
	  (let ((mx (car (selection->mix))))
	    (if (not (mix? mx))
		(snd-display "selection->mix: ~A" mx)
		(let ((mx-rd (make-mix-sampler mx 0))
		      (snd-rd (make-sampler 1000 snd 0))
		      (orig-rd (make-sampler 1000 snd 0 1 0)))
		  (do ((happy #t)
		       (i 0 (+ i 1)))
		      ((or (not happy) 
			   (= i 1000)))
		    (let ((mx-val (mx-rd))
			  (snd-val (snd-rd))
			  (orig-val (orig-rd)))
		      (when (or (fneq mx-val snd-val)
				(fneq snd-val orig-val))
			(set! happy #f)
			(snd-display "selection->mix at ~A: ~A ~A ~A" (+ i 1000) mx-val snd-val orig-val))))
		  (if (not (= (length mx) sel-len 1001)) (snd-display "selection->mix mix length: ~A (~A)" (length mx) sel-len))
		  (if (fneq (maxamp mx) sel-max) (snd-display "selection->mix maxamps: ~A ~A" (maxamp mx) sel-max)))))))
    (for-each close-sound (sounds)))
  
  (let ((snd (open-sound "2.snd")))
    (set! (sync snd) 1)
    ;; make-selection claims it follows the sync field
    (make-selection 2000 3000 snd)
    (if (not (selection?)) 
	(snd-display "make-selection (2) failed?")
	(let ((sel-max (maxamp (selection)))
	      (sel-len (length (selection)))
	      (sel-chns (channels (selection))))
	  (if (not (= sel-chns 2)) (snd-display "make-selection stereo syncd chans: ~A" sel-chns))
	  (if (not (= sel-len 1001)) (snd-display "make-selection stereo length: ~A" sel-len))
	  (let ((mx-list (selection->mix)))
	    (let ((mx0 (car mx-list))
		  (mx1 (cadr mx-list)))
	      (if (not (and (mix? mx0)
			    (mix? mx1)))
		  (snd-display "selection->mix stereo: ~A ~A" mx0 mx1)
		  (let ((mx0-rd (make-mix-sampler mx0 0))
			(mx1-rd (make-mix-sampler mx1 0))
			(snd0-rd (make-sampler 2000 snd 0))
			(snd1-rd (make-sampler 2000 snd 1))
			(orig0-rd (make-sampler 2000 snd 0 1 0))
			(orig1-rd (make-sampler 2000 snd 1 1 0)))
		    (do ((happy #t)
			 (i 0 (+ i 1)))
			((or (not happy) 
			     (= i 1000)))
		      (let ((mx0-val (mx0-rd))
			    (mx1-val (mx1-rd))
			    (snd0-val (snd0-rd))
			    (snd1-val (snd1-rd))
			    (orig0-val (orig0-rd))
			    (orig1-val (orig1-rd)))
			(when (or (fneq mx0-val snd0-val)
				  (fneq snd0-val orig0-val))
			  (set! happy #f)
			  (snd-display "selection->mix stereo 0 at ~A: ~A ~A ~A" (+ i 2000) mx0-val snd0-val orig0-val))
			(when (or (fneq mx1-val snd1-val)
				  (fneq snd1-val orig1-val))
			  (set! happy #f)
			  (snd-display "selection->mix stereo 1 at ~A: ~A ~A ~A" (+ i 2000) mx1-val snd1-val orig1-val))))))
	      (if (not (= (length mx0) (length mx1) sel-len 1001))
		  (snd-display "selection->mix stereo mix length: ~A ~A (~A)" (length mx0) (length mx1) sel-len))
	      (if (fneq (max (maxamp mx0) (maxamp mx1)) sel-max) 
		  (snd-display "selection->mix stereo maxamps: ~A ~A ~A" (maxamp mx0) (maxamp mx1) sel-max))))))
    (for-each close-sound (sounds)))
  
  (let ((ind (new-sound :size 10)))
    (do ((i 0 (+ i 1)))
	((= i 10))
      (set! (sample i ind 0) (* .1 i)))
    (let* ((rd (make-sampler 3 ind 0))
	   (val (read-sample-with-direction rd 1)))
      (if (fneq val .3) (snd-display "read-sample-with-direction 3: ~A" val))
      (read-sample-with-direction rd -1)
      (set! val (read-sample-with-direction rd -1))
      (if (fneq val .2) (snd-display "read-sample-with-direction 2: ~A" val))
      (set! val (read-sample-with-direction rd -1))
      (if (fneq val .1) (snd-display "read-sample-with-direction 1: ~A" val))
      (close-sound ind)))
  
  (clear-save-state-files))


;;; ---------------- test 6: float-vectors ----------------

(define (snd_test_6)
  (do ((clmtest 0 (+ 1 clmtest))) ((= clmtest tests)) 
    (log-mem clmtest)
    (let ((v0 (make-float-vector 10))
	  (v1 (make-float-vector 10)))
      (if (not (= (length v0) 10)) (snd-display "v0 length = ~D?" (length v0)))
      (fill! v0 1.0)
      (fill! v1 0.5)
      (if (equivalent? v0 v1) (snd-display "float-vector equal? ~A ~A" v0 v1))
      (if (eq? v0 v1) (snd-display "float-vector eq? ~A ~A" v0 v1))
      (if (fneq (float-vector-max v0) 1.0) (snd-display "float-vector max ~A" (float-vector-max v0)))
      (if (fneq (float-vector-min v0) 1.0) (snd-display "float-vector min ~A" (float-vector-min v0)))
      (let ((v3 (make-float-vector 10 0.5))
	    (v4 (make-float-vector 3)))
	(if (not (equivalent? v3 v1)) (snd-display "float-vector not equal? ~A ~A" v3 v1))
	(if (equivalent? v4 v1) (snd-display "len diff float-vector equal? ~A ~A" v4 v1))
	(set! (v3 0) 1.0)
	(if (fneq (v3 0) 1.0) (snd-display "set! float-vector-ref: ~A" (v3 0))))
      (let ((vlst (make-float-vector 3)))
	(set! (vlst 1) .1)
	(if (not (feql (map values vlst) '(0.0 0.1 0.0))) (snd-display "vector->list: ~A?" (map values vlst))))
      (let ((v2 (make-float-vector 4)))
	(do ((i 0 (+ i 1)))
	    ((= i 4))
	  (set! (v2 i) i))
	(float-vector-move! v2 3 2 #t)
	(if (or (fneq (v2 3) 2.0) (fneq (v2 2) 1.0))
	    (snd-display "float-vector-move! back: ~A?" v2)))
      
      (if (not (string=? (float-vector->string (float-vector 1.0 2.0)) "(float-vector 1.000 2.000)")) 
	  (snd-display "float-vector->string: ~A" (float-vector->string (float-vector 1.0 2.0))))
      
      (if (not (mus-arrays-equal? #r(4 3 2 1) (reverse! (float-vector 1 2 3 4)))) (snd-display "float-vector-reverse: ~A" (reverse! (float-vector 1 2 3 4))))
      (if (not (mus-arrays-equal? #r(3 2 1) (reverse! (float-vector 1 2 3)))) (snd-display "float-vector-reverse: ~A" (reverse! (float-vector 1 2 3))))
      (if (not (mus-arrays-equal? #r(2 1) (reverse! (float-vector 1 2)))) (snd-display "float-vector-reverse: ~A" (reverse! (float-vector 1 2))))
      (if (not (mus-arrays-equal? #r(1) (reverse! (float-vector 1)))) (snd-display "float-vector-reverse: ~A" (reverse! (float-vector 1))))
      (if (not (mus-arrays-equal? #r(3 2 1) (reverse #r(1 2 3)))) (snd-display "reverse(float-vector): ~A" (reverse #r(1 2 3))))
      (let* ((v #r(3 2 1))
	     (rv (reverse v)))
	(if (not (mus-arrays-equal? rv #r(1 2 3)))
	    (snd-display "reverse(float-vector) -> ~A ~A" v rv)))
      
      (let ((v0 (make-float-vector 3)))
	(let ((var (catch #t (lambda () (v0 10)) (lambda args args))))
	  (if (not (eq? (car var) 'out-of-range))
	      (snd-display "float-vector-ref high index: ~A" var)))
	(let ((var (catch #t (lambda () (set! (v0 10) 1.0)) (lambda args args))))
	  (if (not (eq? (car var) 'out-of-range))
	      (snd-display "float-vector-set! high index: ~A" var)))
	(let ((var (catch #t (lambda () (float-vector-move! v0 10 0 #t)) (lambda args args))))
	  (if (not (eq? (car var) 'out-of-range))
	      (snd-display "float-vector-move! high index: ~A" var)))
	(let ((var (catch #t (lambda () (float-vector-move! v0 0 10 #t)) (lambda args args))))
	  (if (not (eq? (car var) 'out-of-range))
	      (snd-display "float-vector-move! high 2 index: ~A" var)))
	(let ((var (catch #t (lambda () (float-vector-move! v0 -10 0 #f)) (lambda args args))))
	  (if (not (eq? (car var) 'out-of-range))
	      (snd-display "float-vector-move! back high index: ~A" var)))
	(let ((var (catch #t (lambda () (float-vector-move! v0 0 -10 #f)) (lambda args args))))
	  (if (not (eq? (car var) 'out-of-range))
	      (snd-display "float-vector-move! back high 2 index: ~A" var))))
      
      (let ((v #r(0.0 1.0 -2.0 -3.0)))
	(if (not (mus-arrays-equal? (float-vector-abs! v) #r(0.0 1.0 2.0 3.0)))
	    (snd-display "float-vector-abs! ~A" v)))

      ;; float-vector-add! + subvector:
      (let* ((fv #r(1 2 3 4 5))
	     (sv (subvector fv 4 1)))
	(float-vector-add! sv fv)
	(if (not (mus-arrays-equal? fv #r(1.0 3.0 6.0 10.0 15.0)))
	    (snd-display "float-vector+subvector: ~A" fv)))
      
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(if (fneq (v0 i) 1.0) (snd-display "fill v0[~D] = ~F?" i (v0 i)))
	(if (fneq (v1 i) 0.5) (snd-display "preset v1[~D] = ~F?" i (v1 i))))
      (float-vector-add! v0 v1)
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(if (fneq (v0 i) 1.5) (snd-display "add v0[~D] = ~F?" i (v0 i))))
      (float-vector-subtract! v0 v1)
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(if (fneq (v0 i) 1.0) (snd-display "subtract v0[~D] = ~F?" i (v0 i))))
      (let ((v2 (copy v0)))
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (if (fneq (v2 i) 1.0) (snd-display "copy v0[~D] = ~F?" i (v2 i))))
	(float-vector-scale! v2 5.0)
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (if (fneq (v2 i) 5.0) (snd-display "scale v2[~D] = ~F?" i (v2 i))))
	(float-vector-offset! v0 -1.0)
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (if (fneq (v0 i) 0.0) (snd-display "offset v0[~D] = ~F?" i (v0 i))))
	(float-vector-multiply! v2 v1)
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (if (fneq (v2 i) 2.5) (snd-display "multiply v2[~D] = ~F?" i (v2 i))))
	(if (fneq (float-vector-peak v2) 2.5) (snd-display "v2's peak is ~F?" (float-vector-peak v2)))
	(set! (v2 5) 123.0)
	(if (fneq (float-vector-peak v2) 123.0) (snd-display "v2's set peak is ~F?" (float-vector-peak v2)))
	(let ((vn (make-float-vector 32))
	      (vb (make-float-vector 64))
	      (vs (make-float-vector 3))
	      (vss (make-float-vector 1)))
	  (do ((i 0 (+ i 1)))
	      ((= i 32))
	    (set! (vn i) i))
	  (let ((vnew (float-vector-subseq vn 3)))
	    (if (fneq (vnew 0) 3.0) (snd-display "float-vector-subseq[3:] ~A?" (vnew 0)))
	    (if (not (= (length vnew) 29)) (snd-display "float-vector-subseq[3:] length: ~A?" (length vnew))))
	  (let ((vnew (float-vector-subseq vn 3 8)))
	    (if (fneq (vnew 0) 3.0) (snd-display "float-vector-subseq[3:8] ~A?" (vnew 0)))
	    (if (not (= (length vnew) 6)) (snd-display "float-vector-subseq[3:8] length: ~A?" (length vnew))))
	  (float-vector-subseq vn 3 3 vs)
	  (if (or (fneq (vs 0) 3.0)
		  (fneq (vs 1) 0.0)
		  (fneq (vs 2) 0.0))
	      (snd-display "float-vector-subseq[3:3->vs] ~A?" vs))
	  (float-vector-subseq vn 0 32 vs)
	  (if (not (= (length vs) 3)) (snd-display "float-vector-subseq[0:32->vs] length: ~A?" (length vs)))
	  (float-vector-subseq vn 2 3 vss)
	  (if (fneq (vss 0) 2.0) (snd-display "float-vector-subseq[2:3->vss] ~A?" (vss 0)))
	  (set! (vb 8) 123.0)
	  (float-vector-subseq vn 1 8 vb)
	  (if (fneq (vb 0) 1.0) (snd-display "float-vector-subseq[1:8->vb] ~A?" (vb 0)))
	  (if (fneq (vb 8) 123.0) (snd-display "float-vector-subseq[1:8->vb][8] ~A?" (vb 8))))
	
	(let ((v (make-float-vector 20))
	      (mn 1.0)
	      (mx -1.0))
	  (do ((i 0 (+ i 1)))
	      ((= i 20))
	    (let ((val (mus-random 1.0)))
	      (set! (v i) val)
	      (set! mn (min mn val))
	      (set! mx (max mx val))))
	  (if (fneq (float-vector-min v) mn) (snd-display "float-vector-min ran: ~A ~A" (float-vector-min v) mn))
	  (if (fneq (float-vector-max v) mx) (snd-display "float-vector-max ran: ~A ~A" (float-vector-max v) mx))
	  (if (fneq (float-vector-peak v) (max (abs mn) (abs mx))) (snd-display "float-vector-peak ran: ~A ~A ~A" (float-vector-peak v) mn mx)))
	
	(let ((v1 (make-float-vector 3 .1))
	      (v2 (make-float-vector 4 .2)))
	  (let ((val (float-vector+ (copy v1) v2)))
	    (if (not (mus-arrays-equal? val #r(.3 .3 .3))) (snd-display "float-vector+ .1 .2: ~A" val)))
	  (set! (v1 1) .3)
	  (let ((val (float-vector+ (copy v1) v2)))
	    (if (not (mus-arrays-equal? val #r(.3 .5 .3))) (snd-display "float-vector+ .1 .2 (1): ~A" val)))
	  (let ((val (float-vector+ (copy v1) 2.0)))
	    (if (not (mus-arrays-equal? val #r(2.1 2.3 2.1))) (snd-display "float-vector+ .1 2.0: ~A" val)))
	  (let ((val (float-vector+ 2.0 (copy v1))))
	    (if (not (mus-arrays-equal? val #r(2.1 2.3 2.1))) (snd-display "float-vector+ .1 2.0 (1): ~A" val)))
	  (let ((val (float-vector* 2.0 (copy v1))))
	    (if (not (mus-arrays-equal? val #r(.2 .6 .2))) (snd-display "float-vector* 2.0: ~A" val)))
	  (let ((val (float-vector* (copy v1) 2.0)))
	    (if (not (mus-arrays-equal? val #r(.2 .6 .2))) (snd-display "float-vector* 2.0 (1): ~A" val)))
	  (let ((val (float-vector* (copy v1) v2)))
	    (if (not (mus-arrays-equal? val #r(.02 .06 .02))) (snd-display "float-vector* v1 v2: ~A" val))))
	
	(fill! v0 1.0)
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (if (fneq (v0 i) 1.0) (snd-display "map v0[~D] = ~F?" i (v0 i)))))
      
      (if (fneq (#r(1.0 2.0 3.0) 1) 2.0)
	  (snd-display "(float-vector...) = ~A?" (#r(1.0 2.0 3.0) 1)))
      (let ((v1 #r(1 2 3 4)))
	(if (fneq (v1 1) 2.0)
	    (snd-display "(v1 1) = ~A?" (v1 1))))
      
      (when with-gui
	(let ((ind (open-sound "oboe.snd")))
	  (set! (speed-control ind) .5)
	  (play :wait #t)
	  (apply-controls)
	  (revert-sound)
	  (reset-controls ind)
	  ;; try some special cases
	  (apply-controls)
	  (if (not (= (edit-position ind) 0))
	      (snd-display "apply-controls with no:change: ~A: ~A" (edits ind) (edit-tree ind)))
	  (set! (speed-control ind) -1.0)
	  (apply-controls)
	  (if (not (= (edit-position ind) 1))
	      (snd-display "apply-controls with srate -1.0: ~A ~A ~A" (edit-position ind) (edits ind) (edit-tree ind)))
	  (if (> (abs (- (framples ind 0) (framples ind 0 0))) 2)
	      (snd-display "apply-controls srate -1.0 lengths: ~A ~A" (framples ind 0) (framples ind 0 0)))
	  (if (or (fneq (maxamp) .147)
		  (< (abs (sample 9327)) .01))
	      (snd-display "apply-controls srate -1.0 samples: ~A ~A" (maxamp) (sample 9327)))
	  (if (fneq (speed-control ind) 1.0) (snd-display "apply-controls -1.0 -> ~A?" (speed-control ind)))
	  
	  (hook-push after-apply-controls-hook (lambda (hook) 
						 (let ((tag (catch #t 
							      apply-controls 
							      (lambda args args))))
						   (if (not (eq? (car tag) 'cannot-apply-controls))
						       (snd-display "after-apply-controls-hook: recursive attempt apply-controls: ~A" tag)))))
	  (apply-controls)
	  (set! (hook-functions after-apply-controls-hook) ())
	  (revert-sound)
	  (close-sound ind)))
      
      (let ((tag (catch #t
		   (lambda () (float-vector-subseq (make-float-vector 3) 1 0))
		   (lambda args (car args)))))
	(if (not (eq? tag 'out-of-range))
	    (snd-display "float-vector-subseq 1 0: ~A" tag)))
      (let ((v0 (make-float-vector 5 .1))
	    (v1 (make-float-vector 6 .2)))
	(float-vector-add! v0 v1 2)
	(if (not (mus-arrays-equal? v0 #r(.1 .1 .3 .3 .3)))
	    (snd-display "float-vector-add + offset: ~A" v0)))
      
      ;; check s7 stuff with float-vectors
      (let ((v #r(1.0 2.0 3.0)))
	(if (not (string=? (format #f "~{~A~^-~}" v) "1.0-2.0-3.0"))
	    (snd-display "float-vector in format {}: ~S" (format #f "~{~A~^-~}" v)))
	(if (not (= (length v) 3))
	    (snd-display "float-vector s7 len: ~A" (length v)))
	(let ((val (map floor v)))
	  (if (not (equal? val '(1 2 3)))
	      (snd-display "float-vector s7 map: ~A" val)))
	(let ((val 0))
	  (for-each
	   (lambda (x)
	     (set! val (+ val (floor x))))
	   v)
	  (if (not (eqv? val 6))
	      (snd-display "float-vector s7 for-each: ~A" val)))
	(set! v (reverse v))
	(if (not (vmus-arrays-equal? v #r(3.0 2.0 1.0)))
	    (snd-display "float-vector s7 reverse: ~A" v))
	(fill! v 12.0)
	(if (not (vmus-arrays-equal? v #r(12.0 12.0 12.0)))
	    (snd-display "float-vector s7 fill: ~A" (fill! v 12.0))))
      
      (let ((sum 0)) 
	(for-each (lambda (n) (set! sum (+ sum n))) #r(1 2 3))
	(if (not (equivalent? sum 6.0))
	    (snd-display "object for-each (float-vector): ~A" sum)))
      
      (do ((x #r(0.0))
	   (osc (make-oscil :frequency 440))
	   (e1 (make-env '(0 0 1 1 2 0) :length 100))
	   (i 0 (+ i 1)))
	  ((= i 100))
	(float-vector-set! x 0 (* (env e1) (oscil osc (float-vector-ref x 0)))))
      
      (if (fneq (float-vector-equal? #r(1.0) #r(1.1) .1) .0909)
	  (snd-display "float-vector-equal? 0.0909: ~A" (float-vector-equal? #r(1.0) #r(1.1) .1)))
      (if (float-vector-equal? #r(1.0) #r(1.1) .01)
	  (snd-display "float-vector-equal? #f: ~A" (float-vector-equal? #r(1.0) #r(1.1) .01))))))


;;; ---------------- test 7: colors ----------------

(require snd-rgb.scm)

(define (snd_test_7)
  (when (or (provided? 'snd-gtk)
	    (provided? 'snd-motif))

    (let* ((colormap-error-max 0.0)
	   (cfneq (lambda (a b) (> (abs (- a b)) colormap-error-max)))
	   (old-colormap-size *colormap-size*))
      
      (letrec ((test-color
		(lambda (lst)
		  (if (pair? lst)
		      (let* ((name ((car lst) 0))
			     (getfnc ((car lst) 1))
			     (setfnc (lambda (val) (set! (getfnc) val)))
			     (initval ((car lst) 2)))
			(if (not (color? initval)) (snd-display "~A not color?" initval))
			;; we'll get warnings here if the cell chosen didn't exactly match the one requested -- not a bug
			;; (if (not (equal? (getfnc) initval))
			;;	  (snd-display "~A is not ~A (~A)?" name initval (getfnc)))
			(let ((beige (*rgb* 'beige)))
			  (setfnc beige)
			  (if (not (equal? (getfnc) beige))
			      (snd-display "set-~A is not beige (~A)?" name (getfnc))))
			(setfnc initval)
			(test-color (cdr lst)))))))
	
	(let* ((c1 (catch 'no-such-color
		     (lambda () (make-color 0 0 1))
		     (lambda args #f)))
	       (c2 c1)
	       (c3 (catch 'no-such-color
		     (lambda () (make-color 0 0 1))
		     (lambda args #f))))
	  (if (not (equal? c1 c2)) (snd-display "color not equal? ~A ~A?" c1 c2))
	  (if (not (eq? c1 c2)) (snd-display "color not eq? ~A ~A?" c1 c2))
	  (if (eq? c1 c3) (snd-display "diff color eq? ~A ~A?" c1 c3))
	  (if (not (member (color->list c1) '((0.0 0.0 1.0) (0.0 0.0 1.0 1.0))))
	      (snd-display "color->list: ~A ~A?" c1 (color->list c1))))
	
	(if (not (provided? 'snd-motif))
	    (let* ((c1 (catch 'no-such-color
			 (lambda () (make-color 0 0 1 0.5))
			 (lambda args #f)))
		   (c2 c1)
		   (c3 (catch 'no-such-color
			 (lambda () (make-color 0 0 1 0.5))
			 (lambda args #f))))
	      (if (not (equal? c1 c2)) (snd-display "alpha color not equal? ~A ~A?" c1 c2))
	      (if (not (eq? c1 c2)) (snd-display "alpha color not eq? ~A ~A?" c1 c2))
	      (if (eq? c1 c3) (snd-display "alpha diff color eq? ~A ~A?" c1 c3))
	      (let ((c4 (catch 'no-such-color
			  (lambda () (make-color 0 0 1 0.0))
			  (lambda args #f))))
		(if (equal? c1 c4) (snd-display "alpha color equal? ~A ~A?" c1 c2)))))
	
	(do ((tv (vector '(0.0 0.0 0.0) '(0.0 0.0 0.0) '(0.0 0.0 0.0) '(0.0 1.0 1.0)
			  '(0.0 0.0 7.01915007248035e-4) '(0.0 0.0 0.0) '(0.0 0.0 0.0)
			  '(0.0 0.0 0.49999) '(1.0 0.0 0.0) '(1.0 0.0 0.0) '(0.0 0.0 1.0)
			  '(1.0 0.0 1.0) '(0.0 0.500007629510948 0.4) '(1.0 0.0 0.0)
			  '(1.0 0.0 0.0) '(0.0 0.0 1.0)))
	     (i 0 (+ i 1)))
	    ((not (colormap? (integer->colormap i))))
	  (let ((val (colormap-ref (integer->colormap i) 0))
		(true-val (tv i)))
	    (if (not (feql val true-val))
		(snd-display "colormap-ref ~A: ~A (~A)" i val true-val))))
	(catch #t ; might be undefined var as well as no-such-color
	  (lambda () 
	    (test-color
	     (list
	      (list 'basic-color basic-color ivory2)
	      (list 'cursor-color cursor-color red)
	      (list 'data-color data-color black)
	      (list 'enved-waveform-color enved-waveform-color blue)
	      (list 'filter-control-waveform-color filter-control-waveform-color blue)
	      (list 'graph-color graph-color white)
	      (list 'highlight-color highlight-color ivory1)
	      (list 'listener-color listener-color alice-blue)
	      (list 'listener-text-color listener-text-color black)
	      (list 'mark-color mark-color red)
	      (list 'mix-color mix-color dark-gray)
	      (list 'position-color position-color ivory3)
	      (list 'sash-color sash-color light-green)
	      (list 'selected-data-color selected-data-color black)
	      (list 'selected-graph-color selected-graph-color white)
	      (list 'selection-color selection-color lightsteelblue1)
	      (list 'text-focus-color text-focus-color white)
	      (list 'zoom-color zoom-color ivory4)))
	    
	    (let ((ind (open-sound "oboe.snd")))
	      (set! *selected-data-color* light-green)
	      (set! *data-color* blue)
	      (set! *selected-graph-color* black)
	      (let ((red (make-color-with-catch 1.0 0.0 0.0)))
		(set! (foreground-color ind 0 cursor-context) red)
		(let ((col (color->list (foreground-color ind 0 cursor-context))))
		  (if (not (feql col (color->list red)))
		      (snd-display "set foreground cursor color: ~A ~A" col (color->list red))))
		(set! (foreground-color) blue)
		(let ((col (color->list (foreground-color))))
		  (if (not (feql col (color->list blue)))
		      (snd-display "set foreground-color: ~A ~A" col (color->list blue))))
		(set! (foreground-color ind) red)
		(let ((col (color->list (foreground-color ind))))
		  (if (not (feql col (color->list red)))
		      (snd-display "set foreground-color with ind (red): ~A ~A" col (color->list red))))
		(set! (foreground-color ind) black)
		(let ((col (color->list (foreground-color ind))))
		  (if (not (feql col (color->list black)))
		      (snd-display "set foreground-color with ind (black): ~A ~A" col (color->list black)))))
	      (set! *selected-graph-color* (make-color-with-catch 0.96 0.96 0.86))
	      (set! *data-color* black)
	      (set! *selected-data-color* blue)
	      (set! *graph-color* white)
	      (close-sound ind)))
	  (lambda args args))
	
	(if (not (= (length jet-colormap) *colormap-size*))
	    (snd-display "jet-colormap length: ~A ~A" (length jet-colormap) *colormap-size*))

	(let ((tag (catch #t 
		     (lambda () (colormap-ref jet-colormap))
		     (lambda args (car args)))))
	  (if (not (eq? tag 'wrong-number-of-args)) (snd-display "colormap-ref nil: ~A" tag)))
	(let ((tag (catch #t 
		     (lambda () (jet-colormap))
		     (lambda args (car args)))))
	  (if (not (eq? tag 'wrong-number-of-args)) (snd-display "colormap-apply nil: ~A" tag)))
	(let ((tag (catch #t 
		     jet-colormap
		     (lambda args (car args)))))
	  (if (not (eq? tag 'wrong-type-arg))  ; arg2 to catch not a thunk => wrong type
	      (format *stderr* "colormap-apply nil: ~A" tag)))
	
	(for-each 
	 (lambda (n err)
	   (let ((inv (- 1.0 (/ 1.0 n))))
	     (set! *colormap-size* n)
	     (set! colormap-error-max err)
	     
	     (do ((i 0 (+ i 1))) ((= i 10))
	       (let* ((x (random 1.0))
		      (rgb (colormap-ref bone-colormap x))
		      (rgb1 (bone-colormap x)))
		 (let ((r (if (< x 3/4)
			      (* 7/8 x)
			      (- (* 11/8 x) 3/8)))
		       (g (if (< x 3/8)
			      (* 7/8 x)
			      (if (< x 3/4)
				  (- (* 29/24 x) 1/8)
				  (+ (* 7/8 x) 1/8))))
		       (b (if (< x 3/8)
			      (* 29/24 x)
			      (+ (* 7/8 x) 1/8)))
		       (r1 (rgb 0))
		       (g1 (rgb 1))
		       (b1 (rgb 2))
		       (r2 (rgb1 0))
		       (g2 (rgb1 1))
		       (b2 (rgb1 2)))
		   (if (and (< x inv) 
			    (or (cfneq r r1) 
				(cfneq g g1) 
				(cfneq b b1)
				(cfneq r2 r1) 
				(cfneq g2 g1) 
				(cfneq b2 b1)))
		       (snd-display "bone ~,3F (~,3F): ~{~,3F ~} ~{~,3F ~}" 
				    x (max (abs (- r r1)) (abs (- g g1)) (abs (- b b1))) (list r g b) (list r1 g1 b1))))))
	     
	     (do ((i 0 (+ i 1))) ((= i 10))
	       (let* ((x (random 1.0))
		      (rgb (colormap-ref copper-colormap x)))
		 (let ((r (if (< x 4/5)
			      (* 5/4 x)
			      1.0))
		       (g (* 4/5 x))
		       (b (* 1/2 x))
		       (r1 (rgb 0))
		       (g1 (rgb 1))
		       (b1 (rgb 2)))
		   (if (and (< x inv) (or (cfneq r r1) (cfneq g g1) (cfneq b b1)))
		       (snd-display "copper ~,3F (~,3F): ~{~,3F ~} ~{~,3F ~}" 
				    x (max (abs (- r r1)) (abs (- g g1)) (abs (- b b1))) (list r g b) (list r1 g1 b1))))))
	     
	     (do ((i 0 (+ i 1))) ((= i 10))
	       (let* ((x (random 1.0))
		      (rgb (colormap-ref winter-colormap x)))
		 (let ((r 0.0)
		       (b (- 1.0 (/ x 2.0)))
		       (r1 (rgb 0))
		       (g1 (rgb 1))
		       (b1 (rgb 2)))
		   (if (and (< x inv) (or (cfneq r r1) (cfneq x g1) (cfneq b b1)))
		       (snd-display "winter ~,3F (~,3F): ~{~,3F ~} ~{~,3F ~}" 
				    x (max (abs (- r r1)) (abs (- x g1)) (abs (- b b1))) (list r x b) (list r1 g1 b1))))))
	     
	     (do ((i 0 (+ i 1))) ((= i 10))
	       (let* ((x (random 1.0))
		      (rgb (colormap-ref autumn-colormap x)))
		 (let ((r 1.0)
		       (b 0.0)
		       (r1 (rgb 0))
		       (g1 (rgb 1))
		       (b1 (rgb 2)))
		   (if (and (< x inv) (or (cfneq r r1) (cfneq x g1) (cfneq b b1)))
		       (snd-display "autumn ~,3F (~,3F): ~{~,3F ~} ~{~,3F ~}" 
				    x (max (abs (- r r1)) (abs (- x g1)) (abs (- b b1))) (list r x b) (list r1 g1 b1))))))
	     
	     (do ((i 0 (+ i 1))) ((= i 10))
	       (let* ((x (random 1.0))
		      (rgb (colormap-ref cool-colormap x)))
		 (let ((g (- 1.0 x))
		       (b 1.0)	     
		       (r1 (rgb 0))
		       (g1 (rgb 1))
		       (b1 (rgb 2)))
		   (if (and (< x inv) (or (cfneq x r1) (cfneq g g1) (cfneq b b1)))
		       (snd-display "cool ~,3F (~,3F): ~{~,3F ~} ~{~,3F ~}" 
				    x (max (abs (- x r1)) (abs (- g g1)) (abs (- b b1))) (list x g b) (list r1 g1 b1))))))
	     
	     (do ((i 0 (+ i 1))) ((= i 10))
	       (let* ((x (random 1.0))
		      (rgb (colormap-ref hot-colormap x)))
		 (let ((r (if (< x 3/8)
			      (* 8/3 x)
			      1.0))
		       (g (if (< x 3/8)
			      0.0
			      (if (< x 3/4)
				  (- (* 8/3 x) 1.0)
				  1.0)))
		       (b (if (< x 3/4)
			      0.0
			      (- (* 4 x) 3)))
		       (r1 (rgb 0))
		       (g1 (rgb 1))
		       (b1 (rgb 2)))
		   (if (and (< x inv) (or (cfneq r r1) (cfneq g g1) (cfneq b b1)))
		       (snd-display "hot ~,3F (~,3F): ~{~,3F ~} ~{~,3F ~}" 
				    x (max (abs (- r r1)) (abs (- g g1)) (abs (- b b1))) (list r g b) (list r1 g1 b1))))))
	     
	     (do ((i 0 (+ i 1))) ((= i 10))
	       (let* ((x (random 1.0))
		      (rgb (colormap-ref jet-colormap x)))
		 (let ((r (cond ((< x 3/8) 0.0)
				((< x 5/8) (- (* 4 x) 3/2))
				((< x 7/8) 1.0)
				(else      (+ (* -4 x) 9/2))))
		       (g (cond ((< x 1/8) 0.0)
				((< x 3/8) (- (* 4 x) 1/2))
				((< x 5/8) 1.0)
				((< x 7/8) (+ (* -4 x) 7/2))
				(else      0.0)))
		       (b (cond ((< x 1/8) (+ (* 4 x) 1/2))
				((< x 3/8) 1.0)
				((< x 5/8) (+ (* -4 x) 5/2))
				(else      0.0)))
		       (r1 (rgb 0))
		       (g1 (rgb 1))
		       (b1 (rgb 2)))
		   (if (and (< x inv) (or (cfneq r r1) (cfneq g g1) (cfneq b b1)))
		       (snd-display "jet ~,3F (~,3F): ~{~,3F ~} ~{~,3F ~}" 
				    x (max (abs (- r r1)) (abs (- g g1)) (abs (- b b1))) (list r g b) (list r1 g1 b1))))))
	     
	     (when (colormap? pink-colormap)
	       (do ((i 0 (+ i 1))) ((= i 10))
		 (let* ((x (random 1.0))
			(rgb (colormap-ref pink-colormap x)))
		   (let ((r (if (< x 3/8)
				(* 14/9 x)
				(+ (* 2/3 x) 1/3)))
			 (g (if (< x 3/8)
				(* 2/3 x)
				(if (< x 3/4)
				    (- (* 14/9 x) 1/3)
				    (+ (* 2/3 x) 1/3))))			
			 (b (if (< x 3/4)
				(* 2/3 x)
				(- (* 2 x) 1)))
			 (r1 (rgb 0))
			 (g1 (rgb 1))
			 (b1 (rgb 2)))
		     (if (and (< x inv) (or (cfneq r r1) (cfneq g g1) (cfneq b b1)))
			 (snd-display "pink ~,3F (~,3F): ~{~,3F ~} ~{~,3F ~}" 
				      x (max (abs (- r r1)) (abs (- g g1)) (abs (- b b1))) (list r g b) (list r1 g1 b1)))))))
	     
	     (do ((i 0 (+ i 1))) ((= i 10))
	       (let* ((x (random 1.0))
		      (rgb (colormap-ref spring-colormap x)))
		 (let ((r 1.0)
		       (b (- 1.0 x))
		       (r1 (rgb 0))
		       (g1 (rgb 1))
		       (b1 (rgb 2)))
		   (if (and (< x inv) (or (cfneq r r1) (cfneq x g1) (cfneq b b1)))
		       (snd-display "spring ~,3F (~,3F): ~{~,3F ~} ~{~,3F ~}" 
				    x (max (abs (- r r1)) (abs (- x g1)) (abs (- b b1))) (list r x b) (list r1 g1 b1))))))
	     
	     (do ((i 0 (+ i 1))) ((= i 10))
	       (let* ((x (random 1.0))
		      (rgb (colormap-ref gray-colormap x)))
		 (let ((r1 (rgb 0))
		       (g1 (rgb 1))
		       (b1 (rgb 2)))
		   (if (and (< x inv) (or (cfneq x r1) (cfneq x g1) (cfneq x b1)))
		       (snd-display "gray ~,3F (~,3F): ~{~,3F ~} ~{~,3F ~}" 
				    x (max (abs (- x r1)) (abs (- x g1)) (abs (- x b1))) (list x x x) (list r1 g1 b1))))))
	     
	     (do ((i 0 (+ i 1))) ((= i 10))
	       (let* ((x (random 1.0))
		      (rgb (colormap-ref black-and-white-colormap x)))
		 (let ((r 0.0)
		       (g 0.0)
		       (b 0.0)
		       (r1 (rgb 0))
		       (g1 (rgb 1))
		       (b1 (rgb 2)))
		   (if (and (< x inv) (or (cfneq r r1) (cfneq g g1) (cfneq b b1)))
		       (snd-display "black-and-white ~,3F (~,3F): ~{~,3F ~} ~{~,3F ~}" 
				    x (max (abs (- r r1)) (abs (- g g1)) (abs (- b b1))) (list r g b) (list r1 g1 b1))))))
	     
	     (do ((i 0 (+ i 1))) ((= i 10))
	       (let* ((x (random 1.0))
		      (rgb (colormap-ref summer-colormap x)))
		 (let ((g (+ 0.5 (/ x 2)))
		       (b 0.4)
		       (r1 (rgb 0))
		       (g1 (rgb 1))
		       (b1 (rgb 2)))
		   (if (and (< x inv) (or (cfneq x r1) (cfneq g g1) (cfneq b b1)))
		       (snd-display "summer ~,3F (~,3F): ~{~,3F ~} ~{~,3F ~}" 
				    x (max (abs (- x r1)) (abs (- g g1)) (abs (- b b1))) (list x g b) (list r1 g1 b1))))))
	     
	     (do ((i 0 (+ i 1))) ((= i 10))
	       (let* ((x (random 1.0))
		      (rgb (colormap-ref rainbow-colormap x)))
		 (let ((r (cond ((< x 2/5) 1.0)
				((< x 3/5) (+ (* -5 x) 3))
				((< x 4/5) 0.0)
				(else (- (* 10/3 x) 8/3))))
		       (g (cond ((< x 2/5) (* 5/2 x))
				((< x 3/5) 1.0)
				((< x 4/5) (+ (* -5 x) 4))
				(else 0.0)))
		       (b (cond ((< x 3/5) 0.0)
				((< x 4/5) (- (* 5 x) 3))
				(else 1.0)))
		       (r1 (rgb 0))
		       (g1 (rgb 1))
		       (b1 (rgb 2)))
		   (if (and (< x inv) (or (cfneq r r1) (cfneq g g1) (cfneq b b1)))
		       (snd-display "rainbow ~,3F (~,3F): ~{~,3F ~} ~{~,3F ~}" 
				    x (max (abs (- r r1)) (abs (- g g1)) (abs (- b b1))) (list r g b) (list r1 g1 b1))))))
	     
	     (do ((i 0 (+ i 1))) ((= i 10))
	       (let* ((x (random 1.0))
		      (rgb (colormap-ref prism-colormap x)))
		 (if (not (or (>= x inv)
			      (feql rgb '(1 0 0))
			      (feql rgb '(1 0.5 0))
			      (feql rgb '(1 1 0))
			      (feql rgb '(0 1 0))
			      (feql rgb '(0 0 1))
			      (feql rgb '(0.66670000 0 1))))
		     (snd-display "prism ~A" rgb))))
	     
	     (do ((i 0 (+ i 1))) ((= i 10))
	       (let* ((x (random 1.0))
		      (rgb (colormap-ref flag-colormap x)))
		 (if (not (or (>= x inv)
			      (feql rgb '(1 0 0))
			      (feql rgb '(1 1 1))
			      (feql rgb '(0 0 1))
			      (feql rgb '(0 0 0))))
		     (snd-display "flag: ~A" rgb))))
	     ))
	 '(512 64)
	 '(0.005 0.04))
	
	(let ((ind (add-colormap "white" (lambda (size) (list (make-float-vector size 1.0) (make-float-vector size 1.0) (make-float-vector size 1.0))))))
	  (if (not (colormap? ind))
	      (snd-display "add-colormap ~A: ~A" ind (colormap? ind)))
	  (if (not (feql (colormap-ref ind 0.5) '(1.0 1.0 1.0)))
	      (snd-display "white colormap: ~A" (colormap-ref ind 0.5)))
	  (let ((tag (catch #t (lambda () (set! *colormap* ind)) (lambda args args))))
	    (if (or (eq? tag 'no-such-colormap)
		    (not (equal? *colormap* ind))
		    (not (= (colormap->integer *colormap*) (colormap->integer ind))))
		(snd-display "colormap white: ~A ~A ~A" tag ind *colormap*)))
	  (if (not (string=? (colormap-name ind) "white"))
	      (snd-display "white colormap name: ~A" (colormap-name ind))))
	
	(set! *colormap-size* old-colormap-size)
	(if (not (= *colormap-size* old-colormap-size))
	    (snd-display "set colormap-size: ~A ~A" *colormap-size* old-colormap-size))
	
	(if (not (string=? (colormap-name black-and-white-colormap) "black-and-white"))
	    (snd-display "black-and-white: ~A" (colormap-name black-and-white-colormap)))
	(if (not (string=? (colormap-name gray-colormap) "gray"))
	    (snd-display "gray: ~A" (colormap-name gray-colormap)))
	(if (not (string=? (colormap-name rainbow-colormap) "rainbow"))
	    (snd-display "rainbow: ~A" (colormap-name rainbow-colormap)))
	
	(add-colormap "purple" 
		      (lambda (size) 
			(do ((r (make-float-vector size))
			     (g (make-float-vector size))
			     (b (make-float-vector size))
			     (incr (/ 256.0 size))
			     (er (list 0 60 60 116 128 252 192 252 256 60))
			     (eg (list 0 0  64 0   128 252 192 252 256 0))
			     (eb (list 0 80        128 252 192 0   256 80))
			     (i 0 (+ i 1))
			     (x 0.0))
			    ((= i size)
			     (list r g b))			     
			  (set! (r i) (/ (envelope-interp x er) 256.0))
			  (set! (g i) (/ (envelope-interp x eg) 256.0))
			  (set! (b i) (/ (envelope-interp x eb) 256.0))
			  (set! x (+ x incr)))))

	(add-colormap "sin" 
		      (lambda (size) 
			(do ((r (make-float-vector size))
			     (g (make-float-vector size))
			     (b (make-float-vector size))
			     (incr (/ (* 2 pi) size))
			     (i 0 (+ i 1))
			     (x 0.0))
			    ((= i size)
			     (list r g b))     
			  (set! (r i) (abs (sin (* 1.5 x))))
			  (set! (g i) (abs (sin (* 3.5 x))))
			  (set! (b i) (abs (sin (* 2.5 x))))
			  (set! x (+ x incr)))))

	(add-colormap "another-sin" 
		      (lambda (size) 
			(do ((r (make-float-vector size))
			     (g (make-float-vector size))
			     (b (make-float-vector size))
			     (incr (/ (* 2 pi) size))
			     (i 0 (+ i 1))
			     (x 0.0))
			    ((= i size)
			     (list r g b))     
			  (set! (r i) (abs (sin (* 2.5 x))))
			  (set! (g i) (abs (sin (* 3.5 x))))
			  (set! (b i) (abs (sin (* 4.5 x))))
			  (set! x (+ x incr)))))
	
	(delete-colormap pink-colormap)
	(if (colormap? pink-colormap)
	    (snd-display "delete-colormap ~A: ~A" pink-colormap (colormap? pink-colormap)))
	(let ((tag (catch #t (lambda () (set! *colormap* pink-colormap)) (lambda args args))))
	  (if (or (not (eq? (car tag) 'no-such-colormap))
		  (equal? *colormap* pink-colormap))
	      (snd-display "delete pink colormap: ~A ~A ~A" tag pink-colormap *colormap*)))
	
	(for-each
	 (lambda (n)
	   (set! *colormap-size* n)
	   (do ((n2 (> n 2))
		(n/n (- 1.0 (/ 1.0 n)))
		(i 0 (+ i 1))) 
	       ((= i 10))
	     (let* ((x (random 1.0))
		    (rgb (colormap-ref copper-colormap x)))
	       (let ((r (if (< x 4/5) (* 5/4 x) 1.0))
		     (g (* 4/5 x))
		     (b (* 1/2 x))
		     (r1 (rgb 0))
		     (g1 (rgb 1))
		     (b1 (rgb 2)))
		 (if (and n2 (< x n/n) (or (cfneq r r1) (cfneq g g1) (cfneq b b1)))
		     (snd-display "copper size reset ~A: ~,3F (~,3F): ~{~,3F ~} ~{~,3F ~}" 
				  n x (max (abs (- r r1)) (abs (- g g1)) (abs (- b b1))) (list r g b) (list r1 g1 b1)))))))
	 '(1024 256 2 512))
	(set! *colormap-size* 512)
	
	(set! (hook-functions graph-hook) ())))))


;;; ---------------- test 8: clm ----------------

(require snd-moog.scm snd-poly.scm snd-bird.scm snd-v.scm snd-numerics.scm snd-generators.scm)
(if (defined? 'gsl-roots) (require snd-analog-filter.scm))

;;; -------- scissor-tailed flycatcher
;;;
;;; mix a scissor-tailed flycatcher call into the current sound
;;; see bird.scm for lots more birds


(define scissor 
  (let ((+documentation+ "(scissor beg) is the scissor-tailed flycatcher"))
    (lambda (begin-time) ; test 23 also
      (bigbird begin-time 0.05 1800 1800 .2 
	       '(0 0  40 1  60 1  100 0)
	       '(0 0  25 1  75 1  100 0) 
	       '(1 .5  2 1  3 .5  4 .1  5 .01)))))

(define (snd_test_8)

  (define (copy-test o)
    (let ((p (copy o)))
      (if (not (equal? o p))
	  (snd-display "copy ~A != ~A~%" o p))
      (mus-apply o 1.0)
      (if (equal? o p)
	  (snd-display "copy/run ~A == ~A~%" o p))
      (set! p (mus-copy o))
      (if (not (equal? o p))
	  (snd-display "mus-copy ~A != ~A~%" o p))))
  
  ;; ----------------
  (define array-interp-sound-diff 
    (let ((envelope->float-vector 
	   (lambda (e len)
	     (do ((v (make-float-vector len))
		  (e (make-env e :length len))
		  (i 0 (+ i 1)))
		 ((= i len) v)
	       (set! (v i) (env e))))))
      (lambda* (snd chn)
	(let ((tbl (envelope->float-vector '(0.0 -1.0 1.0 1.0) 1001))
	      (curpos (edit-position snd chn)))
	  (map-channel (lambda (y)
			 (array-interp tbl (+ 500.0 (* y 500)) 1000))
		       0 #f snd chn)
	  
	  (let ((r (make-sampler 0 snd chn 1 curpos))
		(mx 0.0))
	    (scan-channel (lambda (y) 
			    (set! mx (max mx (abs (- y (next-sample r))))))
			  0 #f snd chn)
	    mx)))))
  
  ;; ----------------
  (define make-papoulis-window 
    (let ((+documentation+ "(make-papoulis-window size) returns a papoulis window os the given size"))
      (lambda (n)
	(let ((v (make-float-vector n))
	      (n2 (/ n 2)))
	  (do ((i (- n2) (+ i 1)))
	      ((= i n2))
	    (let* ((ratio (/ i n))
		   (pratio (* 2 pi ratio)))
	      (set! (v (+ i n2)) (+ (/ (abs (sin pratio)) pi)
				    (* (- 1.0 (* 2 (abs ratio)))
				       (cos pratio))))))
	  v))))
      
  ;; ----------------
  (define make-dpss-window 
    (let ((+documentation+ "(make-dpss-window size w) returns a prolate spheriodal (slepian) window of the given size"))
      ;; from Verma, Bilbao, Meng, "The Digital Prolate Spheroidal Window"
      ;; output checked using Julius Smith's dpssw.m, although my "w" is different
      (lambda (n w)
	(let ((mat (make-float-vector (list n n)))
	      (cw (cos (* 2 pi w))))
	  (do ((n-1 (- n 1))
	       (n/2 (* 0.5 (- n 1)))
	       (i 0 (+ i 1)))
	      ((= i n))
	    (let ((n2 (- n/2 i)))
	      (set! (mat i i) (* cw n2 n2))
	      (if (< i n-1)
		  (set! (mat i (+ i 1)) (* 0.5 (+ i 1) (- n-1 i))))
	      (if (> i 0)
		  (set! (mat i (- i 1)) (* 0.5 i (- n i))))))
	  (let ((v (let ((vc (vector-ref (cadr (gsl-eigenvectors mat)) 0))) ; cadr->vector of fv-vectors
		     (copy vc (make-float-vector (length vc)))))
		(pk 0.0))
	    ;; sign of eigenvalue is arbitrary, and eigenvector is scaled to sum to 1.0
	    ;;   but we want peak of 1.0 to serve as fft window
	    (do ((i 0 (+ i 1)))
		((= i n))
	      (if (> (abs (v i)) (abs pk))
		  (set! pk (v i)))) 
	    (float-vector-scale! v (/ 1.0 pk)))))))
  
  ;; ----------------
  (define test-lpc
    (let ((make-sine 
	   (lambda* ((n 16))
	     (do ((data (make-float-vector n))
		  (incr (/ (* 2.0 pi) n))
		  (i 0 (+ i 1))
		  (x 0.0))
		 ((= i n) data) 
	       (set! (data i) (sin x))
	       (set! x (+ x incr)))))
	  
	  (make-sines 
	   (lambda (n) 
	     (do ((data (make-float-vector n))
		  (incr (/ (* 2.0 pi) n))
		  (i 0 (+ i 1))
		  (x 0.0))
		 ((= i n) data) 
	       (set! (data i) (+ (sin x)
				 (* .25 (sin (* 2.0 x)))
				 (* .125 (sin (* 4.0 x)))))
	       (set! x (+ x incr))))))
      (lambda ()
	(let ((vals (lpc-predict #r(0 1 2 3 4 5 6 7) 8 (lpc-coeffs #r(0 1 2 3 4 5 6 7) 8 4) 4 2)))
	  (if (not (mus-arrays-equal? vals #r(7.906 8.557)))
	      (snd-display "predict ramp: ~A" vals)))
	(let ((vals (lpc-predict #r(0 1 2 3 4 5 6 7) 8 (lpc-coeffs #r(0 1 2 3 4 5 6 7) 8 7) 7 2)))
	  (if (not (mus-arrays-equal? vals #r(7.971 8.816))) 
	      (snd-display "predict ramp 1: ~A" vals)))
	(let ((vals (lpc-predict #r(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14) 15 
				 (lpc-coeffs #r(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14) 15 7) 7 5)))
	  (if (not (mus-arrays-equal? vals #r(14.999 15.995 16.980 17.940 18.851)))
	      (snd-display "predict ramp 2: ~A" vals)))
	(let ((vals (lpc-predict #r(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14) 15 
				 (lpc-coeffs #r(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14) 15 14) 14 5)))
	  (if (not (mus-arrays-equal? vals #r(15.000 16.000 16.998 17.991 18.971)))
	      (snd-display "predict ramp 3: ~A" vals)))
	(let ((vals (lpc-predict (make-sine) 16 (lpc-coeffs (make-sine) 16 8) 8 2)))
	  (if (not (mus-arrays-equal? vals #r(0.000 0.383)))
	      (snd-display "predict sine: ~A" vals)))
	(let ((vals (lpc-predict (make-sine) 16 (lpc-coeffs (make-sine) 16 8) 8 8)))
	  (if (not (mus-arrays-equal? vals #r(0.000 0.383 0.707 0.924 1.000 0.924 0.707 0.383)))
	      (snd-display "predict sine 1: ~A" vals)))
	(let ((vals (lpc-predict (make-sines 32) 32 (lpc-coeffs (make-sines 32) 32 8) 8 8)))
	  (if (not (mus-arrays-equal? vals #r(0.000 0.379 0.686 0.880 0.970 1.001 1.022 1.053)))
	      (snd-display "predict sines: ~A" vals)))
	(let ((vals (lpc-predict (make-sines 32) 32 (lpc-coeffs (make-sines 32) 32 16) 16 8)))
	  (if (not (or (mus-arrays-equal? vals #r(0.000 0.379 0.684 0.876 0.961 0.987 1.006 1.046))
		       (mus-arrays-equal? vals #r(0.000 0.379 0.685 0.876 0.961 0.985 0.998 1.029))))
	      (snd-display "predict sines 1: ~A" vals)))
	(let ((vals (lpc-predict (make-sines 32) 32 (lpc-coeffs (make-sines 32) 32 30) 30 4)))
	  (if (not (or (mus-arrays-equal? vals #r(0.000 0.379 0.685 0.878))
		       (mus-arrays-equal? vals #r(0.000 0.379 0.684 0.875)))) ; double float-vectors
	      (snd-display "predict sines 2: ~A" vals)))
	(let ((vals (lpc-predict (make-sines 64) 64 (lpc-coeffs (make-sines 64) 64 32) 32 8)))
	  (if (not (mus-arrays-equal? vals #r(0.000 0.195 0.379 0.545 0.684 0.795 0.875 0.927)))
	      (snd-display "predict sines 3: ~A" vals))))))
  
  ;; ----------------
  (define (test-unclip-channel)
    (let ((ind (new-sound "test.snd" 2 22050 mus-lfloat mus-next "unclip-channel test" 1)))
      (set! (sync ind) 1)
      
      (mix "oboe.snd" 0 0 ind 0 #f)
      (mix "oboe.snd" 0 0 ind 1 #f)
      (let ((scl (/ 1.01 (maxamp ind 0)))
	    (dur (framples ind 0)))
	(scale-channel scl 0 dur ind 0)
	(scale-channel scl 0 dur ind 1))
      
      (let* ((vals (unclip-channel ind 1))
	     (umax (vals 1))
	     (clips (vals 3))
	     (lmax (vals 5)))
	(if (not (= clips 20)) (snd-display "unclip-channel 0 oboe clips: ~A" clips))
	(if (not (= lmax 1)) (snd-display "unclip-channel 0 oboe max len: ~A" lmax))
	(if (fneq umax .999) (snd-display "unclip-channel 0 oboe maxamp: ~A" umax)))
      
      (revert-sound ind)
      (do ((data (make-float-vector 100))
	   (e (make-env '(0 0 1 .8 1.5 1.0 2.0 1.0 2.5 .8 3.5 0) :length 101))
	   (o (make-oscil 1000))
	   (i 0 (+ i 1))) 
	  ((= i 100)
	   (float-vector->channel data 0 100 ind 0)
	   (float-vector->channel data 0 100 ind 1))
	(set! (data i) (* 1.05 (env e) (oscil o))))
      
      (let* ((vals (unclip-channel ind 1))
	     (umax (vals 1))
	     (clips (vals 3))
	     (lmax (vals 5)))
	(if (not (= clips 1)) (snd-display "unclip-channel 1 sine clips: ~A" clips))
	(if (not (= lmax 2)) (snd-display "unclip-channel 1 sine max len: ~A" lmax))
	(if (fneq umax .999) (snd-display "unclip-channel 1 sine maxamp: ~A" umax)))
      
      (revert-sound ind)
      (do ((data (make-float-vector 100))
	   (e (make-env '(0 0 1 .8 1.75 1.0 2.0 1.0 2.25 .8 3.5 0) :length 101))
	   (o (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((= i 100)
	   (float-vector->channel data 0 100 ind 0)
	   (float-vector->channel data 0 100 ind 1))
	(set! (data i) (* 1.1 (env e) (oscil o))))
      
      (let* ((vals (unclip-channel ind 1))
	     (umax (vals 1))
	     (clips (vals 3))
	     (lmax (vals 5)))
	(if (not (= clips 1)) (snd-display "unclip-channel 2 sine clips: ~A" clips))
	(if (not (= lmax 3)) (snd-display "unclip-channel 2 sine max len: ~A" lmax))
	(if (fneq umax .999) (snd-display "unclip-channel 2 sine maxamp: ~A" umax)))
      
      (revert-sound ind)
      (do ((data (make-float-vector 100))
	   (e (make-env '(0 0 1 .8 1.85 1.0 2.0 1.0 2.15 .8 3.5 0) :length 101))
	   (o1 (make-oscil 1000))
	   (o2 (make-oscil 2000))
	   (i 0 (+ i 1))) 
	    ((= i 100)
	     (float-vector->channel data 0 100 ind 0)
	     (float-vector->channel data 0 100 ind 1))
	(set! (data i) (* 1.2 (env e) (+ (* .75 (oscil o1)) (* .25 (oscil o2))))))
      
      (let* ((vals (unclip-channel ind 1))
	     (umax (vals 1))
	     (clips (vals 3))
	     (lmax (vals 5)))
	(if (not (= clips 1)) (snd-display "unclip-channel 3 sine clips: ~A" clips))
	(if (not (= lmax 1)) (snd-display "unclip-channel 3 sine max len: ~A" lmax))
	(if (fneq umax .999) (snd-display "unclip-channel 3 sine maxamp: ~A" umax)))
      
      (revert-sound ind)
      (do ((data (make-float-vector 100))
	   (e (make-env '(0 0 40 .75 45 1.0 50 1.25 55 1.0 60 .75 100 0.0) :length 101))
	   (o1 (make-oscil 1000))
	   (o2 (make-oscil 2000))
	   (i 0 (+ i 1))) 
	  ((= i 100)
	   (float-vector->channel data 0 100 ind 0)
	   (float-vector->channel data 0 100 ind 1))
	(set! (data i) (* 1.5 (env e) (+ (* .75 (oscil o1)) (* .25 (oscil o2))))))
      
      (let* ((vals (unclip-channel ind 1))
	     (umax (vals 1))
	     (clips (vals 3))
	     (lmax (vals 5)))
	(if (not (= clips 1)) (snd-display "unclip-channel 4 sine clips: ~A" clips))
	(if (not (= lmax 4)) (snd-display "unclip-channel 4 sine max len: ~A" lmax))
	(if (fneq umax .999) (snd-display "unclip-channel 4 sine maxamp: ~A" umax)))
      
      (revert-sound ind)
      (let ((data (make-float-vector 100))
	    (o1 (make-oscil 1000)))
	(do ((i 0 (+ i 1))) 
	    ((= i 100)) 
	  (set! (data i) (* .25 (oscil o1))))
	(let ((true-max (float-vector-peak data)))
	  (set! (data 50) (+ (data 50) 1.25))
	  (float-vector->channel data 0 100 ind 0)
	  (float-vector->channel data 0 100 ind 1)
	  
	  (let* ((vals (unclip-channel ind 1))
		 (umax (vals 1))
		 (clips (vals 3))
		 (lmax (vals 5)))
	    (if (not (= clips 1)) (snd-display "unclip-channel 5 click clips: ~A" clips))
	    (if (not (= lmax 1)) (snd-display "unclip-channel 5 click max len: ~A" lmax))
	    (if (fneq umax true-max) (snd-display "unclip-channel 5 click maxamp: ~A ~A" umax true-max)))))
      
      (revert-sound ind)
      (let ((data (make-float-vector 100))
	    (o1 (make-oscil 1000)))
	(do ((i 0 (+ i 1))) 
	    ((= i 100)) 
	  (set! (data i) (* .25 (oscil o1))))
	(let ((true-max (float-vector-peak data)))
	  (do ((i 49 (+ i 1)))
	      ((= i 51))
	    (set! (data i) (+ (data i) 1.25)))
	  (float-vector->channel data 0 100 ind 0)
	  (float-vector->channel data 0 100 ind 1)
	  
	  (let* ((vals (unclip-channel ind 1))
		 (umax (vals 1))
		 (clips (vals 3))
		 (lmax (vals 5)))
	    (if (not (= clips 1)) (snd-display "unclip-channel 6 click clips: ~A" clips))
	    (if (not (= lmax 2)) (snd-display "unclip-channel 6 click max len: ~A" lmax))
	    (if (fneq umax true-max) (snd-display "unclip-channel 6 click maxamp: ~A ~A" umax true-max)))))
      
      (revert-sound ind)
      (let ((data (make-float-vector 100))
	    (o1 (make-oscil 1000)))
	(do ((i 0 (+ i 1))) 
	    ((= i 100)) 
	  (set! (data i) (* .25 (oscil o1))))
	(let ((true-max (float-vector-peak data)))
	  (do ((i 45 (+ i 1)))
	      ((= i 55))
	    (set! (data i) (+ (data i) 1.25)))
	  (float-vector->channel data 0 100 ind 0)
	  (float-vector->channel data 0 100 ind 1)
	  
	  (let* ((vals (unclip-channel ind 1))
		 (umax (vals 1))
		 (clips (vals 3))
		 (lmax (vals 5)))
	    (if (not (= clips 1)) (snd-display "unclip-channel 7 click clips: ~A" clips))
	    (if (not (= lmax 10)) (snd-display "unclip-channel 7 click max len: ~A" lmax))
	    (if (fneq umax true-max) (snd-display "unclip-channel 7 click maxamp: ~A ~A" umax true-max)))))
      
      (revert-sound ind)
      (let ((data (make-float-vector 100))
	    (o1 (make-oscil 1000))
	    (o2 (make-oscil 2000)))
	(do ((i 0 (+ i 1))) 
	    ((= i 100)) 
	  (set! (data i) (* .25 (+ (oscil o1) (oscil o2)))))
	(let ((true-max (float-vector-peak data)))
	  (do ((i 45 (+ i 1)))
	      ((= i 55))
	    (set! (data i) (+ (data i) 1.25)))
	  (float-vector->channel data 0 100 ind 0)
	  (float-vector->channel data 0 100 ind 1)
	  
	  (let* ((vals (unclip-channel ind 1))
		 (umax (vals 1))
		 (clips (vals 3))
		 (lmax (vals 5)))
	    (if (not (= clips 1)) (snd-display "unclip-channel 8 click clips: ~A" clips))
	    (if (not (= lmax 10)) (snd-display "unclip-channel 8 click max len: ~A" lmax))
	    (if (fneq umax true-max) (snd-display "unclip-channel 8 click maxamp: ~A ~A" umax true-max)))))
      
      (revert-sound ind)
      (let ((data (make-float-vector 200))
	    (o1 (make-oscil 1000))
	    (o2 (make-oscil 2000)))
	(do ((i 0 (+ i 1))) 
	    ((= i 200)) 
	  (set! (data i) (* .25 (+ (oscil o1) (oscil o2)))))
	(let ((true-max (float-vector-peak data)))
	  (do ((i 45 (+ i 1)))
	      ((= i 55))
	    (set! (data i) (+ (data i) 2.0)))
	  (do ((i 75 (+ i 1)))
	      ((= i 85))
	    (set! (data i) (+ (data i) 2.0)))
	  (float-vector->channel data 0 200 ind 0)
	  (float-vector->channel data 0 200 ind 1)
	  
	  (let* ((vals (unclip-channel ind 1))
		 (umax (vals 1))
		 (clips (vals 3))
		 (lmax (vals 5)))
	    (if (not (= clips 2)) (snd-display "unclip-channel 9 collision clips: ~A" clips))
	    (if (not (= lmax 10)) (snd-display "unclip-channel 9 collision max len: ~A" lmax))
	    (if (fneq umax true-max) (snd-display "unclip-channel 9 collision maxamp: ~A ~A" umax true-max)))))
      
      (revert-sound ind)
      (mix "oboe.snd" 0 0 ind 0 #f)
      (mix "oboe.snd" 0 0 ind 1 #f)
      (scale-sound (/ 1.01 (maxamp ind 0)))
      
      (let* ((vals (unclip-channel ind 1))
	     (umax (vals 1))
	     (clips (vals 3))
	     (lmax (vals 5)))
	(if (not (= clips 20)) (snd-display "unclip-channel 10 oboe clips: ~A" clips))
	(if (not (= lmax 1)) (snd-display "unclip-channel 10 oboe max len: ~A" lmax))
	(if (fneq umax 0.999) (snd-display "unclip-channel 10 oboe maxamp: ~A" umax)))
      
      (revert-sound ind)
      (mix "oboe.snd" 0 0 ind 0 #f)
      (mix "oboe.snd" 0 0 ind 1 #f)
      (scale-sound (/ 1.05 (maxamp ind 0)))
      
      (let* ((vals (unclip-channel ind 1))
	     (umax (vals 1))
	     (clips (vals 3))
	     (lmax (vals 5)))
	(if (not (= clips 217)) (snd-display "unclip-channel 11 oboe clips: ~A" clips))
	(if (not (= lmax 2)) (snd-display "unclip-channel 11 oboe max len: ~A" lmax))
	(if (fneq umax 0.999) (snd-display "unclip-channel 11 oboe maxamp: ~A" umax)))
      
      (revert-sound ind)
      (mix "oboe.snd" 0 0 ind 0 #f)
      (mix "oboe.snd" 0 0 ind 1 #f)
      (let ((scl (/ 1.2 (maxamp ind 0))))
	(env-sound (make-env (list 0 0 .48 (/ scl 2) .5 scl .52 (/ scl 2) 1.0 0) :length (framples ind 0))))
      
      (let* ((vals (unclip-channel ind 1))
	     (umax (vals 1))
	     (clips (vals 3))
	     (lmax (vals 5)))
	(if (not (= clips 28)) (snd-display "unclip-channel 12 oboe clips: ~A" clips))
	(if (not (= lmax 3)) (snd-display "unclip-channel 12 oboe max len: ~A" lmax))
	(if (fneq umax 0.999) (snd-display "unclip-channel 12 oboe maxamp: ~A" umax)))
      
      (close-sound ind)))
  
  ;; ----------------
  (define analog-filter-tests
    (let ((sweep->bins 
	   (lambda* (flt (bins 10))
	     (let ((ind (open-sound "sweep.snd")))
	       ((if (mus-generator? flt) clm-channel map-channel) flt)
	       (let ((mx (maxamp))
		     (resp (make-float-vector bins))
		     (size (round (/ 22050 bins)))
		     (data (channel->float-vector)))
		 (do ((i 0 (+ i 1)))
		     ((= i bins))
		   (float-vector-set! resp i (float-vector-peak (subvector data size (* i size)))))
		 (close-sound ind)
		 (list mx resp)))))
	  
	  (filter-response-max 
	   (lambda (f1)
	     (let ((v (make-float-vector 1000)))
	       (set! (v 0) (f1 1.0))
	       (do ((i 1 (+ i 1)))
		   ((= i 1000))
		 (set! (v i) (filter f1 0.0)))
	       (float-vector-peak v))))
	  
	  (filter-equal?   ; equalp in clm2xen is too restrictive
	   (lambda (f1 f2) 
	     (and (= (mus-order f1) (mus-order f2))
		  (mus-arrays-equal? (mus-xcoeffs f1) (mus-xcoeffs f2))
		  (mus-arrays-equal? (mus-ycoeffs f1) (mus-ycoeffs f2))))))
      
      (lambda () 
	;; ---------------- butterworth tests ----------------
	
	(do ((poles (vector #r(1.000 1.414 1.000) ; numerous references provide these tables (y[0] is ignored)
			    #r(1.000 1.848 1.000 1.000 0.765 1.000)
			    #r(1.000 1.932 1.000 1.000 1.414 1.000 1.000 0.518 1.000)
			    #r(1.000 1.962 1.000 1.000 1.663 1.000 1.000 1.111 1.000 1.000 0.390 1.000)
			    #r(1.000 1.975 1.000 1.000 1.782 1.000 1.000 1.414 1.000 1.000 0.908 1.000 1.000 0.313 1.000)))
	     (i 2 (+ i 2))
	     (k 0 (+ k 1)))
	    ((>= i 12))
	  (let ((vals (butterworth-prototype i)))
	    (if (not (mus-arrays-equal? (cadr vals) (poles k)))
		(snd-display "butterworth prototype poles ~A: ~A (~A)" i (cadr vals) (poles k)))
	    (do ((zeros (make-float-vector (* (+ k 1) 3)))
		 (j 2 (+ j 3)))
		((>= j (* (+ k 1) 3))
		 (if (not (mus-arrays-equal? (car vals) zeros))
		     (snd-display "butterworth prototype zeros ~A: ~A (~A)" i (car vals) zeros)))
	      (set! (zeros j) 1.0))))
	
	(do ((cutoff .1 (+ cutoff .1))
	     (m 0 (+ 1 m)))
	    ((= m 3))
	  (do ((clm-cutoff (* *clm-srate* cutoff))
	       (i 2 (+ i 2))
	       (k 1 (+ k 1)))
	      ((= i 16))
	    (let ((local (make-butterworth-lowpass i cutoff))
		  (dsp (make-butter-lp k clm-cutoff)))
	      (if (not (filter-equal? local dsp))
		  (snd-display "butterworth lowpass ~A ~A ~A" cutoff local dsp)))
	    (let ((local (make-butterworth-highpass i cutoff))
		  (dsp (make-butter-hp k clm-cutoff)))
	      (if (not (filter-equal? local dsp))
		  (snd-display "butterworth highpass ~A ~A ~A" cutoff local dsp))))
	  
	  (let ((ind (open-sound "oboe.snd")))
	    (map-channel (make-eliminate-hum 550))
	    (map-channel (make-peaking-2 500 1000 1.0))
	    (map-channel (chordalize))
	    (close-sound ind))
	  
	  (let ((ind (new-sound "sweep.snd" 1 22050 mus-ldouble mus-next #f 22050)))
	    (let ((ph (make-one-pole 1.0 -1.0))
		  (fq (make-one-pole 1.0 -1.0))
		  (incr (/ pi 22050.0)))
	      (map-channel
	       (lambda (y)
		 (* .5 (sin (one-pole ph (one-pole fq incr)))))
	       2)) ; make it look like the old form
	    (save-sound ind)
	    (close-sound ind))
	  
	  (let ((not.5 (lambda (vals) (fneq (car vals) 0.5)))
		(beyond.5 (lambda (vals) (> (abs (- (car vals) .5)) .05))))
	    
	    (let ((vals (sweep->bins (make-butterworth-lowpass 8 .1))))
	      (if (not.5 vals) (snd-display "butterworth lp 8 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.500 0.500 0.359 0.014 0.001 0.000 0.000 0.000 0.000 0.000)))
		  (snd-display "butterworth lp 8 .1 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-butterworth-lowpass 12 .25))))
	      (if (not.5 vals) (snd-display "butterworth lp 12 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.500 0.500 0.500 0.500 0.499 0.358 0.010 0.000 0.000 0.000)))
		  (snd-display "butterworth lp 12 .25 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-butterworth-lowpass 10 .4))))
	      (if (not.5 vals) (snd-display "butterworth lp 10 max: ~A" (car vals)))
	      (if (not (or (mus-arrays-equal?1 (cadr vals) #r(0.500 0.500 0.500 0.500 0.500 0.500 0.500 0.499 0.361 0.001))
			   (mus-arrays-equal?1 (cadr vals) #r(0.500 0.500 0.500 0.500 0.500 0.500 0.500 0.499 0.360 0.002))))
		  (snd-display "butterworth lp 10 .4 spect: ~A" (cadr vals))))
	    
	    (do ((i 2 (+ i 2)))
		((= i 12))
	      (do ((j .1 (+ j .1)))
		  ((>= j .45))
		(let ((mx (filter-response-max (make-butterworth-lowpass i j))))
		  (if (> mx 1.0)
		      (snd-display "butter low max ~A ~A: ~A" i j mx)))))
	    
	    (let ((vals (sweep->bins (make-butterworth-highpass 8 .1))))
	      (if (not.5 vals) (snd-display "butterworth hp 8 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.001 0.348 0.500 0.500 0.500 0.500 0.500 0.500 0.500 0.500)))
		  (snd-display "butterworth hp 8 .1 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-butterworth-highpass 12 .25))))
	      (if (not.5 vals) (snd-display "butterworth hp 12 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.000 0.000 0.000 0.011 0.348 0.500 0.500 0.500 0.500 0.500)))
		  (snd-display "butterworth hp 12 .25 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-butterworth-highpass 10 .4))))
	      (if (not.5 vals) (snd-display "butterworth hp 10 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.000 0.000 0.000 0.000 0.000 0.000 0.005 0.343 0.501 0.501)))
		  (snd-display "butterworth hp 10 .4 spect: ~A" (cadr vals))))
	    
	    (let ((vals (sweep->bins (make-butterworth-bandpass 4 .1 .2))))
	      (if (beyond.5 vals) (snd-display "butterworth bp 4 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.028 0.350 0.481 0.479 0.346 0.132 0.038 0.009 0.002 0.000)))
		  (snd-display "butterworth bp 4 .1 .2 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-butterworth-bandpass 12 .1 .2))))
	      (if (beyond.5 vals) (snd-display "butterworth bp 12 max: ~A" (car vals)))
	      (if (not (or (mus-arrays-equal?1 (cadr vals) #r(0.006 0.317 0.501 0.500 0.358 0.009 0.000 0.000 0.000 0.000))
			   (mus-arrays-equal?1 (cadr vals) #r(0.012 0.319 0.501 0.500 0.358 0.009 0.000 0.000 0.000 0.000))
			   (mus-arrays-equal?1 (cadr vals) #r(0.000 0.323 0.501 0.500 0.358 0.009 0.000 0.000 0.000 0.000))))
		  (snd-display "butterworth bp 12 .1 .2 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-butterworth-bandpass 8 .3 .4))))
	      (if (beyond.5 vals) (snd-display "butterworth bp 8 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.000 0.000 0.000 0.003 0.034 0.344 0.499 0.499 0.353 0.002)))
		  (snd-display "butterworth bp 8 .3 .4 spect: ~A" (cadr vals))))
	    
	    (do ((i 2 (+ i 2)))
		((= i 12))
	      (do ((j .1 (+ j .1)))
		  ((>= j .45))
		(let ((mx (filter-response-max (make-butterworth-highpass i j))))
		  (if (> mx 1.0)
		      (snd-display "butter high max ~A ~A: ~A" i j mx)))))
	    
	    (let ((vals (sweep->bins (make-butterworth-bandstop 4 .1 .2))))
	      (if (beyond.5 vals) (snd-display "butterworth bs 4 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.500 0.500 0.347 0.339 0.481 0.499 0.500 0.500 0.500 0.500)))
		  (snd-display "butterworth bs 4 .1 .2 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-butterworth-bandstop 12 .1 .2))))
	      (if (beyond.5 vals) (snd-display "butterworth bs 12 max: ~A" (car vals)))
	      (if (not (or (mus-arrays-equal?1 (cadr vals) #r(0.503 0.503 0.364 0.334 0.500 0.500 0.500 0.500 0.500 0.500))
			   (mus-arrays-equal?1 (cadr vals) #r(0.502 0.503 0.365 0.334 0.500 0.500 0.500 0.500 0.500 0.500))
			   (mus-arrays-equal?1 (cadr vals) #r(0.500 0.500 0.365 0.334 0.500 0.500 0.500 0.500 0.500 0.500))))
		  (snd-display "butterworth bs 12 .1 .2 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-butterworth-bandstop 8 .3 .4))))
	      (if (beyond.5 vals) (snd-display "butterworth bs 8 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.500 0.500 0.500 0.500 0.500 0.498 0.354 0.332 0.500 0.500)))
		  (snd-display "butterworth bs 8 .3 .4 spect: ~A" (cadr vals))))
	    
	    
	    ;; ---------------- Chebyshev ----------------
	    
	    ;; ripple .01 .1 1 for 2..10 even
	    
	    (do ((poles-01 (vector #r(1.000 4.456 10.426)
				   #r(1.000 0.822 2.006 1.000 1.984 1.299)
				   #r(1.000 0.343 1.372 1.000 0.937 0.939 1.000 1.280 0.506)
				   #r(1.000 0.189 1.196 1.000 0.537 0.925 1.000 0.804 0.542 1.000 0.948 0.272)
				   #r(1.000 0.119 1.121 1.000 0.347 0.940 1.000 0.540 0.646 1.000 0.680 0.352 1.000 0.754 0.170)))
		 (zeros    (vector #r(0.000 0.000 1.000)
				   #r(0.000 0.000 0.250 0.000 0.000 1.000)
				   #r(0.000 0.000 0.062 0.000 0.000 1.000 0.000 0.000 1.000)
				   #r(0.000 0.000 0.016 0.000 0.000 1.000 0.000 0.000 1.000 0.000 0.000 1.000)
				   #r(0.000 0.000 0.004 0.000 0.000 1.000 0.000 0.000 1.000 0.000 0.000 1.000 0.000 0.000 1.000)))
		 (poles-1  (vector #r(1.000 2.372 3.314)
				   #r(1.000 0.528 1.330 1.000 1.275 0.623)
				   #r(1.000 0.229 1.129 1.000 0.627 0.696 1.000 0.856 0.263)
				   #r(1.000 0.128 1.069 1.000 0.364 0.799 1.000 0.545 0.416 1.000 0.643 0.146)
				   #r(1.000 0.082 1.044 1.000 0.237 0.862 1.000 0.369 0.568 1.000 0.465 0.274 1.000 0.515 0.092)))
		 (poles-10 (vector #r(1.000 1.098 1.103)
				   #r(1.000 0.279 0.987 1.000 0.674 0.279)
				   #r(1.000 0.124 0.991 1.000 0.340 0.558 1.000 0.464 0.125)
				   #r(1.000 0.070 0.994 1.000 0.199 0.724 1.000 0.298 0.341 1.000 0.352 0.070)
				   #r(1.000 0.045 0.996 1.000 0.130 0.814 1.000 0.203 0.521 1.000 0.255 0.227 1.000 0.283 0.045)))
		 (i 2 (+ i 2))
		 (k 0 (+ k 1)))
		((>= i 12))
	      (let ((vals (cadr (chebyshev-prototype i .01))))
		(if (not (mus-arrays-equal?1 vals (poles-01 k)))
		    (snd-display "chebyshev prototype .01 poles ~A: ~A (~A)" i vals (poles-01 k))))
	      (let ((vals (cadr (chebyshev-prototype i .1))))
		(if (not (mus-arrays-equal?1 vals (poles-1 k)))
		    (snd-display "chebyshev prototype .1 poles ~A: ~A (~A)" i vals (poles-1 k))))
	      (let ((vals (chebyshev-prototype i)))
		(if (not (mus-arrays-equal?1 (cadr vals) (poles-10 k)))
		    (snd-display "chebyshev prototype 1 poles ~A: ~A (~A)" i (cadr vals) (poles-10 k)))
		(if (not (mus-arrays-equal? (car vals) (zeros k)))
		    (snd-display "chebyshev prototype .01 zeros ~A: ~A (~A)" i (car vals) (zeros k)))))
	    
	    (let ((vals (sweep->bins (make-chebyshev-lowpass 8 .1))))
	      (if (ffneq (car vals) .51) (snd-display "chebyshev lp 8 max: ~A" (car vals)))
	      (if (not (or (mus-arrays-equal?1 (cadr vals) #r(0.508 0.512 0.468 0.001 0.000 0.000 0.000 0.000 0.000 0.000))
			   (mus-arrays-equal?1 (cadr vals) #r(0.507 0.512 0.467 0.001 0.000 0.000 0.000 0.000 0.000 0.000))
			   (mus-arrays-equal?1 (cadr vals) #r(0.508 0.513 0.469 0.001 0.000 0.000 0.000 0.000 0.000 0.000))
			   (mus-arrays-equal?1 (cadr vals) #r(0.509 0.508 0.465 0.001 0.000 0.000 0.000 0.000 0.000 0.000))))
		  (snd-display "chebyshev lp 8 .1 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-chebyshev-lowpass 12 .25))))
	      (if (ffneq (car vals) .51) (snd-display "chebyshev lp 12 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.509 0.500 0.508 0.508 0.507 0.413 0.000 0.000 0.000 0.000)))
		  (snd-display "chebyshev lp 12 .25 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-chebyshev-lowpass 10 .4))))
	      (if (ffneq (car vals) .51) (snd-display "chebyshev lp 10 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.465 0.493 0.509 0.508 0.477 0.507 0.508 0.507 0.431 0.000)))
		  (snd-display "chebyshev lp 10 .4 spect: ~A" (cadr vals))))
	    
	    (do ((i 2 (+ i 2)))
		((= i 10))
	      (do ((j .1 (+ j .1)))
		  ((>= j .45))
		(let ((mx (filter-response-max (make-chebyshev-lowpass i j))))
		  (if (> mx 1.0)
		      (snd-display "cheby low max ~A ~A: ~A" i j mx)))))
	    
	    (let ((vals (sweep->bins (make-chebyshev-lowpass 8 .1 .01))))
	      (if (ffneq (car vals) .49) (snd-display "chebyshev lp 8 .1 .01 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.492 0.491 0.483 0.006 0.000 0.000 0.000 0.000 0.000 0.000)))
		  (snd-display "chebyshev lp 8 .1 .01 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-chebyshev-lowpass 12 .25 .1))))
	      (if (ffneq (car vals) .49) (snd-display "chebyshev lp 12 .1 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.488 0.488 0.488 0.488 0.487 0.403 0.000 0.000 0.000 0.000)))
		  (snd-display "chebyshev lp 12 .25 .1 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-chebyshev-lowpass 10 .4 .001))))
	      (if (ffneq (car vals) .49) (snd-display "chebyshev lp 10 .001 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.497 0.497 0.497 0.497 0.497 0.497 0.497 0.497 0.488 0.000)))
		  (snd-display "chebyshev lp 10 .4 .001 spect: ~A" (cadr vals))))
	    
	    (let ((vals (sweep->bins (make-chebyshev-highpass 8 .1))))
	      (if (ffneq (car vals) .55) (snd-display "chebyshev hp 8 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.000 0.341 0.551 0.509 0.466 0.501 0.509 0.505 0.481 0.461)))
		  (snd-display "chebyshev hp 8 .1 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins  (make-chebyshev-highpass 12 .25))))
	      (if (ffneq (car vals) .55) (snd-display "chebyshev hp 12 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.000 0.000 0.000 0.000 0.299 0.554 0.509 0.509 0.500 0.509)))
		  (snd-display "chebyshev hp 12 .25 spect: ~A" (cadr vals))))
	    (let ((vals (cadr (sweep->bins (make-chebyshev-highpass 10 .4)))))
	      (if (not (or (mus-arrays-equal?1 vals #r(0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.297 0.786 0.677))
			   (mus-arrays-equal?1 vals #r(0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.301 0.788 0.660))
			   (mus-arrays-equal?1 vals #r(0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.322 0.861 0.724))
			   (mus-arrays-equal?1 vals #r(0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.262 0.571 0.509))))
		  (snd-display "chebyshev hp 10 .4 spect: ~A" vals)))
	    
	    (let ((vals (sweep->bins (make-chebyshev-highpass 8 .1 .01))))
	      (if (ffneq (car vals) .49) (snd-display "chebyshev hp 8 .1 .01 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.000 0.498 0.498 0.492 0.491 0.492 0.492 0.492 0.491 0.491)))
		  (snd-display "chebyshev hp 8 .1 .01 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-chebyshev-highpass 12 .25 .1))))
	      (if (ffneq (car vals) .51) (snd-display "chebyshev hp 12 .1 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.000 0.000 0.000 0.000 0.453 0.516 0.489 0.489 0.488 0.488)))
		  (snd-display "chebyshev hp 12 .25 .1 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-chebyshev-highpass 10 .4 .001))))
	      (if (ffneq (car vals) .5) (snd-display "chebyshev hp 10 .001 max: ~A" (car vals)))
	      (if (not (or (mus-arrays-equal?1 (cadr vals) #r(0.000 0.000 0.000 0.000 0.000 0.000 0.002 0.501 0.504 0.504))
			   (mus-arrays-equal?1 (cadr vals) #r(0.000 0.000 0.000 0.000 0.000 0.000 0.002 0.503 0.505 0.504))
			   (mus-arrays-equal?1 (cadr vals) #r(0.000 0.000 0.000 0.000 0.000 0.000 0.002 0.503 0.501 0.497))))
		  (snd-display "chebyshev hp 10 .4 .001 spect: ~A" (cadr vals))))
	    
	    (do ((i 2 (+ i 2)))
		((= i 10))
	      (do ((j .1 (+ j .1)))
		  ((>= j .45))
		(let ((mx (filter-response-max (make-chebyshev-highpass i j))))
		  (if (> mx 1.0)
		      (snd-display "cheby high max ~A ~A: ~A" i j mx)))))
	    
	    (let ((vals (sweep->bins (make-chebyshev-bandpass 4 .1 .2))))
	      (if (beyond.5 vals) (snd-display "chebyshev bp 4 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.009 0.449 0.509 0.505 0.442 0.065 0.013 0.003 0.000 0.000)))
		  (snd-display "chebyshev bp 4 .1 .2 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-chebyshev-bandpass 6 .1 .2))))
	      (if (beyond.5 vals) (snd-display "chebyshev bp 6 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.001 0.376 0.505 0.498 0.412 0.011 0.001 0.000 0.000 0.000)))
		  (snd-display "chebyshev bp 6 .1 .2 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-chebyshev-bandpass 8 .3 .4))))
	      (if (beyond.5 vals) (snd-display "chebyshev bp 8 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.000 0.000 0.000 0.000 0.002 0.363 0.517 0.513 0.433 0.000)))
		  (snd-display "chebyshev bp 8 .3 .4 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins  (make-chebyshev-bandpass 8 .2 .2 .01))))
	      (if (beyond.5 vals) (snd-display "chebyshev bp 10 .2 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.000 0.000 0.015 0.483 0.482 0.021 0.001 0.000 0.000 0.000)))
		  (snd-display "chebyshev bp 10 .2 spect: ~A" (cadr vals))))
	    
	    (let ((vals (sweep->bins (make-chebyshev-bandstop 4 .1 .4))))
	      (if (beyond.5 vals) (snd-display "chebyshev bs 4 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.509 0.505 0.447 0.033 0.006 0.006 0.033 0.445 0.512 0.509)))
		  (snd-display "chebyshev bs 4 .1 .4 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-chebyshev-bandstop 8 .1 .4))))
	      (if (> (abs (- (car vals) .51)) .05) (snd-display "chebyshev bs 8 max: ~A" (car vals)))
	      (if (not (or (mus-arrays-equal?1 (cadr vals) #r(0.508 0.512 0.468 0.001 0.000 0.000 0.001 0.345 0.551 0.507))
			   (mus-arrays-equal?1 (cadr vals) #r(0.507 0.512 0.467 0.001 0.000 0.000 0.001 0.344 0.549 0.508))
			   (mus-arrays-equal?1 (cadr vals) #r(0.508 0.513 0.469 0.001 0.000 0.000 0.001 0.345 0.552 0.508))
			   (mus-arrays-equal?1 (cadr vals) #r(0.509 0.508 0.465 0.001 0.000 0.000 0.001 0.343 0.548 0.508))))
		  (snd-display "chebyshev bs 8 .1 .4 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-chebyshev-bandstop 8 .1 .4 .01))))
	      (if (beyond.5 vals) (snd-display "chebyshev bs 8 .01 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.492 0.491 0.483 0.006 0.000 0.000 0.006 0.494 0.495 0.492)))
		  (snd-display "chebyshev bs 8 .1 .4 .01 spect: ~A" (cadr vals))))
	    
	    
	    ;; ---------------- inverse-chebyshev ----------------
	    
	    (let ((vals (sweep->bins (make-inverse-chebyshev-lowpass 8 .1))))
	      (if (ffneq (car vals) .51) (snd-display "inverse-chebyshev lp 8 max: ~A" (car vals)))
	      (if (not (or (mus-arrays-equal?1 (cadr vals) #r(0.501 0.496 0.001 0.000 0.001 0.000 0.000 0.000 0.000 0.001))
			   (mus-arrays-equal?1 (cadr vals) #r(0.500 0.498 0.001 0.000 0.001 0.000 0.000 0.000 0.000 0.001))))
		  (snd-display "inverse-chebyshev lp 8 .1 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-inverse-chebyshev-lowpass 12 .25))))
	      (if (ffneq (car vals) .51) (snd-display "inverse-chebyshev lp 12 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.500 0.500 0.500 0.500 0.496 0.001 0.001 0.001 0.001 0.001)))
		  (snd-display "inverse-chebyshev lp 12 .25 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-inverse-chebyshev-lowpass 10 .4))))
	      (if (ffneq (car vals) .51) (snd-display "inverse-chebyshev lp 10 max: ~A" (car vals)))
	      (if (not (or (mus-arrays-equal?1 (cadr vals) #r(0.500 0.500 0.500 0.500 0.500 0.500 0.500 0.497 0.001 0.001))
			   (mus-arrays-equal?1 (cadr vals) #r(0.500 0.500 0.500 0.500 0.500 0.500 0.500 0.497 0.002 0.002))))
		  (snd-display "inverse-chebyshev lp 10 .4 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-inverse-chebyshev-lowpass 10 .4 120))))
	      (if (ffneq (car vals) .51) (snd-display "inverse-chebyshev lp 10 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.501 0.501 0.501 0.501 0.501 0.500 0.345 0.007 0.000 0.000)))
		  (snd-display "inverse-chebyshev lp 10 .4 120 spect: ~A" (cadr vals))))
	    
	    (do ((i 2 (+ i 2)))
		((= i 10))
	      (do ((j .1 (+ j .1)))
		  ((>= j .45))
		(let ((mx (filter-response-max (make-inverse-chebyshev-lowpass i j))))
		  (if (> mx 1.0)
		      (snd-display "inv cheby low max ~A ~A: ~A" i j mx)))))
	    
	    (let ((vals (sweep->bins (make-inverse-chebyshev-highpass 8 .1))))
	      (if (ffneq (car vals) .51) (snd-display "inverse-chebyshev hp 8 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.001 0.001 0.440 0.505 0.505 0.503 0.502 0.501 0.501 0.501)))
		  (snd-display "inverse-chebyshev hp 8 .1 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-inverse-chebyshev-highpass 12 .25))))
	      (if (ffneq (car vals) .51) (snd-display "inverse-chebyshev hp 12 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.001 0.001 0.001 0.001 0.001 0.505 0.506 0.503 0.501 0.501)))
		  (snd-display "inverse-chebyshev hp 12 .25 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-inverse-chebyshev-highpass 10 .4))))
	      (if (ffneq (car vals) .51) (snd-display "inverse-chebyshev hp 10 .4 max: ~A" (car vals)))
	      (if (not (or (mus-arrays-equal?1 (cadr vals) #r(0.000 0.000 0.000 0.001 0.001 0.001 0.001 0.001 0.503 0.503))
			   (mus-arrays-equal?1 (cadr vals) #r(0.000 0.000 0.000 0.001 0.001 0.001 0.001 0.001 0.505 0.503))
			   (mus-arrays-equal?1 (cadr vals) #r(0.000 0.000 0.000 0.001 0.001 0.001 0.001 0.001 0.509 0.504))))
		  (snd-display "inverse-chebyshev hp 10 .4 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-inverse-chebyshev-highpass 10 .1 120))))
	      (if (ffneq (car vals) .51) (snd-display "inverse-chebyshev hp 10 .1 120 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.000 0.000 0.007 0.328 0.502 0.502 0.502 0.501 0.501 0.501)))
		  (snd-display "inverse-chebyshev hp 10 .1 120 spect: ~A" (cadr vals))))
	    
	    (do ((i 2 (+ i 2)))
		((= i 10))
	      (do ((j .1 (+ j .1)))
		  ((>= j .45))
		(let ((mx (filter-response-max (make-inverse-chebyshev-highpass i j))))
		  (if (> mx 1.0)
		      (snd-display "inv cheby high max ~A ~A: ~A" i j mx)))))
	    
	    (let ((vals (sweep->bins (make-inverse-chebyshev-bandpass 10 .1 .2))))
	      (if (beyond.5 vals) (snd-display "inverse-chebyshev bp 4 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.001 0.001 0.498 0.485 0.001 0.001 0.000 0.001 0.000 0.001)))
		  (snd-display "inverse-chebyshev bp 10 .1 .2 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-inverse-chebyshev-bandpass 10 .1 .2 30))))
	      (if (beyond.5 vals) (snd-display "inverse-chebyshev bp 6 max: ~A" (car vals)))
	      (if (not (or (mus-arrays-equal?1 (cadr vals) #r(0.026 0.025 0.509 0.505 0.020 0.016 0.012 0.016 0.011 0.016))
			   (mus-arrays-equal?1 (cadr vals) #r(0.030 0.042 0.511 0.505 0.020 0.016 0.012 0.016 0.011 0.016))
			   (mus-arrays-equal?1 (cadr vals) #r(0.022 0.017 0.511 0.505 0.020 0.016 0.012 0.016 0.011 0.016))))
		  (snd-display "inverse-chebyshev bp 10 .1 .2 30 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-inverse-chebyshev-bandpass 8 .1 .4))))
	      (if (beyond.5 vals) (snd-display "inverse-chebyshev bp 8 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.001 0.001 0.440 0.506 0.505 0.503 0.502 0.434 0.001 0.001)))
		  (snd-display "inverse-chebyshev bp 8 .1 .4 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-inverse-chebyshev-bandpass 8 .3 .4 40))))
	      (if (beyond.5 vals) (snd-display "inverse-chebyshev bp 10 .2 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.002 0.005 0.007 0.007 0.005 0.005 0.503 0.505 0.006 0.005)))
		  (snd-display "inverse-chebyshev bp 10 .2 spect: ~A" (cadr vals))))
	    
	    (let ((vals (sweep->bins (make-inverse-chebyshev-bandstop 4 .1 .4))))
	      (if (beyond.5 vals) (snd-display "inverse-chebyshev bs 4 max: ~A" (car vals)))
	      (if (not (mus-arrays-equal?1 (cadr vals) #r(0.500 0.054 0.001 0.001 0.000 0.000 0.000 0.001 0.055 0.503)))
		  (snd-display "inverse-chebyshev bs 4 .1 .4 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-inverse-chebyshev-bandstop 8 .1 .4))))
	      (if (beyond.5 vals) (snd-display "inverse-chebyshev bs 8 max: ~A" (car vals)))
	      (if (not (or (mus-arrays-equal?1 (cadr vals) #r(0.501 0.496 0.001 0.001 0.000 0.000 0.000 0.001 0.507 0.506))
			   (mus-arrays-equal?1 (cadr vals) #r(0.506 0.328 0.000 0.000 0.000 0.000 0.000 0.000 0.268 0.511))
			   (mus-arrays-equal?1 (cadr vals) #r(0.500 0.498 0.001 0.001 0.000 0.000 0.000 0.001 0.507 0.506))))
		  (snd-display "inverse-chebyshev bs 8 .1 .4 spect: ~A" (cadr vals))))
	    (let ((vals (sweep->bins (make-inverse-chebyshev-bandstop 8 .1 .4 90))))
	      (if (beyond.5 vals) (snd-display "inverse-chebyshev bs 8 90 max: ~A" (car vals)))
	      (if (not (or (mus-arrays-equal?1 (cadr vals) #r(0.505 0.325 0.000 0.000 0.000 0.000 0.000 0.000 0.270 0.506))
			   (mus-arrays-equal?1 (cadr vals) #r(0.506 0.328 0.000 0.000 0.000 0.000 0.000 0.000 0.269 0.509))
			   (mus-arrays-equal?1 (cadr vals) #r(0.501 0.327 0.000 0.000 0.000 0.000 0.000 0.000 0.268 0.506))))
		  (snd-display "inverse-chebyshev bs 8 .1 .4 90 spect: ~A" (cadr vals))))
	    
	    
	    ;; ---------------- bessel ----------------
	    
	    ;; checked poly coeff tables, but the prototype has scaling built in
	    
	    (when (provided? 'gsl)
	      (let ((vals (sweep->bins (make-bessel-lowpass 4 .1))))
		(if (not.5 vals) (snd-display "bessel lp 4 .1 max: ~A" (car vals)))
		(if (not (mus-arrays-equal?1 (cadr vals) #r(0.500 0.417 0.209 0.062 0.018 0.005 0.001 0.000 0.000 0.000)))
		    (snd-display "bessel lp 4 .1 spect: ~A" (cadr vals))))
	      (let ((vals (sweep->bins (make-bessel-lowpass 8 .1))))
		(if (not.5 vals) (snd-display "bessel lp 8 max: ~A" (car vals)))
		(if (not (mus-arrays-equal?1 (cadr vals) #r(0.499 0.365 0.116 0.010 0.001 0.000 0.000 0.000 0.000 0.000)))
		    (snd-display "bessel lp 8 .1 spect: ~A" (cadr vals))))
	      (let ((vals (sweep->bins (make-bessel-lowpass 12 .25))))
		(if (not.5 vals) (snd-display "bessel lp 12 max: ~A" (car vals)))
		(if (not (mus-arrays-equal?1 (cadr vals) #r(0.500 0.477 0.410 0.309 0.185 0.063 0.006 0.000 0.000 0.000)))
		    (snd-display "bessel lp 12 .25 spect: ~A" (cadr vals))))
	      (let ((vals (sweep->bins (make-bessel-lowpass 10 .4))))
		(if (not.5 vals) (snd-display "bessel lp 10 max: ~A" (car vals)))
		(if (not (or (mus-arrays-equal?1 (cadr vals) #r(0.500 0.498 0.491 0.479 0.458 0.423 0.364 0.259 0.086 0.001))
			     (mus-arrays-equal?1 (cadr vals) #r(0.500 0.498 0.491 0.479 0.458 0.423 0.364 0.259 0.086 0.002))))
		    (snd-display "bessel lp 10 .4 spect: ~A" (cadr vals))))
	      
	      (do ((i 2 (+ i 2)))
		  ((= i 12))
		(do ((j .1 (+ j .1)))
		    ((>= j .45))
		  (let ((mx (filter-response-max (make-bessel-lowpass i j))))
		    (if (> mx 1.0)
			(snd-display "bess low max ~A ~A: ~A" i j mx)))))
	      
	      (let ((vals (sweep->bins (make-bessel-highpass 8 .1))))
		(if (not.5 vals) (snd-display "bessel hp 8 max: ~A" (car vals)))
		(if (not (mus-arrays-equal?1 (cadr vals) #r(0.001 0.115 0.290 0.386 0.435 0.465 0.483 0.493 0.498 0.500)))
		    (snd-display "bessel hp 8 .1 spect: ~A" (cadr vals))))
	      (let ((vals (sweep->bins (make-bessel-highpass 12 .25))))
		(if (not.5 vals) (snd-display "bessel hp 12 max: ~A" (car vals)))
		(if (not (mus-arrays-equal?1 (cadr vals) #r(0.000 0.000 0.000 0.006 0.063 0.181 0.309 0.410 0.477 0.500)))
		    (snd-display "bessel hp 12 .25 spect: ~A" (cadr vals))))
	      (let ((vals (sweep->bins (make-bessel-highpass 10 .4))))
		(if (ffneq (car vals) .5) (snd-display "bessel hp 10 max: ~A" (car vals)))
		(if (not (mus-arrays-equal?1 (cadr vals) #r(0.000 0.000 0.000 0.000 0.000 0.000 0.004 0.084 0.343 0.499)))
		    (snd-display "bessel hp 10 .4 spect: ~A" (cadr vals))))
	      
	      (let ((vals (sweep->bins (make-bessel-bandpass 4 .1 .2))))
		(if (> (abs (- (car vals) .245)) .05) (snd-display "bessel bp 4 max: ~A" (car vals)))
		(if (not (mus-arrays-equal?1 (cadr vals) #r(0.023 0.176 0.245 0.244 0.179 0.085 0.031 0.008 0.001 0.000)))
		    (snd-display "bessel bp 4 .1 .2 spect: ~A" (cadr vals))))
	      
	      (let ((vals (sweep->bins (make-bessel-bandstop 12 .1 .2))))
		(if (beyond.5 vals) (snd-display "bessel bs 12 max: ~A" (car vals)))
		(if (not (or (mus-arrays-equal?1 (cadr vals) #r(0.498 0.325 0.065 0.066 0.177 0.297 0.389 0.452 0.488 0.500))
			     (mus-arrays-equal?1 (cadr vals) #r(0.499 0.324 0.065 0.066 0.177 0.297 0.389 0.452 0.488 0.500))))
		    (snd-display "bessel bs 12 .1 .2 spect: ~A" (cadr vals))))
	      
	      ;; ---------------- elliptic ----------------
	      
	      (let ((past.5 (lambda (vals) (> (abs (- (car vals) .5)) .1))))
		(let ((vals (sweep->bins (make-elliptic-lowpass 8 .1))))
		  (if (past.5 vals) (snd-display "elliptic lp 8 max: ~A" (car vals)))
		  (if (not (or (mus-arrays-equal?1 (cadr vals) #r(0.500 0.515 0.379 0.000 0.000 0.000 0.000 0.000 0.000 0.000))
			       (mus-arrays-equal?1 (cadr vals) #r(0.500 0.509 0.385 0.000 0.000 0.000 0.000 0.000 0.000 0.000))
			       (mus-arrays-equal?1 (cadr vals) #r(0.499 0.498 0.373 0.000 0.000 0.000 0.000 0.000 0.000 0.000))))
		      (snd-display "elliptic lp 8 .1 spect: ~A" (cadr vals))))
		(let ((vals (sweep->bins (make-elliptic-lowpass 12 .25))))
		  (if (past.5 vals) (snd-display "elliptic lp 12 max: ~A" (car vals)))
		  (if (not (or (mus-arrays-equal?1 (cadr vals) #r(0.476 0.500 0.491 0.499 0.494 0.412 0.003 0.001 0.000 0.000))
			       (mus-arrays-equal?1 (cadr vals) #r(0.476 0.500 0.491 0.499 0.494 0.561 0.004 0.000 0.000 0.000))
			       (mus-arrays-equal?1 (cadr vals) #r(0.476 0.500 0.491 0.499 0.493 0.299 0.006 0.001 0.000 0.000))))
		      (snd-display "elliptic lp 12 .25 spect: ~A" (cadr vals))))
		(let ((vals (sweep->bins (make-elliptic-lowpass 4 .4))))
		  (if (past.5 vals) (snd-display "elliptic lp 4 max: ~A" (car vals)))
		  (if (not (mus-arrays-equal?1 (cadr vals) #r(0.447 0.453 0.462 0.477 0.494 0.500 0.497 0.496 0.445 0.003)))
		      (snd-display "elliptic lp 4 .4 spect: ~A" (cadr vals))))
		(let ((vals (sweep->bins (make-elliptic-lowpass 8 .1 .1))))
		  (if (past.5 vals) (snd-display "elliptic lp 8 .1 max: ~A" (car vals)))
		  (if (not (mus-arrays-equal?1 (cadr vals) #r(0.500 0.499 0.475 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
		      (snd-display "elliptic lp 8 .1 .1 spect: ~A" (cadr vals))))
		(let ((vals (sweep->bins (make-elliptic-lowpass 8 .1 .1 90))))
		  (if (past.5 vals) (snd-display "elliptic lp 8 .1 90 max: ~A" (car vals)))
		  (if (not (mus-arrays-equal?1 (cadr vals) #r(0.500 0.499 0.475 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
		      (snd-display "elliptic lp 8 .1 .1 90 spect: ~A" (cadr vals))))
		(let ((vals (sweep->bins (make-elliptic-lowpass 8 .25 .01 90))))
		  (if (past.5 vals) (snd-display "elliptic lp 8 .25 90 max: ~A" (car vals)))
		  (if (not (mus-arrays-equal?1 (cadr vals) #r(0.500 0.500 0.500 0.500 0.499 0.495 0.001 0.000 0.000 0.000)))
		      (snd-display "elliptic lp 8 .25 .1 90 spect: ~A" (cadr vals))))
		
		(let ((vals (sweep->bins (make-elliptic-highpass 4 .1))))
		  (if (past.5 vals) (snd-display "elliptic hp 4 max: ~A" (car vals)))
		  (if (not (mus-arrays-equal?1 (cadr vals) #r(0.004 0.438 0.516 0.499 0.502 0.495 0.478 0.463 0.453 0.447)))
		      (snd-display "elliptic hp 4 .1 spect: ~A" (cadr vals))))
		(let ((vals (cadr (sweep->bins (make-elliptic-highpass 12 .25)))))
		  (if (not (or (mus-arrays-equal?1 vals #r(0.000 0.001 0.001 0.001 0.026 0.934 0.518 0.495 0.503 0.477))
			       (mus-arrays-equal?1 vals #r(0.000 0.001 0.001 0.001 0.033 1.185 0.519 0.495 0.503 0.477))
			       (mus-arrays-equal?1 vals #r(0.000 0.001 0.001 0.001 0.018 0.788 0.520 0.495 0.503 0.477))))
		      (snd-display "elliptic hp 12 .25 spect: ~A" vals)))
		(let ((vals (sweep->bins (make-elliptic-highpass 12 .25 .01 90))))
		  (if (past.5 vals) (snd-display "elliptic hp 12 90 max: ~A" (car vals)))
		  (if (not (mus-arrays-equal?1 (cadr vals) #r(0.000 0.000 0.000 0.000 0.499 0.517 0.503 0.501 0.500 0.500)))
		      (snd-display "elliptic hp 12 .25 90 spect: ~A" (cadr vals))))
		(let ((vals (sweep->bins (make-elliptic-highpass 4 .4))))
		  (if (past.5 vals) (snd-display "elliptic hp 4 max: ~A" (car vals)))
		  (if (not (mus-arrays-equal?1 (cadr vals) #r(0.000 0.000 0.000 0.001 0.001 0.002 0.023 0.447 0.515 0.502)))
		      (snd-display "elliptic hp 4 .4 spect: ~A" (cadr vals))))
		(let ((vals (sweep->bins (make-elliptic-highpass 8 .1 .1))))
		  (if (past.5 vals) (snd-display "elliptic hp 8 .1 max: ~A" (car vals)))
		  (if (not (mus-arrays-equal?1 (cadr vals) #r(0.000 0.478 0.553 0.506 0.499 0.501 0.501 0.499 0.497 0.495)))
		      (snd-display "elliptic hp 8 .1 .1 spect: ~A" (cadr vals))))
		(let ((vals (sweep->bins (make-elliptic-highpass 8 .1 .1 90))))
		  (if (past.5 vals) (snd-display "elliptic hp 8 .1 90 max: ~A" (car vals)))
		  (if (not (mus-arrays-equal?1 (cadr vals) #r(0.000 0.478 0.554 0.506 0.499 0.501 0.501 0.499 0.497 0.495)))
		      (snd-display "elliptic hp 8 .1 .1 90 spect: ~A" (cadr vals))))
		(let ((vals (sweep->bins (make-elliptic-highpass 8 .25 .01 90))))
		  (if (past.5 vals) (snd-display "elliptic hp 8 .25 90 max: ~A" (car vals)))
		  (if (not (mus-arrays-equal?1 (cadr vals) #r(0.000 0.000 0.000 0.001 0.516 0.517 0.507 0.503 0.501 0.500)))
		      (snd-display "elliptic hp 8 .25 .1 90 spect: ~A" (cadr vals))))
		
		(let ((vals (sweep->bins (make-elliptic-bandpass 4 .1 .2 .1))))
		  (if (past.5 vals) (snd-display "elliptic bp 4 max: ~A" (car vals)))
		  (if (not (mus-arrays-equal?1 (cadr vals) #r(0.036 0.546 0.550 0.510 0.501 0.032 0.024 0.009 0.021 0.024)))
		      (snd-display "elliptic bp 4 .1 .2 spect: ~A" (cadr vals))))
		(let ((vals (sweep->bins (make-elliptic-bandpass 6 .1 .2 .1 90))))
		  (if (past.5 vals) (snd-display "elliptic bp 6 max: ~A" (car vals)))
		  (if (not (mus-arrays-equal?1 (cadr vals) #r(0.002 0.511 0.532 0.503 0.492 0.003 0.001 0.001 0.001 0.001)))
		      (snd-display "elliptic bp 6 .1 .2 90 spect: ~A" (cadr vals))))
		
		(let ((vals (sweep->bins (make-elliptic-bandstop 4 .1 .3 .1))))
		  (if (past.5 vals) (snd-display "elliptic bs 4 max: ~A" (car vals)))
		  (if (not (mus-arrays-equal?1 (cadr vals) #r(0.499 0.502 0.498 0.037 0.050 0.540 0.544 0.527 0.526 0.521)))
		      (snd-display "elliptic bs 4 .1 .2 spect: ~A" (cadr vals))))
		(let ((vals (sweep->bins (make-elliptic-bandstop 8 .1 .3 .1 120))))
		  (if (past.5 vals) (snd-display "elliptic bs 8 max: ~A" (car vals)))
		  (if (not (or (mus-arrays-equal?1 (cadr vals) #r(0.500 0.499 0.476 0.000 0.000 0.495 0.526 0.505 0.501 0.501))
			       (mus-arrays-equal?1 (cadr vals) #r(0.500 0.499 0.475 0.000 0.000 0.495 0.526 0.505 0.501 0.501))))
		      (snd-display "elliptic bs 8 .1 .2 spect: ~A" (cadr vals))))
		)))))))
      
  ;; ----------------
  (define poly-roots-tests
    (letrec ((ceql (lambda (a b)
		     (if (null? a)
			 (null? b)
			 (and (not (null? b))
			      (not (or (fneq (real-part (car a)) (real-part (car b)))
				       (fneq (imag-part (car a)) (imag-part (car b)))))
			      (ceql (cdr a) (cdr b)))))))
      (lambda ()
	
	;; degree=0
	(let ((val (poly-roots #r(0.0))))
	  (if (pair? val) (snd-display "poly-roots 0.0: ~A" val)))
	(let ((val (poly-roots #r(12.3))))
	  (if (pair? val) (snd-display "poly-roots 12.3: ~A" val)))
	
	;; degree 0 + x=0
	(let ((val (poly-roots #r(0.0 1.0))))
	  (if (not (ceql val '(0.0))) (snd-display "poly-roots 0.0 1.0: ~A" val)))
	(let ((val (poly-roots #r(0.0 0.0 0.0 121.0))))
	  (if (not (ceql val '(0.0 0.0 0.0))) (snd-display "poly-roots 0.0 0.0 0.0 121.0: ~A" val)))
	
	;; degree=1
	(let ((val (poly-roots #r(-1.0 1.0))))
	  (if (not (ceql val '(1.0))) (snd-display "poly-roots -1.0 1.0: ~A" val)))
	(let ((val (poly-roots #r(-2.0 4.0))))
	  (if (not (ceql val '(0.5))) (snd-display "poly-roots -2.0 4.0: ~A" val)))
	(let ((val (poly-as-vector-roots (vector 0.0-i 1))))
	  (if (not (ceql val '(-0.0+1.0i))) (snd-display "poly-roots: -i 1: ~A" val)))
	
	;; linear x^n
	(let ((val (poly-roots #r(-1.0 0.0 0.0 0.0 1.0))))
	  (if (not (or (ceql val '(0.0-1.0i -1.0 0.0+1.0i 1.0))
		       (ceql val '(1.0 -1.0 0.0+1.0i -0.0-1.0i))))
	      (snd-display "poly-roots -1.0 0.0 0.0 0.0 1.0: ~A" val)))
	(let ((val (poly-roots #r(-16.0 0.0 0.0 0.0 1.0))))
	  (if (not (or (ceql val '(0.0-2.0i -2.0 0.0+2.0i 2.0))
		       (ceql val '(2.0 -2.0 0.0+2.0i -0.0-2.0i))))
	      (snd-display "poly-roots -16.0 0.0 0.0 0.0 1.0: ~A" val)))
	(let ((val (poly-roots #r(-32.0 0 0 0 0 0 0.5))))
	  (if (not (ceql val '(1.0-1.7320i -1.0-1.7320i -2.0 -1.0+1.7320i 1.0+1.7320i 2.0))) (snd-display "poly-roots 32 0 0 0 0 0 0.5: ~A" val)))
	
	;; linear + x=0
	(let ((val (poly-roots #r(0.0 -2.0 4.0))))
	  (if (not (ceql val '(0.0 0.5))) (snd-display "poly-roots 0.0 -2.0 4.0: ~A" val)))
	
	;; degree=2
	(let ((val (poly-roots #r(-1.0 0.0 1.0))))
	  (if (not (ceql val '(1.0 -1.0))) (snd-display "poly-roots -1.0 0.0 1.0: ~A" val)))
	(let ((val (poly-roots #r(15.0 -8.0 1.0))))
	  (if (not (ceql val '(5.0 3.0))) (snd-display "poly-roots 15.0 -8.0 1.0: ~A" val)))
	(let ((val (poly-roots #r(1 -2 1))))
	  (if (not (ceql val '(1.0 1.0))) (snd-display "poly-roots 1 -2 1: ~A" val)))
	(let ((val (poly-as-vector-roots (vector -1 0.0+2i 1))))
	  (if (not (ceql val '(0.0-1.0i 0.0-1.0i))) (snd-display "poly-roots -1 2i 1: ~A" val)))
	(let ((val (poly-roots #r(1 1 5))))
	  (if (not (ceql val '(-0.1+0.43589i -0.1-0.43589i))) (snd-display "poly-roots 1 1 5: ~A" val)))
	
	;; 2 + x=0
	(let ((val (poly-roots #r(0.0 0.0 -1.0 0.0 1.0))))
	  (if (not (ceql val '(0.0 0.0 1.0 -1.0))) (snd-display "poly-roots 0.0 0.0 -1.0 0.0 1.0: ~A" val)))
	
	;; quadratic in x^(n/2)
	(let ((vals (poly-roots #r(1.0 0.0 -2.0 0.0 1.0))))
	  (if (not (or (ceql vals '(-1.0 1.0 -1.0 1.0))
		       (ceql vals '(1.0 1.0 -1.0 -1.0))))
	      (snd-display "poly-roots 1 0 -2 0 1: ~A" vals)))
	(let ((vals (poly-roots #r(64.0 0.0 0.0 -16.0 0.0 0.0 1.0))))
	  (if (not (ceql vals '(-1.0-1.73205i -1.0+1.73205i 2.0 -1.0-1.73205i -1.0+1.73205i 2.0)))
	      (snd-display "poly-roots 64 0 0 -16 0 0 1: ~A" vals)))
	
	;; degree=3
	(let ((val (poly-roots #r(-15.0 23.0 -9.0 1.0))))
	  (if (not (ceql val '(5.0 1.0 3.0))) (snd-display "poly-roots 5 1 3: ~A" val)))
	(let ((val (poly-roots #r(-126 -15 0 1))))
	  (if (not (ceql val '(6.0 -3.0+3.46410i -3.0-3.46410i))) (snd-display "poly-roots -126 -15 0 1: ~A" val)))
	
	(let ((val (poly-roots #r(-1 3 -3 1))))
	  (if (not (ceql val '(1.0 1.0 1.0))) (snd-display "poly-roots -1 3 -3 1: ~A" val))) 
	(let ((val (poly-roots #r(1 -1 -1 1))))
	  (if (not (or (ceql val '(1.0 -1.0 1.0))
		       (ceql val '(-1.0 1.0 1.0))))
	      (snd-display "poly-roots 1 -1 1: ~A" val)))
	(let ((val (poly-roots #r(2 -2 -2 2))))
	  (if (not (or (ceql val '(1.0 -1.0 1.0))
		       (ceql val '(-1.0 1.0 1.0))))
	      (snd-display "poly-roots 2 -2 -2 2: ~A" val)))
	
	(let ((vals (poly-roots #r(-64 0 0 0 0 0 1))))
	  (if (not (ceql vals '(0.999999999999999-1.73205080756888i -1.0-1.73205080756888i -2.0 -1.0+1.73205080756888i 1.0+1.73205080756888i 2.0)))
	      (snd-display "poly-roots 64 6: ~A" vals)))
	(let ((vals (poly-roots #r(64 0 0 -16 0 0 1))))
	  (if (not (ceql vals '(-1.0-1.73205080756888i -1.0+1.73205080756888i 2.0 -1.0-1.73205080756888i -1.0+1.73205080756888i 2.0)))
	      (snd-display "poly-roots 64 16 6: ~A" vals)))
	(do ((i 0 (+ i 1))) ((= i 10)) (poly-roots (float-vector (random 1.0) (random 1.0) (random 1.0))))
	(do ((i 0 (+ i 1))) ((= i 10)) (poly-roots (float-vector (mus-random 1.0) (mus-random 1.0) (mus-random 1.0))))
	
	(let ((vals1 (convolution #r(1 2 3 0 0 0 0 0) #r(1 2 3 0 0 0 0 0) 8))
	      (vals2 (poly* #r(1 2 3 0) #r(1 2 3 0))))
	  (if (not (mus-arrays-equal? vals1 vals2))
	      (snd-display "poly* convolve: ~A ~A" vals1 vals2)))
	
	(let ((random-complex (lambda () (complex (mus-random 1.0) (mus-random 1.0)))))
	  (do ((i 0 (+ i 1))) ((= i 10)) 
	    (poly-as-vector-roots (vector (random-complex) (random-complex))))
	  
	  (do ((i 0 (+ i 1))) ((= i 10)) 
	    (poly-as-vector-roots (vector (random-complex) (random-complex) (random-complex))))
	  
	  (do ((i 0 (+ i 1))) ((= i 10)) 
	    (poly-roots (float-vector (mus-random 1.0) (mus-random 1.0) (mus-random 1.0) (mus-random 1.0))))
	  
	  (do ((i 0 (+ i 1))) ((= i 10)) 
	    (poly-as-vector-roots (vector (random-complex) (random-complex) (random-complex) (random-complex)))))
	
	(do ((i 3 (+ i 1))) ((= i 20)) 
	  (let ((v (make-float-vector i)))
	    (set! (v 0) (mus-random 1.0))
	    (set! (v (- i 1)) 1.0)
	    (poly-roots v)))
	
	(do ((i 3 (+ i 2))) ((= i 21)) 
	  (let ((v (make-float-vector i)))
	    (set! (v 0) (mus-random 1.0))
	    (set! (v (- i 1)) 1.0)
	    (set! (v (/ (- i 1) 2)) 1.0)
	    (poly-roots v)))
	
	(let ((vals (poly-roots #r(1 -1 -1 1))))
	  (if (not (or (ceql vals '(1.0 -1.0 1.0))
		       (ceql vals '(-1.0 1.0 1.0))))
	      (snd-display "poly-roots 1-1-11: ~A" vals)))
	(let ((vals (poly-roots #r(2 -1 -2 1))))
	  (if (not (ceql vals '(2.0 -1.0 1.0))) (snd-display "poly-roots 2-1-21: ~A" vals)))
	(let ((vals (poly-roots #r(-1 1 1 1))))
	  (if (not (ceql vals '(0.543689012692076 -0.771844506346038+1.11514250803994i -0.771844506346038-1.11514250803994i)))
	      (snd-display "poly-roots -1111: ~A" vals)))
	(let ((vals (poly-roots #r(-1 3 -3 1))))
	  (if (not (ceql vals '(1.0 1.0 1.0))) (snd-display "poly-roots -13-31: ~A" vals)))
					;      (let ((vals (poly-roots #r(1 -4 6 -4 1))))
					;	(if (not (ceql vals '(1.0 1.0 1.0 1.0))) (snd-display "poly-roots 1-46-41: ~A" vals)))
	(let ((vals (poly-roots #r(0.5 0 0 1.0))))
	  (if (not (or (ceql vals '(0.396850262992049-0.687364818499302i -0.7937005259841 0.39685026299205+0.687364818499301i))
		       (ceql vals '(0.39685026299205+0.687364818499301i 0.39685026299205-0.687364818499301i -0.7937005259841))
		       (ceql vals '(-7.9370052598409979172089E-1 3.968502629920498958E-1+6.873648184993013E-1i 3.96850262992049E-1-6.873648184993E-1i))))
	      (snd-display "poly-roots 0..5 3: ~A" vals)))
	(let ((vals (poly-roots (poly* (poly* (poly* #r(-1 1) #r(1 1))
					      (poly* #r(-2 1) #r(2 1)))
				       (poly* #r(-3 1) #r(3 1))))))
	  (if (not (ceql vals '(-3.0 3.0 -1.0 1.0 -2.0 2.0)))
	      (snd-display "cube in 2: ~A" vals))))))
  
  ;; -----------------
  (define (test-fm-components)
    (if (and (provided? 'gsl)
	     (not (provided? 'gmp)))
	(let ((str (with-output-to-string
		     (lambda ()
		       (fm-complex-component 1200 1000 100 1.0 4.0 0.0 #f)
		       (fm-cascade-component 2000 2000 500 1.5 50 1.0)))))
      (if (not (string=? str ";fm-complex-component add -0.000-0.010i from J-3(1.0) = -0.020 and I5(4.0) = 0.505
;fm-complex-component add 0.163 from J-2(1.0) = 0.115 and I4(4.0) = 1.416
;fm-complex-component add -0.000+1.469i from J-1(1.0) = -0.440 and I3(4.0) = 3.337
;fm-complex-component add -4.914 from J0(1.0) = 0.765 and I2(4.0) = 6.422
;fm-complex-component add 0.000+4.295i from J1(1.0) = 0.440 and I1(4.0) = 9.759
;fm-complex-component add 1.299 from J2(1.0) = 0.115 and I0(4.0) = 11.302
;fm-complex-component add 0.000-0.191i from J3(1.0) = 0.020 and I-1(4.0) = 9.759
;fm-complex-component add -0.016 from J4(1.0) = 0.002 and I-2(4.0) = 6.422
;fm-cascade-component add 0.512 from J0(1.5) = 0.512 and J0(1.0) = 1.000
"))
	  (snd-display "fm-components are unexpected:~%~S" str)))))
  
  ;; ----------------
  (define fltit
    (let ((+documentation+ "(fltit) returns a time-varying filter: (map-channel (fltit))"))
      (lambda ()
	(let ((flt (make-fir-filter 8 #r(.1 .2 .3 .4 .4 .3 .2 .1))))
	  (do ((xcof (mus-xcoeffs flt)) ; maybe a copy?
	       (es (make-float-vector 8))
	       (i 0 (+ i 1)))
	      ((= i 8)
	       (set! (es 5) 1.00002)
	       (lambda (x)
		 (float-vector-multiply! xcof es)
		 (fir-filter flt x)))
	    (set! (es i) 0.9994)))))) ; something like (+ 1.0 (/ (log 1e-5) (* 0.5 *clm-srate*)))
  
;;; (with-sound ("test.snd") (let ((p (make-pulse-train 1000))) (do ((i 0 (+ i 1))) ((= i 44100)) (outa i (* .5 (pulse-train p))))))
;;; (map-channel (fltit))

  
  ;; ----------------
  (define (freq-sweep dur)
    (let ((ph (make-one-pole 1.0 -1.0))
	  (fq (make-one-pole 1.0 -1.0))
	  (incr (/ pi (* dur 1.05 *clm-srate*)))
	  (len (framples)))
      (do ((data (make-float-vector len))
	   (i 2 (+ i 1)))
	  ((= i len)
	   (float-vector->channel (float-vector-scale! data 0.5)))
	(set! (data i) (sin (one-pole ph (one-pole fq incr)))))))

  
  ;; ----------------
  (define make-ssb-am-1 
    (let ()
      (defgenerator sa1 freq (coscar #f) (sincar #f) (dly #f) (hlb #f))
      (lambda* (freq (order 40))
	(if (even? order) (set! order (+ 1 order)))
	(make-sa1 :freq (abs freq)
		  :coscar (make-oscil freq (* .5 pi))
		  :sincar (make-oscil freq)
		  :dly (make-delay order)
		  :hlb (make-hilbert-transform order)))))
  
  ;; ----------------
  (define* (ssb-am-1 gen y (fm-1 0.0))
    (let* ((ccos (oscil (gen 'coscar) fm-1))
	   (csin (oscil (gen 'sincar) fm-1)))
      ((if (> (gen 'freq) 0.0) - +) 
       (* ccos (delay (gen 'dly) y))
       (* csin (hilbert-transform (gen 'hlb) y)))))
  
  ;; ----------------

  (define (rough-spectrum ind)
    (let ((data (channel->float-vector 0 10000 ind 0))
	  (spect (make-float-vector 10))
	  (g (make-one-pole 1.0 -1.0)))
      (float-vector-multiply! data data)
      (do ((i 0 (+ i 1))
	   (beg 0 (+ beg 1000))
	   (end 999 (+ end 1000)))
	  ((= i 10))
	(mus-reset g)
	(do ((j beg (+ j 1)))
	    ((= j end))
	  (one-pole g (float-vector-ref data j)))
	(float-vector-set! spect i (one-pole g (float-vector-ref data end))))
      (float-vector-scale! spect (/ 1.0 (float-vector-peak spect)))))
  
  ;; ----------------
  (define* (print-and-check gen name desc (desc1 "") (desc2 ""))
    
    (if (not (string=? (mus-name gen) name))
	(snd-display "mus-name ~A: ~A?" name (mus-name gen)))
    (if (not (or (string=? (mus-describe gen) desc)
		 (string=? (mus-describe gen) desc1)
		 (string=? (mus-describe gen) desc2)))
	(snd-display "mus-describe ~A: ~A?" (mus-name gen) (mus-describe gen)))
    (let ((egen gen))
      (if (not (equal? egen gen))
	  (snd-display "equal? ~A: ~A?" gen egen))))
  
  ;; ----------------
  (define (test-gen-equal g0 g1 g2)
    ;; g0 = g1 at start != g2
    
    (let ((g3 g0))
      (if (not (eq? g0 g3))
	  (snd-display "let ~A not eq?~%    ~A~%    ~A" (mus-name g0) g0 g3))
      (if (eq? g0 g1)
	  (snd-display "arg ~A eq?~%    ~A~%    ~A" (mus-name g0) g0 g1))
      (if (not (equal? g0 g1))
	  (snd-display "~A not equal?~%    ~A~%    ~A" (mus-name g0) g0 g1))
      (if (equal? g0 g2)
	  (snd-display "~A equal?~%    ~A~%    ~A" (mus-name g0) g0 g2))
      (g0)
      (g3)
      (g3)
      (if (not (eq? g0 g3))
	  (snd-display "run let ~A not eq?~%    ~A~%    ~A" (mus-name g0) g0 g3))
      (if (eq? g0 g1)
	  (snd-display "arg ~A eq?~%    ~A~%    ~A" (mus-name g0) g0 g1))
      (if (equal? g0 g1)
	  (snd-display "run ~A equal?~%    ~A~%    ~A" (mus-name g0) g0 g1))
      (if (equal? g0 g2)
	  (snd-display "run ~A equal?~%    ~A~%    ~A" (mus-name g0) g0 g2))
      (let ((data (catch #t (lambda () (mus-data g0)) (lambda args #f))))
	(when (float-vector? data)
	  (let ((data4 (catch #t (lambda () (mus-data (copy g0))) (lambda args #f))))
	    (if (not (float-vector? data4)) 
		(snd-display "~A copy -> mus-data ~A?" (mus-name g0) data4)))))))
  
  ;; ----------------
  (define (fm-test gen)
    (if (not (mus-generator? gen)) (snd-display "~A not a gen?" gen))
    (set! (mus-frequency gen) 0.0)
    (set! (mus-phase gen) 0.0)
    (gen 0.0)
    (if (fneq (mus-phase gen) 0.0) (snd-display "~A phase(0): ~A" gen (mus-phase gen)))
    (gen 1.0)
    (if (fneq (mus-phase gen) 1.0) (snd-display "~A phase(1): ~A" gen (mus-phase gen)))
    (gen 0.0)
    (if (fneq (mus-phase gen) 1.0) (snd-display "~A phase(1, 0): ~A" gen (mus-phase gen)))
    (set! (mus-frequency gen) (radians->hz 2.0))
    (if (fneq (mus-increment gen) 2.0) (snd-display "~A increment: ~A" gen (mus-increment gen)))
    (set! (mus-increment gen) 2.0)
    (if (fneq (mus-frequency gen) (radians->hz 2.0)) (snd-display "~A set increment: ~A ~A" gen (mus-increment gen) (hz->radians (mus-frequency gen))))
    (gen 0.0)
    (if (fneq (mus-phase gen) 3.0) (snd-display "~A phase(1, 2): ~A ~A" gen (mus-phase gen) (mus-frequency gen)))
    (gen 1.0)
    (if (fneq (mus-phase gen) 6.0) (snd-display "~A phase(3, 2, 1): ~A ~A" gen (mus-phase gen) (mus-frequency gen)))
    (do ((i 0 (+ i 1))) ((= i 10)) (gen 10.0))
    (if (fneq (mus-phase gen) (- 126 (* 40 pi))) ;(+ 26 (- 100 (* 40 pi)))) ;(+ 26 (- 100 (* 2 pi 20)))
	(snd-display "~A phase (over): ~A ~A" gen (mus-phase gen) (mus-frequency gen)))
    (set! (mus-frequency gen) 0.0)
    (set! (mus-phase gen) 0.0)
    (gen 1234567812345678)
    (gen -1234567812345678)
    (set! (mus-frequency gen) 0.0)
    (set! (mus-phase gen) 0.0)
    (gen -2.0)
    (if (and (fneq (mus-phase gen) -2.0)
	     (fneq (mus-phase gen) (- (* 2 pi) 2.0)))
	(snd-display "phase: ~A freq: ~A" (mus-phase gen) (mus-frequency gen))))
  
  ;; ----------------
  (define* (agc (ramp-speed .001) (window-size 512))
    (let ((maxer (make-moving-max window-size))
	  (mult 1.0))
      (map-channel
       (lambda (y)
	 (let ((this-incr (* (- 0.5 (* mult (moving-max maxer y))) ramp-speed)))
	   (set! mult (+ mult this-incr))
	   (* y mult))))))
  
  ;; ----------------
  (define (numerical-reality-checks)
    ;; a few reality checks from John Burkardt test_values.C
    
    (do ((vals (vector 1.6709637479564564156 1.5707963267948966192 1.4706289056333368229 1.3694384060045658278 1.2661036727794991113 
		       1.1592794807274085998 1.0471975511965977462 0.92729521800161223243 0.79539883018414355549 0.64350110879328438680 
		       0.45102681179626243254 0.00000000000000000000))
	 (args (vector -0.1 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0))
	 (max-bad 0.0)
	 (i 0 (+ i 1)))
	((= i 12)
	 (if (> max-bad 1.0e-15)
	     (snd-display "acos: ~A" max-bad)))
      (set! max-bad (max max-bad (abs (- (acos (vector-ref args i))
					 (vector-ref vals i))))))
    
    (do ((vals (vector 0.0000000000000000000 0.14130376948564857735 0.44356825438511518913 0.62236250371477866781 0.75643291085695958624 
		       0.86701472649056510395 0.96242365011920689500 1.3169578969248167086 1.7627471740390860505 1.8115262724608531070 
		       2.0634370688955605467 2.2924316695611776878 2.9932228461263808979 5.2982923656104845907 7.6009022095419886114))
	 (args (vector 1.0 1.01 1.1 1.2 1.3 1.4 1.5 2.0 3.0 3.1415926535897932385 4.0 5.0 10.0 100.0 1000.0))
	 (max-bad 0.0)
	 (i 0 (+ i 1)))
	((= i 15)
	 (if (> max-bad 1.0e-15)
	     (snd-display "acosh: ~A" max-bad)))
      (let ((nval (acosh (vector-ref args i))))
	(set! max-bad (max max-bad (abs (- nval (vector-ref vals i)))))))
    
    (do ((vals (vector -0.10016742116155979635 0.00000000000000000000 0.10016742116155979635 0.20135792079033079146 0.30469265401539750797 
		       0.41151684606748801938 0.52359877559829887308 0.64350110879328438680 0.77539749661075306374 0.92729521800161223243 
		       1.1197695149986341867 1.5707963267948966192))
	 (args (vector -0.1 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0))
	 (max-bad 0.0)
	 (i 0 (+ i 1)))
	((= i 12)
	 (if (> max-bad 1.0e-15)
	     (snd-display "asin: ~A" max-bad)))
      (set! max-bad (max max-bad (abs (- (asin (vector-ref args i))
					 (vector-ref vals i))))))
    
    (do ((vals (vector -2.3124383412727526203 -0.88137358701954302523 0.00000000000000000000 0.099834078899207563327 0.19869011034924140647 
		       0.29567304756342243910 0.39003531977071527608 0.48121182505960344750 0.56882489873224753010 0.65266656608235578681 
		       0.73266825604541086415 0.80886693565278246251 0.88137358701954302523 1.4436354751788103425 1.8184464592320668235 
		       2.0947125472611012942 2.3124383412727526203 2.9982229502979697388 5.2983423656105887574 7.6009027095419886115))
	 (args (vector -5.0 -1.0 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 2.0 3.0 4.0 5.0 10.0 100.0 1000.0))
	 (max-bad 0.0)
	 (i 0 (+ i 1)))
	((= i 20))
      (let* ((nval (asinh (vector-ref args i)))
	     (diff (abs (- nval (vector-ref vals i)))))
	(set! max-bad (max max-bad diff))
	(if (> max-bad 1.0e-14)
	    (snd-display "asinh(~A): ~A ~A -> ~A" (vector-ref args i) nval (vector-ref vals i) max-bad))))
    
    (do ((vals (vector 0.00000000000000000000 0.24497866312686415417 0.32175055439664219340 0.46364760900080611621 0.78539816339744830962 
		       1.1071487177940905030 1.2490457723982544258 1.3258176636680324651 1.3734007669450158609 1.4711276743037345919 1.5208379310729538578))
	 (args (vector 0.00000000000000000000 0.25000000000000000000 0.33333333333333333333 0.50000000000000000000 1.0000000000000000000 
		       2.0000000000000000000 3.0000000000000000000 4.0000000000000000000 5.0000000000000000000 10.000000000000000000 20.000000000000000000))
	 (max-bad 0.0)
	 (i 0 (+ i 1)))
	((= i 11)
	 (if (> max-bad 1.0e-15)
	     (snd-display "atan: ~A" max-bad)))
      (set! max-bad (max max-bad (abs (- (atan (vector-ref args i))
					 (vector-ref vals i))))))
    
    (do ((vals (vector -0.54930614433405484570 0.00000000000000000000 0.0010000003333335333335 0.10033534773107558064 0.20273255405408219099 
		       0.30951960420311171547 0.42364893019360180686 0.54930614433405484570 0.69314718055994530942 0.86730052769405319443 
		       1.0986122886681096914 1.4722194895832202300 2.6466524123622461977 3.8002011672502000318 7.2543286192620472067))
	 (args (vector -0.5 0.0 0.001 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 0.99 0.999 0.999999))
	 (max-bad 0.0)
	 (i 0 (+ i 1)))
	((= i 15))
      (let* ((nval (atanh (vector-ref args i)))
	     (diff (abs (- nval (vector-ref vals i)))))
	(set! max-bad (max max-bad diff))
	(if (> diff 1.0e-10) ; one is > e-11
	    (snd-display "atanh(~A): ~A ~A -> ~A" (vector-ref args i) (vector-ref vals i) nval diff))))
    
    (do ((vals (vector 0.1000000000000000E+01 0.1010025027795146E+01 0.1040401782229341E+01 0.1092045364317340E+01 0.1166514922869803E+01 
		       0.1266065877752008E+01 0.1393725584134064E+01 0.1553395099731217E+01 0.1749980639738909E+01 0.1989559356618051E+01 
		       0.2279585302336067E+01 0.3289839144050123E+01 0.4880792585865024E+01 0.7378203432225480E+01 0.1130192195213633E+02 
		       0.1748117185560928E+02 0.2723987182360445E+02 0.6723440697647798E+02 0.4275641157218048E+03 0.2815716628466254E+04))
	 (args (vector 0.00E+00 0.20E+00 0.40E+00 0.60E+00 0.80E+00 0.10E+01 0.12E+01 0.14E+01 0.16E+01 0.18E+01 0.20E+01 0.25E+01 0.30E+01 
		       0.35E+01 0.40E+01 0.45E+01 0.50E+01 0.60E+01 0.80E+01 
		       0.10E+02))
	 (max-bad 0.0)
	 (i 0 (+ i 1)))
	((= i 20))
      (let* ((nval (bes-i0 (vector-ref args i)))
	     (diff (abs (- nval (vector-ref vals i)))))
	(set! max-bad (max max-bad diff))
	(if (> diff 1.0e-4)
	    (snd-display "bes-i0(~A): ~A ~A -> ~A" (vector-ref args i) (vector-ref vals i) nval diff))))
    
    (do ((vals (vector -0.1775967713143383E+00 -0.3971498098638474E+00 -0.2600519549019334E+00 0.2238907791412357E+00 0.7651976865579666E+00 
		       0.1000000000000000E+01 0.7651976865579666E+00 0.2238907791412357E+00 -0.2600519549019334E+00 -0.3971498098638474E+00 
		       -0.1775967713143383E+00 0.1506452572509969E+00 0.3000792705195556E+00 0.1716508071375539E+00 -0.9033361118287613E-01 
		       -0.2459357644513483E+00 -0.1711903004071961E+00 0.4768931079683354E-01 0.2069261023770678E+00 0.1710734761104587E+00 -0.1422447282678077E-01))
	 (args (vector -5.0E+00 -4.0E+00 -3.0E+00 -2.0E+00 -1.0E+00 0.0E+00 1.0E+00 2.0E+00 3.0E+00 4.0E+00 5.0E+00 6.0E+00 7.0E+00 8.0E+00 
		       9.0E+00 10.0E+00 11.0E+00 12.0E+00 13.0E+00 14.0E+00 15.0E+00))
	 (max-bad 0.0)
	 (i 0 (+ i 1)))
	((= i 21))
      (let* ((nval (bes-j0 (vector-ref args i)))
	     (diff (abs (- nval (vector-ref vals i)))))
	(set! max-bad (max max-bad diff))
	(if (> diff 1.0e-15)
	    (snd-display "bes-j0(~A): ~A ~A -> ~A" (vector-ref args i) (vector-ref vals i) nval diff))))
    
    (do ((vals (vector 0.3275791375914652E+00 0.6604332802354914E-01 -0.3390589585259365E+00 -0.5767248077568734E+00 -0.4400505857449335E+00 
		       0.0000000000000000E+00 0.4400505857449335E+00 0.5767248077568734E+00 0.3390589585259365E+00 -0.6604332802354914E-01 
		       -0.3275791375914652E+00 -0.2766838581275656E+00 -0.4682823482345833E-02 0.2346363468539146E+00 0.2453117865733253E+00 
		       0.4347274616886144E-01 -0.1767852989567215E+00 -0.2234471044906276E+00 -0.7031805212177837E-01 0.1333751546987933E+00 0.2051040386135228E+00))
	 (args (vector -5.0E+00 -4.0E+00 -3.0E+00 -2.0E+00 -1.0E+00 0.0E+00 1.0E+00 2.0E+00 3.0E+00 4.0E+00 5.0E+00 6.0E+00 7.0E+00 8.0E+00 
		       9.0E+00 10.0E+00 11.0E+00 12.0E+00 13.0E+00 14.0E+00 15.0E+00))
	 (max-bad 0.0)
	 (i 0 (+ i 1)))
	((= i 21))
      (let* ((nval (bes-j1 (vector-ref args i)))
	     (diff (abs (- nval (vector-ref vals i)))))
	(set! max-bad (max max-bad diff))
	(if (> diff 1.0e-15)
	    (snd-display "bes-j1(~A): ~A ~A -> ~A" (vector-ref args i) (vector-ref vals i) nval diff))))
    
    (do ((vals (vector 0.1149034849319005E+00 0.3528340286156377E+00 0.4656511627775222E-01 0.2546303136851206E+00 -0.5971280079425882E-01 
		       0.2497577302112344E-03 0.7039629755871685E-02 0.2611405461201701E+00 -0.2340615281867936E+00 -0.8140024769656964E-01 
		       0.2630615123687453E-09 0.2515386282716737E-06 0.1467802647310474E-02 0.2074861066333589E+00 -0.1138478491494694E+00 
		       0.3873503008524658E-24 0.3918972805090754E-18 0.2770330052128942E-10 0.1151336924781340E-04 -0.1167043527595797E+00))
	 (ns (vector 2 2 2 2 2 5 5 5 5 5 10 10 10 10 10 20 20 20 20 20)) 
	 (args (vector 1.0E+00 2.0E+00 5.0E+00 10.0E+00 50.0E+00 1.0E+00 2.0E+00 5.0E+00 10.0E+00 50.0E+00 1.0E+00 2.0E+00 5.0E+00 10.0E+00 
		       50.0E+00 1.0E+00 2.0E+00 5.0E+00 10.0E+00 50.0E+00))
	 (max-bad 0.0)
	 (i 0 (+ i 1)))
	((= i 20))
      (let* ((nval (bes-jn (vector-ref ns i) (vector-ref args i)))
	     (diff (abs (- nval (vector-ref vals i)))))
	(set! max-bad (max max-bad diff))
	(if (> diff 1.0e-15)
	    (snd-display "bes-jn(~A ~A): ~A ~A -> ~A" (vector-ref ns i) (vector-ref args i) (vector-ref vals i) nval diff))))
    
    (do ((vals (vector -0.1534238651350367E+01 0.8825696421567696E-01 0.5103756726497451E+00 0.3768500100127904E+00 -0.1694073932506499E-01 
		       -0.3085176252490338E+00 -0.2881946839815792E+00 -0.2594974396720926E-01 0.2235214893875662E+00 0.2499366982850247E+00 
		       0.5567116728359939E-01 -0.1688473238920795E+00 -0.2252373126343614E+00 -0.7820786452787591E-01 0.1271925685821837E+00 0.2054642960389183E+00))
	 (args (vector 0.1E+00 1.0E+00 2.0E+00 3.0E+00 4.0E+00 5.0E+00 6.0E+00 7.0E+00 8.0E+00 9.0E+00 10.0E+00 11.0E+00 12.0E+00 13.0E+00 14.0E+00 15.0E+00))
	 (max-bad 0.0)
	 (i 0 (+ i 1)))
	((= i 16))
      (let* ((nval (bes-y0 (vector-ref args i)))
	     (diff (abs (- nval (vector-ref vals i)))))
	(set! max-bad (max max-bad diff))
	(if (> diff 1.0e-15)
	    (snd-display "bes-y0(~A): ~A ~A -> ~A" (vector-ref args i) (vector-ref vals i) nval diff))))
    
    (do ((vals (vector -0.6458951094702027E+01 -0.7812128213002887E+00 -0.1070324315409375E+00 0.3246744247918000E+00 0.3979257105571000E+00 
		       0.1478631433912268E+00 -0.1750103443003983E+00 -0.3026672370241849E+00 -0.1580604617312475E+00 0.1043145751967159E+00 
		       0.2490154242069539E+00 0.1637055374149429E+00 -0.5709921826089652E-01 -0.2100814084206935E+00 -0.1666448418561723E+00 0.2107362803687351E-01))
	 (args (vector 0.1E+00 1.0E+00 2.0E+00 3.0E+00 4.0E+00 5.0E+00 6.0E+00 7.0E+00 8.0E+00 9.0E+00 10.0E+00 11.0E+00 12.0E+00 13.0E+00 14.0E+00 15.0E+00))
	 (max-bad 0.0)
	 (i 0 (+ i 1)))
	((= i 16))
      (let* ((nval (bes-y1 (vector-ref args i)))
	     (diff (abs (- nval (vector-ref vals i)))))
	(set! max-bad (max max-bad diff))
	(if (> diff 1.0e-14)
	    (snd-display "bes-y1(~A): ~A ~A -> ~A" (vector-ref args i) (vector-ref vals i) nval diff))))
    
    (do ((vals (vector -0.1650682606816254E+01 -0.6174081041906827E+00 0.3676628826055245E+00 -0.5868082442208615E-02 0.9579316872759649E-01 
		       -0.2604058666258122E+03 -0.9935989128481975E+01 -0.4536948224911019E+00 0.1354030476893623E+00 -0.7854841391308165E-01 
		       -0.1216180142786892E+09 -0.1291845422080393E+06 -0.2512911009561010E+02 -0.3598141521834027E+00 0.5723897182053514E-02 
		       -40816513889983664.0 -0.5933965296914321E+09 -0.1597483848269626E+04 0.1644263394811578E-01))
	 
	 ;; yn(20, 2.0) prints -40816513889983664.0 but I guess due to float inaccuracies (bes-yn 20 2.0) is -40816513889983672.0?
	 
	 (ns (vector 2 2 2 2 2 5 5 5 5 5 10 10 10 10 10 20 20 20 20))
	 (args (vector 1.0E+00 2.0E+00 5.0E+00 10.0E+00 50.0E+00 1.0E+00 2.0E+00 5.0E+00 10.0E+00 50.0E+00 1.0E+00 2.0E+00 5.0E+00 10.0E+00 
		       50.0E+00 2.0E+00 5.0E+00 10.0E+00 50.0E+00))
	 (max-bad 0.0)
	 (i 0 (+ i 1)))
	((= i 19))
      (let* ((nval (bes-yn (vector-ref ns i) (vector-ref args i)))
	     (diff (abs (- nval (vector-ref vals i)))))
	(set! max-bad (max max-bad diff))
	(if (and (> diff 1.0e-6)
		 (not (= i 15))) ; see above
	    (snd-display "bes-yn(~A ~A): ~A ~A -> ~A" (vector-ref ns i) (vector-ref args i) (vector-ref vals i) nval diff))))
    ;; one (20 1.0) is off by a lot but the val is 1e22 
    
    ;; numerics stuff
    (do ((ns (vector 1 6 6 6 15 15 15 15 15 15 15))
	 (ks (vector 0 1 3 5 1  3  5  7  9  11 13))
	 (vals (vector 1 6 20 6 15 455 3003 6435 5005 1365 105))
	 (i 0 (+ i 1)))
	((= i 11))
      (let ((nval (binomial-direct (vector-ref ns i) (vector-ref ks i)))
	    (mval (n-choose-k (vector-ref ns i) (vector-ref ks i))))
	(if (not (= nval mval (vector-ref vals i)))
	    (snd-display "binomial(~A ~A): ~A ~A ~A" (vector-ref ns i) (vector-ref ks i) nval mval (vector-ref vals i)))))
    
    (do ((ls (vector 1 1 1 1 1 2 2 2 3 3 3 3 4 5 6 7 8 9 10))
	 (ms (vector 0 0 0 0 1 0 1 2 0 1 2 3 2 2 3 3 4 4 5))
	 (vals (vector 0.000000 0.500000 0.707107 1.000000 -0.866025 -0.125000 -1.29904  2.25000 -0.437500 -0.324759 5.62500 -9.74278 
		       4.21875 -4.92187  12.7874  116.685 -1050.67 -2078.49  30086.2))
	 (xs (vector 0.0 0.5 0.7071067 1.0  0.5 0.5 0.5 0.5  0.5 0.5 0.5 0.5  0.5 0.5 0.5 0.5  0.5 0.5 0.5))
	 (i 0 (+ i 1)))
	((= i 19))
      (let ((val (plgndr (vector-ref ls i) (vector-ref ms i) (vector-ref xs i))))
	(if (not (and (real? val) 
		      (real? (vector-ref vals i)) 
		      (<= (abs (- val (vector-ref vals i))) 0.1)))
	    (snd-display "plgndr(~A ~A ~A) = ~A (~A)" (vector-ref ls i) (vector-ref ms i) (vector-ref xs i) val (vector-ref vals i)))))
    
    (let ((vals (vector  1.0000000000  0.8000000000  0.2800000000  -0.3520000000 -0.8432000000 -0.9971200000 
			 -0.7521920000 -0.2063872000  0.4219724800  0.8815431680  0.9884965888  0.7000513741  0.1315856097))
	  (ns (vector  0  1  2   3  4  5   6  7  8   9 10 11 	   12))
	  (xs (make-vector 13 0.8)))
      
      (do ((i 0 (+ i 1)))
	  ((= i 13))
	(let ((val (chebyshev (vector-ref ns i) (vector-ref xs i))))
	  (if (fneq val (vector-ref vals i))
	      (snd-display "chebyshev ~A ~A -> ~A ~A" (vector-ref ns i) (vector-ref xs i) val (vector-ref vals i)))))
      
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(let* ((x (random 10.0))
	       (order (random 10))
	       (val1 (gegenbauer order x 1.0))
	       (val2 (chebyshev order x 2)))
	  (if (fneq val1 val2)
	      (snd-display "gegenbauer/chebyshev (alpha=1) ~A ~A: ~A ~A" order x val1 val2)))))
    
    (let ((as (vector      0.5  0.5  0.5      0.5  0.5  0.5      0.5  0.5  0.5      0.5  0.5  0.0      1.0  2.0  3.0 
			   4.0  5.0  6.0      7.0  8.0  9.0     10.0  3.0  3.0      3.0  3.0  3.0      3.0  3.0  3.0      3.0  3.0  3.0 
			   3.0  3.0  3.0      3.0  3.0))
	  (vals (vector    1.0000000000   0.2000000000  -0.4400000000    -0.2800000000   0.2320000000   0.3075200000 
			   -0.0805760000  -0.2935168000  -0.0395648000     0.2459712000   0.1290720256   0.696706 ; was 0 but explicit formula says 2/n cos(nx)
			   -0.3600000000  -0.0800000000   0.8400000000     2.4000000000   4.6000000000   7.4400000000    10.9200000000  15.0400000000  19.8000000000 
			   25.2000000000  9.0000000000  -0.1612800000 ; was -9 but that is wrong (see G&R explicit formula)
			   -6.6729600000  -8.3750400000  -5.5267200000     0.0000000000   5.5267200000   8.3750400000     6.6729600000   0.1612800000  -9.0000000000  
			   -15.4252800000  -9.6969600000  22.4409600000   100.8892800000 252.0000000000))
	  (ns (vector     0  1  2      3  4  5      6  7  8      9 10  2      2  2  2      2  2  2      2  2  2      2  5  5      5  5  5 
			  5  5  5      5  5  5      5  5  5      5  5))
	  (xs (vector    0.20  0.20  0.20     0.20  0.20  0.20     0.20  0.20  0.20     0.20  0.20  0.40     0.40  0.40  0.40 
			 0.40  0.40  0.40     0.40  0.40  0.40     0.40 -0.50 -0.40    -0.30 -0.20 -0.10     0.00  0.10  0.20 
			 0.30  0.40  0.50     0.60  0.70  0.80     0.90  1.00))
      
	  (g3 (lambda (x alpha)
		(- (* 1/3 alpha x x x (+ 8 (* alpha (+ 12 (* alpha 4)))))
		   (* 2 alpha x (+ alpha 1)))))
	  
	  (g5 (lambda (x alpha)
		(+ (* 1/15 alpha x x x x x (+ 96 (* alpha (+ 200 (* alpha (+ 140 (* alpha (+ 40 (* alpha 4)))))))))
		   (* -1/3 alpha x x x (+ 24 (* alpha (+ 44 (* alpha (+ 24 (* alpha 4)))))))
		   (* alpha x (+ 2 (* alpha (+ 3 alpha))))))))
      
      (do ((i 0 (+ i 1)))
	  ((= i 38))
	(let ((val (gegenbauer (vector-ref ns i) (vector-ref xs i) (vector-ref as i))))
	  (if (fneq val (vector-ref vals i))
	      (snd-display "gegenbauer ~A ~A ~A -> ~A ~A" (vector-ref ns i) (vector-ref xs i) (vector-ref as i) val (vector-ref vals i)))))
      
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(let* ((x (random 10.0))
	       (alpha (random 3.0))
	       (val1 (gegenbauer 3 x alpha))
	       (val2 (g3 x alpha)))
	  (if (fneq val1 val2)
	      (snd-display "gegenbauer 3 ~A ~A: ~A ~A" x alpha val1 val2))))
      
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(let* ((x (random 10.0))
	       (alpha (random 3.0))
	       (val1 (gegenbauer 5 x alpha))
	       (val2 (g5 x alpha)))
	  (if (fneq val1 val2)
	      (snd-display "gegenbauer 5 ~A ~A: ~A ~A" x alpha val1 val2))))
      )
    
    (do ((vals (vector     1.0000000000  0.0000000000 -0.5000000000     -0.6666666667 -0.6250000000 -0.4666666667 
			   -0.2569444444 -0.0404761905  0.1539930556      0.3097442681  0.4189459325  0.4801341791 
			   0.4962122235 -0.4455729167  0.8500000000     -3.1666666667 34.3333333333))
	 (ns (vector     0  1  2      3  4  5      6  7  8      9 10 11     12  5  5      5  5))
	 (xs (vector    1.0  1.0  1.0     1.0  1.0  1.0     1.0  1.0  1.0     1.0  1.0  1.0     1.0  0.5  3.0     5.0 10.0))
	 (i 0 (+ i 1)))
	((= i 17))
      (let ((val (laguerre (vector-ref ns i) (vector-ref xs i))))
	(if (fneq val (vector-ref vals i))
	    (snd-display "laguerre ~A ~A -> ~A ~A" (vector-ref ns i) (vector-ref xs i) val (vector-ref vals i)))))
    
    (do ((vals (vector     1.0            10.0           98.0      940.0          8812.0         80600.0 
			   717880.0       6211600.0      52065680.0 ; was off by factor of 10?
			   421271200      3275529760.0   24329873600.0      171237081280.0 41.0          -8.0      3816.0         3041200.0))
	 (ns (vector     0  1  2      3  4  5      6  7  8      9 10 11     12  5  5      5  5))
	 (xs (vector    5.0  5.0  5.0     5.0  5.0  5.0     5.0  5.0  5.0     5.0  5.0  5.0     5.0  0.5  1.0     3.0 10.0))
	 (i 0 (+ i 1)))
	((= i 13))
      (let ((val (hermite (vector-ref ns i) (vector-ref xs i))))
	(if (fneq val (vector-ref vals i))
	    (snd-display "hermite ~A ~A -> ~A ~A" (vector-ref ns i) (vector-ref xs i) val (vector-ref vals i)))))
    
    (do ((i 0 (+ i 1))) 
	((= i 10))
      (let ((lv (legendre-polynomial (let ((v (make-vector 10 0.0))) 
				       (vector-set! v i 1.0) 
				       v) 
				     0.5))
	    (pv (plgndr i 0 0.5)))
	(if (fneq lv pv)
	    (snd-display "lv: ~A, pv: ~A (~A)" lv pv i))))
    
    (let ((pow-x (lambda (pow x)
		   ;; A&S p798
		   (case pow
		     ((0)                  (legendre-polynomial (vector 1) x))
		     ((1)                  (legendre-polynomial (vector 0 1) x))
		     ((2) (* (/ 1.0 3.0)   (legendre-polynomial (vector 1 0 2) x)))
		     ((3) (* (/ 1.0 5.0)   (legendre-polynomial (vector 0 3 0 2) x)))
		     ((4) (* (/ 1.0 35.0)  (legendre-polynomial (vector 7 0 20 0 8) x)))
		     ((5) (* (/ 1.0 63.0)  (legendre-polynomial (vector 0 27 0 28 0 8) x)))
		     ((6) (* (/ 1.0 231.0) (legendre-polynomial (vector 33 0 110 0 72 0 16) x)))
		     (else 'oops)))))
      (for-each
       (lambda (x)
	 (for-each
	  (lambda (pow)
	    (let ((lv (pow-x pow x))
		  (sv (expt x pow)))
	      (if (fneq lv sv)
		  (snd-display "~A ^ ~A = ~A ~A?" x pow lv sv))))
	  '(0 1 2 3 4 5 6)))
       '(2.0 0.5 0.1 -0.5 3.0 0.8)))
    
    (let ((index (find-sound 
		  (with-sound (:scaled-to 0.5) 
		    (do ((i 0 (+ i 1)) 
			 (x 0.0 (+ x .02))) 
			((= i 100)) 
		      (outa i (legendre 20 (cos x))))))))
      (if (fneq (sample 0 index 0) 0.5) (snd-display "legendre(cos(x)) 0: ~A" (sample 0 index 0)))
      (if (fneq (sample 50 index 0) 0.062572978) (snd-display "legendre(cos(x)) 50: ~A" (sample 50 index 0)))
      (close-sound index))
    
    
    (let ((h1 (lambda (x) (* 2 x)))
	  (h2 (lambda (x) (- (* 4 x x) 2)))
	  (h3 (lambda (x) (- (* 8 x x x) (* 12 x))))
	  (h4 (lambda (x) (+ 12 (* x x (- (* x x 16) 48)))))
	  (h5 (lambda (x) (* x (+ 120 (* x x (- (* x x 32) 160))))))
	  (h6 (lambda (x) (- (* x x (+ 720 (* x x (- (* x x 64) 480)))) 120))))
      
      (do ((i 0 (+ i 1)))
	  ((= i 20))
	(let ((x (random 10.0)))
	  (let ((v1 (h1 x))
		(v11 (hermite 1 x))
		(v2 (h2 x))
		(v22 (hermite 2 x))
		(v3 (h3 x))
		(v33 (hermite 3 x))
		(v4 (h4 x))
		(v44 (hermite 4 x))
		(v5 (h5 x))
		(v55 (hermite 5 x))
		(v6 (h6 x))
		(v66 (hermite 6 x)))
	    (cond ((fneq v1 v11) (snd-display "hermite 1 ~A: ~A ~A" x v1 v11))
		  ((fneq v2 v22) (snd-display "hermite 2 ~A: ~A ~A" x v2 v22))
		  ((fneq v3 v33) (snd-display "hermite 3 ~A: ~A ~A" x v3 v33))
		  ((fneq v4 v44) (snd-display "hermite 4 ~A: ~A ~A" x v4 v44))
		  ((fneq v5 v55) (snd-display "hermite 5 ~A: ~A ~A" x v5 v55))
		  ((fneq v6 v66) (snd-display "hermite 6 ~A: ~A ~A" x v6 v66)))))))
    
    (let ((lg1 (lambda (x) (- 1 x)))
	  (lg2 (lambda (x) (+ 1 (* x (- (* x 0.5) 2)))))
	  (lag1 (lambda (x a) (- (+ 1 a) x)))
	  (lag2 (lambda (x a) (* 0.5 (+ (* x x) 
					(* -2 x (+ a 2))
					(* (+ a 1) (+ a 2))))))
	  (lag3 (lambda (x a) (* (/ -1.0 6.0) (- (+ (* x x x) 
						    (* -3 x x (+ a 3)) 
						    (* 3 x (+ a 2) (+ a 3)))
						 (* (+ a 1) (+ a 2) (+ a 3)))))))
      (let ((x (random 10.0))
	    (a (random 1.0)))
	(let ((v1 (laguerre 1 x))
	      (v11 (lg1 x))
	      (v2 (laguerre 2 x))
	      (v22 (lg2 x))
	      (va1 (lag1 x a))
	      (va11 (laguerre 1 x a))
	      (va2 (lag2 x a))
	      (va22 (laguerre 2 x a))
	      (va3 (lag3 x a))
	      (va33 (laguerre 3 x a)))
	  (cond ((fneq v1 v11)   (snd-display "laguerre 1 ~A: ~A ~A" x v1 v11))
		((fneq v2 v22)   (snd-display "laguerre 2 ~A: ~A ~A" x v2 v22))
		((fneq va1 va11) (snd-display "laguerre 1a ~A ~A: ~A ~A" x a va1 va11))
		((fneq va2 va22) (snd-display "laguerre 2a ~A ~A: ~A ~A" x a va2 va22))
		((fneq va3 va33) (snd-display "laguerre 3a ~A ~A: ~A ~A" x a va3 va33)))))))
  
  ;; ----------------
  ;; start of test
  
  (do ((clmtest 0 (+ 1 clmtest))) ((= clmtest tests))
    
    (log-mem clmtest)
    (numerical-reality-checks)

    ;; numerics.scm existence checks
    (if (not (= (factorial 3) 6)) (snd-display "factorial 3: ~A" (factorial 3)))
    (if (not (= (n-choose-k 10 6) 210 (binomial-direct 10 6))) (snd-display "binomial: 210 ~A ~A" (n-choose-k 10 6) (binomial-direct 10 6)))
    (if (not (= (n-choose-k 10 9) 10 (binomial-direct 10 9))) (snd-display "binomial: 10 ~A ~A" (n-choose-k 10 9) (binomial-direct 10 9)))
    (if (fneq (legendre 3 1.0) 1.0) (snd-display "legendre: ~A" (legendre 3 1.0)))
    (if (fneq (gegenbauer 3 1.0) -0.6599949977336302) (snd-display "gegenbauer: ~A" (gegenbauer 3 1.0)))
    (if (fneq (chebyshev 3 1.0) 1.0) (snd-display "chebyshev: ~A" (chebyshev 3 1.0)))
    (if (fneq (hermite 3 1.0) -4.0) (snd-display "hermite: ~A" (hermite 3 1.0)))
    (if (fneq (laguerre 3 1.0) -0.6666666666666666) (snd-display "laguerre: ~A" (laguerre 3 1.0)))
    (if (fneq (Si 1.0) 0.9460830708394717) (snd-display "Si: ~A" (Si 1.0)))
    (if (fneq (Ci 1.0) 0.3374039233633503) (snd-display "Ci: ~A" (Ci 1.0)))
    (if (fneq (bernoulli-poly 1 1.0) 0.5) (snd-display "bernoulli-poly: ~A" (bernoulli-poly 1 1.0)))
    (let ((val1 (sin-m*pi/n 1 4369)) ;(* 257 17)))
	  (val2 (sin-m*pi/n 2 15)))  ;(* 3 5))))
      (let ((num1 (eval val1))
	    (num2 (eval val2)))
	(if (fneq num1 0.0007190644044087482) ; (sin (/ (* 1 pi) (* 257 17)))
	    (snd-display "sin-m*pi/n 1 (* 257 17): ~A" num1))
	(if (fneq num2 0.4067366430758002)    ; (sin (/ (* 2 pi) 15))
	    (snd-display "sin-m*pi/n 2 (* 3 5): ~A" num2))))
    (let ((vals (sin-nx-peak 100)))
      (if (or (fneq (car vals) 1.999876644816418)
	      (fneq (cadr vals) 1.555089933857112))
	  (snd-display "sin-nx-peak 100: ~A" vals)))
    ;(if (not (= (exptmod 3 100 5) 1)) (snd-display "exptmod 3 100 5: ~A" (exptmod 3 100 5)))
    
    (set! *clm-srate* 22050)
    (let ((samps (seconds->samples 1.0))
	  (secs (samples->seconds 22050)))
      (if (not (= samps 22050)) (snd-display "seconds->samples: ~A" samps))
      (if (fneq secs 1.0) (snd-display "samples->seconds: ~A" secs)))
    (set! *clm-file-buffer-size* default-file-buffer-size)
    (let ((var (catch #t (lambda () (set! *clm-file-buffer-size* #f)) (lambda args args))))
      (if (not (eq? (car var) 'wrong-type-arg))
	  (snd-display "mus-file-buffer-size bad size: ~A" var)))
    (set! *clm-file-buffer-size* 128)
    (if (not (= *clm-file-buffer-size* 128)) (snd-display "mus-file-buffer-size: ~D?" *clm-file-buffer-size*))
    (set! *clm-file-buffer-size* default-file-buffer-size)
    
    (if (not (member *mus-array-print-length* '(8 12 32) =))
	(snd-display "mus-array-print-length: ~D?" *mus-array-print-length*))
    (set! *mus-array-print-length* 32)
    (if (not (= *mus-array-print-length* 32)) (snd-display "set mus-array-print-length: ~D?" *mus-array-print-length*))
    (set! *mus-array-print-length* 8)
    
    (if (> (abs (- *mus-float-equal-fudge-factor* 0.0000001)) 0.00000001)
	(snd-display "mus-float-equal-fudge-factor: ~A?" *mus-float-equal-fudge-factor*))
    (let-temporarily ((*mus-float-equal-fudge-factor* .1))
      (if (fneq *mus-float-equal-fudge-factor* .1) 
	  (snd-display "set mus-float-equal-fudge-factor: ~A?" *mus-float-equal-fudge-factor*)))
    
    (if (fneq *clm-srate* 22050.0) (snd-display "mus-srate: ~F?" *clm-srate*))
    (if (fneq (hz->radians 1.0) 2.84951704088598e-4) (snd-display "hz->radians: ~F?" (hz->radians 1.0)))
    (if (fneq (radians->hz 2.84951704088598e-4) 1.0) (snd-display "radians->hz: ~F?" (radians->hz 2.84951704088598e-4)))
    (if (fneq (radians->degrees 1.0) 57.2957801818848) (snd-display "radians->degrees: ~F?" (radians->degrees 1.0)))
    (if (fneq (degrees->radians 57.2957801818848) 1.0) (snd-display "degrees->radians: ~F?" (degrees->radians 57.2957801818848)))
    (if (fneq (linear->db .25) -12.0411996841431) (snd-display "linear->db: ~F?" (linear->db .25)))
    (if (fneq (db->linear -12.0411996841431) .25) (snd-display "db->linear: ~F?" (db->linear -12.0411996841431)))

    (if (fneq (odd-weight 0.0) 0.0) (snd-display "odd-weight 0.0: ~F?" (odd-weight 0.0)))
    (if (fneq (odd-weight 2.0) 0.0) (snd-display "odd-weight 2.0: ~F?" (odd-weight 2.0)))
    (if (fneq (odd-weight 1.0) 1.0) (snd-display "odd-weight 1.0: ~F?" (odd-weight 1.0)))
    (if (fneq (odd-weight 1.5) 0.5) (snd-display "odd-weight 1.5: ~F?" (odd-weight 1.5)))
    (if (fneq (odd-weight 2.5) 0.5) (snd-display "odd-weight 2.5: ~F?" (odd-weight 2.5)))
    (if (fneq (odd-weight 2.1) 0.1) (snd-display "odd-weight 2.1: ~F?" (odd-weight 2.1)))
    (if (fneq (odd-weight 2.9) 0.9) (snd-display "odd-weight 2.9: ~F?" (odd-weight 2.9)))
    (if (fneq (odd-weight 1.1) 0.9) (snd-display "odd-weight 1.1: ~F?" (odd-weight 1.1)))
    (if (fneq (odd-weight 1.9) 0.1) (snd-display "odd-weight 1.9: ~F?" (odd-weight 1.9)))

    (if (fneq (even-weight 0.0) 1.0) (snd-display "even-weight 0.0: ~F?" (even-weight 0.0)))
    (if (fneq (even-weight 2.0) 1.0) (snd-display "even-weight 2.0: ~F?" (even-weight 2.0)))
    (if (fneq (even-weight 1.0) 0.0) (snd-display "even-weight 1.0: ~F?" (even-weight 1.0)))
    (if (fneq (even-weight 1.5) 0.5) (snd-display "even-weight 1.5: ~F?" (even-weight 1.5)))
    (if (fneq (even-weight 2.5) 0.5) (snd-display "even-weight 2.5: ~F?" (even-weight 2.5)))
    (if (fneq (even-weight 2.1) 0.9) (snd-display "even-weight 2.1: ~F?" (even-weight 2.1)))
    (if (fneq (even-weight 2.9) 0.1) (snd-display "even-weight 2.9: ~F?" (even-weight 2.9)))
    (if (fneq (even-weight 1.1) 0.1) (snd-display "even-weight 1.1: ~F?" (even-weight 1.1)))
    (if (fneq (even-weight 1.9) 0.9) (snd-display "even-weight 1.9: ~F?" (even-weight 1.9)))

    (if (fneq (odd-multiple 0.0 2.0) 2.0) (snd-display "odd-multiple 0.0: ~F?" (odd-multiple 0.0 2.0)))
    (if (fneq (odd-multiple 2.0 2.0) 6.0) (snd-display "odd-multiple 2.0: ~F?" (odd-multiple 2.0 2.0)))
    (if (fneq (odd-multiple 1.0 2.0) 2.0) (snd-display "odd-multiple 1.0: ~F?" (odd-multiple 1.0 2.0)))
    (if (fneq (odd-multiple 1.5 2.0) 2.0) (snd-display "odd-multiple 1.5: ~F?" (odd-multiple 1.5 2.0)))
    (if (fneq (odd-multiple 2.5 2.0) 6.0) (snd-display "odd-multiple 2.5: ~F?" (odd-multiple 2.5 2.0)))
    (if (fneq (odd-multiple 2.1 2.0) 6.0) (snd-display "odd-multiple 2.1: ~F?" (odd-multiple 2.1 2.0)))
    (if (fneq (odd-multiple 2.9 2.0) 6.0) (snd-display "odd-multiple 2.9: ~F?" (odd-multiple 2.9 2.0)))
    (if (fneq (odd-multiple 1.1 2.0) 2.0) (snd-display "odd-multiple 1.1: ~F?" (odd-multiple 1.1 2.0)))
    (if (fneq (odd-multiple 1.9 2.0) 2.0) (snd-display "odd-multiple 1.9: ~F?" (odd-multiple 1.9 2.0)))

    (if (fneq (even-multiple 0.0 2.0) 0.0) (snd-display "even-multiple 0.0: ~F?" (even-multiple 0.0 2.0)))
    (if (fneq (even-multiple 2.0 2.0) 4.0) (snd-display "even-multiple 2.0: ~F?" (even-multiple 2.0 2.0)))
    (if (fneq (even-multiple 1.0 2.0) 4.0) (snd-display "even-multiple 1.0: ~F?" (even-multiple 1.0 2.0)))
    (if (fneq (even-multiple 1.5 2.0) 4.0) (snd-display "even-multiple 1.5: ~F?" (even-multiple 1.5 2.0)))
    (if (fneq (even-multiple 2.5 2.0) 4.0) (snd-display "even-multiple 2.5: ~F?" (even-multiple 2.5 2.0)))
    (if (fneq (even-multiple 2.1 2.0) 4.0) (snd-display "even-multiple 2.1: ~F?" (even-multiple 2.1 2.0)))
    (if (fneq (even-multiple 2.9 2.0) 4.0) (snd-display "even-multiple 2.9: ~F?" (even-multiple 2.9 2.0)))
    (if (fneq (even-multiple 1.1 2.0) 4.0) (snd-display "even-multiple 1.1: ~F?" (even-multiple 1.1 2.0)))
    (if (fneq (even-multiple 1.9 2.0) 4.0) (snd-display "even-multiple 1.9: ~F?" (even-multiple 1.9 2.0)))

    (if (fneq (ring-modulate .4 .5) .2) (snd-display "ring-modulate: ~F?" (ring-modulate .4 .5)))
    (if (fneq (amplitude-modulate 1.0 .5 .4) .7) (snd-display "amplitude-modulate: ~F?" (amplitude-modulate 1.0 .5 .4)))
    (if (fneq (contrast-enhancement 0.1 0.75) (sin (+ (* 0.1 (/ pi 2)) (* .75 (sin (* 0.1 2.0 pi))))))
	(snd-display "contrast-enhancement: ~F (0.562925306221587)" (contrast-enhancement 0.1 0.75)))
    (if (fneq (contrast-enhancement 1.0) 1.0) (snd-display "contrast-enhancement opt: ~A" (contrast-enhancement 1.0)))
    (let ((lv0 (partials->polynomial #r(1 1 2 1) mus-chebyshev-first-kind)))
      (if (not (mus-arrays-equal? lv0 #r(-1.000 1.000 2.000) .001)) (snd-display "partials->polynomial(1): ~A?" lv0)))
    (let ((lv1 (partials->polynomial '(1 1 2 1) mus-chebyshev-second-kind)))
      (if (not (mus-arrays-equal? lv1 #r(1.000 2.000 0.0) .001)) (snd-display "partials->polynomial(2): ~A?" lv1)))
    (let ((lv2 (partials->polynomial '(1 1 2 1 3 1 5 1) mus-chebyshev-first-kind)))
      (if (not (mus-arrays-equal? lv2 #r(-1.000 3.000 2.000 -16.000 0.000 16.000) .001)) (snd-display "partials->polynomial(3): ~A?" lv2)))
    (let ((lv3 (partials->polynomial '(1 1 2 1 3 1 5 1) mus-chebyshev-second-kind)))
      (if (not (mus-arrays-equal? lv3 #r(1.000 2.000 -8.000 0.000 16.000 0.000) .001)) (snd-display "partials->polynomial(4): ~A?" lv3)))
    (let ((lv4 (partials->polynomial '(1 1 2 .5 3 .1 6 .01) mus-chebyshev-first-kind)))
      (if (not (mus-arrays-equal? lv4 #r(-0.510 0.700 1.180 0.400 -0.480 0.000 0.320) .001)) (snd-display "partials->polynomial(5): ~A?" lv4)))
    (let ((lv5 (partials->polynomial '(1 1 2 .5 3 .1 6 .01) mus-chebyshev-second-kind)))
      (if (not (mus-arrays-equal? lv5 #r(0.900 1.060 0.400 -0.320 0.000 0.320 0.000) .001)) (snd-display "partials->polynomial(6): ~A?" lv5)))
    (let ((lv6 (partials->polynomial #r(1 9 2 3 3 5 4 7 5 1))))
      (if (not (mus-arrays-equal? lv6 #r(4.000 -1.000 -50.000 0.000 56.000 16.000))) (snd-display "partials->polynomial(7): ~A?" lv6)))
    (let ((lv7 (partials->polynomial '(7 1))))
      (if (not (mus-arrays-equal? lv7 #r(0.000 -7.000 0.000 56.000 0.000 -112.000 0.000 64.000))) (snd-display "partials->polynomial(8): ~A?" lv7))
      (let ((lv7a (partials->polynomial '(7 1) mus-chebyshev-first-kind)))
	(if (not (mus-arrays-equal? lv7 lv7a)) (snd-display "partials->polynomial kind=1? ~A ~A" lv7 lv7a)))
      (if (fneq (polynomial lv7 1.0) (cosh (* 7 (acosh 1.0)))) 
	  (snd-display "ccosh cheb 7 1.0: ~A ~A" (polynomial lv7 1.0) (cosh (* 7 (acosh 1.0)))))
      (if (fneq (polynomial lv7 1.0) (cos (* 7 (acos 1.0)))) 
	  (snd-display "cos cheb 7 1.0: ~A ~A" (polynomial lv7 1.0) (cos (* 7 (acos 1.0)))))  
      (do ((lv8 (partials->polynomial '(7 1) mus-chebyshev-second-kind))
	   (sa (sin (acos 0.5)))
	   (ca (sin (* 7 (acos 0.5))))
	   (i 0 (+ i 1)))
	  ((= i 10))
	(let* ((val (mus-random 1.0))
	       (aval (acos val)))
	  (if (fneq (polynomial lv7 val) (cosh (* 7 (acosh val)))) 
	      (snd-display "ccosh cheb 7 ~A: ~A ~A" val (polynomial lv7 val) (cosh (* 7 (acosh val)))))
	  (if (fneq (polynomial lv7 val) (cos (* 7 aval)))
	      (snd-display "cos cheb 7 ~A: ~A ~A" val (polynomial lv7 val) (cos (* 7 aval))))
	  (if (fneq (polynomial lv8 val) (/ (sin (* 7 aval)) (sin aval)))
	      (snd-display "acos cheb 7 ~A: ~A ~A" val (polynomial lv8 val) (/ (sin (* 7 aval)) (sin aval)))))
	(if (not (mus-arrays-equal? lv8 #r(-1.000 0.000 24.000 0.000 -80.000 0.000 64.000 0.000))) (snd-display "partials->polynomial(9): ~A?" lv8))
	(if (fneq (polynomial lv8 0.5) (/ ca sa))
	    (snd-display "acos cheb 7 1.0: ~A ~A" (polynomial lv8 0.5) (/ ca sa)))))
    ;; G&R 8.943 p 984 uses n+1 where we use n in Un? (our numbering keeps harmonics aligned between Tn and Un)
    
    (if (not (mus-arrays-equal? (normalize-partials (list 1 1 2 1)) #r(1.000 0.500 2.000 0.500)))
	(snd-display "normalize-partials 1: ~A" (normalize-partials (list 1 1 2 1))))
    (if (not (mus-arrays-equal? (normalize-partials #r(1 1 2 1)) #r(1.000 0.500 2.000 0.500)))
	(snd-display "normalize-partials 2: ~A" (normalize-partials #r(1 1 2 1))))
    (if (not (mus-arrays-equal? (normalize-partials #r(1 1 2 -1)) #r(1.000 0.500 2.000 -0.500)))
	(snd-display "normalize-partials 3: ~A" (normalize-partials #r(1 1 2 -1))))
    (if (not (mus-arrays-equal? (normalize-partials #r(1 -.1 2 -.1)) #r(1.000 -0.500 2.000 -0.500)))
	(snd-display "normalize-partials 4: ~A" (normalize-partials #r(1 -.1 2 -.1))))
    (if (not (mus-arrays-equal? (normalize-partials #r(0 2 1 1 4 1)) #r(0.000 0.500 1.000 0.250 4.000 0.250)))
	(snd-display "normalize-partials 4: ~A" (normalize-partials #r(0 2 1 1 4 1))))
    
    ;; check phase-quadrature cancellations
    (do ((cos-coeffs (partials->polynomial '(1 1 2 1) mus-chebyshev-first-kind))
	 (sin-coeffs (partials->polynomial #r(1 1 2 1) mus-chebyshev-second-kind))
	 (incr (/ (* 2 pi 440.0) 22050.0))
	 (i 0 (+ i 1))
	 (a 0.0))
	((= i 1100))
      (let ((x (cos a)))
	(let ((y (sin a))
	      (cax (polynomial cos-coeffs x))
	      (sax (polynomial sin-coeffs x)))
	  (let ((upper (- (* (cos (* 2 a)) cax) (* (sin (* 2 a)) y sax)))
		(lower (+ (* (cos (* 2 a)) cax) (* (sin (* 2 a)) y sax)))
		(upper2 (+ (cos (* a 3)) (cos (* a 4))))
		(lower2 (+ 1.0 (cos a))))
	    (if (or (fneq upper upper2)
		    (fneq lower lower2))
		(snd-display "~A ~A, ~A ~A" upper upper2 lower lower2)))))
      (set! a (+ a incr)))
    
    (let ((tag (catch #t (lambda () (harmonicizer 550.0 '(.5 .3 .2) 10)) (lambda args (car args)))))
      (if (not (eq? tag 'no-data)) (snd-display "odd length arg to partials->polynomial: ~A" tag)))
    
    (let ((rdat (make-float-vector 16))
	  (idat (make-float-vector 16))
	  (vdat (make-float-vector 16)))
      (set! (rdat 0) 1.0)
      (set! (vdat 0) 1.0)
      (let ((v0 (spectrum rdat idat (make-fft-window rectangular-window 16) 1)) ;rectangular here to avoid clobbering 0-th data point
	    (v1 (snd-spectrum vdat rectangular-window 16 #t)))
	(do ((i 0 (+ i 1)))
	    ((= i 8)) ;should all be 1.0 (impulse in)
	  (if (fneq (v0 i) (v1 i))
	      (snd-display "spectra not equal 1: ~A ~A" v0 v1))))
      (float-vector-scale! idat 0.0)
      (float-vector-scale! rdat 0.0)
      (set! (rdat 0) 1.0)
      (let ((v0 (spectrum rdat idat (make-fft-window rectangular-window 17) 1)) ;rectangular here to avoid clobbering 0-th data point
	    (v1 (snd-spectrum vdat rectangular-window 16 #t)))
	(do ((i 0 (+ i 1)))
	    ((= i 8)) ;should all be 1.0 (impulse in)
	  (if (fneq (v0 i) (v1 i))
	      (snd-display "spectra not equal 0: ~A ~A" v0 v1))))
      (let ((var (catch #t (lambda () (spectrum rdat idat #f -1)) (lambda args args))))
	(if (or (float-vector? var) 
		(not (eq? (car var) 'out-of-range)))
	    (snd-display "spectrum bad type: ~A" var))))
    
    (let ((rdat (make-float-vector 16))
	  (idat (make-float-vector 16))
	  (xdat (make-float-vector 16))
	  (ydat (make-float-vector 16)))
      (set! (rdat 3) 1.0)
      (set! (xdat 3) 1.0)
      (fft rdat idat 1)
      (mus-fft xdat ydat 16 1)
      (if (fneq (rdat 0) (xdat 0)) (snd-display "ffts: ~A ~A?" rdat xdat))
      (fft rdat idat -1)
      (mus-fft xdat ydat 17 -1) ; mistake is deliberate
      (do ((i 0 (+ i 1)))
	  ((= i 16))
	(if (if (= i 3)
		(or (fneq (rdat i) 16.0) (fneq (xdat i) 16.0))
		(or (fneq (rdat i) 0.0) (fneq (xdat i) 0.0)))
	    (snd-display "fft real[~D]: ~A ~A?" i (rdat i) (xdat i)))
	(if (or (fneq (idat i) 0.0) (fneq (ydat i) 0.0))
	    (snd-display "fft imag[~D]: ~A ~A?" i (idat i) (ydat i))))
      (let ((var (catch #t (lambda () (mus-fft xdat ydat -1 0)) (lambda args args))))
	(if (not (eq? (car var) 'out-of-range))
	    (snd-display "mus-fft bad len: ~A" var))))
    
    (let ((rdat (make-float-vector 20))
	  (idat (make-float-vector 19)))
      (set! (rdat 3) 1.0)
      (mus-fft rdat idat)
      (convolution rdat idat)
      (spectrum rdat idat #f))
    
    (let ((v0 (make-float-vector 10 1.0))
	  (v1 (make-float-vector 10 0.5)))
      (float-vector-multiply! v0 v1)
      (if (fneq (v0 0) 0.5) (snd-display "multiple-arrays: ~F?" (v0 0)))
      (let ((sum (dot-product v0 v1)))
	(if (fneq sum 2.5) (snd-display "dot-product: ~F?" sum)))
      (let ((sum (dot-product v0 v1 10)))
	(if (fneq sum 2.5) (snd-display "dot-product (10): ~F?" sum)))
      (let ((sum (dot-product v0 v1 3)))
	(if (fneq sum 0.75) (snd-display "dot-product (3): ~F?" sum)))
      (fill! v0 0.0)
      (if (fneq (v0 3) 0.0) (snd-display "fill!: ~A?" v0))
      (fill! v0 1.0)
      (fill! v1 0.5)
      (let ((v2 (rectangular->polar v0 v1)))
	(if (fneq (v2 0) 1.118) (snd-display "rectangular->polar: ~A?" v2)))
      (set! (v0 0) 1.0)
      (set! (v1 0) 1.0)
      (rectangular->polar v0 v1)
      (if (or (fneq (v0 0) (sqrt 2.0))
	      (fneq (v1 0) (- (atan 1.0 1.0)))) ;(tan (atan 1.0 1.0)) -> 1.0 
	  (snd-display "rectangular->polar (~A ~A): ~A ~A?" (sqrt 2.0) (- (atan 1.0 1.0)) (v0 0) (v1 0)))
      (polar->rectangular v0 v1)
      (if (or (fneq (v0 0) 1.0)
	      (fneq (v1 0) 1.0))
	  (snd-display "polar->rectangular (1 1): ~A ~A?" (v0 0) (v1 0)))
      
      (let ((ind (open-sound "oboe.snd"))
	    (rl (channel->float-vector 1200 512))
	    (im (make-float-vector 512)))
	(fft rl im 512)
	(let ((rl-copy (copy rl))
	      (im-copy (copy im)))
	  (rectangular->polar rl im)
	  (polar->rectangular rl im)
	  (do ((i 0 (+ i 1)))
	      ((= i 512))
	    (if (or (fneq (rl i) (rl-copy i))
		    (fneq (im i) (im-copy i)))
		(snd-display "polar->rectangular[~D]: ~A ~A ~A ~A" 
			     i 
			     (rl i) (rl-copy i)
			     (im i) (im-copy i)))))
	(close-sound ind)))
    
    (let ((v0 (make-float-vector 8))
	  (v1 (make-float-vector 8)))
      (do ((i 0 (+ i 1))) ((= i 8)) (set! (v0 i) i) (set! (v1 i) (/ (+ i 1))))
      (rectangular->magnitudes v0 v1)
      (if (not (mus-arrays-equal? v0 #r(1.000 1.118 2.028 3.010 4.005 5.003 6.002 7.001)))
	  (snd-display "rectangular->magnitudes v0: ~A" v0)))
    
    (do ((v0 (make-float-vector 8))
	 (v1 (make-float-vector 8))
	 (v2 (make-float-vector 8))
	 (v3 (make-float-vector 8))
	 (i 0 (+ i 1)))
	((= i 8)
	 (rectangular->magnitudes v0 v1)
	 (rectangular->polar v2 v3)
	 (if (not (mus-arrays-equal? v0 v2))
	     (snd-display "rectangular->magnitudes|polar: ~A ~A" v0 v2)))
      (let ((val1 (random 1.0))
	    (val2 (random 1.0)))
	(set! (v0 i) val1)
	(float-vector-set! v2 i val1)
	(float-vector-set! v1 i val2)
	(float-vector-set! v3 i val2)))
    
    (when (defined? 'edot-product) ; needs complex numbers in C
      (let* ((vals (make-float-vector 1 1.0))
	     (v1 (edot-product 0.0 vals)))
	(if (fneq v1 1.0) ; exp 0.0 * 1.0
	    (snd-display "edot a 1.0: ~A" v1))
	(set! (vals 0) 0.0)
	(set! v1 (edot-product 0.0 vals))
	(if (fneq v1 0.0) ; exp 0.0 * 0.0
	    (snd-display "edot b 0.0: ~A" v1))
	(set! vals (make-vector 1 1.0))
	(set! v1 (edot-product 0.0 vals))  
	(if (fneq v1 1.0) ; exp 0.0 * 1.0
	    (snd-display "edot c 1.0: ~A" v1))
	(set! (vals 0) 0.0+i)
	(set! v1 (edot-product 0.0 vals))
	(if (cneq v1 0.0+i)
	    (snd-display "edot i: ~A" v1))
	(set! vals (make-float-vector 4 1.0))
	(set! v1 (edot-product (* 0.25 2 pi) vals))
	(let ((v2 (+ 1 ;(exp (* 0 2 pi))
		     (exp (* 0.25 2 pi))
		     (exp (* 0.5 2 pi))
		     (exp (* 0.75 2 pi)))))
	  (if (fneq v1 v2) (snd-display "edot 4: ~A ~A" v1 v2)))
	(set! vals (make-vector 4 0.0))  
	(do ((i 0 (+ i 1)))
	    ((= i 4))
	  (set! (vals i) (+ i 1.0)))
	(set! v1 (edot-product (* 0.25 2 pi 0.0-i) vals))
	(let ((v2 (+ 1
		     (* 2 (exp (* 0.25 2 pi 0.0-i)))
		     (* 3 (exp (* 0.5 2 pi 0.0-i)))
		     (* 4 (exp (* 0.75 2 pi 0.0-i))))))
	  (if (cneq v1 v2) (snd-display "edot 4 -i: ~A ~A" v1 v2)))
	(do ((i 0 (+ i 1)))
	    ((= i 4))
	  (set! (vals i) (+ i 1.0+i)))
	(set! v1 (edot-product (* 0.25 2 pi 0.0-i) vals))
	(let ((v2 (+ 1+i
		     (* 2+i (exp (* 0.25 2 pi 0.0-i)))
		     (* 3+i (exp (* 0.5 2 pi 0.0-i)))
		     (* 4+i (exp (* 0.75 2 pi 0.0-i))))))
	  (if (cneq v1 v2) (snd-display "edot 4 -i * i: ~A ~A" v1 v2)))))
    
    (let ((v0 (make-float-vector 3)))
      (set! (v0 0) 1.0)
      (set! (v0 1) 0.5)
      (set! (v0 2) 0.1)
      (if (or (fneq (polynomial v0 0.0) 1.0)
	      (fneq (polynomial v0 1.0) 1.6)
	      (fneq (polynomial v0 2.0) 2.4))
	  (snd-display "polynomial: ~A ~A ~A?"
		       (polynomial v0 0.0)
		       (polynomial v0 1.0)
		       (polynomial v0 2.0))))
    (if (fneq (polynomial #r(0.0 2.0) 0.5) 1.0) 
	(snd-display "polynomial 2.0 * 0.5: ~A" (polynomial #r(2.0) 0.5)))
    (let ((var (catch #t (lambda () (polynomial #f 1.0)) (lambda args args))))
      (if (not (eq? (car var) 'wrong-type-arg))
	  (snd-display "polynomial empty coeffs: ~A" var)))
    
    (do ((i 0 (+ i 1)))
	((= i 100))
      (let ((arg1 (- (random 100.0) 50.0))
	    (arg2 (- (random 100.0) 50.0)))
	(let ((val1 (modulo arg1 arg2))
	      (val2 (modulo arg1 arg2)))
	  (if (and (> (abs (- val1 val2)) 1e-8)
		   (> (abs (- (abs (- val1 val2)) (abs arg2))) 1e-8))
	      (snd-display "poly ~A ~A: ~A ~A -> ~A~%" arg1 arg2 val1 val2 (abs (- val1 val2)))))))
    
    (let ((err 0.0)
	  (coeffs #r(1.0 0.0 -.4999999963 0.0 .0416666418 0.0 -.0013888397 0.0 .0000247609 0.0 -.0000002605))
	  (pi2 (* pi 0.5)))
      (let ((new-cos
	     (lambda (x)
	       (let ((xx (abs x)))
		 (if (<= xx pi2)
		     (polynomial coeffs xx)
		     (let ((nxx (modulo xx (* 2 pi))))
		       (cond ((<= nxx pi2)        (polynomial coeffs nxx))
			     ((<= nxx pi)        (- (polynomial coeffs (- pi nxx))))
			     ((< nxx (* 1.5 pi)) (- (polynomial coeffs (- nxx pi))))
			     (else               (polynomial coeffs (- (* 2 pi) nxx))))))))))
	(do ((i 0 (+ i 1))
	     (x -10.0 (+ x .01)))
	    ((= i 2000))
	  (set! err (max err (abs (- (cos x) (new-cos x))))))
	(if (> err 1.1e-7) (snd-display "new-cos poly err: ~A" err))))
    
    (let ((val (poly+ #r(.1 .2 .3) #r(0.0 1.0 2.0 3.0 4.0))))
      (if (not (mus-arrays-equal? val #r(0.100 1.200 2.300 3.000 4.000))) (snd-display "poly+ 1: ~A" val)))
    
    (let ((val (poly+ #r(.1 .2 .3) .5)))
      (if (not (mus-arrays-equal? val #r(0.600 0.200 0.300))) (snd-display "poly+ 2: ~A" val)))
    (let ((val (poly+ .5 #r(.1 .2 .3))))
      (if (not (mus-arrays-equal? val #r(0.600 0.200 0.300))) (snd-display "poly+ 3: ~A" val)))
    
    (let ((val (poly* #r(1 1) #r(-1 1))))
      (if (not (mus-arrays-equal? val #r(-1.000 0.000 1.000 0.000))) (snd-display "poly* 1: ~A" val)))
    (let ((val (poly* #r(-5 1) #r(3 7 2))))
      (if (not (mus-arrays-equal? val #r(-15.000 -32.000 -3.000 2.000 0.000))) (snd-display "poly* 2: ~A" val)))
    (let ((val (poly* #r(-30 -4 2) #r(0.5 1))))
      (if (not (mus-arrays-equal? val #r(-15.000 -32.000 -3.000 2.000 0.000))) (snd-display "poly* 3: ~A" val)))
    (let ((val (poly* #r(-30 -4 2) 0.5)))
      (if (not (mus-arrays-equal? val #r(-15.000 -2.000 1.000))) (snd-display "poly* 4: ~A" val)))
    (let ((val (poly* 2.0 #r(-30 -4 2))))
      (if (not (mus-arrays-equal? val #r(-60.000 -8.000 4.000))) (snd-display "poly* 5: ~A" val)))
    
    (let ((val (poly/ #r(-1.0 0.0 1.0) #r(1.0 1.0))))
      (if (not (and (mus-arrays-equal? (car val) #r(-1.000 1.000 0.000))
		    (mus-arrays-equal? (cadr val) (make-float-vector 3))))
	  (snd-display "poly/ 1: ~A" val)))
    (let ((val (poly/ #r(-15 -32 -3 2) #r(-5 1))))
      (if (not (and (mus-arrays-equal? (car val) #r(3.000 7.000 2.000 0.000))
		    (mus-arrays-equal? (cadr val) (make-float-vector 4))))
	  (snd-display "poly/ 2: ~A" val)))
    (let ((val (poly/ #r(-15 -32 -3 2) #r(3 1))))
      (if (not (and (mus-arrays-equal? (car val) #r(-5.000 -9.000 2.000 0.000))
		    (mus-arrays-equal? (cadr val) (make-float-vector 4))))
	  (snd-display "poly/ 3: ~A" val)))
    (let ((val (poly/ #r(-15 -32 -3 2) #r(.5 1))))
      (if (not (and (mus-arrays-equal? (car val) #r(-30.000 -4.000 2.000 0.000))
		    (mus-arrays-equal? (cadr val) (make-float-vector 4))))
	  (snd-display "poly/ 4: ~A" val)))
    (let ((val (poly/ #r(-15 -32 -3 2) #r(3 7 2))))
      (if (not (and (mus-arrays-equal? (car val) #r(-5.000 1.000 0.000 0.000))
		    (mus-arrays-equal? (cadr val) (make-float-vector 4))))
	  (snd-display "poly/ 5: ~A" val)))
    (let ((val (poly/ #r(-15 -32 -3 2) 2.0)))
      (if (not (mus-arrays-equal? (car val) #r(-7.500 -16.000 -1.500 1.000)))
	  (snd-display "poly/ 6: ~A" val)))
    (let ((val (poly/ #r(-1.0 0.0 0.0 0.0 1.0) #r(1.0 0.0 1.0))))
      (if (not (and (mus-arrays-equal? (car val) #r(-1.0 0.0 1.0 0.0 0.0))
		    (mus-arrays-equal? (cadr val) (make-float-vector 5))))
	  (snd-display "poly/ 7: ~A" val)))
    (let ((val (poly/ #r(-1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0) #r(1.0 0.0 0.0 0.0 1.0))))
      (if (not (and (mus-arrays-equal? (car val) #r(-1.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0))
		    (mus-arrays-equal? (cadr val) (make-float-vector 9))))
	  (snd-display "poly/ 8: ~A" val)))
    (let ((val (poly/ #r(-1.0 0.0 1.0) #r(-1.0 0.0 1.0))))
      (if (not (and (mus-arrays-equal? (car val) #r(1.0 0.0 0.0))
		    (mus-arrays-equal? (cadr val) (make-float-vector 3))))
	  (snd-display "poly/ 9: ~A" val)))
    (let ((val (poly/ #r(-1.0 0.0 1.0) #r(2.0 1.0))))
      (if (not (and (mus-arrays-equal? (car val) #r(-2.000 1.000 0.000))
		    (mus-arrays-equal? (cadr val) #r(3.000 0.000 0.000))))
	  (snd-display "poly/ 10: ~A" val)))
    (let ((val (poly/ #r(2 1) #r(-1.0 0.0 1.0))))
      (if (not (and (mus-arrays-equal? (car val) #r(0.0))
		    (mus-arrays-equal? (cadr val) #r(-1.000 0.000 1.000))))
	  (snd-display "poly/ 11: ~A" val)))
    (let ((val (poly/ #r(1 2 3 0 1) #r(0 0 0 1))))
      (if (not (and (mus-arrays-equal? (car val) #r(0.000 1.000 0.000 0.000 0.000))
		    (mus-arrays-equal? (cadr val) #r(1.000 2.000 3.000 0.000 0.000))))
	  (snd-display "poly/ 12: ~A" val)))
    
    (let ((ind (open-sound "1a.snd")))
      (let ((v1 (channel->float-vector 0 100 ind 0))
	    (v2 (channel->float-vector 0 100 ind 0)))
	(let ((vals (car (poly/ v1 v2)))
	      (res (make-float-vector 100)))
	  (set! (res 0) 1.0)
	  (if (not (mus-arrays-equal? vals res))
	      (snd-display "poly1 1a: ~A" vals))))
      (close-sound ind))
    
    (let ((val (poly-derivative #r(0.5 1.0 2.0 4.0))))
      (if (not (mus-arrays-equal? val #r(1.000 4.000 12.000))) (snd-display "poly-derivative: ~A" val)))
    
    (let ((val (poly-reduce #r(1 2 3))))
      (if (not (mus-arrays-equal? val #r(1.000 2.000 3.000))) (snd-display "poly-reduce 1: ~A" val)))
    (let ((val (poly-reduce #r(1 2 3 0 0 0))))
      (if (not (mus-arrays-equal? val #r(1.000 2.000 3.000))) (snd-display "poly-reduce 2: ~A" val)))
    (let ((val (poly-reduce #r(0 0 0 0 1 0))))
      (if (not (mus-arrays-equal? val #r(0.000 0.000 0.000 0.000 1.000))) (snd-display "poly-reduce 3: ~A" val)))
    
    (let ((vals (poly-gcd (poly-reduce (poly* #r(2 1) #r(-3 1))) #r(2 1))))
      (if (not (mus-arrays-equal? vals #r(2.000 1.000))) (snd-display "poly-gcd 1: ~A" vals)))
    (let ((vals (poly-gcd (poly-reduce (poly* #r(2 1) #r(-3 1))) #r(3 1))))
      (if (not (mus-arrays-equal? vals #r(0.000))) (snd-display "poly-gcd 2: ~A" vals)))
    (let ((vals (poly-gcd (poly-reduce (poly* #r(2 1) #r(-3 1))) #r(-3 1))))
      (if (not (mus-arrays-equal? vals #r(-3.000 1.000))) (snd-display "poly-gcd 2: ~A" vals)))
    (let ((vals (poly-gcd (poly-reduce (poly* #r(8 1) (poly* #r(2 1) #r(-3 1)))) #r(-3 1))))
      (if (not (mus-arrays-equal? vals #r(-3.000 1.000))) (snd-display "poly-gcd 3: ~A" vals)))
    (let ((vals (poly-gcd (poly-reduce (poly* #r(8 1) (poly* #r(2 1) #r(-3 1)))) (poly-reduce (poly* #r(8 1) #r(-3 1))))))
      (if (not (mus-arrays-equal? vals #r(-24.000 5.000 1.000))) (snd-display "poly-gcd 4: ~A" vals)))
    (let ((vals (poly-gcd #r(-1 0 1) #r(2 -2 -1 1))))
      (if (not (mus-arrays-equal? vals #r(0.000))) (snd-display "poly-gcd 5: ~A" vals)))
    (let ((vals (poly-gcd #r(2 -2 -1 1) #r(-1 0 1))))
      (if (not (mus-arrays-equal? vals #r(1.000 -1.000))) (snd-display "poly-gcd 6: ~A" vals)))
    (let ((vals (poly-gcd #r(2 -2 -1 1) #r(-2.5 1))))
      (if (not (mus-arrays-equal? vals #r(0.000))) (snd-display "poly-gcd 7: ~A" vals)))
    
    (poly-roots-tests)
    
    (let ((val (poly-as-vector-resultant (vector -1 0 1) (vector 1 -2 1))))
      (if (fneq val 0.0) (snd-display "poly-resultant 0: ~A" val)))
    (let ((val (poly-as-vector-resultant (vector -1 0 2) (vector 1 -2 1))))
      (if (fneq val 1.0) (snd-display "poly-resultant 1: ~A" val)))
    (let ((val (poly-as-vector-resultant (vector -1 0 1) (vector 1 1))))
      (if (fneq val 0.0) (snd-display "poly-resultant 2: ~A" val)))
    (let ((val (poly-as-vector-resultant (vector -1 0 1) (vector 2 1))))
      (if (fneq val 3.0) (snd-display "poly-resultant 3: ~A" val)))
    (let ((val (poly-resultant #r(-1 0 1) #r(1 -2 1))))
      (if (fneq val 0.0) (snd-display "poly-resultant 0: ~A" val)))
    
    (let ((val (poly-as-vector-discriminant (vector -1 0 1))))
      (if (fneq val -4.0) (snd-display "poly-discriminant 0: ~A" val)))
    (let ((val (poly-as-vector-discriminant (vector 1 -2 1))))
      (if (fneq val 0.0) (snd-display "poly-discriminant 1: ~A" val)))
    (let ((val (poly-discriminant (poly-reduce (poly* (poly* #r(-1 1) #r(-1 1)) #r(3 1))))))
      (if (fneq val 0.0) (snd-display "poly-discriminant 2: ~A" val)))
    (let ((val (poly-discriminant (poly-reduce (poly* (poly* (poly* #r(-1 1) #r(-1 1)) #r(3 1)) #r(2 1))))))
      (if (fneq val 0.0) (snd-display "poly-discriminant 3: ~A" val)))
    (let ((val (poly-discriminant (poly-reduce (poly* (poly* (poly* #r(1 1) #r(-1 1)) #r(3 1)) #r(2 1))))))
      (if (fneq val 2304.0) (snd-display "poly-discriminant 4: ~A" val)))
    (let ((val (poly-discriminant (poly-reduce (poly* (poly* (poly* #r(1 1) #r(-1 1)) #r(3 1)) #r(3 1))))))
      (if (fneq val 0.0) (snd-display "poly-discriminant 5: ~A" val)))
    
    
    (let ((v0 (make-float-vector 10)))
      (do ((i 0 (+ i 1))) ((= i 10))
	(set! (v0 i) i))
      (if (fneq (array-interp v0 3.5) 3.5) (snd-display "array-interp: ~F?" (array-interp v0 3.5)))
      (if (fneq (array-interp v0 13.5) 3.5) (snd-display "array-interp(13.5): ~F?" (array-interp v0 13.5)))
      (if (fneq (array-interp v0 -6.5) 3.5) (snd-display "array-interp(-6.5): ~F?" (array-interp v0 -6.5)))
      (if (fneq (array-interp v0 103.6) 3.6) (snd-display "array-interp(103.5): ~F?" (array-interp v0 103.6)))
      (if (fneq (array-interp v0 -106.6) 3.4) (snd-display "array-interp(-106.6): ~F?" (array-interp v0 -106.6)))
      (if (fneq (array-interp v0 -0.5) 4.5) (snd-display "array-interp(-0.5): ~F?" (array-interp v0 -0.5)))
      ;; interpolating between 9 and 0 here (confusing...)
      (if (fneq (array-interp v0 -0.9) 8.1) (snd-display "array-interp(-0.9): ~F?" (array-interp v0 -0.9)))
      (if (fneq (array-interp v0 -0.1) 0.9) (snd-display "array-interp(-0.1): ~F?" (array-interp v0 -0.1)))
      (if (fneq (array-interp v0 9.1) 8.1) (snd-display "array-interp(9.1): ~F?" (array-interp v0 9.1)))
      (if (fneq (array-interp v0 9.9) 0.9) (snd-display "array-interp(9.9): ~F?" (array-interp v0 9.9)))
      (if (fneq (array-interp v0 10.1) 0.1) (snd-display "array-interp(10.1): ~F?" (array-interp v0 10.1)))
      (let ((var (catch #t (lambda () (array-interp v0 1 -10)) (lambda args args))))
	(if (not (eq? (car var) 'out-of-range))
	    (snd-display "array-interp bad index: ~A" var))))
    
    (let ((ind (open-sound "oboe.snd")))
      (let ((diff (array-interp-sound-diff ind 0)))
	(if (> diff .00001) (snd-display "array-interp-sound-diff: ~A" diff)))
      (close-sound ind))
    
    (let ((v0 (make-float-vector 10)))
      (do ((i 0 (+ i 1))) ((= i 10))
	(set! (v0 i) i))
      (let ((val (mus-interpolate mus-interp-linear 1.5 v0)))
	(if (fneq val 1.5) (snd-display "mus-interpolate linear: ~A" val))
	(set! val (mus-interpolate mus-interp-all-pass 1.5 v0))
	(if (fneq val 1.5) (snd-display "mus-interpolate all-pass: ~A" val))
	(set! val (mus-interpolate mus-interp-none 1.5 v0))
	(if (fneq val 1.0) (snd-display "mus-interpolate none: ~A" val))
	(set! val (mus-interpolate mus-interp-hermite 1.5 v0))
	(if (fneq val 1.5) (snd-display "mus-interpolate hermite: ~A" val))
	(set! val (mus-interpolate mus-interp-bezier 1.5 v0))
	(if (fneq val 1.5) (snd-display "mus-interpolate bezier: ~A" val))
	(set! val (mus-interpolate mus-interp-lagrange 1.5 v0))
	(if (fneq val 1.5) (snd-display "mus-interpolate lagrange: ~A" val))
	(do ((i 0 (+ i 1))) ((= i 10)) (set! (v0 i) (sin (* pi (/ i 5)))))
	(set! val (mus-interpolate mus-interp-linear 1.5 v0))
	(if (fneq val 0.7694) (snd-display "mus-interpolate linear sin: ~A" val))
	(set! val (mus-interpolate mus-interp-all-pass 1.5 v0))
	(if (fneq val 0.7694) (snd-display "mus-interpolate all-pass sin: ~A" val))
	(set! val (mus-interpolate mus-interp-none 1.5 v0))
	(if (fneq val 0.5877) (snd-display "mus-interpolate none sin: ~A" val))
	(set! val (mus-interpolate mus-interp-hermite 1.5 v0))
	(if (fneq val 0.8061) (snd-display "mus-interpolate hermite sin: ~A" val))
	(set! val (mus-interpolate mus-interp-bezier 1.5 v0))
	(if (fneq val 0.6959) (snd-display "mus-interpolate bezier sin: ~A" val))
	(set! val (mus-interpolate mus-interp-lagrange 1.5 v0))
	(if (fneq val 0.7975) (snd-display "mus-interpolate lagrange sin: ~A" val))))
    
    (let ((tag (catch #t (lambda () (mus-interpolate 1234 1.0 (make-float-vector 3))) (lambda args (car args)))))
      (if (not (eq? tag 'out-of-range))
	  (snd-display "mus-interpolate 1234: ~A" tag)))
    (let ((tag (catch #t (lambda () (mus-interpolate mus-interp-linear 1.0 (make-float-vector 3) -1)) (lambda args (car args)))))
      (if (not (eq? tag 'out-of-range))
	  (snd-display "mus-interpolate size -1: ~A" tag)))

    ;; this test (for % trouble in C) is from Anders Vinjar, bugfix thanks to Tito Latini
    (let ((d (make-delay 10)))
      (do ((i 0 (+ 1 i)))
	  ((= i 10))
	(delay d i))
      (if (not (mus-arrays-equal? (mus-data d) #r(0.0 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0)))
	  (snd-display "delay data (0..9): ~A~%" (mus-data d)))
      (let ((vals (make-float-vector 10)))
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (set! (vals i) (tap d (- i))))
	(if (not (mus-arrays-equal? vals #r(0.0 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0)))
	    (snd-display "delay tapped backwards: ~A~%" vals))
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (set! (vals i) (tap d i)))
	(if (not (mus-arrays-equal? vals #r(0.0 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0)))
	    (snd-display "delay tapped forwards: ~A~%" vals))))
    
    (let ((gen1 (make-delay 4 :initial-contents '(1.0 0.5 0.25 0.0)))
	  (gen3 (make-delay 4 :initial-contents #r(1.0 0.5 0.25 0.0))))
      (let ((gen (make-delay 3)))
	(print-and-check gen 
			 "delay" 
			 "delay line[3, step]: [0 0 0]")
	(let ((v0 (make-float-vector 10))
	      (v1 (make-float-vector 10)))
	  (do ((i 0 (+ i 1)))
	      ((= i 10))
	    (set! (v0 i) (delay gen i)))
	  (let ((gen2 (make-delay 3))
		(k 0))
	    (fill-float-vector v1 (let ((val (if (delay? gen2) (delay gen2 k) -1.0)))
				    (set! k (+ k 1)) 
				    val)))
	  (if (not (mus-arrays-equal? v1 v0)) (snd-display "map delay: ~A ~A" v0 v1))
	  (if (not (delay? gen)) (snd-display "~A not delay?" gen))
	  (if (not (= (mus-length gen) 3)) (snd-display "delay length: ~D?" (mus-length gen)))
	  (if (or (fneq (v0 1) 0.0) (fneq (v0 4) 1.0) (fneq (v0 8) 5.0))
	      (snd-display "delay output: ~A" v0))))
      (if (or (fneq (delay gen1) 1.0) 
	      (fneq (delay gen1) 0.5)
	      (fneq (delay gen1) 0.25)
	      (fneq (delay gen1) 0.0))
	  (snd-display "delay with list initial-contents confused"))
      (if (or (fneq (delay gen3) 1.0) 
	      (fneq (delay gen3) 0.5)
	      (fneq (delay gen3) 0.25)
	      (fneq (delay gen3) 0.0))
	  (snd-display "delay with float-vector initial-contents confused")))
    (let ((var (catch #t (lambda () (make-delay 3 :initial-element (make-oscil))) (lambda args args))))
      (if (not (eq? (car var) 'wrong-type-arg))
	  (snd-display "make-delay bad initial element: ~A" var)))
    (let ((var (catch #t (lambda () (make-delay -3)) (lambda args args))))
      (if (not (eq? (car var) 'out-of-range))
	  (snd-display "make-delay bad size: ~A" var)))
    
    (test-gen-equal (let ((d1 (make-delay 3))) (delay d1 1.0) d1) 
		    (let ((d2 (make-delay 3))) (delay d2 1.0) d2)
		    (let ((d3 (make-delay 4))) (delay d3 1.0) d3))
    (test-gen-equal (make-delay 3 :initial-element 1.0) (make-delay 3 :initial-element 1.0) (make-delay 3 :initial-element 0.5))
    (test-gen-equal (make-delay 3 :initial-contents '(1.0 0.0 0.0)) 
		    (make-delay 3 :initial-contents '(1.0 0.0 0.0)) 
		    (make-delay 3 :initial-contents '(1.0 1.0 1.0)))
    
    (let ((gen (make-delay 5)))
      (delay gen 1.0)
      (delay gen 0.0)
      (delay gen 0.5)
      (let ((data (copy (mus-data gen))))
	(float-vector-set! (mus-data gen) 0 0.3)
	(if (fneq ((mus-data gen) 0) 0.3)
	    (snd-display "delay data 0: ~A" ((mus-data gen) 0)))
	(set! (data 0) .75)
	(set! (mus-data gen) data))
      (if (fneq ((mus-data gen) 0) 0.75)
	  (snd-display "delay set data 0: ~A" ((mus-data gen) 0)))
      (delay gen 0.0)
      (delay gen 0.0)
      (let ((val (delay gen 0.0)))
	(if (fneq val 0.75)
	    (snd-display "set delay data: ~A ~A" val (mus-data gen))))
      (if (mus-data (make-oscil))
	  (snd-display "mus-data osc: ~A" (mus-data (make-oscil)))))
    
    (let ((del (make-delay 5 :max-size 8)))
      (delay del 1.0)
      (do ((i 0 (+ i 1))) ((= i 4)) (delay del 0.0))
      (do ((v0 (make-float-vector 5))
	   (i 0 (+ i 1)))
	  ((= i 5)
	   (if (not (mus-arrays-equal? v0 #r(0.600 0.400 0.000 0.000 0.000)))
	       (snd-display "zdelay: ~A" v0)))
	(set! (v0 i) (delay del 0.0 0.4)))
      (delay del 1.0)
      (delay del 0.0 0.4)
      (if (not (string=? (mus-describe del) "delay line[5,8, linear]: [0 0 1 0 0]"))
	  (snd-display "describe zdelay: ~A" (mus-describe del))))
    (let ((tag (catch #t (lambda () (tap (make-oscil))) (lambda args (car args)))))
      (if (not (eq? tag 'wrong-type-arg))
	  (snd-display "tap of oscil: ~A" tag)))
    
    (let ((dly (make-delay 3))
	  (flt (make-one-zero .5 .4))
	  (v (make-float-vector 20)))
      (let ((inval 1.0))
	(fill-float-vector v (let ((res (delay dly (+ inval (* (one-zero flt (tap dly)) .6)))))
			       (set! inval 0.0)
			       res)))
      (if (not (mus-arrays-equal? v #r(0.0 0.0 0.0 1.0 0.0 0.0 0.300 0.240 0.0 0.090 0.144 0.058 0.027 0.065 0.052 0.022 0.026 0.031 0.019 0.013)))
	  (snd-display "tap with low pass: ~A" v)))
    
    (let ((dly (make-delay 3))
	  (v (make-float-vector 20)))
      (let ((inval 1.0))
	(fill-float-vector v (let ((res (delay dly (+ inval (tap dly)))))
			       (set! inval 0.0)
			       res)))
      (if (not (mus-arrays-equal? v #r(0.0 0.0 0.0 1.0 0.0 0.0 1.0 0.0 0.0 1.0 0.0 0.0 1.0 0.0 0.0 1.0 0.0 0.0 1.0 0.0)))
	  (snd-display "simple tap: ~A" v)))
    
    (let ((dly (make-delay 6))
	  (v (make-float-vector 20)))
      (if (not (tap? dly)) (snd-display "tap?: ~A" (tap? dly)))
      (let ((inval 1.0))
	(fill-float-vector v (let ((res (delay dly (+ inval (tap dly -2.0)))))
			       (set! inval 0.0)
			       res)))
      (set! *print-length* (max 20 *print-length*))
      (if (not (mus-arrays-equal? v #r(0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0)))
	  (snd-display "tap back 2: ~A" v)))
    
    (do ((dly (make-delay 3))
	 (flt (make-one-zero .5 .4))
	 (v (make-float-vector 20))
	 (inval 1.0 0.0)
	 (i 0 (+ i 1)))
	((= i 20)
	 (if (not (mus-arrays-equal? v #r(0.0 0.0 0.0 1.0 0.0 0.0 0.300 0.240 0.0 0.090 0.144 0.058 0.027 0.065 0.052 0.022 0.026 0.031 0.019 0.013)))
	     (snd-display "tap with low pass: ~A" v)))
      (set! (v i) (delay dly (+ inval (* (one-zero flt (tap dly)) .6)))))
    
    (let* ((dly (make-delay 3 :initial-element 32.0))
	   (ddata (mus-data dly)))
      (cond ((not (float-vector? ddata)) (snd-display "delay data not float-vector?"))
	    ((not (= (length ddata) 3))  (snd-display "delay data len not 3: ~A (~A)" (length ddata) ddata))
	    ((fneq (ddata 1) 32.0)       (snd-display "delay [1] 32: ~A" (ddata 1))))
      (let ((tag (catch #t (lambda () (set! (mus-length dly) -1)) (lambda args (car args)))))
	(if (not (eq? tag 'out-of-range)) (snd-display "len to -1 -> ~A" tag)))
      (let ((tag (catch #t (lambda () (set! (mus-length dly) 0)) (lambda args (car args)))))
	(if (not (eq? tag 'out-of-range)) (snd-display "len to 0 -> ~A" tag)))
      (let ((tag (catch #t (lambda () (set! (mus-length dly) 100)) (lambda args (car args)))))
	(if (not (eq? tag 'out-of-range)) (snd-display "len to 100 -> ~A" tag)))
      (let ((tag (catch #t (lambda () (set! ((mus-data dly) 100) .1)) (lambda args (car args)))))
	(if (not (eq? tag 'out-of-range)) (snd-display "data 100 to .1 -> ~A" tag)))
      (set! (mus-data dly) (make-float-vector 32 1.0))
      (set! ddata (mus-data dly))
      (if (not (float-vector? ddata)) (snd-display "set delay data not float-vector?"))
      (if (fneq (ddata 1) 1.0) (snd-display "set delay [1] 1: ~A" (ddata 1)))
      (if (not (= (length ddata) 32)) (snd-display "set delay data len(32): ~A" (length ddata)))
      (let ((tag (catch #t (lambda () (set! (mus-length dly) 100)) (lambda args (car args)))))
	(if (not (eq? tag 'out-of-range)) (snd-display "set len to 100 -> ~A" tag)))
      (let ((tag (catch #t (lambda () (set! (ddata 100) .1)) (lambda args (car args)))))
	(if (not (eq? tag 'out-of-range)) (snd-display "set data 100 to .1 -> ~A" tag))))
    
    (let ((d1 (make-delay 4))
	  (d2 (make-delay 4 :max-size 5 :type mus-interp-linear))
	  (d3 (make-delay 4 :max-size 5 :type mus-interp-all-pass))
	  (d4 (make-delay 4 :max-size 5 :type mus-interp-none))
	  (d5 (make-delay 4 :max-size 4 :type mus-interp-lagrange))
	  (d6 (make-delay 4 :max-size 4 :type mus-interp-hermite))
	  (d7 (make-delay 4 :max-size 4 :type mus-interp-linear))
	  (v1 (make-float-vector 20))
	  (v2 (make-float-vector 20))
	  (v3 (make-float-vector 20))
	  (v4 (make-float-vector 20))
	  (v5 (make-float-vector 20))
	  (v6 (make-float-vector 20))
	  (v7 (make-float-vector 20)))
      (if (not (= (mus-interp-type d1) mus-interp-none)) (snd-display "d1 interp type: ~A" (mus-interp-type d1)))
      (if (not (= (mus-interp-type d2) mus-interp-linear)) (snd-display "d2 interp type: ~A" (mus-interp-type d2)))
      (if (not (= (mus-interp-type d3) mus-interp-all-pass)) (snd-display "d3 interp type: ~A" (mus-interp-type d3)))
      (if (not (= (mus-interp-type d4) mus-interp-none)) (snd-display "d4 interp type: ~A" (mus-interp-type d4)))
      (if (not (= (mus-interp-type d5) mus-interp-lagrange)) (snd-display "d5 interp type: ~A" (mus-interp-type d5)))
      (if (not (= (mus-interp-type d6) mus-interp-hermite)) (snd-display "d6 interp type: ~A" (mus-interp-type d6)))
      (if (not (= (mus-interp-type d7) mus-interp-linear)) (snd-display "d7 interp type: ~A" (mus-interp-type d7)))
      (set! (v1 0) (delay d1 1.0))
      (set! (v2 0) (delay d2 1.0))
      (set! (v3 0) (delay d3 1.0))
      (set! (v4 0) (delay d4 1.0))
      (set! (v5 0) (delay d5 1.0))
      (set! (v6 0) (delay d6 1.0))
      (set! (v7 0) (delay d7 1.0))
      (for-each (lambda (arg) (delay-tick arg 0.0)) (vector d1 d2 d3 d4 d5 d6 d7))
      (do ((i 1 (+ i 1))
	   (j -0.2 (- j 0.2)))
	  ((= i 20))
	(set! (v1 i) (tap d1 j))
	(set! (v2 i) (tap d2 j))
	(set! (v3 i) (tap d3 j))
	(set! (v4 i) (tap d4 j))
	(set! (v5 i) (tap d5 j))
	(set! (v6 i) (tap d6 j))
	(set! (v7 i) (tap d7 j)))
      (set! *print-length* (max 20 *print-length*))
      (if (not (or (mus-arrays-equal? v1 #r(0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 1.0 0.0 0.0 0.0 0.0 0.0))
		   (mus-arrays-equal? v1 #r(0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 0.0 0.0 0.0 0.0 0.0))))
	  (snd-display "delay interp none (1): ~A" v1))
      (if (not (mus-arrays-equal? v2 #r(0.0 0.0 0.0 0.0 0.0 0.0 0.200 0.400 0.600 0.800 1.0 0.800 0.600 0.400 0.200 0.0 0.0 0.0 0.0 0.0)))
	  (snd-display "delay interp linear (2): ~A" v2))
      (if (not (mus-arrays-equal? v3 #r(0.000 0.000 0.000 0.000 0.000 1.000 0.000 0.600 0.160 0.168 -0.168 0.334 0.199 0.520 0.696 -0.696 0.557 -0.334 0.134 -0.027)))
	  (snd-display "delay interp all-pass (3): ~A" v3))
      (if (not (or (mus-arrays-equal? v4 #r(0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 1.0 0.0 0.0 0.0 0.0 0.0))
		   (mus-arrays-equal? v4 #r(0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 0.0 0.0 0.0 0.0 0.0))))
	  (snd-display "delay interp none (4): ~A" v4))
      (if (not (mus-arrays-equal? v5 #r(0.0 0.0 0.0 0.0 0.0 0.0 0.120 0.280 0.480 0.720 1.000 0.960 0.840 0.640 0.360 0.000 -0.080 -0.120 -0.120 -0.080)))
	  (snd-display "delay interp lagrange (5): ~A" v5))
      (if (not (mus-arrays-equal? v6 #r(0.0 -0.016 -0.048 -0.072 -0.064 0.0 0.168 0.424 0.696 0.912 1.0 0.912 0.696 0.424 0.168 0.0 -0.064 -0.072 -0.048 -0.016)))
	  (snd-display "delay interp hermite (6): ~A" v6))
      (if (not (mus-arrays-equal? v7 #r(0.0 0.0 0.0 0.0 0.0 0.0 0.200 0.400 0.600 0.800 1.0 0.800 0.600 0.400 0.200 0.0 0.0 0.0 0.0 0.0)))
	  (snd-display "delay interp linear (7): ~A" v7)))
    
    (let ((dly1 (make-delay :size 2 :max-size 3))
	  (data (make-float-vector 5))
	  (impulse 1.0))
      (do ((i 0 (+ i 1)))
	  ((= i 5))
	(set! (data i) (delay dly1 impulse 0.4)) ; longer line
	(set! impulse 0.0))
      (if (not (mus-arrays-equal? data #r(0.0 0.0 0.6 0.4 0.0)))
	  (snd-display "delay size 2, max 3, off 0.4: ~A" data))
      
      (set! dly1 (make-delay :size 2 :max-size 3))
      (set! impulse 1.0)
      (do ((i 0 (+ i 1)))
	  ((= i 5))
	(set! (data i) (delay dly1 impulse -0.4)) ; shorter line
	(set! impulse 0.0))
      (if (not (mus-arrays-equal? data #r(0.0 0.4 0.6 0.0 0.0)))
	  (snd-display "delay size 2, max 3, off -0.4: ~A" data))
      
      (set! dly1 (make-delay :size 1 :max-size 2))
      (set! impulse 1.0)
      (do ((i 0 (+ i 1)))
	  ((= i 5))
	(set! (data i) (delay dly1 impulse 0.4))
	(set! impulse 0.0))
      (if (not (mus-arrays-equal? data #r(0.0 0.6 0.4 0.0 0.0)))
	  (snd-display "delay size 1, max 2, off 0.4: ~A" data))
      
      (set! dly1 (make-delay :size 0 :max-size 1))
      (set! impulse 1.0)
      (do ((i 0 (+ i 1)))
	  ((= i 5))
	(set! (data i) (delay dly1 impulse 0.4))
	(set! impulse 0.0))
      (if (not (mus-arrays-equal? data #r(0.6 0.4 0.0 0.0 0.0)))
	  (snd-display "delay size 0, max 1, off 0.4: ~A" data))
      
      (set! dly1 (make-delay :size 0 :max-size 1))
      (let ((val (delay dly1 0.0)))
	(if (fneq val 0.0) (snd-display "initial delay 0 size val: ~A" val)))
      
      (set! dly1 (make-delay :size 0 :max-size 1))
      (set! impulse 1.0)
      (do ((i 0 (+ i 1)))
	  ((= i 5))
	(set! (data i) (delay dly1 impulse -0.4)) ; shorter than 0? should this be an error?
	(set! impulse 0.0))
      (if (not (mus-arrays-equal? data #r(1.4 -0.4 0.0 0.0 0.0))) ; hmmm -- they're asking for undefined values here 
	  (snd-display "delay size 0, max 1, off -0.4: ~A" data))
      
      (set! dly1 (make-delay 0))
      (set! impulse 1.0)
      (do ((i 0 (+ i 1)))
	  ((= i 5))
	(set! (data i) (delay dly1 impulse)) 
	(set! impulse 0.0))
      (if (not (mus-arrays-equal? data #r(1 0 0 0 0)))
	  (snd-display "delay size 0: ~A" data))
      (let ((x (delay dly1 0.5)))
	(if (fneq x 0.5)
	    (snd-display "delay size 0 0.5: ~A" x)))
      )
    
    (let ((gen (make-delay :size 0 :max-size 100))
	  (v (make-float-vector 10)))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v i) (delay gen 0.5 i)))
      (if (not (mus-arrays-equal? v #r(0.500 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "delay 0 -> 100: ~A" v))
      (do ((i 9 (- i 1)))
	  ((< i 0))
	(set! (v i) (delay gen 0.5 i)))
      (if (not (mus-arrays-equal? v (make-float-vector 10 0.5)))
	  (snd-display "delay 100 -> 0: ~A" v))
      (mus-reset gen)
      (if (not (mus-arrays-equal? (mus-data gen) (make-float-vector 100)))
	  (snd-display "after reset mus-data delay peak: ~A" (float-vector-peak (mus-data gen))))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v i) (delay gen (if (odd? i) 1.0 0.0) (* i .1))))
      (if (not (mus-arrays-equal? v #r(0.000 0.900 0.000 0.700 0.000 0.500 0.000 0.300 0.000 0.100)))
	  (snd-display "delay 0 -> 100 .1: ~A (~A)" v gen))
      (mus-reset gen)
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v i) (delay gen (if (odd? i) 1.0 0.0) (+ 1.0 (* i .1)))))
      (if (not (mus-arrays-equal? v #r(0.000 0.000 0.800 0.300 0.600 0.500 0.400 0.700 0.200 0.900)))
	  (snd-display "delay 0 -> 100 1.1: ~A" v)))
    
    
    (let ((gen (make-all-pass .4 .6 3))
	  (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "all-pass"
		       "all-pass feedback: 0.400, feedforward: 0.600, line[3, step]:[0 0 0]")
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (all-pass gen 1.0)))
      (let ((gen1 (make-all-pass .4 .6 3))
	    (v1 (make-float-vector 10)))  
	(fill-float-vector v1 (if (all-pass? gen1) (all-pass gen1 1.0) -1.0))
	(if (not (mus-arrays-equal? v1 v0)) (snd-display "map all-pass: ~A ~A" v0 v1)))
      (if (not (all-pass? gen)) (snd-display "~A not all-pass?" gen))
      (if (not (= (mus-length gen) 3)) (snd-display "all-pass length: ~D?" (mus-length gen)))
      (if (not (= (mus-order gen) 3)) (snd-display "all-pass order: ~D?" (mus-order gen)))
      (if (fneq (mus-feedback gen) .4) (snd-display "all-pass feedback: ~F?" (mus-feedback gen)))
      (if (fneq (mus-feedforward gen) .6) (snd-display "all-pass feedforward: ~F?" (mus-feedforward gen)))
      (if (or (fneq (v0 1) 0.6) (fneq (v0 4) 1.84) (fneq (v0 8) 2.336))
	  (snd-display "all-pass output: ~A" v0))
      (set! (mus-feedback gen) 0.5) 
      (if (fneq (mus-feedback gen) .5) (snd-display "all-pass set-feedback: ~F?" (mus-feedback gen)))
      (set! (mus-feedforward gen) 0.5) 
      (if (fneq (mus-feedforward gen) .5) (snd-display "all-pass set-feedforward: ~F?" (mus-feedforward gen))))
    
    (test-gen-equal (let ((d1 (make-all-pass 0.7 0.5 3))) (all-pass d1 1.0) d1)
		    (let ((d2 (make-all-pass 0.7 0.5 3))) (all-pass d2 1.0) d2) 
		    (let ((d3 (make-all-pass 0.7 0.5 4))) (all-pass d3 1.0) d3))
    (test-gen-equal (make-all-pass 0.7 0.5 3 :initial-element 1.0) 
		    (make-all-pass 0.7 0.5 3 :initial-element 1.0) 
		    (make-all-pass 0.7 0.5 3 :initial-element 0.5))
    (test-gen-equal (make-all-pass 0.7 0.5 3 :initial-element 1.0) 
		    (make-all-pass 0.7 0.5 3 :initial-element 1.0) 
		    (make-all-pass 0.5 0.5 3 :initial-element 1.0))
    (test-gen-equal (make-all-pass 0.7 0.5 3 :initial-contents '(1.0 0.0 0.0)) 
		    (make-all-pass 0.7 0.5 3 :initial-contents '(1.0 0.0 0.0)) 
		    (make-all-pass 0.7 0.5 3 :initial-contents '(1.0 1.0 1.0)))
    (let ((err (catch #t (lambda () (make-all-pass :feedback .2 :feedforward .1 :size -1)) (lambda args args))))
      (if (not (eq? (car err) 'out-of-range))
	  (snd-display "make-all-pass bad size error message: ~A" err)))
    
    (let ((gen (make-moving-average 4))
	  (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "moving-average"
		       "moving-average 0.000, line[4]:[0 0 0 0]")
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (moving-average gen 1.0)))
      (let ((gen1 (make-moving-average 4))
	    (v1 (make-float-vector 10)))  
	(fill-float-vector v1 (if (moving-average? gen1) (moving-average gen1 1.0) -1.0))
	(if (not (mus-arrays-equal? v1 v0)) (snd-display "map average: ~A ~A" v0 v1)))
      (if (not (moving-average? gen)) (snd-display "~A not average?" gen))
      (if (not (= (mus-length gen) 4)) (snd-display "average length: ~D?" (mus-length gen)))
      (if (not (= (mus-order gen) 4)) (snd-display "average order: ~D?" (mus-order gen)))
      (if (or (fneq (v0 1) 0.5) (fneq (v0 4) 1.0) (fneq (v0 8) 1.0))
	  (snd-display "average output: ~A" v0)))
    
    (let* ((gen (make-moving-average 8))
	   (val (moving-average gen)))
      (if (fneq val 0.0) (snd-display "empty average: ~A" val))
      (set! val (moving-average gen 1.0))
      (if (fneq val 0.125) (snd-display "average 1: ~A" val))
      (set! val (moving-average gen 1.0))
      (if (fneq val 0.25) (snd-display "average 2: ~A" val))
      (set! val (moving-average gen 0.5))
      (if (fneq val 0.3125) (snd-display "average 2: ~A" val))
      (do ((i 0 (+ i 1))) ((= i 5)) (set! val (moving-average gen 0.0))) 
      (if (fneq val 0.3125) (snd-display "average 6: ~A" val))
      (set! val (moving-average gen 0.0))
      (if (fneq val 0.1875) (snd-display "average 7: ~A" val))
      (set! val (moving-average gen 0.0))
      (if (fneq val 0.0625) (snd-display "average 8: ~A" val))
      (set! val (moving-average gen 0.0))
      (if (fneq val 0.0) (snd-display "average 9: ~A" val)))

    (let ((val (moving-average (make-moving-average 10 :initial-element .5) 0.5)))
      (if (fneq val 0.5) (snd-display "average initial-element: ~A" val)))
    (let ((val (moving-average (make-moving-average 3 :initial-contents '(1.0 1.0 1.0)) 1.0)))
      (if (fneq val 1.0) (snd-display "average initial-contents: ~A" val)))
    
    (test-gen-equal (let ((d1 (make-moving-average 3 :initial-contents '(0.7 0.5 3)))) (moving-average d1 1.0) d1)
		    (let ((d2 (make-moving-average 3 :initial-contents #r(0.7 0.5 3)))) (moving-average d2 1.0) d2) 
		    (let ((d3 (make-moving-average 4 :initial-contents '(0.7 0.5 0.1 4)))) (moving-average d3 1.0) d3))
    (test-gen-equal (make-moving-average 3 :initial-element 1.0) 
		    (make-moving-average 3 :initial-element 1.0) 
		    (make-moving-average 3 :initial-element 0.5))
    (test-gen-equal (make-moving-average 3 :initial-element 1.0) 
		    (make-moving-average 3 :initial-element 1.0) 
		    (make-moving-average 4 :initial-element 1.0))
    (test-gen-equal (make-moving-average 3 :initial-contents '(1.0 0.0 0.0)) 
		    (make-moving-average 3 :initial-contents '(1.0 0.0 0.0)) 
		    (make-moving-average 3 :initial-contents '(1.0 1.0 1.0)))
    (let ((err (catch #t (lambda () (make-moving-average :size -1)) (lambda args args))))
      (if (not (eq? (car err) 'out-of-range))
	  (snd-display "make-average bad size error message: ~A" err)))
    (let ((err (catch #t (lambda () (make-moving-average :size 0)) (lambda args args))))
      (if (not (eq? (car err) 'out-of-range))
	  (snd-display "make-average size==0 error message: ~A" err)))

    (let ((gen (make-moving-max 4))
	  (v0 (make-float-vector 10))
	  (v1 (make-float-vector 10)))
      (print-and-check gen 
		       "moving-max"
		       "moving-max 0.000, line[4]:[0 0 0 0]")
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (moving-max gen 1.0)))
      (let ((gen1 (make-moving-max 4)))
	(fill-float-vector v1 (if (moving-max? gen1) (moving-max gen1 1.0) -1.0)))
      (if (not (mus-arrays-equal? v1 v0)) (snd-display "map max: ~A ~A" v0 v1))
      (if (not (moving-max? gen)) (snd-display "~A not max?" gen))
      (if (not (= (mus-length gen) 4)) (snd-display "max length: ~D?" (mus-length gen)))
      (if (not (= (mus-order gen) 4)) (snd-display "max order: ~D?" (mus-order gen)))
      (if (or (fneq (v0 1) 1.0) (fneq (v0 4) 1.0) (fneq (v0 8) 1.0))
	  (snd-display "max output: ~A" v0)))
    
    (let* ((gen (make-moving-max 8))
	   (val (moving-max gen)))
      (if (fneq val 0.0) (snd-display "empty max: ~A" val))
      (set! val (moving-max gen 1.0))
      (if (fneq val 1.0) (snd-display "max 1: ~A" val))
      (set! val (moving-max gen -0.5))
      (if (fneq val 1.0) (snd-display "max 2: ~A" val))
      (set! val (moving-max gen -1.5))
      (if (fneq val 1.5) (snd-display "max 2: ~A" val))
      (do ((i 0 (+ i 1))) ((= i 5)) (set! val (moving-max gen 0.0))) 
      (if (fneq val 1.5) (snd-display "max 6: ~A" val))
      (set! val (moving-max gen 0.0))
      (if (fneq val 1.5) (snd-display "max 7: ~A" val))
      (set! val (moving-max gen 0.0))
      (if (fneq val 1.5) (snd-display "max 8: ~A" val))
      (set! val (moving-max gen 0.0))
      (if (fneq val 0.0) (snd-display "max 9: ~A" val)))

    (let ((val (moving-max (make-moving-max 10 :initial-element .5) 0.5)))
      (if (fneq val 0.5) (snd-display "max initial-element: ~A" val)))
    (let ((val (moving-max (make-moving-max 3 :initial-contents '(1.0 1.0 1.0)) 1.0)))
      (if (fneq val 1.0) (snd-display "max initial-contents: ~A" val)))
    
    (test-gen-equal (let ((d1 (make-moving-max 3 :initial-contents '(0.7 0.5 3)))) (moving-max d1 1.0) d1)
		    (let ((d2 (make-moving-max 3 :initial-contents #r(0.7 0.5 3)))) (moving-max d2 1.0) d2) 
		    (let ((d3 (make-moving-max 4 :initial-contents '(0.7 0.5 0.1 4)))) (moving-max d3 1.0) d3))
    (test-gen-equal (make-moving-max 3 :initial-element 1.0) 
		    (make-moving-max 3 :initial-element 1.0) 
		    (make-moving-max 3 :initial-element 0.5))
    (test-gen-equal (make-moving-max 3 :initial-element 1.0) 
		    (make-moving-max 3 :initial-element 1.0) 
		    (make-moving-max 4 :initial-element 1.0))
    (test-gen-equal (make-moving-max 3 :initial-contents '(1.0 0.0 0.0)) 
		    (make-moving-max 3 :initial-contents '(1.0 0.0 0.0)) 
		    (make-moving-max 3 :initial-contents '(1.0 1.0 1.0)))
    (let ((err (catch #t (lambda () (make-moving-max :size -1)) (lambda args args))))
      (if (not (eq? (car err) 'out-of-range))
	  (snd-display "make-max bad size error message: ~A" err)))
    (let ((err (catch #t (lambda () (make-moving-max :size 0)) (lambda args args))))
      (if (not (eq? (car err) 'out-of-range))
	  (snd-display "make-max size==0 error message: ~A" err)))

    (let ((gen (make-moving-norm 4))
	  (v0 (make-float-vector 10))
	  (v1 (make-float-vector 10)))
      (print-and-check gen 
		       "moving-norm"
		       "moving-norm, max 0.000, y1 5.000, weight 0.800, line[4]:[0 0 0 0]")
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (moving-norm gen 1.0)))
      (let ((gen1 (make-moving-norm 4)))
	(fill-float-vector v1 (if (moving-norm? gen1) (moving-norm gen1 1.0) -1.0)))
      (if (not (mus-arrays-equal? v1 v0)) (snd-display "map norm: ~A ~A" v0 v1))
      (if (not (moving-norm? gen)) (snd-display "~A not norm?" gen))
      (if (not (= (mus-length gen) 4)) (snd-display "norm length: ~D?" (mus-length gen)))
      (if (not (= (mus-order gen) 4)) (snd-display "norm order: ~D?" (mus-order gen))))
    
    (let* ((gen (make-moving-norm 8))
	   (val (moving-norm gen)))
      (if (fneq val 1.1236) (snd-display "empty norm: ~A" val))
      (set! val (moving-norm gen 1.0))
      (if (fneq val 1.1084) (snd-display "norm 1: ~A" val))
      (set! val (moving-norm gen -0.5))
      (if (fneq val 1.0952) (snd-display "norm 2: ~A" val))
      (set! val (moving-norm gen -1.5))
      (if (fneq val 1.0222) (snd-display "norm 2: ~A" val))
      (do ((i 0 (+ i 1))) ((= i 5)) (set! val (moving-norm gen 0.0))) 
      (if (fneq val 0.8261) (snd-display "norm 6: ~A" val))
      (set! val (moving-norm gen 0.0))
      (if (fneq val 0.8047) (snd-display "norm 7: ~A" val))
      (set! val (moving-norm gen 0.0))
      (if (fneq val 0.7866) (snd-display "norm 8: ~A" val))
      (set! val (moving-norm gen 0.0))
      (if (fneq val 0.8841) (snd-display "norm 9: ~A" val)))

    (let ((val (moving-norm (make-moving-norm 10 :initial-element .5) 0.5)))
      (if (fneq val 1.0476) (snd-display "norm initial-element: ~A" val)))
    (let ((val (moving-norm (make-moving-norm 3 :initial-contents '(1.0 1.0 1.0)) 1.0)))
      (if (fneq val 1.0) (snd-display "norm initial-contents: ~A" val)))
    
    (test-gen-equal (let ((d1 (make-moving-norm 3))) (moving-norm d1 1.0) d1)
		    (let ((d2 (make-moving-norm 3))) (moving-norm d2 1.0) d2) 
		    (let ((d3 (make-moving-norm 4))) (moving-norm d3 1.0) d3))
    (test-gen-equal (make-moving-norm 3 :scaler 1.0) 
		    (make-moving-norm 3 :scaler 1.0) 
		    (make-moving-norm 4 :scaler 1.0))
    (let ((err (catch #t (lambda () (make-moving-norm :size -1)) (lambda args args))))
      (if (not (eq? (car err) 'out-of-range))
	  (snd-display "make-norm bad size error message: ~A" err)))
    (let ((err (catch #t (lambda () (make-moving-norm :size 0)) (lambda args args))))
      (if (not (eq? (car err) 'out-of-range))
	  (snd-display "make-norm size==0 error message: ~A" err)))


    (let ((gen (make-comb .4 3))
	  (v0 (make-float-vector 10))
	  (v1 (make-float-vector 10)))
      (print-and-check gen 
		       "comb"
		       "comb scaler: 0.400, line[3, step]: [0 0 0]")
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (comb gen 1.0)))
      (let ((gen1 (make-comb .4 3)))
	(fill-float-vector v1 (if (comb? gen1) (comb gen1 1.0) -1.0)))
      (if (not (mus-arrays-equal? v0 v1)) (snd-display "map comb: ~A ~A" v0 v1))
      (if (not (comb? gen)) (snd-display "~A not comb?" gen))
      (if (not (= (mus-length gen) 3)) (snd-display "comb length: ~D?" (mus-length gen)))
      (if (not (= (mus-order gen) 3)) (snd-display "comb order: ~D?" (mus-order gen)))
      (if (fneq (mus-feedback gen) .4) (snd-display "comb feedback: ~F?" (mus-feedback gen)))
      (if (or (fneq (v0 1) 0.0) (fneq (v0 4) 1.0) (fneq (v0 8) 1.4))
	  (snd-display "comb output: ~A" v0)))
    
    (test-gen-equal (let ((d1 (make-comb 0.7 3))) (comb d1 1.0) d1) 
		    (let ((d2 (make-comb 0.7 3))) (comb d2 1.0) d2) 
		    (let ((d3 (make-comb 0.7 4))) (comb d3 1.0) d3))
    (test-gen-equal (make-comb 0.7 3 :initial-element 1.0) 
		    (make-comb 0.7 3 :initial-element 1.0) 
		    (make-comb 0.7 3 :initial-element 0.5))
    (test-gen-equal (make-comb 0.7 3 :initial-element 1.0) 
		    (make-comb 0.7 3 :initial-element 1.0) 
		    (make-comb 0.5 3 :initial-element 1.0))
    (test-gen-equal (make-comb 0.7 3 :initial-contents '(1.0 0.0 0.0)) 
		    (make-comb 0.7 3 :initial-contents '(1.0 0.0 0.0)) 
		    (make-comb 0.7 3 :initial-contents '(1.0 1.0 1.0)))
    
    (let ((del (make-comb 0.0 5 :max-size 8)))
      (comb del 1.0)
      (do ((i 0 (+ i 1))) ((= i 4)) (comb del 0.0))
      (do ((v0 (make-float-vector 5))
	   (i 0 (+ i 1)))
	  ((= i 5)
	   (if (not (mus-arrays-equal? v0 #r(0.600 0.400 0.000 0.000 0.000))) ; this is assuming interpolation in the delay...
	       (snd-display "zcomb: ~A" v0)))
	(set! (v0 i) (comb del 0.0 0.4)))
      (comb del 1.0)
      (comb del 0.0 0.4)
      (if (not (string=? (mus-describe del) "comb scaler: 0.000, line[5,8, linear]: [0 0 1 0 0]"))
	  (snd-display "describe zcomb: ~A" (mus-describe del)))
      (set! (mus-feedback del) 1.0)
      (if (fneq (mus-feedback del) 1.0)
	  (snd-display "comb feedback set: ~A" (mus-feedback del))))
    
    (let ((gen (make-filtered-comb .4 5 :filter (make-one-zero .3 .7))))
      (print-and-check gen 
		       "filtered-comb"
		       "filtered-comb scaler: 0.400, line[5, step]: [0 0 0 0 0], filter: [one-zero a0: 0.300, a1: 0.700, x1: 0.000]")
      (do ((v0 (make-float-vector 20))
	   (val 1.0 0.0)
	   (i 0 (+ i 1)))
	  ((= i 20)
	   (if (not (mus-arrays-equal? v0 #r(0.000 0.000 0.000 0.000 0.000 1.000 0.000 0.000 0.000 0.000 0.120 0.280 0.000 0.000 0.000 0.014 0.067 0.078 0.000 0.000)))
	       (snd-display "filtered-comb: ~A" v0)))
	(set! (v0 i) (filtered-comb gen val)))
      (if (not (filtered-comb? gen)) (snd-display "~A not filtered-comb?" gen))
      (if (not (= (mus-length gen) 5)) (snd-display "filtered-comb length: ~D?" (mus-length gen)))
      (if (not (= (mus-order gen) 5)) (snd-display "filtered-comb order: ~D?" (mus-order gen)))
      (if (fneq (mus-feedback gen) .4) (snd-display "filtered-comb feedback: ~F?" (mus-feedback gen))))
    
    (let ((gen (make-filtered-comb .9 5 :filter (make-one-zero .5 .5)))
	  (v0 (make-float-vector 20)))
      (print-and-check gen 
		       "filtered-comb"
		       "filtered-comb scaler: 0.900, line[5, step]: [0 0 0 0 0], filter: [one-zero a0: 0.500, a1: 0.500, x1: 0.000]")
      (do ((val 1.0 0.0)
	   (i 0 (+ i 1)))
	  ((= i 20))
	(set! (v0 i) (filtered-comb gen val)))
      (if (not (mus-arrays-equal? v0 #r(0.000 0.000 0.000 0.000 0.000 1.000 0.000 0.000 0.000 0.000 0.450 0.450 0.000 0.000 0.000 0.202 0.405 0.202 0.000 0.000)))
	  (snd-display "filtered-comb .5 .5: ~A" v0)))
    
    (let ((gen (make-filtered-comb .9 5 :filter (make-fir-filter 5 #r(.1 .2 .3 .2 .1))))
	  (v0 (make-float-vector 20)))
      (print-and-check gen 
		       "filtered-comb"
		       "filtered-comb scaler: 0.900, line[5, step]: [0 0 0 0 0], filter: [fir-filter order: 5, xs: [0.1 0.2 0.3 0.2 0.1]]")
      (do ((val 1.0 0.0)
	   (i 0 (+ i 1)))
	  ((= i 20))
	(set! (v0 i) (filtered-comb gen val)))
      (if (not (mus-arrays-equal? v0 #r(0.000 0.000 0.000 0.000 0.000 1.000 0.000 0.000 0.000 0.000 0.090 0.180 0.270 0.180 0.090 0.008 0.032 0.081 0.130 0.154)))
	  (snd-display "filtered-comb fir: ~A" v0)))
    
    (test-gen-equal (let ((d1 (make-filtered-comb 0.7 3 :filter (make-one-pole .3 .7)))) (filtered-comb d1 1.0) d1) 
		    (let ((d2 (make-filtered-comb 0.7 3 :filter (make-one-pole .3 .7)))) (filtered-comb d2 1.0) d2) 
		    (let ((d3 (make-filtered-comb 0.7 4 :filter (make-one-pole .3 .7)))) (filtered-comb d3 1.0) d3))
    (test-gen-equal (make-filtered-comb 0.7 3 :initial-element 1.0 :filter (make-one-zero .5 .5)) 
		    (make-filtered-comb 0.7 3 :initial-element 1.0 :filter (make-one-zero .5 .5)) 
		    (make-filtered-comb 0.7 3 :initial-element 0.5 :filter (make-one-zero .5 .5)))
    (test-gen-equal (make-filtered-comb 0.7 3 :initial-element 1.0 :filter (make-one-zero .5 .5)) 
		    (make-filtered-comb 0.7 3 :initial-element 1.0 :filter (make-one-zero .5 .5)) 
		    (make-filtered-comb 0.7 3 :initial-element 1.0 :filter (make-one-zero .25 .75)))
    (test-gen-equal (make-filtered-comb 0.7 3 :initial-contents '(1.0 0.0 0.0) :filter (make-one-zero .5 .5)) 
		    (make-filtered-comb 0.7 3 :initial-contents '(1.0 0.0 0.0) :filter (make-one-zero .5 .5)) 
		    (make-filtered-comb 0.7 3 :initial-contents '(1.0 1.0 1.0) :filter (make-one-zero .5 .5)))
    
    (let ((del (make-filtered-comb 0.0 5 :max-size 8 :filter (make-one-zero .5 .5))))
      (filtered-comb del 1.0)
      (do ((i 0 (+ i 1))) ((= i 4)) (filtered-comb del 0.0))
      (do ((v0 (make-float-vector 5))
	   (i 0 (+ i 1)))
	  ((= i 5)
	   (if (not (mus-arrays-equal? v0 #r(0.600 0.400 0.000 0.000 0.000))) ; this is assuming interpolation in the delay...
	       (snd-display "zfiltered-comb: ~A" v0)))
	(set! (v0 i) (filtered-comb del 0.0 0.4)))
      (filtered-comb del 1.0)
      (filtered-comb del 0.0 0.4)
      (if (not (string=? (mus-describe del)
			 "filtered-comb scaler: 0.000, line[5,8, linear]: [0 0 1 0 0], filter: [one-zero a0: 0.500, a1: 0.500, x1: 0.000]"))
	  (snd-display "describe zfiltered-comb: ~A" (mus-describe del)))
      (set! (mus-feedback del) 1.0)
      (if (fneq (mus-feedback del) 1.0)
	  (snd-display "filtered-comb feedback set: ~A" (mus-feedback del))))
    
    (let ((gen (make-notch .4 3))
	  (v0 (make-float-vector 10)))
      (print-and-check gen "notch" "notch scaler: 0.400, line[3, step]: [0 0 0]")
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (notch gen 1.0)))
      (let ((v1 (make-float-vector 10)))
	(let ((gen1 (make-notch .4 3)))
	  (fill-float-vector v1 (if (notch? gen1) (notch gen1 1.0) -1.0)))
	(if (not (mus-arrays-equal? v0 v1)) (snd-display "map notch: ~A ~A" v0 v1)))
      (if (not (notch? gen)) (snd-display "~A not notch?" gen))
      (if (not (= (mus-length gen) 3)) (snd-display "notch length: ~D?" (mus-length gen)))
      (if (not (= (mus-order gen) 3)) (snd-display "notch order: ~D?" (mus-order gen)))
      (if (fneq (mus-feedforward gen) .4) (snd-display "notch feedforward: ~F?" (mus-feedforward gen)))
      (if (or (fneq (v0 1) 0.4) (fneq (v0 4) 1.4) (fneq (v0 8) 1.4))
	  (snd-display "notch output: ~A" v0))
      (set! (mus-feedforward gen) 1.0)
      (if (fneq (mus-feedforward gen) 1.0)
	  (snd-display "notch feedforward set: ~A" (mus-feedforward gen))))
    
    (test-gen-equal (let ((d1 (make-notch 0.7 3))) (notch d1 1.0) d1)
		    (let ((d2 (make-notch 0.7 3))) (notch d2 1.0) d2)
		    (let ((d3 (make-notch 0.7 4))) (notch d3 1.0) d3))
    (test-gen-equal (make-notch 0.7 3 :initial-element 1.0) 
		    (make-notch 0.7 3 :initial-element 1.0) 
		    (make-notch 0.7 3 :initial-element 0.5))
    (test-gen-equal (make-notch 0.7 3 :initial-element 1.0) 
		    (make-notch 0.7 3 :initial-element 1.0) 
		    (make-notch 0.5 3 :initial-element 1.0))
    (test-gen-equal (make-notch 0.7 3 :initial-contents '(1.0 0.0 0.0)) 
		    (make-notch 0.7 3 :initial-contents '(1.0 0.0 0.0)) 
		    (make-notch 0.7 3 :initial-contents '(1.0 1.0 1.0)))
    
    ;; make sure all-pass is the same as comb/notch given the appropriate feedback/forward settings
    
    (do ((gen (make-comb 0.5 5))
	 (v0 (make-float-vector 11))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1)))
	((= i 11)
	 (if (not (mus-arrays-equal? v0 #r(0.000 0.000 0.000 0.000 0.000 1.000 0.000 0.000 0.000 0.000 0.500)))
	     (snd-display "comb (5 .5): ~A" v0)))
      (set! (v0 i) (comb gen in1)))
    
    (do ((gen (make-all-pass 0.5 0.0 5))
	 (v0 (make-float-vector 11))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1)))
	((= i 11)
	 (if (not (mus-arrays-equal? v0 #r(0.000 0.000 0.000 0.000 0.000 1.000 0.000 0.000 0.000 0.000 0.500)))
	     (snd-display "all-pass (5 0 .5): ~A" v0)))
      (set! (v0 i) (all-pass gen in1)))
    
    (do ((gen (make-notch 0.5 5))
	 (v0 (make-float-vector 11))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1)))
	((= i 11)
	 (if (not (mus-arrays-equal? v0 #r(0.500 0.000 0.000 0.000 0.000 1.000 0.000 0.000 0.000 0.000 0.000)))
	     (snd-display "notch (5 .5): ~A" v0)))
      (set! (v0 i) (notch gen in1)))
    
    (do ((gen (make-all-pass 0.0 0.5 5))
	 (v0 (make-float-vector 11))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1)))
	((= i 11)
	 (if (not (mus-arrays-equal? v0 #r(0.500 0.000 0.000 0.000 0.000 1.000 0.000 0.000 0.000 0.000 0.000)))
	     (snd-display "all-pass (5 .5 0): ~A" v0)))
      (set! (v0 i) (all-pass gen in1)))
    
    ;; make sure zall-pass is the same as zcomb/znotch given the appropriate feedback/forward and "pm" settings
    
    (do ((gen (make-comb 0.5 5 :max-size 20))
	 (v0 (make-float-vector 11))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1)))
	((= i 11)
	 (if (not (mus-arrays-equal? v0 #r(0.000 0.000 0.000 0.000 0.000 1.000 0.000 0.000 0.000 0.000 0.500)))
	     (snd-display "1comb (5 .5): ~A" v0)))
      (set! (v0 i) (comb gen in1)))
    
    (do ((gen (make-all-pass 0.5 0.0 5 :max-size 20))
	 (v0 (make-float-vector 11))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1)))
	((= i 11)
	 (if (not (mus-arrays-equal? v0 #r(0.000 0.000 0.000 0.000 0.000 1.000 0.000 0.000 0.000 0.000 0.500)))
	     (snd-display "1all-pass (5 0 .5): ~A" v0)))
      (set! (v0 i) (all-pass gen in1)))
    
    (do ((gen (make-notch 0.5 5 :max-size 20))
	 (v0 (make-float-vector 11))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1)))
	((= i 11)
	 (if (not (mus-arrays-equal? v0 #r(0.500 0.000 0.000 0.000 0.000 1.000 0.000 0.000 0.000 0.000 0.000)))
	     (snd-display "1notch (5 .5): ~A" v0)))
      (set! (v0 i) (notch gen in1)))
    
    (do ((gen (make-all-pass 0.0 0.5 5 :max-size 20))
	 (v0 (make-float-vector 11))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1)))
	((= i 11)
	 (if (not (mus-arrays-equal? v0 #r(0.500 0.000 0.000 0.000 0.000 1.000 0.000 0.000 0.000 0.000 0.000)))
	     (snd-display "1all-pass (5 .5 0): ~A" v0)))
      (set! (v0 i) (all-pass gen in1))    )
    ;; now actually use the size difference
    
    (do ((gen (make-comb 0.5 5 :max-size 20))
	 (v0 (make-float-vector 20))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1))
	 (phase 0.0 (+ phase .2)))
	((= i 20)
	 (if (not (mus-arrays-equal? v0 #r(0.000 0.000 0.000 0.000 0.000 0.000 0.800 0.400 0.000 0.000 0.000 0.000 0.000 0.160 0.360 0.200 0.040 0.000 0.000 0.000)))
	     (snd-display "2comb (5 .5): ~A" v0)))
      (set! (v0 i) (comb gen in1 phase)))
    
    (do ((gen (make-all-pass 0.5 0.0 5 :max-size 20))
	 (v0 (make-float-vector 20))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1))
	 (angle 0.0 (+ angle .2)))
	((= i 20)
	 (if (not (mus-arrays-equal? v0 #r(0.000 0.000 0.000 0.000 0.000 0.000 0.800 0.400 0.000 0.000 0.000 0.000 0.000 0.160 0.360 0.200 0.040 0.000 0.000 0.000)))
	     (snd-display "2all-pass (5 0 .5): ~A" v0)))
      (set! (v0 i) (all-pass gen in1 angle)))
    
    (do ((gen (make-notch 0.5 5 :max-size 20))
	 (v0 (make-float-vector 20))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1))
	 (angle 0.0 (+ angle .2)))
	((= i 20)
	 (if (not (mus-arrays-equal? v0 #r(0.500 0.000 0.000 0.000 0.000 0.000 0.800 0.400 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	     (snd-display "2notch (5 .5): ~A" v0)))
      (set! (v0 i) (notch gen in1 angle)))
    
    (do ((gen (make-all-pass 0.0 0.5 5 :max-size 20))
	 (v0 (make-float-vector 20))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1))
	 (angle 0.0 (+ angle .2)))
	((= i 20)
	 (if (not (mus-arrays-equal? v0 #r(0.500 0.000 0.000 0.000 0.000 0.000 0.800 0.400 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	     (snd-display "2all-pass (5 .5 0): ~A" v0)))
      (set! (v0 i) (all-pass gen in1 angle)))
    
    (do ((gen (make-comb 0.5 5 :max-size 20))
	 (v0 (make-float-vector 20))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1))
	 (angle 0.0 (- angle .2)))
	((= i 20)
	 (if (not (mus-arrays-equal? v0 #r(0.000 0.000 0.000 0.000 0.800 0.000 0.000 0.160 0.160 0.000 0.080 0.064 0.016 0.035 0.013 0.018 0.007 0.007 0.003 0.002)))
	     (snd-display "3comb (5 .5): ~A" v0)))
      (set! (v0 i) (comb gen in1 angle)))
    
    (do ((gen (make-all-pass 0.5 0.0 5 :max-size 20))
	 (v0 (make-float-vector 20))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1))
	 (angle 0.0 (- angle .2)))
	((= i 20)
	 (if (not (mus-arrays-equal? v0 #r(0.000 0.000 0.000 0.000 0.800 0.000 0.000 0.160 0.160 0.000 0.080 0.064 0.016 0.035 0.013 0.018 0.007 0.007 0.003 0.002)))
	     (snd-display "3all-pass (5 0 .5): ~A" v0)))
      (set! (v0 i) (all-pass gen in1 angle)))
    
    (do ((gen (make-notch 0.5 5 :max-size 20))
	 (v0 (make-float-vector 20))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1))
	 (angle 0.0 (- angle .2)))
	((= i 20)
	 (if (not (mus-arrays-equal? v0 #r(0.500 0.000 0.000 0.000 0.800 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	     (snd-display "3notch (5 .5): ~A" v0)))
      (set! (v0 i) (notch gen in1 angle)))
    
    (do ((gen (make-all-pass 0.0 0.5 5 :max-size 20))
	 (v0 (make-float-vector 20))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1))
	 (angle 0.0 (- angle .2)))
	((= i 20)
	 (if (not (mus-arrays-equal? v0 #r(0.500 0.000 0.000 0.000 0.800 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	     (snd-display "3all-pass (5 .5 0): ~A" v0)))
      (set! (v0 i) (all-pass gen in1 angle)))
    
    (do ((gen (make-comb 0.5 5 :max-size 20))
	 (v0 (make-float-vector 20))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1))
	 (angle 0.0 (+ angle .01)))
	((= i 20)
	 (if (not (mus-arrays-equal? v0 #r(0.000 0.000 0.000 0.000 0.000 0.950 0.060 0.000 0.000 0.000 0.428 0.079 0.004 0.000 0.000 0.182 0.067 0.008 0.000 0.000)))
	     (snd-display "4comb (5 .5): ~A" v0)))
      (set! (v0 i) (comb gen in1 angle)))
    
    (do ((gen (make-all-pass 0.5 0.0 5 :max-size 20))
	 (v0 (make-float-vector 20))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1))
	 (angle 0.0 (+ angle .01)))
	((= i 20)
	 (if (not (mus-arrays-equal? v0 #r(0.000 0.000 0.000 0.000 0.000 0.950 0.060 0.000 0.000 0.000 0.428 0.079 0.004 0.000 0.000 0.182 0.067 0.008 0.000 0.000)))
	     (snd-display "4all-pass (5 0 .5): ~A" v0)))
      (set! (v0 i) (all-pass gen in1 angle)))
    
    (do ((gen (make-notch 0.5 5 :max-size 20))
	 (v0 (make-float-vector 20))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1))
	 (angle 0.0 (+ angle .01)))
	((= i 20)
	 (if (not (mus-arrays-equal? v0 #r(0.500 0.000 0.000 0.000 0.000 0.950 0.060 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	     (snd-display "4notch (5 .5): ~A" v0)))
      (set! (v0 i) (notch gen in1 angle)))
    
    (do ((gen (make-all-pass 0.0 0.5 5 :max-size 20))
	 (v0 (make-float-vector 20))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1))
	 (angle 0.0 (+ angle .01)))
	((= i 20)
	 (if (not (mus-arrays-equal? v0 #r(0.500 0.000 0.000 0.000 0.000 0.950 0.060 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	     (snd-display "4all-pass (5 .5 0): ~A" v0)))
      (set! (v0 i) (all-pass gen in1 angle)))
    
    ;; now run off either end of the delay line "by accident"
    
    (do ((gen (make-comb 0.5 5 :max-size 10))
	 (v0 (make-float-vector 20))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1))
	 (angle 0.0 (+ angle .5)))
	((= i 20)
	 (if (not (mus-arrays-equal? v0 #r(0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.500 1.000 0.250 0.125 0.094 0.062 0.055 0.047 0.039 0.031 0.029)))
	     (snd-display "5comb (5 .5): ~A" v0)))
      (set! (v0 i) (comb gen in1 angle)))
    
    (do ((gen (make-all-pass 0.5 0.0 5 :max-size 10))
	 (v0 (make-float-vector 20))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1))
	 (angle 0.0 (+ angle .5)))
	((= i 20)
	 (if (not (mus-arrays-equal? v0 #r(0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.500 1.000 0.250 0.125 0.094 0.062 0.055 0.047 0.039 0.031 0.029)))
	     (snd-display "5all-pass (5 0 .5): ~A" v0)))
      (set! (v0 i) (all-pass gen in1 angle)))
    
    (do ((gen (make-notch 0.5 5 :max-size 10))
	 (v0 (make-float-vector 20))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1))
	 (angle 0.0 (+ angle .5)))
	((= i 20)
	 (if (not (mus-arrays-equal? v0 #r(0.500 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.500 1.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	     (snd-display "5notch (5 .5): ~A" v0)))
      (set! (v0 i) (notch gen in1 angle)))
    
    (do ((gen (make-all-pass 0.0 0.5 5 :max-size 10))
	 (v0 (make-float-vector 20))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1))
	 (angle 0.0 (+ angle .5)))
	((= i 20)
	 (if (not (mus-arrays-equal? v0 #r(0.500 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.500 1.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	     (snd-display "5all-pass (5 .5 0): ~A" v0)))
      (set! (v0 i) (all-pass gen in1 angle)))
    
    (do ((gen (make-comb 0.5 5 :max-size 10))
	 (v0 (make-float-vector 20))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1))
	 (angle 0.0 (- angle .5)))
	((= i 20)
	 (if (not (mus-arrays-equal? v0 #r(0.000 0.000 0.000 0.500 0.000 0.125 0.000 0.031 0.016 0.004 1.000 0.000 0.250 0.031 0.000 0.012 0.002 0.250 0.125 0.008)))
	     (snd-display "6comb (5 .5): ~A" v0)))
      (set! (v0 i) (comb gen in1 angle)))
    
    (do ((gen (make-all-pass 0.5 0.0 5 :max-size 10))
	 (v0 (make-float-vector 20))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1))
	 (angle 0.0 (- angle .5)))
	((= i 20)
	 (if (not (mus-arrays-equal? v0 #r(0.000 0.000 0.000 0.500 0.000 0.125 0.000 0.031 0.016 0.004 1.000 0.000 0.250 0.031 0.000 0.012 0.002 0.250 0.125 0.008)))
	     (snd-display "6all-pass (5 0 .5): ~A" v0)))
      (set! (v0 i) (all-pass gen in1 angle)))
    
    (do ((gen (make-notch 0.5 5 :max-size 10))
	 (v0 (make-float-vector 20))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1))
	 (angle 0.0 (- angle .5)))
	((= i 20)
	 (if (not (mus-arrays-equal? v0 #r(0.500 0.000 0.000 0.500 0.000 0.000 0.000 0.000 0.000 0.000 1.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	     (snd-display "6notch (5 .5): ~A" v0)))
      (set! (v0 i) (notch gen in1 angle)))
    
    (do ((gen (make-all-pass 0.0 0.5 5 :max-size 10))
	 (v0 (make-float-vector 20))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1))
	 (angle 0.0 (- angle .5)))
	((= i 20)
	 (if (not (mus-arrays-equal? v0 #r(0.500 0.000 0.000 0.500 0.000 0.000 0.000 0.000 0.000 0.000 1.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	     (snd-display "6all-pass (5 .5 0): ~A" v0)))
      (set! (v0 i) (all-pass gen in1 angle)))
    
    (do ((gen (make-filtered-comb 0.5 5 :filter (make-one-zero .5 .5)))
	 (v0 (make-float-vector 21))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1)))
	((= i 21)
	 (if (not (mus-arrays-equal? v0 #r(0.000 0.000 0.000 0.000 0.000 1.000 0.000 0.000 0.000 0.000 0.250 0.250 
					   0.000 0.000 0.000 0.062 0.125 0.062 0.000 0.000 0.016)))
	     (snd-display "filtered-comb (5 .5): ~A" v0)))
      (set! (v0 i) (filtered-comb gen in1)))
    
    (do ((gen (make-filtered-comb 0.5 5 :filter (make-one-zero .25 .75)))
	 (v0 (make-float-vector 21))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1)))
	((= i 21)
	 (if (not (mus-arrays-equal? v0 #r(0.000 0.000 0.000 0.000 0.000 1.000 0.000 0.000 0.000 0.000 0.125 0.375 
						 0.000 0.000 0.000 0.016 0.094 0.141 0.000 0.000 0.002)))
	     (snd-display "1filtered-comb (5 .5): ~A" v0)))
      (set! (v0 i) (filtered-comb gen in1)))
    
    (do ((gen (make-filtered-comb 0.5 5 :filter (make-one-zero .25 .75)))
	 (v0 (make-float-vector 21))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1)))
	((= i 21)
	 (if (not (mus-arrays-equal? v0 #r(0.000 0.000 0.000 0.000 0.000 1.000 0.000 0.000 0.000 0.000 0.125 0.375 
						 0.000 0.000 0.000 0.016 0.094 0.141 0.000 0.000 0.002)))
	     (snd-display "1run-filtered-comb (5 .5): ~A" v0)))
      (set! (v0 i) (filtered-comb gen in1)))
    
    (do ((gen (make-filtered-comb 0.5 5 :max-size 20 :filter (make-one-zero .5 .5)))
	 (v0 (make-float-vector 20))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1))
	 (angle 0.0 (+ angle .2)))
	((= i 20)
	 (if (not (mus-arrays-equal? v0 #r(0.000 0.000 0.000 0.000 0.000 0.000 0.800 0.400 0.000 0.000 0.000 0.000 0.000 0.080 0.220 0.300 0.140 0.040 0.000 0.000)))
	     (snd-display "2filtered-comb (5 .5): ~A" v0)))
      (set! (v0 i) (filtered-comb gen in1 angle)))
    
    (do ((gen (make-filtered-comb 0.5 5 :max-size 20 :filter (make-one-zero .5 .5)))
	 (v0 (make-float-vector 20))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1))
	 (angle 0.0 (- angle .2)))
	((= i 20)
	 (if (not (mus-arrays-equal? v0 #r(0.000 0.000 0.000 0.000 0.800 0.000 0.000 0.080 0.200 0.040 0.020 0.068 0.042 0.019 0.026 0.015 0.011 0.009 0.006 0.004)))
	     (snd-display "3filtered-comb (5 .5): ~A" v0)))
      (set! (v0 i) (filtered-comb gen in1 angle)))
    
    (do ((gen (make-filtered-comb 0.5 5 :max-size 20 :filter (make-one-zero .5 .5)))
	 (v0 (make-float-vector 20))
	 (in1 1.0 0.0)
	 (i 0 (+ i 1))
	 (angle 0.0 (+ angle .01)))
	((= i 20)
	 (if (not (mus-arrays-equal? v0 #r(0.000 0.000 0.000 0.000 0.000 0.950 0.060 0.000 0.000 0.000 0.214 0.251 0.043 0.002 0.000 0.045 0.106 0.081 0.023 0.003)))
	     (snd-display "4filtered-comb (5 .5): ~A" v0)))
      (set! (v0 i) (filtered-comb gen in1 angle)))
    
    (let ((gen (make-one-pole .4 .7))
	  (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "one-pole"
		       "one-pole a0: 0.400, b1: 0.700, y1: 0.000")
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (one-pole gen 1.0)))
      (let ((v1 (make-float-vector 10)))
	(let ((gen1 (make-one-pole .4 .7)))
	  (fill-float-vector v1 (if (one-pole? gen) (one-pole gen1 1.0) -1.0)))
	(if (not (mus-arrays-equal? v0 v1)) (snd-display "map one-pole: ~A ~A" v0 v1)))
      (if (not (one-pole? gen)) (snd-display "~A not one-pole?" gen))
      (if (not (= (mus-order gen) 1)) (snd-display "one-pole order: ~D?" (mus-order gen)))
      (if (fneq (mus-xcoeff gen 0) .4) (snd-display "one-pole a0: ~F?" (mus-xcoeff gen 0)))
      (if (fneq (mus-ycoeff gen 1) .7) (snd-display "one-pole b1: ~F?" (mus-ycoeff gen 1)))
      (if (or (fneq (v0 1) 0.120) (fneq (v0 4) 0.275) (fneq (v0 8) 0.245))
	  (snd-display "one-pole output: ~A" v0))
      (if (fneq (mus-ycoeff gen 1) .7) (snd-display "1p ycoeff 1 .7: ~A" gen))
      (set! (mus-ycoeff gen 1) .1)
      (if (fneq (mus-ycoeff gen 1) .1) (snd-display "1p set ycoeff 1 .1: ~A" gen))
      (if (fneq (mus-xcoeff gen 0) .4) (snd-display "1p xcoeff 0 .4: ~A" gen))
      (set! (mus-xcoeff gen 0) .3)
      (if (fneq (mus-xcoeff gen 0) .3) (snd-display "1p set xcoeff 0 .3: ~A" gen)))
    
    
    (let ((gen (make-one-zero .4 .7))
	  (v0 (make-float-vector 10)))
      (print-and-check gen
		       "one-zero"
		       "one-zero a0: 0.400, a1: 0.700, x1: 0.000")
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (one-zero gen 1.0)))
      (let ((v1 (make-float-vector 10)))
	(let ((gen1 (make-one-zero .4 .7)))
	  (fill-float-vector v1 (if (one-zero? gen) (one-zero gen1 1.0) -1.0)))
	(if (not (mus-arrays-equal? v0 v1)) (snd-display "map one-zero: ~A ~A" v0 v1)))
      (if (not (one-zero? gen)) (snd-display "~A not one-zero?" gen))
      (if (not (= (mus-order gen) 1)) (snd-display "one-zero order: ~D?" (mus-order gen)))
      (if (fneq (mus-xcoeff gen 0) .4) (snd-display "one-zero a0: ~F?" (mus-xcoeff gen 0)))
      (if (fneq (mus-xcoeff gen 1) .7) (snd-display "one-zero a1: ~F?" (mus-xcoeff gen 1)))
      (if (fneq (v0 1) 1.1) (snd-display "one-zero output: ~A" v0))
      (if (fneq (mus-xcoeff gen 0) .4) (snd-display "1z xcoeff 0 .4: ~A" gen))
      (set! (mus-xcoeff gen 0) .1)
      (if (fneq (mus-xcoeff gen 0) .1) (snd-display "1z set xcoeff 0 .1: ~A" gen)))
    
    (let ((gen (make-two-zero .4 .7 .3))
	  (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "two-zero"
		       "two-zero a0: 0.400, a1: 0.700, a2: 0.300, x1: 0.000, x2: 0.000")
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (two-zero gen 1.0)))
      (let ((v1 (make-float-vector 10)))
	(let ((gen1 (make-two-zero .4 .7 .3)))
	  (fill-float-vector v1 (if (two-zero? gen1) (two-zero gen1 1.0) -1.0)))
	(if (not (mus-arrays-equal? v0 v1)) (snd-display "map two-zero: ~A ~A" v0 v1)))
      (if (not (two-zero? gen)) (snd-display "~A not two-zero?" gen))
      (if (not (= (mus-order gen) 2)) (snd-display "two-zero order: ~D?" (mus-order gen)))
      (if (fneq (mus-xcoeff gen 0) .4) (snd-display "two-zero a0: ~F?" (mus-xcoeff gen 0)))
      (if (fneq (mus-xcoeff gen 1) .7) (snd-display "two-zero a1: ~F?" (mus-xcoeff gen 1)))
      (if (fneq (mus-xcoeff gen 2) .3) (snd-display "two-zero a2: ~F?" (mus-xcoeff gen 2)))
      (if (or (fneq (v0 1) 1.1) (fneq (v0 8) 1.4)) (snd-display "two-zero output: ~A" v0))
      (if (fneq (mus-xcoeff gen 0) .4) (snd-display "2z xcoeff 0 .4: ~A" gen))
      (set! (mus-xcoeff gen 0) .1)
      (if (fneq (mus-xcoeff gen 0) .1) (snd-display "2z set xcoeff 0 .1: ~A" gen))
      (set! (mus-xcoeff gen 0) 1.0)
      (let ((r (mus-scaler gen)))
	(set! (mus-frequency gen) 500.0)
	(if (ffneq (mus-frequency gen) 500.0) (snd-display "set mus-frequency two-zero: ~A" (mus-frequency gen)))
	(if (fneq (mus-scaler gen) r) (snd-display "set mus-frequency two-zero hit r: ~A" (mus-scaler gen))))
      (set! (mus-scaler gen) .99)
      (if (fneq (mus-scaler gen) .99) (snd-display "set mus-scaler two-zero: ~A" (mus-scaler gen)))
      (if (ffneq (mus-frequency gen) 500.0) (snd-display "set mus-scaler hit freq two-zero: ~A" (mus-frequency gen)))
      (let ((g3 (make-two-zero :radius .99 :frequency 500.0)))
	(if (or (fneq (mus-xcoeff gen 0) (mus-xcoeff g3 0))
		(fneq (mus-xcoeff gen 1) (mus-xcoeff g3 1))
		(fneq (mus-xcoeff gen 2) (mus-xcoeff g3 2)))
	    (snd-display "two-zero setters: ~A ~A" gen g3))))
    
    (let* ((gen (make-two-zero .4 .7 .3))
	   (val (gen 1.0)))
      (if (fneq val .4) (snd-display "2zero->0.4: ~A" val))
      (set! val (gen 0.5))
      (if (fneq val .9) (snd-display "2zero->0.9: ~A" val))
      (set! val (gen 1.0))
      (if (fneq val 1.05) (snd-display "2zero->1.05: ~A" val)))
    
    (let ((gen (make-two-pole .4 .7 .3))
	  (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "two-pole"
		       "two-pole a0: 0.400, b1: 0.700, b2: 0.300, y1: 0.000, y2: 0.000")
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (two-pole gen 1.0)))
      (let ((v1 (make-float-vector 10)))
	(let ((gen1 (make-two-pole .4 .7 .3)))
	  (fill-float-vector v1 (if (two-pole? gen1) (two-pole gen1 1.0) -1.0)))
	(if (not (mus-arrays-equal? v0 v1)) (snd-display "map two-pole: ~A ~A" v0 v1)))
      (if (not (two-pole? gen)) (snd-display "~A not two-pole?" gen))
      (if (not (= (mus-order gen) 2)) (snd-display "two-pole order: ~D?" (mus-order gen)))
      (if (fneq (mus-xcoeff gen 0) .4) (snd-display "two-pole a0: ~F?" (mus-xcoeff gen 0)))
      (if (fneq (mus-ycoeff gen 1) .7) (snd-display "two-pole b1: ~F?" (mus-ycoeff gen 1)))
      (if (fneq (mus-ycoeff gen 2) .3) (snd-display "two-pole b2: ~F?" (mus-ycoeff gen 2)))
      (if (or (fneq (v0 1) 0.12) (fneq (v0 8) 0.201)) (snd-display "two-pole output: ~A" v0))
      (if (fneq (mus-ycoeff gen 1) .7) (snd-display "2p ycoeff 1 .7: ~A" gen))
      (set! (mus-ycoeff gen 1) .1)
      (if (fneq (mus-ycoeff gen 1) .1) (snd-display "2p set ycoeff 1 .1: ~A" gen))
      (if (fneq (mus-xcoeff gen 0) .4) (snd-display "2p xcoeff 0 .4: ~A" gen))
      (set! (mus-xcoeff gen 0) .3)
      (if (fneq (mus-xcoeff gen 0) .3) (snd-display "2p set xcoeff 0 .3: ~A" gen))
      (set! (mus-xcoeff gen 0) 1.0)
      (let ((r (mus-scaler gen)))
	(set! (mus-frequency gen) 500.0)
	(if (ffneq (mus-frequency gen) 500.0) (snd-display "set mus-frequency two-pole: ~A" (mus-frequency gen)))
	(if (fneq (mus-scaler gen) r) (snd-display "set mus-frequency two-pole hit r: ~A" (mus-scaler gen))))
      (set! (mus-scaler gen) .99)
      (if (fneq (mus-scaler gen) .99) (snd-display "set mus-scaler two-pole: ~A" (mus-scaler gen)))
      (if (ffneq (mus-frequency gen) 500.0) (snd-display "set mus-scaler hit freq two-pole: ~A" (mus-frequency gen)))
      (let ((g3 (make-two-pole :radius .99 :frequency 500.0)))
	(if (or (fneq (mus-xcoeff gen 0) (mus-xcoeff g3 0))
		(fneq (mus-ycoeff gen 1) (mus-ycoeff g3 1))
		(fneq (mus-ycoeff gen 2) (mus-ycoeff g3 2)))
	    (snd-display "two-pole setters: ~A ~A" gen g3))))
    
    (let* ((gen (make-two-pole .4 .7 .3))
	   (val (gen 1.0)))
      (if (fneq val .4) (snd-display "a0->out 2pole: ~A" val))
      (set! val (gen 0.5))
      (if (fneq val -.08) (snd-display "a0->out 2pole (-0.08): ~A" val))
      (set! val (gen 1.0))
      (if (fneq val 0.336) (snd-display "a0->out 2pole (0.336): ~A" val)))
    
    (let ((gen (make-oscil 440.0))
	  (v0 (make-float-vector 10))
	  (v1 (make-float-vector 10)))
      (print-and-check gen 
		       "oscil"
		       "oscil freq: 440.000Hz, phase: 0.000")
      (do ((gen1 (make-oscil 440.0))
	   (i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (oscil gen 0.0))
	(set! (v1 i) (mus-apply gen1 0.0 0.0)))
      (let ((v2 (make-float-vector 10)))
	(let ((gen2 (make-oscil 440.0)))
	  (fill-float-vector v2 (if (oscil? gen2) (oscil gen2 0.0) -1.0)))
	(if (not (mus-arrays-equal? v0 v2)) (snd-display "map oscil: ~A ~A" v0 v2)))
      (if (not (oscil? gen)) (snd-display "~A not oscil?" gen))
      (if (fneq (mus-phase gen) 1.253787) (snd-display "oscil phase: ~F?" (mus-phase gen)))
      (if (fneq (mus-frequency gen) 440.0) (snd-display "oscil frequency: ~F?" (mus-frequency gen)))
      (if (not (= (mus-length gen) 1)) (snd-display "oscil cosines: ~D?" (mus-length gen)))
      (if (or (fneq (v0 1) 0.125) (fneq (v0 8) 0.843)) (snd-display "oscil output: ~A" v0))
      (set! (mus-phase gen) 0.0)
      (if (fneq (mus-phase gen) 0.0) (snd-display "oscil set-phase: ~F?" (mus-phase gen)))
      (set! (mus-frequency gen) 100.0)
      (if (fneq (mus-frequency gen) 100.0) (snd-display "oscil set-frequency: ~F?" (mus-frequency gen)))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(if (fneq (v0 i) (v1 i))
	    (snd-display "mus-apply oscil at ~D: ~A ~A?" i (v0 i) (v1 i))))
      (if (fneq (mus-apply) 0.0)
	  (snd-display "(mus-apply): ~A" (mus-apply))))

    ;; we can't (or don't anyway) guarantee optimized arg order evaluation so:
    (let ((o (make-oscil 1000.0)) 
	  (o1 (make-oscil 1000.0))
	  (v (make-float-vector 10))
	  (x 0.0))
      (do ((i 0 (+ i 1))) 
	  ((= i 10))
	(set! x (oscil o (oscil o1) (oscil o1)))
	(set! (v i) x))
      (let ((o4 (make-oscil 1000.0)) 
	    (o5 (make-oscil 1000.0))
	    (v2 (make-float-vector 10))
	    (x1 0.0)
	    (x2 0.0))
	(do ((i 0 (+ i 1))) 
	    ((= i 10))
	  (set! x1 (oscil o5))
	  (set! x2 (oscil o5))
	  (set! (v2 i) (oscil o4 x2 x1)))
	(let ()
	  (define (hi) 
	    (do ((o2 (make-oscil 1000.0)) 
		 (o3 (make-oscil 1000.0)) 
		 (v1 (make-float-vector 10))
		 (i 0 (+ i 1)))
		((= i 10) v1)
	      (float-vector-set! v1 i (oscil o2 (oscil o3) (oscil o3)))))
	  (hi)
	  (let ((v1 (hi)))
	    (if (not (or (mus-arrays-equal? v v1)
			 (mus-arrays-equal? v2 v1)))
		(format *stderr* ":orig: ~A~%;  v1: ~A~%;  v2: ~A~%" v v1 v2))))))
    (test-fm-components)

    ;; osc-opt
    (let ((g1 (make-oscil 1000))
	  (g2 (make-oscil 1000))
	  (g3 (make-oscil 1000))
	  (g4 (make-oscil 1000))
	  (g5 (make-oscil 1000))
	  (g6 (make-oscil 1000))
	  (x1 1.0)
	  (x2 (hz->radians 100.0))
	  (x4 (hz->radians 5.0)))
      (do ((x1x2 (* x1 x2))
	   (x420 (* 20 x4))
	   (i 0 (+ i 1)))
	  ((= i 50))
	(let ((o1 (oscil g1 x2))
	      (o2 (* 1.0 (oscil g2 x2)))
	      (o3 (oscil g3 x420))
	      (o4 (oscil g4 x420))
	      (o5 (oscil g5 x1x2))
	      (o6 (* 1.0 (oscil g6 x420))))
	  (if (> (abs (- (+ o2 o3 o4 o5 o6) (* 5 o1))) 1e-6)
	      (snd-display "~A: ~1,4F ~1,4F ~1,4F ~1,4F ~1,4F ~1,4F" i o1 o2 o3 o4 o5 o6)))))

    ;; nrxysin-opt)
    (let ((g1 (make-nrxysin 1000 :n 10 :r .9))
	  (g2 (make-nrxysin 1000 :n 10 :r .9))
	  (g3 (make-nrxysin 1000 :n 10 :r .9))
	  (g4 (make-nrxysin 1000 :n 10 :r .9))
	  (g5 (make-nrxysin 1000 :n 10 :r .9))
	  (g6 (make-nrxysin 1000 :n 10 :r .9))
	  (x1 1.0)
	  (x2 (hz->radians 100.0))
	  (x4 (hz->radians 5.0)))
      (do ((x1x2 (* x1 x2))
	   (x420 (* 20 x4))
	   (i 0 (+ i 1)))
	  ((= i 50))
	(let ((o1 (nrxysin g1 x2))
	      (o2 (* 1.0 (nrxysin g2 x2)))
	      (o3 (nrxysin g3 x420))
	      (o4 (nrxysin g4 x420))
	      (o5 (nrxysin g5 x1x2))
	      (o6 (nrxysin g6 x420)))
	  (if (> (abs (- (+ o2 o3 o4 o5 o6) (* 5 o1))) 1e-6)
	      (format () "~A: ~1,4F ~1,4F ~1,4F ~1,4F ~1,4F ~1,4F~%" i o1 o2 o3 o4 o5 o6)))))
  
    ;; polywave-opt
    (let ((g1 (make-polywave 1000 '(1 .5 2 .5)))
	  (g2 (make-polywave 1000 '(1 .5 2 .5)))
	  (g3 (make-polywave 1000 '(1 .5 2 .5)))
	  (g4 (make-polywave 1000 '(1 .5 2 .5)))
	  (g5 (make-polywave 1000 '(1 .5 2 .5)))
	  (g6 (make-polywave 1000 '(1 .5 2 .5)))
	  (x1 1.0)
	  (x2 (hz->radians 100.0))
	  (x4 (hz->radians 5.0)))
      (do ((x1x2 (* x1 x2))
	   (x420 (* 20 x4))
	   (i 0 (+ i 1)))
	  ((= i 50))
	(let ((o1 (polywave g1 x2))
	      (o2 (* 1.0 (polywave g2 x2)))
	      (o3 (polywave g3 x420))
	      (o4 (polywave g4 x420))
	      (o5 (polywave g5 x1x2))
	      (o6 (* 1.0 (polywave g6 x420))))
	  (if (> (abs (- (+ o2 o3 o4 o5 o6) (* 5 o1))) 1e-6)
	      (format () "~A: ~1,4F ~1,4F ~1,4F ~1,4F ~1,4F ~1,4F~%" i o1 o2 o3 o4 o5 o6)))))

    (let ((test-simple-polywave 
	   (lambda (n offset kind)
	     (let ((p (do ((h (if offset (list offset 0) ()))
			   (i 1 (+ i 1)))
			  ((> i n)
			   (make-polywave 400.0 (reverse h) kind))  
			(set! h (cons (* i .1) (cons i h)))))
		   (vp (make-float-vector 200))
		   (vo (make-float-vector 200))
		   (ob (make-oscil-bank
			(apply float-vector (do ((frqs (if offset (list 0.0) ()))
						 (i 1 (+ i 1)))
						((> i n)
						 (reverse frqs))
					      (set! frqs (cons (hz->radians (* i 400.0)) frqs))))
			(let ((phases (make-float-vector (if offset (+ n 1) n)
							 (if (= kind mus-chebyshev-second-kind) 0.0 (/ pi 2)))))
			  (if (and offset (= kind mus-chebyshev-second-kind))
			      (set! (phases 0) (/ pi 2)))
			  phases)
			(apply float-vector (do ((amps (if offset (list offset) ()))
						 (i 1 (+ i 1)))
						((> i n)
						 (reverse amps))  
					      (set! amps (cons (* i .1) amps))))
			#t)))
	       (do ((i 0 (+ i 1)))
		   ((= i 200))
		 (float-vector-set! vp i (polywave p)))
	       (do ((i 0 (+ i 1)))
		   ((= i 200))
		 (float-vector-set! vo i (oscil-bank ob)))
	       (if (not (mus-arrays-equal? vp vo))
		   (format *stderr* ";simple polywave ~A ~A ~A: ~A~%    ~A~%    ~A~%~A ~A~%" 
			   n offset (if (= kind mus-chebyshev-first-kind) 'first 'second)
			   (float-vector-peak (float-vector-subtract! (copy vp) vo))
			   vp vo
			   p ob))
	       
	       (let ((temp 0.0))
		 (do ((i 0 (+ i 1)))
		     ((= i 200))
		   (set! temp (polywave p))
		   (vector-set! vp i temp)
		   (set! (vo i) (oscil-bank ob)))
		 (if (not (mus-arrays-equal? vp vo))
		     (format *stderr* ";simple polywave (temps) ~A ~A ~A: ~A~%    ~A~%    ~A~%~A ~A~%" 
			     n offset (if (= kind mus-chebyshev-first-kind) 'first 'second)
			     (float-vector-peak (float-vector-subtract! (copy vp) vo))
			     vp vo
			     p ob)))
	       
	       (let ((t1 (find-sound (with-sound ("test.snd")
				       (do ((i 0 (+ i 1)))
					   ((= i 200))
					 (outa i (polywave p))))))
		     (t2 (find-sound (with-sound ("tst.snd")
				       (do ((i 0 (+ i 1)))
					   ((= i 200))
					 (outa i (oscil-bank ob)))))))
		 (set! vp (channel->float-vector 0 200 t1 0))
		 (set! vo (channel->float-vector 0 200 t2 0))
		 
		 (if (not (mus-arrays-equal? vp vo))
		     (format *stderr* ";simple polywave (with-sound) n: ~A, offset: ~A, type: ~A (len: ~D ~D): dist: ~A~%    ~A~%    ~A~%~A ~A~%" 
			     n offset (if (= kind mus-chebyshev-first-kind) 'first 'second)
			     (length vp) (length vo)
			     (float-vector-peak (float-vector-subtract! (copy vp) vo))
			     vp vo
			     p ob))
		 (close-sound t1)
		 (close-sound t2))))))
      
      (do ((i 1 (+ i 1)))
	  ((= i 6))
	(test-simple-polywave i #f mus-chebyshev-first-kind)
	(test-simple-polywave i .1 mus-chebyshev-first-kind)
	(test-simple-polywave i #f mus-chebyshev-second-kind)
	(test-simple-polywave i .1 mus-chebyshev-second-kind)))

    (do ((gen1 (make-oscil 100.0))
	 (gen2 (make-oscil -100.0))
	 (mx 0.0)
	 (i 0 (+ i 1)))
	((= i 100)
	 (if (fneq mx 0.0)
	     (snd-display "oscil +-: ~A" mx)))
      (set! mx (max mx (abs (+ (gen1) (gen2))))))
    
    (do ((gen1 (make-oscil 100.0 (* pi 0.5)))
	 (gen2 (make-oscil -100.0 (* pi 0.5)))
	 (mx 0.0)
	 (i 0 (+ i 1)))
	((= i 100)
	 (if (fneq mx 0.0)
	     (snd-display "cosil +-: ~A" mx)))
      (set! mx (max mx (abs (- (gen1) (gen2))))))
    
    (let ((frqs #r(0.0 0.0))
	  (amps #r(0.0 0.0))
	  (phs #r(0.0 0.0)))
      (let ((ob (make-oscil-bank frqs phs amps)))
	(if (not (oscil-bank? ob)) (snd-display "oscil-bank? ~A" ob))
	(if (not (equivalent? (mus-data ob) phs)) (snd-display "oscil-bank data: ~A ~A" (mus-data ob) phs))
	(let ((x (oscil-bank ob)))
	  (if (not (= x 0.0)) (snd-display "oscil-bank 0.0: ~A~%" x)))
	(set! (amps 0) 0.5)
	(set! (amps 1) 0.2)
	(let ((x (oscil-bank ob)))
	  (if (not (= x 0.0)) (snd-display "oscil-bank 0.0 (amps): ~A~%" x)))
	(set! (frqs 0) .1)
	(set! (frqs 1) .2)
	(oscil-bank ob)
	(let ((x (oscil-bank ob)))
	  (if (not (equivalent? x 0.08965057448242633)) (snd-display "oscil-bank 0.09: ~A~%" x)))))
    
    (for-each fm-test (vector (make-oscil) (make-nrxysin) (make-nrxycos) (make-square-wave) (make-triangle-wave) (make-ncos)
			      (make-nsin) (make-sawtooth-wave) (make-rand) (make-rand-interp) (make-pulse-train)))
    
    (do ((gen (make-oscil 440.0))
	 (gen1 (make-oscil 440.0))
	 (i 0 (+ i 1)))
	((= i 10))
      (let ((oval (oscil gen .1))
	    (mval (mus-run gen1 .1)))
	(if (fneq oval mval)
	    (snd-display "mus-run ~A but oscil ~A?" mval oval))))
    
    (let ((gen (make-oscil 440.0))
	  (gen1 (make-oscil 440.0))
	  (gen2 (make-oscil 440.0))
	  (gen3 (make-oscil 440.0))
	  (fm-index (hz->radians 440.0))
	  (v0 (make-float-vector 10))
	  (v1 (make-float-vector 10)))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (oscil gen (* fm-index (oscil gen1 0.0))))
	(set! (v1 i) (mus-apply gen2 (* fm-index (mus-apply gen3 0.0 0.0)) 0.0)))
      (if (or (fneq (v0 1) 0.125) (fneq (v0 6) 0.830) (fneq (v0 8) 0.987))
	  (snd-display "oscil fm output: ~A" v0))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(if (fneq (v0 i) (v1 i))
	    (snd-display "mus-apply fm oscil at ~D: ~A ~A?" i (v0 i) (v1 i)))))
    
    (test-gen-equal (make-oscil 440.0) (make-oscil 440.0) (make-oscil 100.0))
    (test-gen-equal (make-oscil 440.0) (make-oscil 440.0) (make-oscil 440.0 1.0))
    
    (do ((gen (make-oscil 440.0))
	 (gen1 (make-oscil 440.0))
	 (pm-index 2.0)
	 (v0 (make-float-vector 10))
	 (i 0 (+ i 1)))
	((= i 10)
	 (if (or (fneq (v0 1) 0.367) (fneq (v0 6) 0.854) (fneq (v0 8) 0.437))
	     (snd-display "oscil pm output: ~A" v0)))
      (set! (v0 i) (gen 0.0 (* pm-index (gen1 0.0)))))
    
    (do ((gen (make-oscil 440.0))
	 (i 0 (+ i 1)))
	((= i 1100))
      (let ((val1 (sin (mus-phase gen)))
	    (val2 (gen 0.0)))
	(if (fneq val1 val2)
	    (snd-display "oscil: ~A: ~A ~A" i val1 val2))))
    
    (do ((gen (make-oscil 440.0 :initial-phase (* pi 0.5)))
	 (incr (/ (* 2 pi 440.0) 22050.0))
	 (i 0 (+ i 1))
	 (a 0.0))
	((= i 900))
      (let ((val1 (cos a))
	    (val2 (gen 0.0)))
	(if (fneq val1 val2)
	    (snd-display "oscil (cos): ~A: ~A ~A" i val1 val2)))
      (set! a (+ a incr)))
    
    (do ((gen (make-oscil 0.0))
	 (gen1 (make-oscil 40.0))
	 (incr (/ (* 2 pi 40.0) 22050.0))
	 (i 0 (+ i 1))
	 (a 0.0))
	((= i 1100))
      (let ((val1 (sin (sin a)))
	    (val2 (oscil gen 0.0 (oscil gen1 0.0))))
	(if (fneq val1 val2)
	    (snd-display "oscil pm: ~A: ~A ~A" i val1 val2)))
      (set! a (+ a incr)))
    
    (do ((gen (make-oscil 0.0))
	 (gen1 (make-oscil 40.0))
	 (incr (/ (* 2 pi 40.0) 22050.0))
	 (a1 0.0)
	 (i 0 (+ i 1))
	 (a 0.0))
	((= i 100))
      (let ((fm (sin a))
	    (val1 (sin a1))
	    (val2 (oscil gen (oscil gen1 0.0))))
	(set! a1 (+ a1 fm))
	(if (fneq val1 val2)
	    (snd-display "oscil fm: ~A: ~A ~A" i val1 val2))
	(set! a (+ a incr))))
    
    (let ()
      (define (oscil-1-1)
	(let ((osc (make-oscil 440.0))
	      (v1 (make-vector 10 0.0))
	      (v2 (make-vector 10 0.0)))
	  (set! (v1 0) (oscil osc))
	  (set! (v1 1) (oscil osc))
	  (do ((osc (make-oscil 440.0))
	       (i 0 (+ i 1)))
	      ((= i 10))
	    (set! (v2 i) (oscil osc)))
	  (do ((i 2 (+ i 1)))
	      ((= i 10))
	    (set! (v1 i) (oscil osc)))
	  (if (not (equal? v1 v2))
	      (snd-display "oscil-1 shadowing test1: ~A ~A" v1 v2))))
      
      (define oscil-1-2
	(let ((ho-1 (lambda (osc v i)
		      (set! (v i) (oscil osc)))))
	  (lambda ()
	    (let ((o1 (make-oscil 440.0))
		  (o2 (make-oscil 440.0))
		  (v1 (make-vector 10 0.0))
		  (v2 (make-vector 10 0.0)))
	      (ho-1 o1 v1 0)
	      (ho-1 o1 v1 1)
	      (do ((i 0 (+ i 1)))
		  ((= i 10))
		(set! (v2 i) (oscil o2)))
	      (do ((i 2 (+ i 1)))
		  ((= i 10))
		(set! (v1 i) (oscil o1)))
	      (if (not (equal? v1 v2))
		  (snd-display "oscil-1 shadowing test2: ~A ~A" v1 v2))))))
	  
      (define oscil-1-3
	(let ((ho (lambda ()
		    (let ((osc (make-oscil 440.0)))
		      (lambda ()
			(oscil osc))))))
	  (lambda ()
	    (let ((o1 (ho))
		  (v1 (make-vector 10 0.0))
		  (v2 (make-vector 10 0.0)))
	      (set! (v1 0) (o1))
	      (set! (v1 1) (o1))
	      (do ((o2 (ho))
		   (i 0 (+ i 1)))
		  ((= i 10))
		(set! (v2 i) (o2)))
	      (do ((i 2 (+ i 1)))
		  ((= i 10))
		(set! (v1 i) (o1)))
	      (if (not (equal? v1 v2))
		  (snd-display "oscil-1 shadowing test3: ~A ~A" v1 v2))))))
      
      (oscil-1-1)
      (oscil-1-2)
      (oscil-1-3))
    
    
    (let ((var (catch #t (lambda () (mus-location (make-oscil))) (lambda args args))))
      (if (not (eq? (car var) 'mus-error))
	  (snd-display "mus-location bad gen: ~A" var)))
    (let ((var (catch #t (lambda () (set! (mus-location (make-oscil)) 0)) (lambda args args))))
      (if (not (eq? (car var) 'mus-error))
	  (snd-display "set mus-location bad gen: ~A" var)))
    (let ((var (catch #t (lambda () (set! (mus-scaler (make-oscil)) 0)) (lambda args args))))
      (if (not (eq? (car var) 'mus-error))
	  (snd-display "set mus-scaler bad gen: ~A" var)))
    (let ((var (catch #t (lambda () (mus-frequency (make-one-pole))) (lambda args args))))
      (if (not (eq? (car var) 'mus-error))
	  (snd-display "mus-frequency bad gen: ~A" var)))
    (let ((var (catch #t (lambda () (set! (mus-frequency (make-one-pole)) 0)) (lambda args args))))
      (if (not (eq? (car var) 'mus-error))
	  (snd-display "set mus-frequency bad gen: ~A" var)))
    (let ((var (catch #t (lambda () (make-delay 41943040)) ;(* 1024 1024 40)
		      (lambda args args))))
      (if (not (eq? (car var) 'out-of-range))
	  (snd-display "make-delay huge line: ~A" var)))
    (let ((var (catch #t (lambda () (make-delay 32 :max-size 41943040)) ;(* 1024 1024 40))
		      (lambda args args))))
      (if (and (pair? var)
	       (not (eq? (car var) 'out-of-range))) ; max-size can change in random tests
	  (snd-display "make-delay huge line: ~A" var)))
    
    (let ((size 1000)
	  
	  (test-pm (lambda (beg end freq amp mc-ratio index)
		     (do ((pm (make-oscil (* freq mc-ratio)))
			  (carrier (make-oscil freq))
			  (i beg (+ i 1)))
			 ((= i end))
		       (outa i (* amp (oscil carrier 0.0 (* index (oscil pm))))))))
	  
	  (test-fm (lambda (beg end freq amp mc-ratio index)
		     (do ((fm (make-oscil (* freq mc-ratio) :initial-phase (/ pi 2.0)))
			  (carrier (make-oscil freq))
			  (fm-index (* (hz->radians freq) mc-ratio index))
			  (i beg (+ i 1)))
			 ((= i end))
		       (outa i (* amp (oscil carrier (* fm-index (oscil fm)))))))))
      
      ;; there's an initial-phase confusion here, so by making the srate high and freq low, we minimize uninteresting off-by-1 troubles
      
      (let ((v1 (with-sound ((make-float-vector size) :srate 441000) (test-pm 0 size 20 1 1 1)))
	    (v2 (with-sound ((make-float-vector size) :srate 441000) (test-fm 0 size 20 1 1 1))))
	(if (not (mus-arrays-equal? v1 v2))
	    (snd-display "fm/pm peak diff (1 1): ~A" (float-vector-peak (float-vector-subtract! v1 v2)))))
      
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(let ((ratio (+ 1 (random 4)))
	      (index (random 2.0)))
	  (let ((v1 (with-sound ((make-float-vector size) :srate 441000) (test-pm 0 size 20 1 ratio index)))
		(v2 (with-sound ((make-float-vector size) :srate 441000) (test-fm 0 size 20 1 ratio index))))
	    (if (not (mus-arrays-equal? v1 v2))
		(snd-display "fm/pm peak diff ~A ~A: ~A" ratio index (float-vector-peak (float-vector-subtract! v1 v2))))))))
    
    (let ((gen (make-ncos 440.0 10))
	  (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "ncos"
		       "ncos freq: 440.000Hz, phase: 0.000, n: 10")
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (ncos gen 0.0)))
      (let ((v1 (make-float-vector 10)))
	(let ((gen1 (make-ncos 440.0 10)))
	  (fill-float-vector v1 (if (ncos? gen1) (ncos gen1 0.0) -1.0)))
	(if (not (mus-arrays-equal? v0 v1)) (snd-display "map ncos: ~A ~A" v0 v1)))
      (if (not (ncos? gen)) (snd-display "~A not ncos?" gen))
      (if (fneq (mus-phase gen) 1.253787) (snd-display "ncos phase: ~F?" (mus-phase gen)))
      (if (fneq (mus-frequency gen) 440.0) (snd-display "ncos frequency: ~F?" (mus-frequency gen)))
      (if (fneq (mus-scaler gen) .1) (snd-display "ncos scaler: ~F?" (mus-scaler gen)))
      (unless (= (mus-length gen) 10)
	(snd-display "ncos n: ~D?" (mus-length gen)))
      (if (or (fneq (v0 1) 0.722) (fneq (v0 8) -0.143)) (snd-display "ncos output: ~A" v0))
      (set! (mus-scaler gen) .5) (if (fneq (mus-scaler gen) 0.5) (snd-display "ncos set-scaler: ~F?" (mus-scaler gen)))
      (set! (mus-length gen) 5) (if (not (= (mus-length gen) 5)) (snd-display "set ncos n: ~D?" (mus-length gen)))
      (if (fneq (mus-scaler gen) .2) (snd-display "set n->scaler: ~A" (mus-scaler gen))))
    
    (test-gen-equal (make-ncos 440.0 3) (make-ncos 440.0 3) (make-ncos 440.0 5))
    (test-gen-equal (make-ncos 440.0 3) (make-ncos 440.0 3) (make-ncos 400.0 3))
    
    (do ((gen (make-ncos 440 10))
	 (i 0 (+ i 1)))
	((= i 1100))
      (let ((val1 (let ((den (sin (* (mus-phase gen) 0.5))))
		    (if (= 0.0 den)
			1.0
			(min 1.0 (* (mus-scaler gen)
				    (- (/ (sin (* (mus-phase gen)
						  (+ (mus-length gen) 0.5)))
					  (* 2.0 den))
				       0.5))))))
	    (val2 (gen 0.0)))
	(if (> (abs (- val1 val2)) .002)
	    (snd-display "ncos: ~A: ~A ~A" i val1 val2))))
    
    (do ((gen1 (make-ncos 100.0 10))
	 (gen2 (make-ncos -100.0 10))
	 (mx 0.0)
	 (i 0 (+ i 1)))
	((= i 100)
	 (if (fneq mx 0.0)
	     (snd-display "ncos +-: ~A" mx)))
      (set! mx (max mx (abs (- (gen1) (gen2))))))

    (for-each (lambda (n)
		(let ((p (make-ncos 400.0 n))
		      (vp (make-float-vector 200))
		      (vo (make-float-vector 200)))
		  (let ((ob (make-oscil-bank 
			     (apply float-vector (do ((frqs ())
						      (i 1 (+ i 1)))
						     ((> i n)
						      (reverse frqs))  
						   (set! frqs (cons (hz->radians (* i 400.0)) frqs))))
			     (make-float-vector n (/ pi 2.0))
			     (make-float-vector n (mus-scaler p))
			     #t)))
		    (do ((i 0 (+ i 1)))
			((= i 200))
		      (float-vector-set! vp i (ncos p)))
		    (do ((i 0 (+ i 1)))
			((= i 200))
		      (float-vector-set! vo i (oscil-bank ob)))
		    (if (not (mus-arrays-equal? vp vo))
			(format *stderr* ";simple ncos ~A: ~A~%    ~A~%    ~A~%~A ~A~%" 
				n 
				(float-vector-peak (float-vector-subtract! (copy vp) vo))
				vp vo
				p ob)))))
	      '(1 3 10))
    
    (let ((gen (make-nsin 440.0 10))
	  (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "nsin"
		       "nsin freq: 440.000Hz, phase: 0.000, n: 10")
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (nsin gen 0.0)))
      (let ((v1 (make-float-vector 10)))
	(let ((gen1 (make-nsin 440.0 10))) 
	  (fill-float-vector v1 (if (nsin? gen1) (nsin gen1 0.0) -1.0)))
	(if (not (mus-arrays-equal? v0 v1)) (snd-display "map nsin: ~A ~A" v0 v1)))
      (if (not (nsin? gen)) (snd-display "~A not nsin?" gen))
      (if (fneq (mus-phase gen) 1.253787) (snd-display "nsin phase: ~F?" (mus-phase gen)))
      (if (fneq (mus-frequency gen) 440.0) (snd-display "nsin frequency: ~F?" (mus-frequency gen)))
      (if (fneq (mus-scaler gen) .1315) (snd-display "nsin scaler: ~F?" (mus-scaler gen)))
      (unless (= (mus-length gen) 10)
	(snd-display "nsin n: ~D?" (mus-length gen)))
      (if (or (fneq (v0 1) 0.784) (fneq (v0 8) 0.181)) (snd-display "nsin output: ~A" v0))
      (set! (mus-scaler gen) .5) (if (fneq (mus-scaler gen) 0.5) (snd-display "nsin set-scaler: ~F?" (mus-scaler gen)))
      (set! (mus-length gen) 5) (if (not (= (mus-length gen) 5)) (snd-display "set nsin n: ~D?" (mus-length gen)))
      (if (fneq (mus-scaler gen) .2525) (snd-display "set sines->scaler: ~A" (mus-scaler gen))))
    
    (test-gen-equal (make-nsin 440.0 3) (make-nsin 440.0 3) (make-nsin 440.0 5))
    (test-gen-equal (make-nsin 440.0 3) (make-nsin 440.0 3) (make-nsin 400.0 3))
    
    (do ((gen1 (make-nsin 100.0 10))
	 (gen2 (make-nsin -100.0 10))
	 (mx 0.0)
	 (i 0 (+ i 1)))
	((= i 100)
	 (if (fneq mx 0.0)
	     (snd-display "nsin +-: ~A" mx)))
      (set! mx (max mx (abs (+ (gen1) (gen2))))))

    (for-each (lambda (n)
		(let ((p (make-nsin 400.0 n))
		      (vp (make-float-vector 200))
		      (vo (make-float-vector 200))
		      (parts (apply float-vector
				    (do ((frqs ())
					 (i 1 (+ i 1)))
					((> i n)
					 (reverse frqs))   
				      (set! frqs (cons (hz->radians (* i 400.0)) frqs))))))
		  (let ((ob (make-oscil-bank parts (make-float-vector n) (make-float-vector n (mus-scaler p)) #t)))
		    (do ((i 0 (+ i 1)))
			((= i 200))
		      (float-vector-set! vp i (nsin p)))
		    (do ((i 0 (+ i 1)))
			((= i 200))
		      (float-vector-set! vo i (oscil-bank ob)))
		    (if (not (mus-arrays-equal? vp vo))
			(format *stderr* ";simple nsin ~A: ~A~%    ~A~%    ~A~%~A ~A~%" 
				n 
				(float-vector-peak (float-vector-subtract! (copy vp) vo))
				vp vo
				p ob)))))
	      '(1 3 10))
    
    (let ((gen (make-nrxysin 440.0)))
      (print-and-check gen 
		       "nrxysin"
                       "nrxysin frequency: 440.000, ratio: 1.000, phase: 0.000, n: 1, r: 0.500")
      (let ((v0 (make-float-vector 10)))
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (set! (v0 i) (nrxysin gen 0.0)))
	(let ((v1 (make-float-vector 10)))
	  (let ((gen1 (make-nrxysin 440.0)))
	    (fill-float-vector v1 (if (nrxysin? gen1) (nrxysin gen1 0.0) -1.0)))
	  (if (not (mus-arrays-equal? v0 v1)) (snd-display "map nrxysin: ~A ~A" v0 v1))))
      (if (not (nrxysin? gen)) (snd-display "~A not nrxysin?" gen))
      (if (fneq (mus-phase gen) 1.253787) (snd-display "nrxysin phase: ~F?" (mus-phase gen)))
      (if (fneq (mus-frequency gen) 440.0) (snd-display "nrxysin frequency: ~F?" (mus-frequency gen)))
      (if (fneq (mus-scaler gen) 0.5) (snd-display "mus-scaler (a) nrxysin: ~A" (mus-scaler gen)))
      (set! (mus-scaler gen) 0.75)
      (if (fneq (mus-scaler gen) 0.75) (snd-display "mus-scaler (set a) nrxysin: ~A" (mus-scaler gen)))
      (if (not (= (mus-length gen) 1)) (snd-display "mus-length nrxysin: ~A" (mus-length gen)))
      (if (fneq (mus-offset gen) 1.0) (snd-display "mus-offset nrxysin: ~A" (mus-offset gen))))
    
    (test-gen-equal (make-nrxysin 440.0) (make-nrxysin 440.0) (make-nrxysin 100.0))
    (test-gen-equal (make-nrxysin 440.0) (make-nrxysin 440.0) (make-nrxysin 440.0 1.5))
    (test-gen-equal (make-nrxysin 440.0) (make-nrxysin 440.0) (make-nrxysin 440.0 :n 3))
    
    (let ((v1 (make-float-vector 10)))
      (with-sound (v1 :srate 44100)
	(do ((gen (make-nrxysin 1000 :n 10 :r .99))
	     (i 0 (+ i 1)))
	    ((= i 10))
	  (outa i (nrxysin gen))))
      (if (not (mus-arrays-equal? v1 #r(0.000 0.671 0.637 0.186 0.017 0.169 0.202 0.048 0.007 0.105)))
	  (snd-display "ws nrxysin output: ~A" v1)))
    
    
    (let ((gen (make-nrxycos 440.0)))
      (print-and-check gen 
		       "nrxycos"
                       "nrxycos frequency: 440.000, ratio: 1.000, phase: 0.000, n: 1, r: 0.500")
      (let ((v0 (make-float-vector 10)))
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (set! (v0 i) (nrxycos gen 0.0)))
	(let ((v1 (make-float-vector 10)))
	  (let ((gen1 (make-nrxycos 440.0))) 
	    (fill-float-vector v1 (if (nrxycos? gen1) (nrxycos gen1 0.0) -1.0)))
	  (if (not (mus-arrays-equal? v0 v1)) (snd-display "map nrxycos: ~A ~A" v0 v1))))
      (if (not (nrxycos? gen)) (snd-display "~A not nrxycos?" gen))
      (if (fneq (mus-phase gen) 1.253787) (snd-display "nrxycos phase: ~F?" (mus-phase gen)))
      (if (fneq (mus-frequency gen) 440.0) (snd-display "nrxycos frequency: ~F?" (mus-frequency gen)))
      (if (fneq (mus-scaler gen) 0.5) (snd-display "mus-scaler (a) nrxycos: ~A" (mus-scaler gen)))
      (set! (mus-scaler gen) 0.75)
      (if (fneq (mus-scaler gen) 0.75) (snd-display "mus-scaler (set a) nrxycos: ~A" (mus-scaler gen)))
      (if (not (= (mus-length gen) 1)) (snd-display "mus-length nrxycos: ~A" (mus-length gen)))
      (if (fneq (mus-offset gen) 1.0) (snd-display "mus-offset nrxycos: ~A" (mus-offset gen))))
    
    (test-gen-equal (make-nrxycos 440.0) (make-nrxycos 440.0) (make-nrxycos 100.0))
    (test-gen-equal (make-nrxycos 440.0) (make-nrxycos 440.0) (make-nrxycos 440.0 1.5))
    (test-gen-equal (make-nrxycos 440.0) (make-nrxycos 440.0) (make-nrxycos 440.0 :n 3))
    
    (let ((v1 (with-sound ((make-float-vector 10) :srate 44100)
			  (do ((gen (make-nrxycos 1000 :n 10 :r .99))
			       (i 0 (+ i 1)))
			      ((= i 10))
			    (outa i (nrxycos gen))))))
      (if (not (mus-arrays-equal? v1 #r(1.000 0.602 -0.067 -0.242 -0.007 0.071 -0.087 -0.128 -0.007 0.012)))
	  (snd-display "ws nrxycos output: ~A" v1)))
    
    (let ((gen (make-asymmetric-fm 440.0))
	  (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "asymmetric-fm"
		       "asymmetric-fm freq: 440.000Hz, phase: 0.000, ratio: 1.000, r: 1.000")
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (asymmetric-fm gen 0.0)))
      (let ((v1 (make-float-vector 10)))
	(let ((gen1 (make-asymmetric-fm 440.0)))
	  (fill-float-vector v1 (if (asymmetric-fm? gen1) (asymmetric-fm gen1 0.0) -1.0)))
	(if (not (mus-arrays-equal? v0 v1)) (snd-display "map asymmetric-fm: ~A ~A" v0 v1)))
      (if (not (asymmetric-fm? gen)) (snd-display "~A not asymmetric-fm?" gen))
      (if (fneq (mus-phase gen) 1.253787) (snd-display "asymmetric-fm phase: ~F?" (mus-phase gen)))
      (set! (mus-phase gen) 1.0)
      (if (fneq (mus-phase gen) 1.0) (snd-display "set! asymmetric-fm phase: ~F?" (mus-phase gen)))
      (if (fneq (mus-frequency gen) 440.0) (snd-display "asymmetric-fm frequency: ~F?" (mus-frequency gen)))
      (set! (mus-frequency gen) 100.0)
      (if (fneq (mus-frequency gen) 100.0) (snd-display "set! asymmetric-fm frequency: ~F?" (mus-frequency gen)))
      (if (or (fneq (v0 2) 0.969) (fneq (v0 8) .538)) (snd-display "asymmetric-fm output: ~A" v0))
      (if (fneq (mus-scaler gen) 1.0) (snd-display "mus-scaler (r) asymmetric-fm: ~A" (mus-scaler gen)))
      (set! (mus-scaler gen) 0.5)
      (if (fneq (mus-scaler gen) 0.5) (snd-display "mus-scaler (set r) asymmetric-fm: ~A" (mus-scaler gen)))
      (if (fneq (mus-offset gen) 1.0) (snd-display "mus-offset asymmetric-fm: ~A" (mus-offset gen))))
    
    (test-gen-equal (make-asymmetric-fm 440.0) (make-asymmetric-fm 440.0) (make-asymmetric-fm 100.0))
    (test-gen-equal (make-asymmetric-fm 440.0) (make-asymmetric-fm 440.0) (make-asymmetric-fm 440.0 1.0))
    (test-gen-equal (make-asymmetric-fm 440.0) (make-asymmetric-fm 440.0) (make-asymmetric-fm 440.0 0.0 3))
    
    (do ((gen1 (make-asymmetric-fm 1000 0 1.0 0.1))
	 (gen2 (make-oscil 1000 :initial-phase (* 0.5 pi)))
	 (happy #t)
	 (i 0 (+ i 1)))
	((or (not happy) (= i 100)))
      (let ((ss (asymmetric-fm gen1 0.0))
	    (os (oscil gen2 0.0)))
	(when (fneq ss os)
	  (snd-display "asymmetric-fm 1: ~A: os: ~A ss: ~A" i os ss)
	  (set! happy #f))))
    
    (for-each
     (lambda (index)
       (for-each
	(lambda (r)
	  (let ((peak (float-vector-peak (with-sound (:clipped #f :output (make-float-vector 1000))
					    (do ((gen (make-asymmetric-fm 2000.0 :ratio .1 :r r))
						 (i 0 (+ i 1)))
						((= i 1000))
					      (outa i (asymmetric-fm gen index)))))))
	    (if (> (abs (- peak 1.0)) .1)
		(snd-display "asymmetric-fm peak: ~A, index: ~A, r: ~A" peak index r))))
	'(-10.0 -1.5 -0.5 0.5 1.0 1.5 10.0)))
     '(1.0 3.0 10.0))
    
    (let ((float-vector0 (make-float-vector 2048))
	  (float-vector1 (make-float-vector 2048))
	  (gen3 (make-asymmetric-fm 1000 0 1.0 0.2))
	  (gen4 (make-oscil 1000 (* 0.5 pi)))
	  (gen5 (make-oscil 200))
	  (fm1 (hz->radians (* 1.0 .2 1000)))) ; make notions of "index" match
      (do ((i 0 (+ i 1)))
	  ((= i 2048))
	(set! (float-vector0 i) (asymmetric-fm gen3 1.0))
	(set! (float-vector1 i) (oscil gen4 (* fm1 (oscil gen5)))))
      (let ((spectr1 (snd-spectrum float-vector0 rectangular-window 2048 #t))
	    (spectr2 (snd-spectrum float-vector1 rectangular-window 2048 #t))
	    (happy #t))
	(do ((i 1 (+ i 1)))
	    ((or (not happy)
		 (= i 512)))
	  (when (> (abs (- (spectr1 i) (spectr2 i))) .02)
	    (snd-display "asymmetric-fm 2: ~A: ~A ~A" i (spectr1 i) (spectr2 i))
	    (set! happy #f)))))
    
    (let ((gen (make-asymmetric-fm 40.0 0.0 1.0 0.1))
	  (gen1 (make-asyfm :frequency 40.0 :ratio .1 :index 2.0))
	  (incr (/ (* 2 pi 40.0) *clm-srate*))
	  (r 1.0))
      (do ((ratio 0.1)
	   (cr (* 0.5 (- r (/ 1.0 r))))
	   (sr (* 0.5 (+ r (/ 1.0 r))))
	   (i 0 (+ i 1))
	   (a 0.0 (+ a incr)))
	  ((= i 1100))
	(let ((val1 (asymmetric-fm gen 2.0)) ; 1.0=index
	      (val3 (asyfm-J gen1 0.0))
	      (index 2.0)
	      (mth (* ratio a)))
	  (let ((val2 (* (exp (* index cr (+ 1.0 (cos mth))))
			 (cos (+ a (* index sr (sin mth)))))))
	    (if (or (fneq val1 val2)
		    (fneq val1 val3))
		(snd-display "asyfm by hand: ~A: ~A ~A ~A" i val1 val2 val3))))))
    
    (let ((float-vector0 (make-float-vector 2048))
	  (float-vector1 (make-float-vector 2048))
	  (gen3 (make-asymmetric-fm 1000 0 2.0 0.1))
	  (gen4 (make-asymmetric-fm 1000 0 0.5 0.1)))
      (do ((i 0 (+ i 1)))
	  ((= i 2048))
	(set! (float-vector0 i) (asymmetric-fm gen3 2.0))
	(set! (float-vector1 i) (asymmetric-fm gen4 2.0)))
      (let ((spectr1 (snd-spectrum float-vector0 rectangular-window 2048 #t))
	    (s1-loc 0)
	    (s2-loc 0))
	(do ((spectr2 (snd-spectrum float-vector1 rectangular-window 2048 #t))
	     (i 1 (+ i 1)))
	    ((= i 256))
	  (if (within-.01? (spectr1 i)) ;(< (abs (- 1.0 (spectr1 i))) .01) 
	      (set! s1-loc i))
	  (if (within-.01? (spectr2 i)) ;(< (abs (- 1.0 (spectr2 i))) .01) 
	      (set! s2-loc i)))
	(if (> s2-loc s1-loc) (snd-display "asymmetric-fm peaks: ~A ~A" s1-loc s2-loc))
	(let ((center (* 11025/1024 0.5 (+ s1-loc s2-loc)))) ;(* (/ 22050 2048) .5 (+ s1-loc s2-loc))
	  (if (> (abs (- 1000 center)) 60) (snd-display "asymmetric-fm center: ~A" center)))
	(set! (mus-scaler gen3) 0.5)
	(do ((i 0 (+ i 1)))
	    ((= i 2048))
	  (set! (float-vector0 i) (asymmetric-fm gen3 2.0)))
	(set! spectr1 (snd-spectrum float-vector0 rectangular-window 2048 #t))
	(do ((i 1 (+ i 1)))
	    ((= i 256))
	  (if (within-.01? (spectr1 i)) ;(< (abs (- 1.0 (spectr1 i))) .01) 
	      (set! s1-loc i)))
	(if (not (= s2-loc s1-loc)) (snd-display "asymmetric-fm set r peaks: ~A ~A" s1-loc s2-loc))
	(do ((i 0 (+ i 1)))
	    ((= i 2048))
	  (set! (float-vector0 i) (asymmetric-fm gen3 2.0)))
	(snd-spectrum float-vector0 rectangular-window 2048 #t 0.0 #t)
	(do ((i 1 (+ i 1)))
	    ((= i 256))
	  (if (within-.01? (float-vector0 i)) ;(< (abs (- 1.0 (float-vector0 i))) .01) 
	      (set! s1-loc i)))
	(if (not (= s2-loc s1-loc)) (snd-display "asymmetric-fm set r in place peaks: ~A ~A" s1-loc s2-loc))))
    
    (asyfm-I (make-asyfm :frequency 2000 :ratio .1) 0.0)
    
    (do ((i 2 (+ i 1)))
	((= i 40))
      (let ((v (make-float-vector i)))
	(do ((k 0 (+ k 1)))
	    ((= k i))
	  (set! (v k) (expt 1.2 (- k))))
	(do ((f (make-fir-filter i v))
	     (k 0 (+ k 1))
	     (x 1.0 0.0))
	    ((= k i))
	  (let ((val (fir-filter f x))
		(exval (expt 1.2 (- k))))
	    (if (> (abs (- val exval)) 1e-12)
		(format *stderr* ";for-filter ~D at ~D: ~A ~A~%" i k val exval))))))
    
    (let ((f (make-fir-filter 3 #r(1.0 .5 .25)))
	  (v (make-float-vector 10)))
      (set! (v 0) (f 1.0))
      (do ((i 1 (+ i 1)))
	  ((= i 5))
	(set! (v i) (f 0.0)))
      (set! (v 5) (f 1.0))
      (do ((i 6 (+ i 1)))
	  ((= i 10))
	(set! (v i) (f 0.0)))
      (if (not (mus-arrays-equal? v #r(1.0 0.5 .25 0.0 0.0 1.0 0.5 .25 0.0 0.0)))
	  (format *stderr* ";f3: ~A~%" v)))
    
    (let ((f (make-fir-filter 7 #r(.7 .6 .5 .4 .3 .2 .1)))
	  (v (make-float-vector 10)))
      (set! (v 0) (f 1.0))
      (do ((i 1 (+ i 1)))
	  ((= i 10))
	(set! (v i) (f 0.0)))
      (if (not (mus-arrays-equal? v #r(.7 .6 .5 .4 .3 .2 .1 0.0 0.0 0.0)))
	  (format *stderr* ";f7: ~A~%" v)))
    
    
    (let ((f (make-iir-filter 3 #r(1.0 .5 .25)))
	  (v (make-float-vector 10)))
      (set! (v 0) (f 1.0))
      (do ((i 1 (+ i 1)))
	  ((= i 5))
	(set! (v i) (f 0.0)))
      (set! (v 5) (f 1.0))
      (do ((i 6 (+ i 1)))
	  ((= i 10))
	(set! (v i) (f 0.0)))
      (if (not (mus-arrays-equal? v #r(1.0 -0.5 0.0 0.125 -0.0625 1.0 -0.484375 -0.0078125 0.125 -0.060546875)))
	  (format *stderr* ";i3: ~A~%" v)))
    
    
    (let ((f (make-iir-filter 7 #r(.7 .6 .5 .4 .3 .2 .1)))
	  (v (make-float-vector 30)))
      (set! (v 0) (f 1.0))
      (do ((i 1 (+ i 1)))
	  ((= i 30))
	(set! (v i) (f 0.0)))
      (unless (mus-arrays-equal? v #r(1.000000 -0.600000 -0.140000 -0.016000 0.019600 0.032240 0.039256 0.045286 
						 -0.048376 -0.021312 -0.001324 0.006140 0.007033 0.004780 0.000657 -0.005043 
						 -0.002420 0.000256 0.001217 0.001013 0.000350 -0.000292 -0.000579 -0.000219 
						 0.000109 0.000192 0.000115 0.000002 -0.000067 -0.000065))
	(format *stderr* ";i7: ")
	(do ((i 0 (+ i 1)))
	    ((= i 30))
	  (format *stderr* "~,6f " (v i)))
	(format *stderr* "~%")))
    
    (let ((x (make-float-vector 3))
	  (y (make-float-vector 3)))
      (do ((i 0 (+ i 1)))
	  ((= i 3))
	(set! (x i) (expt 1.2 (- i)))
	(set! (y i) (expt 1.5 (- i))))
      
      (let ((f (make-filter 3 x y))
	    (v (make-float-vector 10)))
	(set! (v 0) (f 1.0))
	(do ((i 1 (+ i 1)))
	    ((= i 10))
	  (set! (v i) (f 0.0)))
	(unless (mus-arrays-equal? v #r(1.000000 0.166667 0.138889 -0.166667 0.049383 0.041152 -0.049383 0.014632 0.012193 -0.014632))
	  (format *stderr* ";g3: ")
	  (do ((i 0 (+ i 1)))
	      ((= i 10))
	    (format *stderr* "~,6f " (v i)))
	  (format *stderr* "~%"))))
    
    (let ((x (make-float-vector 9))
	  (y (make-float-vector 9)))
      (do ((i 0 (+ i 1)))
	  ((= i 9))
	(set! (x i) (expt 1.2 (- i)))
	(set! (y i) (expt 1.2 (- i))))
      
      (let ((f (make-filter 9 x y))
	    (v (make-float-vector 30)))
	(set! (v 0) (f 1.0))
	(do ((i 1 (+ i 1)))
	    ((= i 30))
	  (set! (v i) (f 0.0)))
	(unless (mus-arrays-equal? v #r(1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0
						   0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0))
	  (format *stderr* ";g9: ")
	  (do ((i 0 (+ i 1)))
	      ((= i 30))
	    (format *stderr* "~,6f " (v i)))
	  (format *stderr* "~%"))))
    
    (let ((x (make-float-vector 9))
	  (y (make-float-vector 9)))
      (do ((i 0 (+ i 1)))
	  ((= i 9))
	(set! (x i) (expt 1.2 (- i)))
	(set! (y i) (expt 1.5 (- i))))
      
      (let ((f (make-filter 9 x y))
	    (v (make-float-vector 30)))
	(set! (v 0) (f 1.0))
	(do ((i 1 (+ i 1)))
	    ((= i 30))
	  (set! (v i) (f 0.0)))
	(unless (mus-arrays-equal? v #r(1.000000 0.166667 0.138889 0.115741 0.096451 0.080376 0.066980 0.055816 0.046514 
						   -0.129033 0.004335 0.003613 0.003011 0.002509 0.002091 0.001742 0.001452 0.001210 
						   -0.003356 0.000113 0.000094 0.000078 0.000065 0.000054 0.000045 0.000038 0.000031
						   -0.000087 0.000003 0.000002))
	  (format *stderr* ";g9e: ")
	  (do ((i 0 (+ i 1)))
	      ((= i 30))
	    (format *stderr* "~,6f " (v i)))
	  (format *stderr* "~%"))))

    (let ((x (make-float-vector 8))
	  (y (make-float-vector 8)))
      (do ((i 0 (+ i 1)))
	  ((= i 8))
	(set! (x i) (expt 1.5 (- i)))
	(set! (y i) (expt 1.2 (- i))))
      
      (let ((f (make-filter 8 x y))
	    (v (make-float-vector 30)))
	(set! (v 0) (f 1.0))
	(do ((i 1 (+ i 1)))
	    ((= i 30))
	  (set! (v i) (f 0.0)))
	(unless (mus-arrays-equal? v #r(1.000000 -0.166667 -0.111111 -0.074074 -0.049383 -0.032922 -0.021948 -0.014632 
						   0.183795 -0.038761 -0.025841 -0.017227 -0.011485 -0.007657 -0.005104 -0.003403 
						   0.042745 -0.009015 -0.006010 -0.004007 -0.002671 -0.001781 -0.001187 -0.000791 
						   0.009941 -0.002097 -0.001398 -0.000932 -0.000621 -0.000414))
	  (format *stderr* ";g-8: ")
	  (do ((i 0 (+ i 1)))
	      ((= i 30))
	    (format *stderr* "~,6f " (v i)))
	  (format *stderr* "~%"))))

    (let ((x (make-float-vector 18))
	  (y (make-float-vector 18)))
      (do ((i 0 (+ i 1)))
	  ((= i 18))
	(set! (x i) (expt 1.5 (- i)))
	(set! (y i) (expt 1.2 (- i))))
      
      (let ((f (make-filter 18 x y))
	    (v (make-float-vector 30)))
	(set! (v 0) (f 1.0))
	(do ((i 1 (+ i 1)))
	    ((= i 30))
	  (set! (v i) (f 0.0)))
	(unless (mus-arrays-equal? v #r(1.000000 -0.166667 -0.111111 -0.074074 -0.049383 -0.032922 -0.021948 -0.014632 -0.009755 
						   -0.006503 -0.004335 -0.002890 -0.001927 -0.001285 -0.000856 -0.000571 -0.000381 -0.000254 
						   0.036715 -0.006260 -0.004173 -0.002782 -0.001855 -0.001237 -0.000824 -0.000550 -0.000366 
						   -0.000244 -0.000163 -0.000109))
	  (format *stderr* ";g-18: ")
	  (do ((i 0 (+ i 1)))
	      ((= i 30))
	    (format *stderr* "~,6f " (v i)))
	  (format *stderr* "~%"))))

    (let ((x (make-float-vector 9))
	  (y (make-float-vector 9)))
      (do ((i 0 (+ i 1)))
	  ((= i 9))
	(set! (x i) (expt 1.5 (- i)))
	(set! (y i) (expt 1.2 (- i))))
      
      (let ((f (make-filter 9 x y))
	    (v (make-float-vector 30)))
	(set! (v 0) (f 1.0))
	(do ((i 1 (+ i 1)))
	    ((= i 30))
	  (set! (v i) (f 0.0)))
	(unless (mus-arrays-equal? v #r(1.000000 -0.166667 -0.111111 -0.074074 -0.049383 -0.032922 
						   -0.021948 -0.014632 -0.009755 0.161291 -0.032301 -0.021534 
						   -0.014356 -0.009571 -0.006380 -0.004254 -0.002836 -0.001891 
						   0.031259 -0.006260 -0.004173 -0.002782 -0.001855 -0.001237 
						   -0.000824 -0.000550 -0.000366 0.006058 -0.001213 -0.000809))
	  (format *stderr* ";g-9: ")
	  (do ((i 0 (+ i 1)))
	      ((= i 30))
	    (format *stderr* "~,6f " (v i)))
	  (format *stderr* "~%"))))
    
    
    (let ((gen (make-fir-filter 3 #r(.5 .25 .125)))
	  (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "fir-filter"
		       "fir-filter order: 3, xs: [0.5 0.25 0.125]"
		       )
      (set! (v0 0) (fir-filter gen 1.0))
      (do ((i 1 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (fir-filter gen 0.0)))
      (let ((v1 (make-float-vector 10)))
	(let ((inp 1.0)
	      (gen1 (make-fir-filter 3 #r(.5 .25 .125))))  
	  (fill-float-vector v1 (let ((val (if (fir-filter? gen1) (fir-filter gen1 inp) -1.0)))
				  (set! inp 0.0)
				  val)))
	(if (not (mus-arrays-equal? v0 v1)) (snd-display "map fir-filter: ~A ~A" v0 v1)))
      (if (not (fir-filter? gen)) (snd-display "~A not fir-filter?" gen))
      (if (not (= (mus-length gen) 3)) (snd-display "fir-filter length: ~D?" (mus-length gen)))
      (if (or (fneq (v0 1) 0.25) (fneq (v0 2) .125)) (snd-display "fir-filter output: ~A" v0))
      (let ((data (mus-xcoeffs gen)))
	(if (fneq (data 1) .25) (snd-display "fir-filter xcoeffs: ~A?" data)))
      (let ((tag (catch #t (lambda () (mus-xcoeff gen 123)) (lambda args (car args)))))
	(if (not (eq? tag 'mus-error))
	    (snd-display "xcoeff 123: ~A" tag)))
      (let ((tag (catch #t (lambda () (mus-ycoeff gen 123)) (lambda args (car args)))))
	(if (not (eq? tag 'mus-error))
	    (snd-display "fir ycoeff 123: ~A" tag))))
    
    (test-gen-equal (let ((f1 (make-fir-filter 3 #r(.5 .25 .125)) )) (fir-filter f1 1.0) f1)
		    (let ((f2 (make-fir-filter 3 #r(.5 .25 .125)) )) (fir-filter f2 1.0) f2)
		    (let ((f3 (make-fir-filter 3 #r(.75 .25 .125)))) (fir-filter f3 1.0) f3))
    (test-gen-equal (let ((f1 (make-fir-filter 3 #r(.5 .25 .125)) )) (fir-filter f1 1.0) f1)
		    (let ((f2 (make-fir-filter 3 #r(.5 .25 .125)) )) (fir-filter f2 1.0) f2)
		    (let ((f3 (make-fir-filter 2 #r(.5 .25)))) (fir-filter f3 1.0) f3))
    
    (let* ((coeffs #r(.1 .2 .3 .4 .4 .3 .2 .1))
	   (flt (make-fir-filter 8 coeffs)))
      (let ((xcof (mus-xcoeffs flt))
	    (es (make-vector 8)))
	(do ((i 0 (+ i 1)))
	    ((= i 8))
	  (set! (es i) (make-env (list 0 (coeffs i) 1 0) :length 102)))
	(set! (es 5) (make-env '(0 .4 1 1) :length 102))
	(let ((data (make-float-vector 100)))
	  (do ((k 0 (+ k 1)))
	      ((= k 100))
	    (set! (data k) (fir-filter flt (if (= (modulo k 12) 0) 1.0 0.0)))
	    (do ((i 0 (+ i 1)))
		((= i 8))
	      (float-vector-set! xcof i (env (vector-ref es i)))))
	  (if (or (fneq (data 1) .2)
		  (fneq (data 10) 0.0)
		  (fneq (data 18) 0.166)
		  (fneq (data 89) 0.923))
	      (snd-display "filter xcoeffs: ~A?" data)))))
    
    (let ((make-f-filter (lambda (coeffs)
			   (list coeffs (make-float-vector (length coeffs)))))
	  (f-filter (lambda (flt x)
		      (let ((coeffs (car flt))
			    (xs (cadr flt)))
			(let ((xlen (length xs)))
			  (float-vector-move! xs (- xlen 1) (- xlen 2) #t)
			  (set! (xs 0) x)
			  (dot-product coeffs xs xlen))))))
      (do ((fir1 (make-fir-filter 3 #r(1.0 0.4 0.1)))
	   (fir2 (make-f-filter #r(1.0 0.4 0.1)))
	   (x 1.0)
	   (happy #t)
	   (i 0 (+ i 1)))
	  ((or (not happy) (= i 10)))
	(let ((val1 (fir-filter fir1 x))
	      (val2 (f-filter fir2 x)))
	  (set! x 0.0)
	  (when (fneq val1 val2)
	    (snd-display "f-filter ~A -> ~A ~A" i val1 val2)
	    (set! happy #f)))))
    
    (let ((gen (make-spencer-filter)))
      (if (not (fir-filter? gen)) 
	  (snd-display "make-spencer-filter returns ~A?" gen)
	  (begin
	    (if (not (= (mus-order gen) 15)) (snd-display "make-spencer-filter order ~A?" (mus-order gen)))
	    (if (not (mus-arrays-equal? (mus-xcoeffs gen) #r(-0.009 -0.019 -0.016 0.009 0.066 0.144 0.209 0.231 0.209 0.144 0.066 0.009 -0.016 -0.019 -0.009)))
		(snd-display "make-spencer-filter coeffs: ~A" (mus-xcoeffs gen))))))
    
    (let ((flt (mus-xcoeffs (make-savitzky-golay-filter 5 2))))
      (if (not (mus-arrays-equal? flt #r(-0.086 0.343 0.486 0.343 -0.086)))
	  (snd-display "sg 5 2: ~A" flt)))
    (let ((flt (mus-xcoeffs (make-savitzky-golay-filter 11 2))))
      (if (not (mus-arrays-equal? flt #r(-0.084 0.021 0.103 0.161 0.196 0.207 0.196 0.161 0.103 0.021 -0.084)))
	  (snd-display "sg 11 2: ~A" flt)))
    (let ((flt (mus-xcoeffs (make-savitzky-golay-filter 11 4))))
      (if (not (mus-arrays-equal? flt #r(0.042 -0.105 -0.023 0.140 0.280 0.333 0.280 0.140 -0.023 -0.105 0.042)))
	  (snd-display "sg 11 4: ~A" flt)))
    (let ((flt (mus-xcoeffs (make-savitzky-golay-filter 25 2))))
      (if (not (mus-arrays-equal? flt #r(-0.049 -0.027 -0.006 0.012 0.028 0.043 0.055 0.066 0.075 0.082 0.086 
						    0.089 0.090 0.089 0.086 0.082 0.075 0.066 0.055 0.043 
						    0.028 0.012 -0.006 -0.027 -0.049)))
	  (snd-display "sg 25 2: ~A" flt)))
    
    (let ((gen (make-iir-filter 3 #r(.5 .25 .125)))
	  (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "iir-filter"
		       "iir-filter order: 3, ys: [0.5 0.25 0.125]"
		       )
      (set! (v0 0) (iir-filter gen 1.0))
      (do ((i 1 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (iir-filter gen 0.0)))
      (let ((v1 (make-float-vector 10)))
	(let ((inp 1.0)
	      (gen1 (make-iir-filter 3 #r(.5 .25 .125))))  
	  (fill-float-vector v1 (let ((val (if (iir-filter? gen1) (iir-filter gen1 inp) -1.0)))
				  (set! inp 0.0)
				  val)))
	(if (not (mus-arrays-equal? v0 v1)) (snd-display "map iir-filter: ~A ~A" v0 v1)))
      (if (not (iir-filter? gen)) (snd-display "~A not iir-filter?" gen))
      (if (not (= (mus-length gen) 3)) (snd-display "iir-filter length: ~D?" (mus-length gen)))
      (if (or (fneq (v0 1) -0.25) (fneq (v0 2) -.062)) (snd-display "iir-filter output: ~A" v0))
      (let ((data (mus-ycoeffs gen)))
	(if (fneq (data 1) .25) (snd-display "iir-filter ycoeffs: ~A?" data)))
      (let ((tag (catch #t (lambda () (mus-ycoeff gen 123)) (lambda args (car args)))))
	(if (not (eq? tag 'mus-error))
	    (snd-display "ycoeff 123: ~A" tag)))
      (let ((tag (catch #t (lambda () (mus-xcoeff gen 123)) (lambda args (car args)))))
	(if (not (eq? tag 'mus-error))
	    (snd-display "iir xcoeff 123: ~A" tag))))
    
    (test-gen-equal (let ((f1 (make-iir-filter 3 #r(.5 .25 .125)))) (iir-filter f1 1.0) f1)
		    (let ((f2 (make-iir-filter 3 #r(.5 .25 .125)) )) (iir-filter f2 1.0) f2)
		    (let ((f3 (make-iir-filter 3 #r(.75 .25 .125)))) (iir-filter f3 1.0) f3))
    (test-gen-equal (let ((f1 (make-iir-filter 3 #r(.5 .25 .125)) )) (iir-filter f1 1.0) f1)
		    (let ((f2 (make-iir-filter 3 #r(.5 .25 .125)) )) (iir-filter f2 1.0) f2)
		    (let ((f3 (make-iir-filter 2 #r(.5 .25)))) (iir-filter f3 1.0) f3))
    
    (let ((gen (make-filter 3 #r(.5 .25 .125) #r(.5 .25 .125))))
      (print-and-check gen 
		       "filter"
		       "filter order: 3, xs: [0.5 0.25 0.125], ys: [0.5 0.25 0.125]")
      (let ((v0 (make-float-vector 10))
	    (gen2 (make-biquad .1 .2 .3 .4 .5)))
	(set! (v0 0) (filter gen 1.0))
	(do ((i 1 (+ i 1)))
	    ((= i 10))
	  (set! (v0 i) (filter gen 0.0)))
	(let ((v1 (make-float-vector 10))
	      (gen1 (make-filter 3 #r(.5 .25 .125) #r(.5 .25 .125)))
	      (inp 1.0))
	  (fill-float-vector v1 (let ((val (if (filter? gen1) (filter gen1 inp) -1.0)))
				  (set! inp 0.0)
				  val))
	  (if (not (mus-arrays-equal? v0 v1)) (snd-display "map filter: ~A ~A" v0 v1)))
	(if (not (filter? gen)) (snd-display "~A not filter?" gen))
	(if (not (= (mus-length gen) 3)) (snd-display "filter length: ~D?" (mus-length gen)))
	(if (or (fneq (v0 1) 0.125) (fneq (v0 2) .031)) (snd-display "filter output: ~A" v0))
	(if (not (filter? gen2)) (snd-display "make-biquad: ~A" gen2)))
      (let ((xs (mus-xcoeffs gen))
	    (ys (mus-ycoeffs gen)))
	(if (not (and (equal? xs #r(.5 .25 .125))
		      (equal? xs ys)))
	    (snd-display "mus-xcoeffs: ~A ~A?" xs ys))))
    
    (let ((var (catch #t (lambda () (make-filter :order 2 :xcoeffs #r(1.0 0.5) :ycoeffs #r(2.0 1.0 0.5))) (lambda args args))))
      (if (not (eq? (car var) 'mus-error))
	  (snd-display "make-filter bad coeffs: ~A" var)))
    (let ((var (catch #t (lambda () (make-filter :order 0 :xcoeffs #r(1.0 0.5))) (lambda args args))))
      (if (not (eq? (car var) 'out-of-range))
	  (snd-display "make-filter bad order: ~A" var)))
    (let ((var (catch #t (lambda () (make-fir-filter :order 22 :xcoeffs #r(1.0 0.5))) (lambda args args))))
      (if (not (eq? (car var) 'mus-error))
	  (snd-display "make-fir-filter bad coeffs: ~A" var)))
    (let ((var (catch #t (lambda () (make-iir-filter :order 22 :ycoeffs #r(1.0 0.5))) (lambda args args))))
      (if (not (eq? (car var) 'mus-error))
	  (snd-display "make-iir-filter bad coeffs: ~A" var)))
    (let ((var (catch #t (lambda () (make-fir-filter -1)) (lambda args args))))
      (if (not (eq? (car var) 'out-of-range))
	  (snd-display "make-fir-filter bad order: ~A" var)))
    (let ((var (make-filter :order 2 :ycoeffs #r(1.0 0.5))))
      (if (not (iir-filter? var))
	  (snd-display "make-filter with only y: ~A" var)))
    
    (test-gen-equal (let ((f1 (make-filter 3 #r(.5 .25 .125) #r(.5 .25 .125)))) (filter f1 1.0) f1)
		    (let ((f2 (make-filter 3 #r(.5 .25 .125) #r(.5 .25 .125)))) (filter f2 1.0) f2)
		    (let ((f3 (make-filter 3 #r(.5 .25 .125) #r(.5 .5 .5)))) (filter f3 1.0) f3))
    (test-gen-equal (let ((f1 (make-filter 3 #r(.5 .25 .125) #r(.5 .25 .125)))) (filter f1 1.0) f1)
		    (let ((f2 (make-filter 3 #r(.5 .25 .125) #r(.5 .25 .125)))) (filter f2 1.0) f2)
		    (let ((f3 (make-filter 3 #r(.5 .5 .125) #r(.5 .25 .0625)))) (filter f3 1.0) f3))
    
    (let ((fr (mus-length (make-fir-filter 6 #r(0 1 2 3 4 5)))))
      (if (not (= fr 6)) (snd-display "filter-length: ~A" fr)))
    
    (let ((val (cascade->canonical (list #r(1.0 0.0 0.0) #r(1.0 0.5 0.25)))))
      (if (not (mus-arrays-equal? val #r(1.000 0.500 0.250 0.000 0.000)))
	  (snd-display "cas2can 0: ~A" val)))
    (let ((val (cascade->canonical (list #r(1.0 1.0 0.0) #r(1.0 0.5 0.25)))))
      (if (not (mus-arrays-equal? val #r(1.000 1.500 0.750 0.250 0.000)))
	  (snd-display "cas2can 1: ~A" val)))
    
    (let ((val (cascade->canonical (list #r(1 0.8 0) #r(1 1.4 0.65) #r(1 0 0)))))
      (if (not (mus-arrays-equal? val #r(1.000 2.200 1.770 0.520 0.000 0.000 0.000)))
	  (snd-display "cascade->canonical: ~A" val)))
    (let ((val (cascade->canonical (list #r(1 -0.9 0) #r(1 1 0.74) #r(1 -1.6 0.8)))))
      (if (not (mus-arrays-equal? val #r(1.000 -1.500 0.480 -0.330 0.938 -0.533 0.000)))
	  (snd-display "cascade->canonical 1: ~A" val)))
    
    (let ((ind (new-sound "test.snd" 1 22050 mus-ldouble mus-next)))
      (pad-channel 0 10000)
      (freq-sweep .45)
      (let ((sp (rough-spectrum ind)))
	(if (not (or (mus-arrays-equal? sp #r(0.962 0.998 0.998 0.998 0.998 0.999 0.999 0.998 0.997 1.000))
		     (mus-arrays-equal? sp #r(0.963 0.999 0.999 0.999 0.999 0.999 1.000 1.000 0.998 0.997))))
	    (snd-display "initial rough spectrum: ~A" sp)))
      
      (let ((b (make-butter-high-pass 440.0)))
	(let ((v (make-float-vector 10))
	      (d (make-delay 1)))
	  (delay d (filter b 1.0))
	  (fill-float-vector v (delay d (filter b 0.0)))
	  (if (not (mus-arrays-equal? v #r(0.915 -0.162 -0.146 -0.131 -0.117 -0.103 -0.090 -0.078 -0.066 -0.056)))
	      (snd-display "butter high: ~A" v)))
	(set! b (make-butter-high-pass 1000.0))
	(map-channel (lambda (y) (filter b y)))
	(let ((sp (rough-spectrum ind)))
	  (if (not (or (mus-arrays-equal? sp #r(0.150 0.833 0.980 0.994 0.997 0.998 0.999 0.998 0.997 1.000))
		       (mus-arrays-equal? sp #r(0.150 0.833 0.981 0.995 0.998 0.999 1.000 1.000 0.998 0.997))))
	      (snd-display "hp rough spectrum: ~A" sp)))
	(undo))
      
      (let ((b (make-butter-low-pass 440.0)))
	(let ((v (make-float-vector 10))
	      (d (make-delay 1)))
	  (delay d (filter b 1.0))
	  (fill-float-vector v (delay d (filter b 0.0)))
	  (if (not (mus-arrays-equal? v #r(0.004 0.014 0.026 0.035 0.043 0.049 0.053 0.055 0.057 0.057)))
	      (snd-display "butter low: ~A" v)))
	(set! b (make-butter-low-pass 1000.0))
	(map-channel (lambda (y) (filter b y)))
	(let ((sp (rough-spectrum ind)))
	  (if (not (mus-arrays-equal? sp #r(1.000 0.212 0.024 0.005 0.001 0.000 0.000 0.000 0.000 0.000)))
	      (snd-display "lp rough spectrum: ~A" sp)))
	(undo))
      
      (let ((b (make-butter-band-pass 440.0 50.0)))
	(let ((v (make-float-vector 10))
	      (d (make-delay 1)))
	  (delay d (filter b 1.0))
	  (fill-float-vector v (delay d (filter b 0.0)))
	  (if (not (mus-arrays-equal? v #r(0.007 0.014 0.013 0.013 0.012 0.011 0.009 0.008 0.007 0.005)))
	      (snd-display "butter bandpass: ~A" v)))
	(set! b (make-butter-band-pass 1000.0 500.0))
	(map-channel (lambda (y) (filter b y)))
	(let ((sp (rough-spectrum ind)))
	  (if (not (mus-arrays-equal? sp #r(0.888 1.000 0.144 0.056 0.027 0.014 0.008 0.004 0.002 0.000)))
	      (snd-display "bp rough spectrum: ~A" sp)))
	(undo))
      
      (let ((b (make-butter-band-reject 440.0 50.0)))
	(let ((v (make-float-vector 10))
	      (d (make-delay 1)))
	  (delay d (filter b 1.0))
	  (fill-float-vector v (delay d (filter b 0.0)))
	  (if (not (mus-arrays-equal? v #r(0.993 -0.014 -0.013 -0.013 -0.012 -0.011 -0.009 -0.008 -0.007 -0.005)))
	      (snd-display "butter bandstop: ~A" v)))
	(set! b (make-butter-band-reject 1000.0 500.0))
	(map-channel (lambda (y) (filter b y)))
	(let ((sp (rough-spectrum ind)))
	  (if (not (or (mus-arrays-equal? sp #r(0.662 0.687 0.953 0.980 0.989 0.994 0.997 0.997 0.997 1.000))
		       (mus-arrays-equal? sp #r(0.664 0.689 0.955 0.982 0.992 0.996 0.999 1.000 0.999 0.998))))
	      (snd-display "bs rough spectrum: ~A" sp)))
	(undo))
      
      (if (defined? 'gsl-roots) (analog-filter-tests))
      (test-lpc)
      (test-unclip-channel)
      
      (let ((v (spectrum->coeffs 10 #r(0 1.0 0 0 0 0 0 0 1.0 0)))
	    (v1 (make-fir-coeffs 10 #r(0 1.0 0 0 0 0 0 0 1.0 0))))
	(if (not (mus-arrays-equal? v #r(-0.190 -0.118 0.000 0.118 0.190 0.190 0.118 0.000 -0.118 -0.190)))
	    (snd-display "spectrum->coeffs: ~A" v))
	(if (not (mus-arrays-equal? v v1))
	    (snd-display "spectrum->coeffs v make-fir-coeffs: ~A ~A" v v1)))
      
      (let ((notched-spectr (make-float-vector 20)))
	(set! (notched-spectr 2) 1.0) 
	(let ((v (spectrum->coeffs 20 notched-spectr))
	      (v1 (make-fir-coeffs 20 notched-spectr)))
	  (if (not (mus-arrays-equal? v #r(0.095 0.059 -0.000 -0.059 -0.095 -0.095 -0.059 0.000 0.059 0.095 
				  0.095 0.059 0.000 -0.059 -0.095 -0.095 -0.059 -0.000 0.059 0.095)))
	      (snd-display "spectrum->coeffs (notch): ~A" v))
	  (if (not (mus-arrays-equal? v v1))
	      (snd-display "spectrum->coeffs v(2) make-fir-coeffs: ~A ~A" v v1))
	  (let ((flt (make-fir-filter 20 v)))
	    (map-channel (lambda (y) (fir-filter flt y))))))
      (let ((sp (rough-spectrum ind)))
	(if (not (mus-arrays-equal? sp #r(0.007 0.493 1.000 0.068 0.030 0.019 0.014 0.011 0.009 0.009)))
	    (snd-display "sp->coeff rough spectrum: ~A" sp)))
      (undo)
      
      (let ((rspect (make-float-vector 20)))
	(do ((i 0 (+ i 1)))
	    ((= i 20))
	  (set! (rspect i) (random 1.0)))
	(let ((v (spectrum->coeffs 20 rspect))
	      (v1 (make-fir-coeffs 20 rspect)))
	  (if (not (mus-arrays-equal? v v1))
	      (snd-display "spectrum->coeffs v(3) make-fir-coeffs: ~A ~A" v v1))))
      
      (let ((b (make-highpass (hz->radians 1000.0) 10)))
	(let ((v (make-float-vector 20)))
	  (let ((d (make-delay 1)))
	    (delay d (fir-filter b 1.0))
	    (fill-float-vector v (delay d (fir-filter b 0.0))))
	  (if (not (mus-arrays-equal? v #r(-0.001 -0.002 -0.005 -0.011 -0.021 -0.034 -0.049 -0.065 -0.078 -0.087 
					   0.909 -0.087 -0.078 -0.065 -0.049 -0.034 -0.021 -0.011 -0.005 -0.002)))
	      (snd-display "dsp.scm high: ~A" v)))
	(set! b (make-highpass (hz->radians 1000.0) 20))
	(map-channel (lambda (y) (fir-filter b y)))
	(let ((sp (rough-spectrum ind)))
	  (if (not (or (mus-arrays-equal? sp #r(0.053 0.774 0.998 0.997 0.997 0.996 0.996 0.996 0.997 1.000))
		       (mus-arrays-equal? sp #r(0.053 0.776 1.000 0.998 0.998 0.998 0.998 0.998 0.998 1.000))))
	      (snd-display "dsp hp rough spectrum: ~A" sp)))
	(undo))
      
      (let ((b (make-lowpass (hz->radians 1000.0) 10)))
	(let ((v (make-float-vector 20)))
	  (let ((d (make-delay 1)))
	    (delay d (fir-filter b 1.0))
	    (fill-float-vector v (delay d (fir-filter b 0.0))))
	  (if (not (mus-arrays-equal? v #r(0.001 0.002 0.005 0.011 0.021 0.034 0.049 0.065 0.078 0.087 0.091 0.087 0.078 0.065
					   0.049 0.034 0.021 0.011 0.005 0.002)))
	      (snd-display "dsp.scm low: ~A" v)))
	(set! b (make-lowpass (hz->radians 1000.0) 20))
	(map-channel (lambda (y) (fir-filter b y)))
	(let ((sp (rough-spectrum ind)))
	  (if (not (mus-arrays-equal? sp #r(1.000 0.054 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	      (snd-display "dsp lp rough spectrum: ~A" sp)))
	(undo))
      
      (let ((b (make-bandpass (hz->radians 1500.0) (hz->radians 2000.0) 10)))
	(let ((v (make-float-vector 20)))
	  (let ((d (make-delay 1)))
	    (delay d (fir-filter b 1.0))
	    (fill-float-vector v (delay d (fir-filter b 0.0))))
	  (if (not (mus-arrays-equal? v #r(0.001 -0.001 -0.005 -0.011 -0.017 -0.019 -0.013 0.003 0.022 0.039 0.045
					   0.039 0.022 0.003 -0.013 -0.019 -0.017 -0.011 -0.005 -0.001)))
	      (snd-display "dsp.scm bp: ~A" v)))
	(set! b (make-bandpass (hz->radians 1500.0) (hz->radians 2000.0) 20))
	(map-channel (lambda (y) (fir-filter b y)))
	(let ((sp (rough-spectrum ind)))
	  (if (not (mus-arrays-equal? sp #r(0.010 1.000 0.154 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	      (snd-display "dsp bp rough spectrum: ~A" sp)))
	(undo))
      
      (let ((b (make-bandstop (hz->radians 1500.0) (hz->radians 2000.0) 10)))
	(let ((v (make-float-vector 20)))
	  (let ((d (make-delay 1)))
	    (delay d (fir-filter b 1.0))
	    (fill-float-vector v (delay d (fir-filter b 0.0))))
	  (if (not (mus-arrays-equal? v #r(-0.001 0.001 0.005 0.011 0.017 0.019 0.013 -0.003 -0.022 -0.039 0.955
					   -0.039 -0.022 -0.003 0.013 0.019 0.017 0.011 0.005 0.001)))
	      (snd-display "dsp.scm bs: ~A" v)))
	(set! b (make-bandstop (hz->radians 1500.0) (hz->radians 2000.0) 20))
	(map-channel (lambda (y) (fir-filter b y)))
	(let ((sp (rough-spectrum ind)))
	  (if (not (or (mus-arrays-equal? sp #r(0.904 0.425 0.821 0.998 0.997 0.996 0.996 0.996 0.997 1.000))
		       (mus-arrays-equal? sp #r(0.906 0.425 0.822 1.000 0.999 0.998 0.998 0.998 0.998 1.000))))
	      (snd-display "dsp bs rough spectrum: ~A" sp)))
	(undo))
      
      (let ((b (make-differentiator 10)))
	(let ((v (make-float-vector 20)))
	  (let ((d (make-delay 1)))
	    (delay d (fir-filter b 1.0))
	    (fill-float-vector v (delay d (fir-filter b 0.0))))
	  (if (not (mus-arrays-equal? v #r(-0.008 0.011 -0.021 0.039 -0.066 0.108 -0.171 0.270 -0.456 0.977
					   0.000 -0.977 0.456 -0.270 0.171 -0.108 0.066 -0.039 0.021 -0.011)))
	      (snd-display "dsp.scm df: ~A" v)))
	(set! b (make-differentiator 20))
	(map-channel (lambda (y) (fir-filter b y)))
	(let ((sp (rough-spectrum ind)))
	  (if (not (mus-arrays-equal? sp #r(0.004 0.027 0.075 0.147 0.242 0.362 0.506 0.674 0.864 1.000)))
	      (snd-display "dsp df rough spectrum: ~A" sp)))
	(undo))
      
      (let ((b (make-iir-high-pass-2 440.0)))
	(let ((v (make-float-vector 10)))
	  (let ((d (make-delay 1)))
	    (delay d (filter b 1.0))
	    (fill-float-vector v (delay d (filter b 0.0))))
	  (if (not (mus-arrays-equal? v #r(0.915 -0.162 -0.146 -0.131 -0.117 -0.103 -0.090 -0.078 -0.066 -0.056)))
	      (snd-display "iir-2 high: ~A" v)))
	(set! b (make-iir-high-pass-2 1000.0))
	(map-channel (lambda (y) (filter b y)))
	(let ((sp (rough-spectrum ind)))
	  (if (not (or (mus-arrays-equal? sp #r(0.150 0.833 0.980 0.994 0.997 0.998 0.999 0.998 0.997 1.000))
		       (mus-arrays-equal? sp #r(0.150 0.833 0.981 0.995 0.998 0.999 1.000 1.000 0.998 0.997))))
	      (snd-display "iir-2 hp rough spectrum: ~A" sp)))
	(undo))
      
      (let ((b (make-iir-low-pass-2 440.0)))
	(let ((v (make-float-vector 10)))
	  (let ((d (make-delay 1)))
	    (delay d (filter b 1.0))
	    (fill-float-vector v (delay d (filter b 0.0))))
	  (if (not (mus-arrays-equal? v #r(0.004 0.014 0.026 0.035 0.043 0.049 0.053 0.055 0.057 0.057)))
	      (snd-display "iir-2 low: ~A" v)))
	(set! b (make-iir-low-pass-2 1000.0))
	(map-channel (lambda (y) (filter b y)))
	(let ((sp (rough-spectrum ind)))
	  (if (not (mus-arrays-equal? sp #r(1.000 0.212 0.024 0.005 0.001 0.000 0.000 0.000 0.000 0.000)))
	      (snd-display "iir-2 lp rough spectrum: ~A" sp)))
	(undo))
      
      (let ((b (make-iir-band-pass-2 440.0 490.0)))
	(let ((v (make-float-vector 10)))
	  (let ((d (make-delay 1)))
	    (delay d (filter b 1.0))
	    (fill-float-vector v (delay d (filter b 0.0))))
	  (if (not (mus-arrays-equal? v #r(0.007 0.014 0.013 0.013 0.012 0.010 0.009 0.008 0.006 0.004)))
	      (snd-display "iir bp-2 bandpass: ~A" v)))
	(set! b (make-iir-band-pass-2 1000.0 1500.0))
	(map-channel (lambda (y) (filter b y)))
	(let ((sp (rough-spectrum ind)))
	  (if (not (mus-arrays-equal? sp #r(0.239 1.000 0.117 0.041 0.019 0.010 0.005 0.003 0.001 0.000)))
	      (snd-display "iir bp-2 rough spectrum: ~A" sp)))
	(undo))
      
      (let ((b (make-iir-band-stop-2 440.0 500.0)))
	(let ((v (make-float-vector 10)))
	  (let ((d (make-delay 1)))
	    (delay d (filter b 1.0))
	    (fill-float-vector v (delay d (filter b 0.0))))
	  (if (not (mus-arrays-equal? v #r(0.992 -0.017 -0.016 -0.015 -0.014 -0.012 -0.011 -0.009 -0.007 -0.005)))
	      (snd-display "iir-2 bandstop: ~A" v)))
	(set! b (make-iir-band-stop-2 1000.0 1500.0))
	(map-channel (lambda (y) (filter b y)))
	(let ((sp (rough-spectrum ind)))
	  (if (not (or (mus-arrays-equal? sp #r(0.836 0.525 0.943 0.979 0.989 0.994 0.997 0.997 0.997 1.000))
		       (mus-arrays-equal? sp #r(0.838 0.527 0.945 0.981 0.991 0.996 0.999 1.000 0.999 0.998))))
	      (snd-display "iir bs-2 rough spectrum: ~A" sp)))
	(undo))
      
      (let ((b (make-butter-hp 4 440.0)))
	(let ((v (make-float-vector 10)))
	  (let ((d (make-delay 1)))
	    (delay d (filter b 1.0))
	    (fill-float-vector v (delay d (filter b 0.0))))
	  (if (not (or (mus-arrays-equal? v #r(0.725 -0.466 -0.315 -0.196 -0.104 -0.036 0.014 0.047 0.0685 0.0775))
		       (mus-arrays-equal? v #r(0.725 -0.466 -0.315 -0.196 -0.104 -0.035 0.015 0.049 0.070 0.081))
		       (mus-arrays-equal? v #r(0.725 -0.466 -0.315 -0.196 -0.104 -0.035 0.014 0.049 0.069 0.079))))
	      (snd-display "butter hp: ~A" v)))
	(set! b (make-butter-hp 4 1000.0))
	(map-channel (lambda (y) (filter b y)))
	(let ((sp (rough-spectrum ind)))
	  (if (not (or (mus-arrays-equal? sp #r(0.0505 0.982 1.000 1.000 0.998 0.998 0.999 0.998 0.996 0.999))
		       (mus-arrays-equal? sp #r(0.051 0.982 1.000 1.000 0.998 0.998 0.998 0.999 0.997 0.995))
		       (mus-arrays-equal? sp #r(0.051 0.991 1.000 1.000 0.998 0.998 0.999 0.999 0.997 0.995))
		       (mus-arrays-equal? sp #r(0.045 0.970 1.000 1.000 0.998 0.998 0.999 0.999 0.997 0.995))
		       (mus-arrays-equal? sp #r(0.052 0.971 1.000 1.000 0.998 0.998 0.999 0.999 0.997 0.995))))
	      (snd-display "bhp rough spectrum: ~A" sp)))
	(undo))
      
      (let ((b (make-butter-lp 4 440.0)))
	(let ((v (make-float-vector 10)))
	  (let ((d (make-delay 1)))
	    (delay d (filter b 1.0))
	    (fill-float-vector v (delay d (filter b 0.0))))
	  (if (not (mus-arrays-equal? v (make-float-vector 10)))
	      (snd-display "butter lp: ~A" v)))
	(set! b (make-butter-lp 4 1000.0))
	(map-channel (lambda (y) (filter b y)))
	(let ((sp (rough-spectrum ind)))
	  (if (not (or (mus-arrays-equal? sp #r(1.000 0.035 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000))
		       (mus-arrays-equal? sp #r(1.000 0.038 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000))))
	      (snd-display "blp rough spectrum: ~A" sp)))
	(undo))
      
      (let ((b (make-butter-bp 4 440.0 500.0)))
	(let ((v (make-float-vector 10)))
	  (let ((d (make-delay 1)))
	    (delay d (filter b 1.0))
	    (fill-float-vector v (delay d (filter b 0.0))))
	  (if (not (mus-arrays-equal? v (make-float-vector 10)))
	      (snd-display "butter bp: ~A" v)))
	(set! b (make-butter-bp 4 1000.0 1500.0))
	(map-channel (lambda (y) (filter b y)))
	(undo))
      
      (let ((b (make-butter-bs 4 440.0 500.0)))
	(let ((v (make-float-vector 10)))
	  (let ((d (make-delay 1)))
	    (delay d (filter b 1.0))
	    (fill-float-vector v (delay d (filter b 0.0))))
	  (if (not (or (mus-arrays-equal? v #r(0.978 -0.043 -0.041 -0.038 -0.035 -0.031 -0.026 -0.0225 -0.015 -0.0085))
		       (mus-arrays-equal? v #r(0.978 -0.043 -0.041 -0.038 -0.035 -0.031 -0.027 -0.022 -0.017 -0.011))
		       (mus-arrays-equal? v #r(0.978 -0.043 -0.041 -0.038 -0.035 -0.031 -0.027 -0.021 -0.014 -0.011))))
	      (snd-display "butter bs: ~A" v)))
	(set! b (make-butter-bs 4 1000.0 1500.0))
	(map-channel (lambda (y) (filter b y)))
	(undo))
      
      (revert-sound)

    (let ((size 256))
      (let ((x0 (make-float-vector size))	   
	    (x1 (make-float-vector size))	   
	    (x2 (make-float-vector size))
	    (dur 10000))
	(do ((i 0 (+ i 1)))
	    ((= i 12))
	  (let ((val (sin (/ (* 2 pi i) 12.0))))
	    (set! (x1 (- (+ i (/ size 4)) 6)) val)))
	(let ((data (make-float-vector dur))
	      (amp 0.1000))
	  (let ((recompute-samps 30) ;just a quick guess
		(gen1 (make-table-lookup 440.0 :wave x1))
		(gen2 (make-table-lookup 440.0 :wave x2)))
	    (do ((i 0 (+ i 1))
		 (k 0.0)
		 (mass 1.0000)
		 (xspring 0.1000)
		 (damp 0.0000)
		 (kincr (/ 1.0 recompute-samps)))
		((= i dur))
	      (if (>= k 1.0)
		  (begin
		    (set! k 0.0)
		    (vibrating-uniform-circular-string size x0 x1 x2 mass xspring damp))
		  (set! k (+ k kincr)))
	      (let ((g1 (table-lookup gen1))
		    (g2 (table-lookup gen2)))
		(set! (data i) (+ g2 (* k (- g1 g2)))))))
	  (float-vector-scale! data (/ amp (float-vector-peak data)))
	  (float-vector->channel data 0 dur))))
      
      (close-sound ind))
    
    (let ((gen (make-sawtooth-wave 440.0)))
      (print-and-check gen 
		       "sawtooth-wave"
		       "sawtooth-wave freq: 440.000Hz, phase: 3.142, amp: 1.000")
      (let ((v0 (make-float-vector 10)))
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (set! (v0 i) (sawtooth-wave gen 0.0)))
	(let ((gen1 (make-sawtooth-wave 440.0))
	      (v1 (make-float-vector 10)))
	  (fill-float-vector v1 (if (sawtooth-wave? gen1) (sawtooth-wave gen1 0.0) -1.0))
	  (if (not (mus-arrays-equal? v0 v1)) (snd-display "map sawtooth: ~A ~A" v0 v1)))
	(if (not (sawtooth-wave? gen)) (snd-display "~A not sawtooth-wave?" gen))
	(if (fneq (mus-phase gen) 4.39538) (snd-display "sawtooth-wave phase: ~F?" (mus-phase gen))) ;starts at pi
	(if (fneq (mus-frequency gen) 440.0) (snd-display "sawtooth-wave frequency: ~F?" (mus-frequency gen)))
	(set! (mus-frequency gen) 100.0)
	(if (fneq (mus-frequency gen) 100.0) (snd-display "set! sawtooth-wave frequency: ~F?" (mus-frequency gen)))
	(if (fneq (mus-scaler gen) 1.0) (snd-display "sawtooth-wave scaler: ~F?" (mus-scaler gen)))
	(set! (mus-scaler gen) 0.5)
	(if (fneq (mus-scaler gen) 0.5) (snd-display "set! sawtooth-wave scaler: ~F?" (mus-scaler gen)))
	(if (or (fneq (v0 1) 0.04) (fneq (v0 8) .319)) (snd-display "sawtooth-wave output: ~A" v0))))
    
    (test-gen-equal (make-sawtooth-wave 440.0) (make-sawtooth-wave 440.0) (make-sawtooth-wave 120.0))
    (test-gen-equal (make-sawtooth-wave 440.0) (make-sawtooth-wave 440.0) (make-sawtooth-wave 440.0 1.0 1.0))
    (test-gen-equal (make-sawtooth-wave 440.0) (make-sawtooth-wave 440.0) (make-sawtooth-wave 440.0 0.5))
    
    (do ((gen1 (make-sawtooth-wave 100.0))
	 (gen2 (make-sawtooth-wave -100.0))
	 (mx 0.0)
	 (i 0 (+ i 1)))
	((= i 100)
	 (if (fneq mx 0.0)
	     (snd-display "sawtooth +-: ~A" mx)))
      (set! mx (max mx (abs (+ (gen1) (gen2))))))
    
    (let ((gen (make-square-wave 440.0)))
      (print-and-check gen 
		       "square-wave"
		       "square-wave freq: 440.000Hz, phase: 0.000, amp: 1.000")
      (let ((v0 (make-float-vector 10)))
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (set! (v0 i) (square-wave gen 0.0)))
	(let ((w 1.0)
	      (gen1 (make-square-wave 440.0))
	      (v1 (make-float-vector 10)))
	  (fill-float-vector v1 (begin
				  (set! w (mus-width gen1))
				  (if (square-wave? gen1) (square-wave gen1 0.0) -1.0)))
	  (if (fneq w 0.5) (snd-display "mus-width opt: ~A" w))
	  (if (not (mus-arrays-equal? v0 v1)) (snd-display "map square-wave: ~A ~A" v0 v1)))
	(if (not (square-wave? gen)) (snd-display "~A not square-wave?" gen))
	(if (fneq (mus-phase gen) 1.253787) (snd-display "square-wave phase: ~F?" (mus-phase gen)))
	(if (fneq (mus-frequency gen) 440.0) (snd-display "square-wave frequency: ~F?" (mus-frequency gen)))
	(if (fneq (mus-scaler gen) 1.0) (snd-display "square-wave scaler: ~F?" (mus-scaler gen)))
	(set! (mus-scaler gen) 0.5)
	(if (fneq (mus-scaler gen) 0.5) (snd-display "set! square-wave scaler: ~F?" (mus-scaler gen)))
	(if (fneq (mus-width gen) 0.5) (snd-display "square-wave width: ~A" (mus-width gen)))
	(set! (mus-width gen) 0.75)
	(if (fneq (mus-width gen) 0.75) (snd-display "set! square-wave width: ~A" (mus-width gen)))
	(if (or (fneq (v0 1) 1.0) (fneq (v0 8) 1.0)) (snd-display "square-wave output: ~A" v0))))
    
    (test-gen-equal (make-square-wave 440.0) (make-square-wave 440.0) (make-square-wave 120.0))
    (test-gen-equal (make-square-wave 440.0) (make-square-wave 440.0) (make-square-wave 440.0 1.0 1.0))
    (test-gen-equal (make-square-wave 440.0) (make-square-wave 440.0) (make-square-wave 440.0 0.5))
    
    (let-temporarily ((*clm-srate* 500.0))
      (do ((gen (make-square-wave 100.0 -0.5 (* pi 0.5)))
	   (v0 (make-float-vector 20))
	   (i 0 (+ i 1)))
	  ((= i 20)
	   (if (not (mus-arrays-equal? v0 #r(-0.5 -0.5 0.0 0.0 -0.5 -0.5 -0.5 0.0 0.0 -0.5 -0.5 -0.5 0.0 0.0 -0.5 -0.5 -0.5 0.0 0.0 -0.5)))
	       (snd-display "square-wave -.5: ~A " v0)))
	(set! (v0 i) (gen))))
    (when (or (<= *clm-srate* 501.0) (<= (mus-srate) 501.0))
      (format *stderr* "make-square-wave *clm-srate*: ~S, mus-srate: ~S~%" *clm-srate* (mus-srate))
      (set! *clm-srate* 44100.0))
    
    (let ((gen (make-triangle-wave 440.0))
	  (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "triangle-wave"
		       "triangle-wave freq: 440.000Hz, phase: 0.000, amp: 1.000")
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (triangle-wave gen 0.0)))
      (let ((gen2 (make-triangle-wave 440.0))
	    (v1 (make-float-vector 10)))
	(fill-float-vector v1 (if (triangle-wave? gen2) (triangle-wave gen2 0.0) -1.0))
	(if (not (mus-arrays-equal? v0 v1)) (snd-display "map triangle-wave: ~A ~A" v0 v1)))
      (if (not (triangle-wave? gen)) (snd-display "~A not triangle-wave?" gen))
      (if (fneq (mus-phase gen) 1.253787) (snd-display "triangle-wave phase: ~F?" (mus-phase gen)))
      (let ((gen1 (mus-phase (make-triangle-wave 440.0 1.0 pi))))
	(if (fneq gen1 pi) (snd-display "init triangle-wave phase: ~F?" gen1)))
      (if (fneq (mus-frequency gen) 440.0) (snd-display "triangle-wave frequency: ~F?" (mus-frequency gen)))
      (if (fneq (mus-scaler gen) 1.0) (snd-display "triangle-wave scaler: ~F?" (mus-scaler gen)))
      (set! (mus-scaler gen) 0.5)
      (if (fneq (mus-scaler gen) 0.5) (snd-display "set! triangle-wave scaler: ~F?" (mus-scaler gen)))
      (if (or (fneq (v0 1) 0.080) (fneq (v0 8) 0.639)) (snd-display "triangle-wave output: ~A" v0)))
    
    (do ((gen1 (make-triangle-wave 100.0))
	 (gen2 (make-triangle-wave -100.0))
	 (mx 0.0)
	 (i 0 (+ i 1)))
	((= i 100)
	 (if (fneq mx 0.0)
	     (snd-display "triangle +-: ~A" mx)))
      (set! mx (max mx (abs (+ (gen1) (gen2))))))
    
    (test-gen-equal (make-triangle-wave 440.0) (make-triangle-wave 440.0) (make-triangle-wave 120.0))
    (test-gen-equal (make-triangle-wave 440.0) (make-triangle-wave 440.0) (make-triangle-wave 440.0 1.0 1.0))
    (test-gen-equal (make-triangle-wave 440.0) (make-triangle-wave 440.0) (make-triangle-wave 440.0 0.5))
    
    (let ((gen (make-pulse-train 440.0))
	  (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "pulse-train"
		       "pulse-train freq: 440.000Hz, phase: 0.000, amp: 1.000")
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (pulse-train gen 0.0)))
      (let ((gen1 (make-pulse-train 440.0))
	    (v1 (make-float-vector 10)))
	(fill-float-vector v1 (if (pulse-train? gen1) (pulse-train gen1 0.0) -1.0))
	(if (not (mus-arrays-equal? v0 v1)) (snd-display "map pulse-train: ~A ~A" v0 v1)))
      (if (not (pulse-train? gen)) (snd-display "~A not pulse-train?" gen))
      (if (fneq (mus-phase gen) 1.253787) (snd-display "pulse-train phase: ~F?" (mus-phase gen)))
      (if (fneq (mus-frequency gen) 440.0) (snd-display "pulse-train frequency: ~F?" (mus-frequency gen)))
      (if (fneq (mus-scaler gen) 1.0) (snd-display "pulse-train scaler: ~F?" (mus-scaler gen)))
      (set! (mus-scaler gen) 0.5)
      (if (fneq (mus-scaler gen) 0.5) (snd-display "set! pulse-train scaler: ~F?" (mus-scaler gen)))
      (if (or (fneq (v0 0) 1.0) (fneq (v0 8) 0.0)) (snd-display "pulse-train output: ~A" v0)))
    
    (test-gen-equal (make-pulse-train 440.0) (make-pulse-train 440.0) (make-pulse-train 120.0))
    (test-gen-equal (make-pulse-train 440.0) (make-pulse-train 440.0) (make-pulse-train 440.0 1.0 1.0))
    (test-gen-equal (make-pulse-train 440.0) (make-pulse-train 440.0) (make-pulse-train 440.0 0.5))
    
    (let-temporarily ((*clm-srate* 500.0))
      (do ((gen (make-pulse-train 100.0 -0.5 (* pi 0.5)))
	   (v0 (make-float-vector 20))
	   (i 0 (+ i 1)))
	  ((= i 20)
	   (if (not (mus-arrays-equal? v0 #r(0.0 0.0 0.0 0.0 -0.5 0.0 0.0 0.0 0.0 -0.5 0.0 0.0 0.0 0.0 -0.5 0.0 0.0 0.0 0.0 -0.5)))
	       (snd-display "pulse-train -.5: ~A " v0)))
	(set! (v0 i) (gen))))
    (when (or (<= *clm-srate* 501.0) (<= (mus-srate) 501.0))
      (format *stderr* "make-pulse-train *clm-srate*: ~S, mus-srate: ~S~%" *clm-srate* (mus-srate))
      (set! *clm-srate* 44100.0))
    
    (let ((gen (make-two-pole 1200.0 .1)))
      (if (not (two-pole? gen)) (snd-display "~A not 2-polar?" gen))
      (if (not (= (mus-order gen) 2)) (snd-display "2-polar order: ~D?" (mus-order gen)))
      (if (fneq (mus-xcoeff gen 0) 1.0) (snd-display "2-polar a0: ~F?" (mus-xcoeff gen 0)))
      (if (fneq (mus-ycoeff gen 1) -.188) (snd-display "2-polar b1: ~F?" (mus-ycoeff gen 1)))
      (if (fneq (mus-ycoeff gen 2) .01) (snd-display "2-polar b2: ~F?" (mus-ycoeff gen 2)))
      (if (fneq (mus-frequency gen) 1200.0) (snd-display "freq 2-polar: ~A" (mus-frequency gen)))
      (if (fneq (mus-scaler gen) 0.1) (snd-display "scaler 2-polar: ~A" (mus-scaler gen))))
    
    (let ((gen (make-two-pole :frequency 1200.0 :radius .1)))
      (if (not (two-pole? gen)) (snd-display "~A not f2-polar?" gen))
      (if (not (= (mus-order gen) 2)) (snd-display "f2-polar order: ~D?" (mus-order gen)))
      (if (fneq (mus-xcoeff gen 0) 1.0) (snd-display "f2-polar a0: ~F?" (mus-xcoeff gen 0)))
      (if (fneq (mus-ycoeff gen 1) -.188) (snd-display "f2-polar b1: ~F?" (mus-ycoeff gen 1)))
      (if (fneq (mus-ycoeff gen 2) .01) (snd-display "f2-polar b2: ~F?" (mus-ycoeff gen 2)))
      (if (fneq (mus-frequency gen) 1200.0) (snd-display "freq f2-polar: ~A" (mus-frequency gen)))
      (if (fneq (mus-scaler gen) 0.1) (snd-display "scaler f2-polar: ~A" (mus-scaler gen))))
    
    (let ((gen (make-two-zero :radius .1 :frequency 1200.0)))
      (if (not (two-zero? gen)) (snd-display "~A not 2-zp?" gen))
      (if (not (= (mus-order gen) 2)) (snd-display "2-zp order: ~D?" (mus-order gen)))
      (if (fneq (mus-xcoeff gen 0) 1.0) (snd-display "2-zp a0: ~F?" (mus-xcoeff gen 0)))
      (if (fneq (mus-xcoeff gen 1) -.188) (snd-display "2-zp a1: ~F?" (mus-xcoeff gen 1)))
      (if (fneq (mus-xcoeff gen 2) .01) (snd-display "2-zp a2: ~F?" (mus-xcoeff gen 2)))
      (if (fneq (mus-frequency gen) 1200.0) (snd-display "freq 2-zp: ~A" (mus-frequency gen)))
      (if (fneq (mus-scaler gen) 0.1) (snd-display "scaler 2-zp: ~A" (mus-scaler gen))))
    
    (let ((gen (make-two-zero 1200.0 .1)))
      (if (not (two-zero? gen)) (snd-display "~A not f2-zp?" gen))
      (if (not (= (mus-order gen) 2)) (snd-display "f2-zp order: ~D?" (mus-order gen)))
      (if (fneq (mus-xcoeff gen 0) 1.0) (snd-display "f2-zp a0: ~F?" (mus-xcoeff gen 0)))
      (if (fneq (mus-xcoeff gen 1) -.188) (snd-display "f2-zp a1: ~F?" (mus-xcoeff gen 1)))
      (if (fneq (mus-xcoeff gen 2) .01) (snd-display "f2-zp a2: ~F?" (mus-xcoeff gen 2)))
      (if (fneq (mus-frequency gen) 1200.0) (snd-display "freq f2-zp: ~A" (mus-frequency gen)))
      (if (fneq (mus-scaler gen) 0.1) (snd-display "scaler f2-zp: ~A" (mus-scaler gen))))
    
    (let ((gen (make-formant 1200.0 0.9))
	  (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "formant"
		       "formant frequency: 1200.000, radius: 0.900")
      (set! (v0 0) (formant gen 1.0))
      (do ((i 1 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (formant gen 0.0)))
      (let ((gen1 (make-formant 1200.0 0.9))
	    (v1 (make-float-vector 10))
	    (inp 1.0))
	(fill-float-vector v1 (let ((val (if (formant? gen1) (formant gen1 inp) -1.0)))
				(set! inp 0.0)
				val))
	(if (not (mus-arrays-equal? v0 v1)) (snd-display "map formant: ~A ~A" v0 v1)))
      (if (not (formant? gen)) (snd-display "~A not formant?" gen))
      (if (not (= (mus-order gen) 2)) (snd-display "formant order: ~D?" (mus-order gen)))
      (if (fneq (mus-frequency gen) 1200.0) (snd-display "formant frequency: ~F?" (mus-frequency gen)))
      (if (or (fneq (v0 0) .095) (fneq (v0 1) .161)) (snd-display "formant output: ~A" v0))
      (if (fneq (mus-scaler gen) 0.9) (snd-display "formant gain: ~F?" (mus-scaler gen)))
      
      (set! (mus-scaler gen) 2.0)
      (if (fneq (mus-scaler gen) 2.0) (snd-display "formant set gain: ~F?" (mus-scaler gen))))
    
    (test-gen-equal (let ((f1 (make-formant 1200.0 0.9))) (formant f1 1.0) f1)
		    (let ((f2 (make-formant 1200.0 0.9))) (formant f2 1.0) f2)
		    (let ((f3 (make-formant 600.0 0.9))) (formant f3 1.0) f3))
    (test-gen-equal (let ((f1 (make-formant 1200.0 0.9))) (formant f1 1.0) f1)
		    (let ((f2 (make-formant 1200.0 0.9))) (formant f2 1.0) f2)
		    (let ((f3 (make-formant 1200.0 0.99))) (formant f3 1.0) f3))
    (test-gen-equal (let ((f1 (make-formant 1200.0 0.9))) (formant f1 1.0) f1)
		    (let ((f2 (make-formant 1200.0 0.9))) (formant f2 1.0) f2)
		    (let ((f3 (make-formant 1200.0 0.5))) (formant f3 1.0) f3))
    
    (let ((fs (make-vector 2))
	  (f0 (make-formant 1000.0 .1))
	  (f1 (make-formant 100.0 .2))
	  (amps (make-float-vector 2 1.0))
	  (v0 (make-float-vector 10))
	  (v1 (make-float-vector 10)))
      (set! (fs 0) (make-formant 1000.0 .1))
      (set! (fs 1) (make-formant 100.0 .2))
      (set! fs (make-formant-bank fs amps))
      (set! (amps 0) 0.5)
      (set! (amps 1) 0.25)
      (do ((val 1.0 0.0)
	   (i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (+ (* 0.5 (formant f0 val)) (* 0.25 (formant f1 val))))
	(set! (v1 i) (formant-bank fs val)))
      (if (not (mus-arrays-equal? v0 v1)) (snd-display "formant bank 1: ~A ~A" v0 v1)))
    
    (let ((fs (make-vector 2))
	  (amps (make-float-vector 2 1.0))
	  (v (make-float-vector 5)))
      (set! (fs 0) (make-formant 1000.0 .1))
      (set! (fs 1) (make-formant 100.0 .2))
      (set! fs (make-formant-bank fs amps))
      (set! (amps 0) 0.5)
      (set! (amps 1) 0.25)
      (let ((val 1.0))
	(fill-float-vector v (let ((res (formant-bank fs val))) (set! val 0.0) res))
	(if (not (mus-arrays-equal? v #r(0.368 0.095 -0.346 -0.091 -0.020))) (snd-display "run formant-bank: ~A" v))))
    
    (let ((ob (open-sound "oboe.snd")))
      ;; test courtesy of Anders Vinjar
      (map-channel (let ((frek 300)
			 (amp 0.1000)
			 (R 0.0000)
			 (gain 30.0000)
			 (frek-env '(0 100 1 4000.0))
			 (R-env '(0 0.99 1 0.9)))
		     (let ((filt (make-formant frek R))
			   (fe (make-env :envelope frek-env :length (framples) :offset frek))
			   (re (make-env :envelope R-env :length (framples) :offset R)))
		       (lambda (y)
			 (let ((outval (* gain (formant filt (* amp y)))))
			   (mus-set-formant-radius-and-frequency filt (env re) (env fe))
			   outval)))))
      (play ob :wait #t)  ;; should sound like "whyieee?"
      (close-sound ob))
    
    (let ((gen (make-firmant 1200.0 0.9))
	  (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "firmant"
		       "firmant frequency: 1200.000, radius: 0.900")
      (set! (v0 0) (firmant gen 1.0))
      (do ((i 1 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (firmant gen 0.0)))
      (let ((inp 1.0)
	    (gen1 (make-firmant 1200.0 0.9))
	    (v1 (make-float-vector 10)))
	(fill-float-vector v1 (let ((val (if (firmant? gen1) (firmant gen1 inp) -1.0)))
				(set! inp 0.0)
				val))
	(if (not (mus-arrays-equal? v0 v1)) (snd-display "map firmant: ~A ~A" v0 v1)))
      (if (not (firmant? gen)) (snd-display "~A not firmant?" gen))
      (if (not (= (mus-order gen) 2)) (snd-display "firmant order: ~D?" (mus-order gen)))
      (if (fneq (mus-frequency gen) 1200.0) (snd-display "firmant frequency: ~F?" (mus-frequency gen)))
      (if (or (fneq (v0 0) .058) (fneq (v0 1) .099)) (snd-display "firmant output: ~A" v0))
      (if (fneq (mus-scaler gen) 0.9) (snd-display "firmant gain: ~F?" (mus-scaler gen)))
      
      (set! (mus-scaler gen) .20)
      (if (fneq (mus-scaler gen) .20) (snd-display "firmant set gain: ~F?" (mus-scaler gen))))
    
    (test-gen-equal (let ((f1 (make-firmant 1200.0 0.9))) (firmant f1 1.0) f1)
		    (let ((f2 (make-firmant 1200.0 0.9))) (firmant f2 1.0) f2)
		    (let ((f3 (make-firmant 600.0 0.9))) (firmant f3 1.0) f3))
    (test-gen-equal (let ((f1 (make-firmant 1200.0 0.9))) (firmant f1 1.0) f1)
		    (let ((f2 (make-firmant 1200.0 0.9))) (firmant f2 1.0) f2)
		    (let ((f3 (make-firmant 1200.0 0.99))) (firmant f3 1.0) f3))
    (test-gen-equal (let ((f1 (make-firmant 1200.0 0.9))) (firmant f1 1.0) f1)
		    (let ((f2 (make-firmant 1200.0 0.9))) (firmant f2 1.0) f2)
		    (let ((f3 (make-firmant 1200.0 0.5))) (firmant f3 1.0) f3))
    
    (let ((gen (make-fft-window hamming-window 16)))
      (if (not (mus-arrays-equal? gen #r(0.080 0.115 0.215 0.364 0.540 0.716 0.865 1.000 1.000 0.865 0.716 0.540 0.364 0.215 0.115 0.080)))
	  (snd-display "hamming window: ~A" gen)))
    (let ((gen (make-fft-window rectangular-window 16)))
      (if (not (mus-arrays-equal? gen (make-float-vector 16 1.0)))
	  (snd-display "rectangular window: ~A" gen)))
    (let ((gen (make-fft-window hann-window 16)))
      (if (not (mus-arrays-equal? gen #r(0.000 0.038 0.146 0.309 0.500 0.691 0.854 1.000 1.000 0.854 0.691 0.500 0.309 0.146 0.038 0.000)))
	  (snd-display "hann window: ~A" gen)))
    (let ((gen (make-fft-window welch-window 16)))
      (if (not (mus-arrays-equal? gen #r(0.000 0.234 0.438 0.609 0.750 0.859 0.938 1.000 1.000 0.938 0.859 0.750 0.609 0.438 0.234 0.000)))
	  (snd-display "welch window: ~A" gen)))
    (let ((gen (make-fft-window connes-window 16)))
      (if (not (mus-arrays-equal? gen #r(0.000 0.055 0.191 0.371 0.562 0.739 0.879 1.000 1.000 0.879 0.739 0.562 0.371 0.191 0.055 0.000)))
	  (snd-display "connes window: ~A" gen)))
    (let ((gen (make-fft-window parzen-window 16)))
      (if (not (mus-arrays-equal? gen #r(0.000 0.125 0.250 0.375 0.500 0.625 0.750 1.000 1.000 0.750 0.625 0.500 0.375 0.250 0.125 0.000)))
	  (snd-display "parzen window: ~A" gen)))
    (let ((gen (make-fft-window bartlett-window 16)))
      (if (not (mus-arrays-equal? gen #r(0.000 0.125 0.250 0.375 0.500 0.625 0.750 1.000 1.000 0.750 0.625 0.500 0.375 0.250 0.125 0.000)))
	  (snd-display "bartlett window: ~A" gen)))
    (let ((gen (make-fft-window blackman2-window 16)))
      (if (not (mus-arrays-equal? gen #r(0.005 0.020 0.071 0.177 0.344 0.558 0.775 1.000 1.000 0.775 0.558 0.344 0.177 0.071 0.020 0.005)))
	  (snd-display "blackman2 window: ~A" gen)))
    (let ((gen (make-fft-window blackman3-window 16)))
      (if (not (mus-arrays-equal? gen #r(0.000 0.003 0.022 0.083 0.217 0.435 0.696 1.000 1.000 0.696 0.435 0.217 0.083 0.022 0.003 0.000)))
	  (snd-display "blackman3 window: ~A" gen)))
    (let ((gen (make-fft-window blackman4-window 16)))
      (if (not (mus-arrays-equal? gen #r(0.002 0.002 0.003 0.017 0.084 0.263 0.562 1.000 1.000 0.562 0.263 0.084 0.017 0.003 0.002 0.002)))
	  (snd-display "blackman4 window: ~A" gen)))
    
    (let ((gen (make-fft-window blackman5-window 16)))
      (if (not (mus-arrays-equal? gen #r(0.000 0.000 0.003 0.022 0.097 0.280 0.574 1.000 1.000 0.574 0.280 0.097 0.022 0.003 0.000 0.000)))
	  (snd-display "blackman5 window: ~A" gen)))
    (let ((gen (make-fft-window blackman6-window 16)))
      (if (not (mus-arrays-equal? gen #r(0.000 0.000 0.001 0.011 0.064 0.223 0.520 1.000 1.000 0.520 0.223 0.064 0.011 0.001 0.000 0.000)))
	  (snd-display "blackman6 window: ~A" gen)))
    (let ((gen (make-fft-window blackman7-window 16)))
      (if (not (mus-arrays-equal? gen #r(0.000 0.000 0.000 0.006 0.042 0.177 0.471 1.000 1.000 0.471 0.177 0.042 0.006 0.000 0.000 0.000)))
	  (snd-display "blackman7 window: ~A" gen)))
    (let ((gen (make-fft-window blackman8-window 16)))
      (if (not (mus-arrays-equal? gen #r(0.000 0.000 0.000 0.003 0.028 0.141 0.426 1.000 1.000 0.426 0.141 0.028 0.003 0.000 0.000 0.000)))
	  (snd-display "blackman8 window: ~A" gen)))
    (let ((gen (make-fft-window blackman9-window 16)))
      (if (not (mus-arrays-equal? gen #r(0.000 0.000 0.000 0.001 0.018 0.112 0.385 1.000 1.000 0.385 0.112 0.018 0.001 0.000 0.000 -0.000)))
	  (snd-display "blackman9 window: ~A" gen)))
    (let ((gen (make-fft-window blackman10-window 16)))
      (if (not (mus-arrays-equal? gen #r(0.000 0.000 0.000 0.001 0.012 0.089 0.349 1.000 1.000 0.349 0.089 0.012 0.001 0.000 0.000 -0.000)))
	  (snd-display "blackman10 window: ~A" gen)))
    (let ((gen (make-fft-window rv2-window 16)))
      (if (not (mus-arrays-equal? gen #r(0.000 0.001 0.021 0.095 0.250 0.478 0.729 1.000 1.000 0.729 0.478 0.250 0.095 0.021 0.001 0.000)))
	  (snd-display "rv2 window: ~A" gen)))
    (let ((gen (make-fft-window rv3-window 16)))
      (if (not (mus-arrays-equal? gen #r(0.000 0.000 0.003 0.029 0.125 0.330 0.622 1.000 1.000 0.622 0.330 0.125 0.029 0.003 0.000 0.000)))
	  (snd-display "rv3 window: ~A" gen)))
    (let ((gen (make-fft-window rv4-window 16)))
      (if (not (mus-arrays-equal? gen #r(0.000 0.000 0.000 0.009 0.062 0.228 0.531 1.000 1.000 0.531 0.228 0.062 0.009 0.000 0.000 0.000)))
	  (snd-display "rv4 window: ~A" gen)))
    
    (let ((gen (make-fft-window exponential-window 16)))
      (if (not (mus-arrays-equal? gen #r(0.000 0.087 0.181 0.283 0.394 0.515 0.646 0.944 0.944 0.646 0.515 0.394 0.283 0.181 0.087 0.000)))
	  (snd-display "exponential window: ~A" gen)))
    (let ((gen (make-fft-window riemann-window 16)))
      (if (not (mus-arrays-equal? gen #r(0.000 0.139 0.300 0.471 0.637 0.784 0.900 1.000 1.000 0.900 0.784 0.637 0.471 0.300 0.139 0.000)))
	  (snd-display "riemann window: ~A" gen)))
    (let ((gen (make-fft-window kaiser-window 16 2.5)))
      (if (not (mus-arrays-equal? gen #r(0.304 0.426 0.550 0.670 0.779 0.871 0.941 1.000 1.000 0.941 0.871 0.779 0.670 0.550 0.426 0.304)))
	  (snd-display "kaiser window: ~A" gen)))
    (let ((gen (make-fft-window cauchy-window 16 2.5)))
      (if (not (mus-arrays-equal? gen #r(0.138 0.173 0.221 0.291 0.390 0.532 0.719 1.000 1.000 0.719 0.532 0.390 0.291 0.221 0.173 0.138)))
	  (snd-display "cauchy window: ~A" gen)))
    (let ((gen (make-fft-window poisson-window 16 2.5)))
      (if (not (mus-arrays-equal? gen #r(0.082 0.112 0.153 0.210 0.287 0.392 0.535 1.000 1.000 0.535 0.392 0.287 0.210 0.153 0.112 0.082)))
	  (snd-display "poisson window: ~A" gen)))
    (let ((gen (make-fft-window gaussian-window 16 1.0)))
      (if (not (mus-arrays-equal? gen #r(0.607 0.682 0.755 0.823 0.882 0.932 0.969 1.000 1.000 0.969 0.932 0.882 0.823 0.755 0.682 0.607)))
	  (snd-display "gaussian window: ~A" gen)))
    (let ((gen (make-fft-window tukey-window 16)))
      (if (not (mus-arrays-equal? gen #r(0.000 0.038 0.146 0.309 0.500 0.691 0.854 1.000 1.000 0.854 0.691 0.500 0.309 0.146 0.038 0.000)))
	  (snd-display "tukey window: ~A" gen)))
    (let ((gen (make-fft-window hann-poisson-window 16)))
      (if (not (mus-arrays-equal? gen #r(0.000 0.038 0.146 0.309 0.500 0.691 0.854 1.000 1.000 0.854 0.691 0.500 0.309 0.146 0.038 0.000)))
	  (snd-display "tukey window: ~A" gen)))
    (let ((gen (make-fft-window bohman-window 16)))
      (if (not (mus-arrays-equal? gen #r(0.000 0.006 0.048 0.151 0.318 0.533 0.755 1.000 1.000 0.755 0.533 0.318 0.151 0.048 0.006 0.000)))
	  (snd-display "bohman window: ~A" gen)))
    
    (for-each
     (lambda (window-data)
       (let ((window (car window-data))
	     (func (caddr window-data))
	     (name (cadr window-data)))
	 (do ((v1 (make-fft-window window 16))
	      (v2 (make-float-vector 16))
	      (incr (/ (* 2 pi) 16.0))
	      (i 0 (+ i 1))
	      (j 15 (- j 1))
	      (ang 0.0))
	     ((> i 8) ; yikes -- even size + smallness = questionable code...
	      (if (not (mus-arrays-equal? v1 v2)) 
		  (snd-display "~A by hand:~%;  mus: ~A~%;  loc: ~A" name v1 v2)))
	   (let ((val (func ang)))
	     (set! (v2 i) val)
	     (set! (v2 j) val))
	   (set! ang (+ ang incr)))))
     (list 
      (list hann-window "hann" (lambda (ang) 
				 (- 0.5 
				    (* 0.5 (cos ang)))))
      
      (list rv2-window "rv2" (lambda (ang) 
			       (+ .375 
				  (* -0.5 (cos ang)) 
				  (* .125 (cos (* 2 ang))))))
      
      (list rv3-window "rv3" (lambda (ang) 
			       (+ (/ 10.0 32.0) 
				  (* (/ -15.0 32.0) (cos ang)) 
				  (* (/ 6.0 32.0) (cos (* 2 ang))) 
				  (* (/ -1.0 32.0) (cos (* 3 ang))))))
      
      (list rv4-window "rv4" (lambda (ang) 
			       (+ (/ 35.0 128.0)
				  (* (/ -56.0 128.0) (cos ang)) 
				  (* (/ 28.0 128.0) (cos (* 2 ang))) 
				  (* (/ -8.0 128.0) (cos (* 3 ang)))
				  (* (/ 1.0 128.0) (cos (* 4 ang))))))
      
      (list hamming-window "hamming" (lambda (ang)
				       (- 0.54
					  (* 0.46 (cos ang)))))
      
      (list blackman2-window "blackman2" (lambda (ang)
					   (+ 0.42323 
					      (* -0.49755 (cos ang)) 
					      (* 0.07922 (cos (* 2 ang))))))
      
      (list blackman3-window "blackman3" (lambda (ang)
					   (+ 0.35875 
					      (* -0.48829 (cos ang)) 
					      (* 0.14128 (cos (* 2 ang))) 
					      (* -0.01168 (cos (* 3 ang))))))
      
      (list blackman4-window "blackman4" (lambda (ang)
					   (+ 0.287333 
					      (* -0.44716 (cos ang))
					      (* 0.20844 (cos (* 2 ang)))
					      (* -0.05190 (cos (* 3 ang)))
					      (* 0.005149 (cos (* 4 ang))))))
      
      (list blackman5-window "blackman5" (lambda (ang)
					   (+ .293557 
					      (* -.451935 (cos ang))
					      (* .201416 (cos (* 2 ang)))
					      (* -.047926 (cos (* 3 ang)))
					      (* .00502619 (cos (* 4 ang)))
					      (* -.000137555 (cos (* 5 ang))))))
      
      (list blackman6-window "blackman6" (lambda (ang)
					   (+ .271220 
					      (* -.433444 (cos ang))
					      (* .218004 (cos (* 2 ang)))
					      (* -.065785 (cos (* 3 ang)))
					      (* .01076186 (cos (* 4 ang)))
					      (* -.000770012 (cos (* 5 ang)))
					      (* .0000136808 (cos (* 6 ang)))))) 
      
      (list blackman7-window "blackman7" (lambda (ang)
					   (+ .253317 
					      (* -.416327 (cos ang))
					      (* .228839 (cos (* 2 ang)))
					      (* -.081575 (cos (* 3 ang)))
					      (* .01773592 (cos (* 4 ang)))
					      (* -.002096702 (cos (* 5 ang)))
					      (* .0001067741 (cos (* 6 ang)))
					      (* -.0000012807(cos (* 7 ang))))))
      
      (list blackman8-window "blackman8" (lambda (ang)
					   (+ .238433 
					      (* -.400554 (cos ang))
					      (* .235824 (cos (* 2 ang)))
					      (* -.095279 (cos (* 3 ang)))
					      (* .02537395 (cos (* 4 ang)))
					      (* -.00415243  (cos (* 5 ang)))
					      (* .0003685604 (cos (* 6 ang)))
					      (* -.0000138435 (cos (* 7 ang)))
					      (* .000000116180(cos (* 8 ang))))))
      
      (list blackman9-window "blackman9" (lambda (ang)
					   (+ .225734 
					      (* -.386012 (cos ang))
					      (* .240129 (cos (* 2 ang)))
					      (* -.107054 (cos (* 3 ang)))
					      (* .03325916 (cos (* 4 ang)))
					      (* -.00687337  (cos (* 5 ang)))
					      (* .0008751673 (cos (* 6 ang)))
					      (* -.0000600859 (cos (* 7 ang)))
					      (* .000001710716 (cos (* 8 ang)))
					      (* -.00000001027272(cos (* 9 ang))))))
      
      (list blackman10-window "blackman10" (lambda (ang)
					     (+ .215153 
						(* -.373135 (cos ang))
						(* .242424 (cos (* 2 ang)))
						(* -.1166907 (cos (* 3 ang)))
						(* .04077422 (cos (* 4 ang)))
						(* -.01000904 (cos (* 5 ang)))
						(* .0016398069 (cos (* 6 ang)))
						(* -.0001651660 (cos (* 7 ang)))
						(* .000008884663 (cos (* 8 ang)))
						(* -.000000193817 (cos (* 9 ang)))
						(* .000000000848248(cos (* 10 ang))))))
      
      (list rectangular-window "rectangular" (lambda (ang) 1.0))
      
      (list bartlett-window "bartlett" (let ((val 0.0)) 
					 (lambda (ang)
					   (let ((result val))
					     (set! val (+ val (/ 1.0 8)))
					     result))))
      
      (list parzen-window "parzen" (let ((i 0))
				     (lambda (ang)
				       (let ((result (- 1.0 (abs (/ (- i 8) 8.0)))))
					 (set! i (+ i 1))
					 result))))
      
      (list welch-window "welch" (let ((i 0)
				       (sqr (lambda (x) (* x x))))
				   (lambda (ang)
				     (let ((result (- 1.0 (sqr (/ (- i 8) 8.0)))))
				       (set! i (+ i 1))
				       result))))
      
      (list flat-top-window "flat-top" (lambda (ang)
					 (+ 0.2156 
					    (* -0.4160 (cos ang))
					    (* 0.2781 (cos (* 2 ang)))
					    (* -0.0836 (cos (* 3 ang)))
					    (* 0.0069 (cos (* 4 ang))))))
      
      (list bohman-window "bohman" (let ((i 0))
				     (lambda (ang)
				       (let ((result (let ((r (/ (- 8 i) 8)))
						       (+ (* (- 1.0 r) (cos (* pi r)))
							  (* (/ 1.0 pi) (sin (* pi r)))))))
					 (set! i (+ i 1))
					 result))))
      
      (list bartlett-hann-window "bartlett-hann" (let ((i 0))
						   (lambda (ang)
						     (let ((result (+ 0.62 
								      (* -0.48 (abs (- (/ i 16.0) 0.5))) 
								      (* 0.38 (cos (* 2 pi (- (/ i 16.0) 0.5)))))))
						       (set! i (+ i 1))
						       result))))
      
      (list connes-window "connes" (let ((i 0)
					 (sqr (lambda (x) (* x x))))
				     (lambda (ang)
				       (let ((result (sqr (- 1.0 (sqr (/ (- i 8) 8.0))))))
					 (set! i (+ i 1))
					 result))))
      
      (list riemann-window "riemann" (let ((i 0))
				       (lambda (ang)
					 (let ((result (if (= 8 i) 
							   1.0
							   (/ (sin (* (/ (* 2 pi) 16.) (- 8 i))) (* (/ (* 2 pi) 16.0) (- 8 i))))))
					   (set! i (+ i 1))
					   result))))
      
      (list exponential-window "exponential" (let ((expsum 1.0))
					       (lambda (ang)
						 (let ((result (- expsum 1.0))) 
						   (set! expsum (* expsum (+ 1.0 (/ (log 2) 8.0))))
						   result))))))
    
    (do ((win (make-fft-window bartlett-hann-window 32))
	 (unhappy #f)
	 (i 0 (+ i 1))) 
	((or unhappy (= i 32)))
      (let ((val (+ 0.62 (* -0.48 (abs (- (/ i 31) 0.5))) (* 0.38 (cos (* 2 pi (- (/ i 31) 0.5)))))))
	(when (> (abs (- val (win i))) .03)
	  (set! unhappy #t)
	  (snd-display "bartlett-hann at ~D: ~A ~A" i val (win i)))))
    (do ((win (make-fft-window flat-top-window 32))
	 (unhappy #f)
      (i 0 (+ i 1))) 
	((or unhappy (= i 32)))
      (let ((val (+ 0.2156 
		    (* -0.4160 (cos (/ (* 2 pi i) 31))) 
		    (* 0.2781 (cos (/ (* 4 pi i) 31))) 
		    (* -0.0836 (cos (/ (* 6 pi i) 31))) 
		    (* 0.0069 (cos (/ (* 8 pi i) 31))))))
	(when (> (abs (- val (win i))) .1) ; error is much less, of course, in a bigger window
	  (set! unhappy #t)
	  (snd-display "flat-top at ~D: ~A ~A" i val (win i)))))
    (catch #t
	   (lambda ()
	     (let ((gen (make-fft-window samaraki-window 16)))
	       (if (not (mus-arrays-equal? gen #r(1.000 0.531 0.559 0.583 0.604 0.620 0.631 0.638 0.640 0.638 0.631 0.620 0.604 0.583 0.559 0.531)))
		   (snd-display "samaraki window: ~A" gen)))
	     (let ((gen (make-fft-window ultraspherical-window 16)))
	       (if (not (mus-arrays-equal? gen #r(1.000 0.033 0.034 0.035 0.036 0.036 0.037 0.037 0.037 0.037 0.037 0.036 0.036 0.035 0.034 0.033)))
		   (snd-display "ultraspherical window: ~A" gen)))
	     (let ((gen (make-fft-window dolph-chebyshev-window 16)))
	       (if (not (mus-arrays-equal? gen #r(1.000 0.033 0.034 0.035 0.036 0.036 0.037 0.037 0.037 0.037 0.037 0.036 0.036 0.035 0.034 0.033)))
		   (snd-display "dolph-chebyshev window: ~A" gen)))
	     
	     (without-errors
	      (let ((gen (make-fft-window dolph-chebyshev-window 16 1.0)))
		(if (not (mus-arrays-equal? gen #r(1.000 0.274 0.334 0.393 0.446 0.491 0.525 0.546 0.553 0.546 0.525 0.491 0.446 0.393 0.334 0.274)))
		    (snd-display "dolph-chebyshev window: ~A" gen))))
	     
	     (let ((val1 (make-fft-window ultraspherical-window 16 0.0 0.0))
		   (val2 (make-fft-window dolph-chebyshev-window 16 0.0)))
	       (if (not (mus-arrays-equal? val1 val2)) (snd-display "ultra/dolph 0: ~A ~A" val1 val2)))  
	     (let ((val1 (make-fft-window ultraspherical-window 16 0.0 1.0))
		   (val2 (make-fft-window samaraki-window 16 0.0)))
	       (if (not (mus-arrays-equal? val1 val2)) (snd-display "ultra/sam 0: ~A ~A" val1 val2)))
	     (let ((val1 (make-fft-window ultraspherical-window 16 0.5 0.0))
		   (val2 (make-fft-window dolph-chebyshev-window 16 0.5)))
	       (if (not (mus-arrays-equal? val1 val2)) (snd-display "ultra/dolph 5: ~A ~A" val1 val2)))  
	     (let ((val1 (make-fft-window ultraspherical-window 16 0.5 1.0))
		   (val2 (make-fft-window samaraki-window 16 0.5)))
	       (if (not (mus-arrays-equal? val1 val2)) (snd-display "ultra/sam 5: ~A ~A" val1 val2)))
	     (let ((val1 (dolph 16 1.0))
		   (val2 (make-fft-window dolph-chebyshev-window 16 1.0)))
	       (if (not (mus-arrays-equal? val1 val2)) (snd-display "dolph/dolph 1: ~A ~A" val1 val2))))
	   (lambda args (snd-display "new windows: ~A" args)))
    
    (when (defined? 'gsl-eigenvectors)
      (let ((win (make-dpss-window 16 .01)))
	(if (not (mus-arrays-equal? win #r(0.964 0.973 0.981 0.987 0.992 0.996 0.999 1.000 1.000 0.999 0.996 0.992 0.987 0.981 0.973 0.964)))
	    (snd-display "make-dpss-window 16 .01: ~A" win)))
      (let ((win (make-dpss-window 16 .1)))
	(if (not (mus-arrays-equal? win #r(0.090 0.193 0.332 0.494 0.664 0.818 0.936 1.000 1.000 0.936 0.818 0.664 0.494 0.332 0.193 0.090)))
	    (snd-display "make-dpss-window 16 .1: ~A" win)))
      (let ((win (make-dpss-window 32 .09)))
	(if (not (mus-arrays-equal? win #r(0.004 0.011 0.025 0.050 0.086 0.138 0.206 0.290 0.388 0.496 0.610 0.722 0.823 0.908 0.968 1.000 
					   1.000 0.968 0.908 0.823 0.722 0.610 0.496 0.388 0.290 0.206 0.138 0.086 0.050 0.025 0.011 0.004)))
	    (snd-display "make-dpss-window 32 .09: ~A" win)))
      
      (for-each
       (lambda (n)
	 (for-each
	  (lambda (beta)
	    (let ((win1 (make-dpss-window n beta))
		  (win2 (make-fft-window dpss-window n beta)))
	      (if (not (mus-arrays-equal? win1 win2))
		  (snd-display "dpss-windows:~%    ~A~%    ~A" win1 win2))))
	  '(.01 .07 .12 .2)))
       '(16 32)))
    
    (let ((win (make-papoulis-window 32)))
      (if (not (mus-arrays-equal? win #r(0.000 0.001 0.006 0.021 0.048 0.091 0.151 0.227 0.318 0.422 0.533 0.647 0.755 0.852 0.930 0.982 
				1.000 0.982 0.930 0.852 0.755 0.647 0.533 0.422 0.318 0.227 0.151 0.091 0.048 0.021 0.006 0.001)))
	  (snd-display "make-papoulis-window 32: ~A" win)))
    
    (for-each
     (lambda (n)
       (let ((win1 (make-papoulis-window n))
	     (win2 (make-fft-window papoulis-window n)))
	 (if (not (mus-arrays-equal? win1 win2))
	     (snd-display "papoulis-windows:~%    ~A~%    ~A" win1 win2))))
     '(32 64 256))
    
    
    (let ((gen (make-env '(0 0 1 1 2 0) :scaler 0.5 :length 11)))
      (print-and-check gen 
		       "env"
		       "env linear, pass: 0 (dur: 11), index: 0, scaler: 0.5000, offset: 0.0000, data: [0 0 1 1 2 0]")
      (if (not (env? gen)) (snd-display "~A not env?" gen))
      (if (fneq (mus-scaler gen) 0.5) (snd-display "env scaler ~F?" (mus-scaler gen)))
      (if (fneq (mus-increment gen) 1.0) (snd-display "env base (1.0): ~A?" (mus-increment gen)))
      (if (not (= (mus-length gen) 11)) (snd-display "env length: ~A" (mus-length gen)))
      (let ((v0 (make-float-vector 10)))
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (set! (v0 i) (env gen)))
	(let ((off 123.0)
	      (v1 (make-float-vector 10))
	      (gen1 (make-env '(0 0 1 1 2 0) :scaler 0.5 :length 11)))
	  (fill-float-vector v1 (begin
				  (set! off (mus-offset gen1))
				  (if (env? gen1) (env gen1) -1.0)))
	  (if (fneq off 0.0) (snd-display "mus-offset opt: ~A" off))
	  (if (not (mus-arrays-equal? v0 v1)) (snd-display "map env: ~A ~A" v0 v1)))
	(if (or (fneq (v0 0) 0.0) (fneq (v0 1) .1) (fneq (v0 6) .4))
	    (snd-display "~A output: ~A" gen v0))
	(if (fneq (env-interp 1.6 gen) 0.2) (snd-display "env-interp ~A at 1.6: ~F?" gen (env-interp 1.5 gen)))
	(set! gen (make-env :envelope '(0 1 1 0) :base 32.0 :length 11))
	(if (fneq (mus-increment gen) 32.0) (snd-display "env base (32.0): ~A?" (mus-increment gen)))
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (set! (v0 i) (env gen)))
	(if (or (fneq (v0 0) 1.0) (fneq (v0 1) .698) (fneq (v0 8) .032))
	    (snd-display "~A output: ~A" gen v0))
	(set! gen (make-env :envelope '(0 1 1 0) :base .0325 :length 11))
	(if (fneq (mus-increment gen) .0325) (snd-display "env base (.0325): ~A?" (mus-increment gen)))
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (set! (v0 i) (env gen)))
	(if (or (fneq (v0 0) 1.0) (fneq (v0 1) .986) (fneq (v0 8) .513))
	    (snd-display "~A output: ~A" gen v0))
	(set! gen (make-env :envelope '(0 1 1 .5 2 0) :base 0.0 :length 11 :offset 1.0))
	(if (fneq (mus-offset gen) 1.0) (snd-display "mus-offset: ~A" (mus-offset gen)))
	(if (fneq (mus-increment gen) 0.0) (snd-display "env base (0.0): ~A?" (mus-increment gen)))
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (if (and (= i 3)
		   (not (= (mus-location gen) 3)))
	      (snd-display "env location: ~A?" (mus-location gen)))
	  (set! (v0 i) (env gen)))
	(if (or (fneq (v0 0) 2.0) (fneq (v0 6) 1.5) (fneq (v0 8) 1.5))
	    (snd-display "~A output: ~A" gen v0)))
      (if (fneq (env-interp 1.5 gen) 1.5) (snd-display "env-interp ~A at 1.5: ~F?" gen (env-interp 1.5 gen)))
      (set! (mus-location gen) 6)
      (if (not (= (mus-location gen) 6)) (snd-display "set! mus-location ~A (6)?" (mus-location gen)))
      (let ((val (env gen)))
	(if (fneq val 1.5) (snd-display "set! mus-location 6 -> ~A (1.5)?" val)))
      (set! (mus-location gen) 0)
      (let ((val (env gen)))
	(if (fneq val 2.0) (snd-display "set! mus-location 0 -> ~A (2.0)?" val)))
      (let ((gen (make-env '(0 0 1 -1 2 0) :length 11)))
	(do ((i 0 (+ i 1)))
	    ((= i 5))
	  (let ((val (env gen)))
	    (if (fneq val (/ i -5.0)) (snd-display "neg env: ~D ~A" i val))))
	(do ((i 0 (+ i 1)))
	    ((= i 5))
	  (let ((val (env gen)))
	    (if (fneq val (- (/ i 5.0) 1.0)) (snd-display "neg env: ~D ~A" (+ i 5) val)))))
      (do ((gen (make-env '(0 0 1 -1 2 0) :length 11 :base 0.5))
	   (v #r(0.0 -0.14869 -0.31950 -0.51571 -0.74110 -1.0 -0.74110 -0.51571 -0.31950 -0.14869))
	   (i 0 (+ i 1)))
	  ((= i 10)
	   (mus-apply gen))	     
	(let ((val (env gen)))
	  (if (fneq val (v i)) (snd-display "neg exp env: ~D ~A" i val)))))

    (let ((env-fill (lambda (v e)
		      (do ((i 0 (+ i 1)))
			  ((= i 10))
			(set! (v i) (env e))))))
      
      (let ((v (make-float-vector 10)))
	(let ((e (make-env '(0 0 1 1) :length 10)))
	  (env-fill v e)
	  (if (not (mus-arrays-equal? v #r(0.000 0.111 0.222 0.333 0.444 0.556 0.667 0.778 0.889 1.000)))
	      (snd-display "simple ramp: ~A" v)))
	(let ((v (make-float-vector 10))
	      (e (make-env '(0 0 1 1) :base 0 :length 8)))
	  (env-fill v e)
	  (if (not (mus-arrays-equal? v #r(0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 1.000 1.000)))
	      (snd-display "simple ramp, base 0: ~A" v)))
	(let ((v (make-float-vector 10))
	      (e (make-env '(0 0 1 1 2 .5) :base 0 :length 8)))
	  (env-fill v e)
	  (if (not (mus-arrays-equal? v #r(0.000 0.000 0.000 0.000 1.000 1.000 1.000 1.000 0.500 0.500)))
	      (snd-display "two-step, base 0: ~A" v)))
	(let ((e (make-env '((0 0) (1 1)) :length 10)))
	  (env-fill v e)
	  (if (not (mus-arrays-equal? v #r(0.000 0.111 0.222 0.333 0.444 0.556 0.667 0.778 0.889 1.000)))
	      (snd-display "simple ramp embedded: ~A" v)))
	(let ((e (make-env '(0 1 1 0) :length 10)))
	  (env-fill v e)
	  (if (not (mus-arrays-equal? v #r(1.000 0.889 0.778 0.667 0.556 0.444 0.333 0.222 0.111 0.000)))
	      (snd-display "simple ramp down: ~A" v)))
	(let ((e (make-env '(0 0 1 1 2 0) :length 10)))
	  (env-fill v e)
	  (if (not (mus-arrays-equal? v #r(0.000 0.200 0.400 0.600 0.800 1.000 0.750 0.500 0.250 0.000)))
	      (snd-display "simple pyr: ~A" v)))
	(let ((e (make-env '((0 0) (1 1) (2 0)) :length 10)))
	  (env-fill v e)
	  (if (not (mus-arrays-equal? v #r(0.000 0.200 0.400 0.600 0.800 1.000 0.750 0.500 0.250 0.000)))
	      (snd-display "simple pyr embedded: ~A" v)))
	(let ((e (make-env '(0 0 1 1 2 -.5) :length 10)))
	  (env-fill v e)
	  (if (not (mus-arrays-equal? v #r(0.000 0.200 0.400 0.600 0.800 1.000 0.625 0.250 -0.125 -0.500)))
	      (snd-display "simple pyr -.5: ~A" v)))
	(let ((e (make-env '((0 0) (1 1) (2 -.5)) :length 10)))
	  (env-fill v e)
	  (if (not (mus-arrays-equal? v #r(0.000 0.200 0.400 0.600 0.800 1.000 0.625 0.250 -0.125 -0.500)))
	      (snd-display "simple pyr -.5 embedded: ~A" v)))
	(let ((e (make-env '(0 0 1 1 2 -.5) :length 10)))
	  (env-fill v e)
	  (if (not (mus-arrays-equal? v #r(0.000 0.200 0.400 0.600 0.800 1.000 0.625 0.250 -0.125 -0.500)))
	      (snd-display "simple pyr -.5: ~A" v))))
      
      (let ((v (make-float-vector 10)))
	(let ((e (make-env #r(0 0 1 1) :length 10)))
	  (env-fill v e)
	  (if (not (mus-arrays-equal? v #r(0.000 0.111 0.222 0.333 0.444 0.556 0.667 0.778 0.889 1.000)))
	      (snd-display "simple ramp: ~A" v)))
	(let ((v (make-float-vector 10))
	      (e (make-env #r(0 0 1 1) :base 0 :length 8)))
	  (env-fill v e)
	  (if (not (mus-arrays-equal? v #r(0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 1.000 1.000)))
	      (snd-display "simple ramp, base 0: ~A" v)))
	(let ((v (make-float-vector 10))
	      (e (make-env #r(0 0 1 1 2 .5) :base 0 :length 8)))
	  (env-fill v e)
	  (if (not (mus-arrays-equal? v #r(0.000 0.000 0.000 0.000 1.000 1.000 1.000 1.000 0.500 0.500)))
	      (snd-display "two-step, base 0: ~A" v)))
	(let ((e (make-env #r(0 1 1 0) :length 10)))
	  (env-fill v e)
	  (if (not (mus-arrays-equal? v #r(1.000 0.889 0.778 0.667 0.556 0.444 0.333 0.222 0.111 0.000)))
	      (snd-display "simple ramp down: ~A" v)))
	(let ((e (make-env #r(0 0 1 1 2 0) :length 10)))
	  (env-fill v e)
	  (if (not (mus-arrays-equal? v #r(0.000 0.200 0.400 0.600 0.800 1.000 0.750 0.500 0.250 0.000)))
	      (snd-display "simple pyr: ~A" v)))
	(let ((e (make-env #r(0 0 1 1 2 -.5) :length 10)))
	  (env-fill v e)
	  (if (not (mus-arrays-equal? v #r(0.000 0.200 0.400 0.600 0.800 1.000 0.625 0.250 -0.125 -0.500)))
	      (snd-display "simple pyr -.5: ~A" v)))
	(let ((e (make-env #r(0 0 1 1 2 -.5) :length 10)))
	  (env-fill v e)
	  (if (not (mus-arrays-equal? v #r(0.000 0.200 0.400 0.600 0.800 1.000 0.625 0.250 -0.125 -0.500)))
	      (snd-display "simple pyr -.5: ~A" v))))
      
      (let ((v (make-float-vector 10)))
	(let ((e (make-env #r(0 0 1 1) :length 10)))
	  (env-fill v e)
	  (if (not (mus-arrays-equal? v #r(0.000 0.111 0.222 0.333 0.444 0.556 0.667 0.778 0.889 1.000)))
	      (snd-display "simple ramp: ~A" v)))
	(let ((v (make-float-vector 10))
	      (e (make-env #r(0 0 1 1) :base 0 :length 8)))
	  (env-fill v e)
	  (if (not (mus-arrays-equal? v #r(0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 1.000 1.000)))
	      (snd-display "simple ramp, base 0: ~A" v)))
	(let ((v (make-float-vector 10))
	      (e (make-env #r(0 0 1 1 2 .5) :base 0 :length 8)))
	  (env-fill v e)
	  (if (not (mus-arrays-equal? v #r(0.000 0.000 0.000 0.000 1.000 1.000 1.000 1.000 0.500 0.500)))
	      (snd-display "two-step, base 0: ~A" v)))
	(let ((e (make-env #r(0 1 1 0) :length 10)))
	  (env-fill v e)
	  (if (not (mus-arrays-equal? v #r(1.000 0.889 0.778 0.667 0.556 0.444 0.333 0.222 0.111 0.000)))
	      (snd-display "simple ramp down: ~A" v)))
	(let ((e (make-env #r(0 0 1 1 2 0) :length 10)))
	  (env-fill v e)
	  (if (not (mus-arrays-equal? v #r(0.000 0.200 0.400 0.600 0.800 1.000 0.750 0.500 0.250 0.000)))
	      (snd-display "simple pyr: ~A" v)))
	(let ((e (make-env #r(0 0 1 1 2 -.5) :length 10)))
	  (env-fill v e)
	  (if (not (mus-arrays-equal? v #r(0.000 0.200 0.400 0.600 0.800 1.000 0.625 0.250 -0.125 -0.500)))
	      (snd-display "simple pyr -.5: ~A" v)))
	(let ((e (make-env #r(0 0 1 1 2 -.5) :length 10)))
	  (env-fill v e)
	  (if (not (mus-arrays-equal? v #r(0.000 0.200 0.400 0.600 0.800 1.000 0.625 0.250 -0.125 -0.500)))
	      (snd-display "simple pyr -.5: ~A" v)))))
    
    (let ((e (make-env '(0 0 1 1) :length 10)))
      (if (fneq (env-interp 1.0 e) 1.0) (snd-display "env-interp 0011 at 1: ~A" (env-interp 1.0 e)))
      (if (fneq (env-interp 2.0 e) 1.0) (snd-display "env-interp 0011 at 2: ~A" (env-interp 2.0 e)))
      (if (fneq (env-interp 0.0 e) 0.0) (snd-display "env-interp 0011 at 0: ~A" (env-interp 0.0 e)))
      (if (fneq (env-interp 0.444 e) 0.444) (snd-display "env-interp 0011 at .444: ~A" (env-interp 0.45 e)))
      (mus-reset e)
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(let ((val (env e)))
	  (if (fneq val (* i .111111)) (snd-display "ramp env over 10: ~A at ~A" val i)))))
    (do ((e (make-env '(0 0 .5 .5 1 1) :base 32 :length 10))
	 (v #r(0.0 0.0243 0.0667 0.1412 0.2716 0.5000 0.5958 0.7090 0.8425 1.0))
	 (i 0 (+ i 1))
	 (x 0.0 (+ x 0.11111)))
	((= i 10))
      (let ((val (env-interp x e)))
	(if (fneq val (v i)) (snd-display "(0 .5 1) env-interp over 10: ~A at ~A (~A)" val i (v i)))))
    (do ((e (make-env '(0 -1.0 1 1) :base 32 :length 10))
	 (v #r(-1.0 -0.9697 -0.9252 -0.8597 -0.7635 -0.6221 -0.4142 -0.1088 0.34017 1.0))
	 (i 0 (+ i 1))
	 (x 0.0 (+ x 0.11111)))
	((= i 10))
      (let ((val (env-interp x e)))
	(if (fneq val (v i)) (snd-display "(-1 1) env-interp over 10: ~A at ~A (~A)" val i (v i)))))
    (do ((e (make-env '(0 -1.0 .5 .5 1 0) :base 32 :length 10))
	 (v #r(-1.0 -0.952 -0.855 -0.661 -0.274 0.5 0.356 0.226 0.107 0.0))
	 (i 0 (+ i 1))
	 (x 0.0 (+ x 0.11111)))
	((= i 10))
      (let ((val (env-interp x e)))
	(if (fneq val (v i)) (snd-display "(-1 .5 0) env-interp over 10: ~A at ~A (~A)" val i (v i)))))
    (do ((e (make-env '(0 0.0 .5 .5 1 -1.0) :base 32 :length 10))
	 (v #r(0.0 0.085 0.177 0.276 0.384 0.5 -0.397 -0.775 -0.933 -1.0))
	 (i 0 (+ i 1))
	 (x 0.0 (+ x 0.11111)))
	((= i 10))
      (let ((val (env-interp x e)))
	(if (fneq val (v i)) (snd-display "(0 .5 -1) env-interp over 10: ~A at ~A (~A)" val i (v i)))))
    (let ((e (make-env '(0 0 1 1) :length 10 :base 4.0)))
      (if (fneq (env-interp 1.0 e) 1.0) (snd-display "env-interp 0011 4 at 1: ~A" (env-interp 1.0 e)))
      (if (fneq (env-interp 0.0 e) 0.0) (snd-display "env-interp 0011 4 at 0: ~A" (env-interp 0.0 e)))
      (if (fneq (env-interp 0.45 e) 0.2839) (snd-display "env-interp 0011 4 at .45: ~A" (env-interp 0.45 e))))
    (let ((e (make-env '(0 0 1 1) :length 10 :base 0.2)))
      (if (fneq (env-interp 1.0 e) 1.0) (snd-display "env-interp 0011 2 at 1: ~A" (env-interp 1.0 e)))
      (if (fneq (env-interp 0.0 e) 0.0) (snd-display "env-interp 0011 2 at 0: ~A" (env-interp 0.0 e)))
      (if (fneq (env-interp 0.45 e) 0.6387) (snd-display "env-interp 0011 2 at .45: ~A" (env-interp 0.45 e))))
    
    (let ((val (let ((e (make-env '(0 0 1 1) :length 10 :offset 2.0))) (set! (mus-offset e) 3.0) (mus-offset e))))
      (if (fneq val 3.0) (snd-display "set mus-offset env: ~A" val)))
    
    (let ((e (make-env '(0 0 1 1 2 0) :length 10))
	  (v (make-float-vector 10)))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v i) (env e)))
      (if (not (mus-arrays-equal? v #r(0.000 0.200 0.400 0.600 0.800 1.000 0.750 0.500 0.250 0.000)))
	  (snd-display "e set off 0: ~A" v))
      (if (not (= (mus-length e) 10)) (snd-display "e set off 0 len: ~A" (mus-length e)))
      (if (fneq (mus-scaler e) 1.0) (snd-display "e set off 0 scl: ~A" (mus-scaler e)))
      (if (fneq (mus-offset e) 0.0) (snd-display "e set off 0 off: ~A" (mus-offset e)))
      (set! (mus-scaler e) 2.0)
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v i) (env e)))
      (if (not (mus-arrays-equal? v #r(0.000 0.400 0.800 1.200 1.600 2.000 1.500 1.000 0.500 0.000)))
	  (snd-display "e set off 1: ~A" v))
      (if (not (= (mus-length e) 10)) (snd-display "e set off 1 len: ~A" (mus-length e)))
      (if (fneq (mus-scaler e) 2.0) (snd-display "e set off 1 scl: ~A" (mus-scaler e)))
      (if (fneq (mus-offset e) 0.0) (snd-display "e set off 1 off: ~A" (mus-offset e)))
      (set! (mus-offset e) 1.0)
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v i) (env e)))
      (if (not (mus-arrays-equal? v #r(1.000 1.400 1.800 2.200 2.600 3.000 2.500 2.000 1.500 1.000)))
	  (snd-display "e set off 2: ~A" v))
      (if (not (= (mus-length e) 10)) (snd-display "e set off 2 len: ~A" (mus-length e)))
      (if (fneq (mus-scaler e) 2.0) (snd-display "e set off 2 scl: ~A" (mus-scaler e)))
      (if (fneq (mus-offset e) 1.0) (snd-display "e set off 2 off: ~A" (mus-offset e)))
      (set! (mus-length e) 19)
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v i) (env e)))
      (if (not (mus-arrays-equal? v #r(1.000 1.222 1.444 1.667 1.889 2.111 2.333 2.556 2.778 3.000)))
	  (snd-display "e set off 3: ~A" v))
      (if (not (= (mus-length e) 19)) (snd-display "e set off 3 len: ~A" (mus-length e)))
      (if (fneq (mus-scaler e) 2.0) (snd-display "e set off 3 scl: ~A" (mus-scaler e)))
      (if (fneq (mus-offset e) 1.0) (snd-display "e set off 3 off: ~A" (mus-offset e))))
    
    (do ((e (make-env #r(0 0 1 1 2 0) :length 10))
	 (v (make-float-vector 10))
	 (i 0 (+ i 1)))
	((= i 10)
	 (if (not (mus-arrays-equal? v #r(0.000 0.200 0.400 0.600 0.800 1.000 0.750 0.500 0.250 0.000)))
	     (snd-display "e from float-vector: ~A" v)))
      (set! (v i) (env e)))
    
    (do ((e1 (make-env '(0 0 1 1) :base 32.0 :length 11))
	 (v #r(0.000 0.013 0.032 0.059 0.097 0.150 0.226 0.333 0.484 0.698 1.00))
	 (i 0 (+ i 1)))
	((> i 10))
      (let ((val (env e1)))
	(if (fneq val (v i))
	    (snd-display "exp env direct (32.0): ~A ~A" val (v i)))))
    
    (do ((e1 (make-env '(0 1 1 2) :base 32.0 :length 11))
	 (v #r(1.000 1.013 1.032 1.059 1.097 1.150 1.226 1.333 1.484 1.698 2.00))
	 (i 0 (+ i 1)))
	((> i 10))
      (let ((val (env e1)))
	(if (fneq val (v i))
	    (snd-display "exp env direct (32.0) offset: ~A ~A" val (v i)))))
    (do ((e1 (make-env '((0 1) (1 2)) :base 32.0 :length 11))
	 (v #r(1.000 1.013 1.032 1.059 1.097 1.150 1.226 1.333 1.484 1.698 2.00))
	 (i 0 (+ i 1)))
	((> i 10))
      (let ((val (env e1)))
	(if (fneq val (v i))
	    (snd-display "exp env direct (32.0) offset embedded: ~A ~A" val (v i)))))
    (do ((e1 (make-env '(0 1 1 2) :base 32.0 :length 11))
	 (v #r(1.000 1.013 1.032 1.059 1.097 1.150 1.226 1.333 1.484 1.698 2.00))
	 (i 0 (+ i 1)))
	((> i 10))
      (let ((val (env e1)))
	(if (fneq val (v i))
	    (snd-display "exp env direct (32.0) offset (and dur): ~A ~A" val (v i)))))
    
    (do ((e1 (make-env '(0 0 1 1) :base 0.032 :length 11))
	 (v #r(0.000 0.301 0.514 0.665 0.772 0.848 0.902 0.940 0.967 0.986 1.0))
	 (i 0 (+ i 1)))
	((> i 10))
      (let ((val (env e1)))
	(if (fneq val (v i))
	    (snd-display "exp env direct (.032): ~A ~A" val (v i)))))
    
    (let ((e1 (make-env '(0 0 1 1) :base .03125 :length 11))
	  (e2 (make-env '(0 0 1 1 2 0) :base 32.0 :length 11))
	  (e3 (make-env '(0 0 .1 1 2 0) :base 1.1 :length 101)))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(let ((lv1 (env-interp (* i .1) e1))
	      (lv2 (env e1))
	      (lv3 (env-interp (* i .2) e2))
	      (lv4 (env e2)))
	  (if (ffneq lv1 lv2) (snd-display "env-interp[rmp ~F]: ~A (~A)?" (* .1 i) lv1 lv2))
	  (if (ffneq lv3 lv4) (snd-display "env-interp[pyr ~F]: ~A (~A)?" (* .2 i) lv3 lv4))))
      (do ((i 0 (+ i 1)))
	  ((= i 100))
	(let* ((lv5 (env-interp (* i .02) e3))
	       (lv6 (env e3)))
	  (if (ffneq lv5 lv6) (snd-display "env-interp[tri ~F]: ~A (~A)?" (* .02 i) lv5 lv6)))))
    
    (let ((e1 (make-env '(0 0 1 1 2 0) :length 10))
	  (lv1 (make-float-vector 11))
	  (lv2 (make-float-vector 11))
	  (lv3 (make-float-vector 11)))
      (do ((i 0 (+ i 1))) ((= i 11)) (set! (lv1 i) (env e1)))
      (do ((i 0 (+ i 1))) ((= i 11)) (set! (lv2 i) (env e1)))
      (mus-reset e1)
      (do ((i 0 (+ i 1))) ((= i 11)) (set! (lv3 i) (env e1)))
      (if (not (mus-arrays-equal? lv1 lv3)) (snd-display "mus-reset: ~A ~A?" lv1 lv3))
      (if (not (mus-arrays-equal? lv2 (make-float-vector 11))) (snd-display "mus-reset 1: ~A?" lv2)))
    
    (let ((gen (make-env '(0 0 1 1 2 0) :length 11)))
      (do ((i 0 (+ i 1))) ((= i 4)) (env gen))
      (let ((val (env gen)))
	(if (fneq val .8) (snd-display "env(5): ~A?" val))
	(mus-reset gen)
	(do ((i 0 (+ i 1))) ((= i 4)) (env gen))
	(set! val (env gen))
	(if (fneq val .8) (snd-display "mus-reset (via reset): ~A?" val))
	(set! (mus-location gen) 6)
	(let ((val (env gen)))
	  (if (fneq val 0.8) (snd-display "set! mus-location 6 -> ~A (0.8)?" val)))))
    
    (let ((gen (make-env '(0 0 1 1) :base .032 :length 12)))
      (set! (mus-location gen) 5)
      (let ((val (env gen)))
	(if (fneq val 0.817)
	    (snd-display "set env location with base: ~A ~A" val gen))))
    (let ((gen (make-env '(0 0 1 1) :base .032 :length 12)))
      (set! (mus-location gen) 5)
      (let ((val (env gen)))
	(if (fneq val 0.817)
	    (snd-display "set env location with base and dur: ~A ~A" val gen))))
    
    (test-gen-equal (make-env '(0 0 1 1 2 0) :scaler 0.5 :length 10) (make-env '(0 0 1 1 2 0) :scaler 0.5 :length 10) (make-env '(0 0 1 1 2 0) :scaler 0.25 :length 10))
    (test-gen-equal (make-env '(0 0 1 1 2 0) :scaler 0.5 :length 10) (make-env '(0 0 1 1 2 0) :scaler 0.5 :length 10) (make-env '(0 0 1 1 2 0) :scaler 0.5 :length 11))
    (test-gen-equal (make-env '(0 0 1 1 2 0) :scaler 0.5 :length 10) (make-env '(0 0 1 1 2 0) :scaler 0.5 :length 10) (make-env '(0 0 1 1 3 0) :scaler 0.5 :length 10))
    (test-gen-equal (make-env '((0 0) (1 1) (2 0)) :scaler 0.5 :length 10) (make-env '(0 0 1 1 2 0) :scaler 0.5 :length 10) (make-env '((0 0) (1 1) (3 0)) :scaler 0.5 :length 10))
    
    (let ((var (catch #t (lambda () (make-env :envelope ())) (lambda args args))))
      (if (not (memq (car var) '(no-data wrong-type-arg)))
	  (snd-display "make-env null env: ~A" var)))
    (let ((var (catch #t (lambda () (make-env :length 1)) (lambda args args))))
      (if (not (memq (car var) '(no-data wrong-type-arg)))
	  (snd-display "make-env no env: ~A" var)))
    (let ((var (catch #t (lambda () (make-env :envelope '(0 0) :length -1)) (lambda args args))))
      (if (not (eq? (car var) 'out-of-range))
	  (snd-display "make-env bad dur: ~A" var)))
    (let ((var (catch #t (lambda () (make-env :envelope '(0 0) :duration -1.0)) (lambda args args))))
      (if (not (eq? (car var) 'out-of-range))
	  (snd-display "make-env bad duration: ~A" var)))
    (let ((var (catch #t (lambda () (make-env :envelope '(0 0) :base -1.0)) (lambda args args))))
      (if (not (eq? (car var) 'out-of-range))
	  (snd-display "make-env bad base: ~A" var)))
    (let ((var (catch #t (lambda () (make-env :envelope '(1 1 0 0) :length 11)) (lambda args args))))
      (if (not (eq? (car var) 'mus-error))
	  (snd-display "make-env bad env 1 1 0 0: ~A" var)))
    (let ((var (catch #t (lambda () (make-env :envelope '(0 1 -1 0) :length 11)) (lambda args args))))
      (if (not (eq? (car var) 'mus-error))
	  (snd-display "make-env bad env 0 1 -1 0: ~A" var)))
    (let ((var (catch #t (lambda () (make-env :envelope '(0 1 1 0) :length 11 :length 10)) (lambda args args))))
      (if (not (memq (car var) '(mus-error wrong-type-arg)))
	  (snd-display "make-env bad end/dur: ~A" var)))
    (let ((var (catch #t (lambda () (make-env :envelope '(0 0 1 1 2 0 1) :duration 1.0)) (lambda args args))))
      (if (not (memq (car var) '(bad-type wrong-type-arg)))
	  (snd-display "make-env odd length env: ~A" var)))
    (let ((var (catch #t (lambda () (make-env :envelope '("hi" 0 1 1 2 0) :duration 1.0)) (lambda args args))))
      (if (not (eq? (car var) 'wrong-type-arg))
	  (snd-display "make-env env of non-number: ~A" var)))
    
    ;; env-any
    (let* ((env-any-env '(0 0 1 1 2 0.25 3 1 4 0))
	   (env-any-1 (lambda (e func)
			(let* ((pts (mus-data e))
			       (pt (min (* 2 (mus-channels e)) (- (length pts) 4)))
			       (val (/ (- (env e) (mus-offset e)) (mus-scaler e)))
			       (y0 (min (pts (+ pt 1)) (pts (+ pt 3))))
			       (y1 (max (pts (+ pt 1)) (pts (+ pt 3))))
			       (new-val (func (/ (- val y0) (- y1 y0)))))
			  (+ (mus-offset e)
			     (* (mus-scaler e)
				(+ y0
				   (* (- y1 y0) new-val)))))))
	   (sine-env-1 (lambda (e)
			 (env-any-1 e (lambda (y) (* 0.5 (+ 1.0 (sin (* pi (- y 0.5)))))))))
	   (square-env-1 (lambda (e)
			   (env-any-1 e (lambda (y)
					  (* y y)))))
	   
	   (blackman4-env-1 (lambda (e)
			      (env-any-1 e (lambda (y)
					     (let ((cx (cos (* pi y))))
					       (+ 0.084037 (* cx (- (* cx (+ .375696 (* cx (- (* cx .041194) .20762)))) .29145))))))))
	   
	   (multi-expt-env-1 (lambda (e expts)
			       (env-any-1 e (lambda (y)
					      (let ((b (expts (modulo (mus-channels e) (length expts)))))
						(/ (- (expt b y) 1.0) (- b 1.0))))))))
      
      ;; assume sine-env square-env blackman4-env and multi-exp-env are available from generators.scm (8)
      
      (let ((val1 (with-sound ((make-float-vector 20))
		    (do ((e (make-env env-any-env :length 20))
			 (i 0 (+ i 1)))
			((= i 20))
		      (outa i (sine-env e)))))
	    
	    (val2 (with-sound ((make-float-vector 20))
		    (do ((e (make-env env-any-env :length 20))
			 (i 0 (+ i 1)))
			((= i 20))
		      (outa i (sine-env e)))))
	    
	    (val3 (with-sound ((make-float-vector 20))
		    (do ((e (make-env env-any-env :length 20))
			 (i 0 (+ i 1)))
			((= i 20))
		      (outa i (sine-env-1 e))))))
	(if (not (mus-arrays-equal? val1 val2))
	    (snd-display "sine-env straight and run: ~%;  ~A~%;  ~A" val1 val2))
	(if (not (mus-arrays-equal? val1 val3))
	    (snd-display "sine-env straight and scm: ~%;  ~A~%;  ~A" val1 val3)))
      
      
      (let ((val1 (with-sound ((make-float-vector 20))
		    (do ((e (make-env env-any-env :length 20))
			 (i 0 (+ i 1)))
			((= i 20))
		      (outa i (square-env e)))))
	    
	    (val2 (with-sound ((make-float-vector 20))
		    (do ((e (make-env env-any-env :length 20))
			 (i 0 (+ i 1)))
			((= i 20))
		      (outa i (square-env e)))))
	    
	    (val3 (with-sound ((make-float-vector 20))
		    (do ((e (make-env env-any-env :length 20))
			 (i 0 (+ i 1)))
			((= i 20))
		      (outa i (square-env-1 e))))))
	(if (not (mus-arrays-equal? val1 val2))
	    (snd-display "square-env straight and run: ~%;  ~A~%;  ~A" val1 val2))
	(if (not (mus-arrays-equal? val1 val3))
	    (snd-display "square-env straight and scm: ~%;  ~A~%;  ~A" val1 val3)))
      
      (let ((val1 (with-sound ((make-float-vector 20))
		    (do ((e (make-env env-any-env :length 20))
			 (i 0 (+ i 1)))
			((= i 20))
		      (outa i (blackman4-env e)))))
	    
	    (val3 (with-sound ((make-float-vector 20))
		    (do ((e (make-env env-any-env :length 20))
			 (i 0 (+ i 1)))
			((= i 20))
		      (outa i (blackman4-env-1 e))))))
	(if (not (mus-arrays-equal? val1 val3))
	    (snd-display "blackman4-env straight and scm: ~%;  ~A~%;  ~A" val1 val3)))
      
      
      (let ((val1 (with-sound ((make-float-vector 20))
		    (do ((e (make-env env-any-env :length 20))
			 (bases #r(32.0 0.3 1.5))
			 (i 0 (+ i 1)))
			((= i 20))
		      (outa i (multi-expt-env e bases)))))
	    
	    (val2 (with-sound ((make-float-vector 20))
		    (do ((e (make-env env-any-env :length 20))
			 (bases #r(32.0 0.3 1.5))
			 (i 0 (+ i 1)))
			((= i 20))
		      (outa i (multi-expt-env e bases)))))
	    
	    (val3 (with-sound ((make-float-vector 20))
		    (do ((e (make-env env-any-env :length 20))
			 (bases #r(32.0 0.3 1.5))
			 (i 0 (+ i 1)))
			((= i 20))
		      (outa i (multi-expt-env-1 e bases))))))
	(if (not (mus-arrays-equal? val1 val2))
	    (snd-display "multi-expt-env straight and run: ~%;  ~A~%;  ~A" val1 val2))
	(if (not (mus-arrays-equal? val1 val3))
	    (snd-display "multi-expt-env straight and scm: ~%;  ~A~%;  ~A" val1 val3)))
      
      (let ((val1 (with-sound ((make-float-vector 220))
		    (do ((e1 (make-env env-any-env :length 220))
			 (e2 (make-env env-any-env :length 220))
			 (i 0 (+ i 1)))
			((= i 220))
		      (outa i (env-any e1
				       (lambda (y1)
					 (* y1 (env-any e2
							(lambda (y2)
							  y2)))))))))
	    (val2 (with-sound ((make-float-vector 220))
		    (do ((e1 (make-env env-any-env :length 220))
			 (e2 (make-env env-any-env :length 220))
			 (i 0 (+ i 1)))
			((= i 220))
		      (outa i (env-any e1 ; try it with and without "declare"
				       (lambda (y1)
					 (* y1 (env-any e2
							(lambda (y2)
							  y2))))))))))
	(if (not (mus-arrays-equal? val1 val2))
	    (snd-display "env-any recursive: ~%;  ~A~%;  ~A" val1 val2))))
    
    (let ((ind (new-sound :size 20)))
      (select-sound ind)
      (map-channel (lambda (y) 1.0))
      (let ((bumpy (lambda ()
		     (let ((x 0.0) 
			   (xi (/ 1.0 (framples)))
			   (start 0)
			   (end 1))
		       (let ((scl (exp (/ 4.0 (- end start))))) ; normalize it
			 (map-channel (lambda (y) 
					(let ((val (if (not (< start x end))
						       0.0
						       (exp (+ (/ -1.0 (- x start))
							       (/ -1.0 (- end x)))))))
					  (set! x (+ x xi))
					  (* scl val)))))))))
	(bumpy)
	(let ((vals (channel->float-vector)))
	  (if (not (mus-arrays-equal? vals #r(0.0 0.0 0.001 0.021 0.105 0.264 0.467 0.673 0.846 0.960 1.000 0.960 0.846 0.673 0.467 0.264 0.105 0.021 0.001 0.0)))
	      (snd-display "bumpy: ~A" vals))))
      (if (fneq (channel-lp-inf) 1.0) ; just a fancy name for maxamp
	  (snd-display "channel-lp-inf: ~A" (channel-lp-inf)))
      (linear-src-channel 2.0)
      (let ((vals (channel->float-vector)))
	(if (not (mus-arrays-equal? vals #r(0.000 0.001 0.105 0.467 0.846 1.000 0.846 0.467 0.105 0.001)))
	    (snd-display "linear-src-channel: ~A" vals)))
      (let-temporarily ((*clipping* #t))
	(save-sound-as "tst.snd")
	(let ((fvals (file->floats "tst.snd")) 
	      (vals (channel->float-vector)))
	  (if (not (mus-arrays-equal? vals fvals))
	      (snd-display "file->floats: ~A ~A" vals fvals)))
	(mus-sound-forget "tst.snd")
	(delete-file "tst.snd"))
      (let ((hp (make-differentiator)))
	(map-channel (lambda (y)
		       (differentiator hp y))))
      (if (fneq (maxamp) .0013)
	  (snd-display "differentiator: ~A" (maxamp)))
      (revert-sound ind)
      (let ((val (window-rms)))
	(if (fneq val 0.0) (snd-display "window-rms empty: ~A" val))
	(set! (sample 10) 1.0)
	(set! val (window-rms))
	(if (fneq val .218) (snd-display "window-rms 1: ~A" val))
	(let ((vals (window-samples)))
	  (if (or (not (float-vector? vals))
		  (not (= (length vals) 21))
		  (fneq (vals 10) 1.0))
	      (snd-display "window-samples: ~A" vals))))
      (revert-sound ind)
      (clean-up-sound ind))
    
    (let ((gen (make-table-lookup 440.0 :wave (partials->wave '(1 1 2 1))))
	  (v0 (make-float-vector 10))
	  (v1 (make-float-vector 10)))
      (print-and-check gen 
		       "table-lookup"
		       "table-lookup freq: 440.000Hz, phase: 0.000, length: 512, interp: linear")
      (if (not (= (mus-length gen) 512)) (snd-display "table-lookup length: ~A?" (mus-length gen)))
      (let ((gen3 (mus-length (make-table-lookup))))
	(if (not (= gen3 512)) (snd-display "default table-lookup length: ~A?" gen3)))
      (do ((gen1 (make-table-lookup 440.0 :wave (partials->wave '(1 1 2 1) (make-float-vector 512))))
	   (i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (table-lookup gen 0.0))
	(set! (v1 i) (mus-apply gen1 0.0)))
      (let ((v2 (make-float-vector 10)))
	(let ((gen4 (make-table-lookup 440.0 :wave (partials->wave '(1 1 2 1)))))
	  (fill-float-vector v2 (if (table-lookup? gen4) (table-lookup gen4 0.0) -1.0))
	  (if (not (mus-arrays-equal? v0 v2)) (snd-display "map table-lookup: ~A ~A" v0 v2))
	  (set! gen4 (make-table-lookup 440.0 :wave (partials->wave #r(1 1 2 1))))
	  (fill-float-vector v2 (table-lookup gen4)))
	(if (not (mus-arrays-equal? v0 v2)) (snd-display "map table-lookup (no fm): ~A ~A" v0 v2)))
      (if (not (table-lookup? gen)) (snd-display "~A not table-lookup?" gen))
      (if (not (float-vector? (mus-data gen))) (snd-display "mus-data table-lookup: ~A" (mus-data gen)))
      (if (fneq (mus-phase gen) 1.253787) (snd-display "table-lookup phase: ~F?" (mus-phase gen)))
      (set! (mus-phase gen) 1.0)
      (if (fneq (mus-phase gen) 1.0) (snd-display "set! table-lookup phase: ~F?" (mus-phase gen)))
      (if (fneq (mus-frequency gen) 440.0) (snd-display "table-lookup frequency: ~F?" (mus-frequency gen)))
      (set! (mus-frequency gen) 100.0)
      (if (fneq (mus-frequency gen) 100.0) (snd-display "set! table-lookup frequency: ~F?" (mus-frequency gen)))
      (if (or (fneq (v0 1) 0.373) (fneq (v0 8) 1.75)) (snd-display "table-lookup output: ~A" v0))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(if (fneq (v0 i) (v1 i))
	    (snd-display "mus-apply table-lookup at ~D: ~A ~A?" i (v0 i) (v1 i)))))
    
    (let ((gen (make-table-lookup 440.0 :wave (phase-partials->wave (list 1 1 0 2 1 (* pi .5)))))
	  (v0 (make-float-vector 10)))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (table-lookup gen 0.0)))
      (if (or (fneq (v0 1) 1.094) (fneq (v0 8) .421)) (snd-display "table-lookup phase output: ~A" v0))
      (if (or (fneq (float-vector-peak (partials->wave '(1 1 2 1))) 1.76035475730896)
	      (fneq (float-vector-peak (partials->wave '(1 1 2 1) #f #t)) 1.0)
	      (fneq (float-vector-peak (partials->wave '(1 1 2 1 3 1 4 1) #f #t)) 1.0))
	  (snd-display "normalized partials?"))
      (set! (mus-data gen) (phase-partials->wave (list 1 1 0 2 1 (* pi .5)) #f #t)))
    
    (let ((tag (catch #t (lambda () (phase-partials->wave '(1 .3 2 .2))) (lambda args (car args)))))
      (if (not (eq? tag 'wrong-type-arg)) (snd-display "bad length arg to phase-partials->wave: ~A" tag)))
    (let ((tag (catch #t (lambda () (phase-partials->wave '("hiho" .3 2 .2))) (lambda args (car args)))))
      (if (not (eq? tag 'wrong-type-arg)) (snd-display "bad harmonic arg to phase-partials->wave: ~A" tag)))
    (let ((tag (catch #t (lambda () (phase-partials->wave ())) (lambda args (car args)))))
      (if (not (eq? tag 'no-data)) (snd-display "nil list to phase-partials->wave: ~A" tag)))
    
    (do ((vals (phase-partials->wave '(1 1 0) (make-float-vector 16) #f))
	 (i 0 (+ i 1)))
	((= i 16))
      (if (fneq (vals i) (sin (/ (* 2 pi i) 16)))
	  (snd-display "phase-partials->wave 1 1 0 at ~D: ~A ~A" i (vals i) (sin (/ (* 2 pi i) 16)))))
    
    (do ((vals (phase-partials->wave (list 1 1 (* .25 pi)) (make-float-vector 16) #f))
	 (i 0 (+ i 1)))
	((= i 16))
      (if (fneq (vals i) (sin (+ (* .25 pi) (/ (* 2 pi i) 16))))
	  (snd-display "phase-partials->wave 1 1 .25 at ~D: ~A ~A" i (vals i) (sin (+ (* .25 pi) (/ (* 2 pi i) 16))))))
    
    (do ((vals (phase-partials->wave #r(1 1 0 2 1 0) (make-float-vector 16) #f))
	 (i 0 (+ i 1)))
	((= i 16))
      (if (fneq (vals i) (+ (sin (/ (* 2 pi i) 16)) (sin (/ (* 4 pi i) 16))))
	  (snd-display "phase-partials->wave 1 1 0 2 1 0 at ~D: ~A ~A" i (vals i) 
		       (+ (sin (/ (* 2 pi i) 16)) (sin (/ (* 4 pi i) 16))))))
    
    (do ((vals (phase-partials->wave (float-vector 1 1 0 2 1 (* .5 pi)) (make-float-vector 16) #f))
	 (i 0 (+ i 1)))
	((= i 16))
      (if (fneq (vals i) (+ (sin (/ (* 2 pi i) 16)) (sin (+ (* .5 pi) (/ (* 4 pi i) 16)))))
	  (snd-display "phase-partials->wave 1 1 0 2 1 .5 at ~D: ~A ~A" i (vals i) 
		       (+ (sin (/ (* 2 pi i) 16)) (sin (+ (* .5 pi) (/ (* 4 pi i) 16)))))))
    
    (test-gen-equal (make-table-lookup 440.0 :wave (partials->wave #r(1 1 2 1)))
		    (make-table-lookup 440.0 :wave (partials->wave '(1 1 2 1)))
		    (make-table-lookup 100.0 :wave (partials->wave '(1 1 2 1))))
    (test-gen-equal (make-table-lookup 440.0 :wave (partials->wave '(1 1 2 1)))
		    (make-table-lookup 440.0 :wave (partials->wave '(1 1 2 1)))
		    (make-table-lookup 440.0 :wave (partials->wave '(1 1 2 .5))))
    (test-gen-equal (make-table-lookup-with-env 440.0 '(0 0 1 1))
		    (make-table-lookup-with-env 440.0 '(0 0 1 1))
		    (make-table-lookup-with-env 440.0 '(0 0 1 1 2 0)))
    (let ((tag (catch #t (lambda () (partials->wave '(.5 .3 .2))) (lambda args (car args)))))
      (if (not (eq? tag 'bad-type)) (snd-display "odd length arg to partials->wave: ~A" tag)))
    
    (let ((hi (mus-length (make-table-lookup :size 256))))
      (if (not (= hi 256)) (snd-display "table-lookup set length: ~A?" hi)))
    (let ((tag (catch #t (lambda () (make-table-lookup :size 0)) (lambda args (car args)))))
      (if (not (eq? tag 'out-of-range)) (snd-display "table-lookup size 0: ~A" tag)))
    
    (do ((gen (make-table-lookup 440.0 :wave (partials->wave '(1 1))))
	 (incr (/ (* 2 pi 440.0) 22050.0))
	 (i 0 (+ i 1))
	 (a 0.0))
	((= i 1100))
      (let ((val1 (sin a))
	    (val2 (gen 0.0)))
	(if (fneq val1 val2)
	    (snd-display "table lookup (1 1): ~A: ~A ~A" i val1 val2)))
      (set! a (+ a incr)))
    
    (do ((gen (make-table-lookup 4.0 :wave (partials->wave '(1 1))))
	 (incr (/ (* 2 pi 4.0) 22050.0))
	 (i 0 (+ i 1))
	 (a 0.0))
	((= i 1100))
      (let ((val1 (sin a))
	    (val2 (gen 0.0)))
	(if (fneq val1 val2)
	    (snd-display "table lookup (1 1) 4: ~A: ~A ~A" i val1 val2)))
      (set! a (+ a incr)))      
    
    (do ((gen (make-table-lookup 440.0 :wave (partials->wave '(1 .75 3 .25))))
	 (incr (/ (* 2 pi 440.0) 22050.0))
	 (i 0 (+ i 1))
	 (a 0.0))
	((= i 1100))
      (let ((val1 (+ (* .75 (sin a)) (* .25 (sin (* 3 a)))))
	    (val2 (gen 0.0)))
	(if (fneq val1 val2)
	    (snd-display "table lookup (1 .75 3 .25): ~A: ~A ~A" i val1 val2)))
      (set! a (+ a incr)))
    
    (do ((gen (make-table-lookup 0.0 :wave (partials->wave '(1 1))))
	 (gen1 (make-table-lookup 40.0 :wave (partials->wave '(1 1))))
	 (incr (/ (* 2 pi 40.0) 22050.0))
	 (a1 0.0)
	 (i 0 (+ i 1))
	 (a 0.0))
	((= i 100))
      (let ((fm (sin a))
	    (val1 (sin a1))
	    (val2 (table-lookup gen (table-lookup gen1 0.0))))
	(set! a1 (+ a1 fm))
	(if (fneq val1 val2)
	    (snd-display "lookup/lookup fm: ~A: ~A ~A" i val1 val2)))
      (set! a (+ a incr)))
    
    (for-each 
     (lambda (args)
       (let ((type (car args))
	     (vals (cadr args)))
	 (let ((tbl1 (make-table-lookup :frequency 0.0 :size 4 :type type)))
	   (float-vector-set! (mus-data tbl1) 1 1.0)
	   (let ((v (make-float-vector 10)))
	     (do ((i 0 (+ i 1)))
		 ((= i 10))
	       (set! (v i) (table-lookup tbl1 (* .1 pi))))
	     (if (not (or (mus-arrays-equal? v vals)
			  (= type mus-interp-all-pass)
			  (and (= type mus-interp-none)
			       (mus-arrays-equal? v #r(0.000 0.000 0.000 0.000 0.000 0.000 1.000 1.000 1.000 1.000)))))
		 (snd-display "tbl interp ~A: ~A" type v))
	     (if (not (= (mus-interp-type tbl1) type)) (snd-display "tbl interp-type (~A): ~A" type (mus-interp-type tbl1)))))))
     (list 
      (list mus-interp-none #r(0.000 0.000 0.000 0.000 0.000 1.000 1.000 1.000 1.000 1.000))
      (list mus-interp-linear #r(0.000 0.200 0.400 0.600 0.800 1.000 0.800 0.600 0.400 0.200))
      (list mus-interp-lagrange #r(0.000 0.120 0.280 0.480 0.720 1.000 0.960 0.840 0.640 0.360))
      (list mus-interp-all-pass #r(1.000 0.000 0.429 0.143 0.095 0.905 0.397 0.830 0.793 0.912))
      (list mus-interp-hermite #r(0.000 0.168 0.424 0.696 0.912 1.000 0.912 0.696 0.424 0.168))))
    ;; this is different if doubles -- not sure whether it's a bug or not
    
    (let ((size 1000)
	  (test-tbl (lambda (beg end freq amp mc-ratio index)
		      (let ((sine (let ((tbl-size 1024))
				    (do ((v (make-float-vector tbl-size))
					 (xp (/ (* 2 pi) tbl-size))
					 (i 0 (+ i 1))
					 (x 0.0))
					((= i tbl-size) v)
				      (set! (v i) (sin x))
				      (set! x (+ x xp))))))
			(do ((fm (make-table-lookup (* mc-ratio freq) :wave sine))
			     (carrier (make-table-lookup freq :wave sine))
			     (i beg (+ i 1)))
			    ((= i end))
			  (outa i (* amp (table-lookup carrier (* index (table-lookup fm)))))))))
	  
	  (test-fm1 (lambda (beg end freq amp mc-ratio index)
		      (do ((fm (make-oscil (* mc-ratio freq)))
			   (carrier (make-oscil freq))
			   (i beg (+ i 1)))
			  ((= i end))
			(outa i (* amp (oscil carrier (* index (oscil fm)))))))))
      
      (let ((v1 (with-sound ((make-float-vector size) :srate 44100) (test-tbl 0 size 200 1 1 1)))
	    (v2 (with-sound ((make-float-vector size) :srate 44100) (test-fm1 0 size 200 1 1 1))))
	(if (and (not (mus-arrays-equal? v1 v2))
		 (> (float-vector-peak (float-vector-subtract! v1 v2)) .002))
	    (snd-display "fm/tbl peak diff (1 1): ~A" (float-vector-peak (float-vector-subtract! v1 v2)))))
      
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(let ((ratio (+ 1 (random 4)))
	      (index (random 0.1)))
	  (let ((v1 (with-sound ((make-float-vector size) :srate 44100) (test-tbl 0 size 20 1 ratio index)))
		(v2 (with-sound ((make-float-vector size) :srate 44100) (test-fm1 0 size 20 1 ratio index))))
	    (if (and (not (mus-arrays-equal? v1 v2))
		     (> (float-vector-peak (float-vector-subtract! v1 v2)) .002))
		(snd-display "fm/tbl peak diff ~A ~A: ~A" ratio index (float-vector-peak (float-vector-subtract! v1 v2))))))))
    
    
    (let ((gen0 (make-polyshape 440.0 :coeffs (partials->polynomial '(1 1))))
	  (gen (make-polyshape 440.0 :partials '(1 1) :kind mus-chebyshev-first-kind))
	  (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "polyshape"
		       "polyshape freq: 440.000Hz, phase: 0.000, coeffs[2]: [0 1]")
      (if (not (= (mus-length gen) 2)) (snd-display "polyshape length: ~A?" (mus-length gen)))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(let ((val0 (polyshape gen0 1.0 0.0))
	      (val (polyshape gen 1.0 0.0)))
	  (if (fneq val val0) (snd-display "polyshape: ~A is not ~F?" val val0))
	  (set! (v0 i) val)))
      (let ((v1 (make-float-vector 10)))
	(let ((gen1 (make-polyshape 440.0)))
	  (fill-float-vector v1 (if (polyshape? gen1) (polyshape gen1 1.0 0.0) -1.0))
	  (if (not (mus-arrays-equal? v0 v1)) (snd-display "map polyshape: ~A ~A" v0 v1))
	  (set! gen1 (make-polyshape 440.0 :coeffs (partials->polynomial '(1 1))))
	  (fill-float-vector v1 (polyshape gen1 1.0)))
	(if (not (mus-arrays-equal? v0 v1)) (snd-display "1 map polyshape: ~A ~A" v0 v1)))
      (if (not (polyshape? gen)) (snd-display "~A not polyshape?" gen))
      (if (fneq (mus-phase gen) 1.253787) (snd-display "polyshape phase: ~F?" (mus-phase gen)))
      (set! (mus-phase gen) 1.0)
      (if (fneq (mus-phase gen) 1.0) (snd-display "set! polyshape phase: ~F?" (mus-phase gen)))
      (if (fneq (mus-frequency gen) 440.0) (snd-display "polyshape frequency: ~F?" (mus-frequency gen)))
      (set! (mus-frequency gen) 100.0)
      (if (fneq (mus-frequency gen) 100.0) (snd-display "polyshape frequency: ~F?" (mus-frequency gen)))
      (if (not (float-vector? (mus-data gen))) (snd-display "mus-data polyshape: ~A" (mus-data gen)))
      (if (or (fneq (v0 1) 0.992) (fneq (v0 8) 0.538)) (snd-display "polyshape output: ~A" v0))
      (set! (mus-data gen0) (make-float-vector 32))
      (set! (mus-length gen0) 32)
      (if (not (= (mus-length gen0) 32)) (snd-display "set mus-length polyshape: ~A" (mus-length gen0))))
    
    (test-gen-equal (make-polyshape 440.0 :partials '(1 1)) 
		    (make-polyshape 440.0) 
		    (make-polyshape 100.0 :partials '(1 1)))
    (test-gen-equal (make-polyshape 440.0 :partials '(1 1)) 
		    (make-polyshape 440.0)
		    (make-polyshape 440.0 :partials '(1 1 2 .5)))
    (test-gen-equal (make-polyshape 440.0 :partials '(1 1)) 
		    (make-polyshape 440.0 :partials #r(1 1))
		    (make-polyshape 440.0 :partials '(1 .5)))
    (test-gen-equal (make-polyshape 440.0 :partials '(1 .1 2 1 3 .5))
		    (make-polyshape 440.0 :partials #r(1 .1 2 1 3 .5))
		    (make-polyshape 440.0 :partials '(1 .1 2 .1 3 .5)))
    
    (do ((gen (make-polyshape 440.0 :partials '(1 1)))
	 (happy #t)
	 (i 0 (+ i 1)))
	((or (not happy) (= i 1100)))
      (let* ((val1 (cos (mus-phase gen)))
	     (val2 (gen 1.0 0.0)))
	(when (fneq val1 val2)
	  (snd-display "polyshaper (1 1) ~A: ~A ~A" i val1 val2)
	  (set! happy #f))))
    
    (do ((gen (make-polyshape 440.0)) ; check default for partials: '(1 1)
	 (happy #t)
	 (i 0 (+ i 1)))
	((or (not happy)
	     (= i 1100)))
      (let* ((val1 (cos (mus-phase gen)))
	     (val2 (gen 1.0 0.0)))
	(when (fneq val1 val2)
	  (snd-display "polyshaper default: '(1 1) ~A: ~A ~A" i val1 val2)
	  (set! happy #f))))
    
    (do ((gen (make-polyshape 440.0 :partials #r(1 1)))
	 (happy #t)
	 (i 0 (+ i 1)))
	((or (not happy) (= i 1100)))
      (let* ((val1 (* .5 (cos (mus-phase gen))))
	     (val2 (gen 0.5 0.0)))
	(when (fneq val1 val2)
	  (snd-display "polyshaper (1 1) .5 index ~A: ~A ~A" i val1 val2)
	  (set! happy #f))))
    
    (let ((var (catch #t (lambda () (make-polyshape 440.0 :coeffs 3.14)) (lambda args args))))
      (if (not (eq? (car var) 'wrong-type-arg))
	  (snd-display "make-polyshape bad coeffs: ~A" var)))
    
    (do ((gen (make-polyshape 0.0 :coeffs (partials->polynomial '(1 1))))
	 (gen1 (make-polyshape 40.0 :coeffs (partials->polynomial '(1 1))))
	 (a1 0.0)
	 (incr (/ (* 2 pi 40.0) 22050.0))
	 (happy #t)
	 (i 0 (+ i 1))
	 (a 0.0))
	((or (not happy) (= i 400)))
      (let ((fm (cos a))
	    (val1 (cos a1))
	    (val2 (polyshape gen 1.0 (polyshape gen1 1.0))))
	(set! a1 (+ a1 fm))
	(when (> (abs (- val1 val2)) .002)
	  (snd-display "polyshape fm: ~A: ~A ~A" i val1 val2)
	  (set! happy #f)))
      (set! a (+ a incr)))
    
    (for-each 
     (lambda (amps name)
       (let ((data1 (make-float-vector 100))
	     (data2 (make-float-vector 100))
	     (data3 (make-float-vector 100))
	     (n (length amps))
	     (incr (hz->radians 1.0)))
	 (do ((i 0 (+ i 1))
	      (angle 0.0 (+ angle incr)))
	     ((= i 100))
	   (float-vector-set! data1 i (mus-chebyshev-t-sum angle amps)))
	 
	 (do ((k 0 (+ k 1))
	      (kincr 0.0 (+ kincr incr)))
	     ((= k n))
	   (do ((i 0 (+ i 1))
		(angle 0.0 (+ angle kincr)))
	       ((= i 100))
	     (float-vector-set! data3 i (cos angle)))
	   (float-vector-scale! data3 (float-vector-ref amps k))
	   (float-vector-add! data2 data3))
	 
	 (let-temporarily ((*mus-float-equal-fudge-factor* .0001))
	   (if (not (mus-arrays-equal? data1 data2))
	       (snd-display "~A: ~A~%~A~%" name data1 data2)))))
     
     (list #r(0.0 1.0)
	   #r(0.0 0.5 0.25 0.25)
	   (make-float-vector 100 0.01)
	   (make-float-vector 1000 0.001))
     '(one-cos
       three-cos
       hundred-cos
       thousand-cos))
    
    (for-each 
     (lambda (amps name)
       (let ((data1 (make-float-vector 100))
	     (data2 (make-float-vector 100))
	     (data3 (make-float-vector 100))
	     (n (length amps))
	     (incr (hz->radians 1.0)))
	 (do ((i 0 (+ i 1))
	      (angle 0.0 (+ angle incr)))
	     ((= i 100))
	   (float-vector-set! data1 i (mus-chebyshev-u-sum angle amps)))
	 
	 (do ((k 0 (+ k 1))
	      (kincr 0.0 (+ kincr incr)))
	     ((= k n))
	   (do ((i 0 (+ i 1))
		(angle 0.0 (+ angle kincr)))
	       ((= i 100))
	     (float-vector-set! data3 i (sin angle)))
	   (float-vector-scale! data3 (float-vector-ref amps k))
	   (float-vector-add! data2 data3))
	 
	 (let-temporarily ((*mus-float-equal-fudge-factor* .0001))
	   (if (not (mus-arrays-equal? data1 data2))
	       (snd-display "~A: ~A~%~A~%" name data1 data2)))))
     
     (list #r(0.0 1.0)
	   #r(0.0 0.5 0.25 0.25)
	   (make-float-vector 100 0.01)
	   (make-float-vector 1000 0.001))
     '(one-sin
       three-sin
       hundred-sin
       thousand-sin))
    
    (for-each 
     (lambda (camps samps name)
       (let ((data1 (make-float-vector 100))
	     (data2 (make-float-vector 100))
	     (data3 (make-float-vector 100))
	     (n (length camps))
	     (incr (hz->radians 1.0)))
	 (do ((i 0 (+ i 1))
	      (angle 0.0 (+ angle incr)))
	     ((= i 100))
	   (float-vector-set! data1 i (mus-chebyshev-tu-sum angle camps samps)))
	 
	 (do ((k 0 (+ k 1))
	      (kincr 0.0 (+ kincr incr)))
	     ((= k n))
	   (do ((i 0 (+ i 1))
		(angle 0.0 (+ angle kincr)))
	       ((= i 100))
	     (float-vector-set! data3 i (sin angle)))
	   (float-vector-scale! data3 (float-vector-ref samps k))
	   (float-vector-add! data2 data3)
	   (do ((i 0 (+ i 1))
		(angle 0.0 (+ angle kincr)))
	       ((= i 100))
	     (float-vector-set! data3 i (cos angle)))
	   (float-vector-scale! data3 (float-vector-ref camps k))
	   (float-vector-add! data2 data3))
	 
	 (let-temporarily ((*mus-float-equal-fudge-factor* .0001))
	   (if (not (mus-arrays-equal? data1 data2))
	       (snd-display "~A: ~A~%~A~%" name data1 data2)))))
     
     (list #r(0.0 1.0)
	   #r(0.0 0.25 0.0 0.25)
	   (make-float-vector 100 .004)
	   (make-float-vector 1000 0.0005))
     (list #r(0.0 0.0)
	   #r(0.0 0.25 0.25 0.0)
	   (make-float-vector 100 .006)
	   (make-float-vector 1000 0.0005))
     '(one-tu
       three-tu
       hundred-tu
       thousand-tu))
    
    ;; polywave
    (let ((gen (make-polywave 440.0 :partials '(1 1) :type mus-chebyshev-first-kind))
	  (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "polywave"
		       "polywave freq: 440.000Hz, phase: 0.000, coeffs[2]: [0 1]")
      (if (not (= (mus-length gen) 2)) (snd-display "polywave length: ~A?" (mus-length gen)))
      
      (do ((gen0 (make-polywave 440.0 '(1 1)))
	   (i 0 (+ i 1)))
	  ((= i 10))
	(let ((val0 (polywave gen0 0.0))
	      (val (polywave gen 0.0)))
	  (if (fneq val val0) (snd-display "polywave: ~A is not ~F?" val val0))
	  (set! (v0 i) val)))
      (let ((gen1 (make-polywave 440.0))
	    (v1 (make-float-vector 10)))  
	(fill-float-vector v1 (if (polywave? gen1) (polywave gen1 0.0) -1.0))
	(if (not (mus-arrays-equal? v0 v1)) (snd-display "map polywave: ~A ~A" v0 v1))
	(set! gen1 (make-polywave 440.0 #r(1 1)))
	(fill-float-vector v1 (polywave gen1))
	(if (not (mus-arrays-equal? v0 v1)) (snd-display "1 map polywave: ~A ~A" v0 v1)))
      (if (not (polywave? gen)) (snd-display "~A not polywave?" gen))
      (if (fneq (mus-phase gen) 1.253787) (snd-display "polywave phase: ~F?" (mus-phase gen)))
      (set! (mus-phase gen) 1.0)
      (if (fneq (mus-phase gen) 1.0) (snd-display "set! polywave phase: ~F?" (mus-phase gen)))
      (if (fneq (mus-frequency gen) 440.0) (snd-display "polywave frequency: ~F?" (mus-frequency gen)))
      (set! (mus-frequency gen) 100.0)
      (if (fneq (mus-frequency gen) 100.0) (snd-display "polywave frequency: ~F?" (mus-frequency gen)))
      (if (not (float-vector? (mus-data gen))) (snd-display "mus-data polywave: ~A" (mus-data gen)))
      (if (or (fneq (v0 1) 0.992) (fneq (v0 8) 0.538)) (snd-display "polywave output: ~A" v0)))
    
    (test-gen-equal (make-polywave 440.0 :partials '(1 1)) 
		    (make-polywave 440.0) 
		    (make-polywave 100.0 :partials '(1 1)))
    (test-gen-equal (make-polywave 440.0 '(1 1)) 
		    (make-polywave 440.0)
		    (make-polywave 440.0 '(1 1 2 .5)))
    (test-gen-equal (make-polywave 440.0 '(1 1)) 
		    (make-polywave 440.0 #r(1 1))
		    (make-polywave 440.0 '(1 .5)))
    (test-gen-equal (make-polywave 440.0 '(1 .1 2 1 3 .5))
		    (make-polywave 440.0 #r(1 .1 2 1 3 .5))
		    (make-polywave 440.0 '(1 .1 2 .1 3 .5)))
    
    (do ((gen (make-polywave 440.0 '(1 1)))
	 (happy #t)
	 (i 0 (+ i 1)))
	((or (not happy) (= i 1100)))
      (let* ((val1 (cos (mus-phase gen)))
	     (val2 (gen 0.0)))
	(when (fneq val1 val2)
	  (snd-display "polywaver (1 1) ~A: ~A ~A" i val1 val2)
	  (set! happy #f))))
    
    (do ((gen (make-polywave 440.0)) ; check default for partials: '(1 1)
	 (happy #t)
	 (i 0 (+ i 1)))
	((or (not happy) (= i 1100)))
      (let* ((val1 (cos (mus-phase gen)))
	     (val2 (gen 0.0)))
	(when (fneq val1 val2)
	  (snd-display "polywaver default: '(1 1) ~A: ~A ~A" i val1 val2)
	  (set! happy #f))))
    
    (let ((gen (make-polywave 440.0 #r(1 1)))
	  (happy #t))
      (set! (mus-scaler gen) 0.5)
      (do ((i 0 (+ i 1)))
	  ((or (not happy) (= i 1100)))
	(let* ((val1 (* .5 (cos (mus-phase gen))))
	       (val2 (gen 0.0)))
	  (when (fneq val1 val2)
	    (snd-display "polywaver (1 1) .5 index ~A: ~A ~A" i val1 val2)
	    (set! happy #f)))))
    
    (let-temporarily ((*clm-srate* 44100))
      (let ((v0 (make-float-vector 4410))
	    (v1 (make-float-vector 4410)))
	(for-each
	 (lambda (k)
	   (let ((gen (make-polywave 100.0 (list 1 0.5 k 0.5)))
		 (incr (/ (* 2.0 pi 100.0) 44100))
		 (kincr (/ (* 2.0 k pi 100.0) 44100)))
	     (do ((i 0 (+ i 1)))
		 ((= i 4410))
	       (set! (v0 i) (polywave gen)))
	     (do ((i 0 (+ i 1))
		  (ph 0.0 (+ ph incr))
		  (kph 0.0 (+ kph kincr)))
		 ((= i 4410))
	       (float-vector-set! v1 i (+ (cos ph) (cos kph)))))
	   (float-vector-scale! v1 0.5)
	   (if (not (mus-arrays-equal? v0 v1))
	       (snd-display "polywave ~D vs cos: ~A" k (float-vector-peak-and-location (float-vector-subtract! v0 v1)))))
       '(2 19 20 29 30 39 40 60 100)))
      
      (for-each
       (lambda (n)
	 (do ((gen1 (make-polywave 100.0 (list n 1.0)))
	      (gen2 (make-oscil (* n 100.0) (/ pi 2)))
	      (happy #t)
	      (i 0 (+ i 1)))
	     ((or (not happy) (= i 1000)))
	   (let ((val1 (polywave gen1))
		 (val2 (oscil gen2)))
	     (when (fneq val1 val2)
	       (set! happy #f)
	       (snd-display "polywave ~A at ~A: ~A ~A" n i val1 val2)))))
       '(1 8 50 128))
      
      (for-each
       (lambda (n)
	 (do ((gen1 (make-polywave 100.0 (list n 1.0) mus-chebyshev-second-kind))
	      (gen2 (make-oscil (* n 100.0)))
	      (happy #t)
	      (i 0 (+ i 1)))
	     ((or (not happy) (= i 1000)))
	   (let ((val1 (polywave gen1))
		 (val2 (oscil gen2)))
	     (when (fneq val1 val2)
	       (set! happy #f)
	       (snd-display "polywave second ~A at ~A: ~A ~A" n i val1 val2)))))
       '(1 8 50 128))
      
      (for-each
       (lambda (n)
	 (do ((gen1 (make-polyshape 100.0 :partials (list n 1.0)))
	      (gen2 (make-oscil (* n 100.0) (/ pi 2)))
	      (happy #t)
	      (i 0 (+ i 1)))
	     ((or (not happy) (= i 1000)))
	   (let ((val1 (polyshape gen1))
		 (val2 (oscil gen2)))
	     (when (fneq val1 val2)
	       (set! happy #f)
	       (snd-display "polyshape ~A at ~A: ~A ~A" n i val1 val2)))))
       '(1 8 16))
      
      (for-each
       (lambda (n)
	 (do ((gen1 (make-polyshape 100.0 :partials (list n 1.0) :kind mus-chebyshev-second-kind))
	      (gen2 (make-oscil (* n 100.0)))
	      (happy #t)
	      (i 0 (+ i 1)))
	     ((or (not happy) (= i 1000)))
	   (let ((val1 (polyshape gen1))
		 (val2 (oscil gen2)))
	     (when (fneq val1 val2)
	       (set! happy #f)
	       (snd-display "polyshape second ~A at ~A: ~A ~A" n i val1 val2)))))
       '(1 8 16))
      
      (for-each
       (lambda (n)
	 (do ((gen1 (make-polywave 100.0 (list n 1.0) mus-chebyshev-first-kind))
	      (gen2 (make-oscil (* n 100.0) (/ pi 2)))
	      (max-dist 0.0)
	      (i 0 (+ i 1)))
	     ((= i 1000)
	      (if (fneq max-dist 0.0)
		  (snd-display "polywave run ~A: ~A" n max-dist)))
	   (let ((val1 (polywave gen1))
		 (val2 (oscil gen2)))
	     (set! max-dist (max max-dist (abs (- val1 val2)))))))
       '(1 3 30 200))
      
      (for-each
       (lambda (n)
	 (do ((gen1 (make-polywave 100.0 (list n 1.0) mus-chebyshev-second-kind))
	      (gen2 (make-oscil (* n 100.0)))
	      (max-dist 0.0)
	      (i 0 (+ i 1)))
	     ((= i 1000)
	      (if (fneq max-dist 0.0)
		  (snd-display "polywave second run ~A: ~A" n max-dist)))
	   (let ((val1 (polywave gen1))
		 (val2 (oscil gen2)))
	     (set! max-dist (max max-dist (abs (- val1 val2)))))))
       '(1 3 30 200))
      
      (for-each
       (lambda (n)
	 (do ((gen1 (make-polyshape 100.0 :partials (list n 1.0) :kind mus-chebyshev-first-kind))
	      (gen2 (make-oscil (* n 100.0) (/ pi 2)))
	      (max-dist 0.0)
	      (i 0 (+ i 1)))
	     ((= i 1000)
	      (if (fneq max-dist 0.0)
		  (snd-display "polyshape run ~A: ~A" n max-dist)))
	   (let ((val1 (polyshape gen1))
		 (val2 (oscil gen2)))
	     (set! max-dist (max max-dist (abs (- val1 val2)))))))
       '(1 3 25))
      
      (for-each
       (lambda (n)
	 (do ((gen1 (make-polyshape 100.0 :partials (list n 1.0) :kind mus-chebyshev-second-kind))
	      (gen2 (make-oscil (* n 100.0)))
	      (max-dist 0.0)
	      (i 0 (+ i 1)))
	     ((= i 1000)
	      (if (fneq max-dist 0.0)
		  (snd-display "polyshape second run ~A: ~A" n max-dist)))
	   (let ((val1 (polyshape gen1))
		 (val2 (oscil gen2)))
	     (set! max-dist (max max-dist (abs (- val1 val2)))))))
       '(1 3 25))
      
      (let* ((gen (make-polywave 100.0 '(1 .9 3 .1 4 0.0)))
	     (vals (mus-data gen)))
	(if (not (and (float-vector? vals)
		      (mus-arrays-equal? vals #r(0.000 0.900 0.000 0.100 0.00))))
	    (snd-display "polywave mus-data: ~A" vals)
	    (begin
	      (float-vector-set! (mus-data gen) 2 .1)
	      (float-vector-set! (mus-data gen) 3 0.0)
	      (do ((happy #t)
		   (gen1 (make-oscil 100.0 (/ pi 2)))
		   (gen2 (make-oscil 200.0 (/ pi 2)))
		   (i 0 (+ i 1)))
		  ((or (not happy) (= i 1000)))
		(let ((val1 (polywave gen))
		      (val2 (+ (* .9 (oscil gen1))
			       (* .1 (oscil gen2)))))
		  (when (fneq val1 val2)
		    (set! happy #f)
		    (snd-display "polywave set mus-data at ~A: ~A ~A" i val1 val2))))))))
    ;; check dc 
    (do ((i 2 (+ i 1)))
	((= i 7))
      (do ((cfs (make-list (* 2 i) 0.1))
	   (k 0 (+ k 2)))
	  ((>= k (length cfs))
	   (let ((val (polywave (make-polywave 100.0 cfs mus-chebyshev-second-kind))))
	     (if (fneq val 0.1)
		 (snd-display "polywave ~D order second 0-coeff: ~A" i val))))
	(set! (cfs k) (/ k 2))))
      
    (do ((i 2 (+ i 1)))
	((= i 7))
      (let ((cfs (make-list (* 2 i) 0.1)))
	(do ((k 0 (+ k 2)))
	    ((>= k (length cfs)))
	  (set! (cfs k) (/ k 2)))
	(let ((val (polywave (make-polywave 100.0 cfs mus-chebyshev-first-kind))))
	  (if (fneq val (* 0.1 i))
	      (snd-display "polywave ~D order first 0-coeff: ~A" i val)))))

    (let ((var (catch #t (lambda () (make-polywave 440.0 3.14)) (lambda args args))))
      (if (not (eq? (car var) 'wrong-type-arg))
	  (snd-display "make-polywave bad coeffs: ~A" var)))
    
    (let ((gen (make-wave-train 440.0 0.0 (make-float-vector 20)))
	  (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "wave-train"
		       "wave-train freq: 440.000Hz, phase: 0.000, size: 20, interp: linear")
      (let ((gen1 (make-wave-train 440.0 0.0 (make-float-vector 20)))
	    (v1 (make-float-vector 10)))
	(do ((i 0 (+ i 1)))
	    ((= i 20))
	  (float-vector-set! (mus-data gen) i (* i .5))
	  (float-vector-set! (mus-data gen1) i ((mus-data gen) i)))
	(if (not (= (length (mus-data gen)) 20)) (snd-display "wave-train data length: ~A?" (length (mus-data gen))))
	(if (not (= (mus-length gen) 20)) (snd-display "wave-train length: ~A?" (mus-length gen)))
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (set! (v0 i) (wave-train gen 0.0)))
	(fill-float-vector v1 (if (wave-train? gen1) (wave-train gen1) -1.0))
	(if (not (mus-arrays-equal? v0 v1)) (snd-display "map wave-train: ~A ~A" v0 v1)))
      (if (not (wave-train? gen)) (snd-display "~A not wave-train?" gen))
      (if (fneq (mus-phase gen) 0.0) (snd-display "wave-train phase: ~F?" (mus-phase gen)))
      (set! (mus-phase gen) 1.0)
      (if (fneq (mus-phase gen) 1.0) (snd-display "set wave-train phase: ~F?" (mus-phase gen)))
      (if (fneq (mus-frequency gen) 440.0) (snd-display "wave-train frequency: ~F?" (mus-frequency gen)))
      (set! (mus-frequency gen) 100.0)
      (if (fneq (mus-frequency gen) 100.0) (snd-display "set wave-train freq: ~A" (mus-frequency gen)))
      (if (or (fneq (v0 1) 0.5) (fneq (v0 8) 4.0)) (snd-display "wave-train output: ~A" v0))
      (mus-reset gen)
      (if (fneq (mus-phase gen) 0.0) (snd-display "wt reset phase: ~A" (mus-phase gen)))
      (let ((val (wave-train gen 0.0)))
	(if (fneq val 0.0) (snd-display "wt reset data: ~A" val)))
      (if (not (float-vector? (mus-data gen))) (snd-display "mus-data wave-train: ~A" (mus-data gen)))
      (set! (mus-data gen) (make-float-vector 3)))
    
    (test-gen-equal (make-wave-train 440.0 0.0 (make-float-vector 20)) (make-wave-train 440.0 0.0 (make-float-vector 20)) (make-wave-train 100.0 0.0 (make-float-vector 20)))
    (test-gen-equal (make-wave-train 440.0 0.0 (make-float-vector 20)) (make-wave-train 440.0 0.0 (make-float-vector 20)) (make-wave-train 440.0 1.0 (make-float-vector 20)))
    
    (test-gen-equal (make-wave-train-with-env 440.0 '(0 0 1 1))
		    (make-wave-train-with-env 440.0 (list 0 0 1 1))
		    (make-wave-train-with-env 440.0 '(0 0 1 1 2 0)))
    
    (let ((hi (make-wave-train :size 256)))
      (if (not (= (mus-length hi) 256)) (snd-display "wave-train set length: ~A?" (mus-length hi)))
      (set! (mus-length hi) 128)
      (if (not (= (mus-length hi) 128)) (snd-display "set wave-train set length: ~A?" (mus-length hi))))
    
    (for-each 
     (lambda (args)
       (let ((type (car args))
	     (vals (cadr args)))
	 (let ((tbl1 (make-wave-train :frequency 3000.0 :initial-phase (/ (* 2.0 pi .2) 4) :size 4 :type type)))
	   (float-vector-set! (mus-data tbl1) 1 1.0)
	   (let ((v (make-float-vector 10)))
	     (do ((i 0 (+ i 1)))
		 ((= i 10))
	       (set! (v i) (wave-train tbl1 0.0))) ;(wave-train tbl1 (/ (* 2 pi .2) 4))))
	     (if (not (mus-arrays-equal? v vals))
		 (snd-display "wt tbl interp ~A: ~A ~A" type v (mus-describe tbl1)))
	     (if (not (= (mus-interp-type tbl1) type)) (snd-display "wt tbl interp-type (~A): ~A" type (mus-interp-type tbl1)))))))
     (list 
      (list mus-interp-none #r(0.000 1.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 1.000))
      (list mus-interp-linear #r(0.200 0.800 0.000 0.000 0.000 0.000 0.000 0.000 0.200 0.800))
      (list mus-interp-lagrange #r(0.120 0.960 -0.080 0.000 0.000 0.000 0.000 0.000 0.120 0.960))
      (list mus-interp-hermite #r(0.168 0.912 -0.064 -0.016 0.000 0.000 0.000 0.000 0.168 0.912))))
    
    (let ((tag (catch #t (lambda () (make-wave-train :size 0)) (lambda args (car args)))))
      (if (not (eq? tag 'out-of-range)) (snd-display "wave-train size 0: ~A" tag)))
    
    (let ((ind (new-sound "fmv.snd" :size 10 :comment "line 20501")))
      (if (not (= (framples) 10)) (snd-display "new-sound size(10): ~A" (framples)))
      (map-channel (lambda (y) 1.0) 7 8)
      (if (not (= (framples) 15)) (snd-display "map-channel 7 8: ~A" (framples)))
      (map-channel (lambda (y) 1.0))
      (if (not (= (framples) 15)) (snd-display "map-channel (no dur): ~A" (framples)))
      (revert-sound ind)
      (map-channel (lambda (y) 1.0) 9 10)
      (if (not (= (framples) 19)) (snd-display "map-channel 9 10: ~A" (framples)))
      (if (> (edit-position ind 0) 2) (snd-display "map-channel pad edits: ~A" (edit-position ind 0)))
      (revert-sound ind)
      (map-channel (lambda (y) 1.0) 10 10)
      (if (not (= (framples) 20)) (snd-display "map-channel 10 10: ~A" (framples)))
      (if (> (edit-position ind 0) 2) (snd-display "map-channel pad edits (2): ~A" (edit-position ind 0)))
      (revert-sound ind)
      (map-channel (lambda (y) 1.0) 20 10)
      (if (not (= (framples) 30)) (snd-display "map-channel 20 10: ~A" (framples)))
      (if (> (edit-position ind 0) 2) (snd-display "map-channel pad edits (3): ~A" (edit-position ind 0)))
      (revert-sound ind)
      (if (scan-channel (lambda (y) #f) 30 10) (snd-display "scan-channel past end?"))
      (clean-up-sound ind))
    
    (let ((ind (new-sound :size 1000))
	  (gen (make-wave-train 1000.0 :wave #r(0.0 .1 .2 .3 .4 .5 .6))))
      (map-channel (lambda (y) (wave-train gen)))
      (let ((mx (maxamp)))
	(if (fneq mx 0.6) (snd-display "wt 0 max: ~A" mx)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30) 
		       #r(0.000 0.100 0.200 0.300 0.400 0.500 0.600 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 
				     0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.100 0.200 0.300 0.400 0.500 0.600)))
	  (snd-display "wt 0 data: ~A" (channel->float-vector 0 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 85 30) 
		       #r(0.000 0.000 0.000 0.000 0.000 0.100 0.200 0.300 0.400 0.500 0.600 0.000 0.000 0.000 0.000 
				     0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.100 0.200 0.300)))
	  (snd-display "wt 0 data 85: ~A" (channel->float-vector 85 30)))
      (undo)
      
      (let ((gen (make-wave-train 1000.0 :initial-phase pi :wave (make-float-vector 10 .1)))) ; initial-phase is confusing in this context!
	(map-channel (lambda (y) (wave-train gen))))
      (let ((mx (maxamp)))
	(if (fneq mx 0.1) (snd-display "wt 1 max: ~A" mx)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30) 
		       #r(0.100 0.100 0.100 0.100 0.100 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 
				     0.000 0.000 0.000 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.000 0.000)))
	  (let-temporarily ((*print-length* 32))
	    (snd-display "wt 1 data: ~A" (channel->float-vector 0 30))))
      (undo)
      
      (let ((gen (make-wave-train 2000.0 :wave (make-float-vector 10 .1))))
	(map-channel (lambda (y) (wave-train gen))))
      (let ((mx (maxamp)))
	(if (fneq mx 0.1) (snd-display "wt 2 max: ~A" mx)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30) 
		       #r(0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.000 0.000 0.100 0.100 0.100 
				     0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.000 0.100 0.100 0.100 0.100 0.100 0.100 0.100)))
	  (snd-display "wt 2 data: ~A" (channel->float-vector 0 30)))
      (if (not (or (mus-arrays-equal? (channel->float-vector 440 30) 
			   #r(0.000 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.000 0.000 0.100 0.100 
					 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.000 0.100 0.100 0.100 0.100 0.100 0.100))
		   ;; if double, round off is just enough different to cause an off-by-1 problem here (and below)
		   (mus-arrays-equal? (channel->float-vector 440 30) 
			   #r(0.000 0.000 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.000 0.100 0.100 
					 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.000 0.100 0.100 0.100 0.100 0.100 0.100))))
	  (snd-display "wt 2 data 440: ~A" (channel->float-vector 440 30)))
      (undo)
      
      (let ((gen (make-wave-train 3000.0 :wave (make-float-vector 10 .1))))
	(map-channel (lambda (y) (wave-train gen))))
      (let ((mx (maxamp)))
	(if (fneq mx 0.2) (snd-display "wt 3 max: ~A" mx)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30) 
		       #r(0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.200 0.200 0.100 0.100 0.100 0.100 0.100 
				     0.200 0.200 0.200 0.100 0.100 0.100 0.100 0.100 0.200 0.200 0.100 0.100 0.100 0.100 0.100)))
	  (snd-display "wt 3 data: ~A" (channel->float-vector 0 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 440 30) 
		       #r(0.100 0.200 0.200 0.200 0.100 0.100 0.100 0.100 0.100 0.200 0.200 0.100 0.100 0.100 0.100 
				     0.100 0.200 0.200 0.200 0.100 0.100 0.100 0.100 0.100 0.200 0.200 0.100 0.100 0.100 0.100)))
	  (snd-display "wt 3 data 440: ~A" (channel->float-vector 440 30)))
      (undo)
      
      (let ((gen (make-wave-train 5000.0 :wave (make-float-vector 10 .1))))
	(map-channel (lambda (y) (wave-train gen))))
      (let ((mx (maxamp)))
	(if (fneq mx 0.3) (snd-display "wt 4 max: ~A" mx)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30) 
		       #r(0.100 0.100 0.100 0.100 0.100 0.200 0.200 0.200 0.200 0.300 0.200 0.200 0.200 0.200 0.300 
				     0.200 0.200 0.200 0.300 0.200 0.200 0.200 0.200 0.300 0.200 0.200 0.200 0.300 0.200 0.200)))
	  (snd-display "wt 4 data: ~A" (channel->float-vector 0 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 440 30) 
		       #r(0.200 0.200 0.300 0.200 0.200 0.200 0.300 0.200 0.200 0.200 0.300 0.300 0.200 0.200 0.200 
				     0.300 0.200 0.200 0.200 0.300 0.200 0.200 0.200 0.200 0.300 0.200 0.200 0.200 0.300 0.200)))
	  (snd-display "wt 4 data 440: ~A" (channel->float-vector 440 30)))
      (undo)
      
      (let ((gen (make-wave-train 1000.0 :wave (make-float-vector 10 .1))))
	(let ((base-freq (mus-frequency gen))
	      (e (make-env '(0 1 1 2) :length 1001)))
	  (map-channel 
	   (lambda (y) 
	     (let ((result (wave-train gen)))
	       (set! (mus-frequency gen) (* base-freq (env e)))
	       result)))))
      (let ((mx (maxamp)))
	(if (fneq mx 0.1) (snd-display "wt 5 max: ~A" mx)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30) 
				  #r(0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.000 0.000 0.000 0.000 0.000 
						0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.100 0.100 0.100 0.100 0.100 0.100 0.100)))
	  (snd-display "wt 5 data: ~A" (channel->float-vector 0 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 440 30) 
				  #r(0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.000 0.000 0.000 0.000 0.000 0.000 0.100 
						0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.000 0.000 0.000 0.000 0.000 0.100)))
	  (snd-display "wt 5 data 440: ~A" (channel->float-vector 440 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 900 30) 
				  #r(0.100 0.000 0.000 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.000 0.100 
						0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.000 0.000 0.100 0.100 0.100 0.100)))
	  (snd-display "wt 5 data 900: ~A" (channel->float-vector 900 30)))
      (undo)
      
      (let ((gen (make-wave-train 500.0 :wave (make-float-vector 10 .1)))
	    (ctr 0))
	(map-channel 
	 (lambda (y) 
	   (let ((result (wave-train gen)))
	     (if (> ctr 22)
		 (begin
		   (set! ctr 0)
		   (float-vector-scale! (mus-data gen) 1.05))
		 (set! ctr (+ ctr 1)))
	     result))))
      (let ((mx (maxamp)))
	(if (fneq mx 0.704) (snd-display "wt 6 max: ~A" mx)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30) 
		       #r(0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.000 0.000 0.000 0.000 0.000 
				     0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "wt 6 data: ~A" (channel->float-vector 0 30)))
      (if (not (or (mus-arrays-equal? (channel->float-vector 440 30) 
			   #r(0.000 0.241 0.241 0.241 0.241 0.241 0.241 0.241 0.241 0.241 0.241 0.000 0.000 0.000 0.000
					 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000))
		   (mus-arrays-equal? (channel->float-vector 440 30) 
			   #r(0.000 0.000 0.241 0.241 0.241 0.241 0.241 0.241 0.241 0.241 0.241 0.241 0.000 0.000 0.000 0.000
					 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000))))
	  (snd-display "wt 6 data 440: ~A" (channel->float-vector 440 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 900 30) 
		       #r(0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 
				     0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.639 0.639 0.639)))
	  (snd-display "wt 6 data 900: ~A" (channel->float-vector 900 30)))
      (undo)
      (let ((fname (file-name ind)))
	(close-sound ind)
	(delete-file fname)))
    
    (let ((gen (make-readin "oboe.snd" 0 1490))
	  (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "readin"
		       "readin oboe.snd[chan 0], loc: 1490, dir: 1")
      (let ((gen1 (make-readin "oboe.snd" 0 1490))
	    (v1 (make-float-vector 10)))
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (set! (v0 i) (readin gen)))
	(fill-float-vector v1 (if (readin? gen1) 
				  (if (= (mus-channel gen1) 0) 
				      (readin gen1) 
				      1.0) 
				  (if (string=? (mus-file-name gen1) "oboe.snd")
				      -1.0
				      1.0)))
	(if (not (mus-arrays-equal? v0 v1)) (snd-display "map readin: ~A ~A" v0 v1)))
      (if (not (readin? gen)) (snd-display "~A not readin?" gen))
      (if (not (mus-input? gen)) (snd-display "~A not input?" gen))
      (if (not (= (mus-length gen) 50828)) (snd-display "readin length: ~A?" (mus-length gen)))
      (if (not (= (mus-channel gen) 0)) (snd-display "readin chan: ~A?" (mus-channel gen)))
      (if (not (string=? (mus-file-name gen) "oboe.snd")) (snd-display "readin mus-file-name: ~A" (mus-file-name gen)))
      (if (or (fneq (v0 1) -0.009) (fneq (v0 7) .029)) (snd-display "readin output: ~A" v0))
      (set! (mus-location gen) 1000)
      (if (not (= (mus-location gen) 1000)) (snd-display "set! mus-location: ~A?" (mus-location gen)))
      (let ((val (readin gen)))
	(if (fneq val 0.033) (snd-display "set! mus-location readin: ~A?" val)))
      (set! (mus-increment gen) -1)
      (if (fneq (mus-increment gen) -1.0) (snd-display "set increment readin: ~A" (mus-increment gen))))
    (let ((tag (catch #t (lambda () (make-readin "/baddy/hiho" 0 124)) (lambda args args))))
      (if (not (eq? (car tag) 'no-such-file)) (snd-display "make-readin w/o file: ~A" tag)))
    (let ((tag (catch #t (lambda () (make-readin "oboe.snd" 123 124)) (lambda args args))))
      (if (not (eq? (car tag) 'out-of-range)) (snd-display "make-readin with bad chan: ~A" tag)))
    
    (test-gen-equal (make-readin "oboe.snd" 0) (make-readin "oboe.snd" 0) (make-readin "oboe.snd" 0 1230))
    (test-gen-equal (make-readin "oboe.snd" 0 :size 512) (make-readin "oboe.snd" 0 :size 512) (make-readin "pistol.snd" 0 :size 512))
    (test-gen-equal (make-readin "2.snd" 1) (make-readin "2.snd" 1) (make-readin "2.snd" 0))
    
    (let ((gen (make-readin "2.snd" 1 :size 1024))
	  (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "readin"
		       "readin 2.snd[chan 1], loc: 0, dir: 1")
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (readin gen)))
      (if (not (= (mus-channel gen) 1)) (snd-display "readin chan 1: ~A?" (mus-channel gen)))
      (if (or (fneq (v0 1) 0.010) (fneq (v0 7) -.006)) (snd-display "readin 1 output: ~A" v0))
      (print-and-check gen 
		       "readin"
		       "readin 2.snd[chan 1], loc: 10, dir: 1"))
    
    (let ((gen (make-file->sample "oboe.snd"))
	  (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "file->sample"
		       "file->sample \"oboe.snd\"")
      (if (not (mus-input? gen)) (snd-display "~A not input?" gen))
      (if (not (= (mus-length gen) 50828)) (snd-display "file->sample length: ~A?" (mus-length gen)))
      (if (not (string=? (mus-file-name gen) "oboe.snd")) (snd-display "file->sample mus-file-name: ~A" (mus-file-name gen)))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (file->sample gen (+ 1490 i))))
      (if (not (file->sample? gen)) (snd-display "~A not file->sample?" gen))
      (if (or (fneq (v0 1) -0.009) (fneq (v0 7) .029)) (snd-display "file->sample output: ~A" v0))
      (if (fneq (mus-increment gen) 0.0) (snd-display "file->sample increment: ~A" (mus-increment gen)))
      (set! (mus-increment gen) 1.0)
      (if (fneq (mus-increment gen) 1.0) (snd-display "file->sample set increment: ~A" (mus-increment gen)))
      (mus-reset gen)) ; a no-op I hope
    
    (let* ((ind (open-sound "oboe.snd"))
	   (gen (make-snd->sample ind))
	   (gen1 (make-snd->sample ind))
	   (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "snd->sample"
		       "snd->sample reading oboe.snd (1 chan) at 0:[no readers]")
      (if (equal? gen gen1) (snd-display "snd->sample eq? not itself?"))
      (if (not (mus-input? gen)) (snd-display "snd->sample ~A not input?" gen))
      (if (not (= (framples ind) (mus-length gen))) (snd-display "snd->sample len: ~A ~A" (framples ind) (mus-length gen)))
      (if (not (string=? (mus-file-name gen) (string-append cwd "oboe.snd")))
	  (snd-display "snd->sample mus-file-name: ~A ~A" (mus-file-name gen) (string-append cwd "oboe.snd")))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (snd->sample gen (+ 1490 i))))
      (if (not (snd->sample? gen)) (snd-display "~A not snd->sample?" gen))
      (if (or (fneq (v0 1) -0.009) (fneq (v0 7) .029)) (snd-display "snd->sample output: ~A" v0))
      (if (not (= (mus-channels gen) 1)) (snd-display "snd->sample channels: ~A" (mus-channels gen)))
      (if (not (= (mus-location gen) 1499)) (snd-display "snd->sample location: ~A" (mus-location gen)))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (ina (+ 1490 i) gen)))
      (if (or (fneq (v0 1) -0.009) (fneq (v0 7) .029)) (snd-display "snd->sample ina output: ~A" v0))
      (close-sound ind))
    
    (let* ((ind (open-sound "2.snd"))
	   (gen (make-snd->sample ind)))
      (do ((v0 (make-float-vector 10))
	   (i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (snd->sample gen (+ 1490 i) 0))
	(set! (v0 i) (snd->sample gen (+ 1490 i) 1)))
      (print-and-check gen 
		       "snd->sample"
		       "snd->sample reading 2.snd (2 chans) at 1499:[#<sampler: 2.snd[0: 0] from 1490, at 1500, forward>, #<sampler: 2.snd[1: 0] from 1490, at 1500, forward>]")
      (if (not (mus-input? gen)) (snd-display "snd->sample ~A not input?" gen))
      (if (not (string=? (mus-file-name gen) (string-append cwd "2.snd")))
	  (snd-display "snd->sample mus-file-name: ~A ~A" (mus-file-name gen) (string-append cwd "2.snd")))
      (if (not (snd->sample? gen)) (snd-display "~A not snd->sample?" gen))
      (if (not (= (mus-channels gen) 2)) (snd-display "snd->sample channels (2): ~A" (mus-channels gen)))
      (if (not (= (mus-location gen) 1499)) (snd-display "snd->sample location (2): ~A" (mus-location gen)))
      (close-sound ind))
    
    (let ((gen (make-file->frample "oboe.snd"))
	  (v0 (make-float-vector 10))
	  (g1 #r(0.0)))
      (print-and-check gen 
		       "file->frample"
		       "file->frample \"oboe.snd\""
		       "file->frample \"oboe.snd\"")
      (if (not (mus-input? gen)) (snd-display "~A not input?" gen))
      (if (not (= (mus-length gen) 50828)) (snd-display "file->frample length: ~A?" (mus-length gen)))
      (if (not (string=? (mus-file-name gen) "oboe.snd")) (snd-display "file->frample mus-file-name: ~A" (mus-file-name gen)))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) ((file->frample gen (+ 1490 i) g1) 0)))
      (if (not (file->frample? gen)) (snd-display "~A not file->frample?" gen))
      (if (or (fneq (v0 1) -0.009) (fneq (v0 7) .029)) (snd-display "file->frample output: ~A" v0)))
    
    (if (file-exists? "fmv.snd") (delete-file "fmv.snd"))
    (if (file-exists? "fmv1.snd") (delete-file "fmv1.snd"))
    (if (file-exists? "fmv2.snd") (delete-file "fmv2.snd"))
    (if (file-exists? "fmv3.snd") (delete-file "fmv3.snd"))
    (let ((gen (make-sample->file "fmv.snd" 2 mus-lshort mus-riff)))
      (print-and-check gen 
		       "sample->file"
		       "sample->file \"fmv.snd\"")
      (if (not (mus-output? gen)) (snd-display "~A not output?" gen))
      (if (not (sample->file? gen)) (snd-display "~A not sample->file?" gen))
      (if (not (= (mus-length gen) *clm-file-buffer-size*)) (snd-display "sample->file length: ~A?" (mus-length gen)))
      (if (not (string=? (mus-file-name gen) "fmv.snd")) (snd-display "sample->file mus-file-name: ~A" (mus-file-name gen)))
      (do ((i 0 (+ i 1)))
	  ((= i 100))
	(sample->file gen i 0 (* i .001))
	(sample->file gen i 1 (* i .01)))
      (outa 50 .015 gen)
      (outb 50 .15 gen)
      (out-any 60 .015 0 gen)
      (out-any 60 .15 1 gen)
      (mus-close gen))
    (let* ((gen (make-file->sample "fmv.snd"))
	   (val0 (in-any 20 0 gen))
	   (val1 (in-any 20 1 gen))
	   (val2 (ina 30 gen))
	   (val3 (inb 30 gen))
	   (val4 (file->sample gen 40 0))
	   (val5 (file->sample gen 40 1))
	   (val6 (in-any 50 0 gen))
	   (val7 (in-any 50 1 gen))
	   (val8 (in-any 60 0 gen))
	   (val9 (in-any 60 1 gen)))
      (print-and-check gen 
		       "file->sample"
		       "file->sample \"fmv.snd\"")
      (if (not (= (mus-channels gen) 2)) (snd-display "make-sample->file chans: ~A?" (mus-channels gen)))
      (if (not (mus-input? gen)) (snd-display "~A not input?" gen))
      (if (or (fneq val0 .02) (fneq val1 .2)) (snd-display "in-any: ~A ~A?" val0 val1))
      (if (or (fneq val2 .03) (fneq val3 .3)) (snd-display "inab: ~A ~A?" val2 val3))
      (if (or (fneq val4 .04) (fneq val5 .4)) (snd-display "sample->file: ~A ~A?" val4 val5))
      (if (or (fneq val6 .065) (fneq val7 .65)) (snd-display "outab: ~A ~A?" val6 val7))
      (if (or (fneq val8 .075) (fneq val9 .75)) (snd-display "out-any: ~A ~A?" val8 val9)))
    
    (let ((gen (make-float-vector 10)))
      (do ((i 0 (+ i 1))
	   (x 0.0 (+ x 0.1)))
	  ((= i 10))
	(outa i x gen))
      (if (not (mus-arrays-equal? gen #r(0 .1 .2 .3 .4 .5 .6 .7 .8 .9)))
	  (snd-display "outa->float-vector ramp: ~A" gen))
      (do ((i 0 (+ i 1))
	   (x 0.0 (+ x 0.1)))
	  ((= i 10))
	(outa i x gen))
      (if (not (mus-arrays-equal? gen (float-vector-scale! #r(0 .1 .2 .3 .4 .5 .6 .7 .8 .9) 2.0)))
	  (snd-display "outa->float-vector ramp 2: ~A" gen))
      (if (not (= (mus-channels gen) 1)) (snd-display "mus-channels float-vector: ~A" (mus-channels gen))))
    
    (let ((gen (make-float-vector '(4 100))))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(outa i .1 gen)
	(outb i .2 gen)
	(outc i .3 gen)
	(outd i .4 gen))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(outa i .01 gen)
	(outb i .02 gen)
	(outc i .03 gen)
	(outd i .04 gen))
      (mus-close gen) ; should be a no-op
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(if (or (fneq (ina i gen) .11)
		(fneq (inb i gen) .22)
		(fneq (in-any i 2 gen) .33)
		(fneq (in-any i 3 gen) .44))
	    (snd-display "4-chan sd out/in[~A]: ~A ~A ~A ~A?" i (ina i gen) (inb i gen) (in-any i 2 gen) (in-any i 3 gen))))  
      (if (not (= (mus-channels gen) 4)) (snd-display "mus-channels sd 4: ~A" (mus-channels gen))))
    
    (let ((gen (make-float-vector '(4 100))))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(out-any i .1 0 gen)
	(out-any i .2 1 gen)
	(out-any i .3 2 gen)
	(out-any i .4 3 gen))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(out-any i .01 0 gen)
	(out-any i .02 1 gen)
	(out-any i .03 2 gen)
	(out-any i .04 3 gen))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(if (or (fneq (in-any i 0 gen) .11)
		(fneq (in-any i 1 gen) .22)
		(fneq (in-any i 2 gen) .33)
		(fneq (in-any i 3 gen) .44))
	    (snd-display "4-chan sd out/in-any[~A]: ~A ~A ~A ~A?" i (in-any i 0 gen) (in-any i 1 gen) (in-any i 2 gen) (in-any i 3 gen)))))
    
    (let ((tag (catch #t (let ((gen (make-oscil 440.0)))
			   (lambda () (outa 0 .1 gen)))
		      (lambda args (car args)))))
      (if (not (memq tag '(wrong-type-arg mus-error)))
	  (snd-display "outa -> oscil: ~A" tag)))
    
    (let ((gen (make-sample->file "fmv.snd" 4 mus-lshort mus-riff)))
      (print-and-check gen 
		       "sample->file"
		       "sample->file \"fmv.snd\"")
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(outa i .1 gen)
	(outb i .2 gen)
	(outc i .3 gen)
	(outd i .4 gen))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(outa i .01 gen)
	(outb i .02 gen)
	(outc i .03 gen)
	(outd i .04 gen))
      (mus-close gen))
    (let ((gen (make-file->sample "fmv.snd")))
      (print-and-check gen 
		       "file->sample"
		       "file->sample \"fmv.snd\"")
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(if (or (fneq (ina i gen) .11)
		(fneq (inb i gen) .22)
		(fneq (in-any i 2 gen) .33)
		(fneq (in-any i 3 gen) .44))
	    (snd-display "4-chan out/in[~A]: ~A ~A ~A ~A?" i (ina i gen) (inb i gen) (in-any i 2 gen) (in-any i 3 gen)))))
    
    (let ((gen (make-sample->file "fmv.snd" 4 mus-lshort mus-riff)))
       (do ((i 0 (+ i 1)))
	   ((= i 10))
	 (outa i .1 gen)
	 (outb i .2 gen)
	 (outc i .3 gen)
	 (outd i .4 gen))
       (do ((i 0 (+ i 1)))
	   ((= i 10))
	 (outa i .01 gen)
	 (outb i .02 gen)
	 (outc i .03 gen)
	 (outd i .04 gen))
      (mus-close gen))
    (let ((gen (make-file->sample "fmv.snd")))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(if (or (fneq (ina i gen) .11)
		(fneq (inb i gen) .22)
		(fneq (in-any i 2 gen) .33)
		(fneq (in-any i 3 gen) .44))
	    (snd-display "4-chan out/in[~A]: ~A ~A ~A ~A?" i (ina i gen) (inb i gen) (in-any i 2 gen) (in-any i 3 gen)))))
    
    (let ((var (catch #t (lambda () (make-sample->file "fmv.snd" -1 mus-lshort mus-next)) (lambda args args))))
      (if (not (eq? (car var) 'out-of-range))
	  (snd-display "make-sample->file bad chans: ~A" var)))
    (let ((var (catch #t (lambda () (mus-location (make-oscil))) (lambda args args))))
      (if (not (and (pair? var) (eq? (car var) 'mus-error)))
	  (snd-display "mus-location oscil: ~A" var)))
    (let ((var (catch #t (lambda () (make-sample->file "fmv.snd" 1 -1 mus-next)) (lambda args args))))
      (if (not (eq? (car var) 'out-of-range))
	  (snd-display "make-sample->file bad format: ~A" var)))
    (let ((var (catch #t (lambda () (make-sample->file "fmv.snd" 1 mus-lshort -1)) (lambda args args))))
      (if (not (eq? (car var) 'out-of-range))
	  (snd-display "make-sample->file bad type: ~A" var)))
    
    (do ((v (vector 1.0 0.5 0.25 0.125 0.0))
	 (v1 (make-float-vector 5))
	 (i 0 (+ i 1)))
	((= i 5)
	 (if (not (mus-arrays-equal? v1 #r(1.0 0.5 0.25 0.125 0.0)))
	     (snd-display "vector in-any -> ~A?" v1)))
      (set! (v1 i) (in-any i 0 v)))
    
    (let ((invals (make-float-vector 10)))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(float-vector-set! invals i (* i 0.1)))
      (let ((result (with-sound ((make-float-vector 10))
				(do ((i 0 (+ i 1)))
				    ((= i 10))
				  (outa i (ina i invals))))))
	(if (not (mus-arrays-equal? result #r(0.000 0.100 0.200 0.300 0.400 0.500 0.600 0.700 0.800 0.900)))
	    (snd-display "ina from float-vector: ~A" result))))
    
    (let ((invals (make-float-vector 10)))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(float-vector-set! invals i (* i 0.1)))
      (let ((result (with-sound ((make-float-vector 10))
				 (do ((i 0 (+ i 1)))
				     ((= i 10))
				   (outa i (ina i invals))))))
	(if (not (mus-arrays-equal? result #r(0.000 0.100 0.200 0.300 0.400 0.500 0.600 0.700 0.800 0.900)))
	    (snd-display "run ina from float-vector: ~A" result))))
    
    (for-each close-sound (sounds))
    
    (let ((vals (float-vector-peak (with-sound ((make-float-vector 4410))
				     (fm-violin 0 .1 440 .1)))))
      (if (fneq vals .1)
	  (snd-display "locsig to float-vector fm-violin peak: ~A" vals)))
    
    (let ((mxs (maxamp (with-sound ((make-float-vector '(2 4410)))
			  (fm-violin 0 .1 440 .1 :degree 30)))))
      (if (fneq mxs 0.0666)
	  (snd-display "locsig to sound-data fm-violin peak: ~A" mxs)))
        
    (let ((gen (make-sample->file "fmv2.snd" 4 mus-bshort mus-aifc)))
      (print-and-check gen 
		       "sample->file"
		       "sample->file \"fmv2.snd\"")
      (if (not (mus-output? gen)) (snd-display "~A not output?" gen))
      (if (not (sample->file? gen)) (snd-display "~A not sample->file?" gen))
      (do ((i 0 (+ i 1)))
	  ((= i 100))
	(sample->file gen i 0 (* i .001))
	(sample->file gen i 1 (* i .01))
	(sample->file gen i 2 (* i .002))
	(sample->file gen i 3 (* i .003)))
      (outa 50 .015 gen)
      (outb 50 .15 gen)
      (outc 50 .02 gen)
      (outd 50 .03 gen)
      (out-any 60 .015 0 gen)
      (out-any 60 .15 1 gen)
      (out-any 60 .02 2 gen)
      (out-any 60 .03 3 gen)
      (mus-close gen))
    (let* ((gen (make-file->sample "fmv2.snd"))
	   (val0 (in-any 20 2 gen))
	   (val1 (in-any 20 3 gen))
	   (val2 (file->sample gen 50 2))
	   (val3 (file->sample gen 50 3))
	   (val4 (file->sample gen 60 2))
	   (val5 (file->sample gen 60 3)))
      (if (not (= (mus-channels gen) 4)) (snd-display "make-file->sample (4) chans: ~A?" (mus-channels gen)))
      (if (not (= (mus-increment gen) 0.0)) (snd-display "file->sample increment: ~A" (mus-increment gen))) ; dir never set in this case
      (if (or (fneq val0 .04) (fneq val1 .06)) (snd-display "in-any(0, 4): ~A ~A?" val0 val1))
      (if (or (fneq val2 .12) (fneq val3 .18)) (snd-display "file->sample(4): ~A ~A?" val2 val3))
      (if (or (fneq val4 .14) (fneq val5 .21)) (snd-display "in-any(4, 4): ~A ~A?" val4 val5)))
    
    (if (file-exists? "fmv.snd") (delete-file "fmv.snd"))
    (mus-sound-forget "fmv.snd")
    (let ((sf (make-sample->file "fmv.snd" 2 mus-bshort mus-next "this is a comment")))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(sample->file sf i 0 (* i .1))
	(sample->file sf i 1 (* i .01)))
      (mus-close sf))
    (if (not (= (mus-sound-chans "fmv.snd") 2)) 
	(snd-display "sample->file chans: ~A" (mus-sound-chans "fmv.snd")))
    (if (not (= (mus-sound-framples "fmv.snd") 10)) 
	(snd-display "sample->file framples: ~A" (mus-sound-framples "fmv.snd")))
    (if (not (= (mus-sound-samples "fmv.snd") 20)) 
	(snd-display "sample->file samples: ~A" (mus-sound-samples "fmv.snd")))
    (if (not (= (mus-sound-header-type "fmv.snd") mus-next)) 
	(snd-display "sample->file type: ~A" (mus-header-type-name (mus-sound-header-type "fmv.snd"))))
    (if (not (= (mus-sound-sample-type "fmv.snd") mus-bshort)) 
	(snd-display "sample->file format: ~A" (mus-sample-type-name (mus-sound-sample-type "fmv.snd"))))
    (if (not (string=? (mus-sound-comment "fmv.snd") "this is a comment"))
	(snd-display "sample->file comment: ~A" (mus-sound-comment "fmv.snd")))
    (let ((rd (make-file->sample "fmv.snd"))
	  (happy #t))
      (do ((i 0 (+ i 1)))
	  ((or (not happy) (= i 10)))
	(let ((c0 (file->sample rd i 0))
	      (c1 (file->sample rd i 1)))
	  (when (or (fneq c0 (* i .1))
		    (fneq c1 (* i .01)))
	    (snd-display "sample->file->sample at ~A: ~A ~A" i c0 c1)
	    (set! happy #f))))
      (mus-close rd))

    (let ((sf (continue-sample->file "fmv.snd")))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(sample->file sf (+ i 5) 0 (* i -.02))
	(sample->file sf (+ i 5) 1 (* i -.01)))
      (mus-close sf))
    (mus-sound-forget "fmv.snd")
    (if (not (= (mus-sound-chans "fmv.snd") 2)) 
	(snd-display "continue-sample->file chans: ~A" (mus-sound-chans "fmv.snd")))
    (if (not (= (mus-sound-framples "fmv.snd") 15)) 
	(snd-display "continue-sample->file framples: ~A" (mus-sound-framples "fmv.snd")))
    (if (not (= (mus-sound-samples "fmv.snd") 30)) 
	(snd-display "continue-sample->file samples: ~A" (mus-sound-samples "fmv.snd")))
    (if (not (= (mus-sound-header-type "fmv.snd") mus-next)) 
	(snd-display "continue-sample->file type: ~A" (mus-header-type-name (mus-sound-header-type "fmv.snd"))))
    (if (not (= (mus-sound-sample-type "fmv.snd") mus-bshort)) 
	(snd-display "continue-sample->file format: ~A" (mus-sample-type-name (mus-sound-sample-type "fmv.snd"))))
    (if (not (string=? (mus-sound-comment "fmv.snd") "this is a comment"))
	(snd-display "continue-sample->file comment: ~A" (mus-sound-comment "fmv.snd")))
    (let ((ind (open-sound "fmv.snd")))
      (let ((c0 (channel->float-vector 0 15 ind 0))
	    (c1 (channel->float-vector 0 15 ind 1)))
	(if (not (mus-arrays-equal? c0 #r(0.0 0.1 0.2 0.3 0.4 0.5 0.58 0.66 0.74 0.82 -0.1 -0.12 -0.14 -0.16 -0.18)))
	    (snd-display "continue-sample->file (0): ~A" c0))
	(if (not (mus-arrays-equal? c1 #r(0.0 0.01 0.02 0.03 0.04 0.05 0.05 0.05 0.05 0.05 -0.05 -0.06 -0.07 -0.08 -0.09)))
	    (snd-display "continue-sample->file (1): ~A" c1)))
      (close-sound ind))
    (delete-file "fmv.snd")
    (mus-sound-forget "fmv.snd")
    
    (let ((f1 #r(1.0 1.0))
	  (f2 #r(0.0 0.0))
	  (m1 #r(.5 .25 .125 1.0)))
      (let ((result (frample->frample m1 f1 2 f2 2)))
	(if (not (equal? result #r(0.625 1.25)))
	  (snd-display "frample->frample: ~A" result))))

    (let ((f1 #r(1.0 2.0 3.0))
	  (f2 #r(0.0 0.0 0.0))
	  (m1 #r(1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0)))
      (let ((result (frample->frample m1 f1 3 f2 3)))
	(if (not (equal? result #r(30.0 36.0 42.0)))
	  (snd-display "frample->frample 1: ~A" result))))

    (let ((sf (make-frample->file "fmv.snd" 2 mus-lfloat mus-riff "this is a comment")))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(frample->file sf i (float-vector (* i .1) (* i .01))))
      (mus-close sf))
    (if (not (= (mus-sound-chans "fmv.snd") 2)) 
	(snd-display "frample->file chans: ~A" (mus-sound-chans "fmv.snd")))
    (if (not (= (mus-sound-framples "fmv.snd") 10)) 
	(snd-display "frample->file framples: ~A" (mus-sound-framples "fmv.snd")))
    (if (not (= (mus-sound-samples "fmv.snd") 20)) 
	(snd-display "frample->file samples: ~A" (mus-sound-samples "fmv.snd")))
    (if (not (= (mus-sound-header-type "fmv.snd") mus-riff)) 
	(snd-display "frample->file type: ~A" (mus-header-type-name (mus-sound-header-type "fmv.snd"))))
    (if (not (= (mus-sound-sample-type "fmv.snd") mus-lfloat)) 
	(snd-display "frample->file format: ~A" (mus-sample-type-name (mus-sound-sample-type "fmv.snd"))))
    (if (not (string=? (mus-sound-comment "fmv.snd") "this is a comment"))
	(snd-display "frample->file comment: ~A" (mus-sound-comment "fmv.snd")))
    (let ((rd (make-file->frample "fmv.snd"))
	  (f0 #r(0.0 0.0))
	  (happy #t))
      (do ((i 0 (+ i 1)))
	  ((or (not happy) (= i 10)))
	(file->frample rd i f0)
	(when (or (not (= (mus-length f0) 2))
		  (fneq (f0 0) (* i .1))
		  (fneq (f0 1) (* i .01)))
	  (snd-display "frample->file->frample at ~A: ~A" i f0)
	  (set! happy #f)))
      (mus-close rd))
    (let ((sf (continue-frample->file "fmv.snd")))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(frample->file sf (+ i 5) (float-vector (* i -.02) (* i -.01))))
      (mus-close sf))
    (mus-sound-forget "fmv.snd")
    (if (not (= (mus-sound-chans "fmv.snd") 2)) 
	(snd-display "continue-frample->file chans: ~A" (mus-sound-chans "fmv.snd")))
    (if (not (= (mus-sound-framples "fmv.snd") 15)) 
	(snd-display "continue-frample->file framples: ~A" (mus-sound-framples "fmv.snd")))
    (if (not (= (mus-sound-samples "fmv.snd") 30)) 
	(snd-display "continue-frample->file samples: ~A" (mus-sound-samples "fmv.snd")))
    (if (not (= (mus-sound-header-type "fmv.snd") mus-riff)) 
	(snd-display "continue-frample->file type: ~A" (mus-header-type-name (mus-sound-header-type "fmv.snd"))))
    (if (not (= (mus-sound-sample-type "fmv.snd") mus-lfloat)) 
	(snd-display "continue-frample->file format: ~A" (mus-sample-type-name (mus-sound-sample-type "fmv.snd"))))
    (if (not (string=? (mus-sound-comment "fmv.snd") "this is a comment"))
	(snd-display "continue-frample->file comment: ~A" (mus-sound-comment "fmv.snd")))
    (let ((ind (open-sound "fmv.snd")))
      (let ((c0 (channel->float-vector 0 15 ind 0))
	    (c1 (channel->float-vector 0 15 ind 1)))
	(if (not (mus-arrays-equal? c0 #r(0.0 0.1 0.2 0.3 0.4 0.5 0.58 0.66 0.74 0.82 -0.1 -0.12 -0.14 -0.16 -0.18)))
	    (snd-display "continue-frample->file (0): ~A" c0))
	(if (not (mus-arrays-equal? c1 #r(0.0 0.01 0.02 0.03 0.04 0.05 0.05 0.05 0.05 0.05 -0.05 -0.06 -0.07 -0.08 -0.09)))
	    (snd-display "continue-frample->file (1): ~A" c1)))
      (close-sound ind))
    (delete-file "fmv.snd")
    (mus-sound-forget "fmv.snd")
    
    (let ((v0 (make-float-vector 1000)))
      (do ((os (make-oscil 440.0))
	   (i 0 (+ i 1)))
	  ((= i 1000))
	(set! (v0 i) (* .1 (oscil os))))
      (array->file "fmv3.snd" v0 10000 22050 1) ; 10000 deliberate
      (let ((v1 (make-float-vector 1000)))
	(file->array "fmv3.snd" 0 0 1000 v1)
	(do ((i 0 (+ i 1)))
	    ((= i 1000))
	  (if (fneq (v0 i) (v1 i)) 
	      (snd-display "array->file->array: ~A ~A ~A?" i (v0 i) (v1 i)))))
      
      (let ((var (catch #t (lambda () (array->file "fmv3.snd" v0 -1 1000 1)) (lambda args args))))
	(if (not (eq? (car var) 'out-of-range))
	    (snd-display "array->file bad samps: ~A" var)))
      (let ((var (catch #t (lambda () (array->file "/bad/baddy/fmv3.snd" v0 1 1000 1)) (lambda args args))))
	(if (not (eq? (car var) 'mus-error))
	    (snd-display "array->file bad file: ~A" var)))
      (let ((var (catch #t (lambda () (file->array "fmv3.snd" -1 0 -1 v0)) (lambda args args))))
	(if (not (eq? (car var) 'out-of-range))
	    (snd-display "file->array bad samps: ~A" var))))
    
    (let ((gen (make-rand 10000.0))
	  (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "rand"
		       "rand freq: 10000.000Hz, phase: 0.000, amp: 1.000")
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (rand gen)))
      (if (not (rand? gen)) (snd-display "~A not rand?" gen))
      (if (fneq (mus-phase gen) 3.3624296) (snd-display "rand phase: ~F?" (mus-phase gen)))
      (if (fneq (mus-frequency gen) 10000.0) (snd-display "rand frequency: ~F?" (mus-frequency gen)))
      (set! (mus-scaler gen) 0.5)
      (if (fneq (mus-scaler gen) 0.5) (snd-display "set! mus-scaler rand: ~A" (mus-scaler gen)))
      (if (= (v0 1) (v0 8)) (snd-display "rand output: ~A" v0))
      (mus-reset gen)
      (let ((val (rand gen)))
	(if (zero? val) (snd-display "mus-reset rand: ~A" val))))
    
    (let ((gen (make-rand 10000.0 :envelope '(0 0 1 1)))
	  (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "rand"
		       "rand freq: 10000.000Hz, phase: 0.000, amp: 1.000, with distribution envelope")
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (rand gen)))
      (if (not (rand? gen)) (snd-display "(dist) ~A not rand?" gen))
      (if (fneq (mus-frequency gen) 10000.0) (snd-display "(dist) rand frequency: ~F?" (mus-frequency gen)))
      (if (= (v0 1) (v0 8)) (snd-display "(dist) rand output: ~A" v0))
      (if (not (and (float-vector? (mus-data gen))
		    (= (mus-length gen) (length (mus-data gen)))
		    (= (mus-length gen) 512)))
	  (snd-display "(dist) rand data: ~A ~A" (mus-length gen) (mus-data gen))))
    
    (let ((gen1 (make-rand 10000.0 :envelope '(0 0 1 1)))
	  (gen2 (make-rand 10000.0 :envelope '(0 1 1 0)))
	  (up1 0)
	  (down1 0)
	  (bad1 0)
	  (up2 0)
	  (down2 0)
	  (bad2 0))
      (do ((i 0 (+ i 1)))
	  ((= i 1000))
	(let ((val1 (rand gen1))
	      (val2 (rand gen2)))
	  (if (>= val1 .5)
	      (set! up1 (+ 1 up1))
	      (if (>= val1 0.0)
		  (set! down1 (+ 1 down1))
		  (set! bad1 (+ 1 bad1))))
	  (if (>= val2 .5)
	      (set! up2 (+ 1 up2))
	      (if (>= val2 0.0)
		  (set! down2 (+ 1 down2))
		  (set! bad2 (+ 1 bad2))))))
      (if (not (and (= bad1 0)
		    (= bad2 0)
		    (<= (* 2 down1) up1)
		    (<= (* 2 up2) down2)))
	  (snd-display " rand dist: ~A ~A ~A, ~A ~A ~A" down1 up1 bad1 down2 up2 bad2)))
    
					;      (test-gen-equal (make-rand 1000) (make-rand 1000) (make-rand 500))
					;      (test-gen-equal (make-rand 1000) (make-rand 1000) (make-rand 1000 0.5))
    
    (do ((gen (make-rand-interp 100.0 0.0))
	 (i 0 (+ i 1)))
	((= i 10))
      (let ((val (rand-interp gen)))
	(if (not (zero? val))
	    (snd-display "rand-interp 0 amp: ~A" val))))

    (let ((gen (make-rand-interp 4000.0))
	  (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "rand-interp"
		       (mus-describe gen))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (rand-interp gen 0.0)))
      (if (not (rand-interp? gen)) (snd-display "~A not rand-interp?" gen))
      (if (fneq (mus-phase gen) 5.114882) (snd-display "rand-interp phase: ~F?" (mus-phase gen)))
      (if (fneq (mus-frequency gen) 4000.0) (snd-display "rand-interp frequency: ~F?" (mus-frequency gen)))
      (set! (mus-scaler gen) 0.5)
      (if (fneq (mus-scaler gen) 0.5) (snd-display "set! mus-scaler rand-interp: ~A" (mus-scaler gen)))
      (if (= (v0 1) (v0 8)) (snd-display "rand-interp output: ~A" v0)))
    
    (let ((gen (make-rand-interp 4000.0 :envelope '(-1 1 0 0 1 1)))
	  (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "rand-interp"
		       (mus-describe gen))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (rand-interp gen 0.0)))
      (if (not (rand-interp? gen)) (snd-display "(dist) ~A not rand-interp?" gen))
      (if (= (v0 1) (v0 8)) (snd-display "(dist) rand-interp output: ~A" v0))
      (if (not (and (float-vector? (mus-data gen))
		    (= (mus-length gen) (length (mus-data gen)))
		    (= (mus-length gen) 512)))
	  (snd-display "(dist) rand-interp data: ~A ~A" (mus-length gen) (mus-data gen))))
    
    (do ((gen (make-rand 10000.0 1.0))
	 (gen1 (make-rand-interp 10000.0 1.0))
	 (i 0 (+ i 1)))
	((= i 1000))
      (let ((val1 (gen 0.0))
	    (val2 (gen1 0.0)))
	(if (not (>= 1.0 val1 -1.0))
	    (snd-display "rand: ~A ~A" val1 gen))
	(if (not (>= 1.0 val2 -1.0))
	    (snd-display "rand-interp: ~A ~A" val2 gen1))))
  
    (let ((gen (make-rand 10000.0 :distribution (inverse-integrate '(0 0 1 1))))
	  (v0 (make-float-vector 10)))
      (print-and-check gen 
		       "rand"
		       "rand freq: 10000.000Hz, phase: 0.000, amp: 1.000, with distribution envelope")
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(set! (v0 i) (rand gen)))
      (if (not (rand? gen)) (snd-display "(dist 2) ~A not rand?" gen))
      (if (fneq (mus-frequency gen) 10000.0) (snd-display "(dist 2) rand frequency: ~F?" (mus-frequency gen)))
      (if (= (v0 1) (v0 8)) (snd-display "(dist 2) rand output: ~A" v0))
      (if (not (and (float-vector? (mus-data gen))
		    (= (mus-length gen) (length (mus-data gen)))
		    (= (mus-length gen) 512)))
	  (snd-display "(dist 2) rand data: ~A ~A" (mus-length gen) (mus-data gen))))
    
    (let ((gen1 (make-rand 10000.0 :distribution (inverse-integrate '(0 0 1 1))))
	  (gen2 (make-rand 10000.0 :distribution (inverse-integrate '(0 1 1 0))))
	  (up1 0)
	  (down1 0)
	  (bad1 0)
	  (up2 0)
	  (down2 0)
	  (bad2 0))
      (do ((i 0 (+ i 1)))
	  ((= i 1000))
	(let ((val1 (rand gen1))
	      (val2 (rand gen2)))
	  (if (>= val1 .5)
	      (set! up1 (+ 1 up1))
	      (if (>= val1 0.0)
		  (set! down1 (+ 1 down1))
		  (set! bad1 (+ 1 bad1))))
	  (if (>= val2 .5)
	      (set! up2 (+ 1 up2))
	      (if (>= val2 0.0)
		  (set! down2 (+ 1 down2))
		  (set! bad2 (+ 1 bad2))))))
      (if (not (and (= bad1 0)
		    (= bad2 0)
		    (<= (* 2.5 down1) up1)
		    (<= (* 2.0 up2) down2)))
	  (snd-display " rand dist 2: ~A ~A ~A, ~A ~A ~A" down1 up1 bad1 down2 up2 bad2))) ; 234 766 0, 705 295 0
    
    (let ((ind (new-sound :size 100)))
      (select-sound ind)
      (map-channel (lambda (y) (any-random 1.0 '(0 1 1 1))))
      (let ((place (scan-channel (lambda (y) (not (<= 0.0 y 1.0)))))) ; (or (< y 0.0) (> y 1.0))))))
	(if place (snd-display "any-random 0 to 1: ~A" place)))
      (if (< (maxamp) .5) (snd-display "any-random maxamp: ~A" (maxamp))) ; possible, but extremely unlikely
      (let ((avg 0.0))
	(scan-channel (lambda (y) (set! avg (+ avg y)) #f))
	(if (> (abs (- (/ avg (framples)) .5)) .2) (snd-display "any-random skewed?")))
      (let ((g (gaussian-distribution 1.0))) 
	(map-channel (lambda (y) (any-random 1.0 g))))
      (let ((g (pareto-distribution 1.0))) 
	(map-channel (lambda (y) (any-random 1.0 g))))
      (clean-up-sound ind))
    
    (let ((v1 (inverse-integrate '(-1 1 1 1))))
      (if (fneq (v1 4) -0.984)
	  (snd-display "inverse-integrate -1 to 1 uniform: ~A" v1)))
    (let ((v1 (inverse-integrate '(0 1 1 1))))
      (if (fneq (v1 4) .008)
	  (snd-display "inverse-integrate 0 to 1 uniform: ~A" v1)))
    (let ((v1 (inverse-integrate '(0 1 1 0))))
      (if (fneq (v1 4) .004)
	  (snd-display "inverse-integrate 0 to 1 1 to 0: ~A" v1)))
    (let ((v1 (inverse-integrate '(0 0 .5 1 1 0))))
      (if (fneq (v1 4) .073)
	  (snd-display "inverse-integrate triangle: ~A" v1)))
    (let ((v1 (inverse-integrate (gaussian-envelope 1.0))))
      (if (fneq (v1 4) -0.593)
	  (snd-display "inverse-integrate gaussian: ~A" v1)))
    
    (let ((minp 1.0)
	  (maxp -1.0))
      (do ((i 0 (+ i 1)))
	  ((= i 1100))
	(let ((val1 (mus-random 1.0)))
	  (set! minp (min minp val1))
	  (set! maxp (max maxp val1))
	  (if (not (>= 1.0 val1 -1.0))
	      (snd-display "mus-random: ~A" val1))))
      (if (or (< maxp .9)
	      (> minp -.9))
	  (snd-display "mus-random min/max: ~A ~A" minp maxp))
      (set! minp 12.0)
      (set! maxp -12.0)
      (do ((i 0 (+ i 1)))
	  ((= i 1100))
	(let ((val1 (mus-random 12.0)))
	  (set! minp (min minp val1))
	  (set! maxp (max maxp val1))
	  (if (not (>= 12.0 val1 -12.0))
	      (snd-display "mus-random (12): ~A" val1))))
      (if (or (< maxp 11.0)
	      (> minp -11.0))
	  (snd-display "mus-random (12) min/max: ~A ~A" minp maxp)))
    
    (let ((n 1000) ; chi^2 or mus-random
	   (hits (make-vector 10 0)))
      (do ((i 0 (+ 1 i )))
	  ((= i n))
	(let ((y (floor (+ 5 (mus-random 5.0)))))
	  (set! (hits y) (+ 1 (vector-ref hits y)))))
      (do ((sum 0.0)
	   (p (/ n 10.0))
	   (i 0 (+ i 1)))
	  ((= i 10) 
	   (if (< sum 3.0)
	       (snd-display "mus-random not so random? ~A (chi)" sum)))
	(let ((num (- (vector-ref hits i) p)))
	  (set! sum (+ sum (/ (* num num) p))))))
      ;; (v 10000)
      ;; #(999 1017 1002 1024 1048 971 963 1000 980 996) 5.8
      ;; if less than 3 complain
    
    (let ((n 10000)
	   (hits (make-vector 10 0))
	   (gen (make-rand 22050.0 5)))
      (do ((i 0 (+ 1 i )))
	  ((= i n))
	(let ((y (floor (+ 5 (rand gen)))))
	  (set! (hits y) (+ 1 (vector-ref hits y)))))
      (do ((sum 0.0)
	   (p (/ n 10.0))
	   (i 0 (+ i 1)))
	  ((= i 10)
	   (if (< sum 3.5)
	       (snd-display "rand not so random? ~A (chi)" sum)))
	(let ((num (- (vector-ref hits i) p)))
	  (set! sum (+ sum (/ (* num num) p))))))
      ;; (v1 10000)
      ;; #(979 1015 977 1008 954 1049 997 1020 1015 986) 6.606
    
    (let ((data (make-float-vector 65536)))
      (do ((i 0 (+ i 1)))
	  ((= i 65536))
	(set! (data i) (mus-random 1.0)))
      (let ((ndat (snd-spectrum data rectangular-window 65536 #t 0.0 #f #f)))
	(let ((peak (float-vector-peak ndat))
	      (sum 0.0))
	  (if (> peak 1000.0)
	      (snd-display "mus-random spectral peak: ~A" peak))
	  (do ((i 0 (+ i 1)))
	      ((= i 32768))
	    (set! sum (+ sum (float-vector-ref ndat i))))
	  (if (> (/ sum 32768.0) 200.0)
	      (snd-display "random average: ~A ~A" (/ sum 32768.0) (ndat 0)))))
      (do ((i 0 (+ i 1)))
	  ((= i 65536))
	(set! (data i) (mus-random 1.0)))
      (autocorrelate data)
      (set! (data 0) 0.0)
      (let ((pk (float-vector-peak data)))
	(if (> pk 1000)
	    (snd-display "random autocorrelate peak: ~A" (float-vector-peak data))))
      (let ((sum 0.0))
	(float-vector-abs! data)
	(do ((i 0 (+ i 1)))
	    ((= i 32768))
	  (set! sum (+ sum (float-vector-ref data i))))
	(if (> (/ sum 32768.0) 200.0)
	    (snd-display "random autocorrelate average: ~A" (/ sum 32768.0)))))
    
    (set! (locsig-type) mus-interp-linear)
    (let ((gen1 (make-locsig 60.0 :channels 2)))
      (let ((gen (make-locsig 30.0 :channels 2)))
	(locsig gen 0 1.0)
	(print-and-check gen 
			 "locsig"
			 "locsig chans 2, outn: [0.667 0.333], interp: linear")
	(if (not (locsig? gen)) (snd-display "~A not locsig?" gen))
	(let ((gen2 (make-locsig 60.0 :channels 4)))
	  (if (eq? gen1 gen2) (snd-display "locsig 1 eq? ~A ~A" gen1 gen2))
	  (if (equal? gen gen1) (snd-display "locsig 2 equal? ~A ~A" gen gen1))
	  (if (equal? gen gen2) (snd-display "locsig 3 equal? ~A ~A" gen gen2))
	  (if (or (fneq (locsig-ref gen 0) .667) (fneq (locsig-ref gen 1) .333))
	      (snd-display "locsig ref: ~F ~F?" (locsig-ref gen 0) (locsig-ref gen 1)))
	  (if (not (mus-arrays-equal? (mus-data gen) #r(0.667 0.333)))
	      (snd-display "locsig gen outn: ~A" (mus-data gen)))
	  (if (not (mus-arrays-equal? (mus-data gen1) #r(0.333 0.667)))
	      (snd-display "locsig gen2 outn: ~A" (mus-data gen1)))
	  (if (not (mus-arrays-equal? (mus-data gen2) #r(0.333 0.667 0.000 0.000)))
	      (snd-display "locsig gen2 outn: ~A" (mus-data gen2))))
	(let ((gen200 (mus-data (make-locsig 200.0 :channels 4))))
	  (if (not (mus-arrays-equal? gen200 #r(0.000 0.000 0.778 0.222)))
	      (snd-display "locsig gen200 outn: ~A" gen200)))
	(locsig-set! gen 0 .25)
	(if (not (mus-arrays-equal? (mus-data gen) #r(0.250 0.333)))
	    (snd-display "locsig gen .25 outn: ~A" (mus-data gen)))
	(locsig gen 0 1.0)
	(locsig-set! gen 0 .5)
	(if (not (mus-arrays-equal? (mus-data gen) #r(0.500 0.333)))
	    (snd-display "locsig gen .5 outn: ~A" (mus-data gen)))
	(locsig gen 0 1.0))
      (let ((gen (make-locsig 120.0 2.0 .1 :channels 4)))
	(if (not (mus-arrays-equal? (mus-data gen) #r(0.000 0.333 0.167 0.000)))
	    (snd-display "locsig gen 120 outn: ~A" (mus-data gen)))
	(locsig gen 0 1.0))
      (let ((gen (make-locsig 300.0 2.0 .1 :channels 4)))
	(if (not (mus-arrays-equal? (mus-data gen) #r(0.167 0.000 0.000 0.333)))
	    (snd-display "locsig gen 300 outn: ~A" (mus-data gen)))
	(locsig gen 0 1.0))
      
      (move-locsig gen1 90.0 1.0)
      (if (not (mus-arrays-equal? (mus-data gen1) #r(0.000 1.000)))
	  (snd-display "locsig gen1 90 outn: ~A" (mus-data gen1)))
      (move-locsig gen1 0.0 1.0)
      (if (not (mus-arrays-equal? (mus-data gen1) #r(1.000 0.000)))
	  (snd-display "locsig gen1 0 outn: ~A" (mus-data gen1)))
      (move-locsig gen1 45.0 1.0)
      (if (not (mus-arrays-equal? (mus-data gen1) #r(0.500 0.500)))
	  (snd-display "locsig gen1 45 outn: ~A" (mus-data gen1)))
      (move-locsig gen1 135.0 2.0)
      (if (not (mus-arrays-equal? (mus-data gen1) #r(0.000 0.500)))
	  (snd-display "locsig gen1 135 outn: ~A" (mus-data gen1)))
      (move-locsig gen1 -270.0 3.0)
      (if (not (mus-arrays-equal? (mus-data gen1) #r(0.333 0.0)))
	  (snd-display "locsig gen1 -270 outn: ~A" (mus-data gen1))))
    
    (for-each
     (lambda (chans)
       (let ((loc (make-locsig :channels chans)))
	 (let ((last (make-float-vector chans))
	       (data (mus-data loc)))
	   ;; do a full circle looking for jumps
	   (move-locsig loc -400.0 1.0)
	   (copy data last)
	   (do ((x -400.0 (+ x 10.0)))
	       ((> x 400.0))
	     (move-locsig loc x 1.0)
	     (if (or (< (float-vector-min data) 0.0)
		     (> (float-vector-max data) 1.0))
		 (format () ";locsig, chans: ~D, degree: ~F, ~A~%" chans x data))
	     (let ((diff (float-vector-peak (float-vector-subtract! last data))))
	       (copy data last)
	       (if (> diff .25)
		 (format () ";locsig, increment ~F with deg ~F~%" diff x)))))))
     '(1 2 4 5 8))
    
    (for-each 
     (lambda (chans)
       (let ((m1 (make-locsig :channels chans)))
	 (if (not (= (mus-channels m1) chans (mus-length m1)))
	     (snd-display "locsig ~A chans but: ~A ~A" chans (mus-channels m1) (mus-length m1)))
	 (do ((i 0 (+ i 1)))
	     ((= i chans))
	   (locsig-set! m1 i (* i .1)))
	 (do ((i 0 (+ i 1)))
	     ((= i chans))
	   (if (fneq (locsig-ref m1 i) (* i .1))
	       (snd-display "locsig[~A] = ~A (~A)?" i (locsig-ref m1 i) (* i .1))))))
     '(1 2 4 8))
    
    (let ((var (catch #t (lambda () (make-locsig :channels 0)) (lambda args args))))
      (if (not (memq (car var) '(out-of-range mus-error)))
	  (snd-display "make-locsig bad (0) chans: ~A" var)))
    (let ((var (catch #t (lambda () (make-locsig :channels -2)) (lambda args args))))
      (if (not (eq? (car var) 'out-of-range))
	  (snd-display "make-locsig bad (-2) chans: ~A" var)))
    (let ((var (catch #t (lambda () (make-locsig :output 1)) (lambda args args))))
      (if (not (eq? (car var) 'wrong-type-arg))
	  (snd-display "make-locsig bad output: ~A" var)))
    (let ((var (catch #t (lambda () (locsig-ref (make-locsig) 1)) (lambda args args))))
      (if (and (pair? var)
	       (not (eq? (car var) 'mus-error)))
	  (snd-display "locsig-ref bad chan: ~A" var)))
    (let ((var (catch #t (lambda () (make-locsig :revout 1)) (lambda args args))))
      (if (and (pair? var)
	       (not (eq? (car var) 'wrong-type-arg)))
	  (snd-display "make-locsig bad revout: ~A" var)))
    (let ((var (catch #t (lambda () (locsig-ref (make-locsig 200 :channels 2) -1)) (lambda args args))))
      (if (and (pair? var)
	       (not (eq? (car var) 'mus-error)))
	  (snd-display "locsig-ref bad chan: ~A" var)))
    (let ((var (catch #t (lambda () (locsig-set! (make-locsig) 2 .1)) (lambda args args))))
      (if (and (pair? var)
	       (not (eq? (car var) 'mus-error)))
	  (snd-display "locsig-set! bad chan (2): ~A" var)))
    (let ((var (catch #t (lambda () (locsig-reverb-ref (make-locsig :reverb .1) 2)) (lambda args args))))
      (if (and (pair? var)
	       (not (eq? (car var) 'mus-error)))
	  (snd-display "locsig-reverb-ref bad reverb chan (2): ~A" var)))
    (let ((var (catch #t (lambda () (locsig-reverb-set! (make-locsig :reverb .1) 2 .1)) (lambda args args))))
      (if (and (pair? var)
	       (not (eq? (car var) 'mus-error)))
	  (snd-display "locsig-reverb-set! bad reverb chan (2): ~A" var)))
    
    (let ((locs (make-locsig :channels 8 :degree 0)))
      (move-locsig locs 180 1.0)
      (if (fneq (locsig-ref locs 0) 0.0) (snd-display "move-locsig by jump: ~A" (mus-data locs)))
      (if (not (mus-arrays-equal? (mus-data locs) #r(0.000 0.000 0.000 0.000 1.000 0.000 0.000 0.000)))
	  (snd-display "move-locsig by jump data: ~A" (mus-data locs)))
      (move-locsig locs 120.0 1.0)
      (if (not (mus-arrays-equal? (mus-data locs) #r(0.000 0.000 0.333 0.667 0.000 0.000 0.000 0.000)))
	  (snd-display "move-locsig by jump 120 data: ~A" (mus-data locs)))
      (move-locsig locs -20.0 1.0)
      (if (not (mus-arrays-equal? (mus-data locs) #r(0.556 0.000 0.000 0.000 0.000 0.000 0.000 0.444)))
	  (snd-display "move-locsig by jump -20 data: ~A" (mus-data locs))))
    
    (let ((sf (make-sample->file "fmv4.snd" 8 mus-bshort mus-next "this is a comment"))
	  (sfrev (make-sample->file "fmv4.reverb" 8 mus-bshort mus-next "this is a comment")))
      (let ((locs (make-locsig :channels 8 :degree 0 :distance 1.0 :reverb 0.1 
			       :output sf :revout sfrev :type mus-interp-linear)))
	(if (not (mus-arrays-equal? (mus-data locs) #r(1.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	    (snd-display "ws not move-locsig by jump data: ~A" (mus-data locs)))
	(if (not (mus-arrays-equal? (mus-xcoeffs locs) #r(0.100 0.000 0.000 0.000 0.0 0.0 0.0 0.0)))
	    (snd-display "ws not move-locsig by jump rev data: ~A" (mus-xcoeffs locs)))
	(move-locsig locs 180 2.0)
	(if (fneq (locsig-ref locs 0) 0.0) (snd-display "ws move-locsig by jump: ~A" (mus-data locs)))
	(if (not (mus-arrays-equal? (mus-data locs) #r(0.000 0.000 0.000 0.000 0.500 0.000 0.000 0.000)))
	    (snd-display "ws move-locsig by jump data: ~A" (mus-data locs)))
	(if (not (mus-arrays-equal? (mus-xcoeffs locs) #r(0.000 0.000 0.000 0.000 0.071 0.000 0.000 0.000)))
	    (snd-display "ws move-locsig by jump rev data: ~A" (mus-xcoeffs locs)))
	(move-locsig locs 120.0 3.0)
	(if (not (mus-arrays-equal? (mus-data locs) #r(0.000 0.000 0.111 0.222 0.000 0.000 0.000 0.000)))
	    (snd-display "ws move-locsig by jump 120 data: ~A" (mus-data locs)))
	(if (not (mus-arrays-equal? (mus-xcoeffs locs) #r(0.000 0.000 0.019 0.038 0.000 0.000 0.000 0.000)))
	    (snd-display "ws move-locsig by jump 120 rev data: ~A" (mus-xcoeffs locs)))
	(move-locsig locs -20.0 4.0)
	(if (not (mus-arrays-equal? (mus-data locs) #r(0.139 0.000 0.000 0.000 0.000 0.000 0.000 0.111)))
	    (snd-display "ws move-locsig by jump -20 data: ~A" (mus-data locs)))
	(if (not (mus-arrays-equal? (mus-xcoeffs locs) #r(0.028 0.000 0.000 0.000 0.000 0.000 0.000 0.022)))
	    (snd-display "ws move-locsig by jump -20 rev data: ~A" (mus-xcoeffs locs))))
      (mus-close sf)
      (mus-close sfrev))
    
    (if (file-exists? "fmv4.snd") (delete-file "fmv4.snd"))
    (if (file-exists? "fmv4.reverb") (delete-file "fmv4.reverb"))
    (mus-sound-prune)
    
    (for-each
     (lambda (ht)
       (let ((ind (find-sound (with-sound (:channels 8)
					  (do ((i 0 (+ i 1)))
					      ((= i 8))
					    (locsig (make-locsig :degree (* i 45) :output *output*) i 0.5))))))
	 (do ((i 0 (+ i 1)))
	     ((= i 8))
	   (let ((samps (channel->float-vector 0 8 ind i)))
	     (do ((k 0 (+ k 1)))
		 ((= k 8))
	       (if (and (= k i) (fneq (samps k) 0.5))
		   (snd-display "8 out ~A chan ~A samp ~A (0.5): ~A" (mus-header-type->string ht) i k (samps k)))
	       (if (and (not (= i k)) (fneq (samps k) 0.0))
		   (snd-display "8 out ~A chan ~A samp ~A (0.0): ~A" (mus-header-type->string ht) i k (samps k))))))
	 (close-sound ind)))
     (list mus-caff mus-aifc mus-next mus-riff mus-rf64))
    
    (let* ((gen (make-frample->file "fmv4.snd" 2 mus-bshort mus-next))
	   (rev (make-frample->file "fmv4.reverb" 1 mus-bshort mus-next))
	   (lc (make-locsig 60.0 :reverb .1 :channels 2 :output gen :revout rev)))
      (do ((i 0 (+ i 1)))
	  ((= i 100))
	(locsig lc i 1.0))
      (if (fneq (locsig-reverb-ref lc 0) .1) (snd-display "locsig reverb ref: ~A?" (locsig-reverb-ref lc 0)))
      (locsig-reverb-set! lc 0 .2)
      (if (fneq (locsig-reverb-ref lc 0) .2) (snd-display "locsig reverb set: ~A?" (locsig-reverb-ref lc 0)))
      (mus-close gen)
      (mus-close rev)
      (let ((v0 (make-float-vector 100))
	    (v1 (make-float-vector 100))
	    (v2 (make-float-vector 100)))
	(file->array "fmv4.snd" 0 0 100 v0)
	(file->array "fmv4.snd" 1 0 100 v1)
	(file->array "fmv4.reverb" 0 0 100 v2)
	(if (fneq (v2 0) .1) (snd-display "locsig reverb: ~A?" v2))
	(if (fneq (* 2 (v0 0)) (v1 0)) (snd-display "locsig direct: ~A ~A?" (v0 0) (v1 0)))))
    
    (let* ((gen (make-frample->file "fmv4.snd" 4 mus-bshort mus-next))
	   (rev (make-frample->file "fmv4.reverb" 4 mus-bshort mus-next))
	   (lc (make-locsig 60.0 :reverb .1 :channels 4 :distance 4.0 :output gen :revout rev)))
      (print-and-check lc
		       "locsig"
		       "locsig chans 4, outn: [0.083 0.167 0.000 0.000], revn: [0.017 0.033 0.000 0.000], interp: linear")
      (do ((i 0 (+ i 1)))
	  ((= i 100))
	(locsig lc i 1.0))
      (do ((i 0 (+ i 1)))
	  ((= i 4))
	(locsig-reverb-set! lc i (* i .1))
	(if (fneq (locsig-reverb-ref lc i) (* i .1))
	    (snd-display "locsig reverb set![~A]: ~A?" i (locsig-reverb-ref lc i))))
      (print-and-check lc
		       "locsig"
		       "locsig chans 4, outn: [0.083 0.167 0.000 0.000], revn: [0.000 0.100 0.200 0.300], interp: linear")
      (if (not (float-vector? (mus-data lc))) (snd-display "out data locsig: ~A" (mus-data lc)))
      (if (not (float-vector? (mus-xcoeffs lc))) (snd-display "rev data locsig: ~A" (mus-xcoeffs lc)))
      (let ((xcs (mus-xcoeffs lc)))
	(if (fneq (mus-xcoeff lc 0) (xcs 0)) (snd-display "locsig xcoeff: ~A ~A" (mus-xcoeff lc 0) (xcs 0)))
	(if (fneq (mus-xcoeff lc 1) .1) (snd-display "locsig xcoeff 1: ~A ~A (.1)" (mus-xcoeff lc 0) (xcs 0))))
      (mus-close gen)
      (mus-close rev))
    
    (print-and-check (make-locsig 160 :channels 4)
		     "locsig"
		     "locsig chans 4, outn: [0.000 0.222 0.778 0.000], interp: linear")
    (print-and-check (make-locsig -200 :channels 4)
		     "locsig"
		     "locsig chans 4, outn: [0.000 0.222 0.778 0.000], interp: linear")
    (print-and-check (make-locsig 160 :channels 4 :distance .5)
		     "locsig"
		     "locsig chans 4, outn: [0.000 0.222 0.778 0.000], interp: linear")
    (print-and-check (make-locsig 320 :channels 4)
		     "locsig"
		     "locsig chans 4, outn: [0.556 0.000 0.000 0.444], interp: linear")
    (print-and-check (make-locsig -40 :channels 4)
		     "locsig"
		     "locsig chans 4, outn: [0.556 0.000 0.000 0.444], interp: linear")
    (print-and-check (make-locsig 320 :channels 2)
		     "locsig"
		     "locsig chans 2, outn: [0.000 1.000], interp: linear")
    (print-and-check (make-locsig -40 :channels 2)
		     "locsig"
		     "locsig chans 2, outn: [1.000 0.000], interp: linear")
    (print-and-check (make-locsig 160 :channels 4 :output (make-float-vector '(4 10)))
		     "locsig"
		     "locsig chans 4, outn: [0.000 0.222 0.778 0.000], interp: linear")
    (print-and-check (make-locsig 0 :channels 1 :output (make-float-vector 10))
		     "locsig"
		     "locsig chans 1, outn: [1.000], interp: linear")
    (let ((locsig-data
	   (lambda (gen)
	     (let ((chans (mus-channels gen)))
	       (do ((dat (make-float-vector chans))
		    (i 0 (+ i 1)))
		   ((= i chans) dat)
		 (set! (dat i) (locsig-ref gen i))))))
	  (gen (make-locsig -.1 :channels 8)))
      (if (not (mus-arrays-equal? (locsig-data gen) #r(0.998 0.000 0.000 0.000 0.000 0.000 0.000 0.002)))
	  (snd-display "locsig -.1(8): ~A" (locsig-data gen)))
      (set! gen (make-locsig -359.9 :channels 8))
      (if (not (mus-arrays-equal? (locsig-data gen) #r(0.998 0.002 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "locsig -359.9(8): ~A" (locsig-data gen)))
      (set! gen (make-locsig -359.9 :channels 4))
      (if (not (mus-arrays-equal? (locsig-data gen) #r(0.999 0.001 0.000 0.000)))
	  (snd-display "locsig -359.9(4): ~A" (locsig-data gen)))
      (set! gen (make-locsig -360.1 :channels 8))
      (if (not (mus-arrays-equal? (locsig-data gen) #r(0.998 0.000 0.000 0.000 0.000 0.000 0.000 0.002)))
	  (snd-display "locsig -360.1(8): ~A" (locsig-data gen)))
      (set! gen (make-locsig -700 :channels 8))
      (if (not (mus-arrays-equal? (locsig-data gen) #r(0.556 0.444 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "locsig -700(8): ~A" (locsig-data gen)))
      (set! gen (make-locsig -700 :channels 2))
      (if (not (mus-arrays-equal? (locsig-data gen) #r(1.000 0.000)))
	  (snd-display "locsig -700(2): ~A" (locsig-data gen)))
      (set! gen (make-locsig 20 :channels 2))
      (if (not (mus-arrays-equal? (locsig-data gen) #r(0.778 0.222)))
	  (snd-display "locsig 20(2): ~A" (locsig-data gen)))
      (set! gen (make-locsig 123456.0 :channels 8))
      (if (not (mus-arrays-equal? (locsig-data gen) #r(0.467 0.000 0.000 0.000 0.000 0.000 0.000 0.533)))
	  (snd-display "locsig 123456(8): ~A" (locsig-data gen)))
      (set! gen (make-locsig 336.0 :channels 8))
      (if (not (mus-arrays-equal? (locsig-data gen) #r(0.467 0.000 0.000 0.000 0.000 0.000 0.000 0.533)))
	  (snd-display "locsig 336(8): ~A" (locsig-data gen)))
      (set! gen (make-locsig -123456.0 :channels 8))
      (if (not (mus-arrays-equal? (locsig-data gen) #r(0.467 0.533 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "locsig -123456(8): ~A" (locsig-data gen)))
      (set! gen (make-locsig 24.0 :channels 8))
      (if (not (mus-arrays-equal? (locsig-data gen) #r(0.467 0.533 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "locsig 24(8): ~A" (locsig-data gen))))
    
    (for-each 
     (let ((locsig-scalers 
	    (let ((xmodulo (lambda (a b)
			     (- a (* (floor (/ a b)) b)))))
	      (lambda (chans degree type)
		(if (= chans 1)
		    #r(1.0)
		    (let* ((pos (let ((deg (if (= chans 2)
					       (max 0.0 (min 90.0 degree))
					       (xmodulo degree 360.0)))
				      (degs-per-chan (if (= chans 2)
							 90.0
							 (/ 360.0 chans))))
				  (/ deg degs-per-chan)))
			   (left (floor pos)))
		      (let ((right (xmodulo (+ left 1) chans))
			    (frac (- pos left))
			    (v (make-float-vector chans)))
			(if (= type mus-interp-linear)
			    (begin
			      (set! (v left) (- 1.0 frac))
			      (set! (v right) frac))
			    (let ((ldeg (* (/ pi 2) (- 0.5 frac))))
			      (let ((norm (/ (sqrt 2.0)))
				    (c (cos ldeg))
				    (s (sin ldeg)))
				(set! (v left) (* norm (+ c s)))
				(set! (v right) (* norm (- c s))))))
			v)))))))
       (lambda (rev-chans)
	 
	 (if (file-exists? "test.reverb") (delete-file "test.reverb"))
	 (let ((revfile (and (> rev-chans 0)
			     (make-frample->file "test.reverb" rev-chans mus-bshort mus-next)))
	       (happy #t))
	   (for-each
	    (lambda (type)
	      ;; global type def as well as local par override etc
	      
	      (when happy
		(set! (locsig-type) type)
		(if (not (= (locsig-type) type)) (snd-display "locsig-type: ~A ~A" type (locsig-type)))
		
		(for-each 
		 (lambda (deg)
		   (let ((gen (make-locsig deg :channels 1 :revout revfile :reverb .1 :distance 2.0))
			 (revs (if revfile (locsig-scalers rev-chans deg type))))
		     (if (not (= (mus-channels gen) 1)) (snd-display "locsig ~A: ~A" deg gen))
		     (if (fneq (locsig-ref gen 0) 0.5) (snd-display "locsig scaler[~A] ~A: ~A" type deg (locsig-ref gen 0)))
		     (if revfile
			 (do ((sq (/ .1 (sqrt 2)))
			      (i 0 (+ i 1)))
			     ((or (not happy) (= i rev-chans)))
			   (when (fneq (locsig-reverb-ref gen i) (* sq (revs i)))
			     (snd-display "mono locrev[~A] ~A at ~A: ~A ~A" 
					  type gen deg 
					  (locsig-reverb-ref gen i) 
					  (* sq (revs i)))
			     (set! happy #f))))))
		 '(0.0 45.0 90.0 1234.0))
		
		(for-each
		 (lambda (ltype)
		   (for-each 
		    (lambda (deg)
		      (let ((gen (make-locsig deg :channels 1 :type ltype)))
			(if (not (= (mus-channels gen) 1)) (snd-display "locsig ~A: ~A" deg gen))
			(if (fneq (locsig-ref gen 0) 1.0) (snd-display "locsig[~A] scaler ~A: ~A" ltype deg (locsig-ref gen 0)))))
		    '(0.0 45.0 90.0 1234.0)))
		 (list mus-interp-linear mus-interp-sinusoidal))
		
		(for-each
		 (lambda (chans)
		   (for-each 
		    (lambda (deg)
		      (let ((gen (make-locsig deg :channels chans :revout revfile :reverb .1)))
			(if (not (= (mus-channels gen) chans)) (snd-display "multi locsig ~A: ~A" deg gen))
			(let ((scalers (locsig-scalers chans deg type))
			      (revs (if revfile (locsig-scalers rev-chans deg type))))
			  (do ((i 0 (+ i 1)))
			      ((or (not happy) (= i chans)))
			    (when (fneq (locsig-ref gen i) (scalers i)) 
			      (snd-display "locsig[~A] ~A at ~A: ~A ~A" type gen deg (locsig-ref gen i) (scalers i)) 
			      (set! happy #f)))
			  (if revfile
			      (do ((i 0 (+ i 1)))
				  ((or (not happy) (= i rev-chans)))
				(when (fneq (locsig-reverb-ref gen i) (* .1 (revs i)))
				  (snd-display "locrev[~A] ~A at ~A: ~A ~A" 
					       type gen deg 
					       (locsig-reverb-ref gen i) 
					       (* .1 (revs i)))
				  (set! happy #f)))))))
		    '(0.0 45.0 90.0 120.0 180.0 275.0 315.0 300.0 15.0 1234.0)))
		 '(2 3 4 5 8 12 16 24))
		
		(for-each
		 (lambda (chans)
		   (for-each 
		    (lambda (ltype)
		      (for-each
		       (lambda (deg)
			 (let ((gen (make-locsig deg :channels chans :type ltype :revout revfile :reverb .1)))
			   (if (not (= (mus-channels gen) chans)) (snd-display "stereo locsig ~A: ~A" deg gen))
			   (let ((scalers (locsig-scalers chans deg ltype))
				 (revs (if revfile (locsig-scalers rev-chans deg ltype))))
			     (do ((i 0 (+ i 1)))
				 ((or (not happy) (= i chans)))
			       (when (fneq (locsig-ref gen i) (scalers i)) 
				 (snd-display "locsig[~A] ~A at ~A: ~A ~A" ltype gen deg (locsig-ref gen i) (scalers i))
				 (set! happy #f)))
			     (if revfile
				 (do ((i 0 (+ i 1)))
				     ((or (not happy) (= i rev-chans)))
				   (when (fneq (locsig-reverb-ref gen i) (* .1 (revs i)))
				     (snd-display "locrev[~A] ~A at ~A: ~A ~A" 
						  type gen deg 
						  (locsig-reverb-ref gen i) 
						  (* .1 (revs i)))
				     (set! happy #f)))))))
		       '(0.0 45.0 90.0 120.0 180.0 275.0 315.0 300.0 15.0 1234.0)))
		    (list mus-interp-linear mus-interp-sinusoidal)))
		 '(2 3 4 5 8 12 16 24))))
	    (list mus-interp-linear mus-interp-sinusoidal))
	   (if revfile (mus-close revfile)))))
       '(0 1 2 4))
    
    (set! (locsig-type) mus-interp-linear)
    (let* ((outp (make-float-vector '(1 10)))
	   (gen (make-locsig 0.0 :output outp)))
      (if (not (= (mus-channels gen) 1)) (snd-display "make-locsig->sd chans (1): ~A" (mus-channels gen)))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(locsig gen i 1.0))
      (if (not (mus-arrays-equal? (outp 0) (make-float-vector 10 1.0)))
	  (snd-display "locsig->sd chan 0: ~A" (outp 0))))
    
    (let* ((outp (make-float-vector '(2 10)))
	   (gen (make-locsig 0.0 :output outp)))
      (if (not (= (mus-channels gen) 2)) (snd-display "make-locsig->sd chans: ~A" (mus-channels gen)))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(locsig gen i 1.0))
      (if (not (mus-arrays-equal? (outp 0) (make-float-vector 10 1.0)))
	  (snd-display "locsig->sd chan 0: ~A" (outp 0)))
      (if (not (mus-arrays-equal? (outp 1) (make-float-vector 10)))
	  (snd-display "locsig->sd chan 1: ~A" (outp 1))))
    
    (let* ((outp (make-float-vector '(2 10)))
	   (gen (make-locsig 45.0 :output outp)))
      (if (not (= (mus-channels gen) 2)) (snd-display "make-locsig->sd chans: ~A" (mus-channels gen)))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(locsig gen i 1.0))
      (if (not (mus-arrays-equal? (outp 0) (make-float-vector 10 0.5)))
	  (snd-display "locsig->sd chan 0 (0.5): ~A (~A)" (outp 0) gen))
      (if (not (mus-arrays-equal? (outp 1) (make-float-vector 10 0.5)))
	  (snd-display "locsig->sd chan 1 (0.5): ~A" (outp 1)))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(locsig gen i 0.5))
      (if (not (mus-arrays-equal? (outp 0) (make-float-vector 10 0.75)))
	  (snd-display "locsig->sd chan 0 (0.75) (~A): ~A" (outp 0) gen))
      (if (not (mus-arrays-equal? (outp 1) (make-float-vector 10 0.75)))
	  (snd-display "locsig->sd chan 1 (0.75): ~A" (outp 1))))
    
    (let* ((outp (make-float-vector 10))
	   (gen (make-locsig 0.0 :output outp)))
      (if (not (= (mus-channels gen) 1)) (snd-display "make-locsig->float-vector chans: ~A" (mus-channels gen)))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(locsig gen i 1.0))
      (if (not (mus-arrays-equal? outp (make-float-vector 10 1.0)))
	  (snd-display "locsig->float-vector chan 0: ~A" outp))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(locsig gen i 0.5))
      (if (not (mus-arrays-equal? outp (make-float-vector 10 1.5)))
	  (snd-display "locsig->float-vector chan 0: ~A" outp)))
    
    (let* ((outp (make-float-vector 10))
	   (gen (make-locsig 45.0 :channels 2 :output outp)))
      (if (not (= (mus-channels gen) 2)) (snd-display "make-locsig->float-vector chans (2): ~A" (mus-channels gen)))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(locsig gen i 1.0))
      (if (not (mus-arrays-equal? outp (make-float-vector 10 0.5)))
	  (snd-display "locsig(2)->float-vector chan 0: ~A" outp))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(locsig gen i 0.5))
      (if (not (mus-arrays-equal? outp (make-float-vector 10 0.75)))
	  (snd-display "locsig(2)->float-vector chan 0: ~A" outp)))
    
    (let* ((outp (make-float-vector '(4 10)))
	   (gen (make-locsig 135.0 :output outp)))
      (if (not (= (mus-channels gen) 4)) (snd-display "make-locsig->sd chans (4): ~A" (mus-channels gen)))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(locsig gen i 1.0))
      (if (not (mus-arrays-equal? (outp 0) (make-float-vector 10)))
	  (snd-display "locsig(4)->sd chan 0 (0.5): ~A" (outp 0)))
      (if (not (mus-arrays-equal? (outp 1) (make-float-vector 10 0.5)))
	  (snd-display "locsig(4)->sd chan 1 (0.5) (~A): ~A" (outp 1) gen))
      (if (not (mus-arrays-equal? (outp 2) (make-float-vector 10 0.5)))
	  (snd-display "locsig(4)->sd chan 2 (0.5): ~A" (outp 2)))
      (if (not (mus-arrays-equal? (outp 3) (make-float-vector 10)))
	  (snd-display "locsig(4)->sd chan 3 (0.5): ~A" (outp 3))))

    (set! *mus-array-print-length* 8)
    (let* ((outf1 (make-frample->file "fmv.snd" 1 mus-ldouble mus-next))
	   (outf4 (make-frample->file "fmv1.snd" 4 mus-ldouble mus-next))
	   (revf (make-frample->file "fmv2.snd" 1 mus-ldouble mus-next))
	   (gen1 (make-move-sound (list 0 1000 1 0
					(make-delay 32) 
					(make-env '(0 0 1 1) :length 1001) 
					(make-env '(0 0 1 1) :length 1001)
					(vector (make-delay 32)) 
					(vector (make-env '(0 0 1 1) :length 1001)) 
					#f
					(vector 0 1))
				  outf1))
	   (gen2 (make-move-sound (list 0 1000 4 0
					(make-delay 12) 
					(make-env '(0 0 10 1) :duration 1.0)
					#f
					(make-vector 4 #f)
					(vector (make-env '(0 0 1 1 2 0 3 0 4 0) :duration 1.0)
						(make-env '(0 0 1 0 2 1 3 0 4 0) :duration 1.0)
						(make-env '(0 0 1 0 2 0 3 1 4 0) :duration 1.0)
						(make-env '(0 0 1 0 2 0 3 0 4 1) :duration 1.0))
					#f
					(vector 0 1 2 3))
				  outf4))
	   (gen3 (make-move-sound (list 0 1000 1 1
					(make-delay 32) 
					(make-env '(0 0 1 1) :length 1001) 
					(make-env '(0 0 1 1) :length 1001)
					(vector (make-delay 32)) 
					(vector (make-env '(0 0 1 1) :length 1001)) 
					(vector (make-env '(0 1 1 1) :length 1001))
					(vector 0 1))
				  outf1 revf)))
      
      (print-and-check gen1
		       "move-sound"
		       "move-sound start: 0, end: 1000, out chans 1, rev chans: 0
  doppler delay line[32, step]: [0 0 0 0 0 0 0 0...(0: 0, 0: 0)]
  doppler env linear, pass: 0 (dur: 1001), index: 0, scaler: 1.0000, offset: 0.0000, data: [0 0 1 1]
  global reverb env linear, pass: 0 (dur: 1001), index: 0, scaler: 1.0000, offset: 0.0000, data: [0 0 1 1]
  out_delays[1]:
    [0]: delay line[32, step]: [0 0 0 0 0 0 0 0...(0: 0, 0: 0)]
  out_envs[1]:
    [0]: env linear, pass: 0 (dur: 1001), index: 0, scaler: 1.0000, offset: 0.0000, data: [0 0 1 1]
  rev_envs: nil
  out_map[1]: (0)
  free: arrays: true, gens: false
")
      
      (print-and-check gen2
		       "move-sound"
		       "move-sound start: 0, end: 1000, out chans 4, rev chans: 0
  doppler delay line[12, step]: [0 0 0 0 0 0 0 0...(0: 0, 0: 0)]
  doppler env linear, pass: 0 (dur: 22050), index: 0, scaler: 1.0000, offset: 0.0000, data: [0 0 10 1]
  global reverb null
  out_delays[4]:
    [0]: nil
    [1]: nil
    [2]: nil
    [3]: nil
  out_envs[4]:
    [0]: env linear, pass: 0 (dur: 22050), index: 0, scaler: 1.0000, offset: 0.0000, data: [0 0 1 1 2 0 3 0...(0: 0, 8: 4)]
    [1]: env linear, pass: 0 (dur: 22050), index: 0, scaler: 1.0000, offset: 0.0000, data: [0 0 1 0 2 1 3 0...(0: 0, 8: 4)]
    [2]: env linear, pass: 0 (dur: 22050), index: 0, scaler: 1.0000, offset: 0.0000, data: [0 0 1 0 2 0 3 1...(0: 0, 8: 4)]
    [3]: env linear, pass: 0 (dur: 22050), index: 0, scaler: 1.0000, offset: 0.0000, data: [0 0 1 0 2 0 3 0...(0: 0, 8: 4)]
  rev_envs: nil
  out_map[4]: (0 1 2 3)
  free: arrays: true, gens: false
")
      
      (print-and-check gen3
		       "move-sound"
		       "move-sound start: 0, end: 1000, out chans 1, rev chans: 1
  doppler delay line[32, step]: [0 0 0 0 0 0 0 0...(0: 0, 0: 0)]
  doppler env linear, pass: 0 (dur: 1001), index: 0, scaler: 1.0000, offset: 0.0000, data: [0 0 1 1]
  global reverb env linear, pass: 0 (dur: 1001), index: 0, scaler: 1.0000, offset: 0.0000, data: [0 0 1 1]
  out_delays[1]:
    [0]: delay line[32, step]: [0 0 0 0 0 0 0 0...(0: 0, 0: 0)]
  out_envs[1]:
    [0]: env linear, pass: 0 (dur: 1001), index: 0, scaler: 1.0000, offset: 0.0000, data: [0 0 1 1]
  rev_envs[1]:
    [0]: env linear, pass: 0 (dur: 1001), index: 0, scaler: 1.0000, offset: 0.0000, data: [0 1 1 1]
  out_map[1]: (0)
  free: arrays: true, gens: false
")
      
      (if (not (move-sound? gen1)) (snd-display "move-sound?"))
      (if (equal? gen1 gen2) (snd-display "move-sounds are equal?"))
      (if (not (= (mus-channels gen1) 1)) (snd-display "mus-channels move-sound (1): ~A" (mus-channels gen1)))
      (if (not (= (mus-channels gen2) 4)) (snd-display "mus-channels move-sound (4): ~A" (mus-channels gen2)))
      (mus-reset gen1) ; a no-op
      
      (do ((v (make-float-vector 10))
	   (i 0 (+ i 1)))
	  ((= i 10)
	   (if (not (mus-arrays-equal? v (make-float-vector 10 0.875)))
	       (snd-display "move-sound output: ~A" v)))
	(set! (v i) (+ (move-sound gen1 i 0.5)
		       (gen2 i 0.25)
		       (move-sound gen3 i 0.125))))
      
      (let ((var (catch #t (lambda () (make-move-sound (list 0 1000 1 0 (make-oscil 32) (make-env '(0 0 1 1) :length 1001) 
							     (make-env '(0 0 1 1) :length 1001) (vector (make-delay 32)) 
							     (vector (make-env '(0 0 1 1) :length 1001)) #f (vector 0 1))
						       outf1))
			(lambda args args))))
	(if (not (eq? (car var) 'wrong-type-arg))
	    (snd-display "make-move-sound bad doppler delay: ~A" var)))
      (let ((var (catch #t (lambda () (make-move-sound (list 0 1000 1 0 (make-oscil 32) (make-env '(0 0 1 1) :length 1001) 
							     (make-env '(0 0 1 1) :length 1001) (vector (make-delay 32)))
						       outf1))
			(lambda args args))))
	(if (not (eq? (car var) 'wrong-type-arg))
	    (snd-display "make-move-sound truncated list: ~A" var)))
      (let ((var (catch #t (lambda () (make-move-sound (list 0 1000 1 0 (make-delay 32) (make-env '(0 0 1 1) :length 1001) 
							     #f (vector #f)
							     (vector (make-env '(0 0 1 1) :length 1001)) #f #f)
						       outf1))
			(lambda args args))))
	(if (not (eq? (car var) 'wrong-type-arg))
	    (snd-display "make-move-sound no out map: ~A" var)))
      
      
      (mus-close outf1) 
      (mus-close outf4) 
      (mus-close revf)
      
      (if (file-exists? "fmv.snd") (delete-file "fmv.snd"))
      (if (file-exists? "fmv1.snd") (delete-file "fmv1.snd"))
      (if (file-exists? "fmv2.snd") (delete-file "fmv2.snd"))
      (mus-sound-prune))
    
    (let* ((vo (make-float-vector 1000))
	   (gen1 (make-move-sound (list 0 1000 1 0
					(make-delay 32) 
					(make-env '(0 0 1 1) :length 1001) 
					(make-env '(0 0 1 1) :length 1001)
					(vector (make-delay 32)) 
					(vector (make-env '(0 0 1 1) :length 1001)) 
					#f
					(vector 0 1))
				  vo))
	   (start -1))
      (do ((i 0 (+ i 1)))
	  ((= i 1000))
	(move-sound gen1 i 0.5)
	(if (and (< start 0)
		 (fneq (vo i) 0.0))
	    (set! start i)))
      (if (not (= start 64))
	  (snd-display "move-sound float-vector output start: ~A" start))
      (if (fneq (float-vector-peak vo) 0.484)
	  (snd-display "move-sound float-vector output: ~A" (float-vector-peak vo))))
    
    (let* ((vo (make-float-vector '(1 1000)))
	   (gen1 (make-move-sound (list 0 1000 1 0
					(make-delay 32) 
					(make-env '(0 0 1 1) :length 1001) 
					(make-env '(0 0 1 1) :length 1001)
					(vector (make-delay 32)) 
					(vector (make-env '(0 0 1 1) :length 1001)) 
					#f
					(vector 0 1))
				  vo))
	   (start -1))
      (do ((i 0 (+ i 1)))
	  ((= i 1000))
	(move-sound gen1 i 0.5)
	(if (and (< start 0)
		 (fneq (vo 0 i) 0.0))
	    (set! start i)))
      (if (not (= start 64))
	  (snd-display "move-sound sd output start: ~A" start))
      (if (fneq (maxamp vo) 0.484)
	  (snd-display "move-sound sd output: ~A" (maxamp vo))))
    
    (let* ((vo (make-float-vector 1000))
	   (gen1 (make-move-sound (list 0 1000 1 0
					(make-delay 32) 
					(make-env '(0 0 1 1) :length 1001) 
					(make-env '(0 0 1 1) :length 1001)
					(vector (make-delay 32)) 
					(vector (make-env '(0 0 1 1) :length 1001)) 
					#f
					(vector 0 1))
				  vo))
	   (start -1))
       (do ((i 0 (+ i 1)))
	   ((= i 1000))
	 (move-sound gen1 i 0.5)
	 (if (and (< start 0)
		  (> (abs (vo i)) 0.001))
	     (set! start i)))
      (if (not (= start 64))
	  (snd-display "move-sound opt float-vector output start: ~A" start))
      (if (fneq (float-vector-peak vo) 0.484)
	  (snd-display "move-sound opt float-vector output: ~A" (float-vector-peak vo))))
    
    (let* ((vo (make-float-vector '(1 1000)))
	   (gen1 (make-move-sound (list 0 1000 1 0
					(make-delay 32) 
					(make-env '(0 0 1 1) :length 1001) 
					(make-env '(0 0 1 1) :length 1001)
					(vector (make-delay 32)) 
					(vector (make-env '(0 0 1 1) :length 1001)) 
					#f
					(vector 0 1))
				  vo))
	   (start -1))
       (do ((i 0 (+ i 1)))
	   ((= i 1000))
	 (move-sound gen1 i 0.5)
	 (if (and (< start 0)
		  (> (abs (vo 0 i)) 0.001))
	     (set! start i)))
      (if (not (= start 64))
	  (snd-display "move-sound opt sd output start: ~A" start))
      (if (fneq (maxamp vo) 0.484)
	  (snd-display "move-sound opt sd output: ~A" (maxamp vo))))
    
    (let ((var (catch #t (lambda () (make-src :width -1)) (lambda args args))))
      (if (not (eq? (car var) 'out-of-range))
	  (snd-display "make-src bad width: ~A" var)))
    
    (let ((s1 (make-src (lambda (y) 1.0) 2.0)))
      (for-each (lambda (arg) 
		  (src s1 arg))
		'(25.0 25.0 125.0 -25.0 -125.0)))
    (do ((i 0 (+ i 1)))
	((= i 10))
      (make-src (lambda (y) 1.0) 1.5 :width (+ 5 (* i 10))))
    
    (let ((ctr 0.0))
      (let ((gen (make-src :srate 2.0 :input (lambda (dir) (let ((val ctr)) (set! ctr (+ ctr 1)) val))))
	    (v0 (make-float-vector 10)))
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (set! (v0 i) (src gen 0.0)))
	(set! ctr 0.0) ; will be accessed within reset
	(mus-reset gen)
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (let ((old-val (v0 i))
		(new-val (src gen 0.0)))
	    (if (fneq old-val new-val)
		(snd-display "reset src ~A ~A ~A" i old-val new-val))))))
    
    (let ()
      (define (so1 s p)
	(src s (env p)))
      
      (let ((s1 (make-src :srate 2.0 :input (make-readin "oboe.snd" 0 10000)))
	    (s2 (make-src :srate 2.0 :input (make-readin "oboe.snd" 0 10000)))
	    (s3 (make-src :srate 2.0 :input (make-readin "oboe.snd" 0 10000)))
	    (e1 (make-env '(0 1 2 0.5) :duration 1000))
	    (e2 (make-env '(0 1 2 0.5) :duration 1000))
	    (e3 (make-env '(0 1 2 0.5) :duration 1000)))
	(do ((i 0 (+ i 1)))
	    ((= i 100))
	  (let ((x1 (src s1 (env e1)))
		(ex2 (env e2)))
	    (let ((x2 (src s2 ex2))
		  (x3 (so1 s3 e3)))
	      (if (not (= x1 x2 x3))
		  (format () "~D ~A ~A ~A~%" i x1 x2 x3)))))))

    (let ((gen (make-granulate :expansion 2.0 :input (make-readin "oboe.snd" 0 4000 1 2048))))
      (print-and-check gen 
		       "granulate"
		       "granulate expansion: 2.000 (551/1102), scaler: 0.600, length: 0.150 secs (3308 samps), ramp: 0.400, jitter: 1.000")
      (let ((rd1b (make-readin :file "oboe.snd" :channel 0 :start 4000 :direction 1 :size *clm-file-buffer-size*))
	    (v0 (make-float-vector 1000)))
	(let ((gen1 (make-granulate :expansion 2.0
				    :input (lambda (dir) (readin rd1b)))))
	  (do ((i 0 (+ i 1)))
	      ((= i 1000))
	    (set! (v0 i) (granulate gen)))
	  (let ((v1 (make-float-vector 1000)))
	    (fill-float-vector v1 (if (granulate? gen1) (granulate gen1) -1.0))
	    (let ((worst (abs (- (float-vector-peak v0) (float-vector-peak v1)))))
	      (if (> worst .01) (snd-display "run granulate: ~A" worst))))
	  (if (equal? gen gen1) (snd-display "granulate equal? ~A ~A" gen gen1)))
	(if (= (float-vector-peak v0) 0.0) (snd-display "granulate output peak: ~F?" (float-vector-peak v0))))
      (if (not (granulate? gen)) (snd-display "~A not granulate?" gen))
      (if (fneq (mus-increment gen) 2.0) (snd-display "granulate increment: ~F?" (mus-increment gen)))
      (if (fneq (mus-scaler gen) 0.6) (snd-display "granulate scaler: ~F?" (mus-scaler gen)))
      (if (ffneq (mus-frequency gen) 0.05) (snd-display "granulate frequency: ~F?" (mus-frequency gen)))
      (if (not (= (mus-ramp gen) 1323)) (snd-display "granulate ramp: ~F?" (mus-ramp gen)))
      (if (not (= (mus-length gen) 3308)) (snd-display "granulate length: ~A?" (mus-length gen)))
      (if (not (= (mus-hop gen) 1102)) (snd-display "granulate hop: ~A?" (mus-hop gen)))
      (set! (mus-hop gen) 1000) (if (not (= (mus-hop gen) 1000)) (snd-display "granulate set-hop: ~A?" (mus-hop gen)))
      (set! (mus-ramp gen) 1000) (if (not (= (mus-ramp gen) 1000)) (snd-display "granulate set-ramp: ~A?" (mus-ramp gen)))
      (set! (mus-length gen) 3000) (if (not (= (mus-length gen) 3000)) (snd-display "granulate set-length: ~A?" (mus-length gen)))
      (set! (mus-increment gen) 3.0)
      (if (> (abs (- (mus-increment gen) 3.0)) .01) (snd-display "granulate set-increment: ~F?" (mus-increment gen)))
      (set! (mus-increment gen) 0.0) ; should be a no-op
      (if (> (abs (- (mus-increment gen) 3.0)) .01) (snd-display "granulate set-increment 0.0: ~F?" (mus-increment gen)))
      (set! (mus-location gen) 1)
      (if (not (= (mus-location gen) 1)) (snd-display "mus-location grn: ~A" (mus-location gen)))
      (set! (mus-frequency gen) .1)
      (if (fneq (mus-frequency gen) .1) (snd-display "set granulate freq: ~A" (mus-frequency gen))))
    (let ((var (catch #t (lambda () (make-granulate :hop 35.0 :length 35.0)) (lambda args args))))
      (if (not (eq? (car var) 'out-of-range))
	  (snd-display "make-granulate bad sizes: ~A" var)))
    
    (let ((ind (new-sound :size 10)))
      (set! (sample 2) .1)
      (set! (sample 6) -.5)
      (let ((vals (map values (make-sampler))))
	(if (not (equivalent? vals '(0.0 0.0 0.1 0.0 0.0 0.0 -0.5 0.0 0.0 0.0)))
	    (snd-display "rd new: ~A" vals)))
      (close-sound ind))
    (let* ((ind (open-sound "oboe.snd"))
	   (mx (maxamp))
	   (rd (make-sampler 0)))
      (if (not (= (length rd) 50828))
	  (snd-display "sampler (oboe) length: ~A" (length rd)))
      (let ((grn (make-granulate :expansion 2.0
				 :input (lambda (dir) (read-sample rd))
				 :edit (lambda (g)
					 (float-vector-scale! (mus-data g) 2.0)
					 0))))
	(map-channel (lambda (y) (granulate grn)))
	(if (or (< (/ (maxamp) mx) 1.4) (> (/ mx (maxamp)) 2.5))
	    (snd-display "gran edit 2* (0): ~A ~A" mx (maxamp)))
	(undo))
      (let ((grn (make-granulate :expansion 2.0
				 :input (let ((rd (make-sampler 0)))
					  (lambda (dir) 
					    (read-sample rd)))
				 :edit (lambda (g)
					 (float-vector-scale! (mus-data g) 4.0)
					 0))))
	(map-channel (lambda (y) (granulate grn)))
	(if (or (< (/ (maxamp) mx) 3.0) (> (/ mx (maxamp)) 6.0))
	    (snd-display "gran edit 4* (0): ~A ~A" mx (maxamp)))
	(revert-sound ind))
      (let ((grn (make-granulate :expansion 2.0
				 :input (let ((rd (make-sampler 0)))
					  (lambda (dir)
					    (read-sample rd)))
				 :edit (lambda (g)
					 (float-vector-scale! (mus-data g) 2.0)
					 0))))
	(map-channel (lambda (y) (granulate grn)))
	(if (or (< (/ (maxamp) mx) 1.4) (> (/ mx (maxamp)) 2.5))
	    (snd-display "gran edit 2* (1): ~A ~A" mx (maxamp)))
	(undo)
	(let ((grn (make-granulate :expansion 2.0
				   :edit (lambda (g)
					   (float-vector-scale! (mus-data g) 4.0)
					   0)
				   :input (let ((rd (make-sampler 0)))
					    (lambda (dir) 
					      (read-sample rd))))))
	  (map-channel (lambda (y) (granulate grn)))
	  (if (or (< (/ (maxamp) mx) 2.9) (> (/ mx (maxamp)) 6.0))
	      (snd-display "gran edit 4* (1): ~A ~A" mx (maxamp)))
	  (revert-sound ind)))
      (let ((grn (make-granulate :expansion 2.0 
				 :input (make-sampler 0)
				 :edit (lambda (g)
					 (float-vector-scale! (mus-data g) 2.0)
					 0))))
	(map-channel (lambda (y) (granulate grn)))
	(if (or (< (/ (maxamp) mx) 1.4) (> (/ mx (maxamp)) 2.5))
	    (snd-display "gran edit 2* (2): ~A ~A" mx (maxamp)))
	(undo)
	(let ((grn (make-granulate :expansion 2.0
				   :input (let ((rd (make-sampler 0)))
					    (lambda (dir) 
					      (read-sample rd)))
				    :edit (lambda (g)
					    (float-vector-scale! (mus-data g) 4.0) 0))))
	  (map-channel (lambda (y) (granulate grn)))
	  (if (or (< (/ (maxamp) mx) 3.0) (> (/ mx (maxamp)) 6.0))
	      (snd-display "gran edit 4* (2): ~A ~A" mx (maxamp)))))
      (close-sound ind))
    
    (let ((ind (open-sound "oboe.snd")))
      (let ((grn (make-granulate :expansion 2.0 :length .01 :hop .05 :input (let ((rd (make-sampler))) (lambda (dir) (next-sample rd))))))
	(map-channel (lambda (y) (granulate grn)))
	(let ((mx (maxamp)))
	  (if (> mx .2) (snd-display "trouble in granulate len .01 hop .05: ~A" mx))
	  (undo)))
      (let ((grn (make-granulate :expansion 2.0 :length .04 :hop .05 :input (let ((rd (make-sampler))) (lambda (dir) (next-sample rd))))))
	(map-channel (lambda (y) (granulate grn)))
	(let ((mx (maxamp)))
	  (if (> mx .2) (snd-display "trouble in granulate len .04 hop .05: ~A" mx))
	  (undo)))
      (let ((grn (make-granulate :expansion 2.0 :length .01 :hop .25 :input (let ((rd (make-sampler))) (lambda (dir) (next-sample rd))))))
	(map-channel (lambda (y) (granulate grn)))
	(let ((mx (maxamp)))
	  (if (> mx .2) (snd-display "trouble in granulate len .01 hop .25: ~A" mx))
	  (undo)))
      (let ((grn (make-granulate :expansion 2.0 :length .4 :hop .5 :input (let ((rd (make-sampler))) (lambda (dir) (next-sample rd))))))
	(map-channel (lambda (y) (granulate grn)))
	(let ((mx (maxamp)))
	  (if (> mx .2) (snd-display "trouble in granulate len .4 hop .5: ~A" mx))
	  (undo)))
      (close-sound ind))
    
    (let ((ind (new-sound :size 1000)))
      (let ((gen (make-granulate :jitter 0.0 :hop .004 :length .001 :input (lambda (dir) .1))))
	(map-channel (lambda (y) (granulate gen))))
      (let ((mx (maxamp)))
	(if (fneq mx 0.06) (snd-display "gran 0 max: ~A" mx)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30) 
		       #r(0.000 0.007 0.013 0.020 0.027 0.033 0.040 0.047 0.053 0.060 0.060 0.060 0.060 0.060 0.060 0.053 
				     0.047 0.040 0.033 0.027 0.020 0.013 0.007 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "gran 0 data: ~A" (channel->float-vector 0 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 85 30) 
		       #r(0.000 0.000 0.000 0.000 0.007 0.013 0.020 0.027 0.033 0.040 0.047 0.053 0.060 0.060 0.060 0.060
				     0.060 0.060 0.053 0.047 0.040 0.033 0.027 0.020 0.013 0.007 0.000 0.000 0.000 0.000)))
	  (snd-display "gran 0 data 85: ~A" (channel->float-vector 85 30)))
      (undo)
      
      (let ((gen (make-granulate :jitter 0.0 :hop .002 :length .001 :input (lambda (dir) .1))))
	(map-channel (lambda (y) (granulate gen))))
      (let ((mx (maxamp)))
	(if (fneq mx 0.06) (snd-display "gran 1 max: ~A" mx)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30) 
		       #r(0.000 0.007 0.013 0.020 0.027 0.033 0.040 0.047 0.053 0.060 0.060 0.060 0.060 0.060 0.060 0.053 
				     0.047 0.040 0.033 0.027 0.020 0.013 0.007 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "gran 1 data: ~A" (channel->float-vector 0 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 40 30) 
		       #r(0.000 0.000 0.000 0.000 0.000 0.007 0.013 0.020 0.027 0.033 0.040 0.047 0.053 0.060 0.060 0.060 
				     0.060 0.060 0.060 0.053 0.047 0.040 0.033 0.027 0.020 0.013 0.007 0.000 0.000 0.000)))
	  (snd-display "gran 1 data 40: ~A" (channel->float-vector 85 30)))
      (undo)
      
      (let ((gen (make-granulate :jitter 0.0 :hop .002 :length .001 :ramp .1 :input (lambda (dir) .1))))
	(map-channel (lambda (y) (granulate gen))))
      (let ((mx (maxamp)))
	(if (fneq mx 0.06) (snd-display "gran 2 max: ~A" mx)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30) 
		       #r(0.000 0.030 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 
				     0.060 0.060 0.060 0.060 0.060 0.060 0.030 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "gran 2 data: ~A" (channel->float-vector 0 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 40 30) 
		       #r(0.000 0.000 0.000 0.000 0.000 0.030 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060
				     0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.030 0.000 0.000 0.000)))
	  (snd-display "gran 2 data 40: ~A" (channel->float-vector 40 30)))
      (undo)
      
      (let ((gen (make-granulate :jitter 0.0 :hop .002 :length .001 :ramp .5 :input (lambda (dir) .1))))
	(map-channel (lambda (y) (granulate gen))))
      (let ((mx (maxamp)))
	(if (fneq mx 0.06) (snd-display "gran 3 max: ~A" mx)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30) 
		       #r(0.000 0.005 0.011 0.016 0.022 0.027 0.033 0.038 0.044 0.049 0.055 0.060 0.060 0.055 0.049 0.044 
				     0.038 0.033 0.027 0.022 0.016 0.011 0.005 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "gran 3 data: ~A" (channel->float-vector 0 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 85 30) 
		       #r(0.000 0.000 0.000 0.000 0.005 0.011 0.016 0.022 0.027 0.033 0.038 0.044 0.049 0.055 0.060 0.060 
				     0.055 0.049 0.044 0.038 0.033 0.027 0.022 0.016 0.011 0.005 0.000 0.000 0.000 0.000)))
	  (snd-display "gran 3 data 85: ~A" (channel->float-vector 85 30)))
      (undo)
      
      (let ((gen (make-granulate :jitter 0.0 :hop .001 :length .001 :ramp .5 :input (lambda (dir) .1))))
	(map-channel (lambda (y) (granulate gen))))
      (let ((mx (maxamp)))
	(if (fneq mx 0.06) (snd-display "gran 4 max: ~A" mx)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30) 
		       #r(0.000 0.005 0.011 0.016 0.022 0.027 0.033 0.038 0.044 0.049 0.055 0.060 0.060 0.055 0.049 0.044 
				     0.038 0.033 0.027 0.022 0.016 0.011 0.005 0.005 0.011 0.016 0.022 0.027 0.033 0.038)))
	  (snd-display "gran 4 data: ~A" (channel->float-vector 0 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 85 30) 
		       #r(0.022 0.016 0.011 0.005 0.005 0.011 0.016 0.022 0.027 0.033 0.038 0.044 0.049 0.055 0.060 0.060 
				     0.055 0.049 0.044 0.038 0.033 0.027 0.022 0.016 0.011 0.005 0.005 0.011 0.016 0.022)))
	  (snd-display "gran 4 data 85: ~A" (channel->float-vector 85 30)))
      (undo)
      
      (let ((gen (make-granulate :jitter 0.0 :hop .001 :length .001 :ramp .25 :scaler 1.0 :input (lambda (dir) .1))))
	(map-channel (lambda (y) (granulate gen))))
      (let ((mx (maxamp)))
	(if (fneq mx 0.1) (snd-display "gran 5 max: ~A" mx)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30) 
		       #r(0.000 0.020 0.040 0.060 0.080 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 
				     0.100 0.100 0.100 0.080 0.060 0.040 0.020 0.020 0.040 0.060 0.080 0.100 0.100 0.100)))
	  (snd-display "gran 5 data: ~A" (channel->float-vector 0 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 85 30) 
		       #r(0.080 0.060 0.040 0.020 0.020 0.040 0.060 0.080 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 
				     0.100 0.100 0.100 0.100 0.100 0.100 0.080 0.060 0.040 0.020 0.020 0.040 0.060 0.080)))
	  (snd-display "gran 5 data 85: ~A" (channel->float-vector 85 30)))
      (undo)
      
      (let ((gen (make-granulate :jitter 0.0 :hop .001 :length .002 :ramp .5 :scaler 1.0 :input (lambda (dir) .1))))
	(map-channel (lambda (y) (granulate gen))))
      (let ((mx (maxamp)))
	(if (fneq mx 0.105) (snd-display "gran 6 max: ~A" mx)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30) 
		       #r(0.000 0.005 0.009 0.014 0.018 0.023 0.027 0.032 0.036 0.041 0.045 0.050 0.055 0.059 0.064 0.068 
				     0.073 0.077 0.082 0.086 0.091 0.095 0.100 0.105 0.105 0.105 0.105 0.105 0.105 0.105)))
	  (snd-display "gran 6 data: ~A" (channel->float-vector 0 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 85 30) (make-float-vector 30 0.105)))
	  (snd-display "gran 6 data 85: ~A" (channel->float-vector 85 30)))
      (undo)
      
      (let ((gen (make-granulate :jitter 0.0 :hop .001 :length .005 :ramp .5 :scaler 1.0 :input (lambda (dir) .1))))
	(map-channel (lambda (y) (granulate gen))))
      (let ((mx (maxamp)))
	(if (fneq mx 0.264) (snd-display "gran 7 max: ~A" mx)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30) 
		       #r(0.000 0.002 0.004 0.005 0.007 0.009 0.011 0.013 0.015 0.016 0.018 0.020 0.022 0.024 0.025 0.027 
				     0.029 0.031 0.033 0.035 0.036 0.038 0.040 0.044 0.047 0.051 0.055 0.058 0.062 0.065)))
	  (snd-display "gran 7 data: ~A" (channel->float-vector 0 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 85 30) 
		       #r(0.244 0.244 0.244 0.244 0.245 0.247 0.249 0.251 0.253 0.255 0.256 0.258 0.260 0.262 0.264 0.264 
				     0.262 0.260 0.258 0.256 0.255 0.253 0.251 0.249 0.247 0.245 0.245 0.247 0.249 0.251)))
	  (snd-display "gran 7 data 85: ~A" (channel->float-vector 85 30)))
      (undo)
      
      (let ((gen (make-granulate :jitter 0.0 :hop .01 :length .001 :ramp .5 :scaler 1.0 :expansion 2.0 :input (lambda (dir) .1))))
	(map-channel (lambda (y) (granulate gen))))
      (let ((mx (maxamp)))
	(if (fneq mx 0.1) (snd-display "gran 8 max: ~A" mx)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30) 
		       #r(0.000 0.009 0.018 0.027 0.036 0.045 0.055 0.064 0.073 0.082 0.091 0.100 0.100 0.091 0.082 0.073 
				     0.064 0.055 0.045 0.036 0.027 0.018 0.009 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "gran 8 data: ~A" (channel->float-vector 0 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 220 30) 
		       #r(0.000 0.009 0.018 0.027 0.036 0.045 0.055 0.064 0.073 0.082 0.091 0.100 0.100 0.091 0.082 0.073 
				     0.064 0.055 0.045 0.036 0.027 0.018 0.009 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "gran 8 data 220: ~A" (channel->float-vector 220 30)))
      (undo)
      
      (let ((gen (make-granulate :jitter 0.0 :hop .01 :length .001 :ramp .5 :scaler 1.0 :expansion 0.5 :input (lambda (dir) .1))))
	(map-channel (lambda (y) (granulate gen))))
      (let ((mx (maxamp)))
	(if (fneq mx 0.1) (snd-display "gran 9 max: ~A" mx))) ; same as 8 because expansion hits the input counter
      (if (not (mus-arrays-equal? (channel->float-vector 0 30) 
		       #r(0.000 0.009 0.018 0.027 0.036 0.045 0.055 0.064 0.073 0.082 0.091 0.100 0.100 0.091 0.082 0.073 
				     0.064 0.055 0.045 0.036 0.027 0.018 0.009 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "gran 9 data: ~A" (channel->float-vector 0 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 220 30) 
		       #r(0.000 0.009 0.018 0.027 0.036 0.045 0.055 0.064 0.073 0.082 0.091 0.100 0.100 0.091 0.082 0.073 
				     0.064 0.055 0.045 0.036 0.027 0.018 0.009 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "gran 9 data 220: ~A" (channel->float-vector 220 30)))
      (undo)
      
      (let ((gen (make-granulate :jitter 0.0 :hop .001 :length .005 :ramp .5 :scaler 1.0
				 :input (lambda (dir) .1)
				 :edit (lambda (g)
					 (float-vector-scale! (mus-data g) 2.0)
					 0))))
	(map-channel (lambda (y) (granulate gen))))
      (let ((mx (maxamp)))
	(if (fneq mx (* 2 0.264)) (snd-display "gran 10 max: ~A" mx)))
      (if (not (mus-arrays-equal? (float-vector-scale! (channel->float-vector 0 30) 0.5)
		       #r(0.000 0.002 0.004 0.005 0.007 0.009 0.011 0.013 0.015 0.016 0.018 0.020 0.022 0.024 0.025 0.027 
				     0.029 0.031 0.033 0.035 0.036 0.038 0.040 0.044 0.047 0.051 0.055 0.058 0.062 0.065)))
	  (snd-display "gran 10 data: ~A" (channel->float-vector 0 30)))
      (if (not (mus-arrays-equal? (float-vector-scale! (channel->float-vector 85 30) 0.5)
		       #r(0.244 0.244 0.244 0.244 0.245 0.247 0.249 0.251 0.253 0.255 0.256 0.258 0.260 0.262 0.264 0.264 
				     0.262 0.260 0.258 0.256 0.255 0.253 0.251 0.249 0.247 0.245 0.245 0.247 0.249 0.251)))
	  (snd-display "gran 10 data 85: ~A" (channel->float-vector 85 30)))
      (undo)
      
      (let ((forward #t)
	    (ctr -0.5)
	    (incr .001))
	(let ((f1 (lambda (dir) 
		    (set! ctr (+ ctr incr))))
	      (f2 (lambda (g)
		    (if forward ; no change to data
			(set! forward #f)
			(let ((grain (subvector (mus-data g) (mus-length g))))
			  (set! forward #t)
			  (reverse! grain))) ; should get ramps going up then down across overall rising ramp
		    (mus-length g))))
	  (let ((gen (make-granulate :jitter 0.0 :hop .005 :length .002 :ramp 0.0 :scaler 1.0 :input f1 :edit f2)))
	    (map-channel (lambda (y) (granulate gen))))))
      (let ((mx (maxamp)))
	(if (> mx 0.6) (snd-display "gran 11 max: ~A" mx)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30)
		       #r(-0.499 -0.498 -0.497 -0.496 -0.495 -0.494 -0.493 -0.492 -0.491 -0.490 -0.489 -0.488 -0.487 -0.486 
				     -0.485 -0.484 -0.483 -0.482 -0.481 -0.480 -0.479 -0.478 -0.477 -0.476 -0.475 -0.474 -0.473 -0.472 -0.471 -0.470)))
	  (snd-display "gran 11 data: ~A" (channel->float-vector 0 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 100 30)
		       #r(0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 -0.345 -0.346 -0.347 -0.348 -0.349 
				     -0.350 -0.351 -0.352 -0.353 -0.354 -0.355 -0.356 -0.357 -0.358 -0.359 -0.360 -0.361 -0.362 -0.363 -0.364)))
	  (snd-display "gran 11 data 100: ~A" (channel->float-vector 100 30)))
      (undo)
      
      (let ((ctr -0.5)
	    (incr .001))
	(let ((gen (make-granulate :jitter 0.0 :hop .005 :length .002 :ramp 0.0 :scaler 1.0
				   :input (lambda (dir) (set! ctr (+ ctr incr))))))
	  (map-channel (lambda (y) (granulate gen)))))
      (let ((mx (maxamp)))
	(if (> mx 0.6) (snd-display "gran 12 max: ~A" mx)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30)
		       #r(-0.499 -0.498 -0.497 -0.496 -0.495 -0.494 -0.493 -0.492 -0.491 -0.490 -0.489 -0.488 -0.487 -0.486 
				     -0.485 -0.484 -0.483 -0.482 -0.481 -0.480 -0.479 -0.478 -0.477 -0.476 -0.475 -0.474 -0.473 -0.472 -0.471 -0.470)))
	  (snd-display "gran 12 data: ~A" (channel->float-vector 0 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 100 30)
		       #r(0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 -0.389 -0.388 -0.387 -0.386 -0.385 
				     -0.384 -0.383 -0.382 -0.381 -0.380 -0.379 -0.378 -0.377 -0.376 -0.375 -0.374 -0.373 -0.372 -0.371 -0.370)))
	  (snd-display "gran 12 data 100: ~A" (channel->float-vector 100 30)))
      (undo)
      
      (let ((gen (make-granulate :jitter 0.0 :hop .001 :length .005 :ramp .5 :scaler 1.0
				 :input (lambda (dir) .1)
				 :edit (lambda (g)
					 (float-vector-scale! (mus-data g) 2.0)
					 0))))
	(map-channel (lambda (y) (granulate gen))))
      (let ((mx (maxamp)))
	(if (> mx .6) (snd-display "gran 13 max: ~A" mx)))
      (if (not (mus-arrays-equal? (float-vector-scale! (channel->float-vector 0 30) 0.5)
		       #r(0.000 0.002 0.004 0.005 0.007 0.009 0.011 0.013 0.015 0.016 0.018 0.020 0.022 0.024 0.025 0.027 
				     0.029 0.031 0.033 0.035 0.036 0.038 0.040 0.044 0.047 0.051 0.055 0.058 0.062 0.065)))
	  (snd-display "gran 13 data: ~A" (channel->float-vector 0 30)))
      (if (not (mus-arrays-equal? (float-vector-scale! (channel->float-vector 85 30) 0.5)
		       #r(0.244 0.244 0.244 0.244 0.245 0.247 0.249 0.251 0.253 0.255 0.256 0.258 0.260 0.262 0.264 0.264 
				     0.262 0.260 0.258 0.256 0.255 0.253 0.251 0.249 0.247 0.245 0.245 0.247 0.249 0.251)))
	  (snd-display "gran 13 data 85: ~A" (channel->float-vector 85 30)))
      (undo)
      
      (let ((forward #t)
	    (ctr -0.5)
	    (incr .001))
	(let ((gen (make-granulate :jitter 0.0 :hop .005 :length .002 :ramp 0.0 :scaler 1.0
				   :input (lambda (dir) (set! ctr (+ ctr incr)))
				   :edit (lambda (g)
					   (if forward
					       (set! forward #f)
					       (let ((grain (subvector (mus-data g) (mus-length g))))
						 (set! forward #t)
						 (reverse! grain)))
					   (mus-length g)))))
	  (map-channel (lambda (y) (granulate gen)))))
      (let ((mx (maxamp)))
	(if (> mx 0.6) (snd-display "gran 14 max: ~A" mx)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30)
		       #r(-0.499 -0.498 -0.497 -0.496 -0.495 -0.494 -0.493 -0.492 -0.491 -0.490 -0.489 -0.488 -0.487 -0.486 
				     -0.485 -0.484 -0.483 -0.482 -0.481 -0.480 -0.479 -0.478 -0.477 -0.476 -0.475 -0.474 -0.473 -0.472 -0.471 -0.470)))
	  (snd-display "gran 14 data: ~A" (channel->float-vector 0 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 100 30)
		       #r(0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 -0.345 -0.346 -0.347 -0.348 -0.349 
				     -0.350 -0.351 -0.352 -0.353 -0.354 -0.355 -0.356 -0.357 -0.358 -0.359 -0.360 -0.361 -0.362 -0.363 -0.364)))
	  (snd-display "gran 14 data 100: ~A" (channel->float-vector 100 30)))
      (undo)
      
      (let ((gen (make-granulate :jitter 0.0 :hop .004 :length .001 :ramp 0.0 :input (lambda (dir) .1)))
	    (e (make-env '(0 0 1 .5) :length 1001)))
	(let ((base-ramp-len (mus-length gen)))
	  (map-channel 
	   (lambda (y) 
	     (let ((result (granulate gen)))
	       (set! (mus-ramp gen) (round (* base-ramp-len (env e))))
	       result))))
	(let ((mx (maxamp)))
	  (if (fneq mx 0.06) (snd-display "granf 0 max: ~A" mx)))
	(if (> (abs (- (mus-ramp gen) (* .5 (mus-length gen)))) 1)
	    (snd-display "granf 0 ramp: ~A ~A" (mus-ramp gen) (mus-length gen))))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30) 
		       #r(0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 
				     0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "granf 0 data: ~A" (channel->float-vector 0 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 440 30) 
		       #r(0.000 0.012 0.024 0.036 0.048 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 
				     0.060 0.060 0.060 0.060 0.060 0.048 0.036 0.024 0.012 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "granf 0 data 440: ~A" (channel->float-vector 440 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 880 30) 
		       #r(0.000 0.006 0.012 0.018 0.024 0.030 0.036 0.042 0.048 0.054 0.060 0.060 0.060 0.060 
				     0.054 0.048 0.042 0.036 0.030 0.024 0.018 0.012 0.006 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "granf 0 data 880: ~A" (channel->float-vector 880 30)))
      (undo)
      
      (let ((gen (make-granulate :jitter 0.0 :hop .004 :length .001 :ramp 0.0 :input (lambda (dir) .1))))
	(let ((base-hop-len (mus-hop gen))
	      (e (make-env '(0 1 1 .25) :length 1001)))
	  (map-channel 
	   (lambda (y) 
	     (let ((result (granulate gen)))
	       (set! (mus-hop gen) (round (* base-hop-len (env e))))
	       result))))
	(let ((mx (maxamp)))
	  (if (fneq mx 0.06) (snd-display "granf 1 max: ~A" mx)))
	(if (> (abs (- (mus-hop gen) (* .001 *clm-srate*))) 1)
	    (snd-display "granf 1 hop: ~A ~A, ~A ~A" (mus-hop gen) (abs (- (mus-hop gen) (* .001 (srate)))) (srate) *clm-srate*)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30) 
		       #r(0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 
				     0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "granf 1 data: ~A" (channel->float-vector 0 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 900 30) 
		       #r(0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.000 0.000 
				     0.000 0.000 0.000 0.000 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060)))
	  (snd-display "granf 1 data 900: ~A" (channel->float-vector 900 30)))
      (undo)
      
      (let ((gen (make-granulate :jitter 0.0 :hop .004 :length .001 :ramp 0.0 :input  (lambda (dir) .1))))
	(let ((base-freq (mus-frequency gen))
	      (e (make-env '(0 1 1 .25) :length 1001)))  
	  (map-channel 
	   (lambda (y) 
	     (let ((result (granulate gen)))
	       (set! (mus-frequency gen) (* base-freq (env e)))
	       result))))
	(let ((mx (maxamp)))
	  (if (fneq mx 0.06) (snd-display "granf 2 max: ~A" mx)))
	(if (> (abs (- (mus-hop gen) (* .001 *clm-srate*))) 1)
	    (snd-display "granf 2 hop: ~A" (mus-hop gen))))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30) 
		       #r(0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 
				     0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "granf 2 data: ~A" (channel->float-vector 0 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 900 30) 
		       #r(0.060 0.060 0.060 0.060 0.060 0.000 0.000 0.000 0.000 0.000 0.000 0.060 0.060 0.060 
				     0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060)))
	  (snd-display "granf 2 data 900: ~A" (channel->float-vector 900 30)))
      (undo)
      
      (let ((gen (make-granulate :jitter 0.0 :hop .002 :length .001 :ramp 0.0 :scaler 1.0 :input (lambda (dir) .1))))
	(map-channel (lambda (y) (granulate gen))))
      (let ((mx (maxamp)))
	(if (fneq mx 0.1) (snd-display "granf 3 max: ~A" mx)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30) 
		       #r(0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 
				     0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "gran 3 data: ~A" (channel->float-vector 0 30)))
      (undo)
      
      (let ((gen (make-granulate :jitter 0.0 :hop .004 :length .001 :ramp 0.0 :scaler 1.0 :input (lambda (dir) .1)))
	    (e (make-env '(0 1 1 0.0) :length 1001)))
	(map-channel 
	 (lambda (y) 
	   (let ((result (granulate gen)))
	     (set! (mus-scaler gen) (env e))
	     result))))
      (let ((mx (maxamp)))
	(if (fneq mx 0.1) (snd-display "granf 4 max: ~A" mx)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30) 
		       #r(0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 
				     0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.100 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "granf 4 data: ~A" (channel->float-vector 0 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 440 30) 
		       #r(0.056 0.056 0.056 0.056 0.056 0.056 0.056 0.056 0.056 0.056 0.056 0.056 0.056 0.056 
				     0.056 0.056 0.056 0.056 0.056 0.056 0.056 0.056 0.056 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "granf 4 data 440: ~A" (channel->float-vector 440 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 900 30) 
		       #r(0.012 0.012 0.012 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 
				     0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "granf 4 data 900: ~A" (channel->float-vector 900 30)))
      (undo)
      
      (let ((gen (make-granulate :jitter 0.0 :hop .006 :length .001 :ramp 0.0 :max-size 2200 :input  (lambda (dir) .1)))
	    (e (make-env '(0 1 1 5) :length 1001)))
	(let ((base-len (mus-length gen)))
	  (map-channel 
	   (lambda (y) 
	     (let ((result (granulate gen)))
	       (set! (mus-length gen) (round (* base-len (env e))))
	       result)))
	  (let ((mx (maxamp)))
	    (if (fneq mx 0.06) (snd-display "granf 5 max: ~A" mx)))
	  (if (> (abs (- (mus-length gen) (* 5 base-len))) 10)
	      (snd-display "granf 5 length: ~A ~A" (mus-length gen) (* 5 base-len)))))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30) 
		       #r(0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 
				     0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "granf 5 data: ~A" (channel->float-vector 0 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 440 30) 
		       #r(0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 
				     0.060 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "granf 5 data 440: ~A" (channel->float-vector 440 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 800 30) (make-float-vector 30 0.060)))
	  (snd-display "granf 5 data 800: ~A" (channel->float-vector 800 30)))
      (undo)
      
      (let ((gen (make-granulate :jitter 0.0 :hop .006 :length .005 :ramp 0.0 :max-size 2200 :input (lambda (dir) .1)))
	    (e (make-env '(0 1 1 .2) :length 1001)))
	(let ((base-len (mus-length gen)))
	  (map-channel 
	   (lambda (y) 
	     (let ((result (granulate gen)))
	       (set! (mus-length gen) (round (* base-len (env e))))
	       result)))
	  (let ((mx (maxamp)))
	    (if (fneq mx 0.06) (snd-display "granf 6 max: ~A" mx)))
	  (if (> (abs (- (mus-length gen) (* .2 base-len))) 4)
	      (snd-display "granf 6 length: ~A ~A" (mus-length gen) (* .2 base-len)))))
      (if (not (mus-arrays-equal? (channel->float-vector 0 30) (make-float-vector 30 0.060)))
	  (snd-display "granf 6 data: ~A" (channel->float-vector 0 30)))
      (if (not (mus-arrays-equal? (channel->float-vector 820 30) 
		       #r(0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.060 0.000 0.000 
				     0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000)))
	  (snd-display "granf 6 data 820: ~A" (channel->float-vector 820 30)))
      (undo)
      
      (let ((max-list (lambda ()
			(let ((pts ()) 
			      (samp 0)
			      (lasty 0.0))
			  (scan-channel (lambda (y) 
					  (if (and (< lasty 0.1)
						   (>= y .1))
					      (set! pts (cons samp pts)))
					  (set! lasty y)
					  (set! samp (+ samp 1))
					  #f)) 
			  (reverse pts)))))
	(let ((gen (make-granulate :jitter 0.0 :hop .01 :length .001 :ramp .5 :scaler 1.0 :expansion 0.5 :input (lambda (dir) .1))))
	  (map-channel (lambda (y) (granulate gen)))
	  (let ((vals (max-list)))
	    (if (not (equal? vals '(11 231 451 671 891)))
		(snd-display "grn jitter 0 max: ~A" vals)))
	  (undo))
	
	(let ((oldvals #f))
	  (let ((gen (make-granulate :jitter 0.3 :hop .01 :length .001 :ramp .5 :scaler 1.0 :expansion 0.5 :input (lambda (dir) .1))))
	    (map-channel (lambda (y) (granulate gen)))
	    ;; (11 232 490 736 982) or whatever
	    (let ((vals (max-list)))
	      (if (equal? vals '(11 231 451 671 891))
		  (snd-display "grn jitter 0.3 max: ~A" vals))
	      (set! oldvals vals))
	    (undo))
	  
	  (let ((gen (make-granulate :jitter 0.3 :hop .01 :length .001 :ramp .5 :scaler 1.0 :expansion 0.5 :input (lambda (dir) .1))))
	    (map-channel (lambda (y) (granulate gen)))
	    (let ((vals (max-list)))
	      (if (equal? vals oldvals)
		  (snd-display "grn jitter 0.3 max: ~A ~A" vals oldvals)))
	    (undo)))
	
	(let ((oldvals #f)
	      (seed 0))
	  (let ((gen (make-granulate :jitter 1.0 :hop .01 :length .001 :ramp .5 :scaler 1.0 :expansion 0.5 :input (lambda (dir) .1))))
	    (set! seed (mus-location gen))
	    (map-channel (lambda (y) (granulate gen))))
	  (set! oldvals (max-list))
	  (undo)
	  
	  (let ((gen (make-granulate :jitter 1.0 :hop .01 :length .001 :ramp .5 :scaler 1.0 :expansion 0.5 :input (lambda (dir) .1))))
	    (set! (mus-location gen) seed)
	    (map-channel (lambda (y) (granulate gen))))
	  (let ((vals (max-list)))
	    (if (not (equal? vals oldvals))
		(snd-display "grn jitter 1.0 max with seed: ~A ~A" vals oldvals)))
	  (undo)))
      
      (let ((fname (file-name ind)))
	(close-sound ind)
	(delete-file fname)
	(when (and with-motif
		   (view-files-dialog #f))
	  (set! (view-files-files (view-files-dialog #f)) ())
	  (if (pair? (view-files-files (view-files-dialog #f)))
	      (snd-display "set vf files list null: ~A" (view-files-files (view-files-dialog #f)))))))
    
    ;; granulate with jitter=0, small hop (comb filter effect)
    (let* ((ind (new-sound "tmp.snd" 1 22050 mus-ldouble mus-next :size 10000))
	   (gen (make-granulate :expansion 20.0
				:input (lambda (dir) .01)
				:length .00995
				:hop .01
				:ramp 0.0
				:scaler 1.0
				:jitter 0.0)))
      (clm-channel gen) ; -> .01 max (stable)
      (if (fneq (maxamp) .01) (snd-display "granulate stable 1: ~A" (maxamp)))
      (let ((minval (scan-channel (lambda (y) (< y .0099)))))
	(if minval (snd-display "granulate stable 1 min: ~A" minval)))
      (undo)
      (set! gen (make-granulate :expansion 20.0
				:input (lambda (dir) .1)
				:length .00995
				:hop .01
				:ramp 0.0
				:scaler 0.5
				:jitter 0.0))
      (clm-channel gen) ; -> .05 max (stable)
      (if (fneq (maxamp) .05) (snd-display "granulate stable 2: ~A" (maxamp)))
      (let ((minval (scan-channel (lambda (y) (< y .0499)))))
	(if minval (snd-display "granulate stable 2 min: ~A" minval)))
      (undo)
      
      (set! gen (make-granulate :expansion 10.0
				:input (lambda (dir) .05)
				:length .099975
				:hop .1
				:ramp 0.0
				:scaler 1.0
				:jitter 0.0))
      (clm-channel gen) ; -> .05 max (stable)
      (if (fneq (maxamp) .05) (snd-display "granulate stable 3: ~A" (maxamp)))
      (let ((minval (scan-channel (lambda (y) (< y .0499)))))
	(if minval (snd-display "granulate stable 3 min: ~A ~A" minval (sample (cadr minval)))))
      (undo)
      
      (let ((ctr -0.0001))
	(set! gen (make-granulate :expansion 2.0
				  :input (lambda (dir) (set! ctr (+ ctr .0001)))
				  :length .01
				  :hop .1
				  :ramp 0.0
				  :scaler 1.0
				  :jitter 0.0))
	(clm-channel gen))
      (if (fneq (maxamp) .462) (snd-display "granulate ramped 4: ~A" (maxamp)))
      (let ((vals (count-matches (lambda (y) (> (abs y) 0.0)))))
	(if (> (abs (- vals 1104)) 10) (snd-display "granulate ramped 4 not 0.0: ~A" vals)))
      (if (not (and (mus-arrays-equal? (channel->float-vector 2203 10)
			    #r(0.000 0.000 0.110 0.110 0.110 0.111 0.111 0.111 0.111 0.111))
		    (mus-arrays-equal? (channel->float-vector 4523 10)
			    #r(0.232 0.232 0.232 0.232 0.232 0.232 0.232 0.232 0.233 0.233))
		    (mus-arrays-equal? (channel->float-vector 8928 10) (make-float-vector 10 0.452))))
	  (snd-display "granulate ramped 4 data off: ~A ~A ~A" 
		       (channel->float-vector 2203 10) (channel->float-vector 4523 10) (channel->float-vector 8928 10)))
      (undo)
      
      (let ((e (make-env '(0 0 1 1) :length 10000)))
	(set! gen (make-granulate :expansion 2.0
				  :input (lambda (dir) (env e))
				  :length .00995
				  :hop .01
				  :ramp 0.0
				  :scaler 1.0
				  :jitter 0.0))
	(clm-channel gen))
      (if (fneq (maxamp) .505) (snd-display "granulate ramped 5: ~A" (maxamp)))
      (let ((mxoff 0.0)
	    (cur 0.0)
	    (incr (/ (maxamp) (framples)))
	    (diff 0.0))
	(scan-channel (lambda (y) 
			(set! diff (abs (- cur y)))
			(set! mxoff (max mxoff diff))
			(set! cur (+ cur incr))
			#f))
	(if (> mxoff .02) (snd-display "granulate ramped 5 mxoff: ~A" mxoff))) ; .0108 actually
      (undo)
      
      (let ((e (make-env '(0 0 1 1) :length 10000)))
	(set! gen (make-granulate :expansion 2.0
				  :input (lambda (dir) (env e))
				  :length .00995
				  :hop .01
				  :ramp 0.5
				  :scaler 1.0
				  :jitter 0.0))
	(clm-channel gen))
      (if (fneq (maxamp) .495) (snd-display "granulate ramped 6: ~A" (maxamp)))
      (if (not (and (mus-arrays-equal? (channel->float-vector 2000 10)
			    #r(0.018 0.019 0.020 0.021 0.022 0.023 0.024 0.025 0.026 0.027))
		    (mus-arrays-equal? (channel->float-vector 8000 10)
			    #r(0.294 0.298 0.301 0.305 0.309 0.313 0.316 0.320 0.324 0.328))))
	  (snd-display "granulate ramped 6 data: ~A ~A"
		       (channel->float-vector 2000 10) (channel->float-vector 8000 10)))
      (undo)
      
      (let ((e (make-env '(0 0 1 1) :length 10000)))
	(set! gen (make-granulate :expansion 2.0
				  :input (lambda (dir) (env e))
				  :length .00995
				  :hop .01
				  :ramp 0.25
				  :scaler 1.0
				  :jitter 0.0))
	(clm-channel gen))
      (if (fneq (maxamp) .505) (snd-display "granulate ramped 7: ~A" (maxamp)))
      (if (not (and (mus-arrays-equal? (channel->float-vector 2000 10)
			    #r(0.037 0.039 0.040 0.042 0.044 0.046 0.048 0.050 0.052 0.054))
		    (mus-arrays-equal? (channel->float-vector 8000 10)
			    #r(0.404 0.404 0.404 0.404 0.404 0.405 0.405 0.405 0.405 0.405))))
	  (snd-display "granulate ramped 7 data: ~A ~A"
		       (channel->float-vector 2000 10) (channel->float-vector 8000 10)))
      (undo)
      
      (let ((e (make-env '(0 0 1 1) :length 10000)))
	(set! gen (make-granulate :expansion 2.0
				  :input (lambda (dir) (env e))
				  :length .05
				  :hop .01
				  :ramp 0.25
				  :scaler 0.1
				  :jitter 0.0))
	(clm-channel gen))
      (if (fneq (maxamp) .201) (snd-display "granulate ramped 7: ~A" (maxamp)))
      (let ((mxoff 0.0)
	    (cur 0.0)
	    (incr (/ (maxamp) (framples)))
	    (diff 0.0))
	(scan-channel (lambda (y) 
			(set! diff (abs (- cur y)))
			(set! mxoff (max mxoff diff))
			(set! cur (+ cur incr))
			#f))
	(if (> mxoff .01) (snd-display "granulate ramped 7 mxoff: ~A" mxoff))) ; .0097 actually
      (undo)
      
      (let ((e (make-env '(0 0 1 1) :length 10000)))
	(set! gen (make-granulate :expansion 2.0
				  :input (lambda (dir) (env e))
				  :length .1
				  :hop .01
				  :ramp 0.1
				  :scaler 0.1
				  :jitter 0.0))
	(clm-channel gen))
      (if (fneq (maxamp) .501) (snd-display "granulate ramped 8: ~A" (maxamp)))
      (let ((cur (sample 2000)))
	(let ((mxoff 0.0)
	      (incr (/ (- (maxamp) cur) (- (framples) 2000)))
	      (diff 0.0))
	  (scan-channel (lambda (y) 
			  (set! diff (abs (- cur y)))
			  (set! mxoff (max mxoff diff))
			  (set! cur (+ cur incr))
			  #f)
			2000)
	  (if (> mxoff .001) (snd-display "granulate ramped 8 mxoff: ~A" mxoff))))
      (undo)
      
      (let ((e (make-env '(0 0 1 1) :length 10000)))
	(set! gen (make-granulate :expansion 2.0
				  :input (lambda (dir) (env e))
				  :length .4
				  :hop .01
				  :ramp 0.4
				  :scaler 0.025
				  :jitter 0.0))
	(clm-channel gen))
      (if (fneq (maxamp) .433) (snd-display "granulate ramped 9: ~A" (maxamp)))
      (undo)
      (close-sound ind))
    
    (let ((v0 (make-float-vector 32))
	  (v1 (make-float-vector 256))
	  (v2 (make-float-vector 256))
	  (v01 (make-float-vector 32))
	  (v11 (make-float-vector 256))
	  (v21 (make-float-vector 256)))
      (do ((i 1 (+ i 1)))
	  ((= i 16))
	(set! (v0 i) (/ 1.0 i))
	(set! (v01 i) (/ 1.0 i)))
      (set! (v1 0) 1.0)
      (set! (v11 0) 1.0)
      (let ((n -1)
	    (n1 -1))
	(let ((gen (make-convolve :filter v0 :input (lambda (dir) (set! n (+ n 1)) (v1 n))))
	      (gen1 (make-convolve :filter v01 :input (lambda (dir) (set! n1 (+ n1 1)) (v11 n1)))))
	  (print-and-check gen 
			   "convolve"
			   "convolve size: 64")
	  (if (not (convolve? gen)) (snd-display "~A not convolve?" gen))
	  (if (equal? gen gen1) (snd-display "convolve equal? ~A ~A" gen gen1))
	  (if (not (= (mus-length gen) 64)) (snd-display "convolve fft len: ~D?" (mus-length gen)))
	  (do ((i 0 (+ i 1)))
	      ((= i 128))
	    (set! (v2 i) (convolve gen)))
	  (fill-float-vector v21 (if (convolve? gen1) (convolve gen1) -1.0))
	  (if (not (mus-arrays-equal? v2 v21)) (snd-display "run gran: ~A ~A" v2 v21))
	  (if (or (fneq (v2 0) 0.0)
		  (fneq (v2 1) 1.0)
		  (fneq (v2 4) 0.25)
		  (fneq (v2 7) 0.143))
	      (snd-display "convolve output: ~A?" v2)))
      
	(convolve-files "oboe.snd" "fyow.snd" .5 "fmv.snd")
	(if (fneq (cadr (mus-sound-maxamp "fmv.snd")) .5) 
	    (snd-display "convolve-files: ~A is not .5?" (cadr (mus-sound-maxamp "fmv.snd"))))
	))

    (let ((flt #r(1.0 0.5 0.1 0.2 0.3 0.4 0.5 1.0))
	  (data #r(0.0 1.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0))
	  (ctr -1))
      (let ((res (make-float-vector 16))
	    (g (make-convolve :filter flt
			      :input (lambda (dir)
				       (set! ctr (+ ctr 1))
				       (data ctr)))))
	(do ((i 0 (+ i 1)))
	    ((= i 16))
	  (set! (res i) (convolve g)))
	(if (not (mus-arrays-equal? res #r(0.0 1.0 0.5 0.1 1.2 0.8 0.5 0.7 1.3 0.4 0.5 1.0 0.0 0.0 0.0 0.0)))
	    (snd-display "convolve: ~A~%" res))))
    
    (let ((ind (new-sound "fmv.snd")))
      (set! (sample 1) .1)
      (save-sound ind)
      (if (not (equal? (edits ind 0) '(0 0)))
	  (snd-display "weird: edits not cleared after save-sound?: ~A" (edits ind 0)))
      (close-sound ind)
      (set! ind (open-sound "fmv.snd"))
      (if (not (= (framples ind 0) 2))
	  (snd-display "save-sound 2 samps: ~A?" (framples ind 0)))
      (if (or (fneq (sample 0) 0.0)
	      (fneq (sample 1) 0.1))
	  (snd-display "save-sound: ~A ~A?" (sample 0) (sample 1)))
      (do ((i 3 (+ i 1)))
	  ((= i 6))
	(set! (sample i) (* i .1))
	(save-sound ind)
	(if (not (equal? (edits ind 0) '(0 0)))
	    (snd-display "weird: edits not cleared after save-sound ~A?: ~A" i (edits ind 0)))
	(close-sound ind)
	(set! ind (open-sound "fmv.snd"))
	(if (not (= (framples ind 0) (+ i 1)))
	    (snd-display "save-sound ~A samps: ~A?" (+ i 1) (framples ind 0)))
	(if (or (fneq (sample 0) 0.0)
		(fneq (sample 1) 0.1)
		(fneq (sample i) (* i 0.1)))
	    (snd-display "save-sound ~A: ~A ~A ~A?" i (sample 0) (sample 1) (sample i))))
      (close-sound ind))
    
    (let ((ind (new-sound "test.snd" :srate 22050 :channels 1 :size 1000)))
      (let ((gen (make-ssb-am 100.0)))
	(map-channel (lambda (y) (ssb-am gen)))
	(if (fneq (maxamp) 0.0) (snd-display "ssb-am 0.0: ~A" (maxamp)))
	(let ((gen1 (make-oscil 220.0)))
	  (map-channel (lambda (y) (* 0.5 (oscil gen1)))))
	(set! gen (make-ssb-am 100.0 100))
	(map-channel (lambda (y) (ssb-am gen y)))
	(delete-samples 0 200)
	(let ((gen1 (make-oscil 320.0 :initial-phase (asin (* 2 (sample 0)))))) ; depends on rising side
	  (map-channel (lambda (y) (- y (* 0.5 (oscil gen1))))))
	(if (> (maxamp) .004) (snd-display "ssb-am cancelled: ~A" (maxamp)))
	(undo 3))
      (let ((gen (make-ssb-am 100.0 100))
	    (hx (hz->radians 50.0)))
	(map-channel (lambda (y) (ssb-am gen y hx))))
      (delete-samples 0 180)
      (let ((gen1 (make-oscil 370.0 :initial-phase (asin (* 2 (sample 0)))))) ; depends on rising side
	(map-channel (lambda (y) (- y (* 0.5 (oscil gen1))))))
      (if (> (maxamp) .004) (snd-display "ssb-am fm cancelled: ~A" (maxamp)))
      (close-sound ind))
    
    (let ((ind (new-sound "test.snd" :srate 22050 :channels 1 :size 1000)))
      (let* ((scl (/ (* 2 pi) 50))
	     (x (- scl)))
	(map-channel (lambda (y) (sin (set! x (+ x scl))))))
      ;; 441 Hz 
      (ssb-bank 441 882 1 100)
      (delete-samples 0 217)
      (let ((gen1 (make-oscil 882.0 :initial-phase (asin (sample 0)))))
	(map-channel (lambda (y) (- y (oscil gen1))))
	(if (> (maxamp) .04) (snd-display "ssb-bank cancelled: ~A" (maxamp))))
      (close-sound ind))
    
    (when *output* 
      (snd-display "*output* ~A" *output*)
      (set! *output* #f))
    
    (let ((nind (new-sound "fmv.snd" 1 22050 mus-bshort mus-aifc "this is a comment")))
      (time (mix-float-vector (with-temp-sound (:output (make-float-vector 22050)) (fm-violin 0 1 440 .1)) 0 nind 0))
      (play nind :wait #t)
      (save-sound nind)
      (if (not (sound? nind)) (snd-display "save sound clobbered ~A?" nind))
      (let ((oboe-index (or (find-sound "oboe.snd") (open-sound "oboe.snd"))))
	(if (equal? oboe-index nind) (snd-display "find-sound found bogus case: ~A" oboe-index))
	(cnvtest oboe-index nind .1) 
	(select-sound nind)
	(select-channel 0)
	(if (not (equal? (selected-sound) nind)) (snd-display "selected-sound: ~A?" (selected-sound)))
	(if (not (= (selected-channel) 0)) (snd-display "selected-channel: ~A?" (selected-channel)))

	(let ((decay-dur 1.0000))
	  (let ((amp-env #f)
		(low-pass #f)
		(volume 0.1000)
		(allpass1 (make-all-pass -0.700 0.700 1051))
		(allpass2 (make-all-pass -0.700 0.700  337))
		(allpass3 (make-all-pass -0.700 0.700  113))
		(comb1 (make-comb 0.742 4799))
		(comb2 (make-comb 0.733 4999))
		(comb3 (make-comb 0.715 5399))
		(comb4 (make-comb 0.697 5801))
		(dur (+ decay-dur (/ (framples) (srate))))
		(outdel (make-delay (seconds->samples .013))))
	    (let ((combs (make-comb-bank (vector comb1 comb2 comb3 comb4)))
		  (allpasses (make-all-pass-bank (vector allpass1 allpass2 allpass3))))
	      (if (or amp-env low-pass)
		  (let ((delf (let ((flt (and low-pass (make-fir-filter 3 #r(0.25 0.5 0.25))))
				    (envA (make-env :envelope (or amp-env '(0 1 1 1)) :scaler volume :duration dur)))
				(if low-pass
				    (lambda (inval)
				      (+ inval (delay outdel (* (env envA) (fir-filter flt (comb-bank combs (all-pass-bank allpasses inval)))))))
				    (lambda (inval)
				      (+ inval (delay outdel (* (env envA) (comb-bank combs (all-pass-bank allpasses inval))))))))))
		    (map-channel delf 0 (round (* dur (srate)))))
		  (map-channel
		   (lambda (inval)
		     (+ inval (delay outdel (* volume (comb-bank combs (all-pass-bank allpasses inval))))))
		   0 (round (* dur (srate))))))))

	(play nind :wait #t)
	(voiced->unvoiced 1.0 256 2.0 2.0) 
	(pulse-voice 80 20.0 1.0 1024 0.01)
	(map-channel (fltit))
	(close-sound oboe-index))
      (if (not (sound? nind)) (snd-display "close sound clobbered ~A?" nind))
      (do ((fr (framples nind 0))
	   (k 0 (+ k 1)))
	  ((= k 10)
	   (if (not (= (framples nind 0) (- fr 1000)))
	       (snd-display "delete-samples: ~A ~A" fr (framples nind 0))))
	(delete-samples 10 100 nind 0)
	(save-sound nind)) ;flush out memory leaks here
      (revert-sound nind)
      (close-sound nind))
    (if (file-exists? "fmv.snd") (delete-file "fmv.snd"))
    
    (let ((nind (new-sound "fmv.snd")))
      (if (not (= (header-type nind) *default-output-header-type*))
	  (snd-display "new-sound default header-type: ~A ~A?"
		       (mus-header-type-name (header-type nind))
		       (mus-header-type-name *default-output-header-type*)))
      (if (not (= (sample-type nind) *default-output-sample-type*))
	  (snd-display "new-sound default sample-type: ~A ~A?"
		       (mus-sample-type-name (sample-type nind))
		       (mus-sample-type-name *default-output-sample-type*)))
      (if (not (= (chans nind) *default-output-chans*))
	  (snd-display "new-sound default chans: ~A ~A?" (chans nind) *default-output-chans*))
      (if (not (= (srate nind) *default-output-srate*))
	  (snd-display "new-sound default srate: ~A ~A?" (srate nind) *default-output-srate*))
      (close-sound nind)
      (if (file-exists? "fmv.snd") (delete-file "fmv.snd")))
    (let ((nind (new-sound "fmv.snd" 1 22050 mus-bshort mus-nist "this is a comment")))
      (set! (sample 0 nind) 1.0) 
      (start-progress-report nind)
      (convolve-with "oboe.snd") 
      (progress-report .1 nind)
      (if (fneq (sample 1000) 0.223) (snd-display "convolve-with: ~A?" (sample 1000)))
      (progress-report .3 nind)
      (revert-sound nind)
      (progress-report .5 nind)
      (set! (sample 200) .0001) 
      (set! (sample 100) 1.0) 
      (progress-report .8 nind)
      (smooth-sound 0 100) 
      (finish-progress-report nind)
      (if (or (fneq (sample 50) .5) (fneq (sample 30) 0.20608) (fneq (sample 90) 0.9755))
	  (snd-display "smooth: ~A ~A ~A?" (sample 50) (sample 30) (sample 90)))
      (undo) 
      (let-temporarily ((*sinc-width* 40))
	(set! (sample 100) 0.5) 
	(if (fneq (sample 100) 0.5) (snd-display "set-sample 100: ~A?" (sample 100)))
	(src-sound .1) )
      (if (or (fneq (sample 1000) 0.5) (fneq (sample 1024) 0.0625) (fneq (sample 1010) 0.0))
	  (snd-display "src-sound: ~A ~A ~A?" (sample 1000) (sample 1024) (sample 1010)))
      (revert-sound)
      (close-sound nind))
    (let ((nind (new-sound "fmv.snd" 1 22050 mus-lshort mus-riff "this is a comment" 22050)))
      (if (not (= (framples nind) 22050)) (snd-display " new-sound initial-length: ~A" (framples nind)))
      (mix "pistol.snd") 
      (map-channel (expsrc 2.0 nind)) 
      (undo) 
      (let ((eds (edits)))
	(if (not (= (car eds) 1 (cadr eds)))
	    (snd-display "undo edits: ~A?" eds))
	(if (not (= (edit-position) (car eds)))
	    (snd-display "undo edit-position: ~A ~A?" (edit-position) eds)))
      (expsnd '(0 1 2 .4)) 
      (map-channel (comb-chord .95 100 .3)) 
      (map-channel (formants .99 900 .02 1800 .01 2700)) 
      (map-channel (moving-formant .99 '(0 1200 1 2400))) 
      (scale-to .3) 
      (let ((eds (edits)))
	(if (not (and (= (car eds) 6) (= (cadr eds) 0)))
	    (snd-display "edits(6): ~A?" eds))
	(if (not (= (edit-position) (car eds)))
	    (snd-display "edit-position(6): ~A ~A?" (edit-position) eds)))
      (set! (edit-position) 1)
      (if (not (= (edit-position) 1))
	  (snd-display "set edit-position(1) ~A?" (edit-position)))
      (set! (edit-position) 4)
      (if (not (= (edit-position) 4))
	  (snd-display "set edit-position(4): ~A?" (edit-position)))
      (revert-sound nind)
      (mix "pistol.snd") 
      (map-channel (zecho .5 .75 6 10.0) 0 65000) 
      (map-channel (am 440)) 
      (add-mark 1200)
      (add-mark 2300)
      (key (char->integer #\x) 4)
      (key (char->integer #\c) 0) ; trigger mark-define-region
      (reverse-sound nind) 
      (revert-sound nind)
      (let ((mid (mix-sound "pistol.snd" 0)))
	(if (and (mix? mid)
		 (not (equal? (mix-home mid) (list (selected-sound) 0 #f 0))))
	    (snd-display "mix-sound mix-home: ~A" (mix-home mid))))
      (hello-dentist 40.0 .1) 
      (fp 1.0 .3 20) 
      (revert-sound nind)
      (enveloped-mix "oboe.snd" 0 '(0 0 1 1 2 0)) 
      (if all-args (pvoc :pitch 0.5 :time 1.0 :snd nind))
      (revert-sound nind)
      (close-sound nind))
    
    (if (and all-args (defined? 'edot-product))
	(let ((ind (new-sound :size 100)))
	  (set! (sample 10) 0.5)
	  (set! (sample 30) -0.8)
	  (stretch-sound-via-dft 2.0 ind 0)
	  (let ((new-len (framples ind 0))
		(len 100))
	    (if (> (abs (- (* 2 len) new-len)) 10)
		(snd-display "stretch-sound-via-dft: ~A ~A" len new-len)))
	  (close-sound ind)))
    
    (let ((make-mix-output (lambda (name i)
			     (if (member i '(0 1) =)
				 name
				 (continue-sample->file name))))
	  (make-mix-input (lambda (name i)
			    (if (member i '(0 2) =)
				name
				(make-file->frample name)))))
      (define (mus-file-mix-1 k . args)
	(let ((outf (make-mix-output "fmv.snd" k)))
	  (apply mus-file-mix outf args)	
	  (if (not (string? outf))
	      (mus-close outf))))

      (do ((k 0 (+ k 1)))
	  ((= k 4))
	(if (file-exists? "fmv.snd") (delete-file "fmv.snd"))
	(if (file-exists? "fmv1.snd") (delete-file "fmv1.snd"))
	(if (file-exists? "fmv2.snd") (delete-file "fmv2.snd"))
	(if (file-exists? "fmv3.snd") (delete-file "fmv3.snd"))
	(let ((v0 (make-float-vector 12 0.1)))
	  (array->file "fmv1.snd" v0 12 22050 1)
	  (fill! v0 0.2)
	  (array->file "fmv2.snd" v0 12 22050 2)
	  (fill! v0 0.3)
	  (array->file "fmv3.snd" v0 12 22050 4)

	  (do ((i 0 (+ i 1))) ((= i 12)) (set! (v0 i) (* i .01)))
	  (array->file "fmv.snd" v0 12 22050 1)
	  (mus-file-mix-1 k (make-mix-input "fmv1.snd" k))
	  (file->array "fmv.snd" 0 0 12 v0)

	  ;; v0: #(0.1 0.11 0.12 0.13 0.14 0.15 0.16 0.17 0.18 0.19 0.2 0.21)
	  (do ((happy #t)
	       (i 0 (+ i 1))) 
	      ((or (not happy) (= i 12)))
	    (when(fneq (v0 i) (+ 0.1 (* i .01))) 
	      (snd-display "~D mus-file-mix(1->1): ~A?" k v0)
	      (set! happy #f)))

	  (mus-file-mix-1 k (make-mix-input "fmv2.snd" k) 3 9 0 #r(0.3 0.0 0.7 0.0))
	  (file->array "fmv.snd" 0 0 12 v0)

	  ;; v0: #(0.1 0.11 0.12 0.33 0.34 0.35 0.36 0.37 0.38 0.19 0.2 0.21)
	  (if (or (fneq (v0 0) .1) (fneq (v0 3) .33) (fneq (v0 9) .19)) (snd-display "~D mus-file-mix(2->1): ~A?" k v0))
	  (mus-file-mix-1 k (make-mix-input "fmv3.snd" k))
	  (file->array "fmv.snd" 0 0 12 v0)

	  ;; ?? v0: #(0.4 0.41 0.42 0.33 0.34 0.35 0.36 0.37 0.38 0.19 0.2 0.21)
	  (if (or (fneq (v0 0) .4) (fneq (v0 3) .33)) (snd-display "~D mus-file-mix(4->1): ~A?" k v0))
	  (let ((vf (make-vector 1)))
	    (let ((e0 (make-env '(0 0 1 1) :length 11))
		  (vf1 (make-vector 1)))
	      (set! (vf 0) vf1)
	      (set! (vf1 0) e0))
	    (mus-file-mix-1 k (make-mix-input "fmv1.snd" k) 0 12 0 #r(1.0) vf)
	    (file->array "fmv.snd" 0 0 12 v0)

	    ;; ?? v0: #(0.4 0.42 0.44000000 0.36 0.38 0.4 0.42 0.44 0.46 0.28 0.3 0.31)
	    (if (or (fneq (v0 0) .4) (fneq (v0 3) .360) (fneq (v0 9) .28)) (snd-display "~D mus-file-mix(env): ~A?" k v0))
	    (mus-file-mix-1 k (make-mix-input "fmv2.snd" k) 0 12 0 (make-float-vector 4 1.0) vf))
	  ;; clm2xen should protect us here
	  (let ((vf (make-vector 2))
		(vf1 (make-vector 2))
		(vf2 (make-vector 2)))
	    (set! (vf 0) vf1)
	    (set! (vf 1) vf2)
	    (set! (vf1 0) (make-env '(0 0 1 1) :length 10))
	    (set! (vf2 1) (make-env '(0 0 1 1) :length 10))
	    (mus-file-mix-1 k (make-mix-input "fmv2.snd" k) 0 12 0 (make-float-vector 4 1.0) vf)
	    (let ((tag (catch #t
			 (lambda ()
			   (set! (vf 0) (make-oscil))
			   (mus-file-mix-1 k (make-mix-input "fmv2.snd" k) 0 12 0 (make-float-vector 4 1.0) vf))
			 (lambda args (car args)))))
	      (if (not (eq? tag 'bad-type))
		  (snd-display "~D mix w oscil-vect: ~A" k tag)))
	    (set! (vf 0) vf1)
	    (set! (vf 1) vf2)
	    (let ((tag (catch #t
			 (lambda ()
			   (set! (vf1 0) (make-oscil))
			   (set! (vf2 1) 0+i)
			   (mus-file-mix-1 k (make-mix-input "fmv2.snd" k) 0 12 0 (make-float-vector 4 1.0) vf))
			 (lambda args (car args)))))
	      (if (not (eq? tag 'bad-type))
		  (snd-display "~D mix w oscil-env: ~A" k tag))))
	  (delete-file "fmv.snd")
	  (do ((i 0 (+ i 1))) ((= i 12)) (set! (v0 i) (* i .01)))
	  (array->file "fmv.snd" v0 12 22050 4)
	  (mus-file-mix-1 k (make-mix-input "fmv1.snd" k))
	  (file->array "fmv.snd" 0 0 3 v0) ; chan 0 start 0 len 3

	  ;; v0: #(0.1 0.14 0.18 0.03 0.04 0.05 0.06 0.070000000 0.08 0.09 0.1 0.11)
	  (if (or (fneq (v0 0) .1) (fneq (v0 2) .18)) (snd-display "~D mus-file-mix(1->4): ~A?" k v0))
	  (mus-file-mix-1 k (make-mix-input "fmv2.snd" k)  0 3 0 #r(0.3 0.0 0.7 0.0))
	  (file->array "fmv.snd" 0 0 3 v0)

	  ;; v0: #(0.3 0.34 0.38 0.03 0.04 0.05 0.06 0.070000000 0.08 0.09 0.1 0.11)
	  (if (or (fneq (v0 0) .3) (fneq (v0 2) .38)) (snd-display "~D mus-file-mix(2->4): ~A?" k v0))
	  (mus-file-mix-1 k (make-mix-input "fmv3.snd" k) 0 2 0)
	  (file->array "fmv.snd" 0 0 3 v0)

	  ;;  v0: #(0.60000000 0.64000000 0.38 0.03 0.04 0.05 0.06 0.070000000 0.08 0.09 0.1 0.11)
	  (if (or (fneq (v0 0) .6) (fneq (v0 2) .38)) (snd-display "~D mus-file-mix(4->4): ~A?" k v0)))
	
	(if (file-exists? "fmv.snd") (delete-file "fmv.snd"))
	(let ((len (mus-sound-framples "oboe.snd")))
	  (array->file "fmv.snd" (make-float-vector 12) 12 22050 1)
	  (mus-file-mix-1 k (make-mix-input "oboe.snd" k))
	  (mus-file-mix-1 k (make-mix-input "oboe.snd" k) 0 len 0 #r(0.5))
	  (let ((egen (make-vector 1))
		(outv (make-vector 1)))
	    (set! (outv 0) egen)
	    (set! (egen 0) (make-env :envelope '(0 0 1 1) :length len))
	    (mus-file-mix-1 k (make-mix-input "oboe.snd" k) 0 len 0 #f outv)
	    (set! (egen 0) (make-env :envelope '(0 1 1 0) :length len))
	    (mus-file-mix-1 k (make-mix-input "oboe.snd" k) 0 len 0 #r(1.0) outv))
	  (let ((ind-oboe (open-sound "oboe.snd"))
		(ind-mix (open-sound "fmv.snd")))
	    (if (not (mus-arrays-equal? (channel->float-vector 1000 10 ind-oboe)
			     (float-vector-scale! (channel->float-vector 1000 10 ind-mix) (/ 1.0 2.5))))
		(snd-display "~D mus-file-mix 1 chan: ~A ~A" k
			     (channel->float-vector 1000 10 ind-oboe)
			     (channel->float-vector 1000 10 ind-mix)))
	    (close-sound ind-oboe)
	    (close-sound ind-mix))
	  (delete-file "fmv.snd")
	  (let ((len (mus-sound-framples "2.snd")))
	    (array->file "fmv.snd" (make-float-vector 12) 12 22050 2)
	    (if (not (= (mus-sound-chans "fmv.snd") 2))
		(snd-display "~D array->file chans? ~A" k (mus-sound-chans "fmv.snd")))
	    (mus-file-mix-1 k (make-mix-input "2.snd" k))
	    (mus-file-mix-1 k (make-mix-input "2.snd" k) 0 len 0 #r(0.5 0.0 0.0 0.5))
	    (let ((egen0 (make-vector 2))
		  (egen1 (make-vector 2))
		  (outv (make-vector 2)))
	      (set! (outv 0) egen0)
	      (set! (outv 1) egen1)
	      (set! (egen0 0) (make-env :envelope '(0 0 1 1) :length len))
	      (set! (egen1 1) (make-env :envelope '(0 0 1 1) :length len))
	      (mus-file-mix-1 k (make-mix-input "2.snd" k) 0 len 0 #f outv)))
	  (let ((ind-mix (open-sound "fmv.snd")))
	    (if (not (= (channels ind-mix) 2))
		(snd-display "~D fmv re-read chans? ~A ~A" k (mus-sound-chans "fmv.snd") (channels ind-mix)))
	    (if (not (mus-arrays-equal? (channel->float-vector 1000 10 ind-mix 0)
			     #r(0.003 0.010 0.012 0.011 0.008 0.004 0.002 0.002 0.007 0.017)))
		(snd-display "~D mus-file-mix 2 chan (2.snd written: ~A): ~A ~A" k
			     (strftime "%d-%b %H:%M %Z" (localtime (mus-sound-write-date "2.snd")))
			     (channel->float-vector 1000 10 ind-mix 0)
			     (channel->float-vector 1000 10 ind-mix 1)))
	    (close-sound ind-mix)
	    (delete-file "fmv.snd")))
	); end do loop
      ); end let
    
    
    (let ()
      ;; someday this should be expanded
      (if (pair? (sounds))
	  (for-each close-sound (sounds)))

      (catch #t (lambda () (mus-file-mix-with-envs rd 0 1000 (float-vector))) (lambda args 'error))
      
      (with-sound ("flat.snd") 
	(do ((i 0 (+ i 1)))
	    ((= i 1000))
	  (outa i 1.0)))
      
      (with-sound ("mix.snd")
	(mus-file-mix-with-envs (vector (make-readin "flat.snd")) 0 1000 #r(0.5) #f #f #f #f))
      
      (let ((ind (find-sound "mix.snd")))
	(if (sound? ind)
	    (if (fneq (sample 100 ind) 0.5)
		(snd-display "mus-file-mix-with-envs 1: ~A" (sample 100 ind)))
	    (snd-display "mus-file-mix-with envs 1: no output? ~A" (map short-file-name (sounds)))))
      
      (with-sound ("mix.snd")
	(mus-file-mix-with-envs (vector (make-readin "flat.snd")) 0 1000 
				#r(0.0) #f
				(vector (make-env '(0 0 1 1) :length 1000))
				#f #f))
      
      (let ((ind (find-sound "mix.snd")))
	(if (sound? ind)
	    (if (fneq (sample 100 ind) 0.1)
		(snd-display "mus-file-mix-with-envs 2: ~A" (sample 100 ind)))
	    (snd-display "mus-file-mix-with envs 2: no output? ~A" (map short-file-name (sounds)))))
      
      (with-sound ("mix.snd" 2 :clipped #f)
	(let ((rd (vector (make-readin "flat.snd") 
			  (make-readin "flat.snd")))
	      (es (vector (make-env '(0 0 1 1) :length 1000 :scaler .1) 
			  (make-env '(0 1 1 0) :length 1000 :scaler .1)
			  (make-env '(0 1 1 1) :length 1000 :scaler .5)
			  (make-env '(0 1 1 1) :length 1000 :scaler -.5))))
	  (mus-file-mix-with-envs rd 0 1000 (make-float-vector 4) #f es #f #f)))
      
      (let ((ind (find-sound "mix.snd")))
	(if (sound? ind)
	    (begin
	      (if (fneq (sample 100 ind 0) 0.51)
		  (snd-display "mus-file-mix-with-envs 3 chan 0: ~A" (sample 100 ind 0)))
	      (if (fneq (sample 100 ind 1) -0.41)
		  (snd-display "mus-file-mix-with-envs 3 chan 1: ~A" (sample 100 ind 1))))
	    (snd-display "mus-file-mix-with envs 3: no output? ~A" (map short-file-name (sounds)))))
      
      (with-sound ("mix.snd" 2 :clipped #f)
	(let ((rd (vector (make-readin "flat.snd")))
	      (es (vector (make-env '(0 0 1 1) :length 1000 :scaler .3) 
			  (make-env '(0 1 1 0) :length 1000 :scaler .4))))
	  (mus-file-mix-with-envs rd 0 1000 (make-float-vector 4) #f es #f #f)))
      
      (let ((ind (find-sound "mix.snd")))
	(if (sound? ind)
	    (begin
	      (if (fneq (sample 100 ind 0) 0.03)
		  (snd-display "mus-file-mix-with-envs 4 chan 0: ~A" (sample 100 ind 0)))
	      (if (fneq (sample 100 ind 1) 0.36)
		  (snd-display "mus-file-mix-with-envs 4 chan 1: ~A" (sample 100 ind 1))))
	    (snd-display "mus-file-mix-with envs 4: no output? ~A" (map short-file-name (sounds)))))
      
      (with-sound ("mix.snd" 1 :clipped #f)
	(let ((rd (vector (make-readin "flat.snd")
			  (make-readin "flat.snd")))
	      (es (vector (make-env '(0 0 1 1) :length 1000 :scaler .3) 
			  (make-env '(0 1 1 0) :length 1000 :scaler .4))))
	  (mus-file-mix-with-envs rd 0 1000 (make-float-vector 4) #f es #f #f)))
      
      (let ((ind (find-sound "mix.snd")))
	(if (sound? ind)
	    (if (fneq (sample 100 ind) 0.39)
		(snd-display "mus-file-mix-with-envs 5: ~A" (sample 100 ind)))
	    (snd-display "mus-file-mix-with envs 5: no output? ~A" (map short-file-name (sounds)))))
      
      (with-sound ("flat.snd") 
	(outa 99 0.5)
	(outa 100 1.0)
	(outa 101 0.5))
      
      (require snd-jcrev.scm)
      
      (with-sound ("mix.snd" :reverb jc-reverb)
	(mus-file-mix-with-envs (vector (make-readin "flat.snd")) 0 1000 #r(0.5) #r(0.1) #f #f #f))
      
      (with-sound ("mix.snd" :reverb jc-reverb)
	(let* ((rd (vector (make-readin "flat.snd") 
			   (make-readin "flat.snd"))) 
	       (srcs (vector (make-src :input (vector-ref rd 0) :srate 2.0)
			     (make-src :input (vector-ref rd 1) :srate 0.5))))
	  (mus-file-mix-with-envs rd 0 1000 #r(1.0 1.0 0.5 0.5) #r(0.1) #f srcs #f)))
      
      (let ((ind (find-sound "mix.snd")))
	(if (sound? ind)
	    (if (fneq (sample 200 ind) 0.5)
		(snd-display "mus-file-mix-with-envs 7: ~A" (sample 200 ind)))
	    (snd-display "mus-file-mix-with envs 7: no output? ~A" (map short-file-name (sounds)))))

      (for-each close-sound (sounds))
      (delete-file "flat.snd")
      (delete-file "mix.snd")
      )


    (let* ((gen (make-phase-vocoder #f 512 4 256 1.0 #f #f #f))
	   (val (catch #t (lambda () (phase-vocoder gen)) (lambda args (car args)))))
      (if (fneq val 0.0) (snd-display "simple no-in pv call: ~A" val))
      (set! val (catch #t (lambda () (set! gen (make-phase-vocoder :fft-size 1234))) (lambda args (car args))))
      (if (not (eq? val 'out-of-range)) (snd-display "pv bad fft: ~A" val))
      )
    
    (let* ((ind (open-sound "oboe.snd"))
	   (pi2 (* 2.0 pi))
	   (reader (make-sampler 0))
	   (pv (make-phase-vocoder (lambda (dir) (next-sample reader))
				   512 4 128 1.0
				   #f ;no change to analysis
				   #f ;no change to edits
				   #f ;no change to synthesis
				   )))
      (if (not (phase-vocoder? pv)) (snd-display "~A not phase-vocoder?" pv))
      (print-and-check pv 
		       "phase-vocoder"
		       "phase-vocoder outctr: 128, interp: 128, filptr: 0, N: 512, D: 128, in_data: nil")
      (let ((val (let ((pv (make-phase-vocoder))) (set! (mus-location pv) 120) (mus-location pv))))
	(if (not (= val 120)) (snd-display "pv set outctr: ~A" val)))
      
      (select-sound ind)
      (map-channel (lambda (val) (phase-vocoder pv)))
      (float-vector-set! (phase-vocoder-amp-increments pv) 0 .1)
      (if (fneq ((phase-vocoder-amp-increments pv) 0) .1)
	  (snd-display "set phase-vocoder-amp-increments: ~A?" ((phase-vocoder-amp-increments pv) 0)))
      (float-vector-set! (phase-vocoder-amps pv) 0 .1)
      (if (fneq ((phase-vocoder-amps pv) 0) .1)
	  (snd-display "set phase-vocoder-amps: ~A?" ((phase-vocoder-amps pv) 0)))
      (float-vector-set! (phase-vocoder-phases pv) 0 .1)
      (if (fneq ((phase-vocoder-phases pv) 0) .1)
	  (snd-display "set phase-vocoder-phases: ~A?" ((phase-vocoder-phases pv) 0)))
      (float-vector-set! (phase-vocoder-phase-increments pv) 0 .1)
      (if (fneq ((phase-vocoder-phase-increments pv) 0) .1)
	  (snd-display "set phase-vocoder-phase-increments: ~A?" ((phase-vocoder-phase-increments pv) 0)))
      (float-vector-set! (phase-vocoder-freqs pv) 0 .1)
      (if (fneq ((phase-vocoder-freqs pv) 0) .1)
	  (snd-display "set phase-vocoder-freqs: ~A?" ((phase-vocoder-freqs pv) 0)))
      (undo 1)
      (free-sampler reader)
      (set! reader (make-sampler 0))
      (let ((edf (let ((lastphases (make-float-vector 512))
		       (diffs (make-float-vector 512)))
		   (lambda (v)
		     ;; new editing func changes pitch
		     (let ((N (mus-length v)) ;mus-increment => interp, mus-data => in-data
			   (D (mus-hop v))
			   (freqs (phase-vocoder-freqs v)))
		       (copy freqs diffs)
		       (float-vector-subtract! diffs lastphases)
		       (copy freqs lastphases)
		       (do ((N2 (floor (/ N 2)))
			    (pscl (/ 1.0 D))
			    (kscl (/ pi2 N))
			    (k 0 (+ k 1))
			    (kx 0.0))
			   ((= k N2))
			 (float-vector-set! freqs k (* 0.5 (+ (* pscl (remainder (float-vector-ref diffs k) pi2)) kx)))
			 (set! kx (+ kx kscl)))
		       #f)))))
	(set! pv (make-phase-vocoder (lambda (dir) (next-sample reader))
				     512 4 128 1.0
				     #f ;no change to analysis
				     edf
				     #f ; no change to synthesis
				     )))
      (map-channel (lambda (val) (phase-vocoder pv)))
      (undo 1)
      (free-sampler reader)
      (set! reader (make-sampler 0))
      (set! pv (make-phase-vocoder (lambda (dir) (next-sample reader))
				   512 4 256 1.0
				   #f ;no change to analysis
				   #f ;no change to edits
				   #f ;no change to synthesis
				   ))
      (let* ((len 1000)
	     (data (make-float-vector len)))
	(fill-float-vector data (phase-vocoder pv))
	(set! (samples 0 len) data))
      (undo 1)
      (free-sampler reader)
      
      (let ((incalls 0)
	    (outcalls 0))
	(set! reader (make-sampler 0))
	(set! pv (make-phase-vocoder (lambda (dir) (next-sample reader))
				     512 4 256 1.0
				     (lambda (v infunc)
				       (set! incalls (+ incalls 1)))
				     #f ;no change to edits
				     (lambda (v)
				       (set! outcalls (+ outcalls 1))
				       0.0)
				     ))
	(let* ((len 1000)
	       (data (make-float-vector len)))
	  (fill-float-vector data (phase-vocoder pv))
	  (set! (samples 0 len) data))
	(undo 1)
	(free-sampler reader)
	(if (or (= incalls 0)
		(= outcalls 0))
	    (snd-display "phase-vocoder incalls: ~A, outcalls: ~A" incalls outcalls)))
      (let ((tag (catch #t 
		   (lambda () (make-phase-vocoder #f 512 4 256 1.0 (lambda (a b c) #f) #f #f)) 
		   (lambda args args))))
	(if (not (memq (car tag) '(wrong-type-arg bad-arity))) (snd-display "make-phase-vocoder bad analyze func: ~A" tag)))
      (let ((tag (catch #t
		   (lambda () (make-phase-vocoder #f 512 4 256 1.0 (lambda (a b) 0.0) (lambda (a b c) #f) #f)) 
		   (lambda args args))))
	(if (not (memq (car tag) '(wrong-type-arg bad-arity))) (snd-display "make-phase-vocoder bad edit func: ~A" tag)))
      (let ((tag (catch #t 
		   (lambda () (make-phase-vocoder #f 512 4 256 1.0 (lambda (a b) 0.0) (lambda (a) #f) (lambda (a b) 0)))
		   (lambda args args))))
	(if (not (memq (car tag) '(wrong-type-arg bad-arity))) (snd-display "make-phase-vocoder bad synthesize func: ~A" tag)))
      (let* ((geno (make-phase-vocoder (lambda (dir) 0.0)))
	     (genx (make-phase-vocoder :input (lambda (dir) 0.0))))
	(if (equal? geno genx) (snd-display "phase-vocoder equal? ~A ~A" geno genx))
	(if (fneq (mus-frequency genx) 1.0) (snd-display "mus-frequency phase-vocoder: ~A" (mus-frequency genx)))
	(set! (mus-frequency genx) 2.0)
	(if (fneq (mus-frequency genx) 2.0) (snd-display "set mus-frequency phase-vocoder: ~A" (mus-frequency genx)))
	(if (fneq (mus-increment genx) 128) (snd-display "mus-increment phase-vocoder: ~A" (mus-increment genx)))
	(set! (mus-increment genx) 256)
	(if (fneq (mus-increment genx) 256) (snd-display "set mus-increment phase-vocoder: ~A" (mus-increment genx)))
	(if (not (= (mus-hop genx) 128)) (snd-display "phase vocoder hop: ~A" (mus-hop genx)))
	(set! (mus-hop genx) 64)
	(if (not (= (mus-hop genx) 64)) (snd-display "set phase vocoder hop: ~A" (mus-hop genx)))
	(if (not (= (mus-length genx) 512)) (snd-display "phase vocoder length: ~A" (mus-length genx))))
      (close-sound ind))
    
    (let-temporarily ((*mus-float-equal-fudge-factor* 1e-5)) ; some phase-vocoder tests
      (let ((ind (new-sound :size 110)))
	(set! (sample 1) 1.0)
	(let ((pv (make-phase-vocoder (let ((rd (make-sampler)))
					(lambda (dir) (next-sample rd)))
				      128 4 32 1.0 #f #f #f)))
	  (map-channel (lambda (y) (phase-vocoder pv)))
	  (let ((v (channel->float-vector 0 50))
		(v0 #r(0.00022 0.00130 0.00382 0.00810 0.01381 0.01960 0.02301 0.02143 0.01421 0.00481 0.0 0.00396 0.01168 0.01231 0.00413 0.00018 0.00704 0.00984 0.00189 0.00197 0.00881 0.00290 0.00151 0.00781 0.00091 0.00404 0.00498 0.00047 0.00641 -0.00017 0.00590 0.00006 0.00492 0.00031 0.00380 0.00052 0.00290 0.00066 0.00219 0.00074 0.00164 0.00076 0.00123 0.00074 0.00092 0.00067 0.00069 0.00058 0.00052 0.00048)))
	    (if (not (or (mus-arrays-equal? v v0)
			 (mus-arrays-equal? (float-vector-scale! v -1.0) v0))) 
		(snd-display "pv 1 diff: ~A" (float-vector-peak (float-vector-subtract! v v0)))))
	  (undo))

	(let ((pv (make-phase-vocoder (let ((rd (make-sampler)))
					(lambda (dir) (next-sample rd)) )
		   128 4 32 2.0 #f #f #f)))
	  (map-channel (lambda (y) (phase-vocoder pv)))
	  (let ((v (channel->float-vector 0 50))
		(v0 #r(0.00044 0.00255 0.00705 0.01285 0.01595 0.01177 0.00281 0.00069 0.00782 0.00702 0.00001 0.00584 0.00385 0.00138 0.00547 0.00035 0.00494 0.00082 0.00305 0.00310 0.00003 0.00380 0.00245 -0.00019 0.00159 0.00348 0.00268 0.00087 -0.00020 -0.00036 -0.00010 0.00012 0.00036 0.00057 0.00075 0.00089 0.00099 0.00105 0.00108 0.00107 0.00104 0.00099 0.00094 0.00087 0.00080 0.00073 0.00066 0.00059 0.00053 0.00047)))
	    (if (not (mus-arrays-equal? v v0))
		(snd-display "pv 2 diff: ~A" (float-vector-peak (float-vector-subtract! v v0)))))
	  (undo))
	
	(let ((pv (make-phase-vocoder (let ((rd (make-sampler)))
					(lambda (dir) (next-sample rd)))
				      128 4 32 0.5 #f #f #f)))
	  (map-channel (lambda (y) (phase-vocoder pv)))
	  (let ((v (channel->float-vector 0 50))
		(v0 #r(0.00011 0.00065 0.00195 0.00428 0.00785 0.01266 0.01845 0.02456 0.02989 0.03305 0.03267 0.02803 0.01970 0.00993 0.00228 0.00009 0.00441 0.01250 0.01858 0.01759 0.00975 0.00160 0.00079 0.00795 0.01454 0.01201 0.00325 0.00024 0.00716 0.01261 0.00704 0.00003 0.00384 0.00962 0.00620 0.00027 0.00196 0.00655 0.00492 0.00040 0.00101 0.00448 0.00375 0.00041 0.00053 0.00305 0.00273 0.00033 0.00029 0.00204)))
	    (if (not (mus-arrays-equal? v v0))
		(snd-display "pv 3 diff: ~A" (float-vector-peak (float-vector-subtract! v v0)))))
	  (undo))
	
	(let ((pv (make-phase-vocoder (let ((rd (make-sampler)))
					(lambda (dir) (next-sample rd)))
				      128 4 64 1.0 #f #f #f)))
	  (map-channel (lambda (y) (phase-vocoder pv)))
	  (let ((v (channel->float-vector 0 100))
		(v0 #r(0.00005 0.00033 0.00098 0.00214 0.00392 0.00633 0.00923 0.01228 0.01495 0.01652 0.01633 0.01401 0.00985 0.00497 0.00114 0.00004 0.00221 0.00625 0.00929 0.00880 0.00488 0.00080 0.00040 0.00397 0.00727 0.00601 0.00162 0.00012 0.00358 0.00630 0.00352 0.00002 0.00217 0.00552 0.00300 -0.00008 0.00299 0.00479 0.00083 0.00098 0.00457 0.00175 0.00033 0.00412 0.00172 0.00039 0.00399 0.00087 0.00118 0.00356 -0.00016 0.00280 0.00169 0.00051 0.00326 -0.00030 0.00301 0.00040 0.00184 0.00144 0.00078 0.00213 0.00015 0.00242 -0.00017 0.00240 -0.00038 0.00230 -0.00049 0.00214 -0.00053 0.00194 -0.00051 0.00172 -0.00047 0.00150 -0.00040 0.00127 -0.00033 0.00106 -0.00025 0.00086 -0.00019 0.00068 -0.00013 0.00052 -0.00008 0.00039 -0.00005 0.00027 -0.00002 0.00017 -0.00001 0.00009 0.0 0.00003 0.0 -0.00002 -0.00001 -0.00006)))
	    (if (not (mus-arrays-equal? v v0))
		(snd-display "pv 4 diff: ~A" (float-vector-peak (float-vector-subtract! v v0)))))
	  (undo))
	
	(set! (sample 10) 1.0)
	(set! (sample 23) 1.0)
	(let ((pv (make-phase-vocoder (let ((rd (make-sampler)))
					(lambda (dir) (next-sample rd)))
				      128 4 32 1.0 #f #f #f)))
	  (map-channel (lambda (y) (phase-vocoder pv)))
	  (let ((v (channel->float-vector 0 100))
		(v0 #r(0.00100 0.00598 0.01756 0.03708 0.06286 0.08826 0.10172 0.09163 0.05680 0.01564 -0.00075 0.02124 0.05164 0.04457 0.00861 0.00529 0.03648 0.02747 -0.00875 0.00936 0.02402 -0.00553 -0.00090 -0.02262 -0.00221 0.06633 -0.03229 0.01861 0.05228 0.00672 0.00885 0.01442 -0.00484 -0.02293 -0.01893 -0.02256 -0.10229 -0.22474 0.31110 0.07597 0.07127 0.03670 0.02583 0.03173 0.02260 0.01550 0.01485 0.03212 -0.00966 0.00779 -0.00964 0.00698 0.01100 0.00468 0.00107 0.00517 0.00469 0.00131 0.00058 0.00530 0.00582 -0.00652 0.00011 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.00000)))
	    (if (not (mus-arrays-equal? v v0))
		(snd-display "pv 5 diff: ~A" (float-vector-peak (float-vector-subtract! v v0)))))
	  (undo))
	
	(set! (sample 40) 1.0)
	(set! (sample 63) 1.0)
	(let  ((pv (make-phase-vocoder (let ((rd (make-sampler)))
					 (lambda (dir) (next-sample rd)))
				       128 4 32 1.0 #f #f #f)))
	  (map-channel (lambda (y) (phase-vocoder pv)))
	  (let ((v (channel->float-vector 0 100))
		(v0 #r(0.00332 0.01977 0.05805 0.12252 0.20738 0.29035 0.33291 0.29696 0.18017 0.04637 -0.00003 0.08250 0.18618 0.15495 0.02775 0.02252 0.13597 0.09767 -0.03116 0.05301 0.10256 -0.05005 0.01966 0.06176 -0.04418 0.04118 -0.11409 -0.04115 -0.05157 -0.11409 0.07815 -0.08155 -0.00536 0.02090 -0.18804 -0.10686 -0.11931 -0.42989 0.39009 0.03157 0.14253 0.05984 0.05439 0.00764 0.02636 -0.02799 -0.01346 -0.01011 -0.04925 -0.02896 -0.07812 -0.07880 -0.11338 -0.13133 -0.41421 0.38140 0.08676 0.07712 0.00983 0.03731 0.01585 0.00108 0.00101 0.00282 -0.01106 -0.00403 -0.02165 -0.02054 -0.02452 -0.02382 -0.03213 -0.02693 -0.03734 -0.03978 -0.04879 -0.07504 -0.09597 -0.31426 0.32995 0.13460 0.04120 0.05029 0.01900 0.02517 0.01163 0.01294 0.00827 0.00576 0.00640 0.00141 0.00489 -0.00057 0.00301 -0.00089 0.00099 0.0 0.0 0.0 0.0 -0.00000)))
	    (if (not (mus-arrays-equal? v v0))
		(snd-display "pv 6 diff: ~A" (float-vector-peak (float-vector-subtract! v v0)))))
	  (close-sound ind))))
      
    (let ()
      (define (pvoc-d beg dur amp size)
	(let ((amps #f) (paincrs #f) (ppincrs #f) (phases #f) (freqs #f))
	  (let ((sr (let ((N2 (floor (/ size 2)))
			  (two-pi (* 2 pi)))
		      (let ((ifunc (let ((osc (make-oscil 1000.0)))
				     (lambda (dir)
				       (oscil osc))))
			    
			    (efunc (let ((lastphases (make-float-vector N2)))
				     (lambda (c)
				       (do ((pscl (/ 1.0 (floor (/ size 4)))) ; overlap = 4
					    (kscl (/ two-pi size))
					    (k 0 (+ k 1))
					    (ks 0.0))
					   ((= k N2) #f)
					 (let* ((freq (freqs k))
						(diff (- freq (lastphases k))))
					   (set! (lastphases k) freq)
					   (if (> diff pi) (set! diff (- diff two-pi)))
					   (if (< diff (- pi)) (set! diff (+ diff two-pi)))
					   (set! (freqs k) (+ (* diff  pscl) ks)))
					 (set! ks (+ ks kscl))))))
			    
			    (sfunc (lambda (c)
				     (float-vector-add! amps paincrs)
				     (float-vector-add! ppincrs freqs)
				     (float-vector-add! phases ppincrs)
				     (do ((sum 0.0)
					  (i 0 (+ i 1)))
					 ((= i N2) sum)
				       (if (> (amps i) .75)
					   (set! sum (+ sum (* (amps i) (if (> (modulo (phases i) two-pi) pi) 1.0 -1.0)))))))))
			(make-phase-vocoder :fft-size size :interp (/ size 4) :overlap 4
					    :edit efunc
					    :synthesize sfunc
					    :input ifunc)))))
	    
	    (set! amps (phase-vocoder-amps sr))
	    (set! paincrs (phase-vocoder-amp-increments sr))
	    (set! ppincrs (phase-vocoder-phase-increments sr))
	    (set! phases (phase-vocoder-phases sr))
	    (set! freqs (phase-vocoder-freqs sr))
	    
	    (do ((end (seconds->samples (+ beg dur)))
		 (i (seconds->samples beg) (+ i 1)))
		((= i end))
	      (outa i (* amp (phase-vocoder sr)))))))
      
      (let ((v (make-float-vector 200)))
	(with-sound (v :srate 44100) (pvoc-d 0 .0025 .2 128))
	(do ((i 55 (+ i 1)))
	    ((= i 65))
	  (if (> (abs (- (v i) .196)) .01)
	      (snd-display "pvoc-d at ~D: ~A~%" i (v i))))
	(do ((i 75 (+ i 1)))
	    ((= i 85))
	  (if (> (abs (+ (v i) .196)) .01)
	      (snd-display "pvoc-d at ~D: ~A~%" i (v i)))))
      )

    (let ((ind (open-sound "oboe.snd")))
      (let ((gen (make-moog-filter 500.0 .1)))
	(if (fneq 500.0 (moog-frequency gen)) (snd-display "moog freq: ~A" (moog-frequency gen))) ; moog-frequency is a separate function
	(if (fneq .1 (gen 'Q)) (snd-display "moog Q: ~A" (gen 'Q)))
;	(if (not (float-vector? (gen 's))) (snd-display "moog state: ~A" (gen 's)))
	(if (fneq 0.0 (gen 'y)) (snd-display "moog A? ~A" (gen 'y)))
	(if (fneq -0.861 (gen 'fc)) (snd-display "moog freqtable: ~A" (gen 'fc)))
	(let ((vals (make-float-vector 20)))
	  (set! (vals 0) (moog-filter gen 1.0))
	  (do ((i 1 (+ i 1)))
	      ((= i 20))
	    (set! (vals i) (moog-filter gen 0.0)))
	  (if (not (mus-arrays-equal? vals #r(0.0    0.0    0.0025 0.0062 0.0120 0.0198 0.0292 0.0398 0.0510 0.0625
				     0.0739 0.0847 0.0946 0.1036 0.1113 0.1177 0.1228 0.1266 0.1290 0.1301)))
	      (snd-display "moog output: ~A" vals))))
      (close-sound ind))
    
    (let ((gen (make-ssb-am 440.0)))
      (print-and-check gen 
		       "ssb-am"
		       "ssb-am shift: up, sin/cos: 439.999975 Hz (0.000000 radians), order: 41"
		       "ssb-am shift: up, sin/cos: 440.000000 Hz (0.000000 radians), order: 41"
		       "ssb-am shift: up, sin/cos: 439.999969 Hz (0.000000 radians), order: 41")
      (let ((gen1 (make-ssb-am 440.0))
	    (v0 (make-float-vector 10))
	    (v1 (make-float-vector 10)))
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (set! (v0 i) (ssb-am gen)))
	(fill-float-vector v1 (if (ssb-am? gen1) (ssb-am gen1) -1.0))
	(if (not (mus-arrays-equal? v0 v1)) (snd-display "map ssb-am: ~A ~A" v0 v1)))
      (if (not (ssb-am? gen)) (snd-display "~A not ssb-am?" gen))
      (if (fneq (mus-phase gen) 1.253787) (snd-display "ssb-am phase: ~F?" (mus-phase gen)))
      (if (fneq (mus-frequency gen) 440.0) (snd-display "ssb-am frequency: ~F?" (mus-frequency gen)))
      (if (not (= (mus-order gen) 41)) (snd-display "ssb-am order: ~F?" (mus-order gen)))
      (if (not (= (mus-length gen) 41)) (snd-display "ssb-am length: ~D?" (mus-length gen)))
      (if (not (= (mus-interp-type gen) mus-interp-none)) (snd-display "ssb-am interp type: ~D?" (mus-interp-type gen)))
      (if (fneq (mus-xcoeff gen 0) -0.00124) (snd-display "ssb-am xcoeff 0: ~A" (mus-xcoeff gen 0)))
      (if (fneq (mus-xcoeff gen 1) 0.0) (snd-display "ssb-am xcoeff 1: ~A" (mus-xcoeff gen 1)))
					;	(if (not (float-vector? (mus-data gen))) (snd-display "mus-data ssb-am: ~A" (mus-data gen)))
					;	(if (not (float-vector? (mus-xcoeffs gen))) (snd-display "mus-xcoeffs ssb-am: ~A" (mus-xcoeffs gen)))
      ;; these apparently aren't handled in clm2xen
      )
    
    (test-gen-equal (make-ssb-am 440.0) (make-ssb-am 440.0) (make-ssb-am 500.0))
    
    (let ((o1 (make-ssb-am 400.0))
	  (o2 (make-ssb-am-1 400.0))
	  (happy #t))
      (do ((i 0 (+ i 1)))
	  ((or (not happy) (= i 100)))
	(let* ((inval (sin (* .1 i)))
	       (o1o (ssb-am o1 inval))
	       (o2o (ssb-am-1 o2 inval)))
	  (when (fneq o1o o2o)
	    (snd-display "ssb-am (up): ~A ~A at ~A" o1o o2o i)
	    (set! happy #f)))))
    
    (let ((o1 (make-ssb-am 400.0))
	  (o2 (make-ssb-am-1 400.0))
	  (happy #t))
      (do ((i 0 (+ i 1)))
	  ((or (not happy) (= i 100)))
	(let* ((inval (sin (* .1 i)))
	       (fmval (sin (* .2 i)))
	       (o1o (ssb-am o1 inval fmval))
	       (o2o (ssb-am-1 o2 inval fmval)))
	  (when (fneq o1o o2o)
	    (snd-display "ssb-am + fm (up): ~A ~A at ~A" o1o o2o i)
	    (set! happy #f)))))
    
    (let ((o1 (make-ssb-am -100.0))
	  (o2 (make-ssb-am-1 -100.0))
	  (happy #t))
      (do ((i 0 (+ i 1)))
	  ((or (not happy) (= i 100)))
	(let* ((inval (random 1.0))
	       (o1o (ssb-am o1 inval))
	       (o2o (ssb-am-1 o2 inval)))
	  (when (fneq o1o o2o)
	    (snd-display "ssb-am (down): ~A ~A at ~A" o1o o2o i)
	    (set! happy #f)))))
    
    (let ((o1 (make-ssb-am 1000.0 100))
	  (o2 (make-ssb-am-1 1000.0 100))
	  (happy #t))
      (do ((i 0 (+ i 1)))
	  ((or (not happy) (= i 100)))
	(let* ((inval (random 1.0))
	       (o1o (ssb-am o1 inval))
	       (o2o (ssb-am-1 o2 inval)))
	  (when (fneq o1o o2o)
	    (snd-display "ssb-am (down): ~A ~A at ~A" o1o o2o i)
	    (set! happy #f)))))
    
    (let ((index (open-sound "pistol.snd"))
	  (data (channel->float-vector 0 100)))
      (convolve-with "oboe.snd" #f)
      (let ((scl (maxamp)))
	(convolve-with "oboe.snd" scl index 0 0)
	(if (ffneq (maxamp) scl)
	    (snd-display "convolve-with amps: ~A ~A" (maxamp) scl)))
      (revert-sound index)
      (agc)
      (if (fneq (maxamp index 0) 1.29) (snd-display "agc: ~A" (maxamp index 0)))
      (close-sound index)
      (let ((reader (make-sampler 0 "pistol.snd")))
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (if (fneq (data i) (next-sample reader))
	      (snd-display "external reader trouble")))
	(free-sampler reader)))

    (let ((make-procs (vector
		       make-all-pass make-asymmetric-fm make-moving-average make-moving-max make-moving-norm
		       make-comb (lambda () (make-convolve :filter #r(0 1 2))) make-delay (lambda () (make-env '(0 1 1 0) :length 10))
		       (lambda () (make-filter :xcoeffs #r(0 1 2))) (lambda () (make-fir-filter :xcoeffs #r(0 1 2))) 
		       (lambda () (make-filtered-comb :filter (make-one-zero .5 .5)))
		       make-formant make-granulate
		       (lambda () (make-iir-filter :ycoeffs #r(0 1 2))) make-locsig 
		       make-notch make-one-pole (lambda () (make-one-pole-all-pass 1 .5)) make-one-zero make-oscil 
		       make-pulse-train make-rand make-rand-interp make-sawtooth-wave
		       make-square-wave make-src make-table-lookup make-triangle-wave
		       make-two-pole make-two-zero make-wave-train make-polyshape make-phase-vocoder make-ssb-am
		       (lambda () (make-filter :ycoeffs #r(0 1 2)))
		       (lambda () (make-filter :xcoeffs #r(1 2 3) :ycoeffs #r(0 1 2)))))
	  (gen-procs (vector all-pass asymmetric-fm moving-average moving-max moving-norm
			   comb convolve delay env 
			   filter fir-filter filtered-comb formant granulate
			   iir-filter (lambda (gen a) (locsig gen 0 a)) notch one-pole one-pole-all-pass one-zero oscil 
			   pulse-train rand rand-interp sawtooth-wave
			   square-wave (lambda (gen a) (src gen 0.0 a)) table-lookup triangle-wave
			   two-pole two-zero wave-train polyshape phase-vocoder ssb-am
			   filter filter))
	  (ques-procs (list all-pass? asymmetric-fm? moving-average? moving-max? moving-norm?
			    comb? convolve? delay? env? 
			    filter? fir-filter? filtered-comb? formant? granulate?
			    iir-filter? locsig? notch? one-pole? one-pole-all-pass? one-zero? oscil? 
			    pulse-train? rand? rand-interp? sawtooth-wave?
			    square-wave? src? table-lookup? triangle-wave?
			    two-pole? two-zero? wave-train? polyshape? phase-vocoder? ssb-am?
			    filter? filter?))
	  (func-names (list 'all-pass 'asymmetric-fm 'moving-average 'moving-max 'moving-norm
			    'comb 'convolve 'delay 'env 
			    'filter-x 'fir-filter 'filtered-comb 'formant 'granulate
			    'iir-filter 'locsig 'notch 'one-pole 'one-pole-all-pass 'one-zero 'oscil
			    'pulse-train 'rand 'rand-interp 'sawtooth-wave
			    'square-wave 'src 'table-lookup 'triangle-wave
			    'two-pole 'two-zero 'wave-train 'polyshape 'phase-vocoder 'ssb-am
			    'filter-y 'filter-xy))
	  (gen-args (list 0.0 0.0 1.0 1.0 1.0
			  0.0 (lambda (dir) 0.0) 0.0 #f
			  0.0 0.0 0.0 0.0 (lambda (dir) 0.0)
			  0.0 0.0 0.0 0.0 0.0 0.0 0.0
			  0.0 0.0 0.0 0.0
			  0.0 (lambda (dir) 0.0) 0.0 0.0
			  0.0 0.0 0.0 0.0 (lambda (dir) 0.0) 0.0
			  0.0 0.0))
	  (generic-procs (vector mus-channel mus-channels mus-data
			       mus-feedback mus-feedforward mus-frequency mus-hop mus-increment mus-length
			       mus-location mus-order mus-phase mus-ramp mus-scaler mus-xcoeffs mus-ycoeffs))
	  (generic-names (vector 'mus-channel 'mus-channels 'mus-data
			       'mus-feedback 'mus-feedforward 'mus-frequency 'mus-hop 'mus-increment 'mus-length
			       'mus-location 'mus-order 'mus-phase 'mus-ramp 'mus-scaler 'mus-xcoeffs 'mus-ycoeffs)))
      (for-each
       (lambda (make runp ques arg name)
	 (catch #t
	   (lambda ()
	     (let ((gen (make)))
	       (if (not (ques gen)) (snd-display "~A: ~A -> ~A?" name make gen))
	       (let ((tag (catch #t (lambda () (if arg (runp gen arg) (runp gen))) (lambda args args))))
		 (if (not (or (number? tag)
			      (float-vector? tag)))
		     (snd-display "~A: ~A ~A ~A: ~A" name runp gen arg tag)))
	       (for-each
		(lambda (func genname)
		  (let ((tag (catch #t (lambda () (func #f)) (lambda args (car args)))))
		    (if (not (eq? tag 'wrong-type-arg))
			(snd-display "generic func with #f: (~A #f) -> ~A" genname tag)))
		  (let ((g1 (make-oscil))
			(g2 (make-one-pole .1 .9)))
		    (let ((tag (catch #t (lambda () (func g1)) (lambda args (car args)))))
		      (if (and (symbol? tag)
			       (not (eq? tag 'wrong-type-arg))
			       (not (eq? tag 'mus-error)))
			  (snd-display "generic ~A of oscil: ~A" genname tag)))
		    (let ((tag (catch #t (lambda () (func g2)) (lambda args (car args)))))
		      (if (and (symbol? tag)
			       (not (eq? tag 'wrong-type-arg))
			       (not (eq? tag 'mus-error)))
			  (snd-display "generic ~A of delay: ~A" genname tag))))
		  (let ((tag (catch #t (lambda () (func gen)) (lambda args (car args)))))
		    (if (and (not (symbol? tag))
			     (dilambda? func)
			     (or (not (eq? genname 'mus-data))
				 (float-vector? tag)))
			(let ((tag1 (catch #t (lambda () (set! (func gen) tag)) (lambda args (car args)))))
			  (if (and (symbol? tag1)
				   (not (eq? tag1 'mus-error))
				   (not (eq? tag1 'out-of-range)))
			      (snd-display "~A set ~A ~A ~A -> ~A" name genname gen tag tag1))))))
		generic-procs generic-names)
	       (mus-reset gen)))
	   (lambda args #f)))
       make-procs gen-procs ques-procs gen-args func-names)
      
      (let ((make-procs (list
			 make-all-pass make-asymmetric-fm make-moving-average make-moving-max 
			 make-comb 
			 (lambda () (make-filtered-comb :filter (make-one-zero .5 .5)))
			 (lambda () (make-convolve :filter #r(0 1 2) :input (lambda (dir) 1.0))) 
			 make-delay 
			 (lambda () (make-env :length 11 :envelope '(0 1 1 0)))
			 (lambda () (make-filter :xcoeffs #r(0 1 2))) 
			 (lambda () (make-fir-filter :xcoeffs #r(0 1 2))) 
			 (lambda () (make-formant :radius .1 :frequency 440.0)) 
			 (lambda () (make-granulate (lambda (dir) 1.0)))
			 (lambda () (make-iir-filter :ycoeffs #r(0 1 2))) 
			 make-locsig 
			 make-notch 
			 (lambda () (make-one-pole .3 .7))
			 (lambda () (make-one-zero .5 .5))
			 make-oscil 
			 make-pulse-train make-sawtooth-wave
			 make-square-wave 
			 (lambda () (make-table-lookup :wave (make-float-vector 128 .1))) 
			 make-triangle-wave
			 (lambda () (make-two-pole .1 .3 .6)) 
			 (lambda () (make-two-zero .1 .3 .5)) 
			 (lambda () (make-polyshape 440.0 :partials '(1 1)))
			 (lambda () (make-phase-vocoder (lambda (dir) 1.0)))
			 make-ssb-am
			 (lambda () (make-filter :ycoeffs #r(0 1 2)))
			 (lambda () (make-filter :xcoeffs #r(1 2 3) :ycoeffs #r(0 1 2)))))
	    (gen-procs (list all-pass asymmetric-fm moving-average moving-max
			     comb filtered-comb convolve delay 
			     (lambda (gen ignored) (env gen))
			     filter fir-filter formant 
			     granulate
			     iir-filter 
			     (lambda (gen a) (locsig gen 0 1.0))
			     notch one-pole one-zero oscil 
			     pulse-train sawtooth-wave
			     square-wave table-lookup triangle-wave
			     two-pole two-zero polyshape phase-vocoder ssb-am
			     filter filter))
	    (func-names (list 'all-pass 'asymmetric-fm 'moving-average 'moving-max
			      'comb 'filtered-comb 'convolve 'delay 'env 
			      'filter-x 'fir-filter 'formant 'granulate
			      'iir-filter 'locsig 'notch 'one-pole 'one-zero 'oscil 
			      'pulse-train 'sawtooth-wave
			      'square-wave 'table-lookup 'triangle-wave
			      'two-pole 'two-zero 'polyshape 'phase-vocoder 'ssb-am
			      'filter-y 'filter-xy)))
	(for-each
	 (lambda (make runp name)
	   (let ((gen (make))
		 (data (make-float-vector 10))
		 (eloc (memq name '(env locsig)))
		 (pssb (memq name '(polyshape ssb-am))))
	     (set! (data 0) (runp gen 1.0))
	     (do ((i 1 (+ i 1)))
		 ((= i 10))
	       (set! (data i) (runp gen 0.0)))
	     (do ((k 0 (+ k 1)))
		 ((= k 2))
	       (mus-reset gen)
	       (unless eloc
		 (let ((not-zero #f)
		       (k0 (= k 0))
		       (ra (if (= k 0) 'run 'apply)))
		   (let ((first-val (if k0 (runp gen 1.0) (mus-apply gen 1.0 0.0))))
		     (if (not (= (data 0) 0.0)) (set! not-zero #t))
		     (if (fneq (data 0) first-val)
			 (snd-display "[~A] ~A: ~A ~A ~A" ra name 0 (data 0) first-val)))
		   (do ((i 1 (+ i 1)))
		       ((= i 10))
		     (let ((old-val (data i))
			   (new-val (if k0 (runp gen 0.0) (mus-apply gen 0.0 0.0))))
		       (if (not (= old-val 0.0)) (set! not-zero #t))
		       (if (fneq old-val new-val)
			   (snd-display "[~A] ~A: ~A ~A ~A" ra name i old-val new-val))))
		   (if (not (or pssb not-zero))
		       (snd-display "~A not much of a reset test!" name)))))))
	 make-procs gen-procs func-names))
      
      (when (and all-args (= clmtest 0))
	(let ((a1 (list 1.5 "/hiho" (list 0 1) 1234 (make-float-vector 3) (make-color-with-catch .95 .95 .95) #i(0 1) 3/4 'mus-error 0+i (make-delay 32)
			(lambda () #t) (curlet) (make-float-vector '(2 3)) :order 0 1 -1 #f #t #\c 0.0 1.0 -1.0 (vector 0 2)
			() 3 4 2 8 16 32 64 #() '(1 . 2) (expt 2.0 21.5) (expt 2.0 -18.0)))
	      (a2 (list 1.5 "/hiho" (list 0 1) 1234 (make-float-vector 3) (make-color-with-catch .95 .95 .95) #i(0 1) 3/4 'mus-error 0+i (make-delay 32)
			(lambda () #t) (curlet) (make-float-vector '(2 3)) :order 0 1 -1 #f #t #\c 0.0 1.0 -1.0 (vector 0 1)
			() 3 4 2 8 16 32 64 #() '(1 . 2) (expt 2.0 21.5) (expt 2.0 -18.0)))
	      (a3 (list 1.5 "/hiho" (list 0 1) 1234 (make-float-vector 3) #i(0 1) 3/4 'mus-error 0+i
			(lambda () #t) (make-float-vector '(2 3)) :order 0 1 -1 #f #t #\c 0.0 1.0 -1.0 
			() 3 4 64 -64 #() '(1 . 2) (expt 2.0 21.5) (expt 2.0 -18.0)
			(lambda (a) a))))
	  (for-each
	   (lambda (make runp)
	     (catch #t 
	       (lambda ()
		 (let ((gen (make)))
		   ;; run args
		   (for-each 
		    (lambda (arg1)
		      ;; how did this ever work??
		      (catch #t 
			(lambda () 
			  (runp gen arg1)
			  (for-each
			   (lambda (arg2)
			     (catch #t 
			       (lambda () 
				 (runp gen arg1 arg2)) 
			       (lambda args 
				 (car args))))
			   a1))
			(lambda args 
			  (car args))))
		    a2)
		   
		   ;; generic args
		   (for-each
		    (lambda (func name)
		      (catch #t
			(lambda ()
			  (let ((default-value (func gen)))
			    (for-each
			     (lambda (arg1)
			       (catch #t
				 (lambda ()
				   (func gen)
				   (set! (func gen) arg1))
				 (lambda args #f)))
			     a3)
			    (if (not (equal? (func gen) default-value))
				(catch #t
				  (lambda ()
				    (set! (func gen) default-value))
				  (lambda args #f)))))
			(lambda args #f)))
		    generic-procs generic-names)
		   (mus-reset gen)))
	       (lambda args (car args))))
	   make-procs gen-procs)
	
	  (let-temporarily ((*clm-srate* 100))
	    (for-each
	     (lambda (n)
	       (set! *clm-srate* n)
	       (for-each 
		(lambda (g name)
		  (let ((tag (catch #t (lambda () (g :frequency 440.0)) (lambda args (car args)))))
		    (if (not (memq tag '(wrong-type-arg out-of-range)))
			(snd-display "key-check ~A: ~A -> ~A" n name tag))))
		(list make-oscil make-asymmetric-fm 
		      make-triangle-wave make-square-wave make-pulse-train make-sawtooth-wave
		      make-rand make-rand-interp)
		'(oscil asymmetric-fm 
			triangle-wave square-wave pusle-train sawtooth-wave
			rand rand-interp)))
	     '(100 1)))
	  
	  (define (tgens)
	    (let ((random-args (vector
				(expt 2.0 21.5) (expt 2.0 -18.0)
				1.5 "/hiho" (list 0 1) 1234 (make-float-vector 3) (make-color-with-catch .1 .2 .3)  #i(0 1) 3/4 0+i (make-delay 32)
				(lambda () 0.0) (lambda (dir) 1.0) (lambda (a b c) 1.0) 0 1 -1 #f #t #\c 0.0 1.0 -1.0 () 32 '(1 . 2)))
		  (gens2 (list make-wave-train make-two-zero make-two-pole make-polywave make-polyshape make-rand-interp make-rand make-notch 
			       make-locsig make-filtered-comb make-fft-window make-env make-delay make-comb make-table-lookup make-moving-norm 
			       make-asymmetric-fm make-all-pass make-square-wave make-sawtooth-wave make-pulse-train make-filter make-triangle-wave 
			       make-moving-max make-moving-average make-ssb-am make-oscil make-one-zero make-one-pole-all-pass make-one-pole 
			       make-iir-filter make-formant make-fir-filter))
		  (gens3 (list make-wave-train make-two-zero make-two-pole make-polywave make-polyshape make-rand-interp make-rand make-notch 
			       make-locsig make-filtered-comb make-fft-window make-env make-delay make-comb make-table-lookup make-moving-norm 
			       make-asymmetric-fm make-all-pass make-square-wave make-sawtooth-wave make-pulse-train make-filter make-triangle-wave 
			       make-moving-max make-moving-average))
		  (gens4 (list make-wave-train make-two-zero make-two-pole make-polywave make-polyshape make-rand-interp make-rand make-notch 
			       make-locsig make-filtered-comb make-fft-window make-env make-delay make-comb make-table-lookup make-moving-norm 
			       make-asymmetric-fm make-all-pass)))

	      (define random-gen
		(lambda (args gs)
		  (for-each
		   (lambda (n)
		     (catch #t
		       (lambda ()
			 (let ((gen (apply n args)))
			   (for-each
			    (lambda (arg)
			      (catch #t
				(lambda ()
				  (gen arg))
				(lambda args #f)))
			    random-args)))
		       (lambda args #f)))
		   gs)))
	      
	      (random-gen () gens2)
	      (let ((a1 (make-list 1 #f))
		    (a2 (make-list 2 #f))
		    (a3 (make-list 3 #f))
		    (a4 (make-list 4 #f)))
		(let ((a22 (cdr a2))
		      (a32 (cdr a3))
		      (a42 (cdr a4))
		      (a33 (cddr a3))
		      (a43 (cddr a4))
		      (a44 (cdddr a4)))
		  (for-each
		   (lambda (arg1)
		     (set-car! a1 arg1)
		     (set-car! a2 arg1)
		     (set-car! a3 arg1)
		     (set-car! a4 arg1)
		     (random-gen a1 gens2)
		     (for-each 
		      (lambda (arg2)
			(set-car! a22 arg2)
			(set-car! a32 arg2)
			(set-car! a42 arg2)
			(random-gen a2 gens2)
			(for-each 
			 (lambda (arg3)
			   (set-car! a33 arg3)
			   (set-car! a43 arg3)
			   (random-gen a3 gens3)
			   (for-each 
			    (lambda (arg4)
			      (set-car! a44 arg4)
			      (random-gen a4 gens4))
			    random-args))
			 random-args))
		      random-args))
		   random-args)))))
	  (tgens))))
      
    (do ((ov (make-float-vector 10))
	 (tv #r(.1 .1 .2 .2 1.5 1.5 1.5 1.5 0.1 0.01))
	 (gen (make-moving-max 4))
	 (iv #r(.1 .05 -.2 .15 -1.5 0.1 0.01 0.001 0.0 0.0))
	 (i 0 (+ i 1)))
	((= i 10)
	 (if (not (mus-arrays-equal? tv ov))
	     (snd-display "moving-max: ~A ~A" ov tv)))
      (set! (ov i) (moving-max gen (iv i))))
    
    (do ((g1 (make-moving-max 10))
	 (i 0 (+ i 1)))
	((= i 1000))
      (let* ((val (moving-max g1 (random 1.0)))
	     (pk (float-vector-peak (mus-data g1))))
	(if (not (= pk val)) 
	    (snd-display "moving-max ~A ~A" pk val))))
    
    (let ((odata (make-float-vector 15))
	  (data #r(1.0 0.0 -1.1 1.1001 0.1 -1.1 1.0 1.0 0.5 -0.01 0.02 0.0 0.0 0.0 0.0))
	  (g (make-moving-max 3)))
	(do ((i 0 (+ i 1))) ((= i 15)) (set! (odata i) (moving-max g (data i))))
	(if (not (mus-arrays-equal? odata #r(1.000 1.000 1.100 1.100 1.100 1.100 1.100 1.100 1.000 1.000 0.500 0.020 0.020 0.000 0.000)))
	    (snd-display "moving max odata: ~A" odata))
	(if (= (odata 4) (odata 7))
	    (snd-display "moving-max .0001 offset?")))
      
    (let ((data #r(0.1 -0.2 0.3 0.4 -0.5 0.6 0.7 0.8 -0.9 1.0 0.0 0.0)))
      (let ((odata (make-float-vector 15))
	    (g (make-moving-sum 3)))
	(do ((i 0 (+ i 1))) ((= i 12)) (set! (odata i) (moving-sum g (data i))))
	(if (not (mus-arrays-equal? odata #r(0.100 0.300 0.600 0.900 1.200 1.500 1.800 2.100 2.400 2.700 1.900 1.000 0.000 0.000 0.000)))
	    (snd-display "moving-sum odata: ~A" odata)))
      
      (let ((odata (make-float-vector 15))
	    (g (make-moving-rms 4)))
	(do ((i 0 (+ i 1))) ((= i 12)) (set! (odata i) (moving-rms g (data i))))
	(if (not (mus-arrays-equal? odata #r(0.050 0.112 0.187 0.274 0.367 0.464 0.561 0.660 0.758 0.857 0.783 0.673 0.000 0.000 0.000)))
	    (snd-display "moving-rms odata: ~A" odata)))
      
      (let ((odata (make-float-vector 15))
	    (g (make-moving-length 4)))
	(do ((i 0 (+ i 1))) ((= i 12)) (set! (odata i) (moving-length g (data i))))
	(if (not (mus-arrays-equal? odata #r(0.100 0.224 0.374 0.548 0.735 0.927 1.122 1.319 1.517 1.715 1.565 1.345 0.000 0.000 0.000)))
	    (snd-display "moving-length odata: ~A" odata)))
	
      (let ((ind (new-sound "test.snd" :size 20)))
	(set! (sample 3) 1.0)
	(let ((gen1 (make-weighted-moving-average 4)))
	  (map-channel (lambda (y) (weighted-moving-average gen1 y))))
	(let ((data1 (channel->float-vector))
	      (gen2 (make-fir-filter 4 #r(0.4 0.3 0.2 0.1))))
	  (undo)
	  (map-channel (lambda (y) (fir-filter gen2 y)))
	  (let ((data2 (channel->float-vector)))
	    (if (not (mus-arrays-equal? data1 data2))
		(snd-display "weighted-moving-average and fir:~%;  ~A~%:   ~A" data1 data2)))
	  (undo))
	(close-sound ind))
      
      (let ((odata (make-float-vector 15)))
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (set! (data i) (mus-random 0.5)))
	(let ((g (make-moving-length 4)))
	  (do ((i 0 (+ i 1))) ((= i 12)) (set! (odata i) (moving-length g (data i)))))
	(do ((i -3 (+ i 1))
	     (k 0 (+ k 1)))
	    ((= i 8))
	  (do ((sum 0.0)
	       (j 0 (+ j 1)))
	      ((= j 4)
	       (if (fneq (odata k) (sqrt sum)) 
		   (snd-display "moving length ran: ~A ~A" (odata k) (sqrt sum)))) 
	    (if (>= (+ i j) 0)
		(set! sum (+ sum (* (data (+ i j)) (data (+ i j))))))))
	
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (set! (data i) (mus-random 0.5)))
	(let ((g (make-moving-sum 4)))
	  (do ((i 0 (+ i 1))) ((= i 12)) (set! (odata i) (moving-sum g (data i)))))
	(do ((i -3 (+ i 1))
	     (k 0 (+ k 1)))
	    ((= i 8))
	  (do ((sum 0.0)
	       (j 0 (+ j 1)))
	      ((= j 4)
	       (if (fneq (odata k) sum) 
		   (snd-display "moving sum ran: ~A ~A" (odata k) sum)))
	    (if (>= (+ i j) 0)
		(set! sum (+ sum (abs (data (+ i j))))))))
	
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (set! (data i) (mus-random 0.5)))
	(let ((g (make-moving-rms 4)))
	  (do ((i 0 (+ i 1))) ((= i 12)) (set! (odata i) (moving-rms g (data i)))))
	(do ((i -3 (+ i 1))
	     (k 0 (+ k 1)))
	    ((= i 8))
	  (do ((sum 0.0)
	       (j 0 (+ j 1)))
	      ((= j 4)
	       (if (fneq (odata k) (sqrt (/ sum 4))) 
		   (snd-display "moving rms ran: ~A ~A" (odata k) (sqrt (/ sum 4)))))
	    (if (>= (+ i j) 0)
		(set! sum (+ sum (* (data (+ i j)) (data (+ i j))))))))))
      
    (let ((ind (open-sound "oboe.snd")))
      (harmonicizer 550.0 '(1 .5 2 .3 3 .2) 10)
      (close-sound ind))
    
    (let ((arglist ()))
      (do ((i 0 (+ i 1)))
	  ((= i 16))
	(set! arglist (cons 440.0 (cons :frequency arglist))))
      (set! arglist (reverse arglist))
      (for-each
       (lambda (make name)
	 (let ((tag (catch #t
			   (lambda () (apply make arglist))
			   (lambda args (car args)))))
	   (if (not (memq tag '(mus-error wrong-type-arg)))
	       (snd-display "long arglist to ~A: ~A" name tag))))
       (list make-wave-train make-polyshape make-delay make-moving-average make-moving-max make-moving-norm make-comb make-filtered-comb make-notch
	     make-rand make-rand-interp make-table-lookup make-env
	     make-readin make-locsig make-granulate make-convolve make-phase-vocoder)
       '(make-wave-train make-polyshape make-delay make-moving-average make-moving-max make-moving-norm make-comb make-filtered-comb make-notch
	 make-rand make-rand-interp make-table-lookup make-env
	 make-readin make-locsig make-granulate make-convolve make-phase-vocoder)))
    
    (let ((v1 (make-float-vector 10 .1)))
      
      (let ((g1 (mus-data (make-table-lookup :wave v1))))
	(if (not (eq? v1 g1)) (snd-display "table-lookup data not eq?: ~A ~A" v1 g1))
	(if (not (eqv? v1 g1)) (snd-display "table-lookup data not eqv?: ~A ~A" v1 g1))
	(if (not (equivalent? v1 g1)) (snd-display "table-lookup data not equal?: ~A ~A" v1 g1))
	(set! (v1 1) .3)
	(if (fneq (g1 1) .3) (snd-display "table-lookup float-vector-set: ~A ~A" (v1 1) (g1 1)))
	(float-vector-set! g1 1 .5)
	(if (fneq (v1 1) .5) (snd-display "table-lookup float-vector-ref: ~A ~A" (v1 1) (g1 1))))
      
      (let ((g1 (mus-data (make-wave-train :wave v1))))
	(if (not (eq? v1 g1)) (snd-display "wave-train data not eq?: ~A ~A" v1 g1))
	(if (not (eqv? v1 g1)) (snd-display "wave-train data not eqv?: ~A ~A" v1 g1))
	(if (not (equivalent? v1 g1)) (snd-display "wave-train data not equal?: ~A ~A" v1 g1))
	(set! (v1 1) .3)
	(if (fneq (g1 1) .3) (snd-display "wave-train float-vector-set: ~A ~A" (v1 1) (g1 1)))
	(float-vector-set! g1 1 .5)
	(if (fneq (v1 1) .5) (snd-display "wave-train float-vector-ref: ~A ~A" (v1 1) (g1 1))))
      
      (let ((g1 (mus-data (make-polyshape :coeffs v1))))
	(if (not (eq? v1 g1)) (snd-display "polyshape data not eq?: ~A ~A" v1 g1))
	(if (not (eqv? v1 g1)) (snd-display "polyshape data not eqv?: ~A ~A" v1 g1))
	(if (not (equivalent? v1 g1)) (snd-display "polyshape data not equal?: ~A ~A" v1 g1))
	(set! (v1 1) .3)
	(if (fneq (g1 1) .3) (snd-display "polyshape float-vector-set: ~A ~A" (v1 1) (g1 1)))
	(float-vector-set! g1 1 .5)
	(if (fneq (v1 1) .5) (snd-display "polyshape float-vector-ref: ~A ~A" (v1 1) (g1 1))))
      
      (let ((g1 (mus-data (make-delay :initial-contents v1))))
	(if (not (eq? v1 g1)) (snd-display "delay data not eq?: ~A ~A" v1 g1))
	(if (not (eqv? v1 g1)) (snd-display "delay data not eqv?: ~A ~A" v1 g1))
	(if (not (equivalent? v1 g1)) (snd-display "delay data not equal?: ~A ~A" v1 g1))
	(set! (v1 1) .3)
	(if (fneq (g1 1) .3) (snd-display "delay float-vector-set: ~A ~A" (v1 1) (g1 1)))
	(float-vector-set! g1 1 .5)
	(if (fneq (v1 1) .5) (snd-display "delay float-vector-ref: ~A ~A" (v1 1) (g1 1))))
      
      (let ((g1 (mus-data (make-filtered-comb :scaler .5 :initial-contents v1 :filter (make-one-zero .1 .2)))))
	(if (not (eq? v1 g1)) (snd-display "filtered-comb data not eq?: ~A ~A" v1 g1))
	(if (not (eqv? v1 g1)) (snd-display "filtered-comb data not eqv?: ~A ~A" v1 g1))
	(if (not (equivalent? v1 g1)) (snd-display "filtered-comb data not equal?: ~A ~A" v1 g1))
	(set! (v1 1) .3)
	(if (fneq (g1 1) .3) (snd-display "filtered-comb float-vector-set: ~A ~A" (v1 1) (g1 1)))
	(float-vector-set! g1 1 .5)
	(if (fneq (v1 1) .5) (snd-display "filtered-comb float-vector-ref: ~A ~A" (v1 1) (g1 1))))
      
      (let ((g1 (mus-data (make-rand :distribution v1))))
	(if (not (eq? v1 g1)) (snd-display "rand data not eq?: ~A ~A" v1 g1))
	(if (not (eqv? v1 g1)) (snd-display "rand data not eqv?: ~A ~A" v1 g1))
	(if (not (equivalent? v1 g1)) (snd-display "rand data not equal?: ~A ~A" v1 g1))
	(set! (v1 1) .3)
	(if (fneq (g1 1) .3) (snd-display "rand float-vector-set: ~A ~A" (v1 1) (g1 1)))
	(float-vector-set! g1 1 .5)
	(if (fneq (v1 1) .5) (snd-display "rand float-vector-ref: ~A ~A" (v1 1) (g1 1))))
      
      (let ((g1 (mus-xcoeffs (make-fir-filter :xcoeffs v1))))
	(if (not (eq? v1 g1)) (snd-display "fir-filter xcoeffs not eq?: ~A ~A" v1 g1))
	(if (not (eqv? v1 g1)) (snd-display "fir-filter xcoeffs not eqv?: ~A ~A" v1 g1))
	(if (not (equivalent? v1 g1)) (snd-display "fir-filter xcoeffs not equal?: ~A ~A" v1 g1))
	(set! (v1 1) .3)
	(if (fneq (g1 1) .3) (snd-display "fir-filter float-vectorset: ~A ~A" (v1 1) (g1 1)))
	(float-vector-set! g1 1 .5)
	(if (fneq (v1 1) .5) (snd-display "fir-filter float-vectorref: ~A ~A" (v1 1) (g1 1))))
      
      (let ((g1 (mus-ycoeffs (make-iir-filter :ycoeffs v1))))
	(if (not (eq? v1 g1)) (snd-display "iir-filter ycoeffs not eq?: ~A ~A" v1 g1))
	(if (not (eqv? v1 g1)) (snd-display "iir-filter ycoeffs not eqv?: ~A ~A" v1 g1))
	(if (not (equivalent? v1 g1)) (snd-display "iir-filter ycoeffs not equal?: ~A ~A" v1 g1))
	(set! (v1 1) .3)
	(if (fneq (g1 1) .3) (snd-display "iir-filter float-vector-set: ~A ~A" (v1 1) (g1 1)))
	(float-vector-set! g1 1 .5)
	(if (fneq (v1 1) .5) (snd-display "iir-filter float-vector-ref: ~A ~A" (v1 1) (g1 1)))))
    
    (let ((tanh-1 (lambda (x)
		    (* x (+ 1 (* x x (- (* x x (+ 2/15 (* x x (- (* x x (+ 62/2835 (* x x -1382/155925))) 17/315)))) 1/3))))))
	  (tanh-2 (lambda (y)
		    (+ (* 140069/172800 (sin y))
		       (* 13319/241920 (sin (* 3 y)))
		       (* 1973/483840 (sin (* 5 y)))
		       (* 799/1451520 (sin (* 7 y)))
		       (* -71/7257600 (sin (* 9 y)))
		       (* 691/79833600 (sin (* 11 y)))))))
      (for-each
       (lambda (x)
	 (let ((val (tanh (sin x)))
	       (val1 (tanh-1 (sin x)))
	       (val2 (tanh-2 x)))
	   (if (or (fneq val val1)
		   (fneq val1 val2))
	       (snd-display "tanh(~A): ~A ~A ~A" x val val1 val2))))
       '(1.0 0.1 0.1 0.333)))
    
    (if all-args
	(do ((maxerr 0.0)
	     (max-case #f)
	     (cases 0)
	     (n 1 (+ n 1)))
	    ((= n 100)
	     (if (> maxerr 1e-12)
		 (snd-display "sin-m*pi/n (~A cases) max err ~A at ~A~%" cases maxerr max-case)))
	  (do ((m 1 (+ m 1)))
	      ((= m 4))
	    (let ((val (sin (/ (* m pi) n)))
		  (expr (sin-m*pi/n m n)))
	      (if expr 
		  (let ((err (magnitude (- val (eval expr)))))
		    (set! cases (+ cases 1))
		    (when (> err maxerr)
		      (set! maxerr err)
		      (set! max-case (/ m n)))))))))
    
    (let ((tag (catch #t
		      (lambda () (with-sound () (outa -1 .1)))
		      (lambda args (car args)))))
      (if (not (eq? tag 'out-of-range))
	  (snd-display "outa -1 -> ~A" tag)))
    
    (let ((tag (catch #t
		      (lambda () (with-sound ((make-float-vector 10)) (outa -1 .1)))
		      (lambda args (car args)))))
      (if (not (eq? tag 'out-of-range))
	  (snd-display "outa (float-vector) -1 -> ~A" tag)))
    
    (let ((tag (catch #t
		      (lambda () (with-sound ((make-float-vector '(1 10))) (outa -1 .1)))
		      (lambda args (car args)))))
      (if (not (eq? tag 'out-of-range))
	  (snd-display "outa (vector 2) -1 -> ~A" tag)))
    
    (let ((v (with-sound () (catch #t (lambda () 
					 (outa -1 .1))
				   (lambda args 'error)))))
      (when (file-exists? v)
	(if (> (cadr (mus-sound-maxamp v)) 0.0) 
	    (snd-display "outa to file at -1: ~A" v))
	(if (> (mus-sound-chans v) 1)
	    (snd-display "outa to file at -1 chans: ~A" (mus-sound-chans v)))
	(cond ((find-sound v) => close-sound))
	(delete-file v)))
    (let ((v (with-sound ((make-float-vector 10)) (catch #t (lambda () 
							      (outa -1 .1)) 
							(lambda args 'error)))))
      (if (> (float-vector-peak v) 0.0) (snd-display "outa to float-vector at -1: ~A" v)))
    (let ((v (with-sound ((make-float-vector '(1 10))) (catch #t (lambda () 
								       (outa -1 .1)) 
								 (lambda args 'error)))))
      (if (> (maxamp v) 0.0) (snd-display "outa to vector1 at -1: ~A" v)))
    
    (if (not (= (signum 0) 0)) (snd-display "signum 0: ~A" (signum 0)))
    (if (not (= (signum 10) 1)) (snd-display "signum 10: ~A" (signum 10)))
    (if (not (= (signum -32) -1)) (snd-display "signum -32: ~A" (signum -32)))


    (do ((c1 (make-comb .5 3))
	 (c2 (make-comb-bank (vector (make-comb .5 3))))
	 (i 0 (+ i 1))
	 (x 1.0 0.0))
	((= i 20))
      (let ((x0 (comb c1 x))
	    (x1 (comb-bank c2 x)))
	(if (not (equivalent? x0 x1))
	    (snd-display "(comb .5 3) ~A, comb: ~A, bank: ~A" i x0 x1))))
    
    (do ((c1 (make-comb .5 3))
	 (c2 (make-comb .2 10))
	 (c3 (make-comb-bank (vector (make-comb .5 3)
				     (make-comb .2 10))))
	 (i 0 (+ i 1))
	 (x 1.0 0.0))
	((= i 30))
      (let ((x0 (+ (comb c1 x) (comb c2 x)))
	    (x1 (comb-bank c3 x)))
	(if (not (equivalent? x0 x1))
	    (snd-display "(comb .5 3) + (comb .2 10) ~A, comb: ~A, bank: ~A" i x0 x1))))
  
    (do ((c1 (make-comb .5 3))
	 (c2 (make-comb .2 10))
	 (c3 (make-comb -.7 11))
	 (c4 (make-comb-bank (vector (make-comb .5 3)
				     (make-comb .2 10)
				     (make-comb -.7 11))))
	 (i 0 (+ i 1))
	 (x 1.0 0.0))
	((= i 40))
      (let ((x0 (+ (comb c1 x) (comb c2 x) (comb c3 x)))
	    (x1 (comb-bank c4 x)))
	(if (not (equivalent? x0 x1))
	    (snd-display "(comb .5 3) + (comb .2 10) + (comb -.7 11) ~A, comb: ~A, bank: ~A" i x0 x1))))
    
    (do ((c1 (make-all-pass -.5 .5 3))
	 (c2 (make-all-pass-bank (vector (make-all-pass -.5 .5 3))))
	 (i 0 (+ i 1))
	 (x 1.0 0.0))
	((= i 20))
      (let ((x0 (all-pass c1 x))
	    (x1 (all-pass-bank c2 x)))
	(if (not (equivalent? x0 x1))
	    (snd-display "(all-pass -.5 .5 3) ~A, all-pass: ~A, bank: ~A" i x0 x1))))
    
    (do ((c1 (make-all-pass -.5 .5 3))
	 (c2 (make-all-pass -.2 .2 10))
	 (c3 (make-all-pass-bank (vector (make-all-pass -.5 .5 3)
					 (make-all-pass -.2 .2 10))))
	 (i 0 (+ i 1))
	 (x 1.0 0.0))
	((= i 30))
      (let ((x0 (all-pass c1 (all-pass c2 x)))
	    (x1 (all-pass-bank c3 x)))
	(if (not (equivalent? x0 x1))
	    (snd-display "(all-pass -.5 .5 3) + (all-pass -.2 .2 10) ~A, all-pass: ~A, bank: ~A" i x0 x1))))
    
    (do ((c1 (make-all-pass -.5 .5 3))
	 (c2 (make-all-pass -.2 .2 10))
	 (c3 (make-all-pass -.7 .1 11))
	 (c4 (make-all-pass-bank (vector (make-all-pass -.5 .5 3)
					 (make-all-pass -.2 .2 10)
					 (make-all-pass -.7 .1 11))))
	 (i 0 (+ i 1))
	 (x 1.0 0.0))
	((= i 40))
      (let ((x0 (all-pass c1 (all-pass c2 (all-pass c3 x))))
	    (x1 (all-pass-bank c4 x)))
	(if (not (equivalent? x0 x1))
	    (snd-display "(all-pass -.5 .5 3) + (all-pass -.2 .2 10) + (all-pass -.7 .1 11) ~A, all-pass: ~A, bank: ~A" i x0 x1))))
    
    
    (do ((c1 (make-filtered-comb .5 3))
	 (c2 (make-filtered-comb-bank (vector (make-filtered-comb .5 3))))
	 (i 0 (+ i 1))
	 (x 1.0 0.0))
	((= i 20))
      (let ((x0 (filtered-comb c1 x))
	    (x1 (filtered-comb-bank c2 x)))
	(if (not (equivalent? x0 x1))
	    (snd-display "(filtered-comb .5 3) ~A, filtered-comb: ~A, bank: ~A" i x0 x1))))
    
    (do ((c1 (make-filtered-comb .5 3))
	 (c2 (make-filtered-comb .2 10))
	 (c3 (make-filtered-comb-bank (vector (make-filtered-comb .5 3)
					      (make-filtered-comb .2 10))))
	 (i 0 (+ i 1))
	 (x 1.0 0.0))
	((= i 30))
      (let ((x0 (+ (filtered-comb c1 x) (filtered-comb c2 x)))
	    (x1 (filtered-comb-bank c3 x)))
	(if (not (equivalent? x0 x1))
	    (snd-display "(filtered-comb .5 3) + (filtered-comb .2 10) ~A, filtered-comb: ~A, bank: ~A" i x0 x1))))
    
    (do ((c1 (make-filtered-comb .5 3))
	 (c2 (make-filtered-comb .2 10))
	 (c3 (make-filtered-comb -.7 11))
	 (c4 (make-filtered-comb-bank (vector (make-filtered-comb .5 3)
					      (make-filtered-comb .2 10)
					      (make-filtered-comb -.7 11))))
	 (i 0 (+ i 1))
	 (x 1.0 0.0))
	((= i 40))
      (let ((x0 (+ (filtered-comb c1 x) (filtered-comb c2 x) (filtered-comb c3 x)))
	    (x1 (filtered-comb-bank c4 x)))
	(if (not (equivalent? x0 x1))
	    (snd-display "(filtered-comb .5 3) + (filtered-comb .2 10) + (filtered-comb -.7 11) ~A, filtered-comb: ~A, bank: ~A" i x0 x1))))
    
    
    ;; make-formant-bank tests
    (do ((c1 (make-formant 440.0 .5))
	 (c2 (make-formant-bank (vector (make-formant 440.0 .5))))
	 (i 0 (+ i 1))
	 (x 1.0 0.0))
	((= i 40))
      (let ((x0 (formant c1 x))
	    (x1 (formant-bank c2 x)))
	(if (not (equivalent? x0 x1))
	    (snd-display "(formant 440.0 .5) ~A, formant: ~A, bank: ~A" i x0 x1))))
    
    (do ((c1 (make-formant 440.0 .5))
	 (c2 (make-formant 1000.0 .2))
	 (c3 (make-formant-bank (vector (make-formant 440.0 .5)
					(make-formant 1000.0 .2))))
	 (i 0 (+ i 1))
	 (x 1.0 0.0))
	((= i 40))
      (let ((x0 (+ (formant c1 x) (formant c2 x)))
	    (x1 (formant-bank c3 x)))
	(if (not (equivalent? x0 x1))
	    (snd-display "(formant 440.0 .5) + (formant 1000.0 .2) ~A, formant: ~A, bank: ~A" i x0 x1))))
    
    (do ((c1 (make-formant 440.0 .5))
	 (c2 (make-formant 1000.0 .2))
	 (c3 (make-formant 34.0 .1))
	 (c4 (make-formant-bank (vector (make-formant 440.0 .5)
					(make-formant 1000.0 .2)
					(make-formant 34.0 .1))))
	 (i 0 (+ i 1))
	 (x 1.0 0.0))
	((= i 40))
      (let ((x0 (+ (formant c1 x) (formant c2 x) (formant c3 x)))
	    (x1 (formant-bank c4 x)))
	(if (not (equivalent? x0 x1))
	    (snd-display "(formant 440.0 .5) + (formant 1000.0 .2) + (formant 34.0 .1) ~A, formant: ~A, bank: ~A" i x0 x1))))

    (do ((c1 (make-formant 440.0 .75))
	 (c2 (make-formant 1000.0 .75))
	 (c3 (make-formant 34.0 .75))
	 (c4 (make-formant-bank (vector (make-formant 440.0 .75)
					(make-formant 1000.0 .75)
					(make-formant 34.0 .75))))
	 (i 0 (+ i 1))
	 (x 1.0 0.0))
	((= i 40))
      (let ((x0 (+ (formant c1 x) (formant c2 x) (formant c3 x)))
	    (x1 (formant-bank c4 x)))
	(if (not (equivalent? x0 x1))
	    (snd-display "(formant 440.0 .75) + (formant 1000.0 .75) + (formant 34.0 .75) ~A, formant: ~A, bank: ~A" i x0 x1))))

    (do ((c1 (make-formant 440.0 .5))
	 (c2 (make-formant 1000.0 .2))
	 (c3 (make-formant 34.0 .1))
	 (c4 (make-formant-bank (vector (make-formant 440.0 .5)
					(make-formant 1000.0 .2)
					(make-formant 34.0 .1))
				#r(.5 .3 .4)))
	 (i 0 (+ i 1))
	 (x 1.0 0.0))
	((= i 40))
      (let ((x0 (+ (* .5 (formant c1 x)) (* .3 (formant c2 x)) (* .4 (formant c3 x))))
	    (x1 (formant-bank c4 x)))
	(if (not (equivalent? x0 x1))
	    (snd-display "fb 3 with amps at ~A, formant: ~A, bank: ~A" i x0 x1))))

    (do ((c1 (make-formant 440.0 .9))
	 (c2 (make-formant 1000.0 .9))
	 (c3 (make-formant 34.0 .9))
	 (c4 (make-formant-bank (vector (make-formant 440.0 .9)
					(make-formant 1000.0 .9)
					(make-formant 34.0 .9))
				#r(.5 .3 .4)))
	 (i 0 (+ i 1))
	 (x 1.0 0.0))
	((= i 40))
      (let ((x0 (+ (* .5 (formant c1 x)) (* .3 (formant c2 x)) (* .4 (formant c3 x))))
	    (x1 (formant-bank c4 x)))
	(if (not (equivalent? x0 x1))
	    (snd-display "fb 3 with amps c1_c2 at ~A, formant: ~A, bank: ~A" i x0 x1))))

    (do ((c1 (make-formant 440.0 .5))
	 (c2 (make-formant 1000.0 .2))
	 (c3 (make-formant 34.0 .1))
	 (inputs (make-float-vector 3 1.0))
	 (c4 (make-formant-bank (vector (make-formant 440.0 .5)
					(make-formant 1000.0 .2)
					(make-formant 34.0 .1))))
	 (i 0 (+ i 1))
	 (x 1.0 0.0))
	((= i 40))
      (let ((x0 (+ (formant c1 x) (formant c2 x) (formant c3 x)))
	    (x1 (formant-bank c4 inputs)))
	(fill! inputs 0.0)
	(if (not (equivalent? x0 x1))
	    (snd-display "many (formant 440.0 .5) + (formant 1000.0 .2) + (formant 34.0 .1) ~A, formant: ~A, bank: ~A" i x0 x1))))

    (do ((c1 (make-formant 440.0 .75))
	 (c2 (make-formant 1000.0 .75))
	 (c3 (make-formant 34.0 .75))
	 (inputs (make-float-vector 3 1.0))
	 (c4 (make-formant-bank (vector (make-formant 440.0 .75)
					(make-formant 1000.0 .75)
					(make-formant 34.0 .75))))
	 (i 0 (+ i 1))
	 (x 1.0 0.0))
	((= i 40))
      (let ((x0 (+ (formant c1 x) (formant c2 x) (formant c3 x)))
	    (x1 (formant-bank c4 inputs)))
	(fill! inputs 0.0)
	(if (not (equivalent? x0 x1))
	    (snd-display "many (formant 440.0 .75) + (formant 1000.0 .75) + (formant 34.0 .75) ~A, formant: ~A, bank: ~A" i x0 x1))))


    (do ((c1 (make-formant 440.0 .5))
	 (c2 (make-formant 1000.0 .2))
	 (c3 (make-formant 34.0 .1))
	 (inputs (make-float-vector 3 1.0))
	 (c4 (make-formant-bank (vector (make-formant 440.0 .5)
					(make-formant 1000.0 .2)
					(make-formant 34.0 .1))
				 #r(.5 .3 .4)))
	 (i 0 (+ i 1))
	 (x 1.0 0.0))
	((= i 40))
      (let ((x0 (+ (* .5 (formant c1 x)) (* .3 (formant c2 x)) (* .4 (formant c3 x))))
	    (x1 (formant-bank c4 inputs)))
	(fill! inputs 0.0)
	(if (not (equivalent? x0 x1))
	    (snd-display "fb 3 with amps at ~A, formant: ~A, bank: ~A" i x0 x1))))

    (do ((c1 (make-formant 440.0 .9))
	 (c2 (make-formant 1000.0 .9))
	 (c3 (make-formant 34.0 .9))
	 (inputs (make-float-vector 3 1.0))
	 (c4 (make-formant-bank (vector (make-formant 440.0 .9)
					(make-formant 1000.0 .9)
					(make-formant 34.0 .9))
				#r(.5 .3 .4)))
	 (i 0 (+ i 1))
	 (x 1.0 0.0))
	((= i 40))
      (let ((x0 (+ (* .5 (formant c1 x)) (* .3 (formant c2 x)) (* .4 (formant c3 x))))
	    (x1 (formant-bank c4 inputs)))
	(fill! inputs 0.0)
	(if (not (equivalent? x0 x1))
	    (snd-display "fb 3 with amps c1_c2 at ~A, formant: ~A, bank: ~A" i x0 x1))))

    (do ((c1 (make-formant 440.0 .9))
	 (c2 (make-formant 1000.0 .9))
	 (c3 (make-formant 34.0 .9))
	 (inputs (make-float-vector 3 1.0))
	 (c4 (make-formant-bank (vector (make-formant 440.0 .9)
					(make-formant 1000.0 .9)
					(make-formant 34.0 .9))
				#r(.5 .3 .4)))
	 (i 0 (+ i 1))
	 (x 1.0 0.0)
	 (y 1.0 0.0)
	 (z 1.0 0.0))
	((= i 40))
      (cond ((< i 10)
	     (let ((x0 (+ (* 0.5 (formant c1 x)) (* 0.3 (formant c2 y)) (* 0.4 (formant c3 z))))
		   (x1 (formant-bank c4 inputs)))
	       (fill! inputs 0.0)
	       (if (not (equivalent? x0 x1))
		   (snd-display "fb 3(1) with amps c1_c2 at ~A, formant: ~A, bank: ~A" i x0 x1))))
	    ((< i 20)
	     (let ((x0 (+ (* 0.5 (formant c1 x)) (* 0.3 (formant c2 y)) (* 0.4 (formant c3 z))))
		   (x1 (formant-bank c4 0.0)))
	       (if (not (equivalent? x0 x1))
		   (snd-display "fb 3(2) with amps c1_c2 at ~A, formant: ~A, bank: ~A" i x0 x1))))
	    ((< i 30)
	     (set! x 0.5)
	     (set! y 0.25)
	     (set! z 0.125)
	     (set! (inputs 0) x)
	     (set! (inputs 1) y)
	     (set! (inputs 2) z)
	     (let ((x0 (+ (* 0.5 (formant c1 x)) (* 0.3 (formant c2 y)) (* 0.4 (formant c3 z))))
		   (x1 (formant-bank c4 inputs)))
	       (if (not (equivalent? x0 x1))
		   (snd-display "fb 3(3) with amps c1_c2 at ~A, formant: ~A, bank: ~A" i x0 x1))))
	    (else
	     (set! x 0.25)
	     (set! y 0.25)
	     (set! z 0.25)
	     (let ((x0 (+ (* 0.5 (formant c1 x)) (* 0.3 (formant c2 y)) (* 0.4 (formant c3 z))))
		   (x1 (formant-bank c4 0.25)))
	       (if (not (equivalent? x0 x1))
		   (snd-display "fb 3(4) with amps c1_c2 at ~A, formant: ~A, bank: ~A" i x0 x1))))))

    (do ((c1 (make-formant 440.0 .9))
	 (c2 (make-formant 1000.0 .9))
	 (c3 (make-formant 34.0 .9))
	 (c4 (make-formant 340.0 .9))
	 (c5 (make-formant 2000.0 .9))
	 (inputs (make-float-vector 5 1.0))
	 (c6 (make-formant-bank (vector (make-formant 440.0 .9)
					(make-formant 1000.0 .9)
					(make-formant 34.0 .9)
					(make-formant 340.0 .9)
					(make-formant 2000.0 .9))))
	 (i 0 (+ i 1))
	 (x 1.0 0.0)
	 (y 1.0 0.0)
	 (z 1.0 0.0)
	 (a 1.0 0.0)
	 (b 1.0 0.0))
	((= i 40))
      (cond ((< i 10)
	     (let ((x0 (+ (formant c1 x) (formant c2 y) (formant c3 z) (formant c4 a) (formant c5 b)))
		   (x1 (formant-bank c6 inputs)))
	       (fill! inputs 0.0)
	       (if (not (equivalent? x0 x1))
		   (snd-display "fb 5(1) no amps c1_c2 at ~A, formant: ~A, bank: ~A" i x0 x1))))
	    ((< i 20)
	     (let ((x0 (+ (formant c1 x) (formant c2 y) (formant c3 z) (formant c4 a) (formant c5 b)))
		   (x1 (formant-bank c6 0.0)))
	       (if (not (equivalent? x0 x1))
		   (snd-display "fb 5(2) no amps c1_c2 at ~A, formant: ~A, bank: ~A" i x0 x1))))
	    ((< i 30)
	     (set! x 0.5)
	     (set! y 0.25)
	     (set! z 0.125)
	     (set! a 0.1)
	     (set! b 0.3)
	     (set! (inputs 0) x)
	     (set! (inputs 1) y)
	     (set! (inputs 2) z)
	     (set! (inputs 3) a)
	     (set! (inputs 4) b)
	     (let ((x0 (+ (formant c1 x) (formant c2 y) (formant c3 z) (formant c4 a) (formant c5 b)))
		   (x1 (formant-bank c6 inputs)))
	       (if (not (equivalent? x0 x1))
		   (snd-display "fb 5(3) no amps c1_c2 at ~A, formant: ~A, bank: ~A" i x0 x1))))
	    (else
	     (set! x 0.25)
	     (set! y 0.25)
	     (set! z 0.25)
	     (set! a 0.25)
	     (set! b 0.25)
	     (let ((x0 (+ (formant c1 x) (formant c2 y) (formant c3 z) (formant c4 a) (formant c5 b)))
		   (x1 (formant-bank c6 0.25)))
	       (if (not (equivalent? x0 x1))
		   (snd-display "fb 5(4) no amps c1_c2 at ~A, formant: ~A, bank: ~A" i x0 x1))))))
		      
    (set! *clm-srate* 44100)
    (when (file-exists? "jcrev-ip.snd")
      (with-sound (:reverb jc-reverb) (outa 0 .1) (outa 0 .5 *reverb*))
      (let ((s1 (find-sound "test.snd"))
	    (s2 (open-sound "jcrev-ip.snd")))
	(if (not (= (channel-distance s1 0 s2 0) 0.0))
	    (snd-display "jcrev ip: ~A" (channel-distance s1 0 s2 0)))
	(close-sound s1)
	(close-sound s2)))
    
    (when (file-exists? "nrev-ip.snd")
      (with-sound (:reverb nrev) (outa 0 .1) (outa 0 .5 *reverb*))
      (let ((s1 (find-sound "test.snd"))
	    (s2 (open-sound "nrev-ip.snd")))
	(if (not (= (channel-distance s1 0 s2 0) 0.0))
	    (snd-display "nrev ip: ~A" (channel-distance s1 0 s2 0)))
	(close-sound s1)
	(close-sound s2)))
    
    (when (file-exists? "freeverb-ip.snd")
      (with-sound (:reverb freeverb :reverb-data '(:output-gain 3.0)) (outa 0 .5 *reverb*))
      (let ((s1 (find-sound "test.snd"))
	    (s2 (open-sound "freeverb-ip.snd")))
	(if (not (= (channel-distance s1 0 s2 0) 0.0))
	    (snd-display "freeverb ip: ~A" (channel-distance s1 0 s2 0)))
	(close-sound s1)
	(close-sound s2)))
    
    (let ()
      (defgenerator (old-rxyk!sin
		     :make-wrapper (lambda (g)
				     (set! (g 'frequency) (hz->radians (g 'frequency)))
				     g))
	(frequency 0.0) (ratio 1.0) (r 0.5) (angle 0.0) fm)
      
      (define* (old-rxyk!sin gen (fm 0.0))
	(set! (gen 'fm) fm)
	(with-let gen
	  (let* ((x angle)
		 (y (* x ratio)))
	    (set! angle (+ x fm frequency))
	    (/ (* (exp (* r (cos y)))
		  (sin (+ x (* r (sin y)))))
	       (exp (abs r))))))
      
      (defgenerator (old-rxyk!cos
		     :make-wrapper (lambda (g)
				     (set! (g 'frequency) (hz->radians (g 'frequency)))
				     (set! (g 'ar) (/ 1.0 (exp (abs (g 'r)))))
				     g))
	(frequency 0.0) (ratio 1.0) (r 0.5) (angle 0.0) fm ar)
      
      (define* (old-rxyk!cos gen (fm 0.0))
	(set! (gen 'fm) fm)
	(with-let gen
	  (let* ((x angle)
		 (y (* x ratio)))
	    (set! angle (+ x fm frequency))
	    (* (exp (* r (cos y)))
	       (cos (+ x (* r (sin y))))
	       ar))))
      
      (define-macro (define-memoized name&arg . body)
	(let ((arg (cadr name&arg))
	      (memo (gensym "memo")))
	  `(define ,(car name&arg)
	     (let ((,memo (make-hash-table)))
	       (lambda (,arg)
		 (or (,memo ,arg)                             ; check for saved value
		     (set! (,memo ,arg) (begin ,@body)))))))) ; set! returns the new value
      
      (define-memoized (kfactorial n)
	(define (k n m)
	  (if (<= n m)
	      n
	      (* (k n (* 2 m))
		 (k (- n m) (* 2 m)))))
	(if (zero? n)
	    1
	    (k n 1)))
      
      (define (rxyk!cos-direct x y a terms)
	(do ((sum 0.0)
	     (k 0 (+ k 1)))
	    ((= k terms) (/ sum (exp (abs a))))
	  (set! sum (+ sum (* (/ (expt a k) (kfactorial k))
			      (cos (+ x (* k y))))))))
      
      (define (rxyk!sin-direct x y a terms)
	(do ((sum 0.0)
	     (k 0 (+ k 1)))
	    ((= k terms) (/ sum (exp (abs a))))
	  (set! sum (+ sum (* (/ (expt a k) (kfactorial k))
			      (sin (+ x (* k y))))))))
    
      
      (let ((g1 (make-rxyk!cos 100.0))
	    (g2 (make-old-rxyk!cos 100.0))
	    (x3 (hz->radians 100.0)))
	(do ((i 0 (+ i 1))
	     (x 0.0 (+ x x3)))
	    ((= i 100))
	  (let ((v1 (rxyk!cos g1))
		(v2 (old-rxyk!cos g2))
		(v3 (rxyk!cos-direct x x 0.5 12)))
	    (if (or (> (abs (- v1 v2)) 1e-6)
		    (> (abs (- v1 v3)) 1e-6))
		(format () ";rxyk!cos ~A ~A: ~A ~A ~A -> ~A~%" i x v1 v2 v3 (max (abs (- v1 v2)) (abs (- v1 v3))))))))
      
      (let ((g1 (make-rxyk!sin 100.0))
	    (g2 (make-old-rxyk!sin 100.0))
	    (x3 (hz->radians 100.0)))
	(do ((i 0 (+ i 1))
	     (x 0.0 (+ x x3)))
	    ((= i 100))
	  (let ((v1 (rxyk!sin g1))
		(v2 (old-rxyk!sin g2))
		(v3 (rxyk!sin-direct x x 0.5 12)))
	    (if (or (> (abs (- v1 v2)) 1e-6)
		    (> (abs (- v1 v3)) 1e-6))
		(format () ";rxyk!sin ~A ~A: ~A ~A ~A -> ~A~%" i x v1 v2 v3 (max (abs (- v1 v2)) (abs (- v1 v3))))))))
      
      (let ((g1 (make-rxyk!cos 100.0 :ratio 2.0 :r 0.25))
	    (g2 (make-old-rxyk!cos 100.0 :ratio 2.0 :r 0.25)))
	(do ((i 0 (+ i 1)))
	    ((= i 100))
	  (let ((v1 (rxyk!cos g1))
		(v2 (old-rxyk!cos g2)))
	    (if (> (abs (- v1 v2)) 1e-6)
		(format () ";rxyk!cos ratio:2: ~A: ~A ~A -> ~A~%" i v1 v2 (abs (- v1 v2)))))))
      
      (let ((g1 (make-rxyk!sin 100.0 :ratio 2.0 :r 0.25))
	    (g2 (make-old-rxyk!sin 100.0 :ratio 2.0 :r 0.25)))
	(do ((i 0 (+ i 1)))
	    ((= i 100))
	  (let ((v1 (rxyk!sin g1))
		(v2 (old-rxyk!sin g2)))
	    (if (> (abs (- v1 v2)) 1e-6)
		(format () ";rxyk!sin ratio:2: ~A: ~A ~A -> ~A~%" i v1 v2 (abs (- v1 v2)))))))
      
      (let ((g1 (make-rxyk!cos 100.0 :ratio 2.0 :r 0.25))
	    (o1 (make-oscil 400.0))
	    (g2 (make-old-rxyk!cos 100.0 :ratio 2.0 :r 0.25))
	    (o2 (make-oscil 400.0)))
	(do ((i 0 (+ i 1)))
	    ((= i 100))
	  (let ((v1 (rxyk!cos g1 (oscil o1)))
		(v2 (old-rxyk!cos g2 (oscil o2))))
	    (if (> (abs (- v1 v2)) 1e-6)
		(format () ";rxyk!cos fm ~A: ~A ~A -> ~A~%" i v1 v2 (abs (- v1 v2)))))))
      
      (let ((g1 (make-rxyk!sin 100.0 :ratio 2.0 :r 0.25))
	    (o1 (make-oscil 400.0))
	    (g2 (make-old-rxyk!sin 100.0 :ratio 2.0 :r 0.25))
	    (o2 (make-oscil 400.0)))
	(do ((i 0 (+ i 1)))
	    ((= i 100))
	  (let ((v1 (rxyk!sin g1 (oscil o1)))
		(v2 (old-rxyk!sin g2 (oscil o2))))
	    (if (> (abs (- v1 v2)) 1e-6)
		(format () ";rxyk!sin fm ~A: ~A ~A -> ~A~%" i v1 v2 (abs (- v1 v2))))))))

    (let ()
      (defgenerator one-pole-allpass coeff input x1 y1)
      
      (define (one-pole-allpass gen input)
	(set! (gen 'input) input)
	(with-let gen
	  (set! y1 (+ x1 (* coeff (- input y1))))
	  (set! x1 input)
	  y1))
      
      (defgenerator one-pole-allpass-bank coeff input x1 y1 x2 y2 x3 y3 x4 y4 x5 y5 x6 y6 x7 y7 x8 y8) 
      
      (define (one-pole-allpass-bank gen input)
	(set! (gen 'input) input)
	(with-let gen
	  (set! y1 (+ x1 (* coeff (- input y1))))
	  (set! x1 input)
	  
	  (set! y2 (+ x2 (* coeff (- y1 y2))))
	  (set! x2 y1)
	  
	  (set! y3 (+ x3 (* coeff (- y2 y3))))
	  (set! x3 y2)
	  
	  (set! y4 (+ x4 (* coeff (- y3 y4))))
	  (set! x4 y3)
	  
	  (set! y5 (+ x5 (* coeff (- y4 y5))))
	  (set! x5 y4)
	  
	  (set! y6 (+ x6 (* coeff (- y5 y6))))
	  (set! x6 y5)
	  
	  (set! y7 (+ x7 (* coeff (- y6 y7))))
	  (set! x7 y6)
	  
	  (set! y8 (+ x8 (* coeff (- y7 y8))))
	  (set! x8 y7)
	  y8))
      
      (let ((o1 (make-one-pole-all-pass 1 .5))
	    (o2 (make-one-pole-allpass .5)))
	(do ((i 0 (+ i 1))
	     (impulse 1.0 0.0))
	    ((= i 30))
	  (let ((v1 (one-pole-all-pass o1 impulse))
		(v2 (one-pole-allpass o2 impulse)))
	    (if (> (abs (- v1 v2)) 1e-6)
		(format () ";one-pole-all-pass (1) ~A: ~A ~A -> ~A~%" i v1 v2 (abs (- v1 v2)))))))
      
      (let ((o1 (make-one-pole-all-pass 8 .5))
	    (o2 (make-one-pole-allpass-bank .5)))
	(do ((i 0 (+ i 1))
	     (impulse 1.0 0.0))
	    ((= i 30))
	  (let ((v1 (one-pole-all-pass o1 impulse))
		(v2 (one-pole-allpass-bank o2 impulse)))
	    (if (> (abs (- v1 v2)) 1e-6)
		(format () ";one-pole-all-pass (1) ~A: ~A ~A -> ~A~%" i v1 v2 (abs (- v1 v2)))))))
      )

    (let-temporarily ((*clm-srate* 44100))
      (do ((pe (make-pulsed-env '(0 0 1 1 2 0) .0004 2205))
	   (v (make-float-vector 100))
	   (i 0 (+ i 1)))
	  ((= i 100)
	   (if (not (mus-arrays-equal? v #r(0.000 0.125 0.250 0.375 0.500 0.625 0.750 0.875 1.000 0.875 0.750 0.625 0.500 0.375 0.250 0.125 0.000 0.000 0.000 0.000 
					    0.000 0.125 0.250 0.375 0.500 0.625 0.750 0.875 1.000 0.875 0.750 0.625 0.500 0.375 0.250 0.125 0.000 0.000 0.000 0.000 
					    0.000 0.125 0.250 0.375 0.500 0.625 0.750 0.875 1.000 0.875 0.750 0.625 0.500 0.375 0.250 0.125 0.000 0.000 0.000 0.000 
					    0.000 0.125 0.250 0.375 0.500 0.625 0.750 0.875 1.000 0.875 0.750 0.625 0.500 0.375 0.250 0.125 0.000 0.000 0.000 0.000 
					    0.000 0.125 0.250 0.375 0.500 0.625 0.750 0.875 1.000 0.875 0.750 0.625 0.500 0.375 0.250 0.125 0.000 0.000 0.000 0.000)))
	       (snd-display "pulsed-env: ~A" v)))
	(set! (v i) (pulsed-env pe))))

    (for-each copy-test 
      (vector (make-oscil 330.0)
	      (make-ncos 440.0 10)
	      (make-nsin 440.0 10)
	      (make-nrxycos 330.0 0.9 10)
	      (make-nrxysin 330.0 0.9 10)
	      (make-rxyk!cos 440.0)
	      (make-rxyk!sin 440.0)
	      (make-sawtooth-wave 100)
	      (make-pulse-train 100)
	      (make-triangle-wave 100)
	      (make-square-wave 100)
	      (make-one-zero .1 .2)
	      (make-one-pole .1 .2)
	      (make-two-zero .9 .1 .2)
	      (make-two-pole .9 .1 .2)
	      (make-polywave 440.0 '(1 .5 2 .5))
	      (make-polyshape 440.0 :coeffs (partials->polynomial '(1 1.0)))
	      (make-oscil-bank #r(100 200 300) #r(0.0 1.0 2.0) #r(0.5 0.25 0.125))
	      (make-delay 10)
	      (make-comb .7 10)
	      (make-notch .7 10)
	      (make-all-pass .8 .7 10)
	      (make-moving-average 10)
	      (make-moving-norm 10)
	      (make-moving-max 10)
	      (make-comb-bank (vector (make-comb 0.742 99) (make-comb 0.733 49) (make-comb 0.715 53)))
	      (make-all-pass-bank (vector (make-all-pass -0.700 0.700 51) (make-all-pass -0.700 0.700  33) (make-all-pass -0.700 0.700 11)))
	      (make-filtered-comb .4 5 :filter (make-one-zero .3 .7))
	      (make-filtered-comb-bank (vector (make-filtered-comb .5 3) (make-filtered-comb .2 10) (make-filtered-comb -.7 11)))
	      (make-formant 1200.0 0.9)
	      (make-firmant 1200.0 0.9)
	      (make-fir-filter 4 #r(0.4 0.3 0.2 0.1))
	      (make-iir-filter 4 #r(0.4 0.3 0.2 0.1))
	      (make-filter 4 #r(0.4 0.3 0.2 0.1))
	      (make-one-pole-all-pass 8 .5)
	      (make-readin "oboe.snd")
	      (make-env '(0 0 1 1) :length 10)
	      (make-pulsed-env '(0 0 1 1) .001 1000)))
	      
    ;; formant-bank isn't really testing equality yet
    
    (let* ((o (make-rand 100.0))
	   (p (copy o)))
      (if (not (equal? o p))
	  (snd-display "rand copy ~A != ~A~%" o p)))
    
    (let* ((o (make-rand-interp 100.0))
	   (p (copy o)))
      (if (not (equal? o p))
	  (snd-display "rand-interp copy ~A != ~A~%" o p)))
    
    (let* ((v1 (make-float-vector 10 .1))
	   (o (make-rand 100.0 :distribution v1))
	   (p (copy o)))
      (if (not (equal? o p))
	  (snd-display "rand+dist copy ~A != ~A~%" o p))
      
      (let* ((o (make-rand-interp 100.0 :distribution v1))
	     (p (copy o)))
	(if (not (equal? o p))
	    (snd-display "rand-interp+dist copy ~A != ~A~%" o p))))
    
    (let* ((o (make-nssb 440.0))
	   (p (copy o)))
      (if (not (equal? o p))
	  (snd-display "nssb copy ~A != ~A~%" o p))
      (nssb o 1.0)
      (if (equal? o p)
	  (snd-display "nssb copy/run ~A == ~A~%" o p)))
    
    (let* ((o (make-wave-train 100 :wave #r(0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9)))
	   (p (copy o)))
      (if (not (equal? o p))
	  (snd-display "wave-train copy ~A != ~A~%" o p)))
    
    (let* ((o (make-table-lookup 440.0 :wave #r(0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9)))
	   (p (copy o)))
      (if (not (equal? o p))
	  (snd-display "table-lookup copy ~A != ~A~%" o p))
      (table-lookup o 1.0)
      (if (equal? o p)
	  (snd-display "table-lookup run ~A == ~A~%" o p)))

    ;; object->let
    (for-each 
     object->let
     (vector 
      (make-polywave 440.0 :partials '(1 1) :type mus-chebyshev-first-kind)
      (make-polyshape 440.0 :coeffs (partials->polynomial '(1 1)))
      (make-move-sound (list 0 1000 1 0
			     (make-delay 32) 
			     (make-env '(0 0 1 1) :length 1001) 
			     (make-env '(0 0 1 1) :length 1001)
			     (vector (make-delay 32)) 
			     (vector (make-env '(0 0 1 1) :length 1001)) 
			     #f
			     (vector 0 1)) (make-float-vector 100))
      (make-phase-vocoder #f 512 4 256 1.0)
      (make-phase-vocoder (lambda (dir) (next-sample reader))
			  512 4 256 1.0
			  (lambda (v infunc)
			    (set! incalls (+ incalls 1)))
			  #f ;no change to edits
			  (lambda (v)
			    (set! outcalls (+ outcalls 1))
			    0.0))
      (make-ssb-am 100.0 8)
      (make-sample->file "fmv.snd" 2 mus-lshort mus-riff)
      (make-frample->file "fmv.snd" 2 mus-lshort mus-riff)
      (make-locsig)
      (make-locsig :reverb .1 :distance 2.0 :degree 46)
      (make-granulate :expansion .5 :scaler .4 :ramp .3)
      (make-rand 100)
      (make-rand-interp 100 :amplitude .1)
      (make-rand-interp 100 :amplitude .1 :envelope '(0 0 1 1))
      (make-rand 100 :amplitude .1 :envelope '(0 0 1 1) :size 8)
      (make-one-pole-all-pass 8 .5)
      (make-pulsed-env '(0 0 1 1 2 0) .0004 2205)
      (make-convolve :filter #r(0 1 2) :input (lambda (dir) 1.0))
      (make-env '(0 0 1 1) :length 11 :scaler .5)
      (make-env '(0 0 1 1) :length 11 :scaler .1 :offset .1 :base 3.0)
      (make-src :srate .5)
      (make-src :srate 2.0 :input (make-readin "oboe.snd" 0 10000))
      (make-file->sample "oboe.snd")
      (make-file->frample"4.aiff")
      (make-readin :file "oboe.snd")
      (make-readin :start 123 :channel 2 :file "4.aiff")
      (make-comb-bank (vector (make-comb .5 3) (make-comb .2 4)))
      (make-all-pass-bank (vector (make-all-pass -.5 .5 3) (make-all-pass -.2 .2 10) (make-all-pass -.7 .1 11)))
      (make-filtered-comb-bank (vector (make-filtered-comb .5 3)))
      (make-wave-train 440.0 0.0 #r(0 0 0))
      (make-table-lookup :wave #r(0 1 2 1 0))
      (make-moving-max 3)
      (make-moving-average 3)
      (make-moving-norm 3 :scaler 0.5)
      (make-filtered-comb .4 5 :filter (make-one-zero .3 .7))
      (make-all-pass .1 .9 3)
      (make-delay 3)
      (make-notch :initial-contents #r(0 1 2 3) :scaler .1 :type 3)
      (make-comb :size 3 :scaler .1)
      (make-formant 1000 .5)
      (make-firmant 1000 .5)
      (make-formant-bank (vector (make-formant 440.0 .5)))
      (make-formant-bank (vector (make-formant 440.0 .5) (make-formant 1000.0 .2) (make-formant 34.0 .1)) #r(.5 .3 .4))
      (make-oscil 440)
      (let ((o (make-oscil 440))) (oscil o) o)
      (make-nsin 100.0 3)
      (make-nsin :n 4 :frequency 100)
      (make-ncos 100.0 3)
      (make-nrxysin :n 3 :frequency 100 :r .1)
      (make-nrxysin :n 4 :frequency 100 :ratio .1)
      (make-nrxycos :n 4 :frequency 100 :ratio .1)
      (make-oscil-bank #r(0.0 0.0) #r(0.0 0.0) #r(0.0 0.0))
      (make-oscil-bank #r(100 200 300) #r(0.0 1.0 2.0) #r(0.5 0.25 0.125))
      (make-rxyk!sin :frequency 100)
      (make-rxyk!cos :frequency 100 :r .1 :ratio .6)
      (make-asymmetric-fm 100)
      (make-asymmetric-fm 100 :r .3 :ratio 2.0)
      (make-square-wave 100 :amplitude .5 :initial-phase 1.0)
      (make-sawtooth-wave 100 :amplitude .25)
      (make-triangle-wave)
      (make-pulse-train 100)
      (make-fir-filter :order 3 :xcoeffs #r(1.0 0.5 0.25))
      (make-iir-filter :order 4 :ycoeffs #r(1.0 0.5 0.25 -0.1))
      (make-filter 3 #r(1.0 0.5 0.2) #r(0.2 0.3 0.4))
      (make-one-zero .3 .2)
      (make-one-pole .3 .2)
      (make-two-zero :frequency 1000 :radius .5)
      (make-two-pole :frequency 1000 :radius .5)
      ))))



;;; ---------------- test 9: mix ----------------

(define (snd_test_9)
  
  (when with-gui
    (do ((test-ctr 0 (+ 1 test-ctr)))
	((= test-ctr tests))
      
      (let ((ind (new-sound "test.snd" :size 10)))
	(let ((v #r(.1 .2 .3)))
	  (let ((id (mix-float-vector v 0)))
	    (let ((nv (channel->float-vector)))
	      (if (not (mus-arrays-equal? nv #r(.1 .2 .3 0 0 0 0 0 0 0)))
		  (snd-display "mix v at 0: ~A" nv)))
	    (let ((eds (edit-tree ind 0)))
	      (if (not (feql eds '((0 0 0 2 0.0 0.0 0.0 3) (3 0 3 9 0.0 0.0 0.0 2) (10 -2 0 0 0.0 0.0 0.0 0))))
		  (snd-display "mix v at 0 eds: ~A" eds)))
	    (if (not (mix? id))
		(snd-display "mix v at 0 id from mix?: ~A" id))
	    (if (fneq (mix-amp id) 1.0) (snd-display "mix v at 0 amp: ~A" (mix-amp id)))
	    (if (fneq (mix-speed id) 1.0) (snd-display "mix v at 0 speed: ~A" (mix-speed id)))
	    (if (not (= (mix-sync id) 0)) (snd-display "mix v at 0 sync: ~A" (mix-sync id)))
	    (if (not (null? (mix-amp-env id))) (snd-display "mix v at 0 amp-env: ~A" (mix-amp-env id)))
	    (if (not (= (mix-position id) 0)) (snd-display "mix v at 0 beg: ~A" (mix-position id)))
	    (if (not (= (mix-length id) 3)) (snd-display "mix v at 0 length: ~A" (mix-length id)))
	    (if (not (string=? (mix-name id) "")) (snd-display "mix v at 0 name: ~A" (mix-name id)))
	    (if (not (null? (mix-properties id))) (snd-display "mix v at 0 properties: ~A" (mix-properties id)))
	    (if (not (equal? (mix-color id) *mix-color*)) (snd-display "mix v at 0 color: ~A" (mix-color id)))
	    (if (not (= (mix-tag-y id) 0)) (snd-display "mix v at 0 tag-y: ~A" (mix-tag-y id)))
	    (let ((sf (make-mix-sampler id))
		  (data (make-float-vector 10)))
	      (do ((i 0 (+ i 1)))
		  ((= i 10))
		(set! (data i) (read-mix-sample sf)))
	      (if (not (mus-arrays-equal? data (channel->float-vector)))
		  (snd-display "mix v at 0 read mix samples: ~A" data))
	      (if (not (sampler-at-end? sf)) (snd-display "mix v at 0 reader not at end?"))
	      (free-sampler sf))
	    (if (not (equal? (mixes ind 0) (list id))) (snd-display "mix v at 0 mixes: ~A" (mixes ind 0)))
	    (if (not (equal? (mix-home id) (list ind 0 #f 0))) (snd-display "mix v at 0 home: ~A" (mix-home id)))
	    (undo))
	  (mix-float-vector v 8)
	  (if (not (= (framples ind 0) 11)) (snd-display "mix v at 8 new len: ~A" (framples ind 0)))
	  (let ((nv (channel->float-vector)))
	    (if (not (mus-arrays-equal? nv #r(0 0 0 0 0 0 0 0 .1 .2 .3)))
		(snd-display "mix v at 8: ~A" nv)))
	  (undo)
	  (mix-float-vector v 3)
	  (if (not (= (framples ind 0) 10)) (snd-display "mix v at 3 new len: ~A" (framples ind 0)))
	  (let ((nv (channel->float-vector)))
	    (if (not (mus-arrays-equal? nv #r(0 0 0 .1 .2 .3 0 0 0 0)))
		(snd-display "mix v at 3: ~A" nv)))
	  (undo))
	(let ((v (make-float-vector 20 .5)))
	  (mix-float-vector v 0)
	  (if (not (= (framples ind 0) 20)) (snd-display "mix v20 at 0 new len: ~A" (framples ind 0))))
	(close-sound ind))
      
      (let ((ind (new-sound "test.snd" :size 100000)))
	(let ((id (car (mix "oboe.snd" 0))))
	  (if (not (mix? id))
	      (snd-display "mix oboe at 0 id from mix?: ~A" id))
	  (if (fneq (mix-amp id) 1.0) (snd-display "mix oboe at 0 amp: ~A" (mix-amp id)))
	  (if (fneq (mix-speed id) 1.0) (snd-display "mix oboe at 0 speed: ~A" (mix-speed id)))
	  (if (not (= (mix-sync id) 0)) (snd-display "mix oboe at 0 sync: ~A" (mix-sync id)))
	  (if (not (null? (mix-amp-env id))) (snd-display "mix oboe at 0 amp-env: ~A" (mix-amp-env id)))
	  (if (not (= (mix-position id) 0)) (snd-display "mix oboe at 0 beg: ~A" (mix-position id)))
	  (if (not (= (mix-length id) 50828)) (snd-display "mix oboe at 0 length: ~A" (mix-length id)))
	  (if (not (string=? (mix-name id) "")) (snd-display "mix oboe at 0 name: ~A" (mix-name id)))
	  (if (not (null? (mix-properties id))) (snd-display "mix oboe at 0 properties: ~A" (mix-properties id)))
	  (if (not (equal? (mix-color id) *mix-color*)) (snd-display "mix oboe at 0 color: ~A" (mix-color id)))
	  (if (not (= (mix-tag-y id) 0)) (snd-display "mix oboe at 0 tag-y: ~A" (mix-tag-y id)))
	  
	  (if (fneq (maxamp ind 0) .14724) (snd-display "mix oboe maxamp: ~A" (maxamp ind 0)))
	  (if (not (equal? (mixes ind 0) (list id))) (snd-display "mix oboe at 0 mixes: ~A" (mixes ind 0)))
	  (if (not (equal? (mix-home id) (list ind 0 "/home/bil/cl/oboe.snd" 0))) (snd-display "mix oboe at 0 home: ~A" (mix-home id))))
	(undo)
	(mix "oboe.snd" 70000)
	(if (not (= (framples ind 0) 120828)) ;(+ 70000 50828)
	    (snd-display "mix oboe at 70k framples: ~A" (framples ind 0)))
	(close-sound ind))
      
      (let ((ind (new-sound "test.snd" :size 10))
	     (v #r(.1 .2 .3)))
	(let ((id (mix-float-vector v 0)))
	  (scale-by 2.0)
	  (if (not (mix? id)) (snd-display "scaled (2) mix not active?"))
	  (let ((nv (channel->float-vector)))
	    (if (not (mus-arrays-equal? nv (float-vector-scale! #r(.1 .2 .3 0 0 0 0 0 0 0) 2.0)))
		(snd-display "mix v at 0 scale-by 2: ~A" nv)))
	  (if (fneq (mix-amp id) 2.0) (snd-display "mix then scale mix amp: ~A" (mix-amp id)))
	  (undo)
	  (delete-sample 1)
	  (if (not (mix? id)) (snd-display "delete hit mix: ~A" (mix? id)))
	  (let ((nv (channel->float-vector)))
	    (if (not (mus-arrays-equal? nv #r(.1 .3 0 0 0 0 0 0 0)))
		(snd-display "mix v at 0 delete .2: ~A" nv)))
	  (revert-sound ind))
	(let ((id (mix-float-vector v 0)))
	  (delete-sample 7)
	  (reverse-sound ind 0)
	  (if (not (mix? id)) (snd-display "reversed mix: ~A" (mix? id)))
	  (let ((nv (channel->float-vector)))
	    (if (not (mus-arrays-equal? nv (reverse! (float-vector .1 .2 .3 0 0 0 0 0 0))))
		(snd-display "mix v at 0 reversed: ~A" nv)))
	  (undo)
	  (if (not (mix? id)) (snd-display "revert reverse mix: ~A" (mix? id)))
	  (map-channel (lambda (y) .1))
	  (if (not (mix? id)) (snd-display "clobbered mix: ~A" (mixes)))
	  (scale-by 2.0)
	  (let ((id (mix-float-vector v 0)))
	    (if (not (mix? id)) (snd-display "mix on scale (2) not active?"))
	    (scale-by 3.0)
	    (if (not (mix? id)) (snd-display "scaled (3) mix not active?"))
	    (let ((nv (channel->float-vector)))
	      (if (not (mus-arrays-equal? nv (float-vector-scale! (float-vector-add! (make-float-vector 9 .2) #r(.1 .2 .3)) 3.0)))
		  (snd-display "mix v at 0 scale-by 2 and 3: ~A" nv))))
	  (revert-sound ind)
	  (map-channel (lambda (y) 1.0))
	  (env-channel '(0 0 1 1 2 0) 0 11)
	  (let ((v #r(.1 .2 .3)))
	    (mix-float-vector v 3)
	    (let ((nv (channel->float-vector)))
	      (if (not (mus-arrays-equal? nv #r(0.0 0.200 0.400 0.700 1.000 1.300 0.800 0.600 0.400 0.200)))
		  (snd-display "mix v at 3 after env: ~A" nv))))
	  (close-sound ind)))
      
      (let* ((ind (new-sound "test.snd" :size 100))
	     (v #r(.1 .2 .3))
	     (id (mix-float-vector v 10)))
	(pad-channel 0 10)
	(if (not (mix? id)) (snd-display "padded mix not active?"))
	(if (not (= (mix-position id) 20)) (snd-display "after pad mix pos: ~A" (mix-position id)))
	(set! (mix-sync id) 2)
	(if (not (= (mix-sync id) 2)) (snd-display "set mix sync 2: ~A" (mix-sync id)))
	(if (and full-test (< (mix-sync-max) 2)) (snd-display "mix-sync-max: ~A" (mix-sync-max)))
	(pad-channel 50 10)
	(if (not (mix? id)) (snd-display "padded 50 mix not active?"))
	(if (not (= (mix-position id) 20)) (snd-display "after pad 50 mix pos: ~A" (mix-position id)))
	(undo 1)
	(let ((id1 (mix-float-vector v 22))
	      (id2 (mix-float-vector v 21)))
	  (let ((vals (channel->float-vector 18 10)))
	    (if (not (mus-arrays-equal? vals #r(0.0 0.0 0.100 0.300 0.600 0.500 0.300 0.0 0.0 0.000)))
		(snd-display "mix 3 vs: ~A" vals)))
	  (if (not (mix? id)) (snd-display "mix 3vs 1 not active?"))
	  (if (not (mix? id1)) (snd-display "mix 3vs 2 not active?"))
	  (if (not (mix? id2)) (snd-display "mix 3vs 3 not active?"))
	  (set! (mix-position id) 10)
	  (let ((vals (channel->float-vector 18 10)))
	    (if (not (mus-arrays-equal? vals #r(0.0 0.0 0.0 0.100 0.300 0.500 0.300 0.0 0.0 0.000)))
		(snd-display "mix 3 vs then move first: ~A" vals))
	    (set! (mix-position id2) 30))
	  (let ((vals (channel->float-vector 18 10)))
	    (if (not (mus-arrays-equal? vals #r(0.0 0.0 0.0 0.0 0.100 0.200 0.300 0.0 0.0 0.000)))
		(snd-display "mix 3 vs then move 2: ~A" vals)))
	  (scale-by 2.0)
	  (if (not (mix? id)) (snd-display "mix 3vs 1 scl not active?"))
	  (if (not (mix? id1)) (snd-display "mix 3vs 2 scl not active?"))
	  (if (not (mix? id2)) (snd-display "mix 3vs 3 scl not active?"))
	  (let ((vals (channel->float-vector 18 10)))
	    (if (not (mus-arrays-equal? vals #r(0.0 0.0 0.0 0.0 0.200 0.400 0.600 0.0 0.0 0.000)))
		(snd-display "mix 3 vs then move 2 scl: ~A" vals)))
	  (delete-sample 15)
	  (if (not (mix? id)) (snd-display "mix 3vs 1 scl del not active?"))
	  (if (not (mix? id1)) (snd-display "mix 3vs 2 scl del not active?"))
	  (if (not (mix? id2)) (snd-display "mix 3vs 3 scl del not active?"))
	  (if (not (= (mix-position id) 10)) (snd-display "mix 3vs etc pos: ~A" (mix-position id)))
	  (if (not (= (mix-position id1) 21)) (snd-display "mix 3vs etc pos 1: ~A" (mix-position id1)))
	  (if (not (= (mix-position id2) 29)) (snd-display "mix 3vs etc pos 2: ~A" (mix-position id2))))
	(close-sound ind))
      
      (let* ((ind (new-sound "test.snd" :size 15))
	     (id (mix-float-vector (make-float-vector 11 1.0) 2)))
	(set! (mix-amp-env id) '(0 0 1 1))
	(let ((vals (channel->float-vector)))
	  (if (not (mus-arrays-equal? vals #r(0 0 0 .1 .2 .3 .4 .5 .6 .7 .8 .9 1.0 0 0)))
	      (snd-display "ramp mix amp env: ~A" vals)))
	(set! (mix-amp-env id) #f)
	(if (pair? (mix-amp-env id)) (snd-display "set mix-amp-env to null: ~A" (mix-amp-env id)))
	(set! (mix-speed id) 0.5)
	(if (not (= (framples) 24)) (snd-display "mix speed lengthens 24: ~A" (framples)))
	(set! (mix-speed id) 1.0)
	(let ((vals (channel->float-vector)))
	  (if (not (mus-arrays-equal? vals #r(0 0 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0)))
	      (snd-display "return to mix original index: ~A" vals)))
	(set! (mix-amp-env id) '(0 0 1 1 2 1 3 0))
	(set! (mix-speed id) 0.5)
	(set! (mix-amp-env id) #f)
	(set! (mix-speed id) 1.0)
	(let ((vals (channel->float-vector)))
	  (if (not (mus-arrays-equal? vals #r(0 0 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0)))
	      (snd-display "return again to mix original index: ~A" vals)))
	(close-sound ind))
      
      (let ((id (open-sound "oboe.snd")))
	(make-selection 1000 2000 id 0)
	(let ((mix-id (car (mix-selection 3000 id 0))))
	  (set! (mix-amp mix-id) .5)
	  (if (fneq (mix-amp mix-id) .5)
	      (snd-display "mix-amp .5: ~A" (mix-amp mix-id))))
	(scale-by .5)
	(undo)
	(close-sound id))
      (set! *print-length* 30)
      
      (let* ((ind (open-sound "2.snd"))
	     (md (car (mix "1a.snd" 1000 0 ind 1 #t))))
	(if (fneq (maxamp ind 1) .1665) (snd-display "maxamp after mix into chan 2: ~A" (maxamp ind 1)))
	(set! (mix-amp md) 0.0)
	(if (not (and (equal? (edits ind 0) '(0 0))
		      (equal? (edits ind 1) '(2 0))))
	    (snd-display "mix into chan2 zeroed: ~A ~A" (edits ind 0) (edits ind 1)))
	(if (fneq (maxamp ind 1) .066) (snd-display "maxamp after mix zeroed into chan 2: ~A" (maxamp ind 1)))
	(set! (mix-amp md) 0.5)
	(if (fneq (maxamp ind 1) .116) (snd-display "maxamp after mix 0.5 into chan 2: ~A" (maxamp ind 1)))
	(set! (mix-speed md) 2.0)
	(if (fneq (/ (mix-length md) (mus-sound-framples "1a.snd")) 0.5)
	    (snd-display "mix srate chan 2: ~A ~A" (mix-length md) (mus-sound-framples "1a.snd")))
	(update-time-graph)
	(set! (mix-speed md) 0.5)
	(update-time-graph)
	(set! (mix-amp md) 1.0)
	(if (fneq (maxamp ind 1) .166)
	    (snd-display "non-sync mix-speed maxamp: ~A" (maxamp ind 1)))
	(set! (mix-amp-env md) '(0 0 1 1 2 0))
	(update-time-graph)
	(set! (mix-speed md) 1.0)
	(update-time-graph)
	(revert-sound ind)
	(set! (sync ind) 1)
	(let ((m0 (maxamp ind 0))
	      (m1 (maxamp ind 1))
	      (len (framples ind 0)))
	  (set! md (mix "2.snd" 0 #t)) ; should double both chans, no len change
	  (if (or (not (= (framples ind 0) len))
		  (fneq (maxamp ind 0) (* 2 m0))
		  (fneq (maxamp ind 1) (* 2 m1)))
	      (snd-display "mix twice syncd: 0: ~A -> ~A, m1: ~A -> ~A, len: ~A -> ~A"
			   m0 (maxamp ind 0) m1 (maxamp ind 1) len (framples ind 0))))
	(set! (hook-functions mix-release-hook) ())
	(close-sound ind))
      
      (let ((ind (new-sound "fmv.snd" 1 22050 mus-ldouble mus-next "mix tests")))
	(insert-silence 0 20 ind)
	(let ((indout (new-sound "test.snd" 1 22050 mus-ldouble mus-next "mix tests")))
	  (insert-silence 0 10 indout)
	  (set! (sample 2 indout 0) .5)
	  (set! (sample 5 indout 0) .25)
	  (save-sound indout)
	  (close-sound indout))
	(let ((tag (car (mix "test.snd"))))
	  (let ((samps (channel->float-vector 0 20))
		(v (make-float-vector 20)))
	    (set! (v 2) .5)
	    (set! (v 5) .25)
	    (if (not (mus-arrays-equal? samps v))
		(snd-display "mix 1->1: ~A ~A" samps v)))
	  (if (not (mix? tag)) (snd-display "mix 1->1 tag: ~A" tag))
	  (undo))
	(let ((tag (car (mix "test.snd" 5))))
	  (let ((samps (channel->float-vector 0 20))
		(v (make-float-vector 20)))
	    (set! (v 7) .5)
	    (set! (v 10) .25)
	    (if (not (mus-arrays-equal? samps v))
		(snd-display "mix 1->1 at 5: ~A ~A" samps v)))
	  (if (not (mix? tag)) (snd-display "mix 1->1 at 5 tag: ~A" tag))
	  (undo))
	(let ((tag (mix "test.snd" 0 0 ind 0 #f)))
	  (let ((samps (channel->float-vector 0 20))
		(v (make-float-vector 20)))
	    (set! (v 2) .5)
	    (set! (v 5) .25)
	    (if (not (mus-arrays-equal? samps v))
		(snd-display "mix 1->1 at 0 #f: ~A ~A" samps v)))
	  (if (mix? tag) (snd-display "mix 1->1 at 5 #f tag: ~A" tag))
	  (undo))
	(let ((indout (new-sound "test.snd" 2 22050 mus-ldouble mus-next "mix tests")))
	  (insert-silence 0 10 indout 0)
	  (insert-silence 0 10 indout 1)
	  (set! (sample 2 indout 0) .5)
	  (set! (sample 5 indout 0) .25)
	  (set! (sample 2 indout 1) .95)
	  (set! (sample 5 indout 1) .125)
	  (save-sound indout)
	  (close-sound indout))
	(let ((tag (car (mix "test.snd" 0 1))))
	  (let ((samps (channel->float-vector 0 20))
		(v (make-float-vector 20)))
	    (set! (v 2) .95)
	    (set! (v 5) .125)
	    (if (not (mus-arrays-equal? samps v))
		(snd-display "mix 2->1: ~A ~A" samps v)))
	  (if (not (mix? tag)) (snd-display "mix 2->1 tag: ~A" tag))
	  (undo))
	(let ((tag (car (mix "test.snd" 5 1))))
	  (let ((samps (channel->float-vector 0 20))
		(v (make-float-vector 20)))
	    (set! (v 7) .95)
	    (set! (v 10) .125)
	    (if (not (mus-arrays-equal? samps v))
		(snd-display "mix 2->1 at 5: ~A ~A" samps v)))
	  (if (not (mix? tag)) (snd-display "mix 2->1 at 5 tag: ~A" tag))
	  (undo))
	(close-sound ind))

      (let ((ind (new-sound "fmv.snd" 2 22050 mus-ldouble mus-next "mix tests")))
	(insert-silence 0 20 ind 0)
	(insert-silence 0 20 ind 1)
	(let ((tag (car (mix "test.snd" 0 #t))))
	  (let ((v (make-float-vector 20)))
	    (set! (v 2) .95) 
	    (set! (v 5) .125)
	    (let ((samps1 (channel->float-vector 0 20 ind 1)))
	      (if (not (mus-arrays-equal? samps1 v))
		  (snd-display "mix 1->1 (2): ~A ~A" samps1 v)))
	    (set! (v 2) .5)
	    (set! (v 5) .25)
	    (let ((samps0 (channel->float-vector 0 20 ind 0)))
	      (if (not (mus-arrays-equal? samps0 v))
		  (snd-display "mix 1->1 (3): ~A ~A" samps0 v))))
	  (if (not (mix? tag)) (snd-display "mix 1->1 tag: ~A" tag)))
	(undo 1 ind 0)
	(undo 1 ind 1)
	(let ((tag (mix "test.snd" 0 1 ind 1 #f))) ; samp:0, in-chan: 1
	  (let ((samps1 (channel->float-vector 0 20 ind 1))
		(v (make-float-vector 20)))
	    (let ((samps0 (channel->float-vector 0 20 ind 0)))
	      (if (not (mus-arrays-equal? samps0 v))
		  (snd-display "mix 1->1 (4): ~A ~A" samps0 v)))
	    (set! (v 2) .95)
	    (set! (v 5) .125)
	    (if (not (mus-arrays-equal? samps1 v))
		(snd-display "mix 1->1 (5): ~A ~A" samps1 v)))
	  (if (mix? tag) (snd-display "mix 1->1 tag (5): ~A" tag)))
	(undo 1 ind 1)
	(set! (sync ind) 1)
	(mix "test.snd" 0 #t)
	(let ((samps1 (channel->float-vector 0 20 ind 1))
	      (v (make-float-vector 20)))
	  (let ((samps0 (channel->float-vector 0 20 ind 0)))
	    (set! (v 2) .5)
	    (set! (v 5) .25)
	    (if (not (mus-arrays-equal? samps0 v))
		(snd-display "mix 1->1 (6): ~A ~A" samps0 v)))
	  (set! (v 2) .95)
	  (set! (v 5) .125)
	  (if (not (mus-arrays-equal? samps1 v))
	      (snd-display "mix 1->1 (7): ~A ~A" samps1 v)))
	(undo)
	(close-sound ind))
      (delete-file "test.snd")
      (delete-file "fmv.snd")
      
      ;; check ripple_mixes
      (let* ((ind (open-sound "oboe.snd"))
	     (data (channel->float-vector 100 100))
	     (m1 (mix-float-vector data 321 ind 0 #t))
	     (m2 (mix-float-vector data 123 ind 0 #t)))
	(set! (mix-position m1) 500)
	(if (not (= (mix-position m1) 500)) (snd-display "mix-position m1[0]: ~A" (mix-position m1)))
	(if (not (= (mix-position m2) 123)) (snd-display "mix-position m2[0]: ~A" (mix-position m2)))
	(undo)
	(set! (mix-position m2) 500)
	(if (not (= (mix-position m2) 500)) (snd-display "mix-position m2[1]: ~A" (mix-position m2)))
	(if (not (= (mix-position m1) 321)) (snd-display "mix-position m1[1]: ~A" (mix-position m1)))
	(undo)
	(insert-silence 0 100)
	(if (not (= (mix-position m1) 421)) (snd-display "mix-position m1[2]: ~A" (mix-position m1)))
	(if (not (= (mix-position m2) 223)) (snd-display "mix-position m2[2]: ~A" (mix-position m2)))
	(delete-samples 0 50)
	(if (not (= (mix-position m1) 371)) (snd-display "mix-position m1[3]: ~A" (mix-position m1)))
	(if (not (= (mix-position m2) 173)) (snd-display "mix-position m2[3]: ~A" (mix-position m2)))
	(undo 2)
	(set! (mix-position m2) 500)
	(undo)
	(scale-channel 0.5 1000 100)
	(if (not (= (mix-position m2) 123)) (snd-display "mix-position m2[5]: ~A" (mix-position m2)))
	(if (not (= (mix-position m1) 321)) (snd-display "mix-position m1[5]: ~A" (mix-position m1)))
	(undo)
	(set! (mix-position m2) 500)
	(undo)
	(set! (mix-position m2) 500)
	(undo-edit)
	(ramp-channel 0.0 1.0 3000 100)
	(catch #t
	  (lambda ()
	    (if (not (= (mix-position m2) 123)) (snd-display "mix-position m2[7]: ~A" (mix-position m2)))
	    (if (not (= (mix-position m1) 321)) (snd-display "mix-position m1[7]: ~A" (mix-position m1))))
	  (lambda args (snd-display "mix-position trouble: ~A" args)))
	(undo)
	(delay-channel-mixes 200 100 ind 0)
	(if (not (= (mix-position m2) 123)) (snd-display "delay-channel mixes mix-position m2: ~A" (mix-position m2)))
	(if (not (= (mix-position m1) 421)) (snd-display "delay-channel-mixes mix-position m1: ~A" (mix-position m1)))
	(check-mix-tags ind 0)
	(close-sound ind))
      
      ;; check that current console is correct
      (let ((ind (open-sound "storm.snd")))
	(set! (x-bounds) (list 0 80.0))
	(make-selection 1000000 1050000)
	(let ((m1 (car (mix-selection 900000)))
	      (m2 (car (mix-selection 400000))))
	  (as-one-edit (lambda () 
			 (set! (mix-position m1) 0) 
			 (set! (mix-position m2) 1)))
	  (if (not (and (= (mix-position m1) 0)
			(= (mix-position m2) 1)))
	      (snd-display "as-one-edit positions: ~A ~A" (mix-position m1) (mix-position m2)))
	  (undo-channel)
	  (if (not (and (= (mix-position m1) 900000)
			(= (mix-position m2) 400000)))
	      (snd-display "as-one-edit positions after undo: (~A): ~A (~A): ~A" m1 (mix-position m1) m2 (mix-position m2)))
	  (redo-channel)
	  (if (not (and (= (mix-position m1) 0)
			(= (mix-position m2) 1)))
	      (snd-display "as-one-edit positions after redo: ~A ~A" (mix-position m1) (mix-position m2)))
	  (close-sound ind)))
      
      (let ((ind (open-sound "2.snd")))
	(make-selection 0 10000 ind)
	(if (not (= (selection-chans) 2))
	    (snd-display "stereo selection: ~A" (selection-chans)))
	(set! (sync ind) #t)
	(let ((md (car (mix-selection 500 ind))))
	  (if (not (mix? (integer->mix (+ 1 (mix->integer md)))))
	      (snd-display "where is second mix? ~A ~A" md (mixes)))
	  (if (not (= (edit-position ind 0) 1))
	      (snd-display "edit-position 0 after stereo mix selection: ~A" (edit-position ind 0)))
	  (if (not (= (edit-position ind 1) 1))
	      (snd-display "edit-position 1 after stereo mix selection: ~A" (edit-position ind 1)))
	  (set! (sync ind) #f)
	  (undo-edit 1 ind 0)
	  (delete-sample 25 ind 0)
	  (set! (mix-position (integer->mix (+ 1 (mix->integer md)))) 750)
	  (if (not (= (edit-position ind 1) 2))
	      (snd-display "edit-position 1 after stereo mix selection moved: ~A" (edit-position ind 2)))
	  (revert-sound ind)
	  (close-sound ind)))
      
      (let ((ind (new-sound "test.snd"))
	    (v (make-float-vector 20)))
	(do ((i 0 (+ i 1))) ((= i 20)) (set! (v i) (* i .01)))
	(float-vector->channel v)
	(do ((i 0 (+ i 1))) ((= i 20)) (set! (v i) (* i -.01)))
	(let ((mx (mix-float-vector v 10)))
	  (let ((hi (make-mix-sampler mx))
		(ho (make-mix-sampler mx 5))
		(happy #t))
	    (do ((i 0 (+ i 1)))
		((or (not happy) (= i 10)))
	      (let ((ho-val (ho))
		    (hi-val (hi)))
		(when (fneq hi-val (* i -.01))
		  (snd-display "mix-reader at ~A from 0: ~A" i hi-val)
		  (set! happy #f))
		(when (fneq ho-val (* (+ i 5) -.01))
		  (snd-display "mix-reader at ~A from 5: ~A" i ho-val)
		  (set! happy #f))))))
	(revert-sound ind)
	(set! v (make-float-vector 21 0.5))
	(float-vector->channel v)
	(let ((mx (mix-float-vector v 10)))
	  (set! (mix-amp-env mx) '(0 0 1 1))
	  (let ((hi (make-mix-sampler mx 0))
		(ho (make-mix-sampler mx 10))
		(happy #t))
	    (do ((i 0 (+ i 1)))
		((or (not happy) (= i 10)))
	      (let ((ho-val (ho))
		    (hi-val (hi)))
		(when (fneq hi-val (* i .025))
		  (snd-display "mix-reader env'd at ~A from 0: ~A" i hi-val)
		  (set! happy #f))
		(when (fneq ho-val (* (+ i 10) .025))
		  (snd-display "mix-reader env'd at ~A from 10: ~A" i ho-val)
		  (set! happy #f))))))
	(close-sound ind))
      
      (let ((ind (open-sound "oboe.snd"))
	    (id (mix-float-vector (make-float-vector 10 .1))))
	(set! (mix-position id) 100)
	(if (not (and (= (mix-position id) 100)
		      (= (edit-position ind 0) 2)))
	    (snd-display "mix-position init: ~A ~A" (mix-position id) (edit-position ind 0)))
	(set! (mix-position id) 100)
	(if (not (and (= (mix-position id) (mix-position id))
		      (= (edit-position ind 0) 2)))
	    (snd-display "mix-position 2 (no-op): ~A ~A" (mix-position id) (edit-position ind 0)))
	(set! (mix-amp id) 1.0)
	(if (or (fneq (mix-amp id) 1.0)
		(not (= (edit-position ind 0) 2)))
	    (snd-display "mix-amp no-op: ~A ~A" (mix-amp id) (edit-position ind 0)))
	(set! (mix-amp id) 0.5)
	(if (or (fneq (mix-amp id) 0.5)
		(not (= (edit-position ind 0) 3)))
	    (snd-display "mix-amp .5: ~A ~A" (mix-amp id) (edit-position ind 0)))
	(set! (mix-speed id) 1.0)
	(if (or (fneq (mix-speed id) 1.0)
		(not (= (edit-position ind 0) 3)))
	    (snd-display "mix-speed no-op: ~A ~A" (mix-speed id) (edit-position ind 0)))
	(set! (mix-speed id) .5)
	(if (or (fneq (mix-speed id) 0.5)
		(not (= (edit-position ind 0) 4)))
	    (snd-display "mix-speed .5: ~A ~A" (mix-speed id) (edit-position ind 0)))
	(set! (mix-amp-env id) '(0 0 1 1))
	(if (not (= (edit-position ind 0) 5))
	    (snd-display "mix-amp-env init: ~A ~A" (mix-amp-env id) (edit-position ind 0)))
	(set! (mix-amp-env id) '(0 0 1 1))
	(if (not (= (edit-position ind 0) 5))
	    (snd-display "mix-amp-env no-op: ~A ~A" (mix-amp-env id) (edit-position ind 0)))
	(close-sound ind))
      
      (let ((ind (new-sound "test.snd" 1 22050 mus-ldouble mus-next "color-mix tests" 300))
	    (old-color *mix-color*))
	(set! *mix-color* (make-color-with-catch 1 1 0))
	(let ((mix1 (mix-float-vector (make-float-vector 10 .5) 10)))
	  (if (not (and (member (color->list *mix-color*)      '((1.0 1.0 0.0) (1.0 1.0 0.0 1.0)))
			(member (color->list (mix-color mix1)) '((1.0 1.0 0.0) (1.0 1.0 0.0 1.0)))))
	      (snd-display "set mix-color: ~A ~A ~A ~A" 
			   (color->list *mix-color*) (color->list (mix-color mix1)) '(1.0 1.0 0.0) (color->list old-color)))
	  (set! *mix-color* old-color)
	  (save-mix mix1 "test1.snd")
	  (let ((ind1 (open-sound "test1.snd")))
	    (if (not (= (framples ind1) (mix-length mix1))) (snd-display "save-mix framples: ~A ~A" (mix-length mix1) (framples ind1)))
	    (if (not (mus-arrays-equal? (channel->float-vector 0 10) (mix->float-vector mix1)))
		(snd-display "save-mix data: ~A ~A" (mix->float-vector mix1) (channel->float-vector 0 10 ind1)))
	    
	    (let ((mix7 (integer->mix 71231)))
	      (if (mix? mix7) (snd-display "mix? ~A~%" mix7))
	      (catch #t 
		(lambda () 
		  (save-mix mix7 "test.snd")
		  (snd-display "save-mix of a bad mix??"))
		(lambda args #f)))
	    (close-sound ind1)
	    (if (file-exists? "test1.snd") (delete-file "test1.snd"))))
	(close-sound ind))
      
      (let ((ind (new-sound "test.snd" 1 22050 mus-ldouble mus-next "lock mix tests" 300)))
	(let ((mix1 (mix-float-vector (make-float-vector 10 .5) 10)))
	  (set! (mix-amp mix1) 0.0))
	(if (fneq (maxamp ind 0) 0.0) (snd-display "delete-mix maxamp: ~A" (maxamp ind 0)))
	(undo-channel 1 ind 0)
	(if (fneq (maxamp ind 0) 0.5) (snd-display "undelete-mix maxamp: ~A" (maxamp ind 0)))
	(redo-channel 1 ind 0)
	(if (fneq (maxamp ind 0) 0.0) (snd-display "redelete-mix maxamp: ~A" (maxamp ind 0)))
	(undo 2)
	(if (fneq (maxamp ind 0) 0.0) (snd-display "no delete-mix maxamp: ~A" (maxamp ind 0)))
	(redo)
	(if (fneq (maxamp ind 0) 0.5) (snd-display "reundelete-mix maxamp: ~A" (maxamp ind 0)))
	(close-sound ind))
      
      (let* ((ind (new-sound "test.snd" :size 100))
	     (id (mix-float-vector (make-float-vector 5 .5) 11))
	     (fv5 #r(0 0.5 0.5 0.5 0.5 0.5 0 0 0 0)))
	
	;; pad-channel
	(if (not (mus-arrays-equal? (channel->float-vector 10 10) fv5))
	    (snd-display "float-vector .5 at 11: ~A" (channel->float-vector 10 10)))
	(pad-channel 0 10)
	(if (not (mix? id))
	    (snd-display "pad locked mix? ~A" (mix? id)))
	(if (not (= (mix-position id) 21))
	    (snd-display "float-vector .5 at 21 position: ~A" (mix-position id)))
	(if (not (mus-arrays-equal? (channel->float-vector 20 10) fv5))
	    (snd-display "float-vector .5 at 21: ~A" (channel->float-vector 20 10)))
	(if (not (mus-arrays-equal? (channel->float-vector 10 10) (make-float-vector 10)))
	    (snd-display "float-vector .5 at 21 at 10: ~A" (channel->float-vector 10 10)))
	(pad-channel 30 10)
	(if (not (mix? id))
	    (snd-display "pad 30 locked mix? ~A" (mix? id)))
	(if (not (= (mix-position id) 21))
	    (snd-display "float-vector .5 at 21 position 30: ~A" (mix-position id)))
	(if (not (mus-arrays-equal? (channel->float-vector 20 10) fv5))
	    (snd-display "float-vector .5 at 21 30: ~A" (channel->float-vector 20 10)))
	(pad-channel 150 10)
	(if (not (mix? id))
	    (snd-display "pad 150 locked mix? ~A" (mix? id)))
	(if (not (= (mix-position id) 21))
	    (snd-display "float-vector .5 at 21 position 150: ~A" (mix-position id)))
	(if (not (mus-arrays-equal? (channel->float-vector 20 10) fv5))
	    (snd-display "float-vector .5 at 21 150: ~A" (channel->float-vector 20 10)))
	(pad-channel 20 10)
	(if (not (mix? id))
	    (snd-display "pad 20 locked mix? ~A" (mix? id)))
	(if (not (= (mix-position id) 31))
	    (snd-display "float-vector .5 at 31 position: ~A" (mix-position id)))
	(if (not (mus-arrays-equal? (channel->float-vector 30 10) fv5))
	    (snd-display "float-vector .5 at 31: ~A" (channel->float-vector 30 10)))
	(pad-channel 32 3)
					;	    (if (mix? id) (snd-display "pad within mix but exists?: ~A" (mix? id)))
	(if (not (mix? id)) (snd-display "pad within mix but no mix?: ~A" (mix? id)))
	(if (not (mus-arrays-equal? (channel->float-vector 30 10) #r(0 .5 0 0 0 .5 .5 .5 .5 0)))
	    (snd-display "float-vector .5 at 31 pad at 32: ~A" (channel->float-vector 30 10)))
	
	(set! (edit-position) 1)
	(if (not (mix? id)) (snd-display "mix float-vector after reset edit position: ~A" (mix? id)))
	(if (not (= (mix-position id) 11)) (snd-display "mix float-vector position after reset edit position: ~A" (mix-position id)))
	(if (not (mus-arrays-equal? (channel->float-vector 10 10) fv5))
	    (snd-display "float-vector .5 at 11 after reset edit: ~A" (channel->float-vector 10 10)))
	
	;; delete
	(delete-samples 0 10)
	(if (not (mix? id))
	    (snd-display "delete locked mix? ~A" (mix? id)))
	(if (not (= (mix-position id) 1))
	    (snd-display "float-vector .5 at 1 position: ~A" (mix-position id)))
	(if (not (mus-arrays-equal? (channel->float-vector 0 10) fv5))
	    (snd-display "float-vector .5 at 1: ~A" (channel->float-vector 0 10)))
	(delete-samples 30 10)
	(if (not (mix? id))
	    (snd-display "delete 30 locked mix? ~A" (mix? id)))
	(if (not (= (mix-position id) 1))
	    (snd-display "float-vector .5 at 1 position del 30: ~A" (mix-position id)))
	(if (not (mus-arrays-equal? (channel->float-vector 0 10) fv5))
	    (snd-display "float-vector .5 at 1 del 30: ~A" (channel->float-vector 0 10)))
	(delete-samples 3 3)
					;	    (if (mix? id) (snd-display "delete within mix but exists?: ~A" (mix? id)))
	(if (not (mix? id)) (snd-display "delete within mix but no mix?: ~A" (mix? id)))
	(if (not (mus-arrays-equal? (channel->float-vector 0 10) #r(0 .5 .5 0 0 0 0 0 0 0)))
	    (snd-display "float-vector .5 at 1 del at 3: ~A" (channel->float-vector 0 10)))
	
	(set! (edit-position) 1)
	(if (not (mix? id)) (snd-display "mix float-vector after del reset edit position: ~A" (mix? id)))
	(if (not (= (mix-position id) 11)) (snd-display "mix float-vector position after del reset edit position: ~A" (mix-position id)))
	(if (not (mus-arrays-equal? (channel->float-vector 10 10) fv5))
	    (snd-display "float-vector .5 at 11 after del reset edit: ~A" (channel->float-vector 10 10)))
	
	;; change
	(set! (samples 0 5) (make-float-vector 5 .6))
	(if (not (mix? id))
	    (snd-display "set locked mix? ~A" (mix? id)))
	(if (not (= (mix-position id) 11))
	    (snd-display "float-vector .5 at 11 set position: ~A" (mix-position id)))
	(if (not (mus-arrays-equal? (channel->float-vector 10 10) fv5))
	    (snd-display "float-vector .5 at 11 set: ~A" (channel->float-vector 10 10)))
	(set! (samples 20 5) (make-float-vector 5 .7))
	(if (not (mix? id))
	    (snd-display "set 20 locked mix? ~A" (mix? id)))
	(if (not (= (mix-position id) 11))
	    (snd-display "float-vector .5 at 11 set 20 position: ~A" (mix-position id)))
	(if (not (mus-arrays-equal? (channel->float-vector 10 10) fv5))
	    (snd-display "float-vector .5 at 11 set 20: ~A" (channel->float-vector 10 10)))
	(set! (samples 12 2) #r(-.5 .8))
					;	    (if (mix? id) (snd-display "set within mix but exists?: ~A" (mix? id)))
	(if (not (mix? id)) (snd-display "set within mix but no mix?: ~A" (mix? id)))
	(if (not (mus-arrays-equal? (channel->float-vector 10 10) #r(0 .5 -.5 .8 .5 .5 0 0 0 0)))
	    (snd-display "float-vector .5 at 11 set at 12: ~A" (channel->float-vector 10 10)))
	
	(set! (edit-position) 1)
	(if (not (mix? id)) (snd-display "mix float-vector after set reset edit position: ~A" (mix? id)))
	(if (not (= (mix-position id) 11)) (snd-display "mix float-vector position after set reset edit position: ~A" (mix-position id)))
	(if (not (mus-arrays-equal? (channel->float-vector 10 10) fv5))
	    (snd-display "float-vector .5 at 11 after set reset edit: ~A" (channel->float-vector 10 10)))
	
	;; scale
	(scale-channel 2.0)
	(if (not (mix? id))
	    (snd-display "scale locked mix? ~A" (mix? id)))
	(if (not (= (mix-position id) 11))
	    (snd-display "float-vector .5 at 11 scale position: ~A" (mix-position id)))
	(if (not (mus-arrays-equal? (channel->float-vector 10 10) #r(0 1 1 1 1 1 0 0 0 0)))
	    (snd-display "float-vector 1 at 11 scale: ~A" (channel->float-vector 10 10)))
	(scale-channel 0.5)
	(if (not (mix? id))
	    (snd-display "unscale locked mix? ~A" (mix? id)))
	(if (not (= (mix-position id) 11))
	    (snd-display "float-vector .5 at 11 unscale position: ~A" (mix-position id)))
	(if (not (mus-arrays-equal? (channel->float-vector 10 10) fv5))
	    (snd-display "float-vector 1 at 11 unscale: ~A" (channel->float-vector 10 10)))
	(scale-channel -1.0 0 5)
	(if (not (mix? id))
	    (snd-display "scale at 0 locked mix? ~A" (mix? id)))
	(if (not (= (mix-position id) 11))
	    (snd-display "float-vector .5 at 11 scale at 0 position: ~A" (mix-position id)))
	(if (not (mus-arrays-equal? (channel->float-vector 10 10) fv5))
	    (snd-display "float-vector 1 at 11 scale at 0: ~A" (channel->float-vector 10 10)))
	(scale-channel -1.0 22 10)
	(if (not (mix? id))
	    (snd-display "scale at 22 locked mix? ~A" (mix? id)))
	(if (not (= (mix-position id) 11))
	    (snd-display "float-vector .5 at 11 scale at 22 position: ~A" (mix-position id)))
	(if (not (mus-arrays-equal? (channel->float-vector 10 10) fv5))
	    (snd-display "float-vector 1 at 11 scale at 22: ~A" (channel->float-vector 10 10)))
	(scale-channel 2.0 12 2)
					;	    (if (mix? id) (snd-display "scale within mix but exists?: ~A" (mix? id)))
	(if (not (mix? id)) (snd-display "scale within mix but no mix?: ~A" (mix? id)))
	(if (not (mus-arrays-equal? (channel->float-vector 10 10) #r(0 .5 1 1 .5 .5 0 0 0 0)))
	    (snd-display "float-vector .5 at 11 scale at 12: ~A" (channel->float-vector 10 10)))
	
	(set! (edit-position) 1)
	(if (not (mix? id)) (snd-display "mix float-vector after scale reset edit position: ~A" (mix? id)))
	(if (not (= (mix-position id) 11)) (snd-display "mix float-vector position after scale reset edit position: ~A" (mix-position id)))
	(if (not (mus-arrays-equal? (channel->float-vector 10 10) fv5))
	    (snd-display "float-vector .5 at 11 after scale reset edit: ~A" (channel->float-vector 10 10)))
	
	;; envelopes
	(env-channel '(0 0 1 1) 0 8)
	(if (not (mix? id))
	    (snd-display "env locked mix? ~A" (mix? id)))
	(if (not (= (mix-position id) 11))
	    (snd-display "float-vector .5 at 11 env position: ~A" (mix-position id)))
	(if (not (mus-arrays-equal? (channel->float-vector 10 10) fv5))
	    (snd-display "float-vector 1 at 11 env: ~A" (channel->float-vector 10 10)))
	(env-channel '(0 0 1 1) 17 10)
	(if (not (mix? id))
	    (snd-display "env 17 locked mix? ~A" (mix? id)))
	(if (not (= (mix-position id) 11))
	    (snd-display "float-vector .5 at 11 env 17 position: ~A" (mix-position id)))
	(if (not (mus-arrays-equal? (channel->float-vector 10 10) fv5))
	    (snd-display "float-vector 1 at 11 env 17: ~A" (channel->float-vector 10 10)))
	(env-channel '(0 0 1 1))
					;	    (if (mix? id) (snd-display "env over mix but exists?: ~A" (mix? id)))
	(if (not (mix? id)) (snd-display "env over mix but no mix?: ~A" (mix? id)))
	(if (not (mus-arrays-equal? (channel->float-vector 10 10) #r(0.0 0.056 0.061 0.066 0.071 0.076 0.0 0.0 0.0 0.000)))
	    (snd-display "float-vector .5 at 11 over env: ~A" (channel->float-vector 10 10)))
	
	(set! (edit-position) 1)
					;	    (if (not (mix? id)) (snd-display "mix float-vector after env reset edit position: ~A" (mix? id)))
	(if (not (= (mix-position id) 11)) (snd-display "mix float-vector position after env reset edit position: ~A" (mix-position id)))
	(if (not (mus-arrays-equal? (channel->float-vector 10 10) fv5))
	    (snd-display "float-vector .5 at 11 after env reset edit: ~A" (channel->float-vector 10 10)))
	
	(scale-by 0.0)
	(if (not (mix? id)) (snd-display "zero mix but no mix?: ~A" (mix? id)))
	(if (not (mus-arrays-equal? (channel->float-vector 10 10) (make-float-vector 10)))
	    (snd-display "float-vector 1 at 11 scale 0: ~A" (channel->float-vector 10 10)))
	(undo 2)
	
	(let ((ids ()))
	  (do ((i 0 (+ i 1)))
	      ((= i 5))
	    (set! ids (cons (mix-float-vector (make-float-vector 5 .1) (+ i 10)) ids)))
	  (let ((vals (channel->float-vector 8 14)))
	    (if (not (mus-arrays-equal? vals #r(0.0 0.0 0.100 0.200 0.300 0.400 0.500 0.400 0.300 0.200 0.100 0.0 0.0 0.000)))
		(snd-display "pile up mixes: ~A" vals)))
	  (let ((mx (mixes-maxamp ids)))
	    (if (fneq mx .1)
		(snd-display "mixes-maxamp: ~A" mx)))
	  (let ((len (mixes-length ids)))
	    (if (not (= len 10))
		(snd-display "mixes-length: ~A" len)))
	  (sync-all-mixes 21)
	  (for-each (lambda (m) (if (not (= (mix-sync m) 21)) (snd-display "sync-all-mixes ~A: ~A" m (mix-sync m)))) ids)
	  (sync-all-mixes 0)
	  (for-each (lambda (m) (if (not (= (mix-sync m) 0)) (snd-display "re sync-all-mixes ~A: ~A" m (mix-sync m)))) ids)
	  (scale-mixes ids -2.0)
	  (for-each (lambda (m) (if (fneq (mix-amp m) -2.0) (snd-display "scale-mixes ~A: ~A" m (mix-amp m)))) ids)
	  (let ((vals (channel->float-vector 8 14)))
	    (if (not (mus-arrays-equal? vals #r(0.0 0.0 -0.200 -0.400 -0.600 -0.800 -1.000 -0.800 -0.600 -0.400 -0.200 0.0 0.0 0.000)))
		(snd-display "scale piled up mixes: ~A" vals)))
	  (silence-mixes ids)
	  (let ((vals (channel->float-vector 8 14)))
	    (if (not (mus-arrays-equal? vals (make-float-vector 14)))
		(snd-display "silence piled up mixes: ~A" vals)))
	  (undo 2)
	  (let ((vals (channel->float-vector 8 14)))
	    (if (not (mus-arrays-equal? vals #r(0.0 0.0 0.100 0.200 0.300 0.400 0.500 0.400 0.300 0.200 0.100 0.0 0.0 0.000)))
		(snd-display "undo 2 to pile up mixes: ~A" vals)))
	  (play-mixes ids)
	  (set-mixes-tag-y ids 100)
	  (for-each (lambda (m) (if (not (= (mix-tag-y m) 100)) (snd-display "set-mixes-tag-y ~A: ~A" m (mix-tag-y m)))) ids)
	  (set-mixes-tag-y ids 0)
	  (move-mixes ids 10)
	  (let ((vals (channel->float-vector 18 14)))
	    (if (not (mus-arrays-equal? vals #r(0.0 0.0 0.100 0.200 0.300 0.400 0.500 0.400 0.300 0.200 0.100 0.0 0.0 0.000)))
		(snd-display "move piled up mixes: ~A" vals)))
	  (let ((vals (channel->float-vector 8 8)))
	    (if (not (mus-arrays-equal? vals (make-float-vector 8)))
		(snd-display "move piled up mixes original: ~A" vals)))
	  (move-mixes ids -10)
	  (let ((vals (channel->float-vector 8 14)))
	    (if (not (mus-arrays-equal? vals #r(0.0 0.0 0.100 0.200 0.300 0.400 0.500 0.400 0.300 0.200 0.100 0.0 0.0 0.000)))
		(snd-display "move piled up mixes -10: ~A" vals)))
	  (let ((vals (channel->float-vector 23 8)))
	    (if (not (mus-arrays-equal? vals (make-float-vector 8)))
		(snd-display "move piled up mixes -10: ~A" vals)))
	  (for-each (lambda (m) (set! (mix-sync m) 24)) ids)
	  (let ((mxs (syncd-mixes 24)))
	    (if (not (= (length mxs) (length ids)))
		(snd-display "syncd-mixes: ~A ~A" mxs ids))
	    (for-each (lambda (m) (if (not (member m ids)) (snd-display "syncd-mixes: ~A not in ~A" m ids))) mxs))
	  (sync-all-mixes 0)
	  (env-mixes ids '(0 0 1 1 2 0))
	  (let ((vals (channel->float-vector 10 10)))
	    (if (not (mus-arrays-equal? vals #r(0.0 0.045 0.137 0.278 0.460 0.360 0.203 0.087 0.020 0.000)))
		(snd-display "env-mixes: ~A" vals)))
	  (undo 3)
	  (let ((vals (channel->float-vector 8 14)))
	    (if (not (mus-arrays-equal? vals #r(0.0 0.0 0.100 0.200 0.300 0.400 0.500 0.400 0.300 0.200 0.100 0.0 0.0 0.000)))
		(snd-display "undo 3 mixes envd: ~A" vals)))
	  (color-mixes ids (make-color 0 1 0))
	  (scale-tempo ids 2.0)
	  (let ((begs (map mix-position ids)))
	    (if (not (equal? begs '(18 16 14 12 10)))
		(snd-display "scale-tempo by 2: ~A" begs)))
	  (let ((vals (channel->float-vector 10 15)))
	    (if (not (mus-arrays-equal? vals #r(0.100 0.100 0.200 0.200 0.300 0.200 0.300 0.200 0.300 0.200 0.200 0.100 0.100 0.0 0.000)))
		(snd-display "scale-tempo 2 vals: ~A" vals)))
	  (scale-tempo ids 0.5)
	  (let ((begs (map mix-position ids)))
	    (if (not (equal? begs '(14 13 12 11 10)))
		(snd-display "scale-tempo by 0.5: ~A" begs)))
	  (let ((vals (channel->float-vector 10 10)))
	    (if (not (mus-arrays-equal? vals #r(0.100 0.200 0.300 0.400 0.500 0.400 0.300 0.200 0.100 0.000)))
		(snd-display "scale-tempo back 0.5: ~A" vals)))
	  (scale-tempo ids -1.0)
	  (let ((begs (map mix-position ids)))
	    (if (not (equal? begs '(6 7 8 9 10)))
		(snd-display "scale-tempo by -1: ~A" begs)))
	  (let ((vals (channel->float-vector 0 15)))
	    (if (not (mus-arrays-equal? vals #r(0.0 0.0 0.0 0.0 0.0 0.0 0.100 0.200 0.300 0.400 0.500 0.400 0.300 0.200 0.100)))
		(snd-display "scale-tempo -1 vals: ~A" vals)))
	  (undo 3)
	  (set! *sinc-width* 10)
	  (src-mixes ids 0.5)
	  (if (fneq (mix-speed (car ids)) 0.5)
	      (snd-display "src-mixes speed: ~A" (mix-speed (car ids))))
	  (if (not (= (mixes-length ids) 15))
	      (snd-display "src-mixes length: ~A" (mixes-length ids)))
	  (let ((vals (channel->float-vector 10 15)))
	    (if (not (mus-arrays-equal? vals #r(0.100 0.211 0.311 0.408 0.508 0.505 0.495 0.505 0.508 0.460 0.362 0.262 0.152 0.052 0.000)))
		(snd-display "src-mixes 0.5 vals: ~A" vals)))
	  (if (not (mus-arrays-equal? (mix->float-vector (car ids)) (mix->float-vector (cadr ids))))
	      (snd-display "src-mixes vals don't match: ~A ~A" (mix->float-vector (car ids)) (mix->float-vector (cadr ids))))
	  (undo)
	  (transpose-mixes ids -12)
	  (if (fneq (mix-speed (car ids)) 0.5)
	      (snd-display "transpose-mixes speed: ~A" (mix-speed (car ids))))
	  (if (not (= (mixes-length ids) 15))
	      (snd-display "transpose-mixes length: ~A" (mixes-length ids)))
	  (let ((vals (channel->float-vector 10 15)))
	    (if (not (mus-arrays-equal? vals #r(0.100 0.211 0.311 0.408 0.508 0.505 0.495 0.505 0.508 0.460 0.362 0.262 0.152 0.052 0.000)))
		(snd-display "transpose-mixes 0.5 vals: ~A" vals)))
	  (if (not (mus-arrays-equal? (mix->float-vector (car ids)) (mix->float-vector (cadr ids))))
	      (snd-display "transpose-mixes vals don't match: ~A ~A" (mix->float-vector (car ids)) (mix->float-vector (cadr ids))))
	  (revert-sound))
	(close-sound ind))
      
      ;; check locks
      (let* ((ind (new-sound "test.snd" :size 100))
	     (id (mix-float-vector #r(.1 .2 .3) 50)))
	(if (not (mix? id))
	    (snd-display "mix lock 0: ~A ~A" id (mix? id)))
	(ramp-channel 0.0 1.0 0 20)
	(if (not (mix? id))
	    (snd-display "mix lock 5: ~A ~A" id (mix? id)))
	(undo)
	(xramp-channel 0.0 1.0 32.0 0 20)
	(if (not (mix? id))
	    (snd-display "mix lock 6: ~A ~A" id (mix? id)))
	(undo 2)
	(delete-sample 52)
	(if (not (mix? id))
	    (snd-display "mix lock 7: ~A ~A" id (mix? id)))
	(undo)
	(delete-sample 10)
	(if (not (mix? id))
	    (snd-display "mix lock 8: ~A ~A" id (mix? id)))
	(undo)
	(insert-samples 51 2 #r(.1 .2))
	(if (not (mix? id))
	    (snd-display "mix lock 9: ~A ~A" id (mix? id)))
	(undo)
	(insert-samples 1 2 #r(.1 .2))
	(if (not (mix? id))
	    (snd-display "mix lock 10: ~A ~A" id (mix? id)))
	(undo)
	(set! (sample 51) 1.0)
	(if (not (mix? id))
	    (snd-display "mix lock 11: ~A ~A" id (mix? id)))
	(undo)
	(set! (sample 1) 1.0)
	(if (not (mix? id))
	    (snd-display "mix lock 12: ~A ~A" id (mix? id)))
	(undo)
	(xramp-channel 0 1 32 0 40)
	(if (not (mix? id))
	    (snd-display "mix lock 13: ~A ~A" id (mix? id)))
	(xramp-channel 0 1 32 0 40)
	(if (not (mix? id))
	    (snd-display "mix lock 14: ~A ~A" id (mix? id)))
	(close-sound ind))
      
      (define (reader-fill data reader)
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (set! (data i) (read-sample reader))))
	
      (do ((i 0 (+ i 1)))
	  ((= i 2))
	
	(let ((ind (new-sound "test.snd" :size 100))
	      (tag *with-mix-tags*))
	  
	  ;; check various mix ops briefly
	  (map-channel (lambda (y) 1.0))
	  (env-channel '(0 0 1 1))
	  (let ((id (mix-float-vector #r(.1 .2 .3) 50)))
	    (let ((vals (channel->float-vector 48 10)))
	      (if (not (mus-arrays-equal? vals (float-vector 0.485 0.495 0.605 0.715 0.825 0.535 0.545 0.556 0.566 0.576)))
		  (snd-display "mix on env: ~A" vals)))
	    (if (and tag (not (mix? id)))
		(snd-display "mix on env: ~A ~A" id (mix? id))))
	  (if (and tag (not (= ((cadr (edit-tree)) 7) 5)))
	      (snd-display "mix on env edit-tree: ~A" ((cadr (edit-tree)) 7)))
	  (let ((data (make-float-vector 10))
		(reader (make-sampler 57 ind 0 -1)))
	    (reader-fill data reader)
	    (if (not (mus-arrays-equal? data (reverse! (float-vector 0.485 0.495 0.605 0.715 0.825 0.535 0.545 0.556 0.566 0.576))))
		(snd-display "read mix on env reversed: ~A" data)))
	  (undo)
	  
	  (env-channel '(0 0 1 1))
	  (let ((id (mix-float-vector #r(.1 .2 .3) 50)))
	    (let ((vals (channel->float-vector 48 10)))
	      (if (not (mus-arrays-equal? vals #r(0.235 0.245 0.355 0.465 0.576 0.287 0.298 0.309 0.320 0.331)))
		  (snd-display "mix on env 1: ~A" vals)))
	    (if (and tag (not (mix? id)))
		(snd-display "mix on env 1: ~A ~A" id (mix? id))))
	  (if (and tag (not (= ((cadr (edit-tree)) 7) 7)))
	      (snd-display "mix on env1 edit-tree: ~A" ((cadr (edit-tree)) 7)))
	  (let ((data (make-float-vector 10))
		(reader (make-sampler 57 ind 0 -1)))
	    (reader-fill data reader)
	    (if (not (mus-arrays-equal? data (reverse! (float-vector 0.235 0.245 0.355 0.465 0.576 0.287 0.298 0.309 0.320 0.331))))
		(snd-display "read mix on env1 reversed: ~A" data)))
	  (undo)
	  
	  (env-channel '(0 0 1 1))
	  (let ((id (mix-float-vector #r(.1 .2 .3) 50)))
	    (let ((vals (channel->float-vector 48 10)))
	      (if (not (mus-arrays-equal? vals #r(0.114 0.121 0.229 0.337 0.445 0.153 0.162 0.171 0.181 0.191)))
		  (snd-display "mix on env 2: ~A" vals)))
	    (if (and tag (not (mix? id)))
		(snd-display "mix on env 2: ~A ~A" id (mix? id))))
	  (if (and tag (not (= ((cadr (edit-tree)) 7) 11)))
	      (snd-display "mix on env2 edit-tree: ~A" ((cadr (edit-tree)) 7)))
	  (let ((data (make-float-vector 10))
		(reader (make-sampler 57 ind 0 -1)))
	    (reader-fill data reader)
	    (if (not (mus-arrays-equal? data (reverse! (float-vector 0.114 0.121 0.229 0.337 0.445 0.153 0.162 0.171 0.181 0.191))))
		(snd-display "read mix on env2 reversed: ~A" data)))
	  (undo)
	  
	  (env-channel '(0 0 1 1))
	  (let ((id (mix-float-vector #r(.1 .2 .3) 50)))
	    (let ((vals (channel->float-vector 48 10)))
	      (if (not (mus-arrays-equal? vals #r(0.055 0.060 0.165 0.270 0.376 0.082 0.089 0.095 0.102 0.110)))
		  (snd-display "mix on env 3: ~A" vals)))
	    (if (and tag (not (mix? id)))
		(snd-display "mix on env 3: ~A ~A" id (mix? id))))
	  (if (and tag (not (= ((cadr (edit-tree)) 7) 11)))
	      (snd-display "mix on env3 edit-tree: ~A" ((cadr (edit-tree)) 7)))
	  (let ((data (make-float-vector 10))
		(reader (make-sampler 57 ind 0 -1)))
	    (reader-fill data reader)
	    (if (not (mus-arrays-equal? data (reverse! (float-vector 0.055 0.060 0.165 0.270 0.376 0.082 0.089 0.095 0.102 0.110))))
		(snd-display "read mix on env3 reversed: ~A" data)))
	  (undo)
	  
	  (env-channel '(0 0 1 1))
	  (let ((id (mix-float-vector #r(.1 .2 .3) 50)))
	    (let ((vals (channel->float-vector 48 10)))
	      (if (not (mus-arrays-equal? vals #r(0.027 0.030 0.133 0.236 0.340 0.044 0.048 0.053 0.058 0.063)))
		  (snd-display "mix on env 4: ~A" vals)))
	    (if (and tag (not (mix? id)))
		(snd-display "mix on env 4: ~A ~A" id (mix? id))))
	  (if (and tag (not (= ((cadr (edit-tree)) 7) 11)))
	      (snd-display "mix on env4 edit-tree: ~A" ((cadr (edit-tree)) 7)))
	  (let ((data (make-float-vector 10))
		(reader (make-sampler 57 ind 0 -1)))
	    (reader-fill data reader)
	    (if (not (mus-arrays-equal? data (reverse! (float-vector 0.027 0.030 0.133 0.236 0.340 0.044 0.048 0.053 0.058 0.063))))
		(snd-display "read mix on env4 reversed: ~A" data)))
	  (undo)
	  
	  (set! (edit-position ind 0) 1)
	  (xramp-channel 1 0 32.0)
	  (let ((id (mix-float-vector #r(.1 .2 .3) 50)))
	    (let ((vals (channel->float-vector 48 10)))
	      (if (not (mus-arrays-equal? vals #r(0.160 0.153 0.247 0.341 0.435 0.129 0.124 0.118 0.113 0.108)))
		  (snd-display "mix on xramp: ~A" vals)))
	    (if (and tag (not (mix? id)))
		(snd-display "mix on xramp: ~A ~A" id (mix? id))))
	  (if (and tag (not (= ((cadr (edit-tree)) 7) 9)))
	      (snd-display "mix on xramp edit-tree: ~A" ((cadr (edit-tree)) 7)))
	  (let ((data (make-float-vector 10))
		(reader (make-sampler 57 ind 0 -1)))
	    (reader-fill data reader)
	    (if (not (mus-arrays-equal? data (reverse! (float-vector 0.160 0.153 0.247 0.341 0.435 0.129 0.124 0.118 0.113 0.108))))
		(snd-display "read mix on xramp reversed: ~A" data)))
	  
	  (set! (edit-position ind 0) 1)
	  (xramp-channel 1 0 32.0)
	  (xramp-channel 1 0 32.0)
	  (let ((id (mix-float-vector #r(.1 .2 .3) 50)))
	    (let ((vals (channel->float-vector 48 10)))
	      (if (not (mus-arrays-equal? vals #r(0.026 0.024 0.122 0.220 0.318 0.017 0.015 0.014 0.013 0.012)))
		  (snd-display "mix on xramp2: ~A" vals)))
	    (if (and tag (not (mix? id)))
		(snd-display "mix on xramp2: ~A ~A" id (mix? id))))
	  (if (and tag (not (= ((cadr (edit-tree)) 7) 13)))
	      (snd-display "mix on xramp2 edit-tree: ~A" ((cadr (edit-tree)) 7)))
	  (let ((data (make-float-vector 10))
		(reader (make-sampler 57 ind 0 -1)))
	    (reader-fill data reader)
	    (if (not (mus-arrays-equal? data (reverse! (float-vector 0.026 0.024 0.122 0.220 0.318 0.017 0.015 0.014 0.013 0.012))))
		(snd-display "read mix on xramp2 reversed: ~A" data)))
	  
	  (set! (edit-position ind 0) 1)
	  (xramp-channel 1 0 32.0)
	  (xramp-channel 1 0 32.0)
	  (ramp-channel 1 0)
	  (let ((id (mix-float-vector #r(.1 .2 .3) 50)))
	    (let ((vals (channel->float-vector 48 10)))
	      (if (not (mus-arrays-equal? vals #r(0.013 0.012 0.111 0.210 0.309 0.008 0.007 0.006 0.006 0.005)))
		  (snd-display "mix on xramp2_ramp: ~A" vals)))
	    (if (and tag (not (mix? id)))
		(snd-display "mix on xramp2_ramp: ~A ~A" id (mix? id))))
	  (if (and tag (not (= ((cadr (edit-tree)) 7) 15)))
	      (snd-display "mix on xramp2_ramp edit-tree: ~A" ((cadr (edit-tree)) 7)))
	  (let ((data (make-float-vector 10))
		(reader (make-sampler 57 ind 0 -1)))
	    (reader-fill data reader)
	    (if (not (mus-arrays-equal? data (reverse! (float-vector 0.013 0.012 0.111 0.210 0.309 0.008 0.007 0.006 0.006 0.005))))
		(snd-display "read mix on xramp2_ramp reversed: ~A" data)))
	  
	  (set! (edit-position ind 0) 1)
	  (xramp-channel 1 0 32.0)
	  (xramp-channel 1 0 32.0)
	  (ramp-channel 1 0)
	  (ramp-channel 1 0)
	  (let ((id (mix-float-vector #r(.1 .2 .3) 50)))
	    (let ((vals (channel->float-vector 48 10)))
	      (if (not (mus-arrays-equal? vals #r(0.007 0.006 0.105 0.205 0.304 0.004 0.003 0.003 0.002 0.002)))
		  (snd-display "mix on xramp2_ramp2: ~A" vals)))
	    (if (and tag (not (mix? id)))
		(snd-display "mix on xramp2_ramp2: ~A ~A" id (mix? id))))
	  (if (and tag (not (= ((cadr (edit-tree)) 7) 15)))
	      (snd-display "mix on xramp2_ramp2 edit-tree: ~A" ((cadr (edit-tree)) 7)))
	  (let ((data (make-float-vector 10))
		(reader (make-sampler 57 ind 0 -1)))
	    (reader-fill data reader)
	    (if (not (mus-arrays-equal? data (reverse! (float-vector 0.007 0.006 0.105 0.205 0.304 0.004 0.003 0.003 0.002 0.002))))
		(snd-display "read mix on xramp2_ramp2 reversed: ~A" data)))
	  
	  (set! (edit-position ind 0) 1)
	  (xramp-channel 1 0 32.0)
	  (ramp-channel 1 0)
	  (let ((id (mix-float-vector #r(.1 .2 .3) 50)))
	    (let ((vals (channel->float-vector 48 10)))
	      (if (not (mus-arrays-equal? vals #r(0.082 0.077 0.173 0.268 0.364 0.060 0.056 0.053 0.049 0.046)))
		  (snd-display "mix on xramp_ramp: ~A" vals)))
	    (if (and tag (not (mix? id)))
		(snd-display "mix on xramp_ramp: ~A ~A" id (mix? id))))
	  (if (and tag (not (= ((cadr (edit-tree)) 7) 15)))
	      (snd-display "mix on xramp_ramp edit-tree: ~A" ((cadr (edit-tree)) 7)))
	  (let ((data (make-float-vector 10))
		(reader (make-sampler 57 ind 0 -1)))
	    (reader-fill data reader)
	    (if (not (mus-arrays-equal? data (reverse! (float-vector 0.082 0.077 0.173 0.268 0.364 0.060 0.056 0.053 0.049 0.046))))
		(snd-display "read mix on xramp_ramp reversed: ~A" data)))
	  
	  (set! (edit-position ind 0) 1)
	  (xramp-channel 1 0 32.0)
	  (ramp-channel 1 0)
	  (ramp-channel 1 0)
	  (let ((id (mix-float-vector #r(.1 .2 .3) 50)))
	    (let ((vals (channel->float-vector 48 10)))
	      (if (not (mus-arrays-equal? vals #r(0.042 0.039 0.136 0.233 0.330 0.028 0.026 0.023 0.021 0.019)))
		  (snd-display "mix on xramp_ramp2: ~A" vals)))
	    (if (and tag (not (mix? id)))
		(snd-display "mix on xramp_ramp2: ~A ~A" id (mix? id))))
	  (if (and tag (not (= ((cadr (edit-tree)) 7) 15)))
	      (snd-display "mix on xramp_ramp2 edit-tree: ~A" ((cadr (edit-tree)) 7)))
	  (let ((data (make-float-vector 10))
		(reader (make-sampler 57 ind 0 -1)))
	    (reader-fill data reader)
	    (if (not (mus-arrays-equal? data (reverse! (float-vector 0.042 0.039 0.136 0.233 0.330 0.028 0.026 0.023 0.021 0.019))))
		(snd-display "read mix on xramp_ramp2 reversed: ~A" data)))
	  
	  (set! (edit-position ind 0) 1)
	  (xramp-channel 1 0 32.0)
	  (ramp-channel 1 0)
	  (ramp-channel 1 0)
	  (ramp-channel 1 0)
	  (let ((id (mix-float-vector #r(.1 .2 .3) 50)))
	    (let ((vals (channel->float-vector 48 10)))
	      (if (not (mus-arrays-equal? vals #r(0.022 0.020 0.118 0.216 0.314 0.013 0.012 0.010 0.009 0.008)))
		  (snd-display "mix on xramp_ramp3: ~A" vals)))
	    (if (and tag (not (mix? id)))
		(snd-display "mix on xramp_ramp3: ~A ~A" id (mix? id))))
	  (if (and tag (not (= ((cadr (edit-tree)) 7) 15)))
	      (snd-display "mix on xramp_ramp3 edit-tree: ~A" ((cadr (edit-tree)) 7)))
	  (let ((data (make-float-vector 10))
		(reader (make-sampler 57 ind 0 -1)))
	    (reader-fill data reader)
	    (if (not (mus-arrays-equal? data (reverse! (float-vector 0.022 0.020 0.118 0.216 0.314 0.013 0.012 0.010 0.009 0.008))))
		(snd-display "read mix on xramp_ramp3 reversed: ~A" data)))
	  
	  (set! *with-mix-tags* #t)
	  (revert-sound)
	  (mix-float-vector #r(.1 .2 .3) 50)
	  (reverse-sound)
	  (let ((vals (channel->float-vector 45 8)))
	    (if (not (mus-arrays-equal? vals #r(0.0 0.0 0.300 0.200 0.100 0.0 0.0 0.000)))
		(snd-display "reversed mix vals: ~A" vals)))
	  (close-sound ind))
	
	(set! *with-mix-tags* #f))
      (set! *with-mix-tags* #t)
      
      (let ((ind (open-sound "oboe.snd"))
	    (fr (+ 1000 (mus-sound-framples "1a.snd"))))
	(mix-float-vector (make-float-vector 100 .1) 1000)
	(for-each
	 (lambda (mtest)
	   (let ((func (car mtest))
		 (edpos (edit-position ind 0)))
	     (func)
	     (set! (edit-position ind 0) edpos)))
	 (list 
	  (list (lambda () (pad-channel 0 100)) 1100 #f 'pad0)
	  (list (lambda () (pad-channel 0 2000)) 3000 #f 'pad20)
	  (list (lambda () (pad-channel 800 100)) 1100 #f 'pad800)
	  (list (lambda () (pad-channel 850 100)) 1100 #f 'pad800)
	  (list (lambda () (pad-channel 990 100)) 1100 #f 'pad990)
	  (list (lambda () (pad-channel 1010 100)) 1000 #t 'pad1010)
	  (list (lambda () (pad-channel 1050 10)) 1000 #t 'pad1050)
	  (list (lambda () (pad-channel 1110 100)) 1000 #f 'pad1110)
	  (list (lambda () (pad-channel 2000 100)) 1000 #f 'pad2000)
	  
	  (list (lambda () (insert-samples 0 100 (make-float-vector 100 .2))) 1100 #f 'insert0)
	  (list (lambda () (insert-samples 800 100 (make-float-vector 100 .2))) 1100 #f 'insert800)
	  (list (lambda () (insert-samples 990 100 (make-float-vector 100 .2))) 1100 #f 'insert990)
	  (list (lambda () (insert-samples 1010 100 (make-float-vector 100 .2))) 1000 #t 'insert1010)
	  (list (lambda () (insert-samples 1050 10 (make-float-vector 100 .2))) 1000 #t 'insert1050)
	  (list (lambda () (insert-samples 1110 100 (make-float-vector 100 .2))) 1000 #f 'insert1110)
	  (list (lambda () (insert-samples 2000 100 (make-float-vector 100 .2))) 1000 #f 'insert2000)
	  
	  (list (lambda () (insert-sound "1a.snd" 0)) fr #f 'inserts0)
	  (list (lambda () (insert-sound "1a.snd" 800)) fr #f 'inserts800)
	  (list (lambda () (insert-sound "1a.snd" 990)) fr #f 'inserts990)
	  (list (lambda () (insert-sound "1a.snd" 1010)) 1000 #t 'inserts1010)
	  (list (lambda () (insert-sound "1a.snd" 1050)) 1000 #t 'inserts1050)
	  (list (lambda () (insert-sound "1a.snd" 1110)) 1000 #f 'inserts1110)
	  (list (lambda () (insert-sound "1a.snd" 2000)) 1000 #f 'inserts2000)
	  
	  (list (lambda () (delete-samples 0 100)) 900 #f 'delete0)
	  (list (lambda () (delete-samples 0 2000)) 1000 #t 'delete20)
	  (list (lambda () (delete-samples 800 100)) 900 #f 'delete800)
	  (list (lambda () (delete-samples 850 100)) 900 #f 'delete850)
	  (list (lambda () (delete-samples 950 40)) 960 #f 'delete950)
	  (list (lambda () (delete-samples 990 100)) 1000 #t 'delete990)
	  (list (lambda () (delete-samples 1010 100)) 1000 #t 'delete1010)
	  (list (lambda () (delete-samples 1050 10)) 1000 #t 'delete1050)
	  (list (lambda () (delete-samples 1110 100)) 1000 #f 'delete1110)
	  (list (lambda () (delete-samples 2000 100)) 1000 #f 'delete2000)
	  
	  (list (lambda () (set! (samples 0 100) (make-float-vector 100 .2))) 1000 #f 'set0)
	  (list (lambda () (set! (samples 0 2000) (make-float-vector 2000 .2))) 1000 #t 'set0)
	  (list (lambda () (set! (samples 800 100) (make-float-vector 100 .2))) 1000 #f 'set800)
	  (list (lambda () (set! (samples 990 100) (make-float-vector 100 .2))) 1000 #t 'set990)
	  (list (lambda () (set! (samples 1010 100) (make-float-vector 100 .2))) 1000 #t 'set1010)
	  (list (lambda () (set! (samples 1050 10) (make-float-vector 100 .2))) 1000 #t 'set1050)
	  (list (lambda () (set! (samples 1110 100) (make-float-vector 100 .2))) 1000 #f 'set1110)
	  (list (lambda () (set! (samples 2000 100) (make-float-vector 100 .2))) 1000 #f 'set2000)
	  
	  (list (lambda () (scale-channel 2.0 0 100)) 1000 #f 'scale0)
	  (list (lambda () (scale-channel 2.0 0 2000)) 1000 #t 'scale20)
	  (list (lambda () (scale-channel 2.0 800 100)) 1000 #f 'scale800)
	  (list (lambda () (scale-channel 2.0 850 100)) 1000 #f 'scale850)
	  (list (lambda () (scale-channel 2.0 950 40)) 1000 #f 'scale950)
	  (list (lambda () (scale-channel 2.0 990 100)) 1000 #t 'scale990)
	  (list (lambda () (scale-channel 2.0 1010 100)) 1000 #t 'scale1010)
	  (list (lambda () (scale-channel 2.0 1050 10)) 1000 #t 'scale1050)
	  (list (lambda () (scale-channel 2.0 1110 100)) 1000 #f 'scale1110)
	  (list (lambda () (scale-channel 2.0 2000 100)) 1000 #f 'scale2000)
	  
	  (list (lambda () (env-channel '(0 0 1 1) 0 100)) 1000 #f 'env0)
	  (list (lambda () (env-channel '(0 0 1 1) 0 2000)) 1000 #t 'env20)
	  (list (lambda () (env-channel '(0 0 1 1) 800 100)) 1000 #f 'env800)
	  (list (lambda () (env-channel '(0 0 1 1) 850 100)) 1000 #f 'env850)
	  (list (lambda () (env-channel '(0 0 1 1) 950 40)) 1000 #f 'env950)
	  (list (lambda () (env-channel '(0 0 1 1) 990 100)) 1000 #t 'env990)
	  (list (lambda () (env-channel '(0 0 1 1) 1010 100)) 1000 #t 'env1010)
	  (list (lambda () (env-channel '(0 0 1 1) 1050 10)) 1000 #t 'env1050)
	  (list (lambda () (env-channel '(0 0 1 1) 1110 100)) 1000 #f 'env1110)
	  (list (lambda () (env-channel '(0 0 1 1) 2000 100)) 1000 #f 'env2000)
	  
	  ))
	(close-sound ind))
      
      (let ((ind (open-sound "4.aiff"))
	    (selind (open-sound "oboe.snd")))
	(make-selection 100 500 selind 0)
	(mix-selection 500 ind 2)
	(if (not (= (edit-position ind 0) 0)) (snd-display "mix-selection 0->2 0: ~A" (edit-position ind 0)))
	(if (not (= (edit-position ind 1) 0)) (snd-display "mix-selection 0->2 1: ~A" (edit-position ind 1)))
	(if (not (= (edit-position ind 2) 1)) (snd-display "mix-selection 0->2 2: ~A" (edit-position ind 2)))
	(if (not (= (edit-position ind 3) 0)) (snd-display "mix-selection 0->2 3: ~A" (edit-position ind 3)))
	(revert-sound ind)
	(set! (sync ind) 1234)
	(mix-selection 500 ind 1)
	(if (not (= (edit-position ind 0) 0)) (snd-display "mix-selection 1->2 0: ~A" (edit-position ind 0)))
	(if (not (= (edit-position ind 1) 1)) (snd-display "mix-selection 1->2 1: ~A" (edit-position ind 1)))
	(if (not (= (edit-position ind 2) 0)) (snd-display "mix-selection 1->2 2: ~A" (edit-position ind 2)))
	(if (not (= (edit-position ind 3) 0)) (snd-display "mix-selection 1->2 3: ~A" (edit-position ind 3)))
	(revert-sound ind)
	(set! (sync ind) 0)
	(insert-selection 500 ind 2)
	(if (not (= (edit-position ind 0) 0)) (snd-display "insert-selection 0->2 0: ~A" (edit-position ind 0)))
	(if (not (= (edit-position ind 1) 0)) (snd-display "insert-selection 0->2 1: ~A" (edit-position ind 1)))
	(if (not (= (edit-position ind 2) 1)) (snd-display "insert-selection 0->2 2: ~A" (edit-position ind 2)))
	(if (not (= (edit-position ind 3) 0)) (snd-display "insert-selection 0->2 3: ~A" (edit-position ind 3)))
	(revert-sound ind)
	(set! (sync ind) 1234)
	(insert-selection 500 ind 1)
	(if (not (= (edit-position ind 0) 0)) (snd-display "insert-selection 1->2 0: ~A" (edit-position ind 0)))
	(if (not (= (edit-position ind 1) 1)) (snd-display "insert-selection 1->2 1: ~A" (edit-position ind 1)))
	(if (not (= (edit-position ind 2) 0)) (snd-display "insert-selection 1->2 2: ~A" (edit-position ind 2)))
	(if (not (= (edit-position ind 3) 0)) (snd-display "insert-selection 1->2 3: ~A" (edit-position ind 3)))
	(revert-sound ind)
	(set! (sync ind) 0)
	(close-sound ind)
	(close-sound selind))
      
      
      (let ((new-index (new-sound "hiho.wave" 1 22050 mus-ldouble mus-next)))
	(log-mem test-ctr)
	(select-sound new-index)
	(if (find-mix 0 new-index 0) (snd-display "found non-existent mix? ~A" (find-mix 0 new-index 0)))
	(let ((mix-id (car (mix "pistol.snd" 100))))
	  (if (not (mix? mix-id)) (snd-display "~A not mix?" mix-id))
	  (view-mixes-dialog)
	  (let ((snd (car (mix-home mix-id)))
		(pos (mix-position mix-id))
		(len (mix-length mix-id)))
	    (let ((mr (make-mix-sampler mix-id)))
	      (if (not (mix-sampler? mr)) (snd-display "~A not mix-sampler?" mr))
	      (if (region-sampler? mr) (snd-display "mix sampler: region ~A" mr))
					;		(if (sampler? mr) (snd-display "mix sampler: normal ~A" mr))
	      (if (not (= (sampler-position mr) 0)) (snd-display "mix sampler position: ~A" (sampler-position mr)))
	      (if (sampler-at-end? mr) (snd-display "mix sampler at end? ~A" mr))
	      (if (not (equal? (sampler-home mr) mix-id))
		  (snd-display "~A home: ~A" mr (sampler-home mr)))
	      (let ((reader-string (object->string mr #f)))
		(if (not (string=? (substring reader-string 0 16) "#<mix-sampler mi"))
		    (snd-display "mix sampler actually got: [~S]" (substring reader-string 0 16))))
	      (do ((i 0 (+ i 1)))
		  ((= i 99))
		(let ((mx (read-mix-sample mr))
		      (sx (sample (+ 100 i))))
		  (if (fneq mx sx) (snd-display "read-mix-sample: ~A ~A?" mx sx))))
	      (let ((mx (mr))
		    (sx (sample 199)))
		(if (fneq mx sx) (snd-display "mix-sample 100: ~A ~A?" mx sx)))
	      (free-sampler mr))
	    (if (not (= pos 100)) (snd-display "mix-position: ~A?" pos))
	    (if (not (= len 41623)) (snd-display "mix-length: ~A?" len))
	    (if (not (equal? snd new-index)) (snd-display "s mix-home: ~A?" snd)))
	  (let ((chn (cadr (mix-home mix-id))))
	    (if (not (= chn 0)) (snd-display "c mix-home: ~A?" chn)))
	  (let ((amp (mix-amp mix-id)))
	    (if (fneq amp 1.0) (snd-display "mix-amp: ~A?" amp)))
	  (let ((spd (mix-speed mix-id)))
	    (if (fneq spd 1.0) (snd-display "mix-speed: ~A?" spd)))
	  (let ((nam (mix-name mix-id)))
	    (if (not (string=? nam "")) (snd-display "mix-name: ~A" nam)))
	  (catch 'mus-error
	    (lambda () (play mix-id))
	    (lambda args (snd-display "can't play mix: ~A" args)))
	  (catch 'mus-error
	    (lambda () (play mix-id 1000))
	    (lambda args (snd-display "can't play mix from 1000: ~A" args)))
	  (set! (mix-name mix-id) "test-mix")
	  (if (not (string=? (mix-name mix-id) "test-mix"))
	      (snd-display "mix-name set: ~A" (mix-name mix-id)))
	  (let ((id (mix-name->id "test-mix")))
	    (if (not (equal? id mix-id)) (snd-display "mix-name->id: ~A ~A" id mix-id)))
	  (set! (mix-name mix-id) "test-mix-again") ; make sure previous name is freed
	  (if (not (string=? (mix-name mix-id) "test-mix-again"))
	      (snd-display "mix-name set again: ~A" (mix-name mix-id)))
	  (set! (mix-name mix-id) "")
	  (if (not (string=? (mix-name mix-id) "")) (snd-display "set mix-name #f: ~A" (mix-name mix-id)))
	  (set! (mix-position mix-id) 200) 
	  (set! (mix-amp mix-id) 0.5) 
	  (set! (mix-speed mix-id) 2.0) 
	  
	  (set! (mix-amp-env mix-id) '(0.0 0.0 1.0 1.0)) 
	  (set! (mix-tag-y mix-id) 20) 
	  (let ((pos (mix-position mix-id)))
	    (if (not (= pos 200)) (snd-display "set-mix-position: ~A?" pos)))
	  (let ((my (mix-tag-y mix-id)))
	    (if (not (= my 20)) (snd-display "set-mix-tag-y: ~A?" my)))
	  (let ((amp (mix-amp mix-id)))
	    (if (fneq amp 0.5) (snd-display "set-mix-amp: ~A?" amp)))
	  (let ((spd (mix-speed mix-id)))
	    (if (fneq spd 2.0) (snd-display "set-mix-speed: ~A?" spd)))
	  (if (not (equal? (mix-amp-env mix-id) '(0.0 0.0 1.0 1.0))) (snd-display "set-mix-amp-env: ~A?" (mix-amp-env mix-id))))
	
	(mix-float-vector (make-float-vector 3 .1) 100)
	(set! (cursor) 0)
	(let ((nid (find-mix 100)))
	  (if (not (and (mix? nid)
			(= (mix-position nid) 100)))
	      (snd-display "find-mix(100): ~A ~A ~A?" nid (and (mix? nid) (mix-position nid)) (map mix-position (mixes new-index 0)))))
	(let ((nid (find-mix 200)))
	  (if (not (and (mix? nid)
			(= (mix-position nid) 200)))
	      (snd-display "find-mix(200): ~A ~A?" nid (and (mix? nid) (mix-position nid)))))
	(let ((mix-id (car (mix "oboe.snd" 100))))
	  (set! *mix-waveform-height* 40)
	  (set! (mix-property :hiho mix-id) 123)
	  (if (not (= (mix-property :hiho mix-id) 123)) (snd-display "mix-property: ~A" (mix-property :hiho mix-id)))
	  (if (mix-property :not-there mix-id) (snd-display "mix-not-property: ~A" (mix-property :not-there mix-id)))
	  (update-time-graph)
	  (set! *mix-waveform-height* 20))
	(close-sound new-index))
      )
    (dismiss-all-dialogs)
    
    ;; pan-mix tests
    (let ((ind (new-sound "fmv.snd" 1 22050 mus-ldouble mus-next "pan-mix tests")))
      
      (let ((id0 (car (pan-mix "1a.snd" 10000 '(0 0 1 1)))))
	(if (or (fneq (mix-amp id0) 1.0)
		(not (feql (mix-amp-env id0) '(0 1 1 0))))
	    (snd-display "pan-mix 1->1 2: ~A ~A" (mix-amp id0) (mix-amp-env id0)))
	(if (not (= (mix-position id0) 10000)) (snd-display "pan-mix 1->1 pos 2: ~A" (mix-position id0)))
	(revert-sound ind))
      
      (let ((ids (pan-mix "2a.snd" 100 '(0 0 1 1))))
	(let ((id0 (car ids))
	      (id1 (cadr ids)))
	  (if (not (and (mix? id0) (mix? id1)))
	      (snd-display "pan-mix 2->1: ~A ~A" id0 id1))
	  (if (not (= (mix-position id0) (mix-position id1) 100))
	      (snd-display "pan-mix 2->1 pos: ~A ~A" (mix-position id0) (mix-position id1)))
	  (if (or (fneq (mix-amp id0) 1.0) (fneq (mix-amp id1) 1.0))
	      (snd-display "pan-mix 2->1 mix amps 3: ~A ~A" (mix-amp id0) (mix-amp id1)))
	  (if (not (feql (mix-amp-env id0) '(0 1 1 0)))
	      (snd-display "pan-mix 2->1 ramp env: ~A" (mix-amp-env id0)))))
      (revert-sound ind)
      (close-sound ind))
    
    (let ((ind (new-sound "fmv.snd" 2 22050 mus-ldouble mus-next "pan-mix tests")))
      (let ((ids (pan-mix "1a.snd" 100 '(0 0 1 1 2 0))))
	(let ((id0 (car ids))
	      (id1 (cadr ids)))
	  (if (not (and (mix? id0) (mix? id1)))
	      (snd-display "pan-mix 1->2: ~A ~A" id0 id1))
	  (if (not (= (mix-position id0) (mix-position id1) 100))
	      (snd-display "pan-mix 1->2 pos: ~A ~A" (mix-position id0) (mix-position id1)))
	  (if (or (fneq (mix-amp id0) 1.0) (fneq (mix-amp id1) 1.0)) 
	      (snd-display "pan-mix 1->2 amps: ~A ~A" (mix-amp id0) (mix-amp id1)))
	  (if (not (feql (mix-amp-env id0) '(0 1 1 0 2 1)))
	      (snd-display "pan-mix 1->2 env 0: ~A" (mix-amp-env id0)))
	  (if (not (feql (mix-amp-env id1) '(0 0 1 1 2 0)))
	      (snd-display "pan-mix 1->2 env 1: ~A" (mix-amp-env id1)))))
      (revert-sound ind)
      
      (let ((ids (pan-mix "2a.snd" 100 '(0 0 1 1 2 0))))
	(let ((id0 (car ids))
	      (id1 (cadr ids))
	      (id2 (caddr ids))
	      (id3 (cadddr ids)))
	  (if (not (and (mix? id0) (mix? id1) (mix? id2) (mix? id3)))
	      (snd-display "pan-mix 2->2: ~A ~A ~A ~A" id0 id1 id2 id3))
	  (if (not (= (mix-position id0) (mix-position id1) (mix-position id2) (mix-position id3) 100))
	      (snd-display "pan-mix 2->2 pos: ~A ~A ~A ~A" (mix-position id0) (mix-position id1) (mix-position id2) (mix-position id3)))
	  (if (or (fneq (mix-amp id0) 1.0) (fneq (mix-amp id1) 1.0)) 
	      (snd-display "pan-mix 2->2 amps: ~A ~A" (mix-amp id0) (mix-amp id1)))
	  (if (not (feql (mix-amp-env id0) '(0 1 1 0 2 1)))
	      (snd-display "pan-mix 2->2 env 0: ~A" (mix-amp-env id0)))
	  (if (not (feql (mix-amp-env id1) '(0 0 1 1 2 0)))
	      (snd-display "pan-mix 2->2 env 1: ~A" (mix-amp-env id1)))
	  (if (not (feql (mix-amp-env id2) '(0 1 1 0 2 1)))
	      (snd-display "pan-mix 2->2 env 2: ~A" (mix-amp-env id2)))
	  (if (not (feql (mix-amp-env id3) '(0 0 1 1 2 0)))
	      (snd-display "pan-mix 2->2 env 3: ~A" (mix-amp-env id3)))))
      (revert-sound ind)
      (close-sound ind))
    
    (let ((ind (new-sound "test.snd" 2 22050 mus-ldouble mus-next "pan-mix-* tests" 1000)))
      (let ((ids (pan-mix-float-vector (make-float-vector 100 .3) 100 '(0 0 1 1))))
	(let ((id0 (car ids))
	      (id1 (cadr ids)))
	  (if (not (and (mix? id0) (mix? id1)))
	      (snd-display "pan-mix-float-vector 1->2: ~A ~A" id0 id1))
	  (if (not (= (mix-position id0) (mix-position id1) 100))
	      (snd-display "pan-mix-float-vector 1->2 pos: ~A ~A" (mix-position id0) (mix-position id1)))
	  (if (or (fneq (mix-amp id0) 1.0) (fneq (mix-amp id1) 1.0)) 
	      (snd-display "pan-mix-float-vector 1->2 amps: ~A ~A" (mix-amp id0) (mix-amp id1)))
	  (if (not (feql (mix-amp-env id0) '(0 1 1 0)))
	      (snd-display "pan-mix-float-vector 1->2 env 0: ~A" (mix-amp-env id0)))
	  (if (not (feql (mix-amp-env id1) '(0 0 1 1)))
	      (snd-display "pan-mix-float-vector 1->2 env 1: ~A" (mix-amp-env id1)))))
      (revert-sound ind)
      
      (let ((ids (pan-mix-region (make-region 0 50 ind 0) 100 '(0 0 1 1))))
	(let ((id0 (car ids))
	      (id1 (cadr ids)))
	  (if (not (and (mix? id0) (mix? id1)))
	      (snd-display "pan-mix-region 1->2: ~A ~A" id0 id1))
	  (if (not (= (mix-position id0) (mix-position id1) 100))
	      (snd-display "pan-mix-region 1->2 pos: ~A ~A" (mix-position id0) (mix-position id1)))
	  (if (or (fneq (mix-amp id0) 1.0) (fneq (mix-amp id1) 1.0)) 
	      (snd-display "pan-mix-region 1->2 amps: ~A ~A" (mix-amp id0) (mix-amp id1)))
	  (if (not (feql (mix-amp-env id0) '(0 1 1 0)))
	      (snd-display "pan-mix-region 1->2 env 0: ~A" (mix-amp-env id0)))
	  (if (not (feql (mix-amp-env id1) '(0 0 1 1)))
	      (snd-display "pan-mix-region 1->2 env 1: ~A" (mix-amp-env id1)))))
      (revert-sound ind)
      
      (select-all)
      (let ((ids (pan-mix-selection 100 '(0 0 1 1))))
	(let ((id0 (car ids))
	      (id1 (cadr ids)))
	  (if (not (and (mix? id0) (mix? id1)))
	      (snd-display "pan-mix-selection 1->2: ~A ~A" id0 id1))
	  (if (not (= (mix-position id0) (mix-position id1) 100))
	      (snd-display "pan-mix-selection 1->2 pos: ~A ~A" (mix-position id0) (mix-position id1)))
	  (if (or (fneq (mix-amp id0) 1.0) (fneq (mix-amp id1) 1.0)) 
	      (snd-display "pan-mix-selection 1->2 amps: ~A ~A" (mix-amp id0) (mix-amp id1)))
	  (if (not (feql (mix-amp-env id0) '(0 1 1 0)))
	      (snd-display "pan-mix-selection 1->2 env 0: ~A" (mix-amp-env id0)))
	  (if (not (feql (mix-amp-env id1) '(0 0 1 1)))
	      (snd-display "pan-mix-selection 1->2 env 1: ~A" (mix-amp-env id1)))))
      (revert-sound ind)
      (close-sound ind))
    
    ;; copy mix
    (let ((snd (new-sound "test.snd"))
	  (v (make-float-vector 1000)))
      (do ((i 0 (+ i 1)))
	  ((= i 1000))
	(set! (v i) (* i .001)))
      (let* ((mx (mix-float-vector v 0 snd 0))
	     (mx-copy (copy mx)))
	(if (not (= (length mx) (length mx-copy)))
	    (snd-display "copy mix lengths: ~A ~A" (length mx) (length mx-copy)))
	(if (not (= (mix-position mx) (mix-position mx-copy)))
	    (snd-display "copy mix positions: ~A ~A" (mix-position mx) (mix-position mx-copy)))
	(set! (mix-position mx-copy) 2000)
	(let ((rd1 (make-sampler 0))
	      (rd2 (make-sampler 2000))
	      (happy #t))
	  (do ((i 0 (+ i 1)))
	      ((or (not happy)
		   (= i 1000)))
	    (let ((x1 (rd1))
		  (x2 (rd2)))
	      (when (or (fneq x1 x2) (fneq x1 (* i .001)))
		(set! happy #f)
		(snd-display "copy mix at ~A: ~A ~A ~A" i x1 x2 (* i .001)))))))
      (close-sound snd))

    (let ((ind (new-sound "mix-test.snd" :channels 4 :size 100)))
      (let ((mx (mix "2a.snd" 0 #t)))
	(if (not (and (= (length mx) 2)
		      (= (length (car (mixes))) 4)))
	    (snd-display "mixes 4+2: ~A ~A" mx (mixes))))
      (close-sound ind))
    
    (when all-args
      ;; waltz
      (let ((frequency->tag-y 
	     (lambda (freq lo octs) ; tag height dependent on freq
	       (round (* 100 (- 1.0 (/ (log (/ freq lo)) (* (log 2.0) octs))))))))
	
	(let ((oldie (find-sound "test.snd")))
	  (if (sound? oldie)
	      (close-sound oldie)))
	
	(let ((index (new-sound "test.snd" :channels 1 :size 485100))) ;(* 22050 22)
	  (as-one-edit
	   (let ((violin 
		  (let ((violin-sync 1)
			(violin-color (make-color 0 0 1))) ; blue
		    (lambda (beg dur freq)
		      (let ((id (car (mix (with-temp-sound ()        ; write instrument output to temp sound
					    (fm-violin 0 dur (->frequency freq #t) 0.2)) ; our favorite FM instrument
					  (->sample beg) 0 index 0   ; mix start, file in-chan, sound, channel
					  #t #t))))                  ; mix with tag and auto-delete
			(if (symbol? freq)
			    (set! (mix-name id) (symbol->string freq)))
			(set! (mix-sync id) violin-sync)
			(set! (mix-color id) violin-color)
			(set! (mix-tag-y id) (frequency->tag-y (->frequency freq #t) (->frequency 'c2) 3))))))
		 
		 (cello 
		  (let ((cello-sync 2)
			(cello-color (make-color 0 1 0))) ; green
		    (lambda (beg dur freq)
		      (let ((id (car (mix (with-temp-sound ()
					    (fm-violin 0 dur (->frequency freq #t) 0.2 :fm-index 1.5))
					  (->sample beg) 0 index 0
					  #t #t))))
			(if (symbol? freq)
			    (set! (mix-name id) (symbol->string freq)))
			(set! (mix-sync id) cello-sync)
			(set! (mix-color id) cello-color)
			(set! (mix-tag-y id) (frequency->tag-y (->frequency freq #t) (->frequency 'c2) 3)))))))
	     
	     (lambda ()
	       (violin 0 1 'e4)  (violin 1 1.5 'g4)  (violin 2.5 .5 'g3)
	       (cello  0 1 'c3)  (cello  1 1.5 'e3)  (cello  2.5 .5 'g2)
	       
	       (violin 3 3 'f4)
	       (cello  3 3 'd3)
	       
	       (violin 6 1 'e4)   (violin 7 1 'g3)   (violin 8 1 'e4)
	       (cello  6 1 'c3)   (cello  7 1 'g2)   (cello  8 1 'c3)
	       
	       (violin 9 3 'd4)
	       (cello  9 3 'b2)
	       
	       (violin 12 1 'f4)  (violin 13 1.5 'a4)  (violin 14.5 .5 'g3)
	       (cello  12 1 'd3)  (cello  13 1.5 'f3)  (cello  14.5 .5 'g2)
	       
	       (violin 15 3 'g4)
	       (cello  15 3 'e3)
	       
	       (violin 18 1 'f4)  (violin 19 1 'g3)  (violin 20 1 'f4)
	       (cello  18 1 'd3)  (cello  19 1 'g2)  (cello  20 1 'd3)
	       
	       (violin 21 3 'e4)
	       (cello  21 3 'c3))))
	  
	  (close-sound index)))
      
      ;; Columbia, Gem of the Ocean
      (let ((seg (lambda (data)			; SEG functions expected data in (y x) pairs.
		   (do ((unseg ())
			(len (length data))
			(i 0 (+ i 2)))
		       ((>= i len)
			(reverse unseg))
		     (let ((x (data (+ i 1)))
			   (y (data i)))
		       (set! unseg (cons y (cons x unseg))))))))
	
	(let ((oldie (find-sound "test.snd")))
	  (if (sound? oldie)
	      (close-sound oldie)))
	
	(let* ((ind (new-sound "test.snd" :channels 1))
	       (mix-fmsimp (let ((soprano ())
				 (alto ())
				 (tenor ())
				 (bass ())
				 (f6 (seg '(1 1  .5 10  .75 50  .4 75  .6 90  0 100)))
				 (f7 (seg '(0 1  .5 10  .25 25  .75 50  .5 75  1 90  0 100))))
			     (lambda (beg dur freq amp rat1 indx1 rat2 indx2)
			       (let ((id (let ((snd1 (with-temp-sound () 
								      (fm-violin 0 dur (if (> freq (/ *clm-srate* 8)) (/ freq 8) freq)
										 (* amp .175)
										 :fm1-rat (* 1.002 rat1)
										 :fm1-index (* .5 rat1 indx1 (hz->radians freq))
										 :fm1-env f6
										 :fm2-rat (* 1.003 rat2)
										 :fm2-index (* .5 indx2 rat2 (hz->radians freq))
										 :fm2-env f7
										 :fm3-index 0.0
										 :reverb-amount 1.0
										 :amp-env (seg '(0 0 1 25 1 75 0 100))))))
					   (car (mix snd1 (->sample beg) 0 ind 0 #t #t)))))  ; with tag and auto-delete
				 (set! (mix-name id) (number->string (floor freq)))
				 (cond ((> freq 700) (set! soprano (cons id soprano)))
				       ((> freq 500) (set! alto (cons id alto)))
				       ((> freq 300) (set! tenor (cons id tenor)))
				       (else         (set! bass (cons id bass)))))))))
	  (as-one-edit
	   (lambda ()
	     (mix-fmsimp   .000  2.488  659.255   .500  5.000  1.260  2.000   .501)
	     (mix-fmsimp   .750  1.988  654.084   .167  3.000  1.260  1.000   .710)
	     (mix-fmsimp  1.000  2.738  880.0   .500  5.000  1.260  1.000   .140)
	     (mix-fmsimp  2.000  2.488  880.0   .500  1.000  1.671  2.000   .745)
	     (mix-fmsimp  2.750  1.969  871.429   .495  5.000  1.312  1.000   .447)
	     (mix-fmsimp  3.000  2.750  493.883   .100  1.000  1.260  2.000  1.069)
	     (mix-fmsimp  4.000  2.488  654.568   .500  3.000  1.671  5.000   .793)
	     (mix-fmsimp  4.750  1.988  590.042   .241  2.000  1.671  5.000  1.046)
	     (mix-fmsimp  5.000  2.238  551.574   .500  4.000  1.671  1.000   .073)
	     (mix-fmsimp  5.500  2.238  664.174   .504  3.000  1.671  4.000   .791)
	     (mix-fmsimp  6.000  1.988  659.255   .400  2.000  1.671  2.000   .955)
	     (mix-fmsimp  6.250  2.738  880.0   .400  5.000  1.260  5.000   .645)
	     (mix-fmsimp  7.250  2.505  885.724   .336  5.000  1.260  4.000   .302)
	     (mix-fmsimp  8.000  1.988  880.0   .500  3.000  1.260  2.000   .672)
	     (mix-fmsimp  8.250  2.738  493.883   .100  4.000  1.671  1.000   .013)
	     (mix-fmsimp  9.250  2.488  659.255   .250  3.000  1.671  3.000  1.167)
	     (mix-fmsimp  10.0  1.988  587.330   .240  2.000  1.314  5.000   .423)
	     (mix-fmsimp  10.250  2.238  554.365   .500  1.000  1.671  2.000   .078)
	     (mix-fmsimp  10.750  2.238  659.255   .500  1.000  1.260  5.000   .797)
	     (mix-fmsimp  11.250  1.988  651.332   .400  5.000  1.671  1.000   .883)
	     (mix-fmsimp  11.500  1.926  878.372   .200  1.000  1.434  4.000   .322)
	     (mix-fmsimp  11.688  2.497  880.0   .335  2.000  1.671  4.000   .879)
	     (mix-fmsimp  12.438  2.006  887.764   .288  1.000  1.671  4.000   .652)
	     (mix-fmsimp  12.688  2.738  493.883   .100  1.000  1.671  4.000   .521)
	     (mix-fmsimp  13.688  2.488  659.255   .250  2.000  1.671  2.000  1.247)
	     (mix-fmsimp  14.438  1.988  587.330   .240  1.000  1.260  2.000  1.182)
	     (mix-fmsimp  14.688  2.238  547.848   .494  4.000  1.671  2.000   .432)
	     (mix-fmsimp  15.188  3.238  867.651   .500  4.000  1.671  1.000   .571)
	     (mix-fmsimp  16.688  2.238  659.255   .400  4.000  1.671  4.000   .477)
	     (mix-fmsimp  17.188  1.988  652.468   .495  3.000  1.671  2.000   .438)
	     (mix-fmsimp  17.438  1.926  880.0   .200  2.000  1.671  4.000  1.107)
	     (mix-fmsimp  17.625  2.523  880.0   .500  5.000  1.671  1.000   .830)
	     (mix-fmsimp  18.375  1.988  880.0   .400  4.000  1.671  3.000   .186)
	     (mix-fmsimp  18.625  2.738  493.883   .100  1.000  1.260  5.000   .407)
	     (mix-fmsimp  19.625  2.488  657.231   .166  5.000  1.260  2.000   .389)
	     (mix-fmsimp  20.375  1.976  587.330   .238  2.000  1.671  1.000   .712)
	     (mix-fmsimp  20.625  2.238  554.365   .500  3.000  1.260  5.000   .171)
	     (mix-fmsimp  21.125  3.238  880.0   .500  4.000  1.671  1.000   .507)
	     (mix-fmsimp  22.625  2.238  650.838   .395  3.000  1.671  4.000   .160)
	     (mix-fmsimp  23.125  1.978  659.255   .497  1.000  1.671  1.000   .867)
	     (mix-fmsimp  23.375  1.926  885.243   .333  2.000  1.412  4.000   .811)
	     (mix-fmsimp  23.563  2.488  880.0   .500  4.000  1.671  3.000   .439)
	     (mix-fmsimp  24.313  1.995  882.799   .401  1.000  1.671  4.000  1.089)
	     (mix-fmsimp  24.563  2.730  246.942   .100  2.000  1.671  1.000   .092)
	     (mix-fmsimp  25.563  2.488  329.628   .167  2.000  1.671  2.000  1.149)
	     (mix-fmsimp  26.313  2.007  587.330   .242  3.000  1.671  3.000   .472)
	     (mix-fmsimp  26.563  2.238  548.468   .495  2.000  1.671  1.000   .259)
	     (mix-fmsimp  27.063  3.238  439.221   .500  3.000  1.260  3.000  1.014)
	     (mix-fmsimp  28.563  2.493  441.603   .401  3.000  1.671  5.000   .056)
	     (mix-fmsimp  29.313  2.220  659.255   .500  3.000  1.260  3.000  1.108)
	     (mix-fmsimp  29.813  1.960  329.628   .500  1.000  1.671  1.000   .944)
	     (mix-fmsimp  30.063  1.894  440.0   .333  1.000  1.260  4.000   .602)
	     (mix-fmsimp  30.250  2.453  443.160   .400  1.000  1.260  3.000   .750)
	     (mix-fmsimp  31.000  1.938  441.168   .333  5.000  1.671  3.000   .522)
	     (mix-fmsimp  31.250  2.684  246.942   .100  5.000  1.654  1.000  1.020)
	     (mix-fmsimp  32.250  2.415  325.263   .167  4.000  1.671  3.000   .014)
	     (mix-fmsimp  33.000  1.901  587.330   .240  4.000  1.671  5.000  1.106)
	     (mix-fmsimp  33.250  2.149  554.936   .501  2.000  1.260  2.000  1.159)
	     (mix-fmsimp  33.750  3.137  440.0   .500  2.000  1.671  1.000   .647)
	     (mix-fmsimp  35.250  2.359  440.0   .400  5.000  1.671  4.000  1.149)
	     (mix-fmsimp  36.000  2.101  661.109   .501  4.000  1.377  2.000  1.121)
	     (mix-fmsimp  36.500  1.836  329.628   .500  2.000  1.671  4.000  1.459)
	     (mix-fmsimp  36.750  1.768  440.0   .250  5.000  1.671  5.000   .601)
	     (mix-fmsimp  36.938  2.327  442.815   .400  2.000  1.671  3.000   .354)
	     (mix-fmsimp  37.688  1.813  440.0   .400  4.000  1.671  2.000   .205)
	     (mix-fmsimp  37.938  2.559  246.712   .100  4.000  1.671  2.000  1.044)
	     (mix-fmsimp  38.938  2.290  329.628   .167  1.000  1.260  2.000  1.316)
	     (mix-fmsimp  39.688  1.781  587.330   .240  1.000  1.671  3.000   .524)
	     (mix-fmsimp  39.938  2.021  554.365   .500  1.000  1.671  2.000   .522)
	     (mix-fmsimp  40.438  2.998  438.022   .498  3.000  1.260  4.000   .264)
	     (mix-fmsimp  41.938  2.253  443.810   .403  1.000  1.671  4.000  1.157)
	     (mix-fmsimp  42.688  1.720  414.691   .319  4.000  1.671  1.000   .612)
	     (mix-fmsimp  42.938  1.965  659.255   .500  2.000  1.671  2.000   .559)
	     (mix-fmsimp  43.438  1.690  329.628   .496  5.000  1.671  2.000  1.457)
	     (mix-fmsimp  43.688  1.630  440.0   .249  2.000  1.671  5.000   .505)
	     (mix-fmsimp  43.875  2.197  440.0   .400  3.000  1.260  3.000   .843)
	     (mix-fmsimp  44.625  1.678  440.0   .332  2.000  1.671  5.000  1.165)
	     (mix-fmsimp  44.875  2.405  246.942   .100  4.000  1.671  3.000   .105)
	     (mix-fmsimp  45.875  2.160  332.580   .168  1.000  1.260  5.000  1.107)
	     (mix-fmsimp  46.625  1.646  583.584   .238  4.000  1.673  5.000   .201)
	     (mix-fmsimp  46.875  1.891  553.184   .492  1.000  1.304  2.000  1.230)
	     (mix-fmsimp  47.375  2.882  438.012   .489  5.000  1.737  4.000   .024)
	     (mix-fmsimp  48.875  2.104  440.0   .487  2.000  1.770  2.000   .308)
	     (mix-fmsimp  49.625  1.590  414.068   .319  4.000  1.866  3.000   .415)
	     (mix-fmsimp  49.875  1.835  659.255   .467  1.000  1.914  3.000   .477)
	     (mix-fmsimp  50.375  1.592  333.127   .470  5.000  1.930  2.000   .230)
	     (mix-fmsimp  50.625  1.509  440.0   .250  5.000  1.963  1.000   .829)
	     (mix-fmsimp  50.813  2.068  440.0   .400  3.000  1.979  1.000  1.450)
	     (mix-fmsimp  51.563  1.536  434.964   .330  4.000  1.991  2.000   .308)
	     (mix-fmsimp  51.813  2.299  246.942   .088  4.000  1.581  5.000  1.149)
	     (mix-fmsimp  52.813  2.030  329.628   .167  5.000  1.916  5.000  1.234)
	     (mix-fmsimp  53.563  1.524  590.360   .241  4.000  2.119  4.000   .374)
	     (mix-fmsimp  53.813  1.761  554.365   .433  3.000  2.168  3.000   .269)
	     (mix-fmsimp  54.313  2.720  434.908   .425  3.000  2.184  1.000  1.209)
	     (mix-fmsimp  55.813  1.966  440.0   .426  4.000  2.196  2.000  1.493)
	     (mix-fmsimp  56.563  1.446  415.305   .316  4.000  2.312  1.000   .753)
	     (mix-fmsimp  56.813  2.205  369.994   .406  2.000  2.361  1.000   .292)
	     (mix-fmsimp  57.813  1.668  329.628   .400  4.000  2.377  1.000   .179)
	     (mix-fmsimp  58.313  1.422  329.628   .394  4.000  2.441  3.000  1.117)
	     (mix-fmsimp  58.563  1.360  435.856   .250  1.000  1.960  5.000   .811)
	     (mix-fmsimp  58.750  1.919  440.0   .389  2.000  2.489  3.000   .242)
	     (mix-fmsimp  59.500  1.405  439.947   .387  3.000  2.501  4.000  1.265)
	     (mix-fmsimp  59.750  2.173  249.594   .073  2.000  2.550  2.000   .351)
	     (mix-fmsimp  60.750  1.881  329.628   .200  2.000  2.566  2.000  1.431)
	     (mix-fmsimp  61.500  1.367  293.665   .240  1.000  2.096  1.000  1.378)
	     (mix-fmsimp  61.750  1.613  554.365   .363  1.000  2.678  1.000   .201)
	     (mix-fmsimp  62.250  2.603  433.901   .356  2.000  2.694  5.000   .950)
	     (mix-fmsimp  63.750  1.809  440.0   .354  4.000  2.727  4.000   .459)
	     (mix-fmsimp  64.500  1.314  415.305   .320  3.000  2.265  1.000  1.059)
	     (mix-fmsimp  64.750  2.057  374.139   .341  2.000  2.307  3.000   .054)
	     (mix-fmsimp  65.750  1.538  329.628   .335  4.000  2.887  3.000  1.281)
	     (mix-fmsimp  66.250  1.278  329.628   .326  3.000  2.952  4.000   .363)
	     (mix-fmsimp  66.500  1.211  440.0   .322  5.000  2.405  4.000   .361)
	     (mix-fmsimp  66.688  1.769  440.0   .319  4.000  2.419  3.000   .190)
	     (mix-fmsimp  67.438  1.256  437.237   .316  1.000  2.430  2.000  1.121)
	     (mix-fmsimp  67.688  1.979  246.942   .056  2.000  2.472  4.000  1.172)
	     (mix-fmsimp  68.688  1.736  330.174   .250  4.000  2.486  3.000   .893)
	     (mix-fmsimp  69.438  1.213  292.204   .238  5.000  2.732  1.000  1.265)
	     (mix-fmsimp  69.688  1.462  553.724   .294  3.000  3.189  3.000   .427)
	     (mix-fmsimp  70.188  2.455  440.0   .292  2.000  2.598  5.000   .489)
	     (mix-fmsimp  71.688  1.654  440.0   .284  5.000  3.237  2.000  1.299)
	     (mix-fmsimp  72.438  1.175  415.305   .277  3.000  2.995  4.000   .916)
	     (mix-fmsimp  72.688  1.933  369.994   .271  1.000  3.382  1.000   .886)
	     (mix-fmsimp  73.688  1.639  440.0   .046  4.000  3.398  5.000   .993)
	     (mix-fmsimp  74.438  15.942  329.628   .257  1.000  2.822  1.000   .402)
	     (mix-fmsimp  74.938  (- 45.394 20)  329.628   .249  1.000  2.864  2.000  1.093)
	     (mix-fmsimp  75.438  (- 45.063 20)  440.0   .246  3.000  3.543  2.000   .978)
	     (mix-fmsimp  75.625  (- 45.335 20)  444.508   .244  2.000  2.920  4.000   .563)
	     (mix-fmsimp  76.375  (- 44.125 20)  445.106   .240  3.000  2.931  2.000   .768)
	     (mix-fmsimp  76.625  (- 43.875 20)  248.294   .038  2.000  2.973  2.000   .155)
	     (mix-fmsimp  77.625  (- 43.455 20)  334.084   .234  3.000  2.987  4.000   .047)
	     (mix-fmsimp  78.375  (- 41.938 20)  292.359   .222  3.000  3.521  5.000  1.140)
	     (mix-fmsimp  78.625  (- 41.605 20)  554.365   .215  2.000  3.085  4.000   .595)
	     (mix-fmsimp  79.125  (- 41.769 20)  440.0   .214  3.000  3.780  3.000   .541)
	     (mix-fmsimp  80.625  (- 39.875 20)  440.0   .200  3.000  3.812  2.000  1.111)
	     (mix-fmsimp  91.130  (- 29.335 20)  415.305   .111  3.000  3.759  2.000   .490)
	     
	     (close-sound ind))))))
    ))


;;; ---------------- test 10: marks ----------------

(require snd-marks.scm)

(if (provided? 'snd-motif)
    (define mark-sync-color (*motif* 'mark-sync-color)))

(define snd_test_10
  (let ((data-max (lambda (beg end)
		    (let ((maxval 0.0))
		      (apply for-each 
			     (lambda (snd chn)
			       (set! maxval (max maxval (float-vector-peak (samples beg (- end beg) snd chn)))))
			     (all-chans))
		      maxval)))
	
	(data-max2 (lambda (snd)
		     (do ((maxval 0.0)
			  (i 0 (+ i 1)))
			 ((= i (chans snd)) maxval)
		       (set! maxval (max maxval (float-vector-peak (samples 0 9 snd i)))))))
	
	(data-max1 (lambda (snd chn)
		     (float-vector-peak (samples 0 9 snd chn))))
	
	;; from marks.scm (commented out)
	
	(eval-header (lambda (sndf)
		       (and (string? (comment sndf))
			    (catch #t
			      (lambda ()
				(eval-string (comment sndf)))
			      (lambda args #f)))))
	
	(marks->string (lambda (sndf)
			 (let ((str (format #f "(let ((m #f))~%"))
			       (chan 0))
			   (for-each
			    (lambda (chan-marks)
			      (for-each 
			       (lambda (m)
				 (set! str 
				       (string-append str 
						      (format #f
							      "  (set! m (add-mark ~A #f ~D ~A ~D))~%" 
							      (mark-sample m)
							      chan
							      (and (> (length (mark-name m)) 0)
								   (object->string (mark-name m)))
							      (mark-sync m))))
				 (if (pair? (mark-properties m))
				     (set! str
					   (string-append str 
							  (format #f
								  "  (set! (mark-properties m) '~A)~%"
								  (mark-properties m))))))
			       chan-marks)
			      (set! chan (+ 1 chan)))
			    (marks sndf))
			   (string-append str (format #f "  m)~%"))))))
    
    ;; snd_test_10
    (lambda ()
      (do ((test-ctr 0 (+ 1 test-ctr)))
	  ((= test-ctr tests))
	(log-mem test-ctr)
	
	(let ((ind0 (view-sound "oboe.snd"))
	      (ind1 (view-sound "pistol.snd")))
	  (let ((v0 (make-float-vector 100 .1))
		(vc (make-vector 10)))
	    (set! (vc 0) (mix-float-vector v0 0 ind0))
	    (set! (vc 1) (mix-float-vector v0 1000 ind0))
	    (set! (vc 2) (mix-float-vector v0 2000 ind0))
	    (set! (vc 3) (mix-float-vector v0 3000 ind0))
	    (set! (vc 4) (mix-float-vector v0 4000 ind0))
	    (set! (vc 5) (mix-float-vector v0 0 ind1))
	    (set! (vc 6) (mix-float-vector v0 1000 ind1))
	    (set! (vc 7) (mix-float-vector v0 2000 ind1))
	    (set! (vc 8) (mix-float-vector v0 3000 ind1))
	    (set! (vc 9) (mix-float-vector v0 4000 ind1)))
	  (close-sound ind0)
	  (close-sound ind1))
	
	(let ((ind0 (new-sound "fmv.snd" 1 22050 mus-bshort mus-aifc "this is a comment")))
	  (insert-samples 0 10 (make-vector 10 1.0) ind0)
	  (time (env-sound '(0 0 1 1) 0 10 1.0 ind0))
	  (do ((i 0 (+ i 1))) ((= i 10)) (if (fneq (sample i) (* i .1111)) (snd-display "1 env-sound[~D]: ~A?" i (sample i))))
	  (undo) 
	  (env-sound (make-env '(0 0 1 1) :length 10) 0 10 1.0 ind0) 
	  (do ((i 0 (+ i 1))) ((= i 10)) (if (fneq (sample i) (* i .1111)) (snd-display "2 env-sound[~D]: ~A?" i (sample i))))
	  (undo) 
	  (env-sound '(0 0 .5 1 1 1) 0 10 0.0 ind0) 
	  (if (or (fneq (sample 3) 0.0) (fneq (sample 8) 1.0) )
	      (snd-display "env-sound stepped: ~A ~A?" (sample 3) (sample 8)))
	  (undo) 
	  (env-sound '(0 0 1 1) 0 10 32.0 ind0) 
	  (if (or (fneq (sample 3) 0.070) (fneq (sample 8) 0.67) )
	      (snd-display "env-sound exp: ~A ~A?" (sample 3) (sample 8)))
	  (undo) 
	  (env-sound (make-env '(0 0 1 1) :base 32.0 :length 10) 0 10 32.0 ind0) 
	  (if (or (fneq (sample 3) 0.070) (fneq (sample 8) 0.67) )
	      (snd-display "env-sound exp: ~A ~A?" (sample 3) (sample 8)))
	  (undo)
	  (env-sound '(0 2))
	  (do ((i 0 (+ i 1))) ((= i 10)) (if (fneq (sample i) 2.0) (snd-display "3 env-sound[~D]: ~A?" i (sample i))))
	  (undo)
	  (env-sound '(0 2) 2 4 1.0 ind0)
	  (if (or (fneq (sample 1) 1.0) (fneq (sample 2) 2.0) (fneq (sample 5) 2.0) (fneq (sample 8) 1.0))
	      (snd-display "3 env-sound exp: ~A ~A ~A ~A?" (sample 1) (sample 2) (sample 5) (sample 8)))
	  (undo) 
	  (do ((i 1 (+ i 1))) ((= i 10)) (set! (sample i) 0.0))
	  (filter-sound '(0 1 1 0) 4)
	  (if (or (fneq (sample 1) 0.3678) (fneq (sample 2) .3678) (fneq (sample 3) .132) (fneq (sample 4) 0.0))
	      (snd-display "filter-sound env: ~A?" (samples 0 8)))
	  (undo)
	  (filter-sound '(0 1 1 0) 1024)
	  (undo)
	  (filter-sound (make-fir-filter 6 #r(.1 .2 .3 .3 .2 .1)))
	  (undo)
	  (filter-sound (make-delay 120))
	  (undo)
	  (filter-sound (make-formant 1200 .99))
	  (undo)
	  (let ((vc0 (make-float-vector 4)))
	    (set! (vc0 0) .125) (set! (vc0 1) .25) (set! (vc0 2) .25) (set! (vc0 3) .125) 
	    (filter-sound vc0 4) 
	    (if (or (fneq (sample 0) 0.125) (fneq (sample 1) .25) (fneq (sample 2) .25) (fneq (sample 5) 0.0))
		(snd-display "filter-sound direct: ~A?" (samples 0 8)))
	    (revert-sound))
	  (close-sound ind0))
	
	(let ((ind0 (new-sound "fmv.snd" 2 22050 mus-bshort mus-aifc "this is a comment")))
	  (let ((v0 (make-vector 10 1.0))
		(ind1 (new-sound "fmv1.snd" 1 22050 mus-bshort mus-aifc "this is a comment")))
	    (set! (sync ind0) 123)
	    (set! (sync ind1) 123)
	    (insert-samples 0 10 v0 ind0 0)
	    (insert-samples 0 10 v0 ind0 1)
	    (insert-samples 0 10 v0 ind1 0)
	    (env-sound '(0 0 1 1) 0 10 1.0 ind0)
	    (do ((i 0 (+ i 1))) 
		((= i 10)) 
	      (if (fneq (sample i ind0 0) (* i .1111)) (snd-display "ind0:0 1 env-sound[~D]: ~A?" i (sample i ind0 0)))
	      (if (fneq (sample i ind0 1) (* i .1111)) (snd-display "ind0:1 1 env-sound[~D]: ~A?" i (sample i ind0 1)))
	      (if (fneq (sample i ind1 0) (* i .1111)) (snd-display "ind1:0 1 env-sound[~D]: ~A?" i (sample i ind1 0))))
	    (undo) 
	    (env-sound (make-env '(0 0 1 1) :length 10) 0 10 1.0 ind0) 
	    (do ((i 0 (+ i 1))) 
		((= i 10)) 
	      (if (fneq (sample i ind0 0) (* i .1111)) (snd-display "ind0:0 2 env-sound[~D]: ~A?" i (sample i ind0 0)))
	      (if (fneq (sample i ind0 1) (* i .1111)) (snd-display "ind0:1 2 env-sound[~D]: ~A?" i (sample i ind0 1)))
	      (if (fneq (sample i ind1 0) (* i .1111)) (snd-display "ind1:0 2 env-sound[~D]: ~A?" i (sample i ind1 0))))
	    (undo) 
	    (env-sound '(0 0 .5 1 1 1) 0 10 0.0 ind0) 
	    (if (or (fneq (sample 3 ind0 0) 0.0) (fneq (sample 8 ind0 0) 1.0) ) 
		(snd-display "ind0:0 env-sound stepped: ~A ~A?" (sample 3 ind0 0) (sample 8 ind0 0)))
	    (if (or (fneq (sample 3 ind0 1) 0.0) (fneq (sample 8 ind0 1) 1.0) ) 
		(snd-display "ind0:1 env-sound stepped: ~A ~A?" (sample 3 ind0 1) (sample 8 ind0 1)))
	    (if (or (fneq (sample 3 ind1 0) 0.0) (fneq (sample 8 ind1 0) 1.0) ) 
		(snd-display "ind1:0 env-sound stepped: ~A ~A?" (sample 3 ind1 0) (sample 8 ind1 0)))
	    (undo)
	    (revert-sound ind0)
	    (revert-sound ind1)
	    (insert-samples 0 10 v0 ind0 0)
	    (insert-samples 0 10 v0 ind0 1)
	    (insert-samples 0 10 v0 ind1 0)
	    (filter-sound (make-one-zero :a0 0.5 :a1 0.0) 0 ind0)
	    (do ((i 0 (+ i 1))) 
		((= i 10)) 
	      (if (fneq (sample i ind0 0) 0.5) (snd-display "ind0:0 1 filter-sound[~D]: ~A?" i (sample i ind0 0)))
	      (if (fneq (sample i ind0 1) 0.5) (snd-display "ind0:1 1 filter-sound[~D]: ~A?" i (sample i ind0 1)))
	      (if (fneq (sample i ind1 0) 0.5) (snd-display "ind1:0 1 filter-sound[~D]: ~A?" i (sample i ind1 0))))
	    
	    (close-sound ind1))
	  (close-sound ind0))
	
	(let ((ind0 (new-sound "fmv.snd" 1 22050 mus-bshort mus-aifc "this is a comment")))
	  (let ((v0 (make-float-vector 10 0.1)))
	    (let ((old5 (sample 5 ind0)))
	      (insert-samples 10 10 v0 ind0)
	      (env-sound '(0 0 1 2) 10 10 1.0 ind0)
	      (do ((i 0 (+ i 1))) ((= i 10)) 
		(if (fneq (sample (+ i 10) ind0) (* i .0222)) (snd-display "env-sound [~D]: ~A?" (+ i 10) (sample (+ i 10) ind0))))
	      (if (fneq (sample 5 ind0) old5) (snd-display "env-sound 5: ~A ~A?" old5 (sample 5 ind0))))
	    (undo)
	    (env-sound '(0 0 1 2) 10 10 4.0 ind0)
	    (set! v0 (channel->float-vector 10 10))
	    (if (or (fneq (v0 3) 0.039) (fneq (v0 8) .162)) (snd-display "env-sound 4: ~A" v0))
	    (undo)
	    (env-sound '(0 0 1 2) 10 10 .05 ind0)
	    (set! v0 (channel->float-vector 10 10))
	    (if (or (fneq (v0 3) 0.133) (fneq (v0 8) .196)) (snd-display "env-sound 05: ~A" v0)))
	  (close-sound ind0))
	
	(let ((ind0 (new-sound "fmv.snd" 2 22050 mus-bshort mus-aifc "this is a comment"))
	      (ind1 (new-sound "fmv1.snd" 1 22050 mus-ldouble mus-next "this is a comment")))
	  (let ((v0 (make-vector 10 1.0)))
	    (insert-samples 0 10 v0 ind0 0) 
	    (fill! v0 0.1)
	    (insert-samples 0 10 v0 ind0 1) 
	    (fill! v0 0.01)
	    (insert-samples 0 10 v0 ind1 0) 
	    (let ((val (data-max1 ind0 0)))
	      (if (fneq val 1.0) (snd-display "scan-chan[0,0]: ~A?" val)))
	    (let ((val (data-max1 ind0 1)))
	      (if (fneq val 0.1) (snd-display "scan-chan[0,1]: ~A?" val)))
	    (let ((val (data-max1 ind1 0)))
	      (if (fneq val 0.01) (snd-display "scan-chan[1,0]: ~A?" val)))
	    (let ((val (data-max1 #f #f)))
	      (if (fneq val 0.01) (snd-display "scan-chans: ~A?" val)))
	    (let ((val (data-max 0 9)))
	      (if (fneq val 1.0) (snd-display "scan-all-chans: ~A?" val)))
	    (let ((val (data-max2 ind0)))
	      (if (fneq val 1.0) (snd-display "scan-across-sound-chans: ~A?" val))))
	  (close-sound ind0)
	  (close-sound ind1))
	
	(let ((ind0 (new-sound "fmv.snd" 2 22050 mus-bshort mus-aifc "this is a comment")))
	  (mix "oboe.snd")
	  (let ((m1 (add-mark 100)))
	    (delete-sample 10)
	    (let ((m2 (add-mark 200)))
	      (delete-sample 10)
	      (let ((m3 (add-mark 300)))
		(undo)
		(save-sound)
		(if (not (= (length (marks ind0 0)) 2))
		    (snd-display "marks after save: ~A" (marks ind0 0)))
		(if (not (and (mark? m1)
			      (= (mark-sample m1) 99)))
		    (snd-display "save-sound mark1: ~A" (mark-sample m1)))
		(if (not (and (mark? m2)
			      (= (mark-sample m2) 200)))
		    (snd-display "save-sound mark2: ~A" (mark-sample m2)))
		(if (mark? m3) (snd-display "save-sound mark3: ~A" m3)))))
	  (close-sound ind0))
	
	(let ((fd (open-sound "oboe.snd"))
	      (m1 (add-mark 123))
	      (sync-val (+ 1 (mark-sync-max))))
	  (if (not (mark? m1)) (snd-display "mark?"))
	  (if (not (= (mark-sample m1) 123)) (snd-display "add-mark: ~A? " (mark-sample m1)))
	  (set! (mark-property :hiho m1) 123)
	  (if (not (= (mark-property :hiho m1) 123)) (snd-display "mark-property: ~A" (mark-property :hiho m1)))
	  (if (mark-property :not-there m1) (snd-display "mark-not-property: ~A" (mark-property :not-there m1)))
	  (if (not (eq? (without-errors (add-mark 123 123)) 'no-such-sound)) 
	      (snd-display "add-mark err: ~A?" (without-errors (add-mark 123 123))))
	  (let ((m2 (without-errors (add-mark 12345 fd 0))))
	    (if (eq? m2 'no-such-mark) (snd-display "add-mark failed?"))
	    (if (not (= (mark-sample m2) 12345)) (snd-display "add-mark 0 0: ~A?" (mark-sample m2)))
	    (if (not (= (mark-sync m2) 0)) (snd-display "init mark-sync: ~A?" (mark-sync m2)))
	    (set! (mark-sync m2) sync-val)
	    (if (not (= (mark-sync m2) sync-val)) (snd-display "set-mark-sync (~A): ~A?" sync-val (mark-sync m2)))
	    
	    (let* ((chans (marks fd 0))
		   (samps (map mark-sample chans)))
	      (let ((syncs (syncd-marks sync-val)))
		(if (not (equal? syncs (list m2))) (snd-display "syncd-marks: ~A?" syncs)))
	      (if (not (equal? chans (list m1 m2))) (snd-display "marks: ~A?" chans))
	      (if (not (equal? samps (list (mark-sample m1) (mark-sample m2)))) (snd-display "map samps: ~A?" samps))
	      (delete-samples 200 100 fd 0)
	      (set! chans (marks fd))
	      (set! samps (map mark-sample (car chans)))
	      (if (not (equal? samps (list (mark-sample m1 0) (- (mark-sample m2 0) 100)))) (snd-display "map samps: ~A?" samps))
	      (let ((descr (describe-mark m2)))
		(if (not (list? descr))
		    (snd-display "describe-mark: ~A?" descr)))
	      (set! (mark-sync m1) (mark-sync m2))
	      (move-syncd-marks sync-val 100)
	      (let ((chans (marks fd)))
		(set! samps (map mark-sample (car chans))))
	      (if (not (equal? samps (list (+ (mark-sample m1 0) 100) (mark-sample m2 0)))) (snd-display "syncd move samps: ~A?" samps)))
	    (set! (cursor) 500)
	    (set! (mark-sync m1) #t)
	    (if (not (= (mark-sync m1) 1)) (snd-display "mark-sync via bool: ~A" (mark-sync m1)))
	    (delete-mark m1)
	    (let ((chans (marks fd 0)))
	      (if (not (equal? chans (list m2))) (snd-display "delete-mark? ~A" chans)))
	    (undo)
	    (let ((chans (marks fd 0)))
	      (if (not (equal? chans (list m1 m2))) (snd-display "delete-mark then undo? ~A" chans)))
	    (redo)
	    (if (not (string=? (mark-name m2) "")) (snd-display "init mark-name: ~A?" (mark-name m2)))
	    (set! (mark-name m2) "hiho!")
	    (if (not (string=? (mark-name m2) "hiho!")) (snd-display "set-mark-name: ~A?" (mark-name m2)))
	    (undo)
	    (if (not (string=? (mark-name m2) "")) (snd-display "undo mark-name: ~A?" (mark-name m2)))
	    (redo)
	    (if (not (string=? (mark-name m2) "hiho!")) (snd-display "redo mark-name: ~A?" (mark-name m2)))
	    
	    (let ((m3 (find-mark "hiho!"))
		  (m4 (find-mark (mark-sample m2))))
	      (let ((m5 (find-mark "not-a-mark"))
		    (m6 (find-mark 123456787)))
		(let ((m7 (mark-name->id "hiho!")))
		  (if (not (and (equal? m2 m3) (equal? m4 m7) (equal? m2 m4))) (snd-display "find-mark: ~A ~A ~A ~A?" m2 m3 m4 m7)))
		(if (or (not (equal? m5 m6)) m5) (snd-display "find-not-a-mark: ~A ~A?" m5 m6)))
	      (set! (mark-sample m2) 2000)
	      (set! m1 (add-mark 1000))
	      (set! m3 (add-mark 3000))
	      (set! m4 (add-mark 4000))
	      (insert-samples 2500 500 (make-float-vector 500) fd 0)
	      (let ((samps (map mark-sample (marks fd 0))))
		(if (not (equal? samps '(1000 2000 3500 4500))) (snd-display "insert ripple: ~A?" samps)))
	      (set! (mark-sample m3) 300)
	      (set! (cursor) 500)
	      (let ((sd (open-sound "4.aiff")))
		(set! m3 (add-mark 1000 sd 2))
		(set! m4 (add-mark 1000 sd 3))
		(if (not (equal? (mark-home m3) (list sd 2))) (snd-display "marks->sound 4: ~A?" (mark-home m3)))
		(close-sound sd)))
	    
	    (let ((file (save-marks fd)))
	      (if (not (equal? file (string-append cwd "oboe.marks")))
		  (snd-display "save-marks -> ~A?" file)))
	    (let ((file (save-marks fd "hiho.marks")))
	      (if (not (equal? file "hiho.marks"))
		  (snd-display "save-marks with arg -> ~A?" file))
	      (if (not (zero? (system (format #f "diff hiho.marks \"~Aoboe.marks\"" cwd))))
		  (snd-display "save marks differs")))
	    (close-sound fd)
	    (let ((s1 (open-sound "oboe.snd"))
		  (s2 (open-sound "oboe.snd")))
	      (add-mark 123 s1 0)
	      (add-mark 321 s2 0)
	      (set! *with-verbose-cursor* #t)
	      (if (file-exists? "s61.scm") (delete-file "s61.scm"))
	      (save-state "s61.scm")
	      (set! *with-verbose-cursor* #f)
	      (close-sound s1)
	      (close-sound s2))
	    (load (string-append cwd "s61.scm"))
	    (if (not *with-verbose-cursor*) (snd-display "save-state with-verbose-cursor?"))
	    (let ((s1 (find-sound "oboe.snd" 0))
		  (s2 (find-sound "oboe.snd" 1)))
	      (if (not (and (sound? s1) (sound? s2)))
		  (snd-display "can't re-open sounds? ~A ~A" s1 s2)
		  (let ((m1 (marks s1))
			(m2 (marks s2)))
		    (if (not (and (pair? m1) (null? (cdr m1))
				  (pair? m2) (null? (cdr m2))
				  (pair? (car m1)) (null? (cdar m1))
				  (pair? (car m2)) (null? (cdar m2))))
			(snd-display "save-marks via save-state to: ~A ~A" m1 m2)
			(let ((samp1 (mark-sample (caar m1)))
			      (samp2 (mark-sample (caar m2))))
			  (if (not (and (= samp1 123)
					(= samp2 321)))
			      (snd-display "save-marks via save-state positions: ~A ~A" samp1 samp2))))))
	      (if (sound? s1) (close-sound s1))
	      (if (sound? s2) (close-sound s2)))
	    (let ((fd (open-sound "pistol.snd")))
	      (let ((file (save-marks)))
		(if (string? file)
		    (snd-display "save-marks no marks -> ~A?" file)))
	      (close-sound fd))
	    (let ((fd (open-sound "oboe.snd")))
	      (load (string-append cwd "oboe.marks"))
	      (let ((mlst (marks fd 0)))
		(if (not (= (length mlst) 4)) 
		    (snd-display "restore oboe.marks: ~A, marks: ~A" (file->string "oboe.marks") (marks fd 0))))
	      (close-sound fd))
	    (let ((fd (open-sound "oboe.snd")))
	      (add-mark 1000)
	      (add-mark 2500)
	      (add-mark (- (framples) 4000))
	      (let ((ms (marks fd 0)))
		(src-sound -.5)
		(if (not (equal? (marks fd 0) (reverse (marks fd 0 0))))
		    (snd-display "src rev marks: ~A ~A ~A" ms (marks fd 0) (reverse (marks fd 0 0))))
		(let ((ms1 (map mark-sample (marks fd 0))))
		  (if (not (equal? ms1 '(7998 96654 99654))) ; off-by-1 somewhere...
		      (snd-display "src rev mark locs: ~A" ms1))))
	      (close-sound fd))
	    (let ((fd (open-sound "4.aiff")))
	      (add-mark 1000 fd 0)
	      (add-mark 2000 fd 1)
	      (add-mark 3000 fd 2)
	      (add-mark 4000 fd 3)
	      (if (null? (marks)) (snd-display "marks (no args): ~A" (marks)))
	      (save-marks fd)
	      (close-sound fd))
	    (let ((fd (open-sound "4.aiff")))
	      (load (string-append cwd "4.marks"))
	      (delete-file "4.marks")
	      (do ((i 0 (+ i 1)))
		  ((= i 4))
		(let ((mlst (marks fd i)))
		  (if (not (= (length mlst) 1))
		      (snd-display "save-marks[~A]: ~A?" i mlst))
		  (if (not (= (mark-sample (car mlst)) (* (+ i 1) 1000)))
		      (snd-display "save-marks[~A] at ~A?" i (mark-sample (car mlst))))))
	      (close-sound fd))
	    ))
	
	(let ((fd (open-sound "oboe.snd"))
	      (m1 (add-mark 1234)))
	  (set! (mark-name m1) "1234")
	  (set! (mark-sync m1) 1234)
	  (let ((m2 (copy m1)))
	    (if (not (mark? m2)) 
		(snd-display " copy mark: ~A?" m2)
		(begin
		  (if (not (= (mark-sample m1) (mark-sample m2) 1234))
		      (snd-display "copy mark sample: ~A ~A" (mark-sample m1) (mark-sample m2)))
		  (if (not (= (mark-sync m1) (mark-sync m2) 1234))
		      (snd-display "copy mark sync: ~A ~A" (mark-sync m1) (mark-sync m2)))
		  (if (not (string=? (mark-name m2) "1234"))
		      (snd-display "copy mark name: ~A?" (mark-name m2))))))
	  (close-sound fd))
	
	(let ((ind (open-sound "pistol.snd"))
	      (samp1 1834)
	      (samp2 8345))
	  (let ((m1 (add-mark samp1 ind 0))
		(m2 (add-mark samp2)))
	    (set! (mark-sync m1) 123)
	    (set! (mark-sync m2) 100)
	    (if (not (= (mark-sync-max) 1234)) (snd-display "mark-sync-max: ~A" (mark-sync-max)))
	    (src-sound -1)
	    (if (not (= (mark-sample m1) 39788))
		(snd-display "src -1 m1 -> ~A" (mark-sample m1)))
	    (if (not (= (mark-sample m2) 33277))
		(snd-display "src -1 m2 -> ~A" (mark-sample m2)))
	    (undo)
	    (src-sound .5)
	    (if (not (= (mark-sample m1) (* 2 samp1)))
		(snd-display "src .5 m1 -> ~A" (mark-sample m1)))
	    (if (not (= (mark-sample m2) (* 2 samp2)))
		(snd-display "src .5 m2 -> ~A" (mark-sample m2)))
	    (undo)
	    (delete-samples 1000 100)
	    (if (not (= (mark-sample m1) (- samp1 100)))
		(snd-display "delete 100 m1 -> ~A" (mark-sample m1)))
	    (insert-silence 1000 100)
	    (if (not (= (mark-sample m1) samp1))
		(snd-display "insert 100 m1 -> ~A" (mark-sample m1)))
	    (revert-sound ind)
	    (delete-samples 2000 100)
	    (if (not (= (mark-sample m1) samp1))
		(snd-display "delete(2) 100 m1 -> ~A" (mark-sample m1)))
	    (if (not (= (mark-sample m2) (- samp2 100)))
		(snd-display "delete(2) 100 m2 -> ~A" (mark-sample m2)))
	    (insert-silence 2000 100)
	    (if (not (= (mark-sample m1) samp1))
		(snd-display "insert(2) 100 m1 -> ~A" (mark-sample m1)))
	    (if (not (= (mark-sample m2) samp2))
		(snd-display "insert(2) 100 m2 -> ~A" (mark-sample m2)))
	    (revert-sound ind)
	    (delete-samples 10000 100)
	    (if (not (= (mark-sample m1) samp1))
		(snd-display "delete(3) 100 m1 -> ~A" (mark-sample m1)))
	    (if (not (= (mark-sample m2) samp2))
		(snd-display "delete(3) 100 m2 -> ~A" (mark-sample m2)))
	    (insert-silence 10000 100)
	    (if (not (= (mark-sample m1) samp1))
		(snd-display "insert(3) 100 m1 -> ~A" (mark-sample m1)))
	    (if (not (= (mark-sample m2) samp2))
		(snd-display "insert(3) 100 m2 -> ~A" (mark-sample m2)))
	    (src-sound '(0 .5 1 .5 2 1))
	    (if (not (= (mark-sample m1) (* 2 samp1)))
		(snd-display "src env .5 m1 -> ~A" (mark-sample m1)))
	    (if (not (= (mark-sample m2) (* 2 samp2)))
		(snd-display "src env .5 m2 -> ~A" (mark-sample m2)))
	    (undo)
	    (reverse-sound)
	    (if (not (= (mark-sample m1) 39788))
		(snd-display "reverse-sound m1 -> ~A" (mark-sample m1)))
	    (if (not (= (mark-sample m2) 33277))
		(snd-display "reverse-sound m2 -> ~A" (mark-sample m2)))
	    (undo)
	    (src-sound '(0 -.5 1 -.5 2 -1))
	    (if (not (= (mark-sample m1) 68598))
		(snd-display "src -env m1 -> ~A" (mark-sample m1)))
	    (if (not (= (mark-sample m2) 61160))
		(snd-display "src -env m2 -> ~A" (mark-sample m2)))
	    (revert-sound ind)
	    (src-channel (make-env '(0 .5 1 1) :length 8001) 2000 10000)
	    (if (not (= (mark-sample m1) samp1))
		(snd-display "src-channel(1) m1 -> ~A" (mark-sample m1)))
	    (if (not (= (mark-sample m2) 11345))
		(snd-display "src-channel(1) m2 -> ~A" (mark-sample m2)))
	    (undo)
	    (src-channel (make-env '(0 .5 1 1) :length 8001) 0 8000)
	    (if (not (= (mark-sample m1) 3303))
		(snd-display "src-channel(2) m1 -> ~A" (mark-sample m1)))
	    (if (not (= (mark-sample m2) samp2))
		(snd-display "src-channel(2) m2 -> ~A" (mark-sample m2)))
	    (undo)
	    (src-channel (make-env '(0 .5 1 1) :length 8001) 10000 8000)
	    (if (not (= (mark-sample m1) samp1))
		(snd-display "src-channel(3) m1 -> ~A" (mark-sample m1)))
	    (if (not (= (mark-sample m2) samp2))
		(snd-display "src-channel(3) m2 -> ~A" (mark-sample m2)))
	    (close-sound ind)
	    (set! ind (open-sound "2.snd"))
	    (set! (sync ind) #t)
	    (let ((m3 (add-mark 1000 ind 0))
		  (m4 (add-mark 8000 ind 1)))
	      (swap-channels)
	      (if (not (and (equal? (mark-home m3) (list ind 1))
			    (equal? (mark-home m4) (list ind 0))))
		  (snd-display "swapped mark homes: ~A ~A?" (mark-home m3) (mark-home m4)))
	      (if (not (and (= (mark-sample m3) 1000)
			    (= (mark-sample m4) 8000)))
		  (snd-display "swapped mark samples: ~A ~A?" (mark-sample m3) (mark-sample m4)))
	      (close-sound ind))
	    (set! ind (open-sound "2.snd"))
	    (set! (sync ind) #t)
	    (let ((m3 (add-mark 1000 ind 0)))
	      (delete-samples 1000 10 ind 1)
	      (swap-channels)
	      (if (not (equal? (mark-home m3) (list ind 1)))
		  (snd-display "edited swapped mark home: ~A?" (mark-home m3)))
	      (if (not (= (mark-sample m3) 1000))
		  (snd-display "edited swapped mark sample: ~A" (mark-sample m3)))
	      (delete-marks))
	    (close-sound ind)))
	
	(let* ((ind (open-sound "oboe.snd"))
	       (m1 (add-mark 123 ind 0))
	       (m2 (add-mark 234 ind 0)))
	  (define-selection-via-marks m1 m2)
	  (let ((sel (selection)))
	    (if (not (and (selection?)
			  (selection? sel)))
		(snd-display "define-selection-via-marks failed?")
		(let ((mc (selection-members)))
		  (if (not (equal? mc (list (list ind 0)))) (snd-display "selection-members after mark definition: ~A (should be '((~A 0)))" mc ind))
		  (if (not (= (selection-position) 123)) (snd-display "selection-position 123: ~A" (selection-position)))
		  (if (not (= (selection-framples) 112)) (snd-display "selection-framples 112: ~A" (selection-framples))))))
	  (set! m1 (add-mark 1000 ind 0))
	  (set! m2 (add-mark 2000 ind 0))
	  (define-selection-via-marks m1 m2)
	  (if (not (selection?))
	      (snd-display "define-selection-via-marks repeat failed?")
	      (let ((mc (selection-members)))
		(if (not (equal? mc (list (list ind 0)))) (snd-display "selection-members after second mark definition: ~A (should be '((~A 0)))" mc ind))
		(if (not (= (selection-position) 1000)) (snd-display "selection-position 1000: ~A" (selection-position)))
		(if (not (= (selection-framples) 1001)) (snd-display "selection-framples 1001: ~A" (selection-framples)))))
	  (set! (selection-member? #t) #f)
	  (if (selection?) (snd-display "can't clear selection via selection-member?"))
	  (if (selection) (snd-display "(inactive) selection returns: ~A" (selection)))
	  (set! (selection-member? ind 0) #t)
	  (set! (selection-position ind 0) 2000)
	  (set! (selection-framples ind 0) 1234)
	  (snap-marks)
	  (set! m1 (find-mark 2000 ind 0))
	  (if (not (mark? m1)) (snd-display "snap-marks start: ~A" (map mark-sample (marks ind 0))))
	  (set! m2 (find-mark 3234))
	  (if (not (mark? m2)) (snd-display "snap-marks end: ~A" (map mark-sample (marks ind 0))))
	  (set! (selection-position ind 0) (+ (framples ind 0) 1123))
	  (if (not (= (selection-position ind 0) (- (framples ind) 1)))
	      (snd-display "selection position past eof: ~A ~A" (selection-position ind 0) (- (framples ind) 1)))
	  (revert-sound ind)
	  (src-sound '(0 .5 1 1.75665))
	  ;; trying to hit previous dur on the nose "by accident..."
	  
	  ;; try to hit mark_size segfault
	  (as-one-edit
	   (lambda ()
	     (add-mark 10)
	     (mix "oboe.snd")
	     (do ((i 0 (+ i 1))) ((= i 20)) (scale-channel 1.2) (add-mark (* i 2)))))
	  (scale-channel .5)
	  (close-sound ind))
	
	(let ((ind (open-sound "oboe.snd"))
	      (mtests 100))
	  (do ((i 0 (+ i 1)))
	      ((= i mtests))
	    (let* ((current-marks (marks ind 0))
		   (current-samples (map mark-sample current-marks)))
	      
	      (if (pair? current-marks)
		  (let ((id (current-marks (random (- (length current-marks) 1)))))
		    (if (not (equal? id (find-mark (mark-sample id)))) 
			(snd-display "~A: two marks at ~A? ~A" i (mark-sample id) (map mark-sample current-marks)))
		    (if (find-mark "not-a-name") (snd-display "find-bogus-mark: ~A" (find-mark "not-a-name")))))
	      
	      (case (random 15)
		((0) (let ((beg (random (framples)))
			   (dur (max 1 (random 100))))
		       (insert-silence beg dur)
		       (for-each
			(lambda (id old-loc)
			  (if (> old-loc beg)
			      (if (not (mark? id))
				  (snd-display "insert clobbered mark: ~A" id)
				  (if (not (= (mark-sample id) (+ old-loc dur)))
				      (snd-display "insert, mark ~D ~D -> ~D (~D)" id old-loc (mark-sample id) dur)))))
			current-marks
			current-samples)))
		((1) (if (> (car (edits ind 0)) 0) (undo)))
		((2) (if (> (cadr (edits ind 0)) 0) (redo)))
		((3) 
		 (scale-channel (if (> (maxamp ind 0) .1) .5 2.0))
		 (if (not (equal? (marks ind 0) current-marks))
		     (snd-display "scaling changed marks: ~A ~A" (marks ind 0) current-marks))
		 (if (not (equal? (map mark-sample (marks ind 0)) current-samples))
		     (snd-display "scaling changed mark locations: ~A ~A" (map mark-sample (marks ind 0)) current-samples)))
		((4) 
		 (set! (sample (random (- (framples) 1))) .5)
		 (if (not (equal? (marks ind 0) current-marks))
		     (snd-display "set-sample changed marks: ~A ~A" (marks ind 0) current-marks))
		 (if (not (equal? (map mark-sample (marks ind 0)) current-samples))
		     (snd-display "set-sample changed mark locations: ~A ~A" (map mark-sample (marks ind 0)) current-samples)))
		((5) (let* ((beg (random (framples)))
			    (dur (max 1 (random 100)))
			    (end (+ beg dur)))
		       (delete-samples beg dur)
		       (for-each
			(lambda (id old-loc)
			  (cond ((and (< beg old-loc end) (mark? id))
				 (snd-display "delete did not clobber mark: ~A ~A [~A ~A]" id old-loc beg end))
				((and (> old-loc end)
				      (not (= (mark-sample id) (- old-loc dur))))
				 (snd-display "delete ripple mark ~D ~D -> ~D (~D)" id old-loc (mark-sample id) dur))
				((and (< old-loc beg)
				      (not (= (mark-sample id) old-loc)))
				 (snd-display "delete but mark before: ~A ~A ~A ~A" id old-loc (mark-sample id) beg))))
			current-marks
			current-samples)))
		((6) (revert-sound))
		((7) (if (and (pair? current-marks)
			      (> (length current-marks) 1))
			 (let ((id (current-marks (random (- (length current-marks) 1)))))
			   (delete-mark id)
			   (if (mark? id)
			       (snd-display "delete-mark failed? ~A" id))
			   (if (not (= (length (marks ind 0)) (- (length current-marks) 1)))
			       (snd-display "delete-mark list trouble: ~A ~A ~A" id current-marks (marks ind 0))))))
		((8) (let ((rate (if (> (framples) 200000) 2.0 0.5)))
		       (src-channel rate)
		       (for-each
			(lambda (id old-loc)
			  (if (not (mark? id))
			      (snd-display "src-channel clobbered mark: ~A" id)
			      (if (> (abs (- (/ old-loc rate) (mark-sample id))) 2)
				  (snd-display "src moved mark: ~A ~A ~A (~A -> ~A)" 
					       id old-loc (mark-sample id) rate (- (/ old-loc rate) (mark-sample id))))))
			current-marks
			current-samples)))
		((9) (reverse-channel)
		 (for-each
		  (lambda (id old-loc)
		    (if (not (mark? id))
			(snd-display "reverse-channel clobbered mark: ~A" id)
			(if (> (abs (- (framples) old-loc (mark-sample id))) 2)
			    (snd-display "reverse moved mark: ~A ~A ~A (~A)" 
					 id old-loc (- (framples) old-loc) (mark-sample id)))))
		  current-marks
		  current-samples))
		(else (add-mark (random (- (framples) 1)))))))
	  (close-sound ind))
	
	(if (and (provided? 'snd-motif) (provided? 'xm)) (mark-sync-color "blue"))
	(let ((ind (open-sound "oboe.snd")))
	  (let ((m0 (add-mark 4321)))
	    (delete-sample 100)
	    (let ((m1 (add-mark 1234)))
	      (let ((val0 (describe-mark m0))
		    (val1 (describe-mark m1)))
		(if (not (and (equal? ((car val0) 0) m0)
			      (equal? ((car val0) 2) ind)
			      (= ((car val0) 5) 0)
			      (= (val0 1) 4321)
			      (= (val0 2) 4320)))
		    (snd-display "describe-mark m0: ~A" val0))
		(if (not (and (equal? ((car val1) 0) m1)
			      (equal? ((car val1) 2) ind)
			      (= ((car val1) 5) 0)
			      (not (val1 1))
			      (= (val1 2) 1234)))
		    (snd-display "describe-mark m1: ~A" val1))
		(delete-mark m0)
		(delete-sample 5000)
		(set! val0 (describe-mark m0))
		(set! val1 (describe-mark m1))
		(let ((v0-ok (and (equal? ((car val0) 0) m0)
				  (equal? ((car val0) 2) ind)
				  (= ((car val0) 5) 0)
				  (= (val0 1) 4321))))
		  (if (or (not v0-ok)
			  (val0 2)
			  (val0 3))
		      (snd-display "describe-mark m0 [1]: ~A" val0)))
		(if (not (and (equal? ((car val1) 0) m1)
			      (equal? ((car val1) 2) ind)
			      (= ((car val1) 5) 0)
			      (not (val1 1))
			      (= (val1 2) (val1 3) 1234)))
		    (snd-display "describe-mark m1 [1]: ~A" val1)))))
	  (revert-sound ind)
	  (hook-push draw-mark-hook (lambda (hook) #t))
	  (let ((m0 (add-mark 4321)))
	    (let ((dur (/ (framples ind) (srate ind))))
	      (pad-marks (list m0 (add-mark 1234)) .01)
	      (if (fneq (/ (framples ind) (srate ind)) (+ dur .02))
		  (snd-display "pad-marks: ~A ~A" dur (/ (framples ind) (srate ind)))))
	    (if (not (member (mark-sample m0) '(4763 4761) =))
		(snd-display "pad-marks m0 pos: ~A" (mark-sample m0)))
	    (if (fneq (sample 1235) 0.0) (snd-display "pad-marks 1235: ~A" (sample 1235))))
	  (close-sound ind)))
      (set! (hook-functions draw-mark-hook) ())
      
      (let ((ind (open-sound "oboe.snd")))
	(if (find-mark 12345) (snd-display "find-mark when no marks: ~A" (find-mark 12345)))
	(add-mark 123 ind 0)
	(delete-sample 0)
	(set! (mark-name (add-mark 23 ind 0)) "23")
	(delete-sample 0)
	(if (not (find-mark 123 ind 0 0))
	    (snd-display "can't find 00th mark"))
	(if (not (find-mark "23"))
	    (snd-display "can't find 01th mark"))
	(if (not (find-mark 121))
	    (snd-display "can't find 02th mark"))
	(delete-mark (find-mark "23"))
	(scale-by 2.0)
	(let ((m1 (add-mark 1234)))
	  (set! (mark-name m1) "23")
	  (let ((m10 (find-mark "23"))
		(m11 (find-mark "23" ind 0 1))
		(m12 (find-mark "23" ind 0 2)))
	    (if (not m10) (snd-display "can't find 10th mark")
		(if (not (= (mark-sample m10) 1234)) (snd-display "mark 10th: ~A" (mark-sample m10))))
	    (if (not m11) (snd-display "can't find 11th mark")
		(if (not (= (mark-sample m11 1) 23)) (snd-display "mark 11th: ~A" (mark-sample m11 1))))
	    (if (mark? m12) (snd-display "found 12th mark: ~A ~A ~A" m12 (mark-sample m12 2) (mark-name m12))))
	  (set! (mark-name m1) ""))
	(close-sound ind)
	(if (string? sf-dir)
	    (let ((ind (open-sound (string-append sf-dir "forest.aiff"))))
	      (mark-loops)
	      (let ((pos (map mark-sample (marks ind 0))))
		(if (not (equal? pos '(24981 144332)))
		    (snd-display "forest marked loops: ~A ~A" (marks ind 0) pos)))
	      (close-sound ind))))
      
      (let ((ind (open-sound "oboe.snd")))
	(add-mark 123)
	(add-mark 234 ind 0 "hiho" 1)
	(add-mark 345 ind 0 #f 1)
	(add-mark 456 ind 0 "a mark" 2)
	(add-mark 567 ind 0 #f 1)
	(save-marks ind "oboe.marks")
	(close-sound ind))
      
      (let ((ind (open-sound "oboe.snd")))
	(add-mark 1 ind 0 "new mark" 1)
	(load (string-append cwd "oboe.marks"))
	(let ((m (find-mark 123 ind 0)))
	  (if (not (mark? m)) 
	      (snd-display "save marks missed 123?")
	      (begin
		(if (not (= (length (mark-name m)) 0)) (snd-display "saved mark 123 name: ~A" (mark-name m)))
		(if (not (= (mark-sync m) 0)) (snd-display "saved mark 123 sync: ~A" (mark-sync m))))))
	(let ((m1-sync 0))
	  (let ((m (find-mark 234 ind 0)))
	    (if (not (mark? m)) 
		(snd-display "save marks missed 234?")
		(begin
		  (if (not (string=? (mark-name m) "hiho")) (snd-display "saved mark 234 name: ~A" (mark-name m)))
		  (if (memv (mark-sync m) '(0 1)) (snd-display "saved mark 234 sync: ~A" (mark-sync m)))
		  (set! m1-sync (mark-sync m)))))
	  (let ((m (find-mark 345 ind 0)))
	    (if (not (mark? m)) 
		(snd-display "save marks missed 345?")
		(begin
		  (if (not (= (length (mark-name m)) 0)) (snd-display "saved mark 345 name: ~A" (mark-name m)))
		  (if (not (= (mark-sync m) m1-sync)) (snd-display "saved mark 345 sync: ~A ~A" (mark-sync m) m1-sync)))))
	  (let ((m (find-mark 567 ind 0)))
	    (if (not (mark? m)) 
		(snd-display "save marks missed 567?")
		(begin
		  (if (not (= (length (mark-name m)) 0)) (snd-display "saved mark 567 name: ~A" (mark-name m)))
		  (if (not (= (mark-sync m) m1-sync)) (snd-display "saved mark 567 sync: ~A ~A" (mark-sync m) m1-sync)))))
	  (let ((m (find-mark 456 ind 0)))
	    (if (not (mark? m)) 
		(snd-display "save marks missed 456?")
		(begin
		  (if (not (string=? (mark-name m) "a mark")) (snd-display "saved mark 456 name: ~A" (mark-name m)))
		  (if (or (= (mark-sync m) m1-sync) 
			  (member (mark-sync m) '(0 1) =))
		      (snd-display "saved mark 456 sync: ~A ~A" (mark-sync m) m1-sync)))))
	  )
	(delete-file "oboe.marks")
	
	(let ((ind1 (open-sound "2a.snd")))
	  (add-mark 1 ind1 0)
	  (add-mark 2 ind1 1)
	  (add-mark 3 ind1 0 "hi3")
	  (add-mark 6 ind1 1 "hi6")
	  (add-mark 4 ind1 0 #f 4)
	  (add-mark 8 ind1 1 #f 5)
	  (add-mark 5 ind1 0 #f 9)
	  (add-mark 10 ind1 1 #f 9)
	  (add-mark 20 ind1 0 #f 12)
	  (add-mark 40 ind1 1 #f 12)
	  (add-mark 60 ind1 1 #f 12)
	  (save-marks ind1 "test.marks")
	  (close-sound ind1))
	(close-sound ind))
      
      (let ((ind (open-sound "2a.snd")))
	(load (string-append cwd "test.marks"))
	
	(let ((m1 (find-mark 1 ind 0))
	      (m2 (find-mark 2 ind 1)))
	  (if (not (and (mark? m1) (mark? m2)))
	      (snd-display "save-marks 2a 1,2: ~A ~A" m1 m2)
	      (if (not (= (mark-sync m1) 0 (mark-sync m2)))
		  (snd-display "save-marks 2a 1,2 syncs: ~A ~A" (mark-sync m1) (mark-sync m2)))))
	(let ((m1 (find-mark 5 ind 0))
	      (m2 (find-mark 10 ind 1)))
	  (if (not (and (mark? m1) (mark? m2)))
	      (snd-display "save-marks 2a 5,10: ~A ~A" m1 m2)
	      (if (or (= (mark-sync m1) 0)
		      (not (= (mark-sync m1) (mark-sync m2))))
		  (snd-display "save-marks 2a 5,10 syncs: ~A ~A" (mark-sync m1) (mark-sync m2)))))
	(let ((m1 (find-mark 4 ind 0))
	      (m2 (find-mark 8 ind 1))
	      (m3 (find-mark 5 ind 0)))
	  (if (not (and (mark? m1) (mark? m2))) 
	      (snd-display "save-marks 2a 4,8: ~A ~A" m1 m2)
	      (if (or (= (mark-sync m1) 0)
		      (= (mark-sync m2) 0)
		      (= (mark-sync m1) (mark-sync m2))
		      (= (mark-sync m1) (mark-sync m3)))
		  (snd-display "save-marks 2a 4,8 syncs: ~A ~A ~A" (mark-sync m1) (mark-sync m2) (mark-sync m3)))))
	(let ((m1 (find-mark 3 ind 0))
	      (m2 (find-mark 6 ind 1)))
	  (if (not (and (mark? m1) (mark? m2))) 
	      (snd-display "save-marks 2a 3,6: ~A ~A" m1 m2)
	      (begin
		(if (not (= (mark-sync m1) 0 (mark-sync m2)))
		    (snd-display "save-marks 2a 3,6 syncs: ~A ~A" (mark-sync m1) (mark-sync m2)))
		(if (not (string=? (mark-name m1) "hi3")) (snd-display "save-marks 2a 3 name: ~A" (mark-name m1)))
		(if (not (string=? (mark-name m2) "hi6")) (snd-display "save-marks 2a 6 name: ~A" (mark-name m2))))))
	(let ((m1 (find-mark 4 ind 0))
	      (m2 (find-mark 5 ind 0))
	      (m3 (find-mark 20 ind 0))
	      (m4 (find-mark 40 ind 1))
	      (m5 (find-mark 60 ind 1)))
	  (if (not (and (mark? m3) (mark? m4) (mark? m5)))
	      (snd-display "save-marks 2a 20...: ~A ~A ~A" m3 m4 m5)
	      (if (or (= (mark-sync m3) 0)
		      (= (mark-sync m1) (mark-sync m3))
		      (= (mark-sync m2) (mark-sync m3))
		      (not (= (mark-sync m3) (mark-sync m4) (mark-sync m5))))
		  (snd-display "save-marks 2a 10... syncs: ~A ~A ~A" (mark-sync m3) (mark-sync m4) (mark-sync m5)))))
	(delete-file "test.marks")
	(close-sound ind))
      
      (let ((ind (new-sound :size 1000)))
	(add-mark 123)
	(add-mark 234 ind 0 "hiho" 1)
	(add-mark 345 ind 0 #f 1)
	(add-mark 456 ind 0 "a mark" 2)
	(add-mark 567 ind 0 #f 1)
	(hook-push output-comment-hook (lambda (hook) (set! (hook 'result) (marks->string (selected-sound)))))
	(save-sound-as "tst.snd")
	(clean-up-sound ind))
      
      (let ((ind (open-sound "tst.snd")))
	(set! (hook-functions output-comment-hook) ())
	(eval-header ind)
	(let ((ms (marks ind 0)))
	  (if (not (= (length ms) 5)) (snd-display "eval-header + marks->string: ~A" ms))
	  (let ((samps (map mark-sample ms)))
	    (if (not (and (memv 123 samps)
			  (memv 567 samps)))
		(snd-display "eval marked header samps: ~A" samps))))
	(if (not (find-mark 234)) (snd-display "eval mark header no mark at 234?"))
	(if (mark? (find-mark 456))
	    (if (not (= (mark-sync (find-mark 456)) 2)) 
		(snd-display "eval mark header sync: ~A" (mark-sync (find-mark 456))))
	    (snd-display "no mark at 456"))
	(close-sound ind))
      
      (mus-sound-forget "tst.snd")
      (delete-file "tst.snd")
      
      ;; mark-explode
      (let ((ind (new-sound :size 31)))
	(let ((ctr -1))
	  (map-channel (lambda (y) (set! ctr (+ ctr 1)) (if (< ctr 10) .1 (if (< ctr 20) .4 .8)))))
	(add-mark 10)
	(add-mark 20)
	(add-mark 30)
	(mark-explode)
	(if (not (file-exists? "mark-0.snd"))
	    (snd-display "mark-explode did not write mark-0.snd?")
	    (let ((ind1 (open-sound "mark-0.snd")))
	      (if (not (= (framples ind1 0) 10)) (snd-display "mark-0 framples: ~A" (framples ind1 0)))
	      (if (not (mus-arrays-equal? (channel->float-vector) (make-float-vector 10 .1))) (snd-display "mark-0 vals: ~A" (channel->float-vector)))
	      (close-sound ind1)
	      (delete-file "mark-0.snd")))
	(if (not (file-exists? "mark-1.snd"))
	    (snd-display "mark-explode did not write mark-1.snd?")
	    (let ((ind1 (open-sound "mark-1.snd")))
	      (if (not (= (framples ind1 0) 10)) (snd-display "mark-1 framples: ~A" (framples ind1 0)))
	      (if (not (mus-arrays-equal? (channel->float-vector) (make-float-vector 10 .4))) (snd-display "mark-1 vals: ~A" (channel->float-vector)))
	      (close-sound ind1)
	      (delete-file "mark-1.snd")))
	(if (not (file-exists? "mark-2.snd"))
	    (snd-display "mark-explode did not write mark-2.snd?")
	    (let ((ind1 (open-sound "mark-2.snd")))
	      (if (not (= (framples ind1 0) 10)) (snd-display "mark-2 framples: ~A" (framples ind1 0)))
	      (if (not (mus-arrays-equal? (channel->float-vector) (make-float-vector 10 .8))) (snd-display "mark-2 vals: ~A" (channel->float-vector)))
	      (close-sound ind1)
	      (delete-file "mark-2.snd")))
	(if (file-exists? "mark-3.snd") (snd-display "mark-explode wrote too many files?"))
	(clean-up-sound ind)))))


;;; ---------------- test 11: dialogs ----------------

(define (snd_test_11)
  
  (define-envelope env4 '(0 1 1 0))
  
  (define (string-equal-ignoring-white-space s1 s2)
    (or (string=? s1 s2)
	(let ((len1 (length s1))
	      (len2 (length s2)))
	  (let loop ((i1 0) (i2 0))
	    (or (and (= i1 len1)
		     (= i2 len2))
		(if (and (< i1 len1)
			 (char-whitespace? (s1 i1)))
		    (loop (+ i1 1) i2)
		    (if (and (< i2 len2)
			     (char-whitespace? (s2 i2)))
			(loop i1 (+ i2 1))
			(and (< i1 len1)
			     (< i2 len2)
			     (char=? (s1 i1) (s2 i2))
			     (loop (+ i1 1) (+ i2 1))))))))))
  
  (when with-gui
    (without-errors (peaks))
    (enved-dialog)
    (color-orientation-dialog)
    (transform-dialog)
    (if with-motif (view-files-dialog))
    (view-regions-dialog)
    (if (not (provided? 'snd-gtk)) (print-dialog))
    (without-errors (edit-header-dialog))
    (open-file-dialog #f)
    (mix-file-dialog #f)
    (insert-file-dialog #f)
    (help-dialog "Test" "snd-test here")
    (save-envelopes "hiho.env")
    (load (string-append cwd "hiho.env"))
    (if (not (equal? env4 '(0.0 1.0 1.0 0.0))) (snd-display "save-envelopes: ~A?" env4))
    (delete-file "hiho.env")
    (help-dialog "test2" "this is the next test" 
		 (list "string 1{open-sound}" "{env-sound}string2" "string{close-sound}3")
		 (list "extsnd.html#sndopen" "extsnd.html#sndenv" "extsnd.html#sndclose"))
    (dismiss-all-dialogs)
    
    (let ((ind (open-sound "oboe.snd")))
      (edit-header-dialog ind)
      (dismiss-all-dialogs)
      (close-sound ind))
    (if (not (string=? (snd-url 'open-sound) "extsnd.html#opensound"))
	(snd-display "snd-url 'open-sound: ~A" (snd-url 'open-sound)))
    (if (not (string=? (snd-url "open-sound") "extsnd.html#opensound"))
	(snd-display "snd-url \"open-sound\": ~A" (snd-url "open-sound")))
    (if (not (list? (snd-urls))) (snd-display "snd-urls: ~A" (snd-urls)))
    (let ((str1 (snd-help open-sound))
	  (str2 (snd-help 'open-sound))
	  (str3 (snd-help "open-sound")))
      (if (not (and (string? str1) ; can happen if we're running -DTIMING
		    (string? str2)
		    (string? str3)
		    (string-equal-ignoring-white-space str2 str3)))
	  (snd-display "snd-help open-sound: ~A ~A ~A" str1 str2 str3)))
					;	(if (not (string? (snd-help 'open-soud)))
					;	    (snd-display "snd-help open-soud (misspelled on purpose) failed"))
    (if (not (string-equal-ignoring-white-space (snd-help enved-base) "(enved-base): envelope editor exponential base value (1.0)"))
	(snd-display "snd-help enved-base: ~A?" (snd-help enved-base)))
    (if (not (string-equal-ignoring-white-space (snd-help 'enved-base) "(enved-base): envelope editor exponential base value (1.0)"))
	(snd-display "snd-help 'enved-base: ~A?" (snd-help 'enved-base)))
    (if (not (string-equal-ignoring-white-space (snd-help "enved-base") "(enved-base): envelope editor exponential base value (1.0)"))
	(snd-display "snd-help \"enved-base\": ~A?" (snd-help "enved-base")))
    (let ((str1 (snd-help 'hamming-window))
	  (str2 (snd-help "hamming-window")))
      (if (not (and (string? str1) (string? str2)
		    (string-equal-ignoring-white-space str1 str2)
		    (string-equal-ignoring-white-space str1 "A raised cosine")))
	  (snd-display "snd-help hamming-window: ~A ~A" str1 str2)))

    (do ((vals (snd-urls))
	 (i 0 (+ i 1)))
	((= i 25)) ; need to cycle the 8's
      (if (defined? (string->symbol (car (vals i))))
	  (snd-help (car (vals i)) #f)))
    
    (set! *show-indices* #t)
    (let ((ind (open-sound "oboe.snd")))
      (if (< (length (sound-widgets ind)) 4)
	  (snd-display "sound-widgets: ~A?" (sound-widgets ind)))
      (status-report "hi there" ind)
      (status-report "")
      (close-sound ind))
    (set! *show-indices* #f)
    
    (define-envelope test-ramp1 '(0 0 1 1))
    (if (not (equal? test-ramp1 '(0 0 1 1))) (snd-display "define-envelope test-ramp1: ~A" test-ramp1))
    (define-envelope test-ramp '(0 1 1 0))
    (if (not (equal? test-ramp '(0 1 1 0))) (snd-display "re-define-envelope test-ramp: ~A" test-ramp))
    
    (when with-motif
      (let ((dialog (view-files-dialog #f)))
	(let ((vfamp (view-files-amp dialog)))
	  (if (fneq vfamp 1.0) (snd-display "vf amp: ~A" vfamp)))
	(let ((vfs (view-files-speed dialog)))
	  (if (fneq vfs 1.0) (snd-display "vf spd: ~A" vfs)))
	(let ((vfsort (view-files-sort)))
	  (if (not (= vfsort 0)) (snd-display "vf sort: ~A" vfsort)))
	(let ((vfsort1 (view-files-sort dialog)))
	  (if (not (= vfsort1 0)) (snd-display "vf sort(d): ~A" vfsort1)))
	(let ((vfe (view-files-amp-env dialog)))
	  (if (not (feql vfe '(0.0 1.0 1.0 1.0))) (snd-display "vf amp env: ~A" vfe)))
	(let ((vffiles (view-files-files dialog)))
	  (if (not (list? vffiles)) (snd-display "vf files: ~A" vffiles)))
	(let ((vfsel (view-files-selected-files dialog)))
	  (if (not (list? vfsel)) (snd-display "vf selected files: ~A" vfsel)))
	(if (not (= (view-files-speed-style dialog) *speed-control-style*))
	    (snd-display "vf speed-style def: ~A ~A" (view-files-speed-style dialog) *speed-control-style*))
	(set! (view-files-amp dialog) 0.5)
	(if (fneq (view-files-amp dialog) 0.5) (snd-display "set vf amp: ~A" (view-files-amp dialog)))
	(set! (view-files-speed dialog) 0.5)
	(if (fneq (view-files-speed dialog) 0.5) (snd-display "set vf spd: ~A" (view-files-speed dialog)))
	(set! (view-files-speed-style dialog) speed-control-as-ratio)
	(if (not (= (view-files-speed-style dialog) speed-control-as-ratio))
	    (snd-display "vf speed-style set: ~A" (view-files-speed-style dialog)))
	(set! (view-files-sort dialog) 2)
	(if (not (= (view-files-sort) 0)) (snd-display "vf global sort after local set: ~A" (view-files-sort)))
	(if (not (= (view-files-sort dialog) 2)) (snd-display "vf local sort after local set: ~A" (view-files-sort dialog)))
	(set! (view-files-sort) 4)
	(if (not (= (view-files-sort) 4)) (snd-display "vf global sort after global set: ~A" (view-files-sort)))    
	(if (not (= (view-files-sort dialog) 2)) (snd-display "vf local sort after global set: ~A" (view-files-sort dialog)))
	(set! (view-files-files dialog) (list "oboe.snd" "1a.snd" "pistol.snd" "storm.snd"))
	(let ((vf-files (view-files-files dialog)))
	  (if (not (and (or (member "1a.snd" vf-files)
			    (member (string-append home-dir "/cl/1a.snd") vf-files)
			    (member (string-append home-dir "/snd-18/1a.snd") vf-files))
			(or (member "pistol.snd" vf-files)
			    (member (string-append home-dir "/cl/pistol.snd") vf-files)
			    (member (string-append home-dir "/snd-18/pistol.snd") vf-files))
			(= (length vf-files) 4)))
	      (snd-display "vf files set: ~A (~A, ~A)" vf-files (string-append home-dir "/cl/1a.snd") (length vf-files))))
	(set! (hook-functions view-files-select-hook) ())
	(let ((selected-file #f))
	  (hook-push view-files-select-hook (lambda (hook)
					      (if (not (string? (hook 'name)))
						  (snd-display "vf select hook arg: ~A" (hook 'name)))
					      (if (not (hook 'widget)) (snd-display "vf select hook dialog: ~A" (hook 'widget)))
					      (set! selected-file (hook 'name))))
	  (set! (view-files-selected-files dialog) (list "1a.snd"))
	  (if (not (or (equal? selected-file "1a.snd")
		       (equal? selected-file (string-append home-dir "/cl/1a.snd"))
		       (equal? selected-file (string-append home-dir "/snd-18/1a.snd"))))
	      (snd-display "vf set selected select hook arg: ~A" selected-file))
	  (if (not (or (equal? (view-files-selected-files dialog) '("1a.snd"))
		       (equal? (view-files-selected-files dialog) (list (string-append home-dir "/cl/1a.snd")))
		       (equal? (view-files-selected-files dialog) (list (string-append home-dir "/snd-18/1a.snd")))))
	      (snd-display "vf selected files set: ~A" (view-files-selected-files dialog))))
	(hide-widget dialog)))
    (dismiss-all-dialogs)))


;;; ---------------- test 12: extensions ----------------

(define (test-remove-if p lst)
  (cond ((null? lst) ())
	((p (car lst)) (test-remove-if p (cdr lst)))
	(else (cons (car lst) (test-remove-if p (cdr lst))))))
  
(define (snd_test_12)
  (if (null? (sound-file-extensions))
      (set! (sound-file-extensions) original-sound-file-extensions))
  
  (let* ((sf-dir-files
	  (and (string? sf-dir) 
	       (let ((good-files ()))
		 (for-each ; omit bad headers (test cases) 
		  (lambda (file)
		    (catch 'mus-error
		      (lambda () 
			(if (and (< 0 (mus-sound-chans (string-append sf-dir file)) 256)
				 (>= (mus-sound-sample-type (string-append sf-dir file)) 0)
				 (> (mus-sound-srate (string-append sf-dir file)) 0)
				 (>= (mus-sound-framples (string-append sf-dir file)) 0))
			    (set! good-files (cons file good-files))))
		      (lambda args 
			(car args))))
		  (sound-files-in-directory sf-dir))
		 good-files)))
	 (sf-dir-len (if sf-dir-files (length sf-dir-files) 0)))
    
    (when (and with-gui
	       (> sf-dir-len 0))
      (let ((open-files ())
	    (open-ctr 0)
	    
	    (test-spectral-difference 
	     (let ((spectral-difference 
		    (lambda (snd1 snd2)
		      (let ((diffs (let* ((fftlen (expt 2 (ceiling (log (max (framples snd1) (framples snd2)) 2))))
					  (fdr1 (channel->float-vector 0 fftlen snd1 0))
					  (fdr2 (channel->float-vector 0 fftlen snd2 0)))
				     (float-vector-subtract! (snd-spectrum fdr1 blackman2-window fftlen #t)
							     (snd-spectrum fdr2 blackman2-window fftlen #t)))))
			(float-vector-abs! diffs)
			(do ((len (length diffs))
			     (incr (make-one-pole 1.0 -1.0))
			     (i 0 (+ i 1)))
			    ((= i len) (one-pole incr 0.0))
			  (one-pole incr (float-vector-ref diffs i)))))))
	       
	       (lambda (snd1 snd2 maxok)
		 (let ((s1 (open-sound snd1))
		       (s2 (open-sound snd2)))
		   (if (not (and (sound? s1)
				 (sound? s2)))
		       (snd-display "open-sound ~A or ~A failed?" snd1 snd2))
		   (let ((diff (spectral-difference s1 s2)))
		     (close-sound s1)
		     (close-sound s2)
		     (if (> diff maxok)
			 (snd-display "translate spectral difference ~A ~A: ~A > ~A?" snd1 snd2 diff maxok))))))))
	
	(add-sound-file-extension "wave")
	(let ((exts (sound-file-extensions)))
	  (if (not (member "wave" exts))
	      (snd-display "sound-file-extensions: ~A" exts))
	  (set! (sound-file-extensions) ())
	  (if (pair? (sound-file-extensions))
	      (snd-display "sound-file-extesions set to (): ~A" (sound-file-extensions)))
	  (set! (sound-file-extensions) exts)
	  (if (not (member "wave" exts))
	      (snd-display "sound-file-extensions reset: ~A" (sound-file-extensions))))
	
	(do ((clmtest 0 (+ 1 clmtest))) ((= clmtest tests)) 
	  (log-mem clmtest)
	  
	  (do ()
	      ((= open-ctr 32))
	    (let ((len (length open-files)))
	      (if (or (= len 0) (> (random 1.0) .5))
		  (let ((fd (let* ((name (let ((choice (floor (random sf-dir-len))))
					   (string-append sf-dir (sf-dir-files choice))))
				   (ht (catch #t (lambda () (mus-sound-header-type name)) (lambda args 0)))
				   (df (catch #t (lambda () (mus-sound-sample-type name)) (lambda args 0))))
			      (if (or (= ht mus-raw)
				      (= ht mus-unknown-header)
				      (= df mus-unknown-sample))
				  -1 
				  (or (catch #t
					(lambda () (view-sound name))
					(lambda args
					  (snd-display "~A ~A ~A" name ht df)
					  -1))
				      -1)))))
		    (unless (eqv? fd -1)
		      (set! open-ctr (+ open-ctr 1))
		      (set! open-files (cons fd open-files))))
		  (if (and (> len 0) (> (random 1.0) 0.3))
		      (let ((fd (open-files (floor (random (* 1.0 (length open-files)))))))
			(close-sound fd)
			(set! open-files (test-remove-if (lambda (a) (equal? a fd)) open-files)))))))
	  (if (pair? open-files) (for-each close-sound open-files))
	  (set! open-files ())
	  
	  (if (pair? (sounds)) (snd-display "active-sounds: ~A ~A?" (sounds) (map short-file-name (sounds))))
	  (let ((fd (open-raw-sound :file (string-append sf-dir "addf8.nh") :channels 1 :srate 8012 :sample-type mus-mulaw)))
	    (if (not (= (sample-type fd) mus-mulaw)) (snd-display "open-raw-sound: ~A?" (mus-sample-type-name (sample-type fd))))
	    (close-sound fd))
	  
	  (set! (hook-functions bad-header-hook) ())
	  (test-spectral-difference (string-append sf-dir "o2.wave") (string-append sf-dir "o2_dvi.wave") 10.0)
	  (test-spectral-difference (string-append sf-dir "wood.riff") (string-append sf-dir "wood.sds") 4.0)
	  (test-spectral-difference (string-append sf-dir "nist-10.wav") (string-append sf-dir "nist-shortpack.wav") 1.0)
	  (hook-push bad-header-hook (lambda (hook) (set! (hook 'result) #t)))
	  
	  ;; dangling readers (overall)
	  (let* ((ind (open-sound "oboe.snd"))
		 (hi (make-sampler 0 ind 0)))
	    (close-sound ind)
	    (if (not (sampler? hi)) (snd-display "dangling reader? ~A" hi))
	    (let ((val (hi))
		  (val1 (next-sample hi))
		  (val2 (previous-sample hi))
		  (val3 (read-sample hi)))
	      (if (or (fneq val 0.0) (fneq val1 0.0) (fneq val2 0.0) (fneq val3 0.0))
		  (snd-display "dangling read: ~A ~A ~A ~A" val val1 val2 val3)))
	    (if (sampler-home hi) (snd-display "dangling reader home: ~A" (sampler-home hi)))
	    (if (not (= (sampler-position hi) 0)) (snd-display "dangling sampler-position: ~A" (sampler-position hi)))
	    (if (not (sampler-at-end? hi)) (snd-display "dangling reader eof: ~A" (sampler-at-end? hi)))
	    (free-sampler hi))
	  ;; same (pruned edit)
	  (let ((ind (open-sound "oboe.snd")))
	    (delete-samples 100 100)
	    (let ((hi (make-sampler 0 ind 0)))
	      (revert-sound)
	      (delete-samples 100 100)
	      (if (not (sampler? hi)) (snd-display "pruned dangling reader? ~A" hi))
	      (let ((val (hi))
		    (val1 (next-sample hi))
		    (val2 (previous-sample hi))
		    (val3 (read-sample hi)))
		(if (or (fneq val 0.0) (fneq val1 0.0) (fneq val2 0.0) (fneq val3 0.0))
		    (snd-display "pruned dangling read: ~A ~A ~A ~A" val val1 val2 val3)))
	      (if (not (equal? (sampler-home hi) (list ind 0))) (snd-display "pruned dangling reader home: ~A" (sampler-home hi)))
	      (if (not (sampler-at-end? hi)) (snd-display "pruned dangling reader eof: ~A" (sampler-at-end? hi)))
	      (free-sampler hi))
	    (close-sound ind))
	  
	  ;; region reader
	  (let ((ind (open-sound "2.snd")))
	    (set! (sync ind) 1)
	    (let ((reg (make-region 90 220 ind #t)))
	      (if (not (= (region-framples reg) 131)) (snd-display "make-region framples: ~A" (region-framples reg)))
	      (if (not (= (region-chans reg) 2)) (snd-display "make-region chans: ~A" (region-chans reg)))
	      (if (not (= (region-framples reg 0) 131)) (snd-display "make-region framples[0]: ~A" (region-framples reg 0)))
	      (if (not (= (region-framples reg 1) 131)) (snd-display "make-region framples[1]: ~A" (region-framples reg 1)))
	      (if (not (= (region-position reg 0) 90)) (snd-display "make-region position[0]: ~A" (region-position reg 0)))
	      (if (not (= (region-position reg 1) 90)) (snd-display "make-region position[1]: ~A" (region-position reg 1)))
	      (if (not (= (region-position reg) 90)) (snd-display "make-region position[]: ~A" (region-position reg)))
	      
	      ;; beg = 0, chan 2 not highlighted
	      
	      (let ((rd1 (make-region-sampler reg 0 0))
		    (rd2 (make-region-sampler reg 100 1)))
		(let ((rd11 (copy-sampler rd1))
		      (rd22 (copy-sampler rd2)))
		  (if (not (and (region-sampler? rd11) (region-sampler? rd22)))
		      (snd-display "copy-sampler (region): ~A ~A" rd11 rd22))
		  (if (or (mix-sampler? rd11) (mix-sampler? rd22))
		      (snd-display "copy (region) sampler-p trouble: ~A ~A"
				   (mix-sampler? rd11) (mix-sampler? rd22)))
		  (if (not (and (equal? (sampler-home rd11) (list reg 0))
				(equal? (sampler-home rd22) (list reg 1))))
		      (snd-display "copy region reader home: ~A ~A" (sampler-home rd11) (sampler-home rd22)))
		  (if (or (sampler-at-end? rd11) (sampler-at-end? rd22))
		      (snd-display "copy region reader end?: ~A ~A" (sampler-at-end? rd11) (sampler-at-end? rd22)))
		  (if (not (and (= (sampler-position rd11) (sampler-position rd1) 0)
				(= (sampler-position rd22) (sampler-position rd2) 100)))
		      (snd-display "copy region reader position: ~A ~A ~A ~A" 
				   (sampler-position rd11) (sampler-position rd1)
				   (sampler-position rd22) (sampler-position rd2)))
		  (free-sampler rd1)
		  (free-sampler rd11))))
	    (close-sound ind))
	  
	  (let* ((ind (open-sound "oboe.snd"))
		 (reg (make-region 1000 2000 ind 0))
		 (rd (make-region-sampler reg 0)))
	    (if (mix-sampler? rd) (snd-display "region sampler: mix ~A" rd))
	    (if (not (region-sampler? rd)) (snd-display "region sampler: region ~A" rd))
	    (if (not (equal? (sampler-home rd) (list reg 0))) (snd-display "region sampler home: ~A" (sampler-home rd)))
	    (if (sampler-at-end? rd) (snd-display "region sampler at end?: ~A" (sampler-at-end? rd)))
	    (let ((val (rd)))
	      (if (fneq val .0328) (snd-display "region-sampler at start: ~A" val))
	      (close-sound ind)
	      (forget-region reg)
	      (set! val (read-sample rd))
	      (if (fneq val 0.0) (snd-display "region-sampler at end: ~A" val))
	      (if (not (sampler-at-end? rd)) (snd-display "region-sampler after deletion?"))
	      (free-sampler rd)))
	  
	  ;; mix reader
	  (mix-click-sets-amp)
	  (let* ((ind (open-sound "oboe.snd"))
		 (md (let ((reg (make-region 1000 2000 ind 0)))
		       (car (mix-region reg 0 ind 0 0))))
		 (rd (make-mix-sampler md)))
	    (set! (mix-property :hi md) "hi")
	    (if (not (string=? (mix-property :hi md) "hi")) (snd-display "mix(9)-property: ~A" (mix-property :hi md)))
	    (let ((val (rd)))
	      (if (fneq val .0328) (snd-display "mix-sampler at start: ~A" val)))
	    (close-sound ind)
	    (let ((tag (catch #t
			 (lambda () (mix-property :hi md))
			 (lambda args (car args)))))
	      (if (not (eq? tag 'no-such-mix)) (snd-display "mix-property bad mix: ~A" tag)))
	    (let ((str (object->string rd)))
	      (if (not (string=? str "#<mix-sampler: inactive>")) (snd-display "mix-sampler released: ~A" str))
	      (free-sampler rd)))
	  (set! (hook-functions mix-click-hook) ())
	  (set! (hook-functions close-hook) ())
	  
	  (let ((sfiles ())
		(ffiles ()))
	    (for-each-sound-file 
	     (lambda (file) 
	       (if (> (mus-sound-chans file) 16)
		   (set! ffiles (cons file ffiles)))))
	    (map-sound-files
	     (lambda (file) 
	       (if (> (mus-sound-chans file) 16)
		   (set! sfiles (cons file sfiles)))))
	    (if (and (file-exists? "s24.snd")
		     (not (and (equal? ffiles '("s24.snd"))
			       (equal? sfiles '("s24.snd")))))
		(snd-display "map|for-each-sound-file(s): ~A ~A" ffiles sfiles))))))))


;;; ---------------- test 13: menus, edit lists, hooks, etc ----------------

(if (and (provided? 'snd-motif) (provided? 'xm) (not (provided? 'snd-effects-utils.scm))) (load "effects-utils.scm"))
(if (and (provided? 'snd-motif) (provided? 'xm) (not (provided? 'snd-new-effects.scm))) (load "new-effects.scm"))
(if (and (provided? 'snd-gtk) (provided? 'xg) (not (provided? 'snd-gtk-effects.scm))) (load "gtk-effects.scm"))

(when (provided? 'snd-ladspa)
  (define (analyze-ladspa library label)
    (let* ((descriptor (ladspa-descriptor library label))
	   (data ())
	   (names (.PortNames descriptor))
	   (hints (.PortRangeHints descriptor))
	   (descriptors (.PortDescriptors descriptor))
	   (name (.Name descriptor))
	   (maker (.Maker descriptor))
	   (copy (.Copyright descriptor)))
      (for-each
       (lambda (port ranges port-name)
	 (unless (or (= (logand port LADSPA_PORT_CONTROL) 0)
		     (= (logand port LADSPA_PORT_INPUT) 0))
	   (let ((ldata ())
		 (hint (car ranges))
		 (lo (cadr ranges))
		 (hi (caddr ranges)))
	     (if (not (= (logand hint LADSPA_HINT_TOGGLED) 0)) (set! ldata (cons "toggle" ldata)))
	     (if (not (= (logand hint LADSPA_HINT_LOGARITHMIC) 0)) (set! ldata (cons "logarithmic" ldata)))
	     (if (not (= (logand hint LADSPA_HINT_INTEGER) 0)) (set! ldata (cons "integer" ldata)))
	     (if (not (= (logand hint LADSPA_HINT_SAMPLE_RATE) 0)) (set! ldata (cons "sample_rate" ldata)))
	     (if (not (= (logand hint LADSPA_HINT_BOUNDED_ABOVE) 0)) 
		 (set! ldata (cons "maximum" (cons hi ldata))))
	     (if (not (= (logand hint LADSPA_HINT_BOUNDED_BELOW) 0) )
		 (set! ldata (cons "minimum" (cons lo ldata))))
	     (set! data (cons (cons port-name ldata) data)))))
       descriptors hints names)
      (append (list name maker copy) data)))

  (define* (ladspa-it library label :rest plugin-parameters)
    ;; (ladspa-it "delay" "delay_5s" .3 .5)
    (init-ladspa)
    (let ((descriptor (ladspa-descriptor library label))
	  (block-size 256))
      (let ((handle (ladspa-instantiate descriptor (srate)))
	    (in-block (make-float-vector block-size))
	    (out-block (make-float-vector block-size))
	    (len (framples)))
	(let ((ra (ladspa-run-adding descriptor handle block-size)))
	  (if ra (snd-display "ladspa-run-adding: ~A" ra)))
	(ladspa-set-run-adding-gain descriptor handle block-size)
	(dynamic-wind
	    (lambda ()
	      (let ((count 0))
		(for-each 
		 (lambda (port)
		   (if (= (logand port LADSPA_PORT_CONTROL) 0)
		       (ladspa-connect-port descriptor handle count (if (not (= (logand port LADSPA_PORT_INPUT) 0)) in-block out-block))
		       (let ((parameter (make-float-vector 1 (car plugin-parameters))))
			 (set! plugin-parameters (cdr plugin-parameters))
			 (ladspa-connect-port descriptor handle count parameter)))
		   (set! count (+ 1 count)))
		 (.PortDescriptors descriptor))))
	    (lambda ()
	      (ladspa-activate descriptor handle)
	      (catch #t
		(lambda ()
		  (do ((i 0 (+ i block-size)))
		      ((>= i len))
		    (set! in-block (channel->float-vector i block-size))
		    (ladspa-run descriptor handle block-size)
		    ;; here do something with the data
		    ))
		(lambda args (snd-display "ladspa-it: ~A" args))))
	    (lambda ()
	      (ladspa-deactivate descriptor handle)
	      (ladspa-cleanup descriptor handle)))))))


(define snd_test_13
  (let ((ladspa_inited #f)
	(clm_buffer_added #f)
    
	(test-hooks (lambda ()
		      (reset-all-hooks)
		      (for-each 
		       (lambda (n) 
			 (if (pair? (hook-functions n))
			     (snd-display "~A not empty?" n)))
		       (snd-hooks))))
  
	(test-menus (lambda ()
		      (if (provided? 'xm)
			  (for-each-child
			   (car (menu-widgets))
			   (lambda (w)
			     (if (not ((*motif* 'XmIsRowColumn) w))
				 (let ((option-holder (cadr ((*motif* 'XtGetValues) w (list (*motif* 'XmNsubMenuId) 0)))))
				   (for-each-child
				    option-holder
				    (lambda (menu)
				      (if (and ((*motif* 'XmIsPushButton) menu)
					       ((*motif* 'XtIsManaged) menu)
					       ((*motif* 'XtIsSensitive) menu)
					       (not (member ((*motif* 'XtName) menu)
							    '("Exit" "New" 
							      "Save   C-x C-s" 
							      "Close  C-x k"
							      "Close all"
							      "Save current settings"
							      "Mixes" "clm" "fm-violin"))))
					  ((*motif* 'XtCallCallbacks) menu (*motif* 'XmNactivateCallback) (snd-global-state))))))))))
		      (for-each close-sound (sounds))
		      (dismiss-all-dialogs))))
  (lambda () ; snd_test_13
    
    (do ((clm-test 0 (+ clm-test 1)))
	((>= clm-test tests))
      (reset-all-hooks)
      
      (let ((fd (view-sound "oboe.snd")))
	(if with-gui
	    (let ((mb #f))
	      (if (not clm_buffer_added)
		  (set! mb (add-to-main-menu "clm")))
	      
	      (let ((var (catch #t (lambda () (add-to-menu -1 "fm-violin" (lambda () #f))) (lambda args args))))
		(if (not (eq? (car var) 'no-such-menu))
		    (snd-display "add-to-menu bad menu: ~A" var)))
	      (set! (cursor fd) 2000)
	      (set! *transform-graph-type* graph-once)
	      (set! (transform-graph? fd) #t)
	      (unless clm_buffer_added
		(add-to-menu mb "not here" (lambda () (snd-display "oops")))
		(remove-from-menu mb "not here")
		(add-to-menu 3 "Denoise" (lambda () (status-report "denoise"))))
	      (set! clm_buffer_added #t)))
	
	(set! (hook-functions help-hook) ())
	(let ((hi (snd-help 'cursor-position)))
	  (hook-push help-hook (lambda (hook)
				 (let ((a (hook (list-ref (hook 'hook-args) 0))) ; this is a bad idea!  we're depending on the make-hook arg name
				       (b (hook (list-ref (hook 'hook-args) 1))))
				   (if (not (string=? a "cursor-position"))
				       (snd-display "help-hook subject: ~A" a))
				   (if (not (string=? b "(cursor-position :optional snd chn): current cursor position (x y in pixels) in snd's channel chn"))
				       (snd-display "help-hook text: ~A" b))
				   (set! (hook 'result) (string-append "hiho:" b)))))
	  (let ((ho (snd-help 'cursor-position)))
	    (if (not (= (length ho) (+ 5 (length hi))))
		(snd-display "help-hook ~A -> ~A" hi ho))
	    (set! (hook-functions help-hook) ())
	    (hook-push help-hook (lambda (hook) (set! (hook 'result) #f)))
	    (set! ho (snd-help 'cursor-position))
	    (if (not (string=? hi ho))
		(snd-display "help-hook #f: ~A ~A" hi ho))
	    (set! (hook-functions help-hook) ())))
	(set! (transform-size fd 0) 256)
	(when with-motif
	  (for-each
	   (lambda (dpy-type fft-type)
	     (set! (transform-graph-type fd 0) dpy-type)
	     (set! (transform-type fd 0) fft-type)
	     (update-transform-graph fd 0)
	     (let ((vals (transform->float-vector fd 0)))
	       (if (not vals) 
		   (snd-display "transform graph-type: ~A type: ~A -> data: ~A" dpy-type fft-type vals)
		   (begin
		     (if (fneq (transform-sample 0 0 fd 0) (vals 0))
			 (snd-display "transform-sample ~A ~A -> ~A ~A" dpy-type fft-type (vals 0) (transform-sample 0 0 fd 0)))
		     (if (< (length vals) 256)
			 (snd-display "transform-> float-vector size: ~A" (length vals)))))))
	   (list graph-once graph-as-sonogram graph-as-spectrogram
		 graph-once graph-as-sonogram graph-as-spectrogram)
	   (list fourier-transform fourier-transform fourier-transform 
		 autocorrelation autocorrelation autocorrelation)))
	(when with-gui
	  (let ((tag (catch #t
		       (lambda ()
			 (transform-sample 5000 0 fd 0))
		       (lambda args (car args)))))
	    (if (not (eq? tag 'no-such-sample))
		(snd-display "access invalid (bin) transform sample: ~A" tag))))
	(close-sound fd))
      (set! *transform-type* fourier-transform)
      
      (hook-push after-open-hook
		 (lambda (hook)
		   (set! (x-axis-style (hook 'snd) #t) x-axis-in-samples)))
      (close-sound (open-sound "2.snd"))
      (set! (hook-functions after-open-hook) ())
      
      (hook-push after-open-hook
		 (lambda (hook)
		   (set! (x-axis-style (hook 'snd) #t) x-axis-as-percentage)))
      (hook-push initial-graph-hook
		 (lambda (hook)
		   (let ((snd (file-name (hook 'snd)))
			 (chn (hook 'chn))
			 (dur (hook 'duration)))
		     (if (mus-sound-maxamp-exists? snd)
			 (let ((max-val ((mus-sound-maxamp snd) (+ (* chn 2) 1)))) ; implicit index
			   (set! (hook 'result) (list 0.0 dur (- max-val) max-val)))
			 (set! (hook 'result) (list 0.0 dur -1.0 1.0))))))
      (set! (hook-functions after-open-hook) ())
      (set! (hook-functions initial-graph-hook) ())
      
      (hook-push initial-graph-hook
		 (lambda (hook)
		   (set! (hook 'result) (list 0.0 (hook 'duration) -1.0 1.0 "a label" -4.0 4.0))))
      (let ((fd (open-sound "2.snd")))
	(let ((ax (axis-info)))
	  (if (and (pair? ax)
		   (or (fneq (ax 2) 0.0)
		       (fneq (ax 3) -1.0)
		       (fneq (ax 4) (mus-sound-duration "2.snd"))
		       (fneq (ax 5) 1.0)
		       (fneq (ax 6) 0.0)
		       (fneq (ax 7) -4.0)
		       (fneq (ax 8) (mus-sound-duration "2.snd"))
		       (fneq (ax 9) 4.0)))
	      (snd-display "initial-graph-hook with ymin/max: ~A" ax))
	  (set! (hook-functions initial-graph-hook) ()))
	(set! (selection-position fd 1) 1000)
	(set! (selection-framples fd 1) 10)
	(set! (selection-member? fd 1) #t)
	(if (selection-member? fd 0) (snd-display "chan 0 is selection-member?"))
	(do ((i 0 (+ i 1))) ((= i 2))
	  (set! (selection-position fd i) 1000)
	  (set! (selection-framples fd i) 10)
	  (set! (selection-member? fd i) #t))
	(scale-selection-to #r(.5 .25))
	(if (or (fneq (maxamp fd 0) .5)
		(fneq (maxamp fd 1) .25))
	    (snd-display "scale-selection-to with vector: ~A" (maxamp fd #t)))
	(close-sound fd))
      
      (let ((fd (open-sound "obtest.snd")))
	(set! (hook-functions close-hook) ())
	(set! *with-background-processes* #t)
	(let ((added 0))
	  (hook-push new-widget-hook
		     (lambda (hook)
		       (set! added (+ added 1)))))
	(if (provided? 'snd-motif)
	    (without-errors
	     (test-menus)))
	(dismiss-all-dialogs)
	(set! (hook-functions close-hook) ())
	(for-each close-sound (sounds))
	(when (sound? fd) 
	  (snd-display "close all didn't? ~A ~A ~A ~A ~A" fd (sound? fd) (short-file-name fd) (hook-functions close-hook) (sounds))
	  (close-sound fd)))
      
      (let ((fd (open-sound "obtest.snd")))
	(set! *with-background-processes* #f)
	(set! (hook-functions new-widget-hook) ())
	
	(when (and (not ladspa_inited)
		   (provided? 'snd-ladspa)
		   (file-exists? "/home/bil/test/ladspa/ladspa_sdk/plugins"))
	  (set! ladspa_inited #t)
	  (set! *ladspa-dir* "/home/bil/test/ladspa/ladspa_sdk/plugins")
	  (init-ladspa)
	  (let* ((ptr (ladspa-descriptor "delay" "delay_5s"))
		 (label (.Label ptr))
		 (name (.Name ptr))
		 (copy (.Copyright ptr))
		 (maker (.Maker ptr))
		 (props (.Properties ptr))
		 (id (.UniqueID ptr))
		 (names (.PortNames ptr))
		 (hints (.PortRangeHints ptr))
		 (count (.PortCount ptr))
		 (descs (.PortDescriptors ptr)))
	    (if (not (string=? label "delay_5s")) 
		(snd-display "ladspa .Label: ~A" label))
	    (if (not (string=? name "Simple Delay Line")) 
		(snd-display "ladspa .Name: ~A" name))
	    (if (not (string=? maker "Richard Furse (LADSPA example plugins)"))
		(snd-display "ladspa .Maker: ~A" maker))
	    (if (not (string=? copy "None"))
		(snd-display "ladspa .Copyright: ~A" copy))
	    (if (not (= id 1043)) (snd-display "ladspa .UniqueID: ~A" id))
	    (if (not (= count 4)) (snd-display "ladspa .PortCount: ~A" count))
	    (if (not (= props 4)) (snd-display "ladspa .Properties: ~A" prop))
	    (if (not (equal? names '("Delay (Seconds)" "Dry/Wet Balance" "Input" "Output")))
		(snd-display "ladspa .PortNames: ~A" names))
	    (if (not (equal? hints '((579 0.0 5.0) (195 0.0 1.0) (0 0.0 0.0) (0 0.0 0.0))))
		(snd-display "ladspa .PortRangeHints: ~A" hints))
	    (if (not (equal? descs '(5 5 9 10)))
		(snd-display "ladspa .PortDescriptors: ~A" descs))
	    (if (not (= (logand (cadr (.PortDescriptors ptr)) LADSPA_PORT_INPUT) 1))
		(snd-display "ladspa port hint: ~A" (logand (cadr (.PortDescriptors ptr)) LADSPA_PORT_INPUT))))
	  (apply-ladspa (make-sampler 0) (list "delay" "delay_5s" .3 .5) 1000 "delayed")
	  (if (not (equal? (analyze-ladspa "delay" "delay_5s")
			   '("Simple Delay Line" "Richard Furse (LADSPA example plugins)" 
			     "None" 
			     ("Dry/Wet Balance" "minimum" 0.0 "maximum" 1.0) 
			     ("Delay (Seconds)" "minimum" 0.0 "maximum" 5.0))))
	      (snd-display "analyze-ladspa: ~A" (analyze-ladspa "delay" "delay_5s")))
	  (ladspa-it "delay" "delay_5s" .3 .5)
	  (if (provided? 'xm)
	      (let ((w ((menu-widgets) 5)))
		(if (and (list? w)
			 (not (XmIsRowColumn w)))
		    (let ((option-holder (cadr (XtGetValues w (list XmNsubMenuId 0)))))
		      (for-each-child
		       option-holder
		       (lambda (menu)
			 (if (and (XmIsPushButton menu)
				  (XtIsSensitive menu)
				  (string=? (XtName menu) "Plugins"))
			     (XtCallCallbacks menu XmNactivateCallback (snd-global-state)))))))))
	  (dismiss-all-dialogs)
	  (let ((tag (catch #t 
		       (lambda () 
			 (apply-ladspa (make-sampler 0) (list "delay" "delay_4s" .3 .5) 1000 "delayed"))
		       (lambda args args))))
	    (if (not (eq? (car tag) 'no-such-plugin))
		(snd-display "apply-ladspa bad plugin: ~A" tag)))
	  (let ((tag (catch #t 
		       (lambda () 
			 (apply-ladspa (list (make-sampler 0) (make-sampler 0)) (list "delay" "delay_5s" .3 .5) 1000 "delayed"))
		       (lambda args args))))
	    (if (not (eq? (car tag) 'plugin-error))
		(snd-display "apply-ladspa reader mismatch: ~A" tag)))
	  (let ((vals (list-ladspa)))
	    (if (not (pair? vals))
		(snd-display "ladspa list: ~A" vals))
	    (let ((descr (analyse-ladspa "delay" "delay_5s")))
	      (if (not (and (pair? descr)
			    (string? (car descr))
			    (string=? (car descr) "Simple Delay Line")))
		  (snd-display "analyse-ladspa: ~A" descr))))
	  (let ((tag (catch #t 
		       (lambda () (analyse-ladspa "delay" "delay_no_delay"))
		       (lambda args (car args)))))
	    (if (not (eq? tag 'no-such-plugin)) (snd-display "analyse-ladspa tag: ~A" tag)))
	  (let ((tag (catch #t
		       (lambda ()
			 (apply-ladspa (list (make-sampler 0) (make-sampler 0)) (list #f) 1000 "delayed"))
		       (lambda args (car args)))))
	    (if (not (eq? tag 'wrong-type-arg)) (snd-display "apply-ladspa tag: ~A" tag)))
	  
	  (set! *ladspa-dir* "/home/bil/test/ladspa/vocoder-0.3")
	  (init-ladspa)
	  (if (not (equal? (list-ladspa) '(("vocoder" "vocoder"))))
	      (snd-display "list-ladspa vocoder: ~A" (list-ladspa)))
	  (if (not (list? (analyze-ladspa "vocoder" "vocoder")))
	      (snd-display "analyze-ladspa vocoder: ~A" (analyze-ladspa "vocoder" "vocoder")))
	  (let ((hi (ladspa-descriptor "vocoder" "vocoder")))
	    (if (not (string=? (.Name hi) "Vocoder"))
		(snd-display "ladspa vocoder name: ~A" (.Name hi))))
	  
	  (let ((snd (open-sound "1a.snd")))
	    (apply-ladspa (list (make-sampler 0) (make-sampler 0)) 
			  (list "vocoder" "vocoder" 12 .5 .5 .5 .5 .5 .5 .5 .5 .5 .5 .5 .5 .5 .5 .5 .5) 
			  (framples) "vocoder")
	    (undo)
	    
	    (set! *ladspa-dir* "/home/bil/test/ladspa/lib/ladspa")
	    (init-ladspa)
	    (for-each (lambda (plug) (apply analyse-ladspa plug)) (list-ladspa))
	    
	    (if (not (list? (analyse-ladspa "amp_1181" "amp")))
		(snd-display "analyze-ladspa can't find amp_1181"))
	    
	    (apply-ladspa (make-sampler 0) (list "amp_1181" "amp" -6) (framples) "amp")
	    (apply-ladspa (make-sampler 0) (list "amp_1181" "amp" 6) (framples) "amp")
	    (close-sound snd))
	  
	  (let ((snd (open-sound "2a.snd")))
	    
	    (let ((tag 
		   (catch #t
		     (lambda ()
		       (apply-ladspa (list (make-sampler 0 snd 0) (make-sampler 0 snd 1)) 
				     (list "amp_1181" "amp" 6 -6) (framples) "amp"))
		     (lambda args (car args)))))
	      (if (not (eq? tag 'plugin-error))
		  (snd-display "apply-ladspa bad inputs: ~A" tag)))
	    
	    (apply-ladspa (list (make-sampler 0 snd 0) (make-sampler 0 snd 0)) 
			  (list "ringmod_1188" "ringmod_2i1o" 1) (framples) "ringmod")
	    (apply-ladspa #f (list "analogue_osc_1416" "analogueOsc" 2 440.0 0.1 0.0) (framples) "osc")
	    (apply-ladspa #f (list "sin_cos_1881" "sinCos" 440.0 1.0) (framples) "sincos")
	    (apply-ladspa (list (make-sampler 0 snd 0) (make-sampler 0 snd 1)) 
			  (list "dj_eq_1901" "dj_eq" -6 0 6) (framples) "djeq")
	    (close-sound snd)))
	
	(revert-sound fd)
	(close-sound fd))
      (for-each close-sound (sounds))
      
      (test-hooks)
      (hook-push bad-header-hook (lambda (hook) (set! (hook 'result) #t)))
      (when with-gui
	(let ((ind (open-sound "oboe.snd")))
	  (set! (cursor) 2000)
	  (key (char->integer #\u) 4 ind)
	  (key (char->integer #\1) 0 ind)
	  (key (char->integer #\0) 0 ind)
	  (key (char->integer #\0) 0 ind)
	  (key (char->integer #\x) 4 ind)
	  (key (char->integer #\z) 4 ind)
	  (if (not (equal? (edit-fragment) '("smooth-channel 2000 100" "set" 2000 100)))
	      (snd-display "C-x C-z fragment: ~A" (edit-fragment)))
	  (if (not (mus-arrays-equal? (channel->float-vector 2010 10) #r(0.064 0.063 0.063 0.062 0.062 0.061 0.060 0.059 0.059 0.058)))
	      (snd-display "C-x C-z samps: ~A" (channel->float-vector 2010 10)))
	  (set! (cursor) 0)
	  (select-all)
	  (key (char->integer #\x) 4 ind)
	  (key (char->integer #\o) 0 ind)
	  (key (char->integer #\-) 4 ind)
	  (key (char->integer #\x) 4 ind)
	  (key (char->integer #\o) 0 ind)
	  (key (char->integer #\x) 4 ind)
	  (key (char->integer #\o) 0 ind)
	  (key (char->integer #\x) 4 ind)
	  (key (char->integer #\p) 0 ind)
	  (set! (selection-member? #t) #f)
	  (revert-sound ind)
	  (set! (search-procedure) (lambda (n4) (> n4 .1)))
	  (key (char->integer #\a) 4 ind 0)
	  (if (not (= (cursor ind 0) 0))
	      (snd-display "C-a cursor: ~D?" (cursor ind 0)))
	  (key (char->integer #\s) 4 ind 0)
	  (key (char->integer #\s) 4 ind 0)
	  (if (not (= (cursor ind 0) 4423))
	      (snd-display "search-procedure C-s C-s cursor: ~D?" (cursor ind 0)))
	  (let ((str (object->string (procedure-source (search-procedure)) #f)))
	    (if (not (string=? str "(lambda (n4) (> n4 0.1))"))
		(snd-display "search-procedure: ~A?" str)))
	  
	  (set! (search-procedure) (lambda (n) (> n .2)))
	  (set! (cursor ind 0) 0)
	  (key (char->integer #\s) 4 ind 0)
	  (key (char->integer #\s) 4 ind 0)
	  (if (not (= (cursor ind 0) 0))
	      (snd-display "search-procedure C-s C-s cursor failed: ~D?" (cursor ind 0)))
	  (let ((str (object->string (procedure-source (search-procedure)) #f)))
	    (if (not (string=? str "(lambda (n) (> n 0.2))"))
		(snd-display "search-procedure (1): ~A?" str)))
	  
	  (set! (hook-functions (edit-hook ind 0)) ())
	  (hook-push (edit-hook ind 0) (lambda (hook) (set! (hook 'result) #f)))
	  (let ((str (object->string (map procedure-source (hook-functions (edit-hook ind 0))) #f)))
	    (if (not (string=? str "((lambda (hook) (set! (hook 'result) #f)))"))
		(snd-display "edit-hook: ~A?" str)))
	  (set! (hook-functions (edit-hook ind 0)) ())
	  (set! (hook-functions (after-edit-hook ind 0)) ())
	  (hook-push (after-edit-hook ind 0) (lambda (hook) (set! (hook 'result) #f)))
	  (let ((str (object->string (map procedure-source (hook-functions (after-edit-hook ind 0))) #f)))
	    (if (not (string=? str "((lambda (hook) (set! (hook 'result) #f)))"))
		(snd-display "after-edit-hook: ~A?" str)))
	  (set! (hook-functions (after-edit-hook ind 0)) ())
	  (set! (hook-functions (undo-hook ind 0)) ())
	  (hook-push (undo-hook ind 0) (lambda (hook) (set! (hook 'result) #f)))
	  (let ((str (object->string (map procedure-source (hook-functions (undo-hook ind 0))) #f)))
	    (if (not (string=? str "((lambda (hook) (set! (hook 'result) #f)))"))
		(snd-display "undo-hook: ~A?" str)))
	  (set! (hook-functions (undo-hook ind 0)) ())
	  (let ((calls 0))
	    (hook-push (undo-hook ind 0) (lambda (hook) (set! calls (+ 1 calls))))
	    (delete-sample 0 ind 0)
	    (undo 1)
	    (redo 1)
	    (revert-sound ind)
	    (if (not (= calls 3)) (snd-display "undo-hook called ~A times" calls)))
	  (set! (hook-functions (undo-hook ind 0)) ())
	  (set! (search-procedure) #f)
	  (close-sound ind)))
      
      (if (pair? (hook-functions open-raw-sound-hook)) (set! (hook-functions open-raw-sound-hook) ()))
      (hook-push open-raw-sound-hook (lambda (hook) (set! (hook 'result) (list 1 22050 mus-bshort))))
      (let ((ind (open-sound "~/sf1/addf8.nh")))
	(play ind :wait #t)
	(set! (hook-functions open-raw-sound-hook) ())
	(if (not (and (= (chans ind) 1)
		      (= (srate ind) 22050)
		      (= (sample-type ind) mus-bshort)
		      (= (framples ind) 23808)))
	    (snd-display "open-raw: ~A ~A ~A ~A" 
			 (chans ind) (srate ind) (sample-type ind) (framples ind)))
	(set! (search-procedure) (lambda (n) (> n .2)))
	(close-sound ind))
      
      (let ((save-as-name "hiho"))
	(set! (hook-functions after-save-as-hook) ())
	(let ((save-as-dialog #t))
	  (hook-push after-save-as-hook 
		     (lambda (hook)
		       (let ((ind (hook 'snd))
			     (name (hook 'name))
			     (dial (hook 'dialog)))
			 (set! save-as-name name)
			 (set! save-as-dialog dial))))
	  (let ((ind (open-sound "oboe.snd")))
	    (save-sound-as "test.snd" ind :header-type mus-raw)
	    (close-sound ind))
	  (set! (hook-functions open-raw-sound-hook) ())
	  (set! (hook-functions after-save-as-hook) ())
	  (if save-as-dialog (snd-display "after-save-as-hook dialog: ~A" save-as-dialog)))
	(if (not (or (string=? (string-append home-dir "/cl/test.snd") save-as-name) 
		     (string=? (string-append home-dir "/snd-18/test.snd") save-as-name)))
	    (snd-display "after-save-as-hook name: ~A (~A)" save-as-name (string-append home-dir "/cl/test.snd"))))
      (hook-push open-raw-sound-hook 
		 (lambda (hook)
		   (let ((file (hook 'name))
			 (choice (hook 'state)))
		     (if (not (string=? (substring file (- (length file) 8)) "test.snd"))
			 (snd-display "open-raw-sound-hook file: ~A?" (substring file (- (length file) 8))))
		     (if choice
			 (snd-display "open-raw-sound-hook choice: ~A?" choice))
		     (set! (hook 'result) (list 2 44100 mus-mulaw)))))
      
      (let ((ind (open-sound "test.snd")))
	(if (not (and (= (header-type ind) mus-raw)
		      (= (sample-type ind) mus-mulaw)
		      (= (chans ind) 2)
		      (= (srate ind) 44100)
		      (= (framples ind) 50828)))
	    (snd-display "open-raw-sound-hook 1: ~A ~A ~A ~A ~A" 
			 (header-type ind) (sample-type ind) (chans ind) (srate ind) (framples ind)))
	(close-sound ind))
      
      (hook-append open-raw-sound-hook
		   (lambda (hook)
		     (if (not (equal? (hook 'name) "/home/bil/cl/test.snd"))
			 (snd-display "open-raw-sound-hook 2: ~A" (hook 'name)))
		     (set! (hook 'result) (list 1 22050 mus-lint))))
      
      (let ((ind (open-sound "test.snd")))
	(if (not (and (= (header-type ind) mus-raw)
		      (= (sample-type ind) mus-lint)
		      (= (chans ind) 1)
		      (= (srate ind) 22050)
		      (= (framples ind) 25414))) ;(/ 50828 2)
	    (snd-display "open-raw-sound-hook 3: ~A ~A ~A ~A ~A" 
			 (header-type ind) (sample-type ind) (chans ind) (srate ind) (framples ind)))
	(close-sound ind))
      
      (set! (hook-functions open-raw-sound-hook) ())
      (hook-push open-raw-sound-hook 
		 (lambda (hook)
		   (set! (hook 'result) (list 2))))
      
      (let ((ind (open-sound "test.snd")))
	(if (not (and (= (header-type ind) mus-raw)
		      (= (sample-type ind) mus-lint)
		      (= (chans ind) 2)
		      (= (srate ind) 22050)))
	    (snd-display "open-raw-sound-hook 4: ~A ~A ~A ~A"
			 (header-type ind) (sample-type ind) (chans ind) (srate ind)))
	(close-sound ind))
      
      (set! (hook-functions open-raw-sound-hook) ())
      (hook-push open-raw-sound-hook 
		 (lambda (hook)
		   (set! (hook 'result) (list 1 22050 mus-bshort 120 320))))
      (let ((ind (open-sound "test.snd")))
	(if (not (and (= (header-type ind) mus-raw)
		      (= (sample-type ind) mus-bshort)
		      (= (chans ind) 1)
		      (= (srate ind) 22050)
		      (= (data-location ind) 120)
		      (= (data-size ind) 320)
		      (= (framples ind) 160)))
	    (snd-display "open-raw-sound-hook 5: ~A ~A ~A ~A ~A ~A ~A" 
			 (header-type ind) (sample-type ind) (chans ind) (srate ind)
			 (data-location ind) (data-size ind) (/ (framples ind) 2)))
	(close-sound ind))
      (set! (hook-functions open-raw-sound-hook) ())
      (set! (hook-functions during-open-hook) ())
      
      (let ((ind #f))
	(let ((op #f)
	      (aop #f)
	      (dop #f)
	      (ig #f))
	  (hook-push open-hook 
		     (lambda (hook)
		       (let ((filename (hook 'name)))
			 (if (not (string=? filename (mus-expand-filename "oboe.snd")))
			     (snd-display "open-hook: ~A?" filename))
			 (set! op #t)
			 (set! (hook 'result) #f))))
	  (hook-push after-open-hook 
		     (lambda (hook)
		       (set! aop (hook 'snd))))
	  (hook-push during-open-hook 
		     (lambda (hook)
		       (let ((filename (hook 'name))
			     (reason (hook 'reason)))
			 (set! dop #t)
			 (if (not (string=? filename (mus-expand-filename "oboe.snd")))
			     (snd-display "during-open-hook filename: ~A?" filename))
			 (if (not (= reason 1))
			     (snd-display "during-open-hook reason: ~A?" reason)))))
	  (hook-push initial-graph-hook
		     (lambda (hook)
		       (if (not (= (hook 'chn) 0))
			   (snd-display "initial-graph-hook (channel): ~A not 0?" (hook 'chn)))
		       (set! ig #t)
		       (set! (hook 'result) #f)))
	  (set! ind (open-sound "oboe.snd"))
	  (if (not op) (snd-display "open-hook not called?"))
	  (if (not dop) (snd-display "during-open-hook not called?"))
	  (when (and with-gui (not ig)) (snd-display "initial-graph-hook not called?"))
	  (if (not (sound? aop)) (snd-display "after-open-hook not called?"))
	  (if (not (equal? aop ind)) (snd-display "after-open-hook ~A but ind: ~A?" aop ind)))
	
	(select-all)
	(set! (hook-functions open-hook) ())
	(set! (hook-functions during-open-hook) ())
	(set! (hook-functions after-open-hook) ())
	(set! (hook-functions initial-graph-hook) ())
	
	(hook-push open-hook (lambda (hook) (set! (hook 'result) #t)))
	(let ((pistol (open-sound "pistol.snd")))
	  (when pistol
	    (snd-display "open-hook #t, but open-sound -> ~A" pistol)
	    (if (sound? pistol) (close-sound pistol))))
	(set! (hook-functions open-hook) ())
	
	(let ((gr #f)
	      (agr #f)
	      (gbf #f)
	      (abf #f))
	  (set! (hook-functions before-transform-hook) ())
	  (set! (hook-functions after-transform-hook) ())
	  (set! (hook-functions after-graph-hook) ())
	  (set! (hook-functions graph-hook) ())
	  (hook-push graph-hook
		     (lambda (hook)
		       (let ((snd (hook 'snd))
			     (chn (hook 'chn)))
			 (if (not (equal? snd ind))
			     (snd-display "graph-hook: ~A not ~A?" snd ind))
			 (if (not (= chn 0))
			     (snd-display "graph-hook (channel): ~A not 0?" chn)))
		       (set! gr #t)
		       (set! (hook 'result) #f)))
	  (hook-push after-graph-hook
		     (lambda (hook)
		       (let ((snd (hook 'snd))
			     (chn (hook 'chn)))
			 (if (not (equal? snd ind))
			     (snd-display "after-graph-hook: ~A not ~A?" snd ind))
			 (if (not (= chn 0))
			     (snd-display "after-graph-hook (channel): ~A not 0?" chn)))
		       (set! agr #t)))
	  (hook-push before-transform-hook
		     (lambda (hook)
		       (set! gbf #t)
		       (set! (hook 'result) (cursor))))
	  (hook-push after-transform-hook
		     (lambda (hook)
		       (let ((snd (hook 'snd))
			     (chn (hook 'chn)))
			 (set! abf #t)
			 (if (and (transform-graph? snd chn) 
				  (= (transform-graph-type snd chn) graph-once))
			     (status-report 
			      (number->string (/ (* 2.0 (float-vector-peak (transform->float-vector snd chn)))
						 (transform-size snd chn)))
			      snd)
			     (set! (hook 'result) #f)))))
	  (set! (transform-graph? ind 0) #t)
	  (set! (time-graph? ind 0) #t)
	  (update-time-graph ind 0)
	  (update-transform-graph ind 0)
	  
	  (if (and (not gr)
		   (provided? 'snd-motif) 
		   (provided? 'xm))
	      (with-let (sublet *motif*)
		(do ((i 0 (+ i 1))
		     (happy #f)
		     (app (car (main-widgets))))
		    ((or happy (= i 1000)))
		  (let ((msk (XtAppPending app)))
		    (if (= (logand msk (logior XtIMXEvent XtIMAlternateInput)) 0)
			(set! happy #t)
			(XtDispatchEvent (XtAppNextEvent app)))))))
	  
	  (when with-gui
	    (if (not (or gr (provided? 'snd-gtk)))
		(snd-display "graph-hook not called? ~A ~A ~A ~A" (time-graph? ind) (short-file-name ind) ind (sounds)))
	    (if (not (or agr (provided? 'snd-gtk))) 
		(snd-display "after-graph-hook not called?"))
	    (if (not gbf) 
		(snd-display "before-transform-hook not called?"))
	    (if (not (or abf (provided? 'snd-gtk)))
		(snd-display "after-transform-hook not called?")))
	  (set! (hook-functions before-transform-hook) ())
	  (set! (transform-graph? ind 0) #f)
	  (set! (hook-functions graph-hook) ())
	  (set! (hook-functions after-graph-hook) ()))
	
	(let ((other (open-sound "pistol.snd")))
	  (let ((sl #f))
	    (hook-push select-sound-hook
		       (lambda (hook)
			 (if (not (equal? (hook 'snd) ind))
			     (snd-display "select-sound-hook: ~A not ~A?" (hook 'snd) ind))
			 (set! sl #t)))
	    (let ((scl #f))
	      (hook-push select-channel-hook 
			 (lambda (hook)
			   (let ((snd (hook 'snd)))
			     (if (not (equal? snd ind))
				 (snd-display "select-channel-hook: ~A not ~A?" snd ind)))
			   (let ((chn (hook 'chn)))
			     (if (not (= chn 0))
				 (snd-display "select-channel-hook (channel): ~A not 0?" chn)))
			   (set! scl #t)))
	      
	      (select-sound ind)
	      (if (not sl) (snd-display "select-sound-hook not called?"))
	      (if (not scl) (snd-display "select-channel-hook not called?"))))
	  (set! (hook-functions select-sound-hook) ())
	  (set! (hook-functions select-channel-hook) ())
	  
	  (let ((spl #f)
		(stl #f)
		(ph #f))
	    (hook-push start-playing-hook
		       (lambda (hook)
			 (if (not (equal? (hook 'snd) ind))
			     (snd-display "start-playing-hook: ~A not ~A?" (hook 'snd) ind))
			 (set! spl #t)
			 (set! (hook 'result) #f)))
	    (hook-push stop-playing-hook
		       (lambda (hook)
			 (if (not (equal? (hook 'snd) ind))
			     (snd-display "stop-playing-hook: ~A not ~A?" (hook 'snd) ind))
			 (set! stl #t)))
	    (hook-push play-hook
		       (lambda (hook)
			 (if (< (hook 'size) 128)
			     (snd-display "play-hook samps: ~A?" (hook 'size)))
			 (set! ph #t)))
	    
	    (set! (expand-control? ind) #t)
	    (set! (reverb-control? ind) #t)
	    (play ind :wait #t :end 1000)
	    (set! (reverb-control? ind) #f)
	    (set! (expand-control? ind) #f)
	    
	    (when with-gui
	      (if (not spl) (snd-display "start-playing-hook not called?"))
	      (if (not stl) (snd-display "stop-playing-hook not called?"))
	      (if (not ph) (snd-display "play-hook not called?")))
	    (set! (hook-functions start-playing-hook) ())
	    (set! (hook-functions start-playing-selection-hook) ())
	    (set! (hook-functions stop-playing-hook) ())
	    (set! (hook-functions play-hook) ())
	    
	    (hook-push play-hook
		       (lambda (hook)
			 (set! *expand-control-hop* .02)
			 (set! *expand-control-length* .02)
			 (set! *expand-control-ramp* .2)
			 (set! *contrast-control-amp* 0.5)
			 (set! *reverb-control-lowpass* .02)
			 (set! *reverb-control-feedback* .02)))
	    
	    (play ind :wait #t :end 1000)
	    (set! (hook-functions play-hook) ())
	    
	    (hook-push start-playing-hook (lambda (hook) (set! (hook 'result) #t)))
	    (play "4.aiff")
	    (set! (hook-functions start-playing-hook) ())
	    
	    (let ((ss #f))
	      (let-temporarily ((*selection-creates-region* #t))
		(hook-push stop-playing-selection-hook (lambda (hook) (set! ss #t)))
		(let ((reg (select-all)))
		  (play (selection) :wait #t)
		  (if (region? reg) (play reg :wait #t))
		  (if (not ss) (snd-display "stop-playing-selection-hook: ~A" ss)))
		(set! (hook-functions stop-playing-selection-hook) ())))
	    
	    (let ((pl (make-player ind 0)))
	      (free-player pl)
	      (if (player? pl) (snd-display "free-player: ~A" pl)))
	    
	    )
	  (let ((e0 #f)
		(e1 #f)
		(u0 #f)
		(u1 #f)
		(a0 #f)
		(a1 #f))
	    (hook-push (edit-hook ind 0) 
		       (lambda (hook)
			 (set! e0 #t)
			 (set! (hook 'result) #t)))
	    (hook-push (edit-hook other 0) 
		       (lambda (hook)
			 (set! e1 #t)
			 (set! (hook 'result) #f)))
	    (hook-push (undo-hook ind 0) 
		       (lambda (hook)
			 (set! u0 #t)))
	    (hook-push (undo-hook other 0) 
		       (lambda (hook)
			 (set! u1 #t)))
	    (hook-push (after-edit-hook ind 0)
		       (lambda (hook)
			 (set! a0 #t)))
	    (hook-push (after-edit-hook other 0)
		       (lambda (hook)
			 (set! a1 #t)))
	    
	    ;; edit of ind should be disallowed, but not other
	    (delete-sample 0 ind 0)
	    (if (not (= (edit-position ind 0) 0))
		(snd-display "edit-hook #t didn't disallow edit!"))
	    (if (not e0) (snd-display "edit-hook #t not called?"))
	    (if a0 (snd-display "after-edit-hook 0 called?"))
	    (undo 1 ind 0)
	    (if u0 (snd-display "undo-hook called?"))
	    
	    (delete-sample 0 other 0)
	    (if (not (= (edit-position other 0) 1))
		(snd-display "edit-hook #f didn't allow edit!"))
	    (if (not e1) (snd-display "edit-hook #f not called?"))
	    (if (not a1) (snd-display "after-edit-hook 1 not called?"))
	    (undo 1 other 0)
	    (if (not u1) (snd-display "undo-hook not called?"))
	    
	    (set! (hook-functions (edit-hook ind 0)) ())
	    (set! (hook-functions (edit-hook other 0)) ())
	    (set! (hook-functions (after-edit-hook ind 0)) ())
	    (set! (hook-functions (after-edit-hook other 0)) ())
	    (set! (hook-functions (undo-hook ind 0)) ())
	    (set! (hook-functions (undo-hook other 0)) ()))
	  
	  (let ((se #f)
		(sw #f)
		(me #f))
	    (hook-push snd-error-hook
		       (lambda (hook)
			 (set! se #t)
			 (set! (hook 'result) #t)))
	    (hook-push snd-warning-hook
		       (lambda (hook)
			 (set! sw #t)
			 (set! (hook 'result) #t)))
	    (hook-push mus-error-hook
		       (lambda (hook)
			 (set! me #t)
			 (set! (hook 'result) #t)))
	    
	    (snd-error "uhoh")
	    (snd-warning "hiho")
	    
	    (if (not se) (snd-display "snd-error-hook not called?"))
	    (if (not sw) (snd-display "snd-warning-hook not called?"))
	    (if (not me) (snd-display "mus-error-hook not called?"))
	    (set! (hook-functions snd-error-hook) ())
	    (set! (hook-functions snd-warning-hook) ())
	    (set! (hook-functions mus-error-hook) ())
	    (hook-push snd-error-hook
		       (lambda (hook)
			 (set! se (hook 'message))
			 (set! (hook 'result) #t)))
	    (snd-error "not an error")
	    
	    (if (not (equal? se "not an error"))
		(snd-display "snd-error-hook saw: ~A" se))
	    (set! (hook-functions snd-error-hook) ()))
	  
	  (hook-push before-exit-hook (lambda (hook) (set! (hook 'result) #t)))
	  (hook-push exit-hook (lambda (hook) #f))
	  (exit)
	  (set! (hook-functions exit-hook) ())
	  (set! (hook-functions before-exit-hook) ())
	  
	  (let ((sh #f))
	    (if (file-exists? "baddy.snd") (delete-file "baddy.snd"))
	    (hook-push save-hook
		       (lambda (hook)
			 (let ((snd (hook 'snd))
			       (filename (hook 'name)))
			   (if (not (equal? filename (mus-expand-filename "baddy.snd")))
			       (snd-display "save-hook filename: ~A?" filename))
			   (if (not (equal? snd ind))
			       (snd-display "save-hook snd: ~A ~A?" snd ind)))
			 (set! sh #t)
			 (set! (hook 'result) #t)))
	    (save-sound-as "baddy.snd" ind)
	    (if (not sh) (snd-display "save-hook not called?"))
	    (when (file-exists? "baddy.snd")
	      (snd-display "save-hook didn't cancel save?")
	      (delete-file "baddy.snd"))
	    (set! (hook-functions save-hook) ()))
	  
	  ;; after-transform-hooks require some way to force the fft to run to completion
	  ;; property-changed hook is similar (seems to happen whenever it's good and ready)
	  (let ((cl #f))
	    (hook-push close-hook
		       (lambda (hook)
			 (if (not (equal? (hook 'snd) ind))
			     (snd-display "close-hook: ~A not ~A?" (hook 'snd) ind))
			 (set! cl #t)))
	    
	    (close-sound ind)
	    (if (not cl) (snd-display "close-hook not called?")))
	  (set! (hook-functions close-hook) ())
	  (close-sound other)))
      
      (if (not (provided? 'alsa))
	  (let ((in1 (open-sound "oboe.snd"))
		(in2 (open-sound "2.snd")))
	    (set! (sync in1) 1)
	    (set! (sync in2) 1)
	    (play :with-sync #t :wait #t)
	    (close-sound in1)
	    (close-sound in2)))
      
      (let* ((ind (open-sound "oboe.snd"))
	     (all-tests (vector (list 'apply-controls 
				      (lambda () 
					(set! (amp-control ind 0) .5) 
					(apply-controls ind) 
					(set! (amp-control ind 0) 1.0)))
				(list 'clm-channel 
				      (lambda () 
					(clm-channel (make-two-zero 1 -1))))
				(list 'convolve-selection-with 
				      (lambda () 
					(let ((reg (select-all ind 0))) 
					  (convolve-selection-with "1a.snd" .5) 
					  (if (region? reg) (forget-region reg)))))
				(list 'convolve-with 
				      (lambda () 
					(convolve-with "1a.snd" 0.5 ind 0)))
				(list 'delete-mix 
				      (lambda () 
					(let ((mx (mix-float-vector (make-float-vector 3 .2) 123))) 
					  (if (mix? mx) (set! (mix-amp mx) 0.0)))))
				(list 'delete-sample 
				      (lambda () 
					(delete-sample 123 ind 0)))
				(list 'delete-samples 
				      (lambda () 
					(delete-samples 123 123 ind 0)))
				(list 'delete-selection 
				      (lambda () 
					(let ((reg (select-all ind 0))) 
					  (delete-selection) 
					  (if (region? reg) (forget-region reg)))))
				(list 'env-channel 
				      (lambda () 
					(env-channel '(0 0 1 1))))
				(list 'env-selection 
				      (lambda () 
					(let ((reg (select-all ind 0))) 
					  (env-selection '(0 0 1 1) 1.0) 
					  (if (region? reg) (forget-region reg)))))
				(list 'env-sound 
				      (lambda () 
					(env-sound '(0 0 1 1))))
				(list 'filter-sound 
				      (lambda () 
					(filter-sound '(0 1 1 0) 1024)))
				(list 'filter-selection 
				      (lambda () 
					(let ((reg (select-all ind 0))) 
					  (filter-selection '(0 0 1 1) 6) 
					  (if (region? reg) (forget-region reg)))))
				(list 'insert-region 
				      (lambda () 
					(let ((reg (make-region 0 100 ind 0))) 
					  (insert-region reg 123 ind 0) 
					  (if (region? reg) (forget-region reg)))))
				(list 'insert-sample 
				      (lambda () 
					(insert-sample 123 .5 ind 0)))
				(list 'insert-samples 
				      (lambda () 
					(insert-samples 123 3 (make-float-vector 3 1.0) ind 0)))
				(list 'insert-selection 
				      (lambda () 
					(let ((reg (select-all ind 0))) 
					  (insert-selection 120 ind 0) 
					  (if (region? reg) (forget-region reg)))))
				(list 'insert-silence 
				      (lambda () 
					(insert-silence 123 456 ind 0)))
				(list 'insert-sound 
				      (lambda () 
					(insert-sound "1a.snd" 123)))
				(list 'map-channel 
				      (lambda () 
					(map-channel (lambda (y) (+ y .2)))))
				(list 'map-channel 
				      (lambda () 
					(map-channel (lambda (y) (+ y .2)))))
				(list 'mix 
				      (lambda () 
					(mix "1a.snd" 123)))
				(list 'mix-amp 
				      (lambda () 
					(let ((mx (mix-float-vector (make-float-vector 3 1.0) 123))) 
					  (if (mix? mx) (set! (mix-amp mx) .123)))))
				(list 'mix-amp-env 
				      (lambda () 
					(let ((mx (mix-float-vector (make-float-vector 3 1.0) 123))) 
					  (if (mix? mx) (set! (mix-amp-env mx) '(0 0 1 1))))))
				(list 'mix-position 
				      (lambda () 
					(let ((mx (mix-float-vector (make-float-vector 3 1.0) 123))) 
					  (if (mix? mx) (set! (mix-position mx) 123)))))
				(list 'mix-speed 
				      (lambda () 
					(let ((mx (mix-float-vector (make-float-vector 3 1.0) 123))) 
					  (if (mix? mx) (set! (mix-speed mx) .123)))))
				(list 'mix-region 
				      (lambda () 
					(let ((reg (make-region 0 100 ind 0))) 
					  (mix-region reg 123 ind 0) 
					  (if (region? reg) (forget-region reg)))))
				(list 'mix-selection 
				      (lambda () 
					(let ((reg (select-all ind 0))) 
					  (mix-selection 1234 ind 0) 
					  (if (region? reg) (forget-region reg)))))
				(list 'mix-float-vector 
				      (lambda () 
					(mix-float-vector (make-float-vector 10 .3) 123)))
				(list 'pad-channel 
				      (lambda () 
					(pad-channel 123 456 ind 0)))
				(list 'ramp-channel 
				      (lambda () 
					(ramp-channel 0.0 0.5 123 456)))
				(list 'reverse-channel 
				      (lambda () 
					(reverse-channel 123 456 ind 0)))
				(list 'reverse-sound 
				      (lambda () 
					(reverse-sound ind 0)))
				(list 'reverse-selection 
				      (lambda () 
					(let ((reg (select-all ind 0))) 
					  (reverse-selection) 
					  (if (region? reg) (forget-region reg)))))
				(list 'scale-by 
				      (lambda () 
					(scale-by 2.0)))
				(list 'scale-channel 
				      (lambda () 
					(scale-channel .5 123 456 ind 0)))
				(list 'scale-selection-by 
				      (lambda () 
					(let ((reg (select-all ind 0)))
					  (scale-selection-by 2.0) 
					  (if (region? reg) (forget-region reg)))))
				(list 'scale-selection-to 
				      (lambda () 
					(let ((reg (select-all ind 0)))
					  (scale-selection-to 0.5) 
					  (if (region? reg) (forget-region reg)))))
				(list 'scale-to 
				      (lambda () 
					(scale-to 0.4)))
				(list 'scale-sound-to 
				      (lambda () 
					(scale-sound-to 0.5)))
				(list 'smooth-channel 
				      (lambda () 
					(smooth-channel 123 456 ind 0)))
				(list 'smooth-sound 
				      (lambda ()
					(smooth-sound 123 456 ind 0)))
				(list 'smooth-selection 
				      (lambda () 
					(let ((reg (select-all ind 0))) 
					  (smooth-selection)
					  (if (region? reg) (forget-region reg)))))
				(list 'src-channel 
				      (lambda ()
					(src-channel .5 123 456 ind 0)))
				(list 'src-sound 
				      (lambda () 
					(src-sound '(0 0.5 1 1))))
				(list 'src-selection 
				      (lambda () 
					(let ((reg (select-all ind 0))) 
					  (src-selection 0.5) 
					  (if (region? reg) (forget-region reg)))))
				(list 'swap-channels 
				      (lambda () 
					(let ((ind1 (open-sound "1a.snd"))) 
					  (swap-channels ind 0 ind1 0)
					  (close-sound ind1))))
				(list 'float-vector->channel 
				      (lambda () 
					(float-vector->channel (make-float-vector 3) 123 3 ind 0)))
				(list 'xramp-channel 
				      (lambda () 
					(xramp-channel .5 1.0 32.0 123 456 ind 0))))))
	
	(if (and (provided? 'snd-motif)
		 (provided? 'xm))
	    (let ((edp ((*motif* 'XtParent) ((channel-widgets ind 0) 7))))
	      ((*motif* 'XtUnmanageChild) edp) 
	      ((*motif* 'XtVaSetValues) edp (list (*motif* 'XmNpaneMinimum) 100)) 
	      ((*motif* 'XtManageChild) edp)))
	
	(let ((edit-hook-ctr 0)
	      (after-edit-hook-ctr 0))
	  (hook-push (edit-hook ind 0) 
		     (lambda (hook) 
		       (set! edit-hook-ctr (+ 1 edit-hook-ctr)) 
		       (set! (hook 'result) #t)))
	  (hook-push (after-edit-hook ind 0) 
		     (lambda (hook) 
		       (set! after-edit-hook-ctr (+ 1 after-edit-hook-ctr)) 
		       (set! (hook 'result) #t)))
	  (for-each
	   (lambda (func-and-name)
	     (let ((func (cadr func-and-name)))
	       (func))
	     (let ((name (car func-and-name)))
	       (if (not (= (edit-position ind 0) 0)) (snd-display "~A: blocked edit: ~A" name (edit-position ind 0)))
	       (if (not (= edit-hook-ctr 1)) (snd-display "~A: edit hook calls: ~A" name edit-hook-ctr))
	       (if (not (= after-edit-hook-ctr 0)) (snd-display "~A: after edit hook calls: ~A" name after-edit-hook-ctr))
	       (set! edit-hook-ctr 0)
	       (if (not (null? (mixes ind 0))) (snd-display "[27315] ~A: mixes: ~A" name (mixes ind 0)))))
	   all-tests)
	  
	  (set! edit-hook-ctr 0)
	  (set! after-edit-hook-ctr 0)
	  (set! (hook-functions (edit-hook ind 0)) ())
	  (set! (hook-functions (after-edit-hook ind 0)) ())
	  (hook-push (edit-hook ind 0) 
		     (lambda (hook) 
		       (set! edit-hook-ctr (+ 1 edit-hook-ctr)) 
		       (set! (hook 'result) #f)))
	  (hook-push (after-edit-hook ind 0) 
		     (lambda (hook) 
		       (set! after-edit-hook-ctr (+ 1 after-edit-hook-ctr)) 
		       (set! (hook 'result) #t)))
	  (for-each
	   (lambda (func-and-name)
	     (let ((func (cadr func-and-name)))
	       (func))
	     (let ((name (car func-and-name)))
	       (if (<= (edit-position ind 0) 0) (snd-display "~A: unblocked edit: ~A" name (edit-position ind 0)))
	       (if (<= edit-hook-ctr 0) (snd-display "~A: unblocked edit hook calls: ~A" name edit-hook-ctr))
	       (if (<= after-edit-hook-ctr 0) (snd-display "~A: unblocked after edit hook calls: ~A" name after-edit-hook-ctr)))
	     (set! edit-hook-ctr 0)
	     (set! after-edit-hook-ctr 0)
	     (revert-sound ind))
	   all-tests))
	
	(if (and (provided? 'snd-motif)
		 (provided? 'xm))
	    (let ((edp ((*motif* 'XtParent) ((channel-widgets ind 0) 7))))
	      ((*motif* 'XtUnmanageChild) edp) 
	      ((*motif* 'XtVaSetValues) edp (list (*motif* 'XmNpaneMinimum) 1))  ; not 0 here -- Xt warnings
	      ((*motif* 'XtManageChild) edp)))
	
	(close-sound ind))
      
      (hook-push mouse-enter-text-hook
		 (lambda (hook)
		   (focus-widget (hook 'widget))))
      (hook-push mouse-leave-text-hook
		 (lambda (hook)
		   (focus-widget (hook 'widget))))
      (describe-hook mouse-enter-text-hook)
      (reset-all-hooks)
      
      (let ((ind (open-sound "oboe.snd")))
	(scale-by 2.0)
	(hook-push (edit-hook ind 0) (lambda (hook) (set! (hook 'result) #t)))
	(mix-float-vector (make-float-vector 10 .1) 0)
	(if (not (= (edit-position ind 0) 1)) (snd-display "mix-float-vector: blocked edit: ~A" (edit-position ind 0)))
	(if (not (null? (mixes ind 0))) (snd-display "mix-float-vector edit-hook: mixes: ~A" (mixes ind 0)))
	(mix "pistol.snd" 1000)
	(if (not (= (edit-position ind 0) 1)) (snd-display "mix: blocked edit: ~A" (edit-position ind 0)))
	(if (not (null? (mixes ind 0))) (snd-display "mix edit-hook: mixes: ~A" (mixes ind 0)))
	(set! (hook-functions (edit-hook ind 0)) ())
	(let ((mx (mix-float-vector (make-float-vector 10 .1) 1000)))
	  (when (mix? mx) ; might be no-gui case
	    (if (not (= (edit-position ind 0) 2)) (snd-display "mix-float-vector: unblocked edit: ~A" (edit-position ind 0)))
	    (if (not (equal? (mixes ind 0) (list mx))) (snd-display "mix-float-vector un edit-hook: mixes: ~A" (mixes ind 0)))
	    (hook-push (edit-hook ind 0) (lambda (hook) (set! (hook 'result) #t)))
	    (set! (mix-amp mx) 2.0)
	    (if (not (= (edit-position ind 0) 2)) (snd-display "mix amp: blocked edit: ~A" (edit-position ind 0)))
	    (if (fneq (mix-amp mx) 1.0) (snd-display "mix amp: blocked edit: ~A" (mix-amp mx)))
	    (set! (mix-amp-env mx) '(0 0 1 1 2 0))
	    (if (not (= (edit-position ind 0) 2)) (snd-display "mix amp env: blocked edit: ~A" (edit-position ind 0)))
	    (if (pair? (mix-amp-env mx)) (snd-display "mix amp env: blocked edit: ~A" (mix-amp-env mx)))
	    (set! (mix-speed mx) 2.0)
	    (if (not (= (edit-position ind 0) 2)) (snd-display "mix speed: blocked edit: ~A" (edit-position ind 0)))
	    (if (fneq (mix-speed mx) 1.0) (snd-display "mix speed: blocked edit: ~A" (mix-speed mx)))
	    (set! (mix-position mx) 2000)
	    (if (not (= (edit-position ind 0) 2)) (snd-display "mix position: blocked edit: ~A" (edit-position ind 0)))
	    (if (not (= (mix-position mx) 1000)) (snd-display "mix position: blocked edit: ~A" (mix-position mx)))
	    (mix-float-vector (make-float-vector 10 .2) 0)
	    (if (not (= (edit-position ind 0) 2)) (snd-display "mix-float-vector 1: blocked edit: ~A" (edit-position ind 0)))
	    (if (not (equal? (mixes ind 0) (list mx))) (snd-display "mix-float-vector 1 edit-hook: mixes: ~A" (mixes ind 0)))
	    ))
	(close-sound ind))
      
      (let ((ind (open-sound "oboe.snd")))
	(if (pair? (hook-functions (edit-hook ind 0))) (snd-display "edit-hook not cleared at close?"))
	(if (pair? (hook-functions (after-edit-hook ind 0))) (snd-display "after-edit-hook not cleared at close?"))
	(close-sound ind))
      
      (reset-all-hooks)
      
      ;; before|after-save-as-hook
      (let ((hook-called #f))
	(hook-push before-save-as-hook ; from docs
		   (lambda (hook)
		     (let ((index (hook 'snd))
			   (filename (hook 'name))
			   (sr (hook 'sampling-rate))
			   (type (hook 'header-type))
			   (dformat (hook 'sample-type))
			   (comment (hook 'comment)))
		       (if (not (= sr (srate index)))
			   (let ((chns (chans index)))
			     (do ((i 0 (+ i 1)))
				 ((= i chns))
			       (src-channel (* 1.0 (/ (srate index) sr)) 0 #f index i))
			     (save-sound-as filename index :header-type type :sample-type dformat :srate sr :comment comment) 
			     ;; hook won't be invoked recursively
			     (do ((i 0 (+ i 1)))
				 ((= i chns))
			       (undo 1 index i))
			     (set! hook-called #t)
			     (set! (hook 'result) #t))))))
	(let ((ind (open-sound "2.snd")))
	  (save-sound-as "test.snd" :srate 44100)
	  (if (not (= (edit-position ind 0) 0)) (snd-display "before-save-as-hook undo: ~A" (edit-position ind 0)))
	  (if (not hook-called) (snd-display "before-save-as-hook not called?"))
	  (close-sound ind)
	  (set! ind (open-sound "test.snd"))
	  (if (not (= (srate ind) 44100)) (snd-display "before-save-as-hook src: ~A" (srate ind)))
	  (close-sound ind))
	(set! (hook-functions before-save-as-hook) ()))
      
      (let ((need-save-as-undo #f))
	(hook-push before-save-as-hook
		   (lambda (hook)
		     (let ((index (hook 'snd))
			   (sr (hook 'sampling-rate)))
		       (set! need-save-as-undo #f)
		       (unless (= sr (srate index))
			 (src-sound (* 1.0 (/ (srate index) sr)) 1.0 index)
			 (set! need-save-as-undo #t)))))
	(hook-push after-save-as-hook
		   (lambda (hook)
		     (if need-save-as-undo (undo)))))
      (let ((ind (open-sound "oboe.snd")))
	(save-sound-as "test.snd" :srate 44100)
	(if (not (= (edit-position ind 0) 0)) (snd-display "after-save-as-hook undo: ~A" (edit-position ind 0)))
	(close-sound ind)
	(set! ind (open-sound "test.snd"))
	(if (not (= (srate ind) 44100)) (snd-display "before|after-save-as-hook src: ~A" (srate ind)))
	(close-sound ind))
      (set! (hook-functions before-save-as-hook) ())
      (set! (hook-functions after-save-as-hook) ())
      
      (let-temporarily ((*clipping* #t)
			((mus-clipping) #t))
	(set! (hook-functions clip-hook) ())
	(let ((index (new-sound "test.snd" 1 22050 mus-ldouble mus-next "clip-hook test" 10)))
	  (map-channel (lambda (y) (mus-random 0.999))) ; -amp to amp
	  (set! (sample 2) 1.0001)
	  (set! (sample 4) -1.0)
	  (set! (sample 6) 1.5)
	  (set! (sample 8) -1.5)
	  (let ((hook-called 0)
		(vals (channel->float-vector 0 10 index)))
	    (hook-push clip-hook (lambda (hook)
				   (let ((val (hook 'val)))
				     (if (and (fneq val 1.0)
					      (fneq val 1.5)
					      (fneq val -1.5))
					 (snd-display "clip-hook called upon: ~A" val))
				     (set! hook-called (+ 1 hook-called))
				     (set! (hook 'result) 0.0))))
	    (save-sound index)
	    (set! (hook-functions clip-hook) ())
	    (if (not (= hook-called 3)) (snd-display "clip-hook called ~A times" hook-called))
	    (close-sound index)
	    (set! index (open-sound "test.snd"))
	    (let ((new-vals (channel->float-vector 0 10 index))
		  (fixed-vals (copy vals)))
	      (set! (fixed-vals 2) 0.0)
	      (set! (fixed-vals 6) 0.0)
	      (set! (fixed-vals 8) 0.0)
	      (if (not (mus-arrays-equal? fixed-vals new-vals))
		  (snd-display "clip-hook results:~%    ~A~%    ~A~%    ~A" new-vals fixed-vals vals)))
	    (close-sound index))))
      ))))



;;; ---------------- test 14: all together now ----------------

(define sfile 0) ; used globally by save-state stuff (... is this a bug?)

(define safe-make-selection 
  (let ((+documentation+ "make-region with error checks"))
    (lambda (snd) ; used in test_15 also
      (let ((len (framples snd))
	    (beg 1000)
	    (end 2000))
	(let-temporarily ((*selection-creates-region* #t))
	  (if (> len 1)
	      (make-selection (if (< end len)
				  (values beg end)
				  (values (if (< beg len) beg 0) (- len 1)))
			      snd)))))))
  
(define (flatten lst)
  (cond ((null? lst) ())
	((not (pair? lst)) lst)
	((pair? (car lst)) (append (flatten (car lst)) (flatten (cdr lst))))
	(else (cons (car lst) (flatten (cdr lst))))))

(define snd_test_14
  (let ((test-panel 
	 (lambda (func name)
	   (if (not (or (feql (func #t) (map func (sounds)))
			(feql (func #t) (map func (reverse (sounds))))))
	       (snd-display "test-panel ~A: ~A ~A?" name (func #t) (map func (sounds))))))
	
	(test-channel 
	 (lambda (func name)
	   (let ((val (flatten (func #t #t))))
	     (if (not (or (equal? val (apply map func (all-chans)))
			  (equal? val (apply map func
					     (let ((sndlist ())
						   (chnlist ()))
					       (for-each
						(lambda (snd)
						  (do ((i (- (channels snd) 1) (- i 1)))
						      ((< i 0))
						    (set! sndlist (cons snd sndlist))
						    (set! chnlist (cons i chnlist))))
						(reverse (sounds)))
					       (list sndlist chnlist))))))
		 (snd-display "test-channel ~A: ~A ~A?" name val (apply map func (all-chans)))))))
	
	(clone-sound-as 
	 (lambda* (new-name snd)
	   ;; copies any edit-sounds to save-dir!
	   (let ((scm (let ((tmpf (snd-tempnam)))
			(string-append (substring tmpf 0 (- (length tmpf) 3)) "scm"))))
	     (let ((oldsnd (or snd (selected-sound))))
	       (if (not (string? *save-dir*)) (set! *save-dir* "/tmp"))
	       (save-edit-history scm oldsnd)
	       (copy-file (file-name oldsnd) new-name))
	     (set! sfile (open-sound new-name))
	     (load scm)
	     (delete-file scm)
	     sfile))))
    
    ;; test_14
    (lambda ()
      (hook-push after-open-hook (lambda (hook)
				   (set! (hook 'result) (make-player (hook 'snd) 0))))
      (do ((open-files () ())
	   (cur-dir-files (test-remove-if 
			   (lambda (file)
			     (catch #t
			       (lambda ()
				 (not (and (<= 0 (mus-sound-framples file) 80000)
					   (<= 1 (mus-sound-chans file) 2))))
			       (lambda args #t)))
			   (sound-files-in-directory ".")))
	   (test-ctr 0 (+ 1 test-ctr)))
	  ((= test-ctr tests))
	(if (> (length open-files) 8)
	    (begin
	      (for-each close-sound open-files)
	      (set! open-files ()))
	    (if (> test-ctr 0)
		(for-each
		 (lambda (snd)
		   (let ((mxpos (edit-position snd 0))
			 (chns (chans snd)))
		     (if (> chns 1)
			 (do ((chn 1 (+ chn 1)))
			     ((= chn chns))
			   (set! mxpos (+ mxpos (edit-position snd chn)))))
		     (when (or (> mxpos 100) (> chns 4))
		       (snd-display "revert ~A at ~A" (file-name snd) mxpos)
		       (revert-sound snd))))
		 (sounds))))
	(log-mem test-ctr)
	
	(if (> 10 test-ctr 0)  ; this creates too many leftover save-state sound files
	    (let ((files (length (sounds))))
	      (if (file-exists? "s61.scm") (delete-file "s61.scm"))
	      (for-each
	       (lambda (s)
		 (when (> (chans s) 4)
		   (set! open-files (test-remove-if (lambda (a) (= a s)) open-files))
		   (close-sound s)))
	       (sounds))
	      (save-state "s61.scm")
	      (for-each close-sound (sounds))
	      (for-each forget-region (regions))
	      (catch #t
		(lambda ()
		  (load (string-append cwd "s61.scm")))
		(lambda args args))
	      (if (not (= (length (sounds)) files))
		  (snd-display "save state restart from ~A to ~A sounds?" files (length (sounds))))
	      (set! open-files (sounds))))
	
	(let ((fd (let ((name (cur-dir-files (random (length cur-dir-files)))))
		    (if (or (= (mus-sound-header-type name) mus-raw) 
			    (= (mus-sound-sample-type name) -1))
			-1 
			(view-sound name)))))
	  (if (and (number? fd)
		   (not (= fd -1)))
	      (set! open-files (cons fd open-files))))
	
	(if (null? open-files)
	    (set! open-files (list (view-sound "1a.snd"))))
	
	(let ((choose-fd (lambda () 
			   (if (zero? test-ctr) ; I think randomness here is messing up my timing comparisons
			       (or (find-sound "1a.snd") (open-sound "1a.snd"))
			       ((sounds) (random (length (sounds))))))))
	  (let ((curfd (choose-fd)))
	    (let ((curloc (max 0 (min 1200 (framples curfd 0))))
		  (old-marks (length (marks curfd 0)))
		  (duration (lambda (ind) 
			      (/ (framples ind) (srate ind)))))
	      
	      (when (> (duration curfd) 0.0)
		(set! (x-bounds curfd) (list 0.0 (min (duration curfd) 1.0)))
		(when with-gui
		  (let ((xb (x-bounds curfd)))
		    (if (or (fneq (car xb) 0.0) 
			    (fneq (cadr xb) (min (duration curfd) 1.0))) 
			(snd-display "x-bounds: ~A?" xb)))))
	      (set! (y-bounds curfd) (list -0.5 0.5))
	      (let ((yb (y-bounds curfd)))
		(when (and with-gui
			   (or (fneq (car yb) -0.5) (fneq (cadr yb) 0.5)))
		  (snd-display "y-bounds: ~A?" yb)))
	      (set! (cursor curfd 0) curloc)
	      (let ((cl (cursor curfd 0)))
		(when (and (not (= cl curloc))
			   (> (framples curfd 0) curloc))
		  (snd-display "cursor ~A is not ~A (framples: ~A)?" cl curloc (framples curfd 0))
		  (set! curloc (cursor curfd 0))))
	      (if (>= curloc (framples curfd 0)) (set! curloc 0))
	      (let ((id (catch #t (lambda () (add-mark curloc curfd)) (lambda args -1))))
		(when (and (number? id) (not (= id -1)))
		  (let ((cl (mark-sample id))
			(new-marks (length (marks curfd 0))))
		    (if (not (= cl curloc)) (snd-display "mark ~A is not ~A?" cl curloc))
		    (if (not (= new-marks (+ 1 old-marks))) (snd-display "marks ~A ~A?" new-marks old-marks)))
		  (let ((new-id (find-mark curloc curfd)))
		    (if (not (and (mark? new-id)
				  (= id new-id)))
			(snd-display "find-mark (by sample): ~A ~A (~A for ~A ~A)?" 
				     id new-id curloc (mark-sample id) (mark-sample new-id))))
		  (set! (mark-name id) "hiho")
		  (let ((new-id (find-mark "hiho" curfd)))
		    (if (not (and (mark? new-id)
				  (= id new-id)))
			(snd-display "find-mark (by name): ~A ~A?" id new-id)))
		  (if (not (string=? (mark-name id) "hiho")) (snd-display "mark name: ~A?" (mark-name id)))
		  (set! (mark-sample id) (max 0 (- curloc 100)))
		  (let ((cl (mark-sample id)))
		    (if (not (= cl (max 0 (- curloc 100)))) (snd-display "set mark ~A is not ~A?" cl curloc))
		    (delete-mark id)))
		(if (> (duration curfd) 1.2) (set! (x-bounds curfd) '(1.0 1.1)))
		(when (> (framples curfd) 25)
		  (add-mark 10 curfd)
		  (add-mark 20 curfd)
		  (key (char->integer #\m) 0 curfd)
		  (set! (cursor curfd) 0)
		  (let ((new-marks (length (marks curfd 0))))
		    (delete-marks curfd)
		    (if (> (duration curfd) 0.0)
			(set! (x-bounds curfd) (list 0.0 (min (duration curfd) 0.1))))
		    (set! (y-bounds curfd) '(-1.0 1.0))
		    (if (or (> (length (marks curfd 0)) 0)
			    (not (= new-marks (+ old-marks 3))))
			(snd-display "delete marks: ~A ~A?" new-marks old-marks)))))))
	  
	  (revert-sound)
	  (let-temporarily ((*selection-creates-region* #t))
	    (let ((reg (select-all)))
	      (without-errors
	       (if (and (region? reg) 
			(selection?))
		   (let ((r1 (region-rms (car (regions))))
			 (r2 (selection-rms)))
		     (if (fneq r1 r2)
			 (snd-display "region rms: ~A?" r1)))))))
	  
	  (without-errors (if (region? (cadr (regions))) (play (cadr (regions)) :wait #t)))
	  (without-errors (mix-region (car (regions))))
	  (if (< (framples) 100000) (play :wait #t))
	  (scale-to .1 (choose-fd))
	  (scale-by 2.0 (choose-fd))
	  (save-controls)
	  (set! (amp-control) .5)
	  (test-panel amp-control 'amp-control)
	  (restore-controls)
	  (status-report "hi")
	  
	  (without-errors
	   (let ((cfd (choose-fd)))
	     (safe-make-selection cfd)
	     (src-selection .5)
	     (undo 1 cfd))
	   (let ((cfd (choose-fd)))
	     (safe-make-selection cfd)
	     (src-selection -1.5)
	     (undo 1 cfd))
	   (let ((cfd (choose-fd)))
	     (safe-make-selection cfd)
	     (scale-selection-by .5)
	     (undo 1 cfd))
	   (let ((cfd (choose-fd)))
	     (safe-make-selection cfd)
	     (env-selection '(0 0 1 1 2 0))
	     (undo 1 cfd))
	   (let ((cfd (choose-fd)))
	     (safe-make-selection cfd)
	     (scale-selection-to .5)
	     (reverse-selection)
	     (undo 2 cfd))
	   (if (> (length (regions)) 2) (forget-region ((regions) 2))))
	  (for-each revert-sound open-files)
	  
	  (without-errors
	   (let ((cfd (car open-files)))
	     (set! (sync cfd) 1)
	     (if (pair? (cdr open-files)) (set! (sync (cadr open-files)) 1))
	     (safe-make-selection cfd)
	     (src-selection .5)
	     (undo 1 cfd)
	     (safe-make-selection cfd)
	     (src-selection -1.5)
	     (undo 1 cfd)
	     (safe-make-selection cfd)
	     (env-selection '(0 0 1 1 2 0))
	     (undo 1 cfd)
	     (safe-make-selection cfd)
	     (reverse-selection)
	     (undo 1 cfd)
	     (safe-make-selection cfd)
	     (filter-selection '(0 0 .1 1 1 0) 40)
	     (undo 1 cfd)
	     (safe-make-selection cfd)
	     (convolve-selection-with "oboe.snd")
	     (undo 1 cfd)
	     (safe-make-selection cfd)
	     (smooth-selection)
	     (undo 1 cfd)
	     (safe-make-selection cfd)
	     (scale-selection-by .5)
	     (undo 1 cfd)
	     (scale-selection-to .5)
	     (reverse-selection)
	     (undo 2)
	     (src-selection '(0 .5 1 1))
	     (undo)
	     (revert-sound cfd)
	     (if (pair? (cdr open-files)) (revert-sound (cadr open-files)))))
	  
	  (when (> 10000 (framples) 1)
	    (make-region 0 (framples))
	    (convolve-selection-with "fyow.snd" .5)
	    (play :wait #t)
	    (convolve-with "fyow.snd" .25))
	  (insert-sound "oboe.snd")
	  (set! (hook-functions graph-hook) ())
	  (set! (hook-functions after-transform-hook) ())
	  (for-each revert-sound open-files)
	  
	  (let ((ind (choose-fd)))
	    (select-sound ind)
	    (for-each
	     (lambda (func func1)
	       (pad-channel 0 100 ind 0)
	       (func 0)
	       (pad-channel 0 100 ind 0)
	       (func1 0)
	       (revert-sound ind)
	       (when (> (chans ind) 1)
		 (pad-channel 0 100 ind 1)
		 (func 0)
		 (pad-channel 0 100 ind 1)
		 (func1 0)
		 (revert-sound ind))
	       (delete-samples 0 1000 ind 0)
	       (func (* 2 (framples ind 0)))
	       (delete-samples 0 10000 ind 0)
	       (func1 (* 2 (framples ind 0)))
	       (revert-sound ind)
	       (when (> (chans ind) 1)
		 (delete-samples 0 1000 ind 1)
		 (func (* 2 (framples ind 1)))
		 (delete-samples 0 10000 ind 1)
		 (func1 (* 2 (framples ind 1)))
		 (revert-sound ind)))
	     (list (lambda (beg) (insert-sound "2a.snd" beg))
		   (lambda (beg) (reverse-sound))
		   (lambda (beg) (if (< (framples ind) 10000) (convolve-with "2a.snd" 0.5) (scale-by 2.0)))
		   (lambda (beg) (env-sound '(0 0 1 1 2 0)))
		   (lambda (beg) (smooth-sound)))
	     (list (lambda (beg) (insert-sound "4a.snd" beg))
		   (lambda (beg) (reverse-sound))
		   (lambda (beg) (src-sound 2.0))
		   (lambda (beg) (env-sound '(0 0 1 1)))
		   (lambda (beg) (insert-silence beg 100)))))
	  
	  (let ((ind (open-sound "z.snd")))
	    (if (not (= (framples ind) 0)) (snd-display "framples z.snd ~A" (framples ind)))
	    (if (samples) (snd-display "samples of empty file (z): ~A" (samples)))
	    (if (channel->float-vector) (snd-display "channel->float-vector of empty file (z): ~A" (channel->float-vector)))
	    (if (fneq (maxamp ind) 0.0) (snd-display "maxamp z.snd ~A" (maxamp ind)))
	    (if (fneq (sample 100 ind) 0.0) (snd-display "sample 100 z.snd ~A" (sample 100 ind)))
	    (scale-by 2.0)
	    (if (not (= (edit-position ind 0) 0)) (snd-display "scale z: ~A" (edit-position ind 0)))
	    (env-sound '(0 0 1 1))
	    (if (not (= (edit-position ind 0) 0)) (snd-display "env z: ~A" (edit-position ind 0)))
	    (smooth-sound)
	    (if (not (= (edit-position ind 0) 0)) (snd-display "smooth z: ~A" (edit-position ind 0)))
	    (reverse-sound)
	    (if (not (= (edit-position ind 0) 0)) (snd-display "reverse z: ~A" (edit-position ind 0)))
	    (src-sound 2.0)
	    (if (not (= (edit-position ind 0) 0)) (snd-display "src z: ~A" (edit-position ind 0)))
	    (insert-sound "z.snd")
	    (if (not (= (edit-position ind 0) 0)) (snd-display "insert z: ~A" (edit-position ind 0)))
	    (mix "z.snd")
	    (if (not (= (edit-position ind 0) 0)) (snd-display "mix z: ~A" (edit-position ind 0)))
	    (filter-sound (make-one-zero :a0 2.0 :a1 0.0))
	    (if (not (= (edit-position ind 0) 0)) (snd-display "filter z: ~A" (edit-position ind 0)))
	    (if (not (= (mus-sound-duration "z.snd") 0.0)) (snd-display "duration z.snd: ~A" (mus-sound-duration "z.snd")))
	    (catch 'IO-error
	      (lambda () (convolve-with "z.snd" 1.0))
	      (lambda args args))
	    (if (not (= (edit-position ind 0) 0)) (snd-display "convolve z: ~A" (edit-position ind 0)))
	    (let ((matches (count-matches (lambda (y) (> y .1)))))
	      (if (and (integer? matches) (> matches 0))
		  (snd-display "count z: ~A" matches)))
	    (let ((val (next-sample (make-sampler 0))))
	      (if (fneq val 0.0) (snd-display "sampler z.snd: ~A" val)))
	    (if (not (equal? (cursor-position) '(0 0))) (snd-display "cursor-position z: ~A" (cursor-position)))
	    (if (not (= (cursor) 0)) (snd-display "cursor z: ~A" (cursor)))
	    (let ((outer (make-player ind 0)))
	      (add-player (make-player ind 0))
	      (start-playing 1 22050 #f)
	      (revert-sound ind)
	      (set! (transform-graph? ind 0) #t)
	      (hook-push lisp-graph-hook display-energy)
	      (set! (x-bounds) (list 0.0 .01))
	      (set! (sample 0) 0.5)
	      (set! (x-bounds) (list 0.0 .001))
	      (close-sound ind)
	      (let ((tag (catch #t (lambda () (add-player outer)) (lambda args (car args)))))
		(if (not (eq? tag 'no-such-player))
		    (snd-display "dangling player: ~A" tag)))))
	  (if (channel-amp-envs "z.snd" 0 100)
	      (snd-display "channel-amp-envs of empty file: ~A" (channel-amp-envs "z.snd" 0 100)))
	  
	  (let ((s8-snd (if (file-exists? "s8.snd") "s8.snd" "oboe.snd")))
	    (let ((zz (view-sound "z.snd")))
	      (select-sound zz)
	      (mix "4.aiff")
	      (add-mark 0)
	      (add-mark 1200)
	      (delete-marks)
	      (revert-sound zz)
	      (let ((editctr (edit-position zz)))
		(let-temporarily ((*selection-creates-region* #t))
		  (if (not (= (edit-position) 0)) (snd-display "revert-sound edit-position: ~A" (edit-position)))
		  (as-one-edit 
		   (lambda ()
		     (mix s8-snd 24000)
		     (let ((reg (select-all)))
		       (when (selection?) 
			 (filter-selection '(0 0 .2 1 .5 0 1 0) 40)
			 (delete-selection)
			 (mix-region reg)))))
		  (if (not (= (edit-position) 1)) (snd-display "as-one-edit mix zz: ~A -> ~A" editctr (edit-position)))
		  (close-sound zz))))
	    (let ((s8 (view-sound s8-snd)))
	      (select-sound s8)
	      (when (= (channels s8) 8)
		(select-channel 5)
		(if (not (eqv? (selected-channel) 5))
		    (snd-display "select-channel: ~A?" (selected-channel))))
	      (let ((editctr (edit-position)))
		(as-one-edit 
		 (lambda ()
		   (let ((reg (select-all)))
		     (delete-selection)
		     (mix "4.aiff")
		     (set! (sync) 1)
		     (mix "oboe.snd" 60000)
		     (scale-by .1)
		     (set! (sync) 1)
		     (if (> (channels s8) 3)
			 (select-channel 3))
		     (if (region? reg)
			 (insert-region reg 80000)))))
		(if (not (= (edit-position) (+ 1 editctr))) (snd-display "as-one-edit s8: ~A -> ~A" editctr (edit-position))))
	      (revert-sound s8)
	      (close-sound s8)))
	  
	  (let ((cfd (choose-fd)))
	    (if (> (chans cfd) 1)
		(let ((uval (random 3)))
		  (set! (channel-style cfd) uval)
		  (if (not (= uval (channel-style cfd))) (snd-display "channel-style: ~A ~A?" uval (channel-style cfd)))))
	    (when (< (framples cfd) 200000)
	      (src-sound 2.5 1.0 cfd)
	      (src-sound -2.5 1.0 cfd)
	      (src-sound .5 1.0 cfd)
	      (revert-sound cfd)
	      (src-sound -.5 1.0 cfd)
	      (src-sound '(0 .5 1 1.5) 1.0 cfd)
	      (if (> (framples cfd) 0) (src-sound (make-env '(0 .5 1 1.5) :length (framples cfd)) 1.0 cfd))
	      (revert-sound cfd)
	      (filter-sound '(0 1 .2 0 .5 1 1 0) 20 cfd)
	      (filter-sound '(0 0 .1 0 .11 1 .12 0 1 0) 2048 cfd)
	      (env-sound '(0 0 .5 1 1 0) 0 (framples cfd) 1.0 cfd)
	      (insert-sample 1200 .1 cfd)
	      (if (fneq (sample 1200 cfd) .1) (snd-display "insert-sample(looped): ~A?" (sample 1200 cfd))))
	    (revert-sound cfd))
	  
	  (let ((cfd (open-sound "obtest.snd")))
	    (select-sound cfd)
	    (let ((cfd2 (open-sound "pistol.snd")))
	      (select-sound cfd2)
	      ;; now run apply a few times
	      (set! (amp-control) .5) 
	      (set! (speed-control) 2.0) 
	      (test-panel speed-control 'speed-control)
	      (apply-controls) 
	      (if (< (framples) 100000) (play :wait #t))
	      
	      (if (fneq (reverb-control-decay cfd) *reverb-control-decay*)
		  (snd-display "reverb-control-decay local: ~A, global: ~A" (reverb-control-decay cfd) *reverb-control-decay*))
	      (set! (reverb-control?) #t)
	      (set! (reverb-control-scale) .2) 
	      (test-panel reverb-control-scale 'reverb-control-scale)
	      (test-panel reverb-control-length 'reverb-control-length)
	      (test-panel reverb-control-lowpass 'reverb-control-lowpass)
	      (test-panel reverb-control-feedback 'reverb-control-feedback)
	      (apply-controls) 
	      (if (< (framples) 100000) (play :wait #t))
	      (set! (contrast-control?) #t)
	      (set! (contrast-control) .5) 
	      (test-panel contrast-control 'contrast-control)
	      (test-panel contrast-control-amp 'contrast-control-amp)
	      (apply-controls) 
					;	      (if (< (framples) 100000) (play :wait #t))
	      (set! (expand-control?) #t)
	      (set! (expand-control) 2.5) 
	      (test-panel expand-control 'expand-control)
	      (test-panel expand-control-length 'expand-control-length)
	      (test-panel expand-control-hop 'expand-control-hop)
	      (test-panel expand-control-ramp 'expand-control-ramp)
	      (apply-controls) 
					;	      (if (< (framples) 100000) (play :wait #t))
	      (set! (filter-control?) #t)
	      (set! *filter-control-order* 40) 
	      (test-panel filter-control-order 'filter-control-order)
	      (set! (filter-control-envelope) '(0 0 .1 1 .2 0 1 0)) 
	      (apply-controls) 
					;	      (if (< (framples) 100000) (play :wait #t))
	      (set! (amp-control) 1.5) 
	      (test-panel amp-control 'amp-control)
	      (apply-controls) 
					;	      (if (< (framples) 100000) (play :wait #t))
	      (swap-channels cfd 0 cfd2 0)
	      (set! (amp-control #t) .75)
	      (test-panel amp-control 'amp-control)
	      (if (> (abs (- (amp-control cfd2) .75)) .05) (snd-display "set-amp .75 #t -> ~A?" (amp-control cfd2)))
	      (set! (contrast-control-amp #t) .75)
	      (if (fneq (contrast-control-amp cfd2) .75) (snd-display "set-contrast-control-amp .75 #t -> ~A?" (contrast-control-amp cfd2)))
	      (set! (contrast-control-bounds cfd2) (list 2.0 3.0))
	      (if (not (feql (contrast-control-bounds cfd2) '(2.0 3.0))) 
		  (snd-display "cfd2 contrast-control-bounds: ~A" (contrast-control-bounds cfd2)))
	      (set! (expand-control-length #t) .025)
	      (if (fneq (expand-control-length cfd2) .025) (snd-display "set-expand-control-length .025 #t -> ~A?" (expand-control-length cfd2)))
	      (set! (expand-control-hop #t) .025)
	      (if (fneq (expand-control-hop cfd2) .025) (snd-display "set-expand-control-hop .025 #t -> ~A?" (expand-control-hop cfd2)))
	      (set! (expand-control-jitter #t) .025)
	      (if (fneq (expand-control-jitter cfd2) .025) (snd-display "set-expand-control-jitter .025 #t -> ~A?" (expand-control-jitter cfd2)))
	      (set! (expand-control-ramp #t) .025)
	      (if (fneq (expand-control-ramp cfd2) .025) (snd-display "set-expand-control-ramp .025 #t -> ~A?" (expand-control-ramp cfd2)))
	      (let ((clone (clone-sound-as "/tmp/cloned.snd" cfd2)))
		(if (not (= (framples cfd2) (framples clone)))
		    (snd-display "clone framples: ~A ~A" (framples cfd2) (framples clone)))
		(close-sound clone))
	      (delete-file "/tmp/cloned.snd")
	      (mus-sound-forget "/tmp/cloned.snd")
	      (close-sound cfd2)
	      (close-sound cfd)))
	  (hook-push (edit-hook) (lambda (hook) (set! (hook 'result) #f)))
	  (let ((editctr (edit-position)))
	    (as-one-edit (lambda () (set! (sample 200) .2) (set! (sample 300) .3)))
	    (if (not (= (edit-position) (+ 1 editctr))) (snd-display "as-one-edit: ~A -> ~A" editctr (edit-position)))
	    (as-one-edit (lambda () #f))
	    (if (not (= (edit-position) (+ 1 editctr))) (snd-display "as-one-edit nil: ~A -> ~A" editctr (edit-position))))
	  (delete-sample 250)
	  (hook-push (undo-hook) (lambda (hook) (set! (hook 'result) #f)))
	  (undo)
	  (delete-sample 250)
	  (undo)
	  (as-one-edit (lambda () (set! (sample 20) .2) (set! (sample 30) .3)))
	  (undo 1)
	  (as-one-edit (lambda () (set! (sample 2) .2) (as-one-edit (lambda () (set! (sample 3) .3)))))
	  (undo 2)
	  (set! (hook-functions (undo-hook)) ())
	  (set! (hook-functions (edit-hook)) ())
	  (hook-push snd-warning-hook 
		     (lambda (hook)
		       (let ((msg (hook 'message)))
			 (if (not (string=? msg "hiho")) (snd-display "snd-warning-hook: ~A?" msg))
			 (set! (hook 'result) #t))))
	  (snd-warning "hiho")
	  (set! (hook-functions snd-error-hook) ())
	  (set! (hook-functions snd-warning-hook) ())
	  (hook-push name-click-hook 
		     (lambda (hook) 
		       (set! (hook 'result) #t)))
	  (redo 1)
	  (set! (hook-functions name-click-hook) ())
	  (set! (transform-graph?) #t)
	  (test-channel transform-graph? 'transform-graph?)
	  (test-channel time-graph? 'time-graph?)
	  (test-channel lisp-graph? 'lisp-graph?)
	  (test-channel framples 'framples)
	  (test-channel cursor 'cursor)
	  (test-channel cursor-size 'cursor-size)
	  (test-channel cursor-style 'cursor-style)
	  (test-channel tracking-cursor-style 'tracking-cursor-style)
	  (test-channel left-sample 'left-sample)
	  (test-channel right-sample 'right-sample)
	  (test-channel squelch-update 'squelch-update)
	  (test-channel x-zoom-slider 'x-zoom-slider)
	  (test-channel y-zoom-slider 'y-zoom-slider)
	  (test-channel x-position-slider 'x-position-slider)
	  (test-channel y-position-slider 'y-position-slider)
	  (test-channel edit-position 'edit-position)
	  (test-channel maxamp 'maxamp)
	  (test-channel edit-hook 'edit-hook)
	  (test-channel after-edit-hook 'after-edit-hook)
	  (test-channel undo-hook 'undo-hook)
	  (when (<= tests 2)
	    (set! *transform-type*
		  (add-transform "histogram" "bins" 0.0 1.0 
				 (lambda (len fd)
				   (do ((v (make-float-vector len))
					(steps (/ len 16))
					(step (/ 1.0 len))
					(i 0 (+ i 1)))
				       ((= i len) v)
				     (let ((bin (round (* 16.0 (abs (next-sample fd))))))
				       (if (< bin steps)
					   (float-vector-offset! (subvector v steps bin) step))))))))
	  (set! (x-bounds) '(.1 .2))
	  (set! *transform-type* fourier-transform)
	  (set! (x-bounds) '(.1 .2))
	  (hook-push lisp-graph-hook display-energy)
	  (set! (hook-functions graph-hook) ())
	  (when (= (channels) 2)
	    (hook-push graph-hook display-correlation)
	    (set! (x-bounds) '(.1 .12))
	    (set! (x-bounds) '(.1 .2))
	    (hook-remove graph-hook display-correlation))
	  (set! (lisp-graph?) #f)
	  (let ((mapf (let ((buffer (make-delay 128))
			    (gen (make-moving-average 128))
			    (current-sample 0)
			    (chan-samples (framples)))
			(set! (mus-feedback gen) 1.0)
			(lambda (y)
			  (let ((old-y (delay buffer y)))
			    (set! current-sample (+ 1 current-sample))
			    (and (> (moving-average gen (* y y)) .01)
				 (if (not (= current-sample chan-samples))
				     old-y
				     ;; at end return trailing samples as long as it looks like sound
				     (do ((temp-buffer (make-delay 128))
					  (i 0 (+ i 1))
					  (fy (delay buffer 0.0) (delay buffer 0.0)))
					 ((= i 128) 
					  (mus-data temp-buffer))
				       (delay temp-buffer (if (> (moving-average gen 0.0) .01) fy 0.0))))))))))
	    (map-channel mapf 0 20))
	  
	  (let ((maxval1 (+ (maxamp) .01)))
	    (if (not (every-sample? (lambda (y) (< y maxval1)))) 
		(let ((res (scan-channel (lambda (y) (>= y maxval1)))))
		  (snd-display "~A, every-sample: ~A ~A [~A: ~A]?" (short-file-name) maxval1 res (cursor) (sample (cursor)))
		  (do ((i 0 (+ i 1)))
		      ((= i (edit-position)))
		    (snd-display "~D: ~A ~A" i (maxamp #f 0 i) (edit-fragment i))))))
	  
	  (map-channel (echo .5 .75) 0 60000)
	  (set! (hook-functions after-transform-hook) ())
	  (set! (hook-functions lisp-graph-hook) ())
	  
	  (hook-push lisp-graph-hook 
		     (lambda (hook)
		       (graph (if (> (random 1.0) .5) 
				  #r(0 1 2)
				  (list #r(0 1 2) #r(3 2 0))))))
	  
	  (for-each
	   (lambda (snd)
	     (set! (sync snd) (random 3))
	     (update-lisp-graph snd))
	   (sounds))
	  (hook-push graph-hook superimpose-ffts)
	  (do ((i 0 (+ i 1)))
	      ((= i 10))
	    (for-each
	     (lambda (snd)
	       (if (> (framples snd) 0)
		   (let* ((dur (floor (/ (framples snd) (srate snd))))
			  (start (max 0.0 (min (- dur .1) (random dur)))))
		     (if (> dur 0.0) 
			 (set! (x-bounds snd 0) (list start (min (+ start .1) dur))))))
	       (update-time-graph snd)
	       (update-lisp-graph snd)
	       (update-transform-graph snd))
	     (sounds)))
	  (set! (hook-functions graph-hook) ())
	  (set! (hook-functions lisp-graph-hook) ())
	  
	  ;; new variable settings 
	  (letrec ((reset-vars
		    (lambda (lst)
		      (when (pair? lst)
			(let* ((name (eq? #t ((car lst) 0)))
			       (index (and ((car lst) 2) (choose-fd)))
			       (getfnc ((car lst) 1))
			       (setfnc (lambda (val snd) (set! (getfnc snd) val)))
			       (setfnc-1 (lambda (val) (set! (getfnc) val)))
			       (minval ((car lst) 3))
			       (maxval ((car lst) 4))
			       (fncval (or (not minval)
					   (if (rational? minval)
					       (if name
						   (floor (expt 2 (min 31 (ceiling (log (+ minval (floor (random (- maxval minval)))) 2)))))
						   (+ minval (floor (random (- maxval minval)))))
					       (+ minval (random (- maxval minval)))))))
			  (cond (index (setfnc fncval index))
				((not minval) 
				 (setfnc-1 #t))
				((not (rational? minval))
				 (setfnc-1 (+ minval (random (- maxval minval)))))
				(name
				 (setfnc-1 (floor (expt 2 (min 31 (ceiling (log (+ minval (floor (random (- maxval minval)))) 2)))))))
				(else
				 (setfnc-1 (+ minval (floor (random (- maxval minval)))))))
			  (reset-vars (cdr lst)))))))
	    (reset-vars 
	     (list
	      (list 'amp-control amp-control #t .1 1.0)
					;(list 'ask-before-overwrite ask-before-overwrite #f #f #t)
	      (list 'auto-resize auto-resize #f #f #t)
	      (list 'auto-update auto-update #f #f #t)
	      (list 'channel-style channel-style #f 0 2)
	      (list 'color-cutoff color-cutoff #f 0.0 0.2)
	      (list 'color-inverted color-inverted #f #f #t)
	      (list 'color-scale color-scale #f 0.1 1000.0)
	      (list 'contrast-control contrast-control #t 0.0 1.0)
	      (list 'contrast-control-amp contrast-control-amp #t 0.0 1.0)
	      (list 'contrast-control? contrast-control? #t #f #t)
	      (list 'auto-update-interval auto-update-interval #f 60.0 120.0)
	      (list 'cursor-update-interval cursor-update-interval #f 0.05 .1)
	      (list 'cursor-location-offset cursor-location-offset #f 0 1024)
	      (list 'with-tracking-cursor with-tracking-cursor #f #f #t)
	      (list 'cursor-size cursor-size #f 15 25)
	      (list 'cursor-style cursor-style #f cursor-cross cursor-line)
	      (list 'tracking-cursor-style tracking-cursor-style #f cursor-line cursor-cross)
	      (list 'clipping clipping #f #f #t)
					;(list 'default-output-chans default-output-chans #f 1 8)
					;(list 'default-output-sample-type default-output-sample-type #f 1 12)
					;(list 'default-output-srate default-output-srate #f 22050 44100)
					;(list 'default-output-header-type default-output-header-type #f 0 2)
	      (list 'dot-size dot-size #f 1 10)
	      (list 'enved-base enved-base #f 0.01  100.0)
	      (list 'enved-clip? enved-clip? #f #f #t)
	      (list 'enved-in-dB enved-in-dB #f #f #t)
	      (list 'enved-style enved-style #f envelope-linear envelope-exponential)
	      (list 'enved-power enved-power #f 3.0 3.5)
	      (list 'enved-target enved-target #f 0 2)
	      (list 'enved-wave? enved-wave? #f #f #t)
	      (list 'expand-control expand-control #t 0.1 5.0)
	      (list 'expand-control-hop expand-control-hop #t 0.01 0.5)
	      (list 'expand-control-jitter expand-control-jitter #t 0.01 0.5)
	      (list 'expand-control-length expand-control-length #t 0.1 0.25)
	      (list 'expand-control-ramp expand-control-ramp #t 0.1 0.4)
	      (list 'expand-control? expand-control? #t #f #t)
	      (list 'fft-window-alpha fft-window-alpha #f 0.0  1.0)
	      (list 'fft-window-beta fft-window-beta #f 0.0  1.0)
	      (list 'fft-log-frequency fft-log-frequency #f #f #t)
	      (list 'fft-log-magnitude fft-log-magnitude #f #f #t)
	      (list 'fft-with-phases fft-with-phases #f #f #t)
	      (list 'transform-size transform-size #f 16 (if (<= tests 10) 4096 128))
	      (list 'transform-graph-type transform-graph-type #f graph-once graph-as-spectrogram)
	      (list 'fft-window fft-window #f 0 dolph-chebyshev-window)
	      (list 'transform-graph? transform-graph? #t #f #t)
	      (list 'filter-control-in-dB filter-control-in-dB #t #f #t)
	      (list 'filter-control-in-hz filter-control-in-hz #t #f #t)
	      (list 'filter-control-order filter-control-order #t 2 (if (<= tests 10) 400 40))
	      (list 'filter-control? filter-control? #t #f #t)
					;	      (list 'graph-cursor graph-cursor #f 0 35)
	      (list 'time-graph-style time-graph-style #f 0 4)
	      (list 'lisp-graph-style lisp-graph-style #f 0 4)
	      (list 'transform-graph-style transform-graph-style #f 0 4)
	      (list 'graphs-horizontal graphs-horizontal #f #f #t)
	      (list 'max-transform-peaks max-transform-peaks #f 1 100)
	      (list 'max-regions max-regions #f 1 32)
	      (list 'min-dB min-dB #f -120.0 -30.0)
	      (list 'log-freq-start log-freq-start #f 50.0 5.0)
	      (list 'selection-creates-region selection-creates-region #f #f #t)
	      (list 'transform-normalization transform-normalization #f dont-normalize normalize-globally)
	      (list 'play-arrow-size play-arrow-size #f 2 32)
	      (list 'print-length print-length #f 2 32)
	      (list 'region-graph-style region-graph-style #f graph-lines graph-lollipops)
	      (list 'reverb-control-decay reverb-control-decay #f 0.0 2.0)
	      (list 'reverb-control-feedback reverb-control-feedback #t 1.00 1.1)
	      (list 'reverb-control-length reverb-control-length #t 1.0 2.0)
	      (list 'reverb-control-lowpass reverb-control-lowpass #t 0.2 0.99)
	      (list 'reverb-control-scale reverb-control-scale #t 0.0 0.2)
	      (list 'reverb-control? reverb-control? #t #f #t)
	      (list 'show-axes show-axes #f 0 2)
	      (list 'show-transform-peaks show-transform-peaks #f #f #t)
	      (list 'show-indices show-indices #f #f #t)
	      (list 'show-marks show-marks #f #f #t)
	      (list 'show-mix-waveforms show-mix-waveforms #t #f #t)
	      (list 'show-selection-transform show-selection-transform #f #f #t)
	      (list 'show-y-zero show-y-zero #f #f #t)
	      (list 'show-grid show-grid #f #f #t)
	      (list 'grid-density grid-density 1.0 0.1 4.0)
	      (list 'show-sonogram-cursor show-sonogram-cursor #f #f #t)
	      (list 'sinc-width sinc-width #f 4 100)
	      (list 'spectrum-end spectrum-end #f 0.5 0.8)
	      (list 'spectro-hop spectro-hop #f 2 20)
	      (list 'spectrum-start spectrum-start #f 0.0 0.1)
	      (list 'spectro-x-angle spectro-x-angle #f 0.0 90.0)
	      (list 'spectro-x-scale spectro-x-scale #f 0.1 2.0)
	      (list 'spectro-y-angle spectro-y-angle #f 0.0 90.0)
	      (list 'spectro-y-scale spectro-y-scale #f 0.1 2.0)
	      (list 'spectro-z-angle spectro-z-angle #f 0.0 359.0)
	      (list 'spectro-z-scale spectro-z-scale #f 0.1 0.2)
	      (list 'speed-control speed-control #t 0.1 5.0)
	      (list 'speed-control-style speed-control-style #f 0 2)
	      (list 'speed-control-tones speed-control-tones #f 2 100)
	      (list 'sync sync #t 0 5)
	      (list 'sync-style sync-style #f 0 3)
	      (list 'with-verbose-cursor with-verbose-cursor #f #f #t)
	      (list 'wavelet-type wavelet-type #f 0 10)
	      (list 'time-graph? time-graph? #t #f #t)
	      (list 'x-axis-style x-axis-style #f 0 2)
	      (list 'beats-per-minute beats-per-minute #f 60.0 120.0)
	      (list 'beats-per-measure beats-per-measure #f 4 120)
	      (list 'zero-pad zero-pad #f 0 2)
	      (list 'zoom-focus-style zoom-focus-style #f 0 3))))
	  
	  (unless (equal? *transform-type* fourier-transform)
	    (set! (transform-graph? #t #t) #f)
	    (set! *transform-size* (min *transform-size* 128))))
	(set! *sinc-width* 10)
	(if (pair? open-files) (for-each close-sound open-files))
	(set! *sync-style* sync-none))
      (set! (mus-rand-seed) 1234)
      (if (not (= (mus-rand-seed) 1234)) (snd-display "mus-rand-seed: ~A (1234)!" (mus-rand-seed)))
      (let ((val (mus-random 1.0))
	    (val1 (mus-random 1.0)))
	(if (or (fneq val -0.7828) 
		(fneq val1 -0.8804))
	    (snd-display "mus-random: ~A ~A?" val val1))
	(if (= (mus-rand-seed) 1234) (snd-display "mus-rand-seed: ~A!" (mus-rand-seed))))
      (set! (mus-rand-seed) 1234)
      (let ((val (mus-random 1.0))
	    (val1 (mus-random 1.0)))
	(if (or (fneq val -0.7828) 
		(fneq val1 -0.8804))
	    (snd-display "mus-random repeated: ~A ~A?" val val1)))
      (set! (hook-functions after-open-hook) ())
      (set! (hook-functions close-hook) ())
      (set! (hook-functions open-hook) ())
      
      (set! *clipping* #f)
      (for-each close-sound (sounds)))))
    


;;; ---------------- test 15: chan-local vars ----------------

(require snd-rubber.scm)

(define snd_test_15
  (let ()
    (define (smoother y0 y1)
      (do ((v (make-float-vector 11))
	   (angle (if (> y1 y0) pi 0.0)) 
	   (off (* .5 (+ y0 y1))) 
	   (incr (/ pi 10))
	   (scale (* 0.5 (abs (- y1 y0))))
	   (i 0 (+ i 1)))
	  ((= i 10) v)
	(set! (v i) (+ off (* scale (cos (+ angle (* i incr))))))))
    
    (define prefix-it
      (lambda (n id)
	(let* ((ns (number->string n))
	       (digits (length ns)))
	  (key (char->integer #\u) 0 id)
	  (do ((i 0 (+ i 1)))
	      ((= i digits))
	    (key (char->integer (ns i)) 0 id)))))
    
    (define prefix-uit
      (lambda (n id)
	(let ((ns (number->string n)))
	  (do ((digits (length ns))
	       (i 0 (+ i 1)))
	      ((= i digits))
	    (key (char->integer (ns i)) 0 id)))))
    
    (define funcs (list time-graph-type wavo-hop wavo-trace max-transform-peaks show-transform-peaks zero-pad transform-graph-type fft-window 
			with-verbose-cursor fft-log-frequency fft-log-magnitude fft-with-phases min-dB
			wavelet-type transform-size fft-window-alpha fft-window-beta transform-type 
			transform-normalization show-mix-waveforms graph-style dot-size show-axes show-y-zero show-grid show-marks grid-density
			spectro-x-angle spectro-x-scale spectro-y-angle spectro-y-scale spectro-z-angle spectro-z-scale
			spectro-hop spectrum-end spectrum-start graphs-horizontal x-axis-style beats-per-minute beats-per-measure
			cursor-size cursor-style tracking-cursor-style show-sonogram-cursor))
    (define func-names (list 'time-graph-type 'wavo-hop 'wavo-trace 'max-transform-peaks 'show-transform-peaks 'zero-pad 'transform-graph-type 'fft-window
			     'with-verbose-cursor 'fft-log-frequency 'fft-log-magnitude 'fft-with-phases 'min-dB
			     'wavelet-type 'transform-size 'fft-window-alpha 'fft-window-beta 'transform-type
			     'transform-normalization 'show-mix-waveforms 'graph-style 'dot-size 'show-axes 'show-y-zero 'show-grid 'show-marks 'grid-density
			     'spectro-x-angle 'spectro-x-scale 'spectro-y-angle 'spectro-y-scale 'spectro-z-angle 'spectro-z-scale
			     'spectro-hop 'spectrum-end 'spectrum-start 'graphs-horizontal 'x-axis-style 'beats-per-minute 'beats-per-measure
			     'cursor-size 'cursor-style 'tracking-cursor-style 'show-sonogram-cursor
			     ))
    (define new-values (list graph-as-wavogram 12 512 3 #t 32 graph-as-sonogram cauchy-window
			     #t #t #t #t -120.0
			     3 32 .5 .5 autocorrelation
			     0 #t graph-lollipops 8 show-no-axes #t #t #f 1.0
			     32.0 .5 32.0 .5 32.0 .5
			     14 .3 .1 #f x-axis-in-samples 120.0 3
			     15 cursor-cross cursor-cross #t
			     ))
    
    (define test-history-channel 
      (let ((test-equal (lambda (nv new-value)
			  (if (and (number? nv)
				   (not (rational? nv)))
			      (not (fneq nv new-value))
			      (equal? nv new-value)))))
	(lambda (func name new-value snd1 snd2 snd3)
	  (if (not (or (equal? (flatten (func #t #t)) (apply map func (all-chans)))
		       (equal? (flatten (func #t #t)) (apply map func (all-chans-reversed)))))
	      (snd-display "test-history-channel ~A[0]: ~A ~A?" name (flatten (func #t #t)) (apply map func (all-chans))))
	  (let ((old-value (func)))
	    (func snd1 0)
	    (set! (func snd1 0) new-value)
	    (let ((nv (func snd1 0)))
	      (if (not (test-equal nv new-value))
		  (snd-display "test-history-channel set-~A[1]: ~A ~A?" name new-value (func snd1 0))))
	    (set! (func snd3 2) new-value)
	    (let ((nv (func snd3 2)))
	      (if (not (test-equal nv new-value))
		  (snd-display "test-history-channel set-~A[2]: ~A ~A?" name new-value (func snd3 2))))
	    (if (not (test-equal old-value new-value))
		(let ((nv (func snd3 1)))
		  (if (test-equal nv new-value)
		      (snd-display "test-history-channel set-~A[3]: ~A ~A?" name new-value (func snd3 1)))))
	    (set! (func snd2 #t) new-value)
	    (let ((nv (func snd2 1)))
	      (if (not (test-equal nv new-value))
		  (snd-display "test-history-channel set-~A[4]: ~A ~A?" name new-value (func snd2 1))))
	    (set! (func) new-value)
	    (if (not (let chan-equal? ((vals (flatten (func #t #t)))
				       (new-value new-value))
		       (cond ((null? vals))
			     ((pair? vals)
			      (and (chan-equal? (car vals) new-value)
				   (chan-equal? (cdr vals) new-value)))
			     (else (test-equal vals new-value)))))
		(snd-display "test-history-channel ~A[5]: ~A ~A?" name (flatten (func #t #t))
			     (apply map func (all-chans))))
	    (set! (func) old-value)))))
    
    ;; test src-* 
    
    (define freq-peak 
      (let ((interpolated-peak-offset 
	     (lambda (la ca ra)
	       (let ((pk (+ .001 (max la ca ra))))
		 (let ((logla (log (/ (max la .0000001) pk) 10))
		       (logca (log (/ (max ca .0000001) pk) 10))
		       (logra (log (/ (max ra .0000001) pk) 10)))
		   (/ (* 0.5 (- logla logra))
		      (- (+ logla logra)
			 (* 2 logca))))))))
	(lambda (beg ind size)
	  (let ((spectr (snd-spectrum (channel->float-vector beg size ind 0) blackman2-window size))
		(peak0 0.0)
		(pk0loc 0)
		(size2 (/ size 2)))
	    (do ((i 0 (+ i 1)))
		((= i size2) 
		 (list (/ (* (+ pk0loc
				(if (> pk0loc 0)
				    (interpolated-peak-offset 
				     (spectr (- pk0loc 1))
				     (spectr pk0loc)
				     (spectr (+ 1 pk0loc)))
				    0.0))
			     (srate))
			  size)
		       peak0))
	      (when (> (spectr i) peak0)
		(set! peak0 (spectr i))
		(set! pk0loc i)))))))
    
    (define (test-selection ind beg len scaler)
      (set! (selection-member? ind 0) #t)
      (set! (selection-position) beg)
      (set! (selection-framples) len)
      (scale-selection-by scaler)
      (let ((diff 0.0)
	    (pos (edit-position ind 0)))
	(let ((old-reader (make-sampler beg ind 0 1 (- pos 1)))
	      (new-reader (make-sampler beg ind 0 1 pos))
	      (incr (make-one-pole 1.0 -1.0)))
	  (do ((i 0 (+ i 1)))
	      ((= i len))
	    (one-pole incr (abs (- (* scaler (next-sample old-reader)) (next-sample new-reader)))))
	  (set! diff (one-pole incr 0.0))
	  (if (> diff 0.0) (snd-display "diff (~D ~D): ~A" beg len diff))
	  (set! diff 0.0)
	  (set! incr (make-one-pole 1.0 -1.0))
	  (do ((i 0 (+ i 1)))
	      ((= i 100))
	    (one-pole incr (abs (- (next-sample old-reader) (next-sample new-reader)))))
	  (set! diff (one-pole incr 0.0))
	  (if (> diff 0.0) (snd-display "zdiff (~D ~D): ~A" beg len diff))
	  (free-sampler old-reader)
	  (free-sampler new-reader))))
    
    (define (test-selection-to ind beg len maxval)
      (set! (selection-member? ind 0) #t)
      (set! (selection-position) beg)
      (set! (selection-framples) len)
      (scale-selection-to maxval)
      (let ((newmax (float-vector-peak (samples beg len ind 0))))
	(if (fneq newmax maxval)
	    (snd-display "scale-selection-to (~D ~D) ~A: ~A?" beg len maxval newmax))))
    
    (define (play-with-amps sound . amps)
      (do ((chans (chans sound))
	   (chan 0 (+ 1 chan)))
	  ((= chan chans)
	   (start-playing chans (srate sound) #f))   
	(let ((player (make-player sound chan)))
	  (if (not (player? player)) (snd-display "player? ~A -> #f?" player))
	  (if (not (member player (players))) (snd-display "player: ~A, but players: ~A" player (players)))
	  (if (not (equal? (player-home player) (list sound chan)))
	      (snd-display "player-home ~A ~A?" (player-home player) (list sound chan)))
	  (set! (amp-control player) (amps chan))
	  (set! (speed-control player) .5)
	  (set! (expand-control? player) #t)
	  (set! (expand-control player) 2.0)
	  (set! (contrast-control? player) #t)
	  (set! (contrast-control player) 1.0)
	  (set! (reverb-control? player) #t)
	  (set! (reverb-control-scale player) .02)
	  (add-player player))))
    
    ;; examp.scm (commented out)
    (define (sound-via-sound snd1 snd2) ; "sound composition"??
      (let ((intrp (make-sound-interp 0 snd1 0))
	    (len (- (framples snd1 0) 1))
	    (rd (make-sampler 0 snd2 0))
	    (mx (/ 1.0 (maxamp snd2 0))))
	(map-channel (lambda (val) 
		       (sound-interp intrp (floor (* len 0.5 (+ 1.0 (* mx (read-sample rd))))))))))
    ;; test_15
    (lambda ()
      (set! *transform-type* fourier-transform)
      
      (when with-gui
	(do ((clmtest 0 (+ 1 clmtest))) ((= clmtest tests)) 
	  (log-mem clmtest)
	  
	  (let ((obi (open-sound (car (match-sound-files (lambda (file) 
							   (and (not (= (mus-sound-header-type file) mus-raw))
								(= (mus-sound-chans file) 1))))))))
	    
	    (if (not (equal? (all-chans) (list (list obi) (list 0)))) (snd-display "all-chans: ~A?" (all-chans)))
	    (let ((s2i (open-sound (car (match-sound-files (lambda (file) (= (mus-sound-chans file) 2)))))))
	      (if (not (or (equal? (all-chans) (list (list obi s2i s2i) (list 0 0 1)))
			   (equal? (all-chans) (list (list s2i s2i obi) (list 0 1 0)))))
		  (snd-display "all-chans(2): ~A?" (all-chans)))
	      (if (not (string=? (finfo "oboe.snd") "oboe.snd: chans: 1, srate: 22050, Sun/Next, big endian short (16 bits), len: 2.305"))
		  (snd-display "finfo: ~A?" (finfo "oboe.snd")))
	      (close-sound s2i))
	    (close-sound obi)
	    (if (not (equal? (all-chans) '(() ()))) (snd-display "all-chans(0): ~A?" (all-chans)))
	    (set! obi (open-sound "oboe.snd"))
	    (set! (cursor obi) 1000)
	    (let ((tick (locate-zero .001)))
	      (if (not (= tick 1050)) 
		  (snd-display "locate-zero: ~A = ~A (second try: ~A)?" tick (sample tick) (locate-zero .001))))
	    (hook-push graph-hook auto-dot)
	    (hook-push graph-hook superimpose-ffts)
	    (set! (transform-graph? obi 0) #t)
	    (let ((s2i (open-sound (car (match-sound-files (lambda (file) (= (mus-sound-chans file) 2)))))))
	      (if (not (= (chans s2i) 2)) (snd-display "match 2 got ~A with ~A chans" (short-file-name s2i) (chans s2i)))
					;(update-graphs)
	      (hook-remove graph-hook auto-dot)
	      (hook-remove graph-hook superimpose-ffts)
	      (set! (transform-graph? obi 0) #f)
	      (select-sound obi)
	      (let ((m1 (add-mark 100 obi 0)))
		(first-mark-in-window-at-left)
		(if (> (abs (- (left-sample obi 0) 100)) 1) (snd-display "mark-in-window: ~A ~A?" (left-sample obi 0) (mark-sample m1)))
		(delete-mark m1))
	      (close-sound s2i))
	    (safe-make-selection obi)
	    (delete-selection-and-smooth)
	    (if (not (equal? (edit-fragment 0 obi 0) '("" "init" 0 50828))) 
		(snd-display "edit-fragment(0): ~S?" (edit-fragment 0 obi 0)))
	    (if (not (equal? (edit-fragment 1 obi 0) '("delete-samples 1000 1001" "delete" 1000 1001))) 
		(snd-display "edit-fragment(1): ~S?" (edit-fragment 1 obi 0)))
	    (if (not (equal? (edit-fragment 2 obi 0) '("delete-selection-and-smooth" "set" 968 64))) 
		(snd-display "edit-fragment(2): ~S?" (edit-fragment 2 obi 0)))
	    
	    (let ((maxa (maxamp obi)))
	      (normalized-mix "pistol.snd" 1000 0 obi 0)
	      (let ((nmaxa (maxamp obi)))
		(if (fneq maxa nmaxa) (snd-display "normalized-mix: ~A ~A?" maxa nmaxa)))
	      (revert-sound obi))
	    (let ((s2i (open-sound (car (match-sound-files (lambda (file) 
							     (and (= (mus-sound-chans file) 2)
								  (not (= (mus-sound-header-type file) mus-raw))
								  (> (mus-sound-framples file) 1000))))))))
	      (if (not (= (chans s2i) 2)) (snd-display "match 2+1000 got ~A with ~A chans" (short-file-name s2i) (chans s2i)))
	      (let ((o1 (sample 1000 obi 0))
		    (s1 (sample 1000 s2i 0))
		    (s2 (sample 1000 s2i 1)))
		(do-all-chans (lambda (val) (* val 2.0)) "double all samples")
		(let ((o11 (sample 1000 obi 0))
		      (s11 (sample 1000 s2i 0))
		      (s21 (sample 1000 s2i 1)))
		  (if (or (fneq (* 2.0 o1) o11)
			  (fneq (* 2.0 s1) s11)
			  (fneq (* 2.0 s2) s21))
		      (snd-display "do-all-chans: ~A?" (list o1 s1 s2 o11 s11 s21)))))
	      (update-graphs)
	      (let ((m1 (maxamp obi 0))
		    (m2 (maxamp s2i 0))
		    (m3 (maxamp s2i 1))
		    (mc (map maxamp (list obi s2i s2i) '(0 0 1))))
		(if (or (fneq m1 (car mc))
			(fneq m2 (cadr mc))
			(fneq m3 (caddr mc)))
		    (snd-display "map maxamp all-chans: ~A ~A ~A ~A?" m1 m2 m3 mc))
		(set! (sync obi) 1)
		(set! (sync s2i) 1)
		(do-chans (lambda (val) (* val 2.0)) "*2")
		(let ((mc1 (map maxamp (list obi s2i s2i) '(0 0 1))))
		  (if (or (fneq (* 2.0 m1) (car mc1))
			  (fneq (* 2.0 m2) (cadr mc1))
			  (fneq (* 2.0 m3) (caddr mc1)))
		      (snd-display "do-chans: ~A ~A?" mc mc1))
		  (set! (sync obi) 0)
		  (set! (sync s2i) 0)
		  (select-sound s2i)
		  (do-sound-chans (lambda (val) (* val 0.5)) "/2")
		  (let ((mc2 (map maxamp (list obi s2i s2i) '(0 0 1))))
		    (if (or (fneq (* 2.0 m1) (car mc2))
			    (fneq m2 (cadr mc2))
			    (fneq m3 (caddr mc2)))
			(snd-display "do-sound-chans: ~A ~A ~A?" mc mc1 mc2)))
					;		  (if (every-sample? (lambda (val) (> val .5))) (snd-display "every-sample(0)?")) 
		  (if (not (every-sample? (lambda (val) (< val 5.0)))) (snd-display "every-sample(1)?")) 
		  (select-sound obi)
		  (let ((bins (sort-samples 32)))
		    (if (not (= (vector-ref bins 1) 4504)) (snd-display "sort-samples: ~A?" bins)))
		  ))
	      (revert-sound s2i)
	      (revert-sound obi)
	      (set! (sync obi) 3)
	      (set! (sync s2i) 3)
	      (let ((half-way (floor (* 0.5 (framples obi)))))
		(let ((o1 (sample half-way obi 0))
		      (s1 (sample half-way s2i 0))
		      (s2 (sample half-way s2i 1)))
		  (place-sound obi s2i '(0 .5 1 .5))
		  (let ((s21 (sample half-way s2i 0))
			(s22 (sample half-way s2i 1)))
		    (revert-sound s2i)
		    (place-sound obi s2i 45.0)
		    (let ((s31 (sample half-way s2i 0))
			  (s32 (sample half-way s2i 1)))
		      (if (or (fneq (+ s1 (* 0.5 o1)) s21)
			      (fneq (+ s2 (* 0.5 o1)) s22)
			      (fneq s21 s31)
			      (fneq s22 s32))
			  (snd-display "place: ~A " (list o1 s1 s2 s21 s22 s31 s32)))))))
	      (revert-sound s2i)
	      (revert-sound obi)
	      (set! (sync obi) 0)
	      (set! (sync s2i) 0)
	      (if (or (fneq ((compand) 0.0) 0.0)
		      (fneq ((compand) 1.0) 1.0)
		      (fneq ((compand) .1) .2)
		      (fneq ((compand) .99) .997)
		      (fneq ((compand) .95) .984))
		  (snd-display "compand: ~A?" (list ((compand) 0.0) ((compand) 1.0) ((compand) .1) ((compand) .99) ((compand) .95))))
	      
	      (close-sound obi)
	      (revert-sound s2i)
	      (let ((s1 (sample 1000 s2i 0))
		    (s2 (sample 1000 s2i 1)))
		(set! (sync s2i) 4)
		(select-all)
		(unless (= (selection-chans) 2)
		  (snd-display "selection-chans(2): ~A?" (selection-chans))
		  (for-each
		   (lambda (snd)
		     (do ((i 0 (+ i 1)))
			 ((= i (chans snd)))
		       (if (selection-member? snd i)
			   (snd-display "  ~A[~A] at ~A" (short-file-name snd) i (selection-position snd i)))))
		   (sounds)))
		(if (not (= (selection-srate) (srate s2i))) (snd-display "selection-srate: ~A ~A?" (selection-srate) (srate s2i)))
		(when (= (selection-chans) 2)
		  (swap-selection-channels)
		  (if (or (fneq s1 (sample 1000 s2i 1))
			  (fneq s2 (sample 1000 s2i 0)))
		      (snd-display "swap-selection-channels: ~A?" (list s1 s2 (sample 1000 s2i 0) (sample 1000 s2i 1))))))
	      (revert-sound s2i)
	      (close-sound s2i)))
	  
	  (let ((obi (open-sound "oboe.snd")))
	    (select-all)
	    (for-each forget-region (regions))
	    (if (not (null? (regions))) (snd-display "no regions? ~A" (regions)))
	    (let ((id (make-region 100 200 obi 0)))
	      (if (not (equal? (regions) (list id))) (snd-display "make-region regions: ~A?" (regions))))
	    
	    (revert-sound obi)
	    (let ((oldlen (framples obi)))
	      (env-sound-interp '(0 0 1 1 2 0) 2.0 obi 0)
	      (let ((newlen (framples obi)))
		(if (> (abs (- (* 2 oldlen) newlen)) 3)
		    (snd-display "env-sound-interp: ~A ~A?" oldlen newlen))))
	    
	    (revert-sound obi)
	    (granulated-sound-interp '(0 0 1 .1 2 1) 1.0 0.2 '(0 0 1 1 2 0))
	    (if (not (= (edit-position obi 0) 1)) (snd-display "granulated-sound-interp no-op 1?"))
	    (if (< (maxamp obi 0) .15) (snd-display "granulated-sound-interp 1 maxamp: ~A" (maxamp obi 0)))
	    (if (> (abs (- (framples obi 0) 50828)) 1000) (snd-display "granulated-sound-interp 1 framples: ~A" (framples obi 0)))
	    (revert-sound obi)
	    (granulated-sound-interp '(0 0 1 1) 2.0)
	    (if (not (= (edit-position obi 0) 1)) (snd-display "granulated-sound-interp no-op 2?"))
	    (if (< (maxamp obi 0) .145) (snd-display "granulated-sound-interp 2 maxamp: ~A" (maxamp obi 0)))
	    (if (> (abs (- (framples obi 0) 101656)) 1000) (snd-display "granulated-sound-interp 2 framples: ~A" (framples obi 0)))
	    (revert-sound obi)
	    (granulated-sound-interp '(0 0 1 .1 2 1) 1.0 0.2 '(0 0 1 1 2 0) 0.02)
	    (if (not (= (edit-position obi 0) 1)) (snd-display "granulated-sound-interp no-op 3?"))
	    (if (< (maxamp obi 0) .2) (snd-display "granulated-sound-interp 3 maxamp: ~A" (maxamp obi 0)))
	    (if (> (abs (- (framples obi 0) 50828)) 1000) (snd-display "granulated-sound-interp 3 framples: ~A" (framples obi 0)))
	    
	    (close-sound obi))
	  
	  (let-temporarily ((*clm-srate* 22050))
	    (let ((ind (new-sound "test.snd" :size 20)))
	      (set! *print-length* (max *print-length* 20))
	      (offset-channel 1.0)
	      (env-sound '(0 0 1 1))
	      (let ((osc (make-oscil :frequency 1000.0 :initial-phase (+ pi (/ pi 2))))
		    (reader (make-sound-interp 0 ind 0)) 
		    (len (- (framples ind 0) 1)))
		(map-channel (lambda (val) 
			       (sound-interp reader (* len (+ 0.5 (* 0.5 (oscil osc)))))))
		(if (not (mus-arrays-equal? (channel->float-vector) #r(0.0 0.020 0.079 0.172 0.291 0.427 0.569 0.706 0.825 0.919 
										  0.979 1.000 0.981 0.923 0.831 0.712 0.576 0.434 0.298 0.177)))
		    (snd-display "sound-interp: ~A" (channel->float-vector))))
	      (undo)
	      
	      (let ((osc (make-oscil :frequency 0.5 :initial-phase (+ pi (/ pi 2))))
		    (reader (make-sound-interp 0 ind 0))
		    (len (- (framples ind 0) 1)))
		(map-channel (lambda (val) 
			       (sound-interp reader (* len (+ 0.5 (* 0.5 (oscil osc))))))))
	      (undo)
	      
	      (env-sound-interp '(0 0 1 1))
	      (if (not (mus-arrays-equal? (channel->float-vector) #r(0.0 0.053 0.105 0.158 0.211 0.263 0.316 0.368 0.421 0.474 
										0.526 0.579 0.632 0.684 0.737 0.789 0.842 0.895 0.947 1.000)))
		  (snd-display "env-sound-interp no change: ~A" (channel->float-vector)))
	      (undo)
	      (env-sound-interp '(0 0 1 .95 2 0) 2.0)
	      (if (not (mus-arrays-equal? (channel->float-vector) #r(0.0 0.050 0.100 0.150 0.200 0.250 0.300 0.350 0.400 0.450 
										0.500 0.550 0.600 0.650 0.700 0.750 0.800 0.850 0.900 0.950
										1.000 0.950 0.900 0.850 0.800 0.750 0.700 0.650 0.600 0.550 
										0.500 0.450 0.400 0.350 0.300 0.250 0.200 0.150 0.100 0.050)))
		  (snd-display "env-sound-interp twice len and back: ~A" (channel->float-vector)))
	      (revert-sound ind)
	      (set! (sample 10) .5)
	      (remove-clicks)
	      (if (fneq (sample 10) 0.0) (snd-display "remove-clicks: ~A" (channel->float-vector)))
	      (undo)
	      (let ((vals (scan-channel (search-for-click))))
		(if (not (= vals 11))
		    (snd-display "search-for-click: ~A" vals)))
	      (close-sound ind)))
	  
	  (let ((ind1 (new-sound :size 20 :comment "new-sound for sound-via-sound"))
		(ind2 (new-sound :size 20 :comment "second new-sound for sound-via-sound")))
	    (let ((val -0.05)) (map-channel (lambda (y) (set! val (+ val .05))) 0 20 ind1))
	    (let ((val 1.1)) (map-channel (lambda (y) (set! val (- val .1))) 0 20 ind2))
	    (select-sound ind1)
	    (sound-via-sound ind1 ind2)
	    (let ((vals (channel->float-vector 0 20 ind1)))
	      (if (not (mus-arrays-equal? vals #r(0.95 0.90 0.85 0.80 0.75 0.70 0.65 0.60 0.55 0.50 0.45 0.40 0.35 0.30 0.25 0.20 0.15 0.10 0.05 0.00)))
		  (snd-display "sound-via-sound: ~A" vals)))
	    (clean-up-sound ind2)
	    (revert-sound ind1)
	    (let ((val -.5)) (map-channel (lambda (y) (set! val (+ val .05)))))
	    (let ((val (scan-channel (zero+))))
	      (if (not (eqv? val 10))
		  (snd-display "zero+: ~A" val)))
	    (set! (sample 8) .8)
	    (let ((val (scan-channel (next-peak))))
	      (if (not (eqv? val 9))
		  (snd-display "next-peak: ~A" val)))
	    (let ((val (scan-channel (search-for-click))))
	      (if (not (eqv? val 9))
		  (snd-display "search-for-click: ~A" val)))
	    (if (not (= (find-click 0) 8)) (snd-display "find-click: ~A" (find-click 0)))
	    (clean-up-sound ind1))
	  
	  (let ((id (open-sound "oboe.snd")))
	    (let ((fr (framples id 0))
		  (mx (maxamp id 0)))
	      (set! (framples id 0) 25000)
	      (if (not (= (framples id 0) 25000)) (snd-display "set-framples 25000: ~A?" (framples id 0)))
	      (if (not (= (edit-position id 0) 1)) (snd-display "set-framples 25000 edit: ~A?" (edit-position id 0)))
	      (set! (framples id 0) 75000)
	      (if (not (= (framples id 0) 75000)) (snd-display "set-framples 75000: ~A?" (framples id 0)))
	      (if (not (= (edit-position id 0) 2)) (snd-display "set-framples 75000 edit: ~A?" (edit-position id 0)))
	      (if (fneq (sample 30000 id 0) 0.0) (snd-display "set-framples 75000 zeros: ~A?" (sample 30000 id 0)))
	      (set! (framples id 0) 0)
	      (if (not (= (framples id 0) 0)) (snd-display "set-framples 0: ~A?" (framples id 0)))
	      (set! (framples id 0) 100)
	      (if (not (= (framples id 0) 100)) (snd-display "set-framples 100: ~A?" (framples id 0)))
	      (revert-sound)
	      (if (fneq (sample 30000 id 0) -0.0844) (snd-display "revert from set-framples: ~A?" (sample 30000 id 0)))
	      (if (not (= fr (framples id 0))) (snd-display "revert set-framples: ~A != ~A?" (framples id 0) fr))
	      (set! (maxamp id 0) .5)
	      (if (fneq (maxamp id 0) .5) (snd-display "set-maxamp: ~A?" (maxamp id 0)))
	      (if (not (= (edit-position id 0) 1)) (snd-display "set-maxamp edit: ~A?" (edit-position id 0)))
	      (set! (maxamp id 0) .1)
	      (if (fneq (maxamp id 0) .1) (snd-display "set-maxamp .1: ~A?" (maxamp id 0)))
	      (if (not (= (edit-position id 0) 2)) (snd-display "set-maxamp .1 edit: ~A?" (edit-position id 0)))
	      (revert-sound)
	      (if (fneq (maxamp id 0) mx) (snd-display "maxamp after set: ~A ~A?" (maxamp id 0) mx))
	      (set! (x-position-slider id 0) .1)
	      (if (fneq (x-position-slider id 0) .1) (snd-display "set x-position-slider .1: ~A?" (x-position-slider id 0)))
	      
	      (set! (x-zoom-slider id 0) .5)
	      (if (fneq (x-zoom-slider id 0) .5) (snd-display "set x-zoom-slider: ~A?" (x-zoom-slider id 0)))
	      (if (> (abs (- fr (* 2 (- (right-sample id 0) (left-sample id 0))))) 10)
		  (snd-display "set x-zoom-slider: ~A ~A -> ~A?" 
			       (left-sample id 0) (right-sample id 0)
			       (abs (- fr (* 2 (right-sample id 0) (left-sample id 0))))))
	      (set! (y-position-slider id 0) .1)
	      (if (and (not (provided? 'snd-gtk)) (fneq (y-position-slider id 0) .1))
		  (snd-display "set y-position-slider .1: ~A?" (y-position-slider id 0)))
	      (set! (y-zoom-slider id 0) .5)
	      (if (fneq (y-zoom-slider id 0) .5) (snd-display "set y-zoom-slider: ~A?" (y-zoom-slider id 0)))
	      (let ((vals (channel-amp-envs "oboe.snd" 0 10)))
		(if (not (and (mus-arrays-equal? (car vals)
						 #r(-4.8828125e-4 -0.104156494140625 -0.125213623046875 -0.1356201171875 -0.138916015625 
							       -0.14093017578125 -0.14093017578125 -0.131439208984375 -0.11248779296875 -0.080047607421875))
			      (mus-arrays-equal? (cadr vals)
						 #r(0.0 0.10955810546875 0.130706787109375 0.14068603515625 0.141204833984375 0.147247314453125 
							       0.145904541015625 0.140289306640625 0.126861572265625 0.08172607421875))))
		    (snd-display "channel-amp-envs: ~A?" vals)))
	      
	      (let ((len (length (channel-properties id 0))))
		(if (channel-property 'hiho id 0)
		    (snd-display "channel-property 'hiho: ~A?" (channel-property 'hiho id 0)))
		(set! (channel-property 'hiho id 0) 123)
		(if (not (= (channel-property 'hiho id 0) 123))
		    (snd-display "channel-property 'hiho (123): ~A?" (channel-property 'hiho id 0)))
		(if (channel-property 'hi id 0)
		    (snd-display "channel-property 'hi: ~A?" (channel-property 'hi id 0)))
		(set! (channel-property 'hi id 0) pi)
		(if (fneq (channel-property 'hi id 0) pi)
		    (snd-display "channel-property 'hi (pi): ~A?" (channel-property 'hi id 0)))
		(if (not (= (channel-property 'hiho id 0) 123))
		    (snd-display "channel-property 'second hiho (123): ~A?" (channel-property 'hiho id 0)))
		(if (not (= (length (channel-properties id 0)) (+ len 2)))
		    (snd-display "channel-properties: ~A?" (channel-properties id 0))))
	      
	      (let ((len (length (sound-properties id))))
		(if (sound-property 'hiho id)
		    (snd-display "sound-property 'hiho: ~A?" (sound-property 'hiho id)))
		(set! (sound-property 'hiho id) 123)
		(if (not (= (sound-property 'hiho id) 123))
		    (snd-display "sound-property 'hiho (123): ~A?" (sound-property 'hiho id)))
		(if (sound-property 'hi id)
		    (snd-display "sound-property 'hi: ~A?" (sound-property 'hi id)))
		(set! (sound-property 'hi id) pi)
		(if (fneq (sound-property 'hi id) pi)
		    (snd-display "sound-property 'hi (pi): ~A?" (sound-property 'hi id)))
		(if (not (= (sound-property 'hiho id) 123))
		    (snd-display "sound-property 'second hiho (123): ~A?" (sound-property 'hiho id)))
		(if (not (= (length (sound-properties id)) (+ len 2)))
		    (snd-display "sound-properties: ~A?" (sound-properties id))))
	      
	      (let ((tag (catch #t (lambda () (map-channel (lambda (y) (copy "hiho")))) (lambda args args))))
		(if (not (memq (car tag) '(bad-type wrong-type-arg))) (snd-display "map-channel bad val: ~A" tag)))
	      
	      (close-sound id)))
	  
	  (let ((ind (open-sound "oboe.snd")))
	    (if (not (null? (edit-properties ind 0 0)))
		(snd-display "initial edit-properties: ~A?" (edit-properties ind 0 0)))
	    (let ((tag (catch #t
			 (lambda () (edit-properties ind 0 123))
			 (lambda args (car args)))))
	      (if (not (eq? tag 'no-such-edit))
		  (snd-display "edit-properties of non-existent edit: ~A" tag)))
	    (let ((tag (catch #t
			 (lambda () (edit-properties ind 1 0))
			 (lambda args (car args)))))
	      (if (not (eq? tag 'no-such-channel))
		  (snd-display "edit-properties of non-existent channel: ~A" tag)))
	    (if (edit-property 'test-key ind 0 0)
		(snd-display "edit-property never set: ~A?" (edit-property ind 0 0)))
	    (set! (edit-property 'test-key ind 0 0) 3210)
	    (let ((val (edit-property 'test-key ind 0 0)))
	      (if (not (eqv? val 3210))
		  (snd-display "edit-property 0: ~A" val)))
	    (pad-channel 0 10 ind 0)
	    (let ((val (edit-property 'test-key ind 0 0)))
	      (if (not (eqv? val 3210))
		  (snd-display "edit-property look back to 0: ~A" val)))
	    (let ((val (edit-property 'test-key ind 0 1)))
	      (if val (snd-display "edit-property current: ~A?" val)))
	    (undo)
	    (let ((val (edit-property 'test-key ind 0 0)))
	      (if (not (eqv? val 3210))
		  (snd-display "edit-property go back to 0: ~A" val)))
	    (close-sound ind))
	  (let ((ind (open-sound "oboe.snd")))
	    (if (edit-property 'test-key ind 0 0)
		(snd-display "edit-property not cleared: ~A?" (edit-property ind 0 0)))
	    (pad-channel 0 10 ind 0)
	    (set! (edit-property 'test-key ind 0 1) 'hiho)
	    (undo)
	    (pad-channel 0 10 ind 0)
	    (let ((val (edit-property 'test-key ind 0 1)))
	      (if val (snd-display "edit-property not erased upon re-edit: ~A?" val)))
	    (close-sound ind))
	  
	  (let ((id (open-sound "oboe.snd")))
	    (prefix-it 1000 id)
	    (key (char->integer #\x) 4 id)
	    (key (char->integer #\b) 4 id)
	    (let ((left (left-sample id)))
	      (if (not (= left 1000)) (snd-display "u1000: ~A" left)))
	    (prefix-it 0 id)
	    (key (char->integer #\x) 4 id)
	    (key (char->integer #\b) 4 id)
	    (let ((left (left-sample id)))
	      (if (not (= left 0)) (snd-display "u0: ~A" left)))
	    (set! (cursor id) 1234)
	    (prefix-it 0 id)
	    (key (char->integer #\f) 4 id)
	    (let ((cr (cursor id)))
	      (if (not (= cr 1234)) (snd-display "0f: ~A" cr)))
	    (prefix-it 100 id)
	    (key (char->integer #\f) 4 id)
	    (let ((cr (cursor id)))
	      (if (not (= cr 1334)) (snd-display "100f: ~A" cr)))
	    (prefix-it -100 id)
	    (key (char->integer #\f) 4 id)
	    (let ((cr (cursor id)))
	      (if (not (= cr 1234)) (snd-display "-100f: ~A" cr)))
	    (prefix-it 1 id)
	    (key (char->integer #\f) 4 id)
	    (let ((cr (cursor id)))
	      (if (not (= cr 1235)) (snd-display "1f: ~A" cr)))
	    (prefix-it 1000 id)
	    (key (char->integer #\x) 4 id)
	    (key (char->integer #\p) 4 id)
	    (let ((left (left-sample id))
		  (right (right-sample id)))
	      (if (> (abs (- right left 1000)) 2) (snd-display "1000xp: ~A:~A" left right)))
	    (prefix-it 1 id)
	    (key (char->integer #\.) 0 id)
	    (key (char->integer #\2) 0 id)
	    (key (char->integer #\x) 4 id)
	    (key (char->integer #\p) 4 id)
	    (let ((left (left-sample id))
		  (right (right-sample id)))
	      (if (> (abs (- right left (* 22050 1.2))) 2) (snd-display "1.2xp: ~A:~A" left right)))
	    
	    (prefix-uit 1000 id)
	    (key (char->integer #\x) 4 id)
	    (key (char->integer #\b) 4 id)
	    (let ((left (left-sample id)))
	      (if (not (member left '(1000 1001) =)) (snd-display "uu1000: ~A" left)))
	    (prefix-uit 0 id)
	    (key (char->integer #\x) 4 id)
	    (key (char->integer #\b) 4 id)
	    (let ((left (left-sample id)))
	      (if (not (= left 0)) (snd-display "uu0: ~A" left)))
	    (set! (cursor id) 1234)
	    (prefix-uit 0 id)
	    (key (char->integer #\f) 4 id)
	    (let ((cr (cursor id)))
	      (if (not (= cr 1234)) (snd-display "u0f: ~A" cr)))
	    (prefix-uit 100 id)
	    (key (char->integer #\f) 4 id)
	    (let ((cr (cursor id)))
	      (if (not (= cr 1334)) (snd-display "u100f: ~A" cr)))
	    (prefix-uit -100 id)
	    (key (char->integer #\f) 4 id)
	    (let ((cr (cursor id)))
	      (if (not (= cr 1234)) (snd-display "u-100f: ~A" cr)))
	    (prefix-uit 1 id)
	    (key (char->integer #\f) 4 id)
	    (let ((cr (cursor id)))
	      (if (not (= cr 1235)) (snd-display "u1f: ~A" cr)))
	    (prefix-uit 1000 id)
	    (key (char->integer #\x) 4 id)
	    (key (char->integer #\p) 4 id)
	    (let ((left (left-sample id))
		  (right (right-sample id)))
	      (if (> (abs (- right left 1000)) 2) (snd-display "u1000xp: ~A:~A" left right)))
	    (prefix-uit 1 id)
	    (key (char->integer #\.) 0 id)
	    (key (char->integer #\2) 0 id)
	    (key (char->integer #\x) 4 id)
	    (key (char->integer #\p) 4 id)
	    (let ((left (left-sample id))
		  (right (right-sample id)))
	      (if (> (abs (- right left (* 22050 1.2))) 2) (snd-display "u1.2xp: ~A:~A" left right)))
	    (close-sound id))
	  (let ((id (open-sound (car (match-sound-files (lambda (file) 
							  (and (>= (mus-sound-chans file) 2)
							       (not (= (mus-sound-header-type file) mus-raw))
							       (> (mus-sound-framples file) 1000))))))))
	    (set! (sync id) 1)
	    (select-sound id)
	    (make-region 200 500 id)
	    (select-channel 1)
	    (key (char->integer #\x) 4 id)
	    (key (char->integer #\v) 0 id)
	    (let ((x0 (x-bounds id 0))
		  (x1 (x-bounds id 1)))
	      (if (or (fneq (car x0) (car x1)) 
		      (fneq (cadr x0) (cadr x1)))
		  (snd-display "C-X v: ~A ~A?" x0 x1)))
	    (key (char->integer #\u) 4 id)
	    (key (char->integer #\1) 0 id)
	    (key (char->integer #\x) 4 id)
	    (key (char->integer #\q) 0 id)
	    (close-sound id))
	  
	  (let ((snd3 (open-sound "4.aiff")))
	    (let ((snd1 (open-sound "oboe.snd"))
		  (snd2 (or (open-sound "2.snd") (open-sound "4.aiff"))))
	      (do ((f funcs (cdr f))
		   (fn func-names (cdr fn))
		   (nv new-values (cdr nv)))
		  ((not (pair? f)))
		(test-history-channel (car f) (car fn) (car nv) snd1 snd2 snd3))
	      (close-sound snd1)
	      (close-sound snd2))
	    
	    (set! (time-graph-style snd3 #t) graph-filled)
	    (do ((i 0 (+ i 1))) ((= i 4)) 
	      (if (not (= (time-graph-style snd3 i) graph-filled)) 
		  (snd-display "set time-graph-style ~A ~A: ~A" snd3 i (time-graph-style snd3 i))))
	    (set! (time-graph-style snd3 2) graph-lines)
	    (do ((i 0 (+ i 1))) ((= i 4)) 
	      (if (not (or (= i 2)
			   (= (time-graph-style snd3 i) graph-filled)))
		  (snd-display "set (2) time-graph-style ~A ~A: ~A" snd3 i (time-graph-style snd3 i))))
	    (if (not (= (time-graph-style snd3 2) graph-lines)) 
		(snd-display "set time-graph-style (2): ~A" (time-graph-style snd3 2)))
	    (set! (time-graph-style snd3 #t) graph-dots)
	    (do ((i 0 (+ i 1))) ((= i 4)) 
	      (if (not (= (time-graph-style snd3 i) graph-dots)) 
		  (snd-display "set time-graph-style (all): ~A" (time-graph-style snd3 i))))
	    (set! *graph-style* graph-dots-and-lines)
	    (do ((i 0 (+ i 1))) ((= i 4)) 
	      (if (not (= (time-graph-style snd3 i) graph-dots-and-lines)) 
		  (snd-display "set time-graph-style (dal): ~A" (time-graph-style snd3 i))))
	    
	    (set! (lisp-graph-style snd3 #t) graph-filled)
	    (do ((i 0 (+ i 1))) ((= i 4)) 
	      (if (not (= (lisp-graph-style snd3 i) graph-filled)) 
		  (snd-display "set lisp-graph-style ~A ~A: ~A" snd3 i (lisp-graph-style snd3 i))))
	    (set! (lisp-graph-style snd3 2) graph-lines)
	    (do ((i 0 (+ i 1))) ((= i 4)) 
	      (if (not (or (= i 2)
			   (= (lisp-graph-style snd3 i) graph-filled)))
		  (snd-display "set (2) lisp-graph-style ~A ~A: ~A" snd3 i (lisp-graph-style snd3 i))))
	    (if (not (= (lisp-graph-style snd3 2) graph-lines)) 
		(snd-display "set lisp-graph-style (2): ~A" (lisp-graph-style snd3 2)))
	    (set! (lisp-graph-style snd3 #t) graph-lines)
	    (do ((i 0 (+ i 1))) ((= i 4)) 
	      (if (not (= (time-graph-style snd3 i) graph-dots-and-lines)) 
		  (snd-display "set lisp -> time-graph-style (dal): ~A" (time-graph-style snd3 i))))
	    
	    (set! (transform-graph-style snd3 #t) graph-filled)
	    (do ((i 0 (+ i 1))) ((= i 4)) 
	      (if (not (= (transform-graph-style snd3 i) graph-filled)) 
		  (snd-display "set transform-graph-style ~A ~A: ~A" snd3 i (transform-graph-style snd3 i))))
	    (set! (transform-graph-style snd3 2) graph-lines)
	    (do ((i 0 (+ i 1))) ((= i 4)) 
	      (if (not (or (= i 2)
			   (= (transform-graph-style snd3 i) graph-filled)))
		  (snd-display "set (2) transform-graph-style ~A ~A: ~A" snd3 i (transform-graph-style snd3 i))))
	    (if (not (= (transform-graph-style snd3 2) graph-lines)) 
		(snd-display "set transform-graph-style (2): ~A" (transform-graph-style snd3 2)))
	    (do ((i 0 (+ i 1))) ((= i 4)) 
	      (if (not (= (time-graph-style snd3 i) graph-dots-and-lines)) 
		  (snd-display "set fft and lisp -> time-graph-style (dal): ~A" (time-graph-style snd3 i))))
	    (do ((i 0 (+ i 1))) ((= i 4)) 
	      (if (not (= (lisp-graph-style snd3 i) graph-lines)) 
		  (snd-display "set fft and lisp -> lisp-graph-style (dal): ~A" (lisp-graph-style snd3 i))))
	    
	    (close-sound snd3))
	  
	  (let ((snd2 (open-sound "2.snd")))
	    (if (sound? snd2)
		(play-with-amps snd2 0.2 0.1))
	    (close-sound snd2))
	  
	  (let-temporarily ((*with-background-processes* #f))
	    (let* ((ind (open-sound "1a.snd"))
		   (player (make-player ind 0))
		   (len (framples ind 0)))
	      (let ((e (make-env '(0 0 1 1) :length (+ 1 (floor (* 1.0 (/ len *dac-size*))))))
		    (samp 0))
		(add-player player 0 -1 -1 
			    (lambda (reason) 
			      (set! (hook-functions play-hook) ())
			      (close-sound ind)))
		(hook-push play-hook 
			   (lambda (hook)
			     (set! (amp-control player) (env e))
			     (if (fneq (amp-control ind) 1.0) (snd-display "amp-control snd: ~A" (amp-control ind)))
			     (if (> (abs (- (amp-control player) (* 1.0 (/ samp len)))) 1.0)
				 (snd-display "amp-control player: ~A ~A" (amp-control player) (* 1.0 (/ samp len))))
			     (set! samp (+ samp *dac-size*))))
		(start-playing 1 (srate ind))))
	    (if (find-sound "1a.snd") (snd-display "stop proc didn't close?")))
	  
	  (let ((ind (open-sound "pistol.snd")))
	    (if (selection-member? ind 0) 
		(snd-display "initial selection-member? ~A ~A?" 
			     (selection-member? ind 0)
			     (selection?)))
	    (set! (selection-member? ind 0) #t)
	    (if (not (and (selection-member? ind 0)
			  (selection-member? ind)))
		(snd-display "selection-member? ~A ~A ~A?" 
			     (selection-member? ind 0)
			     (selection-member? ind)
			     (selection?)))
	    (if (not (= (selection-framples) 1))
		(snd-display "initial selection-framples: ~A?" (selection-framples)))
	    (set! (selection-framples) 1200)
	    (if (not (= (selection-framples) 1200))
		(snd-display "selection-framples: 1200 ~A?" (selection-framples)))
	    (delete-selection)
	    (if (selection?) (snd-display "selection active after cut?"))
	    (undo)
	    (if (not (selection?)) (snd-display "selection inactive after undo?"))
	    (if (not (and (selection-member? ind 0)
			  (selection-member? ind)))
		(snd-display "selection-member? after undo ~A ~A ~A?" 
			     (selection-member? ind 0)
			     (selection-member? ind)
			     (selection?)))
	    (if (not (and (= (selection-framples) 1200)
			  (= (selection-position) 0)))
		(snd-display "selection after undo: '(0 1200) '(~A ~A)?" 
			     (selection-position) 
			     (selection-framples)))
	    (set! (selection-position) 1000)
	    (if (not (and (= (selection-framples) 200)
			  (= (selection-position) 1000)))
		(snd-display "selection after reposition: '(1000 200) '(~A ~A)?" 
			     (selection-position) 
			     (selection-framples)))
	    (reverse-selection)
	    (if (not (and (= (selection-framples) 200)
			  (= (selection-position) 1000)))
		(snd-display "selection after reverse: '(1000 200) '(~A ~A)?" 
			     (selection-position) 
			     (selection-framples)))
	    
	    (let ((old-framples (framples ind)))
	      (src-selection .5)
	      (if (or (> (abs (- (framples ind) 200 old-framples)) 5)
		      (> (abs (- (selection-framples) 400)) 5))
		  (snd-display "selection after src .5: '(1000 400) '(~A ~A)?" 
			       (selection-position) 
			       (selection-framples)))
	      (undo)
	      (redo)
	      (if (or (> (abs (- (framples ind) 200 old-framples)) 5)
		      (> (abs (- (selection-framples) 400)) 5))
		  (snd-display "selection after src .5 with undo/redo: '(1000 400) '(~A ~A)?" 
			       (selection-position) 
			       (selection-framples)))
	      (undo 3))
	    (close-sound ind))
	  
	  (set! *clm-srate* 22050)
	  (let ((ind (new-sound "test.snd" 1 22050 mus-ldouble mus-next "src-* tests" 10000))
		(osc (make-oscil 500))
		(f3neq (lambda (a b) (> (abs (- a b)) 10)))
		(f4neq (lambda (a b) (> (abs (- a b)) 1)))
		(f5neq (lambda (a b) (> (abs (- a b)) (* .05 (max a b))))))
	    
	    ;; src-duration tests
	    (if (or (fneq (src-duration '(0 1 1 2)) 0.693147180559945)
		    (fneq (src-duration '(0 2 1 1)) (src-duration '(0 1 1 2)))
		    (fneq (src-duration '(0 1 .5 2)) (src-duration '(0 1 1 2)))
		    (fneq (src-duration '(.5 1 .75 2)) (src-duration '(0 1 1 2))))
		(snd-display "src-duration test1 ~A ~A ~A ~A"
			     (src-duration '(0 1 1 2))
			     (src-duration '(0 2 1 1))
			     (src-duration '(0 1 .5 2))
			     (src-duration '(.5 1 .75 2))))
	    (if (or (fneq (src-duration '(0 1 1 0.5)) 1.38629436111989)
		    (fneq (src-duration '(0 0.5 1 1)) (src-duration '(0 1 1 0.5)))
		    (fneq (src-duration '(0 1 .5 0.5)) (src-duration '(0 1 1 0.5)))
		    (fneq (src-duration '(.5 1 .75 0.5)) (src-duration '(0 1 1 0.5))))
		(snd-display "src-duration test2 ~A ~A ~A ~A"
			     (src-duration '(0 1 1 0.5))
			     (src-duration '(0 0.5 1 1))
			     (src-duration '(0 1 .5 0.5))
			     (src-duration '(.5 1 .75 0.5))))
	    (if (or (fneq (src-duration '(0 1 1 1)) 1.0)
		    (fneq (src-duration '(0 2 1 2)) 0.5))
		(snd-display "src-duration test3: ~A ~A" (src-duration '(0 1 1 1)) (src-duration '(0 2 1 2))))
	    (if (fneq (src-duration '(0 .5 .5 3 .6 1 .7 .1 .8 1.5 1 1)) 1.02474349685432)
		(snd-display "src-duration test4 ~A" (src-duration '(0 .5 .5 3 .6 1 .7 .1 .8 1.5 1 1))))
	    (if (fneq (src-duration '(0 1 1 2 2 1)) 0.693147180559945)
		(snd-display "src-duration test5: ~A" (src-duration '(0 1 1 2 2 1))))
	    (if (fneq (src-duration '(0 1 1 1)) 1.0)
		(snd-display "src-duration test6: ~A" (src-duration '(0 1 1 1))))
	    (if (fneq (src-duration '(0 2 1 2)) 0.5)
		(snd-display "src-duration test7: ~A" (src-duration '(0 2 1 2))))
	    (if (fneq (src-duration '(0 0.5 2 0.5)) 2.0)
		(snd-display "src-duration test8: ~A" (src-duration '(0 0.5 2 0.5))))
	    
	    (if (fneq (src-duration (src-fit-envelope '(0 1 1 2) 2.0)) 2.0)
		(snd-display "src-fit-envelope 2.0: ~A" (src-duration (src-fit-envelope '(0 1 1 2) 2.0))))
	    (if (fneq (src-duration (src-fit-envelope '(0 1 1 2) 0.5)) 0.5)
		(snd-display "src-fit-envelope 0.5: ~A" (src-duration (src-fit-envelope '(0 1 1 2) 0.5))))
	    
	    
	    (if (fneq (fm-parallel-component 100 100.0 '(100.0 300.0 400.0) '(1.0 0.5 0.25) () () #t) 0.69287)
		(snd-display "fm-parallel-component 100: ~A" (fm-parallel-component 100 100.0 '(100.0 300.0 400.0) '(1.0 0.5 0.25) () () #t)))
	    (if (fneq (fm-parallel-component 500 100.0 '(100.0 300.0 400.0) '(1.0 0.5 0.25) () () #t) 0.17047)
		(snd-display "fm-parallel-component 500: ~A" (fm-parallel-component 500 100.0 '(100.0 300.0 400.0) '(1.0 0.5 0.25) () () #t)))
	    
	    (if (fneq (cheby-hka 3 0.25 #r(0 0 0 0 1.0 1.0)) -0.0732421875)
		(snd-display "cheby-hka 0: ~A" (cheby-hka 3 0.25 #r(0 0 0 0 1.0 1.0))))
	    (if (fneq (cheby-hka 2 0.25 #r(0 0 0 0 1.0 1.0)) -0.234375)
		(snd-display "cheby-hka 1: ~A" (cheby-hka 2 0.25 #r(0 0 0 0 1.0 1.0))))
	    (if (fneq (cheby-hka 1 0.25 #r(0 0 0 0 1.0 1.0)) 1.025390625)
		(snd-display "cheby-hka 2: ~A" (cheby-hka 1 0.25 #r(0 0 0 0 1.0 1.0))))
	    (if (fneq (cheby-hka 0 0.25 #r(0 0 0 0 1.0 1.0)) 1.5234375)
		(snd-display "cheby-hka 3: ~A" (cheby-hka 0 0.25 #r(0 0 0 0 1.0 1.0))))
	    
	    (map-channel (lambda (y) (* .5 (oscil osc))))
	    (let ((vals (freq-peak 0 ind 8192)))
	      (if (or (f4neq (car vals) 500.0)
		      (fneq (cadr vals) 1.0))
		  (snd-display "src no-test: ~A" vals)))
	    (for-each
	     (lambda (sr dur)
	       (src-sound sr 1.0 ind 0)
	       (if (fneq (/ (framples ind 0) 10000.0) dur) (snd-display "src-sound ~A: ~A (~A)" sr (/ (framples ind 0) 10000.0) dur))
	       (let ((vals (freq-peak 0 ind 8192)))
		 (if (or (f4neq (car vals) (* 500 sr))
			 (fneq (cadr vals) 1.0))
		     (snd-display "src ~A freq: ~A" sr vals)))
	       (undo))
	     '(2.0 0.5 5.0 0.2)
	     '(0.5 2.0 0.2 5.0))
	    (for-each
	     (lambda (e f0 f1)
	       (src-sound e 1.0 ind 0)
	       (if (fneq (/ (framples ind 0) 10000.0) (src-duration e))
		   (snd-display "src-sound (env) ~A: ~A (~A)" 
				e (/ (framples ind 0) 10000.0) (src-duration e)))
	       (let ((vals (freq-peak 0 ind 256)))
		 (if (f5neq (car vals) f0)
		     (snd-display "src (env) 0 ~A freq: ~A" f0 vals)))
	       (let ((vals (freq-peak (- (floor (* (src-duration e) 10000.0)) 256) ind 256)))
		 (if (f5neq (car vals) f1)
		     (snd-display "src (env) 1 ~A freq: ~A" f1 vals)))
	       (undo))
	     '((0 1 1 2) (0 2 1 1) (0 1 1 2 2 1) (0 0.5 1 1) (0 0.5 1 2))
	     '(500.0 1000.0 500.0 250.0 250.0)
	     '(1000.0 500.0 500.0 500.0 1000.0))
	    (for-each
	     (lambda (e f0 f1)
	       (src-sound (make-env e :length (framples)) 1.0 ind 0)
	       (if (fneq (/ (framples ind 0) 10000.0) (src-duration e))
		   (snd-display "src-sound (make-env) ~A: ~A (~A)" 
				e (/ (framples ind 0) 10000.0) (src-duration e)))
	       (let ((vals (freq-peak 0 ind 256)))
		 (if (f5neq (car vals) f0)
		     (snd-display "src (make-env) 0 ~A freq: ~A" f0 vals)))
	       (let ((vals (freq-peak (- (floor (* (src-duration e) 10000.0)) 256) ind 256)))
		 (if (f5neq (car vals) f1)
		     (snd-display "src (env) 1 ~A freq: ~A" f1 vals)))
	       (undo))
	     '((0 1 1 2) (0 2 1 1) (0 1 1 2 2 1) (0 0.5 1 1) (0 0.5 1 2))
	     '(500.0 1000.0 500.0 250.0 250.0)
	     '(1000.0 500.0 500.0 500.0 1000.0))
	    
	    (for-each
	     (lambda (sr dur)
	       (src-channel sr)
	       (if (fneq (/ (framples ind 0) 10000.0) dur) (snd-display "src-channel ~A: ~A (~A)" sr (/ (framples ind 0) 10000.0) dur))
	       (let ((vals (freq-peak 0 ind 8192)))
		 (if (or (f4neq (car vals) (* 500 sr))
			 (fneq (cadr vals) 1.0))
		     (snd-display "src ~A freq: ~A" sr vals)))
	       (undo))
	     '(2.0 0.5 5.0 0.2)
	     '(0.5 2.0 0.2 5.0))
	    (for-each
	     (lambda (e f0 f1)
	       (src-channel e)
	       (if (fneq (/ (framples ind 0) 10000.0) (src-duration e))
		   (snd-display "src-channel (env) ~A: ~A (~A)" 
				e (/ (framples ind 0) 10000.0) (src-duration e)))
	       (let ((vals (freq-peak 0 ind 256)))
		 (if (f5neq (car vals) f0)
		     (snd-display "src-channel (env f0) ~A: ~A" f0 vals)))
	       (let ((vals (freq-peak (- (floor (* (src-duration e) 10000.0)) 256) ind 256)))
		 (if (f5neq (car vals) f1)
		     (snd-display "src-channel (env f1) ~A: ~A" f1 vals)))
	       (undo))
	     '((0 1 1 2) (0 2 1 1) (0 1 1 2 2 1) (0 0.5 1 1) (0 0.5 1 2))
	     '(500.0 1000.0 500.0 250.0 250.0)
	     '(1000.0 500.0 500.0 500.0 1000.0))
	    
	    (for-each
	     (lambda (sr dur)
	       (src-channel sr 1000 2500)
	       (if (f4neq (framples ind 0) (+ 7500 (* dur 2500))) 
		   (snd-display "src-channel section: ~A ~A" (framples) (+ 7500 (* dur 2500))))
	       (let ((vals (freq-peak 0 ind 512)))
		 (if (f5neq (car vals) 500.0)
		     (snd-display "src-channel section 0 ~A freq: ~A" sr vals)))
	       (let ((vals (freq-peak (- (+ 7500 (floor (* dur 2500))) 512) ind 512)))
		 (if (f5neq (car vals) 500.0)
		     (snd-display "src-channel section 8000 ~A freq: ~A" sr vals)))
	       (let ((vals (freq-peak 1000 ind 512)))
		 (if (f5neq (car vals) (* sr 500.0))
		     (snd-display "src-channel section ~A freq: ~A" sr vals)))
	       (undo))
	     '(2.0 0.5 5.0 0.2)
	     '(0.5 2.0 0.2 5.0))
	    
	    (for-each
	     (lambda (e)
	       (src-channel (make-env e :length 2500) 1000 2500)
	       (if (f3neq (framples ind 0) (+ 7500 (* (src-duration e) 2500)))
		   (snd-display "src-channel section (make-env duration) ~A: ~A (~A ~A)" 
				e (src-duration e) (framples) (+ 7500 (* (src-duration e) 2500))))
	       (let ((vals (freq-peak 0 ind 256)))
		 (if (f5neq (car vals) 500.0)
		     (snd-display "src-channel section (make-env e) ~A: ~A" e vals)))
	       (let ((vals (freq-peak (- (+ 7500 (floor (* (src-duration e) 2500))) 256) ind 256)))
		 (if (f5neq (car vals) 500.0)
		     (snd-display "src-channel section (make-env e) ~A: ~A" e vals)))
	       (undo))
	     '((0 1 1 2) (0 2 1 1) (0 1 1 2 2 1) (0 0.5 1 1) (0 0.5 1 2)))
	    
	    (make-selection 1000 3500 ind 0)
	    (for-each
	     (lambda (sr dur)
	       (src-selection sr)
	       (if (f3neq (framples ind 0) (+ 7500 (* dur 2500))) 
		   (snd-display "src-selection section: ~A ~A" (framples) (+ 7500 (* dur 2500))))
	       (let ((vals (freq-peak 0 ind 512)))
		 (if (f5neq (car vals) 500.0)
		     (snd-display "src-selection section 0 ~A freq: ~A" sr vals)))
	       (let ((vals (freq-peak (- (+ 7500 (floor (* dur 2500))) 512) ind 512)))
		 (if (f5neq (car vals) 500.0)
		     (snd-display "src-selection section 8000 ~A freq: ~A" sr vals)))
	       (let ((vals (freq-peak 1000 ind 512)))
		 (if (f5neq (car vals) (* sr 500.0))
		     (snd-display "src-selection section ~A freq: ~A" sr vals)))
	       (undo))
	     '(2.0 0.5 5.0 0.2)
	     '(0.5 2.0 0.2 5.0))
	    
	    (for-each
	     (lambda (e)
	       (src-selection (make-env e :length 2500))
	       (if (f3neq (framples ind 0) (+ 7500 (* (src-duration e) 2500)))
		   (snd-display "src-selection section (make-env duration) ~A: ~A (~A ~A)" 
				e (src-duration e) (framples) (+ 7500 (* (src-duration e) 2500))))
	       (let ((vals (freq-peak 0 ind 256)))
		 (if (f5neq (car vals) 500.0)
		     (snd-display "src-selection section (make-env e) ~A: ~A" e vals)))
	       (let ((vals (freq-peak (- (+ 7500 (floor (* (src-duration e) 2500))) 256) ind 256)))
		 (if (f5neq (car vals) 500.0)
		     (snd-display "src-selection section (make-env e) ~A: ~A" e vals)))
	       (undo))
	     '((0 1 1 2) (0 2 1 1) (0 1 1 2 2 1) (0 0.5 1 1) (0 0.5 1 2)))
	    
	    (for-each
	     (lambda (e)
	       (src-selection e)
	       (if (f3neq (framples ind 0) (+ 7500 (* (src-duration e) 2500)))
		   (snd-display "src-selection section (env duration) ~A: ~A (~A ~A)" 
				e (src-duration e) (framples) (+ 7500 (* (src-duration e) 2500))))
	       (let ((vals (freq-peak 0 ind 256)))
		 (if (f5neq (car vals) 500.0)
		     (snd-display "src-selection section (env e) ~A: ~A" e vals)))
	       (let ((vals (freq-peak (- (+ 7500 (floor (* (src-duration e) 2500))) 256) ind 256)))
		 (if (f5neq (car vals) 500.0)
		     (snd-display "src-selection section (env f1) ~A: ~A" e vals)))
	       (undo))
	     '((0 1 1 2) (0 2 1 1) (0 1 1 2 2 1) (0 0.5 1 1) (0 0.5 1 2)))
	    
	    (close-sound ind))
	  
	  (set! *print-length* (max *print-length* 12))
	  (let ((ind (new-sound "hi.snd")))
	    (do ((i 0 (+ i 1)))
		((= i 10)) 
	      (set! (sample i ind) (* i .1)))
	    (select-all ind)
	    (set! (sample 10 ind) 1.0)
	    (smooth-selection)
	    (if (not (mus-arrays-equal? (float-vector-subseq (channel->float-vector 0 11 ind) 0 9) (float-vector-subseq (smoother 0.0 1.0) 0 9)))
		(snd-display "smooth-selection: ~A ~A?" (channel->float-vector 0 11 ind) (smoother 0.0 1.0)))
	    (revert-sound)
	    (do ((i 0 (+ i 1)))
		((= i 10)) 
	      (set! (sample i ind) (- 1.0 (* i .1))))
	    (select-all ind)
	    (set! (sample 10 ind) 0.0)
	    (smooth-selection)
	    (if (not (mus-arrays-equal? (float-vector-subseq (channel->float-vector 0 11 ind) 0 9) (float-vector-subseq (smoother 1.0 0.0) 0 9)))
		(snd-display "smooth-selection back: ~A ~A?" (channel->float-vector 0 11 ind) (smoother 1.0 0.0)))
	    (close-sound ind))
	  
	  (let ((ind (new-sound "hi.snd")))
	    (do ((i 0 (+ i 1)))
		((= i 10)) 
	      (set! (sample i ind) (* i .1)))
	    (set! (sample 10 ind) 1.0)
	    (smooth-sound 0 10 ind)
	    (if (not (mus-arrays-equal? (float-vector-subseq (channel->float-vector 0 11 ind) 0 9) (float-vector-subseq (smoother 0.0 1.0) 0 9)))
		(snd-display "smooth-sound: ~A ~A?" (channel->float-vector 0 11 ind) (smoother 0.0 1.0)))
	    (revert-sound)
	    (do ((i 0 (+ i 1)))
		((= i 10)) 
	      (set! (sample i ind) (- 1.0 (* i .1))))
	    (set! (sample 10 ind) 0.0)
	    (smooth-sound 0 10 ind)
	    (if (not (mus-arrays-equal? (float-vector-subseq (channel->float-vector 0 11 ind) 0 9) (float-vector-subseq (smoother 1.0 0.0) 0 9)))
		(snd-display "smooth-sound back: ~A ~A?" (channel->float-vector 0 11 ind) (smoother 1.0 0.0)))
	    (close-sound ind))
	  (if (file-exists? "hi.snd") (delete-file "hi.snd"))
	  
	  (let* ((ind (open-sound "oboe.snd"))
		 (len (framples ind)))
	    (set! (cursor ind) 1200)
	    (key (char->integer #\u) 4 ind)
	    (key (char->integer #\1) 0 ind)
	    (key (char->integer #\0) 0 ind)
	    (key (char->integer #\0) 0 ind)
	    (key (char->integer #\o) 4 ind)
	    (if (not (= (framples ind) (+ 100 len)))
		(snd-display "C-o len: ~A? " (framples)))
	    (let ((data (float-vector-peak (channel->float-vector 1200 100 ind))))
	      (if (fneq data 0.0) (snd-display "C-o: ~A?" data)))
	    (revert-sound ind)
	    (set! (cursor ind) 1200)
	    (key (char->integer #\u) 4 ind)
	    (key (char->integer #\1) 0 ind)
	    (key (char->integer #\0) 0 ind)
	    (key (char->integer #\0) 0 ind)
	    (key (char->integer #\z) 4 ind)
	    (if (not (= (framples ind) len))
		(snd-display "C-z len: ~A? " (framples)))
	    (let ((data (float-vector-peak (channel->float-vector 1200 100 ind))))
	      (if (fneq data 0.0) (snd-display "C-z: ~A?" data)))
	    (set! (cursor ind) 0)
	    (key (char->integer #\u) 4 ind)
	    (key (char->integer #\3) 0 ind)
	    (key (char->integer #\.) 0 ind)
	    (key (char->integer #\0) 0 ind)
	    (key (char->integer #\z) 4 ind)
	    (if (fneq (maxamp ind 0) 0.0) (snd-display "C-z full: ~A" (maxamp)))
	    (revert-sound ind)
	    (set! (cursor ind) 1200)
	    (key (char->integer #\u) 4 ind)
	    (key (char->integer #\1) 0 ind)
	    (key (char->integer #\.) 0 ind)
	    (key (char->integer #\0) 0 ind)
	    (key (char->integer #\o) 4 ind)
	    (if (not (= (framples ind) (+ (srate ind) len)))
		(snd-display "C-o 1.0 len: ~A? " (framples)))
	    (let ((data (float-vector-peak (channel->float-vector 1200 (srate ind) ind))))
	      (if (fneq data 0.0) (snd-display "C-o 1.0: ~A?" data)))
	    (revert-sound ind)
	    (set! (cursor ind) 1200)
	    (key (char->integer #\u) 4 ind)
	    (key (char->integer #\1) 0 ind)
	    (key (char->integer #\.) 0 ind)
	    (key (char->integer #\0) 0 ind)
	    (key (char->integer #\z) 4 ind)
	    (if (not (= (framples ind) len))
		(snd-display "C-z 1.0 len: ~A? " (framples)))
	    (let ((data (float-vector-peak (channel->float-vector 1200 (srate ind) ind))))
	      (if (fneq data 0.0) (snd-display "C-z 1.0: ~A?" data)))
	    (close-sound ind))
	  
	  (let ((ind (open-sound "2.snd")))
	    (set! (sync ind) 1)
	    (key (char->integer #\>) 4)
	    (key (char->integer #\space) 4)
	    (key (char->integer #\<) 4)
	    (if (not (and (selection-member? ind 0)
			  (selection-member? ind 1)
			  (= (selection-position ind 0) 0)
			  (= (selection-position ind 1) 0)
			  (= (selection-framples ind 0) (framples ind 0))
			  (= (selection-framples ind 1) (framples ind 1))))
		(snd-display "sync selection via <-: ~A ~A ~A ~A ~A ~A"
			     (selection-member? ind 0) (selection-member? ind 1)
			     (selection-position ind 0) (selection-position ind 1)
			     (selection-framples ind 0) (selection-framples ind 1)))
	    (key (char->integer #\space) 4)
	    (key (char->integer #\>) 4)
	    (if (not (and (selection-member? ind 0)
			  (selection-member? ind 1)
			  (= (selection-position ind 0) 0)
			  (= (selection-position ind 1) 0)
			  (= (selection-framples ind 0) (framples ind 0))
			  (= (selection-framples ind 1) (framples ind 1))))
		(snd-display "sync selection via ->: ~A ~A ~A ~A ~A ~A"
			     (selection-member? ind 0) (selection-member? ind 1)
			     (selection-position ind 0) (selection-position ind 1)
			     (selection-framples ind 0) (selection-framples ind 1)))
	    (set! (cursor ind 1) 0)
	    (set! (cursor ind 0) 1000)
	    (if (not (= (cursor ind 1) 1000)) (snd-display "syncd cursors: ~A ~A" (cursor ind 0) (cursor ind 1)))
	    (close-sound ind))
	  
	  (let ((ind (open-sound "2a.snd")))
	    (let ((reg (make-region 100 200 ind #t)))
	      (if (not (= (region-chans reg) 2))
		  (snd-display "make-region #t for chan in 2a.snd: ~A chans" (region-chans reg)))
	      (mix-region reg 1000)
	      (if (not (and (= (edit-position ind 0) 1)
			    (= (edit-position ind 1) 0)))
		  (snd-display "mix-region default mix: ~A ~A" (edit-position ind 0) (edit-position ind 1)))
	      (undo)
	      (set! (sync ind) 1)
	      (mix-region reg 1000)
	      (if (not (and (= (edit-position ind 0) 1)
			    (= (edit-position ind 1) 1)))
		  (snd-display "mix-region sync mix: ~A ~A" (edit-position ind 0) (edit-position ind 1)))
	      (undo)
	      (set! (sync ind) 0)
	      (mix-region reg 1000 ind 1)
	      (if (not (and (= (edit-position ind 0) 0)
			    (= (edit-position ind 1) 1)))
		  (snd-display "mix-region mix -> chan 1: ~A ~A" (edit-position ind 0) (edit-position ind 1)))
	      (revert-sound ind))
	    
	    (set! (selection-member? #t #t) #f)
	    (set! (selection-member? ind 0) #t)
	    (set! (selection-member? ind 1) #t)
	    (set! (selection-position ind 0) 1000)
	    (set! (selection-position ind 1) 1000)
	    (set! (selection-framples ind 0) 100)
	    (set! (selection-framples ind 1) 100)
	    (if (not (= (selection-chans) 2))
		(snd-display "laboriously make 2 chan selection: ~A" (selection-chans)))
	    
	    (mix-selection 100)
	    (if (not (and (= (edit-position ind 0) 1)
			  (= (edit-position ind 1) 0)))
		(snd-display "mix-selection default mix: ~A ~A" (edit-position ind 0) (edit-position ind 1)))
	    (undo)
	    (set! (sync ind) 1)
	    (mix-selection 100)
	    (if (not (and (= (edit-position ind 0) 1)
			  (= (edit-position ind 1) 1)))
		(snd-display "mix-selection sync mix: ~A ~A" (edit-position ind 0) (edit-position ind 1)))
	    (undo)
	    (set! (sync ind) 0)
	    (mix-selection 100 ind 1)
	    (if (not (and (= (edit-position ind 0) 0)
			  (= (edit-position ind 1) 1)))
		(snd-display "mix-selection mix -> chan 1: ~A ~A" (edit-position ind 0) (edit-position ind 1)))
	    
	    (close-sound ind))
	  
	  (let ((ind (open-sound "oboe.snd")))
	    (test-selection ind 1200 100 2.0)
	    (test-selection ind 600 1200 2.0)
	    (test-selection ind 0 100 2.0)
	    (test-selection ind 22500 28327 0.5)
	    (test-selection ind 0 50828 0.5)
	    
	    (test-selection-to ind 1200 100 1.0)
	    (test-selection-to ind 600 1200 0.1)
	    (test-selection-to ind 0 100 0.5)
	    (test-selection-to ind 22500 28327 2.0)
	    (test-selection-to ind 0 50828 0.5)
	    
	    (revert-sound ind)
	    (make-selection 1200 1200)
	    (if (not (selection?)) (snd-display "no selection from 1 samp region?"))
	    (if (not (= (selection-framples) 1)) (snd-display "1 samp selection: ~A samps?" (selection-framples)))
	    (scale-selection-to 1.0)
	    (if (fneq (sample 1200 ind 0) 1.0) (snd-display "scale 1 samp selection: ~A?" (sample 1200 ind 0)))
	    
	    (revert-sound ind)
	    (let ((id (make-region 500 1000)))
	      (src-selection .5)
	      (if (> (abs (- (region-framples id) 500)) 1) (snd-display "region-framples after src-selection: ~A?" (region-framples id)))
	      (let ((reg-mix-id (car (mix-region id 1500 ind 0))))
		(if (not (= (mix-length reg-mix-id) (region-framples id)))
		    (snd-display "mix-region: ~A != ~A?" (region-framples id) (mix-length reg-mix-id)))
		(if (not (equal? (mix-home reg-mix-id) (list ind 0 #f 0)))
		    (snd-display "mix-region mix-home ~A (~A 0 #f 0)?" (mix-home reg-mix-id) ind))
		(let ((sel-mix-id (car (mix-selection 2500 ind 0))))
		  (if (not (= (selection-framples) (mix-length sel-mix-id)))
		      (snd-display "mix-selection framples: ~A != ~A?" (selection-framples) (mix-length sel-mix-id)))
		  (if (> (abs (- (* 2 (mix-length reg-mix-id)) (mix-length sel-mix-id))) 3)
		      (snd-display "mix selection and region: ~A ~A (~A ~A)?" 
				   (mix-length reg-mix-id) (mix-length sel-mix-id) (region-framples id) (selection-framples)))
		  (if (not (equal? (mix-home sel-mix-id) (list ind 0 #f 0)))
		      (snd-display "mix-selection mix-home: ~A (~A 0 #f 0)?" (mix-home sel-mix-id) ind)))))
	    (insert-selection 3000 ind 0)
	    (insert-selection 3000 ind)
	    (mix-selection 3000 ind)
	    (delete-selection)
	    (revert-sound ind)
	    (close-sound ind))
	  
	  (if (file-exists? "storm.snd")
	      (let ((ind (open-sound "storm.snd")))
		(set! *sinc-width* 10)
		(time (src-sound 1.3))
		(time (env-sound '(0 0 1 1 2 0)))
		(time (filter-sound '(0 1 .2 0 .5 1 1 0) 20))      ; FIR direct form
		(time (filter-sound '(0 0 .1 0 .11 1 .12 0 1 0) 2048)) ; convolution
		(revert-sound ind)
		(region->float-vector (make-region 0 123000 ind 0) 0 10 0 (make-float-vector 10)) ; force copy branch to execute
		(do ((i 0 (+ i 1))) ((= i 4)) (ramp-channel 0.0 1.0))
		(close-sound ind)))
	  
	  (if (file-exists? "1a.snd")
	      (let ((ind1 (open-sound "1a.snd")))
		(time (rubber-sound 1.25))
		(close-sound ind1)))
	  (gc)
	  (let* ((oboe (open-sound "oboe.snd"))
		 (a4 (open-sound "4.aiff"))
		 (sr (* 2 (srate oboe))))
	    (save-sound-as "test.aif" oboe :header-type mus-aifc)
	    (let ((oboe-aif (open-sound "test.aif")))
	      (if (not (= (header-type oboe-aif) mus-aifc)) (snd-display "oboe-aif header: ~A?" (mus-header-type-name (header-type oboe-aif))))
	      (set! (srate oboe-aif) (* sr 2))
	      (if (fneq (* 2 sr) (srate oboe-aif)) (snd-display "set! srate: ~A ~A" sr (srate oboe-aif)))
	      (set! (header-type oboe-aif) mus-next)
	      (if (not (= (header-type oboe-aif) mus-next)) (snd-display "set! header: ~A?" (mus-header-type-name (header-type oboe-aif))))
	      (set! (data-location oboe-aif) 28)
	      (if (not (= (data-location oboe-aif) 28)) (snd-display "set! data-location: ~A?" (data-location oboe-aif)))
	      (set! (sample-type oboe-aif) mus-mulaw)
	      (if (not (= (sample-type oboe-aif) mus-mulaw)) (snd-display "set! format: ~A?" (mus-sample-type-name (sample-type oboe-aif))))
	      (save-sound-as "test.aif" oboe-aif 22050 mus-bshort mus-aifc 0)
	      (close-sound oboe-aif)
	      (delete-file "test.aif")
	      (set! (selected-sound) a4)
	      (if (not (equal? (selected-sound) a4)) (snd-display "set! selected-sound: ~A ~A?" (selected-sound) a4))
	      (set! (selected-channel) 2)
	      (if (not (= (selected-channel a4) 2)) (snd-display "set! selected-channel: ~A?" (selected-channel a4)))
	      (set! (selected-channel a4) 3)
	      (if (not (= (selected-channel a4) 3)) (snd-display "set! selected-channel a4: ~A?" (selected-channel a4)))
	      (close-sound a4)
	      (close-sound oboe)))
	  
	  (let ((v1 (envelope-interp 1.0 '(0 0 2.0 1.0))))
	    (if (fneq v1 0.5) (snd-display "envelope-interp(1): ~F (0.5)?" v1)))
	  (let ((v2 (envelope-interp 1.0 '(0 0.0 1 1.0 2 0.0))))
	    (if (fneq v2 1.0) (snd-display "envelope-interp(2): ~F (1.0)?" v2)))
	  (let ((v3 (envelope-interp 2.0 '(0 0.0 1 1.0))))
	    (if (fneq v3 1.0) (snd-display "envelope-interp(3): ~F (1.0)?" v3)))
	  (let ((v4 (envelope-interp 0.0 '(1 .5 2 0))))
	    (if (fneq v4 0.5) (snd-display "envelope-interp(4): ~F (0.5)?" v4)))
	  
	  (let ((v1 (envelope-interp 0.0 '(-1 0  0 1  1 -1))))
	    (if (fneq v1 1.0) (snd-display "envelope-interp(1a): ~A" v1)))
	  (let ((v2 (envelope-interp -0.5 '(-1 0  0 1  1 -1))))
	    (if (fneq v2 0.5) (snd-display "envelope-interp(2a): ~A" v2)))
	  (let ((v3 (envelope-interp -0.5 '(-1 -1  0 1  1 -1))))
	    (if (fneq v3 0.0) (snd-display "envelope-interp(3a): ~A" v3)))
	  (let ((v4 (envelope-interp -0.5 '(-1 -1  1 1))))
	    (if (fneq v4 -0.5) (snd-display "envelope-interp(4a): ~A" v4)))
	  (let ((v5 (envelope-interp -1.5 '(-1 -1  1 1))))
	    (if (fneq v5 -1.0) (snd-display "envelope-interp(5a): ~A" v5)))
	  (let ((v6 (envelope-interp 1.5 '(-1 -1  1 1))))
	    (if (fneq v6 1.0) (snd-display "envelope-interp(6a): ~A" v6)))
	  
	  (let ((v1 (multiply-envelopes '(0.0 0.0 2.0 0.5) '(0.0 0.0 1.0 2.0 2.0 1.0)))
		(v2 (window-envelope 1.0 3.0 '(0.0 0.0 5.0 1.0))))
	    (if (not (feql v1 '(0.0 0.0 0.5 0.5 1.0 0.5))) (snd-display "multiply-envelopes: ~A?" v1))
	    (if (not (feql v2 '(1.0 0.2 3.0 0.6))) (snd-display "window-envelope: ~A?" v2)))
	  
	  (if (fneq (envelope-interp .1 '(0 0 1 1)) 0.1) 
	      (snd-display "envelope-interp .1 -> ~A?" (envelope-interp .1 '(0 0 1 1))))
	  (if (fneq (envelope-interp .1 '(0 0 1 1) 32.0) 0.01336172) 
	      (snd-display "envelope-interp .013 -> ~A?" (envelope-interp .1 '(0 0 1 1) 32.0)))
	  (if (fneq (envelope-interp .1 '(0 0 1 1) .012) 0.36177473) 
	      (snd-display "envelope-interp .361 -> ~A?" (envelope-interp .1 '(0 0 1 1) .012))) 
	  (if (fneq (envelope-interp .3 '(0 0 .5 1 1 0)) .6)
	      (snd-display "envelope-interp .3 '(0 0 .5 1 1 0)) -> ~A" (envelope-interp .3 '(0 0 .5 1 1 0))))
	  
	  (if (fneq (envelope-interp .9 '(0 0 1 1)) 0.9) 
	      (snd-display "envelope-interp .9 -> ~A?" (envelope-interp .9 '(0 0 1 1))))
	  (if (fneq (envelope-interp .9 '(0 0 1 1) 32.0) 0.698) 
	      (snd-display "envelope-interp .698 -> ~A?" (envelope-interp .9 '(0 0 1 1) 32.0)))
	  (if (fneq (envelope-interp .9 '(0 0 1 1) .012) 0.993) 
	      (snd-display "envelope-interp .993 -> ~A?" (envelope-interp .9 '(0 0 1 1) .012))) 
	  
	  (if (fneq (envelope-interp 1.1 '(0 0 1 0 2 1)) 0.1) 
	      (snd-display "envelope-interp .1 (2) -> ~A?" (envelope-interp 1.1 '(0 0 1 0 2 1))))
	  (if (fneq (envelope-interp 1.1 '(0 0 1 0 2 1) 32.0) 0.01336172) 
	      (snd-display "envelope-interp .013 (2) -> ~A?" (envelope-interp 1.1 '(0 0 1 0 2 1) 32.0)))
	  (if (fneq (envelope-interp 1.1 '(0 0 1 0 2 1) .012) 0.36177473) 
	      (snd-display "envelope-interp .361 (2) -> ~A?" (envelope-interp 1.1 '(0 0 1 0 2 1) .012))) 
	  
	  (if (fneq (envelope-interp 1.9 '(0 0 1 0 2 1)) 0.9) 
	      (snd-display "envelope-interp .9 (2) -> ~A?" (envelope-interp 1.9 '(0 0 1 0 2 1))))
	  (if (fneq (envelope-interp 1.9 '(0 0 1 0 2 1) 32.0) 0.698) 
	      (snd-display "envelope-interp .698 (2) -> ~A?" (envelope-interp 1.9 '(0 0 1 0 2 1) 32.0)))
	  (if (fneq (envelope-interp 1.9 '(0 0 1 0 2 1) .012) 0.993) 
	      (snd-display "envelope-interp .993 (2) -> ~A?" (envelope-interp 1.9 '(0 0 1 0 2 1) .012))) 
	  
	  (if (fneq (envelope-interp 1.1 '(0 0 0.5 1 1 0 2 1)) 0.1) 
	      (snd-display "envelope-interp .1 (3) -> ~A?" (envelope-interp 1.1 '(0 0 0.5 1 1 0 2 1))))
	  (if (fneq (envelope-interp 1.1 '(0 0 0.5 1 1 0 2 1) 32.0) 0.01336172) 
	      (snd-display "envelope-interp .013 (3) -> ~A?" (envelope-interp 1.1 '(0 0 0.5 1 1 0 2 1) 32.0)))
	  (if (fneq (envelope-interp 1.1 '(0 0 0.5 1 1 0 2 1) .012) 0.36177473) 
	      (snd-display "envelope-interp .361 (3) -> ~A?" (envelope-interp 1.1 '(0 0 0.5 1 1 0 2 1) .012))) 
	  
	  (if (fneq (envelope-interp 1.9 '(0 0 0.5 1 1 0 2 1)) 0.9) 
	      (snd-display "envelope-interp .9 (3) -> ~A?" (envelope-interp 1.9 '(0 0 0.5 1 1 0 2 1))))
	  (if (fneq (envelope-interp 1.9 '(0 0 0.5 1 1 0 2 1) 32.0) 0.698) 
	      (snd-display "envelope-interp .698 (3) -> ~A?" (envelope-interp 1.9 '(0 0 0.5 1 1 0 2 1) 32.0)))
	  (if (fneq (envelope-interp 1.9 '(0 0 0.5 1 1 0 2 1) .012) 0.993) 
	      (snd-display "envelope-interp .993 (3) -> ~A?" (envelope-interp 1.9 '(0 0 0.5 1 1 0 2 1) .012))) 
	  
	  (if (not (feql (window-envelope 1.0 3.0 '(0.0 0.0 5.0 1.0)) '(1.0 0.2 3.0 0.6))) 
	      (snd-display "window-envelope: ~A?" (window-envelope 1.0 3.0 '(0.0 0.0 5.0 1.0))))
	  (if (not (feql (multiply-envelopes '(0 0 1 1) '(0 0 1 1 2 0)) '(0 0 0.5 0.5 1 0))) 
	      (snd-display "multiply-envelopes: ~A?" (multiply-envelopes '(0 0 1 1) '(0 0 1 1 2 0))))
	  (if (fneq (max-envelope '(0 0 1 1 2 3 4 0)) 3.0)
	      (snd-display "max-envelope: ~A?" (max-envelope '(0 0 1 1 2 3 4 0))))
	  (if (fneq (max-envelope '(0 1)) 1.0)
	      (snd-display "1 max-envelope: ~A?" (max-envelope '(0 1))))
	  (if (fneq (max-envelope '(0 1 1 1 2 2)) 2.0)
	      (snd-display "2 max-envelope: ~A?" (max-envelope '(0 1 1 1 2 2))))
	  (if (fneq (max-envelope '(0 -1 1 -2)) -1.0)
	      (snd-display "3 max-envelope: ~A?" (max-envelope '(0 -1 1 -2))))
	  (if (fneq (max-envelope '(0 -2 1 -1)) -1.0)
	      (snd-display "4 max-envelope: ~A?" (max-envelope '(0 -2 1 -1))))
	  (if (fneq (min-envelope '(0 0 1 1 2 3 4 0)) 0.0)
	      (snd-display "min-envelope: ~A?" (min-envelope '(0 0 1 1 2 3 4 0))))
	  (if (fneq (min-envelope '(0 1)) 1.0)
	      (snd-display "1 min-envelope: ~A?" (min-envelope '(0 1))))
	  (if (fneq (min-envelope '(0 1 1 1 2 2)) 1.0)
	      (snd-display "2 min-envelope: ~A?" (min-envelope '(0 1 1 1 2 2))))
	  (if (fneq (min-envelope '(0 -1 1 -2)) -2.0)
	      (snd-display "3 min-envelope: ~A?" (min-envelope '(0 -1 1 -2))))
	  (if (fneq (min-envelope '(0 -2 1 -1)) -2.0)
	      (snd-display "4 min-envelope: ~A?" (min-envelope '(0 -2 1 -1))))
	  (if (fneq (integrate-envelope '(0 0 1 1)) 0.5) 
	      (snd-display "integrate-envelope: ~A?" (integrate-envelope '(0 0 1 1))))
	  (if (fneq (integrate-envelope '(0 1 1 1)) 1.0) 
	      (snd-display "integrate-envelope: ~A?" (integrate-envelope '(0 1 1 1))))
	  (if (fneq (integrate-envelope '(0 0 1 1 2 .5)) 1.25) 
	      (snd-display "integrate-envelope: ~A?" (integrate-envelope '(0 0 1 1 2 .5))))
	  (if (not (feql (stretch-envelope '(0 0 1 1) .1 .2) '(0 0 0.2 0.1 1.0 1))) 
	      (snd-display "stretch-envelope att: ~A?" (stretch-envelope '(0 0 1 1) .1 .2)))
	  (if (not (feql (stretch-envelope '(0 0 1 1 2 0) .1 .2 1.5 1.6) '(0 0 0.2 0.1 1.1 1 1.6 0.5 2.0 0))) 
	      (snd-display "stretch-envelope dec: ~A?" (stretch-envelope '(0 0 1 1 2 0) .1 .2 1.5 1.6)))
	  (if (not (feql (add-envelopes '(0 0 1 1 2 0) '(0 0 1 1)) '(0 0 0.5 1.5 1 1)))
	      (snd-display "add-envelopes: ~A" (add-envelopes '(0 0 1 1 2 0) '(0 0 1 1))))
	  (if (not (feql (scale-envelope '(0 0 1 1) 2) '(0 0 1 2)))
	      (snd-display "scale-envelope: ~A" (scale-envelope '(0 0 1 1) 2)))
	  (if (not (feql (scale-envelope '(0 0 1 1) 2 1) '(0 1 1 3)))
	      (snd-display "scale-envelope off: ~A" (scale-envelope '(0 0 1 1) 2 1)))
	  (if (not (feql (reverse-envelope '(0 0 1 1)) '(0 1 1 0)))
	      (snd-display "reverse-envelope ramp: ~A" (reverse-envelope '(0 0 1 1))))
	  (if (not (feql (reverse-envelope '(0 0 .5 1 2 0)) '(0 0 1.5 1 2 0)))
	      (snd-display "reverse-envelope ramp 2: ~A" (reverse-envelope '(0 0 .5 1 2 0))))
	  (if (not (feql (reverse-envelope '(0 0 .5 1 2 1)) '(0 1 1.5 1 2 0)))
	      (snd-display "reverse-envelope ramp 2: ~A" (reverse-envelope '(0 0 .5 1 2 1))))
	  (if (not (feql (concatenate-envelopes '(0 0 1 1) '(0 1 1 0)) '(0.0 0 1.0 1 2.0 0)))
	      (snd-display "concatenate-envelopes: ~A" (concatenate-envelopes '(0 0 1 1) '(0 1 1 0))))
	  (if (not (feql (concatenate-envelopes '(0 0 1 1.5) '(0 1 1 0)) '(0.0 0 1.0 1.5 1.01 1 2.01 0)))
	      (snd-display "concatenate-envelopes: ~A" (concatenate-envelopes '(0 0 1 1.5) '(0 1 1 0))))
	  (if (not (feql (repeat-envelope '(0 0 1 100) 2) '(0 0 1 100 1.01 0 2.01 100)))
	      (snd-display "repeat-envelope 0: ~A" (repeat-envelope '(0 0 1 100) 2)))
	  (if (not (feql (repeat-envelope '(0 0 1.5 1 2 0) 2) '(0 0 1.5 1 2.0 0 3.5 1 4.0 0)))
	      (snd-display "repeat-envelope 1: ~A" (repeat-envelope '(0 0 1.5 1 2 0) 2)))
	  (if (not (feql (repeat-envelope '(0 0 1.5 1 2 0) 2 #f #t) '(0.0 0 0.75 1 1.0 0 1.75 1 2.0 0)))
	      (snd-display "repeat-envelope 2: ~A" (repeat-envelope '(0 0 1.5 1 2 0) 2 #f #t)))
	  (if (not (feql (repeat-envelope '(0 0 1.5 1 2 0) 2 #t) '(0 0 1.5 1 2.0 0 2.5 1 4.0 0)))
	      (snd-display "repeat-envelope 3: ~A" (repeat-envelope '(0 0 1.5 1 2 0) 2 #t)))
	  (if (not (feql (repeat-envelope '(0 0 1.5 1 2 0) 3) '(0 0 1.5 1 2.0 0 3.5 1 4.0 0 5.5 1 6.0 0)))
	      (snd-display "repeat-envelope 4: ~A" (repeat-envelope '(0 0 1.5 1 2 0) 3)))
	  (if (not (feql (normalize-envelope '(0 0 1 1.5 2.0 1.0)) '(0 0.0 1 1.0 2.0 0.667)))
	      (snd-display "normalize-envelope: ~A" (normalize-envelope '(0 0 1 1.5 2.0 1.0))))
	  (if (not (feql (normalize-envelope '(0 0 1 .5 2 -.8)) '(0 0.0 1 0.625 2 -1.0)))
	      (snd-display "normalize-envelope: ~A" (normalize-envelope '(0 0 1 .5 2 -.8))))
	  
	  (let ((val (envelope-exp '(0 0 1 1) 2.0 10)))
	    (if (not (feql val '(0.0 0.0 0.100 0.010 0.200 0.040 0.300 0.090 0.400 0.160 
				     0.500 0.250 0.600 0.360 0.700 0.490 0.800 0.640 0.900 0.810 1.000 1.000)))
		(snd-display "envelope-exp: ~A" val))
	    (set! val (envelope-exp '(0 0 1 1 2 0) 1.0 10))
	    (if (not (feql val '(0.0 0.0 0.200 0.200 0.400 0.400 0.600 0.600 0.800 0.800 
				     1.000 1.000 1.200 0.800 1.400 0.600 1.600 0.400 1.800 0.200 2.000 0.000)))
		(snd-display "envelope exp 2: ~A" val)))
	  
	  (let ((ind (new-sound "fmv.snd")))
	    (float-vector->channel (make-float-vector 20 1.0))
	    (if (selection?) (set! (selection-member? #t) #f))
	    (make-selection 5 9 ind 0)
	    (scale-selection-to 0.5)
	    (insert-selection 15 ind)
	    (if (not (= (framples ind) 25)) (snd-display "insert-selection 5: ~A" (framples ind)))
	    (if (not (mus-arrays-equal? (channel->float-vector 0 25) #r(1.0 1.0 1.0 1.0 1.0 0.5 0.5 0.5 0.5 0.5 
										   1.0 1.0 1.0 1.0 1.0 0.5 0.5 0.5 0.5 0.5
										   1.0 1.0 1.0 1.0 1.0)))
		(snd-display "insert-selection: ~A" (channel->float-vector 0 25)))
	    (mix-selection 1 ind 0) ; this is being confused by clipping settings
	    (if (not (mus-arrays-equal? (channel->float-vector 0 10 ind 0) #r(1.000 1.500 1.500 1.500 1.500 1.000 0.500 0.500 0.500 0.500)))
		(snd-display "mix-selection vals: ~A" (channel->float-vector 0 10 ind 0)))
	    (close-sound ind))
	  
	  (let ((ind (new-sound "fmv.snd")))
	    (let-temporarily ((*transform-size* 256)
			      (*transform-type* fourier-transform)
			      (*transform-normalization* normalize-by-channel)
			      (*transform-graph-type* graph-once)
			      (*zero-pad* 0))
	      (let ((v (make-float-vector 2000)))
		(let ((e (make-env (list 0.0 0.0 1.0 (* 2000 0.2 pi)) :length 2001)))
		  (fill-float-vector v (sin (env e))))
		(float-vector->channel v 0 2000 ind 0))
	      (set! (transform-graph?) #t)
	      (make-selection 0 200)
	      (set! *show-selection-transform* #t)
	      (set! (selection-framples) 300)
	      (update-transform-graph)
	      (let ((data (transform->float-vector)))
		(let ((peak (float-vector-peak data))
		      (val (transform-sample 0)))
		  (if (= peak 0.0) (snd-display "transform selection peak: ~A" peak))
		  (if (fneq val (data 0)) (snd-display "transform-sample: ~A, data: ~A" val (data 0)))
		  (if (and (>= (length data) 64)
			   (> (* .5 peak) (data 51)))
		      (snd-display "transform selection at 51: ~A, peak: ~A" (data 51) peak))))
	      (for-each
	       (lambda (pad)
		 (set! *zero-pad* pad)
		 (update-transform-graph)
		 (let* ((data (transform->float-vector))
			(peak (float-vector-peak data))
			(pval (data (floor (* .1 (length data))))))
		   (if (> (* .5 peak) pval)
		       (snd-display "transform selection padded ~D: ~A, peak: ~A" pad pval peak))))
	       '(1 0 3 31))
	      (set! *zero-pad* 100000)
	      (if (> *zero-pad* 1000)
		  (snd-display "zero-pad: ~A" *zero-pad*))
	      (close-sound ind)))
	  
	  (let ((ind (open-sound "storm.snd"))
		(maxes #r(0.8387 0.5169 0.3318 0.2564 0.1982 0.1532)))
	    (do ((i 0 (+ i 1)))
		((= i 5))
	      (if (fneq (maxamp) (maxes i)) (snd-display "enving storm ~D: ~A ~A" i (maxes i) (maxamp)))
	      (env-sound '(0 0 1 1 2 0))
	      (if (fneq (maxamp) (maxes (+ i 1))) (snd-display "enving storm ~D: ~A ~A" (+ i 1) (maxes (+ i 1)) (maxamp))))
	    (close-sound ind)))
	
	;; --------------------------------------------------------------------------------
	;; length as generic function:
	;;     string-length vector-length length 
	;;     framples mus-length framples mix-length region-framples 
	
	(let ((snd (open-sound "oboe.snd"))
	      (sd (framples (make-float-vector '(1 10)))))
	  (let ((mxv (length (mix-float-vector (make-float-vector 3) 1000)))
		(reg (length (make-region 0 100)))
		(dly (length (make-delay 32)))
		(ply (length (make-player snd 0))))
	    (if (not (= (length snd) 50828)) (snd-display "length of sound: ~A" (length snd)))
	    (if (not (= sd 10)) (snd-display "length of vector2: ~A" sd))
	    (if (not (= mxv 3)) (snd-display "length of mix: ~A" mxv))
	    (if (not (= reg 101)) (snd-display "length of region: ~A" reg))
	    (if (not (= dly 32)) (snd-display "length of delay: ~A" dly))
	    (if (not (= ply 50828)) (snd-display "length of player: ~A" ply)))
	  (close-sound snd))
	
	;; srate as generic: mus-sound-srate region-srate srate 
	
	(let ((snd (open-sound "oboe.snd")))
	  (let ((reg (srate (make-region 0 100)))
		(ply (srate (make-player snd 0))))
	    (if (not (= (srate snd) 22050)) (snd-display "srate of sound: ~A" (srate snd)))
	    (let ((str (srate "oboe.snd")))
	      (if (not (= str 22050)) (snd-display "srate of string: ~A" str)))
	    (if (not (= reg 22050)) (snd-display "srate of region: ~A" reg))
	    (if (not (= ply 22050)) (snd-display "srate of player: ~A" ply)))
	  (close-sound snd))
	
	;; channels as generic: mus-sound-chans region-chans chans mus-channels mix/etc
	
	(let ((snd (open-sound "oboe.snd"))
	      (v #r(.1 .2 .3))
	      (sd (channels (make-float-vector '(2 10)))))
	  (let ((mxv (channels (mix-float-vector v 1000)))
		(reg (channels (make-region 0 100)))
		(ply (channels (make-player snd 0))))
	    (if (not (= (channels snd) 1)) (snd-display "channels of sound: ~A" (channels snd)))
	    (if (not (= (channels v) 1)) (snd-display "channels of float-vector: ~A" (channels v)))
	    (let ((str (channels "oboe.snd")))
	      (if (not (= str 1)) (snd-display "channels of string: ~A" str)))
	    (if (not (= sd 2)) (snd-display "channels of vector2: ~A" sd))
	    (if (not (= mxv 1)) (snd-display "channels of mix: ~A" mxv))
	    (if (not (= reg 1)) (snd-display "channels of region: ~A" reg))
	    (if (not (= ply 1)) (snd-display "channels of player: ~A" ply)))
	  (close-sound snd))
	
	;; framples as generic
	
	(let ((snd (open-sound "oboe.snd"))
	      (v #r(.1 .2 .3))
	      (sd (framples (make-float-vector '(1 10)))))
	  (let ((mxv (framples (mix-float-vector v 1000)))
		(reg (framples (make-region 0 100)))
		(dly (framples (make-delay 32)))
		(ply (framples (make-player snd 0))))
	    (if (not (= (framples snd) 50828)) (snd-display "framples of sound: ~A" (framples snd)))
	    (if (not (= (framples v) 3)) (snd-display "framples of float-vector: ~A" (framples v)))
	    (let ((str (framples "oboe.snd")))
	      (if (not (= str 50828)) (snd-display "framples of string: ~A" str)))
	    (if (not (= sd 10)) (snd-display "framples of vector2: ~A" sd))
	    (if (not (= mxv 3)) (snd-display "framples of mix: ~A" mxv))
	    (if (not (= reg 101)) (snd-display "framples of region: ~A" reg))
	    (if (not (= dly 32)) (snd-display "framples of delay: ~A" dly))
	    (if (not (= ply 50828)) (snd-display "framples of player: ~A" ply)))
	  (close-sound snd))
	
	;; file-name as generic
	
	(let ((snd (open-sound "oboe.snd"))
	      (frm (make-file->sample "oboe.snd"))
	      (prt (open-output-file "tst.dat")))
	  (let ((mxv (file-name (car (mix "pistol.snd" 1000))))
		(reg (file-name (make-region 0 100))))
	    (if (not (string=? (file-name snd) (string-append (getcwd) "/oboe.snd"))) (snd-display "file-name of sound: ~A" (file-name snd)))
	    (let ((str (file-name "oboe.snd")))
	      (if (not (string=? str (string-append (getcwd) "/oboe.snd"))) (snd-display "file-name of string: ~A" str)))
	    (if (not (string=? (file-name frm) "oboe.snd")) (snd-display "file-name of file->sample: ~A" (file-name frm)))
	    (if (not (string=? (file-name prt) "tst.dat")) (snd-display "file-name of output port: ~A" (file-name prt)))
	    (if (not (string=? mxv (string-append (getcwd) "/pistol.snd"))) (snd-display "file-name of mix: ~A" mxv))
	    (if (not (string=? reg "oboe.snd")) (snd-display "file-name of region: ~A" reg)))
	  (close-output-port prt)
	  (mus-close frm)
	  (close-sound snd))
	
	;; sync as generic: mix-sync mark-sync sync 
	
	(let ((snd (open-sound "oboe.snd")))
	  (let ((mrk (add-mark 123))
		(mx (mix-float-vector #r(.1 .2 .3))))
	    (if (not (= (sync snd) 0)) (snd-display "sync of sound (0): ~A" (sync snd)))
	    (if (not (= (sync mrk) 0)) (snd-display "sync of mark (0): ~A" (sync mrk)))
	    (if (not (= (sync mx) 0)) (snd-display "sync of mx (0): ~A" (sync mx)))
	    
	    (set! (sync snd) 12)
	    (set! (sync mrk) 24)
	    (set! (sync mx) 36)
	    
	    (if (not (= (sync snd) 12)) (snd-display "sync of sound (12): ~A" (sync snd)))
	    (if (not (= (sync mrk) 24)) (snd-display "sync of mark (24): ~A" (sync mrk)))
	    (if (not (= (sync mx) 36)) (snd-display "sync of mx (36): ~A" (sync mx))))
	  (close-sound snd))
	
	;; maxamp as generic
	
	(let ((snd (open-sound "oboe.snd"))
	      (v #r(.1 .2 .3)))
	  (let ((mxv (maxamp (mix-float-vector v 1000)))
		(reg (maxamp (make-region 0 900))))
	    (if (fneq (maxamp snd) .334) (snd-display "maxamp of sound: ~A" (maxamp snd)))
	    (if (fneq (maxamp snd 0) .334) (snd-display "maxamp of sound (0): ~A" (maxamp snd)))
	    (if (fneq (maxamp snd 0 0) .14724) (snd-display "maxamp of sound (0 0): ~A" (maxamp snd)))
	    (if (fneq (maxamp v) .3) (snd-display "maxamp of float-vector: ~A" (maxamp v)))
	    (let ((vc (maxamp #r(.1 .2 .3 .4))))
	      (if (fneq vc .4) (snd-display "maxamp of vector: ~A" vc)))
	    (let ((str (maxamp "pistol.snd"))) ; can't use oboe.snd since we messed with mus-sound-maxamp above
	      (if (fneq str .49267) (snd-display "maxamp of string: ~A" str)))
	    (let ((sd (make-float-vector '(1 10))))
	      (set! (sd 0 1) .1)
	      (if (fneq (maxamp sd) 0.1) (snd-display "maxamp of vector2: ~A" (maxamp sd))))
	    (if (fneq mxv .3) (snd-display "maxamp of mix: ~A" mxv))
	    (if (fneq reg .02139) (snd-display "maxamp of region: ~A" reg))
	    (let ((dly (make-delay 32)))
	      (delay dly .1)
	      (delay dly .2)
	      (if (fneq (maxamp dly) .2) (snd-display "maxamp of delay: ~A" (maxamp dly)))))
	  (close-sound snd))
	))))


;;; ---------------- test 16: regularized funcs ----------------

(define snd_test_16
  (let ()
    (define opt-test
      (let ((undo-env 
	     (lambda (s c)
	       (let ((len (car (edits s c))))
		 (and (> len 0)
		      (do ((unhappy #f)
			   (i 1 (+ i 1)))
			  ((or unhappy (> i len))
			   unhappy)
			(let ((ed (edit-fragment i s c)))
			  (when (and (pair? ed)
				     (string=? (cadr ed) "env"))
			    (set! (edit-position s c) (- i 1))
			    (set! unhappy #t)))))))))
	(lambda (choice)
	  (let* ((cursnd (let ((snds (sounds))) (snds (random (length snds)))))
		 (curchn (random (chans cursnd)))
		 (chan-list (all-chans)))
	    (let ((cur-maxamps (apply map maxamp chan-list))
		  (cur-edits (apply map edit-position chan-list))
		  (cur-framples (apply map framples chan-list))
		  (cur-amp (maxamp cursnd curchn))
		  (cur-edit (edit-position cursnd curchn))
		  (cur-frame (framples cursnd curchn)))
	      
	      (case choice
		;; scale-channel
		((0) (let* ((scaler (if (< (maxamp cursnd curchn) 1.0) (+ 1.0 (random 1.0)) (+ 0.5 (random 0.5))))
			    (cur-loc (random cur-frame))
			    (cur-samp (sample cur-loc cursnd curchn)))
		       (scale-channel scaler 0 (framples cursnd curchn) cursnd curchn)
		       (if (not (or (= (edit-position cursnd curchn) (+ 1 cur-edit)) 
				    (= (edit-position cursnd curchn) cur-edit)))
			   (snd-display "scale-channel ~A[~A] edit pos: ~A ~A" (short-file-name cursnd) curchn (edit-position cursnd curchn) cur-edit))
		       (if (not (= (framples cursnd curchn) cur-frame))
			   (snd-display "scale-channel ~A[~A] framples: ~A ~A" (short-file-name cursnd) curchn (framples cursnd curchn) cur-frame))
		       (if (fneq (maxamp cursnd curchn) (* scaler cur-amp))
			   (snd-display "scale-channel ~A[~A] maxamp: ~A ~A (~A, scaler: ~A)" 
					(short-file-name cursnd) curchn (maxamp cursnd curchn) (* scaler cur-amp)
					(abs (- (maxamp cursnd curchn) (* scaler cur-amp)))
					scaler))
		       (if (fneq (sample cur-loc cursnd curchn) (* scaler cur-samp))
			   (snd-display "scale-channel ~A[~A] cur-samp: ~A ~A" (short-file-name cursnd) curchn (sample cur-loc cursnd curchn) (* scaler cur-samp)))
		       (for-each
			(lambda (s c amp ed fr)
			  (unless (and (equal? s cursnd)
				       (= c curchn))
			    (if (not (= (edit-position s c) ed))
				(snd-display "scale-channel ~A[~A] wrong edit pos: ~A ~A" (short-file-name s) c (edit-position s c) ed))
			    (if (not (= (framples s c) fr))
				(snd-display "scale-channel ~A[~A] wrong framples: ~A ~A" (short-file-name s) c (framples s c) fr))
			    (if (fneq (maxamp s c) amp)
				(snd-display "scale-channel ~A[~A] wrong maxamp: ~A ~A" (short-file-name s) c (maxamp s c) amp))))
			(car chan-list)
			(cadr chan-list)
			cur-maxamps
			cur-edits
			cur-framples)))
		
		;; scale-by
		((1) (let ((scaler (let ((maxscl (apply max cur-maxamps)))
				     (if (< maxscl 1.0) (+ 1.0 (random 1.0)) (+ 0.5 (random 0.5))))))
		       (scale-by scaler cursnd curchn)
		       (for-each
			(lambda (s c amp ed fr)
			  (if (or (and (= (sync cursnd) 0) 
				       (not (and (equal? s cursnd)
						 (= c curchn))))
				  (not (= (sync s) (sync cursnd))))
			      (begin
				(if (not (= (edit-position s c) ed))
				    (snd-display "scale-by ~A[~A] wrong edit pos: ~A ~A" (short-file-name s) c (edit-position s c) ed))
				(if (not (= (framples s c) fr))
				    (snd-display "scale-by ~A[~A] wrong framples: ~A ~A" (short-file-name s) c (framples s c) fr))
				(if (fneq (maxamp s c) amp)
				    (snd-display "scale-by ~A[~A] wrong maxamp: ~A ~A" (short-file-name s) c (maxamp s c) amp)))
			      (begin
				(if (not (or (= (edit-position s c) (+ 1 ed))
					     (= (edit-position s c) ed)))
				    (snd-display "scale-by ~A[~A] edit pos: ~A ~A" (short-file-name s) c (edit-position s c) ed))
				(if (not (= (framples s c) fr))
				    (snd-display "scale-by ~A[~A] framples: ~A ~A" (short-file-name s) c (framples s c) fr))
				(if (fneq (maxamp s c) (* scaler amp))
				    (snd-display "scale-by ~A[~A] maxamp: ~A ~A" (short-file-name s) c (maxamp s c) (* scaler amp))))))
			(car chan-list)
			(cadr chan-list)
			cur-maxamps
			cur-edits
			cur-framples)))
		
		;; scale-sound-by
		((4) (let ((scaler (let ((maxscl (apply max cur-maxamps)))
				     (if (< maxscl 1.0) (+ 1.0 (random 1.0)) (+ 0.5 (random 0.5))))))
		       (scale-sound-by scaler 1000 1000 cursnd)
		       (for-each
			(lambda (s c amp ed fr)
			  (if (equal? s cursnd)
			      (begin
				(if (not (or (= (edit-position s c) (+ 1 ed)) 
					     (= (edit-position s c) ed)))
				    (snd-display "scale-sound-by ~A[~A] edit pos: ~A ~A" (short-file-name s) c (edit-position s c) ed))
				(if (not (= (framples s c) fr))
				    (snd-display "scale-sound-by ~A[~A] framples: ~A ~A" (short-file-name s) c (framples s c) fr)))
			      (begin
				(if (not (= (edit-position s c) ed))
				    (snd-display "scale-sound-by ~A[~A] wrong edit pos: ~A ~A" (short-file-name s) c (edit-position s c) ed))
				(if (not (= (framples s c) fr))
				    (snd-display "scale-sound-by ~A[~A] wrong framples: ~A ~A" (short-file-name s) c (framples s c) fr))
				(if (fneq (maxamp s c) amp)
				    (snd-display "scale-sound-by ~A[~A] wrong maxamp: ~A ~A" (short-file-name s) c (maxamp s c) amp)))))
			(car chan-list)
			(cadr chan-list)
			cur-maxamps
			cur-edits
			cur-framples)))
		
		((5) (let ((pos (edit-position cursnd curchn)))
		       (if (> pos 0)
			   (undo (random pos) cursnd curchn))))
		
		((6) (let ((len (framples cursnd curchn)))
		       (if (> len 10000)
			   (let ((beg (random (floor (/ len 2)))))
			     (delete-samples beg (+ 10 (random 100)) cursnd curchn)))))
		
		((7) (let ((beg (random (+ (framples cursnd curchn) 100)))
			   (dur (+ 10 (random 100))))
		       (set! (samples beg dur cursnd curchn) (make-float-vector dur 1.0))))
		
		((8) (let ((beg (random (+ (framples cursnd curchn) 100)))
			   (dur (+ 10 (random 100))))
		       (insert-samples beg dur (make-float-vector dur 1.0) cursnd curchn)))
		
		((9) (add-mark (random (framples cursnd curchn)) cursnd curchn))
		
		((10) (let ((beg (random (+ (framples cursnd curchn) 100))))
			(mix-float-vector (make-float-vector (+ 10 (random 100)) (random 1.0)) beg cursnd curchn)))
		
		((11) (let ((beg (random (+ (framples cursnd curchn) 100))))
			(pad-channel beg (+ 10 (random 100)) cursnd curchn)))
		
		((13) (let ((beg (random (- (framples cursnd curchn) 100))))
			(scale-channel .5 beg (+ 10 (random 100)) cursnd curchn)))
		
		((14) (let ((beg (random (- (framples cursnd curchn) 200))))
			(scale-channel .5 beg (+ 10 (random 100)) cursnd curchn)
			(scale-channel .5 (+ beg 10) (+ 10 (random 100)) cursnd curchn)))
		
		((15) (let ((beg (random (- (framples cursnd curchn) 200))))
			(scale-channel .5 beg (+ 10 (random 100)) cursnd curchn)
			(scale-channel 2.0 beg (+ 10 (random 100)) cursnd curchn)))
		
		((16) (let ((beg (random (- (framples cursnd curchn) 200))))
			(pad-channel beg (+ 10 (random 100)) cursnd curchn)
			(pad-channel (+ beg 10) (+ 10 (random 100)) cursnd curchn)))
		
		((17) (let ((beg (random (- (framples cursnd curchn) 200))))
			(pad-channel beg (+ 10 (random 100)) cursnd curchn)
			(pad-channel beg (+ 10 (random 100)) cursnd curchn)))
		
		((18) (let ((beg (random (- (framples cursnd curchn) 200))))
			(delete-sample beg cursnd curchn)
			(delete-sample (+ beg (random 100)) cursnd curchn)))
		
		((19) (let ((beg (random (+ (framples cursnd curchn) 200))))
			(set! (sample beg cursnd curchn) .1)
			(set! (sample (+ beg (random 100)) cursnd curchn) .2)))
		
		((20) (let ((beg (random (- (framples cursnd curchn) 200))))
			(ramp-channel (- (random 2.0) 1.0) (- (random 2.0) 1.0) beg (+ 10 (random 100)) cursnd curchn)))
		
		((12) (let* ((e (let ((e1 ())
				      (x 0.0)
				      (y 0.0)
				      (pts (+ 1 (random 8))))
				  (do ((i 0 (+ i 1)))
				      ((= i pts))
				    (set! e1 (cons x e1))
				    (if (> (random 3) 0)
					(set! y (mus-random 1.0)))
				    (set! e1 (cons y e1))
				    (set! x (+ x .01 (random 1.0))))
				  (reverse e1)))
			     (beg (random (- (framples cursnd curchn) 300)))
			     (dur (+ 80 (random 200)))
			     (reader0 (make-sampler beg cursnd curchn)))
			(env-channel e beg dur cursnd curchn)
			(let ((reader1 (make-sampler beg cursnd curchn))
			      (en (make-env e :length dur)))
			  (do ((i 0 (+ i 1)))
			      ((= i dur))
			    (let* ((e0 (env en))
				   (val00 (reader0))
				   (val0 (* e0 val00))
				   (val1 (reader1)))
			      (when (> (abs (- val0 val1)) .005)
				(if (file-exists? "baddy.scm") (delete-file "baddy.scm"))
				(save-state "baddy.scm")
				(snd-display "read env off by ~A: ~%    (~A) at ~A: ~%    ~A ~A (~A ~A) [~A ~A]:~%    ~A" 
					     (abs (- val0 val1))
					     e i val0 val1
					     reader0 reader1 e0 val00
					     (safe-display-edits cursnd curchn))
				(error 'mus-error)))))))
		
		;; env-channel
		((2) 
		 (let ((pts (+ 1 (random 6))))
		   (when (undo-env cursnd curchn)
		     (set! cur-maxamps (apply map maxamp chan-list))
		     (set! cur-edits (apply map edit-position chan-list))
		     (set! cur-framples (apply map framples chan-list))
		     (set! cur-amp (maxamp cursnd curchn))
		     (set! cur-edit (edit-position cursnd curchn))
		     (set! cur-frame (framples cursnd curchn)))
		   (let ((e (do ((e1 ())
				 (x 0.0 (+ x .01 (random 1.0)))
				 (y 0.0)
				 (i 0 (+ i 1)))
				((= i pts)
				 (reverse e1))	   
			      (set! e1 (cons x e1))
			      (if (> (random 3) 0)
				  (set! y (mus-random 1.0)))
			      (set! e1 (cons y e1)))))
		     (env-channel e 0 (framples cursnd curchn) cursnd curchn))) ; can be a no-op
		 (if (not (or (= (edit-position cursnd curchn) (+ 1 cur-edit))
			      (= (edit-position cursnd curchn) cur-edit)))
		     (snd-display "env-channel ~A[~A] edit pos: ~A ~A" (short-file-name cursnd) curchn (edit-position cursnd curchn) cur-edit))
		 (if (not (= (framples cursnd curchn) cur-frame))
		     (snd-display "env-channel ~A[~A] framples: ~A ~A" (short-file-name cursnd) curchn (framples cursnd curchn) cur-frame))
		 (for-each
		  (lambda (s c amp ed fr)
		    (unless (and (equal? s cursnd)
				 (= c curchn))
		      (if (not (= (edit-position s c) ed))
			  (snd-display "env-channel ~A[~A] wrong edit pos: ~A ~A" (short-file-name s) c (edit-position s c) ed))
		      (if (not (= (framples s c) fr))
			  (snd-display "env-channel ~A[~A] wrong framples: ~A ~A" (short-file-name s) c (framples s c) fr))
		      (if (fneq (maxamp s c) amp)
			  (snd-display "env-channel ~A[~A] wrong maxamp: ~A ~A" (short-file-name s) c (maxamp s c) amp))))
		  (car chan-list)
		  (cadr chan-list)
		  cur-maxamps
		  cur-edits
		  cur-framples))
		
		;; env-sound
		((3) (let* ((pts (+ 1 (random 6)))
			    (recalc #f)
			    (e (do ((e1 ())
				    (x 0.0 (+ x .01 (random 1.0)))
				    (y 0.0)
				    (i 0 (+ i 1)))
				   ((= i pts)
				    (reverse e1))   
				 (set! e1 (cons x e1))
				 (if (> (random 3) 0)
				     (set! y (mus-random 1.0)))
				 (set! e1 (cons y e1))))
			    (end (apply min cur-framples)) ; env-sound can lengthen a shorter sound if syncd+multichannel
			    (beg (random (floor (/ end 2)))))
		       (for-each
			(lambda (s c)
			  (if (and (or (not (= (sync cursnd) 0))
				       (and (equal? s cursnd) (= c curchn)))
				   (= (sync s) (sync cursnd)))
			      (let ((val (undo-env s c)))
				(if (not recalc) (set! recalc val)))))
			(car chan-list)
			(cadr chan-list))
		       (when recalc
			 (set! cur-maxamps (apply map maxamp chan-list))
			 (set! cur-edits (apply map edit-position chan-list))
			 (set! cur-framples (apply map framples chan-list))
			 (set! cur-amp (maxamp cursnd curchn))
			 (set! cur-edit (edit-position cursnd curchn))
			 (set! cur-frame (framples cursnd curchn)))
		       (env-sound e beg (max pts (- end beg)) 1.0 cursnd curchn) ; dur here, not end point
		       (for-each
			(lambda (s c amp ed fr)
			  (if (or (and (= (sync cursnd) 0) 
				       (not (and (equal? s cursnd)
						 (= c curchn))))
				  (not (= (sync s) (sync cursnd))))
			      (begin
				(if (not (= (edit-position s c) ed))
				    (snd-display "env-sound ~A[~A] wrong edit pos: ~A ~A" (short-file-name s) c (edit-position s c) ed))
				(if (not (= (framples s c) fr))
				    (snd-display "env-sound ~A[~A] wrong framples: ~A ~A" (short-file-name s) c (framples s c) fr))
				(if (fneq (maxamp s c) amp)
				    (snd-display "env-sound ~A[~A] wrong maxamp: ~A ~A" (short-file-name s) c (maxamp s c) amp)))
			      (begin
				(if (not (or (= (edit-position s c) (+ 1 ed))
					     (= (edit-position s c) ed)))
				    (snd-display "env-sound ~A[~A] edit pos: ~A ~A" (short-file-name s) c (edit-position s c) ed))
				(if (not (= (framples s c) fr))
				    (snd-display "env-sound ~A[~A] framples: ~A ~A" (short-file-name s) c (framples s c) fr)))))
			(car chan-list)
			(cadr chan-list)
			cur-maxamps
			cur-edits
			cur-framples)))))))))
	
    (define (amp-envs-equal? snd chn pos0 pos1 df)
      (let ((env0 (channel-amp-envs snd chn pos0))
	    (env1 (channel-amp-envs snd chn pos1)))
	(let ((len0 (and (pair? env0) (= (length env0) 2) (length (cadr env0))))
	      (len1 (and (pair? env1) (= (length env1) 2) (length (cadr env1))))
	      (happy #t))
	  (and len0 len1
	       (let ((minlen (min len0 len1)))
		 (let ((minlen1 (- minlen 1))
		       (inc0 (/ len0 minlen))
		       (inc1 (/ len1 minlen))
		       (e0 (cadr env0))
		       (e1 (cadr env1)))
		   (if (not (and (integer? inc0) 
				 (integer? inc1)))
		       (begin
			 (snd-display "lens: ~A ~A" len0 len1)
			 #f)
		       (do ((i 0 (+ i 1))
			    (max0 -1.0 -1.0)
			    (max1 -1.0 -1.0))
			   ((or (not happy) (= i minlen1))
			    happy)
			 (if (= inc0 1)
			     (set! max0 (e0 i))
			     (do ((j 0 (+ j 1))
				  (j1 (* inc0 i) (+ j1 1)))
				 ((= j inc0))
			       (set! max0 (max max0 (e0 j1)))))
			 (if (= inc1 1)
			     (set! max1 (e1 i))
			     (do ((j 0 (+ j 1))
				  (j1 (* inc1 i) (+ j1 1)))
				 ((= j inc1))
			       (set! max1 (max max1 (e1 j1)))))
			 (when (> (abs (- max0 max1)) df)
			   (snd-display "amp-env ~A: ~A ~A" i max0 max1)
			   (set! happy #f))))))))))
    
    (define* (edit-difference s1 c1 e1 e2 (offset 0))
      (let ((N (framples s1 c1 e1)))
	(let ((d1 (samples 0 N s1 c1 e1))
	      (d2 (samples 0 N s1 c1 e2)))
	  (float-vector-subtract! d1 d2)
	  (let ((diffs (float-vector-peak-and-location d1)))
	    (and (> (car diffs) 0.0)
		 diffs)))))
    
    (define* (edit-distance s1 c1 e1 e2 (offset 0))
      (let ((N (framples s1 c1 e1)))
	(let ((incr (make-one-pole 1.0 -1.0))
	      (d1 (samples 0 N s1 c1 e1))
	      (d2 (samples 0 N s1 c1 e2)))
	  (float-vector-multiply! d1 d1)
	  (float-vector-multiply! d2 d2)
	  (float-vector-subtract! d1 d2)
	  (float-vector-abs! d1)
	  (do ((i 0 (+ i 1)))
	      ((= i N))
	    (one-pole incr (float-vector-ref d1 i)))
	  (sqrt (one-pole incr 0.0)))))
    
    (define check-edit-tree-1 
      (letrec ((mus-arrays-equal?-at 
		(lambda (v0 v1)
		  (call-with-exit
		   (lambda (return)
		     (do ((len (length v0))
			  (i 0 (+ i 1)))
			 ((= i len) #f)
		       (if (> (abs (- (v0 i) (v1 i))) .001)
			   (return (list i (v0 i) (v1 i)))))))))
	       (edits-not-equal? 
		(lambda (tl0 tl1 pos)
		  (if (null? tl0)
		      (and (not (null? tl1))
			   (list pos tl0 #f))
		      (let ((t0 (car tl0))
			    (t1 (car tl1)))
			(if (not (and (= (car t0) (car t1))
				      (= (cadr t0) (cadr t1))
				      (= (caddr t0) (caddr t1))
				      (= (cadddr t0) (cadddr t1))
				      (<= (abs (- (t0 4) (t1 4))) 0.0001)
				      (<= (abs (- (t0 5) (t1 5))) 0.0001)
				      (<= (abs (- (t0 6) (t1 6))) 0.0001)))
			    (list pos t0 t1)
			    (edits-not-equal? (cdr tl0) (cdr tl1) (+ 1 pos))))))))
	(lambda (expected-tree expected-vals name line)
	  (let* ((current-vals (channel->float-vector))
		 (len (length current-vals)))
	    (if (and expected-vals (not (= len (length expected-vals))))
		(snd-display "~A (from ~A): lengths differ: ~A ~A" name line len (length expected-vals))
		(if (and expected-vals (not (mus-arrays-equal? current-vals expected-vals)))
		    (snd-display "checking ~A (from ~A), vals disagree (loc cur expect): ~A" name line (mus-arrays-equal?-at current-vals expected-vals))
		    (let ((bad-data (edits-not-equal? (edit-tree) expected-tree 0)))
		      (if bad-data
			  (snd-display "checking ~A (from ~A), trees disagree (loc cur expect): ~A~%  in~%~A" name line bad-data (edit-tree)))
		      (if (> len 5)
			  (let* ((split-loc (+ 2 (random (- len 3))))
				 (fread (make-sampler split-loc))
				 (bread (make-sampler (- split-loc 1) #f #f -1))
				 (split-vals (make-float-vector len)))
			    (do ((i split-loc (+ i 1)))
				((= i len))
			      (float-vector-set! split-vals i (read-sample fread)))
			    (do ((i (- split-loc 1) (- i 1)))
				((< i 0))
			      (float-vector-set! split-vals i (read-sample bread)))
			    (if (and expected-vals (not (mus-arrays-equal? split-vals expected-vals)))
				(snd-display "checking ~A (from ~A), split vals disagree (loc cur expect): ~A"
					     name line (mus-arrays-equal?-at split-vals expected-vals))))))))))))
    
    (define (zigzag-check name snd chn)
      (let ((data (channel->float-vector))
	    (sf (make-sampler 3 snd chn)))
	(do ((i 3 (+ i 1)))
	    ((= i 8))
	  (let ((val (next-sample sf)))
	    (if (fneq (data i) val)
		(snd-display "~A: forward data[~D]: ~A ~A" name i val (data i)))))
	(do ((i 7 (- i 1)))
	    ((= i 0))
	  (let ((val (previous-sample sf)))
	    (if (fneq (data i) val)
		(snd-display "~A: backward data[~D]: ~A ~A" name i val (data i)))))))
    
    (define (init-sound val dur chans)
      (let ((ind (new-sound "test.snd" chans 22050 mus-ldouble mus-next)))
	(do ((i 0 (+ i 1)))
	    ((= i chans))
	  (insert-silence 0 dur ind i)
	  (map-channel (lambda (y) val) 0 (framples) ind i))
	ind))
    
    (define check-back-and-forth
      (let ((reversed-read (lambda (snd chn)
			     (let* ((len (framples snd chn))
				    (data (make-float-vector len))
				    (sf (make-sampler (- len 1) snd chn -1)))
			       (do ((i (- len 1) (- i 1)))
				   ((< i 0))
				 (set! (data i) (read-sample sf)))
			       data))))
	(lambda (ind name v)
	  (let ((happy #t))
	    (unless (mus-arrays-equal? v (channel->float-vector 0 (framples) ind 0))
	      (set! happy #f)
	      (snd-display "~A forth:~%     current: ~A~%     expected: ~A" name (channel->float-vector 0 (framples) ind 0) v))
	    (unless (mus-arrays-equal? v (reversed-read ind 0))
	      (set! happy #f)
	      (snd-display "~A back: ~A ~A" name (reversed-read ind 0) v))
	    happy))))
    
    
    (define (check-both-chans ind name f0 f1)
      (let ((c0 (scan-channel f0 0 (framples) ind 0))
	    (c1 (scan-channel f1 0 (framples) ind 1)))
	(if c0 (snd-display "~A swap c0: ~A" name c0))
	(if c1 (snd-display "~A swap c1: ~A" name c1))))
    
    
    (define (convolve-coeffs v1 v2)
      (let* ((v1-len (length v1))
	     (v2-len (length v2))
	     (res-len (+ v1-len v2-len -1)))
	(do ((vres (make-float-vector res-len))
	     (i 0 (+ i 1)))
	    ((= i res-len)
	     vres)
	  (do ((sum 0.0)
	       (j (max 0 (- (+ i 1) v2-len)) (+ j 1)))
	      ((> j (min i (- v1-len 1)))
	       (set! (vres i) sum))   
	    (set! sum (+ sum (* (v1 j) 
				(v2 (- i j)))))))))
    ;; test_16
    (lambda ()
      (do ((test-16 0 (+ 1 test-16)))
	  ((= test-16 tests))
	(let ((oboe (open-sound "oboe.snd")))
	  (log-mem test-16)
	  (for-each
	   (lambda (func name)
	     (func)
	     (if (not (= (edit-position oboe) 0))
		 (snd-display "dur:0 ~A? ~A ~A" name (edit-position oboe) (edit-fragment))))
	   (list 
	    (lambda () (scale-channel 2.0 0 0 oboe))
	    (lambda () (env-channel (make-env '(0 0 1 1) :length 124) 0 0 oboe))
	    (lambda () (clm-channel (make-oscil) 0 0 oboe))
	    (lambda () (float-vector->channel (make-float-vector 3) 0 0 oboe))
	    (lambda () (smooth-channel 0 0 oboe))
	    (lambda () (pad-channel 0 0 oboe))
	    (lambda () (src-channel 2.0 0 0 oboe))
	    (lambda () (mix-channel "pistol.snd" 0 0 oboe))
	    (lambda () (insert-channel "pistol.snd" 0 0 oboe))
	    (lambda () (reverse-channel 0 0 oboe))
	    (lambda () (play oboe :start 0 :end 0))
	    (lambda () (scale-sound-by 2.0 0 0 oboe))
	    (lambda () (env-sound '(0 0 1 1) 0 0 oboe))
	    (lambda () (set-samples 0 0 (make-float-vector 3) oboe))
	    (lambda () (smooth-sound 0 0 oboe))
	    (lambda () (insert-silence 0 0 oboe)))
	   '("scale-channel" "env-channel" "clm-channel" "float-vector->channel" "smooth-channel" "pad-channel" "src-channel" 
	     "mix-channel" "insert-channel" "reverse-channel" "play" "scale-sound-by" "env-sound" "set-samples" "smooth-sound" "insert-silence"))
	  (for-each
	   (lambda (func name)
	     (let ((tag (catch #t
			  func
			  (lambda args (car args)))))
	       (if (not (eq? tag 'no-such-sample))
		   (snd-display "~A beg -1->~A" name tag))
	       (if (not (= (edit-position oboe) 0))
		   (snd-display "beg:-1 ~A? ~A ~A" name (edit-position oboe) (edit-fragment)))))
	   (list 
	    (lambda () (scale-channel 2.0 -1 123 oboe))
	    (lambda () (env-channel (make-env '(0 0 1 1) :length 124) -1 123 oboe))
	    (lambda () (clm-channel (make-oscil) -1 123 oboe))
	    (lambda () (float-vector->channel (make-float-vector 3) -1 123 oboe))
	    (lambda () (smooth-channel -1 123 oboe))
	    (lambda () (pad-channel -1 123 oboe))
	    (lambda () (src-channel 2.0 -1 123 oboe))
	    (lambda () (mix-channel "pistol.snd" -1 123 oboe))
	    (lambda () (insert-channel "pistol.snd" -1 123 oboe))
	    (lambda () (reverse-channel -1 123 oboe))
	    (lambda () (scale-sound-by 2.0 -1 123 oboe))
	    (lambda () (env-sound '(0 0 1 1) -1 123 oboe))
	    (lambda () (set-samples -1 123 (make-float-vector 3) oboe))
	    (lambda () (smooth-sound -1 123 oboe))
	    (lambda () (insert-silence -1 123 oboe)))
	   '("scale-channel" "env-channel" "clm-channel" "float-vector->channel" "smooth-channel" "pad-channel" "src-channel" "mix-channel" 
	     "insert-channel" "reverse-channel" "scale-sound-by" "env-sound" "set-samples" "smooth-sound" "insert-silence"))
	  
	  (scale-channel 2.0 12345678 123 oboe)
	  (if (not (= (edit-position oboe) 0))
	      (snd-display "beg:12345678 scale-channel? ~A ~A" (edit-position oboe) (edit-fragment)))
	  (env-channel (make-env '(0 0 1 1) :length 124) 12345678 123 oboe)
	  (if (not (= (edit-position oboe) 0))
	      (snd-display "beg:12345678 env-channel? ~A ~A" (edit-position oboe) (edit-fragment)))
	  (smooth-channel 12345678 123 oboe)
	  (if (not (= (edit-position oboe) 0))
	      (snd-display "beg:12345678 smooth-channel? ~A ~A" (edit-position oboe) (edit-fragment)))
	  (src-channel 2.0 12345678 123 oboe)
	  (if (not (= (edit-position oboe) 0))
	      (snd-display "beg:12345678 src-channel? ~A ~A" (edit-position oboe) (edit-fragment)))
	  (reverse-channel 12345678 123 oboe)
	  (if (not (= (edit-position oboe) 0))
	      (snd-display "beg:12345678 reverse-channel? ~A ~A" (edit-position oboe) (edit-fragment)))
	  (play oboe :start 12345678 :end 12345801) ;(+ 12345678 123)
	  
	  (scale-channel 2.0 0 123 oboe 0)
	  (if (not (= (edit-position oboe) 1))
	      (snd-display "oboe scale-channel? ~A ~A" (edit-position oboe) (edit-fragment)))
	  (env-channel (make-env '(0 0 1 1) :length 124) 0 123 oboe 0)
	  (if (not (= (edit-position oboe) 2))
	      (snd-display "oboe env-channel? ~A ~A" (edit-position oboe) (edit-fragment)))
	  (clm-channel (make-oscil) 0 123 oboe 0)
	  (if (not (= (edit-position oboe) 3))
	      (snd-display "oboe clm-channel? ~A ~A" (edit-position oboe) (edit-fragment)))
	  (float-vector->channel (make-float-vector 3) 0 123 oboe 0)
	  (if (not (= (edit-position oboe) 4))
	      (snd-display "oboe float-vector->channel? ~A ~A" (edit-position oboe) (edit-fragment)))
	  (smooth-channel 0 123 oboe 0)
	  (if (not (= (edit-position oboe) 5))
	      (snd-display "oboe smooth-channel? ~A ~A" (edit-position oboe) (edit-fragment)))
	  (pad-channel 0 123 oboe 0)
	  (if (not (= (edit-position oboe) 6))
	      (snd-display "oboe pad-channel? ~A ~A" (edit-position oboe) (edit-fragment)))
	  (src-channel 2.0 0 123 oboe 0)
	  (if (not (= (edit-position oboe) 7))
	      (snd-display "oboe src-channel? ~A ~A" (edit-position oboe) (edit-fragment)))
	  (mix-channel "pistol.snd" 0 123 oboe 0)
	  (if (not (= (edit-position oboe) 8))
	      (snd-display "oboe mix-channel? ~A ~A" (edit-position oboe) (edit-fragment)))
	  (insert-channel "pistol.snd" 0 123 oboe 0)
	  (if (not (= (edit-position oboe) 9))
	      (snd-display "oboe insert-channel? ~A ~A" (edit-position oboe) (edit-fragment)))
	  (reverse-channel 0 123 oboe 0)
	  (if (not (= (edit-position oboe) 10))
	      (snd-display "oboe reverse-channel? ~A ~A" (edit-position oboe) (edit-fragment)))
	  (let ((sr (make-src :srate 2.0 
			      :input (let ((rd (make-sampler 0)))
				       (lambda (dir) 
					 (read-sample rd))))))
	    (clm-channel sr 0 12345 oboe 0)
	    (if (not (= (edit-position oboe) 11))
		(snd-display "oboe clm-channel src? ~A ~A" (edit-position oboe) (edit-fragment))))
	  (let ((sr (make-granulate :expansion 2.0 
				    :input (let ((rd (make-sampler 0)))
					     (lambda (dir) 
					       (read-sample rd))))))
	    (clm-channel sr 0 12345 oboe 0)
	    (if (not (= (edit-position oboe) 12))
		(snd-display "oboe clm-channel granulate? ~A ~A" (edit-position oboe) (edit-fragment))))
	  (let ((sr (make-convolve :input (let ((rd (make-sampler 0)))
					    (lambda (dir) 
					      (read-sample rd)))
				   :filter #r(1.0 0.0 0.0 0.0))))
	    (clm-channel sr 0 12345 oboe 0)
	    (if (not (= (edit-position oboe) 13))
		(snd-display "oboe clm-channel convolve? ~A ~A" (edit-position oboe) (edit-fragment))))
	  (let ((sr (make-phase-vocoder :input (let ((rd (make-sampler 0)))
						 (lambda (dir) 
						   (read-sample rd))))))
	    (clm-channel sr 0 12345 oboe 0)
	    (if (not (= (edit-position oboe) 14))
		(snd-display "oboe clm-channel phase-vocoder? ~A ~A" (edit-position oboe) (edit-fragment))))
	  (revert-sound)
	  
	  (catch #t (lambda () (env-channel (make-env '(0 0 1 1) :length 124) 0 123 oboe 0 123)) (lambda args (car args)))
	  (if (not (= (edit-position oboe) 0))
	      (snd-display "edpos 123 env-channel? ~A ~A" (edit-position oboe) (edit-fragment)))
	  (catch #t (lambda () (clm-channel (make-oscil) 0 123 oboe 0 123)) (lambda args (car args)))
	  (if (not (= (edit-position oboe) 0))
	      (snd-display "edpos 123 clm-channel? ~A ~A" (edit-position oboe) (edit-fragment)))
	  (catch #t (lambda () (float-vector->channel (make-float-vector 3) 0 123 oboe 0 123)) (lambda args (car args)))
	  (if (not (= (edit-position oboe) 0))
	      (snd-display "edpos 123 float-vector->channel? ~A ~A" (edit-position oboe) (edit-fragment)))
	  (catch #t (lambda () (smooth-channel 0 123 oboe 0 123)) (lambda args (car args)))
	  (if (not (= (edit-position oboe) 0))
	      (snd-display "edpos 123 smooth-channel? ~A ~A" (edit-position oboe) (edit-fragment)))
	  (catch #t (lambda () (pad-channel 0 123 oboe 0 123)) (lambda args (car args)))
	  (if (not (= (edit-position oboe) 0))
	      (snd-display "edpos 123 pad-channel? ~A ~A" (edit-position oboe) (edit-fragment)))
	  (catch #t (lambda () (src-channel 2.0 0 123 oboe 0 123)) (lambda args (car args)))
	  (if (not (= (edit-position oboe) 0))
	      (snd-display "edpos 123 src-channel? ~A ~A" (edit-position oboe) (edit-fragment)))
	  (catch #t (lambda () (mix-channel "pistol.snd" 0 123 oboe 0 123)) (lambda args (car args)))
	  (if (not (= (edit-position oboe) 0))
	      (snd-display "edpos 123 mix-channel? ~A ~A" (edit-position oboe) (edit-fragment)))
	  (catch #t (lambda () (insert-channel "pistol.snd" 0 123 oboe 0 123)) (lambda args (car args)))
	  (if (not (= (edit-position oboe) 0))
	      (snd-display "edpos 123 insert-channel? ~A ~A" (edit-position oboe) (edit-fragment)))
	  (catch #t (lambda () (reverse-channel 0 123 oboe 0 123)) (lambda args (car args)))
	  (if (not (= (edit-position oboe) 0))
	      (snd-display "edpos 123 reverse-channel? ~A ~A" (edit-position oboe) (edit-fragment)))
	  (revert-sound oboe)
	  
	  (let ((oldv (channel->float-vector 1000 10 oboe)))
	    (mix-channel "oboe.snd" 0)
	    (float-vector-scale! oldv 2.0)
	    (if (not (mus-arrays-equal? oldv (channel->float-vector 1000 10 oboe)))
		(snd-display "mix-channel at 0: ~A ~A" oldv (channel->float-vector 1000 10 oboe)))
	    (revert-sound oboe)
	    (float-vector-scale! oldv 0.5)
	    (insert-channel "oboe.snd" 0)
	    (if (not (mus-arrays-equal? oldv (channel->float-vector 1000 10 oboe)))
		(snd-display "insert-channel at 0: ~A ~A" oldv (channel->float-vector 1000 10 oboe)))
	    (if (not (= (framples oboe 0) (* 2 (framples oboe 0 0))))
		(snd-display "insert-channel framples: ~A ~A" (framples oboe 0) (framples oboe 0 0)))
	    (revert-sound oboe))
	  (close-sound oboe)
	  
	  (let ((ind (new-sound "test.snd" :size 10 :channels 2)))
	    (set! (sample 3 ind 0) .5)
	    (set! (sample 2 ind 1) -.4)
	    (save-sound-as "fmv.snd")
	    (revert-sound ind)
	    (let ((val (mix-channel "fmv.snd")))
	      (if (mix? val)
		  (snd-display "mix-channel returned a mix: ~A?" val)))
	    (if (not (mus-arrays-equal? (channel->float-vector 0 #f ind 1) (make-float-vector 10)))
		(snd-display "mix-channel mixed channel 1: ~A?" (channel->float-vector 0 #f ind 1)))
	    (if (not (mus-arrays-equal? (channel->float-vector 0 #f ind 0) #r(0 0 0 .5 0 0 0 0 0 0)))
		(snd-display "mix-channel chan 0: ~A" (channel->float-vector 0 #f ind 0)))
	    (revert-sound ind)
	    (let ((val (mix-channel (list "fmv.snd" 2 1) 0 #f ind 0)))
	      (if (mix? val)
		  (snd-display "mix-channel 2 returned a mix: ~A?" val)))
	    (if (not (mus-arrays-equal? (channel->float-vector 0 #f ind 1) (make-float-vector 10)))
		(snd-display "mix-channel mixed channel 1a: ~A?" (channel->float-vector 0 #f ind 1)))
	    (if (not (mus-arrays-equal? (channel->float-vector 0 #f ind 0) #r(-.4 0 0 0 0 0 0 0 0 0)))
		(snd-display "mix-channel chan 0a: ~A" (channel->float-vector 0 #f ind 0)))
	    (revert-sound ind)
	    (set! (sample 2 ind 1) -.4)
	    (let ((val (mix-channel (list ind 2 1) 0 #f ind 0 -1 #t)))
	      (if (not (mix? val))
		  (snd-display "mix-channel with-tag: ~A" val)))
	    (if (not (mus-arrays-equal? (channel->float-vector 0 #f ind 1) #r(0 0 -.4 0 0 0 0 0 0 0)))
		(snd-display "mix-channel mixed channel 1b: ~A?" (channel->float-vector 0 #f ind 1)))
	    (if (not (mus-arrays-equal? (channel->float-vector 0 #f ind 0) #r(-.4 0 0 0 0 0 0 0 0 0)))
		(snd-display "mix-channel chan 0b: ~A" (channel->float-vector 0 #f ind 0)))
	    (revert-sound ind)
	    (let ((val (car (mix-channel (list "fmv.snd" 2 1) 0 #f ind 0 -1 #t))))
	      (if (not (mix? val))
		  (snd-display "mix-channel file with-tag: ~A" val)))
	    (if (not (mus-arrays-equal? (channel->float-vector 0 #f ind 1) (make-float-vector 10)))
		(snd-display "mix-channel mixed channel 1c: ~A?" (channel->float-vector 0 #f ind 1)))
	    (if (not (mus-arrays-equal? (channel->float-vector 0 #f ind 0) #r(-.4 0 0 0 0 0 0 0 0 0)))
		(snd-display "mix-channel chan 0c: ~A" (channel->float-vector 0 #f ind 0)))
	    (revert-sound ind)
	    (let ((val (car (mix-channel (list "fmv.snd") 0 #f ind 1 -1 #t))))
	      (if (not (mix? val))
		  (snd-display "mix-channel file 1 with-tag: ~A" val)))
	    (if (not (mus-arrays-equal? (channel->float-vector 0 #f ind 0) (make-float-vector 10)))
		(snd-display "mix-channel mixed channel 0d: ~A?" (channel->float-vector 0 #f ind 1)))
	    (if (not (mus-arrays-equal? (channel->float-vector 0 #f ind 1) #r(0 0 0 .5 0 0 0 0 0 0)))
		(snd-display "mix-channel chan 1d: ~A" (channel->float-vector 0 #f ind 1)))
	    (revert-sound ind)
	    (if (file-exists? "fmv.snd") (delete-file "fmv.snd"))
	    (close-sound ind))
	  
	  (if (not (= *default-output-chans* 1)) (set! *default-output-chans* 1))
	  (let ((ind (new-sound "fmv.snd")))
	    (float-vector->channel (make-float-vector 20 1.0))
	    (if (not (= (framples) 20)) (snd-display "float-vector->channel new 20: ~A" (framples)))
	    (if (fneq (maxamp) 1.0) (snd-display "float-vector 1->new: ~A" (maxamp)))
	    
	    (env-channel (make-env '(0 0 1 1 2 1) :base 0 :length 20))
	    (let ((v1 (channel->float-vector)))
	      (if (not (mus-arrays-equal? v1 #r(0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1)))
		  (snd-display "env-channel step 1: ~A" v1)))
	    (undo)
	    (env-channel (make-env '(0 0 1 1 2 1) :base 0 :length 20) 8)
	    (let ((v1 (channel->float-vector)))
	      (if (not (mus-arrays-equal? v1 #r(1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 1 1)))
		  (snd-display "env-channel step 1 at 8: ~A" v1)))
	    (undo)
	    (env-channel (make-env '(0 0 1 1 2 1) :base 0 :length 12))
	    (let ((v1 (channel->float-vector)))
	      (if (not (mus-arrays-equal? v1 #r(0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1)))
		  (snd-display "env-channel step 1 at 0: ~A" v1)))
	    (undo)
	    (env-channel (make-env '(0 0 1 1 2 1) :base 0 :length 12) 4)
	    (let ((v1 (channel->float-vector)))
	      (if (not (mus-arrays-equal? v1 #r(1 1 1 1 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1)))
		  (snd-display "env-channel step 1 at 4: ~A" v1)))
	    (undo)
	    (env-channel (make-env '(0 0 1 1 2 1) :base 0 :length 12) 4 3)
	    (let ((v1 (channel->float-vector)))
	      (if (not (mus-arrays-equal? v1 #r(1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1)))
		  (snd-display "env-channel step 1 at 4 by 3: ~A" v1)))
	    (undo)
	    (env-channel (make-env '(0 1 1 0 2 0) :base 0 :length 8) 0 12)
	    (let ((v1 (channel->float-vector)))
	      (if (not (mus-arrays-equal? v1 #r(1 1 1 1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1)))
		  (snd-display "env-channel step 1 at 0 for 7: ~A" v1)))
	    (undo)
	    (env-channel (make-env '(0 0 1 1 2 1 3 0 4 0) :base 0 :length 20))
	    (let ((v1 (channel->float-vector)))
	      (if (not (mus-arrays-equal? v1 #r(0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0)))
		  (snd-display "env-channel step 1: ~A" v1)))
	    (env-channel (make-env '(0 0 1 .5 2 .25 3 0 4 0) :base 0 :length 21))
	    (let ((v1 (channel->float-vector)))
	      (if (not (mus-arrays-equal? v1 #r(0 0 0 0 0 0 .5 .5 .5 .5 .5 .25 .25 .25 .25 0 0 0 0 0)))
		  (snd-display "env-channel step 1 (.5): ~A" v1)))
	    (close-sound ind))
	  
	  (set! *x-axis-style* x-axis-as-percentage)
	  (let ((ind (open-sound "2.snd")))
	    (let ((fr (framples))
		  (m0 (maxamp ind 0))
		  (m1 (maxamp ind 1)))
	      (set! (sync ind) 64)
	      (insert-sound "2.snd")
	      (insert-sound "2.snd")
	      (if (not (= (framples) (* 3 fr))) (snd-display "2.snd 3x = ~A ~A" fr (framples)))
	      (if (not (= (framples ind 0) (framples ind 1))) (snd-display "insert sync'd: ~A ~A" (framples ind 0) (framples ind 1)))
	      (swap-channels)
	      (if (or (fneq m0 (maxamp ind 1)) (fneq m1 (maxamp ind 0)))
		  (snd-display "swapped: ~A ~A -> ~A ~A" m0 m1 (maxamp ind 0) (maxamp ind 1)))
	      (close-sound ind)))
	  (set! *x-axis-style* x-axis-in-seconds)
	  (let ((new-snd (mono-files->stereo "test.snd" "oboe.snd" "pistol.snd")))
	    (if (not (= (channels new-snd) 2)) (snd-display "mono-files->stereo not stereo? ~A" (channels new-snd)))
	    (if (not (string=? (short-file-name new-snd) "test.snd")) (snd-display "mono-files->stereo filename: ~A" (short-file-name new-snd)))
	    (if (not (= (framples new-snd) 50828)) (snd-display "mono-files->stereo framples: ~A" (framples new-snd)))
	    (close-sound new-snd))
	  
	  (let ((oboe0 (open-sound "oboe.snd"))
		(oboe1 (open-sound "oboe.snd")))
	    
	    (define (funcs-equal? name func0 func1)
	      (func0 #f #f oboe0)
	      (func1 #f #f oboe1)
	      (if (not (mus-arrays-equal? (channel->float-vector 1000 100 oboe0) (channel->float-vector 1000 100 oboe1)))
		  (snd-display "~A via #f: ~A ~A" name (channel->float-vector 1000 100 oboe0) (channel->float-vector 1000 100 oboe1)))
	      (revert-sound oboe0)
	      (revert-sound oboe1)
	      (select-sound oboe0)
	      (func0)
	      (select-sound oboe1)
	      (func1)
	      (if (not (mus-arrays-equal? (channel->float-vector 1000 100 oboe0) (channel->float-vector 1000 100 oboe1)))
		  (snd-display "~A via none: ~A ~A" name (channel->float-vector 1000 100 oboe0) (channel->float-vector 1000 100 oboe1)))
	      (revert-sound oboe0)
	      (revert-sound oboe1)
	      (func0 0 (framples oboe0) oboe0)
	      (func1 0 (framples oboe1) oboe1)
	      (if (not (mus-arrays-equal? (channel->float-vector 1000 100 oboe0) (channel->float-vector 1000 100 oboe1)))
		  (snd-display "~A via framples: ~A ~A" name (channel->float-vector 1000 100 oboe0) (channel->float-vector 1000 100 oboe1)))
	      (revert-sound oboe0)
	      (revert-sound oboe1))
	    
	    (funcs-equal? "scale-sound-by" 
			  (lambda args (apply scale-sound-by 2.0 args))
			  (lambda args (apply scale-channel 2.0 args)))
	    (funcs-equal? "scale-and-ramp" 
			  (lambda args (apply scale-sound-by 0.0 args))
			  (lambda args (apply ramp-channel 0.0 0.0 args)))
	    (funcs-equal? "scale-and-ramp" 
			  (lambda args (apply scale-sound-by 2.0 args))
			  (lambda args (apply ramp-channel 2.0 2.0 args)))
	    (funcs-equal? "smooth-sound"
			  smooth-sound
			  smooth-channel)
	    (funcs-equal? "env-sound"
			  (lambda args (env-sound '(0 0 1 1)
						  (if (pair? args) (car args) 0)
						  (and (> (length args) 1)
						       (number? (cadr args))
						       (- (cadr args) 1))
						  1.0
						  (if (> (length args) 2)
						      (caddr args)
						      (selected-sound))))
			  (lambda args 
			    (let ((e (make-env :envelope '(0 0 1 1) 
					       :length (if (and (> (length args) 1)
								(number? (cadr args)))
							   (cadr args)
							   (framples (if (> (length args) 2)
									 (caddr args)
									 (selected-sound)))))))
			      (apply env-channel e args))))
	    (funcs-equal? "src-sound"
			  (lambda args (src-sound 2.0 1.0 (and (> (length args) 2) (caddr args))))
			  (lambda args (apply src-channel 2.0 args)))
	    (funcs-equal? "reverse-sound"
			  (lambda args (reverse-sound (and (> (length args) 2) (caddr args))))
			  reverse-channel)
	    (funcs-equal? "mix"
			  (lambda args (mix "pistol.snd" 0 0 (and (> (length args) 2) (caddr args))))
			  (lambda args (apply mix-channel "pistol.snd" args)))
	    (funcs-equal? "insert-sound"
			  (lambda args (insert-sound "pistol.snd" 0 0 (and (> (length args) 2) (caddr args))))
			  (lambda args (apply insert-channel "pistol.snd" args)))
	    (close-sound oboe0)
	    (close-sound oboe1))
	  
	  (let ((ind (open-sound "oboe.snd"))
		(ind1 (new-sound "test.snd")))
	    (let-temporarily ((*save-dir* #f))
	      (map-channel (lambda (y) 0.5) 0 100 ind1 0)
	      (save-sound ind1)
	      (close-sound ind1)
	      (insert-sound "test.snd" 12345)
	      (let ((vals (channel->float-vector 12295 200 ind 0)))
		(if (file-exists? "hiho.scm") (delete-file "hiho.scm"))
		(save-state "hiho.scm")
		(close-sound ind)
		(for-each forget-region (regions))
		(load (string-append cwd "hiho.scm"))
		(set! ind (find-sound "oboe.snd"))
		(if (not (sound? ind))
		    (snd-display "save hiho failed?")
		    (let ((new-vals (channel->float-vector 12295 200 ind 0)))
		      (if (not (mus-arrays-equal? vals new-vals))
			  (snd-display "save state hiho vals: ~A ~A" vals new-vals))))
		(close-sound ind))))
	  
	  (let ((ind (new-sound "test.snd")))
	    (map-channel (lambda (y) (random 1.0)) 0 10)
	    (ramp-channel 0.0 1.0)
	    (zigzag-check "ramp" ind 0)
	    (undo)
	    (revert-sound ind)
	    (close-sound ind))
	  
	  (set! *x-axis-style* x-axis-in-beats)
	  (let ((ind (open-sound "storm.snd")))
	    (reverse-channel 500000 1000000)
	    (set! (sample 0 ind 0 current-edit-position) .1)
	    (if (fneq (sample 0 ind 0 current-edit-position) .1) 
		(snd-display "set sample + edpos: ~A" (sample 0 ind 0 current-edit-position)))
	    (close-sound ind))
	  (set! *x-axis-style* x-axis-in-seconds)
	  
	  (for-each 
	   (lambda (out-chans)
	     (let ((ind (new-sound "new.snd" out-chans 22050 mus-ldouble mus-next "edpos testing"))
		   (mx (apply max (map sync (sounds)))))
	       (set! (sync ind) (+ mx 1))
	       (for-each 
		(lambda (in-sound)
		  (for-each
		   (lambda (func)
		     (for-each 
		      (lambda (edpos)
			(func edpos)
			(revert-sound ind))
		      (list (lambda () current-edit-position)
			    (lambda () 0)
			    (lambda () (- (edit-position ind 0) 1))
			    (lambda () (edit-position ind 0)))))
		   (list 
		    (lambda (posfunc)
		      (let ((chn (min (random (+ 1 out-chans)) (- out-chans 1))))
			(if (not (mus-arrays-equal? (channel->float-vector 0 (framples ind chn) ind chn 0) #r(0.0)))
			    (snd-display "start bad: ~A" (channel->float-vector 0 (framples ind chn) ind chn 0)))
			(set! (sample 0 ind chn) .1)
			(if (not (mus-arrays-equal? (channel->float-vector 0 (framples ind chn) ind chn) #r(0.1)))
			    (snd-display "set bad: ~A" (channel->float-vector 0 (framples ind chn) ind chn)))
			(pad-channel 0 1 ind chn (posfunc))
			(let ((pos (posfunc)))
			  (if (procedure? pos)
			      (set! pos (pos ind chn)))
			  (let ((data (channel->float-vector 0 (framples ind chn) ind chn)))
			    (if (or (and (= pos 0) 
					 (not (mus-arrays-equal? data #r(0.0 0.0))))
				    (and (or (= pos current-edit-position) 
					     (= pos (edit-position ind chn)))
					 (not (mus-arrays-equal? data #r(0.0 0.1))))			  
				    (and (= pos (- (edit-position ind chn) 1))
					 (not (mus-arrays-equal? data #r(0.0 0.0)))))
				(snd-display "pos[~A]: edpos ~A of ~A, pad result[~A, ~A]: ~A" 
					     chn pos (edit-position ind chn) (framples ind chn pos) (framples ind chn) data))
			    (if (> (chans ind) 1)
				(do ((i 0 (+ i 1)))
				    ((= i (chans ind)))
				  (if (not (= i chn))
				      (let ((data (channel->float-vector 0 (framples ind i) ind i)))
					(if (not (mus-arrays-equal? data #r(0.0)))
					    (snd-display "pad[~A / ~A] empty: ~A" i chn data))))))))))
		    (lambda (posfunc)
		      (let ((chn (min (random (+ 1 out-chans)) (- out-chans 1))))
			(set! (sample 0 ind chn) .1)
			(set! (sample 0 ind chn (posfunc)) (* 2 (sample 0 ind chn (posfunc)))) ; not scale since it checks for zeros
			(let ((pos (posfunc)))
			  (if (procedure? pos) (set! pos (pos ind chn)))
			  (let ((data (channel->float-vector 0 (framples ind chn) ind chn)))
			    (if (or (and (= pos 0) 
					 (not (mus-arrays-equal? data #r(0.0))))
				    (and (or (= pos current-edit-position) 
					     (= pos (edit-position ind chn)))
					 (not (mus-arrays-equal? data #r(0.2))))			  
				    (and (= pos (- (edit-position ind chn) 1))
					 (not (mus-arrays-equal? data #r(0.0)))))
				(snd-display "pos[~A]: edpos ~A of ~A, set *2 result[~A, ~A]: ~A" 
					     chn pos (edit-position ind chn) (framples ind chn pos) (framples ind chn) data))
			    (if (> (chans ind) 1)
				(do ((i 0 (+ i 1)))
				    ((= i (chans ind)))
				  (if (not (= i chn))
				      (let ((data (channel->float-vector 0 (framples ind i) ind i)))
					(if (not (mus-arrays-equal? data #r(0.0)))
					    (snd-display "scale[~A / ~A] empty: ~A" i chn data)))))))))))))
		'("2a.snd" "1a.snd" "4a.snd"))
	       (close-sound ind)))
	   '(1 2 4))
	  
	  (let ((ind (open-sound "oboe.snd")))
	    (map-channel (lambda (y) #f))
	    (if (not (= (framples ind) 0)) (snd-display "map-channel #f framples: ~A" (framples ind)))
	    (if (equal? (edits ind) '(0 0)) (snd-display "map-channel #f edits backed up"))
	    (undo 1 ind)
	    (if (= (framples ind) 0) (snd-display "map-channel #f framples after undo: ~A" (framples ind)))
	    (let ((tag (catch #t (lambda () (map-channel (lambda (y) (copy "hiho")))) (lambda args (car args)))))
	      (if (not (memq tag '(bad-type wrong-type-arg))) (snd-display "map-channel bad-type: ~A" tag)))
#|
	    ;; TODO: this does not unwind the C stack past the scan-channel call?
	    (let* ((ctr 0)
		   (tag (catch #t (lambda () (scan-channel (lambda (y) (set! ctr (+ ctr 1)) (asdf)))) (lambda args (car args)))))
	      (if (not (= ctr 1)) (snd-display "scan-channel error exit: ~A" ctr))
	      (if (not (memq tag '(unbound-variable syntax-error error)))
		  (snd-display "scan-channel unbound: ~A" tag)))
|#
	    (let ((val (scan-channel (lambda (y) #f)))) (if val (snd-display "scan-channel func #f: ~A" val)))
	    (let ((val (scan-channel (lambda (y) #f) 1234))) (if val (snd-display "scan-channel func #f with beg: ~A" val)))
	    (let ((val (scan-channel (lambda (y) #f) 1234 4321))) (if val (snd-display "scan-channel func #f with beg+dur: ~A" val)))
	    (revert-sound ind)
	    (clm-channel (make-delay 1000) 0 (framples) ind 0 0 2000) ; chn=0, edpos=0, overlap=2000?
	    (let ((len (framples)))
	      (if (not (= len 52828))
		  (snd-display "clm-channel overlap length: ~A ~A" len (framples)))
	      (if (not (equal? (edit-tree) '((0 1 0 52827 1.0 0.0 0.0 0) (52828 -2 0 0 0.0 0.0 0.0 0))))
		  (snd-display "clm-channel overlaps: ~A" (edit-tree)))
	      (let ((reader (make-sampler 0))
		    (preader (make-sampler 0 ind 0 1 0))
		    (happy #t))
		(do ((i 0 (+ i 1)))
		    ((or (not happy) (= i 1000)))
		  (let ((val (reader)))
		    (when (fneq val 0.0)
		      (snd-display "clm-channel overlap delayed: ~A: ~A" i val)
		      (set! happy #f))))
		(let ((v0 (make-float-vector len))
		      (v1 (make-float-vector len)))
		  (do ((i 0 (+ i 1)))
		      ((= i len))
		    (set! (v0 i) (read-sample preader)))
		  (do ((i 0 (+ i 1)))
		      ((= i len))
		    (float-vector-set! v1 i (read-sample reader)))
		  (if (not (mus-arrays-equal? v0 v1))
		      (snd-display "clm-channel overlap main: ~A ~A" v0 v1)))
		(do ((i 0 (+ i 1)))
		    ((or (not happy) (= i 1000)))
		  (when (fneq (reader) 0.0)
		    (snd-display "clm-channel overlap trailing garbage")
		    (set! happy #f)))))
	    (close-sound ind))
	  
	  (let ((ind (open-sound "oboe.snd"))
		(oldamp 0.0)
		(oldloc 0)
		(ctr 0))
	    (scan-channel (lambda (y)
			    (when (>= (abs y) oldamp) 
			      (set! oldloc ctr)
			      (set! oldamp (abs y)))
			    (set! ctr (+ ctr 1))
			    #f))
	    (scale-by 10.0)
	    (scale-by 0.1)
	    (reverse-channel 0 #f ind 0 1)
	    (let ((amp 0.0)
		  (loc 0)
		  (ctr (- (framples) 1)))
	      (scan-channel (lambda (y)
			      (when (> (abs y) amp) 
				(set! amp (abs y))
				(set! loc ctr))
			      (set! ctr (- ctr 1))
			      #f))
	      ;; can't use maxamp here because it may be set by scaling process
	      (if (or (fneq oldamp (* .1 amp))
		      (not (= loc oldloc)))
		  (snd-display "reverse edpos screwup: ~A at ~A,  ~A at ~A" oldamp oldloc amp loc)))
	    (undo)
	    (reverse-channel 0 #f ind 0 2)
	    (let ((amp 0.0)
		  (loc 0)
		  (ctr (- (framples) 1)))
	      (scan-channel (lambda (y)
			      (when (> (abs y) amp) 
				(set! amp (abs y))
				(set! loc ctr))
			      (set! ctr (- ctr 1))
			      #f))
	      ;; can't use maxamp here because it may be set by scaling process
	      (if (or (fneq oldamp amp)
		      (not (= loc oldloc)))
		  (snd-display "reverse unscaled edpos screwup: ~A at ~A,  ~A at ~A" oldamp oldloc amp loc)))
	    
	    (close-sound ind))
	  
	  (if (mus-clipping) (set! (mus-clipping) #f))
	  (if *clipping* (set! *clipping* #f))
	  (let ((ind (new-sound "fmv.snd" 1 22050 mus-ldouble mus-next "edit trees"))
		(vals (make-float-vector 100)))
	    (select-sound ind)
	    (select-channel 0)
	    (check-edit-tree '((0 0 0 0 0.0 0.0 0.0 1) (1 -2 0 0 0.0 0.0 0.0 0)) (make-float-vector 1) "initial new-sound")
	    (fill! vals 1.0)
	    (set! (samples 0 100) vals)
	    (check-edit-tree '((0 1 0 99 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0)) vals "set first samps to one")
	    (scale-channel 0.5 10 20)
	    (do ((i 10 (+ i 1)))
		((= i 30))
	      (set! (vals i) 0.5))
	    (check-edit-tree '((0 1 0 9 1.0 0.0 0.0 0) (10 1 10 29 0.5 0.0 0.0 0) (30 1 30 99 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0)) 
			     vals "scale-channel 0.5 10 20")
	    (env-channel (make-env '(0 0 1 1) :length 11) 15 10)
	    (do ((e (make-env '(0 0 1 1) :length 11))
		 (i 15 (+ i 1)))
		((= i 25))
	      (set! (vals i) (* (vals i) (env e))))
	    (check-edit-tree '((0 1 0 9 1.0 0.0 0.0 0) (10 1 10 14 0.5 0.0 0.0 0) (15 1 15 24 0.5 0.0 0.1 1)
			       (25 1 25 29 0.5 0.0 0.0 0) (30 1 30 99 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0)) 
			     vals "env-channel 15 10")
	    (normalize-channel 1.0)
	    (check-edit-tree '((0 1 0 9 1.0 0.0 0.0 0) (10 1 10 14 0.5 0.0 0.0 0) (15 1 15 24 0.5 0.0 0.1 1)
			       (25 1 25 29 0.5 0.0 0.0 0) (30 1 30 99 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0)) 
			     vals "env-channel 15 10 a")
	    (select-all)
	    (if (fneq (selection-maxamp) 1.0)
		(snd-display "selection-maxamp in checker: ~A" (selection-maxamp)))
	    (scale-selection-to 1.0)
	    (check-edit-tree '((0 1 0 9 1.0 0.0 0.0 0) (10 1 10 14 0.5 0.0 0.0 0) (15 1 15 24 0.5 0.0 0.1 1)
			       (25 1 25 29 0.5 0.0 0.0 0) (30 1 30 99 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0)) 
			     vals "env-channel 15 10 b")
	    (set! (selection-position) 5)
	    (set! (selection-framples) 10)
	    (scale-selection-to .5)
	    (do ((i 5 (+ i 1)))
		((= i 15))
	      (set! (vals i) (* (vals i) 0.5)))
	    (check-edit-tree '((0 1 0 4 1.0 0.0 0.0 0) (5 1 5 9 0.5 0.0 0.0 0) (10 1 10 14 0.25 0.0 0.0 0) (15 1 15 24 0.5 0.0 0.1 1) 
			       (25 1 25 29 0.5 0.0 0.0 0) (30 1 30 99 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0))
			     vals "scale-selection-to .5")
	    (set! (sample 20) .1)
	    (set! (vals 20) .1)
	    (check-edit-tree '((0 1 0 4 1.0 0.0 0.0 0) (5 1 5 9 0.5 0.0 0.0 0) (10 1 10 14 0.25 0.0 0.0 0) 
			       (15 1 15 19 0.5 0.0 0.1 1) (20 2 0 0 1.0 0.0 0.0 0)
			       (21 1 21 24 0.5 0.6 0.1 4) (25 1 25 29 0.5 0.0 0.0 0) 
			       (30 1 30 99 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0))
			     vals "set 20 .1")
	    (reverse-channel 5 10)
	    (do ((i 5 (+ i 1))
		 (j 14 (- j 1)))
		((= i 10))
	      (let ((temp (vals i)))
		(set! (vals i) (vals j))
		(set! (vals j) temp)))
	    (check-edit-tree '((0 1 0 4 1.0 0.0 0.0 0) (5 3 0 9 1.0 0.0 0.0 0) 
			       (15 1 15 19 0.5 0.0 0.1 1) (20 2 0 0 1.0 0.0 0.0 0) 
			       (21 1 21 24 0.5 0.6 0.1 4) (25 1 25 29 0.5 0.0 0.0 0) 
			       (30 1 30 99 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0))
			     vals "reverse-channel 5 10")
	    (if (fneq (selection-maxamp) .5) (snd-display "selection-maxamp before: ~A" (selection-maxamp)))
	    (let ((mixvals (make-float-vector 10 .1))
		  (old-sample4 (sample 4))
		  (old-sample5 (sample 5)))
	      (do ((id (mix-float-vector mixvals 4))
		   (i 4 (+ i 1))
		   (j 0 (+ j 1)))
		  ((= i 14)
		   (check-edit-tree '((0 1 0 3 1.0 0.0 0.0 0) (4 1 4 4 1.0 0.0 0.0 1) (5 3 0 8 1.0 0.0 0.0 1) (14 3 9 9 1.0 0.0 0.0 0) 
				      (15 1 15 19 0.5 0.0 0.1 4) (20 2 0 0 1.0 0.0 0.0 0) 
				      (21 1 21 24 0.5 0.6 0.1 4) (25 1 25 29 0.5 0.0 0.0 0) 
				      (30 1 30 99 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0))
				    vals (format #f "mix-float-vector (id: ~A (~A) [~A ~A] + .1 -> [~A ~A] [~A ~A]) 4 (.1)" 
						 id ind
						 old-sample4 old-sample5
						 (sample 4) (sample 5) 
						 (vals 4) (vals 5))))
		(set! (vals i) (+ (vals i) (mixvals j)))))
	    (delete-samples 28 12)
	    (insert-silence 28 12)
	    (do ((i 28 (+ i 1)))
		((= i 40))
	      (set! (vals i) 0.0))
	    (let ((old-vals (copy vals)))
	      (check-edit-tree '((0 1 0 3 1.0 0.0 0.0 0) (4 1 4 4 1.0 0.0 0.0 1) (5 3 0 8 1.0 0.0 0.0 1)
				 (14 3 9 9 1.0 0.0 0.0 0) (15 1 15 19 0.5 0.0 0.1 4) 
				 (20 2 0 0 1.0 0.0 0.0 0) (21 1 21 24 0.5 0.6 0.1 4) 
				 (25 1 25 27 0.5 0.0 0.0 0) (28 -1 0 11 0.0 0.0 0.0 2) 
				 (40 1 40 99 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0))
			       vals "delete/insert")
	      (if (fneq (selection-maxamp) .6) (snd-display "selection-maxamp after: ~A" (selection-maxamp)))
	      (set! (selection-position) 50)
	      (set! (selection-framples) 10)
	      (scale-selection-by .1)
	      (if (fneq (selection-maxamp) .1) (snd-display "re-selection-maxamp: ~A" (selection-maxamp)))
	      (do ((i 50 (+ i 1)))
		  ((= i 60))
		(set! (vals i) .1))
	      (check-edit-tree '((0 1 0 3 1.0 0.0 0.0 0) (4 1 4 4 1.0 0.0 0.0 1) (5 3 0 8 1.0 0.0 0.0 1) (14 3 9 9 1.0 0.0 0.0 0) 
				 (15 1 15 19 0.5 0.0 0.1 4) (20 2 0 0 1.0 0.0 0.0 0) 
				 (21 1 21 24 0.5 0.6 0.1 4) (25 1 25 27 0.5 0.0 0.0 0) (28 -1 0 11 0.0 0.0 0.0 2) 
				 (40 1 40 49 1.0 0.0 0.0 0) (50 1 50 59 0.100000001490116 0.0 0.0 0) (60 1 60 99 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0))
			       vals "scale-selection-by .1")
	      (env-channel (make-env '(0 0 1 1 2 0 3 0) :length 31 :base 0) 50 30)
	      (do ((e (make-env '(0 0 1 1 2 0 3 0) :length 31 :base 0))
		   (i 50 (+ i 1)))
		  ((= i 80))
		(set! (vals i) (* (vals i) (env e))))
	      (check-edit-tree '((0 1 0 3 1.0 0.0 0.0 0) (4 1 4 4 1.0 0.0 0.0 1) (5 3 0 8 1.0 0.0 0.0 1) (14 3 9 9 1.0 0.0 0.0 0) 
				 (15 1 15 19 0.5 0.0 0.1 4) (20 2 0 0 1.0 0.0 0.0 0) 
				 (21 1 21 24 0.5 0.6 0.1 4) (25 1 25 27 0.5 0.0 0.0 0) (28 -1 0 11 0.0 0.0 0.0 2)
				 (40 1 40 49 1.0 0.0 0.0 0) (50 1 50 59 0.0 0.0 0.0 2) (60 1 60 60 0.0 0.0 0.0 2) 
				 (61 1 61 70 1.0 0.0 0.0 0) (71 1 71 79 0.0 0.0 0.0 2) (80 1 80 99 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0))
			       vals "step env 30")
	      (undo-channel 2)
	      (check-edit-tree '((0 1 0 3 1.0 0.0 0.0 0) (4 1 4 4 1.0 0.0 0.0 1) (5 3 0 8 1.0 0.0 0.0 1) 
				 (14 3 9 9 1.0 0.0 0.0 0) (15 1 15 19 0.5 0.0 0.1 4) 
				 (20 2 0 0 1.0 0.0 0.0 0) (21 1 21 24 0.5 0.6 0.1 4) (25 1 25 27 0.5 0.0 0.0 0) 
				 (28 -1 0 11 0.0 0.0 0.0 2) (40 1 40 99 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0))
			       old-vals "undo to delete/insert (over step env)"))
	    (redo-channel 2)
	    (check-edit-tree '((0 1 0 3 1.0 0.0 0.0 0) (4 1 4 4 1.0 0.0 0.0 1) (5 3 0 8 1.0 0.0 0.0 1) (14 3 9 9 1.0 0.0 0.0 0) 
			       (15 1 15 19 0.5 0.0 0.1 4) (20 2 0 0 1.0 0.0 0.0 0) 
			       (21 1 21 24 0.5 0.6 0.1 4) (25 1 25 27 0.5 0.0 0.0 0) (28 -1 0 11 0.0 0.0 0.0 2)
			       (40 1 40 49 1.0 0.0 0.0 0) (50 1 50 59 0.0 0.0 0.0 2) (60 1 60 60 0.0 0.0 0.0 2)
			       (61 1 61 70 1.0 0.0 0.0 0) (71 1 71 79 0.0 0.0 0.0 2) (80 1 80 99 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0))
			     vals "redo past step env 30")
	    (set! (sample 75) -.5)
	    (set! (vals 75) -.5)
	    (let ((flt (make-one-zero 0.5 0.5))
		  (flt1 (make-one-zero 0.5 0.5)))
	      (clm-channel flt 75 10)
	      (do ((i 75 (+ i 1)))
		  ((= i 85))
		(set! (vals i) (one-zero flt1 (vals i))))
	      (check-edit-tree '((0 1 0 3 1.0 0.0 0.0 0) (4 1 4 4 1.0 0.0 0.0 1) (5 3 0 8 1.0 0.0 0.0 1) (14 3 9 9 1.0 0.0 0.0 0) 
				 (15 1 15 19 0.5 0.0 0.1 4) (20 2 0 0 1.0 0.0 0.0 0) 
				 (21 1 21 24 0.5 0.6 0.1 4) (25 1 25 27 0.5 0.0 0.0 0) (28 -1 0 11 0.0 0.0 0.0 2) 
				 (40 1 40 49 1.0 0.0 0.0 0) (50 1 50 59 0.0 0.0 0.0 2) (60 1 60 60 0.0 0.0 0.0 2) 
				 (61 1 61 70 1.0 0.0 0.0 0) (71 1 71 74 0.0 0.0 0.0 2) (75 6 0 9 1.0 0.0 0.0 0) (85 1 85 99 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0))
			       vals "clm-channel 75 10"))
	    (map-channel (lambda (y) (* y 1 .5)) 3 11) ; extra "1" is needed for the tree expectation
	    (do ((i 3 (+ i 1)))
		((= i 14))
	      (set! (vals i) (* .5 (vals i))))
	    (check-edit-tree '((0 1 0 2 1.0 0.0 0.0 0) (3 8 0 10 1.0 0.0 0.0 0) (14 7 10 11 1.0 0.0 0.0 0) 
			       (16 1 16 19 0.5 0.1 0.1 4) (20 2 0 0 1.0 0.0 0.0 0) 
			       (21 1 21 24 0.5 0.6 0.1 4) (25 1 25 27 0.5 0.0 0.0 0) (28 -1 0 11 0.0 0.0 0.0 2) 
			       (40 1 40 49 1.0 0.0 0.0 0) (50 1 50 59 0.0 0.0 0.0 2) (60 1 60 60 0.0 0.0 0.0 2) 
			       (61 1 61 70 1.0 0.0 0.0 0) (71 1 71 74 0.0 0.0 0.0 2) (75 6 0 9 1.0 0.0 0.0 0) 
			       (85 1 85 99 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0))
			     vals "map-channel 3 14")
	    (map-channel (let ((reader (make-sampler 50)))
			   (lambda (y)
			     (- y (next-sample reader))))
			 0 25)
	    (do ((i 0 (+ i 1))
		 (j 50 (+ j 1)))
		((= i 25))
	      (set! (vals i) (- (vals i) (vals j))))
	    (check-edit-tree '((0 9 0 24 1.0 0.0 0.0 0) (25 1 25 27 0.5 0.0 0.0 0) (28 -1 0 11 0.0 0.0 0.0 2)
			       (40 1 40 49 1.0 0.0 0.0 0) (50 1 50 59 0.0 0.0 0.0 2) (60 1 60 60 0.0 0.0 0.0 2)
			       (61 1 61 70 1.0 0.0 0.0 0) (71 1 71 74 0.0 0.0 0.0 2) (75 6 0 9 1.0 0.0 0.0 0)
			       (85 1 85 99 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0))
			     vals "back set via map-channel")
	    (set! (selection-position) 20)
	    (set! (selection-framples) 70)
	    (env-selection '(0 0 1 1))
	    (if (fneq (selection-maxamp ind 0) 1.0) (snd-display "selection-maxamp after env-selection: ~A" (selection-maxamp ind 0)))
	    (do ((i 20 (+ i 1))
		 (x 0.0)
		 (incr (/ 1.0 69.0)))
		((= i 90))
	      (set! (vals i) (* (vals i) x))
	      (set! x (+ x incr)))
	    (check-edit-tree '((0 9 0 19 1.0 0.0 0.0 0) (20 9 20 24 1.0 0.0 0.014492753893137 4) 
			       (25 1 25 27 0.5 0.0724637657403946 0.014492753893137 4) (28 -1 0 11 0.0 0.0 0.0 2) 
			       (40 1 40 49 1.0 0.289855062961578 0.014492753893137 4) (50 1 50 59 0.0 0.0 0.0 2) 
			       (60 1 60 60 0.0 0.0 0.0 2) (61 1 61 70 1.0 0.594202876091003 0.014492753893137 4)
			       (71 1 71 74 0.0 0.0 0.0 2) (75 6 0 9 1.0 0.797101438045502 0.014492753893137 4) 
			       (85 1 85 89 1.0 0.942028999328613 0.014492753893137 4) (90 1 90 99 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0))
			     vals "env-selection")
	    (normalize-channel .5)
	    (float-vector-scale! vals .5)
	    (check-edit-tree '((0 9 0 19 0.5 0.0 0.0 0) (20 9 20 24 0.5 0.0 0.014492753893137 4) 
			       (25 1 25 27 0.25 0.0724637657403946 0.014492753893137 4) (28 -1 0 11 0.0 0.0 0.0 2) 
			       (40 1 40 49 0.5 0.289855062961578 0.014492753893137 4) (50 1 50 59 0.0 0.0 0.0 2) 
			       (60 1 60 60 0.0 0.0 0.0 2) (61 1 61 70 0.5 0.594202876091003 0.014492753893137 4) 
			       (71 1 71 74 0.0 0.0 0.0 2) (75 6 0 9 0.5 0.797101438045502 0.014492753893137 4) 
			       (85 1 85 89 0.5 0.942028999328613 0.014492753893137 4) (90 1 90 99 0.5 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0))
			     vals "scale-to")
	    (if (fneq (selection-maxamp) .5) (snd-display "selection-maxamp after scale: ~A" (selection-maxamp)))
	    (delete-samples 0 100)
	    (insert-silence 0 100)
	    (fill! vals 0.0)
	    (check-edit-tree '((0 -1 0 99 0.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0))
			     vals "second set...")
	    
	    (set! (sample 50) .5)
	    (set! (vals 50) .5)
	    (check-edit-tree '((0 -1 0 49 0.0 0.0 0.0 2) (50 10 0 0 1.0 0.0 0.0 0) (51 -1 51 99 0.0 0.0 0.0 2) (100 -2 0 0 0.0 0.0 0.0 0))
			     vals "split silence")
	    (map-channel (lambda (y) 1.0) 0 25)
	    (fill! vals 1.0 0 25)
	    (check-edit-tree '((0 11 0 24 1.0 0.0 0.0 0) (25 -1 25 49 0.0 0.0 0.0 2) (50 10 0 0 1.0 0.0 0.0 0) (51 -1 51 99 0.0 0.0 0.0 2) (100 -2 0 0 0.0 0.0 0.0 0))
			     vals "clobber silence start")
	    (map-channel (lambda (y) 1.0) 75 25)
	    (fill! vals 1.0 75 100)
	    (check-edit-tree '((0 11 0 24 1.0 0.0 0.0 0) (25 -1 25 49 0.0 0.0 0.0 2) (50 10 0 0 1.0 0.0 0.0 0) 
			       (51 -1 51 74 0.0 0.0 0.0 2) (75 12 0 24 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0))
			     vals "clobber silence end")
	    (scale-channel 0.0 0 100)
	    (fill! vals 0.0)
	    (check-edit-tree '((0 0 0 99 0.0 0.0 0.0 1) (100 -2 0 0 0.0 0.0 0.0 0))
			     vals "scale all to 0.0")
	    (let ((e (make-env '(0 0 1 1) :length 101))
		  (e1 (make-env '(0 0 1 1) :length 101)))
	      (map-channel (lambda (y) (env e)))
	      (do ((i 0 (+ i 1)))
		  ((= i 100))
		(set! (vals i) (env e1))))
	    (check-edit-tree '((0 13 0 99 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0))
			     vals "env start")
	    (set! (sample 50) -.5)
	    (set! (vals 50) -.5)
	    (check-edit-tree '((0 13 0 49 1.0 0.0 0.0 0) (50 14 0 0 1.0 0.0 0.0 0) (51 13 51 99 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0))
			     vals "split env segment")
	    (map-channel (lambda (y) 1.0) 0 25)
	    (fill! vals 1.0 0 25)
	    (check-edit-tree '((0 15 0 24 1.0 0.0 0.0 0) (25 13 25 49 1.0 0.0 0.0 0) (50 14 0 0 1.0 0.0 0.0 0) (51 13 51 99 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0))
			     vals "clobber env start")
	    (map-channel (lambda (y) 1.0) 75 25)
	    (fill! vals 1.0 75 100)
	    (check-edit-tree '((0 15 0 24 1.0 0.0 0.0 0) (25 13 25 49 1.0 0.0 0.0 0) (50 14 0 0 1.0 0.0 0.0 0) 
			       (51 13 51 74 1.0 0.0 0.0 0) (75 16 0 24 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0))
			     vals "clobber env end")
	    
	    (env-channel (make-env '(0 1 1 0 2 1) :length 20) 50 20)
	    (do ((e (make-env '(0 1 1 0 2 1) :length 20))
		 (i 50 (+ i 1)))
		((= i 70))
	      (set! (vals i) (* (env e) (vals i))))
	    (check-edit-tree '((0 15 0 24 1.0 0.0 0.0 0) (25 13 25 49 1.0 0.0 0.0 0) (50 14 0 0 1.0 1.0 -0.100000001490116 4) 
			       (51 13 51 59 1.0 0.899999976158142 -0.100000001490116 4) (60 13 60 69 1.0 0.0 0.111111111938953 4) 
			       (70 13 70 74 1.0 0.0 0.0 0) (75 16 0 24 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0))
			     vals "env on env")
	    (env-channel (make-env '(0 1 1 0 2 1) :length 80) 10 80)
	    (do ((e (make-env '(0 1 1 0 2 1) :length 80))
		 (i 10 (+ i 1)))
		((= i 90))
	      (set! (vals i) (* (env e) (vals i))))
	    (check-edit-tree '((0 15 0 9 1.0 0.0 0.0 0) (10 15 10 24 1.0 1.0 -0.025000000372529 4) (25 13 25 49 1.0 0.625 -0.025000000372529 4) 
			       (50 14 0 0 1.0 1.0 -0.100000001490116 6) (51 13 51 59 1.0 0.899999976158142 -0.100000001490116 6) 
			       (60 13 60 69 1.0 0.0 0.111111111938953 6) (70 13 70 74 1.0 0.512820541858673 0.0256410259753466 4) 
			       (75 16 0 14 1.0 0.64102566242218 0.0256410259753466 4) (90 16 15 24 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0))
			     vals "env on env 2")
	    (env-channel (make-env '(0 1 1 0 2 1) :length 20) 50 20)
	    (do ((e (make-env '(0 1 1 0 2 1) :length 20))
		 (i 50 (+ i 1)))
		((= i 70))
	      (set! (vals i) (* (env e) (vals i))))
	    (check-edit-tree '((0 15 0 9 1.0 0.0 0.0 0) (10 15 10 24 1.0 1.0 -0.025000000372529 4) (25 13 25 49 1.0 0.625 -0.025000000372529 4) 
			       (50 14 0 0 1.0 1.0 -0.100000001490116 10) (51 13 51 59 1.0 0.899999976158142 -0.100000001490116 10) 
			       (60 13 60 69 1.0 0.0 0.111111111938953 10) (70 13 70 74 1.0 0.512820541858673 0.0256410259753466 4)
			       (75 16 0 14 1.0 0.64102566242218 0.0256410259753466 4) (90 16 15 24 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0))
			     vals "env on env 3")
	    (delete-samples 10 20)
	    (insert-silence 10 20)
	    (fill! vals 0.0 10 30)
	    (check-edit-tree '((0 15 0 9 1.0 0.0 0.0 0) (10 -1 0 19 0.0 0.0 0.0 2) (30 13 30 49 1.0 0.5 -0.025000000372529 4) 
			       (50 14 0 0 1.0 1.0 -0.100000001490116 10) (51 13 51 59 1.0 0.899999976158142 -0.100000001490116 10) 
			       (60 13 60 69 1.0 0.0 0.111111111938953 10) (70 13 70 74 1.0 0.512820541858673 0.0256410259753466 4) 
			       (75 16 0 14 1.0 0.64102566242218 0.0256410259753466 4) (90 16 15 24 1.0 0.0 0.0 0) (100 -2 0 0 0.0 0.0 0.0 0))
			     vals "env preclobbered")
	    (close-sound ind))
	  
	  (for-each
	   (lambda (dur)
	     (let ((i1 (new-sound))
		   (check-env (lambda (name r e)
				(let ((v0 (make-float-vector dur))
				      (v1 (make-float-vector dur)))
				  (do ((i 0 (+ i 1)))
				      ((= i dur))
				    (set! (v0 i) (read-sample r)))
				  (if (env? e)
				      (do ((i 0 (+ i 1)))
					  ((= i dur))
					(float-vector-set! v1 i (env e)))
				      (if (sampler? e)
					  (do ((i 0 (+ i 1)))
					      ((= i dur))
					    (float-vector-set! v1 i (read-sample e)))
					  (do ((i 0 (+ i 1)))
					      ((= i dur))
					    (float-vector-set! v1 i (e)))))
				  (if (not (mus-arrays-equal? v0 v1))
				      (snd-display "~A env check [~A]" name r))))))
	       
	       (float-vector->channel (make-float-vector dur 1.0))
	       (env-sound '(0 0 1 1))
	       (check-env 'ramp (make-sampler 0) (make-env '(0 0 1 1) :length dur))
	       (reverse-channel)
	       (check-env 'rev-ramp (make-sampler 0) (make-env '(0 1 1 0) :length dur))
	       (undo 2)
	       (env-sound '(0 0 1 1 2 0))
	       (check-env 'ramp (make-sampler 0) (make-env '(0 0 1 1 2 0) :length dur))
	       (let ((cur-read (make-sampler 0)))
		 (reverse-channel)
		 (check-env 'rev-pyr cur-read (make-sampler (- dur 1) i1 0 -1)))
	       (undo 2)
	       (env-sound '(0 0 1 1 2 0 3 1))
	       (check-env '3-ramp (make-sampler 0) (make-env '(0 0 1 1 2 0 3 1) :length dur))
	       (let ((cur-read (make-sampler 0)))
		 (reverse-channel)
		 (check-env 'rev-pyr cur-read (make-sampler (- dur 1) i1 0 -1)))
	       (undo 2)
	       (env-sound '(0 0 1 1 2 1 3 0))
	       (check-env 'sqoff (make-sampler 0) (make-env '(0 0 1 1 2 1 3 0) :length dur))
	       (undo 1)
	       (env-sound '(0 0 1 .5 2 .5 3 0))
	       (check-env '5sqoff (make-sampler 0) (make-env '(0 0 1 .5 2 .5 3 0) :length dur))
	       (undo 1)
	       (scale-channel .5)
	       (env-sound '(0 0 1 1))
	       (check-env 'scl-ramp (make-sampler 0) (make-env '(0 0 1 1) :length dur :scaler .5))
	       (reverse-channel)
	       (check-env 'scl-rev-ramp (make-sampler 0) (make-env '(0 1 1 0) :length dur :scaler .5))
	       (undo 2)
	       (env-sound '(0 0 1 1 2 0))
	       (check-env 'scl-3-ramp (make-sampler 0) (make-env '(0 0 1 1 2 0) :length dur :scaler .5))
	       (let ((cur-read (make-sampler 0)))
		 (reverse-channel)
		 (check-env 'scl-rev-pyr cur-read (make-sampler (- dur 1) i1 0 -1)))
	       (undo 3)
	       (when (= dur 10000)
		 (for-each 
		  (lambda (beg local-dur)
		    (let ((bend (+ beg local-dur 1)))
		      (env-sound '(0 0 1 1 2 0))
		      (scale-channel .5 beg local-dur)
		      (check-env 'env+scl 
				 (make-sampler 0)
				 (let ((e (make-env '(0 0 1 1 2 0) :length dur))
				       (ctr 0))
				   (lambda ()
				     (let ((val (env e)))
				       (set! ctr (+ ctr 1))
				       (if (< beg ctr bend)
					   (* val .5)
					   val)))))
		      (undo 2)))
		  '(0    0    1000 1000 4000 5000 6000 5000)
		  '(1000 6000 1000 4000 2000 1000 1000 5000))
		 (for-each 
		  (lambda (env-beg env-dur scl-beg scl-dur)
		    (let ((eend (+ env-beg env-dur 1))
			  (send (+ scl-beg scl-dur 1)))
		      (env-channel '(0 0 1 1 2 1 3 0) env-beg env-dur)
		      (scale-channel .5 scl-beg scl-dur)
		      (check-env 'env+scl-partial
				 (make-sampler 0)
				 (let ((e (make-env '(0 0 1 1 2 1 3 0) :length env-dur))
				       (ctr 0))
				   (lambda ()
				     (let ((val 1.0))
				       (set! ctr (+ ctr 1))
				       (if (< env-beg ctr eend)
					   (set! val (env e)))
				       (if (< scl-beg ctr send)
					   (set! val (* val 0.5)))
				       val))))
		      (undo 2)))
		  '(0    0     1000 1000 4000 5000 6000 5000)
		  '(1000 6000  1000 4000 2000 1000 1000 5000)
		  '(500  0     0    2000 5000 4000 0    8000)
		  '(200  10000 1500 1000 500  2000 2000 2000)))
	       (env-sound '(0 0 1 1))
	       (env-sound '(0 0 1 1))
	       (check-env 'unenv-ramp 
			  (make-sampler 0) 
			  (let ((e (make-env '(0 0 1 1) :length dur)))
			    (lambda ()
			      (let ((val (env e)))
				(* val val)))))
	       (undo 2)
	       (env-sound '(0 0 1 1))
	       (let ((v1 (make-float-vector 3 1.0)))
		 (float-vector->channel v1 3 3)
		 (let ((vals (channel->float-vector 0 10)))
		   (if (not (mus-arrays-equal? vals (float-vector 0.0 (/ 1.111 dur) (/ 2.222 dur) 1 1 1 (/ 6.66  dur) (/ 7.77  dur) (/ 8.88  dur) (/ 10.0 dur))))
		       (snd-display " 1 vals: ~A" vals))))
	       (undo 2)
	       (env-sound '(0 0 1 1))
	       (let ((v1 (make-float-vector 3 1.0)))
		 (delete-samples 3 3)
		 (insert-samples 3 3 v1)
		 (let ((vals (channel->float-vector 0 10)))
		   (if (not (mus-arrays-equal? vals (float-vector 0.0 (/ 1.111 dur) (/ 2.222 dur) 1 1 1 (/ 6.66  dur) (/ 7.77  dur) (/ 8.88  dur) (/ 10.0 dur))))
		       (snd-display " 2 vals: ~A" vals))))
	       (undo 3)
	       (env-sound '(0 0 1 1))
	       (let ((v1 (make-float-vector 3 1.0)))
		 (insert-samples 3 3 v1)
		 (delete-samples 3 3))
	       (check-env '5-ramp (make-sampler 0) (make-env '(0 0 1 1) :length dur))
	       (undo 3)
	       (env-sound '(0 0 1 1 2 0))
	       (let ((v1 (make-float-vector 3 1.0)))
		 (if (= dur 10)
		     (begin
		       (float-vector->channel v1 3 3)
		       (let ((vals (channel->float-vector 0 10)))
			 (if (not (mus-arrays-equal? vals #r(0.0 .2 .4 1 1 1 .75 .5 .25 0)))
			     (snd-display " 4 vals (~A): ~A" dur vals))))
		     (begin
		       (fill! v1 0.0)
		       (float-vector->channel v1 4998 3)
		       (let ((vals (channel->float-vector 4995 10)))
			 (if (not (mus-arrays-equal? vals #r(0.999 0.999 1.000 0.0 0.0 0.0 1.000 0.999 0.999 0.999)))
			     (snd-display " 4 vals big: ~A" vals))))))
	       (undo 2)
	       (when (= dur 10)
		 (env-sound '(0 0 1 1 2 0))
		 (let ((v1 (make-float-vector 3 1.0)))
		   (delete-samples 3 3)
		   (insert-samples 3 3 v1)
		   (let ((vals (channel->float-vector 0 10)))
		     (if (not (mus-arrays-equal? vals #r(0.0 .2 .4 1 1 1 .75 .5 .25 0)))
			 (snd-display " 2 vals: ~A" vals))))
		 (undo 3)
		 (env-sound '(0 0 1 1 2 0))
		 (let ((v1 (make-float-vector 3 1.0)))
		   (float-vector->channel v1 0 3)
		   (let ((vals (channel->float-vector 0 10)))
		     (if (not (mus-arrays-equal? vals #r(1.000 1.000 1.000 0.600 0.800 1.000 0.750 0.500 0.250 0.000)))
			 (snd-display " 4 vals: ~A" vals))))
		 (undo 2)
		 (env-sound '(0 0 1 1 2 0))
		 (let ((v1 (make-float-vector 3 1.0)))
		   (float-vector->channel v1 7 3)
		   (let ((vals (channel->float-vector 0 10)))
		     (if (not (mus-arrays-equal? vals #r(0.0 0.200 0.400 0.600 0.800 1.000 0.750 1.000 1.000 1.000)))
			 (snd-display " 5 vals: ~A" vals))))
		 (undo 2))
	       (clean-up-sound i1)))
	   '(10 10000))
	  
	  (let ((ind (new-sound "fmv.snd" 1 22050 mus-ldouble mus-next "envd edit trees")))
	    (let ((vals (make-float-vector 10000)))
	      (select-sound ind)
	      (select-channel 0)
	      (check-edit-tree '((0 0 0 0 0.0 0.0 0.0 1) (1 -2 0 0 0.0 0.0 0.0 0)) (make-float-vector 1) "initial new-sound")
	      (fill! vals 1.0)
	      (set! (samples 0 10000) vals)
	      (check-edit-tree '((0 1 0 9999 1.0 0.0 0.0 0) (10000 -2 0 0 0.0 0.0 0.0 0)) vals "envd set first samps to one")
	      (env-sound '(0 0 1 1))
	      (let ((e (make-env '(0 0 1 1) :length 10000)))
		(fill-float-vector vals (env e)))
	      (check-edit-tree '((0 1 0 9999 1.0 0.0 1.00010001915507e-4 4) (10000 -2 0 0 0.0 0.0 0.0 0))
			       vals "env frag '(0 0 1 1)")
	      (delete-samples 1000 1000)
	      (let ((v1 (make-float-vector 9000)))
		(do ((i 0 (+ i 1)))
		    ((= i 1000))
		  (set! (v1 i) (vals i)))
		(do ((i 1000 (+ i 1))
		     (j 2000 (+ j 1)))
		    ((= i 9000))
		  (set! (v1 i) (vals j)))
		(check-edit-tree '((0 1 0 999 1.0 0.0 1.00010001915507e-4 4) (1000 1 2000 9999 1.0 0.200020000338554 1.00010001915507e-4 4) (9000 -2 0 0 0.0 0.0 0.0 0))
				 v1 "env frag del"))
	      (undo 1)
	      (delete-samples 9000 1000)
	      (insert-samples 3000 1000 (make-float-vector 1000))
	      (do ((i 9999 (- i 1)))
		  ((< i 4000))
		(set! (vals i) (vals (- i 1000))))
	      (fill! vals 0.0 3000 4000)
	      (check-edit-tree '((0 1 0 2999 1.0 0.0 1.00010001915507e-4 4) (3000 2 0 999 1.0 0.0 0.0 0) 
				 (4000 1 3000 8999 1.0 0.300029993057251 1.00010001915507e-4 4) (10000 -2 0 0 0.0 0.0 0.0 0))
			       vals "envd ins/del")
	      (delete-samples 0 1000)
	      (insert-samples 0 1000 (make-float-vector 1000))
	      (fill! vals 0.0 0 1000)
	      (check-edit-tree '((0 3 0 999 1.0 0.0 0.0 0) (1000 1 1000 2999 1.0 0.100010000169277 1.00010001915507e-4 4) 
				 (3000 2 0 999 1.0 0.0 0.0 0) (4000 1 3000 8999 1.0 0.300029993057251 1.00010001915507e-4 4) (10000 -2 0 0 0.0 0.0 0.0 0))
			       vals "envd predel")
	      (scale-by 0.5)
	      (float-vector-scale! vals 0.5)
	      (check-edit-tree '((0 3 0 999 0.5 0.0 0.0 0) (1000 1 1000 2999 0.5 0.100010000169277 1.00010001915507e-4 4) 
				 (3000 2 0 999 0.5 0.0 0.0 0) (4000 1 3000 8999 0.5 0.300029993057251 1.00010001915507e-4 4) (10000 -2 0 0 0.0 0.0 0.0 0))
			       vals "envd scl")
	      (reverse-channel)
	      (do ((i 0 (+ i 1))
		   (j 9999 (- j 1)))
		  ((= i 5000))
		(let ((temp (vals i)))
		  (set! (vals i) (vals j))
		  (set! (vals j) temp)))
	      (check-edit-tree '((0 4 0 9999 1.0 0.0 0.0 0) (10000 -2 0 0 0.0 0.0 0.0 0))
			       vals "envd rev")
	      
	      (revert-sound ind))
	    (let ((vals (make-float-vector 100000 1.0)))
	      (float-vector->channel vals 0 100000)
	      (env-channel (make-env '(0 0 1 1 2 0) :length 10000) 30000 10000)
	      (do ((e (make-env '(0 0 1 1 2 0) :length 10000))
		   (i 30000 (+ i 1)))
		  ((= i 40000))
		(float-vector-set! vals i (env e)))
	      (check-edit-tree '((0 1 0 29999 1.0 0.0 0.0 0) (30000 1 30000 34999 1.0 0.0 1.99999994947575e-4 4)
				 (35000 1 35000 39999 1.0 1.0 -2.00040012714453e-4 4) (40000 1 40000 99999 1.0 0.0 0.0 0) (100000 -2 0 0 0.0 0.0 0.0 0))
			       vals "partial env")
	      (scale-channel .5 10000 10000)
	      (env-channel (make-env '(0 0 1 1 2 0) :length 10000) 30000 10000) ; env over env
	      (do ((e (make-env '(0 0 1 1 2 0) :length 10000))
		   (i 30000 (+ i 1)))
		  ((= i 40000))
		(float-vector-set! vals i (* (float-vector-ref vals i) (env e))))
	      (do ((i 10000 (+ i 1)))
		  ((= i 20000))
		(float-vector-set! vals i (* (float-vector-ref vals i) 0.5)))
	      (check-edit-tree '((0 1 0 9999 1.0 0.0 0.0 0) (10000 1 10000 19999 0.5 0.0 0.0 0) 
				 (20000 1 20000 29999 1.0 0.0 0.0 0) (30000 1 30000 34999 1.0 0.0 1.99999994947575e-4 6) 
				 (35000 1 35000 39999 1.0 1.0 -2.00040012714453e-4 6) (40000 1 40000 99999 1.0 0.0 0.0 0) (100000 -2 0 0 0.0 0.0 0.0 0))
			       vals "env over env")
	      (env-channel (make-env '(0 0 1 1 2 0) :length 10000) 5000 10000) ; env over scl
	      (do ((e (make-env '(0 0 1 1 2 0) :length 10000))
		   (i 5000 (+ i 1)))
		  ((= i 15000))
		(float-vector-set! vals i (* (float-vector-ref vals i) (env e))))
	      (check-edit-tree '((0 1 0 4999 1.0 0.0 0.0 0) (5000 1 5000 9999 1.0 0.0 1.99999994947575e-4 4) 
				 (10000 1 10000 14999 0.5 1.0 -2.00040012714453e-4 4) (15000 1 15000 19999 0.5 0.0 0.0 0)
				 (20000 1 20000 29999 1.0 0.0 0.0 0) (30000 1 30000 34999 1.0 0.0 1.99999994947575e-4 6)
				 (35000 1 35000 39999 1.0 1.0 -2.00040012714453e-4 6) (40000 1 40000 99999 1.0 0.0 0.0 0) (100000 -2 0 0 0.0 0.0 0.0 0))
			       vals "env over scl")
	      (ramp-channel .5 -.5 25000 1000)
	      (do ((e (make-env '(0 .5 1 -.5) :length 1000))
		   (i 25000 (+ i 1)))
		  ((= i 26000))
		(float-vector-set! vals i (* (float-vector-ref vals i) (env e))))
	      (check-edit-tree '((0 1 0 4999 1.0 0.0 0.0 0) (5000 1 5000 9999 1.0 0.0 1.99999994947575e-4 4)
				 (10000 1 10000 14999 0.5 1.0 -2.00040012714453e-4 4) (15000 1 15000 19999 0.5 0.0 0.0 0)
				 (20000 1 20000 24999 1.0 0.0 0.0 0) (25000 1 25000 25999 1.0 0.5 -0.00100100098643452 4)
				 (26000 1 26000 29999 1.0 0.0 0.0 0) (30000 1 30000 34999 1.0 0.0 1.99999994947575e-4 6) 
				 (35000 1 35000 39999 1.0 1.0 -2.00040012714453e-4 6) (40000 1 40000 99999 1.0 0.0 0.0 0) (100000 -2 0 0 0.0 0.0 0.0 0))
			       vals "ramp")
	      (scale-by -1.0)
	      (float-vector-scale! vals -1.0)
	      (check-edit-tree '((0 1 0 4999 -1.0 0.0 0.0 0) (5000 1 5000 9999 -1.0 0.0 1.99999994947575e-4 4)
				 (10000 1 10000 14999 -0.5 1.0 -2.00040012714453e-4 4) (15000 1 15000 19999 -0.5 0.0 0.0 0)
				 (20000 1 20000 24999 -1.0 0.0 0.0 0) (25000 1 25000 25999 -1.0 0.5 -0.00100100098643452 4)
				 (26000 1 26000 29999 -1.0 0.0 0.0 0) (30000 1 30000 34999 -1.0 0.0 1.99999994947575e-4 6)
				 (35000 1 35000 39999 -1.0 1.0 -2.00040012714453e-4 6) (40000 1 40000 99999 -1.0 0.0 0.0 0) (100000 -2 0 0 0.0 0.0 0.0 0))
			       vals "invert")
	      (let ((reader (make-sampler 0 ind 0 1 (- (edit-position) 1))))
		(map-channel (lambda (y)
			       (+ (next-sample reader) y)))
		(check-edit-tree '((0 2 0 99999 1.0 0.0 0.0 0) (100000 -2 0 0 0.0 0.0 0.0 0))
				 (make-float-vector 100000) "invert and add")
		(if (fneq (maxamp) 0.0) (snd-display "invert-and-add maxamp: ~A" (maxamp))))
	      
	      (undo 1)
	      (ramp-channel -1.0 1.0 50000 30000)
	      (do ((e (make-env '(0 -1.0 1 1.0) :length 30000))
		   (i 50000 (+ i 1)))
		  ((= i 80000))
		(float-vector-set! vals i (* (float-vector-ref vals i) (env e))))
	      (check-edit-tree '((0 1 0 4999 -1.0 0.0 0.0 0) (5000 1 5000 9999 -1.0 0.0 1.99999994947575e-4 4)
				 (10000 1 10000 14999 -0.5 1.0 -2.00040012714453e-4 4) (15000 1 15000 19999 -0.5 0.0 0.0 0)
				 (20000 1 20000 24999 -1.0 0.0 0.0 0) (25000 1 25000 25999 -1.0 0.5 -0.00100100098643452 4)
				 (26000 1 26000 29999 -1.0 0.0 0.0 0) (30000 1 30000 34999 -1.0 0.0 1.99999994947575e-4 6)
				 (35000 1 35000 39999 -1.0 1.0 -2.00040012714453e-4 6) (40000 1 40000 49999 -1.0 0.0 0.0 0)
				 (50000 1 50000 79999 -1.0 -1.0 6.66688865749165e-5 4) (80000 1 80000 99999 -1.0 0.0 0.0 0) (100000 -2 0 0 0.0 0.0 0.0 0))
			       vals "ramp")
	      (env-sound '(0 0 1 1))
	      (reverse-channel)
	      (delete-samples 1 99999)
	      (if (fneq (sample 0) -1.0) (snd-display "sample at end: ~A" (sample 0)))
	      (if (not (= (framples) 1)) (snd-display "length at end: ~A" (framples)))
	      (check-edit-tree '((0 2 0 0 1.0 0.0 0.0 0) (1 -2 0 0 0.0 0.0 0.0 0))
			       (make-float-vector 1 -1.0) "at end")
	      (close-sound ind)))
	  
	  ;; a special case that catches the round-off problem
	  (let ((ind (open-sound "oboe.snd")))
	    (env-channel '(0.0 0.984011617147162 0.644050741979388 0.110976689002195 1.17272046995914 0.384709990674106 
			       1.25650287720397 0.551452668245628 1.4389507801877 0.843827758574229 2.16614272265275 0.226832341237953))
	    (let ((val (sample 50827)))
	      (if (or (not (number? val))
		      (fneq val 0.0))
		  (snd-display "round-off env: ~A" val)))
	    (check-edit-tree '((0 0 0 15111 1.0 0.984011590480804 -5.77709688514005e-5 4)
			       (15112 0 15112 27516 1.0 0.110976688563824 2.20663678192068e-5 4)
			       (27517 0 27517 29482 1.0 0.384709984064102 8.4813182184007e-5 4)
			       (29483 0 29483 33763 1.0 0.551452696323395 6.82959798723459e-5 4)
			       (33764 0 33764 50827 1.0 0.843827784061432 -3.61598467861768e-5 4) (50828 -2 0 0 0.0 0.0 0.0 0))
			     #f "round-off test")
	    (revert-sound ind)
	    (map-channel (lambda (y) 1.0))
	    (env-channel '(0 0 1 1 2 0))
	    (scale-channel .5 1000 1000)
	    (let ((val (sample 800)))
	      (if (fneq val .0314)
		  (snd-display "scl on env trouble: ~A" val)))
	    (check-edit-tree '((0 1 0 999 1.0 0.0 3.93483896914404e-5 4) (1000 1 1000 1999 0.5 0.0393483899533749 3.93483896914404e-5 4)
			       (2000 1 2000 25413 1.0 0.0786967799067497 3.93483896914404e-5 4)
			       (25414 1 25414 50827 1.0 1.0 -3.93499394704122e-5 4) (50828 -2 0 0 0.0 0.0 0.0 0))
			     #f "scl on env")
	    (revert-sound ind)
	    (map-channel (lambda (y) 1.0))
	    (ramp-channel 0.0 1.0)
	    (ramp-channel 0.0 1.0)
	    (ramp-channel 0.0 1.0)
	    (let ((val (sample 20000)))
	      (if (fneq val (expt (/ 20000.0 50828) 3))
		  (snd-display "ramp-channels piled up: ~A" val)))
	    (check-edit-tree '((0 1 0 50827 1.0 0.0 1.96745822904631e-5 10) (50828 -2 0 0 0.0 0.0 0.0 0))
			     #f "ramp upon ramp")
	    (revert-sound ind)
	    
	    (map-channel (lambda (y) 1.0))
	    (ramp-channel 0.5 1.0) ; val = 0.5 + (20000/50828)*0.5
	    (ramp-channel 0.0 0.5) ; val * (20000/50828)*0.5
	    (ramp-channel 0.1 0.4) ; val * (0.1 + (20000/50828)*0.3)
	    (let ((val (sample 20000))
		  (val3 (let ((ratio (/ 20000.0 50828)))
			  (* (+ 0.5 (* 0.5 ratio)) 0.5 ratio (+ 0.1 (* ratio 0.3))))))
	      (if (fneq val val3)
		  (snd-display "ramp-channels piled up (2): ~A ~A" val val3)))
	    
	    (revert-sound ind)
	    (env-channel '(0 0 1 1 2 0))
	    (check-edit-tree '((0 0 0 25413 1.0 0.0 3.93483896914404e-5 4) (25414 0 25414 50827 1.0 1.0 -3.93499394704122e-5 4) (50828 -2 0 0 0.0 0.0 0.0 0))
			     #f "env+scl 0")
	    (scale-channel .5 0 1000)
	    (check-edit-tree '((0 0 0 999 0.5 0.0 3.93483896914404e-5 4) (1000 0 1000 25413 1.0 0.0393483899533749 3.93483896914404e-5 4)
			       (25414 0 25414 50827 1.0 1.0 -3.93499394704122e-5 4) (50828 -2 0 0 0.0 0.0 0.0 0))
			     #f "env+scl 1")
	    (undo)
	    (scale-channel .5 1000 1000)
	    (check-edit-tree '((0 0 0 999 1.0 0.0 3.93483896914404e-5 4) (1000 0 1000 1999 0.5 0.0393483899533749 3.93483896914404e-5 4)
			       (2000 0 2000 25413 1.0 0.0786967799067497 3.93483896914404e-5 4)
			       (25414 0 25414 50827 1.0 1.0 -3.93499394704122e-5 4) (50828 -2 0 0 0.0 0.0 0.0 0))
			     #f "env+scl 2")
	    (undo)
	    (scale-channel .5 0 25415)
	    (check-edit-tree '((0 0 0 25413 0.5 0.0 3.93483896914404e-5 4) (25414 0 25414 25414 0.5 1.0 -3.93499394704122e-5 4)
			       (25415 0 25415 50827 1.0 0.999960660934448 -3.93499394704122e-5 4) (50828 -2 0 0 0.0 0.0 0.0 0))
			     #f "env+scl 3")
	    (undo)
	    (scale-channel .5 20000 10000)
	    (check-edit-tree '((0 0 0 19999 1.0 0.0 3.93483896914404e-5 4) (20000 0 20000 25413 0.5 0.786967813968658 3.93483896914404e-5 4) 
			       (25414 0 25414 29999 0.5 1.0 -3.93499394704122e-5 4) (30000 0 30000 50827 1.0 0.819541156291962 -3.93499394704122e-5 4)
			       (50828 -2 0 0 0.0 0.0 0.0 0))
			     #f "env+scl 4")
	    (undo)
	    (scale-channel .5 30000 1000)
	    (check-edit-tree '((0 0 0 25413 1.0 0.0 3.93483896914404e-5 4) (25414 0 25414 29999 1.0 1.0 -3.93499394704122e-5 4)
			       (30000 0 30000 30999 0.5 0.819541156291962 -3.93499394704122e-5 4) (31000 0 31000 50827 1.0 0.780191242694855 -3.93499394704122e-5 4)
			       (50828 -2 0 0 0.0 0.0 0.0 0))
			     #f "env+scl 5")
	    (undo)
	    (scale-channel .5 25415 1000)
	    (check-edit-tree '((0 0 0 25413 1.0 0.0 3.93483896914404e-5 4) (25414 0 25414 25414 1.0 1.0 -3.93499394704122e-5 4)
			       (25415 0 25415 26414 0.5 0.999960660934448 -3.93499394704122e-5 4) (26415 0 26415 50827 1.0 0.960610687732697 -3.93499394704122e-5 4)
			       (50828 -2 0 0 0.0 0.0 0.0 0))
			     #f "env+scl 6")
	    (undo)
	    (scale-channel .5 40000 10828)
	    (check-edit-tree '((0 0 0 25413 1.0 0.0 3.93483896914404e-5 4) (25414 0 25414 39999 1.0 1.0 -3.93499394704122e-5 4)
			       (40000 0 40000 50827 0.5 0.426041781902313 -3.93499394704122e-5 4) (50828 -2 0 0 0.0 0.0 0.0 0))
			     #f "env+scl 7")
	    
	    (close-sound ind))
	  
	  (for-each
	   (lambda (dur)
	     (let ((i1 (new-sound))
		   (i2 (new-sound "fmv1.snd" 2 44100 mus-ldouble mus-next))
		   (v (make-float-vector dur 1.0)))
	       (define check-envs 
		 (let ((check-env (lambda (name r e)
				    (let ((v0 (make-float-vector dur))
					  (v1 (make-float-vector dur)))
				      (if (env? e)
					  (do ((i 0 (+ i 1)))
					      ((= i dur))
					    (set! (v0 i) (env e)))
					  (do ((i 0 (+ i 1)))
					      ((= i dur))
					    (set! (v0 i) (e))))
				      (if (sampler? r)
					  (do ((i 0 (+ i 1)))
					      ((= i dur))
					    (float-vector-set! v1 i (read-sample r)))
					  (do ((i 0 (+ i 1)))
					      ((= i dur))
					    (float-vector-set! v1 i (r))))
				      (if (not (mus-arrays-equal? v0 v1))
					  (snd-display "~A env check: ~A ~A" name v0 v1))))))
		   (lambda (name r-maker e-maker)
		     (check-env (format #f "~A-1-0" name) (r-maker i1 0) (e-maker))
		     (check-env (format #f "~A-2-0" name) (r-maker i2 0) (e-maker))
		     (check-env (format #f "~A-2-1" name) (r-maker i2 1) (e-maker)))))
	       (float-vector->channel v 0 dur i1)
	       (float-vector->channel v 0 dur i2 0)
	       (float-vector->channel v 0 dur i2 1)
	       (set! (sync i1) 1)
	       (set! (sync i2) 1)
	       (env-sound '(0 0 1 1))
	       (check-envs 'ramps (lambda (s c) (make-sampler 0 s c)) (lambda () (make-env '(0 0 1 1) :length dur)))
	       (reverse-sound)
	       (check-envs 'rev-ramps (lambda (s c) (make-sampler 0 s c)) (lambda () (make-env '(0 1 1 0) :length dur)))
	       (undo 2)
	       (env-sound '(0 0 1 1 2 0))
	       (check-envs 'ramps (lambda (s c) (make-sampler 0 s c)) (lambda () (make-env '(0 0 1 1 2 0) :length dur)))
	       (undo 1)
	       (scale-by .5)
	       (env-sound '(0 0 1 1))
	       (check-envs 'scl-ramps (lambda (s c) (make-sampler 0 s c)) (lambda () (make-env '(0 0 1 1) :length dur :scaler .5)))
	       (reverse-sound)
	       (check-envs 'scl-rev-ramps (lambda (s c) (make-sampler 0)) (lambda () (make-env '(0 1 1 0) :length dur :scaler .5)))
	       (undo 3)
	       (env-sound '(0 0 1 1))
	       (env-sound '(0 0 1 1))
	       (check-envs 'unenv-ramps
			   (lambda (s c)
			     (make-sampler 0 s c))
			   (lambda ()
			     (let ((e (make-env '(0 0 1 1) :length dur)))
			       (lambda ()
				 (let ((val (env e)))
				   (* val val))))))
	       (undo 2)
	       (env-sound '(0 0 1 1))
	       (let ((v1 (make-float-vector 3 1.0)))
		 (float-vector->channel v1 3 3 i1)
		 (float-vector->channel v1 3 3 i2 0)
		 (float-vector->channel v1 3 3 i2 1)
		 (let ((vals (channel->float-vector 0 10 i1 0)))
		   (if (not (mus-arrays-equal? vals (float-vector 0.0 (/ 1.111 dur) (/ 2.222 dur) 1 1 1 (/ 6.66  dur) (/ 7.77  dur) (/ 8.88  dur) (/ 10.0 dur))))
		       (snd-display " 1 0 vals: ~A" vals))
		   (set! vals (channel->float-vector 0 10 i2 0))
		   (if (not (mus-arrays-equal? vals (float-vector 0.0 (/ 1.111 dur) (/ 2.222 dur) 1 1 1 (/ 6.66  dur) (/ 7.77  dur) (/ 8.88  dur) (/ 10.0 dur))))
		       (snd-display " 2 0 vals: ~A" vals))
		   (set! vals (channel->float-vector 0 10 i2 1))
		   (if (not (mus-arrays-equal? vals (float-vector 0.0 (/ 1.111 dur) (/ 2.222 dur) 1 1 1 (/ 6.66  dur) (/ 7.77  dur) (/ 8.88  dur) (/ 10.0 dur))))
		       (snd-display " 2 1 vals: ~A" vals))))
	       (clean-up-sound i1)
	       (close-sound i2)
	       ))
	   '(10 10000))
	  
	  (when (null? (hook-functions initial-graph-hook))
	    (set! (hook-functions update-hook) ())
	    (set! (hook-functions close-hook) ())
	    (set! (hook-functions exit-hook) ()))
	  
	  (let ((data (map
		       (lambda (sound)
			 (if (file-exists? sound)
			     (let ((ind (view-sound sound)))
			       (set! (squelch-update ind) #t)
			       
			       (let ((times (map
					     (lambda (function)
					       (let ((start (real-time)))
						 (function)
						 (revert-sound)
						 (- (real-time) start)))
					     (list (lambda () (scale-channel 2.0))
						   reverse-channel
						   (lambda () (env-channel '(0 0 1 1)))
						   (lambda () (map-channel (lambda (y) (* y 2.0))))
						   (lambda () (scan-channel (lambda (y) (> y 1.0))))
						   (lambda () (pad-channel 0 2000))
						   (lambda () (float-vector->channel (make-float-vector 1000 .1) 0 1000))
						   (lambda () (clm-channel (make-two-zero .5 .5)))
						   (lambda () (mix "pistol.snd" 12345))
						   (lambda () (src-channel 2.0))
						   (lambda () (delete-samples 10 200))
						   ))))
				 (close-sound ind)
				 times))))
		       (let ((away (string-append home-dir "/test/sound/away.snd")))
			 (list "1a.snd" "oboe.snd" "storm.snd" (if (file-exists? away) away "lola.snd"))))))
	    
	    (snd-display "        scl   rev   env   map   scn   pad   wrt   clm   mix   src   del")
	    (snd-display "1a:   ~{~A ~}" (map (lambda (a) (if (< a .005) (copy "  0.0") (format #f "~5,2F" a))) (car data)))
	    (snd-display "oboe: ~{~A ~}" (map (lambda (a) (if (< a .005) (copy "  0.0") (format #f "~5,2F" a))) (cdar data)))
	    (snd-display "storm:~{~A ~}" (map (lambda (a) (if (< a .005) (copy "  0.0") (format #f "~5,2F" a))) (caddr data)))
	    (if (pair? (cadddr data))
		(snd-display "away: ~{~A ~}" (map (lambda (a) (if (< a .005) (copy "  0.0") (format #f "~5,2F" a))) (cadddr data)))))
	  
	  (when with-big-file
	    (when all-args
	      (let ((ind (view-sound big-file-name)))
		(catch #t
		  (lambda ()
		    (set! (squelch-update ind) #t)
		    (set! *selection-creates-region* #f)
		    (let ((times (map
				  (lambda (function)
				    (let ((start (real-time)))
				      (function)
				      (update-time-graph)
				      (revert-sound)
				      (- (real-time) start)))
				  (list (lambda () 
					  (let ((ma (maxamp)))
					    (scale-channel 2.0)
					    (if (fneq (maxamp) (* 2 ma)) (snd-display "bigger scale max: ~A ~A" ma (maxamp)))))
					(lambda () 
					  (let ((ma (maxamp)))
					    (env-channel '(0 0 1 1))
					    (if (fneq (maxamp) ma) (snd-display "bigger env max: ~A ~A" ma (maxamp)))))
					(lambda () (pad-channel 0 2000))
					(lambda () (pad-channel 1336909605 297671280))
					(lambda () (insert-silence (+ (framples ind) 100) 100))
					(lambda () (float-vector->channel (make-float-vector 1000 .1) 0 1000))
					(lambda () (float-vector->channel (make-float-vector 1000 .1) (/ (framples ind) 2) 1000))
					(lambda () (float-vector->channel (make-float-vector 1000 .1) (- (framples ind) 2000) 1000))
					(lambda () (mix "pistol.snd" 12345))
					(lambda () (delete-samples 10 200))
					(lambda () (delete-samples 1336909605 297671280))
					(lambda () (delete-samples (- (framples ind) 100) 10))
					))))
		      (set! (squelch-update ind) #f)
		      (snd-display "big:  ~{~6,2F~}" times)
		      ))
		  (lambda args (set! (squelch-update) #f)))
		(close-sound ind)))
	    
	    (letrec ((fieql
		      (lambda (a b)
			(if (null? a)
			    (null? b)
			    (and (not (null? b))
				 (not (or (and (integer? (car a))
					       (not (= (car a) (car b))))
					  (and (number? (car a))
					       (fneq (car a) (car b)))))
				 (fieql (cdr a) (cdr b)))))))
	      
	      (set! (hook-functions after-graph-hook) ())
	      (set! (hook-functions mouse-click-hook) ())
	      
	      (let ((ind (open-sound big-file-name)))
		(let ((old-vals #f))
		  (let ((vals (make-float-vector 100)))
		    (if (= big-file-framples 0)
			(set! big-file-framples (framples ind)))
		    (select-sound ind)
		    (select-channel 0)
		    (set! (squelch-update) #t)
		    (if (not (fieql (edit-tree) (list (list 0 0 0 (- big-file-framples 1) 1.0 0.0 0.0 0) (list big-file-framples -2 0 0 0.0 0.0 0.0 0))))
			(snd-display "bigger initial tree: ~A" (edit-tree)))
		    (fill! vals 1.0)
		    (let ((maxa (maxamp)))
		      (scale-channel 0.5)
		      (set! old-vals (channel->float-vector (- (* (floor *clm-srate*) 50000) 50) 200))
		      (if (fneq (maxamp) (* 0.5 maxa)) (snd-display "bigger scale: ~A ~A" maxa (maxamp)))))
		  (set! (samples (* (floor *clm-srate*) 50000) 100) vals)
		  (if (not (fieql (edit-tree) (list (list 0 0 0 2204999999 0.5 0.0 0.0 0) 
						    (list 2205000000 1 0 99 1.0 0.0 0.0 0) 
						    (list 2205000100 0 2205000100 (- big-file-framples 1) 0.5 0.0 0.0 0) 
						    (list big-file-framples -2 0 0 0.0 0.0 0.0 0))))
		      (snd-display "bigger set tree: ~A" (edit-tree)))
		  (let ((new-vals (channel->float-vector (- (* (floor *clm-srate*) 50000) 50) 200)))
		    (do ((i 50 (+ i 1))) ((= i 150)) (set! (old-vals i) 1.0))
		    (if (not (mus-arrays-equal? new-vals old-vals)) (snd-display "bigger set ~A ~A" old-vals new-vals))))
		(env-channel (make-env '(0 0 1 1) :length (* (floor *clm-srate*) 60000)) 1000 (* (floor *clm-srate*) 60000))
		(if (not (fieql (edit-tree) (list (list 0 0 0 999 0.5 0.0 0.0 0) 
						  (list 1000 0 1000 2204999999 0.5 1.12130420080871e-17 0.83333295583725 1) 
						  (list 2205000000 1 0 99 1.0 0.83333295583725 0.833333015441895 1) 
						  (list 2205000100 0 2205000100 2646000999 0.5 0.833333015441895 1.0 1) 
						  (list 2646001000 0 2646001000 (- big-file-framples 1) 0.5 0.0 0.0 0) 
						  (list big-file-framples -2 0 0 0.0 0.0 0.0 0))))
		    (snd-display "bigger with env: ~A" (edit-tree)))
		(revert-sound ind)
		(env-channel (make-env '(0 0 1 1 2 0) :length 101) (* (floor *clm-srate*) 50000) 100)
		(if (not (fieql (edit-tree) (list (list 0 0 0 2204999999 1.0 0.0 0.0 0) 
						  (list 2205000000 0 2205000000 2205000050 1.0 4.47034825823422e-10 1.0 2) 
						  (list 2205000051 0 2205000051 2205000099 1.0 0.979591846466064 -5.55111512312578e-17 2) 
						  (list 2205000100 0 2205000100 (- big-file-framples 1) 1.0 0.0 0.0 0) 
						  (list big-file-framples -2 0 0 0.0 0.0 0.0 0))))
		    (snd-display "bigger short env: ~A" (edit-tree)))
		(let ((r (make-sampler (+ 75 (* (floor *clm-srate*) 50000))))
		      (v (make-float-vector 10)))
		  (do ((i 0 (+ i 1)))
		      ((= i 10))
		    (set! (v i) (read-sample r)))
		  (if (not (mus-arrays-equal? v #r(-0.021 -0.020 -0.020 -0.019 -0.018 -0.017 -0.016 -0.016 -0.015 -0.014)))
		      (snd-display "bigger short env vals: ~A" v)))
		(revert-sound)
		
		(let ((v (channel->float-vector (+ 75 (* (floor *clm-srate*) 50000)) 10)))
		  (if (not (mus-arrays-equal? v #r(-0.042 -0.043 -0.044 -0.045 -0.045 -0.045 -0.045 -0.045 -0.045 -0.046)))
		      (snd-display "bigger no env vals: ~A" v)))
		(scale-to 1.0)
		(if (fneq (maxamp) 1.0) (snd-display "bigger scale-to 1.0 maxamp: ~A" (maxamp)))
		(set! (sample (* (floor *clm-srate*) 51000)) 0.0)
		(if (not (fieql (edit-tree) (list (list 0 0 0 2249099999 1.18574941158295 0.0 0.0 0) 
						  (list 2249100000 1 0 0 1.0 0.0 0.0 0) 
						  (list 2249100001 0 2249100001 (- big-file-framples 1) 1.18574941158295 0.0 0.0 0) 
						  (list big-file-framples -2 0 0 0.0 0.0 0.0 0))))
		    (snd-display "bigger set 0 samp: ~A" (edit-tree)))
		(if (fneq (sample (* (floor *clm-srate*) 51000)) 0.0) (snd-display "bigger 0 samp: ~A" (sample (* (floor *clm-srate*) 51000))))
		(delete-samples (* (floor *clm-srate*) 52000) 100)
		(if (not (= (framples) (- big-file-framples 100))) 
		    (snd-display "bigger deletion framples: ~A (~A)" (framples) (- big-file-framples 100)))
		(if (not (= (framples ind 0 0) big-file-framples)) 
		    (snd-display "bigger edpos deletion framples: ~A (~A)" (framples ind 0 0) big-file-framples))
		(if (not (= (framples ind 0 (edit-position)) (- big-file-framples 100))) 
		    (snd-display "bigger ed deletion framples: ~A (~A)" (framples ind 0 (edit-position)) (- big-file-framples 100)))
		(if (not (fieql (edit-tree) (list (list 0 0 0 2249099999 1.18574941158295 0.0 0.0 0) 
						  (list 2249100000 1 0 0 1.0 0.0 0.0 0) 
						  (list 2249100001 0 2249100001 2293199999 1.18574941158295 0.0 0.0 0) 
						  (list 2293200000 0 2293200100 (- big-file-framples 1) 1.18574941158295 0.0 0.0 0) 
						  (list (- big-file-framples 100) -2 0 0 0.0 0.0 0.0 0))))
		    (snd-display "bigger deletion: ~A" (edit-tree)))
		(delete-samples 954624868 67)
		(revert-sound)
		
		(delete-samples 1000 (* (floor *clm-srate*) 50000))
		(if (not (= (framples) (- big-file-framples (* (floor *clm-srate*) 50000)))) (snd-display "bigger big deletion: ~A" (framples)))
		(if (not (fieql (edit-tree) (list (list 0 0 0 999 1.0 0.0 0.0 0) 
						  (list 1000 0 1085232704 (- big-file-framples 1) 1.0 0.0 0.0 0) 
						  (list 970200000 -2 0 0 0.0 0.0 0.0 0))))
		    (snd-display "bigger big delete: ~A" (edit-tree)))
		(insert-silence 0 (* (floor *clm-srate*) 50000))
		(if (not (= (framples) big-file-framples)) (snd-display "bigger silence: ~A (~A)" (framples) big-file-framples))
		(if (not (fieql (edit-tree) (list (list 0 -1 0 2204999999 0.0 0.0 0.0 0) 
						  (list 2205000000 0 0 999 1.0 0.0 0.0 0) 
						  (list 2205001000 0 1085232704 (- big-file-framples 1) 1.0 0.0 0.0 0) 
						  (list big-file-framples -2 0 0 0.0 0.0 0.0 0))))
		    (snd-display "bigger pad: ~A" (edit-tree)))
		(revert-sound)
		
		(pad-channel (* (floor *clm-srate*) 50000) 100)
		(if (fneq (sample (+ (* (floor *clm-srate*) 50000) 10)) 0.0) 
		    (snd-display "bigger pad samp: ~A" (sample (+ (* (floor *clm-srate*) 50000) 10))))
		(if (not (= (framples) (+ big-file-framples 100))) 
		    (snd-display "bigger pad framples: ~A (~A)" (framples) (+ big-file-framples 100)))
		(map-channel (lambda (y) (+ y .2)) (* (floor *clm-srate*) 50000) 10)
		(if (fneq (sample (+ (* (floor *clm-srate*) 50000) 1)) 0.2) (snd-display "bigger map samp: ~A" (sample (+ (* (floor *clm-srate*) 50000) 1))))
		(if (not (fieql (edit-tree) (list (list 0 0 0 2204999999 1.0 0.0 0.0 0) 
						  (list 2205000000 1 0 9 1.0 0.0 0.0 0) 
						  (list 2205000010 -1 10 99 0.0 0.0 0.0 0) 
						  (list 2205000100 0 2205000000 (- big-file-framples 1) 1.0 0.0 0.0 0) 
						  (list (+ big-file-framples 100) -2 0 0 0.0 0.0 0.0 0))))
		    (snd-display "bigger map: ~A" (edit-tree)))
		(save-edit-history "hiho.scm")
		(revert-sound)
		
		(set! sfile ind)
		(load (string-append cwd "hiho.scm"))
		(if (not (fieql (edit-tree) (list (list 0 0 0 2204999999 1.0 0.0 0.0 0) 
						  (list 2205000000 1 0 9 1.0 0.0 0.0 0) 
						  (list 2205000010 -1 10 99 0.0 0.0 0.0 0) 
						  (list 2205000100 0 2205000000 (- big-file-framples 1) 1.0 0.0 0.0 0) 
						  (list (+ big-file-framples 100) -2 0 0 0.0 0.0 0.0 0))))
		    (snd-display "bigger reload: ~A" (edit-tree)))
		(delete-file "hiho.scm")
		
		(let* ((flt (make-one-zero 0.5 0.5))
		       (lvals (channel->float-vector (+ 1000 (* (floor *clm-srate*) 65000)) 10 ind 0 0)))
		  (if (not (mus-arrays-equal? lvals #r(-0.006 0.052 0.103 0.146 0.182 0.210 0.232 0.249 0.262 0.272)))
		      (snd-display "bigger (orig) vals: ~A" lvals))
		  (clm-channel flt (+ (* (floor *clm-srate*) 65000) 1000) 10)
		  (if (not (fieql (edit-tree) (list (list 0 0 0 2204999999 1.0 0.0 0.0 0) 
						    (list 2205000000 1 0 9 1.0 0.0 0.0 0) 
						    (list 2205000010 -1 10 99 0.0 0.0 0.0 0) 
						    (list 2205000100 0 2205000000 2866499899 1.0 0.0 0.0 0) 
						    (list 2866500000 2 0 9 1.0 0.0 0.0 0) 
						    (list 2866500010 0 2866499910 (- big-file-framples 1) 1.0 0.0 0.0 0) 
						    (list (+ big-file-framples 100) -2 0 0 0.0 0.0 0.0 0))))
		      (snd-display "bigger clm: ~A" (edit-tree)))
		  (if (not (mus-arrays-equal? (channel->float-vector (+ 1000 (* (floor *clm-srate*) 65000)) 10) 
					      #r(-0.006 0.015 0.065 0.107 0.142 0.169 0.190 0.205 0.216 0.222)))
		      (snd-display "bigger clm vals: ~A" (channel->float-vector (+ 1000 (* (floor *clm-srate*) 65000)) 10)))
		  
		  (let ((r (make-readin big-file-name :start (+ 1000 (* (floor *clm-srate*) 65000))))
			(v (make-float-vector 10)))
		    (do ((i 0 (+ i 1)))
			((= i 10))
		      (set! (v i) (readin r)))
		    (if (not (mus-arrays-equal? v lvals))
			(snd-display "bigger (orig) readin vals: ~A (~A)" v lvals))))
		(revert-sound)
		(let ((found (scan-channel (lambda (y) (> y .5)) (* (floor *clm-srate*) 50000))))
		  (if (not (equal? found '(#t 2205000925)))
		      (snd-display "bigger scan: ~A" found)))
		(set! (squelch-update) #f)
		(close-sound ind))))
	  
	  (let ((ind (new-sound "fmv.snd" :header-type mus-next :sample-type mus-ldouble)))
	    (set! *sinc-width* 10)
	    (pad-channel 0 1000 ind)
	    (set! (sample 100) 0.5)
	    (if (fneq (sample 100 ind 0 2) 0.5) (snd-display "sample 100 (2): ~A" (sample 100 ind 0 2)))
	    (if (fneq (sample 100 ind 0 1) 0.0) (snd-display "sample 100 (1): ~A" (sample 100 ind 0 1)))
	    (src-channel 0.5)
	    (let ((mx (maxamp ind 0)))
	      (if (fneq mx 0.5) (snd-display "src-channel max .5: ~A" mx)))
	    (if (fneq (sample 200) 0.5) (snd-display "src-channel 0.5 200: ~A" (sample 200)))
	    (if (not (mus-arrays-equal? (channel->float-vector 180 40 ind 0)
					#r(0.0 0.0 0.0 0.001 0.0 -0.003 0.0 0.007 0.0 -0.012
						      0.0 0.020 0.0 -0.033 0.0 0.054 0.0 -0.100 0.0 0.316
						      0.500 0.316 0.0 -0.100 0.0 0.054 0.0 -0.033 0.0 0.020
						      0.0 -0.012 0.0 0.007 0.0 -0.003 0.0 0.001 0.0 -0.000)))
		(snd-display "src-channel 0.5 -> ~A" (channel->float-vector 180 40 ind 0)))
	    (undo 1 ind 0)
	    (src-channel 0.25)
	    (let ((mx (maxamp ind 0)))
	      (if (fneq mx 0.5) (snd-display "src-channel max .25: ~A" mx)))
	    (if (fneq (sample 400) 0.5) (snd-display "src-channel 0.25 400: ~A" (sample 400)))
	    (if (not (mus-arrays-equal? (channel->float-vector 360 80 ind 0)
					#r(0.0 0.0 0.0 0.0 0.0 0.0 0.001 0.001 0.0 -0.002
						      -0.003 -0.003 0.0 0.004 0.007 0.006 0.0 -0.008 -0.012 -0.010
						      0.0 0.013 0.020 0.016 0.0 -0.021 -0.033 -0.026 0.0 0.034
						      0.054 0.044 0.0 -0.060 -0.100 -0.087 0.0 0.148 0.316 0.449
						      0.500 0.449 0.316 0.148 0.0 -0.087 -0.100 -0.060 0.0 0.044
						      0.054 0.034 0.0 -0.026 -0.033 -0.021 0.0 0.016 0.020 0.013
						      0.0 -0.010 -0.012 -0.008 0.0 0.006 0.007 0.004 0.0 -0.003
						      -0.003 -0.002 0.0 0.001 0.001 0.0 0.0 0.0 0.0 -0.000)))
		(snd-display "src-channel 0.25 -> ~A" (channel->float-vector 360 80 ind 0)))
	    (undo 2 ind 0)
	    (let ((e (make-env '(0.0 0.0 1.0 1.0) :scaler (* .01 pi (- (framples) 1.0)) :length (framples))))
	      (map-channel (lambda (y) (* .5 (sin (env e))))))
	    (for-each
	     (lambda (sr df)
	       (src-channel sr)
	       (if (> (abs (- (maxamp ind 0) .5)) df) (snd-display "src-channel sine ~A: ~A" sr (maxamp ind 0)))
	       (if (integer? sr)
		   (let ((r0 (make-sampler 0))
			 (r1 (make-sampler 0 ind 0 1 (- (edit-position) 1)))
			 (sri (floor sr)))
		     (do ((i 0 (+ i 1)))
			 ((= i 500))
		       (let ((diff (abs (- (r0) (r1)))))
			 (if (> diff df) (snd-display "src-channel ~A diff ~D: ~A" sr i diff))
			 (do ((j 1 (+ j 1)))
			     ((= j sri))
			   (r1))))))
	       (do ((i 0 (+ i 1)))
		   ((= i 50))
		 (let ((s1 (sample i ind 0 (edit-position)))
		       (s2 (sample (round (* sr i)) ind 0 (- (edit-position) 1)))
		       (s3 (sample i ind 0 1)))
		   (if (> (abs (- s1 s2)) df) (snd-display "sample ~D src(~A): ~A ~A" i sr s1 s2))
		   (if (fneq s3 0.0) (snd-display "sample ~D (1): ~A" i s3))))
	       (undo 1 ind 0))
	     '(2.0 1.5 3.0 3.14)
	     '(0.008 0.01 0.015 0.025))
	    (close-sound ind))
	  (let ((ind (open-sound "oboe.snd")))
	    (let ((orig-max (maxamp ind 0)))
	      (for-each
	       (lambda (sr df)
		 (src-channel sr)
		 (if (> (abs (- (maxamp ind 0) orig-max)) df) (snd-display "src-channel oboe ~A: ~A ~A" sr orig-max (maxamp ind 0)))
		 (if (integer? sr)
		     (let ((r0 (make-sampler 0))
			   (r1 (make-sampler 0 ind 0 1 (- (edit-position) 1)))
			   (sri (floor sr)))
		       (do ((i 0 (+ i 1)))
			   ((= i 5000))
			 (let ((diff (abs (- (r0) (r1)))))
			   (if (> diff df) (snd-display "src-channel oboe ~A diff ~D: ~A" sr i diff))
			   (do ((j 1 (+ j 1)))
			       ((= j sri))
			     (r1))))))
		 (undo 1 ind 0))
	       '(2.0 1.5 3.0 3.14)
	       '(0.008 0.01 0.015 0.025))
	      
	      (for-each
	       (lambda (sr df)
		 (src-channel sr)
		 (if (> (abs (- (maxamp ind 0) orig-max)) df) (snd-display "src-channel oboe ~A: ~A ~A" sr orig-max (maxamp ind 0)))
		 (do ((i 0 (+ i 1)))
		     ((= i 50))
		   (let* ((samp (* i 100))
			  (s1 (sample samp ind 0 (edit-position)))
			  (s2 (sample (floor (* sr samp)) ind 0 (- (edit-position) 1))))
		     (if (> (abs (- s1 s2)) df) (snd-display "sample ~D oboe src(~A): ~A ~A" i sr s1 s2))))
		 (undo 1 ind 0)
		 (amp-envs-equal? ind 0 (edit-position) (+ 1 (edit-position)) .01))
	       '(0.5 0.25 0.9 0.1)
	       '(0.001 0.001 0.001 0.001)))
	    (revert-sound ind)
	    (scale-by 2.0)
	    (scale-by 0.5)
	    (amp-envs-equal? ind 0 (edit-position) (- (edit-position) 2) .001)
	    (revert-sound ind)
	    (close-sound ind))
	  
	  ;; recursion tests
	  (let ((ind (open-sound "oboe.snd")))
	    (let ((val (scan-channel (lambda (y) (scan-channel (lambda (n5) (> n5 .1)))))))
	      (if (not (eqv? val 0))
		  (snd-display "scan-channel in scan-channel: ~A" val)))
	    (let ((hi (make-float-vector 3)))
	      (fill-float-vector hi (if (scan-channel (lambda (y) (> y .1))) 1.0 0.0))
	      (if (not (mus-arrays-equal? hi #r(1.0 1.0 1.0))) (snd-display "fill-float-vector with scan-channel: ~A" hi)))
	    (let ((val (scan-channel (lambda (y) (scan-channel (lambda (n6) (> n6 .1)))))))
	      (if (not (= val 0)) (snd-display "find with find: ~A" val)))
	    (let ((val (scan-channel (lambda (y) (scan-channel (lambda (n7) (> n7 .1)))))))
	      (if (not (= val 0)) (snd-display "find with scan-channel: ~A" val)))
	    (let ((mx (maxamp ind 0)))
	      (let ((val (scan-channel (lambda (y) (map-channel (lambda (n) (* n 2.0))) #t))))
		(if (not (eqv? val 0)) (snd-display "scan-channel with map-channel: ~A" val)))
	      (if (fneq mx (/ (maxamp ind 0) 2)) (snd-display "scan+map max: ~A ~A" mx (maxamp ind 0)))
	      (if (not (= (edit-position ind 0) 1)) (snd-display "scan+map edit-pos: ~A" (edit-position ind 0)))
	      (revert-sound ind)
	      (map-channel (let ((ctr 0)) 
			     (lambda (y) 
			       (if (= ctr 0) (map-channel (lambda (n) (* n 2.0)))) 
			       (set! ctr 1) 
			       y))
			   0 3)
	      (if (fneq mx (maxamp ind 0)) (snd-display "map+map max 2: ~A ~A" mx (maxamp ind 0)))
	      (if (not (= (edit-position ind 0) 2)) (snd-display "map+map edit-pos: ~A" (edit-position ind 0)))
	      (if (fneq mx (/ (maxamp ind 0 1) 2)) (snd-display "map+map max 1: ~A ~A" mx (maxamp ind 0 1))))
	    (close-sound ind))
	  
	  (let ((ind (open-sound "oboe.snd")))
	    (for-each
	     (lambda (func beg dur len)
	       (let ((old-len (framples ind)))
		 (func beg dur)
		 (if (not (= (framples ind) len)) 
		     (snd-display "(~A ~A ~A) with ~A -> ~A (~A)?" func beg dur old-len (framples ind) len))))
	     (list (lambda (beg dur) (env-channel '(0 0 1 1) beg dur))
		   (lambda (beg dur) (map-channel (lambda (y) (* y .5)) beg dur))
		   reverse-channel
		   (lambda (beg dur) (scale-channel 2.0 beg dur))
		   (lambda (beg dur) (float-vector->channel (make-float-vector dur) beg dur))
		   smooth-channel
		   pad-channel
		   (lambda (beg dur) (src-channel 0.5 beg dur))
		   insert-silence)
	     '(0 0 0 0 0 0 0 0 0)
	     '(1000 1000 1000 1000 1000 1000 1000 1000 1000)
	     '(50828 50828 50828 50828 50828 50828 51828 52829 53829))
	    
	    (revert-sound ind)
	    
	    (for-each
	     (lambda (beg dur len)
	       (let ((old-len (framples ind)))
		 (pad-channel beg dur)
		 (if (not (= (framples ind) len))
		     (snd-display "(pad-channel ~A ~A) with ~A -> ~A (~A)?" beg dur old-len (framples ind) len))))
	     '(1000 60000 0 62000 62000 62004)
	     '(1000 1000 1000 1 2 1)
	     '(51828 61000 62000 62001 62003 62005))
	    
	    (revert-sound ind)
	    
	    (for-each
	     (lambda (func dur len)
	       (let ((old-len (framples ind)))
		 (func (+ old-len 100) dur)
		 (if (not (= (framples ind) len)) 
		     (snd-display "(~A ~A) with ~A -> ~A (~A)?" func dur old-len (framples ind) len))))
	     (list (lambda (beg dur) (env-channel '(0 0 1 1) beg dur))
		   reverse-channel
		   (lambda (beg dur) (scale-channel 2.0 beg dur))
		   (lambda (beg dur) (scale-sound-by 2.0 beg dur))
		   (lambda (beg dur) (float-vector->channel (make-float-vector dur) beg dur))
		   smooth-channel
		   pad-channel
		   (lambda (beg dur) (src-channel 0.5 beg dur))
		   insert-silence
		   (lambda (beg dur) (env-sound '(0 0 1 1) beg dur))
		   )
	     '(1000 1000 1000 1000 1000 1000 1000 1000 1000 1000)
	     '(50828 50828 50828 50828 51928 51928 53028 53028 54028 54028))
	    
	    (revert-sound ind)
	    
	    (do ((len (floor (* 1.25 (framples))))
		 (i 0 (+ i 1)))
		((= i 100))
	      (case (if (zero? test-16) 3 (random 10))
		((0) (pad-channel (random len) (random 1000)))
		((1) (env-channel '(0 0 1 1 2 0) (random len) (random 1000)))
		((2) (env-sound '(0 0 1 1 2 0) (random len) (random 1000)))
		((3) (scale-channel (random 1.0) (random len) (random 1000)))
		((4) (scale-sound-by (random 1.0) (random len) (random 1000)))
		((5) (src-channel (+ .9 (random .2)) (random len) (random 1000)))
		((6) (ramp-channel (random 1.0) (random 1.0) (random len) (random 1000)))
		((7) (reverse-channel (random len) (random 1000)))
		((8) (let ((dur (max 2 (random 100)))) (float-vector->channel (make-float-vector dur) (random len) dur)))
		((9) (map-channel (lambda (y) (* y 2.0)) (random (floor (/ (framples) 2))) (random 1000)))))
	    (close-sound ind))
	  
	  (let ((ind (open-sound "oboe.snd"))
		(check-oboe (lambda (mx pos)
			      (if (fneq (maxamp) mx)
				  (snd-display "oboe max: ~A (should be ~A)~%" (maxamp) mx))
			      (if (not (= (maxamp-position) pos))
				  (snd-display "oboe max pos: ~A (should be ~A)~%" (maxamp-position) pos))
			      (if (fneq (abs (sample (maxamp-position))) (maxamp))
				  (snd-display "oboe maxes: ~A ~A~%" (maxamp) (abs (sample (maxamp-position))))))))
	    (check-oboe 0.14724731445312 24971)
	    
	    ;; insert zeros
	    (pad-channel 0 100)
	    (check-oboe 0.14724731445312 25071)
	    
	    (revert-sound)
	    (pad-channel 25000 100)
	    (check-oboe 0.14724731445312 24971)
	    
	    (revert-sound)
	    (pad-channel 24971 100)
	    (check-oboe 0.14724731445312 25071)
	    
	    (revert-sound)
	    (pad-channel 24972 100)
	    (check-oboe 0.14724731445312 24971)
	    
	    (revert-sound)
	    (pad-channel 65000 100)
	    (check-oboe 0.14724731445312 24971)
	    
	    ;; set sample
	    (revert-sound)
	    (set-sample 100 .1)
	    (check-oboe 0.14724731445312 24971)
	    
	    (revert-sound)
	    (set-sample 100 .2)
	    (check-oboe 0.2 100)
	    
	    (revert-sound)
	    (set-sample 25000 .1)
	    (check-oboe 0.14724731445312 24971)
	    
	    (revert-sound)
	    (set-sample 25000 .2)
	    (check-oboe 0.2 25000)
	    
	    (revert-sound)
	    (set-sample 24971 .1)
	    (check-oboe 0.14724731445312 25368)
	    
	    (revert-sound)
	    (set-sample 24971 .2)
	    (check-oboe 0.2 24971)
	    
	    (revert-sound)
	    (set-sample 24971 -.2)
	    (check-oboe 0.2 24971)
	    
	    ;; delete-samples
	    (revert-sound)
	    (delete-samples 0 100)
	    (check-oboe 0.14724731445312 24871)
	    
	    (revert-sound)
	    (delete-samples 25000 100)
	    (check-oboe 0.14724731445312 24971)
	    
	    (revert-sound)
	    (delete-samples 24900 100)
	    (check-oboe 0.14724731445312 25268)
	    
	    ;; insert samples
	    (revert-sound)
	    (insert-samples 0 100 (make-float-vector 100 0.1))
	    (check-oboe 0.14724731445312 25071)
	    
	    (revert-sound)
	    (insert-samples 25000 100 (make-float-vector 100 0.1))
	    (check-oboe 0.14724731445312 24971)
	    
	    (revert-sound)
	    (insert-samples 24971 100 (make-float-vector 100 0.1))
	    (check-oboe 0.14724731445312 25071)
	    
	    (revert-sound)
	    (insert-samples 0 100 (make-float-vector 100 0.2))
	    (check-oboe 0.2 0)
	    
	    (revert-sound)
	    (insert-samples 25000 100 (make-float-vector 100 0.2))
	    (check-oboe 0.2 25000)
	    
	    ;; set samples
	    (revert-sound)
	    (set-samples 0 100 (make-float-vector 100 0.1))
	    (check-oboe 0.14724731445312 24971)
	    
	    (revert-sound)
	    (set-samples 25000 100 (make-float-vector 100 0.1))
	    (check-oboe 0.14724731445312 24971)
	    
	    (revert-sound)
	    (set-samples 24900 100 (make-float-vector 100 0.1))
	    (check-oboe 0.14724731445312 25368)
	    
	    (revert-sound)
	    (set-samples 0 100 (make-float-vector 100 0.2))
	    (check-oboe 0.2 0)
	    
	    (revert-sound)
	    (set-samples 25000 100 (make-float-vector 100 0.2))
	    (check-oboe 0.2 25000)
	    
	    ;; scale samples
	    (revert-sound)
	    (scale-channel 2.0)
	    (check-oboe 0.29449462890625 24971)
	    
	    (revert-sound)
	    (scale-channel 0.0)
	    (check-oboe 0.0 0)
	    
	    (revert-sound)
	    (scale-channel 0.1 0 100)
	    (check-oboe 0.14724731445312 24971)
	    
	    (revert-sound)
	    (scale-channel -0.9 0 100)
	    (check-oboe 0.14724731445312 24971)
	    
	    (revert-sound)
	    (scale-channel 0.1 25000 100)
	    (check-oboe 0.14724731445312 24971)
	    
	    (revert-sound)
	    (scale-channel -2.0 24900 100)
	    (check-oboe 0.29449462890625 24971)
	    
	    (revert-sound)
	    (scale-channel 0.1 24900 100)
	    (check-oboe 0.14724731445312 25368)
	    
	    ;; ramp/xramp samples
	    (revert-sound)
	    (ramp-channel 0.0 1.0)
	    (check-oboe 0.091239139496063 35062)
	    
	    (revert-sound)
	    (xramp-channel 0.0 1.0 3.0)
	    (check-oboe 0.074973157321056 35062)
	    
	    (revert-sound)
	    (ramp-channel 0.0 -1.0 0 100)
	    (check-oboe 0.14724731445312 24971)
	    
	    (revert-sound)
	    (ramp-channel 1.0 9.0 10000 100)
	    (check-oboe 1.057239571003 10089)
	    
	    (close-sound ind))
	  
	  (let ((ind0 (open-sound "oboe.snd"))
		(ind1 (open-sound "2.snd"))
		(ind2 (open-sound "4.aiff")))
	    (set! (squelch-update ind0 #t) #t)
	    (set! (squelch-update ind1 #t) #t)
	    (set! (squelch-update ind2 #t) #t)
	    (catch 'mus-error
	      (lambda ()
		(do ((i 0 (+ i 1)))
		    ((= i 500))
		  (set! (sync ind0) (random 3))
		  (set! (sync ind1) (random 3))
		  (set! (sync ind2) (random 3))
		  (opt-test (random 22))))
	      (lambda args
		(snd-display "caught mus-error")
		#f))
	    (set! (squelch-update ind0 #t) #f)
	    (set! (squelch-update ind1 #t) #f)
	    (set! (squelch-update ind2 #t) #f)
	    (close-sound ind0)
	    (close-sound ind1)
	    (close-sound ind2))
	  
	  (catch #t
	    (lambda ()
	      (let* ((ind (open-sound (string-append home-dir "/test/sound/away.snd")))
		     (start (real-time))
		     (mxs (maxamp ind #t)))
		(swap-channels)
		(update-time-graph)
		(let ((tm (- (real-time) start)))
		  (if (> tm .1) (snd-display "swap-channels not optimized? ~A" tm)))
		(let ((new-mxs (maxamp ind #t)))
		  (if (or (fneq (car mxs) (cadr new-mxs))
			  (fneq (cadr mxs) (car new-mxs)))
		      (snd-display "swap-channels amps: ~A -> ~A" mxs new-mxs)))
		(revert-sound ind)
		(close-sound ind)))
	    (lambda args args)) ; away.snd may not exist
	  
	  (let ((ind (init-sound 0.5 10 2)))
	    (save-sound ind)
	    (scale-channel 2.0 0 (framples) ind 1)
	    (swap-channels)
	    (check-both-chans ind "1" (lambda (y) (fneq y 1.0)) (lambda (y) (fneq y 0.5)))
	    (undo 1 ind 0)
	    (undo 2 ind 1)
	    (scale-channel 0.5 0 (framples) ind 0)
	    (scale-channel 2.0 0 (framples) ind 1)
	    (swap-channels)
	    (check-both-chans ind "2" (lambda (y) (fneq y 1.0)) (lambda (y) (fneq y 0.25)))
	    (undo 2 ind 0)
	    (undo 2 ind 1)
	    (delete-samples 2 3 ind 0)
	    (env-channel '(0 0 1 1 2 0) 0 (framples ind 1) ind 1)
	    (swap-channels)
	    (undo 2 ind 0)
	    (undo 2 ind 1)
	    (delete-samples 2 7 ind 0)
	    (swap-channels ind 0 ind 1 5 4)
	    (revert-sound ind)
	    (let ((m0 (add-mark 3 ind 0))
		  (m1 (add-mark 4 ind 1))
		  (m2 (add-mark 5 ind 1)))
	      (scale-channel 0.5)
	      (swap-channels)
	      (if (not (= (mark-sample m0) 3)) (snd-display "swapped m0: ~A" (mark-sample m0)))
	      (if (not (= (mark-sample m1) 4)) (snd-display "swapped m1: ~A" (mark-sample m1)))
	      (if (not (= (mark-sample m2) 5)) (snd-display "swapped m2: ~A" (mark-sample m2)))
	      (if (not (equal? (mark-home m0) (list ind 1))) (snd-display "mark-home m0: ~A" (mark-home m0)))
	      (if (not (equal? (mark-home m1) (list ind 0))) (snd-display "mark-home m1: ~A" (mark-home m1)))
	      (if (not (equal? (mark-home m2) (list ind 0))) (snd-display "mark-home m2: ~A" (mark-home m2)))
	      (undo 1 ind 0)
	      (undo 1 ind 1)
	      (if (not (= (mark-sample m0) 3)) (snd-display "swapped m0 2: ~A" (mark-sample m0)))
	      (if (not (= (mark-sample m1) 4)) (snd-display "swapped m1 2: ~A" (mark-sample m1)))
	      (if (not (= (mark-sample m2) 5)) (snd-display "swapped m2 2: ~A" (mark-sample m2)))
	      (if (not (equal? (mark-home m0) (list ind 0))) (snd-display "mark-home m0 2: ~A" (mark-home m0)))
	      (if (not (equal? (mark-home m1) (list ind 1))) (snd-display "mark-home m1 2: ~A" (mark-home m1)))
	      (if (not (equal? (mark-home m2) (list ind 1))) (snd-display "mark-home m2 2: ~A" (mark-home m2))))
	    (close-sound ind)
	    (delete-file "test.snd"))
	  
	  (let ((ind (init-sound 0.5 10 4)))
	    (scale-channel 0.5 0 (framples) ind 1)
	    (scale-channel 0.25 0 (framples) ind 2)
	    (scale-channel 0.125 0 (framples) ind 3)
	    (swap-channels ind 1 ind 2)
	    (let ((maxs (maxamp ind #t)))
	      (if (or (fneq (maxs 0) 0.5) (fneq (maxs 1) 0.125) (fneq (maxs 2) 0.25) (fneq (maxs 3) 0.0625))
		  (snd-display "swap midchans: ~A" maxs))
	      (close-sound ind)))
	  
	  (let ((ind0 (open-sound "oboe.snd"))
		(ind1 (open-sound "pistol.snd")))
	    (let ((mx0 (maxamp ind0 0))
		  (mx1 (maxamp ind1 0)))
	      (swap-channels ind0 0 ind1 0)
	      (if (fneq (maxamp ind0 0) mx1) (snd-display "maxamp cross swap 0: ~A" (maxamp ind0 0)))
	      (if (fneq (maxamp ind1 0) mx0) (snd-display "maxamp cross swap 1: ~A" (maxamp ind1 0))))
	    (close-sound ind1)
	    (if (not (string=? (display-edits) (string-append "
EDITS: 1

 (begin) [0:2]:
   (at 0, cp->sounds[0][0:50827, 1.000]) [file: " cwd "oboe.snd[0]]
   (at 50828, end_mark)

 (set 0 41623) ; swap-channels [1:2]:
   (at 0, cp->sounds[1][0:41622, 1.000]) [file: " cwd "pistol.snd[0]]
   (at 41623, end_mark)
")))
		(snd-display "cross swap state: ~A" (display-edits)))
	    (close-sound ind0))
	  
	  (let ((ind (init-sound 1.0 10 1)))
	    
	    ;; -------- ramp+ramp
	    (ramp-channel 0.0 1.0)
	    (check-back-and-forth ind "ramp 1" #r(0.0 0.100 0.200 0.300 0.400 0.500 0.600 0.700 0.800 0.900 1.000))
	    (ramp-channel 0.0 1.0)
	    (check-back-and-forth ind "ramp 2" #r(0.0 0.010 0.040 0.090 0.160 0.250 0.360 0.490 0.640 0.810 1.000))
	    (undo)
	    (ramp-channel 1.0 0.0)
	    (check-back-and-forth ind "ramp 3" #r(0.0 0.090 0.160 0.210 0.240 0.250 0.240 0.210 0.160 0.090 0.000))
	    (undo)
	    (env-channel '(0 0 1 1 2 0))
	    (check-back-and-forth ind "ramp 4" #r(0.0 0.020 0.080 0.180 0.320 0.500 0.480 0.420 0.320 0.180 0.000))
	    (undo 2)
	    (env-channel '(0 0 1 1 2 0))
	    (check-back-and-forth ind "ramp 5" #r(0.0 0.200 0.400 0.600 0.800 1.000 0.800 0.600 0.400 0.200 0.000))
	    (ramp-channel 0.0 1.0)
	    (check-back-and-forth ind "ramp 6" #r(0.0 0.020 0.080 0.180 0.320 0.500 0.480 0.420 0.320 0.180 0.000))
	    (scale-channel 0.5)
	    (check-back-and-forth ind "ramp 7" #r(0.0 0.010 0.040 0.090 0.160 0.250 0.240 0.210 0.160 0.090 0.000))
	    (undo 3)
	    (scale-channel 0.5)
	    (env-channel '(0 0 1 1 2 0))
	    (check-back-and-forth ind "ramp 8" #r(0.0 0.100 0.200 0.300 0.400 0.500 0.400 0.300 0.200 0.100 0.000))
	    (ramp-channel 0.0 1.0)
	    (check-back-and-forth ind "ramp 9" #r(0.0 0.010 0.040 0.090 0.160 0.250 0.240 0.210 0.160 0.090 0.000))
	    (undo 3)
	    (ramp-channel 0.0 1.0)
	    (ramp-channel 0.0 1.0)
	    (ramp-channel 0.0 1.0)
	    (check-back-and-forth ind "ramp 10" #r(0.0 0.001 0.008 0.027 0.064 0.125 0.216 0.343 0.512 0.729 1.000))
	    (undo 3)
	    
	    
	    ;; ramp+scl (checking split loc)
	    
	    (let ((start-pos (edit-position ind 0)))
	      (for-each
	       (lambda (func)
		 (ramp-channel 0.0 1.0 0 5)
		 (let ((edpos (edit-position ind 0)))
		   (check-back-and-forth ind "ramp+scl setup" #r(0.0 0.250 0.500 0.750 1.000 1.000 1.000 1.000 1.000 1.000 1.000))
		   (do ((happy #t)
			(start 0 (+ 1 start)))
		       ((or (not happy)
			    (= start 10)))
		     (do ((len 1 (+ 1 len))
			  (v #f))
			 ((or (not happy)
			      (= (+ start len) 11)))
		       (set! v (float-vector 0.0 0.250 0.500 0.750 1.000 1.000 1.000 1.000 1.000 1.000 1.000))
		       (do ((i 0 (+ i 1)))
			   ((= i len))
			 (set! (v (+ start i)) (* (v (+ start i)) 0.5)))
		       (func 0.5 start len)
		       (set! happy (check-back-and-forth ind (format #f "ramp+scl 0-1 [~A ~A] with ~A" start len func) v))
		       (set! (edit-position ind 0) edpos))))
		 (set! (edit-position ind 0) start-pos)
		 
		 (ramp-channel 1.0 0.0 5 5)
		 (let ((edpos (edit-position ind 0)))
		   (check-back-and-forth ind "ramp+scl 2 setup" #r(1.000 1.000 1.000 1.000 1.000 1.000 0.750 0.500 0.250 0.0 1.000))
		   (do ((happy #t)
			(start 0 (+ 1 start)))
		       ((or (not happy)
			    (= start 10)))
		     (do ((len 1 (+ 1 len))
			  (v #f))
			 ((or (not happy)
			      (= (+ start len) 11)))
		       (set! v (float-vector 1.000 1.000 1.000 1.000 1.000 1.000 0.750 0.500 0.250 0.0 1.000))
		       (do ((i 0 (+ i 1)))
			   ((= i len))
			 (set! (v (+ start i)) (* (v (+ start i)) 0.5)))
		       (func 0.5 start len)
		       (set! happy (check-back-and-forth ind (format #f "ramp+scl 1-0 [~A ~A] with ~A" start len func) v))
		       (set! (edit-position ind 0) edpos))))
		 (set! (edit-position ind 0) start-pos)
		 
		 (ramp-channel 0.0 1.0 0 5)
		 (ramp-channel 1.0 0.0 5 5)
		 (let ((edpos (edit-position ind 0)))
		   (check-back-and-forth ind "ramp+scl 3 setup" #r(0.0 0.250 0.500 0.750 1.000 1.000 0.750 0.500 0.250 0.0 1.000))
		   (do ((happy #t)
			(start 0 (+ 1 start)))
		       ((or (not happy)
			    (= start 10)))
		     (do ((len 1 (+ 1 len))
			  (v #f))
			 ((or (not happy)
			      (= (+ start len) 11)))
		       (set! v (float-vector 0.0 0.250 0.500 0.750 1.000 1.000 0.750 0.500 0.250 0.0 1.000))
		       (do ((i 0 (+ i 1)))
			   ((= i len))
			 (set! (v (+ start i)) (* (v (+ start i)) 0.5)))
		       (func 0.5 start len)
		       (set! happy (check-back-and-forth ind (format #f "ramp+scl 0-1-1-0 [~A ~A] with ~A" start len func) v))
		       (set! (edit-position ind 0) edpos))))
		 (set! (edit-position ind 0) start-pos)
		 
		 (ramp-channel 1.0 0.0 3 5)
		 (let ((edpos (edit-position ind 0)))
		   (check-back-and-forth ind "ramp+scl 4 setup" #r(1.000 1.000 1.000 1.000 0.750 0.500 0.250 0.0 1.000 1.000 1.000))
		   (do ((happy #t)
			(start 0 (+ 1 start)))
		       ((or (not happy)
			    (= start 10)))
		     (do ((len 1 (+ 1 len))
			  (v #f))
			 ((or (not happy)
			      (= (+ start len) 11)))
		       (set! v (float-vector 1.000 1.000 1.000 1.000 0.750 0.500 0.250 0.0 1.000 1.000 1.000))
		       (do ((i 0 (+ i 1)))
			   ((= i len))
			 (set! (v (+ start i)) (* (v (+ start i)) 0.5)))
		       (func 0.5 start len)
		       (set! happy (check-back-and-forth ind (format #f "ramp+scl mid 1-0 [~A ~A] with ~A" start len func) v))
		       (set! (edit-position ind 0) edpos))))
		 (set! (edit-position ind 0) start-pos)
		 
		 (env-channel '(0 1 1 0 2 0 3 1))
		 (let ((edpos (edit-position ind 0)))
		   (check-back-and-forth ind "ramp+scl setup" #r(1.000 0.667 0.333 0.0 0.0 0.0 0.0 0.0 0.333 0.667 1.000))
		   (do ((happy #t)
			(start 0 (+ 1 start)))
		       ((or (not happy)
			    (= start 10)))
		     (do ((len 1 (+ 1 len))
			  (v #f))
			 ((or (not happy) 
			      (= (+ start len) 11)))
		       (set! v (float-vector 1.000 0.667 0.333 0.0 0.0 0.0 0.0 0.0 0.333 0.667 1.000))
		       (do ((i 0 (+ i 1)))
			   ((= i len))
			 (set! (v (+ start i)) (* (v (+ start i)) 0.5)))
		       (func 0.5 start len)
		       (set! happy (check-back-and-forth ind (format #f "ramp+scl 0-1-0-1 [~A ~A] with ~A" start len func) v))
		       (set! (edit-position ind 0) edpos))))
		 (set! (edit-position ind 0) start-pos))
	       
	       (list
		scale-channel
		(lambda (scl beg dur)
		  (map-channel (lambda (y) (* y scl)) beg dur)))))
	    (close-sound ind)
	    )	
	  
	  (when (and all-args (= test-16 0))
	    (let ((tries 256))
	      (snd-display "framples: ~,2F ~,2F" 
			   (* 1.0 (/ (mus-sound-framples "1.snd") (mus-sound-framples "oboe.snd")))
			   (* 1.0 (/ (mus-sound-framples "1.snd") (mus-sound-framples "1a.snd"))))
	      (snd-display "~12T~A~28T~A~44T~A~56T(1/oboe, 1/1a)" "1.snd" "oboe.snd" "1a.snd")
	      (for-each
	       (lambda (name func)
		 (let ((ind (open-sound "1.snd"))
		       (start-time-1 (real-time)))
		   (set! (squelch-update ind 0) #t)
		   (do ((i 0 (+ i 1)))
		       ((= i tries))
		     (if (= (modulo i 10) 0) (revert-sound ind))
		     (func ind i))
		   (let ((mid-time-1 (real-time)))
		     (revert-sound ind)
		     (set! (squelch-update ind 0) #f)
		     (close-sound ind)
		     (let ((end-time-1 (real-time)))
		       (let ((ind (open-sound "oboe.snd"))
			     (start-time-2 (real-time)))
			 (set! (squelch-update ind 0) #t)
			 (do ((i 0 (+ i 1)))
			     ((= i tries))
			   (if (= (modulo i 10) 0) (revert-sound ind))
			   (func ind i))
			 (let ((mid-time-2 (real-time)))
			   (revert-sound ind)
			   (set! (squelch-update ind 0) #f)
			   (close-sound ind)
			   (let ((end-time-2 (real-time)))
			     (let ((ind (open-sound "1a.snd"))
				   (start-time (real-time)))
			       (set! (squelch-update ind 0) #t)
			       (do ((i 0 (+ i 1)))
				   ((= i tries))
				 (if (= (modulo i 10) 0) (revert-sound ind))
				 (func ind i))
			       (let ((mid-time (real-time)))
				 (revert-sound ind)
				 (set! (squelch-update ind 0) #f)
				 (close-sound ind)
				 (let ((end-time (real-time)))
				   (snd-display "~A:~12T~A~18T~A~28T~A~34T~A~44T~A~50T~A~56T(~,2F, ~,2F)" 
						name 
						
						(hundred (- mid-time-1 start-time-1)) (hundred (- end-time-1 mid-time-1))
						(hundred (- mid-time-2 start-time-2)) (hundred (- end-time-2 mid-time-2))
						(hundred (- mid-time start-time)) (hundred (- end-time mid-time))
						
						(* 1.0 (/ (+ (hundred (- mid-time-1 start-time-1)) (hundred (- end-time-1 mid-time-1)))
							  (max 1 (+ (hundred (- mid-time-2 start-time-2)) (hundred (- end-time-2 mid-time-2))))))
						(* 1.0 (/ (+ (hundred (- mid-time-1 start-time-1)) (hundred (- end-time-1 mid-time-1)))
							  (max 1 (+ (hundred (- mid-time start-time)) (hundred (- end-time mid-time)))))))))))))))))
	       '("scale" "set!" "env" "env-exp" "env-step" "delete" "insert" "pad" "mix-no-tag" "mix-tag" "mix-amp"
		 "mix-scale" "src-2" "src" "filter" "filter-sym" "f10" "f10sym" "clm" "reverse")
	       (list 
		(lambda (snd i)
		  (scale-channel (* i .01)))
		(lambda (snd i)
		  (set! (sample i) .5))
		(lambda (snd i)
		  (env-channel '(0 0 1 1)))
		(lambda (snd i)
		  (env-channel-with-base '(0 0 1 1) 32.0))
		(lambda (snd i)
		  (env-channel-with-base '(0 0 1 1) 0.0))
		(lambda (snd i)
		  (delete-sample (* 10 i)))
		(lambda (snd i)
		  (insert-sample (* 10 i) .5))
		(lambda (snd i)
		  (pad-channel (* 10 i) (* 10 i)))
		(lambda (snd i)
		  (mix "pistol.snd" (* i 10) 0 snd 0 #f))
		(lambda (snd i)
		  (mix "pistol.snd" (* i 10) 0 snd 0 #t))
		(lambda (snd i)
		  (let ((mx (car (mix "pistol.snd" (* i 100)))))
		    (set! (mix-amp mx) .01)))
		(lambda (snd i)
		  (mix "pistol.snd" (* i 100))
		  (scale-by .5)) ; scale-to before but that forces channel-maxamp which forces a full read which skews everything
		(lambda (snd i)
		  (src-sound 2.0)
		  (undo))
		(lambda (snd i)
		  (src-sound 2.01)
		  (undo))
		(lambda (snd i)
		  (filter-channel #r(.25 .5 .25 .1) 4))
		(lambda (snd i)
		  (filter-channel #r(.25 .5 .5 .25) 4))
		(lambda (snd i)
		  (filter-channel #r(.1 .2 .1 .1 .1 .1 .1 .2 .1 .1) 10))
		(lambda (snd i)
		  (filter-channel (make-float-vector 10 .1) 10))
		(lambda (snd i)
		  (clm-channel (make-two-zero .5 .5)))
		(lambda (snd i)
		  (reverse-channel (* i 10) (* i 100)))))))
	  
	  (let ((ind (new-sound "fmv.snd" :size 50)))
	    (set! *sinc-width* 10)
	    (set! (sample 20 ind 0) 0.5)
	    (let ((edpos (edit-position ind 0)))
	      
	      ;; -------- no-ops
	      (src-channel 1)
	      (if (not (= (edit-position ind 0) edpos)) (snd-display "src-channel 1 as no-op: ~A ~A" edpos (edit-position ind 0)))
	      (src-sound 1)
	      (if (not (= (edit-position ind 0) edpos)) (snd-display "src-sound 1 as no-op: ~A ~A" edpos (edit-position ind 0)))
	      (select-all)
	      (src-selection 1)
	      (if (not (= (edit-position ind 0) edpos)) (snd-display "src-selection 1 as no-op: ~A ~A" edpos (edit-position ind 0)))
	      
	      (filter-channel #r(1.0))
	      (if (not (= (edit-position ind 0) edpos)) (snd-display "filter-channel 1 as no-op: ~A ~A" edpos (edit-position ind 0)))
	      
	      (env-channel '(0 1 1 1))
	      (if (not (= (edit-position ind 0) edpos)) (snd-display "env-channel 1 as no-op: ~A ~A" edpos (edit-position ind 0)))
	      (env-sound '(0 1 1 1))
	      (if (not (= (edit-position ind 0) edpos)) (snd-display "env-sound 1 as no-op: ~A ~A" edpos (edit-position ind 0)))
	      (env-selection '(0 1 1 1))
	      (if (not (= (edit-position ind 0) edpos)) (snd-display "env-selection 1 as no-op: ~A ~A" edpos (edit-position ind 0)))
	      
	      (scale-channel 1)
	      (if (not (= (edit-position ind 0) edpos)) (snd-display "scale-channel 1 as no-op: ~A ~A" edpos (edit-position ind 0)))
	      (scale-by 1)
	      (if (not (= (edit-position ind 0) edpos)) (snd-display "scale-by 1 as no-op: ~A ~A" edpos (edit-position ind 0)))
	      (scale-selection-by 1)
	      (if (not (= (edit-position ind 0) edpos)) (snd-display "scale-selection 1 as no-op: ~A ~A" edpos (edit-position ind 0)))
	      
	      ;; -------- other special cases
	      (src-channel -1)
	      (reverse-channel)
	      (let ((diff (edit-difference ind 0 edpos (edit-position ind 0))))
		(if diff (snd-display "src -1 and reverse diff: ~A" diff)))
	      
	      (set! (edit-position ind 0) edpos)
	      (scale-by 2)
	      (filter-channel #r(2) 1 0 #f ind 0 edpos)
	      (let ((diff (edit-difference ind 0 (+ 1 edpos) (+ edpos 2))))
		(if diff (snd-display "scale and filter 2 diff: ~A" diff)))
	      
	      ;; -------- not no-ops!
	      (scale-channel 1.0 0 #f ind 0 edpos)
	      (let ((diff (edit-difference ind 0 edpos (edit-position ind 0))))
		(if diff (snd-display "edpos scale 1 diff: ~A" diff)))
	      (if (fneq (maxamp ind 0) 0.5) (snd-display "scale 1 of original: ~A" (maxamp ind 0)))
	      (if (= (edit-position ind 0) (+ edpos 2)) 
		  (snd-display "edpos scl copy opted out?")
		  (undo))
	      
	      (filter-channel #r(1) 1 0 #f ind 0 edpos)
	      (let ((diff (edit-difference ind 0 edpos (edit-position ind 0))))
		(if diff (snd-display "edpos flt 1 diff: ~A" diff)))
	      (if (= (edit-position ind 0) (+ edpos 2)) 
		  (snd-display "edpos flt copy opted out?")
		  (undo))
	      
	      (env-channel '(0 1 1 1) 0 #f ind 0 edpos)
	      (let ((diff (edit-difference ind 0 edpos (edit-position ind 0))))
		(if diff (snd-display "edpos env 1 diff: ~A" diff)))
	      (if (= (edit-position ind 0) (+ edpos 2)) 
		  (snd-display "edpos env copy opted out?")
		  (undo))
	      
	      (src-channel 1.0 0 #f ind 0 edpos)
	      (let ((diff (edit-difference ind 0 edpos (edit-position ind 0))))
		(if (and (pair? diff) (> (car diff) .0001)) (snd-display "edpos src 1 diff: ~A" diff)))
	      (if (= (edit-position ind 0) (+ edpos 2)) 
		  (snd-display "edpos src copy opted out?")
		  (undo)))
	    
	    (let ((edpos (edit-position ind 0))
		  (len (framples ind 0)))
	      (src-channel 0.5)
	      
	      (scale-channel 1.0 0 #f ind 0 edpos)
	      (let ((diff (edit-difference ind 0 edpos (edit-position ind 0))))
		(if diff (snd-display "1 edpos scale 1 diff: ~A" diff)))
	      (if (not (= (framples ind 0) len))
		  (snd-display "scl len edpos: ~A ~A" len (framples ind 0)))
	      (undo)
	      
	      (filter-channel #r(1) 1 0 #f ind 0 edpos)
	      (let ((diff (edit-difference ind 0 edpos (edit-position ind 0))))
		(if diff (snd-display "1 edpos flt 1 diff: ~A" diff)))
	      (if (not (= (framples ind 0) len))
		  (snd-display "flt len edpos: ~A ~A" len (framples ind 0)))
	      (undo)
	      
	      (env-channel '(0 1 1 1) 0 #f ind 0 edpos)
	      (let ((diff (edit-difference ind 0 edpos (edit-position ind 0))))
		(if diff (snd-display "1 edpos env 1 diff: ~A" diff)))
	      (if (not (= (framples ind 0) len))
		  (snd-display "env len edpos: ~A ~A" len (framples ind 0)))
	      (undo)
	      
	      (reverse-channel 0 #f ind 0 edpos)
	      (reverse-channel 0 #f ind 0)
	      (let ((diff (edit-difference ind 0 edpos (edit-position ind 0))))
		(if diff (snd-display "1 edpos rev 1 diff: ~A" diff)))
	      (if (not (= (framples ind 0) len))
		  (snd-display "rev len edpos: ~A ~A" len (framples ind 0)))
	      (undo 2)
	      
	      (src-channel 1.0 0 #f ind 0 edpos)
	      (let ((diff (edit-difference ind 0 edpos (edit-position ind 0))))
		(if (and (pair? diff) (> (car diff) .0001)) (snd-display "1 edpos src 1 diff: ~A" diff)))
	      (if (> (abs (- (framples ind 0) len)) 2)
		  (snd-display "src len edpos: ~A ~A" len (framples ind 0)))
	      (undo)
	      
	      (smooth-channel 0 len ind 0 edpos)
	      (if (not (= (framples ind 0) len))
		  (snd-display "smooth len edpos: ~A ~A" len (framples ind 0)))
	      (undo)
	      
	      (clm-channel (make-one-zero 1.0 0.0) 0 #f ind 0 edpos)
	      (let ((diff (edit-difference ind 0 edpos (edit-position ind 0))))
		(if diff (snd-display "1 edpos clm 1 diff: ~A" diff)))
	      (if (not (= (framples ind 0) len))
		  (snd-display "clm len edpos: ~A ~A" len (framples ind 0)))
	      (undo))
	    
	    ;; dur of 0 is ignored no matter what -- else I have a million special cases
	    ;;   -> insert 0 at other edpos, delete 0, change 0 (x|ramp-channel) (map? etc)
	    
	    (revert-sound ind)
	    (close-sound ind))
	  
	  ;; -------- reach back with partial edit
	  (let ((ind (new-sound "fmv.snd" :size 10)))
	    (as-one-edit
	     (lambda ()
	       (do ((i 0 (+ i 1)))
		   ((= i 10))
		 (set! (sample i) (* i .01)))))
	    
	    (let ((edpos (edit-position ind 0)))
	      (pad-channel 0 10 ind 0)
	      (pad-channel 20 10 ind 0)
	      (set! (samples 0 10 ind 0) (make-float-vector 10 .5))
	      (set! (samples 20 10 ind 0) (make-float-vector 10 -.75))
	      
	      (pad-channel 0 10 ind 0 edpos)
	      (if (not (= (framples ind 0) 20)) (snd-display "pad edpos len: ~A" (framples ind 0)))
	      (if (fneq (maxamp ind 0) .09) (snd-display "pad edpos max: ~A" (maxamp ind 0)))
	      (undo)
	      
	      (delete-samples 0 5 ind 0 edpos)
	      (if (not (= (framples ind 0) 5)) (snd-display "del edpos len: ~A" (framples ind 0)))
	      (if (fneq (maxamp ind 0) .09) (snd-display "del edpos max: ~A" (maxamp ind 0)))
	      (undo)
	      
	      (set! (samples 5 5 ind 0 #f "set" 0 edpos) (make-float-vector 5))
	      (if (not (= (framples ind 0) 10)) (snd-display "set edpos len: ~A" (framples ind 0)))
	      (if (fneq (maxamp ind 0) .04) (snd-display "set edpos max: ~A" (maxamp ind 0)))
	      (undo)
	      
	      (ramp-channel 0.0 1.0 0 5 ind 0 edpos)
	      (if (not (= (framples ind 0) 10)) (snd-display "rmp edpos len: ~A" (framples ind 0)))
	      (if (fneq (maxamp ind 0) .09) (snd-display "rmp edpos max: ~A" (maxamp ind 0)))
	      (undo)
	      
	      (xramp-channel 0.0 1.0 32.0 5 5 ind 0 edpos)
	      (if (not (= (framples ind 0) 10)) (snd-display "xrmp edpos len: ~A" (framples ind 0)))
	      (if (fneq (maxamp ind 0) .09) (snd-display "xrmp edpos max: ~A" (maxamp ind 0)))
	      (undo)
	      
	      (env-channel '(0 0 1 1) 0 5 ind 0 edpos)
	      (if (not (= (framples ind 0) 10)) (snd-display "env edpos len: ~A" (framples ind 0)))
	      (if (fneq (maxamp ind 0) .09) (snd-display "env edpos max: ~A" (maxamp ind 0)))
	      (undo)
	      
	      (smooth-channel 0 5 ind 0 edpos)
	      (if (not (= (framples ind 0) 10)) (snd-display "smooth edpos len: ~A" (framples ind 0)))
	      (if (fneq (maxamp ind 0) .09) (snd-display "smooth edpos max: ~A" (maxamp ind 0)))
	      (undo)
	      
	      (src-channel 0.5 0 5 ind 0 edpos)
	      (if (not (= (framples ind 0) 16)) (snd-display "src edpos len: ~A" (framples ind 0)))
	      (if (fneq (maxamp ind 0) .09) (snd-display "src edpos max: ~A" (maxamp ind 0)))
	      (undo)
	      
	      (reverse-channel 0 5 ind 0 edpos)
	      (if (not (= (framples ind 0) 10)) (snd-display "rev edpos len: ~A" (framples ind 0)))
	      (if (fneq (maxamp ind 0) .09) (snd-display "rev edpos max: ~A" (maxamp ind 0)))
	      (undo)
	      
	      (filter-channel #r(.1 .2 .1) 3 0 5 ind 0 edpos #t) ; truncate
	      (if (not (= (framples ind 0) 10)) (snd-display "flt edpos len: ~A" (framples ind 0)))
	      (if (fneq (maxamp ind 0) .09) (snd-display "flt edpos max: ~A" (maxamp ind 0)))
	      (undo)
	      
	      (scale-channel 1.5 0 5 ind 0 edpos)
	      (if (not (= (framples ind 0) 10)) (snd-display "scl edpos len: ~A" (framples ind 0)))
	      (if (fneq (maxamp ind 0) .09) (snd-display "scl edpos max: ~A" (maxamp ind 0)))
	      (undo)
	      
	      (close-sound ind)))
	  
	  (let ((ind (new-sound "fmv.snd" :size 20)))
	    (map-channel (lambda (y) 1.0))
	    (let ((edpos (edit-position ind 0)))
	      (delete-samples 5 10)
	      (delete-samples 15 5 ind 0 edpos)
	      (if (not (= (framples ind 0) 15)) (snd-display "delete-samples edpos len: ~A" (framples ind 0)))
	      (undo)
	      (float-vector->channel (make-float-vector 5 0.5) 15 5 ind 0 edpos)
	      (if (not (= (framples ind 0) 20)) (snd-display "delete-samples edpos len: ~A" (framples ind 0)))
	      (if (not (mus-arrays-equal? (channel->float-vector 10 10) #r(1.0 1.0 1.0 1.0 1.0 0.5 0.5 0.5 0.5 0.5)))
		  (snd-display "set samples edpos: ~A" (channel->float-vector 10 10)))
	      (undo)
	      (env-channel '(0 0 1 1) 0 #f ind 0 edpos)
	      (if (not (= (framples ind 0) 20)) (snd-display "env edpos len: ~A" (framples ind 0)))
	      (if (not (mus-arrays-equal? (channel->float-vector 0 20) 
					  #r(0.0 0.053 0.105 0.158 0.211 0.263 0.316 0.368 0.421 0.474 0.526 0.579 0.632 0.684 0.737 0.789 0.842 0.895 0.947 1.000)))
		  (snd-display "env edpos: ~A" (channel->float-vector 0 20)))
	      (undo)
	      (close-sound ind)))
	  
	  
	  (let ((ind (new-sound "fmv.snd" :size 20)))
	    (set! (sample 5) 1.0)
	    (filter-channel #r(1.0 0.5))
	    (filter-channel #r(1.0 0.5))
	    (let ((data (channel->float-vector 0 20)))
	      (undo 2)
	      (filter-channel (convolve-coeffs #r(1.0 0.5) #r(1.0 0.5)))
	      (let ((vdata (channel->float-vector 0 20)))
		(if (not (mus-arrays-equal? data vdata)) 
		    (snd-display "filter convolved: ~%  standard: ~A~%   virtual: ~A~%" data vdata)))
	      (undo))
	    (let ((v1 (make-float-vector 8))
		  (v2 (make-float-vector 5)))
	      (do ((i 0 (+ i 1))) ((= i 8)) (float-vector-set! v1 i (random 1.0)))
	      (do ((i 0 (+ i 1))) ((= i 5)) (float-vector-set! v2 i (random 1.0)))
	      (filter-channel v1)
	      (filter-channel v2)
	      (let ((data (channel->float-vector 0 20)))
		(undo 2)
		(filter-channel (convolve-coeffs v1 v2))
		(let ((vdata (channel->float-vector 0 20)))
		  (if (not (mus-arrays-equal? data vdata)) 
		      (snd-display "random filter convolved: ~%  standard: ~A~%   virtual: ~A~%" data vdata)))
		(undo)))
	    (let ((v1 (make-float-vector 18))
		  (v2 (make-float-vector 15)))
	      (do ((i 0 (+ i 1))) ((= i 18)) (float-vector-set! v1 i (random 1.0)))
	      (do ((i 0 (+ i 1))) ((= i 15)) (float-vector-set! v2 i (random 1.0)))
	      (filter-channel v1)
	      (filter-channel v2)
	      (let ((data (channel->float-vector 0 20)))
		(undo 2)
		(filter-channel (convolve-coeffs v1 v2))
		(let ((vdata (channel->float-vector 0 20)))
		  (if (not (mus-arrays-equal? data vdata)) 
		      (snd-display "big random filter convolved: ~%  standard: ~A~%   virtual: ~A~%" data vdata)))
		(undo)))
	    (close-sound ind))
	  
	  (let ((ind (new-sound "fmv.snd" :size 100)))
	    (set! (sample 5) .5)
	    (set! (sample 85) .5)
	    
	    (src-channel -1.001)
	    (src-channel '(0 -1.0 1 -1.0) 0 #f ind 0 2)
	    (let ((dis (edit-distance ind 0 3 4)))
	      (if (> dis .2) (snd-display "src-channel -1, distance: ~A" dis)))
	    (undo 2)
	    
	    (src-channel 1.001)
	    (src-channel '(0 1.0 1 1.0) 0 #f ind 0 2)
	    (let ((dis (edit-distance ind 0 3 4)))
	      (if (> dis .2) (snd-display "src-channel 1, distance: ~A" dis)))
	    (undo 2)
	    
	    (for-each
	     (lambda (rate)
	       (src-channel rate)
	       (src-channel (list 0 rate 1 rate) 0 #f ind 0 2)
	       (let ((dis (edit-distance ind 0 3 4)))
		 (if (> dis .2) (snd-display "src-channel ~A, distance: ~A" rate dis)))
	       (undo 2))
	     '(2.0 -2.0 0.5 -0.5 1.5 -1.5 3.0 -3.0 0.2 -0.2))
	    
	    
	    (src-sound -1.001)
	    (src-sound '(0 -1.0 1 -1.0) 1.0 ind 0 2)
	    (let ((dis (edit-distance ind 0 3 4)))
	      (if (> dis .2) (snd-display "src-sound -1, distance: ~A" dis)))
	    (undo 2)
	    
	    (src-sound 1.001)
	    (src-sound '(0 1.0 1 1.0) 1.0 ind 0 2)
	    (let ((dis (edit-distance ind 0 3 4)))
	      (if (> dis .2) (snd-display "src-sound 1, distance: ~A" dis)))
	    (undo 2)
	    
	    (for-each
	     (lambda (rate)
	       (src-sound rate)
	       (src-sound (list 0 rate 1 rate) 1.0 ind 0 2)
	       (let ((dis (edit-distance ind 0 3 4)))
		 (if (> dis .2) (snd-display "src-sound ~A, distance: ~A" rate dis)))
	       (undo 2))
	     '(2.0 -2.0 0.5 -0.5 1.5 -1.5 3.0 -3.0 0.2 -0.2))
	    
	    (close-sound ind))
	  
	  
	  ;; additional coverage tests
	  
	  (let ((ind (new-sound "test.snd" :size 10)))
	    (float-vector->channel (make-float-vector 10 .4))
	    (make-selection 3 7) ; beg end just for confusion
	    (env-selection '(0 0.5 1 0.5))
	    (let ((data (channel->float-vector)))
	      (if (not (mus-arrays-equal? data #r(.4 .4 .4 .2 .2 .2 .2 .2 .4 .4)))
		  (snd-display "env-selection constant: ~A" data)))
	    (undo)
	    (let ((edpos (edit-position ind 0)))
	      (smooth-channel 10 10 ind 0)
	      (if (not (= (edit-position ind 0) edpos))
		  (snd-display "smooth past end: ~A ~A" (edit-position ind 0) edpos)))
	    
	    (let ((ctr 0))
	      (map-channel (lambda (y) (set! ctr (+ ctr 1)) (or (> ctr 3) (* y 2)))))
	    (if (not (= (framples ind 0) 3)) 
		(snd-display "map-channel -> #t at 3: ~A" (framples ind 0))
		(if (not (mus-arrays-equal? (channel->float-vector) #r(0.8 0.8 0.8)))
		    (snd-display "map-channel #t result: ~A" (channel->float-vector))))
	    
	    (undo)
	    (let ((ctr 0))
	      (map-channel (lambda (y) (set! ctr (+ ctr 1)) (if (= ctr 3) (make-float-vector 5 .1) (* y .5)))))
	    (if (not (= (framples ind 0) 14)) 
		(snd-display "map-channel -> float-vector at 3: ~A" (framples ind 0))
		(if (not (mus-arrays-equal? (channel->float-vector) #r(0.200 0.200 0.100 0.100 0.100 0.100 0.100 0.200 0.200 0.200 0.200 0.200 0.200 0.200)))
		    (snd-display "map-channel float-vector result: ~A" (channel->float-vector))))
	    
	    (undo)
	    (let ((data (make-float-vector 2)))
	      (map-channel (lambda (y) (float-vector-set! data 0 y) data)))
	    (if (not (= (framples ind 0) 20))
		(snd-display "map-channel -> float-vector: ~A" (framples ind 0))
		(if (not (mus-arrays-equal? (channel->float-vector) 
					    #r(0.400 0.0 0.400 0.0 0.400 0.0 0.400 0.0 0.400 0.0 0.400 0.0 0.400 0.0 0.400 0.0 0.400 0.0 0.400 0.000)))
		    (snd-display "map-channel float-vector result: ~A" (channel->float-vector))))
	    (undo)
	    
	    (set! (amp-control ind) 2.0)
	    (apply-controls ind 1 0)
	    (if (> (abs (- (maxamp ind 0) .8)) .01) (snd-display "apply-controls 10: ~A" (channel->float-vector)))
	    (undo)
	    (set! (amp-control ind) 2.0)
	    (apply-controls ind 1 5)
	    (if (not (mus-arrays-equal? (channel->float-vector 0 5) (make-float-vector 5 0.4)))
		(snd-display "apply controls from 5: ~A" (channel->float-vector)))
	    (if (ffneq (sample 5) .8) (snd-display "apply-controls at 5: ~A" (sample 5)))
	    (let ((tag (catch 'no-such-edit
			 (lambda ()
			   (save-sound-as "nope.snd" :edit-position 21))
			 (lambda args (car args)))))
	      (if (not (eq? tag 'no-such-edit)) (snd-display "save-sound-as at bad edpos: ~A" tag)))
	    (let ((tag (catch 'no-such-file
			 (lambda ()
			   (channel-amp-envs "/baddy/hiho"))
			 (lambda args (car args)))))
	      (if (not (eq? tag 'no-such-file)) (snd-display "channel-amp-envs bad file: ~A" tag)))
	    
	    (close-sound ind))
	  
	  
	  (let ((ind (open-sound "oboe.snd")))
	    (let ((ctr 0))
	      (map-channel (lambda (y) (or (> (set! ctr (+ ctr 1)) 3) (* y 2)))))
	    (if (not (= (framples ind 0) 3)) 
		(snd-display "map-channel oboe -> #t at 3: ~A" (framples ind 0))
		(if (not (mus-arrays-equal? (channel->float-vector) #r(0.0 -.001 -.001)))
		    (snd-display "map-channel #t oboe result: ~A" (channel->float-vector))))
	    
	    (undo)
	    (let ((ctr 0))
	      (map-channel (lambda (y) (if (= (set! ctr (+ ctr 1)) 3) (make-float-vector 5 .1) (* y .5)))))
	    (if (not (= (framples ind 0) 50832))
		(snd-display "map-channel oboe -> float-vector at 3: ~A" (framples ind 0))
		(if (not (mus-arrays-equal? (channel->float-vector 0 10) #r(0.0 0.0 0.100 0.100 0.100 0.100 0.100 0.0 0.0 -0.000)))
		    (snd-display "map-channel float-vector result: ~A" (channel->float-vector 0 10))))
	    
	    (undo)
	    (let ((data (make-float-vector 2)))
	      (map-channel (lambda (y) (set! (data 0) y) data)))
	    (if (not (= (framples ind 0) 101656))
		(snd-display "map-channel oboe -> float-vector: ~A" (framples ind 0))
		(if (not (mus-arrays-equal? (channel->float-vector 0 10) (make-float-vector 10)))
		    (snd-display "map-channel float-vector result: ~A" (channel->float-vector 0 10))))
	    (revert-sound)
	    (close-sound ind))
	  
	  (let ((ind (open-sound "2.snd")))
	    (ramp-channel 0.9 1.0)
	    (ramp-channel 0.9 1.0)
	    (xramp-channel 0.9 1.0 32.0)
	    (xramp-channel 0.9 1.0 32.0)
	    (mix-float-vector #r(.01 .02) 10000 ind 0 #t)
	    (set! (sync ind) 1)
	    (let ((mxs (maxamp ind #t)))
	      (env-sound '(0 .25 1 0.5))
	      (let ((mxs1 (maxamp ind #t)))
		(if (or (fneq (car mxs) (* 2.0 (car mxs1)))
			(fneq (cadr mxs) (* 2.0 (cadr mxs1))))
		    (snd-display "env-sound sync'd maxes: ~A -> ~A" mxs mxs1)))
	      (undo 1))
	    (close-sound ind))
	  
	  
	  (let ((ind (new-sound :channels 2 :size 10 :comment "new-sound for ramp2-xramp2")))
	    (map-channel (lambda (y) 1.0))
	    (ramp-channel 0.9 1.0)
	    (ramp-channel 0.9 1.0)
	    (xramp-channel 0.9 1.0 32.0)
	    (xramp-channel 0.9 1.0 32.0)
	    (mix-float-vector #r(.1 .2) 1 ind 0 #t)	  
	    (set! (sync ind) 1)
	    (let ((mxs (maxamp ind #t)))
	      (env-sound '(0 .25 1 0.5))
	      (let ((mxs1 (maxamp ind #t)))
		(if (or (fneq (car mxs) (* 2.0 (car mxs1)))
			(fneq (cadr mxs) (* 2.0 (cadr mxs1))))
		    (snd-display "env-sound sync'd maxes buf: ~A -> ~A" mxs mxs1)))
	      (undo 1))
	    (let ((name (file-name ind)))
	      (if (not (= (srate ind) *default-output-srate*))
		  (snd-display "new-sound default srate: ~A ~A" (srate ind) *default-output-srate*))
	      (close-sound ind)
	      (if (file-exists? name)
		  (delete-file name)
		  (snd-display "new-sound temp? ~A" name))))
	  
	  (let ((ind (new-sound "test.snd" :size 40000)))
	    (clm-channel (make-triangle-wave 10.0 0.5))
	    (src-channel 2)
	    
	    (let ((ind1 (new-sound "test.snd" :size 40000)))
	      (clm-channel (make-triangle-wave 10.0 0.5))
	      (src-channel 2.00001)
	      
	      (let ((dist (channel-distance ind 0 ind1 0)))
		(if (> dist 0.5)
		    (snd-display "src 2/2.0001: ~A" dist)))
	      
	      (close-sound ind)
	      (close-sound ind1)))
	  
	  (let-temporarily ((*sinc-width* 10))
	    
	    (let ((res (new-sound :size 10)))
	      (set! (sample 3) .5)
	      (src-channel 2.0)
	      (let ((v (channel->float-vector)))
		(if (not (vmus-arrays-equal? v #r(-0.05016523320247118 0.1581800948824515 0.1581800948824515 
							     -0.05016523320247118 0.02716944826115516 -0.01652926966015632)))
		    (snd-display "src 2, 10 3 10: ~A" v)))
	      (close-sound res))
	    
	    (let ((res (new-sound :size 10)))
	      (set! (sample 2) .5)
	      (src-channel 2.0)
	      (let ((v (channel->float-vector)))
		(if (not (vmus-arrays-equal? v #r(0.0 0.25 0.0 0.0 0.0 0.0)))
		    (snd-display "src 2, 10 2 10: ~A" v)))
	      (close-sound res))
	    
	    (let ((res (new-sound :size 10)))
	      (set! (sample 0) .5)
	      (src-channel 2.0)
	      (let ((v (channel->float-vector)))
		(if (not (vmus-arrays-equal? v #r(0.25 0.0 0.0 0.0 0.0 0.0)))
		    (snd-display "src 2, 10 0 10: ~A" v)))
	      (close-sound res))
	    
	    (let ((res (new-sound :size 11)))
	      (set! (sample 3) .5)
	      (src-channel 2.0)
	      (let ((v (channel->float-vector)))
		(if (not (vmus-arrays-equal? v #r(-0.05016523320247118 0.1581800948824515 0.1581800948824515 
							     -0.05016523320247118 0.02716944826115516 -0.01652926966015632 0.01022512563738671)))
		    (snd-display "src 2, 11 3 10: ~A" v)))
	      (close-sound res))
	    
	    (let ((res (new-sound :size 11)))
	      (set! (sample 2) .5)
	      (src-channel 2.0)
	      (let ((v (channel->float-vector)))
		(if (not (vmus-arrays-equal? v #r(0.0 0.25 0.0 0.0 0.0 0.0 0.0)))
		    (snd-display "src 2, 11 2 10: ~A" v)))
	      (close-sound res))
	    
	    (let ((res (new-sound :size 11)))
	      (set! (sample 0) .5)
	      (src-channel 2.0)
	      (let ((v (channel->float-vector)))
		(if (not (vmus-arrays-equal? v #r(0.25 0.0 0.0 0.0 0.0 0.0 0.0)))
		    (snd-display "src 2, 11 0 10: ~A" v)))
	      (close-sound res))
	    
	    (let ((res (new-sound :size 40)))
	      (do ((i 0 (+ i 1)))
		  ((= i 20))
		(set! (sample i) (* i .05))
		(set! (sample (- 39 i)) (* i .05)))
	      (src-channel 2.0)
	      (let ((v (channel->float-vector)))
		(if (not (vmus-arrays-equal? v #r(0.01198528796961999 0.1035793306415383 0.2059748594814547 0.3060708098272395 0.4072307780331241 
							     0.5077603318367317 0.6062448605128621 0.7086656575233007 0.8045885470214085 0.9128440616541418 
							     0.9536620711423869 0.8562080426776515 0.7579855746854125 0.6566287955350736 0.5575138524566664 
							     0.4569842986530586 0.3574772574131896 0.2546643622412894 0.1572853567216201 0.04987330456145658 
							     -0.0009027286222166014)))
		    (format *stderr* "src 2, 40 0 10: ~A~%" v)))
	      (close-sound res))
	    
	    (set! *sinc-width* 11)
	    
	    (let ((res (new-sound :size 15)))
	      (set! (sample 3) .5)
	      (src-channel 2.0)
	      (let ((v (channel->float-vector)))
		(if (not (vmus-arrays-equal? v #r(-0.05103248958541851 0.1584755057631961 0.1584755057631961 
							     -0.05103248958541851 0.02854464095499105 -0.01828991864619797 0.01222560572178551 -0.008180460967128276 0.0)))
		    (snd-display "src 2, 15 3 11: ~A" v)))
	      (close-sound res))
	    
	    (let ((res (new-sound :size 15)))
	      (set! (sample 0) .5)
	      (src-channel 2.0)
	      (let ((v (channel->float-vector)))
		(if (not (vmus-arrays-equal? v #r(0.25 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0)))
		    (snd-display "src 2, 15 0 11: ~A" v)))
	      (close-sound res)))
	  
	  (let-temporarily ((*sinc-width* 10))
	    
	    (let ((res (new-sound :size 10)))
	      (set! (sample 3) .5)
	      (src-channel 0.5)
	      (let ((v (channel->float-vector)))
		(if (not (vmus-arrays-equal? v #r(0.0 0.05433889652231032 0.0 -0.1003304664049424 0.0 0.316360189764903 0.5 
							     0.316360189764903 0.0 -0.1003304664049424 0.0 0.05433889652231032 0.0 -0.03305853932031265 0.0 
							     0.02045025127477342 0.0 -0.01220523861007159 0.0 0.006688908032246622 0.0)))
		    (format *stderr* "src 1/2, 10 3 10: ~A~%" v)))
	      (close-sound res))
	    
	    (let ((res (new-sound :size 10)))
	      (set! (sample 2) .5)
	      (src-channel 0.5)
	      (let ((v (channel->float-vector)))
		(if (not (vmus-arrays-equal? v #r(0.0 -0.1003304664049424 0.0 0.316360189764903 0.5 0.316360189764903 0.0 -0.1003304664049424 
							     0.0 0.05433889652231032 0.0 -0.03305853932031265 0.0 0.02045025127477342 0.0 
							     -0.01220523861007159 0.0 0.006688908032246622 0.0 -0.003110640428161881 0.0)))
		    (format *stderr* "src 1/2, 10 2 10: ~A~%" v)))
	      (close-sound res))
	    
	    (let ((res (new-sound :size 10)))
	      (set! (sample 0) .5)
	      (src-channel 0.5)
	      (let ((v (channel->float-vector)))
		(if (not (vmus-arrays-equal? v #r(0.5 0.316360189764903 0.0 -0.1003304664049424 0.0 0.05433889652231032 0.0 -0.03305853932031265 
							     0.0 0.02045025127477342 0.0 -0.01220523861007159 0.0 0.006688908032246622 0.0 
							     -0.003110640428161881 0.0 0.001022072692939124 0.0 -0.000103644775079492 0.0)))
		    (format *stderr* "src 1/2, 10 0 10: ~A~%" v)))
	      (close-sound res))
	    
	    
	    (let ((res (new-sound :size 11)))
	      (set! (sample 3) .5)
	      (src-channel 0.5)
	      (let ((v (channel->float-vector)))
		(if (not (vmus-arrays-equal? v #r(0.0 0.05433889652231032 0.0 -0.1003304664049424 0.0 0.316360189764903 0.5 0.316360189764903 
							     0.0 -0.1003304664049424 0.0 0.05433889652231032 0.0 -0.03305853932031265 0.0 0.02045025127477342 
							     0.0 -0.01220523861007159 0.0 0.006688908032246622 0.0 -0.003110640428161881 0.0)))
		    (format *stderr* "src 1/2, 11 3 10: ~A~%" v)))
	      (close-sound res))
	    
	    (let ((res (new-sound :size 11)))
	      (set! (sample 2) .5)
	      (src-channel 0.5)
	      (let ((v (channel->float-vector)))
		(if (not (vmus-arrays-equal? v #r(0.0 -0.1003304664049424 0.0 0.316360189764903 0.5 0.316360189764903 0.0 -0.1003304664049424 
							     0.0 0.05433889652231032 0.0 -0.03305853932031265 0.0 0.02045025127477342 0.0 -0.01220523861007159 
							     0.0 0.006688908032246622 0.0 -0.003110640428161881 0.0 0.001022072692939124 0.0)))
		    (format *stderr* "src 1/2, 11 2 10: ~A~%" v)))
	      (close-sound res))
	    
	    (let ((res (new-sound :size 11)))
	      (set! (sample 0) .5)
	      (src-channel 0.5)
	      (let ((v (channel->float-vector)))
		(if (not (vmus-arrays-equal? v #r(0.5 0.316360189764903 0.0 -0.1003304664049424 0.0 0.05433889652231032 0.0 -0.03305853932031265 
							     0.0 0.02045025127477342 0.0 -0.01220523861007159 0.0 0.006688908032246622 0.0 
							     -0.003110640428161881 0.0 0.001022072692939124 0.0 -0.000103644775079492 0.0 0.0 0.0)))
		    (format *stderr* "src 1/2, 11 0 10: ~A~%" v)))
	      (close-sound res))
	    
	    
	    (let ((res (new-sound :size 40)))
	      (do ((i 0 (+ i 1)))
		  ((= i 20))
		(set! (sample i) (* i .05))
		(set! (sample (- 39 i)) (* i .05)))
	      (src-channel 0.5)
	      (let ((v (channel->float-vector)))
		(if (not (vmus-arrays-equal? v #r(0.0 0.02056010532402247 0.05 0.07720130317537323 0.1 0.1238094543862298 0.15 0.1758514952493174 
							     0.2 0.2245876821803736 0.25 0.2753688942389073 0.3 0.3249295824364337 0.35 0.3751591614371849 
							     0.4 0.4250776763951197 0.45 0.4750983986223486 0.5 0.5251191208495776 0.55 0.5750480002850203 
							     0.60000000 0.6251857364939857 0.65 0.6749656459425423 0.70000000 0.7252971884488815 
							     0.75 0.7748042296887507 0.8 0.8255720997331736 0.85000000 0.8742119340573964 0.9 
							     0.9274509253698831 0.95000000 0.9590869443463733 0.95000000 0.9274509253698828 
							     0.9 0.8742119340573966 0.85000000 0.8255720997331734 0.8 0.7748042296887506 0.75 
							     0.7252971884488812 0.70000000 0.6749656459425423 0.65 0.6251857364939858 
							     0.60000000 0.5750480002850203 0.55 0.5251191208495776 0.5 0.4750983986223486 
							     0.45 0.4250776763951198 0.4 0.3751591614371849 0.35 0.3249295824364337 0.3
							     0.2753688942389073 0.25 0.2245876821803736 0.2 0.1758514952493173 0.15 0.1238094543862298
							     0.1 0.07720130317537324 0.05 0.02056010532402247 0.0 -0.004445073550837984 0.0)))
		    (format *stderr* "src 1/2, 40 0 10: ~A~%" v)))
	      (close-sound res))
	    
	    (set! *sinc-width* 11)
	    
	    (let ((res (new-sound :size 15)))
	      (set! (sample 3) .5)
	      (src-channel 0.5)
	      (let ((v (channel->float-vector)))
		(if (not (vmus-arrays-equal? v #r(0.0 0.05588873297652781 0.0 -0.1013169884822853 0.0 0.3166955736757819 0.5 0.3166955736757819 
							     0.0 -0.1013169884822853 0.0 0.05588873297652781 0.0 -0.03503207135776369 0.0 0.02267085373675465 
							     0.0 -0.01446863119016991 0.0 0.008794782253203336 0.0 -0.004875864375201019 0.0 0.002288656235197179
							     0.0 -0.0007570986863940245 0.0 7.729542250127452e-05 0.0 0.0 0.0)))
		    (format *stderr* "src 1/2, 15 3 11: ~A~%" v)))
	      (close-sound res))
	    
	    (let ((res (new-sound :size 15)))
	      (set! (sample 0) .5)
	      (src-channel 0.5)
	      (let ((v (channel->float-vector)))
		(if (not (vmus-arrays-equal? v #r(0.5 0.3166955736757819 0.0 -0.1013169884822853 0.0 0.05588873297652781 0.0 -0.03503207135776369 0.0 
							     0.02267085373675465 0.0 -0.01446863119016991 0.0 0.008794782253203336 0.0 -0.004875864375201019 0.0 
							     0.002288656235197179 0.0 -0.0007570986863940245 0.0 7.729542250127452e-05 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0)))
		    (format *stderr* "src 1/2, 15 0 11: ~A~%" v)))
	      (close-sound res))
	    
	    (set! *sinc-width* 10)
	    
	    (let ((res (new-sound :size 10)))
	      (set! (sample 2) .5)
	      (src-channel 1.5)
	      (let ((v (channel->float-vector)))
		(if (not (vmus-arrays-equal? v #r(-0.0659173000292574 0.2750218141864232 0.1361775290259087 -0.05140008051946586 0.02873817799080515 
							     -0.01761592377597271 0.01086818222156537 -0.006418849681280971)))
		    (format *stderr* "src 1.5, 10 0 10: ~A~%" v)))
	      (close-sound res))
	    
	    (let ((res (new-sound :size 10)))
	      (set! (sample 2) .5)
	      (src-channel 0.3)
	      (let ((v (channel->float-vector)))
		(if (not (vmus-arrays-equal? v #r(-2.309626927862667e-14 -0.07046687722856798 -0.1029821798386912 -0.04339187529883121 
							     0.1151049838606023 0.316360189764903 0.4672831482919799 0.4916944808321784 0.3769307110649516 
							     0.1817344234767786 1.953289539319582e-14 -0.09498013189693179 -0.08875244041152466 
							     -0.0236470298331755 0.03764309466867966 0.05433889652231032 0.02735343920407904 
							     -0.01239124709348501 -0.03298325840652785 -0.02431019463203471 4.869902458307762e-14 
							     0.01823801988763548 0.01851483195191724 0.005176164589977362 -0.008430282938941011 
							     -0.01220523861007159 -0.006058987580643592 0.002667220356124145 0.006794601943645224 
							     0.004720812682785585 -3.100277189828097e-14 -0.002989527299513507 -0.002701674743876624 
							     -0.0006539461337230524 0.0008891857488267552)))
		    (format *stderr* "src 0.3, 10 0 10: ~A~%" v)))
	      (close-sound res))
	    
	    (let ((res (new-sound :size 10))
		  (e (make-env '(0 1 1 2) :length 11)))
	      (set! (sample 1) .5)
	      (set! (sample 8) .5)
	      (src-channel e)
	      (let ((v (channel->float-vector)))
		(if (not (vmus-arrays-equal? v #r(3.511360236100833e-14 0.499999999999969 0.03245693012152732 -0.04426423670248926
							     0.05693627592759216 -0.06869987735399859 0.1364034106143399 0.2654607053632132 -0.04771168369895742)))
		    (format *stderr* "src e, 10 0 10: ~A~%" v)))
	      (close-sound res)))
	  
	  (let ((ind (new-sound "test.snd" :size 40000)))
	    (clm-channel (make-triangle-wave 10.0 0.5))
	    (src-channel 0.5)
	    
	    (let ((ind1 (new-sound "test.snd" :size 40000)))
	      (clm-channel (make-triangle-wave 10.0 0.5))
	      (src-channel 0.50001)
	      
	      (let ((dist (channel-distance ind 0 ind1 0)))
		(if (> dist 0.5)
		    (snd-display "src 0.5/0.5001: ~A" dist)))
	      
	      (close-sound ind)
	      (close-sound ind1))))))))



;;; ---------------- test 17: dialogs and graphics ----------------

(require snd-draw.scm)
(if with-gui (require snd-musglyphs.scm))
(require snd-enved.scm)

(define (snd_test_17)
  
  (when (and with-gui
	     (provided? 'snd-motif))
    (require snd-musglyphs.scm)
    (hook-push after-graph-hook (lambda (hook) (display-previous-edits (hook 'snd) (hook 'chn))))
    (hook-push lisp-graph-hook 
	       (lambda (hook)
		 (let ((snd (hook 'snd))
		       (chn (hook 'chn)))
		   (set! (hook 'result) 
			 (lambda ()
			   (draw-string "hi" 
					(x->position .5 snd chn lisp-graph) 
					(y->position .5 snd chn lisp-graph)
					snd chn lisp-graph #f))))))

    (let ((-> (let ((+documentation+ "draw an arrow pointing (from the left) at the point (x0 y0)"))
		(lambda (x0 y0 size snd chn cr)
		  (let ((points (make-vector 8)))
		    
		    (let ((x x0) 
			  (y y0)
			  (point (lambda (i x y)
				   (set! (points (* i 2)) x)
				   (set! (points (+ (* i 2) 1)) y))))
		      (point 0 x y)
		      (point 1 (- x (* 2 size)) (- y size))
		      (point 2 (- x (* 2 size)) (+ y size))
		      (point 3 x y)
		      (fill-polygon points snd chn time-graph cr))
		    
		    (fill-rectangle (- x0 (* 4 size)) 
				    (floor (- y0 (* .4 size)))
				    (* 2 size)
				    (floor (* .8 size))
				    snd chn time-graph #f cr))))))
      (let ((ind (open-sound "oboe.snd"))
	    (wids (channel-widgets))
	    (wids1 (channel-widgets (selected-sound)))
	    (wids2 (channel-widgets (selected-sound) (selected-channel))))
	(do ((i 1 (+ i 1)))
	    ((= i 4))
	  (scale-by 0.5)
	  (set! (x-bounds) (list 0 (* i .3))))
	(revert-sound ind)
	(draw-bass-clef 100 100 100 0 ind 0)
	(update-time-graph ind 0)
	(draw-fermata 200 100 60 0 ind 0)
	(when (provided? 'snd-motif)
	  (draw-line 100 100 200 200 ind 0 time-graph #f)
	  (draw-dot 300 300 10 ind 0 time-graph #f)
	  (draw-string "hiho" 20 20 ind 0 time-graph #f)
	  (draw-dots #i(25 25 50 50 100 100) 10 ind 0 time-graph #f)
	  (-> 100 50 10 ind 0 #f)
	  (fill-rectangle 20 20 100 100 ind 0 time-graph #f #f))
	(update-time-graph ind 0)
					;(fill-rectangle 20 20 100 100 ind 0 time-graph #t)
	(set! (hook-functions after-graph-hook) ())
	(set! (hook-functions lisp-graph-hook) ())
	
	(let ((ind (open-sound "oboe.snd")))
	  (set! (time-graph? ind 0) #f)
	  (graph (list #r(0 1 2) #r(3 2 1) #r(1 2 3) #r(1 1 1) #r(0 1 0) #r(3 1 2)))
	  (update-lisp-graph)
	  (hook-push lisp-graph-hook (lambda (hook)
				       (set! (hook 'result) (list *basic-color* *zoom-color* *data-color* *selected-data-color* *mix-color*))))
	  (graph (list #r(0 1 2) #r(3 2 1) #r(1 2 3) #r(1 1 1) #r(0 1 0) #r(3 1 2)))
	  (update-lisp-graph)
	  (set! (hook-functions lisp-graph-hook) ())
	  (close-sound ind))
	
	(let ((ind1 (open-sound "2.snd")))
	  (let ((wids3 (channel-widgets ind1 0))
		(wids4 (channel-widgets ind1 1)))
	    (if (or (not (pair? wids))
		    (not (pair? wids3))
		    (and (provided? 'snd-motif)
			 (not (= (length wids1) 11 (length wids2)))))
		(snd-display "channel-widgets confused: ~A ~A ~A ~A ~A" wids wids1 wids2 wids3 wids4)))
	  (hide-widget (car (channel-widgets)))
	  (show-widget (car (channel-widgets)))
	  (close-sound ind1))
	(close-sound ind)))
    
    (start-enveloping)
    (let ((nind (open-sound "oboe.snd")))
      (if (not (equal? (channel-envelope nind 0) '(0.0 1.0 1.0 1.0)))
	  (snd-display "channel-envelope: ~A?" (channel-envelope nind 0)))
      (set! (channel-envelope nind 0) '(0 0 1 1 2 0))
      (if (not (equal? (channel-envelope nind 0) '(0 0 1 1 2 0)))
	  (snd-display "set channel-envelope: ~A?" (channel-envelope nind 0)))
      (close-sound nind)
      (stop-enveloping)))
  (reset-all-hooks))


;;; ---------------- test 18: save and restore ----------------

(require snd-fade.scm)

(define* (clm-channel-test snd chn) ; edit-list->function wants this to be global??
  (clm-channel (make-two-zero 1 -1) 0 #f snd chn #f #f "clm-channel-test"))

(define* (insert-float-vector v (beg 0) dur snd chn edpos)
  (if (not (float-vector? v))
      (error 'wrong-type-arg "insert-float-vector: ~A" v)
      (let ((len (or dur (length v))))
	(insert-samples beg len v snd chn edpos #f (format #f "insert-float-vector ~A ~A ~A" (float-vector->string v) beg dur)))))

(define (snd_test_18)
  
  (let ((nind (open-sound "oboe.snd")))
    (add-mark 123)
    (delete-sample 12)
    (set! (x-bounds) (list .2 .4))
    (let ((old-bounds (x-bounds)))
      (set! *show-axes* show-all-axes)
      (set! *transform-graph-type* graph-as-sonogram)
      (set! *speed-control-style* speed-control-as-ratio)
      (set! *channel-style* channels-superimposed)
      (set! *enved-target* enved-srate)
      (set! (sound-property :hi nind) "hi")
      (set! (sound-property 'ho nind) 1234)
      (set! (channel-property :ha nind 0) 3.14)
      (set! (hook-functions after-save-state-hook) ())
      (hook-push before-save-state-hook 
		 (lambda (hook) 
		   (with-output-to-file (hook 'name)
		     (lambda ()
		       (format () ";this comment will be at the top of the saved state file.~%~%")
		       (set! (hook 'result) #t)))))
      (if (file-exists? *save-state-file*) (delete-file *save-state-file*))
      (save-state *save-state-file*)
      (close-sound nind)
      (for-each forget-region (regions))
      (load (string-append cwd *save-state-file*))
      (let ((ind (find-sound "oboe.snd")))
	(if (not (sound? ind))
	    (snd-display "can't restore oboe.snd from ~A?" *save-state-file*)
	    (begin
	      (if (or (> (abs (- (car old-bounds) (car (x-bounds ind 0)))) .05)
		      (> (abs (- (cadr old-bounds) (cadr (x-bounds ind 0)))) .05))
		  (snd-display "save bounds: ~A" (x-bounds ind 0)))
	      (if (not (= (length (marks ind 0)) 1))
		  (snd-display "save marks: ~A (~A)?" (marks ind 0) *save-state-file*)
		  (begin
		    (if (not (= (mark-sample (car (marks ind 0))) 122))
			(snd-display "save mark: ~A?" (mark-sample (car (marks ind 0)))))
		    (if (not (= (edit-position ind 0) 1))
			(snd-display "save edit-position: ~A" (edit-position ind 0)))))
	      (if (not (equal? (edit-fragment 1 ind 0) '("delete-samples 12 1" "delete" 12 1)))
		  (snd-display "save edits: ~A" (edit-fragment 1 ind 0)))
	      (if (not (equal? (edit-tree ind 0) '((0 0 0 11 1.0 0.0 0.0 0) (12 0 13 50827 1.0 0.0 0.0 0) (50827 -2 0 0 0.0 0.0 0.0 0))))
		  (snd-display "save edit tree: ~A" (edit-tree ind 0)))
	      (if (not (eqv? (sound-property 'ho ind) 1234))
		  (snd-display "sound-property saved: 1234 -> ~A" (sound-property 'ho ind)))
	      (if (not (equal? (sound-property :hi ind) "hi"))
		  (snd-display "sound-property saved: hi -> ~A" (sound-property :hi ind)))
	      (if (or (not (number? (channel-property :ha ind 0)))
		      (fneq (channel-property :ha ind 0) 3.14))
		  (snd-display "channel-property saved: 3.14 -> ~A" (channel-property :ha ind 0)))
	      (close-sound ind))))
      (set! (hook-functions after-save-state-hook) ())
      (set! (hook-functions before-save-state-hook) ())
      
      (let ((err (catch 'cannot-save
		   (lambda () 
		     (save-state "/bad/bad.save"))
		   (lambda args 12345))))
	(if (not (= err 12345)) (snd-display "save-state err: ~A?" err)))
      
      (let ((err (catch 'cannot-save
		   (lambda () 
		     (save-listener "/bad/bad.save"))
		   (lambda args 12345))))
	(if (not (= err 12345)) (snd-display "save-listener err: ~A?" err))))
    (set! nind (open-sound "oboe.snd"))
    (set! (sample 1) .5)
    (delete-sample 100)
    (insert-sample 10 .5)
    (scale-channel 2.0)
    (insert-silence 100 20)
    (save-edit-history "hiho.scm")
    (revert-sound nind)
    (set! sfile nind)
    (load (string-append cwd "hiho.scm"))
    (if (not (equal? (edit-fragment 1) '("set-sample 1 0.5000" "set" 1 1))) (snd-display "save-edit-history 1: ~A?" (edit-fragment 1)))
    (if (not (equal? (edit-fragment 2) '("delete-samples 100 1" "delete" 100 1))) (snd-display "save-edit-history 2: ~A?" (edit-fragment 2)))
    (if (not (equal? (edit-fragment 3) '("insert-sample 10 0.5000" "insert" 10 1))) (snd-display "save-edit-history 3: ~A?" (edit-fragment 3)))
    (if (not (equal? (edit-fragment 4) '("scale-channel 2.000 0 #f" "scale" 0 50828))) (snd-display "save-edit-history 4: ~A?" (edit-fragment 4)))
    (if (not (equal? (edit-fragment 5) '("pad-channel" "zero" 100 20))) (snd-display "save-edit-history 5: ~A?" (edit-fragment 5)))
    (save-edit-history "hiho.scm" nind 0)
    (scale-sound-to 1.0 0 (framples nind 0) nind 0)
    (let ((eds (edit-position nind 0))
	  (val (insert-sound "zero.snd")))
      (if (not (and (= 0 val)
		    (= eds (edit-position nind 0))))
	  (snd-display "insert-sound zero.snd was an edit? ~A ~A ~A" val eds (edit-position nind 0))))
    (revert-sound nind)
    (scale-sound-to 0.5 0 (framples nind 0) nind 0)
    (if (fneq (maxamp nind 0) 0.5) (snd-display "scale-sound-to 0.5: ~A" (maxamp nind)))
    (close-sound nind)
    
    (let ((nind (open-sound "oboe.snd")))
      (ramp-channel 0.0 1.0)
      (xramp-channel 0.0 1.0 32.0)
      (save-edit-history "hiho.scm")
      (revert-sound nind)
      (set! sfile nind)
      (load (string-append cwd "hiho.scm"))
      (if (not (equal? (edit-fragment 1) '("ramp-channel 0.000 1.000 0 #f" "env" 0 50828)))
	  (snd-display "save-edit-history ramp 1: ~A?" (edit-fragment 1)))
      (if (not (equal? (edit-fragment 2) '("xramp-channel 0.000 1.000 32.000 0 #f" "env" 0 50828)))
	  (snd-display "save-edit-history xramp 2: ~A?" (edit-fragment 2)))
      (revert-sound nind)
      (let ((str (file->string "hiho.scm")))
	(if (not (string=? str "      (ramp-channel 0.000 1.000 0 #f sfile 0 #f)
      (xramp-channel 0.000 1.000 32.000 0 #f sfile 0 #f)
"))
	    (snd-display "file->string: ~A" str)))
      (close-sound nind))
    
    (for-each add-sound-file-extension '("ogg" "OGG" "sf" "SF2" "mp3" "MP3" "W01" "W02" "W03" "W04" "W05" "W06" "W07" 
					 "W08" "W09" "W10" "w01" "w02" "w03" "w04" "w05"  "gad"))
    
    (let ((ind (new-sound "fmv.snd")))
      (set! (sample 10) .1)
      (save-sound ind)
      (set! (sample 1) .1)
      (let ()
	(safe-display-edits ind)
	(if (file-exists? "t1.scm") (delete-file "t1.scm"))
	(save-state "t1.scm")
	(close-sound ind)
	(for-each forget-region (regions))
	(load (string-append cwd "t1.scm"))
	(set! ind (find-sound "fmv.snd"))
	(if (not (sound? ind))
	    (snd-display "save-state restored but no sound?"))
	(do ((i 3 (+ i 1)))
	    ((= i 6))
	  (set! (sample i) (* i .1))
	  (safe-display-edits ind)
	  (if (file-exists? "t1.scm") (delete-file "t1.scm"))
	  (save-state "t1.scm")
	  (close-sound ind)
	  (for-each forget-region (regions))
	  (load (string-append cwd "t1.scm"))
	  (set! ind (find-sound "fmv.snd"))
	  (if (not (sound? ind))
	      (snd-display "save-state ~A restored but no sound?" i))))
      (close-sound ind)
      (delete-file "t1.scm"))
    
    (let ((ind (new-sound "fmv.snd" 8 22050 mus-ldouble mus-next "this is an 8-channel save-state test"))
	  (ind1 (new-sound "fmv1.snd" 2 22050 mus-ldouble mus-next "this is a 2-channel save-state test")))
      (set! (sample 10 ind 0) .1)
      (set! (sample 10 ind 1) .2)
      (set! (sample 10 ind 2) .3)
      (set! (sample 10 ind 3) .4)
      (set! (sample 10 ind1 0) -.1)
      (set! (sample 10 ind1 1) -.2)
      (save-sound ind)
      (save-sound ind1)
      (set! (sample 1 ind 0) .1)
      (set! (sample 1 ind 1) .2)
      (set! (sample 1 ind 2) .3)
      (set! (sample 1 ind 3) .4)
      (set! (sample 1 ind1 0) -.1)
      (set! (sample 1 ind1 1) -.2)
      (safe-display-edits ind)
      (safe-display-edits ind1)
      (if (file-exists? "t1.scm") (delete-file "t1.scm"))
      (save-state "t1.scm")
      (close-sound ind)
      (close-sound ind1))
    (for-each forget-region (regions))
    (load (string-append cwd "t1.scm"))
    (let ((ind (find-sound "fmv.snd"))
	  (ind1 (find-sound "fmv1.snd")))
      (if (not (and (sound? ind)
		    (sound? ind1)))
	  (snd-display "save-state(2) restored but no sound? ~A ~A" ind ind1))
      (close-sound ind)
      (close-sound ind1))
    (delete-file "t1.scm")
    
    (let ((ind (open-sound "oboe.snd")))
      (let-temporarily ((*eps-file* "hiho.eps")
			(*save-dir* #f))
	(set! (samples 100 32) (make-float-vector 32 1.0))
	(map-channel (lambda (y) (+ y .1)) 1000 10000)
	(set! (show-axes ind 0) show-no-axes)
	(set! *zoom-focus-style* zoom-focus-middle)
	(set! (transform-normalization ind 0) dont-normalize)
	(set! (graph-style ind 0) graph-filled)
	(set! (transform-graph-type ind 0) graph-as-spectrogram)
	(set! (time-graph-type ind 0) graph-as-wavogram)
	(set! (x-axis-style ind 0) x-axis-as-percentage)
	(set! (speed-control-style ind) speed-control-as-semitone)
	(set! (cursor ind 0) 1234)
	(set! (amp-control-bounds ind) (list 0.0 2.5))
	(set! (speed-control-bounds ind) (list 1.0 2.5))
	(set! (reverb-control-scale-bounds ind) (list 0.0 2.5))
	(set! (reverb-control-length-bounds ind) (list 0.0 2.5))
	(set! (contrast-control-bounds ind) (list 0.0 2.5))
	(set! (x-axis-label ind 0 time-graph) "time-x")
	(set! (y-axis-label ind 0 time-graph) "amp-y")
	(let-temporarily ((*clm-srate* 48000)
			  (*clm-file-buffer-size* 4096)
			  (*mus-array-print-length* 24)
			  (*clm-table-size* 256))
	  (if (file-exists? "s61.scm") (delete-file "s61.scm"))
	  (save-state "s61.scm")
	  (close-sound ind)
	  (for-each forget-region (regions))
	  (load (string-append cwd "s61.scm"))
	  (if (fneq *clm-srate* 48000.0) (snd-display "save/restore mus-srate: ~A" *clm-srate*))
	  (if (not (= *clm-file-buffer-size* 4096)) (snd-display "save/restore mus-file-buffer-size: ~A" *clm-file-buffer-size*))
	  (if (not (= *mus-array-print-length* 24)) (snd-display "save/restore mus-array-print-length: ~A" *mus-array-print-length*))
	  (if (not (= *clm-table-size* 256)) (snd-display "save/restore clm-table-size: ~A" *clm-table-size*)))
	(set! ind (find-sound "oboe.snd"))
	(if (not (= (show-axes ind 0) show-no-axes)) (snd-display "save show-no-axes: ~A" (show-axes ind 0)))
	(if (not (= *zoom-focus-style* zoom-focus-middle)) (snd-display "save zoom-focus-middle: ~A" *zoom-focus-style*))
	(if (not (= (transform-normalization ind 0) dont-normalize)) (snd-display "save dont-normalize: ~A" (transform-normalization ind 0)))
	(if (not (= (graph-style ind 0) graph-filled)) (snd-display "save graph-filled: ~A" (graph-style ind 0)))
	(if (not (= (transform-graph-type ind 0) graph-as-spectrogram)) (snd-display "save graph-as-spectrogram: ~A" (transform-graph-type ind 0)))
	(if (not (= (time-graph-type ind 0) graph-as-wavogram)) (snd-display "save graph-as-wavogram: ~A" (time-graph-type ind 0)))
	(if (not (= (x-axis-style ind 0) x-axis-as-percentage)) (snd-display "save x-axis-as-percentage: ~A" (x-axis-style ind 0)))
	(if (not (= (speed-control-style ind) speed-control-as-semitone)) (snd-display "save speed-control-style: ~A" (speed-control-style ind)))
	(if (not (= (cursor ind 0) 1234)) (snd-display "save cursor 1234: ~A" (cursor ind 0)))
	(if (not (string=? *eps-file* "hiho.eps")) (snd-display "save eps-file: ~A" *eps-file*))
	(when with-gui
	  (if (not (string=? (x-axis-label ind 0 time-graph) "time-x"))
	      (snd-display "save x-axis-label: ~A" (x-axis-label ind 0 time-graph)))
	  (if (not (string=? (y-axis-label ind 0 time-graph) "amp-y"))
	      (snd-display "save y-axis-label: ~A" (y-axis-label ind 0 time-graph))))
	(if (not (feql (amp-control-bounds ind) '(0 2.5))) 
	    (snd-display "save amp-control-bounds: ~A" (amp-control-bounds ind)))
	(if (not (feql (speed-control-bounds ind) '(1.0 2.5))) 
	    (snd-display "save speed-control-bounds: ~A" (speed-control-bounds ind)))
	(if (not (feql (contrast-control-bounds ind) '(0 2.5))) 
	    (snd-display "save contrast-control-bounds: ~A" (contrast-control-bounds ind)))
	(if (not (feql (reverb-control-scale-bounds ind) '(0 2.5))) 
	    (snd-display "save reverb-control-scale-bounds: ~A" (reverb-control-scale-bounds ind)))
	(if (not (feql (reverb-control-length-bounds ind) '(0 2.5))) 
	    (snd-display "save reverb-control-length-bounds: ~A" (reverb-control-length-bounds ind)))
	(delete-file "s61.scm")
	(close-sound ind)))
    
    (let ((ind (open-sound "oboe.snd")))
      (let-temporarily ((*tiny-font* "8x13")
			(*peaks-font* "8x13")
			(*bold-peaks-font* "8x13")
			((amp-control-bounds) (list 0.0 2.5))
			((speed-control-bounds) (list 1.0 2.5))
			((reverb-control-scale-bounds) (list 0.0 2.5))
			((reverb-control-length-bounds) (list 0.0 2.5))
			((contrast-control-bounds) (list 0.0 2.5)))
	(save-state "s61.scm")
	(close-sound ind)
	(for-each forget-region (regions))
	(load (string-append cwd "s61.scm"))
	(if (not (string=? *tiny-font* "8x13")) (snd-display "save tiny-font: ~A" *tiny-font*))
	(if (not (string=? *peaks-font* "8x13")) (snd-display "save peaks-font: ~A" *peaks-font*))
	(if (not (string=? *bold-peaks-font* "8x13")) (snd-display "save bold-peaks-font: ~A" *bold-peaks-font*))
	(if (not (feql (amp-control-bounds) '(0 2.5))) 
	    (snd-display "save amp-control-bounds: ~A" (amp-control-bounds)))
	(if (not (feql (speed-control-bounds) '(1.0 2.5))) 
	    (snd-display "save speed-control-bounds: ~A" (speed-control-bounds)))
	(if (not (feql (contrast-control-bounds) '(0 2.5))) 
	    (snd-display "save contrast-control-bounds: ~A" (contrast-control-bounds)))
	(if (not (feql (reverb-control-scale-bounds) '(0 2.5))) 
	    (snd-display "save reverb-control-scale-bounds: ~A" (reverb-control-scale-bounds)))
	(if (not (feql (reverb-control-length-bounds) '(0 2.5))) 
	    (snd-display "save reverb-control-length-bounds: ~A" (reverb-control-length-bounds)))
	(delete-file "s61.scm")
	(close-sound ind)))
    
    (let ((ind (open-sound "oboe.snd"))
	  (funcs (vector transform-graph-type time-graph-type show-axes transform-normalization
			 graph-style x-axis-style spectro-x-scale transform-size fft-window
			 dot-size max-transform-peaks with-verbose-cursor zero-pad min-dB spectro-hop spectrum-end
			 cursor-size cursor-style)))
      (let ((func-names (vector 'transform-graph-type 'time-graph-type 'show-axes 'transform-normalization
				'graph-style 'x-axis-style 'spectro-x-scale 'transform-size 'fft-window
				'dot-size 'max-transform-peaks 'with-verbose-cursor 'zero-pad 'min-dB 'spectro-hop 'spectrum-end
				'cursor-size 'cursor-style))
	    (old-globals (map (lambda (func) (func)) funcs))
	    (new-globals (vector graph-as-sonogram graph-as-wavogram show-all-axes normalize-by-sound
				 graph-dots x-axis-in-samples 0.1 32 bartlett-window
				 4 10 #t 1 -90 12 .1 15 cursor-cross))
	    (new-locals (vector graph-once graph-once show-x-axis normalize-by-channel
				graph-lines x-axis-in-seconds 1.0 256 blackman2-window
				1 100 #f 0 -60 4 1.0 25 cursor-line)))
	(for-each (lambda (func func-name global local)
		    (set! (func) global)
		    (set! (func ind 0) local))
		  funcs func-names new-globals new-locals)
	(set! *zoom-focus-style* zoom-focus-right)
	(set! *channel-style* channels-combined)
	(set! (channel-style ind) channels-separate)
	(if (file-exists? "s61.scm") (delete-file "s61.scm"))
	(save-state "s61.scm")
	(close-sound ind)
	(for-each forget-region (regions))
	(load (string-append cwd "s61.scm"))
	(set! ind (find-sound "oboe.snd"))
	(when with-gui
	  (let ((local-eq? (lambda (a b)
			     (if (number? a)
				 (if (rational? a)
				     (= a b)
				     (< (abs (- a b)) .001))
				 (eq? a b)))))
	    (for-each (lambda (func func-name global local)
			(if (not (and (local-eq? (func) global)
				      (local-eq? (func ind 0) local)))
			    (snd-display " save ~A reversed: ~A [~A] ~A [~A]" 
					 func-name (func) global (func ind 0) local)))
		      funcs func-names new-globals new-locals)))
	(if (not (= (channel-style ind) channels-separate))
	    (snd-display "save channel-style reversed: ~A ~A" *channel-style* (channel-style ind)))
	(for-each (lambda (func val) (set! (func) val)) funcs old-globals)
	(close-sound ind)
	(set! *zoom-focus-style* zoom-focus-active)
	(set! *channel-style* channels-separate)
	(delete-file "s61.scm")))
    
    (let ((ind0 (open-sound "oboe.snd"))
	  (ind1 (open-sound "oboe.snd")))
      (if (not (member (find-sound "oboe.snd" 0) (list ind0 ind1)))
	  (snd-display "find-sound 0: ~A ~A" (list ind0 ind1) (find-sound "oboe.snd" 0)))
      (if (not (member (find-sound "oboe.snd" 1) (list ind0 ind1)))
	  (snd-display "find-sound 1: ~A ~A" (list ind0 ind1) (find-sound "oboe.snd" 1)))
      (add-mark 123 ind0)
      (add-mark 321 ind1)
      (if (file-exists? "s61.scm") (delete-file "s61.scm"))
      (save-state "s61.scm")
      (close-sound ind0)
      (close-sound ind1))
    (load (string-append cwd "s61.scm"))
    (let ((ind0 (find-sound "oboe.snd" 0))
	  (ind1 (find-sound "oboe.snd" 1)))
      (if (not (and ind0 ind1)) (snd-display "saved 2oboes, found: ~A" (map short-file-name (sounds))))
      (if (not (find-mark 123 ind0)) (snd-display "saved 2oboes mark 0?"))
      (if (find-mark 123 ind1) (snd-display "saved 2oboes mark 1->0?"))
      (if (not (find-mark 321 ind1)) (snd-display "saved 2oboes mark 1?"))
      (if (find-mark 321 ind0) (snd-display "saved 2oboes mark 0->1?"))
      (close-sound ind0)
      (close-sound ind1))
    
    (let ((ctr 1))
      (for-each 
       (lambda (func test)
	 (let ((ind (new-sound "test.snd" 1 22050 mus-ldouble mus-next "mono save-state tests" 100)))
	   (func ind)
	   (if (file-exists? "s61.scm") (delete-file "s61.scm"))
	   (save-state "s61.scm")
	   (close-sound ind)
	   (load (string-append cwd "s61.scm"))
	   (set! ind (find-sound "test.snd"))
	   (if (not (sound? ind)) 
	       (snd-display "save-state test ~D no test.snd?" ctr)
	       (begin
		 (test ind)
		 (close-sound ind)))
	   (set! ctr (+ ctr 1))))
       
       (list 
	
	;; basic choices
	(lambda (ind) (insert-sample 10 .5 ind 0))
	(lambda (ind) (delete-sample 10 ind 0))
	(lambda (ind) (set! (sample 10 ind 0) .5))
	(lambda (ind) (set! (sample 10 ind 0) .5) (scale-channel .5))
	(lambda (ind) (float-vector->channel (make-float-vector 10 .5) 10 5 ind 0) (pad-channel 12 5 ind 0))
	(lambda (ind) (map-channel (lambda (y) 1.0)) (env-channel '(0 0 1 1) 0 11 ind 0))
	(lambda (ind) (map-channel (lambda (y) (+ y .1))))
	
	;; map-channel as backup
	(lambda (ind)
	  (let ((p (make-one-pole 1.0 -1.0)))
	    (map-channel (lambda (y) (and (even? (floor (one-pole p 1.0))) .1)))))
	
	;; as-one-edit
	(lambda (ind)
	  ;; change
	  (as-one-edit 
	   (lambda ()
	     (float-vector->channel #r(.1 .2 .3 .4 .5 .6 .7 .8 .9 1.0) 0 10 ind 0)
	     (float-vector->channel #r(.1 .2 .3 .4 .5 .6 .7 .8 .9 1.0) 20 10 ind 0))))
	
	(lambda (ind)
	  ;; scale
	  (as-one-edit
	   (lambda ()
	     (float-vector->channel #r(.1 .2 .3 .4 .5 .6 .7 .8 .9 1.0) 0 10 ind 0)
	     (scale-by .5))))
	
	(lambda (ind)
	  ;; delete
	  (as-one-edit
	   (lambda ()
	     (float-vector->channel #r(.1 .2 .3 .4 .5 .6 .7 .8 .9 1.0) 0 10 ind 0)
	     (delete-samples 5 5))))
	
	(lambda (ind)
	  ;; insert
	  (as-one-edit
	   (lambda ()
	     (delete-samples 5 5)
	     (insert-samples 5 2 #r(.1 .2))))))
       
       (list
	;; basic cases
	(lambda (ind)
	  (if (fneq (sample 10) .5) (snd-display "insert-sample save-state: ~A" (channel->float-vector 5 10 ind 0)))
	  (if (not (= (framples ind 0) 101)) (snd-display "insert-sample save-state len: ~A" (framples ind 0))))
	(lambda (ind)
	  (if (fneq (sample 10) 0.0) (snd-display "delete-sample save-state: ~A" (channel->float-vector 5 10 ind 0)))
	  (if (not (= (framples ind 0) 99)) (snd-display "delete-sample save-state len: ~A" (framples ind 0))))
	(lambda (ind)
	  (if (fneq (sample 10) .5) (snd-display "set sample save-state: ~A" (channel->float-vector 5 10 ind 0)))
	  (if (not (= (framples ind 0) 100)) (snd-display "set sample save-state len: ~A" (framples ind 0))))
	(lambda (ind)
	  (if (fneq (sample 10) .25) (snd-display "scl sample save-state: ~A" (channel->float-vector 5 10 ind 0)))
	  (if (not (= (framples ind 0) 100)) (snd-display "scl sample save-state len: ~A" (framples ind 0)))
	  (if (not (= (edit-position ind 0) 2)) (snd-display "scl sample save-state edpos: ~A" (edit-position ind 0))))
	(lambda (ind)
	  (if (not (= (framples ind 0) 105)) (snd-display "pad sample save-state len: ~A" (framples ind 0)))
	  (if (not (= (edit-position ind 0) 2)) (snd-display "pad sample save-state edpos: ~A" (edit-position ind 0)))
	  (if (not (mus-arrays-equal? #r(.5 .5 0 0 0 0 0 .5 .5 .5) (channel->float-vector 10 10 ind 0)))
	      (snd-display "pad sample save-state: ~A" (channel->float-vector 10 10 ind 0))))
	(lambda (ind)
	  (if (not (= (framples ind 0) 100)) (snd-display "env sample save-state len: ~A" (framples ind 0)))
	  (if (not (= (edit-position ind 0) 2)) (snd-display "env sample save-state edpos: ~A" (edit-position ind 0)))
	  (if (not (mus-arrays-equal? #r(0 .1 .2 .3 .4 .5 .6 .7 .8 .9 1.0 1.0 1.0 1.0 1.0) (channel->float-vector 0 15 ind 0)))
	      (snd-display "env sample save-state: ~A" (channel->float-vector 0 15 ind 0))))
	(lambda (ind)
	  (if (not (= (framples ind 0) 100)) (snd-display " sample save-state len: ~A" (framples ind 0)))
	  (if (not (= (edit-position ind 0) 1)) (snd-display " sample save-state edpos: ~A" (edit-position ind 0)))
	  (if (fneq (maxamp ind 0) .1) (snd-display " save-state max: ~A" (maxamp ind 0)))
	  (if (not (mus-arrays-equal? (make-float-vector 10 .1) (channel->float-vector 0 10))) (snd-display " save-state vals: ~A" (channel->float-vector 0 10 ind 0))))
	
	;; map-channel as backup
	(lambda (ind)
	  (if (not (= (framples ind 0) 50)) (snd-display "map #f save-state len: ~A" (framples ind 0)))
	  (if (not (= (edit-position ind 0) 1)) (snd-display "map #f save-state edpos: ~A" (edit-position ind 0)))
	  (if (fneq (maxamp ind 0) .1) (snd-display "map #f save-state max: ~A" (maxamp ind 0)))
	  (if (not (mus-arrays-equal? (make-float-vector 10 .1) (channel->float-vector 0 10))) (snd-display "map #f save-state vals: ~A" (channel->float-vector 0 10 ind 0))))
	
	;; as-one-edit
	(lambda (ind)
	  (if (not (= (edit-position ind 0) 1)) (snd-display "save-state backup 2 float-vectors edpos: ~A" (edit-position ind 0)))
	  (if (not (mus-arrays-equal? (channel->float-vector 0 10 ind 0) #r(.1 .2 .3 .4 .5 .6 .7 .8 .9 1.0)))
	      (snd-display "as-one-edit save-state 1: ~A" (channel->float-vector 0 10 ind 0)))
	  (if (not (mus-arrays-equal? (channel->float-vector 20 10 ind 0) #r(.1 .2 .3 .4 .5 .6 .7 .8 .9 1.0)))
	      (snd-display "as-one-edit save-state 2: ~A" (channel->float-vector 0 10 ind 0))))
	
	(lambda (ind)
	  (if (not (= (edit-position ind 0) 1)) (snd-display "save-state backup float-vector+scl edpos: ~A" (edit-position ind 0)))
	  (if (not (mus-arrays-equal? (channel->float-vector 0 10 ind 0) (float-vector-scale! #r(.1 .2 .3 .4 .5 .6 .7 .8 .9 1.0) .5)))
	      (snd-display "as-one-edit save-state 3: ~A" (channel->float-vector 0 10 ind 0))))
	
	(lambda (ind)
	  (if (not (= (edit-position ind 0) 1)) (snd-display "save-state backup float-vector+del edpos: ~A" (edit-position ind 0)))
	  (if (not (mus-arrays-equal? (channel->float-vector 0 10 ind 0) #r(.1 .2 .3 .4 .5 0 0 0 0 0)))
	      (snd-display "as-one-edit save-state 4: ~A" (channel->float-vector 0 10 ind 0))))
	
	(lambda (ind)
	  (if (not (= (edit-position ind 0) 1)) (snd-display "save-state backup del+insert edpos: ~A" (edit-position ind 0)))
	  (if (not (mus-arrays-equal? (channel->float-vector 0 10 ind 0) #r(0 0 0 0 0 .1 .2 0 0 0)))
	      (snd-display "as-one-edit save-state 5: ~A" (channel->float-vector 0 10 ind 0)))
	  (if (not (= (framples ind 0) 97)) (snd-display "save-state backup del+insert len: ~A" (framples ind 0)))))))
    
    ;; ---------------- edit-list->function ----------------
    
    (let* ((ind (open-sound "oboe.snd"))
	   (frs (framples ind)))
      
      ;; ---- simple scale
      (let ((mx0 (maxamp)))
	(scale-channel 2.0)
	(if (fneq (* 2 mx0) (maxamp)) (snd-display "edit-list->function off to a bad start: ~A" (maxamp)))
	(let ((func (edit-list->function)))
	  (if (not (procedure? func)) 
	      (snd-display "edit-list->function 1: ~A" func))
	  (if (not (equal? (procedure-source func) '(lambda (snd chn) (scale-channel 2.0 0 #f snd chn))))
	      (snd-display "edit-list->function 1: ~A" (procedure-source func))
	      (func ind 0))
	  (let ((mx (maxamp)))
	    (if (fneq (* 4 mx0) mx) (snd-display "edit-list->function called (1): ~A ~A" mx mx0)))))
      (revert-sound ind)
      
      (scale-by 2.0)
      (let ((func (edit-list->function)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 1a: ~A" func))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (scale-channel 2.0 0 #f snd chn))))
	    (snd-display "edit-list->function 1a: ~A" (procedure-source func))))
      (revert-sound ind)
      (normalize-channel 1.0)
      (let ((func (edit-list->function)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 1c: ~A" func))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (normalize-channel 1.0 0 #f snd chn))))
	    (snd-display "edit-list->function 1c: ~A" (procedure-source func))))
      (revert-sound ind)
      
      ;; ---- simple delete
      (delete-samples 10 100)
      (if (not (= (framples) (- frs 100))) (snd-display "edit-list->function delete: ~A ~A" frs (framples)))
      (let ((func (edit-list->function)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 2: ~A" func))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (delete-samples 10 100 snd chn))))
	    (snd-display "edit-list->function 2: ~A" (procedure-source func))
	    (func ind 0))
	(if (not (= (framples) (- frs 200))) (snd-display "edit-list->function called (2): ~A ~A" frs (framples))))
      (revert-sound ind)
      
      ;; ---- simple delete (a)
      (delete-sample 100)
      (if (not (= (framples) (- frs 1))) (snd-display "edit-list->function delete (2a): ~A ~A" frs (framples)))
      (let ((func (edit-list->function)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 2a: ~A" func))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (delete-samples 100 1 snd chn))))
	    (snd-display "edit-list->function 2a: ~A" (procedure-source func))
	    (func ind 0))
	(if (not (= (framples) (- frs 2))) (snd-display "edit-list->function called (2a): ~A ~A" frs (framples))))
      (revert-sound ind)
      
      ;; ---- simple zero pad
      (pad-channel 10 100)
      (if (not (= (framples) (+ frs 100))) (snd-display "edit-list->function pad: ~A ~A" frs (framples)))
      (let ((func (edit-list->function)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 3: ~A" func))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (pad-channel 10 100 snd chn))))
	    (snd-display "edit-list->function 3: ~A" (procedure-source func))
	    (func ind 0))
	(if (not (= (framples) (+ frs 200))) (snd-display "edit-list->function called (3): ~A ~A" frs (framples))))
      (revert-sound ind)
      
      ;; ---- simple zero pad (a)
      (insert-silence 10 100)
      (if (not (= (framples) (+ frs 100))) (snd-display "edit-list->function pad (3a): ~A ~A" frs (framples)))
      (let ((func (edit-list->function)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 3a: ~A" func))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (pad-channel 10 100 snd chn))))
	    (snd-display "edit-list->function 3a: ~A" (procedure-source func))
	    (func ind 0))
	(if (not (= (framples) (+ frs 200))) (snd-display "edit-list->function called (3a): ~A ~A" frs (framples))))
      (revert-sound ind)
      
      ;; --- simple ramp
      (ramp-channel 0.2 0.9)
      (if (fneq (maxamp) 0.0899) (snd-display "edit-list ramp: ~A" (maxamp)))
      (let ((func (edit-list->function)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 4: ~A" func))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (ramp-channel 0.2 0.9 0 #f snd chn))))
	    (snd-display "edit-list->function 4: ~A" (procedure-source func))
	    (func ind 0))
	(let ((mx (maxamp)))
	  (if (fneq mx 0.061) (snd-display "edit-list->function called (4): ~A" mx))))
      (revert-sound ind)
      
      ;; --- simple xramp
      (xramp-channel 0.2 0.9 32.0)
      (if (and (fneq (maxamp) 0.055) (fneq (maxamp) .056)) (snd-display "edit-list xramp: ~A" (maxamp)))
      (let ((func (edit-list->function)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 5: ~A" func))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (xramp-channel 0.2 0.9 32.0 0 #f snd chn))))
	    (snd-display "edit-list->function 5: ~A" (procedure-source func))
	    (func ind 0))
	(let ((mx (maxamp)))
	  (if (fneq mx 0.0266) (snd-display "edit-list->function called (5): ~A" mx))))
      (revert-sound ind)
      
      
      ;; ---- simple env
      (env-sound '(0 0 1 1))
      (if (fneq (maxamp) 0.0906) (snd-display "edit-list env: ~A" (maxamp)))
      (let ((func (edit-list->function)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 6: ~A" func))
	(if (not (equal? (procedure-source func)
			 '(lambda (snd chn) (env-channel '(0.0 0.0 1.0 1.0) 0 #f snd chn))))
	    (snd-display "edit-list->function 6: ~A" (procedure-source func))
	    (func ind 0))
	(let ((mx (maxamp)))
	  (if (fneq mx 0.0634) (snd-display "edit-list->function called (6): ~A" mx))))
      (revert-sound ind)
      
      ;; ---- less simple env
      (env-sound '(0 0 1 .3 2 .8 3 0))
      (if (fneq (maxamp) 0.107) (snd-display "edit-list env: ~A" (maxamp)))
      (let ((func (edit-list->function)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 7: ~A" func))
	(if (not (equal? (procedure-source func) 
			 '(lambda (snd chn) (env-channel '(0.0 0.0 1.0 0.3 2.0 0.8 3.0 0.0) 0 #f snd chn))))
	    (snd-display "edit-list->function 7: ~A" (procedure-source func))
	    (func ind 0))
	(let ((mx (maxamp)))
	  (if (fneq mx 0.0857) (snd-display "edit-list->function called (7): ~A" mx))))
      (revert-sound ind)
      
      (env-channel '(0 0 1 .3 2 .8 3 0))
      (let ((func (edit-list->function)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 7a: ~A" func))
	(if (not (equal? (procedure-source func) 
			 '(lambda (snd chn) (env-channel '(0.0 0.0 1.0 0.3 2.0 0.8 3.0 0.0) 0 #f snd chn))))
	    (snd-display "edit-list->function 7a: ~A" (procedure-source func))))
      (revert-sound ind)
      
      (env-channel '(0 0 1 .3 2 .8 3 0) 1000 2000)
      (let ((func (edit-list->function)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 7b: ~A" func))
	(if (not (equal? (procedure-source func) 
			 '(lambda (snd chn) (env-channel (make-env '(0.0 0.0 1.0 0.3 2.0 0.8 3.0 0.0) :base 1.0 :end 1999) 1000 2000 snd chn))))
	    (snd-display "edit-list->function 7b: ~A" (procedure-source func))))
      (revert-sound ind)
      
      (env-channel (make-env '(0.0 0.0 1.0 0.3 2.0 0.8 3.0 0.0) :base 32.0 :length 2000) 1000 2000)
      (let ((func (edit-list->function))
	    (mxenv0 (maxamp)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 7c: ~A" func))
	(if (not (equal? (procedure-source func) 
			 '(lambda (snd chn) (env-channel (make-env '(0.0 0.0 1.0 0.3 2.0 0.8 3.0 0.0) :base 32.0 :end 1999) 1000 2000 snd chn))))
	    (snd-display "edit-list->function 7c: ~A" (procedure-source func)))
	(revert-sound ind)
	
	(env-channel (make-env '(0.0 0.0 1.0 0.3 2.0 0.8 3.0 0.0) :length 2000 :offset 2.0 :scaler 3.0) 1000 2000)
	(let ((func (edit-list->function))
	      (mxenv1 (maxamp)))
	  (if (not (procedure? func)) 
	      (snd-display "edit-list->function 7d: ~A" func))
	  (if (not (equal? (procedure-source func) 
			   '(lambda (snd chn) (env-channel (make-env '(0.0 2.0 1.0 2.9 2.0 4.4 3.0 2.0) :base 1.0 :end 1999) 1000 2000 snd chn))))
	      (snd-display "edit-list->function 7d: ~A" (procedure-source func)))
	  (revert-sound ind)
	  (func ind 0)
	  (let ((nmx (maxamp)))
	    (if (fneq nmx mxenv1) (snd-display "edit-list->function 7d max: ~A ~A ~A" nmx mxenv1 mxenv0)))))
      (revert-sound ind)
      
      (do ((i 0 (+ i 1)))
	  ((= i 5)) ; get to unrampable case
	(env-channel '(0 0 1 1 2 0)))
      (let ((func (edit-list->function)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 7e: ~A" func))
	(if (not (equal? (procedure-source func) 
			 '(lambda (snd chn) 
			    (env-channel '(0.0 0.0 1.0 1.0 2.0 0.0) 0 #f snd chn)
			    (env-channel '(0.0 0.0 1.0 1.0 2.0 0.0) 0 #f snd chn)
			    (env-channel '(0.0 0.0 1.0 1.0 2.0 0.0) 0 #f snd chn)
			    (env-channel '(0.0 0.0 1.0 1.0 2.0 0.0) 0 #f snd chn) 
			    (env-channel '(0.0 0.0 1.0 1.0 2.0 0.0) 0 #f snd chn))))
	    (snd-display "edit-list->function 7e: ~A" (procedure-source func)))
	(revert-sound ind)
	(func ind 0)
	(if (fneq (maxamp) 0.1459) (snd-display "edit-list->function 7e max: ~A" (maxamp)))
	(if (not (= (edit-position) 5)) (snd-display "edit-list->function 7e edpos: ~A" (edit-position))))
      (revert-sound ind)
      
      (env-sound '(0 0 1 1 2 0) 0 (framples) 32.0)
      (if (fneq (maxamp) 0.146) (snd-display "edit-list env 7f: ~A" (maxamp)))
      (let ((func (edit-list->function)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 7f: ~A" func))
	(if (not (equal? (procedure-source func) 
			 '(lambda (snd chn) (env-channel-with-base '(0.0 0.0 1.0 1.0 2.0 0.0) 32.0 0 #f snd chn))))
	    (snd-display "edit-list->function 7f: ~A" (procedure-source func)))
	(revert-sound ind)
	(func ind 0)
	(let ((mx (maxamp)))
	  (if (fneq mx 0.146) (snd-display "edit-list->function called (7f): ~A" mx))))
      (revert-sound ind)
      
      (env-sound '(0 0 1 1 2 1 3 0) 0 (framples) 0.0)
      (if (fneq (sample 4000) 0.0) (snd-display "edit-list env 7g: ~A" (sample 4000)))
      (let ((func (edit-list->function)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 7g: ~A" func))
	(if (not (equal? (procedure-source func) 
			 '(lambda (snd chn) (env-channel-with-base '(0.0 0.0 1.0 1.0 2.0 1.0 3.0 0.0) 0.0 0 #f snd chn))))
	    (snd-display "edit-list->function 7g: ~A" (procedure-source func)))
	(revert-sound ind)
	(func ind 0)
	(if (fneq (sample 4000) 0.0) (snd-display "edit-list function 7g: ~A" (sample 4000))))
      (revert-sound ind)
      
      ;; ---- simple 1 sample insert
      (insert-sample 100 .1)
      (if (not (= (framples) (+ frs 1))) (snd-display "edit-list->function insert-sample: ~A ~A" frs (framples)))
      (let ((func (edit-list->function)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 9: ~A" func))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (insert-sample 100 0.1 snd chn))))
	    (snd-display "edit-list->function 9: ~A" (procedure-source func)))
	(func ind 0)
	(if (not (mus-arrays-equal? (channel->float-vector 99 4) #r(0.0 0.1 0.1 0.0)))
	    (snd-display "edit-list->function func 9: ~A" (channel->float-vector 99 4)))
	(if (not (= (framples) (+ frs 2))) (snd-display "edit-list->function called (9): ~A ~A" frs (framples))))
      (revert-sound ind)
      
      ;; ---- insert-samples with data
      (insert-samples 0 100 (make-float-vector 100 .1))
      (if (not (= (framples) (+ frs 100))) (snd-display "edit-list->function insert-samples (100): ~A ~A" frs (framples)))
      (let ((func (edit-list->function)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 9a: ~A" func))
	(func ind 0))
      (if (not (= (framples) (+ frs 200))) (snd-display "edit-list->function insert-samples (200): ~A ~A" frs (framples)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 5) (make-float-vector 5 0.1)))
	  (snd-display "edit-list->function func 9a: ~A" (channel->float-vector 0 5)))
      (revert-sound ind)
      
      ;; ---- set-samples with data
      (set! (samples 0 100) (make-float-vector 100 .1))
      (if (not (= (framples) frs)) (snd-display "edit-list->function set-samples (1): ~A ~A" frs (framples)))
      (let ((func (edit-list->function)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 9b: ~A" func))
	(func ind 0))
      (if (not (= (framples) frs)) (snd-display "edit-list->function set-samples (2): ~A ~A" frs (framples)))
      (if (not (mus-arrays-equal? (channel->float-vector 0 5) (make-float-vector 5 0.1)))
	  (snd-display "edit-list->function func 9b: ~A" (channel->float-vector 0 5)))
      (revert-sound ind)
      
      ;; ---- simple 1 sample set
      (let ((val (sample 100)))
	(set! (sample 100) .1)
	(if (not (= (framples) frs)) (snd-display "edit-list->function set-sample framples: ~A ~A" frs (framples)))
	(if (fneq (sample 100) .1) (snd-display "edit-list->function set-sample val: ~A ~A" val (sample 100)))
	(let ((func (edit-list->function)))
	  (revert-sound)
	  (if (fneq val (sample 100)) (snd-display "edit-list->function unset-sample val: ~A ~A" val (sample 100)))
	  (if (not (procedure? func)) 
	      (snd-display "edit-list->function 10: ~A" func))
	  (if (not (equal? (procedure-source func) '(lambda (snd chn) (set-sample 100 0.1 snd chn))))
	      (snd-display "edit-list->function 10: ~A" (procedure-source func)))
	  (func ind 0)
	  (if (not (mus-arrays-equal? (channel->float-vector 99 4) #r(0.0 0.1 0.0 0.0)))
	      (snd-display "edit-list->function func 10: ~A" (channel->float-vector 99 4)))))
      (revert-sound ind)
      
      
      (let ((pfrs (mus-sound-framples "pistol.snd")))
	(insert-sound "pistol.snd" 1000)
	(if (not (= (framples) (+ frs pfrs))) (snd-display "edit-list->function insert-sound: ~A ~A" frs (framples)))
	(let ((func (edit-list->function)))
	  (if (not (procedure? func)) 
	      (snd-display "edit-list->function 10a: ~A" func))
	  (if (not (member (procedure-source func) 
			   '((lambda (snd chn) (insert-sound "/home/bil/cl/pistol.snd" 1000 0 snd chn))
			     (lambda (snd chn) (insert-sound "/home/bil/snd-18/pistol.snd" 1000 0 snd chn)))))
	      (snd-display "edit-list->function 10a: ~A" (procedure-source func)))
	  (revert-sound ind)
	  (func ind 0)
	  (if (not (= (framples) (+ frs pfrs))) (snd-display "edit-list->function called (10): ~A ~A" frs (framples)))))
      (revert-sound ind)
      
      (let ((pfrs (mus-sound-framples "pistol.snd")))
	(insert-samples 1000 pfrs "pistol.snd")
	(if (not (= (framples) (+ frs pfrs))) (snd-display "edit-list->function insert-samples: ~A ~A" frs (framples)))
	(let ((func (edit-list->function)))
	  (if (not (procedure? func)) 
	      (snd-display "edit-list->function 11: ~A" func))
	  (if (not (member (procedure-source func) 
			   '((lambda (snd chn) (insert-samples 1000 41623 "/home/bil/cl/pistol.snd" snd chn))
			     (lambda (snd chn) (insert-samples 1000 41623 "/home/bil/snd-18/pistol.snd" snd chn)))))
	      (snd-display "edit-list->function 11: ~A" (procedure-source func)))
	  (revert-sound ind)
	  (func ind 0)
	  (if (not (= (framples) (+ frs pfrs))) (snd-display "edit-list->function called (11): ~A ~A" frs (framples)))))
      (revert-sound ind)
      
      (smooth-channel 1000 100)
      (let ((func (edit-list->function))
	    (val (sample 1050)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 12: ~A" func))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (smooth-channel 1000 100 snd chn))))
	    (snd-display "edit-list->function 12: ~A" (procedure-source func)))
	(revert-sound ind)
	(func ind 0)
	(if (fneq (sample 1050) val) (snd-display "edit-list->function 12: ~A ~A" (sample 1050) val)))
      (revert-sound ind)
      
      (smooth-sound 1000 100)
      (let ((func (edit-list->function)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 12a: ~A" func))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (smooth-channel 1000 100 snd chn))))
	    (snd-display "edit-list->function 12a: ~A" (procedure-source func))))
      (revert-sound ind)
      
      ;; ---- selection stuff
      (make-selection 1000 11000)
      (scale-selection-by 2.0)
      (let ((func (edit-list->function)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 13: ~A" func))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (scale-channel 2.0 1000 10001 snd chn))))
	    (snd-display "edit-list->function 13: ~A" (procedure-source func)))
	(revert-sound ind)
	(func ind 0)
	(let ((mx (maxamp)))
	  (if (fneq mx .269) (snd-display "edit-list->function called (13): ~A" mx))))
      (revert-sound ind)
      
      (scale-selection-to 1.0)
      (let ((func (edit-list->function)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 13a: ~A" func))
	(if (not (equal? (procedure-source func) 
			 '(lambda (snd chn) (normalize-channel 1.0 1000 10001 snd chn))))
	    (snd-display "edit-list->function 13a: ~A" (procedure-source func))))
      (revert-sound ind)
      
      (env-selection '(0 0 1 1 2 0))
      (let ((func (edit-list->function)))
	(if (fneq (sample 4000) 0.0173) (snd-display "edit-list->function 14 samp: ~A" (sample 4000)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 14: ~A" func))
	(if (not (equal? (procedure-source func) 
			 '(lambda (snd chn) (env-channel (make-env '(0.0 0.0 1.0 1.0 2.0 0.0) :base 1.0 :end 10000) 1000 10001 snd chn))))
	    (snd-display "edit-list->function 14: ~A" (procedure-source func)))
	(revert-sound ind)
	(func ind 0)
	(if (fneq (sample 4000) 0.0173) (snd-display "edit-list->function 14 re-samp: ~A" (sample 4000))))
      (revert-sound ind)
      
      (make-selection 1000 1100)
      (smooth-selection)
      (let ((func (edit-list->function))
	    (val (sample 1050)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 14a: ~A" func))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (smooth-channel 1000 101 snd chn))))
	    (snd-display "edit-list->function 14a: ~A" (procedure-source func)))
	(revert-sound ind)
	(func ind 0)
	(if (fneq (sample 1050) val) (snd-display "edit-list->function 14a: ~A ~A" (sample 1050) val)))
      (revert-sound ind)
      
      (reverse-selection)
      (let ((func (edit-list->function)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 14b: ~A" func))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (reverse-channel 1000 101 snd chn))))
	    (snd-display "edit-list->function 14b: ~A" (procedure-source func)))
	(revert-sound ind)
	(func ind 0))
      (revert-sound ind)
      
      (delete-selection)
      (let ((func (edit-list->function)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 14c: ~A" func))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (delete-samples 1000 101 snd chn))))
	    (snd-display "edit-list->function 14c: ~A" (procedure-source func)))
	(revert-sound ind)
	(func ind 0))
      (revert-sound ind)
      
      ;; ---- simple reapply
      (env-channel '(0 0 1 1 2 0))
      (let ((func (edit-list->function)))
	(close-sound ind)
	(set! ind (new-sound "tmp.snd" 1 22050 mus-ldouble mus-next :size 20 :comment #f))
	(map-channel (lambda (y) 1.0))
	(func ind 0)
	(let ((data (channel->float-vector)))
	  (if (not (mus-arrays-equal? data #r(0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 0.889 0.778 0.667 0.556 0.444 0.333 0.222 0.111 0.0)))
	      (snd-display "edit-list->function env reapply: ~A" data)))
	(close-sound ind)
	(set! ind (open-sound "oboe.snd")))
      
      ;; ---- insert-region
      (let ((reg (make-region 1000 1100)))
	(insert-region reg 2000)
	(let ((func (edit-list->function))
	      (val (sample 2050)))
	  (if (not (procedure? func)) 
	      (snd-display "edit-list->function 16: ~A" func))
	  (revert-sound ind)
	  (func ind 0)
	  (if (fneq (sample 2050) val) (snd-display "edit-list->function 16: ~A ~A" (sample 2050) val))))
      (revert-sound ind)
      
      ;; ---- reverse
      (reverse-channel)
      (let ((func (edit-list->function))
	    (val (sample 2000)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 17: ~A" func))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (reverse-channel 0 #f snd chn))))
	    (snd-display "edit-list->function 17: ~A" (procedure-source func)))
	(if (fneq val -.002) (snd-display "edit-list->function val: ~A" val))
	(revert-sound ind)
	(func ind 0)
	(if (fneq val -.002) (snd-display "edit-list->function 17 re-val: ~A" val)))
      (revert-sound ind)
      
      (reverse-sound)
      (let ((func (edit-list->function))
	    (val (sample 2000)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 17a: ~A" func))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (reverse-channel 0 #f snd chn))))
	    (snd-display "edit-list->function 17a: ~A" (procedure-source func)))
	(if (fneq val -.002) (snd-display "edit-list->function 17a val: ~A" val)))
      (revert-sound ind)
      
      (reverse-channel 1000 500)
      (let ((func (edit-list->function)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 17b: ~A" func))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (reverse-channel 1000 500 snd chn))))
	    (snd-display "edit-list->function 17b: ~A" (procedure-source func))))
      (revert-sound ind)
      
      ;; ---- src
      (src-sound 2.0)
      (if (> (abs (- (framples) 25415)) 2) (snd-display "edit-list->function 18 len: ~A" (framples)))
      (let ((func (edit-list->function)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 18: ~A" func))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (src-channel 2.0 0 #f snd chn))))
	    (snd-display "edit-list->function 18: ~A" (procedure-source func)))
	(revert-sound ind)
	(func ind 0)
	(if (> (abs (- (framples) 25415)) 2) (snd-display "edit-list->function 18 re-len: ~A" (framples))))
      (revert-sound ind)
      
      (src-channel 2.0 1000 500)
      (let ((func (edit-list->function))
	    (frs (framples)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 18a: ~A" func))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (src-channel 2.0 1000 500 snd chn))))
	    (snd-display "edit-list->function 18a: ~A" (procedure-source func)))
	(revert-sound ind)
	(func ind 0)
	(if (not (= frs (framples))) (snd-display "edit-list->function 18a re-len: ~A ~A" frs (framples))))
      (revert-sound)
      
      (src-sound '(0 1 1 2 2 1))
      (let ((func (edit-list->function))
	    (frs (framples)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 18b: ~A" func))
	(if (not (equal? (procedure-source func) 
			 '(lambda (snd chn) (src-channel '(0.0 1.0 1.0 2.0 2.0 1.0) 0 #f snd chn))))
	    (snd-display "edit-list->function 18b: ~A" (procedure-source func)))
	(revert-sound ind)
	(func ind 0)
	(if (not (= frs (framples))) (snd-display "edit-list->function 18b re-len: ~A ~A" frs (framples))))
      (revert-sound)
      
      (src-channel '(0 1 1 2) 1000 500)
      (let ((func (edit-list->function))
	    (frs (framples)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 18c: ~A" func))
	(if (not (equal? (procedure-source func) 
			 '(lambda (snd chn) (src-channel '(0.0 1.0 1.0 2.0) 1000 500 snd chn))))
	    (snd-display "edit-list->function 18c: ~A" (procedure-source func)))
	(revert-sound ind)
	(func ind 0)
	(if (not (= frs (framples))) (snd-display "edit-list->function 18c re-len: ~A ~A" frs (framples))))
      (revert-sound)
      
      ;; ---- filter-channel
      (filter-channel '(0 1 1 0) 10)
      (let ((func (edit-list->function))
	    (mx (maxamp)))
	(if (not (procedure? func)) 
	    (snd-display "edit-list->function 19: ~A" func))
	(if (not (equal? (procedure-source func) 
			 '(lambda (snd chn) (filter-channel '(0.0 1.0 1.0 0.0) 10 0 #f snd chn))))
	    (snd-display "edit-list->function 19: ~A" (procedure-source func)))
	(revert-sound ind)
	(func ind 0)
	(if (fneq mx (maxamp)) (snd-display "edit-list->function 19 re-filter: ~A ~A" mx (maxamp))))
      (revert-sound)
      
      (filter-fft (make-one-zero .5 .5))
      (float-vector->channel (fft-smoother .1 (cursor) 400) (cursor) 400)
      (revert-sound)
      
      (let ((ind (new-sound :size 32)))
	(select-sound ind)
	(let ((ang 0.0)) 
	  (map-channel (lambda (y) 
			 (let ((val (* .5 (+ (sin ang) (sin (* ang 4))))))
			   (set! ang (+ ang (/ (* 2 pi) 16.0))) 
			   val))))
	(let ((vals (fft-env-data '(0 0 .3 0 .4 1 1 1))))
	  (float-vector->channel vals)
	  (if (not (mus-arrays-equal? vals #r(0.0 0.500 0.0 -0.500 0.0 0.500 0.0 -0.500 0.0 0.500 0.0 
							 -0.500 0.0 0.500 0.0 -0.500 0.0 0.500 0.0 -0.500 0.0 0.500 
							 0.0 -0.500 0.0 0.500 0.0 -0.500 0.0 0.500 0.0 -0.500)))
	      (snd-display "fft-env-data: ~A" vals)))
	(let ((hilbert-transform-via-fft
	       (let ((+documentation+ "same as FIR version but use FFT and change phases by hand"))
		 (lambda* (snd chn)
		   (let* ((size (framples snd chn))
			  (len (expt 2 (ceiling (log size 2.0)))))
		     (let ((rl (make-float-vector len))
			   (im (make-float-vector len))
			   (pi2 (* 0.5 pi)))
		       (do ((rd (make-sampler 0 snd chn))
			    (i 0 (+ i 1)))
			   ((= i size))
			 (set! (rl i) (rd)))
		       (mus-fft rl im len)
		       (rectangular->polar rl im)
		       (float-vector-offset! im (- pi2))
		       (do ((i (/ len 2) (+ i 1)))
			   ((= i len))
			 (float-vector-set! im i (+ (float-vector-ref im i) pi)))
		       (polar->rectangular rl im)
		       (mus-fft rl im len -1)
		       (float-vector-scale! rl (/ 1.0 len))
		       (float-vector->channel rl 0 len snd chn #f "hilbert-transform-via-fft")))))))
	  (hilbert-transform-via-fft))
	(let ((vals (channel->float-vector))
	      (nvals #r(-0.500 0.0 0.500 0.0 -0.500 0.0 0.500 0.0 -0.500 0.0 0.500 
				   0.0 -0.500 0.0 0.500 0.0 -0.500 0.0 0.500 0.0 -0.500 0.0 
				   0.500 0.0 -0.500 0.0 0.500 0.0 -0.500 0.0 0.500 -0.000)))
	  (if (not (mus-arrays-equal? vals nvals))
	      (snd-display "hilbert via dft: ~A" vals)))
	(revert-sound ind)
	(map-channel (lambda (y) 1.0))
	
	(powenv-channel '(0 0 .325  1 1 32.0 2 0 32.0))
	(let ((vals (channel->float-vector)))
	  (if (not (mus-arrays-equal? vals #r(0.0 0.107 0.206 0.298 0.384 0.463 0.536 0.605 0.668 0.727 0.781 0.832 0.879 
							 0.922 0.963 1.000 1.000 0.787 0.618 0.484 0.377 0.293 0.226 0.173 0.130 0.097 
							 0.070 0.049 0.032 0.019 0.008 0.000)))
	      (snd-display "powenv-channel: ~A" vals)))
	(undo)
	(revert-sound ind)
	(map-channel (lambda (y) 1.0))
	(env-sound '(0 0 1 1))
	(set! (cursor ind 0) 10)
	(make-selection 0 7 ind 0)
	(if (not (selection?))
	    (snd-display "make-selection failed??")
	    (begin
	      (replace-with-selection)
	      (let ((vals (channel->float-vector)))
		(if (not (mus-arrays-equal? vals #r(0.0 0.032 0.065 0.097 0.129 0.161 0.194 0.226 0.258 0.290 0.0 0.032 0.065 
							       0.097 0.129 0.161 0.194 0.226 0.581 0.613 0.645 0.677 0.710 0.742 0.774 0.806 
							       0.839 0.871 0.903 0.935 0.968 1.000)))
		    (snd-display "replace-with-selection: ~A" vals)))))
	(set! (cursor ind 0) 2)
	(replace-with-selection)
	(let ((vals (channel->float-vector)))
	  (if (not (mus-arrays-equal? vals #r(0.0 0.032 0.0 0.032 0.065 0.097 0.129 0.161 0.194 0.226 0.0 0.032 0.065 
							 0.097 0.129 0.161 0.194 0.226 0.581 0.613 0.645 0.677 0.710 0.742 0.774 0.806 
							 0.839 0.871 0.903 0.935 0.968 1.000)))
	      (snd-display "replace-with-selection (at 2): ~A" vals)))
	(revert-sound ind)
	(map-channel (lambda (y) 1.0))
	(env-sound '(0 0 1 1))
	
	(let ((m1 (add-mark 10))
	      (m2 (add-mark 20)))
	  (make-selection 0 9)
	  (fit-selection-between-marks m1 m2)
	  (let ((vals (channel->float-vector))) 
	    (if (not (mus-arrays-equal? vals #r(0.0 0.032 0.065 0.097 0.129 0.161 0.194 0.226 0.258 0.290 0.323 0.387 0.452 
							   0.516 0.581 0.645 0.710 0.774 0.839 0.903 0.645 0.677 0.710 0.742 0.774 0.806 
							   0.839 0.871 0.903 0.935 0.968 1.000)))
		(snd-display "fit-selection-between-marks: ~A" vals))))
	
	(revert-sound ind)
	(map-channel (lambda (y) 1.0))
	
	(let ((ramper (make-ramp 10)))
	  (map-channel (lambda (y) (ramp ramper y)))
	  (let ((vals (channel->float-vector 0 20)))
	    (if (not (mus-arrays-equal? vals #r(0.100 0.200 0.300 0.400 0.500 0.600 0.700 0.800 0.900 1.000 1.0
							   1.000 1.000 1.000 1.000 1.000 1.000 1.000 1.000 1.000)))
		(snd-display "make-ramp: ~A" vals))))
	(revert-sound ind)
	(float-vector->channel (with-sound ((make-float-vector 44100)) (cross-fade 0 2 1.0 "oboe.snd" "trumpet.snd" 0.5 1.0 0 .1 256 2)))
	(if (and (ffneq (maxamp) .142) (ffneq (maxamp) .155)) (snd-display "cross fade maxamp: ~A" (maxamp)))
	(revert-sound)
	(float-vector->channel (with-sound ((make-float-vector 44100)) (dissolve-fade 0 2 1.0 "oboe.snd" "trumpet.snd" 512 2 2 #f)))
	(clean-up-sound ind))	
      
      (let ((vals (apply float-vector (rms-envelope "oboe.snd" :rfreq 4))))
	(if (not (mus-arrays-equal? vals #r(0.0 0.0430 0.25 0.0642 0.5 0.0695 0.75 0.0722 1.0 0.0738 1.25 0.0713 
						       1.5 0.065 1.75 0.0439 2.0 0.01275 2.25 0.007)))
	    (snd-display "rms-envelope: ~A" vals)))
      
      (let ((ind (open-sound "2a.snd")))
	(hook-push graph-hook display-correlation)
	(update-time-graph)
	(set! (hook-functions graph-hook) ())
	(stereo->mono ind "hi1.snd" "hi2.snd")
	(let ((hi1 (find-sound "hi1.snd"))
	      (hi2 (find-sound "hi2.snd")))
	  (if (not (and hi1 hi2 (= (chans hi1) 1) (= (chans hi2) 1)))
	      (snd-display "stereo->mono: ~A ~A" (map file-name (sounds)) (map chans (sounds)))
	      (let ((dist1 (channel-distance ind 0 hi1 0))
		    (dist2 (channel-distance ind 1 hi2 0)))
		(if (or (fneq dist1 0.0) (fneq dist2 0.0))
		    (snd-display "stereo->mono distances: ~A ~A" dist1 dist2))
		(mono->stereo "ho2.snd" hi1 0 hi2 0)
		(let ((ho2 (find-sound "ho2.snd")))
		  (if (not (and ho2 (= (chans ho2) 2)))
		      (snd-display "mono->stereo: ~A" (map file-name (sounds)))
		      (let ((dist1 (channel-distance ho2 0 ind 0))
			    (dist2 (channel-distance ho2 1 ind 1)))
			(if (or (fneq dist1 0.0) (fneq dist2 0.0))
			    (snd-display "stereo->mono->stereo distances: ~A ~A" dist1 dist2))))
		  (close-sound ho2))))
	  (close-sound hi1)
	  (close-sound hi2))
	(close-sound ind))
      
      (if (file-exists? "hi1.snd") (delete-file "hi1.snd"))
      (if (file-exists? "hi2.snd") (delete-file "hi2.snd"))
      (if (file-exists? "ho2.snd") (delete-file "ho2.snd"))
      
      (let ((ind (new-sound :size 1000)))
	(map-channel (lambda (y) 0.5))
	(map-channel (vibro 1000.0 .5))
	(let ((vals (channel->float-vector 0 20)))
	  (if (not (or (mus-arrays-equal? vals #r(0.375 0.410 0.442 0.469 0.489 0.499 0.499 0.489 0.470 0.443 0.411 0.376 
							     0.341 0.308 0.281 0.262 0.251 0.251 0.261 0.280))
		       (mus-arrays-equal? vals #r(0.375 0.393 0.410 0.427 0.442 0.457 0.469 0.480 0.489 0.495 0.499 0.500 
							     0.499 0.495 0.489 0.480 0.470 0.457 0.443 0.428))))
	      (snd-display "no vibro? ~A" vals)))
	(clean-up-sound ind))
      
      (let ((ind (open-sound "pistol.snd")))
	(let ((pitch 1.1) 
	      (scaler .95) 
	      (secs .25))
	  (define-macro (make-fdelay len pitch scaler)
	    `(let ((body ())
		   (closure (list (list 'dly (list 'make-delay ,len))))
		   (old-freq 440.0)
		   (new-freq (* 440.0 ,pitch))
		   (pairs 10)
		   (order 40)
		   (bw 50.0))
	       (let ((factor (/ (- new-freq old-freq) old-freq)))
		 (do ((i 1 (+ i 4)))
		     ((> i pairs))
		   (let ((inner-body ())
			 (n (+ 1 (min 3 (- pairs i)))))
		     (do ((k 0 (+ k 1))) ; the inner loop is dividing up large sums for the optimizer's benefit (it can handle 4 at a time currently)
			 ((= k n))
		       (let ((aff (* (+ i k) old-freq))
			     (bwf (* bw (+ 1.0 (/ (+ i k) (* 2 pairs)))))
			     (ssb (string->symbol (format #f "s~D" (+ i k))))
			     (flt (string->symbol (format #f "g~D" (+ i k)))))
			 (set! closure (cons (list ssb (list 'make-ssb-am (* (+ i k) old-freq factor)))
					     (cons (list flt (list 'make-bandpass (hz->radians (- aff bw)) (hz->radians (+ aff bw)) order)) 
						   closure)))
			 (set! inner-body (cons (list 'ssb-am ssb (list 'bandpass flt 'y)) inner-body))))
		     (set! body (cons (append (list '+) inner-body) body))))
		 (apply let closure
			`((lambda (y) 
			    (+ y (delay dly (* ,,scaler (+ ,@body))))))))))
	  (map-channel (make-fdelay (round (* secs (srate))) pitch scaler)))
	(play :wait #t)
	(set! (channel-property 'colored-samples ind 0) (list (list *cursor-color* 0 100)))
	(hook-push after-graph-hook display-samples-in-color)
	(update-time-graph)
	(ssb-bank 220.0 440.0 10)
	(uncolor-samples)
	(let ((factor (/ (srate) (framples))))
	  (ssb-bank 557 (* 557.0 factor) 10)
	  (src-sound (/ 1.0 factor)))
	(close-sound ind))
      (hook-remove after-graph-hook display-samples-in-color)
      
      (let ((val 0)) 
	(tree-for-each (lambda (n) (set! val (+ val n))) (list (list 1 0) (list 2) 3))
	(if (not (= val 6)) (snd-display "tree-for-each: ~A" val)))
      
      (let ((ind (new-sound :channels 4 :size 32)))
	(set! (sample 0 ind 0) 0.5)
	(set! (sample 10 ind 1) 0.25)
	(set! (sample 20 ind 2) 0.125)
	(set! (sample 30 ind 3) 0.0625)
	(scramble-channels 3 2 0 1)                ; 3->0, 2->1, 0->2 1->3
	(if (or (fneq (sample 0 ind 2) .5)         ; chan 0 is 2 after swaps
		(fneq (sample 10 ind 3) .25)
		(fneq (sample 20 ind 1) .125)
		(fneq (sample 30 ind 0) .0625))
	    (snd-display "scramble-channels: ~A ~A ~A ~A (~A ~A ~A ~A)" 
			 (sample 0 ind 2) (sample 10 ind 3) (sample 20 ind 1) (sample 30 ind 2)
			 (sample 0 ind 0) (sample 10 ind 1) (sample 20 ind 2) (sample 30 ind 3)))
	(do ((i 0 (+ i 1))) ((= i 4)) (set! (edit-position ind i) 1))
	(scramble-channels 3 0 1 2)
	(if (or (fneq (sample 0 ind 1) .5)
		(fneq (sample 10 ind 2) .25)
		(fneq (sample 20 ind 3) .125)
		(fneq (sample 30 ind 0) .0625))
	    (snd-display "scramble-channels (1): ~A ~A ~A ~A (~A ~A ~A ~A)" 
			 (sample 0 ind 1) (sample 10 ind 2) (sample 20 ind 3) (sample 30 ind 0)
			 (sample 0 ind 0) (sample 10 ind 1) (sample 20 ind 2) (sample 30 ind 3)))
	(do ((i 0 (+ i 1))) ((= i 4)) (set! (edit-position ind i) 1))
	(scramble-channels 0 1 3 2)
	(if (or (fneq (sample 0 ind 0) .5)
		(fneq (sample 10 ind 1) .25)
		(fneq (sample 20 ind 3) .125)
		(fneq (sample 30 ind 2) .0625))
	    (snd-display "scramble-channels (2): ~A ~A ~A ~A (~A ~A ~A ~A)" 
			 (sample 0 ind 0) (sample 10 ind 1) (sample 20 ind 3) (sample 30 ind 2)
			 (sample 0 ind 0) (sample 10 ind 1) (sample 20 ind 2) (sample 30 ind 3)))
	(do ((i 0 (+ i 1))) ((= i 4)) (set! (edit-position ind i) 1))
	(scramble-channels 1 2 3 0)
	(if (or (fneq (sample 0 ind 3) .5)
		(fneq (sample 10 ind 0) .25)
		(fneq (sample 20 ind 1) .125)
		(fneq (sample 30 ind 2) .0625))
	    (snd-display "scramble-channels (3): ~A ~A ~A ~A (~A ~A ~A ~A)" 
			 (sample 0 ind 3) (sample 10 ind 0) (sample 20 ind 1) (sample 30 ind 2)
			 (sample 0 ind 0) (sample 10 ind 1) (sample 20 ind 2) (sample 30 ind 3)))
	(do ((i 0 (+ i 1))) ((= i 4)) (set! (edit-position ind i) 1))
	(clean-up-sound ind))
      
      (let ((ind (new-sound :channels 8 :size 10 :comment "new-sound for scramble-channels")))
	(do ((i 0 (+ i 1))) ((= i 8)) (set! (sample i ind i) .5))
	(scramble-channels 1 2 3 4 7 6 5 0)
	(if (or (fneq (sample 1 ind 0) .5)
		(fneq (sample 2 ind 1) .5)
		(fneq (sample 3 ind 2) .5)
		(fneq (sample 4 ind 3) .5)
		(fneq (sample 7 ind 4) .5)
		(fneq (sample 6 ind 5) .5)
		(fneq (sample 5 ind 6) .5)
		(fneq (sample 0 ind 7) .5))
	    (snd-display "scramble-channels 8 ways: ~A"
			 (list (sample 1 ind 0) (sample 2 ind 1) (sample 3 ind 2) (sample 4 ind 3)
			       (sample 7 ind 4) (sample 6 ind 5) (sample 5 ind 6) (sample 0 ind 7))))
	(clean-up-sound ind))
      
      ;; ---- *.scm
      (when (and (defined? 'effects-squelch-channel)
		 (or (provided? 'xm) (provided? 'xg)))
	(let ((ctr 1))
	  (for-each
	   (lambda (func1 descr)
	     (func1)
	     (let ((func (edit-list->function)))
	       (if (not (equal? (procedure-source func) descr))
		   (snd-display "edit-list->function 20[~D]:~%;  [~A]~%;  [~A]" ctr descr (procedure-source func))
		   (begin
		     (revert-sound ind)
		     (func ind 0))))
	     (set! ctr (+ ctr 1))
	     (revert-sound ind))
	   (list 
	    (lambda () (insert-float-vector #r(1.0 0.5) 0 2))
	    clm-channel-test
	    
	    ;; examp.scm
	    (lambda () (fft-edit 1000 3000))
	    (lambda () (fft-squelch .01))
	    (lambda () (fft-cancel 1000 3000))
	    squelch-vowels
	    (lambda () (fft-env-edit '(0 0 1 1 2 0)))
	    (lambda () (fft-env-interp '(0 0 1 1 2 0) '(0 1 1 0 2 0) '(0 0 1 1)))
	    (lambda () (hello-dentist 10.0 .1))
	    (lambda () (fp 1.0 0.3 20.0))
	    (lambda () (expsnd '(0 1 1 2)))
	    (lambda () (env-sound-interp '(0 0 1 1 2 0) 2.0))
	    (lambda () (add-notes '(("1a.snd") ("pistol.snd" 1.0 2.0))))
	    (lambda () (filtered-env '(0 0 1 1 2 0)))
	    (lambda () (reverse-by-blocks .1))
	    (lambda () (reverse-within-blocks .1))
	    
	    ;; extensions.scm
	    (lambda () (mix-channel "1a.snd" 1200))
	    (lambda () (insert-channel "1a.snd" 1200))
	    (lambda () (sine-ramp 0.5 0.9))
	    (lambda () (sine-env-channel '(0 0 1 1 2 -0.5 3 1)))
	    (lambda () (blackman4-ramp 0.0 1.0))
	    (lambda () (blackman4-env-channel '(0 0 1 1 2 -0.5 3 1)))
	    (lambda () (ramp-squared 0.2 0.8 #t))
	    (lambda () (env-squared-channel '(0.0 0.0 1.0 1.0) #t))
	    (lambda () (ramp-expt 0.2 0.8 32.0 #t))
	    (lambda () (env-expt-channel '(0.0 0.0 1.0 1.0) 32.0 #t))
	    (lambda () (offset-channel .1))
	    (lambda () (dither-channel .1))
	    (lambda () (contrast-channel .1))
	    
	    ;; dsp.scm
	    (lambda () (ssb-bank 550 600 10))
	    (lambda () (ssb-bank-env 550 600 '(0 1 1 2) 10))	   
	    (lambda () (down-oct 1))
	    spike
	    zero-phase
	    (lambda () (rotate-phase (lambda (x) (random pi))))
	    (lambda () (brighten-slightly .5))
	    (lambda () (shift-channel-pitch 100))
	    (lambda () (channel-polynomial #r(0.0 0.5)))
	    (lambda () (spectral-polynomial #r(0.0 1.0)))
	    (lambda () (notch-channel (list 60.0 120.0 240.0) #f #f #f))
	    
	    ;; ---- new-effects.scm
	    (lambda () (effects-squelch-channel .1 128))
	    (lambda () (effects-echo #f 0.5 0.1 0 #f))
	    (lambda () (effects-flecho-1 0.5 0.1 #f 0 #f))
	    (lambda () (effects-zecho-1 0.75 0.75 6.0 10.0 #f 0 #f))
	    ;;		      (lambda () (effects-comb-filter 0.1 50 0 #f))
	    (lambda () (effects-moog 10000 0.5 0 #f))
	    effects-remove-dc
	    effects-compand
	    (lambda () (effects-am 100.0 #f))
	    (lambda () (effects-rm 100.0 #f))
	    (lambda () (effects-bbp 1000.0 100.0 0 #f))
	    (lambda () (effects-bbr 1000.0 100.0 0 #f))
	    (lambda () (effects-bhp 1000.0 0 #f))
	    (lambda () (effects-blp 1000.0 0 #f))
	    (lambda () (effects-hello-dentist 50.0 0.5 0 #f))
	    (lambda () (effects-fp 1.0 0.3 20.0 0 #f))
	    (lambda () (effects-flange 5.0 2.0 0.001 0 #f))
	    (lambda () (effects-jc-reverb-1 0.1 0 #f)))
	   '((lambda (snd chn) (insert-float-vector #r(1.0 0.5) 0 2 snd chn))
	     (lambda (snd chn) (clm-channel-test snd chn))
	     
	     (lambda (snd chn) (fft-edit 1000 3000 snd chn))
	     (lambda (snd chn) (fft-squelch 0.01 snd chn))
	     (lambda (snd chn) (fft-cancel 1000 3000 snd chn))
	     (lambda (snd chn) (squelch-vowels snd chn))
	     (lambda (snd chn) (fft-env-edit '(0 0 1 1 2 0) snd chn))
	     (lambda (snd chn) (fft-env-interp '(0 0 1 1 2 0) '(0 1 1 0 2 0) '(0 0 1 1) snd chn))
	     (lambda (snd chn) (hello-dentist 10.0 0.1 snd chn))
	     (lambda (snd chn) (fp 1.0 0.3 20.0 snd chn))
	     (lambda (snd chn) (expsnd '(0 1 1 2) snd chn))
	     (lambda (snd chn) (env-sound-interp '(0 0 1 1 2 0) 2.0 snd chn))
	     (lambda (snd chn) (add-notes '(("1a.snd") ("pistol.snd" 1.0 2.0)) snd chn))
	     (lambda (snd chn) (filtered-env '(0 0 1 1 2 0) snd chn))
	     (lambda (snd chn) (reverse-by-blocks 0.1 snd chn))
	     (lambda (snd chn) (reverse-within-blocks 0.1 snd chn))
	     
	     (lambda (snd chn) (mix-channel "1a.snd" 1200 #f snd chn))
	     (lambda (snd chn) (insert-channel "1a.snd" 1200 #f snd chn))
	     (lambda (snd chn) (sine-ramp 0.5 0.9 0 #f snd chn))
	     (lambda (snd chn) (sine-env-channel '(0 0 1 1 2 -0.5 3 1) 0 #f snd chn))
	     (lambda (snd chn) (blackman4-ramp 0.0 1.0 0 #f snd chn))
	     (lambda (snd chn) (blackman4-env-channel '(0 0 1 1 2 -0.5 3 1) 0 #f snd chn))
	     (lambda (snd chn) (ramp-squared 0.2 0.8 #t 0 #f snd chn))
	     (lambda (snd chn) (env-squared-channel '(0.0 0.0 1.0 1.0) #t 0 #f snd chn))
	     (lambda (snd chn) (ramp-expt 0.2 0.8 32.0 #t 0 #f snd chn))
	     (lambda (snd chn) (env-expt-channel '(0.0 0.0 1.0 1.0) 32.0 #t 0 #f snd chn))
	     (lambda (snd chn) (offset-channel 0.1 0 #f snd chn))
	     (lambda (snd chn) (dither-channel 0.1 0 #f snd chn))
	     (lambda (snd chn) (contrast-channel 0.1 0 #f snd chn))
	     
	     (lambda (snd chn) (ssb-bank 550 600 10 40 50.0 0 #f snd chn))
	     (lambda (snd chn) (ssb-bank-env 550 600 '(0 1 1 2) 10 40 50.0 0 #f snd chn))
	     (lambda (snd chn) (down-oct 1 snd chn))
	     (lambda (snd chn) (spike snd chn))
	     (lambda (snd chn) (zero-phase snd chn))
	     (lambda (snd chn) (rotate-phase (lambda (x) (random pi)) snd chn))
	     (lambda (snd chn) (brighten-slightly 0.5 snd chn))
	     (lambda (snd chn) (shift-channel-pitch 100 40 0 #f snd chn))
	     (lambda (snd chn) (channel-polynomial #r(0.0 0.5) snd chn))
	     (lambda (snd chn) (spectral-polynomial #r(0.0 1.0) snd chn))
	     (lambda (snd chn) (notch-channel '(60.0 120.0 240.0) #f #f #f snd chn))
	     
	     (lambda (snd chn) (effects-squelch-channel 0.1 128 snd chn))
	     (lambda (snd chn) (effects-echo #f 0.5 0.1 0 #f snd chn))
	     (lambda (snd chn) (effects-flecho-1 0.5 0.1 #f 0 #f snd chn))
	     (lambda (snd chn) (effects-zecho-1 0.75 0.75 6.0 10.0 #f 0 #f snd chn))
	     ;;		      (lambda (snd chn) (effects-comb-filter 0.1 50 0 #f snd chn))
	     (lambda (snd chn) (effects-moog 10000 0.5 0 #f snd chn))
	     (lambda (snd chn) (effects-remove-dc snd chn))
	     (lambda (snd chn) (effects-compand snd chn))
	     (lambda (snd chn) (effects-am 100.0 #f #f #f snd chn))
	     (lambda (snd chn) (effects-rm 100.0 #f #f #f snd chn))
	     (lambda (snd chn) (effects-bbp 1000.0 100.0 0 #f snd chn))
	     (lambda (snd chn) (effects-bbr 1000.0 100.0 0 #f snd chn))
	     (lambda (snd chn) (effects-bhp 1000.0 0 #f snd chn))
	     (lambda (snd chn) (effects-blp 1000.0 0 #f snd chn))
	     (lambda (snd chn) (effects-hello-dentist 50.0 0.5 0 #f snd chn))
	     (lambda (snd chn) (effects-fp 1.0 0.3 20.0 0 #f snd chn))
	     (lambda (snd chn) (effects-flange 5.0 2.0 0.001 0 #f snd chn))
	     (lambda (snd chn) (effects-jc-reverb-1 0.1 0 #f snd chn))))))
      (close-sound ind))
    
    ;; ---- apply controls edit lists
    (set! (*s7* 'print-length) 12345)
    (let ((ind (open-sound "oboe.snd")))
      (let ((original-maxamp (maxamp)))
	(reset-controls)
	(controls->channel '(2.0))
	(if (fneq (amp-control ind) 1.0) (snd-display "controls->channel amp: ~A" (amp-control ind)))
	(if (fneq (maxamp) (* 2 original-maxamp)) (snd-display "controls->channel maxamp: ~A" (maxamp))))
      (let ((func (edit-list->function)))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (scale-channel 2.0 0 #f snd chn))))
	    (snd-display "edit-list->function controls->channel 1: ~A" (procedure-source func))
	    (func ind 0))
	(revert-sound ind))
      
      (controls->channel '(#f 2.0))
      (let ((pk (float-vector-peak (channel->float-vector 22000 22100))))
	(if (fneq pk 0.0479) (snd-display "dp->end screwed up again!?!: ~A" pk)))
      (let ((func (edit-list->function)))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (controls->channel '(#f 2.0) 0 #f snd chn))))
	    (snd-display "edit-list->function controls->channel 2: ~A" (procedure-source func))
	    (begin
	      (revert-sound ind)
	      (func ind 0)))
	(revert-sound ind)
	(if (fneq (speed-control ind) 1.0) (snd-display "controls->channel speed: ~A" (speed-control ind))))
      
      (controls->channel (list #f #f (list 0.5)))
      (let ((func (edit-list->function)))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (controls->channel '(#f #f (0.5)) 0 #f snd chn))))
	    (snd-display "edit-list->function controls->channel 3: ~A" (procedure-source func))
	    (begin
	      (revert-sound ind)
	      (func ind 0)))
	(revert-sound ind)
	(if (fneq (contrast-control ind) 0.0) (snd-display "controls->channel contrast: ~A" (contrast-control ind))))
      
      (controls->channel (list #f #f (list 0.5 2.0)))
      (let ((func (edit-list->function)))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (controls->channel '(#f #f (0.5 2.0)) 0 #f snd chn))))
	    (snd-display "edit-list->function controls->channel 3a: ~A" (procedure-source func))
	    (begin
	      (revert-sound ind)
	      (func ind 0)))
	(revert-sound ind)
	(if (fneq (contrast-control ind) 0.0) (snd-display "controls->channel contrast 3a: ~A" (contrast-control ind))))
      
      (controls->channel (list #f #f #f (list 0.5)))
      (let ((func (edit-list->function)))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (controls->channel '(#f #f #f (0.5)) 0 #f snd chn))))
	    (snd-display "edit-list->function controls->channel 4: ~A" (procedure-source func))
	    (begin
	      (revert-sound ind)
	      (func ind 0)))
	(revert-sound ind)
	(if (ffneq (expand-control ind) 1.0) (snd-display "controls->channel expand: ~A" (expand-control ind))))
      
      (controls->channel (list #f #f #f (list 0.5 .1 .2 .06 0.0)))
      (let ((func (edit-list->function)))
	(if (not (equal? (procedure-source func) 
			 '(lambda (snd chn) (controls->channel '(#f #f #f (0.5 0.1 0.2 0.06 0.0)) 0 #f snd chn))))
	    (snd-display "edit-list->function controls->channel 4a: ~A" (procedure-source func))
	    (begin
	      (revert-sound ind)
	      (func ind 0)))
	(revert-sound ind)
	(if (ffneq (expand-control ind) 1.0) (snd-display "controls->channel expand 4a: ~A" (expand-control ind))))
      
      (controls->channel (list #f #f #f #f (list 0.1)))
      (let ((func (edit-list->function)))
	(if (not (equal? (procedure-source func) '(lambda (snd chn) (controls->channel '(#f #f #f #f (0.1)) 0 #f snd chn))))
	    (snd-display "edit-list->function controls->channel 5: ~A" (procedure-source func))
	    (begin
	      (revert-sound ind)
	      (func ind 0)))
	(revert-sound ind)
	(if (fneq (reverb-control-scale ind) 0.0) (snd-display "controls->channel reverb: ~A" (reverb-control-scale ind))))
      
      (controls->channel (list #f #f #f #f (list 0.1 1.2 0.9 0.9 2.0)))
      (let ((func (edit-list->function)))
	(if (not (equal? (procedure-source func) 
			 '(lambda (snd chn) (controls->channel '(#f #f #f #f (0.1 1.2 0.9 0.9 2.0)) 0 #f snd chn))))
	    (snd-display "edit-list->function controls->channel 5a: ~A" (procedure-source func))
	    (begin
	      (revert-sound ind)
	      (func ind 0)))
	(revert-sound ind)
	(if (fneq (reverb-control-scale ind) 0.0) (snd-display "controls->channel reverb 5a: ~A" (reverb-control-scale ind))))
      
      (let ((order (filter-control-order ind)))
	(controls->channel (list #f #f #f #f #f (list 10 '(0 0 1 1))))
	(let ((func (edit-list->function)))
	  (if (not (equal? (procedure-source func) 
			   '(lambda (snd chn) (controls->channel '(#f #f #f #f #f (10 (0 0 1 1))) 0 #f snd chn))))
	      (snd-display "edit-list->function controls->channel 6: ~A" (procedure-source func))
	      (begin
		(revert-sound ind)
		(func ind 0)))
	  (revert-sound ind)
	  (if (not (= (filter-control-order ind) order)) (snd-display "controls->channel filter: ~A" (filter-control-order ind)))))
      
      (close-sound ind))
    
    (let ((ind (open-sound "2.snd")))
      (src-sound 3.0 1.0 ind)
      (save-sound-as "test.snd")
      (close-sound ind)
      (set! ind (open-sound "test.snd"))
      (if (not (= (chans ind) 2)) (snd-display "src-sound/save-sound-as-> ~D chans" (chans ind)))
      (let ((tag (scan-channel (lambda (y) (> (abs y) 0.0)) 8000 #f)))
	(if tag (snd-display "src-sound/save-sound-as not zeros: ~A ~A" tag (sample (cadr tag) ind 0))))
      (close-sound ind))
    
    (let ((ind (open-sound "oboe.snd")))
      (let ((tag (catch #t (lambda () (save-sound-as "test.snd" :edit-position 1)) (lambda args args))))
	(if (not (and (pair? tag) (eq? (car tag) 'no-such-edit)))
	    (snd-display "save-sound-as bad edpos: ~A" tag)))
      (let ((tag (catch #t (lambda () (save-sound-as "test.snd" :channel 1 :edit-position 1)) (lambda args args))))
	(if (not (and (pair? tag) (eq? (car tag) 'no-such-channel)))
	    (snd-display "save-sound-as bad chan: ~A" tag)))
      (save-sound-as "test.snd" :comment "this is a comment")
      (close-sound ind)
      (set! ind (open-sound "test.snd"))
      (if (not (string=? (comment ind) "this is a comment"))
	  (snd-display "save-sound-as with comment: ~A" (comment ind)))
      (close-sound ind))
    
    ;; these are from Tito Latini
    
    (if (file-exists? "s61.scm") (delete-file "s61.scm"))
    
    (let ((ind (new-sound "fmv.snd" :size 100)))
      (src-sound .5)
      (set! (cursor) 150)
      (set! (selection-position) 170)
      (set! (selection-framples) 20)
      (set! (speed-control) -2.0)
      (save-state "s61.scm")
      (close-sound ind))
    
    (load "s61.scm")
    
    (if (not (= (cursor) 150)) 
	(snd-display "save-state cursor: ~A" (cursor)))
    (if (not (= (selection-position) 170)) 
	(snd-display "save-state selection-position: ~A" (selection-position)))
    (if (not (= (selection-framples) 20)) 
	(snd-display "save-state selection-framples: ~A" (selection-framples)))
    (if (fneq (speed-control) -2.0) 
	(snd-display "save-state srate: ~A" (srate)))
    (close-sound)
    
    (if (file-exists? "s61.scm") (delete-file "s61.scm"))
    
    (let ((ind (new-sound "fmv.snd" :size 100000)))
      (let ((m1 (car (mix "oboe.snd" 0)))
	    (m2 (car (mix "pistol.snd" 48000))))
	(set! (mix-position m2) 20000)
	(set! (mix-position m1) 60000)
	(set! (mix-amp m1) 0.5)
	(set! (mix-amp-env m1) '(0 0 2 1 10 0))
	(set! (mix-amp m2) 0.25)
	(set! (mix-amp-env m2) '(0 0 8 1 10 0))
	(set! (mix-speed m2) 1.5))
      (save-state "s61.scm")
      (close-sound ind))
    
    (load "s61.scm")
    
    (let ((m1 ((if (= (mix-position (caaar (mixes))) 20000) caaar cadaar) (mixes)))
	  (m2 ((if (= (mix-position (caaar (mixes))) 60000) caaar cadaar) (mixes))))
      (if (fneq (mix-amp m1) 0.25)
	  (snd-display "save-state mix-amp 0: ~A" (mix-amp m1)))
      (if (fneq (mix-amp m2) 0.5)
	  (snd-display "save-state mix-amp 1: ~A" (mix-amp m2)))
      (if (fneq (mix-speed m1) 1.5)
	  (snd-display "save-state mix-speed 0: ~A" (mix-speed m1)))
      (if (fneq (mix-speed m2) 1.0)
	  (snd-display "save-state mix-speed 1: ~A" (mix-speed m2)))
      (if (not (equivalent? (mix-amp-env m1) '(0.0 0.0 8.0 1.0 10.0 0.0)))
	  (snd-display "save-state mix-amp-env 0: ~A" (mix-amp-env m1)))  
      (if (not (equivalent? (mix-amp-env m2) '(0.0 0.0 2.0 1.0 10.0 0.0)))
	  (snd-display "save-state mix-amp-env 1: ~A" (mix-amp-env m2)))
      (close-sound))
    (if (file-exists? "s61.scm") (delete-file "s61.scm"))
    (for-each forget-region (regions))
    
    (let ((ind (new-sound "fmv.snd" :size 321)))
      (make-region 0 123)
      (save-state "s61.scm")
      (close-sound ind))
    
    (load "s61.scm")
    
    (let ((reg (region-home (car (regions)))))
      (if (not (equal? reg '("fmv.snd" 0 124)))
	  (snd-display "save-state region-home: ~A" reg)))
    (close-sound)
    (if (file-exists? "s61.scm") (delete-file "s61.scm"))
    (for-each forget-region (regions))
    
    (let ((ind (open-sound "2.snd")))
      (set! (selection-position) 2400)
      (set! (selection-framples) 4800)
      (let ((mx (car (mix-selection 6000))))
	(set! (mix-amp-env mx) '(0 0 1 1 2 0)))
      (set! (selection-position) 5000)
      (set! (selection-framples) 2000)
      (mix "2a.snd" 8000)
      (mix-selection 4000)
      (save-state "s61.scm")
      (close-sound ind))
    
    (load "s61.scm")
    (if (not (selection?))
	(snd-display "save-state: no selection")
	(begin
	  (if (not (= (selection-position) 5000))
	      (snd-display "save-state selection-position: ~A" (selection-position)))
	  (if (not (= (selection-framples) 2000))
	      (snd-display "save-state selection-framples: ~A" (selection-framples)))
	  (if (not (equal? (sort! (map mix-position (caar (mixes))) <) '(4000 6000 8000)))
	      (snd-display "save-state mix-positions: ~A" (map mix-position (caar (mixes)))))
	  (if (not (equal? (sort! (map mix-length (cadar (mixes))) <) '(2000 4800)))
	      (snd-display "save-state mix lengths: ~A" (map mix-length (cadar (mixes)))))))
    (close-sound)
    (if (file-exists? "s61.scm") (delete-file "s61.scm"))
    (for-each forget-region (regions))
    (mus-sound-prune)))
    


;;; ---------------- test 19: transforms ----------------
(define snd_test_19
  (let ()
    (define (bes-j0-1 x)				;returns J0(x) for any real x
      (if (< (abs x) 8.0)			;direct rational function fit
	  (let ((y (* x x)))
	    (let ((ans1 (+ 57568490574.0000 (* y (- (* y (+ 651619640.7 (* y (- (* y (+ 77392.33017 (* y -184.9052456))) 11214424.18)))) 13362590354.0))))
		  (ans2 (+ 57568490411.0 
			   (* y (+ 1029532985.0 
				   (* y (+ 9494680.718
					   (* y (+ 59272.64853
						   (* y (+ 267.8532712 y)))))))))))
	      (/ ans1 ans2)))
	  (let* ((ax (abs x))
		 (z (/ 8.0 ax))
		 (y (* z z)))
	    (let ((xx (- ax 0.785398164))
		  (ans1 (+ 1.0 (* y (- (* y (+ 2.734510407e-05 (* y (- (* y 2.093887211e-07) 2.073370639e-06)))) 0.001098628627))))
		  (ans2 (- (* y (+ 0.0001 (* y (- (* y (+ 7.621095160999999e-07 (* y -9.34945152e-08))) 6.911147651000001e-06)))) 0.0156)))
	      (* (sqrt (/ 0.636619772 ax))
		 (- (* ans1 (cos xx))
		    (* z (sin xx) ans2)))))))
    
    (define (test-j0)
      (for-each 
       (lambda (x)
	 (if (fneq (bes-j0 x) (bes-j0-1 x))
	     (snd-display "(bes-j0 ~A) -> ~A ~A" x (bes-j0 x) (bes-j0-1 x))))
       '(0.0 0.5 1.0 2.0 20.0))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(let ((x (random 100.0)))
	  (if (fneq (bes-j0 x) (bes-j0-1 x))
	      (snd-display "(bes-j0 ~A) -> ~A ~A" x (bes-j0 x) (bes-j0-1 x))))))
    
    
    (define bes-j1-1 
      (let ((signum (lambda (x) (if (= x 0.0) 0 (if (< x 0.0) -1 1)))))
	(lambda (x)				;returns J1(x) for any real x
	  (if (< (abs x) 8.0)
	      (let ((y (* x x)))
		(let ((ans1 (* x (+ 72362614232.0000 (* y (- (* y (+ 242396853.1 (* y (- (* y (+ 15704.4826 (* y -30.16036606))) 2972611.439)))) 7895059235.0)))))
		      (ans2 (+ 144725228442.0 
			       (* y (+ 2300535178.0 
				       (* y (+ 18583304.74
					       (* y (+ 99447.43394
						       (* y (+ 376.9991397 y)))))))))))
		  (/ ans1 ans2)))
	      (let* ((ax (abs x))
		     (z (/ 8.0 ax))
		     (y (* z z)))
		(let ((xx (- ax 2.356194491))
		      (ans1 (+ 1.0 (* y (+ 0.00183105 (* y (- (* y (+ 2.457520174e-06 (* y -2.40337019e-07))) 3.516396496e-05))))))
		      (ans2 (+ 0.0469 (* y (- (* y (+ 8.449199096000001e-06 (* y (- (* y 1.05787412e-07) 8.8228987e-07)))) 0.0002002690873)))))
		  (* (signum x)
		     (sqrt (/ 0.636619772 ax))
		     (- (* ans1 (cos xx))
			(* z (sin xx) ans2)))))))))
    
    (define (test-j1)
      (for-each 
       (lambda (x)
	 (if (fneq (bes-j1 x) (bes-j1-1 x))
	     (snd-display "(bes-j1 ~A) -> ~A ~A" x (bes-j1 x) (bes-j1-1 x))))
       '(0.0 0.5 1.0 2.0 20.0))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(let ((x (random 100.0)))
	  (if (fneq (bes-j1 x) (bes-j1-1 x))
	      (snd-display "(bes-j1 ~A) -> ~A ~A" x (bes-j1 x) (bes-j1-1 x))))))
    
    (define test-jn
      (let ((bes-jn-1 
	     (lambda (nn x)				;return Jn(x) for any integer n, real x
	       (let ((besn (let ((n (abs nn)))
			     (cond ((= n 0) (bes-j0-1 x))
				   ((= n 1) (bes-j1-1 x))
				   ((= x 0.0) 0.0)
				   (else
				    (let ((iacc 40)
					  (ans 0.0000)
					  (bigno 1.0e10)
					  (bigni 1.0e-10))
				      (if (> (abs x) n)
					  (do ((tox (/ 2.0 (abs x)))
					       (bjm (bes-j0-1 (abs x)))
					       (bj (bes-j1-1 (abs x)))
					       (j 1 (+ j 1))
					       (bjp 0.0))
					      ((= j n) (set! ans bj))
					    (set! bjp (- (* j tox bj) bjm))
					    (set! bjm bj)
					    (set! bj bjp))
					  (let ((tox (/ 2.0 (abs x)))
						(m (* 2 (floor (/ (+ n (sqrt (* iacc n))) 2))))
						(jsum 0)
						(bjm 0.0000)
						(sum 0.0000)
						(bjp 0.0000)
						(bj 1.0000))
					    (do ((j m (- j 1)))
						((= j 0))
					      (set! bjm (- (* j tox bj) bjp))
					      (set! bjp bj)
					      (set! bj bjm)
					      (when (> (abs bj) bigno)
						(set! bj (* bj bigni))
						(set! bjp (* bjp bigni))
						(set! ans (* ans bigni))
						(set! sum (* sum bigni)))
					      (if (not (= 0 jsum))
						  (set! sum (+ sum bj)))
					      (set! jsum (- 1 jsum))
					      (if (= j n) (set! ans bjp)))
					    (set! ans (/ ans (- (* 2.0 sum) bj)))))
				      (if (and (< x 0.0) (odd? n))
					  (- ans)
					  ans)))))))
		 (if (and (< nn 0)
			  (odd? nn))
		     (- besn)
		     besn)))))
	(lambda ()
	  (do ((k 0 (+ k 1)))
	      ((= k 10))
	    (do ((i 0 (+ i 1)))
		((= i 10))
	      (let ((x (random 100.0)))
		(if (fneq (bes-jn k x) (bes-jn-1 k x))
		    (snd-display "(bes-jn ~A ~A) -> ~A ~A" k x (bes-jn k x) (bes-jn-1 k x)))))))))
    
    
    (define (bes-y0-1 x)				;Bessel function Y0(x)
      (if (< x 8.0)
	  (let ((y (* x x)))
	    (let ((ans1 (- (* y (+ 7062834065.0 (* y (- (* y (+ 10879881.29 (* y (- (* y 228.4622733) 86327.92757)))) 512359803.6)))) 2957821389.0000))
		  (ans2 (+ 40076544269.0
			   (* y (+ 745249964.8
				   (* y (+ 7189466.438
					   (* y (+ 47447.26470
						   (* y (+ 226.1030244 y)))))))))))
	      (+ (/ ans1 ans2) (* 0.636619772 (bes-j0 x) (log x)))))
	  (let ((ans (let* ((z (/ 8.0 x))
			    (y (* z z)))
		       (let ((xx (- x 0.785398164))
			     (ans1 (+ 1.0 (* y (- (* y (+ 2.734510407e-05 (* y (- (* y 2.093887211e-07) 2.073370639e-06)))) 0.001098628627))))
			     (ans2 (- (* y (+ 0.0001 (* y (- (* y (+ 7.621095160999999e-07 (* y -9.34945152e-08))) 6.911147651000001e-06)))) 0.0156)))
			 (+ (* ans1 (sin xx)) (* z (cos xx) ans2))))))
	    (* (sqrt (/ 0.636619772 x)) ans))))
    
    (define (test-y0)
      (for-each 
       (lambda (x)
	 (if (fneq (bes-y0 x) (bes-y0-1 x))
	     (snd-display "(bes-y0 ~A) -> ~A ~A" x (bes-y0 x) (bes-y0-1 x))))
       '(0.5 1.0 2.0 20.0))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(let ((x (random 100.0)))
	  (if (fneq (bes-y0 x) (bes-y0-1 x))
	      (snd-display "(bes-y0 ~A) -> ~A ~A" x (bes-y0 x) (bes-y0-1 x))))))
    
    (define (bes-y1-1 x)				;Bessel function Y1(x)
      (if (= x 0.0)
	  (real-part (log 0.0)) ; -inf.0
	  (if (< x 8.0)
	      (let ((y (* x x)))
		(let ((ans1 (* x (- (* y (+ 1275274390000.0000 (* y (- (* y (+ 734926455.1 (* y (- (* y 8511.937935) 4237922.726)))) 51534381390.0)))) 4900604943000.0000)))
		      (ans2 (+ 0.2499580570e14
			       (* y (+ 0.4244419664e12
				       (* y (+ 0.3733650367e10
					       (* y (+ 0.2245904002e8
						       (* y (+ 0.1020426050e6
							       (* y (+ 0.3549632885e3 y)))))))))))))
		  (+ (/ ans1 ans2) (* 0.636619772 (- (* (bes-j1 x) (log x)) (/ 1.0 x))))))
	      (let* ((z (/ 8.0 x))
		     (y (* z z)))
		(let ((xx (- x 2.356194491))
		      (ans1 (+ 1.0 (* y (+ 0.00183105 (* y (- (* y (+ 2.457520174e-06 (* y -2.40337019e-07))) 3.516396496e-05))))))
		      (ans2 (+ 0.0469 (* y (- (* y (+ 8.449199096000001e-06 (* y (- (* y 1.05787412e-07) 8.8228987e-07)))) 0.000200269087)))))
		  (* (sqrt (/ 0.636619772 x)) (+ (* ans1 (sin xx)) (* z (cos xx) ans2))))))))
    
    (define (test-y1)
      (for-each 
       (lambda (x)
	 (if (fneq (bes-y1 x) (bes-y1-1 x))
	     (snd-display "(bes-y1 ~A) -> ~A ~A" x (bes-y1 x) (bes-y1-1 x))))
       '(0.01 0.5 1.0 2.0 20.0))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(let ((x (random 100.0)))
	  (if (ffneq (bes-y1 x) (bes-y1-1 x))
	      (snd-display "(bes-y1 ~A) -> ~A ~A" x (bes-y1 x) (bes-y1-1 x))))))
    
    (define test-yn
      (let ((bes-yn-1 
	     (lambda (n x)				;return Yn(x) for any integer n, real x
	       (case n
		 ((0) (bes-y0-1 x))
		 ((1) (bes-y1-1 x))
		 (else 
		  (do ((tox (/ 2.0 x))
		       (byp 0.0)
		       (by (bes-y1-1 x))
		       (bym (bes-y0-1 x))
		       (j 1 (+ j 1)))
		      ((= j n) by)
		    (set! byp (- (* j tox by) bym))
		    (set! bym by)
		    (set! by byp)))))))
	(lambda ()
	  (do ((k 0 (+ k 1)))
	      ((= k 10))
	    (do ((i 0 (+ i 1)))
		((= i 10))
	      (let ((x (random 100.0)))
		(if (ffneq (/ (bes-yn k x) (bes-yn-1 k x)) 1.0)
		    (snd-display "(bes-yn ~A ~A) -> ~A ~A" k x (bes-yn k x) (bes-yn-1 k x)))))))))
    
    
    (define test-i0
      (let ((bes-i0-1 
	     (lambda (x)			;I0(x)
	       (if (< (abs x) 3.75)
		   (let ((y (expt (/ x 3.75) 2)))
		     (+ 1.0
			(* y (+ 3.5156229
				(* y (+ 3.0899424
					(* y (+ 1.2067492
						(* y (+ 0.2659732
							(* y (+ 0.360768e-1
								(* y 0.45813e-2)))))))))))))
		   (let* ((ax (abs x))
			  (y (/ 3.75 ax)))
		     (* (/ (exp ax) (sqrt ax))
			(+ 0.3989 (* y (+ 0.0133 
					  (* y (+ 0.0023 
						  (* y (- (* y (+ 0.0092 
								  (* y (- (* y (+ 0.02635537 
										  (* y (- (* y 0.00392377) 0.01647633)))) 
									  0.02057706)))) 
							  0.0016)))))))))))))
	(lambda ()
	  (for-each 
	   (lambda (x)
	     (if (fneq (bes-i0 x) (bes-i0-1 x))
		 (snd-display "(bes-i0 ~A) -> ~A ~A" x (bes-i0 x) (bes-i0-1 x))))
	   '(0.0 0.5 1.0 2.0 0.01))
	  (do ((i 0 (+ i 1)))
	      ((= i 10))
	    (let ((x (random 1.0)))
	      (if (fneq (bes-i0 x) (bes-i0-1 x))
		  (snd-display "(bes-i0 ~A) -> ~A ~A" x (bes-i0 x) (bes-i0-1 x))))))))
    
    (define (bes-i1 x)				;I1(x)
      (if (< (abs x) 3.75)
	  (let ((y (expt (/ x 3.75) 2)))
	    (* x (+ 0.5
		    (* y (+ 0.87890594
			    (* y (+ 0.51498869
				    (* y (+ 0.15084934
					    (* y (+ 0.2658733e-1
						    (* y (+ 0.301532e-2
							    (* y 0.32411e-3))))))))))))))
	  (let ((ax (abs x)))
	    (let ((ans2 (let* ((y (/ 3.75 ax))
			       (ans1 (+ 0.02282967 (* y (- (* y (+ 0.01787654 (* y -0.00420059))) 0.02895312)))))
			  (+ 0.39894228 (* y (- (* y (- (* y (+ 0.00163801 (* y (- (* y ans1) 0.01031555)))) 0.00362018)) 0.03988024)))))
		  (sign (if (< x 0.0) -1.0 1.0)))
	      (/ (* (exp ax) ans2 sign) (sqrt ax))))))
    
    (define (test-i1)
      (if (fneq (bes-i1 1.0) 0.565159) (snd-display "bes-i1 1.0: ~A" (bes-i1 1.0)))
      (if (fneq (bes-i1 2.0) 1.59063685) (snd-display "bes-i1 2.0: ~A" (bes-i1 2.0)))
      (if (fneq (bes-i1 5.0) 24.33564) (snd-display "bes-i1 5.0: ~A" (bes-i1 5.0)))
      (if (fneq (bes-i1 10.0) 2670.9883) (snd-display "bes-i1 10.0: ~A" (bes-i1 10.0))))
    
    (define test-in
      (let ((bes-in                     ; in older versions where test-in was (define (test-in)..., bes-in was picked up from
					;   the Snd built-in version of bes-in!  So this code was not tested.
					;   Surely that was a bug -- bes-in is redefined locally before use? -- yes, a bug in optimize_syntax.
	     (lambda (n x)			;return In(x) for any integer n, real x
	       (cond ((= n 0) (bes-i0 x))
		     ((= n 1) (bes-i1 x))
		     ((= x 0.0) 0.0)
		     (else
		      (let ((bigno 1.0e10)
			    (bigni 1.0e-10)
			    (ans 0.0000)
			    (tox (/ 2.0 (abs x)))
			    (bip 0.0000)
			    (bi 1.0000)
			    (m (* 2 (+ n (truncate (sqrt (* 40 n)))))) ; iacc=40
			    (bim 0.0000))
			(do ((j m (- j 1)))
			    ((= j 0))
			  (set! bim (+ bip (* j tox bi)))
			  (set! bip bi)
			  (set! bi bim)
			  (when (> (abs bi) bigno)
			    (set! ans (* ans bigni))
			    (set! bi (* bi bigni))
			    (set! bip (* bip bigni)))
			  (if (= j n) (set! ans bip)))
			(if (and (< x 0.0) (odd? n))
			    (set! ans (- ans)))
			(* ans (/ (bes-i0 x) bi))))))))
	(lambda ()
	  (unless (provided? 'solaris)
	    (if (fneq (bes-in 1 1.0) 0.565159) (snd-display "bes-in 1 1.0: ~A" (bes-in 1 1.0)))
	    (if (fneq (bes-in 2 1.0) 0.13574767) (snd-display "bes-in 2 1.0: ~A" (bes-in 2 1.0)))
	    (if (fneq (bes-in 3 1.0) 0.02216842) (snd-display "bes-in 3 1.0: ~A" (bes-in 3 1.0)))
	    (if (fneq (bes-in 5 1.0) 2.71463e-4) (snd-display "bes-in 5 1.0: ~A" (bes-in 5 1.0)))
	    (if (fneq (bes-in 10 1.0) 2.752948e-10) (snd-display "bes-in 10 1.0: ~A" (bes-in 10 1.0)))
	    
	    (if (fneq (bes-in 1 2.0) 1.5906368) (snd-display "bes-in 1 2.0: ~A" (bes-in 1 2.0)))
	    (if (fneq (bes-in 2 2.0) 0.6889484) (snd-display "bes-in 2 2.0: ~A" (bes-in 2 2.0)))
	    (if (fneq (bes-in 3 2.0) 0.21273995) (snd-display "bes-in 3 2.0: ~A" (bes-in 3 2.0)))
	    (if (fneq (bes-in 5 2.0) 0.009825679) (snd-display "bes-in 5 2.0: ~A" (bes-in 5 2.0)))
	    (if (fneq (bes-in 10 2.0) 3.016963e-7) (snd-display "bes-in 10 2.0: ~A" (bes-in 10 2.0)))
	    
	    (if (fneq (bes-in 1 5.0) 24.33564) (snd-display "bes-in 1 5.0: ~A" (bes-in 1 5.0)))
	    (if (fneq (bes-in 2 5.0) 17.505615) (snd-display "bes-in 2 5.0: ~A" (bes-in 2 5.0)))
	    (if (fneq (bes-in 3 5.0) 10.331150) (snd-display "bes-in 3 5.0: ~A" (bes-in 3 5.0)))
	    (if (fneq (bes-in 5 5.0) 2.157974) (snd-display "bes-in 5 5.0: ~A" (bes-in 5 5.0)))
	    (if (fneq (bes-in 10 5.0) 0.004580044) (snd-display "bes-in 10 5.0: ~A" (bes-in 10 5.0)))))))
    
    (define (bes-k0 x)				;K0(x)
      (if (<= x 2.0)
	  (let ((y (* x (/ x 4.0))))
	    (+ (* (- (log (/ x 2.0))) (bes-i0 x)) -0.57721566
	       (* y (+ 0.42278420
		       (* y (+ 0.23069756
			       (* y (+ 0.3488590e-1
				       (* y (+ 0.262698e-2
					       (* y (+ 0.10750e-3
						       (* y 0.74e-5)))))))))))))
	  (let ((y (/ 2.0 x)))
	    (* (/ (exp (- x)) (sqrt x))
	       (+ 1.2533 
		  (* y (- (* y (+ 0.02189568 (* y (- (* y (+ 0.00587872 (* y (- (* y -0.00053208) 0.0025154)))) 0.01062446)))) 0.0783)))))))
    
    (define (test-k0)
      (if (fneq (bes-k0 1.0) 0.4210244) (snd-display "bes-k0 1.0: ~A" (bes-k0 1.0)))
      (if (fneq (bes-k0 2.0) 0.1138938) (snd-display "bes-k0 2.0: ~A" (bes-k0 2.0)))
      (if (fneq (bes-k0 10.0) 1.7780e-5) (snd-display "bes-k0 10.0: ~A" (bes-k0 10.0))))
    
    (define (bes-k1 x)				;K1(x)
      (if (<= x 2.0)
	  (let ((y (* x (/ x 4.0))))
	    (+ (* (log (/ x 2)) (bes-i1 x))
	       (* (/ 1.0 x)
		  (+ 1.0000
		     (* y (+ 0.15443144
			     (* y (- (* y (- (* y (- (* y (- (* y -4.686e-05) 0.00110404)) 0.01919402)) 0.18156897)) 0.6728))))))))
	  (let ((y (/ 2.0 x)))
	    (* (/ (exp (- x)) (sqrt x))
	       (+ 1.2533 
		  (* y (+ 0.2350
			  (* y (- (* y (+ 0.01504268 (* y (- (* y (+ 0.00325614 (* y -0.00068245))) 0.00780353)))) 0.0365562)))))))))
    
    (define (test-k1)
      (if (fneq (bes-k1 1.0) 0.60190723) (snd-display "bes-k1 1.0: ~A" (bes-k1 1.0)))
      (if (fneq (bes-k1 2.0) 0.1398658) (snd-display "bes-k1 2.0: ~A" (bes-k1 2.0)))
      (if (fneq (bes-k1 10.0) 1.86487e-5) (snd-display "bes-k1 10.0: ~A" (bes-k1 10.0))))
    
    
    (define test-kn
      (let ((bes-kn 
	     (lambda (n x)			;return Kn(x) for any integer n, real x
	       (case n
		 ((0) (bes-k0 x))
		 ((1) (bes-k1 x))
		 (else
		  (do ((tox (/ 2.0 x))
		       (bkm (bes-k0 x))
		       (bk (bes-k1 x))
		       (bkp 0.0)
		       (j 1 (+ j 1)))
		      ((= j n) bk)
		    (set! bkp (+ bkm (* j tox bk)))
		    (set! bkm bk)
		    (set! bk bkp)))))))
	(lambda ()
	  (if (fneq (bes-kn 1 1.0) 0.6019072) (snd-display "bes-kn 1 1.0: ~A" (bes-kn 1 1.0)))
	  (if (fneq (bes-kn 2 1.0) 1.6248389) (snd-display "bes-kn 2 1.0: ~A" (bes-kn 2 1.0)))
	  (if (fneq (bes-kn 3 1.0) 7.1012629) (snd-display "bes-kn 3 1.0: ~A" (bes-kn 3 1.0)))
	  (if (fneq (bes-kn 5 1.0) 360.96059) (snd-display "bes-kn 5 1.0: ~A" (bes-kn 5 1.0)))
	  
	  (if (fneq (bes-kn 1 2.0) 0.139865) (snd-display "bes-kn 1 2.0: ~A" (bes-kn 1 2.0)))
	  (if (fneq (bes-kn 2 2.0) 0.2537597) (snd-display "bes-kn 2 2.0: ~A" (bes-kn 2 2.0)))
	  (if (fneq (bes-kn 3 2.0) 0.6473854) (snd-display "bes-kn 3 2.0: ~A" (bes-kn 3 2.0)))
	  (if (fneq (bes-kn 5 2.0) 9.431049) (snd-display "bes-kn 5 2.0: ~A" (bes-kn 5 2.0)))
	  
	  (if (fneq (bes-kn 1 5.0) 0.00404461) (snd-display "bes-kn 1 5.0: ~A" (bes-kn 1 5.0)))
	  (if (fneq (bes-kn 2 5.0) 0.0053089) (snd-display "bes-kn 2 5.0: ~A" (bes-kn 2 5.0)))
	  (if (fneq (bes-kn 3 5.0) 0.0082917) (snd-display "bes-kn 3 5.0: ~A" (bes-kn 3 5.0)))
	  (if (fneq (bes-kn 5 5.0) 0.0327062) (snd-display "bes-kn 5 5.0: ~A" (bes-kn 5 5.0))))))
    
    
    (define test-lgamma
      (let ((gammln (let ((stp 2.5066282746310005e0))
		      (lambda (x)			;Ln(gamma(x)), x>0 
			(let ((tmp1 (let ((tmp (+ x 5.5)))
				      (- tmp (* (+ x 0.5) (log tmp)))))
			      (ser (+ 1.000000000190015
				      (/ 76.18009172947146 (+ x 1.0))
				      (/ -86.50532032941677 (+ x 2.0))
				      (/ 24.01409824083091 (+ x 3.0))
				      (/ -1.231739572450155 (+ x 4))
				      (/ 0.1208650973866179e-2 (+ x 5.0))
				      (/ -0.5395239384953e-5 (+ x 6.0)))))
			  (- (log (/ (* stp ser) x)) tmp1))))))
	(lambda ()
	  (do ((i 0 (+ i 1)))
	      ((= i 10))
	    (let ((x (random 100.0)))
	      (if (fneq (lgamma x) (gammln x))
		  (snd-display "(lgamma ~A) -> ~A ~A" x (lgamma x) (gammln x))))))))
    
    (define (test-erf)
      (if (fneq (erf 0.0) 0.0) (snd-display "erf 0.0: ~A" (erf 0.0)))
      (if (fneq (erf 0.5) 0.5204998) (snd-display "erf 0.5: ~A" (erf 0.5)))
      (if (fneq (erf 1.0) 0.8427007) (snd-display "erf 0.0: ~A" (erf 1.0)))
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(let ((val (random 2.0)))
	  (if (fneq (+ (erf val) (erfc val)) 1.0)
	      (snd-display "erf+erfc: ~A (~A + ~A)" 
			   (+ (erf val) (erfc val))
			   (erf val)
			   (erfc val))))))
    
    (define (inverse-haar f)
      (let ((n (length f)))
	(let ((g (make-float-vector n))
	      (s2 (sqrt 2.0))
	      (v (/ 1.0 (sqrt n))))
	  (set! (f 0) (* (f 0) v))
	  (do ((m 2 (* m 2)))
	      ((> m n))
	    (do ((mh (/ m 2))
		 (j 0 (+ j 2))
		 (k 0 (+ k 1)))
		((= j m)
		 (do ((i (- m 1) (- i 1)))
		     ((< i 0))
		   (set! (f i) (g i)))
		 (set! v (* v s2)))
	      (let ((x (f k))
		    (y (* (f (+ mh k)) v)))
		(set! (g j) (+ x y))
		(set! (g (+ j 1)) (- x y)))))
	  f)))
    
    (define (wavelet data n isign wf cc)
      (let ((cc-size (length cc)))
	(let ((ccr (make-float-vector cc-size))
	      (sig -1.0))
	  (do ((i 0 (+ i 1))
	       (j (- cc-size 1) (- j 1)))
	      ((= i cc-size))
	    (set! (ccr j) (* sig (cc i)))
	    (set! sig (- sig)))
	  (if (>= n 4)
	      (if (>= isign 0)
		  (do ((nn n (/ nn 2)))
		      ((< nn 4))
		    (wf data nn isign cc ccr))
		  (do ((nn 4 (* nn 2)))
		      ((> nn n))
		    (wf data nn isign cc ccr)))))))
    
    (define (pwt data n isign cc cr)
      (let* ((ncof (length cc))
	     (joff (- (floor (/ ncof 2)))))
	(let ((data1 (make-float-vector n))
	      (n1 (- n 1))
	      (nmod (* ncof n))
	      (nh (floor (/ n 2))))
	  (if (>= isign 0)
	      (do ((ii 0 (+ 1 ii))
		   (i 1 (+ i 2)))
		  ((> i n))
		(do ((ni (+ i nmod joff))
		     (nj (+ i nmod joff))
		     (ii+nh (+ ii nh))
		     (k 1 (+ k 1)))
		    ((> k ncof))
		  (let ((jf (logand n1 (+ ni k))) ;gad wotta kludge...
			(jr (logand n1 (+ nj k))))
		    (set! (data1 ii) (+ (data1 ii)
					(* (cc (- k 1)) 
					   (data jf))))
		    (set! (data1 ii+nh) (+ (data1 ii+nh)
					   (* (cr (- k 1)) 
					      (data jr)))))))
	      (do ((ii 0 (+ 1 ii))
		   (i 1 (+ i 2)))
		  ((> i n))
		(do ((ai (data ii))
		     (ai1 (data (+ ii nh)))
		     (ni (+ i nmod joff))
		     (nj (+ i nmod joff))
		     (k 1 (+ k 1)))
		    ((> k ncof))
		  (let ((jf (logand n1 (+ ni k)))
			(jr (logand n1 (+ nj k))))
		    (set! (data1 jf) (+ (data1 jf) 
					(* ai (cc (- k 1)))))
		    (set! (data1 jr) (+ (data1 jr)
					(* ai1 (cr (- k 1)))))))))
	  (copy data1 data))))
    
    (define (corr x y N M)
      ;; correlation from Orfanidis
      (do ((R (make-float-vector (+ 1 M)))
	   (k 0 (+ k 1)))
	  ((> k M) R)
	(set! (R k) 0.0)
	(do ((n 0 (+ 1 n)))
	    ((= n (- N k)))
	  (set! (R k) (+ (R k) (* (x (+ n k)) (y n)))))))
    
    ;; this returns the same results as the fft-based version below, modulo float-vector lengths
    (define (cross-correlate-1 snd0 chn0 snd1 chn1)
      (let ((len0 (framples snd0 chn0))
	    (len1 (framples snd1 chn1)))
	(let ((clen (min len0 len1))
	      (dlen (max len0 len1)))
	  (let ((corr (make-float-vector clen))
		(data0 (channel->float-vector 0 dlen snd0 chn0))
		(data1 (channel->float-vector 0 dlen snd1 chn1)))
	    (do ((lag 0 (+ 1 lag)))
		((= lag clen) corr)
	      (let ((mdata (float-vector-multiply! (copy data0) data1))
		    (sum (make-one-pole 1.0 -1.0)))
		(do ((i 0 (+ i 1)))
		    ((= i dlen))
		  (one-pole sum (float-vector-ref mdata i)))
		(set! (corr lag) (one-pole sum 0.0))
		(let ((orig (data0 0)))
		  (float-vector-move! data0 0 1)
		  (set! (data0 (- dlen 1)) orig))))))))
    
    (define (cross-correlate-2 snd0 chn0 snd1 chn1)
      (let* ((fftlen (expt 2 (ceiling (log (max (framples snd0 chn0) (framples snd1 chn1)) 2))))
	     (fftscale (/ 1.0 fftlen)))
	(let ((rl1 (channel->float-vector 0 fftlen snd1 chn1))
	      (rl2 (channel->float-vector 0 fftlen snd0 chn0))
	      (im1 (make-float-vector fftlen))
	      (im2 (make-float-vector fftlen)))
	  (fft rl1 im1 1)
	  (fft rl2 im2 1)
	  (let ((tmprl (copy rl1))
		(tmpim (copy im1)))
	    (float-vector-multiply! tmprl rl2)     ; (* tempr1 tempr2)
	    (float-vector-multiply! tmpim im2)     ; (* tempi1 tempi2)
	    (float-vector-multiply! im2 rl1)       ; (* tempr1 tempi2)
	    (float-vector-multiply! rl2 im1)       ; (* tempr2 tempi1)
	    (float-vector-add! tmprl tmpim)        ; add the first two
	    (float-vector-subtract! im2 rl2)       ; subtract the fourth from the third
	    (float-vector-scale! (fft tmprl im2 -1) fftscale)))))
    
    (define (cross-correlate-3 rl1 rl2 fftlen)
      (let ((fftscale (/ 1.0 fftlen))
	    (im1 (make-float-vector fftlen))
	    (im2 (make-float-vector fftlen)))
	(fft rl1 im1 1)
	(fft rl2 im2 1)
	(let ((tmprl (copy rl1))
	      (tmpim (copy im1)))
	  (float-vector-multiply! tmprl rl2)     ; (* tempr1 tempr2)
	  (float-vector-multiply! tmpim im2)     ; (* tempi1 tempi2)
	  (float-vector-multiply! im2 rl1)       ; (* tempr1 tempi2)
	  (float-vector-multiply! rl2 im1)       ; (* tempr2 tempi1)
	  (float-vector-add! tmprl tmpim)        ; add the first two
	  (float-vector-subtract! im2 rl2)       ; subtract the fourth from the third
	  (float-vector-scale! (fft tmprl im2 -1) fftscale))))
    
    (define* (automorph a b c d snd chn)
      (let* ((len (framples snd chn))
	     (fftlen (expt 2 (ceiling (log len 2)))))
	(let ((fftlen2 (/ fftlen 2))
	      (rl (channel->float-vector 0 fftlen snd chn))
	      (im (make-float-vector fftlen))
	      (c1 #f))
	  (fft rl im 1)
	  (let ((fftscale (/ 1.0 fftlen)))
	    (float-vector-scale! rl fftscale)
	    (float-vector-scale! im fftscale))
	  ;; handle 0 case by itself
	  (set! c1 (complex (rl 0) (im 0)))
	  (set! c1 (/ (+ (* a c1) b) (+ (* c c1) d)))
	  (set! (rl 0) (real-part c1))
	  (set! (im 0) (imag-part c1))
	  
	  (do ((i 1 (+ i 1))
	       (k (- fftlen 1) (- k 1)))
	      ((= i fftlen2))
	    (set! c1 (complex (float-vector-ref rl i) (float-vector-ref im i)))
	    (set! c1 (/ (+ (* a c1) b) (+ (* c c1) d)))
	    (float-vector-set! rl k (float-vector-set! rl i (real-part c1)))
	    (float-vector-set! im k (- (float-vector-set! im i (imag-part c1)))))
	  
	  (fft rl im -1)
	  (float-vector->channel rl 0 len snd chn #f (format #f "automorph ~A ~A ~A ~A" a b c d)))))
    
    (define* (cfft! data n (dir 1))
      (if (not n) (set! n (length data)))
      (let ((t0 (complex 0.0 (* pi dir))))
	(do ((i 0 (+ i 1))
	     (j 0))
	    ((= i n))
	  (if (> j i)
	      (let ((temp (data j)))
		(set! (data j) (data i))
		(set! (data i) temp)))
	  (do ((m (/ n 2) (/ m 2)))
	      ((not (<= 2 m j))
	       (set! j (+ j m)))   
	    (set! j (- j m))))
	(do ((ipow (floor (log n 2)))
	     (prev 1)
	     (lg 0 (+ lg 1))
	     (mmax 2 (* mmax 2))
	     (pow (/ n 2) (/ pow 2))
	     (theta t0 (* theta 0.5)))
	    ((= lg ipow))
	  (do ((wpc (exp theta))
	       (wc 1.0)
	       (ii 0 (+ ii 1)))
	      ((= ii prev)
	       (set! prev mmax))
	    (do ((jj 0 (+ jj 1))
		 (i ii (+ i mmax))
		 (j (+ ii prev) (+ j mmax)))
		((>= jj pow))
	      (let ((tc (* wc (data j))))
		(set! (data j) (- (data i) tc))
		(set! (data i) (+ (data i) tc))))
	    (set! wc (* wc wpc))))
	data))
    
    (define* (fft! rl im n (dir 1))
      (if (not im)
	  (set! im (make-float-vector (length rl))))
      (if (not n)
	  (set! n (length rl)))
      (do ((i 0 (+ i 1))
	   (j 0))
	  ((= i n))
	(if (> j i)
	    (let ((tempr (rl j))
		  (tempi (im j)))
	      (set! (rl j) (rl i))
	      (set! (im j) (im i))
	      (set! (rl i) tempr)
	      (set! (im i) tempi)))
	(do ((m (/ n 2) (/ m 2)))
	    ((not (<= 2 m j))
	     (set! j (+ j m)))
	  (set! j (- j m))))
      (do ((ipow (floor (log n 2)))
	   (prev 1)
	   (lg 0 (+ lg 1))
	   (mmax 2 (* mmax 2))
	   (pow (/ n 2) (/ pow 2))
	   (theta (* pi dir) (* theta 0.5)))
	  ((= lg ipow))
	(do ((wpr (cos theta))
	     (wpi (sin theta))
	     (wr 1.0)
	     (wi 0.0)
	     (ii 0 (+ ii 1)))
	    ((= ii prev)
	     (set! prev mmax))   
	  (do ((jj 0 (+ jj 1))
	       (i ii (+ i mmax))
	       (j (+ ii prev) (+ j mmax)))
	      ((>= jj pow))
	    (let ((tempr (- (* wr (rl j)) (* wi (im j))))
		  (tempi (+ (* wr (im j)) (* wi (rl j)))))
	      (set! (rl j) (- (rl i) tempr))
	      (set! (im j) (- (im i) tempi))
	      (set! (rl i) (+ (rl i) tempr))
	      (set! (im i) (+ (im i) tempi))))
	  (let ((wtemp wr))
	    (set! wr (- (* wr wpr) (* wi wpi)))
	    (set! wi (+ (* wi wpr) (* wtemp wpi))))))
      rl)
      
    ;; test_19
    (lambda ()
      (when (defined? 'bes-j0) ; dependent on mus-config.h HAVE_SPECIAL_FUNCTIONS
	(test-j0)
	(test-j1)
	(test-jn)
	(test-y0)
	(test-y1)
	(test-yn)
	(test-k0)
	(test-k1)
	(test-kn)
	(test-i0)
	(test-i1)
	(test-in)
	(test-erf)
	(test-lgamma))
      
      (do ((clmtest 0 (+ 1 clmtest))) ((= clmtest tests))
	(log-mem clmtest)
	
	(let ((index (open-sound "oboe.snd")))
	  ;; check small transform cases
	  (set! (transform-graph?) #t)
	  (for-each 
	   (lambda (transform)
	     (set! *transform-type* transform)
	     (for-each
	      (lambda (size)
		(catch #t
		  (lambda ()
		    (set! *transform-size* size)
		    (update-transform-graph))
		  (lambda args args)))
	      '(8 7 -7 4 3 2 1 0)))
	   (list fourier-transform wavelet-transform autocorrelation walsh-transform cepstrum haar-transform))
	  (close-sound index))
	
	;; -------- fft
	
	(let ((d0 (make-float-vector 16)))
	  (set! (d0 0) 1.0)
	  (snd-transform fourier-transform d0 0)
	  (do ((i 0 (+ i 1)))
	      ((= i 16))
	    (if (fneq (d0 i) 1.0)
		(snd-display "fourier (1.0) [~D]: ~A?" i (d0 i)))))
	
	(let ((d0 (make-float-vector 19)))
	  (set! (d0 0) 1.0)
	  (snd-transform fourier-transform d0 0)
	  (do ((happy #t)
	       (i 0 (+ i 1)))
	      ((or (not happy) (= i 16)))
	    (when (fneq (d0 i) 1.0)
	      (snd-display "fourier (1.0) [~D]: ~A?" i (d0 i))
	      (set! happy #f)))
	  
	  (snd-transform fourier-transform d0 0)
	  (if (and (fneq (d0 0) 256.0)
		   (fneq (d0 0) 361.0)) ; fftw funny length 
	      (snd-display "fourier (256.0): ~A?" (d0 0)))
	  (do ((happy #t)
	       (i 1 (+ i 1)))
	      ((or (not happy) (= i 16)))
	    (when (fneq (d0 i) 0.0)
	      (snd-display "fourier (0.0) [~D]: ~A?" i (d0 i))
	      (set! happy #f))))
	
	(let ((r0 (make-float-vector 8))
	      (i0 (make-float-vector 8))
	      (r1 (make-float-vector 8))
	      (i1 (make-float-vector 8))
	      (r2 (make-float-vector 8))
	      (i2 (make-float-vector 8)))
	  (set! (r0 1) .5)
	  (set! (r1 3) .75)
	  (set! (r2 1) .25) ; 1/2
	  (set! (r2 3) .25) ; 1/3
	  (mus-fft r0 i0)
	  (mus-fft r1 i1)
	  (mus-fft r2 i2)
	  (float-vector-scale! r0 .5)
	  (float-vector-scale! i0 .5)
	  (float-vector-scale! r1 .3333)
	  (float-vector-scale! i1 .3333)
	  (float-vector-add! r0 r1)
	  (float-vector-add! i0 i1)
	  (if (not (and (mus-arrays-equal? r0 r2)
			(mus-arrays-equal? i0 i2)))
	      (snd-display "fft additions/scaling: ~A ~A: ~A ~A" r2 i2 r0 i0)))
	
	(let ((d0 (make-float-vector 8))
	      (d1 (make-float-vector 8)))
	  (set! (d0 2) 1.0)
	  (mus-fft d0 d1 8 1)
	  (if (not (and (mus-arrays-equal? d0 #r(1.000 0.0 -1.000 0.0 1.000 0.0 -1.000 0.000))
			(mus-arrays-equal? d1 #r(0.0 1.000 0.0 -1.000 0.0 1.000 0.0 -1.000))))
	      (snd-display "mus-fft 1: ~A ~A?" d0 d1))
	  (mus-fft d0 d1 8 -1)
	  (if (not (and (mus-arrays-equal? d0 #r(0.0 0.0 8.000 0.0 0.0 0.0 0.0 0.000))
			(mus-arrays-equal? d1 (make-float-vector 8))))
	      (snd-display "mus-fft -1: ~A ~A?" d0 d1))
	  
	  (fill! d0 1.0)
	  (fill! d1 0.0)
	  (mus-fft d0 d1 8)
	  (if (not (and (mus-arrays-equal? d0 #r(8.000 0.0 0.0 0.0 0.0 0.0 0.0 0.000))
			(mus-arrays-equal? d1 (make-float-vector 8))))
	      (snd-display "mus-fft 2: ~A ~A?" d0 d1))
	  (mus-fft d0 d1 8 -1)
	  (if (not (and (mus-arrays-equal? d0 (make-float-vector 8 8.0))
			(mus-arrays-equal? d1 (make-float-vector 8))))
	      (snd-display "mus-fft -2: ~A ~A?" d0 d1))
	  
	  (fill! d1 0.0)
	  (fill-float-vector d0 (random 1.0))
	  (let ((fn (copy d0)))
	    (mus-fft d0 d1 8)
	    (mus-fft d0 d1 8 -1)
	    (float-vector-scale! d0 (/ 1.0 8.0))
	    (if (not (mus-arrays-equal? d0 fn))
		(snd-display "mus-fft 3: ~A ~A?" d0 fn)))
	  
	  (let ((d0 (make-float-vector 8))
		(d1 (make-float-vector 8)))
	    (do ((i 0 (+ i 1)))
		((= i 8))
	      (set! (d0 i) (- 1.0 (random 2.0)))
	      (set! (d1 i) (- 1.0 (random 2.0))))
	    (let ((save-d0 (copy d0))
		  (save-d1 (copy d1))
		  (reversed-d0 (make-float-vector 8))
		  (reversed-d1 (make-float-vector 8)))
	      (do ((i 0 (+ i 1)))
		  ((= i 8))
		(set! (reversed-d0 i) (d0 (- 7 i)))
		(set! (reversed-d1 i) (d1 (- 7 i))))
	      (mus-fft d0 d1 8)
	      (mus-fft d0 d1 8)
	      (float-vector-scale! d0 .125)
	      (float-vector-scale! d1 .125)
	      (do ((i 0 (+ i 1))) ; one sample rotation here
		  ((= i 7))
		(if (fneq (d0 (+ i 1)) (reversed-d0 i))
		    (snd-display "mus-fft d0 reversed: ~A ~A" d0 reversed-d0))
		(if (fneq (d1 (+ i 1)) (reversed-d1 i))
		    (snd-display "mus-fft d1 reversed: ~A ~A" d1 reversed-d1)))
	      (mus-fft d0 d1 8)
	      (mus-fft d0 d1 8)
	      (float-vector-scale! d0 .125)
	      (float-vector-scale! d1 .125)
	      (if (not (mus-arrays-equal? d0 save-d0))
		  (snd-display "mus-fft d0 saved: ~A ~A" d0 save-d0))
	      (if (not (mus-arrays-equal? d1 save-d1))
		  (snd-display "mus-fft d1 saved: ~A ~A" d1 save-d1)))))
	
	(for-each 
	 (lambda (size)
	   (let ((d0 (make-float-vector size)))
	     (set! (d0 0) 1.0)
	     (let ((dcopy (copy d0))
		   (d1 (snd-spectrum d0 rectangular-window size)))
	       (if (not (mus-arrays-equal? d0 dcopy)) (snd-display "snd-spectrum not in-place? ~A ~A" d0 dcopy))
	       (do ((happy #t)
		    (i 0 (+ i 1)))
		   ((or (not happy) (= i (/ size 2))))
		 (when (fneq (d1 i) 1.0)
		   (snd-display "snd-spectrum (1.0) [~D: ~D]: ~A?" i size (d1 i))
		   (set! happy #f)))))
	   
	   (let ((d1 (snd-spectrum (make-float-vector size 1.0) rectangular-window)))
	     (if (fneq (d1 0) 1.0)
		 (snd-display "snd-spectrum back (1.0 ~D): ~A?" size (d1 0)))
	     (do ((happy #t)
		  (i 1 (+ i 1)))
		 ((or (not happy) (= i (/ size 2))))
	       (when (fneq (d1 i) 0.0)
		 (snd-display "snd-spectrum (0.0) [~D: ~D]: ~A?" i size (d1 i))
		 (set! happy #f))))
	   
	   (let* ((d0 (make-float-vector size))
		  (d1 (snd-spectrum d0 rectangular-window size #f))) ; dB (0.0 = max)
	     (set! (d0 0) 1.0)
	     (do ((happy #t)
		  (i 0 (+ i 1)))
		 ((or (not happy) (= i (/ size 2))))
	       (when (fneq (d1 i) 0.0)
		 (snd-display "snd-spectrum dB (0.0) [~D: ~D]: ~A?" i size (d1 i))
		 (set! happy #f))))
	   
	   (let ((d1 (snd-spectrum (make-float-vector size 1.0) rectangular-window size #f)))
	     (if (fneq (d1 0) 0.0)
		 (snd-display "snd-spectrum dB back (0.0 ~D): ~A?" size (d1 0)))
	     (do ((happy #t)
		  (i 1 (+ i 1)))
		 ((or (not happy) (= i (/ size 2))))
	       (when (fneq (d1 i) -90.0) ; currently ignores min-dB (snd-sig.c 5023)
		 (snd-display "snd-spectrum dB (1.0) [~D: ~D]: ~A?" i size (d1 i))
		 (set! happy #f))))
	   
	   (let ((d0 (make-float-vector size)))
	     (set! (d0 0) 1.0)
	     (let ((dcopy (copy d0))
		   (d1 (snd-spectrum d0 rectangular-window size #t 1.0 #t))) ; in-place 
	       (if (mus-arrays-equal? d0 dcopy) (snd-display "snd-spectrum in-place? ~A ~A" d0 dcopy))
	       (if (not (mus-arrays-equal? d0 d1)) (snd-display "snd-spectrum returns in-place? ~A ~A" d0 d1))
	       (do ((happy #t)
		    (i 0 (+ i 1)))
		   ((or (not happy) (= i (/ size 2))))
		 (when (fneq (d1 i) 1.0)
		   (snd-display "snd-spectrum (1.0 #t) [~D: ~D]: ~A?" i size (d1 i))
		   (set! happy #f)))))
	   
	   (let ((d0 (make-float-vector size)))
	     (set! (d0 0) 1.0)
	     (let ((dcopy (copy d0))
		   (d1 (snd-spectrum d0 rectangular-window size #f 1.0 #t))) ; in-place dB
	       (if (mus-arrays-equal? d0 dcopy) (snd-display "snd-spectrum dB in-place? ~A ~A" d0 dcopy))
	       (if (not (mus-arrays-equal? d0 d1)) (snd-display "snd-spectrum dB returns in-place? ~A ~A" d0 d1))
	       (do ((happy #t)
		    (i 0 (+ i 1)))
		   ((or (not happy) (= i (/ size 2))))
		 (when (fneq (d1 i) 0.0)
		   (snd-display "snd-spectrum dB (1.0 #t) [~D: ~D]: ~A?" i size (d1 i))
		   (set! happy #f)))))
	   
	   (let ((d1 (snd-spectrum (make-float-vector size 1.0) rectangular-window size #t 0.0 #f #f))) ; linear (in-place) not normalized
	     (if (fneq (d1 0) size) (snd-display "snd-spectrum no norm 0: ~A" d1))
	     (do ((happy #t)
		  (i 1 (+ i 1)))
		 ((or (not happy) (= i (/ size 2))))
	       (when (fneq (d1 i) 0.0)
		 (snd-display "snd-spectrum no norm (0.0) [~D: ~D]: ~A?" i size (d1 i))
		 (set! happy #f))))
	   
	   (let ((d1 (snd-spectrum (make-float-vector size 1.0) blackman2-window size)))
	     (if (not (or (mus-arrays-equal? d1 #r(1.000 0.721 0.293 0.091))
			  (mus-arrays-equal? d1 #r(1.000 0.647 0.173 0.037 0.024 0.016 0.011 0.005))))
		 (snd-display "blackman2 snd-spectrum: ~A~%" d1)))
	   
	   (let ((d1 (snd-spectrum (make-float-vector size 1.0) gaussian-window size #t 0.5)))
	     (if (not (or (mus-arrays-equal? d1 #r(1.000 0.900 0.646 0.328))
			  (mus-arrays-equal? d1 #r(1.000 0.870 0.585 0.329 0.177 0.101 0.059 0.028))))
		 (snd-display "gaussian 0.5 snd-spectrum: ~A~%" d1)))
	   
	   (let ((d1 (snd-spectrum (make-float-vector size 1.0) gaussian-window size #t 0.85)))
	     (if (not (or (mus-arrays-equal? d1 #r(1.000 0.924 0.707 0.383))
			  (mus-arrays-equal? d1 #r(1.000 0.964 0.865 0.725 0.566 0.409 0.263 0.128))))
		 (snd-display "gaussian 0.85 snd-spectrum: ~A~%" d1))))
	 
	 '(8 16))
	
	(for-each
	 (lambda (len)
	   (let ((rl (make-float-vector len 1.0))
		 (xrl (make-float-vector len 1.0))
		 (len2 (/ len 2)))
	     (snd-transform fourier-transform rl)
	     (snd-transform fourier-transform xrl #t)
	     (do ((happy #t)
		  (i 0 (+ i 1)))
		 ((or (not happy) (= i len2)))
	       (when (fneq (rl i) (xrl i))
		 (snd-display "flat fft: ~A at ~A: ~A ~A" len i (rl i) (xrl i))
		 (set! happy #f)))
	     (if (fneq (rl 0) (* len len)) (snd-display "snd-transform ~A at 0: ~A" len (rl 0)))
	     (set! (rl 0) 0.0)
	     (if (> (float-vector-peak rl) .001) (snd-display "snd-transform ~A impulse: ~A" len (float-vector-peak rl)))))
	 '(16 128 512 1024))
	
	(for-each
	 (lambda (len)
	   (let ((rl (make-float-vector len))
		 (xrl (make-float-vector len))
		 (len2 (/ len 2)))
	     (set! (rl len2) 1.0)
	     (set! (xrl len2) 1.0)
	     (snd-transform fourier-transform rl)
	     (snd-transform fourier-transform xrl #t)
	     (do ((happy #t)
		  (i 0 (+ i 1)))
		 ((or (not happy) (= i len2)))
	       (when (fneq (rl i) (xrl i))
		 (snd-display "impulse fft: ~A at ~A: ~A ~A" len i (rl i) (xrl i))
		 (set! happy #f)))
	     (if (fneq (rl 0) 1.0) (snd-display "flat ~A at 0: ~A" len (rl 0)))))
	 '(16 128 512 1024))
	
	(for-each
	 (lambda (len)
	   (let ((rl (make-float-vector len))
		 (xrl (make-float-vector len)))
	     (do ((i 0 (+ i 1)))
		 ((= i len))
	       (float-vector-set! rl i (random 1.0)))
	     (copy rl xrl)
	     (snd-transform fourier-transform rl)
	     (float-vector-scale! rl (/ 1.0 len))
	     (snd-transform fourier-transform xrl #t)
	     (float-vector-scale! xrl (/ 1.0 len))
	     (if (not (mus-arrays-equal? rl xrl))
		 (snd-display "random fft: ~A: ~A ~A" len rl xrl))))
	 '(16 128 512 1024 4096))
	
	(for-each
	 (lambda (len)
	   (let ((rl (make-float-vector len))
		 (xrl (make-float-vector len)))
	     (do ((g (make-oscil (/ 220500.0 len)))
		  (i 0 (+ i 1)))
		 ((= i len))
	       (float-vector-set! rl i (oscil g)))
	     (copy rl xrl)
	     (snd-transform fourier-transform rl)
	     (float-vector-scale! rl (/ 1.0 len))
	     (snd-transform fourier-transform xrl #t)
	     (float-vector-scale! xrl (/ 1.0 len))
	     (if (not (mus-arrays-equal? rl xrl))
		 (snd-display "random fft: ~A: ~A ~A" len rl xrl))))
	 '(16 128 512 1024 4096))
	
	;; -------- autocorrelation
	
	(let ((rl (make-float-vector 16)))
	  (set! (rl 0) 1.0)
	  (autocorrelate rl)
	  (if (not (mus-arrays-equal? rl #r(1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)))
	      (snd-display "autocorrelate 1: ~A" rl)))
	
	(let ((rl (make-float-vector 16)))
	  (set! (rl 0) 1.0)
	  (set! (rl 1) -1.0)
	  (autocorrelate rl)
	  (if (not (mus-arrays-equal? rl #r(2 -1 0 0 0 0 0 0 0 0 0 0 0 0 0 0)))
	      (snd-display "autocorrelate 1 -1: ~A" rl)))
	
	(let ((rl (make-float-vector 16)))
	  (set! (rl 0) 1.0)
	  (set! (rl 4) -1.0)
	  (autocorrelate rl)
	  (if (not (mus-arrays-equal? rl #r(2 0 0 0 -1 0 0 0 0 0 0 0 0 0 0 0)))
	      (snd-display "autocorrelate 1 0 0 0 -1: ~A" rl)))
	
	(let ((rl (make-float-vector 16))
	      (rl1 (make-float-vector 16)))
	  (do ((i 0 (+ i 1)))
	      ((= i 8))
	    (set! (rl i) (- 8.0 i)))
	  (copy rl rl1)
	  (let ((nr (float-vector-subseq (corr rl rl 16 16) 0 15)))
	    (autocorrelate rl1)
	    (if (not (mus-arrays-equal? rl1 nr))
		(snd-display "autocorrelate/corr (ramp):~%;  ~A~%;  ~A" rl1 nr))))
	
	(let ((rl (make-float-vector 16))
	      (rl1 (make-float-vector 16)))
	  (do ((i 0 (+ i 1)))
	      ((= i 8))
	    (set! (rl i) (- 1.0 (random 2.0))))
	  (copy rl rl1)
	  (let ((nr (float-vector-subseq (corr rl rl 16 16) 0 15)))
	    (autocorrelate rl1)
	    (if (not (mus-arrays-equal? rl1 nr))
		(snd-display "autocorrelate/corr:~%;  ~A~%;  ~A" rl1 nr))))
	
	(let ((ind0 (new-sound "test.snd" :size 16))
	      (ind1 (new-sound "fmv.snd" :size 16)))
	  (set! (sample 3 ind0 0) .75)
	  (set! (sample 6 ind1 0) -.5)
	  (let ((data0 (cross-correlate-1 ind0 0 ind1 0))
		(data1 (cross-correlate-2 ind0 0 ind1 0)))
	    (if (not (mus-arrays-equal? data0 data1))
		(snd-display "cross-correlate: ~A ~A" data0 data1)))
	  (set! (sample 3 ind0 0) 0.0)
	  (set! (sample 8 ind0 0) 1.0)
	  (let ((data0 (cross-correlate-1 ind0 0 ind1 0))
		(data1 (cross-correlate-2 ind0 0 ind1 0)))
	    (if (not (mus-arrays-equal? data0 data1))
		(snd-display "cross-correlate 1: ~A ~A" data0 data1)))
	  (close-sound ind0)
	  (close-sound ind1))
	
	(let ((v1 (make-float-vector 16))
	      (v2 (make-float-vector 16))
	      (v3 (make-float-vector 16))
	      (v4 (make-float-vector 16)))
	  (set! (v1 0) 1.0)  
	  (set! (v2 3) 1.0)  
	  (set! (v3 0) 1.0)  
	  (set! (v4 3) 1.0)
	  (set! v1 (cross-correlate-3 v1 v2 16))
	  (set! v3 (correlate v3 v4))
	  (if (not (mus-arrays-equal? v1 v3))
	      (snd-display "correlate 16:~%;  ~A~%;  ~A" v1 v3)))
	
	(let ((v1 (make-float-vector 128))
	      (v2 (make-float-vector 128))
	      (v3 (make-float-vector 128))
	      (v4 (make-float-vector 128)))
	  (set! (v1 0) 1.0)  
	  (set! (v2 32) 1.0)  
	  (set! (v3 0) 1.0)  
	  (set! (v4 32) 1.0)
	  (set! v1 (cross-correlate-3 v1 v2 128))
	  (set! v3 (correlate v3 v4))
	  (if (not (mus-arrays-equal? v1 v3))
	      (snd-display "correlate 128:~%;  ~A~%;  ~A" v1 v3)))
	
	(let ((v1 (make-float-vector 128))
	      (v2 (make-float-vector 128))
	      (v3 #f)
	      (v4 #f))
	  (do ((i 0 (+ i 1)))
	      ((= i 128))
	    (float-vector-set! v1 i (mus-random 5.0))
	    (float-vector-set! v2 i (mus-random 0.5)))
	  (set! v3 (copy v1))
	  (set! v4 (copy v2))
	  (set! v1 (cross-correlate-3 v1 v2 128))
	  (set! v3 (correlate v3 v4))
	  (if (not (mus-arrays-equal? v1 v3))
	      (snd-display "correlate 128 at random:~%;  ~A~%;  ~A" v1 v3)))
	
	(let ((v1 (make-float-vector 16))
	      (v2 (make-float-vector 16)))
	  (set! (v1 3) 1.0)  
	  (set! (v2 3) 1.0)  
	  (set! v1 (correlate v1 (copy v1)))
	  (set! v2 (autocorrelate v2))
	  (if (not (mus-arrays-equal? v1 v2))
	      (snd-display "auto/correlate 16:~%;  ~A~%;  ~A" v1 v2)))
	
	(for-each
	 (lambda (len)
	   (let ((rl (make-float-vector len))
		 (rla (make-float-vector len))
		 (xim (make-float-vector len))
		 (xrl (make-float-vector len))
		 (len2 (/ len 2)))
	     (set! (rl 0) 1.0)
	     (set! (rl 4) 1.0)
	     (snd-transform autocorrelation rl 0) ; this is exactly the same as (autocorrelate rl)
	     (if (fneq (rl 0) 2.0) (snd-display "autocorrelation ~A 0: ~A" len (rl 0)))
	     (if (fneq (rl 4) 1.0) (snd-display "autocorrelation ~A 4: ~A" len (rl 4)))
	     
	     (set! (rla 0) 1.0)
	     (set! (rla 4) 1.0)
	     (autocorrelate rla)
	     (if (fneq (rla 0) 2.0) (snd-display "autocorrelate ~A 0: ~A" len (rla 0)))
	     (if (fneq (rla 4) 1.0) (snd-display "autocorrelate ~A 4: ~A" len (rla 4)))
	     
	     (set! (xrl 0) 1.0)
	     (set! (xrl 4) 1.0)
	     (mus-fft xrl xim len 1)
	     (do ((i 0 (+ i 1)))
		 ((= i len))
	       (set! (xrl i) (+ (* (xrl i) (xrl i)) (* (xim i) (xim i)))))
	     (float-vector-scale! xim 0.0)
	     (mus-fft xrl xim len -1)
	     (float-vector-scale! xrl (/ 1.0 len))
	     
	     (do ((happy #t)
		  (i 0 (+ i 1)))
		 ((or (not happy) (= i len2)))
	       (when (fneq (rl i) (xrl i))
		 (snd-display "mus-fft? ~A at ~A: ~A ~A" len i (rl i) (xrl i))
		 (set! happy #f)))
	     (set! (rl 0) 0.0)
	     (set! (rl 4) 0.0)
	     (fill! rl 0.0 len2 len)
	     (if (> (float-vector-peak rl) .001) (snd-display "autocorrelate peak: ~A" (float-vector-peak rl)))))
	 '(16 64 256 512))
	
	(for-each
	 (lambda (len)
	   (let ((rl (make-float-vector len))
		 (xim (make-float-vector len))
		 (xrl (make-float-vector len))
		 (len2 (/ len 2)))
	     (let ((ones (max 2 (random len2))))
	       (do ((i 0 (+ i 1)))
		   ((= i ones))
		 (let ((val (random 1.0))
		       (ind (random len)))
		   (set! (rl ind) val)
		   (set! (xrl ind) val))))
	     (snd-transform autocorrelation rl 0)
	     (mus-fft xrl xim len 1)
	     (set! (xrl 0) (* (xrl 0) (xrl 0)))
	     (set! (xrl len2) (* (xrl len2) (xrl len2)))
	     (do ((i 1 (+ i 1))
		  (j (- len 1) (- j 1)))
		 ((= i len2))
	       (set! (xrl i) (+ (* (xrl i) (xrl i)) (* (xim j) (xim j))))
	       (set! (xrl j) (xrl i)))
	     (float-vector-scale! xim 0.0)
	     (mus-fft xrl xim len -1)
	     (float-vector-scale! xrl (/ 1.0 len))
	     (do ((happy #t)
		  (i 0 (+ i 1)))
		 ((or (not happy) (= i len2)))
	       (when (fneq (rl i) (xrl i))
		 (snd-display "random ~A at ~A: ~A ~A" len i (rl i) (xrl i))
		 (set! happy #f)))))
	 '(16 64 256 512))
	
	;; -------- cepstrum
	
	;; these values from Octave real(ifft(log(abs(fft(x)))))
	(do ((rl (make-float-vector 16))
	     (lst '(0.423618  0.259318 -0.048365  1.140571  -0.811856  -0.994098  -0.998613 -2.453642
		     -0.438549  -1.520463  -0.312065  -0.724707    1.154010    1.466936   0.110463  -1.520854))
	     (i 0 (+ i 1)))
	    ((= i 16)
	     (let ((nrl (float-vector-scale! (snd-transform cepstrum rl 0) 1.399)))
	       (if (not (mus-arrays-equal? nrl #r(1.3994950   0.1416877   0.0952407   0.0052814  -0.0613192   0.0082986  -0.0233993
						  -0.0476585   0.0259498  -0.0476585  -0.0233993   0.0082986  -0.0613192   0.0052814 0.0952407   0.1416877)))
		   (snd-display "cepstrum 16: ~A" nrl))))
	  (set! (rl i) (lst i)))

	(do ((rl (make-float-vector 16))
	     (i 0 (+ i 1))) 
	    ((= i 16)
	     (let ((nrl (float-vector-scale! (snd-transform cepstrum rl 0) 2.72)))
	       (if (not (mus-arrays-equal? nrl #r(2.720 0.452 0.203 0.122 0.082 0.061 0.048 0.041 0.039 0.041 0.048 0.061 0.082 0.122 0.203 0.452)))
		   (snd-display "cepstrum 16 by ones: ~A" nrl))))
	  (set! (rl i) i))
	
	(for-each
	 (lambda (len)
	   (let ((rl (make-float-vector len))
		 (xim (make-float-vector len))
		 (xrl (make-float-vector len)))
	     (set! (rl 0) 1.0)
	     (set! (rl 4) 1.0)
	     (snd-transform cepstrum rl 0)
	     (set! (xrl 0) 1.0)
	     (set! (xrl 4) 1.0)
	     (mus-fft xrl xim len 1)
	     (do ((i 0 (+ i 1)))
		 ((= i len))
	       (let ((val (+ (* (xrl i) (xrl i)) (* (xim i) (xim i)))))
		 (set! (xrl i) (if (> val .0000001) (* 1/2 (log val)) -10.0))))
	     (float-vector-scale! xim 0.0)
	     (mus-fft xrl xim len -1)
	     (float-vector-scale! xrl (/ 1.0 (float-vector-peak xrl)))
	     (if (not (mus-arrays-equal? rl xrl))
		 (snd-display "mus-fft?? ~A: ~A ~A" len rl xrl))))
	 '(16 64 256 512))
	
	
	;; -------- walsh
	
	(let ((d0 (make-float-vector 8)))
	  (set! (d0 0) 1.0)
	  (snd-transform walsh-transform d0)
	  (if (not (mus-arrays-equal? d0 (make-float-vector 8 1.0)))
	      (snd-display "walsh 1: ~A" d0))
	  (snd-transform walsh-transform d0)
	  (if (not (mus-arrays-equal? d0 #r(8.000 0.0 0.0 0.0 0.0 0.0 0.0 0.000)))
	      (snd-display "walsh -1: ~A" d0)))
	
	(let ((d0 (make-float-vector 8)))
	  (set! (d0 1) 1.0)
	  (snd-transform walsh-transform d0)
	  (if (not (mus-arrays-equal? d0 #r(1.000 -1.000 1.000 -1.000 1.000 -1.000 1.000 -1.000)))
	      (snd-display "walsh 2: ~A" d0))
	  (snd-transform walsh-transform d0)
	  (if (not (mus-arrays-equal? d0 #r(0.0 8.000 0.0 0.0 0.0 0.0 0.0 0.000)))
	      (snd-display "walsh -2: ~A" d0)))
	
	(let ((d0 (make-float-vector 8)))
	  (set! (d0 1) 1.0)
	  (set! (d0 0) 0.5)
	  (snd-transform walsh-transform d0)
	  (if (not (mus-arrays-equal? d0 #r(1.500 -0.500 1.500 -0.500 1.500 -0.500 1.500 -0.500)))
	      (snd-display "walsh 3: ~A" d0))
	  (snd-transform walsh-transform d0)
	  (if (not (mus-arrays-equal? d0 #r(4.000 8.000 0.0 0.0 0.0 0.0 0.0 0.000)))
	      (snd-display "walsh -3: ~A" d0)))
	
	(let ((d0 (make-float-vector 8)))
	  (fill-float-vector d0 (random 1.0))
	  (let ((d1 (copy d0)))
	    (snd-transform walsh-transform d0)
	    (snd-transform walsh-transform d0)
	    (float-vector-scale! d0 (/ 1.0 8.0))
	    (if (not (mus-arrays-equal? d0 d1))
		(snd-display "walsh 4: ~A ~A" d0 d1))))
	
	(let ((d1 (snd-transform walsh-transform #r(1 1 1 -1 1 1 1 -1 1 1 1 -1 -1 -1 -1 1))))
	  (if (not (mus-arrays-equal? d1 #r(4.00 4.00 4.00 -4.00 4.00 4.00 4.00 -4.00 4.00 4.00 4.00 -4.00 -4.00 -4.00 -4.00 4.00)))
	      (snd-display "walsh 5: ~A" d1)))
	
	(let ((d1 (snd-transform walsh-transform #r(1 0 0 -1 0 0 0 0 0 0 0 0 0 0 0 0))))
	  (if (not (mus-arrays-equal? d1 #r(0.0 2.000 2.000 0.0 0.0 2.000 2.000 0.0 0.0 2.000 2.000 0.0 0.0 2.000 2.000 0.000)))
	      (snd-display "walsh 6: ~A" d1)))
	
	(let ((d1 (snd-transform walsh-transform 
				 #r(0.174 -0.880 -0.555 -0.879 0.038 0.696 -0.612 0.006 -0.613 0.334 -0.111 -0.821 0.130 0.030 -0.229 0.170))))
	  (if (not (mus-arrays-equal? d1 #r(-3.122 -0.434 2.940 -0.468 -3.580 2.716 -0.178 -1.386 -0.902 0.638 1.196 1.848 -0.956 2.592 -1.046 2.926)))
	      (snd-display "walsh 7: ~A" d1)))
	
	
	;; -------- haar
	
	(let ((d0 (make-float-vector 8)))
	  (set! (d0 2) 1.0)
	  (snd-transform haar-transform d0)
	  (if (not (mus-arrays-equal? d0 #r(0.354 0.354 -0.500 0.0 0.0 0.707 0.0 0.000)))
	      (snd-display "haar 1: ~A" d0))
	  (inverse-haar d0)
	  (if (not (mus-arrays-equal? d0 #r(0.0 0.0 1.000 0.0 0.0 0.0 0.0 0.000)))
	      (snd-display "inverse haar 1: ~A" d0)))
	
	(let ((d0 (make-float-vector 8)))
	  (set! (d0 0) 1.0)
	  (snd-transform haar-transform d0)
	  (if (not (mus-arrays-equal? d0 #r(0.354 0.354 0.500 0.0 0.707 0.0 0.0 0.000)))
	      (snd-display "haar 2: ~A" d0))
	  (inverse-haar d0)
	  (if (not (mus-arrays-equal? d0 #r(1.000 0.0 0.0 0.0 0.0 0.0 0.0 0.000)))
	      (snd-display "inverse haar 2: ~A" d0)))
	
	(let ((d0 (snd-transform haar-transform #r(-0.483 0.174 -0.880 -0.555 -0.879 0.038 0.696 -0.612))))
	  (if (not (mus-arrays-equal? d0 #r(-0.884 -0.349 0.563 -0.462 -0.465 -0.230 -0.648 0.925)))
	      (snd-display "haar 3: ~A" d0)))
	
	;; from "A Primer on Wavelets"
	(let ((sq2 (sqrt 2.0))
	      (d0 (snd-transform haar-transform #r(4 6 10 12 8 6 5 5))))
	  (if (not (mus-arrays-equal? d0 (float-vector (* 14 sq2) (* 2 sq2) -6 2 (- sq2) (- sq2) sq2 0)))
	      (snd-display "haar 4: ~A" d0))
	  
	  (set! d0 (snd-transform haar-transform #r(2 4 6 8 10 12 14 16)))
	  (if (not (mus-arrays-equal? d0 (float-vector (* 18 sq2) (* -8 sq2) -4 -4 (- sq2) (- sq2) (- sq2) (- sq2))))
	      (snd-display "haar 5: ~A" d0)))
	
	(let ((d0 (make-float-vector 8))
	      (d1 (make-float-vector 8)))
	  (do ((i 0 (+ i 1)))
	      ((= i 8))
	    (float-vector-set! d0 i (random 1.0)))
	  (copy d0 d1)
	  (snd-transform haar-transform d0)
	  (inverse-haar d0)
	  (if (not (mus-arrays-equal? d0 d1))
	      (snd-display "inverse haar 6: ~A ~A" d0 d1)))
	
	
	(let* ((SQRT2 1.41421356237309504880168872420969808)
	       (SQRT2*3 (* SQRT2 3)))
	  (let ((daub4 #r(0.4829629131445341 0.8365163037378079 0.2241438680420134 -0.1294095225512604))
		(daub6 #r(0.332670552950 0.806891509311 0.459877502118 -0.135011020010 -0.085441273882 0.035226291886))
		(daub8 #r(0.230377813309 0.714846570553 0.630880767930 -0.027983769417 -0.187034811719 0.030841381836
				     0.032883011667 -0.010597401785))
		(daub10 #r(0.160102397974 0.603829269797 0.724308528438 0.138428145901 -0.242294887066 -0.032244869585
				      0.077571493840 -0.006241490213 -0.012580751999 0.003335725285))
		(daub12 #r(0.111540743350 0.494623890398 0.751133908021 0.315250351709 -0.226264693965 -0.129766867567
				      0.097501605587 0.027522865530 -0.031582039317 0.000553842201 0.004777257511 -0.001077301085))
		(daub14 #r(0.077852054085 0.396539319482 0.729132090846 0.469782287405 -0.143906003929 -0.224036184994
				      0.071309219267 0.080612609151 -0.038029936935 -0.016574541631 0.012550998556 0.000429577973
				      -0.001801640704 0.000353713800))
		(daub16 #r(0.054415842243 0.312871590914 0.675630736297 0.585354683654 -0.015829105256 -0.284015542962
				      0.000472484574 0.128747426620 -0.017369301002 -0.044088253931 0.013981027917 0.008746094047
				      -0.004870352993 -0.000391740373 0.000675449406 -0.000117476784))
		(daub18 #r(0.038077947364 0.243834674613 0.604823123690 0.657288078051 0.133197385825 -0.293273783279
				      -0.096840783223 0.148540749338 0.030725681479 -0.067632829061 0.000250947115 0.022361662124
				      -0.004723204758 -0.004281503682 0.001847646883 0.000230385764 -0.000251963189 0.000039347320))
		(daub20 #r(0.026670057901 0.188176800077 0.527201188931 0.688459039453 0.281172343661 -0.249846424327
				      -0.195946274377 0.127369340336 0.093057364604 -0.071394147166 -0.029457536822 0.033212674059
				      0.003606553567 -0.010733175483 0.001395351747 0.001992405295 -0.000685856695 -0.000116466855
				      0.000093588670 -0.000013264203))
		(Battle-Lemarie (float-vector (* SQRT2 -0.002) (* SQRT2 -0.003) (* SQRT2  0.006) (* SQRT2  0.006) (* SQRT2 -0.013)
					      (* SQRT2 -0.012) (* SQRT2  0.030) (* SQRT2  0.023) (* SQRT2 -0.078) (* SQRT2 -0.035)
					      (* SQRT2  0.307) (* SQRT2  0.542) (* SQRT2  0.307) (* SQRT2 -0.035) (* SQRT2 -0.078)
					      (* SQRT2  0.023) (* SQRT2  0.030) (* SQRT2 -0.012) (* SQRT2 -0.013) (* SQRT2  0.006)
					      (* SQRT2  0.006) (* SQRT2 -0.003) (* SQRT2 -0.002) 0.0))
		(Burt-Adelson (float-vector (* SQRT2 (/ -1.0 20.0)) (* SQRT2 (/ 5.0 20.0)) (* SQRT2 (/ 12.0 20.0))
					    (* SQRT2 (/ 5.0 20.0)) (* SQRT2 (/ -1.0 20.0)) 0.0))
		(Beylkin #r(0.099305765374353 0.424215360812961 0.699825214056600 0.449718251149468
				       -.110927598348234 -.264497231446384 0.026900308803690 0.155538731877093
				       -.017520746266529 -.088543630622924 0.019679866044322 0.042916387274192
				       -.017460408696028 -.014365807968852 0.010040411844631 .0014842347824723
				       -.002736031626258 .0006404853285212))
		(coif2 (let ((SQRT15 3.87298334620741688517927))
			 (float-vector (/ (* SQRT2 (- SQRT15 3)) 32.0) (/ (* SQRT2 (- 1 SQRT15)) 32.0) (/ (* SQRT2 (- 6 (* 2 SQRT15))) 32.0)
				       (/ (* SQRT2 (+ (* 2 SQRT15) 6)) 32.0) (/ (* SQRT2 (+ SQRT15 13)) 32.0) (/ (* SQRT2 (- 9 SQRT15)) 32.0))))
		(coif4 #r(0.0011945726958388 	-0.01284557955324 0.024804330519353 0.050023519962135 -0.15535722285996
				     -0.071638282295294 0.57046500145033 0.75033630585287 0.28061165190244 -0.0074103835186718
				     -0.014611552521451 -0.0013587990591632))
		(coif6 #r(-0.0016918510194918 -0.00348787621998426 0.019191160680044 0.021671094636352 -0.098507213321468
				     -0.056997424478478 0.45678712217269 0.78931940900416 0.38055713085151 -0.070438748794943 
				     -0.056514193868065 0.036409962612716 0.0087601307091635 -0.011194759273835 -0.0019213354141368
				     0.0020413809772660 0.00044583039753204 -0.00021625727664696))
		(sym2 (float-vector (* SQRT2 -0.125) (* SQRT2  0.25) (* SQRT2  0.75) (* SQRT2  0.25) (* SQRT2 -0.125)))
		(sym3 (float-vector (/ (* SQRT2 1.0) 8.0) (/ SQRT2*3 8.0) (/ SQRT2*3 8.0) (/ (* SQRT2 1.0) 8.0)))
		(sym4 (float-vector (/ SQRT2*3 128.0) (/ (* SQRT2  -6.0) 128.0) (/ (* SQRT2 -16.0) 128.0)
				    (/ (* SQRT2  38.0) 128.0) (/ (* SQRT2  90.0) 128.0) (/ (* SQRT2  38.0) 128.0)
				    (/ (* SQRT2 -16.0) 128.0) (/ (* SQRT2  -6.0) 128.0) (/ SQRT2*3 128.0) 0.0))
		(sym5 (float-vector (/ SQRT2*3 64.0) (/ (* SQRT2 -9.0) 64.0) (/ (* SQRT2 -7.0) 64.0) (/ (* SQRT2 45.0) 64.0)
				    (/ (* SQRT2 45.0) 64.0) (/ (* SQRT2 -7.0) 64.0) (/ (* SQRT2 -9.0) 64.0) (/ SQRT2*3 64.0)))
		(sym6 (float-vector (/ (* SQRT2   -35.0) 16384.0) (/ (* SQRT2  -105.0) 16384.0) (/ (* SQRT2  -195.0) 16384.0)
				    (/ (* SQRT2   865.0) 16384.0) (/ (* SQRT2   363.0) 16384.0) (/ (* SQRT2 -3489.0) 16384.0)
				    (/ (* SQRT2  -307.0) 16384.0) (/ (* SQRT2 11025.0) 16384.0) (/ (* SQRT2 11025.0) 16384.0)
				    (/ (* SQRT2  -307.0) 16384.0) (/ (* SQRT2 -3489.0) 16384.0) (/ (* SQRT2   363.0) 16384.0)
				    (/ (* SQRT2   865.0) 16384.0) (/ (* SQRT2  -195.0) 16384.0) (/ (* SQRT2  -105.0) 16384.0)
				    (/ (* SQRT2   -35.0) 16384.0))))
	    ;; --------- wavelet
	    
	    ;; test against fxt output
	    (let ((d0 (snd-transform wavelet-transform #r(1 1 0 0 0 0 0 0) 0))) ;"daub4"
	      (if (not (mus-arrays-equal? d0 #r(0.625 0.375 -0.217 1.083 -0.354 0.0 0.0 0.354)))
		  (snd-display "fxt wavelet 1: ~A" d0)))
	    
	    (let ((wts (vector daub4 daub6 daub8 daub10 daub12 daub14 daub16 daub18 daub20
			       Battle-Lemarie Burt-Adelson Beylkin coif2 coif4 coif6
			       sym2 sym3 sym4 sym5 sym6)))
	      (for-each 
	       (lambda (size)
		 (do ((i 0 (+ i 1))
		      (d1 (make-float-vector size) (make-float-vector size))
		      (d2 (make-float-vector size) (make-float-vector size)))
		     ((= i 20))
		   (set! (d1 2) 1.0)
		   (set! (d2 2) 1.0)
		   (wavelet d1 size 0 pwt (wts i))
		   (snd-transform wavelet-transform d2 i)
		   (if (not (mus-arrays-equal? d1 d2))
		       (snd-display "wavelet ~D: ~A ~A" i d1 d2))
		   (wavelet d2 size -1 pwt (wts i))
		   (fill! d1 0.0)
		   (set! (d1 2) 1.0)
		   (if (not (mus-arrays-equal? d1 d2))
		       (if (memv i '(9 10))
			   (begin
			     (set! (d2 2) 0.0)
			     (if (> (float-vector-peak d2) .1)
				 (snd-display "inverse wavelet ~D: ~A ~A" i d1 d2)))
			   (if (> i 14)
			       (let ((pk (d2 2)))
				 (set! (d2 2) 0.0)
				 (if (> (float-vector-peak d2) pk)
				     (snd-display "inverse wavelet ~D: ~A ~A" i d1 d2)))
			       (snd-display "inverse wavelet ~D: ~A ~A" i d1 d2)))))
		 (do ((i 0 (+ i 1))
		      (d1 #f)
		      (d2 (make-float-vector size)))
		     ((= i 9))
		   (fill-float-vector d2 (random 1.0))
		   (set! d1 (copy d2))
		   (snd-transform wavelet-transform d2 i)
		   (wavelet d2 size -1 pwt (wts i))
		   (if (not (mus-arrays-equal? d1 d2))
		       (snd-display "random wavelet ~D: ~A ~A" i d1 d2))))
	       '(16 64)))))
	
	(set! *max-transform-peaks* 100)
	(let ((ind (open-sound "oboe.snd")))
	  (let ((ftype (add-transform "low-pass" "filtered" 0.0 1.0
				      (lambda (len fd)
					(let ((flt (make-fir-filter :order 8 
								    :xcoeffs (make-float-vector 8 0.125)))
					      (v (make-float-vector len)))
					  (fill-float-vector v (fir-filter flt (read-sample fd))))))))
	    (if (not (transform? ftype)) (snd-display "transform added: ~A?" ftype))
	    (set! *transform-normalization* dont-normalize)
	    (set! (transform-type ind 0) ftype))
	  (set! (transform-size ind 0) 16)
	  (set! (transform-graph-type ind 0) graph-once)
	  (set! (transform-graph? ind 0) #t)
	  (set! (cursor ind 0) 12000)
	  (if (file-exists? "s61.scm") (delete-file "s61.scm"))
	  (save-state "s61.scm")
	  (delete-file "s61.scm") ; added transform needs to be saved somehow?
	  (close-sound ind))
	
	(let ((ind (open-sound "oboe.snd"))
	      (ftype (add-transform "abs-it" "absit" 0.0 1.0
				    (lambda (len fd)
				      (let ((v (make-float-vector len)))
					(fill-float-vector v (read-sample fd)))))))
	  (set! *transform-normalization* dont-normalize)
	  (set! (transform-type ind 0) ftype)
	  (set! (transform-size ind 0) 256)
	  (set! (transform-graph-type ind 0) graph-once)
	  (set! (transform-graph? ind 0) #t)
	  (set! (cursor ind 0) 12000)
	  (let ((samps (transform->float-vector ind 0))
		(orig (channel->float-vector (left-sample ind 0) 256))
		(happy #t))
	    (do ((i 0 (+ i 1)))
		((or (not happy) (= i 256)))
	      (when (fneq (samps i) (orig i))
		(snd-display "add-transform same (~A): ~D ~A ~A" ftype i (samps i) (orig i))
		(set! happy #f))))
	  (set! (dot-size ind 0) 60)
	  (set! (graph-style ind 0) graph-lollipops)
	  (set! (x-bounds) (list 2.579 2.580))
	  (update-time-graph)
	  (delete-transform ftype)
	  (if (transform? ftype) (snd-display "transform deleted: ~A" ftype))
	  (if (transform? -1) (snd-display "transform? -1"))
	  (if (transform? (integer->transform 123)) (snd-display "transform? 123"))
	  (if (not (equal? (transform-type ind 0) fourier-transform)) 
	      (snd-display "after delete-transform ~A -> ~A" ftype (transform-type ind 0)))
	  (close-sound ind))
	
	(when (defined? 'bignum-fft)
	  
	  (define* (vectors-equal? v1 v2 (error 1e-30))
	    (let ((len (length v1)))
	      (and (= (length v2) len)
		   (do ((happy #t)
			(i 0 (+ i 1)))
		       ((or (= i len) (not happy)) happy)
		     (set! happy (< (magnitude (- (vector-ref v1 i) (vector-ref v2 i))) error))))))
	  
	  (define* (bignum-vector :rest args)
	    (let ((len (length args)))
	      (do ((v (make-vector len))
		   (i 0 (+ i 1))
		   (arg args (cdr arg)))
		  ((= i len) v)
		(vector-set! v i (if (bignum? (car arg)) (car arg) (bignum (number->string (car arg))))))))
	  
	  ;; -------- -1 -1 at 1
	  (let ((rl (make-vector 8))
		(im (make-vector 8)))
	    (do ((i 0 (+ i 1))) 
		((= i 8)) 
	      (set! (rl i) (bignum "0.0")) 
	      (set! (im i) (bignum "0.0")))
	    (set! (rl 1) (bignum "-1.0"))
	    (set! (im 1) (bignum "-1.0"))
	    (bignum-fft rl im 8) ; third arg is size
	    (let ((crl (bignum-vector -1.000 0.0 1.000 (sqrt (bignum "2")) 1.000 0.0 -1.000 (- (sqrt (bignum "2")))))
		  (cim (bignum-vector -1.000 (- (sqrt (bignum "2"))) -1.000 0.0 1.000 (sqrt (bignum "2")) 1.000 0.000)))
	      (if (not (and (vectors-equal? rl crl)
			    (vectors-equal? im cim)))
		  (snd-display "big-fft -1 -1 at 1:~%rl: ~A~%    ~A~%im: ~A~%    ~A~%" rl crl im cim)))
	    (bignum-fft rl im 8 -1)
	    (let ((crl (bignum-vector 0.0 -8.0 0.0 0.0 0.0 0.0 0.0 0.0))
		  (cim (bignum-vector 0.0 -8.0 0.0 0.0 0.0 0.0 0.0 0.0)))
	      (if (not (and (vectors-equal? rl crl)
			    (vectors-equal? im cim)))
		  (snd-display "big-fft -1 -1 at 1 inverse:~%rl: ~A~%    ~A~%im: ~A~%    ~A~%" rl crl im cim))
	      (set! (rl 1) (bignum "-1.0"))
	      (set! (im 1) (bignum "-1.0"))
	      (do ((i 0 (+ i 1)))
		  ((= i 4))
		(bignum-fft rl im 8))
	      (set! (crl 1) (bignum "-64.0"))
	      (set! (cim 1) (bignum "-64.0"))
	      (if (not (and (vectors-equal? rl crl)
			    (vectors-equal? im cim)))
		  (snd-display "big-fft -1 -1 at 1 rotate:~%rl: ~A~%    ~A~%im: ~A~%    ~A~%" rl crl im cim))))
	  
	  ;; -------- -1 1 at 3
	  (let ((rl (make-vector 8))
		(im (make-vector 8)))
	    (do ((i 0 (+ i 1))) 
		((= i 8)) 
	      (set! (rl i) (bignum "0.0")) 
	      (set! (im i) (bignum "0.0")))
	    (set! (rl 3) (bignum "-1.0"))
	    (set! (im 3) (bignum "1.0"))
	    (bignum-fft rl im 8)
	    (let ((crl (bignum-vector -1.000 0.0 1.000 (- (sqrt (bignum "2"))) 1.000 0.0 -1.000 (sqrt (bignum "2"))))
		  (cim (bignum-vector 1.000 (- (sqrt (bignum "2"))) 1.000 0.0 -1.000 (sqrt (bignum "2")) -1.000 0.000)))
	      (if (not (and (vectors-equal? rl crl)
			    (vectors-equal? im cim)))
		  (snd-display "big-fft -1 1 at 3:~%rl: ~A~%    ~A~%im: ~A~%    ~A~%" rl crl im cim))))
	  
	  ;; -------- 1 0 at 0 with bignum arg to make-vector (so it should copy)
	  (let ((rl (make-vector 8 (bignum "0.0")))
		(im (make-vector 8 (bignum "0.0"))))
	    (set! (rl 0) (bignum "1.0"))
	    (bignum-fft rl im 8)
	    (let ((crl (bignum-vector 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0))
		  (cim (bignum-vector 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0)))
	      (if (not (and (vectors-equal? rl crl)
			    (vectors-equal? im cim)))
		  (snd-display "big-fft 1 0 at 0 (and copied fill):~%rl: ~A~%    ~A~%im: ~A~%    ~A~%" rl crl im cim))))
	  
	  ;; -------- cos/sin
	  (let ((rl (make-vector 64))
		(im (make-vector 64)))
	    (do ((i 0 (+ i 1))) 
		((= i 64)) 
	      (set! (rl i) (bignum "0.0")) 
	      (set! (im i) (bignum "0.0")))
	    (set! (rl 1) (bignum "1.0"))
	    
	    (bignum-fft rl im 64 -1)
	    (do ((happy #t)
		 (i 0 (+ i 1)))
		((or (= i 64) (not happy)))
	      (let ((cerr (magnitude (- (vector-ref rl i) (cos (/ (* 2 pi i) 64)))))
		    (serr (magnitude (- (vector-ref im i) (sin (/ (* -2 pi i) 64))))))
		(set! happy (and (< cerr 1e-30)
				 (< serr 1e-30)))
		(if (not happy)
		    (snd-display "big fft 1 at 0 (sin/cos) differs by ~A in ~A at ~A (~A ~A)~%"
				 (max cerr serr)
				 (if (> cerr serr) "cos" "sin")
				 i
				 (if (> cerr serr)
				     (cos (/ (* 2 pi i) 64))
				     (sin (/ (* -2 pi i) 64)))
				 (vector-ref (if (> cerr serr) rl im) i)))))
	    
	    (bignum-fft rl im 64)
	    (let ((crl (make-vector 64 (bignum "0.0")))
		  (cim (make-vector 64 (bignum "0.0"))))
	      (set! (crl 1) (bignum "64"))
	      (if (not (and (vectors-equal? rl crl)
			    (vectors-equal? im cim)))
		  (snd-display "big-fft 1 at 0 fill cos/sin inverse:~%rl: ~A~%    ~A~%im: ~A~%    ~A~%" rl crl im cim))))
	  
	  ;; -------- random 
	  (let ((rl (make-vector 64))
		(im (make-vector 64))
		(crl (make-vector 64))
		(cim (make-vector 64)))
	    (let ((rs (random-state (bignum "12345678"))))
	      (do ((i 0 (+ i 1))) 
		  ((= i 64)) 
		(set! (rl i) (random (bignum "1.0") rs))
		(set! (crl i) (+ (vector-ref rl i) 0.0)) ; try to force a copy
		(set! (im i) (random (bignum "1.0") rs))
		(set! (cim i) (+ (vector-ref im i) 0.0))))
	    
	    (bignum-fft rl im 64 1)
	    (if (or (vectors-equal? rl crl)
		    (vectors-equal? im cim))
		(snd-display "big-fft random not copied?:~%rl: ~A~%    ~A~%im: ~A~%    ~A~%" rl crl im cim))
	    
	    (bignum-fft rl im 64 -1)
	    (do ((i 0 (+ i 1)))
		((= i 64))
	      (set! (rl i) (/ (vector-ref rl i) 64.0))
	      (set! (im i) (/ (vector-ref im i) 64.0)))
	    (if (not (and (vectors-equal? rl crl)
			  (vectors-equal? im cim)))
		(snd-display "big-fft random:~%rl: ~A~%    ~A~%im: ~A~%    ~A~%" rl crl im cim))))
	
	
	(let ((ind1 (open-sound "oboe.snd")))
	  (set! (time-graph-style ind1 0) graph-lollipops)
	  (graph->ps "aaa.eps")
	  (set! (transform-graph? ind1 0) #t)
	  (set! (transform-graph-type ind1 0) graph-as-sonogram)
	  (set! *transform-size* 256)
	  (update-transform-graph)
	  (when with-gui
	    (let ((size (transform-framples ind1 0)))
	      (if (or (number? size)
		      (not (= (length size) 3)))
		  (snd-display "transform-framples of sonogram: ~A" size))))
	  (graph->ps "aaa.eps")
	  (if (and (defined? 'integer->colormap)
		   (integer? *colormap*))
	      (set! *colormap* (integer->colormap *colormap*)))
	  (let-temporarily ((*colormap* black-and-white-colormap))
	    (update-transform-graph)
	    (set! (transform-graph-type ind1 0) graph-as-spectrogram)
	    (update-transform-graph)
	    (graph->ps "aaa.eps"))
	  (close-sound ind1))
	
	(let ((ind (new-sound "test.snd" :header-type mus-next :sample-type mus-ldouble)))
	  (pad-channel 0 1000)
	  (set! (transform-graph-type ind 0) graph-once)
	  (set! (show-transform-peaks ind 0) #t)
	  (set! (fft-log-magnitude ind 0) #t)
	  (set! (fft-log-frequency ind 0) #f)
	  (set! (transform-graph? ind 0) #t)
	  (set! (x-bounds) (list 0.0 .04))
	  (update-time-graph)
	  (update-transform-graph)
	  (close-sound ind))
	
	(let ((ind (open-sound "oboe.snd")))
	  (set! (show-listener) #f)
	  (set! (window-height) 800)
	  (set! (lisp-graph? ind 0) #t)
	  (graph (channel->float-vector 1000 8192 ind 0) "biggy" 0.0 1.0 0.0 1.0 ind 0)
	  (set! (transform-graph-type ind 0) graph-once)
	  (set! (show-transform-peaks ind 0) #t)
	  (set! (fft-log-magnitude ind 0) #t)
	  (set! (fft-log-frequency ind 0) #f)
	  (set! (transform-graph? ind 0) #t)
	  (graph->ps "aaa.eps")
	  (set! (x-bounds) (list 0.0 1.0))
	  (set! (max-transform-peaks ind 0) 3)
	  (update-time-graph)
	  (update-transform-graph)
	  (update-lisp-graph)
	  (scale-by 0.0)
	  (update-time-graph)
	  (update-transform-graph)
	  (undo)
	  (set! (transform-graph-type ind 0) graph-as-sonogram)
	  (set! (fft-log-magnitude ind 0) #f)
	  (update-transform-graph)
	  (graph->ps "aaa.eps")
	  (set! *with-gl* #f)
	  (set! (spectrum-end ind 0) .2)
	  (set! (transform-graph-type ind 0) graph-as-spectrogram)
	  (update-transform-graph)
	  (update-lisp-graph)
	  (graph->ps "aaa.eps")
	  (set! (show-listener) #t)
	  (close-sound ind))
	
	(let ((v (dolph 16 2.5)))
	  (if (not (mus-arrays-equal? v #r(0.097 0.113 0.221 0.366 0.536 0.709 0.860 0.963 1.000 0.963 0.860 0.709 0.536 0.366 0.221 0.113)))
	      (snd-display "dolph 16 2.5 (dsp.scm): ~A" v)))
	
	(let ((v (make-float-vector 8)))
	  (let ((v0 (make-float-vector 8)))
	    (do ((i 0 (+ i 1)))
		((= i 8))
	      (set! (v i) (mus-random 1.0))
	      (set! (v0 i) (float-vector-ref v i)))
	    (set! v (float-vector-scale! (dht (dht v)) (/ 1.0 8.0)))
	    (if (not (vmus-arrays-equal? v v0))
		(snd-display "dht twice: ~A ~A" v v0)))
	  (fill! v 0.0)
	  (set! (v 1) 1.0)
	  (set! v (dht v))
	  (if (not (mus-arrays-equal? v #r(1.000 1.414 1.000 0.0 -1.000 -1.414 -1.000 0.000)))
	      (snd-display "dht of pulse: ~A" v)))
	
	(let ((ind (open-sound "oboe.snd")))
	  (let ((val1 (car (find-sine 553.0 2000 3000 ind)))
		(val2 (car (find-sine 620.0 2000 3000 ind))))
	    (if (or (fneq val1 .03835)
		    (fneq val2 .0012))
		(snd-display "find-sine: ~A ~A" val1 val2)))
	  (let ((frq (spot-freq 2000 ind 0)))
	    (if (not (= (round frq) 553))
		(snd-display "spot-freq: ~A" frq)))
	  (down-oct 2)
	  (let ((frq (spot-freq 2000 ind 0)))
	    (if (not (member (round frq) '(276 277) =))
		(snd-display "spot-freq down oct: ~A" frq)))
	  (undo)
	  (zero-phase)
	  (if (fneq (sample 0) .1472) (snd-display "zero-phase: ~A" (sample 0)))
	  (undo)
	  (rotate-phase (lambda (x) x))
	  (undo)
	  (brighten-slightly .5)
	  (undo)
	  (spike)
	  (close-sound ind))
	
	(let* ((ind (open-sound "1a.snd"))
	       (valf (car (find-sine 440.0 0 (framples) ind)))
	       (valg (* 2 (/ (goertzel 440.0 0 (framples) ind) (framples))))
	       (valf1 (car (find-sine 100.0 0 (framples) ind)))
	       (valg1 (* 2 (/ (goertzel 100.0 0 (framples) ind) (framples))))
	       (valf2 (car (find-sine 440.0 0 (framples) ind)))
	       (valg2 (* 2 (/ (goertzel 440.0 0 (framples) ind) (framples))))
	       (valf3 (car (find-sine 437.0 0 (framples) ind)))
	       (valg3 (* 2 (/ (goertzel 437.0 0 (framples) ind) (framples)))))
	  (if (fneq valf valg) (snd-display "goertzel 0: ~A ~A" valf valg))
	  (if (fneq valf1 valg1) (snd-display "goertzel 1: ~A ~A" valf1 valg1))
	  (if (fneq valf2 valg2) (snd-display "goertzel 2: ~A ~A" valf2 valg2))
	  (if (fneq valf3 valg3) (snd-display "goertzel 3: ~A ~A" valf3 valg3))
	  (close-sound ind))
	
	(let ((v (float-vector-polynomial #r(0.0 2.0) #r(1.0 2.0))))
	  (if (not (mus-arrays-equal? v #r(1.0 5.0)))
	      (snd-display "float-vector-polynomial 0: ~A" v)))
	(let ((v (float-vector-polynomial #r(0 1 2) #r(0 2 1))))
	  (if (not (mus-arrays-equal? v #r(0.0 3.000 8.000)))
	      (snd-display "float-vector-polynomial 1: ~A" v)))
	(let ((v (float-vector-polynomial #r(0 1 2) #r(0 2 1 .5))))
	  (if (not (mus-arrays-equal? v #r(0.0 3.500 12.000)))
	      (snd-display "float-vector-polynomial 2: ~A" v)))
	(let ((v (float-vector-polynomial #r(0 1 2) #r(1))))
	  (if (not (mus-arrays-equal? v #r(1 1 1)))
	      (snd-display "float-vector-polynomial 3: ~A" v)))
	(let ((ind (open-sound "pistol.snd")))
	  (let ((mx (maxamp ind 0)))
	    (channel-polynomial #r(0.0 2.0) ind 0)
	    (if (fneq (maxamp) (* mx 2))
		(snd-display "channel-polynomial 2: ~A" (maxamp))))
	  (undo)
	  (channel-polynomial #r(0.0 0.5 0.25 0.25) ind 0)
	  (if (fneq (maxamp) .222)
	      (snd-display "channel-polynomial 3: ~A" (maxamp)))
	  (undo)
	  (channel-polynomial #r(0.0 0.0 1.0) ind 0)
	  (let ((pos (scan-channel (lambda (y) (< y 0.0)))))
	    (if pos
		(snd-display "channel-polynomial squares: ~A" pos)))
	  (undo)
	  (channel-polynomial #r(0.5 1.0) ind 0)
	  (let ((pos (scan-channel (lambda (y) (< y 0.0)))))
	    (if pos
		(snd-display "channel-polynomial offset: ~A" pos)))
	  (if (fneq (maxamp) .8575)
	      (snd-display "channel-polynomial off mx: ~A" (maxamp)))
	  (undo)
	  (spectral-polynomial #r(0.0 1.0) ind 0)
	  (if (fneq (maxamp) .493)
	      (snd-display "spectral-polynomial 0 mx: ~A" (maxamp)))
	  (if (not (= (framples ind 0) 41623))
	      (snd-display "spectral-polynomial 0 len: ~A" (framples)))
	  (undo)
	  (spectral-polynomial #r(0.0 0.5 0.5) ind 0)
	  (if (fneq (maxamp) .493)
	      (snd-display "spectral-polynomial 1: ~A" (maxamp)))
	  (if (not (= (framples ind 0) 83246)) ;(* 2 41623)
	      (snd-display "spectral-polynomial 1 len: ~A" (framples)))
	  (undo)
	  (spectral-polynomial #r(0.0 0.0 0.0 1.0) ind 0)
	  (if (fneq (maxamp) .493)
	      (snd-display "spectral-polynomial 2: ~A" (maxamp)))
	  (if (not (= (framples ind 0) 124869)) ;(* 3 41623)
	      (snd-display "spectral-polynomial 1 len: ~A" (framples)))
	  (close-sound ind))
	
	(let ((vals (scentroid "oboe.snd")))
	  (if (or (fneq (vals 0) 1876.085) (fneq (vals 1) 1447.004))
	      (snd-display "scentroid: ~A" vals)))
	
	(let ((flt (make-fir-filter 3 #r(0.5 0.25 0.125)))
	      (data (make-float-vector 10))
	      (undata (make-float-vector 10)))
	  (set! (data 0) 1.0)
	  (do ((i 0 (+ i 1)))
	      ((= i 10))
	    (set! (undata i) (fir-filter flt (data i))))
	  (let ((fdata (invert-filter #r(0.5 0.25 0.125))))
	    (set! flt (make-fir-filter (length fdata) fdata))
	    (do ((i 0 (+ i 1)))
		((= i 10))
	      (set! (undata i) (fir-filter flt (undata i))))
	    (if (not (mus-arrays-equal? undata data))
		(snd-display "invert-filter: ~A" undata))))
	
	(let ((coeffs (make-float-vector 6)))
	  (do ((i 0 (+ i 1))
	       (top .8 (- top .1)))
	      ((= i 6))
	    (set! (coeffs i) (+ top (random .2))))
	  (let ((flt (make-fir-filter 6 coeffs))
		(data (make-float-vector 20))
		(undata (make-float-vector 20)))
	    (set! (data 0) 1.0)
	    (do ((i 0 (+ i 1)))
		((= i 20))
	      (set! (undata i) (fir-filter flt (data i))))
	    (let ((fdata (invert-filter coeffs)))
	      (set! flt (make-fir-filter (length fdata) fdata))
	      (do ((i 0 (+ i 1)))
		  ((= i 20))
		(set! (undata i) (fir-filter flt (undata i))))
	      (if (not (mus-arrays-equal? undata data))
		  (snd-display "invert-filter (6): ~A" undata)))))
	
	(let ((flt (make-volterra-filter #r(1.0 .4) #r(.3 .2 .1)))
	      (data (make-float-vector 10))
	      (x 0.0))
	  (do ((i 0 (+ i 1)))
	      ((= i 10))
	    (set! (data i) (volterra-filter flt x))
	    (set! x (if (= i 0) 0.5 0.0)))
	  (if (not (mus-arrays-equal? data #r(0.0 0.575 0.250 0.025 0.0 0.0 0.0 0.0 0.0 0.000)))
	      (snd-display "volterra-filter: ~A" data)))
	
	(let ((flt (make-volterra-filter #r(1.0) #r(1.0)))
	      (data (make-float-vector 10)))
	  (do ((i 0 (+ i 1))
	       (x 1.0 0.0))
	      ((= i 10))
	    (set! (data i) (volterra-filter flt x)))
	  (if (not (mus-arrays-equal? data #r(2.000 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.000)))
	      (snd-display "volterra-filter x + x^2: ~A" data)))
	
	(let ((flt (make-volterra-filter #r(1.0) #r(1.0)))
	      (data (make-float-vector 10)))
	  (do ((i 0 (+ i 1))
	       (x 1.0 (- x 0.1)))
	      ((= i 10))
	    (set! (data i) (volterra-filter flt x)))
	  (if (not (mus-arrays-equal? data #r(2.000 1.710 1.440 1.190 0.960 0.750 0.560 0.390 0.240 0.110)))
	      (snd-display "volterra-filter x + x^2 by -0.1: ~A" data)))
	
	(let ((flt (make-volterra-filter #r(1.0 0.5) #r(1.0)))
	      (data (make-float-vector 10)))
	  (do ((i 0 (+ i 1))
	       (x 1.0 0.0))
	      ((= i 10))
	    (set! (data i) (volterra-filter flt x)))
	  (if (not (mus-arrays-equal? data #r(2.000 0.500 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.000)))
	      (snd-display "volterra-filter x + .5x(n-1) + x^2: ~A" data)))
	
	(let ((flt (make-volterra-filter #r(1.0 0.5) #r(1.0 0.6)))
	      (data (make-float-vector 10)))
	  (do ((i 0 (+ i 1))
	       (x 0.9 0.0))
	      ((= i 10))
	    (set! (data i) (volterra-filter flt x)))
	  (if (not (mus-arrays-equal? data #r(1.710 0.936 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.000)))
	      (snd-display "volterra-filter x + .5x(n-1) + x^2 + 0.6: ~A" data)))
	
	
	(let ((ind (new-sound "test.snd" :size 100)))
	  (let ((gen (make-oscil 440.0)))
	    (map-channel (lambda (y) (oscil gen))))
	  (down-oct 2)
	  (if (not (= (framples) 200)) (snd-display "down-oct new len: ~A" (framples)))
	  (let ((r1 (make-sampler 0 ind 0 1 1))
		(r2 (make-sampler 0 ind 0 1 2)))
	    (do ((i 0 (+ i 2)))
		((= i 200))
	      (let ((val1 (r1))
		    (val2 (r2))
		    (val3 (r2)))
		(if (and (fneq val1 val2)
			 (fneq val1 val3))
		    (snd-display "down-oct: ~A ~A ~A ~A" i val1 val2 val3)))))
	  
	  (kalman-filter-channel) ; just make sure it runs
	  
	  (close-sound ind))
	
	(let ((d0 (make-float-vector 8))
	      (d1 (make-float-vector 8)))
	  (set! (d0 2) 1.0)
	  (let ((vals (fractional-fourier-transform d0 d1 8 1.0)))
	    (if (not (and (mus-arrays-equal? (car vals) #r(1.000 0.0 -1.000 0.0 1.000 0.0 -1.000 -0.000))
			  (mus-arrays-equal? (cadr vals) #r(0.0 1.000 0.0 -1.000 0.0 1.000 0.0 -1.000))))
		(snd-display "fractional-fft: ~A?" vals))))
	
	(let ((d0 (make-float-vector 8))
	      (d1 (make-float-vector 8)))
	  (let ((val (z-transform (vector 0 0 1.0 0 0 0 0 0) 8 (exp (complex 0.0 (* .25 pi))))))
	    (do ((i 0 (+ i 1)))
		((= i 8))
	      (set! (d0 i) (real-part (vector-ref val i)))
	      (set! (d1 i) (imag-part (vector-ref val i))))
	    (if (not (and (mus-arrays-equal? d0 #r(1.000 0.0 -1.000 0.0 1.000 0.0 -1.000 -0.000))
			  (mus-arrays-equal? d1 #r(0.0 1.000 0.0 -1.000 0.0 1.000 0.0 -1.000))))
		(snd-display "z-transform: ~A ~A?" d0 d1))))
	
	(let ((v1 (make-float-vector 16)))
	  (set! (v1 0) 1.0)
	  (let ((res (z-transform v1 16 0.5)))
	    (if (not (mus-arrays-equal? res (make-float-vector 16 1.0)))
		(snd-display "z 0.5 0=1: ~A" res)))
	  (let ((res (z-transform v1 16 -1.0)))
	    (if (not (mus-arrays-equal? res (make-float-vector 16 1.0)))
		(snd-display "z -1.0 0=1: ~A" res)))
	  (set! (v1 0) 0.0)
	  (set! (v1 1) 1.0)
	  (let ((res (z-transform v1 16 0.5)))
	    (if (not (mus-arrays-equal? res #r(1.000 0.500 0.250 0.125 0.062 0.031 0.016 0.008 0.004 0.002 0.001 0.0 0.0 0.0 0.0 0.0)))
		(snd-display "z 0.5 1=1: ~A" res)))
	  (let ((res (z-transform v1 16 2.0)))
	    (if (not (mus-arrays-equal? res #r(1.0 2.0 4.0 8.0 16.0 32.0 64.0 128.0 256.0 512.0 1024.0 
							  2048.0 4096.0 8192.0 16384.0 32768.0)))
		(snd-display "z 2.0 1=1: ~A" res)))
	  (set! (v1 2) 1.0)
	  (let ((res (z-transform v1 16 0.5)))
	    (if (not (mus-arrays-equal? res #r(2.0 0.75 0.3125 0.140 0.0664 0.0322 0.0158 0.00787 0.0039 0.0019 0 0 0 0 0 0)))
		(snd-display "z 0.5 1=1 2=1: ~A" res)))
	  (let ((res (z-transform v1 16 2.0)))
	    (if (not (mus-arrays-equal? res #r(2.0 6.0 20.0 72.0 272.0 1056.0 4160.0 16512.0 65792.0 
							  262656.0 1049600.0 4196352.0 16781312.0 67117056.0 268451840.0 1073774592.0)))
		(snd-display "z 2.0 1=1 2=1: ~A" res)))
	  (do ((i 0 (+ i 1))
	       (j 1.0 (* j 0.4)))
	      ((= i 16))
	    (float-vector-set! v1 i j))
	  (let ((res (z-transform v1 16 1.0)))
	    (if (not (mus-arrays-equal? res (make-float-vector 16 (/ 1.0 (- 1.0 0.4))))) ; this is confusing
		(snd-display "z 1 0.4g: ~A" res))))
	
	(let ((ind (open-sound "oboe.snd")))
	  (do ((i 0 (+ i 1))) ((= i 4)) (automorph 0.0+1.0i 0 0 1))
	  (let ((mxdiff (float-vector-peak (float-vector-subtract! (channel->float-vector 0 #f ind 0 0) (channel->float-vector 0 #f ind 0) ))))
	    (if (> mxdiff .003) (snd-display "automorph rotation: ~A" mxdiff)))
	  
	  (revert-sound ind)
	  (periodogram 256)
	  (if (not (lisp-graph? ind)) (snd-display "periodogram not graphed?"))
	  (close-sound ind)))
      
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(let ((len (expt 2 (+ 2 (random 8)))))
	  (let ((v0 (make-float-vector len))
		(v1 (make-float-vector len))
		(v2 (make-vector len)))
	    (do ((k 0 (+ k 1)))
		((= k len))
	      (float-vector-set! v0 k (mus-random 0.5))
	      (float-vector-set! v1 k (mus-random 0.5))
	      (vector-set! v2 k (complex (v0 k) (v1 k))))
	    (mus-fft v0 v1 len 1)
	    (cfft! v2 len 1)
	    (do ((sum 0.0)
		 (mx 0.0)
		 (m 0 (+ m 1)))
		((= m len)
		 (if (or (> mx 1e-6)
			 (> sum 1e-6))
		     (snd-display "cfft! ~A: ~A ~A~%" len mx sum)))
	      (let ((diffr (abs (- (v0 m) (real-part (v2 m)))))
		    (diffi (abs (- (v1 m) (imag-part (v2 m))))))
		(set! sum (+ sum diffr diffi))
		(set! mx (max mx diffr diffi)))))))
      
      (let ((val (cfft! (cfft! (cfft! (cfft! (vector 0.0 1+i 0.0 0.0)))))))
	(if (or (> (magnitude (val 0)) 1e-12)
		(> (magnitude (val 2)) 1e-12)
		(> (magnitude (val 3)) 1e-12)
		(fneq 16.0 (real-part (val 1)))
		(fneq 16.0 (imag-part (val 1))))
	    (snd-display "cfft! 4x: ~A" val)))
      
      (do ((i 0 (+ i 1)))
	  ((= i 10))
	(let ((len (expt 2 (+ 2 (random 8)))))
	  (let ((v0 (make-float-vector len))
		(v1 (make-float-vector len))
		(v2 (make-float-vector len))
		(v3 (make-float-vector len)))
	    (do ((k 0 (+ k 1)))
		((= k len))
	      (float-vector-set! v0 k (mus-random 0.5))
	      (float-vector-set! v1 k (mus-random 0.5))
	      (set! (v2 k) (v0 k))
	      (set! (v3 k) (v1 k)))
	    (mus-fft v0 v1 len 1)
	    (fft! v2 v3 len 1)
	    (do ((sum 0.0)
		 (mx 0.0)
		 (m 0 (+ m 1)))
		((= m len)
		 (if (or (> mx 1e-6)
			 (> sum 1e-6))
		     (snd-display "fft! ~A: ~A ~A~%" len mx sum)))
	      (let ((diffr (abs (- (v0 m) (v2 m))))
		    (diffi (abs (- (v1 m) (v3 m)))))
		(set! sum (+ sum diffr diffi))
		(set! mx (max mx diffr diffi))))))))))


;;; ---------------- test 20: new stuff ----------------

(if (not (defined? 'load-font))
    (define (load-font name) #f))

(require snd-clean.scm snd-snddiff.scm)

(define snd_test_20
  (let ((add-comment 
	 (lambda* (sample comment snd1 chn1)
	   (let* ((snd (or snd1 (selected-sound)))
		  (chn (or chn1 (selected-channel)))
		  (old-comments (or (channel-property 'comments snd chn) ())))
	     (set! (channel-property 'comments snd chn)
		   (cons (list sample comment)
			 old-comments)))))
	
	(show-comments 
	 (lambda (snd chn)
	   (let ((comments (or (channel-property 'comments snd chn) ())))
	     (for-each
	      (lambda (comment)
		(let ((text (cadr comment)))
		  (let ((samp (car comment))
			(text-width (* 6 (length text)))
			(ls (left-sample snd chn))
			(rs (right-sample snd chn)))
		    (when (and (< ls samp rs)
			       (provided? 'snd-motif))
		      (let ((xpos (x->position (/ samp (srate))))
			    (ypos (y->position (sample samp))))
			(catch #t
			  (lambda ()
			    (draw-line xpos 20 xpos (- ypos 4) snd chn time-graph #f)
			    (draw-string text (- xpos (/ text-width 2)) 18 snd chn time-graph #f))
			  (lambda args
			    (snd-display "draw error: ~A" args))))))))
	      comments))))
	
	(display-samps-in-red 
	 (let ((+documentation+ "display samples 1000 to 2000 in red whenever they're in the current view"))
	   (lambda (snd chn)
	     (catch #t
	       (lambda ()
		 (let ((left (left-sample snd chn))
		       (right (right-sample snd chn))
		       (old-color (foreground-color snd chn))
		       (red (make-color-with-catch 1 0 0)))
		   (when (and (< left 2000)
			      (> right 1000)
			      (provided? 'snd-motif))
		     (let ((data (make-graph-data snd chn)))
		       (when data
			 (if (float-vector? data)                      ;the simple, one-sided graph case
			     (let ((new-data (let ((samps (- (min right 2000) (max left 1000)))
						   (offset (max 0 (- 1000 left))))
					       (float-vector-subseq data offset (+ offset samps)))))
			       (set! (foreground-color snd chn) red)
			       (graph-data new-data snd chn copy-context (max 1000 left) (min 2000 right) graph-lines #f)
			       (set! (foreground-color snd chn) old-color))
			     (let* ((low-data (car data))     ;the two-sided envelope graph case
				    ;; we need to place the red portion correctly in the current graph
				    ;; so the following is getting the "bin" numbers associated with 
				    ;; samples 1000 and 2000
				    (size (length low-data))
				    (samps (- right left))
				    (left-bin (round (/ (* size (max 0 (- 1000 left))) samps)))
				    (right-bin (round (/ (* size (- (min 2000 right) left)) samps)))
				    (new-low-data (float-vector-subseq low-data left-bin right-bin))
				    (new-high-data (float-vector-subseq (cadr data) left-bin right-bin)))
			       (set! (foreground-color snd chn) red)
			       (graph-data (list new-low-data new-high-data) snd chn copy-context left-bin right-bin graph-lines #f)
			       (set! (foreground-color snd chn) old-color))))))))
	       (lambda args
		 (snd-display "draw error: ~A" args))))))
	
	(show-greeting 
	 (lambda* ((snd 0) (chn 0))
	   (let ((ls (left-sample snd chn))
		 (rs (right-sample snd chn)))
	     (if (and (< ls 1000 rs)
		      (provided? 'snd-motif))
		 (let ((pos (x->position (/ 1000.0 (srate)))))
		   (let-temporarily (((foreground-color) (make-color 0.75 0.75 0.75)))
		     (fill-rectangle pos 10 50 20 snd chn time-graph #f #f)
		     (set! (foreground-color) (make-color 1 0 0))
		     (draw-string "hi!" (+ pos 5) 12 snd chn time-graph #f))))))))
    (lambda ()
      (do ((test-ctr 0 (+ 1 test-ctr))) ((= test-ctr tests)) 
	(log-mem test-ctr)
	
	(if (not (sound-file? "oboe.snd")) (snd-display "oboe.snd not a sound file?"))
	(if (not (sound-file? "4.aiff")) (snd-display "4.aiff not a sound file?"))
	(if (sound-file? "snd.h") (snd-display "snd.h is a sound-file?"))
	
	(let ((ind1 (open-sound "oboe.snd")))
	  (save-sound-as "test.snd" ind1)
	  (let ((ind2 (open-sound "test.snd")))
	    (if (not (channels-equal? ind1 0 ind2 0))
		(snd-display "channels-equal? of copy"))
	    (if (not (channels=? ind1 0 ind2 0))
		(snd-display "channels=? of copy"))
	    (pad-channel (framples ind2 0) 100)
	    (if (channels-equal? ind1 0 ind2 0)
		(snd-display "channels-equal? of pad"))
	    (if (not (channels=? ind1 0 ind2 0))
		(snd-display "channels=? of pad"))
	    (set! (sample 50900 ind2 0) .1)
	    (if (channels-equal? ind1 0 ind2 0)
		(snd-display "channels-equal? of pad+set"))
	    (if (channels=? ind1 0 ind2 0)
		(snd-display "channels=? of pad+set 0 err"))
	    (if (not (channels=? ind1 0 ind2 0 .2))
		(snd-display "channels=? of pad+set .2 err"))
	    (when (and with-gui
		       (or (provided? 'snd-motif)
			   (provided? 'gtk4)))
	      (add-comment 1234 "sample 1234" ind1 0)
	      (let ((comments (show-comments ind1 0)))
		(update-time-graph)
		(if (null? comments) (snd-display "add-comment failed?")))
	      (display-samps-in-red ind1 0)
	      (update-time-graph)
	      (catch #t (lambda () (show-greeting ind1 0)) (lambda args args))
	      (update-time-graph)
	      (color-samples *highlight-color* 0 100 ind1 0)
	      (update-time-graph)
	      (power-env-channel (make-power-env '(0 0 .325  1 1 32.0 2 0 32.0) :duration 2.0))
	      (update-time-graph)
	      (revert-sound ind1)
	      (make-selection 10000 20000 ind1 0)
	      (if (not (selection?))
		  (snd-display "make-selection for show failed?")
		  (begin
		    (show-selection)
		    (let ((vals (x-bounds ind1 0)))
		      (if (and (pair? vals)
			       (pair? (cdr vals))
			       (or (fneq (car vals) (/ 10000.0 (srate ind1)))
				   (fneq (cadr vals) (/ 20000.0 (srate ind1)))))
			  (snd-display "show-selection: ~A (~A)" vals (list (/ 10000.0 (srate ind1)) (/ 20000.0 (srate ind1))))))))
	      (hook-push graph-hook zoom-spectrum)
	      (set! (transform-graph? ind1 0) #t)
	      (let ((ind3 (open-sound "pistol.snd")))
		(overlay-sounds ind2 ind1 ind3)
		(update-time-graph ind2 0)
		(set! (hook-functions after-graph-hook) ())
		(close-sound ind3))
	      (samples-via-colormap ind1 0))
	    (close-sound ind1)
	    (hook-remove graph-hook zoom-spectrum)
	    (close-sound ind2)))
	
	(let ((ns (open-sound "1.snd")))
	  (set! (sync ns) 0)
	  (set! (selection-member? ns 0) #t)
	  (set! (selection-position ns 0) 1000)
	  (set! (selection-framples ns 0) 3000)
	  (show-selection)
	  (if (not (equal? (list (left-sample ns 0) (right-sample ns 0)) '(1000 3999)))
	      (snd-display "show-selection 1.snd: ~A ~A" (left-sample ns 0) (right-sample ns 0)))
	  (unselect-all)
	  (let ((ns1 (open-sound "1234.snd")))
	    (set! (sync ns1) 0)
	    (set! (selection-member? ns 0) #t)
	    (set! (selection-position ns 0) 10000)
	    (set! (selection-framples ns 0) 30000)
	    (set! (selection-member? ns1 0) #t)
	    (set! (selection-position ns1 0) 10000)
	    (set! (selection-framples ns1 0) 30000)
	    (set! (selection-member? ns1 1) #t)
	    (set! (selection-position ns1 1) 10000)
	    (set! (selection-framples ns1 1) 30000)
	    (show-selection)
	    (if (not (and (eqv? (left-sample ns 0) 10000)
			  (memv (right-sample ns 0) '(39999 39998))
			  (eqv? (left-sample ns1 0) 10000)
			  (memv (right-sample ns1 0) '(39999 39998))
			  (eqv? (left-sample ns1 1) 10000)
			  (memv (right-sample ns1 1) '(39999 39998))))
		(snd-display "show-selection 1234.snd: ~A" (list (left-sample ns 0) (right-sample ns 0) 
								 (left-sample ns1 0) (right-sample ns1 0) 
								 (left-sample ns1 1) (right-sample ns1 1))))
	    (close-sound ns1)
	    (close-sound ns)))
	
	(let ((pe (make-power-env '(0 0 32.0 1 1 32.0 2 0 0.0) :duration .1)))
	  (if (not (penv? pe)) (snd-display "penv? ~A" pe))
	  (let ((x (power-env pe))) (if (fneq x 0.0) (snd-display "power-env start: ~A" x)))
	  (if (> (abs (- (pe 'current-pass) 2203)) 2) (snd-display "power-env pass: ~A" (pe 'current-pass))) ; 4410/2 - 1 because x1=2
	  (if (not (= (pe 'current-env) 0)) (snd-display "power-env seg: ~A" (pe 'current-env))))
	
	(let-temporarily ((*clm-srate* 22050))
	  (set! *print-length* (max *print-length* 48))
	  (let ((ind (new-sound :size 33 :srate 22050)))
	    (map-channel (lambda (y) 1.0))
	    (let ((pe (make-power-env '(0 0 32.0  1 1 0.0312  2 0 1) :duration (/ 34.0 22050.0))))
	      (map-channel (lambda (y) (* y (power-env pe))))
	      (if (not (or (mus-arrays-equal?1 (channel->float-vector) 
					       #r(0.0 0.008 0.017 0.030 0.044 0.063 0.086 0.115 0.150 0.194 0.249 
							     0.317 0.402 0.507 0.637 0.799 1.000 0.992 0.983 0.971 0.956 0.937 
							     0.914 0.885 0.850 0.806 0.751 0.683 0.598 0.493 0.363 0.201 0.000))
			   (mus-arrays-equal?1 (channel->float-vector)
					       #r(0.0 0.008 0.019 0.032 0.049 0.070 0.097 0.130 0.173 0.226 0.293 
							     0.377 0.484 0.618 0.787 1.000 0.992 0.981 0.968 0.951 0.930 0.903 
							     0.870 0.828 0.774 0.707 0.623 0.516 0.382 0.213 0.0 0.0 0.000))))
		  (snd-display "power-env: ~A" (channel->float-vector))))
	    (map-channel (lambda (y) 1.0))
	    (let ((pe (make-power-env '(0 0 1.0  1 1 0.0  2 0 1  3 0 1) :duration (/ 34.0 22050.0))))
	      (map-channel (lambda (y) (* y (power-env pe))))
	      (if (not (mus-arrays-equal?1 (channel->float-vector) 
					   #r(0.0 0.100 0.200 0.300 0.400 0.500 0.600 0.700 0.800 0.900 1.000 
							 1.000 1.000 1.000 1.000 1.000 1.000 1.000 1.000 1.000 0.0 0.0 
							 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.000)))
		  (snd-display "power-env 0 and 1: ~A" (channel->float-vector))))
	    (map-channel (lambda (y) 1.0))
	    (let ((pe (make-power-env '(0 0 .01 1 1 1) :duration (/ 34.0 22050.0))))
	      (map-channel (lambda (y) (* y (power-env pe))))
	      (if (not (or (mus-arrays-equal?1 (channel->float-vector) 
					       #r(0.0 0.132 0.246 0.346 0.432 0.507 0.573 0.630 0.679 0.722 0.760 
							     0.792 0.821 0.845 0.867 0.886 0.902 0.916 0.928 0.939 0.948 0.956 
							     0.963 0.969 0.975 0.979 0.983 0.987 0.990 0.992 0.995 0.997 0.998))
			   (mus-arrays-equal?1 (channel->float-vector)
					       #r(0.0 0.135 0.253 0.354 0.442 0.518 0.584 0.641 0.691 0.733 0.771 
							     0.803 0.830 0.855 0.875 0.893 0.909 0.923 0.934 0.945 0.953 0.961 
							     0.968 0.973 0.978 0.982 0.986 0.987 0.990 0.992 0.995 0.997 0.998))))
		  (snd-display "power-env .01: ~A" (channel->float-vector))))
	    (clean-up-sound ind)))
	
	(let ((ind (new-sound "tmp.snd" 1 22050 mus-ldouble mus-next :size 50)))
	  (set! (sample 3) 1.0)
	  (filter-channel #r(.5 1.0 .5) 3)
	  (let ((data (channel->float-vector 0 10)))
	    (if (not (mus-arrays-equal? data #r(0.0 0.0 0.0 0.500 1.000 0.500 0.0 0.0 0.0 0.000)))
		(snd-display "filter (sym 3): ~A" data)))
	  (undo)
	  (filter-channel #r(.5 1.0 .25) 3)
	  (let ((data (channel->float-vector 0 10)))
	    (if (not (mus-arrays-equal? data #r(0.0 0.0 0.0 0.500 1.000 0.250 0.0 0.0 0.0 0.000)))
		(snd-display "filter (3): ~A" data)))
	  (undo)
	  (filter-channel #r(.5 1.0 1.0 .5) 4)
	  (let ((data (channel->float-vector 0 10)))
	    (if (not (mus-arrays-equal? data #r(0.0 0.0 0.0 0.500 1.000 1.000 0.500 0.0 0.0 0.000)))
		(snd-display "filter (sym 4): ~A" data)))
	  (undo)
	  (filter-channel #r(.5 1.0 1.0 .25) 4)
	  (let ((data (channel->float-vector 0 10)))
	    (if (not (mus-arrays-equal? data #r(0.0 0.0 0.0 0.500 1.000 1.000 0.250 0.0 0.0 0.000)))
		(snd-display "filter (4): ~A" data)))
	  (undo)
	  (close-sound ind))
	
	(new-sound "tmp.snd" 1 22050 mus-ldouble mus-next #f 100)
	(set! (sample 10) 0.5)
	(filter-sound #r(1.0 0.0 1.0) 3)
	(if (not (mus-arrays-equal? (channel->float-vector 5 10) #r(0.0 0.0 0.0 0.0 0.0 0.500 0.0 0.500 0.0 0.000)))
	    (snd-display "filter-sound 1 0 1: ~A" (channel->float-vector 5 10)))
	(undo)
	(filter-channel #r(1.0 0.0 1.0) 3)
	(if (not (mus-arrays-equal? (channel->float-vector 5 10) #r(0.0 0.0 0.0 0.0 0.0 0.500 0.0 0.500 0.0 0.000)))
	    (snd-display "filter-channel (v) 1 0 1: ~A" (channel->float-vector 5 10)))
	(undo)
	(filter-sound '(0 1 1 1) 100)
	(let ((coeffs (make-fir-coeffs 100 (make-float-vector 100 0.5)))
	      (data (channel->float-vector 10 100))
	      (happy #t))
	  (do ((i 0 (+ i 1)))
	      ((or (not happy) (= i 100)))
	    (when (fneq (data i) (coeffs i))
	      (snd-display "coeffs '(0 1 1 1): ~A ~A ~A" i (coeffs i) (data i))
	      (set! happy #f))))
	(undo)
	(filter-sound '(0 1 1 1) 1000)
	(if (not (mus-arrays-equal? (channel->float-vector 5 10) #r(0.0 0.0 0.0 0.0 0.0 0.500 0.0 0.0 0.0 0.000)))
	    (snd-display "filter-sound 1 (1000): ~A" (channel->float-vector 5 10)))
	(undo)
	(make-selection 5 15)
	(filter-selection '(0 1 1 1) 100)
	(if (not (member (edit-fragment 2) 
			 '(("filter-selection '(0.000 1.000 1.000 1.000) 100" "set" 5 11)
			   ("filter-selection '(0.000 1.000 1.000 1.000) 100" "set" 5 111))))
	    (snd-display "filter-selection truncated: ~S" (edit-fragment 2)))
	(undo)
	(filter-selection '(0 1 1 1) 100 #f)  
	(if (not (equal? (edit-fragment 2) '("filter-selection '(0.000 1.000 1.000 1.000) 100" "set" 5 111)))
	    (snd-display "filter-selection not truncated: ~S" (edit-fragment 2)))
	(if (not (mus-arrays-equal? (channel->float-vector 50 10) #r(-0.016 0.018 -0.021 0.024 -0.029 0.035 -0.045 0.064 -0.106 0.318)))
	    (snd-display "filter-selection no trunc: ~A" (channel->float-vector 50 10)))
	(undo)
	(filter-selection '(0 1 1 1) 1024 #t)
	(if (not (equal? (edit-fragment 2) '("filter-selection '(0.000 1.000 1.000 1.000) 1024" "set" 5 11)))
	    (snd-display "filter-selection truncated (1000): ~S" (edit-fragment 2)))
	(if (fneq (maxamp) 0.0) (snd-display "filter-selection 1000 untrunc? ~A" (maxamp)))
	(undo)
	(filter-selection '(0 1 1 1) 1024 #f)
	(if (not (equal? (edit-fragment 2) '("filter-selection '(0.000 1.000 1.000 1.000) 1024" "set" 5 1035)))
	    (snd-display "filter-selection not truncated (1000): ~S" (edit-fragment 2)))
	(if (fneq (maxamp) 0.318) (snd-display "filter-selection 1000 no trunc? ~A" (maxamp)))
	(if (not (mus-arrays-equal? (channel->float-vector 517 10) #r(0.035 -0.045 0.064 -0.106 0.318 0.318 -0.106 0.064 -0.045 0.035)))
	    (snd-display "filter-selection 1000 no trunc: ~A" (channel->float-vector 505 10)))
	
	(undo)
	(filter-channel '(0 1 1 1) 10)
	(if (not (mus-arrays-equal? (channel->float-vector 10 10) #r(0.008 -0.025 0.050 -0.098 0.316 0.316 -0.098 0.050 -0.025 0.008)))
	    (snd-display "filter-channel 10: ~A" (channel->float-vector 10 10)))
	(undo)
	(filter-channel '(0 1 1 1) 1000)
	(if (not (mus-arrays-equal? (channel->float-vector 5 10) #r(0.0 0.0 0.0 0.0 0.0 0.500 0.0 0.0 0.0 0.000)))
	    (snd-display "filter-channel 1 (1000): ~A" (channel->float-vector 5 10)))
	(undo)
	(filter-channel '(0 1 1 0) 10)
	(if (not (mus-arrays-equal? (channel->float-vector 0 30) #r(0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.000
									       0.005 0.010 0.006 0.038 0.192 0.192 0.038 0.006 0.010 0.005
									       0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.000)))
	    (snd-display "filter-channel lp: ~A ~A ~A" (channel->float-vector 0 10) (channel->float-vector 10 10) (channel->float-vector 20 10)))
	(undo)
	(filter-channel '(0 1 1 0) 10 0 20 #f #f #f #f)
	(if (not (mus-arrays-equal? (channel->float-vector 0 30) #r(0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.000
									       0.005 0.010 0.006 0.038 0.192 0.192 0.038 0.006 0.010 0.005
									       0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.000)))
	    (snd-display "filter-channel lp no trunc: ~A ~A ~A" (channel->float-vector 0 10) (channel->float-vector 10 10) (channel->float-vector 20 10)))
	(undo)
	(close-sound)
	
	(let ((ind (new-sound "tmp.snd" 2 22050 mus-ldouble mus-next #f 100)))
	  (set! (sample 10) 0.5)
	  (set! (sample 5 ind 1) -0.5)
	  (set! (sync ind) 1)
	  (filter-sound #r(1.0 0.0 1.0) 3)
	  (if (not (mus-arrays-equal? (channel->float-vector 5 10 ind 0) #r(0.0 0.0 0.0 0.0 0.0 0.500 0.0 0.500 0.0 0.000)))
	      (snd-display "(2) filter-sound 1 0 1: ~A" (channel->float-vector 5 10)))
	  (if (not (mus-arrays-equal? (channel->float-vector 0 10 ind 1) #r(0.0 0.0 0.0 0.0 0.0 -0.500 0.0 -0.500 0.0 0.000)))
	      (snd-display "(2) filter-sound 1 0 2: ~A" (channel->float-vector 0 10 ind 1)))
	  (undo)
	  (filter-sound '(0 1 1 1) 1000)
	  (if (not (mus-arrays-equal? (channel->float-vector 5 10 ind 0) #r(0.0 0.0 0.0 0.0 0.0 0.500 0.0 0.0 0.0 0.000)))
	      (snd-display "(2) filter-sound 1 (1000): ~A" (channel->float-vector 5 10)))
	  (if (not (mus-arrays-equal? (channel->float-vector 0 10 ind 1) #r(0.0 0.0 0.0 0.0 0.0 -0.500 0.0 0.0 0.0 0.000)))
	      (snd-display "(2) filter-sound 2 (1000): ~A" (channel->float-vector 0 10)))
	  (undo)
	  (make-selection 0 20)
	  (filter-selection #r(1.0 0.0 1.0) 3)
	  (if (not (mus-arrays-equal? (channel->float-vector 5 10 ind 0) #r(0.0 0.0 0.0 0.0 0.0 0.500 0.0 0.500 0.0 0.000)))
	      (snd-display "(2) filter-selection 1 0 1: ~A" (channel->float-vector 5 10)))
	  (if (not (mus-arrays-equal? (channel->float-vector 0 10 ind 1) #r(0.0 0.0 0.0 0.0 0.0 -0.500 0.0 -0.500 0.0 0.000)))
	      (snd-display "(2) filter-selection 1 0 2: ~A" (channel->float-vector 0 10 ind 1)))
	  (undo)
	  (set! (sync ind) 0)
	  (filter-selection #r(1.0 0.0 1.0) 3)
	  (if (not (mus-arrays-equal? (channel->float-vector 5 10 ind 0) #r(0.0 0.0 0.0 0.0 0.0 0.500 0.0 0.500 0.0 0.000)))
	      (snd-display "(2) filter-selection 1 0 1 (no sync): ~A" (channel->float-vector 5 10)))
	  (if (not (mus-arrays-equal? (channel->float-vector 0 10 ind 1) #r(0.0 0.0 0.0 0.0 0.0 -0.500 0.0 -0.500 0.0 0.000)))
	      (snd-display "(2) filter-selection 1 0 2 (no sync): ~A" (channel->float-vector 0 10 ind 1)))
	  (undo 1 ind 0)
	  (undo 1 ind 1)
	  (if (not (= (edit-position ind 0) 1)) (snd-display "edpos filter-sel undo: ~A" (edit-position ind 0)))
	  (if (not (= (edit-position ind 1) 1)) (snd-display "edpos filter-sel undo 1: ~A" (edit-position ind 1)))
	  (filter-sound #r(1.0 0.0 1.0) 3)
	  (if (not (mus-arrays-equal? (channel->float-vector 5 10 ind 0) #r(0.0 0.0 0.0 0.0 0.0 0.500 0.0 0.500 0.0 0.000)))
	      (snd-display "(2) filter-sound 1 0 1 no sync: ~A" (channel->float-vector 5 10)))
	  (if (not (mus-arrays-equal? (channel->float-vector 0 10 ind 1) #r(0.0 0.0 0.0 0.0 0.0 -0.500 0.0 0.0 0.0 0.000)))
	      (snd-display "(2) filter-sound 1 0 2 no sync: ~A" (channel->float-vector 0 10 ind 1)))
	  (undo 1 ind 0)
	  (filter-channel '(0 1 1 0) 10 #f #f ind 1)
	  (if (not (mus-arrays-equal? (channel->float-vector 0 30 ind 1) #r(0.0 0.0 0.0 0.0 0.000; 0.0 0.0 0.0 0.0 0.000
										       -0.005 -0.010 -0.006 -0.038 -0.192 -0.192 -0.038 -0.006 -0.010 -0.005
										       0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.000
										       0 0 0 0 0)))
	      (snd-display "filter-channel lp: ~A ~A ~A" (channel->float-vector 0 10 ind 1) (channel->float-vector 10 10 ind 1) (channel->float-vector 20 10 ind 1)))
	  (undo 1 ind 1)
	  (close-sound ind))
	
	(let ((ind (new-sound "tmp.snd" 1 22050 mus-bshort mus-next :size 100))) ; short out needed here
	  (set! (sample 10) 0.5)
	  (set! (sample 20) -0.5)
	  (scale-to 1.0)
	  (if (fneq (sample 10) .999) (snd-display "scale-to 1.0 short (10): ~A" (sample 10)))
	  (if (fneq (sample 20) -.999) (snd-display "scale-to 1.0 short (20): ~A" (sample 10)))
	  (close-sound ind))
	(let ((ind (new-sound "tmp.snd" 1 22050 mus-byte mus-next :size 100)))
	  (set! (sample 10) 0.5)
	  (set! (sample 20) -0.5)
	  (scale-to 1.0)
	  (if (fneq (sample 10) .992) (snd-display "scale-to 1.0 byte (10): ~A" (sample 10)))
	  (if (fneq (sample 20) -.992) (snd-display "scale-to 1.0 byte (20): ~A" (sample 10)))
	  (close-sound ind))
	
	(when with-gui
	  (set! *transform-graph-type* graph-once)
	  (set! *fft-window* 6)
	  (set! *show-y-zero* #f)
	  (set! *show-transform-peaks* #f)
	  (set! *fft-log-frequency* #f)
	  (set! *fft-log-magnitude* #f)
	  (set! *with-verbose-cursor* #f)
	  (set! *show-grid* #f)
	  (set! *show-sonogram-cursor* #f)
	  (set! *with-tracking-cursor* #f)
	  (set! *show-controls* #f)
	  (set! *speed-control-tones* 12)
	  (set! *wavelet-type* 0)
	  (set! *spectrum-start* 0.0)
	  (set! *spectro-hop* 4)
	  (set! *fft-window-alpha* 0.0)
	  (set! *fft-window-beta* 0.0)
	  (set! *min-dB* -60.0)
	  (set! *reverb-control-decay* 1.0)
	  
	  (letrec ((test-sound-func-1
		    (lambda (func name ind-1 ind-2 new-val eq-func leq-func settable channel global)
		      (let* ((old-val (func))
			     (old-vals (func #t))
			     (old-default (func #f))
			     (old-1 (func ind-1))
			     (old-2 (func ind-2))
			     (caller (if channel "channel" "sound")))
			(if (not (eq-func old-val old-default))
			    (snd-display "~A sound-func: no arg: ~A, #f: ~A" name old-val old-default))
			(if (not (or (leq-func old-vals (list old-1 old-2))
				     (leq-func old-vals (list old-2 old-1))))
			    (snd-display "~A sound-func #t: ~A, sep: ~A" name old-vals (list old-1 old-2)))
			(when settable
			  (let* ((sel-snd (selected-sound))
				 (unsel-snd (if (equal? sel-snd ind-1) ind-2 ind-1)))
			    (set! (func) new-val)
			    (if (not (eq-func (func) new-val))
				(snd-display "~A set no arg: ~A ~A" name (func) new-val))
			    (if (not (eq-func (func) (func sel-snd)))
				(snd-display "~A set no arg sel: ~A ~A" name (func) (func sel-snd)))
			    (if (not (eq? (not global) (not (eq-func (func) (func unsel-snd)))))
				(snd-display "~A set no arg unsel: ~A ~A (sel: ~A)" name (func) (func unsel-snd) (func sel-snd)))
			    (if (not (or (leq-func (func #t) (list (func sel-snd) (func unsel-snd)))
					 (leq-func (func #t) (list (func unsel-snd) (func sel-snd)))))
				(snd-display "~A ~A-func #t set: ~A, sep: ~A" name caller (func #t) (list (func sel-snd) (func unsel-snd)))))
			  (set! (func) old-val)
			  (set! (func ind-1) new-val)
			  (if (not (eq-func (func ind-1) new-val))
			      (snd-display "~A set arg: ~A ~A" name (func ind-1) new-val))
			  (if (eq-func (func ind-2) new-val)
			      (snd-display "~A set arg (2): ~A ~A" name (func ind-2) new-val))
			  (if (not (or (leq-func (func #t) (list (func ind-1) (func ind-2)))
				       (leq-func (func #t) (list (func ind-2) (func ind-1)))))
			      (snd-display "~A ~A-func arg set: ~A, sep: ~A" name caller (func #t) (list (func ind-1) (func ind-2))))
			  (set! (func ind-1) old-1)
			  (set! (func #t) new-val)
			  (if (not (leq-func (func #t) (list new-val new-val)))
			      (snd-display "~A ~A-func arg set #t: ~A, sep: ~A" name caller (func #t) (list new-val new-val)))
			  (if (not (eq-func (func ind-1) new-val))
			      (snd-display "~A set arg #t: ~A ~A" name (func ind-1) new-val))
			  (if (not (eq-func (func ind-2) new-val))
			      (snd-display "~A set arg #t (2): ~A ~A" name (func ind-2) new-val))
			  (set! (func ind-1) old-1)
			  (set! (func ind-2) old-2)
			  (if (not (eq-func (func ind-1) old-1))
			      (snd-display "~A set arg #t old: ~A ~A" name (func ind-1) old-1))
			  (if (not (eq-func (func ind-2) old-2))
			      (snd-display "~A set arg #t (2): ~A ~A" name (func ind-2) old-2))))))
		   (test-sound-func (lambda (func name ind-1 ind-2 new-val eq-func leq-func settable)
				      (test-sound-func-1 func name ind-1 ind-2 new-val eq-func leq-func settable #f #f))))
	    
	    (let ((ind-1 (new-sound "test-1.snd" 1 22050 mus-lfloat mus-next "mono testing" 100))
		  (ind-2 (new-sound "test-2.snd" 2 44100 mus-bshort mus-aifc "stereo testing" 300)))
	      
	      (for-each
	       (lambda (data)
		 (apply test-sound-func data))
	       (list
		(list srate 'srate ind-1 ind-2 48000 = equal? #t)
		(list sample-type 'sample-type ind-1 ind-2 mus-byte = equal? #t)
		(list data-location 'data-location ind-1 ind-2 123 = equal? #t)
		(list data-size 'data-size ind-1 ind-2 12348 = equal? #t)
		(list framples 'framples ind-1 ind-2 12348 = equal? #t)
		(list sync 'sync ind-1 ind-2 2 = equal? #t)
		(list sample-type 'sample-type ind-1 ind-2 mus-byte = equal? #t)
		(list channels 'channels ind-1 ind-2 0 = equal? #f)
		(list chans 'chans ind-1 ind-2 0 = equal? #f)
		(list header-type 'header-type ind-1 ind-2 0 = equal? #f)
		
		(reader-cond (with-gui 
			      (list amp-control 'amp-control ind-1 ind-2 .5 very-close? feql #t)
			      (list contrast-control 'contrast-control ind-1 ind-2 .5 very-close? feql #t)
			      (list expand-control 'expand-control ind-1 ind-2 .5 very-close? ffeql #t)
			      (list speed-control 'speed-control ind-1 ind-2 .5 very-close? feql #t)
			      (list reverb-control-length 'reverb-control-length ind-1 ind-2 .5 very-close? feql #t)
			      (list reverb-control-scale 'reverb-control-scale ind-1 ind-2 .5 very-close? feql #t)
			      
			      (list contrast-control? 'contrast-control? ind-1 ind-2 #t equal? equal? #t)
			      (list expand-control? 'expand-control? ind-1 ind-2 #t equal? equal? #t)
			      (list filter-control? 'filter-control? ind-1 ind-2 #t equal? equal? #t)
			      (list reverb-control? 'reverb-control? ind-1 ind-2 #t equal? equal? #t)
			      (list read-only 'read-only ind-1 ind-2 #t equal? equal? #t)))
		
		(list file-name 'file-name ind-1 ind-2 #f string=? equal? #f)
		(list short-file-name 'short-file-name ind-1 ind-2 #f string=? equal? #f)
		(list comment 'comment ind-1 ind-2 #f string=? equal? #f)))
	      
	      (save-controls #t)
	      (restore-controls #t)
	      (reset-controls #t)
	      (close-sound #t)
	      (if (not (null? (sounds))) (snd-display "sounds after close-sound #t: ~A" (sounds)))
	      
	      ;; snd chn cases
	      (letrec ((test-channel-func-1 
			(lambda (func name ind-1 ind-2 new-val eq-func leq-func settable global)
			  (let ((old-1-0 (func ind-1 0))
				(old-2-0 (func ind-2 0))
				(old-2-1 (func ind-2 1))
				(old-1-all (func ind-1 #t))
				(old-2-all (func ind-2 #t))
				(old-all-all (func #t #t)))
			    (if (not (eq-func old-1-0 (car old-1-all))) (snd-display "~A channel-func old 1/#t: ~A ~A" name old-1-0 old-1-all))
			    (if (not (eq-func old-2-0 (car old-2-all))) (snd-display "~A channel-func old 2/#t: ~A ~A" name old-2-0 old-2-all))
			    (if (not (eq-func old-2-1 (cadr old-2-all))) (snd-display "~A channel-func old 2-2/#t: ~A ~A" name old-2-1 old-2-all))
			    (if (not (leq-func old-1-all (list old-1-0))) (snd-display "~A channel-func #t list: ~A ~A" name old-1-all old-1-0))
			    (if (not (leq-func old-2-all (list old-2-0 old-2-1))) 
				(snd-display "~A channel-func (2) #t list: ~A ~A ~A" name old-2-all old-2-0 old-2-1))
			    (if (not (and (or (leq-func (car old-all-all) old-1-all)
					      (leq-func (car old-all-all) old-2-all))
					  (or (leq-func (cadr old-all-all) old-1-all)
					      (leq-func (cadr old-all-all) old-2-all))))
				(snd-display "~A channel-func #t #t: ~A ~A ~A" name old-all-all old-1-all old-2-all))
			    (when settable
			      (set! (func ind-1 0) new-val)
			      (if (not (eq-func (func ind-1 0) new-val)) (snd-display "~A set channel-func: ~A ~A" name (func ind-1 0) new-val))
			      (if (eq-func (func ind-2 0) new-val) (snd-display "~A set 2 channel-func: ~A ~A" name (func ind-2 0) new-val))
			      (set! (func ind-1 0) old-1-0)
			      (set! (func ind-2 1) new-val)
			      (if (eq-func (func ind-1 0) new-val) (snd-display "~A set (2) channel-func: ~A ~A" name (func ind-1 0) new-val))
			      (if (not (eq-func (func ind-2 1) new-val)) (snd-display "~A set (2) 2 channel-func: ~A ~A" name (func ind-2 0) new-val))
			      (set! (func ind-2 0) new-val)
			      (set! (func ind-2 #t) old-2-0)
			      (if (not (eq-func (func ind-2 0) old-2-0)) (snd-display "~A set (#t 0) 2 channel-func: ~A ~A" name (func ind-2 0) old-2-0))
			      (if (not (eq-func (func ind-2 1) old-2-0)) (snd-display "~A set (#t 1) 2 channel-func: ~A ~A" name (func ind-2 1) old-2-0))
			      (set! (func ind-2 0) old-2-0)
			      (set! (func ind-2 1) old-2-1)))))
		       (test-channel-func 
			(lambda (func name ind-1 ind-2 new-val eq-func leq-func settable global)
			  (test-sound-func-1 func name ind-1 ind-2 new-val eq-func leq-func settable #t global)
			  (test-channel-func-1 func name ind-1 ind-2 new-val eq-func leq-func settable global))))
		
		(let ((ind-1 (new-sound "test-1.snd" 1 22050 mus-ldouble mus-next "mono testing" 100))
		      (ind-2 (new-sound "test-2.snd" 2 44100 mus-bshort mus-aifc "stereo testing" 300)))
		  (set! (sample 1 ind-1 0) .1)
		  (set! (sample 2 ind-2 0) .2)
		  (set! (sample 3 ind-2 1) .3)
		  (for-each
		   (lambda (data)
		     (apply test-channel-func data))
		   (list
		    (list min-dB 'min-dB ind-1 ind-2 -100.0 very-close? feql #t #t)
		    
		    (list x-position-slider 'x-position-slider ind-1 ind-2 .1 very-close? feql #t #f)
		    ;; (list y-position-slider 'y-position-slider ind-1 ind-2 0.5 very-close? feql #t #f)
		    (list x-zoom-slider 'x-zoom-slider ind-1 ind-2 0.2 very-close? feql #t #f)
		    (list y-zoom-slider 'y-zoom-slider ind-1 ind-2 0.2 very-close? feql #t #f)
		    (list fft-window-alpha 'fft-window-alpha ind-1 ind-2 0.5 (lambda (a b) (< (abs (- a b)) .02)) feql #t #t)
		    (list fft-window-beta 'fft-window-beta ind-1 ind-2 0.5 (lambda (a b) (< (abs (- a b)) .02)) feql #t #t)
		    (list spectrum-end 'spectrum-end ind-1 ind-2 0.2 very-close? feql #t #t)
		    (list spectrum-start 'spectrum-start ind-1 ind-2 0.1 very-close? feql #t #t)
		    (list spectro-x-angle 'spectro-x-angle ind-1 ind-2 10.0 very-close? feql #t #t)
		    (list spectro-x-scale 'spectro-x-scale ind-1 ind-2 0.2 very-close? feql #t #t)
		    (list spectro-y-angle 'spectro-y-angle ind-1 ind-2 10.0 very-close? feql #t #t)
		    (list spectro-y-scale 'spectro-y-scale ind-1 ind-2 0.1 very-close? feql #t #t)
		    (list spectro-z-angle 'spectro-z-angle ind-1 ind-2 10.0 very-close? feql #t #t)
		    (list spectro-z-scale 'spectro-z-scale ind-1 ind-2 0.3 very-close? feql #t #t)
		    (list beats-per-minute 'beats-per-minute ind-1 ind-2 100.0 very-close? feql #t #t)
		    
		    (list dot-size 'dot-size ind-1 ind-2 10 = equal? #t #t)
		    (list x-axis-style 'x-axis-style ind-1 ind-2 1 = equal? #t #t)
		    ;; (list left-sample 'left-sample ind-1 ind-2 1 (lambda (a b) (< (abs (- a b)) 2)) equal? #t #f)
		    ;; (list right-sample 'right-sample ind-1 ind-2 50 (lambda (a b) (< (abs (- a b)) 2)) equal? #t #f)
		    (list show-axes 'show-axes ind-1 ind-2 2 = equal? #t #t)
		    
		    (list transform-graph? 'transform-graph? ind-1 ind-2 #t equal? equal? #t #f)
		    (list time-graph? 'time-graph? ind-1 ind-2 #f equal? equal? #t #f)
		    (list lisp-graph? 'lisp-graph? ind-1 ind-2 #t equal? equal? #t #f)
		    (list squelch-update 'squelch-update ind-1 ind-2 #t equal? equal? #t #f)
		    (list show-y-zero 'show-y-zero ind-1 ind-2 #t equal? equal? #t #t)
		    (list show-grid 'show-grid ind-1 ind-2 #t equal? equal? #t #t)
		    (list grid-density 'grid-density ind-1 ind-2 0.5 very-close? feql #t #t)
		    (list show-sonogram-cursor 'show-sonogram-cursor ind-1 ind-2 #t equal? equal? #t #t)
		    (list show-marks 'show-marks ind-1 ind-2 #f equal? equal? #t #t)
		    (list show-transform-peaks 'show-transform-peaks ind-1 ind-2 #t equal? equal? #t #t)
		    (list fft-log-frequency 'fft-log-frequency ind-1 ind-2 #t equal? equal? #t #t)
		    (list fft-log-magnitude 'fft-log-magnitude ind-1 ind-2 #t equal? equal? #t #t)
		    (list show-mix-waveforms 'show-mix-waveforms ind-1 ind-2 #f equal? equal? #t #t)
		    (list with-verbose-cursor 'with-verbose-cursor ind-1 ind-2 #t equal? equal? #t #t)
		    (list max-transform-peaks 'max-transform-peaks ind-1 ind-2 10 = equal? #t #t)
		    (list wavelet-type 'wavelet-type ind-1 ind-2 1 = equal? #t #t)
		    (list transform-size 'transform-size ind-1 ind-2 64 = equal? #t #t)
		    (list transform-graph-type 'transform-graph-type ind-1 ind-2 1 = equal? #t #t)
		    (list transform-normalization 'transform-normalization ind-1 ind-2 2 = equal? #t #t)
		    
		    (list time-graph-type 'time-graph-type ind-1 ind-2 graph-as-wavogram = equal? #t #t)
		    (list wavo-hop 'wavo-hop ind-1 ind-2 10 = equal? #t #t)
		    (list wavo-trace 'wavo-trace ind-1 ind-2 10 = equal? #t #t)
		    (list spectro-hop 'spectro-hop ind-1 ind-2 10 = equal? #t #t)
		    (list cursor 'cursor ind-1 ind-2 50 = equal? #t #f)
		    (list cursor-style 'cursor-style ind-1 ind-2 1 = equal? #t #t)
		    (list cursor-size 'cursor-size ind-1 ind-2 10 = equal? #t #t)
		    
		    (list framples 'framples ind-1 ind-2 50 = equal? #t #f)
		    (list zero-pad 'zero-pad ind-1 ind-2 1 = equal? #t #t)
		    (list fft-window 'fft-window ind-1 ind-2 1 = equal? #t #t)
					;               (list transform-type 'transform-type ind-1 ind-2 1 equal? equal? #t #t)
		    )))
		(update-time-graph #t #t)
		(update-transform-graph #t #t)
		(update-lisp-graph #t #t)
		
		(close-sound #f)
		(close-sound #f)
		(if (not (null? (sounds))) (snd-display "sounds after close-sound #t: ~A" (sounds)))))
	    
	    (let ((test-sound-func-2
		   (lambda (func name ind-1 ind-2 new-val eq-func leq-func)
		     (let* ((old-global-val (func))
			    (old-vals (func #t))
			    (old-1 (func ind-1))
			    (old-2 (func ind-2)))
		       (let* ((sel-snd (selected-sound))
			      (unsel-snd (if (equal? sel-snd ind-1) ind-2 ind-1)))
			 (if (not (or (leq-func old-vals (list old-1 old-2))
				      (leq-func old-vals (list old-2 old-1))))
			     (snd-display "~A sound-func #t: ~A, sep: ~A" name old-vals (list old-1 old-2)))
			 (set! (func) new-val)
			 (if (not (eq-func (func) new-val))
			     (snd-display "~A global set no arg: ~A ~A" name (func) new-val))
			 (if (not (eq-func (func) (func sel-snd)))
			     (snd-display "~A global set no arg sel: ~A ~A" name (func) (func sel-snd)))
			 (if (not (eq-func (func) (func unsel-snd)))
			     (snd-display "~A set global no arg unsel: ~A ~A (sel: ~A)" name (func) (func unsel-snd) (func sel-snd)))
			 (if (not (or (leq-func (func #t) (list (func sel-snd) (func unsel-snd)))
				      (leq-func (func #t) (list (func unsel-snd) (func sel-snd)))))
			     (snd-display "~A func #t set: ~A, sep: ~A" name (func #t) (list (func sel-snd) (func unsel-snd)))))
		       
		       (set! (func) old-global-val)
		       (set! (func ind-1) new-val)
		       (if (not (eq-func (func ind-1) new-val))
			   (snd-display "~A set arg: ~A ~A" name (func ind-1) new-val))
		       (if (eq-func (func ind-2) new-val)
			   (snd-display "~A set arg (2): ~A ~A" name (func ind-2) new-val))
		       (if (not (or (leq-func (func #t) (list (func ind-1) (func ind-2)))
				    (leq-func (func #t) (list (func ind-2) (func ind-1)))))
			   (snd-display "~A func arg set: ~A, sep: ~A" name (func #t) (list (func ind-1) (func ind-2))))
		       (set! (func ind-1) old-1)
		       (set! (func #t) new-val)
		       (if (not (leq-func (func #t) (list new-val new-val)))
			   (snd-display "~A func arg set #t: ~A, sep: ~A" name (func #t) (list new-val new-val)))
		       (if (not (eq-func (func ind-1) new-val))
			   (snd-display "~A set arg #t: ~A ~A" name (func ind-1) new-val))
		       (if (not (eq-func (func ind-2) new-val))
			   (snd-display "~A set arg #t (2): ~A ~A" name (func ind-2) new-val))
		       (if (eq-func (func) new-val)
			   (snd-display "~A overwrote global: ~A ~A" name (func) new-val))
		       (set! (func ind-1) old-1)
		       (set! (func ind-2) old-2)
		       (if (not (eq-func (func ind-1) old-1))
			   (snd-display "~A set arg #t old: ~A ~A" name (func ind-1) old-1))
		       (if (not (eq-func (func ind-2) old-2))
			   (snd-display "~A set arg #t (2): ~A ~A" name (func ind-2) old-2))))))
	      
	      (let ((ind-1 (new-sound "test-1.snd" 1 22050 mus-ldouble mus-next "mono testing" 100))
		    (ind-2 (new-sound "test-2.snd" 2 44100 mus-bshort mus-aifc "stereo testing" 300)))
		
		(for-each
		 (lambda (data)
		   (apply test-sound-func-2 data))
		 (list
		  (list filter-control-in-dB 'filter-control-in-dB ind-1 ind-2 #t eq? equal?)
		  (list filter-control-in-hz 'filter-control-in-hz ind-1 ind-2 #t eq? equal?)
		  ;(list show-controls 'show-controls ind-1 ind-2 #t eq? equal?)
		  
		  (list speed-control-tones 'speed-control-tones ind-1 ind-2 14 = equal?)
		  (list speed-control-style 'speed-control-style ind-1 ind-2 speed-control-as-semitone = equal?)
		  (list filter-control-order 'filter-control-order ind-1 ind-2 14 = equal?)
		  
		  (list expand-control-length 'expand-control-length ind-1 ind-2 .25 very-close? feql)
		  (list expand-control-ramp 'expand-control-ramp ind-1 ind-2 .25 very-close? feql)
		  (list expand-control-hop 'expand-control-hop ind-1 ind-2 .25 very-close? feql)
		  (list expand-control-jitter 'expand-control-jitter ind-1 ind-2 .25 very-close? feql)
		  (list contrast-control-amp 'contrast-control-amp ind-1 ind-2 .25 very-close? feql)
		  (list reverb-control-feedback 'reverb-control-feedback ind-1 ind-2 .25 very-close? feql)
		  (list reverb-control-lowpass 'reverb-control-lowpass ind-1 ind-2 .25 very-close? feql)
		  (list reverb-control-decay 'reverb-control-decay ind-1 ind-2 .25 very-close? feql)
		  
		  (list amp-control-bounds 'amp-control-bounds ind-1 ind-2 (list 0.0 2.0) feql 
			(lambda (a b) (and (feql (car a) (car b)) (feql (cadr a) (cadr b)))))
		  (list contrast-control-bounds 'contrast-control-bounds ind-1 ind-2 (list 0.0 2.0) feql
			(lambda (a b) (and (feql (car a) (car b)) (feql (cadr a) (cadr b)))))
		  (list expand-control-bounds 'expand-control-bounds ind-1 ind-2 (list 0.1 2.0) feql
			(lambda (a b) (and (feql (car a) (car b)) (feql (cadr a) (cadr b)))))
		  (list speed-control-bounds 'speed-control-bounds ind-1 ind-2 (list 0.1 2.0) feql
			(lambda (a b) (and (feql (car a) (car b)) (feql (cadr a) (cadr b)))))
		  (list reverb-control-length-bounds 'reverb-control-length-bounds ind-1 ind-2 (list 0.0 2.0) feql
			(lambda (a b) (and (feql (car a) (car b)) (feql (cadr a) (cadr b)))))
		  (list reverb-control-scale-bounds 'reverb-control-scale-bounds ind-1 ind-2 (list 0.0 2.0) feql
			(lambda (a b) (and (feql (car a) (car b)) (feql (cadr a) (cadr b)))))))
		(close-sound ind-1)
		(close-sound ind-2)))))
	
	(set! *remember-sound-state* #t)
	(let ((ind (open-sound "oboe.snd")))
	  (set! (transform-graph? ind 0) #t)
	  (set! (show-transform-peaks ind 0) #t)
	  (set! (show-y-zero ind 0) #t)
	  (close-sound ind))
	(let ((ind (open-sound "oboe.snd")))
	  (if (not (and (transform-graph? ind 0)
			(show-transform-peaks ind 0)
			(show-y-zero ind 0)))
	      (snd-display "remember-sound-state: ~A ~A ~A" (transform-graph? ind 0) (show-transform-peaks ind 0) (show-y-zero ind 0)))
	  (close-sound ind))
	(reset-all-hooks)
	(set! *remember-sound-state* #f)
	(if (file-exists? "remembered-oboe.snd.scm")
	    (delete-file "remembered-oboe.snd.scm"))
	
	(map-sound-files (lambda (n) (if (> (mus-sound-duration n) 1000.0) (snd-display "~A is pretty long! ~A" n (mus-sound-duration n)))))
	(if (string? sf-dir)
	    (map-sound-files 
	     (lambda (n)
	       (catch #t
		 (lambda ()
		   (if (> (mus-sound-duration (string-append sf-dir n)) 1000.0) 
		       (snd-display "~A is pretty long! ~A" 
				    n 
				    (mus-sound-duration (string-append sf-dir n)))))
		 (lambda args #f))
	       (mus-sound-forget (string-append sf-dir n)))
	     sf-dir))
	
	(let ((snd (new-sound "test.snd")))
	  (pad-channel 0 20)
	  (map-channel (lambda (y) 1.0))
	  (env-channel-with-base '(0 0 1 1) 1.0)
	  (let ((data (channel->float-vector 0 20)))
	    (if (not (mus-arrays-equal? data #r(0.0 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95)))
		(snd-display "env-chan 1.0: ~A" data)))
	  (undo)
	  (env-channel-with-base '(0 0 1 1 2 1 3 0) 0.0)
	  (let ((data (channel->float-vector 0 20)))
	    (if (not (mus-arrays-equal? data #r(0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0)))
		(snd-display "env-chan 0.0: ~A" data)))
	  (undo)
	  (env-channel-with-base '(0 0 1 1) 100.0)
	  (let ((data (channel->float-vector 0 20)))
	    (if (not (mus-arrays-equal? data #r(0.0 0.003 0.006 0.010 0.015 0.022 0.030 0.041 0.054 0.070 
							   0.091 0.117 0.150 0.191 0.244 0.309 0.392 0.496 0.627 0.792)))
		(snd-display "env-chan 100.0: ~A" data)))
	  (undo)
	  (env-channel-with-base '(0 0 1 1) 0.01)
	  (let ((data (channel->float-vector 0 20)))
	    (if (not (mus-arrays-equal? data #r(0.0 0.208 0.373 0.504 0.608 0.691 0.756 0.809 0.850 0.883 
							   0.909 0.930 0.946 0.959 0.970 0.978 0.985 0.990 0.994 0.997)))
		(snd-display "env-chan 0.01: ~A" data)))
	  (undo)
	  
	  (env-channel-with-base '(0 0 1 1) 1.0 5 10)
	  (let ((data (channel->float-vector 0 20)))
	    (if (not (mus-arrays-equal? data #r(1.0 1.0 1.0 1.0 1.0 0.0 0.111 0.222 0.333 0.444 0.556 0.667 0.778 0.889 1.0 1.0 1.0 1.0 1.0 1.0)))
		(snd-display "env-chan 1.0 seg: ~A" data)))
	  (undo)
	  (env-channel-with-base '(0 0 1 1 2 1 3 0) 0.0 5 10)
	  (let ((data (channel->float-vector 0 20)))
	    (if (not (mus-arrays-equal? data #r(1.0 1.0 1.0 1.0 1.0 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0)))
		(snd-display "env-chan 0.0 seg: ~A" data)))
	  (undo)
	  (env-channel-with-base '(0 0 1 1) 100.0 5 10)
	  (let ((data (channel->float-vector 0 20)))
	    (if (not (mus-arrays-equal? data #r(1.0 1.0 1.0 1.0 1.0 0.0 0.007 0.018 0.037 0.068 0.120 0.208 0.353 0.595 1.0 1.0 1.0 1.0 1.0 1.0)))
		(snd-display "env-chan 100.0 seg: ~A" data)))
	  (undo)
	  (env-channel-with-base '(0 0 1 1) 0.01 5 10)
	  (let ((data (channel->float-vector 0 20)))
	    (if (not (mus-arrays-equal? data #r(1.0 1.0 1.0 1.0 1.0 0.0 0.405 0.647 0.792 0.880 0.932 0.963 0.982 0.993 1.0 1.0 1.0 1.0 1.0 1.0)))
		(snd-display "env-chan 0.01 seg: ~A" data)))
	  (undo)
	  (close-sound snd))
	
	(let ((ind2 (open-sound "oboe.snd")))
	  (let ((ind1 (open-sound "now.snd")))
	    (let ((val (channel-mean ind1 0)))
	      (if (fneq val 5.02560673308833e-5) (snd-display "channel-mean: ~A" val)))
	    (let ((val (channel-total-energy ind1 0)))
	      (if (fneq val 50.7153476262465) (snd-display "channel-total-energy: ~A" val)))
	    (let ((val (channel-average-power ind1 0)))
	      (if (fneq val 0.00155078578803922) (snd-display "channel-average-power: ~A" val)))
	    (let ((val (channel-rms ind1 0)))
	      (if (fneq val 0.039380017623653) (snd-display "channel-rms: ~A" val)))
	    (let ((val (channel-norm ind1 0)))
	      (if (fneq val 7.12147088923675) (snd-display "channel-norm: ~A" val)))
	    (let ((val (channel-variance ind1 0)))
	      (if (fneq val 50.7153476237207) (snd-display "channel-variance: ~A" val)))
	    (let ((val (channel-lp 2 ind1 0)))
	      (if (fneq val 7.12147088923675) (snd-display "channel-lp 2: ~A" val)))
	    (let ((val (channel-lp 1 ind1 0)))
	      (if (fneq val 775.966033935547) (snd-display "channel-lp 1: ~A" val)))
	    (let ((val (channel2-inner-product ind1 0 ind2 0)))
	      (if (fneq val 1.52892031334341) (snd-display "channel2-inner-product: ~A" val)))
	    (let ((val (channel2-angle ind1 0 ind2 0)))
	      (if (fneq val 1.55485084385627) (snd-display "channel2-angle: ~A" val)))
	    (let ((val (channel2-orthogonal? ind1 0 ind2 0)))
	      (if val (snd-display "channel2-orthogonal: ~A" val)))
	    (let ((val (channel2-coefficient-of-projection ind1 0 ind2 0)))
	      (if (fneq val 0.0301470932351876) (snd-display "channel2-coefficient-of-projection: ~A" val)))
	    (close-sound ind1))
	  (let ((ind1 (open-sound "oboe.snd")))
	    (scale-by .99 ind1 0)
	    (let ((dist (channel-distance ind1 0 ind2 0)))
	      (if (fneq dist .1346) (snd-display "channel-distance: ~A" dist)))
	    (close-sound ind1))
	  (close-sound ind2))
	
	(let ((loboe  (string-append (getcwd) "/oboe.snd"))
	      (ltest  (string-append (getcwd) "/test.snd")))
	  (copy-file loboe ltest)
	  (mus-sound-forget ltest)
	  (let ((ind (open-sound ltest)))
	    (let ((mx (maxamp ind 0))
		  (chns (chans ind))
		  (sr (srate ind))
		  (fr (framples ind 0)))
	      (if (not (and (= (chans ind) (mus-sound-chans loboe))
			    (= (srate ind) (mus-sound-srate loboe))
			    (= (framples ind) (mus-sound-framples loboe))))
		  (snd-display "copy oboe -> test seems to have failed? ~A ~A ~A"
			       (chans ind) (srate ind) (framples ind))
		  (with-local-hook
		   update-hook
		   (list (lambda (orig-ind)
			   (lambda (new-ind)
			     (set! ind new-ind))))
		   (lambda ()
		     (do ((i 0 (+ i 1)))
			 ((= i 10))
		       (let ((v (channel->float-vector)))
			 (if (not (float-vector? v))
			     (snd-display "channel->float-vector of oboe copy is null??")
			     (array->file ltest v fr sr chns)))
		       (update-sound ind)
		       (let ((mx1 (maxamp ind 0)))
			 (if (fneq mx mx1)
			     (snd-display "update-sound looped maxamp: ~A ~A ~A ~A ~A (~A)" i ind (framples ind) mx1 mx (/ mx1 mx))))
		       (if (not (= (chans ind) chns)) (snd-display "update-sound looped chans: ~A ~A" chns (chans ind)))
		       (if (not (= (srate ind) sr)) (snd-display "update-sound looped srate: ~A ~A" sr (srate ind)))
		       (if (not (= (framples ind) fr)) (snd-display "update-sound looped framples: ~A ~A" fr (framples ind 0))))
		     (let ((old-ind (open-sound "oboe.snd")))
		       (let ((mxdiff (float-vector-peak (float-vector-subtract! (channel->float-vector 0 #f ind 0 0) (channel->float-vector 0 #f old-ind 0)))))
			 (if (fneq mxdiff 0.0) 
			     (snd-display "update-sound looped overall max diff: ~A, sounds: ~A, ind: ~A, old-ind: ~A, rd: ~A" 
					  mxdiff (sounds) ind old-ind home)))
		       (close-sound old-ind)))))
	      (close-sound ind))))
	
	(if (file-exists? "test.snd") (delete-file "test.snd"))
	(let ((ind (open-sound "oboe.snd")))
	  (let ((data (channel->float-vector))
		(len (framples ind)))
	    (do ((i 0 (+ i 1)))
		((= i 5))
	      (array->file "test.snd" data len 22050 1)
	      (file->array "test.snd" 0 0 len data)
	      (let ((d2 (samples 0 len ind 0)))
		(float-vector-subtract! d2 data)
		(let ((diff (float-vector-peak d2)))
		  (if (fneq diff 0.0) (snd-display "arr->file->array overall max diff: ~A" diff))))))
	  
	  ;; now clear sono bins if possible 
	  (set! *colormap-size* 16)
	  (set! (transform-size ind 0) 8)
	  (set! (transform-graph-type ind 0) graph-as-sonogram)
	  (set! (transform-graph? ind 0) #t)
	  (update-transform-graph)
	  (set! (x-bounds) (list 0.0 .04))
	  (update-time-graph)
	  (update-transform-graph)
	  (set! *zoom-focus-style* (lambda (s c z x0 x1 range)
				     0))
	  (if (not (procedure? *zoom-focus-style*))
	      (snd-display "zoom-focus-style as func: ~A" *zoom-focus-style*))
	  (set! *zoom-focus-style* zoom-focus-right)
	  (if (not (= *zoom-focus-style* zoom-focus-right))
	      (snd-display "unset zoom-focus-style as func: ~A" *zoom-focus-style*))
	  (close-sound ind))
	
	(if (file-exists? "test.snd") (delete-file "test.snd"))
	(if (file-exists? "fmv.snd") (delete-file "fmv.snd"))
	(mus-sound-forget "fmv.snd")
	(mus-sound-forget "test.snd")
	(let ((rdin #f)
	      (rdout #f)
	      (len (mus-sound-framples "oboe.snd"))
	      (types (list mus-riff mus-aifc mus-next mus-nist mus-ircam))
	      (forms (list mus-lshort mus-bshort mus-b24int mus-l24int mus-bint)))
	  (system "cp oboe.snd fmv.snd")
	  (do ((i 0 (+ i 1)))
	      ((= i 5))
	    (set! rdin (make-readin :file "fmv.snd"))
	    (set! rdout (make-sample->file "test.snd" 1 (forms i) (types i)))
	    (do ((k 0 (+ k 1)))
		((= k len))
	      (sample->file rdout k 0 (readin rdin)))
	    (mus-close rdout)
	    (mus-close rdin)
	    (system "mv test.snd fmv.snd")
	    (mus-sound-forget "test.snd")
	    (mus-sound-forget "fmv.snd"))
	  (let ((diff 0.0) (ctr 0)
		(ind1 (open-sound "oboe.snd"))
		(ind2 (make-file->sample "fmv.snd")))
	    (scan-channel (lambda (y)
			    (set! diff (max diff (abs (- y (file->sample ind2 ctr 0)))))
			    (set! ctr (+ ctr 1))
			    ;; if this happens it is almost certainly a problem with mus-sound-forget above
			    #f))
	    (if (fneq diff 0.0) (snd-display "file->sample->file overall max diff: ~A" diff))
	    (close-sound ind1)))
	
	(let ((ind (open-sound "1a.snd"))
	      (mx (maxamp)))
	  ;; jokes from extsnd.html (make sure they run)
	  (for-each
	   (lambda (name-and-func)
	     (let ((name (car name-and-func)))
	       ((cadr name-and-func))
	       (if (and (fneq (/ (maxamp) mx) 2.0)
			(not (eq? name 'set-samples))
			(not (eq? name 'coroutines)))
		   (snd-display "silly scalers: ~A ~A" name (/ (maxamp) mx)))
	       (revert-sound)))
	   (list
	    (list 'scale-by (lambda () (scale-by 2.0)))
	    (list 'scale-channel (lambda () (scale-channel 2.0)))
	    (list 'map-channel (lambda () (map-channel (lambda (val) (* val 2.0)))))
	    (list 'set-max (lambda () (set! (maxamp) (* 2 (maxamp)))))
	    (list 'env-sound (lambda () (env-sound '(0 2 1 2))))
	    (list 'env-channel (lambda () (env-channel (make-env '(0 1 1 1) :scaler 2.0 :length (framples)))))
	    (list 'clm-channel (lambda () (clm-channel (make-one-zero :a0 2.0 :a1 0.0))))
	    (list 'filter-channel (lambda () (filter-channel #r(2.0) 1)))
	    (list 'float-vector->channel (lambda () (float-vector->channel (float-vector-scale! (channel->float-vector) 2.0) 0)))
	    (list 'mix-selection (lambda () (select-all) (mix-selection 0)))
	    (list 'scale-selection (lambda () (select-all) (scale-selection-by 2.0)))
	    (list 'mix (lambda () (save-sound-as "temp.snd") (mix "temp.snd" 0) (delete-file "temp.snd")))
	    (list 'vector2 (lambda ()
			     (let ((sd (subvector (channel->float-vector) (list 1 (framples)))))
			       (float-vector-scale! (sd 0) 2.0)
			       (float-vector->channel (sd 0)))))
	    (list 'convolve (lambda () 
			      (let ((flt (make-float-vector 8))
				    (sf (make-sampler 0)))
				(set! (flt 0) 2.0)
				(let ((cnv (make-convolve :filter flt :input (lambda (dir) (read-sample sf)))))
				  (map-channel
				   (lambda (val) (convolve cnv)))))))
	    (list 'fft (lambda ()
			 (let* ((len (framples))
				(fsize (expt 2 (ceiling (log len 2))))
				(rl (channel->float-vector 0 fsize)))
			   (do ((im (make-float-vector fsize))
				(i 0 (+ i 1))) 
			       ((= i 4)) 
			     (mus-fft rl im fsize))
			   (float-vector->channel (float-vector-scale! rl (/ 2.0 (* fsize fsize))) 0 len))))
	    (list 'set-samples (lambda () ; too slow for some reason, so cut it short at 100
				 (set! (squelch-update) #t)
				 (do ((i 0 (+ i 1)))
				     ((= i 100))
				   (set! (sample i) (* 2 (sample i))))
				 (set! (squelch-update) #f)))
	    (list 'coroutines (lambda ()
				(set! (squelch-update) #t)
				(let ((make-scaler 
				       (lambda (start end)
					 (letrec ((ctr start)
						  (us (lambda (them)
							(set! (sample ctr) (* 2.0 (sample ctr)))
							(set! ctr (+ ctr 2))
							(if (<= ctr end)
							    (them us)))))
					   us))))
				  ((make-scaler 0 100)
				   (make-scaler 1 100)))
				(set! (squelch-update) #f)))))
	  (close-sound ind))
	
	(let ((data1 (file->floats "1a.snd"))
	      (data2 (file->floats "2a.snd")))
	  (let ((ind1 (open-sound "1a.snd")))
	    (if (not (equal? data1 (channel->float-vector 0 #f ind1 0)))
		(snd-display "file->floats 1a.snd")))
	  (let ((ind2 (open-sound "2a.snd")))
	    (if (not (equal? data2 (channel->float-vector 0 #f ind2 0)))
		(snd-display "file->floats 2a.snd")))
	  (floats->file data1 "tmp.snd")
	  (let ((ind3 (open-sound "tmp.snd")))
	    (if (not (equal? data1 (channel->float-vector 0 #f ind3 0)))
		(snd-display "floats->file 1a"))
	    (close-sound ind3))
	  (mus-sound-forget "tmp.snd")
	  (floats->file data2 "tmp.snd" 44100 "this is a comment"))
	(let ((ind3 (open-sound "tmp.snd")))
	  (if (not (= (srate ind3) 44100))
	      (snd-display "floats->file srate: ~A" (srate ind3)))
	  (close-sound ind3))
	(mus-sound-forget "tmp.snd")
	(let ((tag (catch #t (lambda () (floats->file 32 "tmp.snd")) (lambda args (car args)))))
	  (if (not (eq? tag 'wrong-type-arg)) (snd-display "floats->file bad arg: ~A" tag)))
	
	(for-each close-sound (sounds))
	
	(let ((ind (new-sound "test.snd" 1 22050 mus-ldouble mus-next "insert-* tests" 10)))
	  (map-channel (lambda (y) 1.0) 0 10 ind 0)
	  (insert-float-vector (make-float-vector 5 .1) 2)
	  (if (not (= (framples ind) 15)) (snd-display "insert-float-vector len: ~A" (framples ind)))
	  (let ((vals (channel->float-vector 0 #f ind 0)))
	    (if (not (mus-arrays-equal? vals #r(1 1 .1 .1 .1 .1 .1 1 1 1 1 1 1 1 1)))
		(snd-display "insert-float-vector vals: ~A" vals))) 
	  
	  (let ((tag (catch #t (lambda () (insert-float-vector 32)) (lambda args (car args)))))
	    (if (not (eq? tag 'wrong-type-arg)) (snd-display "insert-float-vector bad arg: ~A" tag)))
	  
	  (insert-float-vector (make-float-vector 1 1.5) 0 1 ind 0)
	  (if (not (= (framples ind) 16)) (snd-display "insert-float-vector 1 len: ~A" (framples ind)))
	  (let ((vals (channel->float-vector 0 #f ind 0)))
	    (if (not (mus-arrays-equal? vals #r(1.5 1 1 .1 .1 .1 .1 .1 1 1 1 1 1 1 1 1)))
		(snd-display "insert-float-vector 1 vals: ~A" vals)))
	  (close-sound ind))
	
	(let ((ind (new-sound "test.snd" 4 22050 mus-ldouble mus-next "insert-* tests" 5)))
	  (map-channel (lambda (y) 0.4) 0 5 ind 0)
	  (map-channel (lambda (y) 0.5) 0 5 ind 1)
	  (map-channel (lambda (y) 0.6) 0 5 ind 2)
	  (map-channel (lambda (y) 0.7) 0 5 ind 3)
	  
	  (insert-float-vector (make-float-vector 20 .1) 2 2 ind 2)
	  (if (not (= (framples ind 0) 5)) (snd-display "4chn insert-float-vector (0) len: ~A" (framples ind 0)))
	  (if (not (= (framples ind 2) 7)) (snd-display "4chn insert-float-vector (2) len: ~A" (framples ind 2)))
	  (if (not (mus-arrays-equal? (channel->float-vector 0 7 ind 0) #r(.4 .4 .4 .4 .4 0 0)))
	      (snd-display "4chn insert-float-vector 0: ~A" (channel->float-vector 0 7 ind 0)))
	  (if (not (mus-arrays-equal? (channel->float-vector 0 7 ind 1) #r(.5 .5 .5 .5 .5 0 0)))
	      (snd-display "4chn insert-float-vector 1: ~A" (channel->float-vector 0 7 ind 1)))
	  (if (not (mus-arrays-equal? (channel->float-vector 0 7 ind 2) #r(.6 .6 .1 .1 .6 .6 .6)))
	      (snd-display "4chn insert-float-vector 2: ~A" (channel->float-vector 0 7 ind 2)))
	  (if (not (mus-arrays-equal? (channel->float-vector 0 7 ind 3) #r(.7 .7 .7 .7 .7 0 0)))
	      (snd-display "4chn insert-float-vector 3: ~A" (channel->float-vector 0 7 ind 3)))
	  
	  (insert-float-vector (make-float-vector 20 .2) 0 2 ind 0)
	  (if (not (= (framples ind 0) 7)) (snd-display "4chn insert-float-vector (0 0) len: ~A" (framples ind 0)))
	  (if (not (= (framples ind 1) 5)) (snd-display "4chn insert-float-vector (0 1) len: ~A" (framples ind 1)))
	  (if (not (= (framples ind 2) 7)) (snd-display "4chn insert-float-vector (2 2) len: ~A" (framples ind 2)))
	  (if (not (mus-arrays-equal? (channel->float-vector 0 7 ind 0) #r(.2 .2 .4 .4 .4 .4 .4)))
	      (snd-display "4chn insert-float-vector 1 0: ~A" (channel->float-vector 0 7 ind 0)))
	  (if (not (mus-arrays-equal? (channel->float-vector 0 7 ind 1) #r(.5 .5 .5 .5 .5 0 0)))
	      (snd-display "4chn insert-float-vector 1 1: ~A" (channel->float-vector 0 7 ind 1)))
	  (if (not (mus-arrays-equal? (channel->float-vector 0 7 ind 2) #r(.6 .6 .1 .1 .6 .6 .6)))
	      (snd-display "4chn insert-float-vector 1 2: ~A" (channel->float-vector 0 7 ind 2)))
	  (if (not (mus-arrays-equal? (channel->float-vector 0 7 ind 3) #r(.7 .7 .7 .7 .7 0 0)))
	      (snd-display "4chn insert-float-vector 1 3: ~A" (channel->float-vector 0 7 ind 3)))
	  
	  (revert-sound ind)
	  (map-channel (lambda (y) 0.4) 0 5 ind 0)
	  (map-channel (lambda (y) 0.5) 0 5 ind 1)
	  (map-channel (lambda (y) 0.6) 0 5 ind 2)
	  (map-channel (lambda (y) 0.7) 0 5 ind 3)
	  
	  (close-sound ind))
	
	(let ((ind (new-sound "test.snd" 4 22050 mus-ldouble mus-next "mix-* tests" 5)))
	  (map-channel (lambda (y) 0.4) 0 5 ind 0)
	  (map-channel (lambda (y) 0.5) 0 5 ind 1)
	  (map-channel (lambda (y) 0.6) 0 5 ind 2)
	  (map-channel (lambda (y) 0.7) 0 5 ind 3)
	  
	  (revert-sound ind)
	  (map-channel (lambda (y) 0.4) 0 5 ind 0)
	  (map-channel (lambda (y) 0.5) 0 5 ind 1)
	  (map-channel (lambda (y) 0.6) 0 5 ind 2)
	  (map-channel (lambda (y) 0.7) 0 5 ind 3)
	  
	  (close-sound ind))
	
	;; tests from clean.scm
	(test-remove-single-clicks)
	(test-remove-pops)
	(test-notch-hum)
	(test-remove-DC)
	
	;; check 0 cases
	(let ((ind (open-sound "oboe.snd")))
	  (scale-by 0.0)
	  (if (fneq (maxamp) 0.0) (snd-display "scale-by 0 amp: ~A" (maxamp)))
	  (scale-by 3.0)
	  (if (not (= (edit-position) 1)) (snd-display "scale-by over 0: ~A" (edit-position)))
	  (scale-to 1.0)
	  (if (not (= (edit-position) 1)) (snd-display "scale-to 1.0 over 0: ~A" (edit-position)))
	  (if (fneq (maxamp) 0.0) (snd-display "scale-to 1.0 over 0 amp: ~A" (maxamp)))  
	  (ramp-channel 0 1)
	  (if (not (= (edit-position) 1)) (snd-display "ramp over 0: ~A" (edit-position)))  
	  (env-channel '(0 0 1 1 2 0))
	  (if (not (= (edit-position) 1)) (snd-display "ramp over 0: ~A" (edit-position)))  
	  (if (not (string=? (car (edit-fragment 1)) "scale-channel 0.000 0 #f"))
	      (snd-display "ramp over 0 clobbered origin: ~A" (edit-fragment 1)))
	  (xramp-channel 0 1 32.0)
	  (if (not (= (edit-position) 1)) (snd-display "ramp over 0: ~A" (edit-position)))  
	  (env-channel-with-base '(0 0 1 1 2 0 3 1) 0.0)  
	  (if (not (= (edit-position) 1)) (snd-display "ramp over 0: ~A" (edit-position)))
	  (close-sound ind))
	
	;; snddiff.scm
	(let ((ind0 (open-sound "oboe.snd"))
	      (ind1 (open-sound "oboe.snd")))
	  (let ((diff (snddiff ind0 0 ind1 0)))
	    (if (not (eq? diff 'no-difference))
		(snd-display "snddiff of same sound: ~A" diff)))
	  (scale-channel 2.0 0 #f ind1)
	  (let ((diff (snddiff ind0 0 ind1 0)))
	    (if (or (not (eq? (car diff) 'scale))
		    (fneq (cadr diff) 2.0))
		(snd-display "snddiff scale by 2: ~A" diff)))
	  (revert-sound ind1)
	  (set! (sample 100 ind0 0) 1.0)
	  (let* ((diff (snddiff ind0 0 ind1 0))
		 (info (and (list? diff) (= (length diff) 2) (= (length (caadr diff)) 3) (caadr diff))))
	    (if (or (not (and (eq? (car diff) 'differences)
			      (pair? info)
			      (= (car info) 100)))
		    (fneq (cadr info) 1.0)
		    (fneq (caddr info) -3.051e-4))
		(snd-display "snddiff change sample 100: ~A" diff)))
	  (revert-sound ind0)
	  (pad-channel 0 100 ind0 0)
	  (let* ((diff (snddiff ind0 0 ind1 0))
		 (lag-diff (and (eq? (diff 0) 'lag)
				(= (diff 1) 100)
				(eq? (diff 2) 'no-difference))))
	    (if (or (not lag-diff)
		    (fneq (diff 3) 0.0)
		    (diff 4)
		    (diff 5)
		    (diff 6))
		(snd-display "snddiff + lag: ~A" diff)))
	  (revert-sound ind0)
	  (filter-channel #r(1.0 0.5 0.25) 3 0 #f ind1 0)
	  (let* ((diff (snddiff ind0 0 ind1 0))
		 (info (and (cadr diff) (= (length (cadr diff)) 3) (cadr diff))))
	    (if (or (not (and (list? info)
			      (pair? diff)
			      (eq? (car diff) 'filter)))
		    (fneq (caar info) 1.0)
		    (fneq (caadr info) 0.5)
		    (fneq (caaddr info) 0.25)
		    (not (and (= (cadar info) 0)
			      (= (cadadr info) 1)
			      (= (cadr (caddr info)) 1))))
		(snd-display "snddiff filter: ~A ~A" diff info)))
	  (revert-sound ind1)
	  
	  (close-sound ind0)
	  (close-sound ind1))
	
	(let ((ind (open-sound "oboe.snd")))
	  (let ((g550 (goertzel-channel 550.0))
		(g1700 (goertzel-channel 1700.0)))
	    (if (> (* 1000 g1700) g550) (snd-display "goertzel-channel oboe: ~A ~A" g550 g1700))
	    (close-sound ind)))))))


;;; ---------------- test 21: optimizer ----------------

(define (snd_test_21)

  (let ()
    (define (for-each-permutation func vals)          ; for-each-combination -- use for-each-subset below
      (define (pinner cur nvals len)
	(if (= len 1)
	    (apply func (car nvals) cur)
	    (do ((i 0 (+ i 1))                       ; I suppose a named let would be more Schemish
		 (start nvals nvals))
		((= i len))
	      (set! nvals (cdr nvals))
	      (let ((cur1 (cons (car nvals) cur)))  ; add (car nvals) to our arg list
		(set! (cdr start) (cdr nvals))      ; splice out that element and 
		(pinner cur1 (cdr start) (- len 1)) ;   pass a smaller circle on down
		(set! (cdr start) nvals)))))       ; restore original circle
      (let ((len (length vals)))
	(set-cdr! (list-tail vals (- len 1)) vals)    ; make vals into a circle
	(pinner () vals len)
	(set-cdr! (list-tail vals (- len 1)) ())))   ; restore its original shape
    
    (define (for-each-subset func args)
      (let subset ((source args)
                   (dest ())
                   (len 0))
        (if (null? source)
            (if (aritable? func len)
                (apply func dest))
            (begin
              (subset (cdr source) (cons (car source) dest) (+ len 1))
              (subset (cdr source) dest len)))))
    
    (define-macro (test tst expected)
      `(let ((val ,tst))
	 (if (not (equivalent? val ,expected))
	     (format *stderr* "~S: ~S but expected ~S~%" ',tst val ,expected))))
    
    (define (fv0)
      (do ((fv (make-float-vector 3))
	   (g (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((= i 3) fv)
	(float-vector-set! fv i (oscil g))))
    (test (fv0) #r(0.0 0.1419943179576268 0.2811111133316549))
    
    (define (fv00)
      (do ((fv (make-float-vector 3))
	   (g (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((= i 3) fv)
	(set! (fv i) (oscil g))))
    (test (fv00) #r(0.0 0.1419943179576268 0.2811111133316549))

    (define (fv01)
      (do ((fv (make-float-vector 3))
	   (g (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((= i 5) fv)
	(float-vector-set! fv i (oscil g))))
    
    (test (catch #t
	    fv01
	    (lambda args 
	      (apply format #f (cadr args))))    ; float-vector-set! argument, 3, is out of range (it is too large)
	  "float-vector-set! argument, 3, is out of range (it is too large)")
    
    (define (fv02)
      (do ((fv (make-float-vector 3))
	   (g (make-oscil 1000))
	   (i 0 (+ i 1/2)))
	  ((= i 2) fv)
	(float-vector-set! fv i (oscil g))))
    
    (test (catch #t
	    (lambda ()
	      (display (fv02)) (newline))
	    (lambda args 
	      (apply format #f (cadr args))))   ; float-vector-set! argument 2, 1/2, is a ratio but should be an integer
	  "float-vector-set! argument 2, 1/2, is a ratio but should be an integer")
    
    ;; (+ (* s1 s2) (* (- 1.0 s1) s3)) 
    
    (define (fv1 s1 s2 s3)
      (do ((fv (make-float-vector 4))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (+ (* s1 s2) (* (- 1.0 s1) s3)))))
    
    (test (fv1 1 2 3) (make-float-vector 4 2.0))
    (test (fv1 2 3 4) (make-float-vector 4 2.0))
    (test (fv1 1.0 2.0 3.0) (make-float-vector 4 2.0))
    (test (fv1 2.0 3.0 4.0) (make-float-vector 4 2.0))
    (test (fv1 1/2 5/4 3/4) (make-float-vector 4 1.0))
    
    (test 
     (catch #t 
       (lambda ()
	 (fv1 1+i 2+2i 3+3i)) ; 'error? -- 3+i 
       (lambda args 
	 (apply format #f (cadr args))))   ; float-vector-set! argument 3, 3+1i, is a complex number but should be a real
     "float-vector-set! argument 3, 3.0+1.0i, is a complex number but should be a real")
    
    (define (fv2 s2 s3)
      (do ((fv (make-float-vector 4))
	   (i 0 (+ i 1))
	   (x 1.0 (+ x 0+i)))
	  ((= i 4) fv)
	(float-vector-set! fv i (+ (* x s2) (* (- 1.0 x) s3)))))
    (test
     (catch #t
       (lambda ()
	 (fv2 2 3)) ; 'error again #(2.0 2-1i 2-2i 2-3i)
       (lambda args (car args))) 'wrong-type-arg)
    
    (define (fv3)
      (let ((gens (vector (make-oscil 100) (make-oscil 200 1.7) (make-oscil 300 5.0))))
	(let ((fv (make-float-vector 3))
	      (iter (make-iterator gens)))
	  (do ((i 0 (+ i 1))
	       (g (iterate iter) (iterate iter)))
	      ((= i 3) fv)
	    (float-vector-set! fv i (oscil g))))))
    
    (test (fv3) #r(0.0 0.9916648104524686 -0.9589242746631385))
    ;; (oscil (make-oscil 200 1.7)): 0.9916648104524686
    ;; (oscil (make-oscil 300 5.0)): -0.9589242746631385
    
    (define (fv4)
      (do ((fv-a (make-float-vector 4))
	   (fv-b (make-float-vector 4))
	   (g (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((= i 4) (list fv-a fv-b))
	(float-vector-set! fv-a i (float-vector-set! fv-b i (oscil g)))))
    
    (test (fv4) (list #r(0.0 0.1419943179576268 0.2811111133316549 0.4145311766902953) 
		      #r(0.0 0.1419943179576268 0.2811111133316549 0.4145311766902953)))
    
    (define (fv5)
      (do ((fv-a (make-float-vector 4))
	   (g1 (make-oscil 1000))
	   (g2 (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((= i 4) fv-a)
	(float-vector-set! fv-a i (oscil g1 (oscil g2)))))
    
    (test (fv5) #r(0.0 0.1419943179576268 0.4140929109323406 0.7516320715399403))
    
    (define (fv6)
      (let ((g1 (make-oscil 1000))
	    (g2 (make-oscil 1000)))
	(let ((call (lambda () (oscil g1 (oscil g2)))))
	  (list (call) (call) (call) (call)))))
    
    (test (fv6) '(0.0 0.1419943179576268 0.4140929109323406 0.7516320715399403))
    
    (define (fv7)
      (let ((g0 (make-oscil 1000))
	    (g1 (make-oscil 1000))
	    (x 0.1)
	    (fv (make-float-vector 6)))
	(do ((i 0 (+ i 1)))
	    ((= i 3))
	  (float-vector-set! fv i (oscil g0 0.1)))
	(do ((i 3 (+ i 1)))
	    ((= i 6))
	  (float-vector-set! fv i (oscil g1 x)))
	fv))
    
    (test (fv7) #r(0.0 0.2401067896488338 0.4661656420314379 0.0 0.2401067896488338 0.4661656420314379))
    
    (define (fv8)
      (do ((g (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((= i 4)
	   (oscil g))
	(oscil g)))
    
    (test (equivalent? (fv8) 0.5395507431861811) #t)
    
    (define (fv9)
      (do ((g (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((= i 4)
	   (oscil g 0.1))
	(oscil g 0.1)))
    
    (test (equivalent? (fv9) 0.8248311180769614) #t)
    
    (define (fv10)
      (do ((fv (make-float-vector 4))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (* i i))))
    (test (fv10) #r(0.0 1.0 4.0 9.0))
    
    (define (fv11)
      (do ((fv (make-float-vector 4))
	   (g0 (make-oscil 1000))
	   (g1 (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (* (oscil g0) (oscil g1)))))
    (test (fv11) #r(0.0 0.02016238633225161 0.07902345803856255 0.1718360964482408))
    
    (define (fv12)
      (do ((fv (make-float-vector 4))
	   (g0 (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (* 2.0 (oscil g0)))))
    (test (fv12) #r(0.0 0.2839886359152535 0.5622222266633099 0.8290623533805906))
    
    (define (fv13)
      (do ((fv (make-float-vector 4))
	   (x 2.0)
	   (g0 (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (* (oscil g0) x))))
    (test (fv13) #r(0.0 0.2839886359152535 0.5622222266633099 0.8290623533805906))
    
    (define (fv14)
      (do ((fv (make-float-vector 4))
	   (g0 (make-oscil 1000))
	   (g1 (make-oscil 1000))
	   (s0 2.0)
	   (s1 3.0)
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (* s0 (oscil g0 (* s1 (oscil g1)))))))
    (test (fv14) #r(0.0 0.2839886359152535 1.305084606281564 1.984158175327229))
    
    (define (fv15)
      (do ((fv (make-float-vector 4))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (+ i i))))
    (test (fv15) #r(0.0 2.0 4.0 6.0))
    
    (define (fv16)
      (do ((fv (make-float-vector 4))
	   (g0 (make-oscil 1000))
	   (g1 (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (+ (oscil g0) (oscil g1)))))
    (test (fv16) #r(0.0 0.2839886359152535 0.5622222266633099 0.8290623533805906))
    
    (define (fv17)
      (do ((fv (make-float-vector 4))
	   (g0 (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (+ 2.0 (oscil g0)))))
    (test (fv17) #r(2.0 2.141994317957627 2.281111113331655 2.414531176690295))
    
    (define (fv18)
      (do ((fv (make-float-vector 4))
	   (x 2.0)
	   (g0 (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (+ (oscil g0) x))))
    (test (fv18) #r(2.0 2.141994317957627 2.281111113331655 2.414531176690295))
    
    (define (fv19)
      (do ((fv (make-float-vector 4))
	   (g0 (make-oscil 1000))
	   (g1 (make-oscil 1000))
	   (s0 2.0)
	   (s1 3.0)
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (+ s0 (oscil g0 (* s1 (oscil g1)))))))
    (test (fv19) #r(2.0 2.141994317957627 2.652542303140782 2.992079087663615))
    
    (define (fv20)
      (do ((fv (make-float-vector 4))
	   (g0 (make-oscil 1000))
	   (g1 (make-oscil 1000))
	   (g2 (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (+ (oscil g0) (oscil g1) (oscil g2)))))
    (test (fv20) #r(0.0 0.4259829538728803 0.8433333399949648 1.243593530070886))
    
    (define (fv21)
      (do ((fv (make-float-vector 4))
	   (g0 (make-oscil 1000))
	   (g1 (make-oscil 1000))
	   (s1 1.0)
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (+ (oscil g0) (oscil g1) s1))))
    (test (fv21) #r(1.0 1.283988635915253 1.56222222666331 1.829062353380591))
    
    (define (fv22)
      (do ((fv (make-float-vector 4))
	   (g0 (make-oscil 1000))
	   (g1 (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (+ (oscil g0) 1.0 (oscil g1)))))
    (test (fv22) #r(1.0 1.283988635915253 1.56222222666331 1.829062353380591))
    
    (define (fv23)
      (do ((fv (make-float-vector 4))
	   (g0 (make-oscil 1000))
	   (s1 1.0)
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (+ s1 1.0 (oscil g0)))))
    (test (fv23) #r(2.0 2.141994317957627 2.281111113331655 2.414531176690295))
    
    (define (fv24)
      (do ((fv (make-float-vector 4))
	   (g0 (make-oscil 1000))
	   (s1 1.0)
	   (s2 2.0)
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (+ s1 (oscil g0) s2))))
    (test (fv24) #r(3.0 3.141994317957627 3.281111113331655 3.414531176690295))
    
    (define (fv25)
      (do ((fv (make-float-vector 4))
	   (g0 (make-oscil 1000))
	   (s1 1.0)
	   (s2 2.0)
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (+ s1 s2 (oscil g0)))))
    (test (fv25) #r(3.0 3.141994317957627 3.281111113331655 3.414531176690295))
    
    (define (fv26)
      (do ((fv (make-float-vector 4))
	   (g0 (make-oscil 1000))
	   (s1 1.0)
	   (s2 2.0)
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (+ (oscil g0) s1 s2))))
    (test (fv26) #r(3.0 3.141994317957627 3.281111113331655 3.414531176690295))
    
    (define (fv27)
      (do ((fv (make-float-vector 4))
	   (s3 4.0)
	   (s1 1.0)
	   (s2 2.0)
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (+ s3 s1 s2))))
    (test (fv27) (make-float-vector 4 7.0))
    
    (define (fv28)
      (do ((fv (make-float-vector 4))
	   (s1 1.0)
	   (s2 2.0)
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (+ 4.0 s1 s2))))
    (test (fv28) (make-float-vector 4 7.0))
    
    (define (fv29)
      (do ((fv (make-float-vector 4))
	   (s1 1.0)
	   (s2 2.0)
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (+ s1 s2 4.0))))
    (test (fv29) (make-float-vector 4 7.0))
    
    (define (fv30)
      (do ((fv (make-float-vector 4))
	   (g0 (make-oscil 1000))
	   (g1 (make-oscil 1000))
	   (g2 (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (* (oscil g0) (oscil g1) (oscil g2)))))
    (test (fv30) #r(0.0 0.002862944295646243 0.02221437226853764 0.07123141925855635))
    
    (define (fv31)
      (do ((fv (make-float-vector 4))
	   (g0 (make-oscil 1000 4.0))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (abs (oscil g0)))))
    (test (fv31) #r(0.7568024953079282 0.8419478535558946 0.9100310927158114 0.9596725022396432))
    
    (define (fv32)
      (do ((fv (make-float-vector 4))
	   (s0 -1.5)
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (abs s0))))
    (test (fv32) (make-float-vector 4 1.5))
    
    (define (fv31a)
      (do ((g0 (make-oscil 1000))
	   (fv (make-float-vector 4))
	   (g1 (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(let ((x (oscil g0)))
	  (float-vector-set! fv i (oscil g1 x)))))
    (test (fv31a) #r(0.0 0.1419943179576268 0.4140929109323406 0.7516320715399403))
    
    (define (fv33)
      (do ((g0 (make-oscil 1000))
	   (fv (make-float-vector 4))
	   (g1 (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(let* ((x (oscil g0))
	       (y (oscil g0)))
	  (float-vector-set! fv i (* y (oscil g1 x))))))
    (test (fv33) #r(0.0 0.05886107170631096 0.3505537450231597 0.7966641560805439))
    
    (define (fv34)
      (do ((g0 (make-oscil 1000))
	   (fv (make-float-vector 4))
	   (g1 (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(let* ((x (oscil g0))
	       (y (oscil g0)))
	  (float-vector-set! fv i (* y (oscil g1 x))))))
    (test (fv34) #r(0.0 0.05886107170631096 0.3505537450231597 0.7966641560805439))
    
    (define (fv35)
      (do ((g0 (make-oscil 1000))
	   (fv (make-float-vector 4))
	   (g1 (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(let ((y (oscil g0)))
	  (float-vector-set! fv i (+ y (oscil g1))))))
    (test (fv35) #r(0.0 0.2839886359152535 0.5622222266633099 0.8290623533805906))
    
    (define (fv37)
      (do ((g0 (make-oscil 1000))
	   (fv (make-float-vector 4))
	   (x0 1.0)
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (odd-weight (+ x0 (oscil g0))))))
    (test (fv37) #r(1.0 0.8580056820423732 0.7188888866683452 0.5854688233097047))
    
    (define (fv38)
      (do ((g0 (make-oscil 1000))
	   (fv (make-float-vector 4))
	   (x0 1.0)
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (even-weight (+ x0 (oscil g0))))))
    (test (fv38) #r(0.0 0.1419943179576268 0.2811111133316548 0.4145311766902953))
    
    (define (fv39)
      (do ((g0 (make-oscil 1000))
	   (fv (make-float-vector 4))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (max (oscil g0) 0.25))))
    (test (fv39) #r(0.25 0.25 0.2811111133316549 0.4145311766902953))
    
    (define (fv40)
      (do ((g0 (make-file->sample "oboe.snd"))
	   (fv (make-float-vector 4))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (ina i g0))))
    (test (fv40) #r(0.0 -0.00030517578125 -0.00030517578125 -0.000274658203125))
    
    (define (fv41)
      (do ((g0 (make-float-vector 3 0.5))
	   (fv (make-float-vector 4))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (ina i g0))))
    (test (fv41) #r(0.5 0.5 0.5 0.0))
    
    (define (fv42)
      (do ((g0 (make-float-vector 3 0.5))
	   (fv (make-float-vector 4))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (- (ina i g0)))))
    (test (fv42) #r(-0.5 -0.5 -0.5 0.0))
    
    (define (fv43)
      (do ((fv (make-float-vector 4))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (- i))))
    (test (fv43) #r(0 -1 -2 -3))
    
    (define (permute op args)
      (let () 
	(define (t1)
	  (let ((x 1.5) (y 3.5) (g0 (make-oscil 1000)) (g1 (make-oscil 2000)) (fv (make-float-vector 4)))
	    (do ((i 0 (+ i 1)))
		((= i 4) fv)
	      (float-vector-set! fv i (eval `(,op ,@args)))))) ; op and args include g0 et al
	(define (t2)
	  (let ((x 1.5) (y 3.5) (g0 (make-oscil 1000)) (g1 (make-oscil 2000)) (v (make-vector 4)))
	    (do ((i 0 (+ i 1)))
		((= i 4) v)
	      (vector-set! v i (eval `(,op ,@args))))))
	(let ((v1 (t1))
	      (v2 (copy (t2) (make-float-vector 4))))
	  (if (not (equivalent? v1 v2))
	      (do ((max-diff 0.0)
		   (i 0 (+ i 1)))
		  ((= i 4)
		   (format *stderr* "~A: ~A -> ~A ~A: ~A~%" op args v1 v2 max-diff))
		(set! max-diff (max max-diff (abs (- (v1 i) (v2 i))))))))))

    (set! (*s7* 'equivalent-float-epsilon) 1e-12)    
    (for-each
     (lambda (op)
       (for-each-subset
	(lambda s-args
	  (if (pair? s-args)
	      (for-each-permutation (lambda args (permute op args)) s-args)))
	(list 'x '(oscil g0) 2.0 '(oscil g1) 'y)))
     '(+ * -))
    
    (set! (*s7* 'equivalent-float-epsilon) 5e-12)    
    (for-each-subset
     (lambda s-args
       (if (pair? s-args)
	   (for-each-permutation (lambda args (permute '/ args)) s-args)))
     (list 'x '(+ .01 (oscil g0)) 2.0 '(+ .01 (oscil g1)) 'y))
    
    (define (fv44)
      (do ((g0 (make-float-vector 3 1.0))
	   (fv (make-float-vector 4))
	   (x 2.0)
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (polynomial g0 x))))
    (test (fv44) (make-float-vector 4 7.0))
    
    (define (fv45)
      (do ((g0 (make-float-vector 3 1.0))
	   (fv (make-float-vector 4))
	   (x (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (polynomial g0 (* 2.0 (oscil x))))))
    (test (fv45) #r(1.0 1.36463818124426 1.87831605881756 2.516406739173554))
    
    (define (fv47)
      (do ((g0 (make-oscil 1000))
	   (fv (make-float-vector 4))
	   (x 1.0)
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (amplitude-modulate 1.0 x (oscil g0)))))
    (test (fv47) #r(1.0 1.141994317957627 1.281111113331655 1.414531176690295))
    
    (define (fv48)
      (do ((g0 (make-oscil 1000))
	   (fv (make-float-vector 4))
	   (x 1.0)
	   (i 0 (+ i 1)))
	  ((= i 4) (and (zero? (log x)) fv))
	(float-vector-set! fv i (remainder (* 10 (oscil g0)) 1.0))))
    (test (fv48) #r(0.0 0.4199431795762676 0.8111111333165493 0.1453117669029531))

    (define (fv49)
      (do ((g0 #r(1 2 3 4 5 6))
	   (fv (make-float-vector 4))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (float-vector-ref g0 (+ i 2)))))
    (test (fv49) #r(3 4 5 6))

    (define (fv49a)
      (do ((fv (make-float-vector 4))
	   (g0 (make-oscil 1000))
	   (g1 (make-oscil 1000))
	   (g2 (make-oscil 1000))
	   (g3 (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (+ (oscil g0) (oscil g1) (oscil g2) (oscil g3)))))
    (test (fv49a) #r(0.0 0.5679772718305071 1.12444445332662 1.658124706761181))

    (define (fv51)
      (do ((fv (make-float-vector 4))
	   (g (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((> i 4) fv)
	(float-vector-set! fv i (oscil g))))
    (test (catch #t fv51 (lambda args (car args))) 'out-of-range)
    
    (define (fv52)
      (do ((fv (make-float-vector 4))
	   (g (make-oscil 1000))
	   (i 0 (+ i 1.1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (oscil g))))
    (test (catch #t fv52 (lambda args (car args))) 'wrong-type-arg)
    
    (define (fv53)
      (do ((fv (make-float-vector 4))
	   (g (make-oscil 1000))
	   (i 0 (+ i 2)))
	  ((= i 3) fv)
	(float-vector-set! fv i (oscil g))))
    (test (catch #t fv53 (lambda args (car args))) 'out-of-range)
    
    
    (define (fv54)
      (do ((fv (make-float-vector 4))
	   (g (make-oscil 1000))
	   (i 0 (+ i 1))
	   (x 0.0 (+ x 0.1)))
	  ((> i 4) (and (positive? x) fv))
	(float-vector-set! fv i (oscil g))))
    (test (catch #t fv54 (lambda args (car args))) 'out-of-range)
    
    (define (fv55)
      (do ((fv (make-float-vector 4))
	   (g (make-oscil 1000))
	   (i 0 (+ i 1.1))
	   (x 0.0 (+ x 0.1)))
	  ((= i 4) (and (positive? x) fv))
	(float-vector-set! fv i (oscil g))))
    (test (catch #t fv55 (lambda args (car args))) 'wrong-type-arg)
    
    (define (fv56)
      (do ((fv (make-float-vector 4))
	   (g (make-oscil 1000))
	   (i 0 (+ i 2))
	   (x 0.0 (+ x 0.1)))
	  ((= i 3) (and (positive? x) fv))
	(float-vector-set! fv i (oscil g))))
    (test (catch #t fv56 (lambda args (car args))) 'out-of-range)
    
    (define (fv57)
      (do ((g (make-oscil 1000))
	   (e (make-env '(0 0 1 1) :length 5))
	   (fv (make-float-vector 4))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (* (env e) (oscil g)))))
    (test (fv57) #r(0.0 0.03549857948940669 0.1405555566658275 0.3108983825177215))
    
    (define (fv59)
      (do ((fv (make-float-vector 4))
	   (g (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(let ((j (abs i))) ; j is not an integer! so is_fv_set_rf rejects it -- yow
	  (float-vector-set! fv j (oscil g)))))
    (test (fv59) #r(0.0 0.1419943179576268 0.2811111133316549 0.4145311766902953))

    (define (fv60)
      (do ((xv #r(0 1 2 3 4))
	   (fv (make-float-vector 4))
	   (g (make-oscil 1000))
	   (len 5)
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (array-interp xv (* 4 (abs (oscil g))) len))))
    (test (fv60) #r(0.0 0.5679772718305071 1.12444445332662 1.658124706761181))

    (define (fv61)
      (do ((fv (make-float-vector 4))
	   (g (make-oscil 1000))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (+ (oscil g) (oscil g)))))
    (test (fv61) #r(0.1419943179576268 0.6956422900219503 1.193187027684375 1.594501774071586))
    
    (define (fv62)
      (do ((fv (make-float-vector 4))
	   (g (make-oscil 1000))
	   (x .1)
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (+ (oscil g) (oscil g x)))))
    (test (fv62) #r(0.1419943179576268 0.8788265473477139 1.4870276868047 1.877577239959861))
    
    (define (fv63)
      (do ((fv (make-float-vector 4))
	   (g (make-oscil 1000))
	   (x .1)
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (+ (oscil g x) (oscil g)))))
    (test (fv63) #r(0.2401067896488338 0.962578603769539 1.544160801705073 1.899729018207357))

    (define (fv64)
      (set! (mus-rand-seed) 1234)
      (do ((fv (make-float-vector 10))
	   (e (make-env '(0 0 1 1) :length 10))
	   (r (make-rand-interp 1000 .1))
	   (i 0 (+ i 1)))
	  ((= i 10) fv)
	(float-vector-set! fv i (+ (env e) (rand-interp r)))))
    (test (fv64) #r(-0.07828369138846 0.03260625378213546 0.1434961989527309 0.2543861441233264 0.3652760892939219 0.4761660344645173 
		     0.5870559796351129 0.6979459248057084 0.8088358699763039 0.9197258151468994))
    
    (define (fv65)
      (set! (mus-rand-seed) 1234)
      (do ((fv (make-float-vector 10))
	   (e (make-triangle-wave 1000 .5))
	   (r (make-rand-interp 1000 .1))
	   (i 0 (+ i 1)))
	  ((= i 10) fv)
	(float-vector-set! fv i (+ (triangle-wave e) (rand-interp r)))))
    (test (fv65) #r(-0.07828369138846 -0.03315338340607316 0.01197692457631369 0.05710723255870052 0.1022375405410874 0.1473678485234742 
                    0.1924981565058611 0.2376284644882479 0.2827587724706346 0.3278890804530215))

    ;; from Tito Latini
    (define (rand-test constr fn seed rep)
      (set! (mus-rand-seed) seed)
      (let ((r (constr (/ *clm-srate* 4))))
	(do ((i 0 (+ i 1))
	     (j (fn r) (fn r))
	     (acc ()))
	    ((= i rep) (reverse! acc))
	  (when (= (logand i 3) 0)
	    ;; Skip duplicated or interpolated values.
	    (set! acc (cons j acc))))))
    
    (test (rand-test make-rand rand 12345 32)
	  '(0.3103027354484 -0.3903808588755999 0.3499145518871001 -0.7864990232626 0.0331420906901001 -0.02069091716649996 0.2048950205183 -0.2601318353313999))

    (test (rand-test make-rand-interp rand-interp 12345 32)
	  '(0.3103027354484 -0.3903808588755999 0.3499145518871001 -0.7864990232625999 0.0331420906901001 -0.02069091716649996 0.2048950205183 -0.2601318353313999))

    
    (define (fv66)
      (let ((fv (make-float-vector 8))
	    (gv (make-vector 8))
	    (g0 (make-oscil 1000))
	    (g1 (make-oscil 1000)))
	(do ((i 0 (+ i 2)))
	    ((= i 8))
	  (set! (gv i) g0)
	  (set! (gv (+ i 1)) g1))
	(do ((i 0 (+ i 1)))
	    ((= i 8) fv)
	  (float-vector-set! fv i (oscil (vector-ref gv i))))))
    (test (fv66) #r(0.0 0.0 0.1419943179576268 0.1419943179576268 0.2811111133316549 0.2811111133316549 0.4145311766902953 0.4145311766902953))
    
    (define (fv67)
      (let ((fv (make-float-vector 8))
	    (g (make-oscil 1000))
	    (v (make-vector 8)))
	(fill! v g)
	(do ((i 0 (+ i 1)))
	    ((= i 8) fv)
	  (float-vector-set! fv i (oscil (vector-ref v i))))))
    (test (fv67) #r(0.0 0.1419943179576268 0.2811111133316549 0.4145311766902953 0.5395507431861811 0.6536362844981936 0.7544758509208143 0.8400259231507713))
    
    (define (fv68)
      (let ((fv (make-float-vector 8))
	    (gv (make-vector 8))
	    (g0 (make-oscil 1000))
	    (g1 (make-oscil 1000))
	    (x .1))
	(do ((i 0 (+ i 2)))
	    ((= i 8))
	  (set! (gv i) g0)
	  (set! (gv (+ i 1)) g1))
	(do ((i 0 (+ i 1)))
	    ((= i 8) fv)
	  (float-vector-set! fv i (oscil (vector-ref gv i) x)))))
    (test (fv68) #r(0.0 0.0 0.2401067896488338 0.2401067896488338 0.4661656420314379 0.4661656420314379 0.6649505230927522 0.6649505230927522))
    
    (define (fv69)
      (do ((fv (make-float-vector 4))
	   (g (make-formant 440 .9))
	   (e (make-env '(0 440 1 880) :length 10))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (mus-set-formant-frequency g (env e)))))
    (test (fv69) #r(440.0 488.8888888888889 537.7777777777778 586.6666666666667))

    (define (fv70)
      (do ((fv1 (make-float-vector 4))
	   (fv2 (make-float-vector 4))
	   (g1 (make-oscil 1000))
	   (g2 (make-oscil 1000))
	   (e (make-env '(0 2.0 1 2.0) :length 10))
	   (i 0 (+ i 1)))
	  ((= i 4) (list fv1 fv2))
	(let ((x (env e)))
	  (float-vector-set! fv1 i (oscil g1))
	  (float-vector-set! fv2 i (* x (oscil g2))))))
    (test (fv70) (list #r(0.0 0.1419943179576268 0.2811111133316549 0.4145311766902953) 
		       #r(0.0 0.2839886359152535 0.5622222266633099 0.8290623533805906)))

    (define (fv71)
      (let ((fv (make-float-vector 8))
	    (gv (make-vector 8))
	    (g0 (make-env '(0 0 1 1) :length 5))
	    (g1 (make-env '(0 0 1 1) :length 5)))
	(do ((i 0 (+ i 2)))
	    ((= i 8))
	  (set! (gv i) g0)
	  (set! (gv (+ i 1)) g1))
	(do ((i 0 (+ i 1)))
	    ((= i 8) fv)
	  (float-vector-set! fv i (env (vector-ref gv i))))))
    (test (fv71) #r(0.0 0.0 0.25 0.25 0.5 0.5 0.75 0.75))

    (define (fv72)
      (let ((fv (make-float-vector 10))
	    (ls (make-list 10))
	    (x 0.0))
	(do ((g (make-square-wave 2205))
	     (i 0 (+ i 1)))
	    ((= i 10))
	  (float-vector-set! fv i (+ (square-wave g) (square-wave g x))))
	(do ((g (make-square-wave 2205))
	     (i 0 (+ i 1)))
	    ((= i 10))
	  (list-set! ls i (+ (square-wave g) (square-wave g x))))
	(list fv ls)))
    
    (test (fv72) (list #r(2.0 2.0 2.0 2.0 2.0 0.0 0.0 0.0 0.0 0.0) 
		       (list 2.0 2.0 2.0 2.0 2.0 0.0 0.0 0.0 0.0 0.0)))
    
    (define (fv73)
      (let ((fv (make-float-vector 10))
	    (ls (make-list 10))
	    (x 0.5))
	(do ((g (make-square-wave 2205))
	     (i 0 (+ i 1)))
	    ((= i 10))
	  (float-vector-set! fv i (+ (square-wave g) (square-wave g x))))
	(newline *stderr*)
	(do ((g (make-square-wave 2205))
	     (i 0 (+ i 1)))
	    ((= i 10))
	  (list-set! ls i (+ (square-wave g) (square-wave g x))))
	(list fv ls)))
    
    (test (fv73) (list #r(2.0 2.0 2.0 0.0 0.0 0.0 2.0 2.0 2.0 0.0) 
		       (list 2.0 2.0 2.0 0.0 0.0 0.0 2.0 2.0 2.0 0.0)))
    
    (define (fv74)
      (let ((fv (make-float-vector 4))
	    (g (make-r2k!cos 1000 :r 0.5 :k 3.0)))
	(do ((i 0 (+ i 1)))
	    ((= i 4) fv)
	  (float-vector-set! fv i (r2k!cos g)))))
    (test (fv74) #r(0.008 0.01148666785741709 0.01717900881454179 0.02679348967895129))
    
    (define (fv75)
      (do ((fv (make-float-vector 4))
	   (g (make-r2k!cos 1000 :r 0.5 :k 3.0))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (r2k!cos g .1))))
    (test (fv75) #r(0.008 0.01517028252035849 0.03244495213443228 0.07802652038780451))
    
    (define (fv76)
      (do ((fv (make-float-vector 4))
	   (g (make-r2k!cos 1000 :r 0.5 :k 3.0))
	   (x .1)
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (r2k!cos g x))))
    (test (fv76) #r(0.008 0.01517028252035849 0.03244495213443228 0.07802652038780451))
    
    (define (fv77)
      (do ((fv (make-float-vector 4))
	   (g (make-r2k!cos 1000 :r 0.5 :k 3.0))
	   (x (make-env '(0 .1 1 .1) :length 10))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i (r2k!cos g (env x)))))
    (test (fv77) #r(0.008 0.01517028252035849 0.03244495213443228 0.07802652038780451))

    (define (fv81) (do ((x 0.0) (i 0 (+ i 1)) (y .1 .1)) ((= i 4) x) (set! x y))) (test (fv81) .1)
    (define (fv82) (do ((x 0.0) (y 0.1) (i 0 (+ i 1))) ((= i 4) x) (set! x y))) (test (fv82) .1)
    (define (fv84) (do ((x 1.0) (i 0 (+ i 1))) ((= i 10) x) (set! x (+ x (* i 2.0))))) (test (fv84) 91.0)

    (define (fv85)
      (do ((fv1 (make-float-vector 4 1.5))
	   (fv2 (make-float-vector 4))
	   (i 0 (+ i 1)))
	  ((= i 10) fv2)
	(float-vector-add! fv2 fv1)))
    (test (fv85) (make-float-vector 4 15.0))

    (define (fv86)
      (do ((g0 (make-float-vector 4 1.0))
	   (fv (make-float-vector 4))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(set! (fv i) (g0 i))))
    (test (fv86) (make-float-vector 4 1.0))

    (define (fv87)
      (do ((fv1 (make-float-vector 4 1.5))
	   (fv2 (make-float-vector 4))
	   (i 0 (+ i 1))
	   (j 0 (+ j 1)))
	  ((= i 4) fv2)
	(float-vector-add! fv2 fv1)
	(float-vector-set! fv1 j 2.5)))
    (test (fv87) #r(9 8 7 6))
    
    (define (fv88)
      (do ((fv (make-float-vector 4))
	   (ifv (make-float-vector 1))
	   (g (make-file->frample "oboe.snd"))
	   (i 0 (+ i 1))
	   (j 1000 (+ j 1)))
	  ((= i 4) fv)
	(file->frample g j ifv)
	(float-vector-set! fv i (ifv 0))))
    (test (fv88) #r(0.0328369140625 0.0347900390625 0.0340576171875 0.031036376953125))
    
    (define (fv89)
      (do ((fv0 (make-float-vector 4))
	   (fv1 (make-float-vector 4))
	   (ifv (make-float-vector 2))
	   (g (make-file->frample "2.snd"))
	   (i 0 (+ i 1))
	   (j 1000 (+ j 1)))
	  ((= i 4) (list fv0 fv1))
	(file->frample g j ifv)
	(float-vector-set! fv0 i (ifv 0))
	(float-vector-set! fv1 i (ifv 1))))
    (test (fv89) (list #r(0.002227783203125 0.00634765625 0.00787353515625 0.007293701171875)
		       #r(0.004425048828125 0.012664794921875 0.015777587890625 0.014556884765625)))

    (define (fv90)
      (do ((fv (make-float-vector 4))
	   (i 0 (+ i 1))
	   (x 1.0 (+ x 0.5)))
	  ((= i 4) fv)
	(set! (fv i) x)))
    (test (fv90) #r(1.0 1.5 2.0 2.5))
    
    (define (fv91)
      (do ((f1 #r(1.0 2.0 3.0))
	   (f2 #r(0.0 0.0 0.0))
	   (m1 #r(1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0))
	   (f1-len 3)
	   (f2-len 3)
	   (i 0 (+ i 1))
	   (x 0 (+ x 2))) ; currently needed to trigger optimizer
	  ((= i 1) (and (positive? x) f2))
	(frample->frample m1 f1 f1-len f2 f2-len)))
    (test (fv91) #r(30.0 36.0 42.0))
    
    (define (fv92)
      (let ((sf (make-frample->file "fmv.snd" 2 mus-lfloat mus-riff "this is a comment"))
	    (fv #r(.1 .2))
	    (fv1 (make-float-vector 4))
	    (fv2 (make-float-vector 4)))
	(do ((i 0 (+ i 1)))
	    ((= i 4))
	  (frample->file sf i fv))
	(mus-close sf)
	(list (file->array "fmv.snd" 0 0 4 fv1)
	      (file->array "fmv.snd" 1 0 4 fv2))))
    (let-temporarily (((*s7* 'equivalent-float-epsilon) 1e-5))
      (test (fv92) (list (make-float-vector 4 .1) (make-float-vector 4 .2))))

    (define (fv93)
      (let ((sf (make-frample->file "fmv.snd" 2 mus-lfloat mus-riff "this is a comment"))
	    (fv #r(.01 .02))
	    (fv1 (make-float-vector 4))
	    (fv2 (make-float-vector 4)))
	(do ((i 0 (+ i 1)))
	    ((= i 4))
	  (frample->file sf i (float-vector-add! fv fv)))
	(mus-close sf)
	(list (file->array "fmv.snd" 0 0 4 fv1)
	      (file->array "fmv.snd" 1 0 4 fv2))))
    (let-temporarily (((*s7* 'equivalent-float-epsilon) 1e-5))
      (test (fv93) (list #r(.02 .04 .08 .16)
			 #r(.04 .08 .16 .32))))

    (define (fv94)
      (do ((fv0 #r(0 1 2 3 4 5))
	   (fv (make-float-vector 4))
	   (i 0 (+ i 1))
	   (x 0.4 (+ x 0.7)))
	  ((= i 4) fv)
	(float-vector-set! fv i (float-vector-ref fv0 (floor x)))))
    (test (fv94) #r(0.0 1.0 1.0 2.0))

    (define (fv94a)
      (do ((fv0 #r(0 1 2 3 4 5))
	   (fv (make-float-vector 4))
	   (i 0 (+ i 1))
	   (x 0.4 (+ x 0.7)))
	  ((= i 4) fv)
	(float-vector-set! fv i (float-vector-ref fv0 (ceiling x)))))
    (test (fv94a) #r(1.0 2.0 2.0 3.0))
    
    (define (fv95)
      (do ((fv (make-float-vector 4))
	   (i 0 (+ i 1))
	   (x 0 (+ x 1)))
	  ((= i 4) (and (positive? x) fv))
	(float-vector-set! fv i ((if (even? i) + -) i 10.0))))
    (test (fv95) #r(10.0 -9.0 12.0 -7.0))
    
    (define (fv95a)
      (do ((fv (make-float-vector 4))
	   (i 0 (+ i 1))
	   (x 0 (+ x 1)))
	  ((= i 4) (and (positive? x) fv))
	(float-vector-set! fv i ((if (odd? i) + -) i 10.0))))
    (test (fv95a) #r(-10.0 11.0 -8.0 13.0))

    (define (fv96)
      (do ((fv (make-float-vector 4))
	   (fv1 (make-float-vector 4))
	   (i 0 (+ i 1))
	   (x 0 (+ x 1)))
	  ((= i 4) (and (positive? x) (list fv fv1)))
	(float-vector-set! fv1 i 3.0)
	(float-vector-set! fv i ((if (even? i) + -) i 10.0))
	(float-vector-set! fv1 i (+ (float-vector-ref fv1 i) 1.0))))
    (test (fv96) (list #r(10.0 -9.0 12.0 -7.0)
		       (make-float-vector 4 4.0)))

    (define (fv97)
      (do ((fv (make-float-vector 4))
	   (j 0)
	   (i 0 (+ i 1))
	   (x 0.4 (+ x 0.7)))
	  ((= i 4) fv)
	(set! j (floor x))
	(float-vector-set! fv i (* j 2.0))))
    (test (fv97) #r(0.0 2.0 2.0 4.0))

    (define (fv98)
      (do ((fv (make-float-vector 4))
	   (i 0 (+ i 1))
	   (x 0.0 (+ x 0.1)))
	  ((not (= i 0)) fv)
	(set! i (* i 0.5))
	(set! (fv i) x)))
    (test (catch #t
	    fv98
	    (lambda args 
	      (apply format #f (cadr args)))) "vector-set!: index must be an integer: ((fv i) x)")

    (define (fv99)
      (do ((fv (make-float-vector 4))
	   (i 0 (+ i 1))
	   (x 0 (+ x 1)))
	  ((= i 4) (and (positive? x) fv))
	(float-vector-set! fv i ((if (zero? i) + -) i 10.0))))
    (test (fv99) #r(10.0 -9.0 -8.0 -7.0))

    (define (fv100)
      (do ((fv (make-float-vector 4))
	   (i 0 (+ i 1))
	   (x 0 (+ x 1)))
	  ((= i 4) (and (positive? x) fv))
	(float-vector-set! fv i ((if (zero? (modulo i 2)) + -) i 10.0))))
    (test (fv100) #r(10.0 -9.0 12.0 -7.0))

    (define (fv101)
      (do ((ctr 0)
	   (i 0 (+ i 1))
	   (x 0 (+ x 1)))
	  ((= i 4) (and (positive? x) ctr))
	(if (zero? (modulo i 2))
	    (set! ctr (+ ctr 1)))))
    (test (fv101) 2)

    (define (fv104)
      (do ((fv (make-float-vector 10))
	   (i 0 (+ i 1))) 
	  ((= i 10) fv)
	(do ((j 0 (+ j 1))) ((= j i))
	  (float-vector-set! fv i (+ (float-vector-ref fv j) 1.0)))))
    (test (fv104) #r(0 1 2 3 4 5 6 7 8 9))
    
    (define (fv107)
      (do ((g0 (make-hash-table))
	   (i 0 (+ i 1))
	   (x 0.0 (+ x 10.0)))
	  ((= i 4) g0)
	(hash-table-set! g0 i x)))
    (test (fv107) (hash-table 0 0.0 1 10.0 2 20.0 3 30.0))

    (define (fv108)
      (let ((fv (make-float-vector 10)))
	(do ((locs (make-locsig :output fv))
	     (k 0)
	     (i 0 (- i 1)))
	    ((= i -10) fv)
	  (set! k (abs i))
	  (locsig locs k (* .1 i)))))
    (test (fv108) #r(0 -.1 -.2 -.3 -.4 -.5 -.6 -.7 -.8 -.9))
    
    (define (fv109)
      (let ((fv (make-float-vector 10)))
	(do ((locs (make-locsig :output fv))
	     (k 0 (+ k 1))
	     (i 0 (+ i 1)))
	    ((= i 10) fv)
	  (locsig locs k (* .1 i)))))
    (test (fv109) #r(0 .1 .2 .3 .4 .5 .6 .7 .8 .9))

    (define (fv110)
      (let ((fv (make-float-vector 10))
	    (k 0))
	(set! *output* fv)
	(do ((i 0 (+ i 1)))
	    ((= i 10) fv)
	  (outa k (* .1 i))
	  (set! k (+ k 1)))))
    (test (fv110) #r(0 .1 .2 .3 .4 .5 .6 .7 .8 .9))
    
    (define (fv111)
      (let ((fv (make-float-vector 10))
	    (k 0))
	(set! *output* fv)
	(do ((i 0 (+ i 1))
	     (x 0.0 (+ x 0.1)))
	    ((= i 10) fv)
	  (outa k x)
	  (set! k (+ k 1)))))
    (test (fv111) #r(0 .1 .2 .3 .4 .5 .6 .7 .8 .9))
    
    (define (fv112)
      (let ((fv (make-float-vector 10))
	    (k 0))
	(set! *output* fv)
	(do ((i 0 (+ i 1))
	     (x 0.0 (+ x 0.1)))
	    ((= i 10) fv)
	  (outa k x)
	  (set! k (+ k 1.2)))))
    (test (catch #t fv112 (lambda args 'error)) 'error)
    
    (define (fv113)
      (let ((fv (make-float-vector 10)))
	(let ((locs (make-locsig :output fv))
	      (k 0))
	  (do ((i 0 (+ i 1)))
	      ((= i 10) fv)
	    (locsig locs k (* .1 i))
	    (set! k (+ k 1.2))))))
    (test (catch #t fv113 (lambda args 'error)) 'error)
    
    (define (fv114)
      (let ((fv (make-float-vector base-length))
	    (k 0)
	    (x 1.2))
	(set! *output* fv)
	(do ((i 0 (+ i 1)))
	    ((= i base-length) fv)
	  (outa k (* .001 i))
	  (set! k (+ k x)))))
    (test (catch #t fv114 (lambda args 'error)) 'error)

    (define (fv115)
      (do ((g0 (make-float-vector 4 1.0))
	   (fv (make-float-vector 4))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(let ((x (g0 i)))
	  (set! (fv i) x))))
    (test (fv115) (make-float-vector 4 1.0))
    
    (define (fv116)
      (do ((fv (make-float-vector 4))
	   (g (make-oscil 100))
	   (i 0 (+ i 1))
	   (x 0 (+ x 1)))
	  ((= i 4) (and (positive? x) fv))
	(float-vector-set! fv i ((if (oscil? g) + -) i 10.0))))
    (test (fv116) #r(10.0 11.0 12.0 13.0))

    (define (fv117)
      (do ((fv (make-float-vector 4))
	   (i 0 (+ i 1))
	   (x 0 (+ x 1)))
	  ((= i 4) (and (positive? x) fv))
	(float-vector-set! fv i ((if (even? (round i)) + -) i 10.0))))
    (test (fv117) #r(10.0 -9.0 12.0 -7.0))
    
    (define (fv118)
      (do ((fv (make-float-vector 4))
	   (lst '(1 2 3))
	   (i 0 (+ i 1))
	   (x 0 (+ x 1)))
	  ((= i 4) (and (positive? x) fv))
	(float-vector-set! fv i ((if (even? (car lst)) + -) i 10.0))))
    (test (fv118) #r(-10.0 -9.0 -8.0 -7.0))

    (define (fv119)
      (do ((fv (make-float-vector 4))
	   (lst '(1 2 3))
	   (i 0 (+ i 1))
	   (x 0 (+ x 1)))
	  ((= i 4) (and (positive? x) fv))
	(float-vector-set! fv i ((if (eqv? i (car lst)) + -) i 10.0))))
    (test (fv119) #r(-10.0 11.0 -8.0 -7.0))

    (define (fv120)
      (do ((fv (make-float-vector 4))
	   (j 2)
	   (i 0 (+ i 1))
	   (x 0 (+ x 1)))
	  ((= i 4) (and (positive? x) fv))
	(float-vector-set! fv i ((if (= i j) + -) i 10.0))))
    (test (fv120) #r(-10.0 -9.0 12.0 -7.0))

    (define (fv121)
      (do ((fv (make-float-vector 4))
	   (j 2)
	   (i 0 (+ i 1))
	   (x 0 (+ x 1)))
	  ((= i 4) (and (positive? x) fv))
	(float-vector-set! fv i ((if (< i j) + -) i 10.0))))
    (test (fv121) #r(10.0 11.0 -8.0 -7.0))
    
    (define (fv122)
      (do ((fv (make-float-vector 4))
	   (j 2)
	   (i 0 (+ i 1))
	   (x 0 (+ x 1)))
	  ((= i 4) (and (positive? x) fv))
	(float-vector-set! fv i ((if (<= i j) + -) i 10.0))))
    (test (fv122) #r(10.0 11.0 12.0 -7.0))
    
    (define (fv123)
      (do ((fv (make-float-vector 4))
	   (j 2)
	   (i 0 (+ i 1))
	   (x 0 (+ x 1)))
	  ((= i 4) (and (positive? x) fv))
	(float-vector-set! fv i ((if (>= i j) + -) i 10.0))))
    (test (fv123) #r(-10.0 -9.0 12.0 13.0))
    
    (define (fv124)
      (do ((fv (make-float-vector 4))
	   (j 2)
	   (i 0 (+ i 1))
	   (x 0 (+ x 1)))
	  ((= i 4) (and (positive? x) fv))
	(float-vector-set! fv i ((if (> i j) + -) i 10.0))))
    (test (fv124) #r(-10.0 -9.0 -8.0 13.0))
    
    (define (fv126)
      (let ((d0 #r(1 0 -1 0 1 0 -1 0))
	    (d1 #r(0 1 0 -1 0 1 0 -1))
	    (e0 #r(0 0 8 0 0 0 0 0))
	    (e1 (make-float-vector 8))
	    (rl (make-float-vector 8))
	    (im (make-float-vector 8)))
	(set! (rl 2) 1.0)
	(mus-fft rl im 8 1)
	(if (not (and (equivalent? d0 rl) 
		      (equivalent? d1 im)))
	    (format *stderr* ";fv126 mus-fft 0: ~A ~A~%" rl im))
	(mus-fft rl im 8 -1)
	(if (not (and (equivalent? e0 rl) 
		      (equivalent? e1 im)))
	    (format *stderr* ";fv126 mus-fft 1: ~A ~A~%" rl im))
	(set! (rl 2) 1.0)
	(do ((i 0 (+ i 1)))
	    ((= i 1))
	  (mus-fft rl im))
	(if (not (and (equivalent? d0 rl)
		      (equivalent? d1 im)))
	    (format *stderr* ";fv126 mus-fft 2: ~A ~A~%" rl im))
	(do ((loc 2)
	     (val 1.0)
	     (i 0 (+ i 1)))
	    ((= i 1)
	     (if (not (and (equivalent? d0 rl)
			   (equivalent? d1 im)))
		 (format *stderr* ";fv126 mus-fft 2: ~A ~A~%" rl im)))
	  (mus-fft rl im 8 -1)
	  (float-vector-set! rl loc val)
	  (mus-fft rl im 8))))
    (fv126)

    (define (fv127)
      (do ((fv (make-float-vector 4))
	   (j 2)
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i ((if (or (> i j) (= i 3)) + -) i 10.0))))
    (test (fv127) #r(-10.0 -9.0 -8.0 13.0))
    
    (define (fv129)
      (do ((fv (make-float-vector 4))
	   (j 2)
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i ((if (and (= i j) (< i 3)) + -) i 10.0))))
    (test (fv129) #r(-10.0 -9.0 12.0 -7.0))

    (define (fv130)
      (do ((fv (make-float-vector 4))
	   (j #\a)
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(float-vector-set! fv i ((if (char=? j #\a) + -) i 10.0))))
    (test (fv130) #r(10.0 11.0 12.0 13.0))

    (unless (provided? 'pure-s7)
      (define (fv131)
	(let ((fv1 (make-float-vector 10))
	      (fv2 #f)
	      (coeffs #r(0.0 0.5 0.25 0.125)))
	  (do ((i 0 (+ i 1))
	       (x 0.0 (+ x 0.1)))
	      ((= i 10))
	    (float-vector-set! fv1 i (mus-chebyshev-t-sum x coeffs)))
	  (do ((i 0 (+ i 1))
	       (x 0.0 (+ x 0.1))
	       (lst ()))
	      ((= i 10)
	       (set! fv2 (reverse (list->vector lst))))
	    (set! lst (cons (mus-chebyshev-t-sum x coeffs) lst)))
	  (if (not (equivalent? fv1 fv2))
	      (format *stderr* ";t-sum: ~A ~A~%" fv1 fv2))))
      
      (define (fv132)
	(let ((fv1 (make-float-vector 10))
	      (fv2 #f)
	      (t-coeffs #r(0.0 0.5 0.25 0.125))
	      (u-coeffs #r(0.0 0.2 0.1 0.05)))
	  (do ((i 0 (+ i 1))
	       (x 0.0 (+ x 0.1)))
	      ((= i 10))
	    (float-vector-set! fv1 i (mus-chebyshev-tu-sum x t-coeffs u-coeffs)))
	  (do ((i 0 (+ i 1))
	       (x 0.0 (+ x 0.1))
	       (lst ()))
	      ((= i 10)
	       (set! fv2 (reverse (list->vector lst))))
	    (set! lst (cons (mus-chebyshev-tu-sum x t-coeffs u-coeffs) lst)))
	  (if (not (equivalent? fv1 fv2))
	      (format *stderr* ";tu-sum: ~A ~A~%" fv1 fv2))))
      (fv131)
      (fv132))

    (define (fv132a)
      (do ((fv (make-float-vector 10))
	   (o1 (make-oscil 1000))
	   (o2 (make-oscil 1000))
	   (s1 (make-sawtooth-wave 1000))
	   (s2 (make-sawtooth-wave 1000))
	   (s3 (make-sawtooth-wave 1000))
	   (s4 (make-sawtooth-wave 1000))
	   (t1 (make-triangle-wave 1000))
	   (t2 (make-triangle-wave 1000))
	   (p1 (make-polywave 1000 '(1 .4 2 .6)))
	   (p2 (make-polywave 1000 '(1 .4 2 .6)))
	   (p3 (make-polywave 1000 '(1 .4 2 .6)))
	   (p4 (make-polywave 1000 '(1 .4 2 .6)))
	   (i 0 (+ i 1)))
	  ((= i 10) fv)
	(set! (fv i) 
	      (if (even? i) 
		  (+ (oscil o1)
		     (* (triangle-wave t1)
			(polywave (if (zero? (modulo i 2)) p1 p2)))
		     (sawtooth-wave (if (odd? i) s1 s2)))
		  (+ (oscil o2)
		     (* (triangle-wave t2)
			(polywave (if (zero? (modulo i 2)) p3 p4)))
		     (sawtooth-wave (if (odd? i) s3 s4)))))))

    (test (fv132a) #r(0.0 0.0 0.2754865742400099 0.2754865742400099 0.5330915108442034 0.5330915108442034 
				 0.7567925994733748 0.7567925994733748 0.9340879688376413 0.9340879688376413))
    
    (define (fv136)
      (do ((fv (make-vector 4))
	   (i 0 (+ i 1))
	   (x 0.0 (+ x 1.0)))
	  ((= i 4) fv)
	(vector-set! fv i (cons i x))))
    (test (fv136) (vector '(0 . 0.0) '(1 . 1.0) '(2 . 2.0) '(3 . 3.0)))
    
    (define (fv137)
      (do ((fv (make-vector 4))
	   (i 0 (+ i 1))
	   (x 0.0 (+ x 0.6)))
	  ((= i 4) fv)
	(vector-set! fv i (asin x))))
    (test (fv137) (vector 0.0 (asin 0.6) (asin 1.2) (asin 1.8)))
    
    (define (fv138)
      (do ((fv (make-vector 4))
	    (fv1 (vector 0.0 0.6 1.2 1.8))
	    (i 0 (+ i 1))
	    (x 0.0 (+ x 0.6)))
	  ((= i 4) (and (positive? x) fv))
	(vector-set! fv i (asin (vector-ref fv1 i)))))
    (test (fv138) (vector 0.0 (asin 0.6) (asin 1.2) (asin 1.8)))
    
    (define (fv138a)
      (do ((fv (make-vector 4))
	   (i 0 (+ i 1))
	   (x 0.0 (+ x 0.6)))
	  ((= i 4) (and (positive? x) fv))
	(vector-set! fv i (asin (floor i)))))
    (test (fv138a) (vector 0 (asin 1) (asin 2) (asin 3)))
    
    (define (fv138b)
      (do ((fv (make-vector 4))
	   (i 0 (+ i 1))
	   (x 0.0 (+ x 0.6)))
	  ((= i 4) fv)
	(vector-set! fv i (asin (complex x i)))))
    (test (fv138b) (vector 0.0 (asin 0.6+i) (asin 1.2+2i) (asin 1.8+3i)))

    (define (fv139)
      (with-output-to-string
	(lambda ()
	  (do ((i 80 (+ i 1)))
	      ((= i 84))
	    (write-byte i)))))
    (test (fv139) "PQRS")
    
    (define (fv140)
      (with-output-to-string
	(lambda ()
	  (do ((i 80 (+ i 1)))
	      ((= i 84))
	    (write-byte i)))))
    (test (fv140) "PQRS")

    (define (fv141)
      (do ((g0 (make-hash-table))
	   (v (vector 0 1 2 3 4 5))
	   (i 0 (+ i 1))
	   (x 0.0 (+ x 10.0)))
	  ((= i 4) g0)
	(hash-table-set! g0 (vector-ref v i) x)))
    (test (fv141) (hash-table 0 0.0 1 10.0 2 20.0 3 30.0))
    
    (define (fv142)
      (do ((g0 (make-hash-table))
	   (i 0 (+ i 1))
	   (x 0.0 (+ x 10.0)))
	  ((= i 4) g0)
	(hash-table-set! g0 i (list x))))
    (test (fv142) (hash-table 0 '(0.0) 1 '(10.0) 2 '(20.0) 3 '(30.0)))
    
    (define (fv143)
      (do ((g0 (make-hash-table))
	   (v (vector 0 1 2 3 4 5))
	   (i 0 (+ i 1))
	   (x 0.0 (+ x 10.0)))
	  ((= i 4) g0)
	(hash-table-set! g0 (vector-ref v i) (list x))))
    (test (fv143) (hash-table 0 '(0.0) 1 '(10.0) 2 '(20.0) 3 '(30.0)))

    (define (fv144)
      (do ((g0 (make-iterator '(0 1 2 3 4)))
	   (v (make-vector 4))
	   (i 0 (+ i 1)))
	  ((= i 4) v)
	(vector-set! v i (iterate g0))))
    (test (fv144) (vector 0 1 2 3))
    
    (define (fv145)
      (do ((g0 (list (make-iterator '(0 1 2 3 4))))
	   (v (make-vector 4))
	   (i 0 (+ i 1)))
	  ((= i 4) v)
	(vector-set! v i (iterate (car g0)))))
    (test (fv145) (vector 0 1 2 3))

    (define (fv146)
      (do ((x 0)
	   (i 0 (+ i 1)))
	  ((= i 4) x)
	(do ((k 0 (+ k 1)))
	    ((= k 4))
	  (set! x (+ x k)))))
    (test (fv146) 24)
    
    (define (fv147a)
      (let ((x 0)
	    (lst '(1 2 3)))
	(for-each
	 (lambda (y)
	   (if (= x y) (display "fv147 oops")))
	 lst)))
    (test (fv147a) #<unspecified>)
    
    (define (fv147b)
      (let ((s "012345")
	    (lst '(1 2 3)))
	(map
	 (lambda (y)
	   (string-ref s y))
	 lst)))
    (test (fv147b) '(#\1 #\2 #\3))

    (define (fv147c)
      (let ((lst '(1 2 3)))
	(map
	 (lambda (y)
	   (* y 2.0))
	 lst)))
    (test (fv147c) '(2.0 4.0 6.0))

    (define (fv148)
      (do ((g0 (list 0 1 2 3 4))
	   (v (make-vector 4))
	   (i 0 (+ i 1)))
	  ((= i 4) v)
	(vector-set! v i (g0 i))))
    (test (fv148) (vector 0 1 2 3))
    
    (define (fv149)
      (do ((g0 "012345")
	   (v (make-vector 4))
	   (i 0 (+ i 1)))
	  ((= i 4) v)
	(vector-set! v i (g0 i))))
    (test (fv149) (vector #\0 #\1 #\2 #\3))
    
    (define (fv150)
      (do ((g0 #i(0 1 2 3 4))
	   (v (make-vector 4))
	   (i 0 (+ i 1)))
	  ((= i 4) v)
	(vector-set! v i (g0 i))))
    (test (fv150) (vector 0 1 2 3))
    
    (define (fv151)
      (do ((g0 #r(0 1 2 3 4))
	   (v (make-vector 4))
	   (i 0 (+ i 1)))
	  ((= i 4) v)
	(vector-set! v i (g0 i))))
    (test (fv151) (vector 0 1 2 3))
    
    (define (fv152)
      (do ((g0 (inlet 'a 0 'b 1 'c 2 'd 3))
	   (syms (vector 'a 'b 'c 'd))
	   (v (make-vector 4))
	   (i 0 (+ i 1)))
	  ((= i 4) v)
	(vector-set! v i (g0 (syms i)))))
    (test (fv152) (vector 0 1 2 3))

    (define (fv153)
      (do ((g0 (list 0 1 2 3 4))
	   (v (make-list 4 #f))
	   (i 0 (+ i 1)))
	  ((= i 4) v)
	(set! (v i) (g0 i))))
    (test (fv153) (list 0 1 2 3))
    
    (define (fv154)
      (do ((g0 "012345")
	   (v (make-string 4))
	   (i 0 (+ i 1)))
	  ((= i 4) v)
	(set! (v i) (g0 i))))
    (test (fv154) "0123")
    
    (define (fv155)
      (do ((g0 #i(0 1 2 3 4))
	   (v (make-int-vector 4 -1))
	   (i 0 (+ i 1)))
	  ((= i 4) v)
	(set! (v i) (g0 i))))
    (test (fv155) #i(0 1 2 3))
    
    (define (fv156)
      (do ((g0 #r(0 1 2 3 4))
	   (v (make-float-vector 4 pi))
	   (i 0 (+ i 1)))
	  ((= i 4) v)
	(set! (v i) (g0 i))))
    (test (fv156) #r(0 1 2 3))
    
    (define (fv157)
      (do ((g0 (inlet 'a 0 'b 1 'c 2 'd 3))
	   (syms (vector 'a 'b 'c 'd))
	   (v (inlet 'a -1 'b -1 'c -1 'd -1))
	   (i 0 (+ i 1)))
	  ((= i 4) v)
	(set! (v (syms i)) (g0 (syms i)))))
    (test (fv157) (inlet 'a 0 'b 1 'c 2 'd 3))
    
    (define (fv158)
      (do ((g0 (hash-table 'a 0 'b 1 'c 2 'd 3))
	   (syms (vector 'a 'b 'c 'd))
	   (v (hash-table 'a -1 'b -1 'c -1 'd -1))
	   (i 0 (+ i 1)))
	  ((= i 4) v)
	(set! (v (syms i)) (g0 (syms i)))))
    (test (fv158) (hash-table 'a 0 'b 1 'c 2 'd 3))

    (define (fv160)
      (do ((fv (make-float-vector 4))
	   (g (make-oscil 1000))
	   (i 0 (+ i 1))
	   (x 0.1 0.0))
	  ((= i 4) fv)
	(float-vector-set! fv i (oscil g x))))
    
    (test (fv160) (let ((g (make-oscil 1000))) (float-vector (oscil g 0.1) (oscil g) (oscil g) (oscil g))))

    (define (fv162)
      (do ((fv (make-int-vector 4))
	   (iter (make-iterator '(1 2 3 4)))
	   (i 0 (+ i 1)))
	  ((= i 4) fv)
	(int-vector-set! fv i (iterate iter))))
    (test (fv162) #i(1 2 3 4))

    (define (fv163)
      (do ((fv (make-float-vector 4))
	   (i 0 (+ i 1))
	   (x 0.0 (+ x 0.25)))
	  ((= i 4) fv)
	(set! (fv i) (sin x))))
    (test (fv163) (float-vector 0.0 (sin 0.25) (sin 0.5) (sin 0.75)))

    (define (fv165) (do ((fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (+ 4.5 3/2))))
    (test (fv165) (make-float-vector 4 6.0))
    
    (define (fv166) (do ((x 1/2) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (+ 1 x))))
    (test (fv166) (make-float-vector 4 1.5))
    
    (define (fv167) (do ((fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) 6.0)))
    (test (fv167) (make-float-vector 4 6.0))
    
    (define (fv168) (do ((x 1.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (+ x 5.0))))
    (test (fv168) (make-float-vector 4 6.0))
    
    (define (fv169) (do ((x 1.0) (y 5.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (+ x y))))
    (test (fv169) (make-float-vector 4 6.0))
    
    (define (fv170) (do ((x 1.0) (y 6.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (+ x y -1.0))))
    (test (fv170) (make-float-vector 4 6.0))
    
    (define (fv171) (do ((x 1.0) (y 6.0) (z -1.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (+ x y z))))
    (test (fv171) (make-float-vector 4 6.0))
    
    (define (fv173) (do ((x 3.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (+ x (abs x)))))
    (test (fv173) (make-float-vector 4 6.0))
    
    (define (fv174) (do ((x 2.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (+ x 2 (abs x)))))
    (test (fv174) (make-float-vector 4 6.0))
    
    (define (fv175) (do ((x 2.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (+ 2.0 2 (abs x)))))
    (test (fv175) (make-float-vector 4 6.0))
    
    (define (fv178) (do ((x 2.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (+ (abs x) x (abs x)))))
    (test (fv178) (make-float-vector 4 6.0))
    
    (define (fv178c) (do ((x 2.0) (y 2.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (+ (abs x) x y))))
    (test (fv178c) (make-float-vector 4 6.0))
    
    
    (define (fv179) (do ((fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (* 1.0 2.0 3.0))))
    (test (fv179) (make-float-vector 4 6.0))
    
    (define (fv180) (do ((x 1.0) (y 6.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (* x y -1.0))))
    (test (fv180) (make-float-vector 4 -6.0))
    
    (define (fv181) (do ((x 1.0) (y 6.0) (z -1.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (* x y z))))
    (test (fv181) (make-float-vector 4 -6.0))
    
    (define (fv182) (do ((x 1.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (* x -1.0 6.0))))
    (test (fv182) (make-float-vector 4 -6.0))
    
    (define (fv183) (do ((x 3.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (* x (abs x)))))
    (test (fv183) (make-float-vector 4 9.0))
    
    (define (fv184) (do ((x 2.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (* x 2 (abs x)))))
    (test (fv184) (make-float-vector 4 8.0))
    
    (define (fv185) (do ((x 2.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (* 2.0 2 (abs x)))))
    (test (fv185) (make-float-vector 4 8.0))
    
    (define (fv188) (do ((x 2.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (* (abs x) x (abs x)))))
    (test (fv188) (make-float-vector 4 8.0))
    
    (define (fv188c) (do ((x 2.0) (y 2.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (* (abs x) x y))))
    (test (fv188c) (make-float-vector 4 8.0))
    
    (define (fv189) (do ((fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (* 4.5 3/2))))
    (test (fv189) (make-float-vector 4 6.75))
    
    (define (fv190) (do ((x 1/2) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) x)))
    (test (fv190) (make-float-vector 4 0.5))
    
    (define (fv192) (do ((x 1.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (* x 5.0))))
    (test (fv192) (make-float-vector 4 5.0))
    
    (define (fv193) (do ((x 1.0) (y 5.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (* x y))))
    (test (fv193) (make-float-vector 4 5.0))

    (define (fvi165) (do ((fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (+ 4.5 3/2))))
    (test (catch #t fvi165 (lambda args 'error)) 'error)
    
    (define (fvi166) (do ((x 1/2) (fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (+ 1 x))))
    (test (catch #t fvi166 (lambda args 'error))'error)
    
    (define (fvi167) (do ((fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) 6)))
    (test (fvi167) (make-int-vector 4 6))
    
    (define (fvi168) (do ((x 1) (fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (+ x 5))))
    (test (fvi168) (make-int-vector 4 6))
    
    (define (fvi169) (do ((x 1) (y 5) (fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (+ x y))))
    (test (fvi169) (make-int-vector 4 6))
    
    (define (fvi170) (do ((x 1) (y 6) (fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (+ x y -1))))
    (test (fvi170) (make-int-vector 4 6))
    
    (define (fvi171) (do ((x 1) (y 6) (z -1) (fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (+ x y z))))
    (test (fvi171) (make-int-vector 4 6))
    
    (define (fvi173) (do ((x 3) (fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (+ x (abs x)))))
    (test (fvi173) (make-int-vector 4 6))
    
    (define (fvi174) (do ((x 2) (fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (+ x 2 (abs x)))))
    (test (fvi174) (make-int-vector 4 6))
    
    (define (fvi178) (do ((x 2) (fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (+ (abs x) x (abs x)))))
    (test (fvi178) (make-int-vector 4 6))
    
    (define (fvk178) (do ((x 2) (y 2) (fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (+ (abs x) x y))))
    (test (fvk178) (make-int-vector 4 6))
    
    (define (fvi181) (do ((x 1) (y 6) (z -1) (fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (* x y z))))
    (test (fvi181) (make-int-vector 4 -6))
    
    (define (fvi183) (do ((x 3) (fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (* x (abs x)))))
    (test (fvi183) (make-int-vector 4 9))
    
    (define (fvi184) (do ((x 2) (fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (* x 2 (abs x)))))
    (test (fvi184) (make-int-vector 4 8))
    
    (define (fvi188) (do ((x 2) (fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (* (abs x) x (abs x)))))
    (test (fvi188) (make-int-vector 4 8))
    
    (define (fvk188) (do ((x 2) (y 2) (fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (* (abs x) x y))))
    (test (fvk188) (make-int-vector 4 8))
    
    (define (fvi192) (do ((x 1) (fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (* x 5))))
    (test (fvi192) (make-int-vector 4 5))
    
    (define (fvi193) (do ((x 1) (y 5) (fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (* x y))))
    (test (fvi193) (make-int-vector 4 5))
    
    (define (fv198) (do ((fv (make-float-vector 4))
			  (a 1.0) (b 2.0) (c 4.0)
			  (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (+ a b 3.0 c a c b c a b c a b c a b c a b c a b c))))
    (test (fv198) (make-float-vector 4 56.0))

    (define (fv164b) (do ((fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (- 1.0 2.0 3.0))))
    (test (fv164b) (make-float-vector 4 -4.0))
    
    (define (fv165b) (do ((fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (- 4.5 3/2))))
    (test (fv165b) (make-float-vector 4 3.0))
    
    (define (fv166b) (do ((x 1/2) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (- 1 x))))
    (test (fv166b) (make-float-vector 4 .5))
    
    (define (fv168b) (do ((x 1.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (- x 5.0))))
    (test (fv168b) (make-float-vector 4 -4.0))
    
    (define (fv169b) (do ((x 1.0) (y 5.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (- x y))))
    (test (fv169b) (make-float-vector 4 -4.0))
    
    (define (fv170b) (do ((x 1.0) (y 6.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (- x y -1.0))))
    (test (fv170b) (make-float-vector 4 -4.0))
    
    (define (fv171b) (do ((x 1.0) (y 6.0) (z -1.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (- x y z))))
    (test (fv171b) (make-float-vector 4 -4.0))
    
    (define (fv172b) (do ((x 1.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (- x -1.0 6.0))))
    (test (fv172b) (make-float-vector 4 -4.0))
    
    (define (fv173b) (do ((x 3.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (- x (abs x)))))
    (test (fv173b) (make-float-vector 4))
    
    (define (fv174b) (do ((x 2.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (- x 2 (abs x)))))
    (test (fv174b) (make-float-vector 4 -2.0))
    
    (define (fv178bb) (do ((x 2.0) (y 2.0) (fv (make-float-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (- (abs x) x y))))
    (test (fv178bb) (make-float-vector 4 -2.0))
    
    (define (fvi165a) (do ((fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (- 4.5 3/2))))
    (test (catch #t fvi165a (lambda args 'error)) 'error)
    
    (define (fvi166a) (do ((x 1/2) (fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (- 1 x))))
    (test (catch #t fvi166a (lambda args 'error))'error)
    
    (define (fvi167a) (do ((fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) -6)))
    (test (fvi167a) (make-int-vector 4 -6))
    
    (define (fvi168a) (do ((x 1) (fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (- x 5))))
    (test (fvi168a) (make-int-vector 4 -4))
    
    (define (fvi169a) (do ((x 1) (y 5) (fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (- x y))))
    (test (fvi169a) (make-int-vector 4 -4))
    
    (define (fvi170a) (do ((x 1) (y 6) (fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (- x y -1))))
    (test (fvi170a) (make-int-vector 4 -4))
    
    (define (fvi171a) (do ((x 1) (y 6) (z -1) (fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (- x y z))))
    (test (fvi171a) (make-int-vector 4 -4))
    
    (define (fvi173a) (do ((x 3) (fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (- x (abs x)))))
    (test (fvi173a) (make-int-vector 4))
    
    (define (fvi174a) (do ((x 2) (fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (- x 2 (abs x)))))
    (test (fvi174a) (make-int-vector 4 -2))
    
    (define (fvi178aa) (do ((x 2) (y 2) (fv (make-int-vector 4)) (i 0 (+ i 1))) ((= i 4) fv) (set! (fv i) (- (abs x) x y))))
    (test (fvi178aa) (make-int-vector 4 -2))

    ))



;;; ---------------- test 22: with-sound ----------------

(require snd-prc95.scm snd-jcrev.scm snd-maraca.scm snd-singer.scm snd-strad.scm snd-noise.scm snd-clm-ins.scm snd-jcvoi.scm)
(require snd-piano.scm snd-play.scm snd-zip.scm snd-clm23.scm snd-freeverb.scm snd-grani.scm snd-animals.scm snd-big-gens.scm)
(require snd-dlocsig.scm snd-sndwarp.scm snd-tankrev.scm)

(defgenerator st1 one two)
(defgenerator st2 (one 11) (two 22))
(defgenerator grab-bag 
  (flt 0.0)
  (flt1 1.0)
  (i 0)
  (i1 123)
  (bool #f)
  (bool1 #t)
  (ch #\c)
  (ch1 #\c)
  (str "hi")
  (str1 "hi1")
  (lst ())
  (sym 'hi)
  (v #f)
  (rd #f)
  (mxrd #f)
  (sd #f)
  (gen #f)
  (fvect #f)
  (ivect #f)
  (vvect #f)
  (cvect #f))

(define (snd_test_22)
  
  (definstrument (green3 start dur freq amp amp-env noise-freq noise-width noise-max-step)
    ;; brownian noise on amp env
    (let ((grn (make-green-noise-interp :frequency noise-freq :amplitude noise-max-step :high (* 0.5 noise-width) :low (* -0.5 noise-width)))
	  (osc (make-oscil freq))
	  (e (make-env amp-env :scaler amp :duration dur))
	  (beg (floor (* start *clm-srate*)))
	  (end (floor (* (+ start dur) *clm-srate*))))
      (do ((i beg (+ i 1)))
	  ((= i end))
	(outa i (* (env e) 
		   (+ 1.0 (green-noise-interp grn 0.0))
		   (oscil osc))))))
  
					;(with-sound () (green3 0 2.0 440 .5 '(0 0 1 1 2 1 3 0) 100 .2 .02))
  
  (definstrument (green4 start dur freq amp freq-env gliss noise-freq noise-width noise-max-step)
    ;; same but on freq env
    (let ((grn (make-green-noise-interp :frequency noise-freq 
					:amplitude (hz->radians noise-max-step)
					:high (hz->radians (* 0.5 noise-width))
					:low (hz->radians (* -0.5 noise-width))))
	  (osc (make-oscil freq))
	  (e (make-env freq-env :scaler (hz->radians gliss) :duration dur))
	  (beg (seconds->samples start))
	  (end (seconds->samples (+ start dur))))
      (do ((i beg (+ i 1)))
	  ((= i end))
	(outa i (* amp (oscil osc (+ (env e) (green-noise-interp grn 0.0))))))))
  
  (define (ws-sine freq)
    (do ((o (make-oscil freq))
	 (i 0 (+ i 1)))
	((= i 100))
      (outa i (oscil o))))
  
  (define (step-src)
    (let ((tempfile (with-sound ((snd-tempnam) :srate (srate) :to-snd #f :comment "step-src")
		      (let ((o (make-oscil 2205.0))
			    (rd (make-sampler 0)))	     
			(do ((s (make-src :srate 0.0 :input rd))
			     (incr (+ 2.0 (oscil o)))
			     (samp 0 (+ samp 1)))
			    ((sampler-at-end? rd))
			  (outa samp (src s incr))
			  (if (= (modulo samp 2205) 0)
			      (set! incr (+ 2.0 (oscil o)))))))))
      (set-samples 0 (- (mus-sound-framples tempfile) 1) tempfile #f #f #t "step-src" 0 #f #t)))
  
  (define* (clm-reverb-sound reverb-amount reverb (reverb-data ()) snd)
    (let ((output (snd-tempnam))
	  (revout (snd-tempnam))
	  (len (+ (framples snd) (srate snd))))
      (scale-by (- 1.0 reverb-amount) snd)
      (save-sound-as output snd)
      (undo 1 snd)
      (scale-by reverb-amount snd)
      (save-sound-as revout snd)
      (undo 1 snd)
      (dynamic-wind
	  (lambda ()
	    (set! *output* (continue-sample->file output))
	    (set! *clm-srate* (srate snd))
	    (set! *reverb* (make-file->sample revout)))
	  (lambda ()
	    (apply reverb reverb-data))
	  (lambda ()
	    (mus-close *reverb*)
	    (mus-close *output*)
	    (set! *reverb* #f)
	    (set! *output* #f)
	    (delete-file revout)
	    (set! (samples 0 len snd #f #f #f 0 #f #t) output)))))
  
  (define* (optkey-1 a) a)
  (define* (optkey-2 (a 3) b) (list a b))
  (define* (optkey-3 a b c) (list a b c))
  (define* (optkey-4 (a 1) (b 2) (c 3) d) (list a b c d))
  
  (define (fir+comb beg dur freq amp size)
    (let ((dly (make-comb :scaler .9 :size size)))
      (let ((start (floor (* *clm-srate* beg)))
	    (end (floor (* *clm-srate* (+ beg dur))))
	    (flt (make-fir-filter :order size :xcoeffs (mus-data dly))) 
	    (r (make-rand freq)))
	(do ((i start (+ i 1))) 
	    ((= i end)) 
	  (outa i (* amp (fir-filter flt (comb dly (rand r)))))))))
  
  (definstrument (dloc-sinewave start-time duration freq amp 
				(amp-env '(0 1 1 1))
				(path (make-path :path '(-10 10 0 5 10 10))))
    (let ((vals (make-dlocsig :start-time start-time
			      :duration duration
			      :path path)))
      (let ((dloc (car vals))
	    (beg (cadr vals))
	    (end (caddr vals)))
	(do ((osc (make-oscil :frequency freq))
	     (aenv (make-env :envelope amp-env :scaler amp :duration duration))
	     (i beg (+ i 1)))
	    ((= i end))
	  (dlocsig dloc i (* (env aenv) (oscil osc)))))))
  
  (definstrument (dlocsig-sinewave-1 start-time duration freq amp 
				     (amp-env '(0 1 1 1))
				     (path (make-path :path '(-10 10 0 5 10 10)))
				     (decode amplitude-panning)
				     initdly)
    (let ((vals (make-dlocsig :start-time start-time
			      :duration duration
			      :render-using decode
			      :initial-delay initdly
			      :path path)))
      (let ((dloc (car vals))
	    (beg (cadr vals))
	    (end (caddr vals)))
	(do ((osc (make-oscil :frequency freq))
	     (aenv (make-env :envelope amp-env :scaler amp :duration duration))
	     (i beg (+ i 1)))
	    ((= i end))
	  (dlocsig dloc i (* (env aenv) (oscil osc)))))))
  
  (define (mix-move-sound start-time file path)
    (let* ((rd (make-sampler 0 file))
	   (start (round (* *clm-srate* start-time)))
	   (tmp-sound (with-temp-sound (:channels 4 :srate (mus-sound-srate file))
				       (let ((vals (make-dlocsig :start-time 0
								 :duration (mus-sound-duration file)
								 :path path)))
					 (let ((dloc (car vals))
					       (beg (cadr vals))
					       (end (caddr vals)))
					   (do ((i beg (+ i 1)))
					       ((= i end))
					     (dlocsig dloc i (read-sample rd))))))))
      (mix tmp-sound start #t #f #f *with-mix-tags* #t)))
  
  (definstrument (defopt-simp beg dur (frequency 440.0) (amplitude 0.1))
    (do ((os (make-oscil frequency))
	 (end (+ beg dur))
	 (i beg (+ i 1))) ((= i end))
      (outa i (* amplitude (oscil os)))))
  
  (definstrument (jcrev2)
    (let ((allpass11 (make-all-pass -0.700 0.700 1051))
	  (allpass21 (make-all-pass -0.700 0.700  337))
	  (allpass31 (make-all-pass -0.700 0.700  113))
	  (comb11 (make-comb 0.742 4799))
	  (comb21 (make-comb 0.733 4999))
	  (comb31 (make-comb 0.715 5399))
	  (comb41 (make-comb 0.697 5801))
	  (outdel11 (make-delay (seconds->samples .01)))
	  
	  (allpass12 (make-all-pass -0.700 0.700 1051))
	  (allpass22 (make-all-pass -0.700 0.700  337))
	  (allpass32 (make-all-pass -0.700 0.700  113))
	  (comb12 (make-comb 0.742 4799))
	  (comb22 (make-comb 0.733 4999))
	  (comb32 (make-comb 0.715 5399))
	  (comb42 (make-comb 0.697 5801))
	  (outdel12 (make-delay (seconds->samples .01)))
	  (len (floor (+ (framples *reverb*) *clm-srate*))))
      
      (let ((combs1 (make-comb-bank (vector comb11 comb21 comb31 comb41)))
	    (combs2 (make-comb-bank (vector comb12 comb22 comb32 comb42)))
	    (allpasses1 (make-all-pass-bank (vector allpass11 allpass21 allpass31)))
	    (allpasses2 (make-all-pass-bank (vector allpass12 allpass22 allpass32))))
	(do ((i 0 (+ i 1)))
	    ((= i len))
	  (outa i (delay outdel11 (comb-bank combs1 (all-pass-bank allpasses1 (ina i *reverb*))))))
	(do ((i 0 (+ i 1)))
	    ((= i len))
	  (outb i (delay outdel12 (comb-bank combs2 (all-pass-bank allpasses2 (inb i *reverb*)))))))))
  
  
  (definstrument (floc-simp beg dur (amp 0.5) (freq 440.0) (ramp 2.0) (rfreq 1.0) offset)
    (let ((os (make-pulse-train freq amp))
	  (floc (make-flocsig :reverb-amount 0.1
			      :frequency rfreq
			      :amplitude ramp
			      :offset offset))
	  (start (seconds->samples beg))
	  (end (seconds->samples (+ beg dur))))
      (do ((i start (+ i 1))) 
	  ((= i end))
	(flocsig floc i (pulse-train os)))))
  
  (dismiss-all-dialogs)
  
  ;; start of test 22
  (do ((clmtest 0 (+ 1 clmtest))) ((= clmtest tests)) 
    (log-mem clmtest)
    
					;    (set! *clm-notehook* (lambda args (display args) (newline)))
    ;; check clm output for bad zero case
    (for-each
     (lambda (type)
       (let ((mx (maxamp
		  (find-sound 
		    (with-sound (:sample-type type :srate 22050)
		      (fm-violin 0 .1 440 .1)
		      (fm-violin 10 .1 440 .1)
		      (fm-violin 100 .1 440 .1)
		      (fm-violin 250 .1 440 .1))))))
	 (if (ffneq mx .1) ; mus-byte -> 0.093
	     (snd-display "max: ~A, format: ~A" mx (mus-sample-type->string type)))))
     (list mus-bshort   mus-lshort   mus-mulaw   mus-alaw   mus-byte  
	   mus-lfloat   mus-bint     mus-lint    mus-b24int mus-l24int
	   mus-ubshort  mus-ulshort  mus-ubyte   mus-bfloat mus-bdouble 
	   mus-ldouble))

    (with-sound () (fm-violin 0 .1 440 .1))
    (with-sound (:continue-old-file #t) (fm-violin .2 .1 660 .04))
    (let ((ind (find-sound "test.snd")))
      (if (fneq (maxamp ind 0) .1) (snd-display "maxamp after continued sound: ~A" (maxamp ind 0)))
      (if (fneq (/ (framples ind) (srate ind)) .3) (snd-display "duration after continued sound: ~A" (/ (framples ind) (srate ind))))
      (close-sound ind))
    
    (with-sound (:srate 22050 :channels 2 :output "test1.snd") (fm-violin 0 .1 440 .1 :degree 45.0))
    (let ((ind (find-sound "test1.snd")))
      (if (not ind) (snd-display "with-sound (1): ~A" (map file-name (sounds))))
      (let ((mx (maxamp)))
	(if (fneq mx .05) (snd-display "with-sound max (1): ~A" (maxamp))))
      (if (not (= (srate ind) 22050 (mus-sound-srate "test1.snd")))
	  (snd-display "with-sound srate (1): ~A (~A, ~A)" (srate ind) *clm-srate* (mus-sound-srate "test1.snd")))
      (if (not (member (framples ind) '(2205 2206) =))
	  (snd-display "with-sound framples (1): ~A" (framples ind)))
      (if (not (= (chans ind) 2 (mus-sound-chans "test1.snd")))
	  (snd-display "with-sound chans (1): ~A" (chans ind)))
      (close-sound ind)
      (delete-file "test1.snd"))
    
    (with-sound (:srate 48000 :channels 2 :header-type mus-riff :sample-type mus-lshort :output "test1.snd") (fm-violin 0 .1 440 .1))
    (let ((ind (find-sound "test1.snd")))
      (if (not (= (srate ind) 48000 (mus-sound-srate "test1.snd")))
	  (snd-display "with-sound srate (48000, r): ~A (~A, ~A)" (srate ind) *clm-srate* (mus-sound-srate "test1.snd")))
      (if (not (= (header-type ind) mus-riff)) (snd-display "with-sound type (~A, r): ~A" mus-riff (header-type ind)))
      (if (not (= (chans ind) 2)) (snd-display "with-sound chans (2, r): ~A" (chans ind)))
      (close-sound ind)
      (delete-file "test1.snd"))
    
    (with-sound (:srate 48000 :channels 2 :header-type mus-rf64 :sample-type mus-lshort :output "test1.snd") (fm-violin 0 .1 440 .1))
    (let ((ind (find-sound "test1.snd")))
      (if (not (= (srate ind) 48000 (mus-sound-srate "test1.snd")))
	  (snd-display "with-sound srate (48000, r): ~A (~A, ~A)" (srate ind) *clm-srate* (mus-sound-srate "test1.snd")))
      (if (not (= (header-type ind) mus-rf64)) (snd-display "with-sound type (~A, r): ~A" mus-rf64 (header-type ind)))
      (if (not (= (chans ind) 2)) (snd-display "with-sound chans (2, r): ~A" (chans ind)))
      (close-sound ind)
      (delete-file "test1.snd"))
    
    (with-sound (:srate 48000 :channels 2 :header-type mus-caff :sample-type mus-lshort :output "test1.snd") (fm-violin 0 .1 440 .1))
    (let ((ind (find-sound "test1.snd")))
      (if (not (= (srate ind) 48000 (mus-sound-srate "test1.snd")))
	  (snd-display "with-sound mus-caff srate (48000, r): ~A (~A, ~A)" (srate ind) *clm-srate* (mus-sound-srate "test1.snd")))
      (if (not (= (header-type ind) mus-caff)) (snd-display "with-sound type (~A, r): ~A" mus-caff (header-type ind)))
      (if (not (= (chans ind) 2)) (snd-display "with-sound mus-caff chans (2, r): ~A" (chans ind)))
      (close-sound ind)
      (delete-file "test1.snd"))
    
    (with-sound (:srate 8000 :channels 3 :header-type mus-next :output "test1.snd") (fm-violin 0 .1 440 .1))
    (let ((ind (find-sound "test1.snd")))
      (if (not (= (srate ind) 8000)) (snd-display "with-sound srate (8000, s): ~A (~A, ~A)" 
						  (srate ind) *clm-srate* (mus-sound-srate "test1.snd")))
      (if (not (= (header-type ind) mus-next)) (snd-display "with-sound type (~A, s): ~A" mus-next (header-type ind)))
      (if (not (= (chans ind) 3)) (snd-display "with-sound chans (3, s): ~A" (chans ind)))
      (close-sound ind)
      (delete-file "test1.snd"))
    
    (with-sound (:srate 96000 :channels 4 :header-type mus-aifc :output "test1.snd") (fm-violin 0 .1 440 .1))
    (let ((ind (find-sound "test1.snd")))
      (if (not (= (srate ind) 96000)) (snd-display "with-sound srate (96000, t): ~A (~A, ~A)" 
						   (srate ind) *clm-srate* (mus-sound-srate "test1.snd")))
      (if (not (= (header-type ind) mus-aifc)) (snd-display "with-sound type (~A, t): ~A" mus-aifc (header-type ind)))
      (if (not (= (chans ind) 4)) (snd-display "with-sound chans (4, t): ~A" (chans ind)))
      (close-sound ind)
      (delete-file "test1.snd"))
    
    (with-sound (:srate 22050 :channels 1 :header-type mus-raw :output "test1.snd") (fm-violin 0 .1 440 .1))
    (let ((ind (find-sound "test1.snd")))
      (if (not (= (srate ind) 22050)) (snd-display "with-sound srate (22050, u): ~A (~A, ~A)" 
						   (srate ind) *clm-srate* (mus-sound-srate "test1.snd")))
      (if (not (= (header-type ind) mus-raw)) (snd-display "with-sound type (~A, u): ~A" mus-raw (header-type ind)))
      (if (not (= (chans ind) 1)) (snd-display "with-sound chans (1, u): ~A" (chans ind)))
      (close-sound ind)
      (delete-file "test1.snd"))
    
    (with-sound (:srate 22050 :channels 2 :output "test1.snd" :reverb jc-reverb) 
      (if (not (= (mus-sound-srate (mus-file-name *output*)) 22050))
	  (snd-display "srate file *output*: ~A" (mus-sound-srate (mus-file-name *output*))))
      (if (not (= (mus-sound-srate (mus-file-name *reverb*)) 22050))
	  (snd-display "srate file *reverb*: ~A" (mus-sound-srate (mus-file-name *reverb*))))
      (fm-violin 0 .1 440 .1 :degree 45.0))
    (let ((ind (find-sound "test1.snd")))
      (if (not ind) (snd-display "with-sound (2): ~A" (map file-name (sounds)))
	  (if (> (framples ind) 24256) (snd-display "with-sound reverbed framples (2): ~A" (framples ind))))
      (close-sound ind))
    
    (with-sound (:srate 22050 :comment "Snd+Run!" :scaled-to .5) (fm-violin 0 .1 440 .1))
    (let ((ind (find-sound "test.snd")))
      (if (not ind) (snd-display "with-sound: ~A" (map file-name (sounds))))
      (let ((mx (maxamp)))
	(if (fneq mx .5) (snd-display "with-sound scaled-to: ~A" (maxamp)))
	(if (not (string=? (comment ind) "Snd+Run!")) (snd-display "with-sound comment: ~A (~A)" (comment ind) (mus-sound-comment "test.snd"))))
      (close-sound ind))
    
    (with-sound (:scaled-to .9 :channels 2) (fm-violin 0 .1 440 1.5 :degree 90))
    (let ((ind (find-sound "test.snd")))
      (if (not ind) (snd-display "with-sound: ~A" (map file-name (sounds))))
      (let ((mx0 (maxamp ind 0))
	    (mx1 (maxamp ind 1)))
	(if (> (max mx0 mx1) .9)
	    (snd-display "with-sound scaled-to: ~A" (maxamp))))
      (close-sound ind))
    
    (with-sound (:scaled-to .9 :channels 2) (fm-violin 0 .1 440 1.5 :degree 0))
    (let ((ind (find-sound "test.snd")))
      (if (not ind) (snd-display "with-sound: ~A" (map file-name (sounds))))
      (let ((mx0 (maxamp ind 0))
	    (mx1 (maxamp ind 1)))
	(if (> (max mx0 mx1) .9)
	    (snd-display "with-sound scaled-to: ~A" (maxamp))))
      (close-sound ind))
    
    (with-sound (:srate 22050 :scaled-by .5 :header-type mus-aifc :sample-type mus-bfloat) (fm-violin 0 .1 440 .1))
    (let ((ind (find-sound "test.snd")))
      (if (not ind) (snd-display "with-sound: ~A" (map file-name (sounds))))
      (let ((mx (maxamp)))
	(if (fneq mx .05) (snd-display "with-sound scaled-by: ~A" (maxamp)))
	(if (not (= (header-type ind) mus-aifc)) (snd-display "with-sound type: ~A (~A)" (header-type ind) (mus-header-type-name (header-type ind))))
	(if (not (= (sample-type ind) mus-bfloat)) (snd-display "with-sound format: ~A (~A)" (sample-type ind) (mus-sample-type-name (sample-type ind)))))
      (close-sound ind))
    
    (hook-push open-raw-sound-hook (lambda (hook) (set! (hook 'result) (list 1 22050 mus-bshort))))
    (with-sound (:header-type mus-raw) (fm-violin 0 1 440 .1))
    (set! (hook-functions open-raw-sound-hook) ())
    (let ((ind (find-sound "test.snd")))
      (if (not ind) (snd-display "with-sound (raw out): ~A" (map file-name (sounds))))
      (if (not (= (header-type ind) mus-raw)) 
	  (snd-display "with-sound type raw: ~A (~A)" (header-type ind) (mus-header-type-name (header-type ind))))
      (if (not (or (= (sample-type ind) mus-bshort)
		   (= (sample-type ind) mus-bfloat)
		   (= (sample-type ind) mus-lfloat)))
	  (snd-display "with-sound format raw: ~A (~A)" (sample-type ind) (mus-sample-type-name (sample-type ind))))
      (close-sound ind))
    
    (with-sound (:srate 44100 :statistics #t) (ws-sine 1000))
    (let ((ind (find-sound "test.snd")))
      (let ((i -1))
	(scan-channel (lambda (y)
			(set! i (+ i 1))
			(and (< i 100)
			     (fneq y (sin (/ (* 2 pi i 1000.0) 44100.0)))
			     (begin
			       (format () "~%;with-sound sine: ~D ~A ~A" i y (sin (/ (* 2 pi i 1000.0) 44100.0)))
			       #t)))))
      (close-sound ind))
    
    (with-sound ()
      (do ((i 0 (+ i 1)))
	  ((= i 3))
	(let ((gen (make-oscil 440.0))
	      (e (make-env #r(0.0 0.0 1.0 1.0 2.0 0.0) 0.1 1.0))
	      (beg (* i 50000))
	      (end (+ 44100 (* i 50000))))
	  (do ((k beg (+ k 1)))
	      ((= k end))
	    (outa k (* (env e) (oscil gen)))))))
    
    (let ((ind (find-sound "test.snd")))
      (if (> (abs (- (framples ind) 144100)) 2)
	  (snd-display "with-sound make-oscil framples: ~A" (framples)))
      (if (fneq (maxamp ind) .1)
	  (snd-display "with-sound make-oscil maxamp: ~A" (maxamp ind)))
      (close-sound ind))
    
    (for-each close-sound (sounds))

    (when (file-exists? "ii.scm")
      (time (load "ii.scm"))
      (for-each close-sound (sounds))
      (delete-file "test.snd")
      (delete-file "test.rev"))
    
    (let ((var (make-st1 :one 1 :two 2)))
      (if (not (= (var 'one) 1)) (snd-display "st1-one: ~A" (var 'one)))
      (if (not (= (var 'two) 2)) (snd-display "st1-two: ~A" (var 'two)))
      (if (not (st1? var)) (snd-display "st1? ~A (~A)" (st1? var) var))
      (set! (var 'one) 321)
      (set! (var 'two) "hiho")
      (if (not (= (var 'one) 321)) (snd-display "st1-one (321): ~A" (var 'one)))
      (if (not (string=? (var 'two) "hiho")) (snd-display "st1-two (hiho): ~A" (var 'two))))
    (let ((var (make-st1)))
      (if (fneq (var 'one) 0.0) (snd-display "st1-one #f: ~A" (var 'one)))
      (if (fneq (var 'two) 0.0) (snd-display "st1-two #f: ~A" (var 'two))))
    (let ((var (make-st1 :two 3)))
      (if (fneq (var 'one) 0.0) (snd-display "st1-one #f (def): ~A" (var 'one)))  
      (if (not (= (var 'two) 3)) (snd-display "st1-two (3): ~A" (var 'two))))

    (let ((var (make-st2 :one 1 :two 2)))
      (if (not (= (var 'one) 1)) (snd-display "st2-one: ~A" (var 'one)))
      (if (not (= (var 'two) 2)) (snd-display "st2-two: ~A" (var 'two)))
      (if (not (st2? var)) (snd-display "st2? ~A (~A)" (st1? var) var))
      (if (st1? var) (snd-display "st1? (not ~A): ~A" (st1? var) var))
      (set! (var 'one) 321)
      (set! (var 'two) "hiho")
      (if (not (= (var 'one) 321)) (snd-display "st2-one (321): ~A" (var 'one)))
      (if (not (string=? (var 'two) "hiho")) (snd-display "st2-two (hiho): ~A" (var 'two))))
    (let ((var (make-st2)))
      (if (not (= (var 'one) 11)) (snd-display "st2-one 11: ~A" (var 'one)))
      (if (not (= (var 'two) 22)) (snd-display "st2-two 22: ~A" (var 'two))))
    (let ((var (make-st2 :two 3)))
      (if (not (= (var 'one) 11)) (snd-display "st2-one 11 (def): ~A" (var 'one)))  
      (if (not (= (var 'two) 3)) (snd-display "st2-two (3): ~A" (var 'two))))
    
    (let ((gad (make-grab-bag)))
      (if (not (= (gad 'i) 0))
	  (snd-display "grab-bag-i: ~A" (gad 'i)))
      (set! (gad 'flt) 123.0)
      (set! (gad 'v) #r(.1 .2 .3))
      (set! (gad 'fvect) (vector .1 .2 .3))
      (set! (gad 'ivect) (make-vector 3 1))
      (set! (gad 'cvect) (make-vector 3 #f))
      (do ((i 0 (+ i 1)))
	  ((= i 3))
	(vector-set! (gad 'cvect) i (make-oscil 440.0)))
      (set! (gad 'gen) (make-oscil 440.0))
      (let ((val (gad 'flt)))
	(if (fneq val 123.0) (snd-display "defgenerator flt: ~A ~A" val (gad 'flt))))
      (if (fneq (gad 'flt1) 1.0) (snd-display "defgenerator flt1: ~A" (gad 'flt1)))
      (if (not (= (gad 'i) 0)) (snd-display "defgenerator i: ~A" (gad 'i)))
      (if (not (= (gad 'i1) 123)) (snd-display "defgenerator i1: ~A" (gad 'i1))))
    
    (let ()
      (defgenerator (g1 :methods (list (cons 'g1-method (lambda (g) 440)))))
      (let ((g (make-g1)))
	(if (not (g1? g)) 
	    (format () ";not g1: ~A~%" (reverse (map values g))))
	(if (not (= ((g 'g1-method) g) 440))
	    (format () ";g1-method: ~A~%" ((g 'g1-method) g)))))
    
    (if (file-exists? "test.snd") (delete-file "test.snd"))
    (set! *clm-srate* 22050)
    (set! *default-output-srate* 22050)
    (let ((outer (with-sound () 
		   (sound-let ((a () (fm-violin 0 .1 440 .1))) 
			      (mus-file-mix *output* a)))))
      (if (not (string=? outer "test.snd"))
	  (snd-display "with-sound returns: ~A" outer))
      (let ((ind (find-sound outer)))
	(if (not (and (sound? ind)
		      (<= (- (framples ind) (floor (* *clm-srate* .1))) 1)))
	    (snd-display "sound-let: ~A ~A" (framples ind) (floor (* *clm-srate* .1))))
	(close-sound ind)))
    
    (if (file-exists? "test.snd") (delete-file "test.snd"))
    (let ((outer (with-sound () 
		   (sound-let ((a () (fm-violin 0 .1 440 .1))
			       (b 100))
			      (mus-file-mix *output* a b)
			      (sound-let ((c (:channels 1 :output "temp.snd") (fm-violin 0 .1 110.0 .1)))
					 (mus-file-mix *output* c))))))
      (if (not (string=? outer "test.snd"))
	  (snd-display "with-sound (2) returns: ~A" outer))
      (let ((ind (find-sound outer)))
	(if (or (not (sound? ind))
		(> (- (framples ind) 100 (floor (* *clm-srate* .1))) 1))
	    (snd-display "sound-let (2): ~A ~A" (framples ind) (+ 100 (floor (* *clm-srate* .1)))))
	(if (file-exists? "temp.snd")
	    (snd-display "sound-let explicit output exists?"))
	(close-sound ind)))
    
    (let ((w (init-with-sound)))
      (fm-violin 0 1 440 .1)
      (let ((outer (finish-with-sound w)))
	(if (not (string=? outer "test.snd"))
	    (snd-display "finish-with-sound returns: ~A" outer))
	(let ((ind (find-sound outer)))
	  (if (not (sound? ind))
	      (snd-display "init-with-sound: ~A" (map short-file-name (sounds)))
	      (begin
		(if (fneq (maxamp ind 0) .1)
		    (snd-display "init-with-sound max: ~A" (maxamp ind 0)))
		(close-sound ind))))))
    
    (let ((w (init-with-sound :output "test.aiff" :header-type mus-aifc :scaled-to .5)))
      (fm-violin 0 1 440 .1)
      (let ((outer (finish-with-sound w)))
	(if (not (string=? outer "test.aiff"))
	    (snd-display "finish-with-sound (2) returns: ~A ~A" outer w))
	(let ((ind (find-sound outer)))
	  (if (not (sound? ind))
	      (snd-display "init-with-sound (2): ~A" (map short-file-name (sounds)))
	      (begin
		(if (fneq (maxamp ind 0) .5)
		    (snd-display "init-with-sound scaled-to: ~A ~A" (maxamp ind 0) w))
		(if (not (= (header-type ind) mus-aifc))
		    (snd-display "init-with-sound type: ~A ~A" (header-type ind) w))
		(close-sound ind))))))
    
    (with-sound ("test1.snd" :reverb freeverb :reverb-data '(:output-gain 3.0)) (fm-violin 0 .1 440 .1 :reverb-amount .1))
    (let ((ind (find-sound "test1.snd")))
      (if (not ind) (snd-display "with-sound (freeverb): ~A" (map file-name (sounds))))
      (if (<= (maxamp ind) .1) (snd-display "freeverb 3.0: ~A" (maxamp ind)))
      (close-sound ind)
      (delete-file "test1.snd"))
    
    (with-sound ("test1.snd" :reverb freeverb :reverb-data '(:output-gain 3.0 :global 0.5)) (fm-violin 0 .1 440 .1 :reverb-amount .1))
    (let ((ind (find-sound "test1.snd")))
      (if (not ind) (snd-display "with-sound (freeverb): ~A" (map file-name (sounds))))
      (if (<= (maxamp ind) .16) (snd-display "freeverb 3.0 global 0.5: ~A" (maxamp ind)))
      (close-sound ind)
      (delete-file "test1.snd"))
    
    ;; tankrev from Anders Vinjar
    (let ((dur 3000))
      (let ((s (make-oscil 10))
	    (e (make-env `(0 ,pi 1 0) :length dur)))
	(with-sound (:reverb tank-reverb :reverb-data '(:damping 0.0 :reverb-decay-time 3.0))
	  (do ((i 0 (+ 1 i)))
	      ((= i dur))
	    (let ((sig (* 0.8 (oscil s (env e)))))
	      (outa i sig) (outb i sig)
	      (outa i (* 0.3 sig) *reverb*))))))

    (set! *clm-srate* 22050)
    (set! *default-output-srate* 22050)
    
    (let ((fmt1 '(0 1200 100 1000))
	  (fmt2 '(0 2250 100 1800))
	  (fmt3 '(0 4500 100 4500))
	  (fmt4 '(0 6750 100 8100))
	  (amp1 '(0 .67 100 .7))
	  (amp2 '(0 .95 100 .95))
	  (amp3 '(0 .28 100 .33))
	  (amp4 '(0 .14 100 .15))
	  (ind1 '(0 .75 100 .65))
	  (ind2 '(0 .75 100 .75))
	  (ind3 '(0 1 100 1))
	  (ind4 '(0 1 100 1))
	  (skwf '(0 0 100 0))
	  (ampf '(0 0 25 1 75 1 100 0))
	  (ranf '(0 .5 100 .5))
	  (index '(0 1 100 1))
	  (solid '(0 0 5 1 95 1 100 0))
	  (bassdr2 '(.5 .06 1 .62 1.5 .07 2.0 .6 2.5 .08 3.0 .56 4.0 .24 
			5 .98 6 .53 7 .16 8 .33 9 .62 10 .12 12 .14 14 .86
			16 .12 23 .14 24 .17))
	  (tenordr '(.3 .04 1 .81 2 .27 3 .2 4 .21 5 .18 6 .35 7 .03 8 .07 9 .02 10 .025 11 .035)))
      ;; a partial of .3 makes a click (or a buzz in this case) -- can this be right?
      ;;   we currently get away with it because it is normalized out of existence
      ;;   the .5 business in the bassdr2 works because it is like adding abs(sin)
      (with-sound (:reverb nrev :play #f)
	(drone  .0  4.0  115.0  (* .25 .500) solid bassdr2  .100  .500
		.030  45.0 1  .010 10)
	(drone  .0  4.0  229.0  (* .25 .500) solid tenordr  .100  .500
		.030  45.0 1  .010 11)
	(drone  .0  4.0  229.500  (* .25 .500) solid tenordr  .100  .500
		.030  45.0 1  .010 9)
	(canter  .0  2.100 918  (* .25 .700)  45.0 1  .050 ampf ranf skwf
		 .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2
		 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
	(canter  2.100  .300 688.5  (* .25 .700)  45.0 1  .050 ampf ranf skwf
		 .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2
		 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
	(canter  2.400  .040 826.2  (* .25 .700)  45.0 1  .050 ampf ranf skwf
		 .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2
		 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
	(canter  2.440  .560 459  (* .25 .700)  45.0 1  .050 ampf ranf skwf
		 .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2
		 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
	(canter  3.0  .040 408  (* .25 .700)  45.0 1  .050 ampf ranf skwf
		 .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2
		 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
	(canter  3.040  .040 619.65  (* .25 .700)  45.0 1  .050 ampf ranf skwf
		 .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2
		 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
	(canter  3.080  .040 408  (* .25 .700)  45.0 1  .050 ampf ranf skwf
		 .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2
		 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
	(canter  3.120  .040 688.5  (* .25 .700)  45.0 1  .050 ampf ranf skwf
		 .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2
		 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
	(canter  3.160  .290 459  (* .25 .700)  45.0 1  .050 ampf ranf skwf
		 .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2
		 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
	(canter  3.450  .150 516.375  (* .25 .700)  45.0 1  .050 ampf ranf skwf
		 .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2
		 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
	(canter  3.600  .040 826.2  (* .25 .700)  45.0 1  .050 ampf ranf skwf
		 .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2
		 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
	(canter  3.640  .040 573.75  (* .25 .700)  45.0 1  .050 ampf ranf skwf
		 .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2
		 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
	(canter  3.680  .040 619.65  (* .25 .700)  45.0 1  .050 ampf ranf skwf
		 .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2
		 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
	(canter  3.720  .180 573.75  (* .25 .700)  45.0 1  .050 ampf ranf skwf
		 .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2
		 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
	(canter  3.900  .040 688.5  (* .25 .700)  45.0 1  .050 ampf ranf skwf
		 .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2
		 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)
	(canter  3.940  .260 459  (* .25 .700)  45.0 1  .050 ampf ranf skwf
		 .050  .010 10 index  .005  .005 amp1 ind1 fmt1 amp2
		 ind2 fmt2 amp3 ind3 fmt3 amp4 ind4 fmt4)))
    
    (with-sound (:srate 22050 :play #f) 
      (fm-violin 0 .01 440 .1 :noise-amount 0.0)
      (pluck 0.05 .01 330 .1 .95 .95)
      (maraca .1 .1)
      (big-maraca .2 .5 .25 0.95 0.9985 .03125 '(2300 5600 8100) '(0.96 0.995 0.995) .01)
      (fm-bell 0.3 1.0 220.0 .5 
	       '(0 0 .1000 1 10 .6000 25 .3000 50 .1500 90 .1000 100 0)
	       '(0 1 2 1.1000 25 .7500 75 .5000 100 .2000)
	       1.0)
      (singer .4 .1 (list (list .4 ehh.shp test.glt 523.0 .8 0.0 .01) (list .6 oo.shp test.glt 523.0 .7 .1 .01)))
      (stereo-flute .6 .2 440 .55 :flow-envelope '(0 0 1 1 2 1 3 0))
      (fofins 1 .3 270 .4 .001 730 .6 1090 .3 2440 .1)
      (bow 1.2 .3 400 0.5 :vb 0.15 :fb 0.1 :inharm 0.25)
      (pqw-vox 1.5 1 300 300 .1 '(0 0 50 1 100 0) '(0 0 100 0) 0 '(0 L 100 L) '(.33 .33 .33) '((1 1 2 .5) (1 .5 2 .5 3 1) (1 1 4 .5)))
      (fm-noise 2 0.5 500 0.25 '(0 0 25 1 75 1 100 0) 0.1 0.1  1000 '(0 0 100 1) 0.1 0.1 10 1000 '(0 0 100 1) 0 0  100 500 '(0 0 100 1) 0 0)
      (bes-fm 2.5 .5 440 5.0 1.0 8.0)
      (chain-dsps 3 0.5 '(0 0 1 .1 2 0) (make-oscil 440))
      (chain-dsps 3.5 1.0 '(0 0 1 1 2 0) (make-one-zero .5) (make-readin "oboe.snd"))
      (vox 4 2 170 .4 '(0 0 25 1 75 1 100 0) '(0 0 5 .5 10 0 100 1) .1 '(0 E 25 AE 35 ER 65 ER 75 I 100 UH) 
	   '(.8 .15 .05) '(.005 .0125 .025) .05 .1)
      (p 5.0 :duration .5 :keyNum 36 :strike-velocity .5 :amp .4 :DryPedalResonanceFactor .25)
					;(bobwhite 5.5)
      (scissor 2.0) 
      (plucky 3.25 .3 440 .2 1.0)
      (bowstr 3.75 .3 220 .2 1.0)
      (brass 4.2 .3 440 .2 1.0)
      (clarinet 5.75 .3 440 .2 1.0)
      (flute 6 .3 440 .2 1.0)
      (fm-trumpet 6.5 .25)
      (touch-tone 6.75 '(7 2 3 4 9 7 1))
      (pins 7.0 1.0 "now.snd" 1.0 :time-scaler 2.0)
      
      (let ((locust '(0 0 40 1 95 1 100 .5))
	    (bug_hi '(0 1 25 .7 75 .78 100 1))
	    (amp    '(0 0 25 1 75 .7 100 0)))
	(fm-insect 7      1.699  4142.627  .015 amp 60 -16.707 locust 500.866 bug_hi  .346  .500)
	(fm-insect 7.195   .233  4126.284  .030 amp 60 -12.142 locust 649.490 bug_hi  .407  .500)
	(fm-insect 7.217  2.057  3930.258  .045 amp 60 -3.011  locust 562.087 bug_hi  .591  .500)
	(fm-insect 9.100  1.500   900.627  .06  amp 40 -16.707 locust 300.866 bug_hi  .346  .500)
	(fm-insect 10.0  1.500   900.627  .06  amp 40 -16.707 locust 300.866 bug_hi  .046  .500)
	(fm-insect 10.450  1.500   900.627  .09  amp 40 -16.707 locust 300.866 bug_hi  .006  .500)
	(fm-insect 10.950  1.500   900.627  .12  amp 40 -10.707 locust 300.866 bug_hi  .346  .500)
	(fm-insect 11.300  1.500   900.627  .09  amp 40 -20.707 locust 300.866 bug_hi  .246  .500))
      
      (fm-drum 7.5 1.5 55 .3 5 #f)
      (fm-drum 8 1.5 66 .3 4 #t)
      (gong 9 3 261.61 .6)
      (attract 10 .25 .5 2.0)
      (pqw 11 .5 200 1000 .2 '(0 0 25 1 100 0) '(0 1 100 0) '(2 .1 3 .3 6 .5))
      
      (zn 10 1 100 .1 20 100 .995) 
      (zn 11.5 1 100 .1 100 20 .995)
      (zc 11 1 100 .1 20 100 .95) 
      (zc 12.5 1 100 .1 100 20 .95)
      (za 13 1 100 .1 20 100 .95 .95) 
      (za 14.5 1 100 .1 100 20 .95 .95)
      
      (tubebell 12 2 440 .2)
      (wurley 12.5 .25 440 .2)
      (rhodey 12.75 .25 440 .2)
      (hammondoid 13 .25 440 .2)
      (metal 13.5 .25 440 .2)
      (reson 14.0 1.0 440 .1 2 '(0 0 100 1) '(0 0 100 1) .1 .1 .1 5 .01 5 .01 0 1.0 0.01
	     '(((0 0 100 1) 1200 .5 .1 .1 0 1.0 .1 .1)
	       ((0 1 100 0) 2400 .5 .1 .1 0 1.0 .1 .1)))
      (cellon 14.5 1 220 .1 
	      '(0 0 25 1 75 1 100 0) 
	      '(0 0 25 1 75 1 100 0) .75 1.0 0 0 0 0 1 0 0 220 
	      '(0 0 25 1 75 1 100 0) 0 0 0 0 
	      '(0 0 100 0) 0 0 0 0 '(0 0 100 0))
      (clm-expsrc 14.75 2.5 "oboe.snd" 2.0 1.0 1.0)
      (scratch 15.0 "now.snd" 1.5 '(0.0 .5 .25 1.0))
      (two-tab 15 1 440 .1)
      (exp-snd "fyow.snd" 15 1.5 1 '(0 1 1 3) 0.4 .15 '(0 2 1 .5) 0.05)
      (exp-snd "oboe.snd" 16 1 1 '(0 1 1 3) 0.4 .15 '(0 2 1 .5) 0.2)
      (gran-synth 15.5 1 300 .0189 .03 .4)
      (spectra 16 1 440.0 .1 '(1.0 .4 2.0 .2 3.0 .2 4.0 .1 6.0 .1) '(0.0 0.0 1.0 1.0 5.0 0.9 12.0 0.5 25.0 0.25 100.0 0.0))
      (lbj-piano 16.5 1 440.0 .2)
      (resflt 17 1.0 0 0 0 #f .1 200 230 10 '(0 0 50 1 100 0) '(0 0 100 1) 500 .995 .1 1000 .995 .1 2000 .995 .1)
      (resflt 17.5 1.0 1 10000 .01 '(0 0 50 1 100 0) 0 0 0 0 #f #f 500 .995 .1 1000 .995 .1 2000 .995 .1)
      (bes-fm 18 1 440 10.0 1.0 4.0)
      
      (green3 19 2.0 440 .5 '(0 0 1 1 2 1 3 0) 100 .2 .02)
      (green4 21 2.0 440 .5 '(0 0 1 1 2 1 3 0) 440 100 100 10)
      
      (fir+comb 20 2 10000 .001 200)
      (fir+comb 22 2 1000 .0005 400)
      (fir+comb 24 2 3000 .001 300)
      (fir+comb 26 2 3000 .0005 1000)
      
      (sndwarp 28 1.0 "pistol.snd")
      (expandn 29 .5 "oboe.snd" .2)
      (expandn 30 2 "2.snd" 1.0 '(0.0 1.0 1.0 4.0 2.0 1.0))
      (let ((ampf '(0 0 1 1 2 1 3 0))) 
	(fm-voice 0 1 300 .8 3 1 ampf ampf ampf ampf ampf ampf ampf 1 0 0 .25 1 .01 ampf .01))
      (graphEq "oboe.snd")
      )
    
    (with-sound (:channels 4) (expandn 0 .1 "4.aiff" 1 :expand 4))
    (with-sound (:channels 4 :reverb jc-reverb) (expandn 0 .1 "4.aiff" 1 :expand 4))
    (with-sound (:channels 2 :reverb freeverb :reverb-channels 2) (expandn 0 .1 "4.aiff" 1 :expand 4))
    (with-sound (:play #f) (defopt-simp 0 10000) (defopt-simp 10000 10000 550.0 0.1) (defopt-simp 20000 10000 :amplitude .2))
    (with-sound (:channels 2 :reverb-channels 2 :reverb jcrev2 :play #f) (floc-simp 0 1))
    
    
    (with-sound (:channels 2 :statistics #t)
      (fullmix "pistol.snd")
      (fullmix "oboe.snd" 1 2 0 (list (list .1 (make-env '(0 0 1 1) :duration 2 :scaler .5)))))
    (let ((ind (find-sound "test.snd")))
      (if (sound? ind) (close-sound ind)))
    
    (with-sound (:channels 2) 
      (fullmix "4.aiff" 0.0 0.1 36.4 '((0.0 0.0) (0.0 0.0) (1.0 0.0) (0.0 1.0))))
    (let ((ind (find-sound "test.snd")))
      (if (fneq (maxamp) 0.8865) (snd-display "4->2(0) fullmix: ~A" (maxamp)))
      (close-sound ind))
    
    (with-sound (:channels 1) 
      (fullmix "4.aiff" 0.0 0.1 36.4 '((1.0) (0.0) (0.0) (0.0))))
    (let ((ind (find-sound "test.snd")))
      (if (fneq (maxamp) 0.221649169921875) (snd-display "4->1(0) fullmix: ~A" (maxamp)))
      (close-sound ind))
    
    (with-sound (:channels 1) 
      (fullmix "4.aiff" 0.0 0.1 36.4 '((0.0) (1.0) (0.0) (0.0))))
    (let ((ind (find-sound "test.snd")))
      (if (fneq (maxamp) 0.44329833984375) (snd-display "4->1(1) fullmix: ~A" (maxamp)))
      (close-sound ind))
    
    (with-sound (:channels 1) 
      (fullmix "4.aiff" 0.0 0.1 36.4 '((0.0) (0.0) (1.0) (0.0))))
    (let ((ind (find-sound "test.snd")))
      (if (fneq (maxamp) 0.664947509765625) (snd-display "4->1(2) fullmix: ~A" (maxamp)))
      (close-sound ind))
    
    (with-sound (:channels 1) 
      (fullmix "4.aiff" 0.0 0.1 36.4 '((0.0) (0.0) (0.0) (1.0))))
    (let ((ind (find-sound "test.snd")))
      (if (fneq (maxamp) 0.8865966796875) (snd-display "4->1(3) fullmix: ~A" (maxamp)))
      (close-sound ind))
    
    (with-sound (:channels 2) 
      (fullmix "4.aiff" 0.0 0.1 36.4 '((0.0 0.0) (0.0 0.0) (1.0 0.0) (0.0 1.0))))
    (let* ((ind (find-sound "test.snd"))
	   (mxs (maxamp ind #t)))
      (if (or (fneq (car mxs) 0.664947509765625)
	      (fneq (cadr mxs) 0.8865966796875))
	  (snd-display "4->2(1) fullmix: ~A" mxs))
      (close-sound ind))
    
    (with-sound (:channels 2) 
      (fullmix "4.aiff" 0.0 0.1 36.4 '((0.0 0.0) (0.0 0.0) (0.0 1.0) (1.0 0.0))))
    (let* ((ind (find-sound "test.snd"))
	   (mxs (maxamp ind #t)))
      (if (or (fneq (car mxs) 0.8865966796875)
	      (fneq (cadr mxs) 0.664947509765625))
	  (snd-display "4->2(2) fullmix: ~A" mxs))
      (close-sound ind))
    
    (with-sound (:channels 2 :reverb nrev) 
      (fullmix "pistol.snd" 0.0 2.0 0.25 #f 2.0 0.1)
      (fullmix "pistol.snd" 1.0 2.0 0.25 0.2 2.0 0.1)
      (fullmix "2a.snd" #f #f #f '((0.5 0.0) (0.0 0.75)))
      (fullmix "oboe.snd" #f #f #f (list (list (list 0 0 1 1 2 0) 0.5)))
      (fullmix "oboe.snd" 3 2 0 (list (list .1 (make-env '(0 0 1 1) :duration 2 :scaler .5)))))
    
    (with-sound (:channels 2 :statistics #t)
      (fullmix "pistol.snd")
      (fullmix "oboe.snd" 1 2 0 (list (list .1 (make-env '(0 0 1 1) :duration 2 :scaler .5)))))
    (let ((ind (find-sound "test.snd")))
      (if (sound? ind) (close-sound ind) (snd-display "fullmix.scm no output?")))
    
    (with-sound (:channels 2) 
      (fullmix "4.aiff" 0.0 0.1 36.4 '((0.0 0.0) (0.0 0.0) (1.0 0.0) (0.0 1.0))))
    (let ((ind (find-sound "test.snd")))
      (if (fneq (maxamp) 0.8865) (snd-display "4->2(0) fullmix.scm: ~A" (maxamp)))
      (close-sound ind))
    
    (with-sound (:channels 1) 
      (fullmix "4.aiff" 0.0 0.1 36.4 '((1.0) (0.0) (0.0) (0.0))))
    (let ((ind (find-sound "test.snd")))
      (if (fneq (maxamp) 0.221649169921875) (snd-display "4->1(0) fullmix.scm: ~A" (maxamp)))
      (close-sound ind))
    
    (with-sound (:statistics #t :scaled-to .5 :srate 44100 :channels 1) 
      (cnvrev "oboe.snd" "fyow.snd"))
    (let ((ind (find-sound "test.snd")))
      (if (sound? ind) (close-sound ind) (snd-display "cnvrev no output?")))
    
    
    (with-sound ()
      (sound-let ((temp-1 () (fm-violin 0 1 440 .1))
		  (temp-2 () (fm-violin 0 2 660 .1 :base 32.0)
			  (fm-violin .125 .5 880 .1)))
		 (mus-file-mix *output* temp-1 0) 
		 (mus-file-mix *output* temp-2 22050)))
    (let ((ind (find-sound "test.snd")))
      (if (not (sound? ind)) (snd-display "with-sound+sound-lets init: no test.snd?"))
      (if (not (>= 0.2 (maxamp ind) 0.15)) (snd-display "with-mix+sound-lets maxamp: ~A" (maxamp ind)))
      (if (fneq 3.0 (/ (framples ind) (srate ind))) (snd-display "with-sound+sound-lets dur: ~A" (/ (framples ind) (srate ind))))
      (close-sound ind))
    
    (with-sound (:srate 44100 :play #f) (bigbird 0 2 60 0 .5 '(0 0 1 1) '(0 0 1 1 2 1 3 0) '(1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 1 10 1)))
    (let ((ind (or (find-sound "test.snd") (open-sound "oboe.snd"))))
      (let ((mx (maxamp)))
	(notch-sound (do ((freqs ()) (i 60 (+ i 60))) ((= i 3000) (reverse freqs)) (set! freqs (cons i freqs))))
	(if (or (fneq mx .5)
		(ffneq (maxamp) .027))
	    (snd-display "notch 60 Hz: ~A to ~A" mx (maxamp))))
      (undo)
      (notch-sound (do ((freqs ()) (i 60 (+ i 60))) ((= i 3000) (reverse freqs)) (set! freqs (cons i freqs))) #f ind 0 10)
      (if (ffneq (maxamp) .011)
	  (snd-display "notch-sound 60 hz 2: ~A" (maxamp)))
      (undo)
      (notch-channel (do ((freqs ()) (i 60 (+ i 60))) ((= i 3000) (reverse freqs)) (set! freqs (cons i freqs))) #f #f #f ind 0 #f #f 10)
      (if (ffneq (maxamp) .004)
	  (snd-display "notch-channel 60 hz 2: ~A" (maxamp)))
      (undo)
      (make-selection 10000 11000)
      (notch-selection (do ((freqs ()) (i 60 (+ i 60))) ((= i 3000) (reverse freqs)) (set! freqs (cons i freqs))) #f 10)
      (close-sound ind))
    
    (with-sound (:srate 44100 :play #f) (bigbird 0 30 60 0 .5 '(0 0 1 1) '(0 0 1 1 2 1 3 0) '(1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 1 10 1)))
    (let ((ind (find-sound "test.snd")))
      (notch-sound (do ((freqs ()) (i 60 (+ i 60))) ((= i 3000) (reverse freqs)) (set! freqs (cons i freqs))) #f ind 0 10)
      (if (ffneq (maxamp) .011)
	  (snd-display "notch-sound 60 hz 2 60: ~A" (maxamp)))
      (close-sound ind))
    
    (play-sine 440 .1)
    (play-sines '((425 .05) (450 .01) (470 .01) (546 .02) (667 .01) (789 .034) (910 .032)))
    
    (with-sound (:channels 2 :reverb jc-reverb :reverb-channels 1 :statistics #t)
      (grani 0 1 .5 "oboe.snd" :grain-envelope '(0 0 0.2 0.2 0.5 1 0.8 0.2 1 0))
      (grani 0 4 1 "oboe.snd")
      
      (grani 0 4 1 "oboe.snd" :grains 10)
      (grani 0 4 1 "oboe.snd" 
	     :grain-start 0.11 
	     :amp-envelope '(0 1 1 1) :grain-density 8
	     :grain-envelope '(0 0 0.2 0.2 0.5 1 0.8 0.2 1 0)
	     :grain-envelope-end '(0 0 0.01 1 0.99 1 1 0)
	     :grain-envelope-transition '(0 0 0.4 1 0.8 0 1 0))
      (grani 0 3 1 "oboe.snd" 
	     :grain-start 0.1 
	     :amp-envelope '(0 1 1 1) :grain-density 20
	     :grain-duration '(0 0.003 0.2 0.01 1 0.3))
      (grani 0 3 1 "oboe.snd" 
	     :grain-start 0.1 
	     :amp-envelope '(0 1 1 1) :grain-density 20
	     :grain-duration '(0 0.003 0.2 0.01 1 0.3)
	     :grain-duration-limit 0.02)
      (grani 0 2 1 "oboe.snd" 
	     :amp-envelope '(0 1 1 1) :grain-density 40
	     :grain-start '(0 0.1 0.3 0.1 1 0.6))
      (grani 0 2 1 "oboe.snd" 
	     :amp-envelope '(0 1 1 1) :grain-density 40
	     :grain-start '(0 0.1 0.3 0.1 1 0.6)
	     :grain-start-spread 0.01)
      (grani 0 2.6 1 "oboe.snd" 
	     :grain-start 0.1 :grain-start-spread 0.01
	     :amp-envelope '(0 1 1 1) :grain-density 40
	     :srate '(0 0 0.2 0 0.6 5 1 5))
      (grani 0 2.6 1 "oboe.snd" 
	     :grain-start 0.1 :grain-start-spread 0.01
	     :amp-envelope '(0 1 1 1) :grain-density 40
	     :srate-base 2
	     :srate '(0 0 0.2 0 0.6 -1 1 -1))
      (grani 0 2.6 1 "oboe.snd" 
	     :grain-start 0.1 :grain-start-spread 0.01
	     :amp-envelope '(0 1 1 1) :grain-density 40
	     :srate-linear #t
	     :srate (list 0 1 0.2 1 0.6 (expt 2 5/12) 1 (expt 2 5/12)))
      (grani 0 2 1 "oboe.snd" 
	     :grain-start 0.1 :grain-start-spread 0.01
	     :amp-envelope '(0 1 1 1) :grain-density 40
	     :grain-duration '(0 0.02 1 0.1) 
	     :grain-duration-spread '(0 0 0.5 0.1 1 0)
	     :where-to grani-to-grain-duration ; from grani.scm
	     :where-bins #r(0 0.05 1))
      (grani 0 2 1 "oboe.snd" 
	     :grain-start 0.1 :grain-start-spread 0.01
	     :amp-envelope '(0 1 1 1) :grain-density 40
	     :grain-degree '(0 0 1 90)
	     :grain-degree-spread 10))
    
    (let ((ind (open-sound "oboe.snd")))
      (with-sound ("test1.snd" :to-snd #f) (fm-violin 0 .1 440 .1))
      (set-samples 0 2205 "test1.snd" ind 0 #f "set-samples auto-delete test" 0 #f #t)
      (if (not (file-exists? "test1.snd")) (snd-display "oops: auto-delete test1.snd?"))
      (undo 1 ind)
      (with-sound ("test2.snd" :to-snd #f) (fm-violin 0 .1 440 .1))
      (insert-sound "test2.snd" 0 0 ind 0 #f #t)
      (if (file-exists? "test1.snd") (snd-display "auto-delete set-samples?"))
      (undo 1 ind)
      (with-sound ("test3.snd" :to-snd #f) (fm-violin 0 .1 440 .1))
      (insert-samples 0 2205 "test3.snd" ind 0 #f #t)  
      (if (file-exists? "test2.snd") (snd-display "auto-delete insert-sound?"))
      (undo 1 ind)
      (with-sound ("test4.snd" :to-snd #f) (fm-violin 0 .1 440 .1))
      (mix "test4.snd" 0 0 ind 0 #f #t)
      (if (file-exists? "test3.snd") (snd-display "auto-delete insert-samples?"))
      (undo 1 ind)
      (delete-sample 100)
      (if (file-exists? "test4.snd") (snd-display "auto-delete mix?"))
      (with-sound ("test5.snd" :to-snd #f) (fm-violin 0 .1 440 .1))
      (mix "test5.snd" 0 0 ind 0 #t #t)
      (revert-sound ind)
      (close-sound ind)
      (if (file-exists? "test5.snd") (snd-display "auto-delete mix (with-tag)?")))
    )        
  
  (let ((o2 (optkey-1 1)))
    (if (not (eqv? o2 1)) (snd-display "optkey-1: ~A" o2)))
  (let ((o2 (optkey-1 :a 1)))
    (if (not (eqv? o2 1)) (snd-display "optkey-1 1: ~A" o2)))
  (let ((o2 (optkey-1)))
    (if o2 (snd-display "optkey-1 2: ~A" o2)))
  (let ((o2 (optkey-2 1 2)))
    (if (not (equal? o2 '(1 2))) (snd-display "optkey-2: ~A" o2)))
  (let ((o2 (optkey-2 :a 1 :b 2)))
    (if (not (equal? o2 '(1 2))) (snd-display "optkey-2 1: ~A" o2)))
  (let ((o2 (optkey-2)))
    (if (not (equal? o2 '(3 #f))) (snd-display "optkey-2 2: ~A" o2)))
  (let ((o2 (optkey-2 1 :b 2)))
    (if (not (equal? o2 '(1 2))) (snd-display "optkey-2 3: ~A" o2)))
  (let ((o2 (optkey-3 1 2 3)))
    (if (not (equal? o2 '(1 2 3))) (snd-display "optkey-3: ~A" o2)))
  (let ((o2 (optkey-3 1 :b 2 :c 3)))
    (if (not (equal? o2 '(1 2 3))) (snd-display "optkey-3 1: ~A" o2)))
  (let ((o2 (optkey-3 1 2 :c 3)))
    (if (not (equal? o2 '(1 2 3))) (snd-display "optkey-3 2: ~A" o2)))
  (let ((o2 (optkey-4)))
    (if (not (equal? o2 '(1 2 3 #f))) (snd-display "optkey-4: ~A" o2)))
  (let ((o2 (optkey-4 1 :b 3 :c 4 :d 5)))
    (if (not (equal? o2 '(1 3 4 5))) (snd-display "optkey-4 1: ~A 1" o2)))
  (let ((o2 (optkey-4 1 :d 5 :c 4 :b 3)))
    (if (not (equal? o2 '(1 3 4 5))) (snd-display "optkey-4 2: ~A 1" o2)))
  (let ((o2 (optkey-4 1 3 4 5)))
    (if (not (equal? o2 '(1 3 4 5))) (snd-display "optkey-4 3: ~A 2" o2)))
  
  (when (and (or (provided? 'snd-motif)
		 (and (provided? 'snd-gtk) (defined? 'gtk_box_new)))
	     (defined? 'variable-display))
    (let ((wid3 (make-variable-display "do-loop" "i3" 'spectrum))
	  (wid4 (make-variable-display "do-loop" "i4" 'graph)))
      (let ((wid1 (make-variable-display "do-loop" "i*1" 'text))
	    (wid2 (make-variable-display "do-loop" "i*2" 'scale '(-1.0 1.0))))
	(do ((i 0 (+ i 1)))
	    ((= i 1000))
	  (variable-display (variable-display (* (variable-display (sin (* (variable-display i wid1) .1)) wid3) .5) wid2) wid4)))
      (let ((tag (catch #t (lambda () (set! (sample 0 (car wid3) 0) .5)) (lambda args (car args)))))
	(if (> (edit-position (car wid3) 0) 0) (snd-display "edited variable graph? ~A ~A" tag (edit-position (car wid3) 0))))
      ((if (provided? 'snd-motif)
	  (*motif* 'XtUnmanageChild)
	  (*gtk* 'gtk_widget_hide))
       variables-dialog)
      (close-sound (car wid3))
      (close-sound (car wid4))))
  
  (if (not (= *clm-srate* *default-output-srate*)) (snd-display "*clm-srate*: ~A ~A" *clm-srate* *default-output-srate*))
  (if (not (= *clm-channels* *default-output-chans*)) (snd-display "*clm-channels*: ~A ~A" *clm-channels* *default-output-chans*))
  (if (not (= *clm-header-type* *default-output-header-type*)) (snd-display "*clm-header-type*: ~A ~A" *clm-header-type* *default-output-header-type*))
					;	(if (not (= *clm-sample-type* *default-output-sample-type*)) (snd-display "*clm-sample-type*: ~A ~A" *clm-sample-type* *default-output-sample-type*))
  (if (not (= *clm-reverb-channels* 1)) (snd-display "*clm-reverb-channels*: ~A" *clm-reverb-channels*))
  (if (not (string=? *clm-file-name* "test.snd")) (snd-display "*clm-file-name*: ~A" *clm-file-name*))
  (if *clm-play* (snd-display "*clm-play*: ~A" *clm-play*))
  (if *clm-verbose* (snd-display "*clm-verbose*: ~A" *clm-verbose*))
  (if *clm-statistics* (snd-display "*clm-statistics*: ~A" *clm-statistics*))
  (if *clm-reverb* (snd-display "*clm-reverb*: ~A" *clm-reverb*))
  (if (pair? *clm-reverb-data*) (snd-display "*clm-reverb-data*: ~A?" *clm-reverb-data*))
  (if *clm-delete-reverb* (snd-display "*clm-delete-reverb*: ~A" *clm-delete-reverb*))
  
  (let-temporarily ((*clm-statistics* #t))
    (set! *clm-channels* 2)
    (set! *clm-srate* 44100)
    (set! *clm-file-name* "test.wav")
    (set! *clm-verbose* #t)
    (set! *clm-play* #t)
    (set! *clm-sample-type* mus-mulaw)
    (set! *clm-header-type* mus-riff)
    (set! *clm-delete-reverb* #t)
    (set! *clm-reverb* jc-reverb)
    (set! *clm-reverb-data* (list #t 2.0 (list 0 1 3.0 1 4.0 0)))
    
    (with-sound () (fm-violin 0 1 440 .1 :reverb-amount .1))
    
    (let ((ind (find-sound "test.wav")))
      (if (not (sound? ind))
	  (snd-display "default output in ws: ~A" (map file-name (sounds)))
	  (begin
	    (if (not (= (srate ind) 44100)) (snd-display "default srate in ws: ~A ~A" (srate ind) *clm-srate*))
	    (if (not (= (channels ind) 2)) (snd-display "default chans in ws: ~A ~A" (channels ind) *clm-channels*))
	    (if (not (= (sample-type ind) mus-mulaw)) (snd-display "default format in ws: ~A ~A" (sample-type ind) *clm-sample-type*))
	    (if (not (= (header-type ind) mus-riff)) (snd-display "default type in ws: ~A ~A" (header-type ind) *clm-header-type*))
	    (if (> (abs (- (framples ind) 88200)) 1) (snd-display "reverb+1 sec out in ws: ~A" (framples ind)))
	    (if (file-exists? "test.rev") (snd-display "perhaps reverb not deleted in ws?"))
	    (close-sound ind))))
    
    (let ((val 0))
      (let-temporarily ((*clm-notehook* (lambda args (set! val 1))))
	(with-sound () (fm-violin 0 .1 440 .1))
	(if (not (= val 1)) (snd-display "*clm-notehook*: ~A ~A" val *clm-notehook*))
	(with-sound (:notehook (lambda args (set! val 2))) (fm-violin 0 .1 440 .1))
	(if (not (= val 2)) (snd-display ":notehook: ~A" val))
	(with-sound () (fm-violin 0 .1 440 .1))
	(if (not (= val 1)) (snd-display "*clm-notehook* (1): ~A ~A" val *clm-notehook*))))
    
    (set! *clm-channels* 1)
    (set! *clm-srate* 22050)
    (set! *clm-file-name* "test.snd")
    (set! *clm-verbose* #f)
    (set! *clm-play* #f)
    (set! *clm-sample-type* mus-ldouble)
    (set! *clm-header-type* mus-next)
    (set! *clm-delete-reverb* #f)
    (set! *clm-reverb* #f)
    (set! *clm-reverb-data* ()))
  
  (with-sound (:reverb jl-reverb)
    (attract 0 1 0.1 2.0)
    (expfil 0 2 .2 .01 .1 "oboe.snd" "fyow.snd")
    (fm-violin 0 .1 660 .1 :reverb-amount .1)
    (anoi "oboe.snd" 1 1)
    (let* ((ind (open-sound "oboe.snd"))
	   (ind1 (open-sound "now.snd"))
	   (zp (make-zipper (make-env '(0 0 1 1) :length 22050)
			    0.05
			    (make-env (list 0 (* *clm-srate* 0.05)) :length 22050)))
	   (reader0 (make-sampler 0 ind 0))
	   (reader1 (make-sampler 0 ind1 0)))
      (do ((i 0 (+ i 1))) ((= i 22050)) (outa i (zipper zp reader0 reader1)))
      (close-sound ind)
      (close-sound ind1)))
  
  (zip-sound 1 1 "fyow.snd" "now.snd" '(0 0 1 1) .05)
  (zip-sound 2 3 "mb.snd" "fyow.snd" '(0 0 1.0 0 1.5 1.0 3.0 1.0) .025)
  
  (if all-args
      (let ((ind (open-sound "1a.snd"))
	    (pv (make-pvocoder 256 4 64))
	    (rd (make-sampler 0)))
	(map-channel (lambda (y) (pvocoder pv rd)))
	(clm-reverb-sound .1 jc-reverb)
	(close-sound ind)))
  
  (let-temporarily ((*clm-play* #f))
    (make-birds))
  
  (for-each close-sound (sounds))
  
  (with-sound (:play #f :srate 22050)
    (simple-ssb 0 .2 440 .1)
    (simple-nsin .6 .2 .1)
    (simple-ncos 0.7 .2 440 .1)
    (simple-nrxysin .6 .2 .1)
    (simple-nrxycos 0.7 .2 440 .1)
    (simple-osc 0.75 .2 440 .1)
    (simple-asy 1.25 .2 .1)
    (simple-saw 1.5 .2 .1)
    (simple-tri 1.75 .2 .1)
    (simple-pul 2.0 .2 .1)
    (simple-sqr 2.25 .2 .1)
    (simple-oz 2.75 .2 440.0 .1)
    (simple-op 3.0 .2 440.0 .1)
    (simple-tz 3.25 .2 440.0 .1)
    (simple-tp 3.5 .2 440.0 .1)
    (simple-frm 3.75 .2 440.0 .1)
    (simple-firm 3.875 .2 440.0 .1)
    (simple-firm2 4.0 .2 440.0 .1)
    (simple-poly 4.25 .2 440.0 .1)
    (simple-polyw 4.5 .2 440.0 .1)
    (simple-dly 4.75 .2 440.0 .1)
    (simple-cmb 5.0 .2 440.0 .1)
    (simple-filtered-cmb 5.125 .2 440.0 .1)
    (simple-not 5.25 .2 440.0 .1)
    (simple-alp 5.5 .2 440.0 .1)
    (simple-ave 5.75 .2 440.0 .1)
    (simple-tab 6.0 .2 440.0 .1)
    (simple-flt 6.25 .2 440.0 .1)
    (simple-fir 6.5 .2 440.0 .1)
    (simple-iir 6.5 .2 440.0 .3)
    (simple-ran 7.0 .2 440.0 .1)
    (simple-ri 7.25 .2 440.0 .1)
    (simple-env 7.5 .2 440.0 .1)
    (simple-amb 7.75 .2 440.0 .1)
    (simple-fof 8 1 270 .1 .001 730 .6 1090 .3 2440 .1) ;"Ahh"
    (simple-fof 9 4 270 .1 0.005 730 .6 1090 .3 2440 .1 '(0 0 40 0 75 .2 100 1) 
		'(0 0 .5 1 3 .5 10 .2 20 .1 50 .1 60 .2 85 1 100 0))
    (simple-fof 9 4 648 .1 0.005 730 .6 1090 .3 2440 .1 '(0 0 40 0 75 .2 100 1) 
		'(0 0 .5 .5 3 .25 6 .1 10 .1 50 .1 60 .2 85 1 100 0))
    (simple-fof 9 4 135 .1 0.005 730 .6 1090 .3 2440 .1 '(0 0 40 0 75 .2 100 1) 
		'(0 0 1 3 3 1 6 .2 10 .1 50 .1 60 .2 85 1 100 0))
    
    (simple-src-f 13  .45 1.0 2.0 "oboe.snd")
    (simple-rd 13.5 .45 .75 "oboe.snd")
    (simple-rd-start 13.65 .25 .75 "oboe.snd" 0 0)
    (simple-rd-start 13.8 .25 .75 "oboe.snd" 0 12345)
    (simple-rd-start 13.9 .25 .75 "oboe.snd" 0 12345678)
    (simple-cnv 14.0 .45 .75 "oboe.snd")
    (simple-cnf 14.5 .45 .75 "oboe.snd")
    (simple-lrg 15.0 .45 .75 "oboe.snd")
    (simple-cn2 15.5 .45 .4 "oboe.snd")
    (simple-src 16  .45 1.0 2.0 "oboe.snd")
    (simple-sr2 16.5 .45 1.0 2.0 "oboe.snd")
    (simple-sr2a 16.75 .45 1.0 2.0 "oboe.snd")
    (simple-rndist 17.0 .2 440.0 .1)
    (simple-ridist 17.25 .2 440.0 .1)
    (simple-sro 17.5 .45 .1 .5 440)
    (simple-grn 18 .2 .1 1.0 440)
    (simple-pvoc 18.25 .2 .4 256 "oboe.snd")
    (simple-ina 18.5 .45 1 "oboe.snd")
    (simple-rdf 19 .45 1 "oboe.snd")
    (simple-f2s 19.5 .45 1 "oboe.snd")
    (simple-loc 20 .2 440 .1)
    (simple-dloc 20.1 .2 440 .1)
    (simple-out 20.25 .2 440 .1)	
    (simple-fm 20 1 440 .1 2 1.0)
    (simple-dup 20.5 .2 440 .1)
    (simple-du1 20.75 .2 440 .1)
    (simple-grn-f1 21 .45 .1 2 440)
    (simple-grn-f2 21.5 .45 1 2 "oboe.snd")
    (simple-grn-f3 22 .45 1 2 "oboe.snd")
    (simple-grn-f4 22.5 .45 1 2 "oboe.snd")
    (simple-grn-f5 23 .45 1 2 "oboe.snd")
    (simple-multiarr 23.5 .5 440 .1))
  
  
  (with-sound (:channels 4 :play #f :srate 22050) (simple-dloc-4 0 2 440 .5))
  
  (with-sound (:play #f :srate 22050)
    (sample-desc 0 .2 440 .1)
    (sample-mdat .25 .2 440 .1)
    (sample-xtab .5 .2 440 .1)
    (sample-xts .75 .2 440 .1)
    (sample-srl2 1 .2 .2 .5 880)
    (sample-srll 1.25 .2 .1 .5 1760)
    (sample-srl3 1.5 .2 .1 .5 880)
    (sample-grn2 1.75 .2 .1 .5 880)
    (sample-grn3 2 .45 1 1 "oboe.snd")
    
    (sample-cnv 2.5 .45 1 1 "oboe.snd")
    (sample-cnv1 3.0 .45 1 1 "oboe.snd")
    (sample-pvoc1 3.5 .45 1 512 "oboe.snd")
    (sample-pvoc2 4.0 .45 1 512 "oboe.snd")
    (sample-pvoc3 4.5 .001 1 512 "oboe.snd")
    (sample-osc 5.25 .2 440 .1)
    (if all-args (sample-ardcl 5.5 .2 440 .1))
    (sample-flt 6 .2 440 .1)
    (sample-arrintp 6.25 .2 440 .1)
    (sample-arrfile 6.75 .2 440 .15)
    (sample-pvoc5 7.25 .2 .1 256 "oboe.snd" 440.0)
    )
  
  (let* ((file (with-sound (:clipped #f :sample-type mus-lfloat :header-type mus-next)
		 (fm-violin 0 .1 440 pi)))
	 (ind (find-sound file))
	 (mx (maxamp ind)))
    (if (fneq mx pi) (snd-display "clipped #f: ~A" mx))
    (close-sound ind)
    (set! file (with-sound (:clipped #t :sample-type mus-lfloat :header-type mus-next)
		 (fm-violin 0 .1 440 pi)))
    (set! ind (find-sound file))
    (set! mx (maxamp ind))
    (if (fneq mx 1.0) (snd-display "clipped #t: ~A" mx))
    
    (close-sound ind)
    (set! file (with-sound (:sample-type mus-lfloat :header-type mus-next :scaled-by .1 :clipped #f)
		 (fm-violin 0 .1 440 pi)))
    (set! ind (find-sound file))
    (set! mx (maxamp ind))
    (if (fneq mx .314159) (snd-display "scaled-by ~A" mx))
    
    (close-sound ind)
    (set! file (with-sound (:sample-type mus-lfloat :header-type mus-next :scaled-to .1 :clipped #f)
		 (fm-violin 0 .1 440 pi)))
    (set! ind (find-sound file))
    (set! mx (maxamp ind))
    (if (fneq mx .1) (snd-display "scaled-to ~A" mx))
    
    (close-sound ind)
    (let-temporarily ((*clm-file-buffer-size* 1048576)
		      (*clm-table-size* 256)
		      (*clm-array-print-length* 123))
      (let ((tsize 0)
	    (arrp 0))
	(set! file (with-sound (:sample-type mus-lfloat :header-type mus-next)
		     (set! mx *clm-file-buffer-size*)
		     (set! tsize *clm-table-size*)
		     (set! arrp *mus-array-print-length*)
		     (fm-violin 0 .1 440 .1)))
	(set! ind (find-sound file))
	(if (not (= mx 1048576)) (snd-display "*clm-file-buffer-size*: ~A" mx))
	(if (not (= tsize 256)) (snd-display "*clm-table-size*: ~A" tsize))
	(if (not (= arrp 123)) (snd-display "*clm-array-print-length*: ~A" arrp))
	(close-sound ind)))
    
    (set! file (with-sound () (fm-violin 0 3.0 440 .1)))
    (set! ind (find-sound file))
    (set! (amp-control ind) .5)
    (set! (x-bounds ind 0) (list 1.0 2.0))
    (set! file (with-sound () (fm-violin 0 4.0 440 .1)))
    (set! ind (find-sound file))
    (if (fneq (amp-control ind) .5) (snd-display "update ws amp: ~A" (amp-control ind)))
    (if (or (fneq (car (x-bounds ind 0)) 1.0)
	    (fneq (cadr (x-bounds ind 0)) 2.0))
	(snd-display "update ws bounds: ~A" (x-bounds ind)))
    
    (if (not (= (->sample 1.0) (srate))) (snd-display "1.0->sample: ~A" (->sample 1.0)))
    (close-sound ind)
    
    (set! file (with-sound (:reverb jc-reverb) (fm-violin 0 .1 440 .1 :reverb-amount .1)))
    (set! ind (find-sound file))
    (set! mx (maxamp ind))
    (set! file (with-sound (:reverb jc-reverb :reverb-data '(#f 12.0 (0 0 1 1 20 1 21 0))) (fm-violin 0 .1 440 .1 :reverb-amount .1)))
    (set! ind (find-sound file))
    (if (<= (maxamp ind) mx) (snd-display "reverb-data: ~A ~A" mx (maxamp ind)))
    (close-sound ind))
  
  (let ((ind (open-sound "oboe.snd")))
    (step-src)
    (if (> (abs (- (framples) 24602)) 100) (snd-display "step-src framples: ~A (~A)" (framples) (edits)))
    (close-sound ind))
  
  (let ((ind (find-sound
	     (with-sound (:channels 3)
		 (let ((rg (make-rmsgain))
		       (rg1 (make-rmsgain 40))
		       (rg2 (make-rmsgain 2))
		       (e (make-env '(0 0 1 1 2 0) :length base-length))
		       (e1 (make-env '(0 0 1 1) :length base-length))
		       (e2 (make-env '(0 0 1 1 2 0 10 0) :length base-length))
		       (o (make-oscil 440.0)))
		   (do ((i 0 (+ i 1)))
		       ((= i base-length))
		     (let ((sig (env e)))
		       (outa i (balance rg sig (env e2)))
		       (outb i (balance rg1 sig (env e1)))
		       (outc i (balance rg2 (* .1 (oscil o)) (env e2)))))
		   (if (fneq (gain-avg rg) 1.4227) (snd-display "rmsgain gain-avg: ~A" (gain-avg rg)))
		   (if (not (= (rg2 'avgc) base-length)) (snd-display "rmsgain count: ~A" (rg2 'avgc))))))))
    (if (sound? ind)
	(close-sound ind)
	(snd-display "with-sound balance?")))
  
  (let ((mg (make-oscil 100.0))
	(gen (make-ssb-fm 1000))
	(ind (new-sound "tmp.snd" 1 22050 mus-ldouble mus-next)))
    (pad-channel 0 1000 ind 0)
    (catch #t (lambda () (map-channel (lambda (y) (ssb-fm gen (* .02 (oscil mg)))))) (lambda arg (display arg)))
    (close-sound ind))
  
  ;; dlocsig tests
  (if (not (provided? 'snd-dlocsig.scm))
      (catch #t 
	(lambda () (load "dlocsig.scm"))
	(lambda args (snd-display "load dlocsig: ~A" args))))
  (if (not (defined? 'make-spiral-path))
      (snd-display "make-spiral-path is not defined, dlocsig is ~Aloaded"
		   (if (provided? 'snd-dlocsig.scm) "" "not "))
      (begin
	
	(let ((file (new-sound "tmp.snd" 4 22050 mus-ldouble mus-next)))
	  (mix-move-sound 0 "oboe.snd" (make-spiral-path :turns 3))
	  (close-sound file))
	
	(let ((path (make-path '((-10 10) (0.5 0.5) (10 10)) :3d #f)))
	  (if (not (equal? path '(open-bezier-path () () () () () () () () () ((-10 10) (0.5 0.5) (10 10)) #f #f () () () () () () () 0.01 #f #f #f)))
	      (snd-display "dlocsig path 1: ~A~%" path)))
	(let ((path (make-path :path '((-10 10 0 1) (0 5 0 0) (10 10 10 1)) :3d #t)))
	  (if (not (equal? path '(open-bezier-path () () () () () () () () () ((-10 10 0 1) (0 5 0 0) (10 10 10 1)) #t #f () () () () () () () 0.01 #f #f #f)))
	      (snd-display "dlocsig path 2: ~A~%" path)))
	(let ((path (make-spiral-path :total-angle 360)))
	  (if (not (equal? path '(spiral-path () () () () () () () () () () #f #f 0.0 360 18/5 () (0 10 1 10) (0 0 1 0) (0 1 1 1))))
	      (snd-display "dlocsig path 3: ~A~%" path)))
	(let ((path (make-spiral-path :turns 3)))
	  (if (not (equal? path '(spiral-path () () () () () () () () () () #f #f 0.0 #f 18/5 3 (0 10 1 10) (0 0 1 0) (0 1 1 1))))
	      (snd-display "dlocsig path 4: ~A~%" path)))
	(let ((path (make-literal-path '((-10 10) (10 10)) :polar #t)))
	  (if (not (equal? path '(literal-path () () () () () () () () () ((-10 10) (10 10)) #f #t)))
	      (snd-display "dlocsig path 5: ~A~%" path)))
	(let ((path (make-spiral-path :total-angle 360 :distance '(0 10 1 30 2 10))))
	  (if (not (equal? path '(spiral-path () () () () () () () () () () #f #f 0.0 360 18/5 () (0 10 1 30 2 10) (0 0 1 0) (0 1 1 1))))
	      (snd-display "dlocsig path 6: ~A~%" path)))
	
	(with-sound (:channels 2) (dloc-sinewave 0 1.0 440 .5 :path (make-path '((-10 10) (0.5 0.5) (10 10)) :3d #f)))
	(with-sound (:channels 4) (dloc-sinewave 0 1.0 440 .5 :path (make-path '((-10 10) (0.5 0.5) (10 10)) :3d #f)))
	(with-sound (:channels 8) (dloc-sinewave 0 1.0 440 .5 :path (make-path '((-10 10) (0.5 0.5) (10 10)) :3d #f)))
	(with-sound (:channels 4) (dloc-sinewave 0 1.0 440 .5 :path (make-path '((-10 10) (0.5 0.5) (10 10)) :3d #t)))
	(with-sound (:channels 4 :reverb jc-reverb) (dloc-sinewave 0 1.0 440 .5 :path (make-path '((-10 10) (0.5 0.5) (10 10)) :error .001 :3d #f)))
	(with-sound (:channels 2) (dloc-sinewave 0 1.0 440 .5 :path (make-path :path '((-10 10 0 1) (0 5 0 0) (10 10 10 1)) :3d #t)))
	(with-sound (:channels 4) (dloc-sinewave 0 1.0 440 .5 :path (make-spiral-path :total-angle 360)))
	(with-sound (:channels 8) (dloc-sinewave 0 3.0 440 .5 :path (make-spiral-path :turns 3)))
	(with-sound (:channels 4) (dloc-sinewave 0 1.0 440 .5 :path (make-literal-path '((-10 10) (10 10)) :polar #f)))
	(with-sound (:channels 3) (dloc-sinewave 0 1.0 440 .5 :path (make-literal-path '((-10 10) (10 10)) :polar #t)))
	(with-sound (:channels 4) (dloc-sinewave 0 1.0 440 .5 :path (make-spiral-path :total-angle 360 :distance '(0 10 1 30 2 10))))
	
	(set-speaker-configuration (arrange-speakers :speakers '(-45 45 90 135 225) 
						     :delays '(.010 .020 .030 .040 .050)
						     :channel-map '(0 1 3 2 4)))
	(with-sound (:channels 5) (dloc-sinewave 0 1.0 440 .5 :path (make-spiral-path :turns 2)))
	(with-sound (:channels 5 :reverb freeverb :reverb-channels 5 :reverb-data '(:decay-time .9))
	  (dloc-sinewave 0 1.0 440 .5 :path (make-spiral-path :turns 2)))
	
	(set-speaker-configuration (arrange-speakers :speakers '(-45 45 90 135 225) 
						     :delays '(.010 .020 .030 .040 .050)
						     :channel-map '(4 3 2 1 0)))
	
	(with-sound (:channels 5 :reverb freeverb :reverb-channels 5) 
	  (dloc-sinewave 0 1.0 440 .5 :path (make-spiral-path :turns 2)))
	(with-sound (:channels 4) 
	  (dlocsig-sinewave-1 0 1.0 440 .5 :path (make-path '((-10 10) (0.5 0.5) (10 10)) :3d #f) :decode b-format-ambisonics))
	(with-sound (:channels 4) 
	  (dlocsig-sinewave-1 0 1.0 440 .5 :path (make-path '((-10 10) (0.5 0.5) (10 10)) :3d #f) :decode decoded-ambisonics))
	))
  (let ()
    (define (frample n)
      (let* ((ind (selected-sound))
	     (c (channels ind)))
	(do ((v (make-float-vector c))
	     (i 0 (+ i 1)))
	    ((= i c) v)
	  (set! (v i) (sample n ind i)))))
    (with-sound (:channels 5 :reverb freeverb :reverb-channels 5 :srate 44100 :reverb-data '(:decay-time .1))
      (frample->file *reverb* 0 #r(.2 .1 .05 .025 .0125)))
    (if (not (vmus-arrays-equal? (frample 2438) (make-float-vector 5))) 
	(snd-display "freeverb 2438: ~A" (frample 2438)))
    (if (not (vmus-arrays-equal? (frample 2439) #r(0.04276562482118607 -0.0009843750158324838 0.00995312537997961 -0.0009843750158324838 0.001750000054016709)))
	(format *stderr* ";freeverb 2439: ~A" (frample 2439)))
    (if (not (vmus-arrays-equal? (frample 4305) #r(0.03010422177612782 -0.00203015236184001 0.007028832100331783 -0.001004761666990817 0.00125998433213681)))
	(format *stderr* ";freeverb 4305: ~A" (frample 4305)))
    (close-sound))
  
  (let ((a4 (->frequency 'a4)))
    (if (fneq a4 440.0) (snd-display "a4->frequency: ~A" a4)))
  (let ((a440 (->frequency 440.0)))
    (if (fneq a440 440.0) (snd-display "a440->frequency: ~A" a440)))
  (let ((cs5 (->frequency 'cs5)))
    (if (fneq cs5 554.365) (snd-display "cs5->frequency: ~A" cs5)))
  (let ((df3 (->frequency 'df3)))
    (if (fneq df3 138.591) (snd-display "df3->frequency: ~A" df3)))
  (let ((c1 (->frequency 'cn1)))
    (if (fneq c1 32.703) (snd-display "c1->frequency: ~A" c1)))
  (let ((b8 (->frequency 'b8)))
    (if (fneq b8 7902.132) (snd-display "b8->frequency: ~A" b8)))
  
  (let ((violins (make-sample->file "violins.snd" 1 mus-ldouble mus-next))
	(cellos (make-sample->file "cellos.snd" 1 mus-ldouble mus-next)))

    (let((violin (lambda (beg dur freq amp)
		   (with-temp-sound (:continue-old-file #t :output "violins.snd") 
				    (fm-violin beg dur (->frequency freq #t) amp))))
	 (cello (lambda (beg dur freq amp)
		  (with-temp-sound (:continue-old-file #t :output "cellos.snd") 
				   (fm-violin beg dur (->frequency freq #t) amp :fm-index 1.5)))))
      
      (violin 0 1 'e4 .2)  (violin 1 1.5 'g4 .2)   (violin 2.5 .5 'g3 .2)
      (cello  0 1 'c3 .2)  (cello  1 1.5 'e3 .2)  (cello  2.5 .5 'g2 .2))
    
    (let* ((index (new-sound "test.snd" :channels 1)) ; our overall output file
	   (vs1 (mix "violins.snd"))
	   (cs1 (mix "cellos.snd")))
      (let ((vs (and (pair? vs1) (car vs1)))
	    (cs (and (pair? cs1) (car cs1))))
	
	(mus-close violins)
	(mus-close cellos)
	
	(if (mix? vs)
	    (let ((vsr (make-mix-sampler vs))
		  (csr (make-mix-sampler cs))
		  (fsr (make-sampler 0 index)))
	      
	      (do ((i 0 (+ i 1)))
		  ((= i 1000))
		(let ((v (vsr))
		      (c (csr))
		      (f (fsr)))
		  (if (fneq f (+ c v))
		      (snd-display "multi temp output: ~A != ~A + ~A" f v c))))
	      
	      (free-sampler vsr)
	      (free-sampler csr)
	      (free-sampler fsr)))
	
	(close-sound index)
	(if (file-exists? "violins.snd") (delete-file "violins.snd"))  
	(if (file-exists? "cellos.snd") (delete-file "cellos.snd")))))
  
  (let ((v1 (with-sound ((make-float-vector 2210)) (fm-violin 0 .1 440 .1 :random-vibrato-amplitude 0.0))))
    (if (fneq (float-vector-peak v1) .1) (snd-display "with-sound -> float-vector fm-violin maxamp (opt): ~A" (float-vector-peak v1)))
    (let ((v2 (with-sound ((make-float-vector 2210)) (fm-violin 0 .1 440 .1 :random-vibrato-amplitude 0.0))))
      (if (fneq (float-vector-peak v2) .1) (snd-display "with-sound -> float-vector fm-violin maxamp: ~A" (float-vector-peak v2)))
      (if (not (mus-arrays-equal? v1 v2)) (snd-display "with-sound -> float-vector v1 v2 not equal?")))
    (sound-let ((tmp () (fm-violin 0 .1 440 .1 :random-vibrato-amplitude 0.0)))
	       (let ((v3 (make-float-vector 2210)))
		 (file->array tmp 0 0 2205 v3)
		 (if (not (mus-arrays-equal? v1 v3)) (snd-display "with-sound -> float-vector v1 v3 not equal?"))))
    (with-sound (v1)
      (fm-violin 0 .1 440 .1 :random-vibrato-amplitude 0.0)
      (fm-violin 0 .1 440 .1 :random-vibrato-amplitude 0.0))
    (if (fneq (float-vector-peak v1) .2) (snd-display "with-sound -> float-vector fm-violin maxamp (opt 2): ~A" (float-vector-peak v1))))
  
  (let ((v1 (with-sound ((make-float-vector '(1 2210))) (fm-violin 0 .1 440 .1 :random-vibrato-amplitude 0.0))))
    (if (fneq (maxamp v1) .1) (snd-display "with-sound -> vector2 fm-violin maxamp (opt): ~A" (maxamp v1)))
    (let ((v2 (with-sound ((make-float-vector '(1 2210))) (fm-violin 0 .1 440 .1 :random-vibrato-amplitude 0.0))))
      (if (fneq (maxamp v2) .1) (snd-display "with-sound -> vector2 fm-violin maxamp: ~A" (maxamp v2)))
      (if (not (mus-arrays-equal? v1 v2)) (snd-display "with-sound -> vector2 v1 v2 not equal?")))
    (with-sound (v1)
      (fm-violin 0 .1 440 .1 :random-vibrato-amplitude 0.0)
      (fm-violin 0 .1 440 .1 :random-vibrato-amplitude 0.0))
    (if (fneq (maxamp v1) .2) (snd-display "with-sound -> vector2 fm-violin maxamp (opt 2): ~A" (maxamp v1))))
  
  (set! (locsig-type) mus-interp-linear)
  (let ((v1 (with-sound ((make-float-vector '(2 2210)))
	      (if (not (= (mus-channels *output*) 2)) (snd-display "with-sound *output* chans: ~A" (mus-channels *output*)))
	      (fm-violin 0 .1 440 .1 :degree 45 :random-vibrato-amplitude 0.0))))
    (when (fneq (maxamp v1) .05) 
      (snd-display "with-sound -> vector2 fm-violin maxamp (1 opt): ~A" (maxamp v1)))
    (let ((v2 (with-sound ((make-float-vector '(2 2210))) 
		(fm-violin 0 .1 440 .1 :degree 45 :random-vibrato-amplitude 0.0))))
      (when (fneq (maxamp v2) .05)
	(snd-display "with-sound -> vector2 fm-violin maxamp (2): ~A" (maxamp v2)))
      (if (not (mus-arrays-equal? v1 v2)) (snd-display "with-sound (2 chans) -> vector2 v1 v2 not equal?")))
    (with-sound (v1)
      (fm-violin 0 .1 440 .1 :degree 0 :random-vibrato-amplitude 0.0)
      (fm-violin 0 .1 440 .1 :degree 0 :random-vibrato-amplitude 0.0))
    (if (fneq (maxamp v1) .2) (snd-display "with-sound -> vector2 fm-violin maxamp (opt 2): ~A" (maxamp v1))))
  
  (let ((violin-note (lambda () (fm-violin 0 .1 440 .1 :random-vibrato-amplitude 0.0))))

    (let ((v1 (with-sound ((make-float-vector 2210) :scaled-to .3) (violin-note))))
      (if (fneq (float-vector-peak v1) .3) 
	  (snd-display "with-sound -> float-vector fm-violin maxamp (opt, scaled-to): ~A" (float-vector-peak v1)))
      (let ((v2 (with-sound ((make-float-vector 2210) :scaled-to .3) (violin-note))))
	(if (fneq (float-vector-peak v2) .3) 
	    (snd-display "with-sound -> float-vector fm-violin maxamp scaled-to: ~A" (float-vector-peak v2)))
	(if (not (mus-arrays-equal? v1 v2)) (snd-display "with-sound (scaled-to) -> float-vector v1 v2 not equal?")))
      (with-sound (v1 :scaled-by 2.0)
	(violin-note)
	(violin-note))
      (if (fneq (float-vector-peak v1) .4) (snd-display "with-sound -> float-vector fm-violin maxamp (opt 2 scaled-by): ~A" (float-vector-peak v1))))
    
    (let ((v1 (with-sound ((make-float-vector '(1 2210)) :scaled-to .5) (violin-note))))
      (if (fneq (maxamp v1) .5) 
	  (snd-display "with-sound -> vector2 fm-violin maxamp (opt, scaled-to): ~A" (maxamp v1)))
      (let ((v2 (with-sound ((make-float-vector '(1 2210)) :scaled-to .5) (violin-note))))
	(if (fneq (maxamp v2) .5) 
	    (snd-display "with-sound -> vector2 fm-violin maxamp scaled-to: ~A" (maxamp v2)))
	(if (not (mus-arrays-equal? v1 v2)) (snd-display "with-sound scaled-to -> vector2 v1 v2 not equal?")))
      (with-sound (v1 :scaled-by 0.5)
	(violin-note)
	(violin-note))
      (if (fneq (maxamp v1) .1) 
	  (snd-display "with-sound -> vector2 fm-violin maxamp (opt 2 scaled-by): ~A" (maxamp v1))))
    
    (let ((stats-string ""))
      (with-sound ((make-float-vector 2210) :statistics (lambda (str) (set! stats-string str)))
	(violin-note))
      (if (not (member stats-string '("\n;vector:\n  maxamp: 0.1000\n  compute time: 0.000\n"
				      "\n;vector:\n  maxamp: 0.1000\n  compute time: 0.001\n"
				      "\n;vector:\n  maxamp: 0.1000\n  compute time: 0.002\n"
				      "\n;vector:\n  maxamp: 0.1000\n  compute time: 0.010\n"
				      "\n;vector:\n  maxamp: 0.09999998\n  compute time: 0.001\n"
				      "\n;vector:\n  maxamp: 0.09999998\n  compute time: 0.000\n"
				      "\n;vector:\n  maxamp: 0.1000\n  compute time: 0.180\n")
		       string=?))
	  (snd-display "with-sound to float-vector stats: [~A]" stats-string))
      (with-sound ((make-float-vector '(1 2210)) :scaled-to .5 :statistics (lambda (str) (set! stats-string str)))
	(violin-note))
      (if (not (member stats-string '("\n;vector:\n  maxamp (before scaling): 0.1000\n  compute time: 0.000\n"
				      "\n;vector:\n  maxamp (before scaling): 0.1000\n  compute time: 0.001\n"
				      "\n;vector:\n  maxamp (before scaling): 0.1000\n  compute time: 0.002\n"
				      "\n;vector:\n  maxamp (before scaling): 0.1000\n  compute time: 0.010\n"
				      "\n;vector:\n  maxamp (before scaling): 0.09999998\n  compute time: 0.001\n"
				      "\n;vector:\n  maxamp (before scaling): 0.09999998\n  compute time: 0.000\n"
				      "\n;vector:\n  maxamp (before scaling): 0.1000\n  compute time: 0.009\n")
		       string=?))
	  (snd-display "with-sound to float-vector stats: [~A]" stats-string))
      
      (with-sound ((make-float-vector '(4 2210)) :channels 4 :statistics (lambda (str) (set! stats-string str)))
	(fm-violin 0 .1 440 .1 :degree 0 :random-vibrato-amplitude 0.0)
	(fm-violin 0 .1 440 .2 :degree 90 :random-vibrato-amplitude 0.0)
	(fm-violin 0 .1 440 .3 :degree 180 :random-vibrato-amplitude 0.0)
	(fm-violin 0 .1 440 .4 :degree 270 :random-vibrato-amplitude 0.0)))
    
    (for-each
     (lambda (n)
       ;; testing overwrites here -- just hope we don't crash...
       (let ((v1 (with-sound ((make-float-vector 20) :channels 1)
		   (violin-note))))
	 (if (fneq (v1 0) 0.0) (snd-display "overwrite float-vector with-sound: ~A (~A)" (v1 0) (float-vector-peak v1))))
       
       (let ((v1 (with-sound ((make-float-vector 20) 4)
		   (fm-violin 0 .1 440 .1 :degree 45 :random-vibrato-amplitude 0.0))))
	 (if (fneq (v1 0) 0.0) (snd-display "overwrite float-vector with-sound (4): ~A (~A)" (v1 0) (float-vector-peak v1))))
       
       (let ((v1 (with-sound ((make-float-vector '(4 20)) :channels 4)
		   (fm-violin 0 .1 440 .1 :degree 0 :random-vibrato-amplitude 0.0)
		   (fm-violin 0 .1 440 .2 :degree 90 :random-vibrato-amplitude 0.0)
		   (fm-violin 0 .1 440 .3 :degree 180 :random-vibrato-amplitude 0.0)
		   (fm-violin 0 .1 440 .4 :degree 270 :random-vibrato-amplitude 0.0))))
	 (do ((i 0 (+ i 1))) ((= i 4))
	   (if (fneq (v1 i 0) 0.0) (snd-display "overwrite sd ~D with-sound: ~A" i (v1 i 0)))))
       
       (let ((v1 (with-sound ((make-float-vector '(2 20)) 4)
		   (fm-violin 0 .1 440 .1 :degree 0 :random-vibrato-amplitude 0.0)
		   (fm-violin 0 .1 440 .2 :degree 90 :random-vibrato-amplitude 0.0)
		   (fm-violin 0 .1 440 .3 :degree 180 :random-vibrato-amplitude 0.0)
		   (fm-violin 0 .1 440 .4 :degree 270 :random-vibrato-amplitude 0.0))))
	 (do ((i 0 (+ i 1))) ((= i 2))
	   (if (fneq (v1 i 0) 0.0) (snd-display "overwrite sd (2) ~D with-sound: ~A" i (v1 i 0)))))
       
       (let ((v1 (with-sound ((make-float-vector '(4 20)) :channels 1)
		   (fm-violin 0 .1 440 .1 :degree 0 :random-vibrato-amplitude 0.0)
		   (fm-violin 0 .1 440 .2 :degree 90 :random-vibrato-amplitude 0.0)
		   (fm-violin 0 .1 440 .3 :degree 180 :random-vibrato-amplitude 0.0)
		   (fm-violin 0 .1 440 .4 :degree 270 :random-vibrato-amplitude 0.0))))
	 (do ((i 0 (+ i 1))) ((= i 4))
	   (if (fneq (v1 i 0) 0.0) (snd-display "overwrite sd (4) ~D with-sound: ~A" i (v1 i 0))))))
     '(0 3 6))
    
    ;; reverb cases parallel to above
    (let ((v1 (with-sound ((make-float-vector 44100) :reverb jc-reverb)
		(if (not (= (mus-length *output*) 44100)) (snd-display "ws mus-length float-vector: ~A" (mus-length *output*)))
		(fm-violin 0 .1 440 .1 :random-vibrato-amplitude 0.0 :reverb-amount 0.9))))
      (let ((v4 (with-sound ((make-float-vector 44100)) 
		  (violin-note))))
	(if (mus-arrays-equal? v1 v4) (snd-display "reverb output not written to float-vector?")))
      (if (< (float-vector-peak v1) .28)
	  (snd-display "rev with-sound -> float-vector fm-violin maxamp (opt): ~A" (float-vector-peak v1)))
      (let ((v2 (float-vector-peak (with-sound ((make-float-vector 44100) :reverb jc-reverb) (fm-violin 0 .1 440 .1 :reverb-amount 0.9)))))
	(if (< v2 .28) 
	    (snd-display "rev with-sound -> float-vector fm-violin maxamp: ~A" v2)))
      (with-sound (v1 :channels 1 :reverb jc-reverb)
	(fm-violin 0 .1 440 .1 :reverb-amount 0.9)
	(fm-violin 0 .1 440 .1 :reverb-amount 0.9))
      (if (< (float-vector-peak v1) .28) 
	  (snd-display "rev with-sound -> float-vector fm-violin maxamp (opt 2): ~A" (float-vector-peak v1))))
    
    (let ((v1 (with-sound ((make-float-vector '(1 44100)) :reverb jc-reverb) 
		(if (not (= (mus-length *output*) 44100)) (snd-display "ws mus-length sd: ~A" (mus-length *output*)))
		(fm-violin 0 .1 440 .1 :reverb-amount 0.9 :random-vibrato-amplitude 0.0))))
      (let ((v4 (with-sound ((make-float-vector '(1 44100))) 
		  (violin-note))))
	(if (mus-arrays-equal? v1 v4) (snd-display "reverb output not written to sd?")))
      (if (< (maxamp v1) .23) 
	  (snd-display "rev with-sound -> vector2 fm-violin maxamp (opt): ~A" (maxamp v1)))
      (let ((v2 (maxamp (with-sound ((make-float-vector '(1 44100)) :reverb jc-reverb) (fm-violin 0 .1 440 .1 :reverb-amount 0.9)))))
	(if (< v2 .23) 
	    (snd-display "rev with-sound -> vector2 fm-violin maxamp: ~A" v2)))
      (with-sound (v1 :reverb jc-reverb)
	(fm-violin 0 .1 440 .1 :reverb-amount 0.9)
	(fm-violin 0 .1 440 .1 :reverb-amount 0.9))
      (if (< (maxamp v1) .52) 
	  (snd-display "with-sound -> vector2 fm-violin maxamp (opt 2): ~A" (maxamp v1))))
    
    (set! (locsig-type) mus-interp-linear)
    (let ((v1 (with-sound ((make-float-vector '(2 44100)) :reverb jc-reverb)
		(if (not (= (mus-channels *output*) 2)) 
		    (snd-display "rev with-sound *output* chans: ~A" (mus-channels *output*)))
		(fm-violin 0 .1 440 .1 :degree 45 :reverb-amount 0.9))))
      (when (< (maxamp v1) .23) 
	(snd-display "rev with-sound -> vector2 fm-violin maxamp (1 opt): ~A" (maxamp v1))
	(snd-display "rev with-sound -> vector2 fm-violin maxamp (2 opt): ~A" (maxamp v1)))
      
      (let ((v2 (maxamp (with-sound ((make-float-vector '(2 44100)) :reverb jc-reverb) 
			  (fm-violin 0 .1 440 .1 :degree 45 :reverb-amount 0.9)))))
	(when (< v2 .23) 
	  (snd-display "rev with-sound -> vector2 fm-violin maxamp (2): ~A" v2)
	  (snd-display "rev with-sound -> vector2 fm-violin maxamp (2 2): ~A" v2)))
      (with-sound (v1 :reverb jc-reverb)
	(fm-violin 0 .1 440 .1 :degree 0 :reverb-amount 0.9)
	(fm-violin 0 .1 440 .1 :degree 0 :reverb-amount 0.9))
      (if (< (maxamp v1) .5) 
	  (snd-display "rev with-sound -> vector2 fm-violin maxamp (opt 2): ~A" (maxamp v1))))
    
    (let ((v1 (with-sound ((make-float-vector 44100) :revfile (make-float-vector 44100) :reverb jc-reverb)
		(if (not (= (mus-length *output*) 44100)) (snd-display "1 ws mus-length float-vector: ~A" (mus-length *output*)))
		(if (not (= (mus-length *reverb*) 44100)) (snd-display "1 ws mus-length float-vector rev: ~A" (mus-length *reverb*)))
		(fm-violin 0 .1 440 .1 :random-vibrato-amplitude 0.0 :reverb-amount 0.9))))
      (let ((v4 (with-sound ((make-float-vector 44100)) 
		  (violin-note))))
	(if (mus-arrays-equal? v1 v4) (snd-display "1 reverb output not written to float-vector?")))
      (if (< (float-vector-peak v1) .28)
	  (snd-display "1 rev with-sound -> float-vector fm-violin maxamp (opt): ~A" (float-vector-peak v1)))
      (let ((v2 (with-sound ((make-float-vector 44100) :revfile (make-float-vector 44100) :reverb jc-reverb) 
		  (fm-violin 0 .1 440 .1 :reverb-amount 0.9))))
	(if (< (float-vector-peak v2) .28) 
	    (snd-display "1 rev with-sound -> float-vector fm-violin maxamp: ~A" (float-vector-peak v2)))
	(with-sound (v1 :revfile v2 :channels 1 :reverb jc-reverb)
	  (fm-violin 0 .1 440 .1 :reverb-amount 0.9)
	  (fm-violin 0 .1 440 .1 :reverb-amount 0.9))
	(if (< (float-vector-peak v1) .28) 
	    (snd-display "1 rev with-sound -> float-vector fm-violin maxamp (opt 2): ~A" (float-vector-peak v1)))))
    
    (let ((v1 (with-sound ((make-float-vector '(1 44100)) :revfile (make-float-vector '(1 44100)) :reverb jc-reverb) 
		(if (not (= (mus-length *output*) 44100)) (snd-display "ws mus-length sd: ~A" (mus-length *output*)))
		(fm-violin 0 .1 440 .1 :reverb-amount 0.9 :random-vibrato-amplitude 0.0))))
      (let ((v4 (with-sound ((make-float-vector '(1 44100))) 
		  (violin-note))))
	(if (mus-arrays-equal? v1 v4) (snd-display "2 reverb output not written to sd?")))
      (if (< (maxamp v1) .28) 
	  (snd-display "2 rev with-sound -> vector2 fm-violin maxamp (opt): ~A" (maxamp v1)))
      (let ((v2 (with-sound ((make-float-vector '(1 44100)) :revfile (make-float-vector '(1 44100)) :reverb jc-reverb) 
		  (fm-violin 0 .1 440 .1 :reverb-amount 0.9))))
	(if (< (maxamp v2) .28) 
	    (snd-display "2 rev with-sound -> vector2 fm-violin maxamp: ~A" (maxamp v2)))
	(with-sound (v1 :revfile v2 :reverb jc-reverb)
	  (fm-violin 0 .1 440 .1 :reverb-amount 0.9)
	  (fm-violin 0 .1 440 .1 :reverb-amount 0.9))
	(if (< (maxamp v1) .5) 
	    (snd-display "2 with-sound -> vector2 fm-violin maxamp (opt 2): ~A" (maxamp v1)))))
    
    (set! (locsig-type) mus-interp-linear)
    (let ((v1 (with-sound ((make-float-vector '(2 44100)) :revfile (make-float-vector '(1 44100)) :reverb jc-reverb)
		(if (not (= (mus-channels *output*) 2)) 
		    (snd-display "3 rev with-sound *output* chans: ~A" (mus-channels *output*)))
		(fm-violin 0 .1 440 .1 :degree 45 :reverb-amount 0.9))))
      (when (< (maxamp v1) .23) 
	(snd-display "3 rev with-sound -> vector2 fm-violin maxamp (1 opt): ~A" (maxamp v1))
	(snd-display "3 rev with-sound -> vector2 fm-violin maxamp (2 opt): ~A" (maxamp v1)))
      (let ((v2 (with-sound ((make-float-vector '(2 44100)) :revfile (make-float-vector '(1 44100)) :reverb jc-reverb) 
		  (fm-violin 0 .1 440 .1 :degree 45 :reverb-amount 0.9))))
	(when (< (maxamp v2) .23) 
	  (snd-display "3 rev with-sound -> vector2 fm-violin maxamp (2): ~A" (maxamp v2))
	  (snd-display "3 rev with-sound -> vector2 fm-violin maxamp (2 2): ~A" (maxamp v2)))
	(with-sound (v1 :revfile v2 :reverb jc-reverb)
	  (fm-violin 0 .1 440 .1 :degree 0 :reverb-amount 0.9)
	  (fm-violin 0 .1 440 .1 :degree 0 :reverb-amount 0.9))
	(if (< (maxamp v1) .5) 
	    (snd-display "3 rev with-sound -> vector2 fm-violin maxamp (opt 2): ~A" (maxamp v1)))))
    
    (for-each
     (lambda (n)
       (let ((v2 (float-vector-peak (with-sound ((make-float-vector 400))
				      (simple-outn 0 .01 440 .1 .2 .3 .4 0.0 0.0)))))
	 (if (fneq v2 0.1) (snd-display "outa tests 2 ~A: ~A" n v2)))
       (let ((v3 (float-vector-peak (with-sound ((make-float-vector 400))
				      (simple-outn 0 .01 440 0.0 .5 0.0 0.0 0.0 0.0)))))
	 (if (fneq v3 0.0) (snd-display "outa tests 3 ~A: ~A" n v3)))
       (let ((v4 (float-vector-peak (with-sound ((make-float-vector 4410) :reverb jc-reverb)
				      (simple-outn 0 .01 440 0.2 0.0 0.0 0.0 0.05 0.0)))))
	 (if (fneq v4 0.2) (snd-display "outa tests 4 ~A: ~A" n v4)))
       (let ((v5 (float-vector-peak (with-sound ((make-float-vector 4410) :reverb simple-in-rev :reverb-data '(0.0 1.0 1.0 0.0))
				      (simple-outn 0 .01 440 0.0 0.0 0.0 0.0 0.5 0.0)))))
	 (if (fneq v5 0.5) (snd-display "outa tests 5 ~A: ~A" n v5)))
       (let ((v6 (float-vector-peak (with-sound ((make-float-vector 400))
				      (simple-outn 0 .01 440 0.5 0.0 0.0 0.0 0.0 0.0)
				      (simple-outn 0 .01 440 0.2 0.0 0.0 0.0 0.0 0.0)))))
	 (if (fneq v6 0.7) (snd-display "outa tests 11 ~A: ~A" n v6)))
       (let ((mx1 (maxamp
		   (with-sound ((make-float-vector '(1 4410)))
		     (simple-outn 0 .01 440 .1 .2 .3 .4 0.0 0.0)))))
	 (if (fneq mx1 .1) (snd-display "outa tests 6 ~A: ~A" n mx1)))
       (let ((mx3 (maxamp
		   (with-sound ((make-float-vector '(2 4410)))
		     (simple-outn 0 .01 440 0.0 0.0 .3 .4 0.0 0.0)))))
	 (if (fneq mx3 0.0) (snd-display "outa tests 8 ~A: ~A" n mx3)))
       (let ((mx4 (maxamp 
		   (with-sound ((make-float-vector '(4 4410)) :reverb simple-in-rev :reverb-channels 2 :reverb-data '(0.0 1.0 1.0 1.0))
		     (simple-outn 0 .01 440 0.0 0.0 0.0 0.0 0.5 0.25)))))
	 (if (fneq mx4 0.5) (snd-display "outa tests 9 ~A: ~A" n mx4)))
       (let ((mx5 (maxamp
		   (with-sound ((make-float-vector '(4 4410)) :reverb simple-in-rev :reverb-channels 1 :reverb-data '(0.0 1.0 1.0 1.0))
		     (simple-outn 0 .01 440 0.0 0.0 0.0 0.0 0.5 0.25)))))
	 (if (fneq mx5 0.5) (snd-display "outa tests 10 ~A: ~A" n mx5)))
       (let ((mx6 (maxamp
		   (with-sound ((make-float-vector '(4 4410)))
		     (simple-outn 0 .01 440 .1 .2 .3 .4 0.0 0.0)
		     (simple-outn 0 .01 440 .1 .2 .3 .4 0.0 0.0)))))
	 (if (fneq mx6 .8) (snd-display "outa tests 12 ~A: ~A" n mx6)))
       (let ((v1 (with-sound ((make-float-vector 4410))
		   (simple-outn 0 .01 440 .1 .2 .3 .4 0.0 0.0))))
	 (if (fneq (float-vector-peak v1) 0.1) (snd-display "outa tests 1 ~A: ~A" n (float-vector-peak v1)))
	 (with-sound (v1 :continue-old-file #t)
	   (simple-outn 0 .1 440 .1 .2 .3 .4 0.0 0.0))
	 (if (fneq (float-vector-peak v1) 0.2) (snd-display "outa tests 13 ~A: ~A" n (float-vector-peak v1)))
	 (let ((sd2 (with-sound ((make-float-vector '(4 4410)))
		      (simple-outn 0 .01 440 .1 .2 .3 .4 0.0 0.0))))
	   (let ((mx2 (maxamp sd2)))
	     (if (fneq mx2 .4) (snd-display "outa tests 7 ~A: ~A" n mx2)))
	   (with-sound (sd2 :continue-old-file #t)
	     (simple-outn 0 .1 440 .1 .2 .3 .4 0.0 0.0))
	   (let ((mx7 (maxamp sd2)))
	     (if (fneq mx7 .8) (snd-display "outa tests 14 ~A: ~A" n mx7))))))
     '(0 6))
    
    (let ((ind (find-sound
		(with-sound ()
		  (fm-violin 0 .1 880 .1 :random-vibrato-amplitude 0.0)
		  (let ((v1 (with-temp-sound (:output (make-float-vector 2210))
					     (violin-note)))
			(sd1 (with-temp-sound (:output (make-float-vector '(1 2210)))
					      (fm-violin 0 .1 660 .1 :random-vibrato-amplitude 0.0))))
		    (do ((i 0 (+ i 1)))
			((= i 2205))
		      (outa i (+ (v1 i) (sd1 0 i)))))
		  (fm-violin 0 .1 220.0 .1 :random-vibrato-amplitude 0.0)))))
      (if (not (sound? ind))
	  (snd-display "can't find mixed with-sound output")
	  (let ((mx (maxamp ind 0)))
	    (if (< mx .35) (snd-display "mixed with-sound max: ~A" mx))
	    (if (not (mus-arrays-equal? (channel->float-vector 1000 10) #r(0.255 0.275 0.316 0.364 0.391 0.379 0.337 0.283 0.228 0.170)))
		(snd-display "mixed with-sound: ~A" (channel->float-vector 1000 10)))
	    (close-sound ind))))
    
    (let ((ind (find-sound
		(with-sound ()
		  (fm-violin 0 .1 880 .1 :random-vibrato-amplitude 0.0)
		  (sound-let ((v1 (:output (make-float-vector 2210))
				  (violin-note))
			      (sd1 (:output (make-float-vector '(1 2210)))
				   (fm-violin 0 .1 660 .1 :random-vibrato-amplitude 0.0))
			      (fs1 ()
				   (fm-violin 0 .1 110 .1 :random-vibrato-amplitude 0.0)))
			     (mus-file-mix *output* fs1)
			     (do ((i 0 (+ i 1)))
				 ((= i 2205))
			       (outa i (+ (v1 i) (sd1 0 i)))))
		  (fm-violin 0 .1 220.0 .1 :random-vibrato-amplitude 0.0)))))
      (if (not (sound? ind))
	  (snd-display "can't find mixed with-sound sound-let output")
	  (let ((mx (maxamp ind 0)))
	    (if (< mx .375) (snd-display "mixed with-sound max: ~A" mx))
	    (if (not (mus-arrays-equal? (channel->float-vector 1000 10) #r(0.349 0.370 0.412 0.461 0.489 0.478 0.436 0.383 0.328 0.270)))
		(snd-display "mixed with-sound via sound-let: ~A" (channel->float-vector 1000 10)))
	    (close-sound ind)))))
  
  (let ((snd (find-sound (with-mixed-sound () (fm-violin 0 .1 440 .1)))))
    (if (not (sound? snd)) (snd-display "with-mixed-sound (1): ~A?" res))
    (let ((mxs (mixes snd 0))
	  (info (sound-property 'with-mixed-sound-info snd)))
      (if (not (pair? mxs))
	  (snd-display "with-mixed-sound (1) mixes: ~A" mxs))
      (if (not (and (equal? (car (info 0)) (car mxs))
		    (= (cadr (info 0)) 0)
		    (= (caddr (info 0)) 1)))
	  (snd-display "with-mixed-sound info (1) 0: ~A" (info 0))))
    (if (ffneq (maxamp snd) .1)
	(snd-display "with-mixed-sound (1) 0: ~A" (maxamp snd)))
    (close-sound snd))
  
  (let ((snd (find-sound (with-mixed-sound (:srate 44100) 
					   (fm-violin 0 .1 440 .1) 
					   (fm-violin 1 .1 660 .1)))))
    (if (not (sound? snd)) (snd-display "with-mixed-sound (2): ~A?" res))
    (let ((mxs (mixes snd 0))
	  (info (sound-property 'with-mixed-sound-info snd)))
      (if (not (and (pair? mxs)
		    (= (length mxs) 2)))
	  (snd-display "with-mixed-sound mixes (2): ~A" mxs))
      (if (not (and (equal? (car (info 0)) (car mxs))
		    (= (cadr (info 0)) 0)
		    (= (caddr (info 0)) 1)))
	  (snd-display "with-mixed-sound info (2) 0: ~A" (info 0)))
      (if (not (and (equal? (car (info 1)) (cadr mxs))
		    (= (cadr (info 1)) 44100)
		    (= (caddr (info 1)) 1)))
	  (snd-display "with-mixed-sound info (2) 1: ~A" (info 1)))
      (if (or (not (member (framples snd) '(48510 48511) =))
	      (fneq (maxamp snd) .1))
	  (snd-display "with-mixed-sound 0 (2): ~A ~A" (framples snd) (maxamp snd)))
      (close-sound snd)))
  
  (let ((snd (find-sound (with-mixed-sound (:channels 2 :srate 44100) 
					   (fm-violin 0 .1 440 .1 :degree 0) 
					   (fm-violin 1 .1 660 .1 :degree 45)))))
    (let ((mxs (mixes snd))
	  (info (sound-property 'with-mixed-sound-info snd)))
      (if (not (and (= (length mxs) 2)
		    (= (length (car mxs)) 2)
		    (= (length info) 2)
		    (equal? (caar info) (caar mxs))))
	  (snd-display "with-mixed-sound (3) 1: ~A ~A" mxs info))
      (close-sound snd)))
  
  (let* ((snd (find-sound (with-marked-sound () 
					     (fm-violin 0 .1 440 .1) 
					     (fm-violin 1 .1 660 .1))))
	 (mxs (marks snd 0)))
    (if (not (= (length mxs) 2))
	(snd-display "with-marked-sound marks: ~A " mxs)
	(begin
	  (if (not (string=? (mark-name (car mxs)) "fm-violin 0 0.1"))
	      (snd-display "with-marked-sound name: ~A" (mark-name (car mxs))))
	  (if (fneq (maxamp snd) .1)
	      (snd-display "with-marked-sound maxamp: ~A" (maxamp snd)))))
    (close-sound snd))
  
  (set! (hook-functions mark-click-hook) ())
  (set! (hook-functions mix-click-hook) ())
  (set! (hook-functions mix-drag-hook) ())
  
  
  ;; generators.scm

  (let ((snd (find-sound (with-sound (:clipped #f)
			    (do ((gen (make-ercos 100 :r 1.0))
				 (i 0 (+ i 1)))
				((= i base-length))
			      (outa i (ercos gen)))))))
    (if (not (sound? snd)) (snd-display "ercos: ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "ercos max: ~A" (maxamp snd))))
    
  (let ((snd (find-sound (with-sound (:clipped #f)  
			   (let ((gen (make-ercos 100 :r 0.1)))
			     (with-let gen
			       (do ((g (curlet))
				    (t-env (make-env '(0 .1 1 2) :length 20000))
				    (poly-coeffs (mus-data osc))
				    (i 0 (+ i 1)))
				   ((= i base-length))
				 (set! r (env t-env))
				 (set! cosh-t (cosh r))
				 (float-vector-set! poly-coeffs 0 cosh-t)
				 (let ((exp-t (exp (- r))))
				   (set! offset (/ (- 1.0 exp-t) (* 2.0 exp-t)))
				   (set! scaler (* (sinh r) offset)))
				 (outa i (ercos g)))))))))
    (if (not (sound? snd)) (snd-display "ercos 1: ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "ercos 1 max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-erssb 1000.0 0.1 1.0))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (erssb gen)))))))
    (if (not (sound? snd)) (snd-display "erssb: ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "erssb max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-noddsin 100 :n 10))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (noddsin gen)))))))
    (if (not (sound? snd)) (snd-display "noddsin: ~A" snd))
    (if (ffneq (maxamp snd) 1.0) (snd-display "noddsin max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-noddcos 100 :n 10))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (noddcos gen)))))))
    (if (not (sound? snd)) (snd-display "noddcos: ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "noddcos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-noddssb 1000.0 0.1 5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (noddssb gen)))))))
    (if (not (sound? snd)) (snd-display "noddssb: ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "noddssb max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f) 
			   (do ((gen (make-asyfm 2000.0 :ratio .1))
				(i 0 (+ i 1)))
			       ((= i 1000))
			     (outa i (asyfm-J gen)))))))
    (if (not (sound? snd)) (snd-display "asyfm-J ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "asyfm-J max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f) 
			   (do ((gen (make-asyfm 2000.0 :ratio .1 :index 1))
				(r-env (make-env '(0 -4 1 -1) :length 20000))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (set! (gen 'r) (env r-env))
			     (outa i (asyfm-J gen)))))))
    (if (not (sound? snd)) (snd-display "asyfm-J1 ~A" snd))
    (if (ffneq (maxamp snd) 1.0) (snd-display "asyfm-J1 max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f) 
			   (do ((gen (make-asyfm 2000.0 :ratio .1))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (asyfm-I gen)))))))
    (if (not (sound? snd)) (snd-display "asyfm-I ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "asyfm-I max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f :statistics #t)
			   (do ((gen (make-nrcos 400.0 :n 5 :r 0.5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (nrcos gen)))))))
    (if (not (sound? snd)) (snd-display "nrcos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "nrcos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-noid 100.0 3 'min-peak))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (noid gen)))))))
    (if (not (sound? snd)) (snd-display "noid ~A" snd))
    (if (ffneq (maxamp snd) 0.6599) (snd-display "noid min-peak max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-noid 100.0 3 'max-peak))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (noid gen)))))))
    (if (not (sound? snd)) (snd-display "noid ~A" snd))
    (if (ffneq (maxamp snd) 1.0) (snd-display "noid max-peak max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (let ((gen (make-nrcos 100 :n 15 :r 0.5))
				 (indr (make-env '(0 -1 1 1) :length 40000 :scaler 0.9999)))
			     (let ((set-nrcos-scaler (setter (gen 'mus-scaler))))
			       (do ((i 0 (+ i 1)))
				   ((= i base-length))
				 (set-nrcos-scaler gen (env indr))
				 (outa i (nrcos gen)))))))))
    (if (not (sound? snd)) (snd-display "nrcos with scaler ~A" snd))
    ;; this is not a new problem -- was the scaler supposed to fix maxamp?
    )
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-ncos2 100.0 :n 10))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (ncos2 gen)))))))
    (if (not (sound? snd)) (snd-display "ncos2 ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "ncos2 max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-ncos4 100.0 :n 10))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (ncos4 gen)))))))
    (if (not (sound? snd)) (snd-display "ncos4 ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "ncos4 max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-npcos 100.0 :n 10))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (npcos gen)))))))
    (if (not (sound? snd)) (snd-display "npcos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "npcos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-n1cos 100.0 :n 10))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (n1cos gen)))))))
    (if (not (sound? snd)) (snd-display "n1cos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "n1cos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-rcos 100.0 :r 0.5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (rcos gen)))))))
    (if (not (sound? snd)) (snd-display "rcos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "rcos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-bess 100.0 :n 0))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (bess gen)))))))
    (if (not (sound? snd)) (snd-display "bess ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "bess max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen1 (make-bess 400.0 :n 1))
				(gen2 (make-bess 400.0 :n 1))
				(vol (make-env '(0 0 1 1 9 1 10 0) :scaler 2.0 :length 20000))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (bess gen1 (* (env vol) (bess gen2 0.0)))))))))
    (if (not (sound? snd)) (snd-display "bess 1 ~A" snd))
    (if (ffneq (maxamp snd) 1.0) (snd-display "bess 1 max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen1 (make-bess 400.0 :n 1))
				(gen2 (make-oscil 400.0))
				(vol (make-env '(0 1 1 0) :scaler 1.0 :length 20000))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (bess gen1 (* (env vol) (oscil gen2 0.0)))))))))
    (if (not (sound? snd)) (snd-display "bess 2 ~A" snd))
    (if (ffneq (maxamp snd) 1.0) (snd-display "bess 2 max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-eoddcos 400.0 :r 1.0))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (eoddcos gen)))))))
    (if (not (sound? snd)) (snd-display "eoddcos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "eoddcos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-eoddcos 400.0 :r 0.0))
				(a-env (make-env '(0 0 1 1) :length 10000))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (set! (gen 'r) (env a-env))
			     (outa i (eoddcos gen)))))))
    (if (not (sound? snd)) (snd-display "eoddcos 1 ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "eoddcos 1 max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (let ((gen1 (make-eoddcos 400.0 :r 0.0))
				 (gen2 (make-oscil 400.0))
				 (a-env (make-env '(0 0 1 1) :length 10000)))
			     (do ((i 0 (+ i 1)))
				 ((= i base-length))
			       (set! (gen1 'r) (env a-env))
			       (outa i (eoddcos gen1 (* .1 (oscil gen2))))))))))
    (if (not (sound? snd)) (snd-display "eoddcos 2 ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "eoddcos 2 max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-nssb 2000.0 0.05 3))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (* .3 (nssb gen))))))))
    (if (not (sound? snd)) (snd-display "nssb ~A" snd))
    (if (fneq (maxamp snd) 0.3) (snd-display "nssb max: ~A" (maxamp snd))))
  
  (let ()
    (define (test-nssb-0)
      (let ((g1 (make-nssb 10.0 1.0 10))
	    (g2 (make-nssb 10.0 1.0 10)))
	(do ((i 0 (+ i 1)))
	    ((= i 10))
	  (let ((v1 (nssb g1 1.0))
		(v2 (nssb g2 1.0)))
	    (if (> (abs (- v1 v2)) 1e-6)
		(snd-display "nssb ~D (0): ~A ~A" i v1 v2)))
	  (let ((v1 (nssb g1 0.0))
		(v2 (nssb g2)))
	    (if (> (abs (- v1 v2)) 1e-6)
		(snd-display "nssb ~D (1): ~A ~A" i v1 v2))))))
    
    (define (test-nssb-1)
      (let ((g1 (make-nssb 10.0 1.0 1.0)))
	(nssb g1 1.0)
	(if (not (= (g1 'fm) 1.0)) (snd-display "nssb 1: ~A" (g1 'fm)))
	(nssb g1 0.0)
	(if (not (= (g1 'fm) 0.0)) (snd-display "nssb 2: ~A" (g1 'fm)))
	(nssb g1 1.0)
	(if (not (= (g1 'fm) 1.0)) (snd-display "nssb 3: ~A" (g1 'fm)))
	(nssb g1)
	(if (not (= (g1 'fm) 0.0)) (snd-display "nssb 4: ~A" (g1 'fm)))))
    
    (test-nssb-0)
    (test-nssb-0)
    
    (test-nssb-1)
    (test-nssb-1))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-nrssb 2000.0 0.05 3 0.5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (nrssb gen)))))))
    (if (not (sound? snd)) (snd-display "nrssb ~A" snd))
    (if (fneq (maxamp snd) 0.777) (snd-display "nrssb max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-rkcos 440.0 :r 0.5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (rkcos gen)))))))
    (if (not (sound? snd)) (snd-display "rkcos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "rkcos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-rk!cos 440.0 :r 0.5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (rk!cos gen)))))))
    (if (not (sound? snd)) (snd-display "rk!cos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "rk!cos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-r2k!cos 440.0 :r 0.5 :k 3.0))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (r2k!cos gen)))))))
    (if (not (sound? snd)) (snd-display "r2k!cos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "r2k!cos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-k2sin 440.0))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (k2sin gen)))))))
    (if (not (sound? snd)) (snd-display "k2sin ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "k2sin max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-k2cos 440.0))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (k2cos gen)))))))
    (if (not (sound? snd)) (snd-display "k2cos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "k2cos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-k2ssb 1000.0 0.1))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (k2ssb gen)))))))
    (if (not (sound? snd)) (snd-display "k2ssb ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "k2ssb max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-rssb 1000 0.1 0.5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (rssb gen)))))))
    (if (not (sound? snd)) (snd-display "rssb ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "rssb max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-dblsum 100 0.5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (* .47 (dblsum gen)))))))) ; k starts at 0, so maxamp would be 2 except something else is wrong
    (if (not (sound? snd)) (snd-display "dblsum ~A" snd))
    (if (> (maxamp snd) 1.0) (snd-display "dblsum max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-nkssb 1000.0 0.1 5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (nkssb gen)))))))
    (if (not (sound? snd)) (snd-display "nkssb ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "nkssb max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (let ((gen (make-nkssb 1000.0 0.1 5))
				 (vib (make-polywave 5.0 (list 1 (hz->radians 50.0))  mus-chebyshev-second-kind)))
			     (do ((i 0 (+ i 1)))
				 ((= i base-length))
			       (outa i (nkssb gen (polywave vib)))))))))
    (if (not (sound? snd)) (snd-display "nkssb 1 ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "nkssb 1 max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (let ((gen (make-nkssb 1000.0 0.1 5))
				 (move (make-env '(0 1 1 -1) :length 30000))
				 (vib (make-polywave 5.0 (list 1 (hz->radians 50.0)) mus-chebyshev-second-kind)))
			     (do ((i 0 (+ i 1)))
				 ((= i base-length))
			       (outa i (nkssb-interp gen (polywave vib) (env move)))))))))
    (if (not (sound? snd)) (snd-display "nkssb 2 ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "nkssb 2 max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-rkoddssb 1000.0 0.1 0.5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (rkoddssb gen)))))))
    (if (not (sound? snd)) (snd-display "rkoddssb ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "rkoddssb max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-krksin 440.0 0.5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (krksin gen)))))))
    (if (not (sound? snd)) (snd-display "krksin ~A" snd)))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-abcos 100.0 0.5 0.25))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (abcos gen)))))))
    (if (not (sound? snd)) (snd-display "abcos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "abcos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f :statistics #t)
			   (do ((gen (make-absin 100.0 0.5 0.25))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (absin gen)))))))
    (if (not (sound? snd)) (snd-display "absin ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "absin max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-r2k2cos 100.0 1.0))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (r2k2cos gen)))))))
    (if (not (sound? snd)) (snd-display "r2k2cos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "r2k2cos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-jjcos 100.0 :a 1.0 :r 1.0 :k 1))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (jjcos gen)))))))
    (if (not (sound? snd)) (snd-display "jjcos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "jjcos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-j0evencos 100.0 1.0))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (j0evencos gen)))))))
    (if (not (sound? snd)) (snd-display "j0evencos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "j0evencos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-rksin 100.0 :r 0.5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (rksin gen)))))))
    (if (not (sound? snd)) (snd-display "rksin ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "rksin max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-rkssb 1000.0 0.1 :r 0.5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (rkssb gen)))))))
    (if (not (sound? snd)) (snd-display "rkssb ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "rkssb max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-rk!ssb 1000.0 0.1 :r 0.5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (rk!ssb gen)))))))
    (if (not (sound? snd)) (snd-display "rk!ssb ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "rk!ssb max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-jpcos 100.0 :a 1.0 :r 0.99 :k 1))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (jpcos gen)))))))
    (if (not (sound? snd)) (snd-display "jpcos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "jpcos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-j2cos 100.0 :r 1.0 :n 0))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (j2cos gen)))))))
    (if (not (sound? snd)) (snd-display "j2cos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "j2cos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-nxysin 300 1/3 3))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (nxysin gen)))))))
    (if (not (sound? snd)) (snd-display "nxysin ~A" snd)))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-nxycos 300 1/3 3))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (nxycos gen)))))))
    (if (not (sound? snd)) (snd-display "nxycos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "nxycos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-nxy1cos 300 1/3 3))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (nxy1cos gen)))))))
    (if (not (sound? snd)) (snd-display "nxy1cos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "nxy1cos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-nxy1sin 300 1/3 3))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (nxy1sin gen)))))))
    (if (not (sound? snd)) (snd-display "nxy1sin ~A" snd))
    (if (fneq (maxamp snd) 0.951) (snd-display "nxy1sin max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f :statistics #t)
			   (do ((gen (make-nrxysin 1000 0.1 5 0.5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (nrxysin gen)))))))
    (if (not (sound? snd)) (snd-display "nrxysin ~A" snd))
    (if (fneq (maxamp snd) 0.985) (snd-display "nrxysin max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-nrxycos 1000 0.1 5 0.5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (nrxycos gen)))))))
    (if (not (sound? snd)) (snd-display "nrxycos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "nrxycos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-nrxycos 1000 0.1 15 0.5))
				(indr (make-env '(0 -1 1 1) :length 40000 :scaler 0.9999))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (set! (mus-scaler gen) (env indr)) 
			     (outa i (nrxycos gen)))))))
    (if (not (sound? snd)) (snd-display "nrxycos with scaler ~A" snd))
    (if (fneq (maxamp snd) 0.992) (snd-display "nrxycos with scaler max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((black4 (make-blackman 440.0))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (blackman black4 0.0)))))))
    (if (not (sound? snd)) (snd-display "blackman ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "blackman max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((black4 (make-sinc-train 440.0 10))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (sinc-train black4 0.0)))))))
    (if (not (sound? snd)) (snd-display "sinc-train ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "sinc-train max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-k3sin 100.0))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (k3sin gen)))))))
    (if (not (sound? snd)) (snd-display "k3sin ~A" snd))
    (if (ffneq (maxamp snd) 1.0) (snd-display "k3sin max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f :statistics #t)
			   (do ((gen (make-izcos 100.0 1.0))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (izcos gen)))))))
    (if (not (sound? snd)) (snd-display "izcos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "izcos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-rxysin 1000 0.1 0.5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (* .5 (rxysin gen))))))))
    (if (not (sound? snd)) (snd-display "rxysin ~A" snd))
    (if (> (maxamp snd) 1.0) (snd-display "rxysin max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-rxycos 1000 0.1 0.5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (rxycos gen)))))))
    (if (not (sound? snd)) (snd-display "rxycos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "rxycos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f :srate 44100)
			   (do ((gen (make-safe-rxycos 1000 0.1 0.5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (safe-rxycos gen)))))))
    (if (not (sound? snd)) (snd-display "safe-rxycos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "safe-rxycos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f :channels 2 :srate 44100)
		(let ((gen1 (make-safe-rxycos 1000 1 0.99))
		      (gen2 (make-safe-rxycos 1000 1 0.99))
		      (frqf (make-env '(0 0 1 1) :length 10000 :scaler (hz->radians 1000))))
		  (let ((set-freq (setter (gen2 'mus-frequency))))
		    (do ((i 0 (+ i 1)))
			((= i base-length))
		      (let ((fm (env frqf)))
			(set-freq gen2 (+ 1000 (radians->hz fm)))
			(outa i (safe-rxycos gen1 fm)))
		      (outb i (safe-rxycos gen2 0.0)))))))))
    (if (not (sound? snd)) (snd-display "safe-rxycos 1 ~A" snd)))
  
  (let* ((base-r 0.0)
	 (snd (find-sound (with-sound (:clipped #f :channels 2 :srate 44100)
		(let ((gen1 (make-safe-rxycos 1000 .1 0.99))
		      (gen2 (make-safe-rxycos 1000 .1 0.99))
		      (frqf (make-env '(0 0 1 1) :length 10000 :scaler (hz->radians 1000))))
		  (let ((set-freq (setter (gen2 'mus-frequency))))
		    (set! base-r (gen1 'r))
		    (do ((i 0 (+ i 1)))
			((= i base-length))
		      (let ((fm (env frqf)))
			(set-freq gen2 (+ 1000 (radians->hz fm)))
			(outa i (safe-rxycos gen1 fm)))
		      (outb i (safe-rxycos gen2 0.0)))))))))
    (if (not (sound? snd)) (snd-display "safe-rxycos 2 ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "safe-rxycos 2 max: ~A" (maxamp snd)))
    (if (fneq base-r .951) (snd-display "safe-rxycos-r 2 base: ~A" base-r)))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-rxyk!sin 1000 0.1 0.5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (rxyk!sin gen)))))))
    (if (not (sound? snd)) (snd-display "rxyk!sin ~A" snd))
    (if (fneq (maxamp snd) 0.992) (snd-display "rxyk!sin max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-rxyk!cos 1000 0.1 0.5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (rxyk!cos gen)))))))
    (if (not (sound? snd)) (snd-display "rxyk!cos ~A" snd))
    (if (ffneq (maxamp snd) 1.0) (snd-display "rxyk!cos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f :statistics #t :play #f)
			   (do ((gen (make-nsincos 100.0 3))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (nsincos gen)))))))
    (if (not (sound? snd)) (snd-display "nsincos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "nsincos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f :play #f)
			   (do ((gen (make-nchoosekcos 2000.0 0.05 10))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (nchoosekcos gen)))))))
    (if (not (sound? snd)) (snd-display "nchoosekcos ~A" snd))
    (if (ffneq (maxamp snd) 1.0) (snd-display "nchoosekcos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound ()
			   (do ((gen (make-adjustable-square-wave 100 .2 .5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (adjustable-square-wave gen)))))))
    (if (not (sound? snd)) (snd-display "adj sq ~A" snd))
    (if (fneq (maxamp snd) 0.5) (snd-display "adj sq max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound ()
			   (do ((gen (make-adjustable-triangle-wave 100 .2 .5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (adjustable-triangle-wave gen)))))))
    (if (not (sound? snd)) (snd-display "adj tri ~A" snd))
    (if (ffneq (maxamp snd) 0.5) (snd-display "adj tri max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound ()
			   (do ((gen (make-adjustable-sawtooth-wave 100 .2 .5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (adjustable-sawtooth-wave gen)))))))
    (if (not (sound? snd)) (snd-display "adj saw ~A" snd))
    (if (ffneq (maxamp snd) 0.5) (snd-display "adj saw max: ~A" (maxamp snd))))
  
  (with-sound (:clipped #f) ; at least run the thing -- not sure how to test this automatically
    (let ((gen (make-pink-noise 12)))
      (do ((i 0 (+ i 1)))
	  ((= i base-length))
	(outa i (pink-noise gen)))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-brown-noise 100.0))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (brown-noise gen)))))))
    (if (not (sound? snd)) (snd-display "brown-noise ~A" snd))
    (if (< (maxamp snd) 0.01) (snd-display "brown-noise max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-green-noise 100.0))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (green-noise gen)))))))
    (if (not (sound? snd)) (snd-display "green-noise ~A" snd))
    (if (not (<= 0.01 (maxamp snd) 1.0)) (snd-display "green-noise max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-green-noise 100.0 0.1 -0.1 0.5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (green-noise gen)))))))
    (if (not (sound? snd)) (snd-display "green-noise .5 ~A" snd))
    (if (not (<= 0.01 (maxamp snd) 0.5)) (snd-display "green-noise .5 max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-green-noise-interp 100.0))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (green-noise-interp gen)))))))
    (if (not (sound? snd)) (snd-display "green-noise-interp ~A" snd))
    (if (not (<= 0.01 (maxamp snd) 1.0))  (snd-display "green-noise-interp max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-green-noise-interp 100.0 0.1 -0.1 0.5))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (green-noise-interp gen)))))))
    (if (not (sound? snd)) (snd-display "green-noise-interp .5 ~A" snd))
    (if (not (<= 0.01 (maxamp snd) 0.5))  (snd-display "green-noise-interp .5 max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen (make-tanhsin 440.0 2.0))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (tanhsin gen)))))))
    (if (not (sound? snd)) (snd-display "tanhsin ~A" snd))
    (if (> (abs (- 1.0 (maxamp snd))) 0.1) (snd-display "tanhsin max: ~A" (maxamp snd))))
  
  (if (not (provided? 'snd-nogui))
      (let* ((snd (new-sound))
	     (ft (make-moving-fft (make-readin "oboe.snd")))
	     (data (make-float-vector 256)))
	(set! (lisp-graph?) #t)
	(do ((i 0 (+ i 1)))
	    ((= i base-length))
	  (when (moving-fft ft)
	    (float-vector-subseq (mus-xcoeffs ft) 0 255 data)
	    (graph data "fft" 0.0 11025.0 0.0 0.1 snd 0 #t)))
	(close-sound snd)))
  
  (test-sv)
  
  (let ((rd (make-readin "1a.snd"))
	(cur-srate (mus-sound-srate "1a.snd")))
    (let-temporarily ((*clm-srate* cur-srate))
      (let ((pitch (moving-pitch (make-moving-pitch rd))))
	(if (not (>= 443.0 pitch 439.0))
	    (snd-display "moving-pitch 1a: ~A" pitch)))))
  
  (let ((val (make-vector 3)))
    (set! (val 0) (make-nrcos 100))  
    (set! (val 1) (make-nrcos 200))  
    (set! (val 2) (make-nrcos 300))
    (let ((frq (mus-frequency (vector-ref val 1))))
      (if (fneq frq 200.0) (snd-display "defgen vect freq: ~A" frq))))
  
  (let ((val (make-vector 3)))
    (set! (val 0) (make-nrcos 100))  
    (set! (val 1) (make-nrcos 200))  
    (set! (val 2) (make-nrcos 300))
    (let ((frq (+ (mus-frequency (vector-ref val 0))
		  (mus-frequency (vector-ref val 1))
		  (mus-frequency (vector-ref val 2)))))
      (if (fneq frq 600.0) (snd-display "defgen vect freq 1: ~A" frq))))
  
  (let ((val (make-vector 3)))
    (set! (val 0) (make-nrcos 100))  
    (set! (val 1) (make-nrcos 200))  
    (set! (val 2) (make-nrcos 300))
    (set! (mus-frequency (vector-ref val 1)) 500.0)
    (let ((frq (mus-frequency (vector-ref val 1))))
      (if (fneq frq 500.0) (snd-display "defgen set freq: ~A ~A" frq (mus-frequency (vector-ref val 1))))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (let ((v (make-vector 2 #f)))
			     (set! (v 0) (make-nrcos 440 10 .5))    
			     (set! (v 1) (make-nrcos 440 10 .5))    
			     (do ((i 0 (+ i 1)))
				 ((= i base-length))
			       (outa i (nrcos (vector-ref v 0) 0.0))))))))
    (if (not (sound? snd)) (snd-display "vect nrcos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "vect nrcos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (let ((val (make-vector 2)))
			     (set! (val 0) (make-nrcos 100 1 .1))  
			     (set! (val 1) (make-nrcos 200 1 .1))  
			     (do ((i 0 (+ i 1)))
				 ((= i base-length))
			       (outa i (* .5 (+ (nrcos (vector-ref val 0) 0.0)
						(nrcos (vector-ref val 1) 0.0))))))))))
    (if (not (sound? snd)) (snd-display "vect 2 nrcos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "vect 2 nrcos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (do ((gen1 (make-nrcos 100 1 .1))
				(gen2 (make-nrcos 200 1 .1))
				(i 0 (+ i 1)))
			       ((= i base-length))
			     (outa i (* .5 (+ (nrcos gen1 0.0)
					      (nrcos gen2 0.0)))))))))
    (if (not (sound? snd)) (snd-display "no vect 2 nrcos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "no vect 2 nrcos max: ~A" (maxamp snd))))
  
  (let ((snd (find-sound (with-sound (:clipped #f)
			   (let ((v (make-vector 2 #f)))
			     (set! (v 0) (make-nrcos 440 10 .5))    
			     (set! (v 1) (make-nrcos 440 10 .5))    
			     (do ((i 0 (+ i 1))
				  (gen (vector-ref v 0)))
				 ((= i base-length))
			       (outa i (nrcos gen))))))))
    (if (not (sound? snd)) (snd-display "vect let nrcos ~A" snd))
    (if (fneq (maxamp snd) 1.0) (snd-display "vect let nrcos max: ~A" (maxamp snd))))
  
  (with-sound (:play #t)
    (define ifunc 
      (let ((ampf (make-env '(0.0 0.0 0.011 0.147 0.023 0.131 0.028 0.034 0.059 0.0 0.063 0.153 0.067 0.113 
			      0.072 0.391 0.081 0.095 0.088 0.052 0.102 0.025 0.124 0.0 0.131 0.452 0.139 0.327 
			      0.144 0.099 0.156 0.097 0.160 0.048 0.186 0.0 0.194 0.438 0.200 0.366 0.201 0.156 
			      0.211 0.063 0.247 0.0 0.256 0.628 0.268 0.154 0.274 0.190 0.285 0.027 0.296 0.059 
			      0.309 0.031 0.312 0.481 0.322 0.939 0.331 0.314 0.351 0.061 0.363 0.099 0.374 0.056 
			      0.377 0.438 0.389 0.858 0.394 0.467 0.403 0.241 0.414 0.197 0.415 0.127 0.425 0.075 
			      0.436 0.090 0.441 0.526 0.454 0.869 0.471 0.239 0.490 0.029 0.503 0.117 0.505 0.485
			      0.514 0.811 0.528 0.415 0.538 0.088 0.552 0.056 0.561 0.106 0.580 0.075 0.597 0.0 
			      0.776 0.0 0.777 0.573 0.786 0.145 0.801 0.054 0.826 0.0 0.827 0.632 0.844 1.0 
			      0.856 0.524 0.866 0.031 0.883 0.074 0.891 0.136 0.896 0.745 0.907 0.424 0.915 0.765 
			      0.934 0.059 0.951 0.048 0.962 0.079 0.970 0.436 0.986 0.266 1.0 0.000)
			    :duration 0.25 :scaler 0.5))
	    (frqf (make-env '(0.0 0.220 0.074 0.249 0.133 0.249 0.194 0.240 0.258 0.252 0.324 0.264 0.389 0.267 
			      0.456 0.270 0.520 0.264 0.847 0.270 0.920 0.273 1.0 0.279)
			    :duration 0.25 :scaler (hz->radians (* 0.5 0.205 22050.0))))
	    (gen1 (make-polywave :partials '(2 .35  3 .1 4 .8  5 .01 6 .03  8 .005)))
	    (rnd (make-rand-interp 600 (hz->radians 50))))
	(lambda (dir)
	  (* (env ampf)
	     (polywave gen1 (+ (env frqf)
			       (rand-interp rnd)))))))
    (let* ((samps (seconds->samples 2.0))
	   (gran (make-granulate :expansion 8.0 :input ifunc)))
      (do ((i 0 (+ i 1)))
	  ((= i samps))
	(outa i (granulate gran)))))

  (calling-all-animals)
  (calling-all-generators)
  
  (let ((gen-list (list make-nssb make-nxysin make-nxycos make-nxy1cos make-nxy1sin make-noddsin make-noddcos make-noddssb make-ncos2 make-npcos
			   make-nrsin make-nrcos make-nrssb make-nkssb make-nsincos make-rcos make-rssb make-rxysin make-rxycos
			   make-rxyk!sin make-rxyk!cos make-ercos make-erssb make-eoddcos make-rkcos make-rksin make-rkssb
			   make-rk!cos make-rk!ssb make-r2k!cos make-k2sin make-k2cos make-k2ssb make-dblsum make-rkoddssb make-krksin
			   make-abcos make-absin make-r2k2cos make-bess make-jjcos make-j0evencos make-j2cos make-jpcos make-jncos
			   make-j0j1cos make-jycos make-blackman make-fmssb make-k3sin make-izcos make-nchoosekcos make-n1cos
			   make-adjustable-square-wave make-adjustable-triangle-wave make-adjustable-sawtooth-wave make-adjustable-oscil
			   make-round-interp make-sinc-train make-pink-noise make-green-noise make-brown-noise make-green-noise-interp
			   make-moving-max make-moving-norm make-moving-sum make-moving-rms make-moving-length 
			   make-weighted-moving-average make-exponentially-weighted-moving-average 
			   make-tanhsin 
			   (lambda args
			     (make-moving-fft (make-readin "oboe.snd")))
			   make-moving-scentroid 
			   (lambda args
			     (make-moving-autocorrelation (make-readin "oboe.snd")))
			   (lambda args
			     (make-moving-pitch (make-readin "oboe.snd"))))))
    (for-each
     (lambda (name maker isit run)
       (let ((gen (maker)))
	 (if (not (isit gen))
	     (format *stderr* ";~A is not a ~A?" gen name))
	 (run gen)
	 (run gen)))
     
     '(nssb nxysin nxycos nxy1cos nxy1sin noddsin noddcos noddssb ncos2 npcos
	   nrsin nrcos nrssb nkssb nsincos rcos rssb rxysin rxycos
	   rxyk!sin rxyk!cos ercos erssb eoddcos rkcos rksin rkssb
	   rk!cos rk!ssb r2k!cos k2sin k2cos k2ssb dblsum rkoddssb krksin
	   abcos absin r2k2cos bess jjcos j0evencos j2cos jpcos jncos
	   j0j1cos jycos blackman fmssb k3sin izcos nchoosekcos n1cos
	   adjustable-square-wave adjustable-triangle-wave adjustable-sawtooth-wave adjustable-oscil
	   round-interp sinc-train pink-noise green-noise brown-noise green-noise-interp
	   moving-max moving-norm moving-sum moving-rms moving-length weighted-moving-average exponentially-weighted-moving-average
	   tanhsin moving-fft moving-scentroid moving-autocorrelation moving-pitch)

     gen-list
     
     (list nssb? nxysin? nxycos? nxy1cos? nxy1sin? noddsin? noddcos? noddssb? ncos2? npcos? 
	   nrsin? nrcos? nrssb? nkssb? nsincos? rcos? rssb? rxysin? rxycos? 
	   rxyk!sin? rxyk!cos? ercos? erssb? eoddcos? rkcos? rksin? rkssb? 
	   rk!cos? rk!ssb? r2k!cos? k2sin? k2cos? k2ssb? dblsum? rkoddssb? krksin? 
	   abcos? absin? r2k2cos? bess? jjcos? j0evencos? j2cos? jpcos? jncos? 
	   j0j1cos? jycos? blackman? fmssb? k3sin? izcos? nchoosekcos? n1cos? 
	   adjustable-square-wave? adjustable-triangle-wave? adjustable-sawtooth-wave? adjustable-oscil? 
	   round-interp? sinc-train? pink-noise? green-noise? brown-noise? green-noise-interp? 
	   moving-max? moving-norm? moving-sum? moving-rms? moving-length? weighted-moving-average? exponentially-weighted-moving-average? 
	   tanhsin? moving-fft? moving-scentroid? moving-autocorrelation? moving-pitch? )
     
     (list nssb nxysin nxycos nxy1cos nxy1sin noddsin noddcos noddssb ncos2 npcos
	   nrsin nrcos nrssb nkssb nsincos rcos rssb rxysin rxycos
	   rxyk!sin rxyk!cos ercos erssb eoddcos rkcos rksin rkssb
	   rk!cos rk!ssb r2k!cos k2sin k2cos k2ssb dblsum rkoddssb krksin
	   abcos absin r2k2cos bess jjcos j0evencos j2cos jpcos jncos
	   j0j1cos jycos blackman fmssb k3sin izcos nchoosekcos n1cos
	   adjustable-square-wave adjustable-triangle-wave adjustable-sawtooth-wave adjustable-oscil
	   round-interp sinc-train pink-noise green-noise brown-noise green-noise-interp
	   moving-max moving-norm 
	   (lambda (g) 
	     (moving-sum g 0.0)) 
	   (lambda (g)
	     (moving-rms g 0.0))
	   (lambda (g)
	     (moving-length g 0.0))
	   (lambda (g)
	     (weighted-moving-average g 0.0))
	   exponentially-weighted-moving-average
	   tanhsin moving-fft moving-scentroid moving-autocorrelation moving-pitch
	   )))
  
  (do ((gen1 (make-oscil 440.0))
       (gen2 (make-oscil 440.0))
       (i 0 (+ i 1)))
      ((= i 1000))
    (let* ((pm (mus-random 1.0))
	   (val1 (oscil gen1 0.0 pm))
	   (val2 (run-with-fm-and-pm gen2 0.0 pm))) ; generators.scm
      (if (fneq val1 val2)
	  (snd-display "run-with-fm-and-pm: ~A ~A" val1 val2))))
  
  (do ((gen1 (make-oscil 440.0))
       (gen2 (make-oscil 440.0))
       (happy #t)
       (i 0 (+ i 1)))
      ((or (not happy)
	   (= i 1000))
       (if (not happy)
	   (snd-display "run-with-fm-and-pm unhappy")))
    (let* ((pm (mus-random 1.0))
	   (val1 (oscil gen1 0.0 pm))
	   (val2 (run-with-fm-and-pm gen2 0.0 pm)))
      (if (fneq val1 val2)
	  (set! happy #f))))
  
  (if (pair? (sounds)) (for-each close-sound (sounds)))
  
  (test-documentation-instruments)) ; clm23.scm


;;; ---------------- test 23: errors ----------------

(define snd_test_23
  (let ((check-error-tag 
	 (lambda (expected-tag thunk)
	   (let ((tag
		  (catch #t 
		    thunk
		    (lambda args args))))
	     (if (not (and (pair? tag) 
			   (eq? (car tag) expected-tag)))
		 (snd-display "check-error-tag ~A from ~A: ~A" 
			      expected-tag (procedure-source thunk) tag)))))

	(set-arity-ok 
	 (lambda (func args)
	   (let ((arit (if (dilambda? func)
			   (arity (setter func))
			   (and (procedure? (setter func))
				(arity (setter func))))))
	     (and (pair? arit)
		  (<= (car arit) args (cdr arit)))))))
    
    (lambda ()
      
      (when with-gui ; to the end!
	(set! *with-background-processes* #t)
	(set! *remember-sound-state* #f)
	(let* ((delay-32 (make-delay 32))
	       (color-95 (make-color-with-catch .95 .95 .95))
	       (procs (list 
		       add-mark add-sound-file-extension add-source-file-extension sound-file-extensions sound-file? 
		       add-to-main-menu add-to-menu add-transform amp-control ask-about-unsaved-edits
		       as-one-edit ask-before-overwrite 
		       auto-resize auto-update autocorrelate axis-color axis-info axis-label-font axis-numbers-font
		       basic-color bind-key apply-controls change-samples-with-origin channel-style
		       channel-widgets channels chans peaks-font bold-peaks-font close-sound combined-data-color
		       color-cutoff color-orientation-dialog colormap-ref add-colormap delete-colormap colormap-size colormap-name colormap?
		       color-inverted color-scale color->list colormap color?  comment contrast-control contrast-control-amp
		       contrast-control? convolve-selection-with convolve-with channel-properties channel-property controls->channel
		       amp-control-bounds speed-control-bounds expand-control-bounds contrast-control-bounds
		       reverb-control-length-bounds reverb-control-scale-bounds cursor-update-interval cursor-location-offset
		       auto-update-interval current-font cursor cursor-color with-tracking-cursor cursor-size
		       cursor-style tracking-cursor-style dac-combines-channels dac-size clipping data-color sample-type data-location data-size
		       default-output-chans default-output-sample-type default-output-srate default-output-header-type define-envelope
		       delete-mark delete-marks forget-region delete-sample delete-samples delete-samples-and-smooth
		       delete-selection delete-selection-and-smooth dialog-widgets display-edits dot-size draw-dot draw-dots draw-line
		       draw-lines draw-string edit-header-dialog edit-fragment edit-list->function edit-position edit-tree edits env-selection
		       env-sound enved-envelope enved-base enved-clip? enved-in-dB enved-dialog enved-style enved-power
		       enved-target enved-waveform-color enved-wave? eps-file eps-left-margin 
		       eps-bottom-margin eps-size expand-control expand-control-hop expand-control-jitter expand-control-length expand-control-ramp
		       expand-control? fft fft-window-alpha fft-window-beta fft-log-frequency fft-log-magnitude fft-with-phases transform-size disk-kspace
		       transform-graph-type fft-window transform-graph? mix-file-dialog file-name fill-polygon
		       fill-rectangle filter-sound filter-control-in-dB filter-control-envelope enved-filter-order enved-filter
		       filter-control-in-hz filter-control-order filter-selection filter-channel filter-control-waveform-color filter-control?
		       find-mark find-sound finish-progress-report foreground-color insert-file-dialog file-write-date
		       framples free-sampler graph transform? delete-transform
		       graph-color graph-cursor graph-data graph->ps gl-graph->ps graph-style lisp-graph?  graphs-horizontal header-type
		       help-dialog info-dialog highlight-color insert-region insert-sample insert-samples
		       insert-samples-with-origin insert-selection insert-silence insert-sound just-sounds key key-binding
		       left-sample listener-color listener-font listener-prompt listener-selection listener-text-color
		       main-widgets make-color make-graph-data make-mix-sampler make-player make-region
		       make-region-sampler make-sampler mark-color mark-name mark-properties mark-property
		       mark-sample mark-sync mark-sync-max mark-home marks mark?  max-transform-peaks max-regions
		       maxamp maxamp-position menu-widgets min-dB log-freq-start mix mixes mix-amp mix-amp-env
		       mix-color mix-length mix? view-mixes-dialog mix-position
		       mix-dialog-mix mix-name mix-sync-max mix-sync mix-properties mix-property 
		       mix-region mix-sampler?  mix-selection mix-sound mix-home mix-speed mix-tag-height mix-tag-width mark-tag-height mark-tag-width
		       mix-tag-y mix-float-vector mix-waveform-height time-graph-style lisp-graph-style transform-graph-style
					;new-sound in
		       read-mix-sample next-sample read-region-sample show-full-duration show-full-range initial-beg initial-dur
		       transform-normalization open-file-dialog-directory open-raw-sound open-sound previous-sample
		       peaks player? players play-arrow-size
		       position-color position->x position->y 
		       print-length progress-report read-only read-sample-with-direction
		       redo region-chans view-regions-dialog region-home 
		       region-graph-style region-framples region-position region-maxamp region-maxamp-position remember-sound-state
		       selection-maxamp selection-maxamp-position region-sample region->float-vector 
		       region-srate regions region?  remove-from-menu status-report reset-controls restore-controls
		       restore-region reverb-control-decay reverb-control-feedback 
		       reverb-control-length reverb-control-lowpass reverb-control-scale reverb-control?  reverse-sound
		       reverse-selection revert-sound right-sample sample sampler-at-end?  sampler? samples sampler-position
		       sash-color save-controls ladspa-dir peak-env-dir save-dir save-edit-history save-envelopes
		       save-listener save-marks save-region save-selection save-sound save-sound-as
		       save-state save-state-file scale-by scale-selection-by scale-selection-to scale-to
		       search-procedure select-all select-channel select-sound
		       selected-channel selected-data-color selected-graph-color selected-sound
		       selection-position selection-color selection-creates-region selection-framples selection-member? selection?
		       short-file-name show-axes show-controls show-transform-peaks show-indices show-listener show-selection unselect-all
		       show-marks show-mix-waveforms show-selection-transform show-y-zero sinc-width show-grid show-sonogram-cursor grid-density
		       smooth-sound smooth-selection snd-print snd-spectrum snd-tempnam snd-version sound-files-in-directory
		       sound-loop-info sound-widgets soundfont-info sound? sounds spectrum-end spectro-hop spectrum-start
		       spectro-x-angle spectro-x-scale spectro-y-angle spectro-y-scale spectro-z-angle spectro-z-scale
		       speed-control speed-control-style speed-control-tones squelch-update srate src-sound src-selection
					;start-playing 
		       start-progress-report stop-player stop-playing swap-channels syncd-marks sync sync-max sound-properties sound-property stdin-prompt
		       temp-dir text-focus-color tiny-font region-sampler? transform-dialog transform-sample
		       transform->float-vector transform-framples transform-type with-file-monitor unbind-key undo
		       update-transform-graph update-time-graph update-lisp-graph update-sound clm-table-size
		       with-verbose-cursor view-sound wavelet-type with-inset-graph with-interrupts with-pointer-focus with-smpte-label
		       with-toolbar with-tooltips with-menu-icons save-as-dialog-src save-as-dialog-auto-comment
		       time-graph?  time-graph-type wavo-hop wavo-trace window-height window-width window-x window-y
		       with-mix-tags with-relative-panes with-gl x-axis-style beats-per-measure
		       beats-per-minute x-bounds x-position-slider x->position x-zoom-slider mus-header-type->string mus-sample-type->string
		       y-bounds y-position-slider y->position y-zoom-slider zero-pad zoom-color zoom-focus-style sync-style mus-set-formant-radius-and-frequency
		       mus-sound-samples mus-sound-framples mus-sound-duration mus-sound-datum-size mus-sound-data-location data-size
		       mus-sound-chans mus-sound-srate mus-sound-header-type mus-sound-sample-type mus-sound-length
		       mus-sound-type-specifier mus-header-type-name mus-sample-type-name mus-sound-comment mus-sound-write-date
		       mus-bytes-per-sample mus-sound-loop-info mus-sound-mark-info 
					;mus-alsa-buffers mus-alsa-buffer-size mus-apply
		       mus-alsa-squelch-warning
					;mus-alsa-device mus-alsa-playback-device mus-alsa-capture-device 
		       mus-sound-maxamp mus-sound-maxamp-exists? 
		       mus-clipping mus-file-clipping mus-header-raw-defaults 
		       moving-average moving-average? make-moving-average moving-max moving-max? make-moving-max
		       make-moving-norm moving-norm moving-norm? mus-expand-filename 
		       all-pass all-pass? amplitude-modulate
		       array->file array-interp mus-interpolate asymmetric-fm asymmetric-fm?
		       comb comb? filtered-comb filtered-comb? contrast-enhancement convolution convolve convolve? db->linear degrees->radians
		       delay delay? dot-product env env-interp env? file->array file->frample file->frample?  file->sample
		       even-multiple even-weight odd-multiple odd-weight
		       file->sample? filter filter? fir-filter fir-filter? formant formant-bank formant-bank? formant? firmant firmant?
		       comb-bank make-comb-bank comb-bank? all-pass-bank make-all-pass-bank all-pass-bank? filtered-comb-bank make-filtered-comb-bank filtered-comb-bank?
		       granulate granulate? hz->radians iir-filter iir-filter? linear->db locsig ; in-any ina inb 
		       locsig-ref locsig-reverb-ref locsig-reverb-set! locsig-set!  locsig? make-all-pass make-asymmetric-fm
		       make-comb make-filtered-comb make-convolve make-delay make-env make-fft-window make-file->frample
		       make-file->sample make-filter make-fir-filter make-formant make-firmant make-frample->file make-granulate
		       make-iir-filter make-locsig move-locsig make-notch make-one-pole make-one-pole-all-pass make-one-zero make-oscil
		       make-pulse-train make-rand make-rand-interp make-readin make-sample->file make-sawtooth-wave
		       make-nrxysin make-nrxycos make-square-wave make-src make-ncos make-rxyk!cos make-rxyk!sin 
		       make-nsin make-ssb-am make-table-lookup make-triangle-wave
		       make-two-pole make-two-zero make-wave-train
		       move-sound make-move-sound move-sound? mus-float-equal-fudge-factor
		       mus-array-print-length mus-channel mus-channels make-polyshape polyshape polyshape? make-polywave polywave polywave?
		       mus-close mus-data mus-feedback mus-feedforward mus-fft mus-frequency
		       mus-hop mus-increment mus-input? mus-file-name mus-length mus-location mus-file-mix mus-order mus-output?  mus-phase
		       mus-ramp mus-random mus-scaler mus-srate mus-xcoeff mus-xcoeffs mus-ycoeff mus-ycoeffs 
		       notch notch? one-pole one-pole? one-pole-all-pass one-pole-all-pass?
		       one-zero one-zero? oscil oscil? out-any outa outb outc outd partials->polynomial normalize-partials
		       partials->wave phase-partials->wave polynomial pulse-train pulse-train?
		       radians->degrees radians->hz rand rand-interp rand-interp?  rand? readin readin? rectangular->polar rectangular->magnitudes
		       ring-modulate sample->file sample->file? sawtooth-wave
		       sawtooth-wave? nrxysin nrxysin? nrxycos nrxycos? rxyk!cos rxyk!cos? rxyk!sin rxyk!sin?
		       spectrum square-wave square-wave? src src? ncos nsin ssb-am
		       ncos? nsin? ssb-am? table-lookup table-lookup? tap tap? triangle-wave triangle-wave? two-pole two-pole? two-zero
		       two-zero? wave-train wave-train?  make-float-vector float-vector-add! float-vector-subtract!
		       float-vector-multiply! float-vector-offset! float-vector-ref float-vector-scale! 
		       float-vector-set! float-vector-peak float-vector-max float-vector-min
		       float-vector? float-vector-move! float-vector-subseq float-vector little-endian? float-vector->string
		       clm-channel env-channel env-channel-with-base map-channel scan-channel
		       reverse-channel seconds->samples samples->seconds
		       smooth-channel float-vector->channel channel->float-vector src-channel scale-channel ramp-channel pad-channel normalize-channel
		       cursor-position clear-listener mus-sound-prune mus-sound-forget xramp-channel
		       snd->sample snd->sample? make-snd->sample 
		       
		       beats-per-minute beats-per-measure channel-amp-envs convolve-files filter-control-coeffs 
		       locsig-type make-phase-vocoder 
		       mus-describe mus-error-type->string mus-file-buffer-size mus-name mus-offset mus-out-format mus-reset
		       mus-rand-seed mus-width phase-vocoder?
		       polar->rectangular phase-vocoder-amp-increments phase-vocoder-amps phase-vocoder-freqs
		       phase-vocoder-phase-increments phase-vocoder-phases mus-generator?
		       
		       read-sample reset-listener-cursor goto-listener-end sampler-home selection-chans selection-srate snd-gcs snd-font snd-color
		       snd-warning x-axis-label variable-graph? y-axis-label
		       snd-url snd-urls free-player
		       
		       delay-tick playing pausing draw-axes copy-sampler html-dir html-program
		       make-fir-coeffs mus-interp-type mus-run phase-vocoder
		       player-home redo-edit undo-edit ;widget-position widget-size 
		       ;focus-widget 
		       ))
	       
	       (set-procs (list 
			   amp-control ask-about-unsaved-edits ask-before-overwrite auto-resize
			   auto-update axis-color axis-label-font axis-numbers-font ;basic-color
			   channel-style peaks-font bold-peaks-font sound-file-extensions show-full-duration show-full-range initial-beg initial-dur
			   color-cutoff color-inverted color-scale contrast-control contrast-control-amp combined-data-color
			   amp-control-bounds speed-control-bounds expand-control-bounds contrast-control-bounds
			   reverb-control-length-bounds reverb-control-scale-bounds cursor-update-interval cursor-location-offset
			   contrast-control? auto-update-interval current-font cursor cursor-color channel-properties channel-property 
			   with-tracking-cursor cursor-size cursor-style tracking-cursor-style dac-combines-channels dac-size clipping data-color
			   default-output-chans default-output-sample-type default-output-srate default-output-header-type dot-size
			   enved-envelope enved-base enved-clip? enved-in-dB enved-style enved-power
			   enved-target enved-waveform-color enved-wave? eps-file eps-left-margin eps-bottom-margin eps-size
			   expand-control expand-control-hop expand-control-jitter expand-control-length expand-control-ramp expand-control?
			   fft-window-alpha fft-window-beta fft-log-frequency fft-log-magnitude fft-with-phases transform-size transform-graph-type fft-window
			   transform-graph? filter-control-in-dB filter-control-envelope enved-filter-order enved-filter 
			   filter-control-in-hz filter-control-order filter-control-waveform-color filter-control?  foreground-color
			   graph-color graph-cursor graph-style lisp-graph? graphs-horizontal highlight-color
			   just-sounds left-sample listener-color listener-font listener-prompt listener-text-color mark-color
			   mark-name mark-properties mark-property mark-sample mark-sync max-transform-peaks max-regions min-dB log-freq-start mix-amp
			   mix-amp-env mix-color mix-name mix-position mix-sync mix-properties mix-property 
			   mix-speed mix-tag-height mix-tag-width mix-tag-y mark-tag-width mark-tag-height 
			   mix-waveform-height transform-normalization open-file-dialog-directory
			   position-color print-length play-arrow-size
			   region-graph-style reverb-control-decay reverb-control-feedback
			   reverb-control-length reverb-control-lowpass reverb-control-scale time-graph-style lisp-graph-style transform-graph-style
			   reverb-control? sash-color ladspa-dir peak-env-dir save-dir save-state-file selected-data-color selected-graph-color
			   selection-color selection-creates-region show-axes show-controls
			   show-transform-peaks show-indices show-marks show-mix-waveforms show-selection-transform show-listener
			   show-y-zero show-grid show-sonogram-cursor sinc-width spectrum-end spectro-hop spectrum-start spectro-x-angle  grid-density
			   spectro-x-scale spectro-y-angle spectro-y-scale spectro-z-angle spectro-z-scale speed-control
			   speed-control-style speed-control-tones squelch-update sync sound-properties sound-property stdin-prompt
			   temp-dir text-focus-color tiny-font y-bounds
			   transform-type with-file-monitor with-verbose-cursor 
			   with-inset-graph with-interrupts with-pointer-focus wavelet-type x-bounds with-smpte-label
			   with-toolbar with-tooltips with-menu-icons save-as-dialog-src save-as-dialog-auto-comment
			   time-graph? wavo-hop wavo-trace with-gl with-mix-tags x-axis-style beats-per-minute zero-pad zoom-color zoom-focus-style sync-style
			   with-relative-panes  window-x window-y window-width window-height mix-dialog-mix beats-per-measure
			   channels chans colormap comment sample-type data-location data-size edit-position framples header-type maxamp
			   read-only right-sample sample samples selected-channel colormap-size colormap?
			   selected-sound selection-position selection-framples selection-member? sound-loop-info
			   srate time-graph-type x-position-slider x-zoom-slider
			   y-position-slider y-zoom-slider mus-array-print-length mus-float-equal-fudge-factor
					;mus-data 
			   mus-feedback mus-feedforward mus-frequency mus-hop
			   mus-increment mus-length mus-location mus-name mus-phase mus-ramp mus-scaler x-axis-label
			   filter-control-coeffs locsig-type mus-file-buffer-size 
			   mus-rand-seed mus-width clm-table-size mus-offset mus-reset
			   phase-vocoder-amp-increments phase-vocoder-amps 
			   phase-vocoder-freqs phase-vocoder-phase-increments phase-vocoder-phases 
			   html-dir html-program mus-interp-type ;widget-position widget-size 
			   mus-clipping mus-file-clipping mus-header-raw-defaults))
	       
	       (procs0 (test-remove-if (lambda (n) (not (and (procedure? n) (aritable? n 0)))) procs))
	       (set-procs0 (test-remove-if (lambda (n) (not (and (procedure? n) (set-arity-ok n 1)))) set-procs))
	       (procs1 (test-remove-if (lambda (n) (not (and (procedure? n) (aritable? n 1)))) procs))
	       (set-procs1 (test-remove-if (lambda (n) (not (and (procedure? n) (set-arity-ok n 2)))) set-procs))
	       (procs2 (test-remove-if (lambda (n) (not (and (procedure? n) (aritable? n 2)))) procs))
	       (set-procs2 (test-remove-if (lambda (n) (not (and (procedure? n) (set-arity-ok n 3)))) set-procs)))
	  
	  (let ((vector-0 #())
		(str-3 "/hiho")
		(float-vector-3 (make-float-vector 3))
		(float-vector-5 (make-float-vector 5))
		(car-main (and with-gui (car (main-widgets))))
		(cadr-main (and with-gui (cadr (main-widgets))))
		(a-hook (make-hook 'a 'b))
		(exts (sound-file-extensions)) ; save across possible set below
		
		(make-procs (vector
			     make-all-pass make-asymmetric-fm make-snd->sample make-moving-average make-moving-max make-moving-norm
			     make-comb make-filtered-comb make-convolve make-delay make-env make-fft-window make-file->frample
			     make-file->sample make-filter make-fir-filter make-formant make-firmant make-frample->file make-granulate
			     make-iir-filter make-locsig make-notch make-one-pole make-one-pole-all-pass make-one-zero make-oscil
			     make-pulse-train make-rand make-rand-interp make-readin make-sample->file make-sawtooth-wave
			     make-nrxysin make-nrxycos make-rxyk!cos make-rxyk!sin make-square-wave 
			     make-src make-ncos make-nsin make-table-lookup make-triangle-wave
			     make-two-pole make-two-zero make-wave-train make-phase-vocoder make-ssb-am make-polyshape make-polywave
			     make-color make-player make-region))
		
		(keyargs
		 (vector
		  :frequency :initial-phase :wave :cosines :amplitude :ratio :size :a0 :a1 :a2 :b1 :b2 :input 
		  :srate :file :channel :start :initial-contents :initial-element :scaler :feedforward :feedback 
		  :max-size :radius :gain :partials :r :a :n :fill-time :order :xcoeffs :ycoeffs :envelope 
		  :base :duration :offset :end :direction :degree :distance :reverb :output :fft-size :expansion 
		  :length :hop :ramp :jitter :type :format :comment :channels :filter :revout :width :edit 
		  :synthesize :analyze :interp :overlap :pitch :distribution :sines :dur)))
	    
	    (reset-all-hooks)
	    
	    (do ((test-errors 0 (+ 1 test-errors)))
		((= test-errors tests))
	      (log-mem test-errors)
	      
	      (case test-errors
		((1) 
		 (set! delay-32 (make-oscil 440))
		 (set! color-95 (vector 1 2 3))
		 (set! vector-0 (make-comb 0.1 3))
		 (set! float-vector-3 (make-notch 0.1 101))
		 (set! car-main (make-all-pass 0.4 0.5 2))
		 (set! cadr-main (make-table-lookup 101))
		 (set! a-hook (make-triangle-wave 220)))
		((2) 
		 (set! delay-32 (make-sawtooth-wave 440))
		 (set! color-95 123+123i)
		 (set! vector-0 (make-rand 100))
		 (set! float-vector-3 (make-rand-interp 100))
		 (set! car-main (make-asymmetric-fm 100))
		 (set! a-hook (make-one-pole 0.1 0.1)))
		((3) 
		 (set! delay-32 (make-two-zero 0.5 0.5 0.1))
		 (set! color-95 (list 1 2 3))
		 (set! vector-0 (make-formant 100 0.1))
		 (set! float-vector-3 (make-polyshape :frequency 300 :partials '(1 1 2 1)))
		 (set! car-main (make-oscil))
		 (set! cadr-main (vector 1 2 3))
		 (set! a-hook #r(0.2 0.1)))
		((4) 
		 (set! delay-32 (make-filter 3 #r(3 1 2) #r(3 1 2)))
		 (set! color-95 (make-float-vector '(2 1)))
		 (set! vector-0 (make-iir-filter 3 #r(1 2 3)))
		 (set! float-vector-3 (make-ncos))
		 (set! car-main (make-env '(0 0 1 1) :length 101))
		 (set! cadr-main (make-nsin 100 4))
		 (set! a-hook (make-nsin 100 3)))
		((5)
		 (set! delay-32 1.5)
		 (set! color-95 (make-color-with-catch 0.9 0.9 0.9))
		 (set! vector-0 (make-vector 1))
		 (set! car-main (make-moving-average 3))
		 (set! cadr-main (make-oscil 440))
		 (set! a-hook (subvector #r(0.1 0.2 0.1 0.2) (list 2 2)))))
	      
	      (for-each (lambda (n)
			  (let ((tag
				 (catch #t
				   (lambda ()
				     (n (integer->sound 123)))
				   (lambda args (car args)))))
			    (if (not (memq tag '(wrong-type-arg no-such-sound)))
				(snd-display "snd no-such-sound ~A: ~A" n tag))))
			(list amp-control apply-controls channels chans comment contrast-control 
			      amp-control-bounds speed-control-bounds expand-control-bounds contrast-control-bounds
			      reverb-control-length-bounds reverb-control-scale-bounds
			      contrast-control-amp contrast-control? sample-type data-location data-size 
			      expand-control expand-control-hop expand-control-jitter
			      expand-control-length expand-control-ramp expand-control? file-name filter-control-in-dB filter-control-in-hz
			      filter-control-envelope filter-control-order filter-control?  finish-progress-report framples header-type
			      progress-report read-only reset-controls restore-controls reverb-control-decay reverb-control-feedback
			      reverb-control-length reverb-control-lowpass reverb-control-scale reverb-control? save-controls
			      select-sound short-file-name sound-loop-info soundfont-info speed-control speed-control-style
			      speed-control-tones srate channel-style start-progress-report sync sound-properties sound-property swap-channels))
	      
	      (for-each (lambda (arg)
			  (for-each (lambda (n)
				      (let ((tag
					     (catch #t
					       (lambda ()
						 (n arg))
					       (lambda args (car args)))))
					(if (not (memq tag '(wrong-type-arg mus-error)))
					    (snd-display "snd wrong-type-arg ~A: ~A ~A" n tag arg))))
				    (list amp-control apply-controls close-sound comment contrast-control 
					  amp-control-bounds speed-control-bounds expand-control-bounds contrast-control-bounds
					  reverb-control-length-bounds reverb-control-scale-bounds
					  contrast-control-amp contrast-control? sample-type data-location data-size expand-control
					  expand-control-hop expand-control-jitter expand-control-length expand-control-ramp expand-control?
					  filter-control-in-dB filter-control-in-hz filter-control-envelope filter-control-order filter-control?
					  finish-progress-report header-type read-only reset-controls restore-controls
					  reverb-control-decay reverb-control-feedback reverb-control-length reverb-control-lowpass
					  reverb-control-scale reverb-control? save-controls select-sound short-file-name
					  sound-loop-info soundfont-info speed-control speed-control-style speed-control-tones srate
					  channel-style start-progress-report sync sound-properties swap-channels)))
			(list float-vector-5 0+i 1.5 "hiho" delay-32))
	      
	      (for-each (lambda (arg)
			  (for-each (lambda (n)
				      (let ((tag
					     (catch #t
					       (lambda ()
						 (set! (n arg) 0))
					       (lambda args (car args)))))
					(if (not (memq tag '(wrong-type-arg syntax-error error)))
					    (snd-display "snd set wrong-type-arg: ~A: ~A ~A" n tag arg))))
				    (list amp-control channels chans comment contrast-control contrast-control-amp 
					  amp-control-bounds speed-control-bounds expand-control-bounds contrast-control-bounds
					  reverb-control-length-bounds reverb-control-scale-bounds
					  contrast-control? sample-type data-location data-size expand-control expand-control-hop expand-control-jitter
					  expand-control-length expand-control-ramp expand-control? filter-control-in-dB filter-control-in-hz
					  filter-control-envelope filter-control-order filter-control? framples header-type read-only
					  reverb-control-decay reverb-control-feedback reverb-control-length reverb-control-lowpass
					  reverb-control-scale reverb-control? sound-loop-info soundfont-info speed-control
					  speed-control-style speed-control-tones srate channel-style sync)))
			(list float-vector-5 0+i 1.5 "hiho" delay-32))
	      
	      (let ((index (open-sound "obtest.snd")))
		(for-each (lambda (arg)
			    (for-each (lambda (n)
					(let ((tag
					       (catch #t
						 (lambda ()
						   (set! (n index) arg))
						 (lambda args (car args)))))
					  (if (not (eq? tag 'wrong-type-arg))
					      (snd-display "snd safe set wrong-type-arg: ~A ~A ~A" n tag arg))))
				      (list amp-control contrast-control contrast-control-amp contrast-control? expand-control 
					    amp-control-bounds speed-control-bounds expand-control-bounds contrast-control-bounds
					    reverb-control-length-bounds reverb-control-scale-bounds
					    expand-control-hop expand-control-jitter expand-control-length expand-control-ramp expand-control?
					    filter-control-in-dB filter-control-in-hz filter-control-envelope filter-control-order filter-control?
					    reverb-control-decay reverb-control-feedback reverb-control-length reverb-control-lowpass
					    reverb-control-scale reverb-control? speed-control speed-control-style speed-control-tones
					    channel-style sync)))
			  (list float-vector-5 0+i "hiho" delay-32))
		(close-sound index))
	      
	      (for-each (lambda (arg)
			  (for-each (lambda (n)
				      (let ((tag
					     (catch #t
					       (lambda ()
						 (n arg))
					       (lambda args (car args)))))
					(if (not (eq? tag 'wrong-type-arg))
					    (snd-display "float-vector 0 wrong-type-arg ~A: ~A ~A" n tag arg))))
				    (list make-float-vector float-vector-peak float-vector-max float-vector-min)))
			(list (make-vector 1) "hiho" 0+i 1.5 #i(0 1) delay-32))
	      
	      (for-each (lambda (arg1)
			  (for-each (lambda (arg2)
				      (for-each (lambda (n)
						  (let ((tag
							 (catch #t
							   (lambda ()
							     (n arg1 arg2))
							   (lambda args (car args)))))
						    (if (not (memq tag '(wrong-type-arg wrong-number-of-args mus-error)))
							(snd-display "float-vector 1 wrong-whatever ~A: ~A ~A ~A" n tag arg1 arg2))))
						(list float-vector-add! float-vector-subtract! float-vector-multiply! float-vector-ref float-vector-scale!)))
				    (list float-vector-5 "hiho" 0+i 1.5 (list 1 0) #i(0 1) delay-32)))
			(list (make-vector 1) "hiho" 0+i 1.5 (list 1 0) #i(0 1) delay-32))
	      
	      (for-each (lambda (arg)
			  (for-each (lambda (n)
				      (let ((tag
					     (catch #t
					       (lambda ()
						 (n float-vector-3 arg))
					       (lambda args (car args)))))
					(if (not (eq? tag 'wrong-type-arg))
					    (snd-display "float-vector arg 2 (scaler) wrong-type-arg ~A: ~A ~A" n arg tag))))
				    (list float-vector-add! float-vector-subtract! float-vector-multiply! float-vector-ref float-vector-scale!)))
			(list (make-vector 1) "hiho" 0+i (list 1 0) #i(0 1) delay-32))
	      
	      (let ((tag (catch #t
			   (lambda ()
			     (float-vector-3 12))
			   (lambda args (car args)))))
		(if (not (eq? tag 'out-of-range))
		    (snd-display "float-vector[12]: ~A" tag)))
	      
	      (for-each (lambda (arg)
			  (for-each (lambda (n)
				      (let ((tag
					     (catch #t
					       (lambda ()
						 (n arg))
					       (lambda args (car args)))))
					(if tag
					    (snd-display "?proc ~A: ~A" n tag))))
				    (list all-pass? asymmetric-fm? comb? filtered-comb? convolve? delay? env? file->frample? file->sample? snd->sample?
					  filter? fir-filter? formant? formant-bank? firmant? frample->file? granulate? iir-filter? locsig? move-sound? mus-input? 
					  mus-output? notch? one-pole? one-pole-all-pass? one-zero? oscil? phase-vocoder? pulse-train? rand-interp? rand? readin? 
					  sample->file? sawtooth-wave? nrxysin? nrxycos? rxyk!cos? rxyk!sin?
					  square-wave? src? ncos? nsin? tap? table-lookup? 
					  triangle-wave? two-pole? two-zero? wave-train? color? mix-sampler? moving-average? moving-max? moving-norm? ssb-am?
					  sampler? region-sampler? float-vector? )))
			(list (make-vector 1) "hiho" 0+i 1.5 (list 1 0) #i(0 1)))
	      
	      
	      (for-each (lambda (n)
			  (let ((tag
				 (catch #t
				   (lambda ()
				     (n (make-oscil 440)))
				   (lambda args (car args)))))
			    (if tag
				(snd-display "oscil?proc ~A: ~A" n tag))))
			(list all-pass? asymmetric-fm? comb? filtered-comb? convolve? delay? env? file->frample? file->sample? snd->sample?
			      filter? fir-filter? formant? formant-bank? firmant? frample->file? granulate? iir-filter? locsig? move-sound? mus-input? 
			      mus-output? notch? one-pole? one-pole-all-pass? one-zero? phase-vocoder? pulse-train? rand-interp? rand? readin? 
			      sample->file? sawtooth-wave? nrxysin? nrxycos? rxyk!cos? rxyk!sin?
			      square-wave? src? ncos? nsin? tap? table-lookup? 
			      triangle-wave? two-pole? two-zero? wave-train? sound? color? mix-sampler? moving-average? moving-max? moving-norm? ssb-am?
			      sampler? region-sampler? float-vector?))
	      
	      (for-each (lambda (n)
			  (let ((tag
				 (catch #t
				   n
				   (lambda args (car args)))))
			    (if (not (eq? tag 'no-active-selection))
				(snd-display "selection ~A: ~A" n tag))))
			(list reverse-selection selection-position selection-framples smooth-selection
			      scale-selection-to insert-selection delete-selection delete-selection-and-smooth mix-selection))
	      
	      (for-each (lambda (n)
			  (let ((tag
				 (catch #t
				   (lambda ()
				     (n 0.0))
				   (lambda args (car args)))))
			    (if (not (eq? tag 'no-active-selection))
				(snd-display "selection ~A: ~A" n tag))))
			(list src-selection filter-selection env-selection))
	      
	      (for-each (lambda (arg)
			  (for-each (lambda (n)
				      (let ((tag
					     (catch #t
					       (lambda ()
						 (n arg))
					       (lambda args (car args)))))
					(if (not (memq tag '(wrong-type-arg no-data no-such-method bad-type error arg-error out-of-range)))
					    (snd-display "clm ~A: tag: ~A arg: ~A" n tag arg))))
				    (list all-pass asymmetric-fm comb filtered-comb convolve db->linear moving-average moving-max moving-norm
					  degrees->radians delay env formant firmant granulate hz->radians linear->db even-weight odd-weight
					  make-all-pass make-asymmetric-fm make-comb make-filtered-comb make-convolve make-delay make-env
					  make-file->frample make-file->sample make-filter make-fir-filter make-formant make-firmant 
					  make-granulate make-iir-filter make-locsig make-notch make-one-pole make-one-zero
					  make-oscil make-pulse-train make-rand make-rand-interp make-readin
					  make-sawtooth-wave make-nrxysin make-nrxycos make-rxyk!cos make-rxyk!sin make-square-wave make-src 
					  make-ncos make-nsin
					  make-table-lookup make-triangle-wave make-two-pole make-two-zero make-wave-train make-ssb-am
					  mus-channel mus-channels make-polyshape make-polywave
					  mus-data mus-feedback mus-feedforward mus-frequency mus-hop
					  mus-increment mus-length mus-file-name mus-location mus-name mus-order mus-phase mus-ramp mus-random mus-run
					  mus-scaler mus-xcoeffs mus-ycoeffs notch one-pole one-pole-all-pass one-zero 
					  make-moving-average make-moving-max make-moving-norm
					  seconds->samples samples->seconds
					  oscil partials->polynomial partials->wave phase-partials->wave
					  phase-vocoder pulse-train radians->degrees radians->hz rand rand-interp readin
					  sawtooth-wave nrxysin nrxycos rxyk!cos rxyk!sin square-wave src 
					  ncos nsin table-lookup tap triangle-wave
					  two-pole two-zero wave-train ssb-am)))
			(list (make-vector 1) color-95 (list 1.0)))
	      
	      (for-each (lambda (n)
			  (let ((tag
				 (catch #t
				   (lambda ()
				     (n (make-oscil) float-vector-5)
				     )
				   (lambda args (car args)))))
			    (if (not (memq tag '(wrong-type-arg bad-arity error mus-error out-of-range no-data)))
				(snd-display "clm-1 ~A: ~A" n tag))))
			(list all-pass array-interp asymmetric-fm comb filtered-comb contrast-enhancement convolution convolve moving-average moving-max moving-norm
			      convolve-files delay dot-product env-interp file->sample snd->sample filter fir-filter formant firmant
			      formant-bank granulate iir-filter ina
			      inb locsig-ref locsig-reverb-ref make-all-pass make-asymmetric-fm make-comb make-filtered-comb
			      make-delay make-env make-fft-window make-filter make-fir-filter make-formant make-firmant make-granulate
			      make-iir-filter make-locsig make-notch make-one-pole make-one-pole-all-pass make-one-zero make-oscil make-phase-vocoder
			      make-pulse-train make-rand make-rand-interp make-readin make-sawtooth-wave make-moving-average make-moving-max make-moving-norm
			      make-nrxysin make-nrxycos make-rxyk!cos make-rxyk!sin make-square-wave make-src make-ncos 
			      make-nsin make-table-lookup make-triangle-wave
			      make-two-pole make-two-zero make-wave-train
			      notch one-pole one-pole-all-pass one-zero oscil partials->polynomial partials->wave make-polyshape make-polywave
			      phase-partials->wave phase-vocoder polynomial pulse-train rand rand-interp rectangular->polar rectangular->magnitudes
			      ring-modulate sawtooth-wave nrxysin nrxycos rxyk!cos rxyk!sin square-wave src ncos nsin
			      table-lookup tap triangle-wave two-pole two-zero wave-train ssb-am make-ssb-am))
	      
	      (for-each (lambda (n)
			  (let ((tag
				 (catch #t
				   (lambda ()
				     (set! (n (make-oscil)) vector-0))
				   (lambda args (car args)))))
			    (if (not (memq tag '(wrong-type-arg syntax-error error)))
				(snd-display "mus-gen ~A: ~A" n tag))))
			(list mus-channel mus-channels mus-data
			      mus-feedback mus-feedforward mus-frequency mus-hop mus-increment mus-length
			      mus-location mus-file-mix mus-name mus-order mus-phase mus-ramp mus-random mus-run mus-scaler mus-xcoeffs
			      mus-ycoeffs))
	      
	      
	      (for-each (lambda (n)
			  (let ((tag
				 (catch #t
				   (lambda ()
				     (n float-vector-5))
				   (lambda args (car args)))))
			    (if (not (eq? tag 'wrong-type-arg))
				(snd-display "mus-sound ~A: ~A" n tag))))
			(list mus-sound-samples mus-sound-framples mus-sound-duration mus-sound-datum-size
			      mus-sound-data-location mus-sound-chans mus-sound-srate mus-sound-header-type mus-sound-sample-type
			      mus-sound-length mus-sound-type-specifier mus-header-type-name mus-sample-type-name mus-sound-comment
			      mus-sound-write-date mus-bytes-per-sample mus-sound-loop-info mus-sound-mark-info mus-sound-maxamp
			      mus-sound-maxamp-exists? mus-header-type->string mus-sample-type->string))
	      
	      (for-each (lambda (n)
			  (let ((tag
				 (catch #t
				   (lambda ()
				     (n "/bad/baddy"))
				   (lambda args (car args)))))
			    (if (not (eq? tag 'mus-error))
				(snd-display "bad file mus-sound ~A: ~A" n tag))))
			(list mus-sound-samples mus-sound-framples mus-sound-duration mus-sound-datum-size
			      mus-sound-data-location mus-sound-chans mus-sound-srate mus-sound-header-type mus-sound-sample-type
			      mus-sound-length mus-sound-type-specifier mus-sound-comment mus-sound-write-date mus-sound-maxamp
			      mus-sound-maxamp-exists?))
	      (mus-sound-forget "/bad/baddy") ; for possible second time around
	      
	      (for-each (lambda (n)
			  (let ((tag
				 (catch #t
				   (lambda ()
				     (n float-vector-5))
				   (lambda args (car args)))))
			    (if (not (memq tag '(wrong-type-arg error no-such-sound)))
				(snd-display " chn (no snd) procs ~A: ~A" n tag))))
			(list channel-widgets cursor channel-properties channel-property 
			      cursor-position cursor-size cursor-style tracking-cursor-style delete-sample display-edits dot-size
			      draw-dots draw-lines edit-fragment edit-position edit-tree edits fft-window-alpha fft-window-beta fft-log-frequency
			      fft-log-magnitude fft-with-phases transform-size transform-graph-type fft-window transform-graph?
			      graph graph-style lisp-graph? (lambda (a) (insert-region 0 a)) insert-sound
			      time-graph-style lisp-graph-style transform-graph-style
			      left-sample make-graph-data max-transform-peaks maxamp-position min-dB mix-region
			      transform-normalization peaks ;play
			      position->x position->y reverse-sound
			      revert-sound right-sample sample save-sound save-sound-as 
			      select-channel show-axes show-transform-peaks show-marks show-mix-waveforms show-y-zero show-grid show-sonogram-cursor
			      spectrum-end spectro-hop spectrum-start spectro-x-angle spectro-x-scale spectro-y-angle  grid-density
			      spectro-y-scale spectro-z-angle spectro-z-scale squelch-update transform-sample
			      transform->float-vector transform-framples transform-type update-transform-graph update-time-graph
			      update-lisp-graph update-sound wavelet-type time-graph? time-graph-type wavo-hop wavo-trace x-bounds
			      x-position-slider x-zoom-slider x-axis-label y-axis-label y-bounds y-position-slider y-zoom-slider zero-pad))
	      
	      (for-each (lambda (n)
			  (let ((tag
				 (catch #t
				   (lambda ()
				     (n 0 float-vector-5))
				   (lambda args (car args)))))
			    (if (not (eq? tag 'wrong-type-arg))
				(snd-display " chn (no chn) procs ~A: ~A" n tag))))
			(list channel-widgets cursor channel-properties channel-property combined-data-color
			      cursor-position cursor-size cursor-style tracking-cursor-style delete-sample display-edits dot-size draw-dots draw-lines
			      edit-fragment edit-position edit-tree edits fft-window-alpha fft-window-beta fft-log-frequency fft-log-magnitude fft-with-phases
			      transform-size transform-graph-type fft-window transform-graph?
			      graph graph-style lisp-graph? insert-region insert-sound left-sample
			      time-graph-style lisp-graph-style transform-graph-style
			      make-graph-data max-transform-peaks maxamp maxamp-position min-dB mix-region transform-normalization
			      peaks play position->x position->y reverse-sound right-sample sample
			      save-sound-as show-axes show-transform-peaks show-marks
			      show-mix-waveforms show-y-zero show-grid show-sonogram-cursor 
			      spectrum-end spectro-hop spectrum-start spectro-x-angle
			      spectro-x-scale spectro-y-angle spectro-y-scale spectro-z-angle spectro-z-scale squelch-update  grid-density
			      transform-sample transform->float-vector transform-framples transform-type
			      update-transform-graph update-time-graph update-lisp-graph wavelet-type time-graph? time-graph-type
			      wavo-hop wavo-trace x-bounds x-position-slider x-zoom-slider x-axis-label y-axis-label y-bounds y-position-slider
			      y-zoom-slider zero-pad))
	      
	      (for-each (lambda (n)
			  (let ((tag
				 (catch #t
				   (lambda ()
				     (n (integer->sound 1234)))
				   (lambda args (car args)))))
			    (if (not (eq? tag 'no-such-sound))
				(snd-display " chn procs ~A: ~A" n tag))))
			(list channel-widgets cursor channel-properties
			      cursor-position cursor-size cursor-style tracking-cursor-style 
			      (lambda (snd) (delete-sample 0 snd)) display-edits dot-size 
			      (lambda (snd) (edit-fragment 0 snd))
			      edit-position edit-tree edits env-sound fft-window-alpha fft-window-beta fft-log-frequency fft-log-magnitude fft-with-phases
			      transform-size transform-graph-type fft-window transform-graph? filter-sound
			      graph-data graph-style lisp-graph? left-sample
			      time-graph-style lisp-graph-style transform-graph-style
			      make-graph-data max-transform-peaks maxamp maxamp-position min-dB transform-normalization
			      (lambda (snd) (position->x 0 snd))
			      (lambda (snd) (position->y 0 snd))
			      (lambda (snd) (redo 1 snd)) reverse-sound revert-sound right-sample 
			      (lambda (snd) (sample 0 snd))
			      save-sound scale-by scale-to show-axes show-transform-peaks
			      show-marks show-mix-waveforms show-y-zero show-grid show-sonogram-cursor 
			      spectrum-end spectro-hop spectrum-start spectro-x-angle
			      spectro-x-scale spectro-y-angle spectro-y-scale spectro-z-angle spectro-z-scale squelch-update  grid-density
			      src-sound 
			      (lambda (snd) (transform-sample 0 0 snd)) transform->float-vector
			      transform-framples transform-type 
			      (lambda (snd) (undo 1 snd)) update-transform-graph update-time-graph update-lisp-graph
			      update-sound wavelet-type time-graph? time-graph-type wavo-hop wavo-trace x-bounds x-position-slider 
			      (lambda (snd) (normalize-channel 0.5 0 #f snd))
			      (lambda (snd) (x->position 0 snd))
			      x-zoom-slider y-bounds y-position-slider x-axis-label y-axis-label 
			      (lambda (snd) (y->position 0 snd)) y-zoom-slider 
			      zero-pad 
			      (lambda (snd) (scale-channel 2.0 0 #f snd))
			      ))
	      
	      (for-each (lambda (n)
			  (let ((tag
				 (catch #t
				   (lambda ()
				     (n 0 1234))
				   (lambda args (car args)))))
			    (if (not (eq? tag 'no-such-sound))
				(snd-display " snd(1) chn procs ~A: ~A" n tag))))
			(list delete-sample edit-fragment graph-data graph-style play position->x position->y redo
			      time-graph-style lisp-graph-style transform-graph-style
			      scale-by scale-to undo x->position y->position x-axis-label))
	      
	      (let ((index (open-sound "oboe.snd")))
		(for-each (lambda (n)
			    (let ((tag
				   (catch #t
				     (lambda ()
				       (n 0 index 1234))
				     (lambda args (car args)))))
			      (if (not (eq? tag 'no-such-channel))
				  (snd-display " snd(1 1234) chn procs ~A: ~A" n tag))))
			  (list delete-sample edit-fragment graph-data position->x position->y redo scale-by
				scale-to undo x->position y->position))
		(close-sound index))
	      (if (sound? (find-sound "oboe.snd"))
		  (snd-display "oboe.snd is still open?"))
	      
	      (let ((index (open-sound "oboe.snd")))
		(for-each (lambda (n)
			    (let ((tag
				   (catch #t
				     (lambda ()
				       (n index 1234))
				     (lambda args (car args)))))
			      (if (not (memq tag '(no-such-channel no-such-sound)))
				  (snd-display " chn procs ~A: ~A" n tag))))
			  (list channel-widgets cursor cursor-position cursor-size cursor-style tracking-cursor-style display-edits
				dot-size edit-position edit-tree edits fft-window-alpha fft-window-beta fft-log-frequency fft-log-magnitude fft-with-phases
				transform-size transform-graph-type fft-window transform-graph? graph-style lisp-graph? left-sample
				time-graph-style lisp-graph-style transform-graph-style combined-data-color
				make-graph-data max-transform-peaks maxamp maxamp-position min-dB transform-normalization
				reverse-sound right-sample show-axes show-transform-peaks show-marks 
				show-mix-waveforms show-y-zero show-grid show-sonogram-cursor  grid-density
				spectrum-end spectro-hop spectrum-start spectro-x-angle spectro-x-scale spectro-y-angle
				spectro-y-scale spectro-z-angle spectro-z-scale squelch-update transform->float-vector
				transform-framples transform-type update-transform-graph update-time-graph update-lisp-graph
				wavelet-type time-graph?  time-graph-type wavo-hop wavo-trace x-bounds x-position-slider x-axis-label
				x-zoom-slider y-bounds y-position-slider y-zoom-slider zero-pad channel-properties channel-property ))
		(close-sound index))
	      (if (sound? (find-sound "oboe.snd"))
		  (snd-display "oboe.snd is still open?"))
	      
	      (let ((index (open-sound "oboe.snd")))
		(for-each (lambda (n)
			    (let ((tag
				   (catch #t
				     (lambda ()
				       (set! (n index 0) float-vector-5))
				     (lambda args (car args)))))
			      (if (not (memq tag '(wrong-type-arg syntax-error error)))
				  (snd-display " set chn procs ~A: ~A" n tag))))
			  (list channel-widgets cursor cursor-position display-edits dot-size edit-tree edits
				fft-window-alpha fft-window-beta fft-log-frequency fft-log-magnitude fft-with-phases transform-size transform-graph-type fft-window
				transform-graph? graph-style lisp-graph? left-sample make-graph-data max-transform-peaks maxamp maxamp-position
				time-graph-style lisp-graph-style transform-graph-style combined-data-color
				min-dB transform-normalization reverse-sound right-sample show-axes  grid-density
				show-transform-peaks show-marks show-mix-waveforms show-y-zero show-grid show-sonogram-cursor spectrum-end spectro-hop
				spectrum-start spectro-x-angle spectro-x-scale spectro-y-angle spectro-y-scale spectro-z-angle
				spectro-z-scale squelch-update transform->float-vector transform-framples transform-type
				update-transform-graph update-time-graph update-lisp-graph wavelet-type time-graph? time-graph-type
				wavo-hop wavo-trace x-bounds x-position-slider x-zoom-slider y-bounds y-position-slider
				y-zoom-slider zero-pad x-axis-label
				))
		
		(close-sound index))
	      (if (sound? (find-sound "oboe.snd"))
		  (snd-display "oboe.snd is still open?"))
	      
	      (for-each (lambda (n b)
			  (let ((tag
				 (catch #t
				   (lambda ()
				     (n float-vector-5))
				   (lambda args (car args)))))
			    (if (not (memq tag '(error wrong-type-arg syntax-error)))
				(snd-display "[0]: mix procs ~A: ~A (~A)" b tag float-vector-5))))
			(list mix-amp mix-amp-env mix-length mix-name mix-position mix-home mix-speed mix-tag-y)
			'(mix-amp mix-amp-env mix-length mix-name mix-position mix-home mix-speed mix-tag-y))
	      
	      (for-each (lambda (n)
			  (let ((tag
				 (catch #t
				   (lambda ()
				     (set! (n (integer->mix 1234)) float-vector-5))
				   (lambda args (car args)))))
			    (if (not (memq tag '(error wrong-type-arg syntax-error no-such-mix)))
				(snd-display "[2]: mix procs ~A: ~A" n tag))))
			(list mix-name mix-position mix-home mix-speed mix-tag-y))
	      
	      (let ((index (open-sound "oboe.snd"))
		    (id (mix-sound "oboe.snd" 10)))
		(for-each (lambda (n b)
			    (let ((tag
				   (catch #t
				     (lambda ()
				       (set! (n id) float-vector-5))
				     (lambda args (car args)))))
			      (if (not (memq tag '(error wrong-type-arg syntax-error)))
				  (snd-display "[3]: mix procs ~A: ~A (~A)" b tag float-vector-5))))
			  (list  mix-name mix-position mix-home mix-speed mix-tag-y)
			  '(mix-name mix-position mix-home mix-speed mix-tag-y))
		(close-sound index)
		(if (sound? (find-sound "oboe.snd"))
		    (snd-display "oboe.snd is still open? ~A ~A ~A" index (find-sound "oboe.snd") (sounds))))
	      
	      (for-each (lambda (n)
			  (let ((tag
				 (catch #t
				   (lambda ()
				     (n float-vector-5))
				   (lambda args (car args)))))
			    (if (not (eq? tag 'wrong-type-arg))
				(snd-display " mark procs ~A: ~A" n tag))))
			(list add-mark mark-name mark-sample mark-sync mark-home delete-mark delete-marks find-mark))
	      
	      (let* ((index (open-sound "oboe.snd"))
		     (id (add-mark 0 index 0)))
		(for-each (lambda (n)
			    (let ((tag
				   (catch #t
				     (lambda ()
				       (set! (n id) float-vector-5))
				     (lambda args (car args)))))
			      (if (not (eq? tag 'wrong-type-arg))
				  (snd-display " set mark procs ~A: ~A" n tag))))
			  (list mark-name mark-sample mark-sync))
		(close-sound index))
	      (if (sound? (find-sound "oboe.snd"))
		  (snd-display "oboe.snd is still open?"))
	      
	      (for-each (lambda (arg)
			  (for-each (lambda (n)
				      (let ((tag
					     (catch #t
					       (lambda ()
						 (n arg))
					       (lambda args (car args)))))
					(if (not (memq tag '(wrong-type-arg wrong-number-of-args)))
					    (snd-display " region procs ~A: ~A ~A" n tag arg))))
				    (list region-chans region-home region-framples 
					  region-position region-maxamp region-maxamp-position region-sample 
					  region->float-vector region-srate forget-region)))
			(list float-vector-5 #i(0 1) 0+i "hiho" (list 0 1)))
	      
	      (when (and with-gui
			 (or (provided? 'snd-motif)
			     (provided? 'gtk4)))
		(for-each (lambda (n)
			    (let ((tag
				   (catch #t
				     (lambda ()
				       (set! (n) float-vector-5))
				     (lambda args (car args)))))
			      (if (not (memq tag '(error wrong-type-arg syntax-error)))
				  (snd-display " misc procs ~A: ~A" n tag))))
			  (list axis-color enved-filter-order enved-filter filter-control-waveform-color ask-before-overwrite ask-about-unsaved-edits
				auto-resize auto-update axis-label-font axis-numbers-font basic-color bind-key show-full-duration show-full-range initial-beg initial-dur
				channel-style color-cutoff color-orientation-dialog color-inverted color-scale
				cursor-color dac-combines-channels dac-size clipping data-color default-output-chans 
				default-output-sample-type default-output-srate default-output-header-type enved-envelope enved-base
				enved-clip? enved-in-dB enved-dialog enved-style  enved-power enved-target
				enved-waveform-color enved-wave? eps-file eps-left-margin eps-bottom-margin eps-size
				foreground-color graph-color graph-cursor highlight-color just-sounds key-binding
				listener-color listener-font listener-prompt listener-text-color max-regions
				mix-waveform-height region-graph-style position-color
				time-graph-style lisp-graph-style transform-graph-style peaks-font bold-peaks-font
				print-length play-arrow-size sash-color ladspa-dir peak-env-dir save-dir save-state-file
				selected-channel selected-data-color selected-graph-color 
				selected-sound selection-creates-region show-controls show-indices show-listener
				show-selection-transform sinc-width stdin-prompt temp-dir text-focus-color tiny-font
				with-file-monitor unbind-key with-verbose-cursor 
				with-inset-graph with-interrupts with-pointer-focus window-height beats-per-measure with-smpte-label
				with-toolbar with-tooltips with-menu-icons remember-sound-state save-as-dialog-src save-as-dialog-auto-comment
				window-width window-x window-y with-gl with-mix-tags x-axis-style beats-per-minute zoom-color mix-tag-height
				mix-tag-width with-relative-panes clm-table-size mark-tag-width mark-tag-height
				)))
	      
	      
	      (set! *ask-about-unsaved-edits* #f)
	      (set! *remember-sound-state* #f)
	      (when (zero? test-errors) 
		(for-each (lambda (arg) 
			    (check-error-tag 'no-such-key arg)) ; check-error-tag calls the function
			  (vector   
			   (lambda () (key-binding 12345678 0 #f)) 
			   (lambda () (key-binding -1 0 #f)) 
			   (lambda () (key-binding 12 17 #f)) 
			   (lambda () (key-binding 12 -1 #f))
			   (lambda () (key-binding 12345678 0)) 
			   (lambda () (key-binding -1 0)) 
			   (lambda () (key-binding 12 17)) 
			   (lambda () (key-binding 12 -1))))
		(for-each (lambda (arg)
			    (check-error-tag 'bad-arity arg))
			  (vector (lambda () (add-colormap "baddy" (lambda () #f)))
				  (lambda () (add-colormap "baddy" (lambda (a b c) #f)))
				  (lambda () (add-to-main-menu "hi" (lambda (a b) #f)))
				  (lambda () (add-to-menu 1 "hi" (lambda (a b) #f)))
				  (lambda () (add-transform "hiho" "time" 0 1 (lambda () 1.0)))
				  (lambda () (bind-key (char->integer #\p) 0 (lambda (a b) (play-often (max 1 a)))))
				  (lambda () (set! (search-procedure) (lambda (a b c) a)))
				  (lambda () (set! *zoom-focus-style* (lambda (a) 0)))))
		(for-each (lambda (arg)
			    (check-error-tag 'bad-header arg))
			  (vector (lambda () (file->array (string-append sf-dir "bad_chans.snd") 0 0 123 (make-float-vector 123)))
				  (lambda () (make-readin (string-append sf-dir "bad_chans.snd")))
				  (lambda () (mus-file-mix "oboe.snd" (string-append sf-dir "bad_chans.aifc")))
				  (lambda () (mus-file-mix (string-append sf-dir "bad_chans.aifc") "oboe.snd"))
				  (lambda () (mus-sound-maxamp (string-append sf-dir "bad_chans.snd")))
				  (lambda () (new-sound "fmv.snd" 2 22050 mus-bfloat mus-nist "this is a comment"))
				  (lambda () (new-sound "hiho" :header-type mus-nist :sample-type mus-bfloat))))
		(check-error-tag 'bad-type (lambda () (normalize-partials '(1 2 3))))
		(check-error-tag 'bad-type (lambda () (normalize-partials #r(3))))
		(check-error-tag 'cannot-print graph->ps)
		(check-error-tag 'cannot-save (lambda () (mus-sound-report-cache "/bad/baddy")))
		(check-error-tag 'cannot-save (lambda () (save-envelopes "/bad/baddy")))
		(check-error-tag 'cannot-save (lambda () (save-state "/bad/baddy")))
		(for-each (lambda (arg)
			    (check-error-tag 'mus-error arg))
			  (vector (lambda () (make-filter :ycoeffs (make-float-vector 4) :order 12))
				  ;(lambda () (make-fir-filter :coeffs (make-float-vector 4) :xcoeffs (make-float-vector 4)))
				  (lambda () (make-granulate :expansion 32000.0))
				  (lambda () (make-iir-filter 30 (make-float-vector 3)))
				  ;(lambda () (make-iir-filter :xcoeffs (make-float-vector 4) :ycoeffs (make-float-vector 4)))
				  (lambda () (make-iir-filter :order 32 :ycoeffs (make-float-vector 4)))
				  (lambda () (make-locsig 1/0 :channels 2))
				  (lambda () (make-rand :envelope '(0 0 1 1) :distribution (make-float-vector 10)))
				  ;(lambda () (make-rand :envelope '(0 0 1)))
				  (lambda () (mus-file-mix "oboe.snd" (string-append sf-dir "bad_length.aifc")))
				  (lambda () (mus-sound-chans (string-append sf-dir "bad_field.nist")))
				  (lambda () (mus-sound-chans (string-append sf-dir "bad_location.nist")))
				  (lambda () (mus-xcoeff (make-filter 3 :xcoeffs float-vector-3 :ycoeffs float-vector-3) 4))
				  (lambda () (mus-ycoeff (make-filter 3 :xcoeffs float-vector-3 :ycoeffs float-vector-3) 4))
				  (lambda () (set! (mus-offset (make-oscil)) 1))
				  (lambda () (set! (mus-xcoeff (make-filter 3 :xcoeffs float-vector-3 :ycoeffs float-vector-3) 4) 1.0))
				  (lambda () (set! (mus-ycoeff (make-filter 3 :xcoeffs float-vector-3 :ycoeffs float-vector-3) 4) 1.0))))
		(check-error-tag 'no-data (lambda () (make-polyshape 440.0 :partials #r(1 1 -2 1))))
		(check-error-tag 'no-data (lambda () (make-polyshape 440.0 :partials '(1 1 -2 1))))
		(check-error-tag 'wrong-type-arg (lambda () (make-polyshape 440.0 :partials ())))
		(check-error-tag 'no-such-channel (lambda () (make-sampler 0 "oboe.snd" -1)))
		(check-error-tag 'no-such-channel (lambda () (make-sampler 0 "oboe.snd" 1)))
		(check-error-tag 'no-such-envelope (lambda () (set! (enved-envelope) "not-an-env")))
		(for-each (lambda (arg)
			    (check-error-tag 'no-such-file arg))
			  (vector (lambda () (make-sampler 0 "/bad/baddy.snd"))
				  (lambda () (open-raw-sound "/bad/baddy.snd" 1 22050 mus-lshort))
				  (lambda () (open-sound "/bad/baddy.snd"))
				  (lambda () (set! *save-dir* "/hiho"))
				  (lambda () (set! *temp-dir* "/hiho"))
				  (lambda () (view-sound "/bad/baddy.snd"))))
		(check-error-tag 'no-such-menu (lambda () (add-to-menu 1234 "hi" (lambda () #f))))
		(check-error-tag 'no-such-menu (lambda () (main-menu -1)))
		(check-error-tag 'no-such-menu (lambda () (main-menu 111)))
		(check-error-tag 'no-such-sound (lambda () (edit-header-dialog 1234)))
		(check-error-tag 'no-such-sound (lambda () (set! (sound-loop-info 123) '(0 0 1 1))))
		(for-each (lambda (arg)
			    (check-error-tag 'out-of-range arg))
			  (vector (lambda () (dot-product (make-float-vector 3) (make-float-vector 3) -1))
				  (lambda () (make-color -0.5 0.0 0.0))
				  (lambda () (make-color 1.5 0.0 0.0))
				  ;(lambda () (make-delay 3 :initial-element 0.0 :initial-contents #r(.1 .2 .3))) -> 'conflicting-arguments
				  (lambda () (make-delay 3 :max-size 100 :initial-contents #r(.1 .2 .3)))
				  (lambda () (make-file->frample "oboe.snd" -1))
				  (lambda () (make-file->frample "oboe.snd" 0))
				  (lambda () (make-file->sample "oboe.snd" -1))
				  (lambda () (make-file->sample "oboe.snd" 0))
				  (lambda () (make-granulate :ramp -0.5))
				  (lambda () (make-granulate :ramp 1.5))
				  (lambda () (make-locsig :channels (expt 2 30)))
				  (lambda () (make-polyshape 440.0 :partials '(1 1) :kind -1))
				  (lambda () (make-polyshape 440.0 :partials '(1 1) :kind 3))
				  (lambda () (make-rand :envelope '(0 0 1 1) :size -2))
				  (lambda () (make-rand :envelope '(0 0 1 1) :size 1234567890))
				  (lambda () (make-readin "oboe.snd" :size -1))
				  (lambda () (make-readin "oboe.snd" :size 0))
				  (lambda () (make-src :width 3000))
				  (lambda () (make-ssb-am 100 12345678))
				  (lambda () (make-table-lookup :size 100 :wave (make-float-vector 3)))
				  (lambda () (make-table-lookup :size 123456789))
				  (lambda () (make-wave-train :size (expt 2 30)))
				  (lambda () (make-wave-train :size 100 :wave (make-float-vector 3)))
				  (lambda () (new-sound "hiho" :header-type 123))
				  (lambda () (new-sound "hiho" :header-type mus-nist :sample-type 123))
				  (lambda () (new-sound "test.snd" :channels 0))
				  (lambda () (new-sound "test.snd" :size -1))
				  (lambda () (new-sound "test.snd" :srate 0))
				  (lambda () (partials->polynomial '(1 1) -1))
				  (lambda () (partials->polynomial '(1 1) 3))
				  (lambda () (set! *clm-srate* -1000))
				  (lambda () (set! *clm-srate* 0.0))
				  (lambda () (set! *default-output-header-type* mus-soundfont))
				  (lambda () (set! *default-output-sample-type* -1))
				  (lambda () (set! *enved-style* 12))
				  (lambda () (set! *mus-array-print-length* -1))
				  (lambda () (set! *play-arrow-size* -1))
				  (lambda () (set! *print-length* -1))
				  (lambda () (src (make-src :input (lambda (dir) 1.0)) 2000000.0))))
		(for-each (lambda (arg)
			    (check-error-tag 'wrong-type-arg arg))
			  (vector (lambda () (envelope-interp 1.0 '(0 0 .5)))
				  (lambda () (help-dialog (list 0 1) "hiho"))
				  (lambda () (info-dialog (list 0 1) "hiho"))
				  (lambda () (make-variable-graph #f))
				  (lambda () (normalize-partials ()))
				  (lambda () (normalize-partials 32))
				  (lambda () (player-home 123))
				  (lambda () (set! (mus-header-raw-defaults) (list 44100 2.123 "hi")))
				  (lambda () (set! (mus-header-raw-defaults) 1234))
				  (lambda () (set! *ask-about-unsaved-edits* 123))
				  (lambda () (set! *save-as-dialog-auto-comment* 123))
				  (lambda () (set! *save-as-dialog-src* 123))
				  (lambda () (set! *with-menu-icons* 123))
				  (lambda () (set! *with-smpte-label* 123))
				  (lambda () (set! *with-toolbar* 123))
				  (lambda () (set! *with-tooltips* 123))))
		
		(when (provided? 'snd-motif)
		  (for-each (lambda (arg)
			      (check-error-tag 'no-such-widget arg))
			    (vector (lambda () (widget-position '(Widget 0)))
				    (lambda () (widget-size '(Widget 0)))
				    (lambda () (widget-text '(Widget 0)))
				    (lambda () (set! (widget-position '(Widget 0)) (list 0 0)))
				    (lambda () (set! (widget-size '(Widget 0)) (list 10 10)))
				    (lambda () (set! (widget-text '(Widget 0)) "hiho")))))
		(let ((ind (open-sound "oboe.snd"))) 
		  (set! *selection-creates-region* #t)
		  (select-all)
		  (check-error-tag 'IO-error (lambda () (convolve-with (string-append sf-dir "bad_chans.snd"))))
		  (check-error-tag 'bad-arity (lambda () (map-channel (lambda (a b c) 1.0))))
		  (check-error-tag 'bad-arity (lambda () (scan-channel (lambda (a b c) 1.0))))
		  (check-error-tag 'bad-arity (lambda () (set! (cursor-style ind 0) (lambda (a) 32))))
		  (check-error-tag 'bad-arity (lambda () (set! (search-procedure) (lambda (a b c) #t))))
		  (check-error-tag 'bad-header (lambda () (insert-sound (string-append sf-dir "bad_chans.snd"))))
		  (check-error-tag 'bad-sample-type (lambda () (play (string-append sf-dir "nist-shortpack.wav"))))
		  (for-each (lambda (arg)
			      (check-error-tag 'cannot-save arg))
			    (vector (lambda () (save-selection "test.snd" 22050 mus-bshort mus-riff))
				    (lambda () (save-selection "test.snd" 22050 mus-bshort mus-voc))
				    (lambda () (save-sound-as "hiho.snd" ind -12))
				    (lambda () (save-sound-as "hiho.snd" ind :header-type mus-next :sample-type -12))
				    (lambda () (save-sound-as "test.snd" ind :header-type mus-aifc :sample-type mus-lfloat))
				    (lambda () (save-sound-as "test.snd" ind :header-type mus-nist :sample-type mus-bdouble))
				    (lambda () (save-sound-as "test.snd" ind :header-type mus-riff :sample-type mus-bshort))
				    (lambda () (save-sound-as "test.snd" ind :header-type mus-voc :sample-type mus-bshort))))
		  (check-error-tag 'env-error (lambda () (filter-sound '(0 0 .1 .1 .05 .1 1 1) 32)))
		  (check-error-tag 'wrong-type-arg (lambda () (save-selection "sel0.snd" :not-a-key 3)))
		  (check-error-tag 'no-data (lambda () (set! (filter-control-envelope ind) ())))
		  (for-each (lambda (arg)
			      (check-error-tag 'no-such-axis arg))
			    (vector (lambda () (axis-info ind 0 1234))
				    (lambda () (position->x 100 ind 0 1234))
				    (lambda () (position->y 100 ind 0 1234))
				    (lambda () (x->position 100 ind 0 1234))
				    (lambda () (y->position 100 ind 0 1234))))
		  (check-error-tag 'no-such-channel (lambda () (axis-info ind 1234)))
		  (check-error-tag 'no-such-channel (lambda () (insert-selection 0 ind 123)))
		  (check-error-tag 'no-such-channel (lambda () (make-player ind 123)))
		  (check-error-tag 'no-such-channel (lambda () (mix "oboe.snd" 0 2)))
		  (check-error-tag 'no-such-channel (lambda () (mix-selection 0 ind 123)))
		  (check-error-tag 'no-such-channel (lambda () (set! (selected-channel ind) 123)))
		  (check-error-tag 'no-such-file (lambda () (insert-samples 0 10 "/baddy/hiho.snd")))
		  (check-error-tag 'no-such-file (lambda () (insert-sound "/baddy/hiho.snd")))
		  (check-error-tag 'no-such-file (lambda () (mix "/baddy/hiho")))
		  (check-error-tag 'no-such-file (lambda () (mix-sound "/baddy/hiho" 0)))
		  (check-error-tag 'no-such-file (lambda () (play "/baddy/hiho")))
		  (check-error-tag 'no-such-graphics-context (lambda () (current-font ind 0 1234)))
		  (check-error-tag 'no-such-graphics-context (lambda () (draw-line 0 0 1 1 ind 0 1234)))
		  (check-error-tag 'no-such-graphics-context (lambda () (foreground-color ind 0 1234)))
		  (check-error-tag 'no-such-graphics-context (lambda () (graph-data (list float-vector-3 float-vector-3) ind 0 1234 0 1 0)))
		  (check-error-tag 'no-such-sample (lambda () (mix-float-vector #r(0.1 0.2 0.3) -1 ind 0 #t)))
		  (check-error-tag 'no-such-sample (lambda () (sample -1)))
		  (check-error-tag 'no-such-sample (lambda () (set! (sample -1) -1)))
		  (check-error-tag 'no-such-sound (lambda () (axis-info 1234)))
		  (check-error-tag 'no-such-sound (lambda () (swap-channels ind 0 12345 0)))
		  (for-each (lambda (arg)
			      (check-error-tag 'out-of-range arg))
			    (vector (lambda () (apply-controls ind 123))
				    (lambda () (draw-axes (car (channel-widgets)) (car (snd-gcs)) "hiho" 0.0 1.0 -1.0 1.0 1234))
				    (lambda () (draw-axes (car (channel-widgets)) (car (snd-gcs)) "hiho" 0.0 1.0 -1.0 1.0 x-axis-in-seconds 1234))
				    (lambda () (filter-sound '(0 0 1 1) 0))
				    (lambda () (filter-sound float-vector-3 32))
				    (lambda () (set! (channels ind) 0))
				    (lambda () (set! (channels ind) 12340))
				    (lambda () (set! (expand-control-bounds) (list 0.0 2.0)))
				    (lambda () (set! (expand-control-bounds) (list 2.0 0.0)))
				    (lambda () (set! (filter-control-envelope ind) (list 0.0 1.0 0.1 -0.1 1.0 0.0)))
				    (lambda () (set! (filter-control-envelope ind) (list 0.0 1.0 0.1 1.1 1.0 0.0)))
				    (lambda () (set! (framples) -10))
				    (lambda () (set! (header-type ind) 123))
				    (lambda () (set! (header-type ind) 12340))
				    (lambda () (set! (min-dB ind 0) 0.0))
				    (lambda () (set! (sample-type ind) 123))
				    (lambda () (set! (sample-type ind) 12340))
				    (lambda () (set! (speed-control-bounds) (list 0.0 2.0)))
				    (lambda () (set! (speed-control-bounds) (list 2.0 0.0)))
				    (lambda () (set! (srate ind) 0))
				    (lambda () (set! *min-dB* 0.0))
				    (lambda () (snd-spectrum (make-float-vector 8) 0 -123))
				    (lambda () (snd-spectrum (make-float-vector 8) 0 0))
				    (lambda () (src-channel (make-env '(0 -1 1 1) :length 11)))
				    (lambda () (src-channel (make-env '(0 0 1 1) :length 11)))
				    (lambda () (src-channel (make-env '(0 1 1 -1) :length 11)))
				    (lambda () (src-channel (make-env '(0 1 1 0) :length 11)))
				    (lambda () (src-sound (make-env '(0 -1 1 1) :length 11)))
				    (lambda () (src-sound (make-env '(0 0 1 1) :length 11)))
				    (lambda () (src-sound (make-env '(0 1 1 -1) :length 11)))
				    (lambda () (src-sound (make-env '(0 1 1 0) :length 11)))
				    (lambda () (start-playing 1 -22))
				    (lambda () (start-playing 1 0))))
		  (for-each (lambda (arg)
			      (check-error-tag 'wrong-type-arg arg))
			    (vector (lambda () (framples ind '(0)))
				    (lambda () (read-only (list ind)))
				    (lambda () (set! (channels ind) -1))
				    (lambda () (set! (data-location ind) -1))
				    (lambda () (set! (data-size ind) -1))
				    (lambda () (smooth-sound 0 -10))))
		  (set! *time-graph-type* graph-once)
		  (check-error-tag 'out-of-range (lambda () (set! (x-bounds) (list .1 -.1))))
		  (check-error-tag 'out-of-range (lambda () (make-region 100 0)))
		  (check-error-tag 'no-such-sample (lambda () (delete-sample -1)))
		  (check-error-tag 'no-such-sample (lambda () (delete-sample (* 2 (framples ind)))))
		  (check-error-tag 'no-such-file (lambda () (play "/bad/baddy.snd")))
		  (check-error-tag 'no-such-sound (lambda () (play 1234 0)))
		  (if (null? (regions)) (make-region 0 100))
		  (check-error-tag 'no-such-channel (lambda () (region-sample (car (regions)) 0 1234)))
		  (check-error-tag 'no-such-channel (lambda () (region-framples (car (regions)) 1234)))
		  (check-error-tag 'no-such-channel (lambda () (region-position (car (regions)) 1234)))
		  (check-error-tag 'cannot-save (lambda () (save-sound-as "/bad/baddy.snd")))
		  (check-error-tag 'no-such-sound (lambda () (transform-sample 0 1 1234)))
		  (check-error-tag 'no-such-channel (lambda () (transform-sample 0 1 ind 1234)))
		  (check-error-tag 'no-such-sound (lambda () (graph #r(0 1) "hi" 0 1 0 1 1234)))
		  (check-error-tag 'no-such-channel (lambda () (graph #r(0 1) "hi" 0 1 0 1 ind 1234)))
		  (set! (selection-member? #t) #f)
		  (check-error-tag 'no-active-selection (lambda () (filter-selection #r(0 0 1 1) 4)))
		  (check-error-tag 'no-active-selection (lambda () (save-selection "/bad/baddy.snd")))
		  (check-error-tag 'no-active-selection (lambda () (env-selection '(0 0 1 1))))
		  (make-region 0 100 ind 0)
		  (check-error-tag 'cannot-save (lambda () (save-selection "/bad/baddy.snd")))
		  (check-error-tag 'cannot-save (lambda () (save-region (car (regions)) "/bad/baddy.snd")))
		  (check-error-tag 'no-such-sound (lambda () (make-region 0 12 1234 #t)))
		  (set! (read-only ind) #t)
		  (check-error-tag 'bad-arity (lambda () (play (selected-sound) 0 :stop (lambda () #f))))
		  (check-error-tag 'cannot-save (lambda () (set! (sound-loop-info ind) '(0 0 1 1))))
		  (check-error-tag 'no-data (lambda () (scale-by ())))
		  (check-error-tag 'no-data (lambda () (scale-to ())))
		  (check-error-tag 'no-such-auto-delete-choice (lambda () (insert-sound "1a.snd" 0 0 ind 0 0 123)))
		  (check-error-tag 'no-such-channel (lambda () (filter-channel '(0 0 1 1) 100 #f #f ind 1)))
		  (check-error-tag 'no-such-channel (lambda () (filter-channel #r(0 0 1 1) 4 #f #f ind 1)))
		  (check-error-tag 'no-such-direction (lambda () (make-sampler 0 ind 0 -2)))
		  (check-error-tag 'no-such-direction (lambda () (make-sampler 0 ind 0 0)))
		  (check-error-tag 'no-such-direction (lambda () (make-sampler 0 ind 0 123)))
		  (for-each (lambda (arg)
			      (check-error-tag 'no-such-edit arg))
			    (vector (lambda () (display-edits ind 0 123))
				    (lambda () (edit-fragment -1))
				    (lambda () (edit-fragment 101 ind 0))
				    (lambda () (edit-tree ind 0 -2))
				    (lambda () (edit-tree ind 0 101))
				    (lambda () (marks ind 0 123))
				    (lambda () (save-sound-as "test.snd" :edit-position 123))))
		  (check-error-tag 'no-such-file (lambda () (convolve-with "/bad/baddy")))
		  (check-error-tag 'no-such-file (lambda () (mix "/bad/baddy")))
		  (check-error-tag 'no-such-sample (lambda () (add-mark (* 2 (framples)))))
		  (check-error-tag 'no-such-sample (lambda () (add-mark -1)))
		  (check-error-tag 'no-such-sample (lambda () (set! (selection-position ind 0) -999)))
		  (check-error-tag 'no-such-sound (lambda () (filter-channel '(0 0 1 1) 100 #f #f 1234 0)))
		  (check-error-tag 'no-such-sound (lambda () (swap-channels ind 0 123)))
		  (for-each (lambda (arg)
			      (check-error-tag 'out-of-range arg))
			    (vector (lambda () (env-sound '(0 0 1 1) 0 #f -1.5))
				    (lambda () (filter-sound #r(0 0 1 1) 0))
				    (lambda () (filter-sound #r(0 0 1 1) 10))
				    (lambda () (set! (graph-style ind 0) -123))
				    (lambda () (set! (graph-style ind 0) 123))
				    (lambda () (set! (reverb-control-length-bounds ind) (list .1 .01)))
				    (lambda () (set! (reverb-control-scale-bounds ind) (list .1 .01)))
				    (lambda () (set! (show-axes ind 0) -123))
				    (lambda () (set! (show-axes ind 0) 123))
				    (lambda () (set! (x-axis-style ind 0) -123))
				    (lambda () (set! (x-axis-style ind 0) 123))
				    (lambda () (xramp-channel 0.0 1.0 -1.6))))
		  (for-each (lambda (arg)
			      (check-error-tag 'wrong-type-arg arg))
			    (vector (lambda () (add-mark 123 '(0)))
				    (lambda () (amp-control '(0)))
				    (lambda () (left-sample '(0)))
				    (lambda () (scale-by #f))
				    (lambda () (set! (samples 0 2) -1))
				    (lambda () (set! (selection-framples ind 0) -999))
				    (lambda () (set! (selection-framples ind 0) 0))
				    (lambda () (sound-loop-info '(0)))
				    (lambda () (src-sound 3.0 1.0 #t))
				    (lambda () (src-sound 3.0 1.0 ind #t))))
		  (close-sound ind))
		)
	      
	      ;; xen.h over-optimization regression check
	      (catch #t 
		(lambda ()
		  (set! (x-zoom-slider -1) 123))
		(lambda args
		  (let ((str (apply format #f (cadr args))))
		    (if (not (string=? str "set! x-zoom-slider: no such sound: -1"))
			(snd-display "x-zoom-slider error: ~S~%" str)))))
	      (catch #t 
		(lambda ()
		  (set! (y-zoom-slider -1) 123))
		(lambda args
		  (let ((str (apply format #f (cadr args))))
		    (if (not (string=? str "set! y-zoom-slider: no such sound: -1"))
			(snd-display "y-zoom-slider error: ~S~%" str)))))
	      (catch #t 
		(lambda ()
		  (set! (beats-per-measure -1) 123))
		(lambda args
		  (let ((str (apply format #f (cadr args))))
		    (if (not (string=? str "set! beats-per-measure: no such sound: -1"))
			(snd-display "beats-per-measure error: ~S~%" str)))))
	      
	      (if (pair? (sounds))
		  (snd-display "sounds after error checks: ~A~%" (map short-file-name (sounds))))
	      
	      (if (provided? 'snd-motif)
		  (for-each
		   (lambda (n name)
		     (let ((tag (catch #t
				  (lambda () (n (list 'Widget 0)))
				  (lambda args (car args)))))
		       (if (not (eq? tag 'no-such-widget))
			   (snd-display "~A of null widget -> ~A" name tag))))
		   (list widget-position widget-size widget-text hide-widget show-widget focus-widget)
		   '(widget-position widget-size widget-text hide-widget show-widget focus-widget)))
	      
	      ;; ---------------- key args
	      (let ((a1 (list 1.5 str-3 (list 0 1) 12 float-vector-3 :wave -1 0 1 #f #t () vector-0 delay-32)))
		(for-each
		 (lambda (arg1)
		   (for-each 
		    (lambda (arg2)
		      (for-each 
		       (lambda (n)
			 (catch #t
			   (lambda () (n arg1 arg2))
			   (lambda args (car args))))
		       make-procs))
		    a1))
		 keyargs))
	      
	      (when (and all-args (= test-errors 0))
		(let ((a1 (list 1.5 str-3 (list 0 1) 12 float-vector-3 :wave -1 0 1 #f #t () vector-0 delay-32))
		      (a2 (list 1.5 str-3 (list 0 1) 12 float-vector-3 :wave -1 0 1 #f #t () vector-0 delay-32)))
		  (for-each
		   (lambda (arg1)
		     (for-each 
		      (lambda (arg2)
			(for-each 
			 (lambda (arg3)
			   (for-each 
			    (lambda (n)
			      (catch #t
				(lambda () (n arg1 arg2 arg3))
				(lambda args (car args))))
			    make-procs))
			 a1))
		      keyargs))
		   a2))
		
		(let ((a1 (list 1.5 str-3 (list 0 1) 12 float-vector-3 :wave -1 0 1 #f #t () vector-0 delay-32))
		      (a2 (list 1.5 str-3 (list 0 1) 12 float-vector-3 :wave -1 0 1 #f #t () vector-0 delay-32)))
		  (for-each
		   (lambda (arg1)
		     (for-each 
		      (lambda (arg2)
			(for-each 
			 (lambda (arg3)
			   (for-each 
			    (lambda (arg4)
			      (for-each 
			       (lambda (n)
				 (catch #t
				   (lambda () (n arg1 arg2 arg3 arg4))
				   (lambda args (car args))))
			       make-procs))
			    keyargs))
			 a1))
		      keyargs))
		   a2)))
	      
	      ;; ---------------- 0 Args
	      (for-each 
	       (lambda (n)
		 (let ((err (catch #t
			      n
			      (lambda args (car args)))))
		   (if (eq? err 'wrong-number-of-args)
		       (snd-display "procs0: ~A ~A" err (documentation n)))))
	       procs0)
	      (dismiss-all-dialogs)
	      (for-each close-sound (sounds))
	      
	      (let* ((main-args (list 1.5 str-3 (list 0 1) 12 float-vector-3 color-95  #i(0 1) 3/4 'mus-error 0+i delay-32
				      (lambda () #t) float-vector-5 :order 0 1 -1 a-hook #f #t #\c 0.0 -1.0 
				      () 3 64 -64 vector-0 '(1 . 2) (expt 2.0 21.5) (expt 2.0 -18.0) car-main cadr-main 
				      (lambda (a) #f) abs
				      1.0+1.0i (cons 1 2) '((1 2) (3 4)) '((1 (2)) (((3) 4)))
				      (vector 1 #\a '(3)) #()
				      (let ((x 3)) (lambda (y) (+ x y))) (lambda args args)
				      "" (make-hash-table 256)
				      #<undefined> #<unspecified> #<eof>
				      (random-state 12) (float-vector) (vector)))
		     (less-args (if all-args 
				    main-args 
				    (list 1.5 str-3 (list 0 1) 12 float-vector-3 color-95 #i(0 1) 3/4 -1.0 (float-vector) (vector) () ""
					  0+i delay-32 :feedback -1 0 1 'hi (lambda (a) (+ a 1)) -64 #f #t vector-0))))
		
		;; ---------------- 1 Arg
		(for-each 
		 (lambda (arg)
		   (for-each 
		    (lambda (n)
		      (catch #t
			(lambda () (n arg))
			(lambda args 
			  (if (eq? (car args) 'wrong-number-of-args)
			      (snd-display "procs1 wna: ~A ~A ~A" arg args (documentation n))))))
		    procs1))
		 main-args)
		(for-each close-sound (sounds))
		
		;; ---------------- 2 Args
		(for-each 
		 (lambda (arg1)
		   (for-each 
		    (lambda (arg2)
		      (for-each 
		       (lambda (n)
			 (catch #t
			   (lambda () (n arg1 arg2))
			   (lambda args 
			     (if (eq? (car args) 'wrong-number-of-args)
				 (snd-display "procs2: ~A ~A ~A ~A" arg1 arg2 args (documentation n))))))
		       procs2))
		    main-args))
		 main-args)
		(for-each close-sound (sounds))
		
		;; ---------------- set! no Args
		(for-each 
		 (lambda (arg)
		   (for-each 
		    (lambda (n)
		      (catch #t
			(lambda () (set! (n) arg))
			(lambda args 
			  (if (eq? (car args) 'wrong-number-of-args)
			      (snd-display "set-procs0: ~A" (documentation n))))))
		    set-procs0))
		 main-args)
		(for-each close-sound (sounds))
		
		;; ---------------- set! 1 Arg
		(for-each 
		 (lambda (arg1)
		   (for-each 
		    (lambda (arg2)
		      (for-each 
		       (lambda (n)
			 (catch #t
			   (lambda () (set! (n arg1) arg2))
			   (lambda args 
			     (if (eq? (car args) 'wrong-number-of-args)
				 (snd-display "set-procs1: ~A" (documentation n))))))
		       set-procs1))
		    main-args))
		 main-args)
		(for-each close-sound (sounds))
		
		;; ---------------- set! 2 Args
		(for-each 
		 (lambda (arg1)
		   (for-each close-sound (sounds))
		   (for-each 
		    (lambda (arg2)
		      (for-each 
		       (lambda (arg3)
			 (for-each 
			  (lambda (n)
			    (catch #t
			      (lambda () (set! (n arg1 arg2) arg3))
			      (lambda args 
				(if (eq? (car args) 'wrong-number-of-args)
				    (snd-display "set-procs2: ~A" (documentation n))))))
			  set-procs2))
		       less-args))
		    less-args))
		 less-args)
		
		(set! delay-32 #f)
		(set! color-95 #f)
		(set! vector-0 #f)
		(set! float-vector-3 #f)
		(set! *clm-srate* 22050)
		(set! *print-length* 12)
		(set! *mus-array-print-length* 12)
		(set! (sound-file-extensions) exts)
		(set! car-main #f)
		(set! cadr-main #f)
		(set! a-hook #f)
		(set! float-vector-5 #f)
		))))))))


;;; ---------------- test 24: s7 ----------------

(define s7test-exits #f)
(define (snd_test_24)
  (load "s7test.scm"))

(define test-funcs (make-vector (+ 1 total-tests)))
(set! (test-funcs 0) snd_test_0)
(set! (test-funcs 1) snd_test_1)
(set! (test-funcs 2) snd_test_2)
(set! (test-funcs 3) snd_test_3)
(set! (test-funcs 4) snd_test_4)
(set! (test-funcs 5) snd_test_5)
(set! (test-funcs 6) snd_test_6)
(set! (test-funcs 7) snd_test_7)
(set! (test-funcs 8) snd_test_8)
(set! (test-funcs 9) snd_test_9)
(set! (test-funcs 10) snd_test_10)
(set! (test-funcs 11) snd_test_11)
(set! (test-funcs 12) snd_test_12)
(if (not (or (provided? 'openbsd)
	     (provided? 'freebsd)
	     ;(provided? 'snd-gtk)
	     ))
    (begin
      (set! (test-funcs 13) snd_test_13)
      (set! (test-funcs 14) snd_test_14)
      (set! (test-funcs 15) snd_test_15))
    (begin
      (set! (test-funcs 13) (lambda () #f))
      (set! (test-funcs 14) (lambda () #f))
      (set! (test-funcs 15) (lambda () #f))))
(set! (test-funcs 16) snd_test_16)
(set! (test-funcs 17) snd_test_17)
(set! (test-funcs 18) snd_test_18)
(set! (test-funcs 19) snd_test_19)
(set! (test-funcs 20) snd_test_20)
(set! (test-funcs 21) snd_test_21)
(set! (test-funcs 22) snd_test_22)
(set! (test-funcs 23) snd_test_23)
(set! (test-funcs 24) snd_test_24)


(define all-hooks
  (list after-graph-hook after-lisp-graph-hook lisp-graph-hook before-transform-hook mix-release-hook save-hook mus-error-hook
	mouse-enter-graph-hook mouse-leave-graph-hook open-raw-sound-hook select-channel-hook after-open-hook close-hook drop-hook update-hook
	mark-click-hook mark-drag-hook name-click-hook open-hook help-hook before-save-state-hook
	output-comment-hook play-hook snd-error-hook snd-warning-hook start-playing-hook stop-playing-hook
	mouse-enter-listener-hook mouse-leave-listener-hook select-sound-hook
	exit-hook during-open-hook after-transform-hook mouse-enter-label-hook mouse-leave-label-hook initial-graph-hook
	graph-hook key-press-hook mouse-drag-hook mouse-press-hook enved-hook mouse-click-hook new-widget-hook
	mark-hook stop-playing-selection-hook after-apply-controls-hook draw-mark-hook
	bad-header-hook save-state-hook new-sound-hook color-hook orientation-hook listener-click-hook mix-click-hook after-save-state-hook
	mouse-enter-text-hook mouse-leave-text-hook mix-drag-hook 
	start-playing-selection-hook after-save-as-hook before-save-as-hook draw-mix-hook
	before-exit-hook before-close-hook clip-hook))

(define hook-names
  (list 'after-graph-hook 'after-lisp-graph-hook 'lisp-graph-hook 'before-transform-hook 'mix-release-hook 'save-hook 'mus-error-hook
	'mouse-enter-graph-hook 'mouse-leave-graph-hook 'open-raw-sound-hook 'select-channel-hook 'after-open-hook 'close-hook 'drop-hook 'update-hook
	'mark-click-hook 'mark-drag-hook 'name-click-hook 'open-hook 'help-hook 'before-save-state-hook
	'output-comment-hook 'play-hook 'snd-error-hook 'snd-warning-hook 'start-playing-hook 'stop-playing-hook
	'mouse-enter-listener-hook 'mouse-leave-listener-hook 'select-sound-hook
	'exit-hook 'during-open-hook 'after-transform-hook 'mouse-enter-label-hook 'mouse-leave-label-hook 'initial-graph-hook
	'graph-hook 'key-press-hook 'mouse-drag-hook 'mouse-press-hook 'enved-hook 'mouse-click-hook 'new-widget-hook
	'mark-hook 'stop-playing-selection-hook 'after-apply-controls-hook 'draw-mark-hook
	'bad-header-hook 'save-state-hook 'new-sound-hook 'color-hook 'orientation-hook 'listener-click-hook 'mix-click-hook 'after-save-state-hook
	'mouse-enter-text-hook 'mouse-leave-text-hook 'mix-drag-hook 
	'start-playing-selection-hook 'after-save-as-hook 'before-save-as-hook 'draw-mix-hook
	'before-exit-hook 'before-close-hook 'clip-hook))

(define hook-calls (make-vector (length all-hooks) 0))

(define (set-all-hooks)
  (for-each
   (let ((ctr 0))
     (lambda (h)
       (set! (hook-functions h)
	     (list
	      (let ((local-ctr ctr))
		(lambda (hook)
		  (set! (hook-calls local-ctr) (+ (hook-calls local-ctr) 1))))))
       (set! ctr (+ ctr 1))))
   all-hooks))

(define (report-hook-calls)
  (do ((not-called ())
       (i 0 (+ i 1)))
      ((= i (length all-hooks))
       (if (pair? not-called)
	   (format *stderr* "not called: ~{~A~^, ~}~%" not-called)))
    (if (positive? (hook-calls i))
	(format *stderr* "~A: ~D~%" (hook-names i) (hook-calls i))
	(set! not-called (cons (hook-names i) not-called)))))


(cond ((> test-at-random 0)             ; run tests in any random order
       (do ((i 0 (+ i 1)))
	   ((= i test-at-random))
	 (set! snd-test (random 23))
	 (format *stderr* "~%~A: ~A~%" i snd-test)
	 (before-test-hook snd-test)
	 (if hooked (set-all-hooks))
	 ((vector-ref test-funcs snd-test))
	 (after-test-hook snd-test)))

      ((not (or full-test 
		keep-going
		(< snd-test 0)))
       (before-test-hook snd-test)
       (if hooked (set-all-hooks))
       ((vector-ref test-funcs snd-test))
       (after-test-hook snd-test))

      (else
       (do ((i 0 (+ i 1)))
	   ((> i total-tests))
	 (when (or full-test
		   (and keep-going (<= snd-test i)))
	   (before-test-hook i)
	   (if hooked (set-all-hooks))
	   ((vector-ref test-funcs i))
	   (after-test-hook i)))))


;;; currently not called:
;;;    before-exit-hook, mix-drag-hook, mouse-leave-text-hook, mouse-enter-text-hook, mix-click-hook, listener-click-hook, 
;;;    stop-playing-selection-hook, mouse-click-hook, enved-hook, mouse-press-hook, mouse-drag-hook, key-press-hook, 
;;;    mouse-leave-label-hook, mouse-enter-label-hook, exit-hook, mouse-leave-listener-hook, mouse-enter-listener-hook, 
;;;    snd-error-hook, name-click-hook, mark-drag-hook, mark-click-hook, drop-hook, mouse-leave-graph-hook, 
;;;    mouse-enter-graph-hook, mix-release-hook


;;; ---------------- test all done

(for-each forget-region (regions))
(if with-motif (set! (view-files-sort) 0))

(stop-playing)
(mus-oss-set-buffers 4 12)

(reset-all-hooks)
(set! *ask-about-unsaved-edits* #f)
(set! *remember-sound-state* #f)

;(save-listener "test.output")
(set! *listener-prompt* original-prompt)
(set! *stdin-prompt* "")
(clear-listener)
(set! (show-listener) #t)

(format () "~%;all done!~%~A" original-prompt)

(set! *print-length* 64)
(format *stderr* "~%;times: ~A~%;total: ~A~%" timings (round (- (real-time) overall-start-time)))

(if hooked (report-hook-calls))


;; #(59 58 114 95 2244 5373 613 134 11680 2892 609 743 868 976 815 1288 3020 197 168 2952 758 1925 4997 6567 846  183 0 242 6696 0))) ; 571
;; 
;; fatty4
;; 19-Dec-12: #(1 1 2 2 69 240 6 1 583 1 23 1 1 17 70 1 233 1 1 271 89 119 1 1877 0 0 0 1 1 73)  ;  37
;; 1-Jan-13:  #(1 1 2 2 64 200 7 1 575 1 17 1 2 12 84 1 246 1 1 215 45 111 1 1552 0 0 0 1 2 77)  ;  32
;; 11-Feb-13: #(1 1 3 2 49 170 5 1 463 1 15 1 1 11 46 1 216 1 2 158 42 110 1 1456 0 0 0 1 1 80)  ;  28
;; 1-Mar-13:  #(1 1 3 1 40 117 5 1 439 1 16 1 2 11 20 1 109 1 2 159 43 100 1 1263 0 0 0 1 2 78)  ;  24
;; 3-Apr-13:  #(1 1 2 2 30  89 4 1 297 1 11 1 2 10  9 1  81 1 1 110 41  73 1 1048 0 0 0 1 2 80)  ;  19
;; 24-Feb-14: #(1 1 2 1 22  74 2 1 162 2  9 1 3  8  9 2  54 2    70 33  24 2  791     0 0 1 82)  ;  14
;; 15-Mar-14: #(1 2 3 2 25  71 3 2 129 1  8 1 2  8 14 2  45 2    74 32  25 1  781     0 0 2 81)  ;  13
;; 1-Oct-14:  #(1 2 2 2 22  68 2 2 114 2  9 1 3  8 50 1  45 2    70 32  26 2  749     0 0 2 113) ;  13
;; 9-Mar-15:  #(1 1 3 2 86  69 3 3 131 1  8 2 2  8  8 3  43 2    71 30  33 2  697     0 0 3 130) ;  13
;; 29-May-15: #(2 3 3 3 22  79 3 3 130 3  8 3 4  9  9 3  49 3    75 30  28 3  708     0 0 3 144) ;  13
;; fatty10
;; 30-Jan-17: #(0 0 1 0  6  45 1 1 101 1  4 1 1  3  4 1  29 1    48 12   9 3  389     0 0 1 181) ;   8
;; 6-Aug-18:  #(1 1 1 1  7  52 1 1  95 1  5 1 2  4  6 1  29 1    43 15  15 3  367         1 168) ;   8

;;; -------- cleanup temp files

(if (provided? 'snd-nogui)
    (set! *max-regions* 0))

(if (file-exists? "saved-snd.scm") (delete-file "saved-snd.scm"))
(if (file-exists? original-save-dir)
    (system (format #f "rm -f ~A/snd_*" original-save-dir)))

(if (file-exists? original-temp-dir)
    (system (format #f "rm -f ~A/snd_*" original-temp-dir)))

(when (file-exists? "/tmp")
  (system "rm -f /tmp/snd_*")
  (system "rm -f /tmp/file*.snd"))

(when (file-exists? "/var/tmp")
  (system "rm -f /var/tmp/snd_*")
  (system "rm -f /var/tmp/file*.snd"))

(if (defined? 'dlocsig-speaker-configs) (set! dlocsig-speaker-configs #f))

(for-each
 (lambda (f)
   (if (file-exists? f)
       (delete-file f)))
 (list 
  "aaa.eps"
  "envs.save"
  "fmv.snd"
  "fmv.wav"
  "fmv0.snd"
  "fmv1.snd"
  "fmv2.snd"
  "fmv3.snd"
  "fmv4.reverb"
  "fmv4.snd"
  "hiho.marks"
  "hiho.snd"
  "hiho.snd"
  "hiho.tmp"
  "hiho.wave"
  "ho"
  "new.snd"
  "oboe.marks"
  "obtest.snd.stereo"
  "snd.eps"
  "test-1.snd"
  "test-2.snd"
  "test-macros.scm"
  "test.aiff"
  "testx.data"
  "test.output"
  "test.rev"
  "test.reverb"
  "test.snd"
  "test.snd.snd"
  "test.wav"
  "test.xpm"
  "test2.snd"
  "test3.snd"
  "tmp.snd"
  "with-mix.snd"
  "1"
  "gtk-errors"
  "accelmap"
  ".snd-remember-sound"
  "test.clm"
  "hiho.scm"
  
  (string-append sf-dir "mus10.snd.snd")
  (string-append sf-dir "ieee-text-16.snd.snd")
  (string-append sf-dir "trumps22.adp.snd")
  (string-append sf-dir "oki.wav.snd")
  (string-append sf-dir "nasahal.avi.snd")
  (string-append sf-dir "hcom-16.snd.snd")
  (string-append sf-dir "ce-c3.w02.snd")
;  (string-append sf-dir "oboe.g723_24.snd")
;  (string-append sf-dir "oboe.g723_40.snd")
;  (string-append sf-dir "oboe.g721.snd")
  (string-append sf-dir "wood.sds.snd")
  (string-append sf-dir "o2_dvi.wave.snd")
  (string-append sf-dir "nist-shortpack.wav.snd")
  (string-append sf-dir "bad_data_format.snd.snd")
  ))

(if (file-exists? "/home/bil/peaks")
    (system "rm /home/bil/peaks/*"))

(for-each close-sound (sounds))
(mus-sound-prune)
(if (and with-motif (dialog-widgets))
    (let ((vfs ((dialog-widgets) 5))) ; view-files (possible list)
      (if vfs
	  (if (symbol? (car vfs))
	      (set! (view-files-files vfs) ())
	      (for-each
	       (lambda (d)
		 (set! (view-files-files d) ()))
	       vfs)))))


#|
(let ((st (symbol-table)))
  (for-each 
      (lambda (sym)
	(if (defined? sym)
	    (let ((val (symbol->value sym)))
	      (if (and (procedure? val)
		       (string=? "" (documentation val)))
		  (snd-display "~A " sym)))))
   st))
|#

(gc) (gc)

(if with-exit (#_exit))
