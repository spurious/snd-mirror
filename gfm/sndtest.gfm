#! /usr/bin/env gforth
\ sndtest.gfm -- sndlib test -*- forth -*-

\ Copyright (C) 2003--2005 Michael Scholz

\ Author: Michael Scholz <scholz-micha@gmx.de>
\ Created: Wed Aug 27 17:20:45 CEST 2003
\ Last: Thu Jan 13 23:01:37 CET 2005
\ Ident: $Id: sndtest.gfm,v 1.150 2005/01/13 22:01:41 mike Exp $

\ This file is part of GFM Gforth Music.

\ This program is free software; you can redistribute it and/or
\ modify it under the terms of the GNU General Public License as
\ published by the Free Software Foundation; either version 2 of
\ the License, or (at your option) any later version.

\ This program is distributed in the hope that it will be
\ useful, but WITHOUT ANY WARRANTY; without even the implied
\ warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
\ PURPOSE.  See the GNU General Public License for more details.

\ You should have received a copy of the GNU General Public
\ License along with this program; if not, write to the Free
\ Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
\ MA 02111-1307 USA

\ Commentary:

\ Some tests need one or more of the following sound files, their
\ contents isn't important:
\ 
\ fyow.snd
\ oboe.snd
\ pistol.snd

\ Code:

\ 0 assert-level !

require utils.fs

: (sndtest-help) ( -- )
    ." Usage: " argv @ 1 cells + @ $c>string file-basename .string ."  [ options ]" cr
    ."	   -c, --csndlib	       use csndlib.fs (default)" cr
    ."	   -f, --fsndlib	       use fsndlib.fs" cr
    ."	   -d, --dac		       write to dac" cr
    cr
    ."	   -p, --play FILENAME	       play FILENAME" cr
    ."	   -a, --test-all	       start test-all (TEST-INPUT and TEST-CLM-INS)" cr
    cr
    ."	   -V, --version	       display version information and exit" cr
    ."	   -h, --help		       display this help message and exit" cr
    ." If no option was given TEST-CLM-INS will be started." cr
;
' (sndtest-help) is str-help

script? [unless] cr [then]
require gfm.fs
.sndversion

*clm-use-csndlib* [if]
    *clm-search-list* $" cforth.snd" $+ to *clm-file-name*
    *clm-search-list* $" cforth.reverb" $+ to *clm-reverb-file-name*
[else]
    *clm-search-list* $" fforth.snd" $+ to *clm-file-name*
    *clm-search-list* $" fforth.reverb" $+ to *clm-reverb-file-name*
[then]

\ === SRC ===
\ It is possible to set the input callback between the run loop like
\ in SRC-SIMP-2, but this works only if the callback is a variable and
\ not a create/does construct.  The latter overflows the dictionary.
\ A better solution is to provide it at initialization time to
\ MAKE-SRC/CONVOLVE/GRANULATE/PHASE-VOCODER like SRC-SIMP-1 if
\ possible.
instrument: src-simp-1 { f: start f: dur f: amp f: srt srt-env fname -- }
    :file fname make-readin { rd }
    :input rd :srate srt make-src { sr }
    :envelope srt-env :duration dur make-env { en }
    90e random :locsig-degree
    start dur run-instrument
	\ src(sr, env(en)) * amp
	en env sr src amp f*
    end-run
    rd mus-close
    sr mus-free
    en mus-free
;instrument

instrument: src-simp-2 { f: start f: dur f: amp f: srt f: fm-amp f: fmfreq fname -- }
    :srate srt          make-src { sr }
    :file fname      make-readin { rd }
    :frequency fmfreq make-oscil { os }
    rd            make-readin-cb { cb }
    90e random :locsig-degree
    start dur run-instrument
	\ src(sr, :input, lambda do |dir| readin(rd) end, fm_amp * oscil(os)) * amp	
	fm-amp 0e 0e os oscil f*  :input cb sr src  amp f*
    end-run
    rd mus-close
    sr mus-free
    os mus-free
;instrument

instrument: hello-dentist { f: start f: dur f: freq f: amp fname -- }
    :frequency freq :amplitude amp make-rand-interp { rn }
    :file fname       make-readin { rd }
    :input rd :width 5   make-src { sr }
    90e random :locsig-degree
    start dur run-instrument
	\ src(sr, rand_interp(rn))
	0e rn rand-interp sr src
    end-run
    rd mus-close
    rn mus-free
    sr mus-free
;instrument

\ === CONVOLVE ===
instrument: conv-array { f: start f: dur filt fname f: amp -- }
    :file fname            make-readin { rd }
    :input rd :filter filt make-convolve { cv }
    90e random :locsig-degree
    start dur run-instrument
	\ convolve(cv) * amp
	cv convolve  amp f*
    end-run
    rd mus-close
    cv mus-free
;instrument

instrument: conv-file { f: start f: dur filt fname f: amp -- }
    :file fname make-readin { rd }
    filt 0 0 filt sound-frames file>array { data }
    :input rd make-readin-cb :filter data make-convolve { cv }
    90e random :locsig-degree
    start dur run-instrument
	\ convolve(cv) * amp
	cv convolve  amp f*
    end-run
    rd mus-close
    cv mus-free
    data free-vct
;instrument

\ === GRANULATE ===
instrument: gran-snd { f: start f: dur f: orig-beg fname -- }
    fname sound-srate s>f orig-beg f* fround f>s { fstart } 
    :file fname :start fstart make-readin    { rd }
    :input rd                 make-granulate { gr }
    90e random :locsig-degree
    start dur run-instrument
	\ granulate(gr) * 4.0
	gr granulate  4e f*
    end-run
    rd mus-free
    gr mus-free
;instrument

instrument: grev { f: start f: dur f: exp-amt fname f: fstart -- }
    fstart seconds>samples { fbeg }
    :file fname :start fbeg :direction start fstart f< if -1 else 1 then make-readin { rd }
    :expansion exp-amt make-granulate { gr }
    rd make-readin-cb { cb }
    90e random :locsig-degree
    start dur run-instrument
	\ granulate(gr, :input, lambda do |dir| readin(rd) end) * 2.0
	:input cb gr granulate 2e f*
    end-run
    rd mus-free
    gr mus-free
;instrument

\ === PHASE VOCODER ===
\ no analyze, edit and synthesize functions
instrument: phase-simp-1 { f: start f: dur f: amp f: pitch fname -- }
    :file fname  make-readin { rd }
    :input rd  :pitch pitch  make-phase-vocoder { pv }
    90e random :locsig-degree
    start dur run-instrument
	\ phase_vocoder(pv) * amp
	pv phase-vocoder amp f*
    end-run
    rd mus-close
    pv mus-free
;instrument


\ === Phase-Vocoder, analyze, edit and synthesize callbacks ===
: pv-cb-filptr  ( self -- addr ) ;
: pv-cb-in-data ( self -- addr ) cell+ ;
: pv-cb-win     ( self -- addr ) 2 cells + ;
: pv-cb-first   ( self -- addr ) 3 cells + ;

: pv-analyze-cb { fftsize -- xt; input gen self -- f }
    mus-hamming-window fftsize 0e make-fft-window { win }
    2e 0.54e fftsize s>f f* f/ win vct-scale!
    fftsize make-vct { in-vct }
    lambda-create 0 , in-vct , win , true , latestxt
  does> { input gen self -- f }
    self pv-cb-filptr  @ { filptr }
    self pv-cb-in-data @ { in-data }
    self pv-cb-win     @ { pv-win }
    self pv-cb-first   @ { pv-first }
    gen hop@    { D }
    gen length@ { N }
    gen pv-freqs>vct vct-clear
    0 gen pv-outctr!
    pv-first if
	in-data map 1 input execute end-map drop
	false self pv-cb-first !
    else
	N D do i in-data vct@ i D - in-data vct! loop
	N N D - do 1 input execute i in-data vct! loop
    then
    filptr N mod
    pv-win each
	i in-data vct@ f* dup gen pv-amp-increments!
	1+ dup N >= if drop 0 then
    end-each
    drop
    D self pv-cb-filptr +!
    gen pv-amp-increments>vct gen pv-freqs>vct N 1 fft
    gen pv-amp-increments>vct gen pv-freqs>vct N 2/ rectangular>polar
    false
;
: pv-edit-cb ( lastphase-vct -- xt; gen self -- f )
    lambda-create , latestxt
  does> { gen self --  f }
    self @  { lastphase }
    gen hop@ s>f 1/f          { f: pscl }
    two-pi gen length@ s>f f/ { f: kscl }
    0e ( ks )
    lastphase each
	i gen pv-freqs@ fswap f- ( phasediff )
	i gen pv-freqs@ i lastphase vct!
	begin fdup pi f> while two-pi f- repeat
	begin fdup pi fnegate f< while two-pi f+ repeat
	pscl f* fover f+ gen frequency@ f* i gen pv-freqs!
	kscl f+
    end-each
    fdrop false
;
: pv-synthesis-cb ( -- xt; gen self -- r )
    lambda-create latestxt
  does> { gen self --  r }
    gen pv-amps>vct each
	fdrop
	i gen pv-amps@             i gen pv-amp-increments@   f+ i gen pv-amps!    
	i gen pv-phase-increments@ i gen pv-freqs@            f+ i gen pv-phase-increments!
	i gen pv-phases@           i gen pv-phase-increments@ f+ i gen pv-phases!  
    end-each
    gen pv-amps>vct gen pv-phases>vct sine-bank
;

instrument: phase-simp-2 { f: start f: dur f: amp f: pitch fname -- }
    256 make-vct { last-phases }
    :file fname make-readin { rd }
    :input      rd      make-readin-cb
    :analyze    512      pv-analyze-cb
    :edit       last-phases pv-edit-cb
    :synthesize        pv-synthesis-cb
    :pitch pitch make-phase-vocoder { pv }
    90e random :locsig-degree
    start dur run-instrument
	\ phase_vocoder(pv) * amp
	pv phase-vocoder amp f*
    end-run
    pv mus-free
    rd mus-free
    last-phases free-vct
;instrument

instrument: phase-simp-3 { f: start f: dur f: amp f: pitch fname -- }
    256 make-vct { last-phases }
    :file fname make-readin { rd }
    rd make-readin-cb       { in-cb }
    512 pv-analyze-cb       { ana-cb }
    last-phases pv-edit-cb  { ed-cb }
    pv-synthesis-cb         { syn-cb }
    :pitch pitch make-phase-vocoder { pv }
    90e random :locsig-degree
    start dur run-instrument
	\ phase_vocoder(pv, :input in_cb, :analyze, ana_cb, :edit, ed_cb, :synthesize, syn_cb) * amp
	:input in-cb :analyze ana-cb :edit ed-cb :synthesize syn-cb pv phase-vocoder amp f*
    end-run
    pv mus-free
    rd mus-free
    last-phases free-vct
;instrument

\ buffer
instrument: buf-simp { f: start f: dur -- }
    :size 128 :time 128 make-buffer { bf }
    128 0 do i s>f 0.001e f* i bf data! loop
    90e random :locsig-degree
    start dur run-instrument
	bf ?buffer-empty if
	    128 0 do i s>f 0.001e f* i bf data! loop
	    128e bf increment!
	then
	bf buffer>sample 4e f*
    end-run
    bf gen-free
;instrument

\ snd-7/clm.html
instrument: move-osc { f: start f: dur -- }
    0.3e { f: amp }
    make-oscil { os }
    :envelope vct[ 0e 0e 1e 90e ] :scaler amp :duration dur make-env { en }
    90e random :locsig-degree
    start dur run-instrument
	0e 0e os oscil  amp  f*
	en env 1e *locsig* move-locsig
    end-run
    os mus-free
    en mus-free
;instrument

event: test-input
    2e 2.2e { f: dur f: forward }
    \ SRC
    now@ 1.5e 0.5e 0.2e vct[ 0e 0e 50e 1e 100e 0e ] $" fyow.snd" src-simp-1 1.7e wait 
    now@ 1e 0.5e 1e 0.3e 20e $" fyow.snd" src-simp-2 1.2e wait
    now@ 2e 0.5e 0.01e 1e 10e $" fyow.snd" src-simp-2 forward wait
    now@ 1e 40e 0.5e $" oboe.snd" hello-dentist 1.2e wait
    \ CONVOLVE
    now@ 1e vct[ 0.5e 0.2e 0.1e 0.05e 0e 0e 0e 0e ] $" fyow.snd" 0.5e conv-array 1.2e wait
    now@ 1.2e $" fyow.snd" $" oboe.snd" 0.3e conv-file 1.4e wait
    now@ 1e $" pistol.snd" $" fyow.snd" 0.1e conv-file 1.2e wait
    \ GRANULATE
    now@ 2e 0e $" pistol.snd" gran-snd forward wait
    now@ 2e 2e $" oboe.snd" 1e grev forward wait
    \ PHASE-VOCODER
    now@ 0.8e 0.5e 0.5e $" fyow.snd" phase-simp-1 1e wait
    now@ 0.8e 0.5e 0.8e $" fyow.snd" phase-simp-2 1e wait
    now@ 0.8e 0.5e 1.4e $" fyow.snd" phase-simp-3 1e wait
;event

event: test-clm-ins ( -- )
    0.2e 2e { f: forward f: dur }
    \ dlocsig.fs
    :beg now@ :dur dur dlocsig-test      forward wait
    \ additions
    now@ dur           buf-simp          dur forward f+ wait
    now@ dur           move-osc          dur forward f+ wait
    :beg now@ :dur dur fm-violin-test    forward wait
    :beg now@ :dur dur formant-test      forward wait
    :beg now@ :dur dur fm-noise-test     forward wait
    :beg now@ :dur dur polter-test       forward wait
    \ clm-ins.rb
    :beg now@ :dur dur pluck-test        forward wait
    :beg now@ :dur dur vox-test          forward wait
    :beg now@ :dur dur fofins-test       forward wait
    :beg now@ :dur dur bess-test         forward wait
    :beg now@ :dur dur fm-trumpet-test   forward wait
    :beg now@ :dur dur pqw-vox-test      forward wait
    :beg now@ :dur dur flute-test        forward wait
    :beg now@ :dur dur fm-bell-test      forward wait
    :beg now@ :dur dur fm-insect-test    forward wait
    :beg now@ :dur dur fm-drum-test      forward wait
    :beg now@ :dur dur gong-test         forward wait
    :beg now@ :dur dur attract-test      forward wait
    :beg now@ :dur dur pqw-test          forward wait
    :beg now@ :dur dur tubebell-test     forward wait
    :beg now@ :dur dur wurley-test       forward wait
    :beg now@ :dur dur rhodey-test       forward wait
    :beg now@ :dur dur hammondoid-test   forward wait
    :beg now@ :dur dur metal-test        forward wait
    :beg now@ :dur dur drone/canter-test forward wait
    :beg now@ :dur dur reson-test        forward wait
    :beg now@ :dur dur cellon-test       forward wait
    :beg now@ :dur dur gran-synth-test   forward wait
    :beg now@ :dur dur touch-tone-test   forward wait
    :beg now@ :dur dur spectra-test      forward wait
    :beg now@ :dur dur two-tab-test      forward wait
    :beg now@ :dur dur lbj-piano-test    forward wait
    :beg now@ :dur dur resflt-test       forward wait
    :beg now@ :dur dur scratch-test      forward wait
    :beg now@ :dur dur pins-test         forward wait
    :beg now@ :dur dur zc-test           forward wait
    :beg now@ :dur dur zn-test           forward wait
    :beg now@ :dur dur za-test           forward wait
    :beg now@ :dur dur exp-snd-test      forward wait
    :beg now@ :dur dur expfil-test       forward wait
    :beg now@ :dur dur graph-eq-test     forward wait
    :beg now@ :dur dur anoi-test         forward wait
    :beg now@ :dur dur fullmix-test      forward wait
;event

event: test-all ( -- )
    ['] test-input   :play false :statistics false :channels 2 with-sound
    ['] test-clm-ins :continue-old-file true :play true :channels 2 with-sound
;event

\ The notehook function gets the instrument name (of type String) for
\ use with .$ or .STRING or what else.
lambda: ( str -- ) !script-cr ." \ <" .$ ." >" script-cr ; to *clm-notehook*

: finish ( -- ) f.s .s cr bye ;

: main ( -- )
    array[ $" -p" $" --play" ]     opt-string getopts if play-sound finish then
    array[ $" -a" $" --test-all" ] opt-bool   getopts if test-all finish then
    ['] test-clm-ins
    :play true
    :channels 2
    :reverb-channels 1
    :reverb ['] jl-reverb
    with-sound finish
;

0 [if]
    4 to *clm-channels*
    22050 to *clm-srate*
    *clm-search-list* $" cd-rec.snd" $+ mus-audio-dac-out 5e record-sound
    *clm-search-list* $" cd-rec.snd" $+ play-sound
    finish
[then]

script? [if] main finish [then]

\ sndtest.gfm ends here
